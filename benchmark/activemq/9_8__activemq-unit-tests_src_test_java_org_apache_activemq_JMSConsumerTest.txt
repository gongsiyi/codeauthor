1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:c7d559f:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:c7d559f:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
17:d29ca2a: 
1:9a60743: import java.lang.Thread.UncaughtExceptionHandler;
1:444412f: import java.util.Collections;
1:9a60743: import java.util.HashMap;
1:41a1007: import java.util.List;
1:9a60743: import java.util.Map;
1:230a86c: import java.util.concurrent.CountDownLatch;
1:9a60743: import java.util.concurrent.ExecutorService;
1:9a60743: import java.util.concurrent.Executors;
1:230a86c: import java.util.concurrent.TimeUnit;
1:230a86c: import java.util.concurrent.atomic.AtomicInteger;
1:230a86c: 
1:d29ca2a: import javax.jms.BytesMessage;
1:35f3010: import javax.jms.IllegalStateException;
1:e91f5c8: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.DeliveryMode;
1:d29ca2a: import javax.jms.Message;
1:d29ca2a: import javax.jms.MessageConsumer;
1:d29ca2a: import javax.jms.MessageListener;
1:d29ca2a: import javax.jms.MessageProducer;
1:d29ca2a: import javax.jms.Session;
1:d29ca2a: import javax.jms.TextMessage;
1:d29ca2a: import javax.jms.Topic;
1:b997d25: import javax.management.ObjectName;
1:c7d559f: 
1:d29ca2a: import junit.framework.Test;
1:c7d559f: 
1:b997d25: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1:41a1007: import org.apache.activemq.broker.region.QueueSubscription;
1:41a1007: import org.apache.activemq.broker.region.Subscription;
1:41a1007: import org.apache.activemq.broker.region.TopicSubscription;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:98f3545: import org.apache.activemq.command.ActiveMQQueue;
1:578eaca: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:230a86c: 
1:41a1007: import static org.apache.activemq.TestSupport.getDestinationConsumers;
1:41a1007: 
1:d29ca2a: /**
1:d29ca2a:  * Test cases used to test the JMS message consumer.
1:d29ca2a:  */
1:d29ca2a: public class JMSConsumerTest extends JmsTestSupport {
1:ecf89a6: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JMSConsumerTest.class);
1:230a86c: 
1:ecf89a6:     public ActiveMQDestination destination;
1:ecf89a6:     public int deliveryMode;
1:ecf89a6:     public int prefetch;
1:ecf89a6:     public int ackMode;
1:ecf89a6:     public byte destinationType;
1:ecf89a6:     public boolean durableConsumer;
1:230a86c: 
1:d29ca2a:     public static Test suite() {
1:d29ca2a:         return suite(JMSConsumerTest.class);
1:d29ca2a:     }
1:1ec71bd: 
1:d29ca2a:     public static void main(String[] args) {
1:d29ca2a:         junit.textui.TestRunner.run(suite());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestMessageListenerWithConsumerCanBeStopped() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testMessageListenerWithConsumerCanBeStopped() throws Exception {
1:d29ca2a: 
1:d29ca2a:         final AtomicInteger counter = new AtomicInteger(0);
1:d29ca2a:         final CountDownLatch done1 = new CountDownLatch(1);
1:d29ca2a:         final CountDownLatch done2 = new CountDownLatch(1);
1:230a86c: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:230a86c:         ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)session.createConsumer(destination);
1:d29ca2a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:d29ca2a:             public void onMessage(Message m) {
1:d29ca2a:                 counter.incrementAndGet();
1:fc00993:                 if (counter.get() == 1) {
1:d29ca2a:                     done1.countDown();
1:fc00993:                 }
1:fc00993:                 if (counter.get() == 2) {
1:d29ca2a:                     done2.countDown();
1:fc00993:                 }
1:d29ca2a:             }
1:d29ca2a:         });
1:d29ca2a: 
1:230a86c:         // Send a first message to make sure that the consumer dispatcher is
1:230a86c:         // running
1:d29ca2a:         sendMessages(session, destination, 1);
1:d29ca2a:         assertTrue(done1.await(1, TimeUnit.SECONDS));
1:d29ca2a:         assertEquals(1, counter.get());
1:230a86c: 
1:d29ca2a:         // Stop the consumer.
1:d29ca2a:         consumer.stop();
1:d29ca2a: 
1:d29ca2a:         // Send a message, but should not get delivered.
1:d29ca2a:         sendMessages(session, destination, 1);
1:05b4019:         assertFalse(done2.await(500, TimeUnit.MILLISECONDS));
1:d29ca2a:         assertEquals(1, counter.get());
1:d29ca2a: 
1:d29ca2a:         // Start the consumer, and the message should now get delivered.
1:d29ca2a:         consumer.start();
1:05b4019:         assertTrue(done2.await(500, TimeUnit.MILLISECONDS));
1:d29ca2a:         assertEquals(2, counter.get());
1:d29ca2a:     }
1:230a86c: 
1:9a60743:     public void testMessageListenerWithConsumerCanBeStoppedConcurently() throws Exception {
1:d29ca2a: 
1:9a60743:         final AtomicInteger counter = new AtomicInteger(0);
1:9a60743:         final CountDownLatch closeDone = new CountDownLatch(1);
1:c7d559f: 
1:d29ca2a:         connection.start();
1:9a60743:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:9a60743:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1:d29ca2a: 
1:9a60743:         // preload the queue
1:9a60743:         sendMessages(session, destination, 2000);
1:c7d559f: 
1:9a60743:         final ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)session.createConsumer(destination);
1:c7d559f: 
1:c7d559f:         final Map<Thread, Throwable> exceptions =
1:9a60743:             Collections.synchronizedMap(new HashMap<Thread, Throwable>());
1:9a60743:         Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
1:c7d559f:             @Override
1:9a60743:             public void uncaughtException(Thread t, Throwable e) {
1:9a60743:                 LOG.error("Uncaught exception:", e);
1:9a60743:                 exceptions.put(t, e);
1:9a60743:             }
1:d29ca2a:         });
1:c7d559f: 
1:c7d559f:         final class AckAndClose implements Runnable {
1:c7d559f:             private final Message message;
1:d29ca2a: 
1:9a60743:             public AckAndClose(Message m) {
1:9a60743:                 this.message = m;
1:9a60743:             }
1:d29ca2a: 
1:c7d559f:             @Override
1:9a60743:             public void run() {
1:c7d559f:                 try {
1:9a60743:                     int count = counter.incrementAndGet();
1:9a60743:                     if (count == 590) {
1:9a60743:                         // close in a separate thread is ok by jms
1:9a60743:                         consumer.close();
1:9a60743:                         closeDone.countDown();
1:9a60743:                     }
1:9a60743:                     if (count % 200 == 0) {
1:9a60743:                         // ensure there are some outstanding messages
1:9a60743:                         // ack every 200
1:35f3010:                         try {
1:35f3010:                             message.acknowledge();
1:35f3010:                         } catch (IllegalStateException okForAck) {}
1:9a60743:                     }
1:c7d559f:                 } catch (Exception e) {
1:9a60743:                     LOG.error("Exception on close or ack:", e);
1:9a60743:                     exceptions.put(Thread.currentThread(), e);
1:c7d559f:                 }
1:c7d559f:             }
1:9a60743:         };
1:c7d559f: 
1:9a60743:         final ExecutorService executor = Executors.newCachedThreadPool();
1:184761a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:c7d559f:             public void onMessage(Message m) {
1:9a60743:                 // ack and close eventually in separate thread
1:9a60743:                 executor.execute(new AckAndClose(m));
1:9a60743:             }
1:184761a:         });
1:d29ca2a: 
1:9a60743:         assertTrue(closeDone.await(20, TimeUnit.SECONDS));
1:05b4019: 
1:9a60743:         // await possible exceptions
1:05b4019:         executor.shutdown();
1:05b4019:         executor.awaitTermination(1, TimeUnit.SECONDS);
1:05b4019: 
1:9a60743:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:9a60743:     }
1:c7d559f: 
1:d29ca2a:     public void initCombosForTestMutiReceiveWithPrefetch1() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
1:230a86c:                                                       Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     public void testMutiReceiveWithPrefetch1() throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Set prefetch to 1
1:d29ca2a:         connection.getPrefetchPolicy().setAll(1);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         // Use all the ack modes
1:d29ca2a:         Session session = connection.createSession(false, ackMode);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:41a1007: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 4);
1:41a1007: 
1:d29ca2a:         // Make sure 4 messages were delivered.
1:d29ca2a:         Message message = null;
1:d29ca2a:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             message = consumer.receive(1000);
1:d29ca2a:             assertNotNull(message);
1:d29ca2a:         }
1:d29ca2a:         assertNull(consumer.receiveNoWait());
1:d29ca2a:         message.acknowledge();
1:d29ca2a:     }
1:c7d559f: 
1:41a1007:     public void testReceiveTopicWithPrefetch1() throws Exception {
1:41a1007: 
1:41a1007:         // Set prefetch to 1
1:41a1007:         connection.getPrefetchPolicy().setAll(1);
1:41a1007:         connection.start();
1:41a1007: 
1:41a1007:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:41a1007:         destination = createDestination(session, Byte.valueOf(ActiveMQDestination.TOPIC_TYPE));
1:41a1007:         MessageConsumer consumer = session.createConsumer(destination);
1:41a1007: 
1:41a1007:         // Send the messages
1:41a1007:         sendMessages(session, destination, 4);
1:41a1007: 
1:41a1007:         // Make sure 4 messages were delivered.
1:41a1007:         Message message = null;
1:41a1007:         for (int i = 0; i < 4; i++) {
1:41a1007:             message = consumer.receive(1000);
1:41a1007:             assertNotNull(message);
1:41a1007:         }
1:41a1007: 
1:41a1007:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1:41a1007: 
1:578eaca:         assertTrue("prefetch extension..",
4:41a1007:                 subscriptions.stream().
1:41a1007:                         filter(s -> s instanceof TopicSubscription).
1:41a1007:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
2:41a1007:                         allMatch(e -> e == 4));
1:41a1007: 
1:41a1007:         assertNull(consumer.receiveNoWait());
1:41a1007:         message.acknowledge();
1:41a1007: 
1:578eaca:         assertTrue("prefetch extension back to 0", Wait.waitFor(new Wait.Condition() {
1:578eaca:             @Override
1:578eaca:             public boolean isSatisified() throws Exception {
1:578eaca:                 return subscriptions.stream().
1:41a1007:                         filter(s -> s instanceof TopicSubscription).
1:41a1007:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
1:578eaca:                         allMatch(e -> e == 0);
1:578eaca:             }
1:578eaca:         }));
1:41a1007: 
1:41a1007:     }
1:9fe716b: 
1:41a1007:     public void testReceiveQueueWithPrefetch1() throws Exception {
1:41a1007: 
1:41a1007:         // Set prefetch to 1
1:41a1007:         connection.getPrefetchPolicy().setAll(1);
1:41a1007:         connection.start();
1:41a1007: 
1:41a1007:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:41a1007:         destination = createDestination(session, Byte.valueOf(ActiveMQDestination.QUEUE_TYPE));
1:41a1007:         MessageConsumer consumer = session.createConsumer(destination);
1:41a1007: 
1:41a1007:         // Send the messages
1:41a1007:         sendMessages(session, destination, 4);
1:41a1007: 
1:41a1007:         // Make sure 4 messages were delivered.
1:41a1007:         Message message = null;
1:41a1007:         for (int i = 0; i < 4; i++) {
1:41a1007:             message = consumer.receive(1000);
1:41a1007:             assertNotNull(message);
1:41a1007:         }
1:41a1007: 
1:41a1007:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1:9fe716b: 
1:63b71af:         assertTrue("prefetch extension..", Wait.waitFor(new Wait.Condition() {
1:63b71af:                     @Override
1:63b71af:                     public boolean isSatisified() throws Exception {
1:63b71af:                         return subscriptions.stream().
1:63b71af:                                 filter(s -> s instanceof QueueSubscription).
1:63b71af:                                 mapToInt(s -> ((QueueSubscription)s).getPrefetchExtension().get()).
1:63b71af:                                 allMatch(e -> e == 4);
1:63b71af:                     }
1:63b71af:                 }));
1:63b71af: 
1:41a1007: 
1:41a1007:         assertNull(consumer.receiveNoWait());
1:41a1007:         message.acknowledge();
1:41a1007: 
1:578eaca:         assertTrue("prefetch extension back to 0", Wait.waitFor(new Wait.Condition() {
1:578eaca:             @Override
1:578eaca:             public boolean isSatisified() throws Exception {
1:578eaca:                 return subscriptions.stream().
2:41a1007:                         filter(s -> s instanceof QueueSubscription).
2:41a1007:                         mapToInt(s -> ((QueueSubscription)s).getPrefetchExtension().get()).
1:578eaca:                         allMatch(e -> e == 0);
1:578eaca:             }
1:578eaca:         }));
1:41a1007:     }
1:41a1007: 
1:d29ca2a:     public void initCombosForTestDurableConsumerSelectorChange() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:d29ca2a:     }
1:9fe716b: 
1:7f5213b:     public void testDurableConsumerSelectorChange() throws Exception {
1:9fe716b: 
1:9fe716b:         // Receive a message with the JMS API
1:d29ca2a:         connection.setClientID("test");
1:9fe716b:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageProducer producer = session.createProducer(destination);
1:d29ca2a:         producer.setDeliveryMode(deliveryMode);
1:ecf89a6:         MessageConsumer consumer = session.createDurableSubscriber((Topic)destination, "test", "color='red'", false);
1:230a86c: 
1:9fe716b:         // Send the messages
1:d29ca2a:         TextMessage message = session.createTextMessage("1st");
1:d29ca2a:         message.setStringProperty("color", "red");
1:d29ca2a:         producer.send(message);
1:230a86c: 
1:d29ca2a:         Message m = consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertEquals("1st", ((TextMessage)m).getText());
1:c7d559f: 
1:d29ca2a:         // Change the subscription.
1:d29ca2a:         consumer.close();
1:d29ca2a:         consumer = session.createDurableSubscriber((Topic)destination, "test", "color='blue'", false);
1:230a86c: 
1:d29ca2a:         message = session.createTextMessage("2nd");
1:d29ca2a:         message.setStringProperty("color", "red");
1:d29ca2a:         producer.send(message);
1:d29ca2a:         message = session.createTextMessage("3rd");
1:d29ca2a:         message.setStringProperty("color", "blue");
1:d29ca2a:         producer.send(message);
1:230a86c: 
1:d29ca2a:         // Selector should skip the 2nd message.
1:d29ca2a:         m = consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertEquals("3rd", ((TextMessage)m).getText());
1:230a86c: 
1:d29ca2a:         assertNull(consumer.receiveNoWait());
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void initCombosForTestSendReceiveBytesMessage() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:98f3545: 
1:7f5213b:     public void testSendReceiveBytesMessage() throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:9fe716b:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a:         MessageProducer producer = session.createProducer(destination);
1:d29ca2a: 
1:d29ca2a:         BytesMessage message = session.createBytesMessage();
1:d29ca2a:         message.writeBoolean(true);
1:d29ca2a:         message.writeBoolean(false);
1:d29ca2a:         producer.send(message);
1:230a86c: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         BytesMessage m = (BytesMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertTrue(m.readBoolean());
1:d29ca2a:         assertFalse(m.readBoolean());
1:230a86c: 
1:d29ca2a:         assertNull(consumer.receiveNoWait());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestSetMessageListenerAfterStart() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testSetMessageListenerAfterStart() throws Exception {
1:d29ca2a: 
1:d29ca2a:         final AtomicInteger counter = new AtomicInteger(0);
1:d29ca2a:         final CountDownLatch done = new CountDownLatch(1);
1:230a86c: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:9fe716b:         sendMessages(session, destination, 4);
1:d29ca2a: 
1:d29ca2a:         // See if the message get sent to the listener
1:d29ca2a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:d29ca2a:             public void onMessage(Message m) {
1:d29ca2a:                 counter.incrementAndGet();
1:fc00993:                 if (counter.get() == 4) {
1:d29ca2a:                     done.countDown();
1:fc00993:                 }
1:fc00993:             }
1:d29ca2a:         });
1:d29ca2a: 
1:d29ca2a:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:d29ca2a:         Thread.sleep(200);
1:230a86c: 
1:d29ca2a:         // Make sure only 4 messages were delivered.
1:d29ca2a:         assertEquals(4, counter.get());
1:fc00993:     }
1:230a86c: 
1:fba0742:     public void initCombosForTestPassMessageListenerIntoCreateConsumer() {
1:fba0742:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:fba0742:     public void testPassMessageListenerIntoCreateConsumer() throws Exception {
1:230a86c: 
1:d29ca2a:         final AtomicInteger counter = new AtomicInteger(0);
1:d29ca2a:         final CountDownLatch done = new CountDownLatch(1);
1:d29ca2a: 
1:d29ca2a:         // Receive a message with the JMS API
1:9a60743:         connection.start();
1:fba0742:         ActiveMQSession session = (ActiveMQSession) connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:fba0742:         destination = createDestination(session, destinationType);
1:fba0742:         MessageConsumer consumer = session.createConsumer(destination, new MessageListener() {
1:c7d559f:             @Override
1:9a60743:             public void onMessage(Message m) {
1:fba0742:                 counter.incrementAndGet();
1:fc00993:                 if (counter.get() == 4) {
1:d29ca2a:                     done.countDown();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         });
1:c7d559f:         assertNotNull(consumer);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 4);
1:d29ca2a: 
1:fba0742:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:fba0742:         Thread.sleep(200);
1:d29ca2a: 
1:fba0742:         // Make sure only 4 messages were delivered.
1:fba0742:         assertEquals(4, counter.get());
1:9a60743:     }
1:d29ca2a: 
1:c7d559f:     public void initCombosForTestMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:1c34b2a:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
1:f812e34:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE)});
1:184761a:     }
1:d29ca2a: 
1:184761a:     public void testMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() throws Exception {
1:c7d559f: 
1:184761a:         final AtomicInteger counter = new AtomicInteger(0);
1:ecb5023:         final CountDownLatch sendDone = new CountDownLatch(1);
1:ecb5023:         final CountDownLatch got2Done = new CountDownLatch(1);
1:d29ca2a: 
1:d29ca2a:         // Set prefetch to 1
1:d29ca2a:         connection.getPrefetchPolicy().setAll(1);
1:230a86c:         // This test case does not work if optimized message dispatch is used as
1:230a86c:         // the main thread send block until the consumer receives the
1:230a86c:         // message. This test depends on thread decoupling so that the main
1:230a86c:         // thread can stop the consumer thread.
1:d29ca2a:         connection.setOptimizedMessageDispatch(false);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         // Use all the ack modes
1:d29ca2a:         Session session = connection.createSession(false, ackMode);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:d29ca2a:             public void onMessage(Message m) {
1:d29ca2a:                 try {
1:d29ca2a:                     TextMessage tm = (TextMessage)m;
1:fc00993:                     LOG.info("Got in first listener: " + tm.getText());
1:230a86c:                     assertEquals("" + counter.get(), tm.getText());
1:d29ca2a:                     counter.incrementAndGet();
1:184761a:                     if (counter.get() == 2) {
1:ecb5023:                         sendDone.await();
1:d29ca2a:                         connection.close();
1:184761a:                         got2Done.countDown();
1:d29ca2a:                     }
1:1c34b2a:                     tm.acknowledge();
1:184761a:                 } catch (Throwable e) {
1:d29ca2a:                     e.printStackTrace();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         });
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 4);
1:ecb5023:         sendDone.countDown();
1:230a86c: 
1:d29ca2a:         // Wait for first 2 messages to arrive.
1:ecb5023:         assertTrue(got2Done.await(100000, TimeUnit.MILLISECONDS));
1:d29ca2a: 
1:d29ca2a:         // Re-start connection.
1:230a86c:         connection = (ActiveMQConnection)factory.createConnection();
1:d29ca2a:         connections.add(connection);
1:230a86c: 
1:d29ca2a:         connection.getPrefetchPolicy().setAll(1);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         // Pickup the remaining messages.
1:d29ca2a:         final CountDownLatch done2 = new CountDownLatch(1);
1:d29ca2a:         session = connection.createSession(false, ackMode);
1:d29ca2a:         consumer = session.createConsumer(destination);
1:d29ca2a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:d29ca2a:             public void onMessage(Message m) {
1:d29ca2a:                 try {
1:d29ca2a:                     TextMessage tm = (TextMessage)m;
1:fc00993:                     LOG.info("Got in second listener: " + tm.getText());
1:184761a:                     // order is not guaranteed as the connection is started before the listener is set.
1:184761a:                     // assertEquals("" + counter.get(), tm.getText());
1:d29ca2a:                     counter.incrementAndGet();
1:fc00993:                     if (counter.get() == 4) {
1:d29ca2a:                         done2.countDown();
1:fc00993:                     }
1:d29ca2a:                 } catch (Throwable e) {
1:184761a:                     LOG.error("unexpected ex onMessage: ", e);
1:184761a:                 }
1:184761a:             }
1:d29ca2a:         });
1:d29ca2a: 
1:184761a:         assertTrue(done2.await(1000, TimeUnit.MILLISECONDS));
1:184761a:         Thread.sleep(200);
1:230a86c: 
1:1c34b2a:         // assert msg 2 was redelivered as close() from onMessages() will only ack in auto_ack and dups_ok mode
1:c7d559f:         assertEquals(5, counter.get());
1:184761a:     }
1:d29ca2a: 
1:184761a:     public void initCombosForTestMessageListenerAutoAckOnCloseWithPrefetch1() {
1:184761a:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:184761a:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
1:f812e34:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE)});
1:184761a:     }
1:d29ca2a: 
1:184761a:     public void testMessageListenerAutoAckOnCloseWithPrefetch1() throws Exception {
1:c7d559f: 
1:fba0742:         final AtomicInteger counter = new AtomicInteger(0);
1:184761a:         final CountDownLatch sendDone = new CountDownLatch(1);
1:184761a:         final CountDownLatch got2Done = new CountDownLatch(1);
1:d29ca2a: 
1:184761a:         // Set prefetch to 1
1:184761a:         connection.getPrefetchPolicy().setAll(1);
1:184761a:         // This test case does not work if optimized message dispatch is used as
1:184761a:         // the main thread send block until the consumer receives the
1:184761a:         // message. This test depends on thread decoupling so that the main
1:184761a:         // thread can stop the consumer thread.
1:184761a:         connection.setOptimizedMessageDispatch(false);
1:184761a:         connection.start();
1:d29ca2a: 
1:184761a:         // Use all the ack modes
1:184761a:         Session session = connection.createSession(false, ackMode);
1:184761a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:184761a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:184761a:             public void onMessage(Message m) {
1:184761a:                 try {
1:184761a:                     TextMessage tm = (TextMessage)m;
1:184761a:                     LOG.info("Got in first listener: " + tm.getText());
1:230a86c:                     assertEquals("" + counter.get(), tm.getText());
1:184761a:                     counter.incrementAndGet();
1:d29ca2a:                     m.acknowledge();
1:230a86c:                     if (counter.get() == 2) {
1:230a86c:                         sendDone.await();
1:ecb5023:                         connection.close();
1:ecb5023:                         got2Done.countDown();
1:d29ca2a:                     }
1:d29ca2a:                 } catch (Throwable e) {
1:d29ca2a:                     e.printStackTrace();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         });
1:d29ca2a: 
1:184761a:         // Send the messages
1:184761a:         sendMessages(session, destination, 4);
1:184761a:         sendDone.countDown();
1:d29ca2a: 
1:184761a:         // Wait for first 2 messages to arrive.
1:184761a:         assertTrue(got2Done.await(100000, TimeUnit.MILLISECONDS));
1:d29ca2a: 
1:184761a:         // Re-start connection.
1:230a86c:         connection = (ActiveMQConnection)factory.createConnection();
1:184761a:         connections.add(connection);
1:d29ca2a: 
1:184761a:         connection.getPrefetchPolicy().setAll(1);
1:184761a:         connection.start();
1:d29ca2a: 
1:184761a:         // Pickup the remaining messages.
1:184761a:         final CountDownLatch done2 = new CountDownLatch(1);
1:184761a:         session = connection.createSession(false, ackMode);
1:184761a:         consumer = session.createConsumer(destination);
1:9a60743:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:184761a:             public void onMessage(Message m) {
1:184761a:                 try {
1:184761a:                     TextMessage tm = (TextMessage)m;
1:184761a:                     LOG.info("Got in second listener: " + tm.getText());
1:184761a:                     counter.incrementAndGet();
1:fc00993:                     if (counter.get() == 4) {
1:184761a:                         done2.countDown();
1:184761a:                     }
1:184761a:                 } catch (Throwable e) {
1:184761a:                     LOG.error("unexpected ex onMessage: ", e);
1:184761a:                 }
1:184761a:             }
1:184761a:         });
1:d29ca2a: 
1:d29ca2a:         assertTrue(done2.await(1000, TimeUnit.MILLISECONDS));
1:d29ca2a:         Thread.sleep(200);
1:d29ca2a: 
1:184761a:         // close from onMessage with Auto_ack will ack
1:d29ca2a:         // Make sure only 4 messages were delivered.
1:d29ca2a:         assertEquals(4, counter.get());
1:9a60743:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestMessageListenerWithConsumerWithPrefetch1() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testMessageListenerWithConsumerWithPrefetch1() throws Exception {
1:230a86c: 
1:d29ca2a:         final AtomicInteger counter = new AtomicInteger(0);
1:d29ca2a:         final CountDownLatch done = new CountDownLatch(1);
1:230a86c: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         connection.getPrefetchPolicy().setAll(1);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:d29ca2a:             public void onMessage(Message m) {
1:d29ca2a:                 counter.incrementAndGet();
1:184761a:                 if (counter.get() == 4) {
1:d29ca2a:                     done.countDown();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         });
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 4);
1:d29ca2a: 
1:d29ca2a:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:d29ca2a:         Thread.sleep(200);
1:d29ca2a: 
1:d29ca2a:         // Make sure only 4 messages were delivered.
1:d29ca2a:         assertEquals(4, counter.get());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestMessageListenerWithConsumer() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testMessageListenerWithConsumer() throws Exception {
1:230a86c: 
1:d29ca2a:         final AtomicInteger counter = new AtomicInteger(0);
1:d29ca2a:         final CountDownLatch done = new CountDownLatch(1);
1:d29ca2a: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a:         consumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:d29ca2a:             public void onMessage(Message m) {
1:d29ca2a:                 counter.incrementAndGet();
1:fba0742:                 if (counter.get() == 4) {
1:d29ca2a:                     done.countDown();
1:d29ca2a:                 }
3:fba0742:             }
1:d29ca2a:         });
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 4);
1:d29ca2a: 
1:d29ca2a:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:d29ca2a:         Thread.sleep(200);
1:d29ca2a: 
1:d29ca2a:         // Make sure only 4 messages were delivered.
1:d29ca2a:         assertEquals(4, counter.get());
1:fba0742:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestUnackedWithPrefetch1StayInQueue() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
1:230a86c:                                                       Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
1:184761a:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE)});
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     public void testUnackedWithPrefetch1StayInQueue() throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Set prefetch to 1
1:d29ca2a:         connection.getPrefetchPolicy().setAll(1);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         // Use all the ack modes
1:d29ca2a:         Session session = connection.createSession(false, ackMode);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 4);
1:d29ca2a: 
1:d29ca2a:         // Only pick up the first 2 messages.
1:d29ca2a:         Message message = null;
1:d29ca2a:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             message = consumer.receive(1000);
1:d29ca2a:             assertNotNull(message);
1:d29ca2a:         }
1:d29ca2a:         message.acknowledge();
1:d29ca2a: 
1:d29ca2a:         connection.close();
1:184761a:         connection = (ActiveMQConnection)factory.createConnection();
1:d29ca2a:         connections.add(connection);
1:d29ca2a:         connection.getPrefetchPolicy().setAll(1);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         // Use all the ack modes
1:d29ca2a:         session = connection.createSession(false, ackMode);
1:d29ca2a:         consumer = session.createConsumer(destination);
1:d29ca2a: 
1:d29ca2a:         // Pickup the rest of the messages.
1:d29ca2a:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             message = consumer.receive(1000);
1:d29ca2a:             assertNotNull(message);
1:d29ca2a:         }
1:d29ca2a:         message.acknowledge();
1:d29ca2a:         assertNull(consumer.receiveNoWait());
1:d29ca2a:     }
1:d29ca2a: 
1:98f3545:     public void initCombosForTestPrefetch1MessageNotDispatched() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:98f3545:     }
1:230a86c: 
1:98f3545:     public void testPrefetch1MessageNotDispatched() throws Exception {
1:98f3545: 
1:98f3545:         // Set prefetch to 1
1:98f3545:         connection.getPrefetchPolicy().setAll(1);
1:98f3545:         connection.start();
1:98f3545: 
1:98f3545:         Session session = connection.createSession(true, 0);
1:98f3545:         destination = new ActiveMQQueue("TEST");
1:98f3545:         MessageConsumer consumer = session.createConsumer(destination);
1:98f3545: 
1:98f3545:         // Send 2 messages to the destination.
1:98f3545:         sendMessages(session, destination, 2);
1:98f3545:         session.commit();
1:98f3545: 
1:efdf8ce:         // The prefetch should fill up with 1 message.
1:230a86c:         // Since prefetch is still full, the 2nd message should get dispatched
1:efdf8ce:         // to another consumer.. lets create the 2nd consumer test that it does
1:230a86c:         // make sure it does.
1:230a86c:         ActiveMQConnection connection2 = (ActiveMQConnection)factory.createConnection();
1:fc338b7:         connection2.start();
1:98f3545:         connections.add(connection2);
1:98f3545:         Session session2 = connection2.createSession(true, 0);
1:efdf8ce:         MessageConsumer consumer2 = session2.createConsumer(destination);
1:230a86c: 
1:efdf8ce:         // Pick up the first message.
1:b6ba20b:         Message message1 = consumer.receive(1000);
1:efdf8ce:         assertNotNull(message1);
1:efdf8ce: 
1:efdf8ce:         // Pick up the 2nd messages.
1:2f65221:         Message message2 = consumer2.receive(5000);
1:98f3545:         assertNotNull(message2);
1:230a86c: 
1:98f3545:         session.commit();
1:98f3545:         session2.commit();
1:230a86c: 
1:98f3545:         assertNull(consumer.receiveNoWait());
1:98f3545:     }
1:98f3545: 
1:d29ca2a:     public void initCombosForTestDontStart() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:d29ca2a:     }
1:98f3545: 
1:7f5213b:     public void testDontStart() throws Exception {
1:98f3545: 
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:98f3545: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 1);
1:98f3545: 
1:d29ca2a:         // Make sure no messages were delivered.
2:9fe716b:         assertNull(consumer.receive(1000));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestStartAfterSend() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     public void testStartAfterSend() throws Exception {
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 1);
1:d29ca2a: 
1:d29ca2a:         // Start the conncection after the message was sent.
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         assertNotNull(consumer.receive(1000));
1:d29ca2a:         assertNull(consumer.receiveNoWait());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void initCombosForTestReceiveMessageWithConsumer() {
1:ecf89a6:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:ecf89a6:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:ecf89a6:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     public void testReceiveMessageWithConsumer() throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         destination = createDestination(session, destinationType);
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         sendMessages(session, destination, 1);
1:d29ca2a: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         Message m = consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertEquals("0", ((TextMessage)m).getText());
1:d29ca2a:         assertNull(consumer.receiveNoWait());
1:d29ca2a:     }
1:d29ca2a: 
1:9fe716b:     public void testDupsOkConsumer() throws Exception {
1:d29ca2a: 
1:fba0742:         // Receive a message with the JMS API
1:fba0742:         connection.start();
1:9fe716b:         Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);
1:9fe716b:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1:184761a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a: 
1:fba0742:         // Send the messages
1:fba0742:         sendMessages(session, destination, 4);
1:d29ca2a: 
1:9fe716b:         // Make sure only 4 message are delivered.
1:9fe716b:         for( int i=0; i < 4; i++){
1:9fe716b:             Message m = consumer.receive(1000);
1:9fe716b:             assertNotNull(m);
1:9fe716b:         }
1:05b4019:         assertNull(consumer.receive(500));
1:9fe716b: 
1:9fe716b:         // Close out the consumer.. no other messages should be left on the queue.
1:9fe716b:         consumer.close();
1:c7d559f: 
1:9fe716b:         consumer = session.createConsumer(destination);
1:05b4019:         assertNull(consumer.receive(500));
1:9fe716b:     }
1:9fe716b: 
1:92e1431:     public void testRedispatchOfUncommittedTx() throws Exception {
1:d29ca2a: 
1:92e1431:         connection.start();
1:92e1431:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:92e1431:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1:c7d559f: 
1:3804d66:         sendMessages(connection, destination, 2);
1:c7d559f: 
1:92e1431:         MessageConsumer consumer = session.createConsumer(destination);
1:3804d66:         assertNotNull(consumer.receive(1000));
1:3804d66:         assertNotNull(consumer.receive(1000));
1:c7d559f: 
1:92e1431:         // install another consumer while message dispatch is unacked/uncommitted
1:92e1431:         Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:92e1431:         MessageConsumer redispatchConsumer = redispatchSession.createConsumer(destination);
1:c7d559f: 
1:0bfb28a:         // no commit so will auto rollback and get re-dispatched to redisptachConsumer
1:92e1431:         session.close();
1:c7d559f: 
1:0bfb28a:         Message msg = redispatchConsumer.receive(1000);
1:50a98e3:         assertNotNull(msg);
1:7343337:         assertTrue("redelivered flag set", msg.getJMSRedelivered());
1:3804d66:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
1:c7d559f: 
1:3804d66:         msg = redispatchConsumer.receive(1000);
1:0bfb28a:         assertNotNull(msg);
1:50a98e3:         assertTrue(msg.getJMSRedelivered());
1:3804d66:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
1:92e1431:         redispatchSession.commit();
1:c7d559f: 
1:92e1431:         assertNull(redispatchConsumer.receive(500));
1:92e1431:         redispatchSession.close();
1:d29ca2a:     }
1:e91f5c8: 
1:50a98e3:     public void testRedispatchOfRolledbackTx() throws Exception {
1:c7d559f: 
1:50a98e3:         connection.start();
1:50a98e3:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:50a98e3:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1:c7d559f: 
1:3804d66:         sendMessages(connection, destination, 2);
1:c7d559f: 
1:50a98e3:         MessageConsumer consumer = session.createConsumer(destination);
1:50a98e3:         assertNotNull(consumer.receive(1000));
1:92e1431:         assertNotNull(consumer.receive(1000));
1:c7d559f: 
1:50a98e3:         // install another consumer while message dispatch is unacked/uncommitted
1:50a98e3:         Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:50a98e3:         MessageConsumer redispatchConsumer = redispatchSession.createConsumer(destination);
1:c7d559f: 
1:50a98e3:         session.rollback();
1:50a98e3:         session.close();
1:c7d559f: 
1:50a98e3:         Message msg = redispatchConsumer.receive(1000);
1:3804d66:         assertNotNull(msg);
1:3804d66:         assertTrue(msg.getJMSRedelivered());
1:3804d66:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
1:3804d66:         msg = redispatchConsumer.receive(1000);
1:3804d66:         assertNotNull(msg);
1:3804d66:         assertTrue(msg.getJMSRedelivered());
1:3804d66:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
1:50a98e3:         redispatchSession.commit();
1:c7d559f: 
1:50a98e3:         assertNull(redispatchConsumer.receive(500));
1:50a98e3:         redispatchSession.close();
1:50a98e3:     }
1:d29ca2a: 
1:e91f5c8:     public void testExceptionOnClientAckAfterConsumerClose() throws Exception {
1:e91f5c8: 
1:e91f5c8:         connection.start();
1:e91f5c8:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:e91f5c8:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1:d29ca2a: 
1:e91f5c8:         sendMessages(connection, destination, 1);
1:e91f5c8: 
1:e91f5c8:         MessageConsumer consumer = session.createConsumer(destination);
1:e91f5c8:         Message message = consumer.receive(1000);
1:e91f5c8:         assertNotNull(message);
1:e91f5c8:         consumer.close();
1:e91f5c8: 
1:e91f5c8:         try {
1:e91f5c8:             message.acknowledge();
1:e91f5c8:             fail("Expect exception on ack after close - consumer gone so message available again");
1:e91f5c8:         } catch (JMSException expected) {}
1:e91f5c8: 
1:e91f5c8:         Session redispatchSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:e91f5c8:         MessageConsumer redispatchConsumer = redispatchSession.createConsumer(destination);
1:e91f5c8:         Message msg = redispatchConsumer.receive(1000);
1:e91f5c8:         assertNotNull(msg);
1:e91f5c8: 
1:e91f5c8:         redispatchSession.close();
1:e91f5c8:     }
1:e91f5c8: 
1:e91f5c8: 
1:b997d25:     public void initCombosForTestAckOfExpired() {
1:c7d559f:         addCombinationValues("destinationType",
1:05b4019:             new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:b997d25:     }
1:c7d559f: 
1:b997d25:     public void testAckOfExpired() throws Exception {
1:c7d559f: 
1:b997d25:         ActiveMQConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost?jms.prefetchPolicy.all=4&jms.sendAcksAsync=false");
1:b997d25:         connection = fact.createActiveMQConnection();
1:c7d559f: 
1:b997d25:         connection.start();
1:c7d559f:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b997d25:         destination = (ActiveMQDestination) (destinationType == ActiveMQDestination.QUEUE_TYPE ?
1:b997d25:                 session.createQueue("test") : session.createTopic("test"));
1:c7d559f: 
1:b997d25:         MessageConsumer consumer = session.createConsumer(destination);
1:b997d25:         connection.setStatsEnabled(true);
1:c7d559f: 
1:c7d559f:         Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b136df1:         MessageProducer producer = sendSession.createProducer(destination);
1:05b4019:         producer.setTimeToLive(500);
1:b997d25:         final int count = 4;
1:b997d25:         for (int i = 0; i < count; i++) {
1:b997d25:             TextMessage message = sendSession.createTextMessage("" + i);
1:b997d25:             producer.send(message);
1:b997d25:         }
1:c7d559f: 
1:b997d25:         // let first bunch in queue expire
1:05b4019:         Thread.sleep(1000);
1:c7d559f: 
1:b997d25:         producer.setTimeToLive(0);
1:b997d25:         for (int i = 0; i < count; i++) {
1:b997d25:             TextMessage message = sendSession.createTextMessage("no expiry" + i);
1:b997d25:             producer.send(message);
1:b997d25:         }
1:c7d559f: 
1:b997d25:         ActiveMQMessageConsumer amqConsumer = (ActiveMQMessageConsumer) consumer;
1:c7d559f: 
1:05b4019:         for (int i=0; i<count; i++) {
1:b997d25:             TextMessage msg = (TextMessage) amqConsumer.receive();
1:b997d25:             assertNotNull(msg);
1:5a0f76d:             assertTrue("message has \"no expiry\" text: " + msg.getText(), msg.getText().contains("no expiry"));
1:c7d559f: 
1:b997d25:             // force an ack when there are expired messages
1:c7d559f:             amqConsumer.acknowledge();
1:b997d25:         }
1:b997d25:         assertEquals("consumer has expiredMessages", count, amqConsumer.getConsumerStats().getExpiredMessageCount().getCount());
1:c7d559f: 
1:b997d25:         DestinationViewMBean view = createView(destination);
1:c7d559f: 
1:a707594:         assertEquals("Wrong inFlightCount: " + view.getInFlightCount(), 0, view.getInFlightCount());
1:a707594:         assertEquals("Wrong dispatch count: " + view.getDispatchCount(), 8, view.getDispatchCount());
1:a707594:         assertEquals("Wrong dequeue count: " + view.getDequeueCount(), 8, view.getDequeueCount());
1:b136df1:         assertEquals("Wrong expired count: " + view.getExpiredCount(), 4, view.getExpiredCount());
1:b997d25:     }
1:c7d559f: 
1:b997d25:     protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
1:c7d559f: 
1:05b4019:         String domain = "org.apache.activemq";
1:05b4019:         ObjectName name;
1:b997d25:         if (destination.isQueue()) {
1:cb7b657:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=test");
1:b997d25:         } else {
1:cb7b657:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Topic,destinationName=test");
1:b997d25:         }
1:05b4019:         return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
1:b997d25:     }
1:92e1431: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:63b71af
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("prefetch extension..", Wait.waitFor(new Wait.Condition() {
1:                     @Override
1:                     public boolean isSatisified() throws Exception {
1:                         return subscriptions.stream().
1:                                 filter(s -> s instanceof QueueSubscription).
1:                                 mapToInt(s -> ((QueueSubscription)s).getPrefetchExtension().get()).
1:                                 allMatch(e -> e == 4);
1:                     }
1:                 }));
1: 
commit:578eaca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("prefetch extension..",
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("prefetch extension back to 0", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return subscriptions.stream().
1:                         allMatch(e -> e == 0);
1:             }
1:         }));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("prefetch extension back to 0", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return subscriptions.stream().
1:                         allMatch(e -> e == 0);
1:             }
1:         }));
commit:41a1007
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.QueueSubscription;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.broker.region.TopicSubscription;
1: import static org.apache.activemq.TestSupport.getDestinationConsumers;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testReceiveTopicWithPrefetch1() throws Exception {
1: 
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = createDestination(session, Byte.valueOf(ActiveMQDestination.TOPIC_TYPE));
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         // Make sure 4 messages were delivered.
1:         Message message = null;
1:         for (int i = 0; i < 4; i++) {
1:             message = consumer.receive(1000);
1:             assertNotNull(message);
1:         }
1: 
1:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1: 
0:         assertTrue("prefetch extension back to 0",
1:                 subscriptions.stream().
1:                         filter(s -> s instanceof TopicSubscription).
1:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
1:                         allMatch(e -> e == 4));
1: 
1:         assertNull(consumer.receiveNoWait());
1:         message.acknowledge();
1: 
0:         assertTrue("prefetch extension back to 0",
1:                 subscriptions.stream().
1:                         filter(s -> s instanceof TopicSubscription).
1:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
0:                         allMatch(e -> e == 0));
1: 
1:     }
1: 
1:     public void testReceiveQueueWithPrefetch1() throws Exception {
1: 
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = createDestination(session, Byte.valueOf(ActiveMQDestination.QUEUE_TYPE));
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         // Make sure 4 messages were delivered.
1:         Message message = null;
1:         for (int i = 0; i < 4; i++) {
1:             message = consumer.receive(1000);
1:             assertNotNull(message);
1:         }
1: 
1:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1: 
0:         assertTrue("prefetch extension..",
1:                 subscriptions.stream().
1:                         filter(s -> s instanceof QueueSubscription).
1:                         mapToInt(s -> ((QueueSubscription)s).getPrefetchExtension().get()).
1:                         allMatch(e -> e == 4));
1: 
1:         assertNull(consumer.receiveNoWait());
1:         message.acknowledge();
1: 
0:         assertTrue("prefetch extension back to 0",
1:                 subscriptions.stream().
1:                         filter(s -> s instanceof QueueSubscription).
1:                         mapToInt(s -> ((QueueSubscription)s).getPrefetchExtension().get()).
0:                         allMatch(e -> e == 0));
1:     }
1: 
commit:35f3010
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.IllegalStateException;
/////////////////////////////////////////////////////////////////////////
1:                         try {
1:                             message.acknowledge();
1:                         } catch (IllegalStateException okForAck) {}
commit:e91f5c8
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
1:     public void testExceptionOnClientAckAfterConsumerClose() throws Exception {
1: 
1:         connection.start();
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1: 
1:         sendMessages(connection, destination, 1);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         Message message = consumer.receive(1000);
1:         assertNotNull(message);
1:         consumer.close();
1: 
1:         try {
1:             message.acknowledge();
1:             fail("Expect exception on ack after close - consumer gone so message available again");
1:         } catch (JMSException expected) {}
1: 
1:         Session redispatchSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer redispatchConsumer = redispatchSession.createConsumer(destination);
1:         Message msg = redispatchConsumer.receive(1000);
1:         assertNotNull(msg);
1: 
1:         redispatchSession.close();
1:     }
1: 
1: 
commit:b136df1
/////////////////////////////////////////////////////////////////////////
1:         MessageProducer producer = sendSession.createProducer(destination);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Wrong expired count: " + view.getExpiredCount(), 4, view.getExpiredCount());
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:Timothy Bish
-------------------------------------------------------------------------------
commit:05b4019
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertFalse(done2.await(500, TimeUnit.MILLISECONDS));
1:         assertTrue(done2.await(500, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         executor.shutdown();
1:         executor.awaitTermination(1, TimeUnit.SECONDS);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertNull(consumer.receive(500));
1:         assertNull(consumer.receive(500));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         producer.setTimeToLive(500);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         for (int i=0; i<count; i++) {
/////////////////////////////////////////////////////////////////////////
1:         String domain = "org.apache.activemq";
1:         ObjectName name;
1:         return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c7d559f
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         final Map<Thread, Throwable> exceptions =
1:             @Override
1: 
1:         final class AckAndClose implements Runnable {
1:             private final Message message;
1:             @Override
1:                 try {
/////////////////////////////////////////////////////////////////////////
1:                 } catch (Exception e) {
1:                 }
1:             }
1: 
1:             @Override
1:             public void onMessage(Message m) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull(consumer);
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() {
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(5, counter.get());
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         addCombinationValues("destinationType",
1: 
1: 
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
1:         Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:             amqConsumer.acknowledge();
1: 
1: 
1: 
1: 
commit:ef24cc9
author:Robert Davies
-------------------------------------------------------------------------------
commit:cb7b657
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=test");
1:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Topic,destinationName=test");
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
1:          
/////////////////////////////////////////////////////////////////////////
0:         return (DestinationViewMBean)broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE) });
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:                 Integer.valueOf(Session.AUTO_ACKNOWLEDGE),
0:                 Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE), 
0:                 Integer.valueOf(Session.CLIENT_ACKNOWLEDGE) });
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] { Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE) });
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE) });
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) 
0:                 Integer.valueOf(Session.AUTO_ACKNOWLEDGE),
0:                 Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE), 
0:                 Integer.valueOf(Session.CLIENT_ACKNOWLEDGE) 
0:         addCombinationValues("destinationType", new Object[] { Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), });
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE) });
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE) });
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] { Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:         		Integer.valueOf(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("ackMode", new Object[] { Integer.valueOf(Session.AUTO_ACKNOWLEDGE),
0:         		Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE), Integer.valueOf(Session.CLIENT_ACKNOWLEDGE) });
0:         addCombinationValues("destinationType", new Object[] { Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), });
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] { Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] { Integer.valueOf(DeliveryMode.NON_PERSISTENT), });
0:         addCombinationValues("destinationType", new Object[] { Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), });
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] { Integer.valueOf(DeliveryMode.NON_PERSISTENT), });
0:         addCombinationValues("destinationType", new Object[] { Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), });
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] { Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                 Integer.valueOf(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE) });
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
1:         Message message1 = consumer.receive(1000);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:1c34b2a
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
/////////////////////////////////////////////////////////////////////////
1:                     tm.acknowledge();
/////////////////////////////////////////////////////////////////////////
1:         // assert msg 2 was redelivered as close() from onMessages() will only ack in auto_ack and dups_ok mode
commit:fc338b7
/////////////////////////////////////////////////////////////////////////
1:         connection2.start();
commit:efdf8ce
/////////////////////////////////////////////////////////////////////////
1:         // The prefetch should fill up with 1 message.
1:         // to another consumer.. lets create the 2nd consumer test that it does
1:         MessageConsumer consumer2 = session2.createConsumer(destination);
1:         // Pick up the first message.
0:         Message message1 = consumer.receive(1000);
1:         assertNotNull(message1);
1: 
1:         // Pick up the 2nd messages.
0:         Message message2 = consumer2.receive(1000);
commit:9fe716b
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void testDupsOkConsumer() throws Exception {
1: 
1:         // Receive a message with the JMS API
1:         connection.start();
1:         Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);
1:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         // Make sure only 4 message are delivered.
1:         for( int i=0; i < 4; i++){
1:             Message m = consumer.receive(1000);
1:             assertNotNull(m);
1:         }
1:         assertNull(consumer.receive(1000));
1:         
1:         // Close out the consumer.. no other messages should be left on the queue.
1:         consumer.close();
1:         
1:         consumer = session.createConsumer(destination);
1:         assertNull(consumer.receive(1000));
1:     }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(JMSConsumerTest.class);
/////////////////////////////////////////////////////////////////////////
0:         session2.createConsumer(destination);
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(JMSConsumerTest.class);
1: 
1:     public ActiveMQDestination destination;
1:     public int deliveryMode;
1:     public int prefetch;
1:     public int ackMode;
1:     public byte destinationType;
1:     public boolean durableConsumer;
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = session.createDurableSubscriber((Topic)destination, "test", "color='red'", false);
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory
/////////////////////////////////////////////////////////////////////////
1:                 if (counter.get() == 1) {
1:                 }
1:                 if (counter.get() == 2) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (counter.get() == 4) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Got in first listener: " + tm.getText());
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Got in second listener: " + tm.getText());
1:                     if (counter.get() == 4) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 if (counter.get() == 4) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (counter.get() == 4) {
1:                 }
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
0:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
0:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         .getLog(JMSConsumerTest.class);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
1:         ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)session.createConsumer(destination);
0:                 if (counter.get() == 1)
0:                 if (counter.get() == 2)
1:         // Send a first message to make sure that the consumer dispatcher is
1:         // running
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE),
0:                                                       Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
1:                                                       Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1: 
/////////////////////////////////////////////////////////////////////////
0:         MessageConsumer consumer = session.createDurableSubscriber((Topic)destination, "test", "color='red'",
0:                                                                    false);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (counter.get() == 4)
1: 
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE),
0:                                                       Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
1:                                                       Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),});
/////////////////////////////////////////////////////////////////////////
1:         // This test case does not work if optimized message dispatch is used as
1:         // the main thread send block until the consumer receives the
1:         // message. This test depends on thread decoupling so that the main
1:         // thread can stop the consumer thread.
/////////////////////////////////////////////////////////////////////////
0:                     log.info("Got in first listener: " + tm.getText());
1:                     assertEquals("" + counter.get(), tm.getText());
1:                     if (counter.get() == 2) {
1:                         sendDone.await();
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection = (ActiveMQConnection)factory.createConnection();
1: 
/////////////////////////////////////////////////////////////////////////
0:                     log.info("Got in second listener: " + tm.getText());
1:                     assertEquals("" + counter.get(), tm.getText());
0:                     if (counter.get() == 4)
/////////////////////////////////////////////////////////////////////////
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
1: 
0:                 if (counter.get() == 4)
/////////////////////////////////////////////////////////////////////////
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (counter.get() == 4)
/////////////////////////////////////////////////////////////////////////
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE),
0:                                                       Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),
0:                                                       Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),});
/////////////////////////////////////////////////////////////////////////
1:         connection = (ActiveMQConnection)factory.createConnection();
/////////////////////////////////////////////////////////////////////////
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1: 
/////////////////////////////////////////////////////////////////////////
0:         assertNotNull(message1);
1: 
0:         // Don't acknowledge yet. This should keep our prefetch full.
1:         // Since prefetch is still full, the 2nd message should get dispatched
0:         // to
0:         // another consumer.. lets create the 2nd consumer test that it does
1:         // make sure it does.
1:         ActiveMQConnection connection2 = (ActiveMQConnection)factory.createConnection();
1: 
1: 
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
commit:ecb5023
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch sendDone = new CountDownLatch(1);
1:         final CountDownLatch got2Done = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:                     	sendDone.await();
1:                         connection.close();
1:                         got2Done.countDown();
/////////////////////////////////////////////////////////////////////////
1:         sendDone.countDown();
1:         assertTrue(got2Done.await(100000, TimeUnit.MILLISECONDS));
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicInteger;
commit:98f3545
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQQueue;
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestPrefetch1MessageNotDispatched() {
0:         addCombinationValues("deliveryMode", new Object[] { new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
1:     }
1:     
1:     public void testPrefetch1MessageNotDispatched() throws Exception {
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, 0);
1:         destination = new ActiveMQQueue("TEST");
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send 2 messages to the destination.
1:         sendMessages(session, destination, 2);
1:         session.commit();
1: 
0:         // Only pick up the first message.
0:         Message message1 = message1 = consumer.receive(1000);
0:         assertNotNull(message1);        
1:         
0:         // Don't acknowledge yet.  This should keep our prefetch full.        
0:         // Since prefetch is still full, the 2nd message should get dispatched to 
0:         // another consumer..  lets create the 2nd consumer test that it does make sure it does.        
0:         ActiveMQConnection connection2 = (ActiveMQConnection) factory.createConnection();
1:         connections.add(connection2);
1:         Session session2 = connection2.createSession(true, 0);
0:         MessageConsumer consumer2 = session2.createConsumer(destination);
1:         
0:         // Only pick up the 2nd messages.
0:         Message message2 = consumer.receive(1000);
1:         assertNotNull(message2);
1:         
1:         session.commit();
1:         session2.commit();
1: 
1:         assertNull(consumer.receiveNoWait());
1: 
1:     }
1:     
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void testMessageListenerWithConsumerCanBeStopped() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testMutiReceiveWithPrefetch1() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testDurableConsumerSelectorChange() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testSendReceiveBytesMessage() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testSetMessageListenerAfterStart() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testMessageListenerUnackedWithPrefetch1StayInQueue() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testMessageListenerWithConsumerWithPrefetch1() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testMessageListenerWithConsumer() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testUnackedWithPrefetch1StayInQueue() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testDontStart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testStartAfterSend() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testReceiveMessageWithConsumer() throws Exception {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import javax.jms.BytesMessage;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.Topic;
1: 
1: import junit.framework.Test;
1: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.ActiveMQMessageConsumer;
1: import org.apache.activemq.command.ActiveMQDestination;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
1: 
1: /**
1:  * Test cases used to test the JMS message consumer.
0:  * 
0:  * @version $Revision$
1:  */
1: public class JMSConsumerTest extends JmsTestSupport {
1: 
0:     private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory
0:             .getLog(JMSConsumerTest.class);
1:     
1:     public static Test suite() {
1:         return suite(JMSConsumerTest.class);
1:     }
1: 
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
1: 
0:     public ActiveMQDestination destination;
0:     public int deliveryMode;
0:     public int prefetch;
0:     public int ackMode;
0:     public byte destinationType;
0:     public boolean durableConsumer;
1:     
1:     public void initCombosForTestMessageListenerWithConsumerCanBeStopped() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE) });
1:     }
0:     public void testMessageListenerWithConsumerCanBeStopped() throws Throwable {
1: 
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch done1 = new CountDownLatch(1);
1:         final CountDownLatch done2 = new CountDownLatch(1);
1:         
1:         // Receive a message with the JMS API
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
0:         ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 counter.incrementAndGet();
0:                 if( counter.get()==1 )
1:                     done1.countDown();
0:                 if( counter.get()==2 )
1:                     done2.countDown();
1:             }
1:         });
1: 
0:         // Send a first message to make sure that the consumer dispatcher is running
1:         sendMessages(session, destination, 1);
1:         assertTrue(done1.await(1, TimeUnit.SECONDS));
1:         assertEquals(1, counter.get());
1: 
1:         // Stop the consumer.
1:         consumer.stop();
1: 
1:         // Send a message, but should not get delivered.
1:         sendMessages(session, destination, 1);
0:         assertFalse(done2.await(1, TimeUnit.SECONDS));
1:         assertEquals(1, counter.get());
1:         
1:         // Start the consumer, and the message should now get delivered.
1:         consumer.start();
0:         assertTrue(done2.await(1, TimeUnit.SECONDS));
1:         assertEquals(2, counter.get());
1:     }
1:     
1:     public void initCombosForTestMutiReceiveWithPrefetch1() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("ackMode", new Object[] { 
0:                 new Integer(Session.AUTO_ACKNOWLEDGE),
0:                 new Integer(Session.DUPS_OK_ACKNOWLEDGE), 
0:                 new Integer(Session.CLIENT_ACKNOWLEDGE) });
0:         addCombinationValues("destinationType", new Object[] { 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)
1:                 });
1:     }
1: 
0:     public void testMutiReceiveWithPrefetch1() throws Throwable {
1: 
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         // Use all the ack modes
1:         Session session = connection.createSession(false, ackMode);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         // Make sure 4 messages were delivered.
1:         Message message = null;
1:         for (int i = 0; i < 4; i++) {
1:             message = consumer.receive(1000);
1:             assertNotNull(message);
1:         }
1:         assertNull(consumer.receiveNoWait());
1:         message.acknowledge();
1:     }
1: 
1:     public void initCombosForTestDurableConsumerSelectorChange() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE)});
1:     }
0:     public void testDurableConsumerSelectorChange() throws Throwable {
1: 
1:         // Receive a message with the JMS API
1:         connection.setClientID("test");
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageProducer producer = session.createProducer(destination);
1:         producer.setDeliveryMode(deliveryMode);
0:         MessageConsumer consumer = session.createDurableSubscriber((Topic)destination, "test", "color='red'", false);
1: 
1:         // Send the messages
1:         TextMessage message = session.createTextMessage("1st");
1:         message.setStringProperty("color", "red");
1:         producer.send(message);
1:         
1:         Message m = consumer.receive(1000);
1:         assertNotNull(m);
1:         assertEquals("1st", ((TextMessage)m).getText());
1: 
1:         // Change the subscription.
1:         consumer.close();
1:         consumer = session.createDurableSubscriber((Topic)destination, "test", "color='blue'", false);
1:         
1:         message = session.createTextMessage("2nd");
1:         message.setStringProperty("color", "red");
1:         producer.send(message);
1:         message = session.createTextMessage("3rd");
1:         message.setStringProperty("color", "blue");
1:         producer.send(message);
1: 
1:         // Selector should skip the 2nd message.
1:         m = consumer.receive(1000);
1:         assertNotNull(m);
1:         assertEquals("3rd", ((TextMessage)m).getText());
1:         
1:         assertNull(consumer.receiveNoWait());
1:     }
1: 
1:     public void initCombosForTestSendReceiveBytesMessage() {
0:         addCombinationValues("deliveryMode", new Object[] { new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE) });
1:     }
1: 
0:     public void testSendReceiveBytesMessage() throws Throwable {
1: 
1:         // Receive a message with the JMS API
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         MessageProducer producer = session.createProducer(destination);
1:         
1:         BytesMessage message = session.createBytesMessage();
1:         message.writeBoolean(true);
1:         message.writeBoolean(false);
1:         producer.send(message);
1:         
1:         // Make sure only 1 message was delivered.
1:         BytesMessage m = (BytesMessage)consumer.receive(1000);
1:         assertNotNull(m);
1:         assertTrue(m.readBoolean());
1:         assertFalse(m.readBoolean());
1:         
1:         assertNull(consumer.receiveNoWait());
1:     }
1: 
1:     
1:     public void initCombosForTestSetMessageListenerAfterStart() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE) });
1:     }
0:     public void testSetMessageListenerAfterStart() throws Throwable {
1: 
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch done = new CountDownLatch(1);
1:         
1:         // Receive a message with the JMS API
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         // See if the message get sent to the listener
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 counter.incrementAndGet();
0:                 if( counter.get()==4 )
1:                     done.countDown();
1:             }
1:         });
1: 
1:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:         Thread.sleep(200);
1:         
1:         // Make sure only 4 messages were delivered.
1:         assertEquals(4, counter.get());
1:     }
1:     
0:     public void initCombosForTestMessageListenerUnackedWithPrefetch1StayInQueue() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) 
1:                 });
0:         addCombinationValues("ackMode", new Object[] { 
0:                 new Integer(Session.AUTO_ACKNOWLEDGE),
0:                 new Integer(Session.DUPS_OK_ACKNOWLEDGE), 
0:                 new Integer(Session.CLIENT_ACKNOWLEDGE) 
1:                 });
0:         addCombinationValues("destinationType", new Object[] { new Byte(ActiveMQDestination.QUEUE_TYPE), });
1:     }
1: 
0:     public void testMessageListenerUnackedWithPrefetch1StayInQueue() throws Throwable {
1: 
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch done = new CountDownLatch(1);
1: 
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
0:         // This test case does not work if optimized message dispatch is used as the main thread send block until the consumer receives the 
0:         // message.  This test depends on thread decoupling so that the main thread can stop the consumer thread.
1:         connection.setOptimizedMessageDispatch(false);
1:         connection.start();
1: 
1:         // Use all the ack modes
1:         Session session = connection.createSession(false, ackMode);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 try {
1:                     TextMessage tm = (TextMessage)m;
0:                     log.info("Got in first listener: "+tm.getText());
0:                     assertEquals( ""+counter.get(), tm.getText() );
1:                     counter.incrementAndGet();
1:                     m.acknowledge();
0:                     if( counter.get()==2 ) {
1:                             done.countDown();
0:                             Thread.sleep(500);
1:                     }
1:                 } catch (Throwable e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1:         
1:         // Wait for first 2 messages to arrive.
0:         assertTrue(done.await(100000, TimeUnit.MILLISECONDS));
1:         connection.close();
1: 
1:         // Re-start connection.
0:         connection = (ActiveMQConnection) factory.createConnection();
1:         connections.add(connection);
1:         
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         // Pickup the remaining messages.
1:         final CountDownLatch done2 = new CountDownLatch(1);
1:         session = connection.createSession(false, ackMode);
1:         consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 try {
1:                     TextMessage tm = (TextMessage)m;
0:                     log.info("Got in second listener: "+tm.getText());
0:                     assertEquals( ""+counter.get(), tm.getText() );
1:                     counter.incrementAndGet();
0:                     if( counter.get()==4 )
1:                         done2.countDown();
1:                 } catch (Throwable e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         assertTrue(done2.await(1000, TimeUnit.MILLISECONDS));
1:         Thread.sleep(200);
1:         
1:         // Make sure only 4 messages were delivered.
1:         assertEquals(4, counter.get());
1: 
1:     }
1: 
1:     
1:     public void initCombosForTestMessageListenerWithConsumerWithPrefetch1() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE) });
1:     }
0:     public void testMessageListenerWithConsumerWithPrefetch1() throws Throwable {
1: 
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch done = new CountDownLatch(1);
1:         
1:         // Receive a message with the JMS API
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1:         
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 counter.incrementAndGet();
0:                 if( counter.get()==4 )
1:                     done.countDown();
1:             }
1:         });
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:         Thread.sleep(200);
1:         
1:         // Make sure only 4 messages were delivered.
1:         assertEquals(4, counter.get());
1:     }
1: 
1:     public void initCombosForTestMessageListenerWithConsumer() {
0:         addCombinationValues("deliveryMode", new Object[] { 
0:                 new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE) });
1:     }
0:     public void testMessageListenerWithConsumer() throws Throwable {
1: 
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch done = new CountDownLatch(1);
1:         
1:         // Receive a message with the JMS API
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 counter.incrementAndGet();
0:                 if( counter.get()==4 )
1:                     done.countDown();
1:             }
1:         });
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:         Thread.sleep(200);
1:         
1:         // Make sure only 4 messages were delivered.
1:         assertEquals(4, counter.get());
1:     }
1: 
1:     public void initCombosForTestUnackedWithPrefetch1StayInQueue() {
0:         addCombinationValues("deliveryMode", new Object[] { new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("ackMode", new Object[] { new Integer(Session.AUTO_ACKNOWLEDGE),
0:                 new Integer(Session.DUPS_OK_ACKNOWLEDGE), new Integer(Session.CLIENT_ACKNOWLEDGE) });
0:         addCombinationValues("destinationType", new Object[] { new Byte(ActiveMQDestination.QUEUE_TYPE), });
1:     }
1: 
0:     public void testUnackedWithPrefetch1StayInQueue() throws Throwable {
1: 
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         // Use all the ack modes
1:         Session session = connection.createSession(false, ackMode);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1: 
1:         // Only pick up the first 2 messages.
1:         Message message = null;
1:         for (int i = 0; i < 2; i++) {
1:             message = consumer.receive(1000);
1:             assertNotNull(message);
1:         }
1:         message.acknowledge();
1: 
1:         connection.close();
0:         connection = (ActiveMQConnection) factory.createConnection();
1:         connections.add(connection);
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
1: 
1:         // Use all the ack modes
1:         session = connection.createSession(false, ackMode);
1:         consumer = session.createConsumer(destination);
1: 
1:         // Pickup the rest of the messages.
1:         for (int i = 0; i < 2; i++) {
1:             message = consumer.receive(1000);
1:             assertNotNull(message);
1:         }
1:         message.acknowledge();
1:         assertNull(consumer.receiveNoWait());
1: 
1:     }
1: 
1:     public void initCombosForTestDontStart() {
0:         addCombinationValues("deliveryMode", new Object[] { new Integer(DeliveryMode.NON_PERSISTENT), });
0:         addCombinationValues("destinationType", new Object[] { new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), });
1:     }
1: 
0:     public void testDontStart() throws Throwable {
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 1);
1: 
1:         // Make sure no messages were delivered.
0:         assertNull(consumer.receive(1000));
1:     }
1: 
1:     public void initCombosForTestStartAfterSend() {
0:         addCombinationValues("deliveryMode", new Object[] { new Integer(DeliveryMode.NON_PERSISTENT), });
0:         addCombinationValues("destinationType", new Object[] { new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), });
1:     }
1: 
0:     public void testStartAfterSend() throws Throwable {
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 1);
1: 
1:         // Start the conncection after the message was sent.
1:         connection.start();
1: 
1:         // Make sure only 1 message was delivered.
1:         assertNotNull(consumer.receive(1000));
1:         assertNull(consumer.receiveNoWait());
1:     }
1: 
1:     public void initCombosForTestReceiveMessageWithConsumer() {
0:         addCombinationValues("deliveryMode", new Object[] { new Integer(DeliveryMode.NON_PERSISTENT),
0:                 new Integer(DeliveryMode.PERSISTENT) });
0:         addCombinationValues("destinationType", new Object[] { new Byte(ActiveMQDestination.QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE) });
1:     }
1: 
0:     public void testReceiveMessageWithConsumer() throws Throwable {
1: 
1:         // Receive a message with the JMS API
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         sendMessages(session, destination, 1);
1: 
1:         // Make sure only 1 message was delivered.
1:         Message m = consumer.receive(1000);
1:         assertNotNull(m);
1:         assertEquals("0", ((TextMessage)m).getText());
1:         assertNull(consumer.receiveNoWait());
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JMSConsumerTest.class);
commit:444412f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:7343337
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("redelivered flag set", msg.getJMSRedelivered());
commit:2f65221
/////////////////////////////////////////////////////////////////////////
1:         Message message2 = consumer2.receive(5000);
commit:5a0f76d
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("message has \"no expiry\" text: " + msg.getText(), msg.getText().contains("no expiry"));
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:a707594
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Wrong inFlightCount: " + view.getInFlightCount(), 0, view.getInFlightCount());
1:         assertEquals("Wrong dispatch count: " + view.getDispatchCount(), 8, view.getDispatchCount());
1:         assertEquals("Wrong dequeue count: " + view.getDequeueCount(), 8, view.getDequeueCount());
commit:b997d25
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.ExceptionListener;
/////////////////////////////////////////////////////////////////////////
0: import javax.management.MBeanServer;
0: import javax.management.MBeanServerInvocationHandler;
1: import javax.management.ObjectName;
0: 
1: import org.apache.activemq.broker.jmx.DestinationViewMBean;
/////////////////////////////////////////////////////////////////////////
0:     
0:     
1:     public void initCombosForTestAckOfExpired() {
0:         addCombinationValues("destinationType", 
0:                 new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:     }
0:         
1:     public void testAckOfExpired() throws Exception {
1:         ActiveMQConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost?jms.prefetchPolicy.all=4&jms.sendAcksAsync=false");
1:         connection = fact.createActiveMQConnection();
0:         
1:         connection.start();
0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
1:         destination = (ActiveMQDestination) (destinationType == ActiveMQDestination.QUEUE_TYPE ?
1:                 session.createQueue("test") : session.createTopic("test"));
0:                     
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         connection.setStatsEnabled(true);
0:                 
0:         Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
0:             MessageProducer producer = sendSession.createProducer(destination);
0:         producer.setTimeToLive(1000);
1:         final int count = 4;
1:         for (int i = 0; i < count; i++) {
1:             TextMessage message = sendSession.createTextMessage("" + i);
1:             producer.send(message);
1:         }
0:         
1:         // let first bunch in queue expire
0:         Thread.sleep(1000);
0:         
1:         producer.setTimeToLive(0);
1:         for (int i = 0; i < count; i++) {
1:             TextMessage message = sendSession.createTextMessage("no expiry" + i);
1:             producer.send(message);
1:         }
0:         
1:         ActiveMQMessageConsumer amqConsumer = (ActiveMQMessageConsumer) consumer;
0:         
0:         for(int i=0; i<count; i++) {
1:             TextMessage msg = (TextMessage) amqConsumer.receive();
1:             assertNotNull(msg);
0:             assertTrue(msg.getText().contains("no expiry"));
0:             
1:             // force an ack when there are expired messages
0:             amqConsumer.acknowledge();         
1:         }
1:         assertEquals("consumer has expiredMessages", count, amqConsumer.getConsumerStats().getExpiredMessageCount().getCount());
0:     
1:         DestinationViewMBean view = createView(destination);
0:         
0:         assertTrue("Wrong inFlightCount: " + view.getInFlightCount(), (view.getDispatchCount() - view.getDequeueCount()) - view.getInFlightCount() < 5);
1:     }
0:     
1:     protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
0:          MBeanServer mbeanServer = broker.getManagementContext().getMBeanServer();
0:          String domain = "org.apache.activemq";
0:          ObjectName name;
1:         if (destination.isQueue()) {
0:             name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=test");
1:         } else {
0:             name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=test");
1:         }
0:         return (DestinationViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, name, DestinationViewMBean.class, true);
1:     }
commit:184761a
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() { 
0:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE)});
1:     public void testMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() throws Exception {
0:     
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch sendDone = new CountDownLatch(1);
1:         final CountDownLatch got2Done = new CountDownLatch(1);
1:         // Set prefetch to 1
1:         connection.getPrefetchPolicy().setAll(1);
1:         // This test case does not work if optimized message dispatch is used as
1:         // the main thread send block until the consumer receives the
1:         // message. This test depends on thread decoupling so that the main
1:         // thread can stop the consumer thread.
1:         connection.setOptimizedMessageDispatch(false);
1:         connection.start();
0: 
1:         // Use all the ack modes
1:         Session session = connection.createSession(false, ackMode);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 try {
1:                     TextMessage tm = (TextMessage)m;
1:                     LOG.info("Got in first listener: " + tm.getText());
0:                     assertEquals("" + counter.get(), tm.getText());
1:                     counter.incrementAndGet();
1:                     if (counter.get() == 2) {
0:                         sendDone.await();
0:                         connection.close();
1:                         got2Done.countDown();
1:                     }
1:                 } catch (Throwable e) {
0:                     e.printStackTrace();
1:                 }
1:             }
1:         });
0: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
1:         sendDone.countDown();
0: 
1:         // Wait for first 2 messages to arrive.
1:         assertTrue(got2Done.await(100000, TimeUnit.MILLISECONDS));
0: 
1:         // Re-start connection.
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
0: 
1:         connection.getPrefetchPolicy().setAll(1);
1:         connection.start();
0: 
1:         // Pickup the remaining messages.
1:         final CountDownLatch done2 = new CountDownLatch(1);
1:         session = connection.createSession(false, ackMode);
1:         consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) {
1:                 try {
1:                     TextMessage tm = (TextMessage)m;
1:                     LOG.info("Got in second listener: " + tm.getText());
1:                     // order is not guaranteed as the connection is started before the listener is set.
1:                     // assertEquals("" + counter.get(), tm.getText());
1:                     counter.incrementAndGet();
1:                     if (counter.get() == 4) {
1:                         done2.countDown();
1:                     }
1:                 } catch (Throwable e) {
1:                     LOG.error("unexpected ex onMessage: ", e);
1:                 }
1:             }
1:         });
0: 
1:         assertTrue(done2.await(1000, TimeUnit.MILLISECONDS));
1:         Thread.sleep(200);
0: 
0:         // assert msg 2 was redelivered as close() from onMessages() will only ack in auto_ack mode
0:         assertEquals(5, counter.get());      
1:     }
0: 
1:     public void initCombosForTestMessageListenerAutoAckOnCloseWithPrefetch1() {
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("ackMode", new Object[] {Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE)});
1:     }
0: 
1:     public void testMessageListenerAutoAckOnCloseWithPrefetch1() throws Exception {
0:     
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("unexpected ex onMessage: ", e);
/////////////////////////////////////////////////////////////////////////
1:         // close from onMessage with Auto_ack will ack
commit:9a60743
/////////////////////////////////////////////////////////////////////////
1: import java.lang.Thread.UncaughtExceptionHandler;
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
0: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.Collections;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void testMessageListenerWithConsumerCanBeStoppedConcurently() throws Exception {
0: 
1:         final AtomicInteger counter = new AtomicInteger(0);
1:         final CountDownLatch closeDone = new CountDownLatch(1);
0:         
1:         connection.start();
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
0: 
1:         // preload the queue
1:         sendMessages(session, destination, 2000);
0:         
0: 
1:         final ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)session.createConsumer(destination);
0:        
0:         final Map<Thread, Throwable> exceptions = 
1:             Collections.synchronizedMap(new HashMap<Thread, Throwable>());
1:         Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
1:             public void uncaughtException(Thread t, Throwable e) {
1:                 LOG.error("Uncaught exception:", e);
1:                 exceptions.put(t, e);
1:             }
0:         });
0:         
0:         final class AckAndClose implements Runnable {            
0:             private Message message;
0: 
1:             public AckAndClose(Message m) {
1:                 this.message = m;
1:             }
0: 
1:             public void run() {
0:                 try {   
1:                     int count = counter.incrementAndGet();
1:                     if (count == 590) {
1:                         // close in a separate thread is ok by jms
1:                         consumer.close();
1:                         closeDone.countDown();
1:                     }
1:                     if (count % 200 == 0) {
1:                         // ensure there are some outstanding messages
1:                         // ack every 200
0:                         message.acknowledge();
1:                     }
0:                 } catch (Exception e) {        
1:                     LOG.error("Exception on close or ack:", e);
1:                     exceptions.put(Thread.currentThread(), e);
1:                 } 
1:             }  
1:         };
0:     
1:         final ExecutorService executor = Executors.newCachedThreadPool();
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message m) { 
1:                 // ack and close eventually in separate thread
1:                 executor.execute(new AckAndClose(m));
1:             }
0:         });
0: 
1:         assertTrue(closeDone.await(20, TimeUnit.SECONDS));
1:         // await possible exceptions
0:         Thread.sleep(1000);
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:     }
0: 
0:     
commit:3804d66
/////////////////////////////////////////////////////////////////////////
1:         sendMessages(connection, destination, 2);
1:         assertNotNull(consumer.receive(1000));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
0:         
1:         msg = redispatchConsumer.receive(1000);
1:         assertNotNull(msg);
1:         assertTrue(msg.getJMSRedelivered());
1:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
/////////////////////////////////////////////////////////////////////////
1:         sendMessages(connection, destination, 2);
1:         assertNotNull(consumer.receive(1000));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
1:         msg = redispatchConsumer.receive(1000);
1:         assertNotNull(msg);
1:         assertTrue(msg.getJMSRedelivered());
1:         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
commit:50a98e3
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void testRedispatchOfRolledbackTx() throws Exception {
0: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
0:         
0:         sendMessages(connection, destination, 1);
0:         
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         assertNotNull(consumer.receive(1000));
0:         
1:         // install another consumer while message dispatch is unacked/uncommitted
1:         Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer redispatchConsumer = redispatchSession.createConsumer(destination);
0: 
1:         session.rollback();
1:         session.close();
0:                 
1:         Message msg = redispatchConsumer.receive(1000);
1:         assertNotNull(msg);
1:         assertTrue(msg.getJMSRedelivered());
0:         // should have re-delivery of 2, one for re-dispatch, one for rollback which is a little too much!
0:         assertEquals(3, msg.getLongProperty("JMSXDeliveryCount"));
1:         redispatchSession.commit();
0:         
1:         assertNull(redispatchConsumer.receive(500));
1:         redispatchSession.close();
1:     }
0: 
commit:0bfb28a
/////////////////////////////////////////////////////////////////////////
1:         // no commit so will auto rollback and get re-dispatched to redisptachConsumer
1:         Message msg = redispatchConsumer.receive(1000);
1:         assertNotNull(msg);
0:         assertTrue(msg.getJMSRedelivered());
0:         // should have re-delivery of 2, one for re-dispatch, one for rollback which is a little too much!
0:         assertEquals(3, msg.getLongProperty("JMSXDeliveryCount"));
commit:92e1431
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void testRedispatchOfUncommittedTx() throws Exception {
0: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         destination = createDestination(session, ActiveMQDestination.QUEUE_TYPE);
0:         
0:         sendMessages(connection, destination, 1);
0:         
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         assertNotNull(consumer.receive(1000));
0:         
1:         // install another consumer while message dispatch is unacked/uncommitted
1:         Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer redispatchConsumer = redispatchSession.createConsumer(destination);
0: 
0:         // no commit so will auto rollback and get redispatched to redisptachConsumer
1:         session.close();
0:                 
0:         assertNotNull(redispatchConsumer.receive(1000));
1:         redispatchSession.commit();
0:         
1:         assertNull(redispatchConsumer.receive(500));
1:         redispatchSession.close();
1:     }
0:     
commit:8b34eac
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("unexpected ex onMessage: ", e);
author:James Strachan
-------------------------------------------------------------------------------
commit:fba0742
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestPassMessageListenerIntoCreateConsumer() {
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:     }
0: 
1:     public void testPassMessageListenerIntoCreateConsumer() throws Exception {
0: 
1:         final AtomicInteger counter = new AtomicInteger(0);
0:         final CountDownLatch done = new CountDownLatch(1);
0: 
1:         // Receive a message with the JMS API
1:         connection.start();
1:         ActiveMQSession session = (ActiveMQSession) connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         destination = createDestination(session, destinationType);
1:         MessageConsumer consumer = session.createConsumer(destination, new MessageListener() {
0:             public void onMessage(Message m) {
1:                 counter.incrementAndGet();
1:                 if (counter.get() == 4) {
0:                     done.countDown();
1:                 }
1:             }
0:         });
0: 
1:         // Send the messages
1:         sendMessages(session, destination, 4);
0: 
1:         assertTrue(done.await(1000, TimeUnit.MILLISECONDS));
1:         Thread.sleep(200);
0: 
1:         // Make sure only 4 messages were delivered.
1:         assertEquals(4, counter.get());
1:     }
0: 
============================================================================