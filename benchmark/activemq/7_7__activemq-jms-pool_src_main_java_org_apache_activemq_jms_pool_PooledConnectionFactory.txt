1:b65c0d1: /*
1:b66559e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b66559e:  * contributor license agreements.  See the NOTICE file distributed with
1:b66559e:  * this work for additional information regarding copyright ownership.
1:b66559e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b66559e:  * (the "License"); you may not use this file except in compliance with
1:b66559e:  * the License.  You may obtain a copy of the License at
2:b66559e:  *
1:b66559e:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b66559e:  *
1:b66559e:  * Unless required by applicable law or agreed to in writing, software
1:b66559e:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b66559e:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b66559e:  * See the License for the specific language governing permissions and
1:b66559e:  * limitations under the License.
1:b66559e:  */
1:b66559e: package org.apache.activemq.jms.pool;
17:b66559e: 
1:b432173: import java.util.Properties;
1:b66559e: import java.util.concurrent.atomic.AtomicBoolean;
1:878e3a1: import java.util.concurrent.atomic.AtomicReference;
1:b66559e: 
1:b66559e: import javax.jms.Connection;
1:b66559e: import javax.jms.ConnectionFactory;
1:b66559e: import javax.jms.JMSException;
1:459593c: import javax.jms.QueueConnection;
1:459593c: import javax.jms.QueueConnectionFactory;
1:459593c: import javax.jms.TopicConnection;
1:459593c: import javax.jms.TopicConnectionFactory;
1:d872994: 
1:6d6ed4e: import org.apache.commons.pool2.KeyedPooledObjectFactory;
1:6d6ed4e: import org.apache.commons.pool2.PooledObject;
1:6d6ed4e: import org.apache.commons.pool2.impl.DefaultPooledObject;
1:6d6ed4e: import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
1:7c7c505: import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
1:b66559e: import org.slf4j.Logger;
1:b66559e: import org.slf4j.LoggerFactory;
1:b66559e: 
2:b66559e: /**
1:b66559e:  * A JMS provider which pools Connection, Session and MessageProducer instances
1:b66559e:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's
1:b66559e:  * <a href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
1:b66559e:  * Connections, sessions and producers are returned to a pool after use so that they can be reused later
1:b66559e:  * without having to undergo the cost of creating them again.
1:b66559e:  *
1:b66559e:  * b>NOTE:</b> while this implementation does allow the creation of a collection of active consumers,
1:b66559e:  * it does not 'pool' consumers. Pooling makes sense for connections, sessions and producers, which
1:b66559e:  * are expensive to create and can remain idle a minimal cost. Consumers, on the other hand, are usually
1:b66559e:  * just created at startup and left active, handling incoming messages as they come. When a consumer is
1:b66559e:  * complete, it is best to close it rather than return it to a pool for later reuse: this is because,
1:b66559e:  * even if a consumer is idle, ActiveMQ will keep delivering messages to the consumer's prefetch buffer,
1:b66559e:  * where they'll get held until the consumer is active again.
1:b66559e:  *
1:b66559e:  * If you are creating a collection of consumers (for example, for multi-threaded message consumption), you
1:b66559e:  * might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that
1:b66559e:  * all messages don't end up going to just one of the consumers. See this FAQ entry for more detail:
1:b66559e:  * http://activemq.apache.org/i-do-not-receive-messages-in-my-second-consumer.html
1:b66559e:  *
1:b66559e:  * Optionally, one may configure the pool to examine and possibly evict objects as they sit idle in the
1:b66559e:  * pool. This is performed by an "idle object eviction" thread, which runs asynchronously. Caution should
1:b66559e:  * be used when configuring this optional feature. Eviction runs contend with client threads for access
1:b66559e:  * to objects in the pool, so if they run too frequently performance issues may result. The idle object
1:b66559e:  * eviction thread may be configured using the {@link org.apache.activemq.jms.pool.PooledConnectionFactory#setTimeBetweenExpirationCheckMillis} method.  By
1:b66559e:  * default the value is -1 which means no eviction thread will be run.  Set to a non-negative value to
1:b66559e:  * configure the idle eviction thread to run.
1:b66559e:  */
1:459593c: public class PooledConnectionFactory implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory {
1:b66559e:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledConnectionFactory.class);
1:b66559e: 
1:b66559e:     protected final AtomicBoolean stopped = new AtomicBoolean(false);
1:b66559e:     private GenericKeyedObjectPool<ConnectionKey, ConnectionPool> connectionsPool;
1:b66559e: 
1:577b29c:     protected Object connectionFactory;
1:b66559e: 
1:b66559e:     private int maximumActiveSessionPerConnection = 500;
1:b66559e:     private int idleTimeout = 30 * 1000;
1:b66559e:     private boolean blockIfSessionPoolIsFull = true;
1:dc607bb:     private long blockIfSessionPoolIsFullTimeout = -1L;
1:b66559e:     private long expiryTimeout = 0l;
1:b66559e:     private boolean createConnectionOnStartup = true;
1:2a7c349:     private boolean useAnonymousProducers = true;
1:b53d8ea:     private boolean reconnectOnException = true;
1:b66559e: 
1:878e3a1:     // Temporary value used to always fetch the result of makeObject.
1:878e3a1:     private final AtomicReference<ConnectionPool> mostRecentlyCreated = new AtomicReference<ConnectionPool>(null);
1:878e3a1: 
1:b66559e:     public void initConnectionsPool() {
1:b66559e:         if (this.connectionsPool == null) {
1:7c7c505:             final GenericKeyedObjectPoolConfig poolConfig = new GenericKeyedObjectPoolConfig();
1:7c7c505:             poolConfig.setJmxEnabled(false);
1:b66559e:             this.connectionsPool = new GenericKeyedObjectPool<ConnectionKey, ConnectionPool>(
1:6d6ed4e:                 new KeyedPooledObjectFactory<ConnectionKey, ConnectionPool>() {
1:d872994:                     @Override
1:6d6ed4e:                     public PooledObject<ConnectionPool> makeObject(ConnectionKey connectionKey) throws Exception {
1:6d6ed4e:                         Connection delegate = createConnection(connectionKey);
1:d872994: 
1:d872994:                         ConnectionPool connection = createConnectionPool(delegate);
1:d872994:                         connection.setIdleTimeout(getIdleTimeout());
1:d872994:                         connection.setExpiryTimeout(getExpiryTimeout());
1:d872994:                         connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());
1:d872994:                         connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());
1:dc607bb:                         if (isBlockIfSessionPoolIsFull() && getBlockIfSessionPoolIsFullTimeout() > 0) {
1:dc607bb:                             connection.setBlockIfSessionPoolIsFullTimeout(getBlockIfSessionPoolIsFullTimeout());
1:d872994:                         }
1:2a7c349:                         connection.setUseAnonymousProducers(isUseAnonymousProducers());
1:b53d8ea:                         connection.setReconnectOnException(isReconnectOnException());
1:6d6ed4e: 
1:b65c0d1:                         LOG.trace("Created new connection: {}", connection);
1:6d6ed4e: 
1:878e3a1:                         PooledConnectionFactory.this.mostRecentlyCreated.set(connection);
1:878e3a1: 
1:6d6ed4e:                         return new DefaultPooledObject<ConnectionPool>(connection);
1:d872994:                     }
1:b66559e: 
1:d872994:                     @Override
1:6d6ed4e:                     public void destroyObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {
1:6d6ed4e:                         ConnectionPool connection = pooledObject.getObject();
1:d872994:                         try {
1:b65c0d1:                             LOG.trace("Destroying connection: {}", connection);
1:d872994:                             connection.close();
1:d872994:                         } catch (Exception e) {
1:d872994:                             LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
1:d872994:                         }
1:d872994:                     }
1:d872994: 
1:d872994:                     @Override
1:6d6ed4e:                     public boolean validateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) {
1:6d6ed4e:                         ConnectionPool connection = pooledObject.getObject();
1:d872994:                         if (connection != null && connection.expiredCheck()) {
1:b65c0d1:                             LOG.trace("Connection has expired: {} and will be destroyed", connection);
1:d872994:                             return false;
1:d872994:                         }
1:d872994: 
1:d872994:                         return true;
1:d872994:                     }
1:d872994: 
1:d872994:                     @Override
1:6d6ed4e:                     public void activateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {
1:d872994:                     }
1:d872994: 
1:d872994:                     @Override
1:6d6ed4e:                     public void passivateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {
1:d872994:                     }
1:d872994: 
1:7c7c505:                 }, poolConfig);
1:6d6ed4e: 
1:b66559e:             // Set max idle (not max active) since our connections always idle in the pool.
1:6d6ed4e:             this.connectionsPool.setMaxIdlePerKey(1);
1:878e3a1:             this.connectionsPool.setLifo(false);
1:b66559e: 
1:b66559e:             // We always want our validate method to control when idle objects are evicted.
1:b66559e:             this.connectionsPool.setTestOnBorrow(true);
1:b66559e:             this.connectionsPool.setTestWhileIdle(true);
1:d872994:         }
1:d872994:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * @return the currently configured ConnectionFactory used to create the pooled Connections.
1:b66559e:      */
1:577b29c:     public Object getConnectionFactory() {
1:b66559e:         return connectionFactory;
1:6d6ed4e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Sets the ConnectionFactory used to create new pooled Connections.
1:b66559e:      * <p/>
1:b66559e:      * Updates to this value do not affect Connections that were previously created and placed
1:b66559e:      * into the pool.  In order to allocate new Connections based off this new ConnectionFactory
1:9ae2264:      * it is first necessary to {@link #clear} the pooled Connections.
1:b66559e:      *
1:b66559e:      * @param toUse
1:b66559e:      *      The factory to use to create pooled Connections.
1:b66559e:      */
1:577b29c:     public void setConnectionFactory(final Object toUse) {
1:577b29c:         if (toUse instanceof ConnectionFactory) {
1:b66559e:             this.connectionFactory = toUse;
1:577b29c:         } else {
1:991d69f:             throw new IllegalArgumentException("connectionFactory should implement javax.jms.ConnectionFactory");
1:6d6ed4e:         }
1:6d6ed4e:     }
1:b66559e: 
1:d872994:     @Override
1:459593c:     public QueueConnection createQueueConnection() throws JMSException {
1:459593c:         return (QueueConnection) createConnection();
1:459593c:     }
1:459593c: 
1:459593c:     @Override
1:459593c:     public QueueConnection createQueueConnection(String userName, String password) throws JMSException {
1:459593c:         return (QueueConnection) createConnection(userName, password);
1:459593c:     }
1:459593c: 
1:459593c:     @Override
1:459593c:     public TopicConnection createTopicConnection() throws JMSException {
1:459593c:         return (TopicConnection) createConnection();
1:459593c:     }
1:459593c: 
1:459593c:     @Override
1:459593c:     public TopicConnection createTopicConnection(String userName, String password) throws JMSException {
1:459593c:         return (TopicConnection) createConnection(userName, password);
1:459593c:     }
1:459593c: 
1:459593c:     @Override
1:d872994:     public Connection createConnection() throws JMSException {
1:b66559e:         return createConnection(null, null);
1:6d6ed4e:     }
1:b66559e: 
1:d872994:     @Override
1:b66559e:     public synchronized Connection createConnection(String userName, String password) throws JMSException {
1:b66559e:         if (stopped.get()) {
1:b66559e:             LOG.debug("PooledConnectionFactory is stopped, skip create new connection.");
1:b66559e:             return null;
1:dc607bb:         }
1:b66559e: 
1:b66559e:         ConnectionPool connection = null;
1:b66559e:         ConnectionKey key = new ConnectionKey(userName, password);
1:b66559e: 
1:b66559e:         // This will either return an existing non-expired ConnectionPool or it
1:b66559e:         // will create a new one to meet the demand.
1:b66559e:         if (getConnectionsPool().getNumIdle(key) < getMaxConnections()) {
1:6d6ed4e:             try {
1:b66559e:                 connectionsPool.addObject(key);
1:878e3a1:                 connection = mostRecentlyCreated.getAndSet(null);
1:878e3a1:                 connection.incrementReferenceCount();
1:6d6ed4e:             } catch (Exception e) {
1:b66559e:                 throw createJmsException("Error while attempting to add new Connection to the pool", e);
22:b66559e:             }
2:b66559e:         } else {
1:878e3a1:             try {
1:878e3a1:                 // We can race against other threads returning the connection when there is an
1:878e3a1:                 // expiration or idle timeout.  We keep pulling out ConnectionPool instances until
1:878e3a1:                 // we win and get a non-closed instance and then increment the reference count
1:878e3a1:                 // under lock to prevent another thread from triggering an expiration check and
1:878e3a1:                 // pulling the rug out from under us.
1:878e3a1:                 while (connection == null) {
1:878e3a1:                     connection = connectionsPool.borrowObject(key);
1:878e3a1:                     synchronized (connection) {
1:878e3a1:                         if (connection.getConnection() != null) {
1:878e3a1:                             connection.incrementReferenceCount();
1:878e3a1:                             break;
1:878e3a1:                         }
1:b66559e: 
1:878e3a1:                         // Return the bad one to the pool and let if get destroyed as normal.
1:878e3a1:                         connectionsPool.returnObject(key, connection);
1:878e3a1:                         connection = null;
1:b66559e:                     }
1:b66559e:                 }
1:878e3a1:             } catch (Exception e) {
1:878e3a1:                 throw createJmsException("Error while attempting to retrieve a connection from the pool", e);
1:b66559e:             }
1:b66559e: 
1:878e3a1:             try {
1:878e3a1:                 connectionsPool.returnObject(key, connection);
1:878e3a1:             } catch (Exception e) {
1:878e3a1:                 throw createJmsException("Error when returning connection to the pool", e);
1:878e3a1:             }
1:b66559e:         }
1:b66559e: 
1:b66559e:         return newPooledConnection(connection);
1:b66559e:     }
1:b66559e: 
1:b66559e:     protected Connection newPooledConnection(ConnectionPool connection) {
1:b66559e:         return new PooledConnection(connection);
1:b66559e:     }
1:b66559e: 
1:b66559e:     private JMSException createJmsException(String msg, Exception cause) {
1:b66559e:         JMSException exception = new JMSException(msg);
1:b66559e:         exception.setLinkedException(cause);
1:b66559e:         exception.initCause(cause);
1:b66559e:         return exception;
1:b66559e:     }
1:b66559e: 
1:b66559e:     protected Connection createConnection(ConnectionKey key) throws JMSException {
1:577b29c:         if (connectionFactory instanceof ConnectionFactory) {
1:577b29c:             if (key.getUserName() == null && key.getPassword() == null) {
1:577b29c:                 return ((ConnectionFactory) connectionFactory).createConnection();
1:577b29c:             } else {
1:577b29c:                 return ((ConnectionFactory) connectionFactory).createConnection(key.getUserName(), key.getPassword());
1:577b29c:             }
1:b66559e:         } else {
1:577b29c:             throw new IllegalStateException("connectionFactory should implement javax.jms.ConnectionFactory");
1:b66559e:         }
1:b66559e:     }
1:b66559e: 
1:b66559e:     public void start() {
1:b66559e:         LOG.debug("Staring the PooledConnectionFactory: create on start = {}", isCreateConnectionOnStartup());
1:b66559e:         stopped.set(false);
1:b66559e:         if (isCreateConnectionOnStartup()) {
5:b66559e:             try {
1:b66559e:                 // warm the pool by creating a connection during startup
1:c6d0aaa:                 createConnection().close();
1:b66559e:             } catch (JMSException e) {
1:b66559e:                 LOG.warn("Create pooled connection during start failed. This exception will be ignored.", e);
1:b66559e:             }
1:b66559e:         }
1:b66559e:     }
1:b66559e: 
1:b66559e:     public void stop() {
1:b66559e:         if (stopped.compareAndSet(false, true)) {
1:b66559e:             LOG.debug("Stopping the PooledConnectionFactory, number of connections in cache: {}",
1:b65c0d1:                       connectionsPool != null ? connectionsPool.getNumActive() : 0);
1:b66559e:             try {
1:b66559e:                 if (connectionsPool != null) {
1:b66559e:                     connectionsPool.close();
1:0706fd0:                     connectionsPool = null;
1:b66559e:                 }
5:b66559e:             } catch (Exception e) {
1:b66559e:             }
1:b66559e:         }
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Clears all connections from the pool.  Each connection that is currently in the pool is
1:b66559e:      * closed and removed from the pool.  A new connection will be created on the next call to
1:9ae2264:      * {@link #createConnection}.  Care should be taken when using this method as Connections that
1:b66559e:      * are in use be client's will be closed.
1:b66559e:      */
1:b66559e:     public void clear() {
1:b66559e:         if (stopped.get()) {
1:b66559e:             return;
1:b66559e:         }
1:b66559e: 
1:b66559e:         getConnectionsPool().clear();
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Returns the currently configured maximum number of sessions a pooled Connection will
1:b66559e:      * create before it either blocks or throws an exception when a new session is requested,
1:b66559e:      * depending on configuration.
1:b66559e:      *
1:b66559e:      * @return the number of session instances that can be taken from a pooled connection.
1:b66559e:      */
1:b66559e:     public int getMaximumActiveSessionPerConnection() {
1:b66559e:         return maximumActiveSessionPerConnection;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Sets the maximum number of active sessions per connection
1:b66559e:      *
1:b66559e:      * @param maximumActiveSessionPerConnection
1:b66559e:      *      The maximum number of active session per connection in the pool.
1:b66559e:      */
1:b66559e:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
1:b66559e:         this.maximumActiveSessionPerConnection = maximumActiveSessionPerConnection;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Controls the behavior of the internal session pool. By default the call to
1:b66559e:      * Connection.getSession() will block if the session pool is full.  If the
1:b66559e:      * argument false is given, it will change the default behavior and instead the
1:b66559e:      * call to getSession() will throw a JMSException.
1:b66559e:      *
1:b66559e:      * The size of the session pool is controlled by the @see #maximumActive
1:b66559e:      * property.
1:b66559e:      *
1:b66559e:      * @param block - if true, the call to getSession() blocks if the pool is full
1:b66559e:      * until a session object is available.  defaults to true.
1:b66559e:      */
1:b66559e:     public void setBlockIfSessionPoolIsFull(boolean block) {
1:b66559e:         this.blockIfSessionPoolIsFull = block;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Returns whether a pooled Connection will enter a blocked state or will throw an Exception
1:b66559e:      * once the maximum number of sessions has been borrowed from the the Session Pool.
1:b66559e:      *
1:b66559e:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:dc607bb:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:b66559e:      */
1:b66559e:     public boolean isBlockIfSessionPoolIsFull() {
1:b66559e:         return this.blockIfSessionPoolIsFull;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Returns the maximum number to pooled Connections that this factory will allow before it
1:9ae2264:      * begins to return connections from the pool on calls to ({@link #createConnection}.
1:b66559e:      *
1:b66559e:      * @return the maxConnections that will be created for this pool.
1:b66559e:      */
1:b66559e:     public int getMaxConnections() {
1:6d6ed4e:         return getConnectionsPool().getMaxIdlePerKey();
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Sets the maximum number of pooled Connections (defaults to one).  Each call to
1:9ae2264:      * {@link #createConnection} will result in a new Connection being create up to the max
1:b66559e:      * connections value.
1:b66559e:      *
1:b66559e:      * @param maxConnections the maxConnections to set
1:b66559e:      */
1:b66559e:     public void setMaxConnections(int maxConnections) {
1:6d6ed4e:         getConnectionsPool().setMaxIdlePerKey(maxConnections);
1:6d6ed4e:         getConnectionsPool().setMaxTotalPerKey(maxConnections);
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Gets the Idle timeout value applied to new Connection's that are created by this pool.
1:b66559e:      * <p/>
1:b66559e:      * The idle timeout is used determine if a Connection instance has sat to long in the pool unused
1:b66559e:      * and if so is closed and removed from the pool.  The default value is 30 seconds.
1:b66559e:      *
1:b66559e:      * @return idle timeout value (milliseconds)
1:b66559e:      */
1:b66559e:     public int getIdleTimeout() {
1:b66559e:         return idleTimeout;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Sets the idle timeout  value for Connection's that are created by this pool in Milliseconds,
1:b66559e:      * defaults to 30 seconds.
1:b66559e:      * <p/>
1:b66559e:      * For a Connection that is in the pool but has no current users the idle timeout determines how
1:b66559e:      * long the Connection can live before it is eligible for removal from the pool.  Normally the
1:b66559e:      * connections are tested when an attempt to check one out occurs so a Connection instance can sit
1:b66559e:      * in the pool much longer than its idle timeout if connections are used infrequently.
1:b66559e:      *
1:b66559e:      * @param idleTimeout
1:b66559e:      *      The maximum time a pooled Connection can sit unused before it is eligible for removal.
1:b66559e:      */
1:b66559e:     public void setIdleTimeout(int idleTimeout) {
1:b66559e:         this.idleTimeout = idleTimeout;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * allow connections to expire, irrespective of load or idle time. This is useful with failover
1:b66559e:      * to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery
1:b66559e:      *
1:b66559e:      * @param expiryTimeout non zero in milliseconds
1:b66559e:      */
1:b66559e:     public void setExpiryTimeout(long expiryTimeout) {
1:b66559e:         this.expiryTimeout = expiryTimeout;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * @return the configured expiration timeout for connections in the pool.
1:b66559e:      */
1:b66559e:     public long getExpiryTimeout() {
1:b66559e:         return expiryTimeout;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * @return true if a Connection is created immediately on a call to {@link start}.
1:b66559e:      */
1:b66559e:     public boolean isCreateConnectionOnStartup() {
1:b66559e:         return createConnectionOnStartup;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Whether to create a connection on starting this {@link PooledConnectionFactory}.
1:b66559e:      * <p/>
1:b66559e:      * This can be used to warm-up the pool on startup. Notice that any kind of exception
1:b66559e:      * happens during startup is logged at WARN level and ignored.
1:b66559e:      *
1:b66559e:      * @param createConnectionOnStartup <tt>true</tt> to create a connection on startup
1:b66559e:      */
1:b66559e:     public void setCreateConnectionOnStartup(boolean createConnectionOnStartup) {
1:b66559e:         this.createConnectionOnStartup = createConnectionOnStartup;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:2a7c349:      * Should Sessions use one anonymous producer for all producer requests or should a new
1:2a7c349:      * MessageProducer be created for each request to create a producer object, default is true.
1:2a7c349:      *
1:2a7c349:      * When enabled the session only needs to allocate one MessageProducer for all requests and
1:2a7c349:      * the MessageProducer#send(destination, message) method can be used.  Normally this is the
1:2a7c349:      * right thing to do however it does result in the Broker not showing the producers per
1:2a7c349:      * destination.
1:2a7c349:      *
1:2a7c349:      * @return true if a PooledSession will use only a single anonymous message producer instance.
1:2a7c349:      */
1:2a7c349:     public boolean isUseAnonymousProducers() {
1:2a7c349:         return this.useAnonymousProducers;
1:2a7c349:     }
1:2a7c349: 
1:2a7c349:     /**
1:2a7c349:      * Sets whether a PooledSession uses only one anonymous MessageProducer instance or creates
1:2a7c349:      * a new MessageProducer for each call the create a MessageProducer.
1:2a7c349:      *
1:2a7c349:      * @param value
1:2a7c349:      *      Boolean value that configures whether anonymous producers are used.
1:2a7c349:      */
1:2a7c349:     public void setUseAnonymousProducers(boolean value) {
1:2a7c349:         this.useAnonymousProducers = value;
1:2a7c349:     }
1:2a7c349: 
1:2a7c349:     /**
1:b66559e:      * Gets the Pool of ConnectionPool instances which are keyed by different ConnectionKeys.
1:b66559e:      *
1:b66559e:      * @return this factories pool of ConnectionPool instances.
1:b66559e:      */
1:b66559e:     protected GenericKeyedObjectPool<ConnectionKey, ConnectionPool> getConnectionsPool() {
1:b66559e:         initConnectionsPool();
1:b66559e:         return this.connectionsPool;
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Sets the number of milliseconds to sleep between runs of the idle Connection eviction thread.
1:b66559e:      * When non-positive, no idle object eviction thread will be run, and Connections will only be
1:b66559e:      * checked on borrow to determine if they have sat idle for too long or have failed for some
1:b66559e:      * other reason.
1:b66559e:      * <p/>
1:b66559e:      * By default this value is set to -1 and no expiration thread ever runs.
1:b66559e:      *
1:b66559e:      * @param timeBetweenExpirationCheckMillis
1:b66559e:      *      The time to wait between runs of the idle Connection eviction thread.
1:b66559e:      */
1:b66559e:     public void setTimeBetweenExpirationCheckMillis(long timeBetweenExpirationCheckMillis) {
1:b66559e:         getConnectionsPool().setTimeBetweenEvictionRunsMillis(timeBetweenExpirationCheckMillis);
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * @return the number of milliseconds to sleep between runs of the idle connection eviction thread.
1:b66559e:      */
1:b66559e:     public long getTimeBetweenExpirationCheckMillis() {
1:b66559e:         return getConnectionsPool().getTimeBetweenEvictionRunsMillis();
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * @return the number of Connections currently in the Pool
1:b66559e:      */
1:b66559e:     public int getNumConnections() {
1:b66559e:         return getConnectionsPool().getNumIdle();
1:b66559e:     }
1:b66559e: 
1:b66559e:     /**
1:b66559e:      * Delegate that creates each instance of an ConnectionPool object.  Subclasses can override
1:b66559e:      * this method to customize the type of connection pool returned.
1:b66559e:      *
1:b66559e:      * @param connection
1:b66559e:      *
1:b66559e:      * @return instance of a new ConnectionPool.
1:b66559e:      */
1:b66559e:     protected ConnectionPool createConnectionPool(Connection connection) {
1:b66559e:         return new ConnectionPool(connection);
1:b66559e:     }
1:dc607bb: 
1:dc607bb:     /**
1:dc607bb:      * Returns the timeout to use for blocking creating new sessions
1:dc607bb:      *
1:dc607bb:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:dc607bb:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:dc607bb:      */
1:dc607bb:     public long getBlockIfSessionPoolIsFullTimeout() {
1:dc607bb:         return blockIfSessionPoolIsFullTimeout;
1:dc607bb:     }
1:dc607bb: 
1:dc607bb:     /**
1:dc607bb:      * Controls the behavior of the internal session pool. By default the call to
1:dc607bb:      * Connection.getSession() will block if the session pool is full.  This setting
1:dc607bb:      * will affect how long it blocks and throws an exception after the timeout.
1:dc607bb:      *
1:dc607bb:      * The size of the session pool is controlled by the @see #maximumActive
1:dc607bb:      * property.
1:dc607bb:      *
1:dc607bb:      * Whether or not the call to create session blocks is controlled by the @see #blockIfSessionPoolIsFull
1:dc607bb:      * property
1:dc607bb:      *
1:dc607bb:      * @param blockIfSessionPoolIsFullTimeout - if blockIfSessionPoolIsFullTimeout is true,
1:dc607bb:      *                                        then use this setting to configure how long to block before retry
1:dc607bb:      */
1:dc607bb:     public void setBlockIfSessionPoolIsFullTimeout(long blockIfSessionPoolIsFullTimeout) {
1:dc607bb:         this.blockIfSessionPoolIsFullTimeout = blockIfSessionPoolIsFullTimeout;
1:dc607bb:     }
1:b432173: 
1:b432173:     /**
1:b53d8ea:      * @return true if the underlying connection will be renewed on JMSException, false otherwise
1:b53d8ea:      */
1:b53d8ea:     public boolean isReconnectOnException() {
1:b53d8ea:         return reconnectOnException;
1:b53d8ea:     }
1:b53d8ea: 
1:b53d8ea:     /**
1:b53d8ea:      * Controls weather the underlying connection should be reset (and renewed) on JMSException
1:b53d8ea:      *
1:b53d8ea:      * @param reconnectOnException
1:b53d8ea:      *          Boolean value that configures whether reconnect on exception should happen
1:b53d8ea:      */
1:b53d8ea:     public void setReconnectOnException(boolean reconnectOnException) {
1:b53d8ea:         this.reconnectOnException = reconnectOnException;
1:b53d8ea:     }
1:b53d8ea: 
1:b53d8ea:     /**
1:b432173:      * Called by any superclass that implements a JNDIReferencable or similar that needs to collect
1:b432173:      * the properties of this class for storage etc.
1:b432173:      *
1:b432173:      * This method should be updated any time there is a new property added.
1:b432173:      *
1:b432173:      * @param props
1:b432173:      *        a properties object that should be filled in with this objects property values.
1:b432173:      */
1:b432173:     protected void populateProperties(Properties props) {
1:b432173:         props.setProperty("maximumActiveSessionPerConnection", Integer.toString(getMaximumActiveSessionPerConnection()));
1:b432173:         props.setProperty("maxConnections", Integer.toString(getMaxConnections()));
1:b432173:         props.setProperty("idleTimeout", Integer.toString(getIdleTimeout()));
1:b432173:         props.setProperty("expiryTimeout", Long.toString(getExpiryTimeout()));
1:b432173:         props.setProperty("timeBetweenExpirationCheckMillis", Long.toString(getTimeBetweenExpirationCheckMillis()));
1:b432173:         props.setProperty("createConnectionOnStartup", Boolean.toString(isCreateConnectionOnStartup()));
1:b432173:         props.setProperty("useAnonymousProducers", Boolean.toString(isUseAnonymousProducers()));
1:b432173:         props.setProperty("blockIfSessionPoolIsFullTimeout", Long.toString(getBlockIfSessionPoolIsFullTimeout()));
1:b53d8ea:         props.setProperty("reconnectOnException", Boolean.toString(isReconnectOnException()));
1:b432173:     }
1:b66559e: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:0706fd0
/////////////////////////////////////////////////////////////////////////
1:                     connectionsPool = null;
commit:b65c0d1
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         LOG.trace("Created new connection: {}", connection);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.trace("Destroying connection: {}", connection);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.trace("Connection has expired: {} and will be destroyed", connection);
/////////////////////////////////////////////////////////////////////////
1:                       connectionsPool != null ? connectionsPool.getNumActive() : 0);
/////////////////////////////////////////////////////////////////////////
commit:b432173
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Called by any superclass that implements a JNDIReferencable or similar that needs to collect
1:      * the properties of this class for storage etc.
1:      *
1:      * This method should be updated any time there is a new property added.
1:      *
1:      * @param props
1:      *        a properties object that should be filled in with this objects property values.
1:      */
1:     protected void populateProperties(Properties props) {
1:         props.setProperty("maximumActiveSessionPerConnection", Integer.toString(getMaximumActiveSessionPerConnection()));
1:         props.setProperty("maxConnections", Integer.toString(getMaxConnections()));
1:         props.setProperty("idleTimeout", Integer.toString(getIdleTimeout()));
1:         props.setProperty("expiryTimeout", Long.toString(getExpiryTimeout()));
1:         props.setProperty("timeBetweenExpirationCheckMillis", Long.toString(getTimeBetweenExpirationCheckMillis()));
1:         props.setProperty("createConnectionOnStartup", Boolean.toString(isCreateConnectionOnStartup()));
1:         props.setProperty("useAnonymousProducers", Boolean.toString(isUseAnonymousProducers()));
1:         props.setProperty("blockIfSessionPoolIsFullTimeout", Long.toString(getBlockIfSessionPoolIsFullTimeout()));
1:     }
commit:c6d0aaa
/////////////////////////////////////////////////////////////////////////
1:                 createConnection().close();
commit:577b29c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected Object connectionFactory;
/////////////////////////////////////////////////////////////////////////
1:     public Object getConnectionFactory() {
/////////////////////////////////////////////////////////////////////////
1:     public void setConnectionFactory(final Object toUse) {
1:         if (toUse instanceof ConnectionFactory) {
1:         } else {
0:             throw new IllegalArgumentException("connectionFactory should implement javax.jmx.ConnectionFactory");
/////////////////////////////////////////////////////////////////////////
1:         if (connectionFactory instanceof ConnectionFactory) {
1:             if (key.getUserName() == null && key.getPassword() == null) {
1:                 return ((ConnectionFactory) connectionFactory).createConnection();
1:             } else {
1:                 return ((ConnectionFactory) connectionFactory).createConnection(key.getUserName(), key.getPassword());
1:             }
1:             throw new IllegalStateException("connectionFactory should implement javax.jms.ConnectionFactory");
commit:459593c
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.QueueConnection;
1: import javax.jms.QueueConnectionFactory;
1: import javax.jms.TopicConnection;
1: import javax.jms.TopicConnectionFactory;
/////////////////////////////////////////////////////////////////////////
1: public class PooledConnectionFactory implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory {
/////////////////////////////////////////////////////////////////////////
1:     public QueueConnection createQueueConnection() throws JMSException {
1:         return (QueueConnection) createConnection();
1:     }
1: 
1:     @Override
1:     public QueueConnection createQueueConnection(String userName, String password) throws JMSException {
1:         return (QueueConnection) createConnection(userName, password);
1:     }
1: 
1:     @Override
1:     public TopicConnection createTopicConnection() throws JMSException {
1:         return (TopicConnection) createConnection();
1:     }
1: 
1:     @Override
1:     public TopicConnection createTopicConnection(String userName, String password) throws JMSException {
1:         return (TopicConnection) createConnection(userName, password);
1:     }
1: 
1:     @Override
commit:9ae2264
/////////////////////////////////////////////////////////////////////////
1:      * it is first necessary to {@link #clear} the pooled Connections.
/////////////////////////////////////////////////////////////////////////
1:      * {@link #createConnection}.  Care should be taken when using this method as Connections that
/////////////////////////////////////////////////////////////////////////
1:      * begins to return connections from the pool on calls to ({@link #createConnection}.
/////////////////////////////////////////////////////////////////////////
1:      * {@link #createConnection} will result in a new Connection being create up to the max
commit:878e3a1
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:     // Temporary value used to always fetch the result of makeObject.
1:     private final AtomicReference<ConnectionPool> mostRecentlyCreated = new AtomicReference<ConnectionPool>(null);
1: 
/////////////////////////////////////////////////////////////////////////
1:                         PooledConnectionFactory.this.mostRecentlyCreated.set(connection);
1: 
/////////////////////////////////////////////////////////////////////////
1:             this.connectionsPool.setLifo(false);
/////////////////////////////////////////////////////////////////////////
1:                 connection = mostRecentlyCreated.getAndSet(null);
1:                 connection.incrementReferenceCount();
1:             try {
1:                 // We can race against other threads returning the connection when there is an
1:                 // expiration or idle timeout.  We keep pulling out ConnectionPool instances until
1:                 // we win and get a non-closed instance and then increment the reference count
1:                 // under lock to prevent another thread from triggering an expiration check and
1:                 // pulling the rug out from under us.
1:                 while (connection == null) {
1:                     connection = connectionsPool.borrowObject(key);
1:                     synchronized (connection) {
1:                         if (connection.getConnection() != null) {
1:                             connection.incrementReferenceCount();
1:                             break;
1:                         }
1:                         // Return the bad one to the pool and let if get destroyed as normal.
1:                         connectionsPool.returnObject(key, connection);
1:                         connection = null;
1:             } catch (Exception e) {
1:                 throw createJmsException("Error while attempting to retrieve a connection from the pool", e);
1:             try {
1:                 connectionsPool.returnObject(key, connection);
1:             } catch (Exception e) {
1:                 throw createJmsException("Error when returning connection to the pool", e);
1:             }
commit:2a7c349
/////////////////////////////////////////////////////////////////////////
1:     private boolean useAnonymousProducers = true;
/////////////////////////////////////////////////////////////////////////
1:                         connection.setUseAnonymousProducers(isUseAnonymousProducers());
/////////////////////////////////////////////////////////////////////////
1:      * Should Sessions use one anonymous producer for all producer requests or should a new
1:      * MessageProducer be created for each request to create a producer object, default is true.
1:      *
1:      * When enabled the session only needs to allocate one MessageProducer for all requests and
1:      * the MessageProducer#send(destination, message) method can be used.  Normally this is the
1:      * right thing to do however it does result in the Broker not showing the producers per
1:      * destination.
1:      *
1:      * @return true if a PooledSession will use only a single anonymous message producer instance.
1:      */
1:     public boolean isUseAnonymousProducers() {
1:         return this.useAnonymousProducers;
1:     }
1: 
1:     /**
1:      * Sets whether a PooledSession uses only one anonymous MessageProducer instance or creates
1:      * a new MessageProducer for each call the create a MessageProducer.
1:      *
1:      * @param value
1:      *      Boolean value that configures whether anonymous producers are used.
1:      */
1:     public void setUseAnonymousProducers(boolean value) {
1:         this.useAnonymousProducers = value;
1:     }
1: 
1:     /**
commit:d872994
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                 new KeyedPoolableObjectFactory<ConnectionKey, ConnectionPool>() {
1:                     @Override
0:                     public void activateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                     }
1:                     @Override
0:                     public void destroyObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                         try {
0:                                 LOG.trace("Destroying connection: {}", connection);
1:                             }
1:                             connection.close();
1:                         } catch (Exception e) {
1:                             LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
1:                         }
1:                     }
1: 
1:                     @Override
0:                     public ConnectionPool makeObject(ConnectionKey key) throws Exception {
0:                         Connection delegate = createConnection(key);
1: 
1:                         ConnectionPool connection = createConnectionPool(delegate);
1:                         connection.setIdleTimeout(getIdleTimeout());
1:                         connection.setExpiryTimeout(getExpiryTimeout());
1:                         connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());
1:                         connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());
1: 
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace("Created new connection: {}", connection);
1:                         }
1: 
0:                         return connection;
1:                     }
1: 
1:                     @Override
0:                     public void passivateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                     }
1: 
1:                     @Override
0:                     public boolean validateObject(ConnectionKey key, ConnectionPool connection) {
1:                         if (connection != null && connection.expiredCheck()) {
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace("Connection has expired: {} and will be destroyed", connection);
1:                             return false;
1:                         return true;
1:                     }
0:                 });
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 public Connection createConnection() throws JMSException {
0:                     return ((XAConnectionFactory)toUse).createXAConnection();
1:                 }
1:                 @Override
0:                 public Connection createConnection(String userName, String password) throws JMSException {
0:                     return ((XAConnectionFactory)toUse).createXAConnection(userName, password);
1:                 }
0:             };
/////////////////////////////////////////////////////////////////////////
author:sprgn
-------------------------------------------------------------------------------
commit:991d69f
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException("connectionFactory should implement javax.jms.ConnectionFactory");
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:7c7c505
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
/////////////////////////////////////////////////////////////////////////
1:             final GenericKeyedObjectPoolConfig poolConfig = new GenericKeyedObjectPoolConfig();
1:             poolConfig.setJmxEnabled(false);
/////////////////////////////////////////////////////////////////////////
1:                 }, poolConfig);
author:Jeff Genender
-------------------------------------------------------------------------------
commit:6d6ed4e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.pool2.KeyedPooledObjectFactory;
1: import org.apache.commons.pool2.PooledObject;
1: import org.apache.commons.pool2.impl.DefaultPooledObject;
1: import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
/////////////////////////////////////////////////////////////////////////
1:                 new KeyedPooledObjectFactory<ConnectionKey, ConnectionPool>() {
1:                     public PooledObject<ConnectionPool> makeObject(ConnectionKey connectionKey) throws Exception {
1:                         Connection delegate = createConnection(connectionKey);
/////////////////////////////////////////////////////////////////////////
1:                         return new DefaultPooledObject<ConnectionPool>(connection);
1:                     public void destroyObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {
1:                         ConnectionPool connection = pooledObject.getObject();
1:                         try {
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace("Destroying connection: {}", connection);
1:                             }
0:                             connection.close();
1:                         } catch (Exception e) {
0:                             LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
1:                         }
1:                     public boolean validateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) {
1:                         ConnectionPool connection = pooledObject.getObject();
/////////////////////////////////////////////////////////////////////////
1: 
0:                     @Override
1:                     public void activateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {
1:                     }
1: 
0:                     @Override
1:                     public void passivateObject(ConnectionKey connectionKey, PooledObject<ConnectionPool> pooledObject) throws Exception {
1:                     }
1: 
1:             this.connectionsPool.setMaxIdlePerKey(1);
/////////////////////////////////////////////////////////////////////////
1:         return getConnectionsPool().getMaxIdlePerKey();
/////////////////////////////////////////////////////////////////////////
1:         getConnectionsPool().setMaxIdlePerKey(maxConnections);
1:         getConnectionsPool().setMaxTotalPerKey(maxConnections);
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:b53d8ea
/////////////////////////////////////////////////////////////////////////
1:     private boolean reconnectOnException = true;
/////////////////////////////////////////////////////////////////////////
1:                         connection.setReconnectOnException(isReconnectOnException());
/////////////////////////////////////////////////////////////////////////
1:      * @return true if the underlying connection will be renewed on JMSException, false otherwise
1:      */
1:     public boolean isReconnectOnException() {
1:         return reconnectOnException;
1:     }
1: 
1:     /**
1:      * Controls weather the underlying connection should be reset (and renewed) on JMSException
1:      *
1:      * @param reconnectOnException
1:      *          Boolean value that configures whether reconnect on exception should happen
1:      */
1:     public void setReconnectOnException(boolean reconnectOnException) {
1:         this.reconnectOnException = reconnectOnException;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("reconnectOnException", Boolean.toString(isReconnectOnException()));
author:Christian Posta
-------------------------------------------------------------------------------
commit:dc607bb
/////////////////////////////////////////////////////////////////////////
1:     private long blockIfSessionPoolIsFullTimeout = -1L;
/////////////////////////////////////////////////////////////////////////
1:                         if (isBlockIfSessionPoolIsFull() && getBlockIfSessionPoolIsFullTimeout() > 0) {
1:                             connection.setBlockIfSessionPoolIsFullTimeout(getBlockIfSessionPoolIsFullTimeout());
1:                         }
/////////////////////////////////////////////////////////////////////////
1:      * @see #setBlockIfSessionPoolIsFull(boolean)
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Returns the timeout to use for blocking creating new sessions
1:      *
1:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:      */
1:     public long getBlockIfSessionPoolIsFullTimeout() {
1:         return blockIfSessionPoolIsFullTimeout;
1:     }
1: 
1:     /**
1:      * Controls the behavior of the internal session pool. By default the call to
1:      * Connection.getSession() will block if the session pool is full.  This setting
1:      * will affect how long it blocks and throws an exception after the timeout.
1:      *
1:      * The size of the session pool is controlled by the @see #maximumActive
1:      * property.
1:      *
1:      * Whether or not the call to create session blocks is controlled by the @see #blockIfSessionPoolIsFull
1:      * property
1:      *
1:      * @param blockIfSessionPoolIsFullTimeout - if blockIfSessionPoolIsFullTimeout is true,
1:      *                                        then use this setting to configure how long to block before retry
1:      */
1:     public void setBlockIfSessionPoolIsFullTimeout(long blockIfSessionPoolIsFullTimeout) {
1:         this.blockIfSessionPoolIsFullTimeout = blockIfSessionPoolIsFullTimeout;
1:     }
author:gtully
-------------------------------------------------------------------------------
commit:b66559e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.jms.pool;
1: 
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: 
0: import javax.jms.XAConnectionFactory;
0: import org.apache.commons.pool.KeyedPoolableObjectFactory;
0: import org.apache.commons.pool.impl.GenericKeyedObjectPool;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A JMS provider which pools Connection, Session and MessageProducer instances
1:  * so it can be used with tools like <a href="http://camel.apache.org/activemq.html">Camel</a> and Spring's
1:  * <a href="http://activemq.apache.org/spring-support.html">JmsTemplate and MessagListenerContainer</a>.
1:  * Connections, sessions and producers are returned to a pool after use so that they can be reused later
1:  * without having to undergo the cost of creating them again.
1:  *
1:  * b>NOTE:</b> while this implementation does allow the creation of a collection of active consumers,
1:  * it does not 'pool' consumers. Pooling makes sense for connections, sessions and producers, which
1:  * are expensive to create and can remain idle a minimal cost. Consumers, on the other hand, are usually
1:  * just created at startup and left active, handling incoming messages as they come. When a consumer is
1:  * complete, it is best to close it rather than return it to a pool for later reuse: this is because,
1:  * even if a consumer is idle, ActiveMQ will keep delivering messages to the consumer's prefetch buffer,
1:  * where they'll get held until the consumer is active again.
1:  *
1:  * If you are creating a collection of consumers (for example, for multi-threaded message consumption), you
1:  * might want to consider using a lower prefetch value for each consumer (e.g. 10 or 20), to ensure that
1:  * all messages don't end up going to just one of the consumers. See this FAQ entry for more detail:
1:  * http://activemq.apache.org/i-do-not-receive-messages-in-my-second-consumer.html
1:  *
1:  * Optionally, one may configure the pool to examine and possibly evict objects as they sit idle in the
1:  * pool. This is performed by an "idle object eviction" thread, which runs asynchronously. Caution should
1:  * be used when configuring this optional feature. Eviction runs contend with client threads for access
1:  * to objects in the pool, so if they run too frequently performance issues may result. The idle object
1:  * eviction thread may be configured using the {@link org.apache.activemq.jms.pool.PooledConnectionFactory#setTimeBetweenExpirationCheckMillis} method.  By
1:  * default the value is -1 which means no eviction thread will be run.  Set to a non-negative value to
1:  * configure the idle eviction thread to run.
1:  *
1:  */
0: public class PooledConnectionFactory implements ConnectionFactory {
1:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledConnectionFactory.class);
1: 
1:     protected final AtomicBoolean stopped = new AtomicBoolean(false);
1:     private GenericKeyedObjectPool<ConnectionKey, ConnectionPool> connectionsPool;
1: 
0:     private ConnectionFactory connectionFactory;
1: 
1:     private int maximumActiveSessionPerConnection = 500;
1:     private int idleTimeout = 30 * 1000;
1:     private boolean blockIfSessionPoolIsFull = true;
1:     private long expiryTimeout = 0l;
1:     private boolean createConnectionOnStartup = true;
1: 
1: 
1:     public void initConnectionsPool() {
1:         if (this.connectionsPool == null) {
1:             this.connectionsPool = new GenericKeyedObjectPool<ConnectionKey, ConnectionPool>(
0:                     new KeyedPoolableObjectFactory<ConnectionKey, ConnectionPool>() {
1: 
0:                         @Override
0:                         public void activateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                         }
1: 
0:                         @Override
0:                         public void destroyObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                             try {
0:                                 if (LOG.isTraceEnabled()) {
0:                                     LOG.trace("Destroying connection: {}", connection);
1:                                 }
0:                                 connection.close();
1:                             } catch (Exception e) {
0:                                 LOG.warn("Close connection failed for connection: " + connection + ". This exception will be ignored.",e);
1:                             }
1:                         }
1: 
0:                         @Override
0:                         public ConnectionPool makeObject(ConnectionKey key) throws Exception {
0:                             Connection delegate = createConnection(key);
1: 
0:                             ConnectionPool connection = createConnectionPool(delegate);
0:                             connection.setIdleTimeout(getIdleTimeout());
0:                             connection.setExpiryTimeout(getExpiryTimeout());
0:                             connection.setMaximumActiveSessionPerConnection(getMaximumActiveSessionPerConnection());
0:                             connection.setBlockIfSessionPoolIsFull(isBlockIfSessionPoolIsFull());
1: 
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace("Created new connection: {}", connection);
1:                             }
1: 
0:                             return connection;
1:                         }
1: 
0:                         @Override
0:                         public void passivateObject(ConnectionKey key, ConnectionPool connection) throws Exception {
1:                         }
1: 
0:                         @Override
0:                         public boolean validateObject(ConnectionKey key, ConnectionPool connection) {
0:                             if (connection != null && connection.expiredCheck()) {
0:                                 if (LOG.isTraceEnabled()) {
0:                                     LOG.trace("Connection has expired: {} and will be destroyed", connection);
1:                                 }
1: 
0:                                 return false;
1:                             }
1: 
0:                             return true;
1:                         }
0:                     });
1: 
1:             // Set max idle (not max active) since our connections always idle in the pool.
0:             this.connectionsPool.setMaxIdle(1);
1: 
1:             // We always want our validate method to control when idle objects are evicted.
1:             this.connectionsPool.setTestOnBorrow(true);
1:             this.connectionsPool.setTestWhileIdle(true);
1:         }
1:     }
1: 
1:     /**
1:      * @return the currently configured ConnectionFactory used to create the pooled Connections.
1:      */
0:     public ConnectionFactory getConnectionFactory() {
1:         return connectionFactory;
1:     }
1: 
1:     /**
1:      * Sets the ConnectionFactory used to create new pooled Connections.
1:      * <p/>
1:      * Updates to this value do not affect Connections that were previously created and placed
1:      * into the pool.  In order to allocate new Connections based off this new ConnectionFactory
0:      * it is first necessary to {@link clear} the pooled Connections.
1:      *
1:      * @param toUse
1:      *      The factory to use to create pooled Connections.
1:      */
0:     public void setConnectionFactory(final ConnectionFactory toUse) {
0:         if (toUse instanceof XAConnectionFactory) {
0:             connectionFactory = new ConnectionFactory() {
0:                         public Connection createConnection() throws JMSException {
0:                             return ((XAConnectionFactory)toUse).createXAConnection();
1:                         }
0:                         public Connection createConnection(String userName, String password) throws JMSException {
0:                             return ((XAConnectionFactory)toUse).createXAConnection(userName, password);
1:                         }
0:                     };
1:         } else {
1:             this.connectionFactory = toUse;
1:         }
1:     }
1: 
0:     @Override
0:     public Connection createConnection() throws JMSException {
1:         return createConnection(null, null);
1:     }
1: 
0:     @Override
1:     public synchronized Connection createConnection(String userName, String password) throws JMSException {
1:         if (stopped.get()) {
1:             LOG.debug("PooledConnectionFactory is stopped, skip create new connection.");
1:             return null;
1:         }
1: 
1:         ConnectionPool connection = null;
1:         ConnectionKey key = new ConnectionKey(userName, password);
1: 
1:         // This will either return an existing non-expired ConnectionPool or it
1:         // will create a new one to meet the demand.
1:         if (getConnectionsPool().getNumIdle(key) < getMaxConnections()) {
1:             try {
0:                 // we want borrowObject to return the one we added.
0:                 connectionsPool.setLifo(true);
1:                 connectionsPool.addObject(key);
1:             } catch (Exception e) {
1:                 throw createJmsException("Error while attempting to add new Connection to the pool", e);
1:             }
1:         } else {
0:             // now we want the oldest one in the pool.
0:             connectionsPool.setLifo(false);
1:         }
1: 
1:         try {
1: 
0:             // We can race against other threads returning the connection when there is an
0:             // expiration or idle timeout.  We keep pulling out ConnectionPool instances until
0:             // we win and get a non-closed instance and then increment the reference count
0:             // under lock to prevent another thread from triggering an expiration check and
0:             // pulling the rug out from under us.
0:             while (connection == null) {
0:                 connection = connectionsPool.borrowObject(key);
0:                 synchronized (connection) {
0:                     if (connection.getConnection() != null) {
0:                         connection.incrementReferenceCount();
0:                         break;
1:                     }
1: 
0:                     // Return the bad one to the pool and let if get destroyed as normal.
0:                     connectionsPool.returnObject(key, connection);
0:                     connection = null;
1:                 }
1:             }
1:         } catch (Exception e) {
0:             throw createJmsException("Error while attempting to retrieve a connection from the pool", e);
1:         }
1: 
1:         try {
0:             connectionsPool.returnObject(key, connection);
1:         } catch (Exception e) {
0:             throw createJmsException("Error when returning connection to the pool", e);
1:         }
1: 
1:         return newPooledConnection(connection);
1:     }
1: 
1:     protected Connection newPooledConnection(ConnectionPool connection) {
1:         return new PooledConnection(connection);
1:     }
1: 
1:     private JMSException createJmsException(String msg, Exception cause) {
1:         JMSException exception = new JMSException(msg);
1:         exception.setLinkedException(cause);
1:         exception.initCause(cause);
1:         return exception;
1:     }
1: 
1:     protected Connection createConnection(ConnectionKey key) throws JMSException {
0:         if (key.getUserName() == null && key.getPassword() == null) {
0:             return connectionFactory.createConnection();
1:         } else {
0:             return connectionFactory.createConnection(key.getUserName(), key.getPassword());
1:         }
1:     }
1: 
1:     public void start() {
1:         LOG.debug("Staring the PooledConnectionFactory: create on start = {}", isCreateConnectionOnStartup());
1:         stopped.set(false);
1:         if (isCreateConnectionOnStartup()) {
1:             try {
1:                 // warm the pool by creating a connection during startup
0:                 createConnection();
1:             } catch (JMSException e) {
1:                 LOG.warn("Create pooled connection during start failed. This exception will be ignored.", e);
1:             }
1:         }
1:     }
1: 
1:     public void stop() {
1:         if (stopped.compareAndSet(false, true)) {
1:             LOG.debug("Stopping the PooledConnectionFactory, number of connections in cache: {}",
0:                     connectionsPool != null ? connectionsPool.getNumActive() : 0);
1:             try {
1:                 if (connectionsPool != null) {
1:                     connectionsPool.close();
1:                 }
1:             } catch (Exception e) {
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Clears all connections from the pool.  Each connection that is currently in the pool is
1:      * closed and removed from the pool.  A new connection will be created on the next call to
0:      * {@link createConnection}.  Care should be taken when using this method as Connections that
1:      * are in use be client's will be closed.
1:      */
1:     public void clear() {
1: 
1:         if (stopped.get()) {
1:             return;
1:         }
1: 
1:         getConnectionsPool().clear();
1:     }
1: 
1:     /**
1:      * Returns the currently configured maximum number of sessions a pooled Connection will
1:      * create before it either blocks or throws an exception when a new session is requested,
1:      * depending on configuration.
1:      *
1:      * @return the number of session instances that can be taken from a pooled connection.
1:      */
1:     public int getMaximumActiveSessionPerConnection() {
1:         return maximumActiveSessionPerConnection;
1:     }
1: 
1:     /**
1:      * Sets the maximum number of active sessions per connection
1:      *
1:      * @param maximumActiveSessionPerConnection
1:      *      The maximum number of active session per connection in the pool.
1:      */
1:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
1:         this.maximumActiveSessionPerConnection = maximumActiveSessionPerConnection;
1:     }
1: 
1:     /**
1:      * Controls the behavior of the internal session pool. By default the call to
1:      * Connection.getSession() will block if the session pool is full.  If the
1:      * argument false is given, it will change the default behavior and instead the
1:      * call to getSession() will throw a JMSException.
1:      *
1:      * The size of the session pool is controlled by the @see #maximumActive
1:      * property.
1:      *
1:      * @param block - if true, the call to getSession() blocks if the pool is full
1:      * until a session object is available.  defaults to true.
1:      */
1:     public void setBlockIfSessionPoolIsFull(boolean block) {
1:         this.blockIfSessionPoolIsFull = block;
1:     }
1: 
1:     /**
1:      * Returns whether a pooled Connection will enter a blocked state or will throw an Exception
1:      * once the maximum number of sessions has been borrowed from the the Session Pool.
1:      *
1:      * @return true if the pooled Connection createSession method will block when the limit is hit.
0:      * @see setBlockIfSessionPoolIsFull
1:      */
1:     public boolean isBlockIfSessionPoolIsFull() {
1:         return this.blockIfSessionPoolIsFull;
1:     }
1: 
1:     /**
1:      * Returns the maximum number to pooled Connections that this factory will allow before it
0:      * begins to return connections from the pool on calls to ({@link createConnection}.
1:      *
1:      * @return the maxConnections that will be created for this pool.
1:      */
1:     public int getMaxConnections() {
0:         return getConnectionsPool().getMaxIdle();
1:     }
1: 
1:     /**
1:      * Sets the maximum number of pooled Connections (defaults to one).  Each call to
0:      * {@link createConnection} will result in a new Connection being create up to the max
1:      * connections value.
1:      *
1:      * @param maxConnections the maxConnections to set
1:      */
1:     public void setMaxConnections(int maxConnections) {
0:         getConnectionsPool().setMaxIdle(maxConnections);
1:     }
1: 
1:     /**
1:      * Gets the Idle timeout value applied to new Connection's that are created by this pool.
1:      * <p/>
1:      * The idle timeout is used determine if a Connection instance has sat to long in the pool unused
1:      * and if so is closed and removed from the pool.  The default value is 30 seconds.
1:      *
1:      * @return idle timeout value (milliseconds)
1:      */
1:     public int getIdleTimeout() {
1:         return idleTimeout;
1:     }
1: 
1:     /**
1:      * Sets the idle timeout  value for Connection's that are created by this pool in Milliseconds,
1:      * defaults to 30 seconds.
1:      * <p/>
1:      * For a Connection that is in the pool but has no current users the idle timeout determines how
1:      * long the Connection can live before it is eligible for removal from the pool.  Normally the
1:      * connections are tested when an attempt to check one out occurs so a Connection instance can sit
1:      * in the pool much longer than its idle timeout if connections are used infrequently.
1:      *
1:      * @param idleTimeout
1:      *      The maximum time a pooled Connection can sit unused before it is eligible for removal.
1:      */
1:     public void setIdleTimeout(int idleTimeout) {
1:         this.idleTimeout = idleTimeout;
1:     }
1: 
1:     /**
1:      * allow connections to expire, irrespective of load or idle time. This is useful with failover
1:      * to force a reconnect from the pool, to reestablish load balancing or use of the master post recovery
1:      *
1:      * @param expiryTimeout non zero in milliseconds
1:      */
1:     public void setExpiryTimeout(long expiryTimeout) {
1:         this.expiryTimeout = expiryTimeout;
1:     }
1: 
1:     /**
1:      * @return the configured expiration timeout for connections in the pool.
1:      */
1:     public long getExpiryTimeout() {
1:         return expiryTimeout;
1:     }
1: 
1:     /**
1:      * @return true if a Connection is created immediately on a call to {@link start}.
1:      */
1:     public boolean isCreateConnectionOnStartup() {
1:         return createConnectionOnStartup;
1:     }
1: 
1:     /**
1:      * Whether to create a connection on starting this {@link PooledConnectionFactory}.
1:      * <p/>
1:      * This can be used to warm-up the pool on startup. Notice that any kind of exception
1:      * happens during startup is logged at WARN level and ignored.
1:      *
1:      * @param createConnectionOnStartup <tt>true</tt> to create a connection on startup
1:      */
1:     public void setCreateConnectionOnStartup(boolean createConnectionOnStartup) {
1:         this.createConnectionOnStartup = createConnectionOnStartup;
1:     }
1: 
1:     /**
1:      * Gets the Pool of ConnectionPool instances which are keyed by different ConnectionKeys.
1:      *
1:      * @return this factories pool of ConnectionPool instances.
1:      */
1:     protected GenericKeyedObjectPool<ConnectionKey, ConnectionPool> getConnectionsPool() {
1:         initConnectionsPool();
1:         return this.connectionsPool;
1:     }
1: 
1:     /**
1:      * Sets the number of milliseconds to sleep between runs of the idle Connection eviction thread.
1:      * When non-positive, no idle object eviction thread will be run, and Connections will only be
1:      * checked on borrow to determine if they have sat idle for too long or have failed for some
1:      * other reason.
1:      * <p/>
1:      * By default this value is set to -1 and no expiration thread ever runs.
1:      *
1:      * @param timeBetweenExpirationCheckMillis
1:      *      The time to wait between runs of the idle Connection eviction thread.
1:      */
1:     public void setTimeBetweenExpirationCheckMillis(long timeBetweenExpirationCheckMillis) {
1:         getConnectionsPool().setTimeBetweenEvictionRunsMillis(timeBetweenExpirationCheckMillis);
1:     }
1: 
1:     /**
1:      * @return the number of milliseconds to sleep between runs of the idle connection eviction thread.
1:      */
1:     public long getTimeBetweenExpirationCheckMillis() {
1:         return getConnectionsPool().getTimeBetweenEvictionRunsMillis();
1:     }
1: 
1:     /**
1:      * @return the number of Connections currently in the Pool
1:      */
1:     public int getNumConnections() {
1:         return getConnectionsPool().getNumIdle();
1:     }
1: 
1:     /**
1:      * Delegate that creates each instance of an ConnectionPool object.  Subclasses can override
1:      * this method to customize the type of connection pool returned.
1:      *
1:      * @param connection
1:      *
1:      * @return instance of a new ConnectionPool.
1:      */
1:     protected ConnectionPool createConnectionPool(Connection connection) {
1:         return new ConnectionPool(connection);
1:     }
1: 
1: }
============================================================================