1:08aecbe: /**
1:08aecbe:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:08aecbe:  * contributor license agreements.  See the NOTICE file distributed with
1:08aecbe:  * this work for additional information regarding copyright ownership.
1:08aecbe:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:08aecbe:  * (the "License"); you may not use this file except in compliance with
1:08aecbe:  * the License.  You may obtain a copy of the License at
1:08aecbe:  *
1:08aecbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:08aecbe:  *
1:08aecbe:  * Unless required by applicable law or agreed to in writing, software
1:08aecbe:  * distributed under the License is distributed on an "AS IS" BASIS,
1:08aecbe:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:08aecbe:  * See the License for the specific language governing permissions and
1:08aecbe:  * limitations under the License.
1:9765540:  */
1:eab5a3a: 
1:08aecbe: package org.apache.activemq.bugs;
1:76f842d: 
1:fb9a292: import java.io.File;
1:7c50c1c: import java.lang.IllegalStateException;
1:7c50c1c: import java.util.HashSet;
1:86ec055: import java.util.Timer;
1:86ec055: import java.util.TimerTask;
1:08aecbe: import java.util.Vector;
1:c60af64: import java.util.concurrent.Callable;
1:c60af64: import java.util.concurrent.ExecutorService;
1:c60af64: import java.util.concurrent.Executors;
1:c60af64: import java.util.concurrent.Future;
1:c60af64: import java.util.concurrent.TimeUnit;
1:c60af64: import java.util.concurrent.TimeoutException;
1:c8e518b: 
1:7c50c1c: import javax.jms.*;
1:132f662: 
1:a91a181: import org.apache.activemq.AutoFailTestSupport;
1:c60af64: import org.junit.After;
1:c60af64: import org.junit.Before;
1:c60af64: import org.junit.Rule;
1:c60af64: import org.junit.Test;
1:c60af64: 
1:c60af64: import org.apache.activemq.ActiveMQConnectionFactory;
1:08aecbe: import org.apache.activemq.broker.BrokerService;
1:132f662: import org.apache.activemq.broker.region.Destination;
1:132f662: import org.apache.activemq.broker.region.DestinationStatistics;
1:132f662: import org.apache.activemq.broker.region.RegionBroker;
1:c8e518b: import org.apache.activemq.broker.util.LoggingBrokerPlugin;
1:c8e518b: import org.apache.activemq.command.ActiveMQDestination;
1:c60af64: import org.junit.rules.TestName;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:fb9a292: 
1:c60af64: import static org.junit.Assert.*;
1:c60af64: 
1:86ec055: interface Configurer {
1:86ec055:     public void configure(BrokerService broker) throws Exception;
1:86ec055: }
1:c60af64: 
1:c60af64: public class AMQ2149Test {
1:7c50c1c: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(AMQ2149Test.class);
1:c60af64:     @Rule
1:c60af64:     public TestName testName = new TestName();
1:e45bb06: 
1:86ec055:     private static final String BROKER_CONNECTOR = "tcp://localhost:61617";
1:e45bb06:     private static final String DEFAULT_BROKER_URL = "failover:("+ BROKER_CONNECTOR
1:86ec055:         +")?maxReconnectDelay=1000&useExponentialBackOff=false";
1:e45bb06:         
1:08aecbe:     private final String SEQ_NUM_PROPERTY = "seqNum";
1:e45bb06: 
1:c8e518b:     final int MESSAGE_LENGTH_BYTES = 75 * 1024;
1:9f548bb:     final long SLEEP_BETWEEN_SEND_MS = 25;
1:08aecbe:     final int NUM_SENDERS_AND_RECEIVERS = 10;
1:86ec055:     final Object brokerLock = new Object();
1:e45bb06:     
1:49dd85c:     private static final long DEFAULT_BROKER_STOP_PERIOD = 10 * 1000;
1:9f548bb:     private static final long DEFAULT_NUM_TO_SEND = 1400;
1:e45bb06:     
1:e45bb06:     long brokerStopPeriod = DEFAULT_BROKER_STOP_PERIOD;
1:e45bb06:     long numtoSend = DEFAULT_NUM_TO_SEND;
1:9f548bb:     long sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;
1:e45bb06:     String brokerURL = DEFAULT_BROKER_URL;
1:e45bb06:     
1:e45bb06:     int numBrokerRestarts = 0;
1:82c4ab8:     final static int MAX_BROKER_RESTARTS = 4;
1:08aecbe:     BrokerService broker;
1:08aecbe:     Vector<Throwable> exceptions = new Vector<Throwable>();
1:e45bb06: 
1:7071102:     protected File dataDirFile;
1:c8e518b:     final LoggingBrokerPlugin[] plugins = new LoggingBrokerPlugin[]{new LoggingBrokerPlugin()};
1:e45bb06:     
1:c8e518b:     
1:86ec055:     public void createBroker(Configurer configurer) throws Exception {
1:08aecbe:         broker = new BrokerService();
1:76f842d:         configurePersistenceAdapter(broker);
1:eab5a3a:         
1:9765540:         broker.getSystemUsage().getMemoryUsage().setLimit(MESSAGE_LENGTH_BYTES * 200 * NUM_SENDERS_AND_RECEIVERS);
1:eab5a3a: 
1:86ec055:         broker.addConnector(BROKER_CONNECTOR);        
1:c60af64:         broker.setBrokerName(testName.getMethodName());
1:fb9a292:         broker.setDataDirectoryFile(dataDirFile);
1:86ec055:         if (configurer != null) {
1:86ec055:             configurer.configure(broker);
1:e45bb06:         }
1:08aecbe:         broker.start();
1:76f842d:     }
1:76f842d:     
1:969e758:     protected void configurePersistenceAdapter(BrokerService brokerService) throws Exception {
1:c8e518b:     }
1:9765540: 
1:c60af64:     @Before
1:fb9a292:     public void setUp() throws Exception {
1:c60af64:         LOG.debug("Starting test {}", testName.getMethodName());
1:c60af64:         dataDirFile = new File("target/"+ testName.getMethodName());
1:e45bb06:         numtoSend = DEFAULT_NUM_TO_SEND;
1:e45bb06:         brokerStopPeriod = DEFAULT_BROKER_STOP_PERIOD;
1:9f548bb:         sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;
1:e45bb06:         brokerURL = DEFAULT_BROKER_URL;
1:fb9a292:     }
1:c60af64: 
1:c60af64:     @After
1:08aecbe:     public void tearDown() throws Exception {
1:c60af64:         ExecutorService executor = Executors.newSingleThreadExecutor();
1:c60af64:         Future<Boolean> future = executor.submit(new TeardownTask(brokerLock, broker));
1:c60af64:         try {
1:c60af64:             LOG.debug("Teardown started.");
1:c60af64:             long start = System.currentTimeMillis();
1:c60af64:             Boolean result =  future.get(30, TimeUnit.SECONDS);
1:c60af64:             long finish = System.currentTimeMillis();
1:c60af64:             LOG.debug("Result of teardown: {} after {} ms ", result, (finish - start));
1:c60af64:         } catch (TimeoutException e) {
1:c60af64:             fail("Teardown timed out");
1:c60af64:             AutoFailTestSupport.dumpAllThreads(testName.getMethodName());
1:fb9a292:         }
1:c60af64:         executor.shutdownNow();
1:86ec055:         exceptions.clear();
1:86ec055:     }
1:c8e518b:     
1:08aecbe:     private String buildLongString() {
1:08aecbe:         final StringBuilder stringBuilder = new StringBuilder(
1:08aecbe:                 MESSAGE_LENGTH_BYTES);
1:08aecbe:         for (int i = 0; i < MESSAGE_LENGTH_BYTES; ++i) {
1:08aecbe:             stringBuilder.append((int) (Math.random() * 10));
19:08aecbe:         }
1:08aecbe:         return stringBuilder.toString();
1:08aecbe:     }
1:c8e518b: 
1:7c50c1c:     HashSet<Connection> connections = new HashSet<Connection>();
1:08aecbe:     private class Receiver implements MessageListener {
1:132f662: 
1:c8e518b:         private final javax.jms.Destination dest;
1:132f662: 
1:08aecbe:         private final Connection connection;
1:132f662: 
1:08aecbe:         private final Session session;
1:132f662: 
1:08aecbe:         private final MessageConsumer messageConsumer;
1:e45bb06: 
1:dc06c8d:         private volatile long nextExpectedSeqNum = 1;
1:132f662:                 
1:e45bb06:         private final boolean transactional;
1:e45bb06: 
1:86ec055:         private String lastId = null;
1:fb9a292: 
1:e45bb06:         public Receiver(javax.jms.Destination dest, boolean transactional) throws JMSException {
1:c8e518b:             this.dest = dest;
1:e45bb06:             this.transactional = transactional;
1:e45bb06:             connection = new ActiveMQConnectionFactory(brokerURL)
1:08aecbe:                     .createConnection();
1:c8e518b:             connection.setClientID(dest.toString());
1:e45bb06:             session = connection.createSession(transactional, transactional ? Session.SESSION_TRANSACTED : Session.AUTO_ACKNOWLEDGE);
1:c8e518b:             if (ActiveMQDestination.transform(dest).isTopic()) {
1:c8e518b:                 messageConsumer = session.createDurableSubscriber((Topic) dest, dest.toString());
1:c8e518b:             } else {
1:c8e518b:                 messageConsumer = session.createConsumer(dest);
1:c8e518b:             }
1:08aecbe:             messageConsumer.setMessageListener(this);
1:08aecbe:             connection.start();
1:7c50c1c:             connections.add(connection);
1:08aecbe:         }
1:fb9a292: 
1:86ec055:         public void close() throws JMSException {
1:86ec055:             connection.close();
1:86ec055:         }
1:fb9a292:         
1:86ec055:         public long getNextExpectedSeqNo() {
1:86ec055:             return nextExpectedSeqNum;
1:86ec055:         }
1:fb9a292:         
1:e561040:         final int TRANSACITON_BATCH = 500;
1:82c4ab8:         boolean resumeOnNextOrPreviousIsOk = false;
1:08aecbe:         public void onMessage(Message message) {
2:86ec055:             try {
1:08aecbe:                 final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);
1:e561040:                 if ((seqNum % TRANSACITON_BATCH) == 0) {
1:c8e518b:                     LOG.info(dest + " received " + seqNum);
1:e45bb06:                     
1:e45bb06:                     if (transactional) {
1:e45bb06:                         LOG.info("committing..");
1:e45bb06:                         session.commit();
1:e45bb06:                     }
1:86ec055:                 }
1:82c4ab8:                 if (resumeOnNextOrPreviousIsOk) {
1:dc06c8d:                     // after an indoubt commit we need to accept what we get
1:dc06c8d:                     // either a batch replay or next batch
1:82c4ab8:                     if (seqNum != nextExpectedSeqNum) {
1:dc06c8d:                         if (seqNum == nextExpectedSeqNum - TRANSACITON_BATCH) {
1:dc06c8d:                             nextExpectedSeqNum -= TRANSACITON_BATCH;
1:82c4ab8:                             LOG.info("In doubt commit failed, getting replay at:" +  nextExpectedSeqNum);
1:82c4ab8:                         }
1:82c4ab8:                     }
1:82c4ab8:                     resumeOnNextOrPreviousIsOk = false;
1:82c4ab8:                 }
1:08aecbe:                 if (seqNum != nextExpectedSeqNum) {
1:c8e518b:                     LOG.warn(dest + " received " + seqNum
1:86ec055:                             + " in msg: " + message.getJMSMessageID()
1:86ec055:                             + " expected "
1:86ec055:                             + nextExpectedSeqNum
1:fb9a292:                             + ", lastId: " + lastId 
1:fb9a292:                             + ", message:" + message);
1:c8e518b:                     fail(dest + " received " + seqNum + " expected "
2:08aecbe:                             + nextExpectedSeqNum);
1:86ec055:                 }
1:08aecbe:                 ++nextExpectedSeqNum;
1:86ec055:                 lastId = message.getJMSMessageID();
1:e561040:             } catch (TransactionRolledBackException expectedSometimesOnFailoverRecovery) {
1:dc06c8d:                 ++nextExpectedSeqNum;
1:e561040:                 LOG.info("got rollback: " + expectedSometimesOnFailoverRecovery);
1:82c4ab8:                 if (expectedSometimesOnFailoverRecovery.getMessage().contains("completion in doubt")) {
1:82c4ab8:                     // in doubt - either commit command or reply missing
1:82c4ab8:                     // don't know if we will get a replay
1:82c4ab8:                     resumeOnNextOrPreviousIsOk = true;
1:7c50c1c:                     LOG.info("in doubt transaction completion: ok to get next or previous batch. next:" + nextExpectedSeqNum);
1:82c4ab8:                 } else {
1:82c4ab8:                     resumeOnNextOrPreviousIsOk = false;
1:82c4ab8:                     // batch will be replayed
1:dc06c8d:                     nextExpectedSeqNum -= TRANSACITON_BATCH;
1:82c4ab8:                 }
1:82c4ab8: 
1:08aecbe:             } catch (Throwable e) {
1:dc06c8d:                 LOG.error(dest + " onMessage error:" + e);
1:08aecbe:                 exceptions.add(e);
1:86ec055:             }
1:86ec055:         }
1:86ec055: 
1:86ec055:     }
1:86ec055: 
1:08aecbe:     private class Sender implements Runnable {
1:86ec055: 
1:c8e518b:         private final javax.jms.Destination dest;
1:86ec055: 
1:08aecbe:         private final Connection connection;
1:86ec055: 
1:08aecbe:         private final Session session;
1:86ec055: 
1:08aecbe:         private final MessageProducer messageProducer;
9:86ec055: 
1:08aecbe:         private volatile long nextSequenceNumber = 0;
1:86ec055: 
1:c8e518b:         public Sender(javax.jms.Destination dest) throws JMSException {
1:c8e518b:             this.dest = dest;
1:e45bb06:             connection = new ActiveMQConnectionFactory(brokerURL)
1:08aecbe:                     .createConnection();
2:08aecbe:             session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:c8e518b:             messageProducer = session.createProducer(dest);
1:08aecbe:             messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:08aecbe:             connection.start();
1:7c50c1c:             connections.add(connection);
1:86ec055:         }
1:86ec055: 
1:08aecbe:         public void run() {
1:08aecbe:             final String longString = buildLongString();
1:e45bb06:             while (nextSequenceNumber < numtoSend) {
1:fb9a292:                 try {
1:08aecbe:                     final Message message = session
1:08aecbe:                             .createTextMessage(longString);
1:08aecbe:                     message.setLongProperty(SEQ_NUM_PROPERTY,
1:dc06c8d:                             ++nextSequenceNumber);
1:08aecbe:                     messageProducer.send(message);
1:e45bb06:                     
1:e45bb06:                     if ((nextSequenceNumber % 500) == 0) {
1:e45bb06:                         LOG.info(dest + " sent " + nextSequenceNumber);
1:e45bb06:                     }
1:7c50c1c: 
1:7c50c1c:                 } catch (javax.jms.IllegalStateException e) {
1:7c50c1c:                     LOG.error(dest + " bailing on send error", e);
1:7c50c1c:                     exceptions.add(e);
1:7c50c1c:                     break;
1:08aecbe:                 } catch (Exception e) {
1:c8e518b:                     LOG.error(dest + " send error", e);
1:08aecbe:                     exceptions.add(e);
1:86ec055:                 }
1:9f548bb:                 if (sleepBetweenSend > 0) {
1:86ec055:                     try {
1:9f548bb:                         Thread.sleep(sleepBetweenSend);
1:fb9a292:                     } catch (InterruptedException e) {
1:c8e518b:                         LOG.warn(dest + " sleep interrupted", e);
1:fb9a292:                     }
1:86ec055:                 }
1:86ec055:             }
1:86ec055:             try {
1:86ec055:                 connection.close();
1:86ec055:             } catch (JMSException ignored) {
1:86ec055:             }
1:86ec055:         }
1:86ec055:     }
1:e45bb06: 
1:7c50c1c:     // attempt to simply replicate leveldb failure. no joy yet
1:7c50c1c:     public void x_testRestartReReceive() throws Exception {
1:7c50c1c:         createBroker(new Configurer() {
1:7c50c1c:             public void configure(BrokerService broker) throws Exception {
1:7c50c1c:                 broker.deleteAllMessages();
1:7c50c1c:             }
1:7c50c1c:         });
1:7c50c1c: 
1:7c50c1c:         final javax.jms.Destination destination =
1:7c50c1c:                 ActiveMQDestination.createDestination("test.dest.X", ActiveMQDestination.QUEUE_TYPE);
1:7c50c1c:         Thread thread = new Thread(new Sender(destination));
1:7c50c1c:         thread.start();
1:7c50c1c:         thread.join();
1:7c50c1c: 
1:7c50c1c:         Connection connection = new ActiveMQConnectionFactory(brokerURL).createConnection();
1:7c50c1c:         connection.setClientID(destination.toString());
1:7c50c1c:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:7c50c1c:         MessageConsumer messageConsumer = session.createConsumer(destination);
1:7c50c1c:         connection.start();
1:7c50c1c: 
1:7c50c1c:         int batch = 200;
1:7c50c1c:         long expectedSeq;
1:7c50c1c: 
1:7c50c1c:         final TimerTask restartTask = schedualRestartTask(null, new Configurer() {
1:7c50c1c:             public void configure(BrokerService broker) throws Exception {
1:7c50c1c:             }
1:7c50c1c:         });
1:7c50c1c: 
1:7c50c1c:         expectedSeq = 0;
1:7c50c1c:         for (int s = 0; s < 4; s++) {
1:7c50c1c:             for (int i = 0; i < batch; i++) {
1:7c50c1c:                 Message message = messageConsumer.receive(20000);
1:7c50c1c:                 assertNotNull("s:" + s + ", i:" + i, message);
1:7c50c1c:                 final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);
1:7c50c1c:                 assertEquals("expected order s:" + s, expectedSeq++, seqNum);
1:7c50c1c: 
1:7c50c1c:                 if (i > 0 && i%600 == 0) {
1:7c50c1c:                     LOG.info("Commit on %5");
1:7c50c1c:                 //    session.commit();
1:7c50c1c:                 }
1:7c50c1c:             }
1:7c50c1c:             restartTask.run();
1:7c50c1c:         }
1:7c50c1c: 
1:7c50c1c:     }
1:7c50c1c: 
1:c8e518b:     // no need to run this unless there are some issues with the others
1:132f662:     public void vanilaVerify_testOrder() throws Exception {
1:132f662:         
1:132f662:         createBroker(new Configurer() {
1:e45bb06:             public void configure(BrokerService broker) throws Exception {
1:c8e518b:                broker.deleteAllMessages();            
1:132f662:             }
1:132f662:         });
1:132f662:         
1:132f662:         verifyOrderedMessageReceipt();
1:132f662:         verifyStats(false);
1:132f662:     }
1:132f662: 
1:6cf9a8a:     @Test(timeout = 10 * 60 * 1000)
1:9f548bb:     public void testOrderWithRestart() throws Exception {
1:fb9a292:         createBroker(new Configurer() {
1:132f662:             public void configure(BrokerService broker) throws Exception {
1:132f662:                 broker.deleteAllMessages();     
1:fb9a292:             }
2:132f662:         });
1:fb9a292:         
1:fb9a292:         final Timer timer = new Timer();
1:e45bb06:         schedualRestartTask(timer, new Configurer() {
1:c8e518b:             public void configure(BrokerService broker) throws Exception {    
1:c8e518b:             }
1:c8e518b:         });
1:132f662:         
1:fb9a292:         try {
1:132f662:             verifyOrderedMessageReceipt();
1:fb9a292:         } finally {
1:fb9a292:             timer.cancel();
1:132f662:         }
1:132f662:         
1:132f662:         verifyStats(true);
1:132f662:     }
1:c60af64: 
1:6cf9a8a:     @Test(timeout = 10 * 60 * 1000)
1:9f548bb:     public void testTopicOrderWithRestart() throws Exception {
1:132f662:         createBroker(new Configurer() {
2:132f662:             public void configure(BrokerService broker) throws Exception {
1:eab5a3a:                 broker.deleteAllMessages();
1:132f662:             }
1:e45bb06:         });
1:132f662:         
1:132f662:         final Timer timer = new Timer();
1:eab5a3a:         schedualRestartTask(timer, null);
1:132f662:         
1:132f662:         try {
1:c8e518b:             verifyOrderedMessageReceipt(ActiveMQDestination.TOPIC_TYPE);
1:132f662:         } finally {
1:132f662:             timer.cancel();
1:132f662:         }
1:132f662:         
2:132f662:         verifyStats(true);
1:132f662:     }
1:132f662: 
1:6cf9a8a:     @Test(timeout = 10 * 60 * 1000)
1:e45bb06:     public void testQueueTransactionalOrderWithRestart() throws Exception {
1:e45bb06:         doTestTransactionalOrderWithRestart(ActiveMQDestination.QUEUE_TYPE);
1:e45bb06:     }
1:c60af64: 
1:6cf9a8a:     @Test(timeout = 10 * 60 * 1000)
1:e45bb06:     public void testTopicTransactionalOrderWithRestart() throws Exception {
1:e45bb06:         doTestTransactionalOrderWithRestart(ActiveMQDestination.TOPIC_TYPE);
1:e45bb06:     }
1:e45bb06:     
1:e45bb06:     public void doTestTransactionalOrderWithRestart(byte destinationType) throws Exception {
1:6cf9a8a:         numtoSend = 5000;
1:9f548bb:         sleepBetweenSend = 3;
1:82c4ab8:         brokerStopPeriod = 10 * 1000;
1:1f4757b:               
1:e45bb06:         createBroker(new Configurer() {
1:e45bb06:             public void configure(BrokerService broker) throws Exception {
1:e45bb06:                 broker.deleteAllMessages();
1:e45bb06:             }
1:e45bb06:         });
1:e45bb06:         
1:e45bb06:         final Timer timer = new Timer();
1:1f4757b:         schedualRestartTask(timer, null);
1:e45bb06:         
1:e45bb06:         try {
1:e45bb06:             verifyOrderedMessageReceipt(destinationType, 1, true);
1:e45bb06:         } finally {
1:e45bb06:             timer.cancel();
1:e45bb06:         }
1:e45bb06:         
1:e45bb06:         verifyStats(true);
1:e45bb06:     }
1:e45bb06: 
1:132f662:     private void verifyStats(boolean brokerRestarts) throws Exception {
1:132f662:         RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:132f662:         
1:132f662:         for (Destination dest : regionBroker.getQueueRegion().getDestinationMap().values()) {
1:132f662:             DestinationStatistics stats = dest.getDestinationStatistics();
1:132f662:             if (brokerRestarts) {
1:e45bb06:                 // all bets are off w.r.t stats as there may be duplicate sends and duplicate
1:e45bb06:                 // dispatches, all of which will be suppressed - either by the reference store
1:e45bb06:                 // not allowing duplicate references or consumers acking duplicates
1:e45bb06:                 LOG.info("with restart: not asserting qneue/dequeue stat match for: " + dest.getName()
1:e45bb06:                         + " " + stats.getEnqueues().getCount() + " <= " +stats.getDequeues().getCount());
1:132f662:             } else {
1:132f662:                 assertEquals("qneue/dequeue match for: " + dest.getName(),
1:132f662:                         stats.getEnqueues().getCount(), stats.getDequeues().getCount());   
1:132f662:             }
1:132f662:         }
1:fb9a292:     }
1:fb9a292: 
1:7c50c1c:     private TimerTask schedualRestartTask(final Timer timer, final Configurer configurer) {
1:fb9a292:         class RestartTask extends TimerTask {
1:86ec055:             public void run() {
1:86ec055:                 synchronized (brokerLock) {
1:86ec055:                     LOG.info("stopping broker..");
1:86ec055:                     try {
1:e45bb06:                         broker.stop();
1:e45bb06:                         broker.waitUntilStopped();
1:86ec055:                     } catch (Exception e) {
1:86ec055:                         LOG.error("ex on broker stop", e);
1:86ec055:                         exceptions.add(e);
1:e45bb06:                     }
1:86ec055:                     LOG.info("restarting broker");
1:fb9a292:                     try {
1:86ec055:                         createBroker(configurer);
1:fb9a292:                         broker.waitUntilStarted();
1:86ec055:                     } catch (Exception e) {
1:86ec055:                         LOG.error("ex on broker restart", e);
1:86ec055:                         exceptions.add(e);
1:86ec055:                     }
1:86ec055:                 }
1:7c50c1c:                 if (++numBrokerRestarts < MAX_BROKER_RESTARTS && timer != null) {
1:e45bb06:                     // do it again
1:e45bb06:                     try {
2:e45bb06:                         timer.schedule(new RestartTask(), brokerStopPeriod);
1:7c50c1c:                     } catch (IllegalStateException ignore_alreadyCancelled) {
1:e45bb06:                     }
1:e45bb06:                 } else {
1:e45bb06:                     LOG.info("no longer stopping broker on reaching Max restarts: " + MAX_BROKER_RESTARTS);
1:7c50c1c:                 }
1:fb9a292:             }
1:fb9a292:         }
1:7c50c1c:         RestartTask task = new RestartTask();
1:7c50c1c:         if (timer != null) {
1:7c50c1c:             timer.schedule(task, brokerStopPeriod);
1:7c50c1c:         }
1:7c50c1c:         return task;
1:fb9a292:     }
1:86ec055:     
1:c8e518b:     private void verifyOrderedMessageReceipt(byte destinationType) throws Exception {
1:e45bb06:         verifyOrderedMessageReceipt(destinationType, NUM_SENDERS_AND_RECEIVERS, false);
1:e45bb06:     }
1:e45bb06:     
1:e45bb06:     private void verifyOrderedMessageReceipt() throws Exception {
1:e45bb06:         verifyOrderedMessageReceipt(ActiveMQDestination.QUEUE_TYPE, NUM_SENDERS_AND_RECEIVERS, false);
1:e45bb06:     }
1:e45bb06:     
1:e45bb06:     private void verifyOrderedMessageReceipt(byte destinationType, int concurrentPairs, boolean transactional) throws Exception {
1:c60af64: 
1:08aecbe:         Vector<Thread> threads = new Vector<Thread>();
1:86ec055:         Vector<Receiver> receivers = new Vector<Receiver>();
1:e45bb06:         
1:e45bb06:         for (int i = 0; i < concurrentPairs; ++i) {
1:c8e518b:             final javax.jms.Destination destination =
1:c8e518b:                     ActiveMQDestination.createDestination("test.dest." + i, destinationType);
1:e45bb06:             receivers.add(new Receiver(destination, transactional));
1:c8e518b:             Thread thread = new Thread(new Sender(destination));
1:08aecbe:             thread.start();
1:08aecbe:             threads.add(thread);
1:86ec055:         }
1:86ec055:         
1:6cf9a8a:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 10;
1:fb9a292:         while(!threads.isEmpty() && exceptions.isEmpty() && System.currentTimeMillis() < expiry) {
1:08aecbe:             Thread sendThread = threads.firstElement();
1:6cf9a8a:             sendThread.join(1000*60*10);
1:08aecbe:             if (!sendThread.isAlive()) {
1:08aecbe:                 threads.remove(sendThread);
1:128921e:             } else {
1:cb6941e:                 AutoFailTestSupport.dumpAllThreads("Send blocked");
1:fb9a292:             }
1:86ec055:         }
1:7c50c1c:         LOG.info("senders done..." + threads);
1:7c50c1c: 
1:fb9a292:         while(!receivers.isEmpty() && System.currentTimeMillis() < expiry) {
1:86ec055:             Receiver receiver = receivers.firstElement();
1:e45bb06:             if (receiver.getNextExpectedSeqNo() >= numtoSend || !exceptions.isEmpty()) {
1:86ec055:                 receiver.close();
1:86ec055:                 receivers.remove(receiver);
1:86ec055:             }
1:86ec055:         }
1:fb9a292: 
1:7c50c1c:         for (Connection connection : connections) {
1:7c50c1c:             try {
1:7c50c1c:                 connection.close();
1:7c50c1c:             } catch (Exception ignored) {}
1:7c50c1c:         }
1:7c50c1c:         connections.clear();
1:7c50c1c: 
1:128921e:         assertTrue("No timeout waiting for senders/receivers to complete", System.currentTimeMillis() < expiry);
1:128921e:         if (!exceptions.isEmpty()) {
1:128921e:             exceptions.get(0).printStackTrace();
1:128921e:         }
1:128921e: 
1:7c50c1c:         LOG.info("Dangling threads: " + threads);
1:7c50c1c:         for (Thread dangling : threads) {
1:7c50c1c:             dangling.interrupt();
1:7c50c1c:             dangling.join(10*1000);
1:7c50c1c:         }
1:7c50c1c: 
1:08aecbe:         assertTrue("No exceptions", exceptions.isEmpty());
1:5eb274d:     }
1:86ec055: 
1:86ec055: }
1:86ec055: 
1:c60af64: class TeardownTask implements Callable<Boolean> {
1:c60af64:     private Object brokerLock;
1:c60af64:     private BrokerService broker;
1:c60af64: 
1:c60af64:     public TeardownTask(Object brokerLock, BrokerService broker) {
1:c60af64:         this.brokerLock = brokerLock;
1:c60af64:         this.broker = broker;
1:c60af64:     }
1:c60af64: 
1:c60af64:     @Override
1:c60af64:     public Boolean call() throws Exception {
1:c60af64:         synchronized(brokerLock) {
1:c60af64:             if (broker!= null) {
1:c60af64:                 broker.stop();
1:c60af64:                 broker.waitUntilStopped();
1:c60af64:             }
1:c60af64:         }
1:c60af64:         return Boolean.TRUE;
1:c60af64:     }
1:c60af64: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:dc06c8d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         private volatile long nextExpectedSeqNum = 1;
/////////////////////////////////////////////////////////////////////////
1:                     // after an indoubt commit we need to accept what we get
1:                     // either a batch replay or next batch
1:                         if (seqNum == nextExpectedSeqNum - TRANSACITON_BATCH) {
1:                             nextExpectedSeqNum -= TRANSACITON_BATCH;
/////////////////////////////////////////////////////////////////////////
1:                 ++nextExpectedSeqNum;
1:                     nextExpectedSeqNum -= TRANSACITON_BATCH;
1:                 LOG.error(dest + " onMessage error:" + e);
/////////////////////////////////////////////////////////////////////////
1:                             ++nextSequenceNumber);
commit:6cf9a8a
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 10 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 10 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 10 * 60 * 1000)
1:     @Test(timeout = 10 * 60 * 1000)
1:         numtoSend = 5000;
/////////////////////////////////////////////////////////////////////////
1:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 10;
1:             sendThread.join(1000*60*10);
commit:cb6941e
/////////////////////////////////////////////////////////////////////////
0:             sendThread.join(1000*30);
1:                 AutoFailTestSupport.dumpAllThreads("Send blocked");
commit:128921e
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 4;
0:             sendThread.join(1000*20);
1:             } else {
0:                 Throwable throwable = new Throwable("blocked send thread");
0:                 throwable.setStackTrace(sendThread.getStackTrace());
0:                 LOG.error("Send thread blocked", throwable);
0:                 throwable.printStackTrace();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("No timeout waiting for senders/receivers to complete", System.currentTimeMillis() < expiry);
1:         if (!exceptions.isEmpty()) {
1:             exceptions.get(0).printStackTrace();
1:         }
1: 
author:Kevin Earls
-------------------------------------------------------------------------------
commit:c60af64
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.TimeoutException;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Rule;
1: import org.junit.Test;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.junit.rules.TestName;
1: import static org.junit.Assert.*;
1: 
1: public class AMQ2149Test {
1:     @Rule
1:     public TestName testName = new TestName();
/////////////////////////////////////////////////////////////////////////
1:         broker.setBrokerName(testName.getMethodName());
/////////////////////////////////////////////////////////////////////////
1:     @Before
1:         LOG.debug("Starting test {}", testName.getMethodName());
1:         dataDirFile = new File("target/"+ testName.getMethodName());
1: 
1:     @After
1:         ExecutorService executor = Executors.newSingleThreadExecutor();
1:         Future<Boolean> future = executor.submit(new TeardownTask(brokerLock, broker));
1:         try {
1:             LOG.debug("Teardown started.");
1:             long start = System.currentTimeMillis();
1:             Boolean result =  future.get(30, TimeUnit.SECONDS);
1:             long finish = System.currentTimeMillis();
1:             LOG.debug("Result of teardown: {} after {} ms ", result, (finish - start));
1:         } catch (TimeoutException e) {
1:             fail("Teardown timed out");
1:             AutoFailTestSupport.dumpAllThreads(testName.getMethodName());
1:         executor.shutdownNow();
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 5 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Test(timeout = 5 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 5 * 60 * 1000)
1: 
0:     @Test(timeout = 5 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: class TeardownTask implements Callable<Boolean> {
1:     private Object brokerLock;
1:     private BrokerService broker;
1: 
1:     public TeardownTask(Object brokerLock, BrokerService broker) {
1:         this.brokerLock = brokerLock;
1:         this.broker = broker;
1:     }
1: 
1:     @Override
1:     public Boolean call() throws Exception {
1:         synchronized(brokerLock) {
1:             if (broker!= null) {
1:                 broker.stop();
1:                 broker.waitUntilStopped();
1:             }
1:         }
1:         return Boolean.TRUE;
1:     }
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:7c50c1c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.IllegalStateException;
1: import java.util.HashSet;
1: import javax.jms.*;
/////////////////////////////////////////////////////////////////////////
1:     HashSet<Connection> connections = new HashSet<Connection>();
/////////////////////////////////////////////////////////////////////////
1:             connections.add(connection);
/////////////////////////////////////////////////////////////////////////
0:                     nextExpectedSeqNum++;
1:                     LOG.info("in doubt transaction completion: ok to get next or previous batch. next:" + nextExpectedSeqNum);
/////////////////////////////////////////////////////////////////////////
1:             connections.add(connection);
/////////////////////////////////////////////////////////////////////////
1: 
1:                 } catch (javax.jms.IllegalStateException e) {
1:                     LOG.error(dest + " bailing on send error", e);
1:                     exceptions.add(e);
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:     // attempt to simply replicate leveldb failure. no joy yet
1:     public void x_testRestartReReceive() throws Exception {
1:         createBroker(new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
1:                 broker.deleteAllMessages();
1:             }
1:         });
1: 
1:         final javax.jms.Destination destination =
1:                 ActiveMQDestination.createDestination("test.dest.X", ActiveMQDestination.QUEUE_TYPE);
1:         Thread thread = new Thread(new Sender(destination));
1:         thread.start();
1:         thread.join();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerURL).createConnection();
1:         connection.setClientID(destination.toString());
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer messageConsumer = session.createConsumer(destination);
1:         connection.start();
1: 
1:         int batch = 200;
1:         long expectedSeq;
1: 
1:         final TimerTask restartTask = schedualRestartTask(null, new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
1:             }
1:         });
1: 
1:         expectedSeq = 0;
1:         for (int s = 0; s < 4; s++) {
1:             for (int i = 0; i < batch; i++) {
1:                 Message message = messageConsumer.receive(20000);
1:                 assertNotNull("s:" + s + ", i:" + i, message);
1:                 final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);
1:                 assertEquals("expected order s:" + s, expectedSeq++, seqNum);
1: 
1:                 if (i > 0 && i%600 == 0) {
1:                     LOG.info("Commit on %5");
1:                 //    session.commit();
1:                 }
1:             }
1:             restartTask.run();
1:         }
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private TimerTask schedualRestartTask(final Timer timer, final Configurer configurer) {
/////////////////////////////////////////////////////////////////////////
1:                 if (++numBrokerRestarts < MAX_BROKER_RESTARTS && timer != null) {
1:                     } catch (IllegalStateException ignore_alreadyCancelled) {
1:             }
1:         RestartTask task = new RestartTask();
1:         if (timer != null) {
1:             timer.schedule(task, brokerStopPeriod);
1:         }
1:         return task;
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("senders done..." + threads);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (Connection connection : connections) {
1:             try {
1:                 connection.close();
1:             } catch (Exception ignored) {}
1:         }
1:         connections.clear();
1: 
1:         LOG.info("Dangling threads: " + threads);
1:         for (Thread dangling : threads) {
1:             dangling.interrupt();
1:             dangling.join(10*1000);
1:         }
1: 
commit:82c4ab8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     final static int MAX_BROKER_RESTARTS = 4;
/////////////////////////////////////////////////////////////////////////
1:         boolean resumeOnNextOrPreviousIsOk = false;
/////////////////////////////////////////////////////////////////////////
1:                 if (resumeOnNextOrPreviousIsOk) {
0:                     // after an indoubt commit we need to accept what we get (within reason)
1:                     if (seqNum != nextExpectedSeqNum) {
0:                         if (seqNum == nextExpectedSeqNum - (TRANSACITON_BATCH -1)) {
0:                             nextExpectedSeqNum -= (TRANSACITON_BATCH -1);
1:                             LOG.info("In doubt commit failed, getting replay at:" +  nextExpectedSeqNum);
1:                         }
1:                     }
1:                     resumeOnNextOrPreviousIsOk = false;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (expectedSometimesOnFailoverRecovery.getMessage().contains("completion in doubt")) {
1:                     // in doubt - either commit command or reply missing
1:                     // don't know if we will get a replay
1:                     resumeOnNextOrPreviousIsOk = true;
1:                 } else {
1:                     resumeOnNextOrPreviousIsOk = false;
1:                     // batch will be replayed
0:                     nextExpectedSeqNum -= (TRANSACITON_BATCH -1);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:         brokerStopPeriod = 10 * 1000;
commit:9765540
/////////////////////////////////////////////////////////////////////////
1:         broker.getSystemUsage().getMemoryUsage().setLimit(MESSAGE_LENGTH_BYTES * 200 * NUM_SENDERS_AND_RECEIVERS);
/////////////////////////////////////////////////////////////////////////
0: /*
0:         https://issues.apache.org/jira/browse/AMQ-4296
1: 
0:         a leveldb variant will fail. needs to have this test exercise all stores
1: */
commit:49dd85c
/////////////////////////////////////////////////////////////////////////
1:     private static final long DEFAULT_BROKER_STOP_PERIOD = 10 * 1000;
/////////////////////////////////////////////////////////////////////////
0:     final static int MAX_BROKER_RESTARTS = 3;
commit:a91a181
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.AutoFailTestSupport;
/////////////////////////////////////////////////////////////////////////
0: public class AMQ2149Test extends AutoFailTestSupport {
/////////////////////////////////////////////////////////////////////////
0:         setMaxTestTime(30*60*1000);
0:         setAutoFail(true);
commit:969e758
/////////////////////////////////////////////////////////////////////////
1:     protected void configurePersistenceAdapter(BrokerService brokerService) throws Exception {
commit:76f842d
/////////////////////////////////////////////////////////////////////////
1:         configurePersistenceAdapter(broker);
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:     protected void configurePersistenceAdapter(BrokerService brokerService) {
0:         AMQPersistenceAdapterFactory persistenceFactory = new AMQPersistenceAdapterFactory();
0:         persistenceFactory.setDataDirectory(dataDirFile);
0:         brokerService.setPersistenceFactory(persistenceFactory);
1:     }
1: 
commit:e561040
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.TransactionRolledBackException;
/////////////////////////////////////////////////////////////////////////
1:         final int TRANSACITON_BATCH = 500;
1:                 if ((seqNum % TRANSACITON_BATCH) == 0) {
/////////////////////////////////////////////////////////////////////////
1:             } catch (TransactionRolledBackException expectedSometimesOnFailoverRecovery) {
1:                 LOG.info("got rollback: " + expectedSometimesOnFailoverRecovery);
0:                 // batch will be replayed
0:                 nextExpectedSeqNum -= (TRANSACITON_BATCH -1);
commit:5eb274d
/////////////////////////////////////////////////////////////////////////
0:         if (!exceptions.isEmpty()) {
0:             exceptions.get(0).printStackTrace();
1:         }
commit:9f548bb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     final long SLEEP_BETWEEN_SEND_MS = 25;
1:     private static final long DEFAULT_NUM_TO_SEND = 1400;
1:     long sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;
0:     final static int MAX_BROKER_RESTARTS = 5;
/////////////////////////////////////////////////////////////////////////
1:         sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;
/////////////////////////////////////////////////////////////////////////
1:                 if (sleepBetweenSend > 0) {
1:                         Thread.sleep(sleepBetweenSend);
/////////////////////////////////////////////////////////////////////////
1:     public void testOrderWithRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicOrderWithRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         numtoSend = 10000;
1:         sleepBetweenSend = 3;
commit:1f4757b
/////////////////////////////////////////////////////////////////////////
0:     public void x_testOrderWithRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void x_testTopicOrderWithRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:               
1:         schedualRestartTask(timer, null);
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
1:     private static final String DEFAULT_BROKER_URL = "failover:("+ BROKER_CONNECTOR
1:     
0:     private static final long DEFAULT_BROKER_STOP_PERIOD = 20 * 1000;
0:     private static final long DEFAULT_NUM_TO_SEND = 1500;
1:     
1:     long brokerStopPeriod = DEFAULT_BROKER_STOP_PERIOD;
1:     long numtoSend = DEFAULT_NUM_TO_SEND;
1:     String brokerURL = DEFAULT_BROKER_URL;
1:     
1:     int numBrokerRestarts = 0;
0:     final static int MAX_BROKER_RESTARTS = 4;
/////////////////////////////////////////////////////////////////////////
1:         numtoSend = DEFAULT_NUM_TO_SEND;
1:         brokerStopPeriod = DEFAULT_BROKER_STOP_PERIOD;
1:         brokerURL = DEFAULT_BROKER_URL;
0:             if (broker!= null) {
1:                 broker.stop();
1:                 broker.waitUntilStopped();
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 
1:         private final boolean transactional;
1: 
1:         public Receiver(javax.jms.Destination dest, boolean transactional) throws JMSException {
1:             this.transactional = transactional;
1:             connection = new ActiveMQConnectionFactory(brokerURL)
1:             session = connection.createSession(transactional, transactional ? Session.SESSION_TRANSACTED : Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
1:                     
1:                     if (transactional) {
1:                         LOG.info("committing..");
1:                         session.commit();
1:                     }
/////////////////////////////////////////////////////////////////////////
1:             connection = new ActiveMQConnectionFactory(brokerURL)
/////////////////////////////////////////////////////////////////////////
1:             while (nextSequenceNumber < numtoSend) {
/////////////////////////////////////////////////////////////////////////
1:                     
1:                     if ((nextSequenceNumber % 500) == 0) {
1:                         LOG.info(dest + " sent " + nextSequenceNumber);
1:                     }
1:                         
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:     public void testQueueTransactionalOrderWithRestart() throws Exception {
1:         doTestTransactionalOrderWithRestart(ActiveMQDestination.QUEUE_TYPE);
1:     }
1:     
1:     public void testTopicTransactionalOrderWithRestart() throws Exception {
1:         doTestTransactionalOrderWithRestart(ActiveMQDestination.TOPIC_TYPE);
1:     }
1:     
1:     public void doTestTransactionalOrderWithRestart(byte destinationType) throws Exception {
1:         
0:         // with transactions there may be lots of re deliveries, in the case
0:         // or a commit every 500 messages there could be up to 500 re deliveries
0:         // In order to ensure these are acked and don't block new message receipt,
0:         // the prefetch should be less than double the commit window.
0:         // In addition there needs to be sufficient memory to available to dispatch
0:         // transaction size + redeliveries - so 2*transaction size
0:         brokerURL = DEFAULT_BROKER_URL + "&jms.prefetchPolicy.all=240";
0:         numtoSend = 15000;
0:         brokerStopPeriod = 30 * 1000;
1:             
0:         final PolicyMap policyMap = new PolicyMap();
0:         PolicyEntry policy = new PolicyEntry();
0:         policy.setMaxPageSize(500);
0:         policyMap.setDefaultEntry(policy);
1:     
1:         createBroker(new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
1:                 broker.deleteAllMessages();
0:                 broker.setDestinationPolicy(policyMap);
1:             }
1:         });
1:         
1:         final Timer timer = new Timer();
1:         schedualRestartTask(timer, new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
0:                 broker.setDestinationPolicy(policyMap);
1:             }
1:         });
1:         
1:         try {
1:             verifyOrderedMessageReceipt(destinationType, 1, true);
1:         } finally {
1:             timer.cancel();
1:         }
1:         
1:         verifyStats(true);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 // all bets are off w.r.t stats as there may be duplicate sends and duplicate
1:                 // dispatches, all of which will be suppressed - either by the reference store
1:                 // not allowing duplicate references or consumers acking duplicates
1:                 LOG.info("with restart: not asserting qneue/dequeue stat match for: " + dest.getName()
1:                         + " " + stats.getEnqueues().getCount() + " <= " +stats.getDequeues().getCount());
/////////////////////////////////////////////////////////////////////////
0:                 if (++numBrokerRestarts < MAX_BROKER_RESTARTS) {
1:                     // do it again
1:                     try {
1:                         timer.schedule(new RestartTask(), brokerStopPeriod);
0:                     } catch (IllegalStateException ignore_alreadyCancelled) {   
1:                     }
1:                 } else {
1:                     LOG.info("no longer stopping broker on reaching Max restarts: " + MAX_BROKER_RESTARTS);
1:         timer.schedule(new RestartTask(), brokerStopPeriod);
1:         verifyOrderedMessageReceipt(destinationType, NUM_SENDERS_AND_RECEIVERS, false);
1:     }
1:     
1:     private void verifyOrderedMessageReceipt() throws Exception {
1:         verifyOrderedMessageReceipt(ActiveMQDestination.QUEUE_TYPE, NUM_SENDERS_AND_RECEIVERS, false);
1:     }
1:     
1:     private void verifyOrderedMessageReceipt(byte destinationType, int concurrentPairs, boolean transactional) throws Exception {
1:                 
1:         for (int i = 0; i < concurrentPairs; ++i) {
1:             receivers.add(new Receiver(destination, transactional));
/////////////////////////////////////////////////////////////////////////
1:             if (receiver.getNextExpectedSeqNo() >= numtoSend || !exceptions.isEmpty()) {
commit:eab5a3a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          
/////////////////////////////////////////////////////////////////////////
1:         
0:         SystemUsage usage = new SystemUsage();
0:         MemoryUsage memoryUsage = new MemoryUsage();
0:         memoryUsage.setLimit(MESSAGE_LENGTH_BYTES * 200 * NUM_SENDERS_AND_RECEIVERS);
0:         usage.setMemoryUsage(memoryUsage);
0:         broker.setSystemUsage(usage);
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void testTopicOrderWithRestart() throws Exception {
1:                 broker.deleteAllMessages();
1:         schedualRestartTask(timer, null);
commit:c8e518b
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Topic;
0: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.util.LoggingBrokerPlugin;
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     final int MESSAGE_LENGTH_BYTES = 75 * 1024;
1:         
1:     final LoggingBrokerPlugin[] plugins = new LoggingBrokerPlugin[]{new LoggingBrokerPlugin()};
1:     
/////////////////////////////////////////////////////////////////////////
1:         private final javax.jms.Destination dest;
/////////////////////////////////////////////////////////////////////////
0:         public Receiver(javax.jms.Destination dest) throws JMSException {
1:             this.dest = dest;
1:             connection.setClientID(dest.toString());
1:             if (ActiveMQDestination.transform(dest).isTopic()) {
1:                 messageConsumer = session.createDurableSubscriber((Topic) dest, dest.toString());
1:             } else {
1:                 messageConsumer = session.createConsumer(dest);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info(dest + " received " + seqNum);
1:                     LOG.warn(dest + " received " + seqNum
1:                     fail(dest + " received " + seqNum + " expected "
0:                 LOG.error(dest + " onMessage error", e);
/////////////////////////////////////////////////////////////////////////
1:         private final javax.jms.Destination dest;
/////////////////////////////////////////////////////////////////////////
1:         public Sender(javax.jms.Destination dest) throws JMSException {
1:             this.dest = dest;
1:             messageProducer = session.createProducer(dest);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error(dest + " send error", e);
1:                         LOG.warn(dest + " sleep interrupted", e);
/////////////////////////////////////////////////////////////////////////
0:                 memoryUsage.setLimit(MESSAGE_LENGTH_BYTES * 10 * NUM_SENDERS_AND_RECEIVERS);
/////////////////////////////////////////////////////////////////////////
1:     // no need to run this unless there are some issues with the others
0:     public void noProblem_testOrderWithRestartAndVMIndex() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         schedualRestartTask(timer, new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {    
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
0:     public void x_testTopicOrderWithRestart() throws Exception {
0:         plugins[0].setLogAll(true);
0:         plugins[0].setLogInternalEvents(false);
1:         
1:                 broker.deleteAllMessages();   
0:                 broker.setPlugins(plugins);
0:                 broker.setPlugins(plugins);
1:             verifyOrderedMessageReceipt(ActiveMQDestination.TOPIC_TYPE);
/////////////////////////////////////////////////////////////////////////
0:                 broker.setPlugins(plugins);
/////////////////////////////////////////////////////////////////////////
0:                 broker.setPlugins(plugins);
/////////////////////////////////////////////////////////////////////////
0:         verifyOrderedMessageReceipt(ActiveMQDestination.QUEUE_TYPE);
1:     }
1:     
1:     private void verifyOrderedMessageReceipt(byte destinationType) throws Exception {
1:             final javax.jms.Destination destination =
1:                     ActiveMQDestination.createDestination("test.dest." + i, destinationType);
0:             receivers.add(new Receiver(destination));
1:             Thread thread = new Thread(new Sender(destination));
0:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 30;
commit:132f662
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.DestinationStatistics;
1: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
0:     private static final long BROKER_STOP_PERIOD = 20 * 1000;
/////////////////////////////////////////////////////////////////////////
0:     final int MAX_TO_SEND  = 1500;
/////////////////////////////////////////////////////////////////////////
0:                 if ((seqNum % 500) == 0) {
/////////////////////////////////////////////////////////////////////////
0:             while (nextSequenceNumber < MAX_TO_SEND) {
/////////////////////////////////////////////////////////////////////////
0:     // no need to run this unless there are some issues with the others
1:     public void vanilaVerify_testOrder() throws Exception {
1:         
1:         createBroker(new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
1:                broker.deleteAllMessages();            
1:             }
1:         });
1:         
1:         verifyOrderedMessageReceipt();
1:         verifyStats(false);
1:     }
1: 
0:     public void testOrderWithMemeUsageLimit() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         verifyStats(false);
0:     public void testOrderWithRestartAndVMIndex() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         verifyStats(true);
0:     public void testOrderWithRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         
1:         verifyStats(true);
1:     
0:     public void testOrderWithRestartAndNoCache() throws Exception {
1:         
0:         PolicyEntry noCache = new PolicyEntry();
0:         noCache.setUseCache(false);
0:         final PolicyMap policyMap = new PolicyMap();
0:         policyMap.setDefaultEntry(noCache);
1:         createBroker(new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
0:                 broker.setDestinationPolicy(policyMap);
0:                 broker.deleteAllMessages();
1:             }
1:         });
1:         
1:         final Timer timer = new Timer();
0:         schedualRestartTask(timer, new Configurer() {
1:             public void configure(BrokerService broker) throws Exception {
0:                 broker.setDestinationPolicy(policyMap);
1:             }
1:         });
1:         
1:         try {
1:             verifyOrderedMessageReceipt();
1:         } finally {
1:             timer.cancel();
1:         }
1:         
1:         verifyStats(true);
1:     }
1: 
1: 
0:     // no need to run this unless there are issues with the other restart tests
1:   
0:     public void eaiserToRepoduce_testOrderWithRestartWithForceRecover() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
0:         verifyStats(true);
1:     }
1: 
1:     private void verifyStats(boolean brokerRestarts) throws Exception {
1:         RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:         
1:         for (Destination dest : regionBroker.getQueueRegion().getDestinationMap().values()) {
1:             DestinationStatistics stats = dest.getDestinationStatistics();
1:             if (brokerRestarts) {
0:                 assertTrue("qneue/dequeue match for: " + dest.getName(),
0:                         stats.getEnqueues().getCount() <= stats.getDequeues().getCount());
1:             } else {
1:                 assertEquals("qneue/dequeue match for: " + dest.getName(),
1:                         stats.getEnqueues().getCount(), stats.getDequeues().getCount());   
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:                         broker.waitUntilStopped();
/////////////////////////////////////////////////////////////////////////
0:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 20;
commit:fb9a292
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
0:     final long SLEEP_BETWEEN_SEND_MS = 3;
1: 
0:     private File dataDirFile;
0:         AMQPersistenceAdapterFactory persistenceFactory = new AMQPersistenceAdapterFactory();
0:         persistenceFactory.setDataDirectory(dataDirFile);
0:         broker.setPersistenceFactory(persistenceFactory);
1: 
0:         broker.setBrokerName(getName());
1:         broker.setDataDirectoryFile(dataDirFile);
1:     public void setUp() throws Exception {
0:         dataDirFile = new File("target/"+ getName());
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                             + ", lastId: " + lastId 
1:                             + ", message:" + message);
/////////////////////////////////////////////////////////////////////////
0:                 if (SLEEP_BETWEEN_SEND_MS > 0) {
1:                     try {
0:                         Thread.sleep(SLEEP_BETWEEN_SEND_MS);
1:                     } catch (InterruptedException e) {
0:                         LOG.warn(queueName + " sleep interrupted", e);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:     public void x_testOrderWithMemeUsageLimit() throws Exception {
0:                 memoryUsage.setLimit(MESSAGE_LENGTH_BYTES * 5 * NUM_SENDERS_AND_RECEIVERS);
/////////////////////////////////////////////////////////////////////////
0:                 AMQPersistenceAdapterFactory persistenceFactory =
0:                     (AMQPersistenceAdapterFactory) broker.getPersistenceFactory();
/////////////////////////////////////////////////////////////////////////
0:                 AMQPersistenceAdapterFactory persistenceFactory =
0:                     (AMQPersistenceAdapterFactory) broker.getPersistenceFactory();
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void x_testOrderWithRestart() throws Exception {
1:         createBroker(new Configurer() {
0:             public void configure(BrokerService broker) throws Exception {
0:                 broker.deleteAllMessages();     
1:             }
0:         });
1:         
1:         final Timer timer = new Timer();
0:         schedualRestartTask(timer, null);
1:         
1:         try {
0:             verifyOrderedMessageReceipt();
1:         } finally {
1:             timer.cancel();
1:         }
1:     }
1: 
0:                 AMQPersistenceAdapterFactory persistenceFactory =
0:                     (AMQPersistenceAdapterFactory) broker.getPersistenceFactory();
/////////////////////////////////////////////////////////////////////////
0:                 AMQPersistenceAdapterFactory persistenceFactory =
0:                     (AMQPersistenceAdapterFactory) broker.getPersistenceFactory();
0: //                PolicyEntry auditDepthPolicy = new PolicyEntry();
0: //                auditDepthPolicy.setMaxAuditDepth(2000);
0: //                PolicyMap policyMap = new PolicyMap();
0: //                policyMap.setDefaultEntry(auditDepthPolicy);
0: //                broker.setDestinationPolicy(policyMap);
/////////////////////////////////////////////////////////////////////////
1:         class RestartTask extends TimerTask {
/////////////////////////////////////////////////////////////////////////
1:                         broker.waitUntilStarted();
0:                 // do it again
1:                 try {
0:                     timer.schedule(new RestartTask(), BROKER_STOP_PERIOD);
0:                 } catch (IllegalStateException ignore_alreadyCancelled) {   
1:                 }
1:             } 
1:         }
0:         timer.schedule(new RestartTask(), BROKER_STOP_PERIOD);
/////////////////////////////////////////////////////////////////////////
0:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 10;
1:         while(!threads.isEmpty() && exceptions.isEmpty() && System.currentTimeMillis() < expiry) {
1:         }
0:         LOG.info("senders done...");
1:         
1:         while(!receivers.isEmpty() && System.currentTimeMillis() < expiry) {
0:             if (receiver.getNextExpectedSeqNo() >= MAX_TO_SEND || !exceptions.isEmpty()) {
commit:86ec055
/////////////////////////////////////////////////////////////////////////
1: import java.util.Timer;
1: import java.util.TimerTask;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.amq.AMQPersistenceAdapterFactory;
1: interface Configurer {
1:     public void configure(BrokerService broker) throws Exception;
1: }
1: 
0:     private static final Log LOG = LogFactory.getLog(AMQ2149Test.class);
0:     private static final long BROKER_STOP_PERIOD = 15 * 1000;
1: 
1:     private static final String BROKER_CONNECTOR = "tcp://localhost:61617";
0:     private static final String BROKER_URL = "failover:("+ BROKER_CONNECTOR
1:         +")?maxReconnectDelay=1000&useExponentialBackOff=false";
1:         
1:     final Object brokerLock = new Object();
1:     public void createBroker(Configurer configurer) throws Exception {
0:         broker.setDataDirectory("target/amq-data/" + getName());
1:         broker.addConnector(BROKER_CONNECTOR);        
1:         if (configurer != null) {
1:             configurer.configure(broker);
1:         }
0:         broker.setBrokerName(getName());
0:         synchronized(brokerLock) {
0:             broker.stop();
0:             broker.waitUntilStopped();
1:         }
1:         exceptions.clear();
/////////////////////////////////////////////////////////////////////////
1:         
1:         private String lastId = null;
/////////////////////////////////////////////////////////////////////////
1:         public void close() throws JMSException {
1:             connection.close();
1:         }
1:         
1:         public long getNextExpectedSeqNo() {
1:             return nextExpectedSeqNum;
1:         }
1:         
0:                     LOG.info(queueName + " received " + seqNum);
0:                     LOG.warn(queueName + " received " + seqNum
1:                             + " in msg: " + message.getJMSMessageID()
1:                             + " expected "
1:                             + nextExpectedSeqNum
0:                             + ", lastId: " + lastId);
1:                 lastId = message.getJMSMessageID();
0:                 LOG.error(queueName + " onMessage error", e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error(queueName + " send error", e);
0:                     LOG.warn(queueName + " sleep interrupted", e);
1:             try {
1:                 connection.close();
1:             } catch (JMSException ignored) {
1:             }
0:     public void testOrderWithMemeUsageLimit() throws Exception {
1:         
0:         createBroker(new Configurer() {
0:             public void configure(BrokerService broker) throws Exception {
0:                 SystemUsage usage = new SystemUsage();
0:                 MemoryUsage memoryUsage = new MemoryUsage();
0:                 memoryUsage.setLimit(2048 * 7 * NUM_SENDERS_AND_RECEIVERS);
0:                 usage.setMemoryUsage(memoryUsage);
0:                 broker.setSystemUsage(usage);
1:                 
0:                 broker.deleteAllMessages();            
1:             }
0:         });
1:         
0:         verifyOrderedMessageReceipt();
1:     }
1: 
0:     public void testOrderWithRestartVMIndex() throws Exception {
0:         createBroker(new Configurer() {
0:             public void configure(BrokerService broker) throws Exception {
0:                 AMQPersistenceAdapterFactory persistenceFactory = new AMQPersistenceAdapterFactory();
0:                 persistenceFactory.setPersistentIndex(false);
0:                 broker.setPersistenceFactory(persistenceFactory);
0:                 broker.deleteAllMessages();     
1:             }
0:         });
1:         
0:         final Timer timer = new Timer();
0:         schedualRestartTask(timer, new Configurer() {
0:             public void configure(BrokerService broker) throws Exception {
0:                 AMQPersistenceAdapterFactory persistenceFactory = new AMQPersistenceAdapterFactory();
0:                 persistenceFactory.setPersistentIndex(false);
0:                 broker.setPersistenceFactory(persistenceFactory);
1:             }
0:         });
1:         
1:         try {
0:             verifyOrderedMessageReceipt();
0:         } finally {
0:             timer.cancel();
1:         }
1:     }
1: 
1:     
0:     public void x_testOrderWithRestartWithForceRecover() throws Exception {
0:         createBroker(new Configurer() {
0:             public void configure(BrokerService broker) throws Exception {
0:                 AMQPersistenceAdapterFactory persistenceFactory = new AMQPersistenceAdapterFactory();
0:                 persistenceFactory.setForceRecoverReferenceStore(true);
0:                 broker.setPersistenceFactory(persistenceFactory);
0:                 broker.deleteAllMessages();     
1:             }
0:         });
1:         
0:         final Timer timer = new Timer();
0:         schedualRestartTask(timer, new Configurer() {
0:             public void configure(BrokerService broker) throws Exception {
0:                 AMQPersistenceAdapterFactory persistenceFactory = new AMQPersistenceAdapterFactory();
0:                 persistenceFactory.setForceRecoverReferenceStore(true);
0:                 broker.setPersistenceFactory(persistenceFactory);
1:             }
0:         });
1:         
1:         try {
0:             verifyOrderedMessageReceipt();
0:         } finally {
0:             timer.cancel();
1:         }
1:     }
1: 
0:     private void schedualRestartTask(Timer timer) {
0:         schedualRestartTask(timer, null);   
1:     }
1: 
0:     private void schedualRestartTask(final Timer timer, final Configurer configurer) {
0:         timer.schedule(new TimerTask() {
1:             public void run() {
1:                 synchronized (brokerLock) {
1:                     LOG.info("stopping broker..");
1:                     try {
0:                         broker.stop();
1:                     } catch (Exception e) {
1:                         LOG.error("ex on broker stop", e);
1:                         exceptions.add(e);
1:                     }
1:                     LOG.info("restarting broker");
1:                     try {
1:                         createBroker(configurer);
1:                     } catch (Exception e) {
1:                         LOG.error("ex on broker restart", e);
1:                         exceptions.add(e);
1:                     }
1:                 }
0:                 // do once
0:                 // timer.cancel();
1:             }            
0:         }, BROKER_STOP_PERIOD, BROKER_STOP_PERIOD);
1:     }
1:     
0:     private void verifyOrderedMessageReceipt() throws Exception {
1:         
1:         Vector<Receiver> receivers = new Vector<Receiver>();
0:             receivers.add(new Receiver(queueName));
0:         while(!threads.isEmpty() && !receivers.isEmpty() 
0:                 && exceptions.isEmpty() && System.currentTimeMillis() < expiry) {
1:             
1:             Receiver receiver = receivers.firstElement();
0:             if (receiver.getNextExpectedSeqNo() >= MAX_TO_SEND) {
1:                 receiver.close();
1:                 receivers.remove(receiver);
1:             }
0:         assertTrue("No timeout waiting for senders/receivers to complete", System.currentTimeMillis() < expiry);
commit:08aecbe
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
1: package org.apache.activemq.bugs;
0: 
1: import java.util.Vector;
0: 
0: import junit.framework.TestCase;
0: 
0: import javax.jms.Connection;
0: import javax.jms.DeliveryMode;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.usage.SystemUsage;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: public class AMQ2149Test extends TestCase {
0: 
0:     private static final Log log = LogFactory.getLog(AMQ2149Test.class);
0: 
0:     private String BROKER_URL;
1:     private final String SEQ_NUM_PROPERTY = "seqNum";
0: 
0:     final int MESSAGE_LENGTH_BYTES = 75000;
0:     final int MAX_TO_SEND  = 2000;
0:     final long SLEEP_BETWEEN_SEND_MS = 5;
1:     final int NUM_SENDERS_AND_RECEIVERS = 10;
0:     
1:     BrokerService broker;
1:     Vector<Throwable> exceptions = new Vector<Throwable>();
0:     
0:     public void setUp() throws Exception {
1:         broker = new BrokerService();
0:         broker.addConnector("tcp://localhost:0");
0:         broker.deleteAllMessages();
0:         
0:         SystemUsage usage = new SystemUsage();
0:         MemoryUsage memoryUsage = new MemoryUsage();
0:         memoryUsage.setLimit(2048 * 7 * NUM_SENDERS_AND_RECEIVERS);
0:         usage.setMemoryUsage(memoryUsage);
0:         broker.setSystemUsage(usage);
1:         broker.start();
0: 
0:         BROKER_URL = "failover:("
0:             + broker.getTransportConnectors().get(0).getUri()
0:             +")?maxReconnectDelay=1000&useExponentialBackOff=false";
1:     }
0:     
1:     public void tearDown() throws Exception {
0:         broker.stop();
1:     }
0:     
1:     private String buildLongString() {
1:         final StringBuilder stringBuilder = new StringBuilder(
1:                 MESSAGE_LENGTH_BYTES);
1:         for (int i = 0; i < MESSAGE_LENGTH_BYTES; ++i) {
1:             stringBuilder.append((int) (Math.random() * 10));
1:         }
1:         return stringBuilder.toString();
1:     }
0: 
1:     private class Receiver implements MessageListener {
0: 
0:         private final String queueName;
0: 
1:         private final Connection connection;
0: 
1:         private final Session session;
0: 
1:         private final MessageConsumer messageConsumer;
0: 
0:         private volatile long nextExpectedSeqNum = 0;
0: 
0:         public Receiver(String queueName) throws JMSException {
0:             this.queueName = queueName;
0:             connection = new ActiveMQConnectionFactory(BROKER_URL)
1:                     .createConnection();
1:             session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             messageConsumer = session.createConsumer(new ActiveMQQueue(
0:                     queueName));
1:             messageConsumer.setMessageListener(this);
1:             connection.start();
1:         }
0: 
1:         public void onMessage(Message message) {
0:             try {
1:                 final long seqNum = message.getLongProperty(SEQ_NUM_PROPERTY);
0:                 if ((seqNum % 100) == 0) {
0:                     log.info(queueName + " received " + seqNum);
1:                 }
1:                 if (seqNum != nextExpectedSeqNum) {
0:                     log.warn(queueName + " received " + seqNum + " expected "
1:                             + nextExpectedSeqNum);
0:                     fail(queueName + " received " + seqNum + " expected "
1:                             + nextExpectedSeqNum);
1:                 }
1:                 ++nextExpectedSeqNum;
1:             } catch (Throwable e) {
0:                 log.error(queueName + " onMessage error", e);
1:                 exceptions.add(e);
1:             }
1:         }
0: 
1:     }
0: 
1:     private class Sender implements Runnable {
0: 
0:         private final String queueName;
0: 
1:         private final Connection connection;
0: 
1:         private final Session session;
0: 
1:         private final MessageProducer messageProducer;
0: 
1:         private volatile long nextSequenceNumber = 0;
0: 
0:         public Sender(String queueName) throws JMSException {
0:             this.queueName = queueName;
0:             connection = new ActiveMQConnectionFactory(BROKER_URL)
1:                     .createConnection();
1:             session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             messageProducer = session.createProducer(new ActiveMQQueue(
0:                     queueName));
1:             messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:             connection.start();
1:         }
0: 
1:         public void run() {
1:             final String longString = buildLongString();
0:             while (nextSequenceNumber <= MAX_TO_SEND) {
0:                 try {
1:                     final Message message = session
1:                             .createTextMessage(longString);
1:                     message.setLongProperty(SEQ_NUM_PROPERTY,
0:                             nextSequenceNumber);
0:                     ++nextSequenceNumber;
1:                     messageProducer.send(message);
1:                 } catch (Exception e) {
0:                     log.error(queueName + " send error", e);
1:                     exceptions.add(e);
1:                 }
0:                 try {
0:                     Thread.sleep(SLEEP_BETWEEN_SEND_MS);
0:                 } catch (InterruptedException e) {
0:                     log.warn(queueName + " sleep interrupted", e);
1:                 }
1:             }
1:         }
1:     }
0: 
0:     public void testOutOfOrderWithMemeUsageLimit() throws Exception {
1:         Vector<Thread> threads = new Vector<Thread>();
0:         
0:         for (int i = 0; i < NUM_SENDERS_AND_RECEIVERS; ++i) {
0:             final String queueName = "test.queue." + i;
0:             new Receiver(queueName);
0:             Thread thread = new Thread(new Sender(queueName));
1:             thread.start();
1:             threads.add(thread);
1:         }
0:         
0:         final long expiry = System.currentTimeMillis() + 1000 * 60 * 5;
0:         while(!threads.isEmpty() && exceptions.isEmpty() && System.currentTimeMillis() < expiry) {
1:             Thread sendThread = threads.firstElement();
0:             sendThread.join(1000*10);
1:             if (!sendThread.isAlive()) {
1:                 threads.remove(sendThread);
1:             }
1:         }
0:         assertTrue("No timeout waiting for senders to complete", System.currentTimeMillis() < expiry);
1:         assertTrue("No exceptions", exceptions.isEmpty());
1:     }
0: 
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:7071102
/////////////////////////////////////////////////////////////////////////
1:     protected File dataDirFile;
/////////////////////////////////////////////////////////////////////////
commit:b2fca26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.leveldb.LevelDBStore;
/////////////////////////////////////////////////////////////////////////
0:         LevelDBStore persistenceFactory = new LevelDBStore();
0:         persistenceFactory.setDirectory(dataDirFile);
0:         brokerService.setPersistenceAdapter(persistenceFactory);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(AMQ2149Test.class);
============================================================================