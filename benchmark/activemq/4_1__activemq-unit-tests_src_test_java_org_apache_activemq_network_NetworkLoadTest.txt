1:8bf987b: /**
1:8bf987b:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8bf987b:  * contributor license agreements.  See the NOTICE file distributed with
1:8bf987b:  * this work for additional information regarding copyright ownership.
1:8bf987b:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8bf987b:  * (the "License"); you may not use this file except in compliance with
1:8bf987b:  * the License.  You may obtain a copy of the License at
1:8bf987b:  *
1:8bf987b:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8bf987b:  *
1:8bf987b:  * Unless required by applicable law or agreed to in writing, software
1:8bf987b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8bf987b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8bf987b:  * See the License for the specific language governing permissions and
1:8bf987b:  * limitations under the License.
1:8bf987b:  */
1:8bf987b: package org.apache.activemq.network;
1:8bf987b: 
1:8bf987b: import java.net.URI;
1:8bf987b: import java.util.ArrayList;
1:8bf987b: import java.util.Date;
1:8bf987b: import java.util.List;
1:8bf987b: import java.util.concurrent.atomic.AtomicBoolean;
1:8bf987b: import java.util.concurrent.atomic.AtomicLong;
1:8bf987b: import java.util.concurrent.atomic.AtomicReference;
1:8bf987b: 
1:8bf987b: import javax.jms.Connection;
1:8bf987b: import javax.jms.DeliveryMode;
1:8bf987b: import javax.jms.JMSException;
1:8bf987b: import javax.jms.Message;
1:8bf987b: import javax.jms.MessageConsumer;
1:8bf987b: import javax.jms.MessageListener;
1:8bf987b: import javax.jms.MessageProducer;
1:8bf987b: import javax.jms.Session;
1:8bf987b: import javax.jms.TextMessage;
1:8bf987b: 
1:8bf987b: import junit.framework.TestCase;
1:8bf987b: 
1:8bf987b: import org.apache.activemq.ActiveMQConnectionFactory;
1:8bf987b: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:8bf987b: import org.apache.activemq.broker.BrokerService;
1:8bf987b: import org.apache.activemq.broker.TransportConnector;
1:8bf987b: import org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy;
1:8bf987b: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:8bf987b: import org.apache.activemq.broker.region.policy.PolicyMap;
1:8bf987b: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
1:8bf987b: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
1:8bf987b: import org.apache.activemq.command.ActiveMQQueue;
1:8bf987b: import org.apache.activemq.command.ActiveMQTextMessage;
1:8bf987b: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:8bf987b: 
1:8bf987b: /**
1:8bf987b:  * This test case is used to load test store and forwarding between brokers.  It sets up
1:8bf987b:  * n brokers to which have a chain of queues which this test consumes and produces to. 
1:8bf987b:  * 
1:8bf987b:  * If the network bridges gets stuck at any point subsequent queues will not get messages.  This test 
1:8bf987b:  * samples the production and consumption stats every second and if the flow of messages
1:8bf987b:  * get stuck then this tast fails.  The test monitors the flow of messages for 1 min.
1:8bf987b:  *  
1:8bf987b:  * @author chirino
1:8bf987b:  */
1:8bf987b: public class NetworkLoadTest extends TestCase {
1:8bf987b: 
1:8bf987b: 	private static final transient Logger LOG = LoggerFactory.getLogger(NetworkLoadTest.class);
1:8bf987b: 
1:8bf987b: 	// How many times do we sample?
1:8bf987b:     private static final long SAMPLES = Integer.parseInt(System.getProperty("SAMPLES", ""+60*1/5)); 
1:8bf987b:     // Slower machines might need to make this bigger.
1:8bf987b:     private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty("SAMPLES_DURATION", "" + 1000 * 5));
1:8bf987b: 	protected static final int BROKER_COUNT = 4;
1:8bf987b: 	protected static final int MESSAGE_SIZE = 2000;
1:8bf987b:         String groupId;
1:8bf987b:         
1:8bf987b: 	class ForwardingClient {
1:8bf987b: 
1:8bf987b: 		private final AtomicLong forwardCounter = new AtomicLong();
1:8bf987b: 		private final Connection toConnection;
1:8bf987b: 		private final Connection fromConnection;
1:8bf987b: 
1:8bf987b: 		public ForwardingClient(int from, int to) throws JMSException {
1:8bf987b: 			toConnection = createConnection(from);
1:8bf987b: 			Session toSession = toConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8bf987b: 			final MessageProducer producer = toSession.createProducer(new ActiveMQQueue("Q"+to));
1:8bf987b: 			producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:8bf987b: 			producer.setDisableMessageID(true);
1:8bf987b: 
1:8bf987b: 			fromConnection = createConnection(from);
1:8bf987b: 			Session fromSession = fromConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8bf987b: 			MessageConsumer consumer = fromSession.createConsumer(new ActiveMQQueue("Q"+from));
1:8bf987b: 			
1:8bf987b: 			consumer.setMessageListener(new MessageListener() {
1:8bf987b: 					public void onMessage(Message msg) {
1:8bf987b: 						try {
1:8bf987b: 							producer.send(msg);
1:8bf987b: 							forwardCounter.incrementAndGet();
1:8bf987b: 						} catch (JMSException e) {
1:8bf987b: 							// this is caused by the connection getting closed. 
1:8bf987b: 						}
1:8bf987b: 					}
1:8bf987b: 			});
1:8bf987b: 		}
1:8bf987b: 
1:8bf987b: 		public void start() throws JMSException {
1:8bf987b: 			toConnection.start();
1:8bf987b: 			fromConnection.start();
1:8bf987b: 		}
1:8bf987b: 		
1:8bf987b: 		public void stop() throws JMSException {
1:8bf987b: 		        toConnection.stop();
1:8bf987b: 			fromConnection.stop();
1:8bf987b: 		}
1:8bf987b: 		
1:8bf987b: 		public void close() throws JMSException {
1:8bf987b: 			toConnection.close();
1:8bf987b: 			fromConnection.close();
1:8bf987b: 		}
1:8bf987b: 	}
1:8bf987b: 
1:8bf987b: 	private BrokerService[] brokers;
1:8bf987b: 	private ForwardingClient[] forwardingClients;
1:8bf987b: 
1:8bf987b: 	
1:8bf987b: 	protected void setUp() throws Exception {
1:8bf987b: 	        groupId = "network-load-test-"+System.currentTimeMillis();
1:8bf987b: 		brokers = new BrokerService[BROKER_COUNT];
1:8bf987b: 		for (int i = 0; i < brokers.length; i++) {
1:8bf987b: 		    LOG.info("Starting broker: "+i);
1:8bf987b: 			brokers[i] = createBroker(i);
1:8bf987b: 			brokers[i].start();
1:8bf987b: 		}
1:8bf987b: 		
1:8bf987b: 		// Wait for the network connection to get setup.
1:8bf987b: 		// The wait is exponential since every broker has to connect to every other broker.
1:8bf987b: 		Thread.sleep(BROKER_COUNT*BROKER_COUNT*50);
1:8bf987b: 		
1:8bf987b: 		forwardingClients = new ForwardingClient[BROKER_COUNT-1];		
1:8bf987b: 		for (int i = 0; i < forwardingClients.length; i++) {
1:8bf987b: 		    LOG.info("Starting fowarding client "+i);
1:8bf987b: 			forwardingClients[i] = new ForwardingClient(i, i+1);
1:8bf987b: 			forwardingClients[i].start();
1:8bf987b: 		}
1:8bf987b: 	}
1:8bf987b: 
1:8bf987b: 	protected void tearDown() throws Exception {
1:8bf987b: 		for (int i = 0; i < forwardingClients.length; i++) {
1:8bf987b: 		    LOG.info("Stoping fowarding client "+i);
1:8bf987b: 			forwardingClients[i].close();
1:8bf987b: 		}
1:8bf987b: 		for (int i = 0; i < brokers.length; i++) {
1:8bf987b: 		    LOG.info("Stoping broker "+i);
1:8bf987b: 			brokers[i].stop();
1:8bf987b: 		}
1:8bf987b: 	}
1:8bf987b: 
1:8bf987b: 	protected Connection createConnection(int brokerId) throws JMSException {
1:8bf987b: 		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:"+(60000+brokerId));
1:8bf987b:         connectionFactory.setOptimizedMessageDispatch(true);
1:8bf987b:         connectionFactory.setCopyMessageOnSend(false);
1:8bf987b:         connectionFactory.setUseCompression(false);
1:8bf987b:         connectionFactory.setDispatchAsync(true);
1:8bf987b:         connectionFactory.setUseAsyncSend(false);
1:8bf987b:         connectionFactory.setOptimizeAcknowledge(false);
1:8bf987b:         connectionFactory.setWatchTopicAdvisories(false);
1:8bf987b:         ActiveMQPrefetchPolicy qPrefetchPolicy= new ActiveMQPrefetchPolicy();
1:8bf987b:         qPrefetchPolicy.setQueuePrefetch(100);
1:8bf987b:         qPrefetchPolicy.setTopicPrefetch(1000);
1:8bf987b:         connectionFactory.setPrefetchPolicy(qPrefetchPolicy);
1:8bf987b:         connectionFactory.setAlwaysSyncSend(true);
1:8bf987b: 		return connectionFactory.createConnection();
1:8bf987b: 	}
1:8bf987b: 
1:8bf987b: 	protected BrokerService createBroker(int brokerId) throws Exception {
1:8bf987b: 		BrokerService broker = new BrokerService();
1:8bf987b: 		broker.setBrokerName("broker-" + brokerId);
1:8bf987b: 		broker.setPersistent(false);
1:8bf987b: 		broker.setUseJmx(true);
1:8bf987b: 		broker.getManagementContext().setCreateConnector(false);
1:8bf987b: 
1:8bf987b: 		final SystemUsage memoryManager = new SystemUsage();
1:8bf987b: 		memoryManager.getMemoryUsage().setLimit(1024 * 1024 * 50); // 50 MB
1:8bf987b: 		broker.setSystemUsage(memoryManager);
1:8bf987b: 
1:8bf987b: 		final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
1:8bf987b: 		final PolicyEntry entry = new PolicyEntry();
1:8bf987b: 		entry.setQueue(">");
1:8bf987b: 		entry.setMemoryLimit(1024 * 1024 * 1); // Set to 1 MB
1:8bf987b: 		entry.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
1:8bf987b: 		entry.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
1:8bf987b: 		policyEntries.add(entry);
1:8bf987b: 
1:8bf987b: 		// This is to turn of the default behavior of storing topic messages for retroactive consumption
1:8bf987b: 		final PolicyEntry topicPolicyEntry = new PolicyEntry();
1:8bf987b: 		topicPolicyEntry.setTopic(">");
1:8bf987b: 		final NoSubscriptionRecoveryPolicy noSubscriptionRecoveryPolicy = new NoSubscriptionRecoveryPolicy();
1:8bf987b: 		topicPolicyEntry.setSubscriptionRecoveryPolicy(noSubscriptionRecoveryPolicy);
1:8bf987b: 
1:8bf987b: 		final PolicyMap policyMap = new PolicyMap();
1:8bf987b: 		policyMap.setPolicyEntries(policyEntries);
1:8bf987b: 		broker.setDestinationPolicy(policyMap);
1:8bf987b: 		
1:8bf987b:         TransportConnector transportConnector = new TransportConnector();
1:8bf987b:         transportConnector.setUri(new URI("tcp://localhost:"+(60000+brokerId)));
1:8bf987b:         
1:8bf987b:         transportConnector.setDiscoveryUri(new URI("multicast://default?group="+groupId));        
1:8bf987b:         broker.addConnector(transportConnector);
1:8bf987b:                         
1:8bf987b:         DiscoveryNetworkConnector networkConnector = new DiscoveryNetworkConnector();
1:8bf987b:         networkConnector.setUri(new URI("multicast://default?group="+groupId));
1:8bf987b: 	    networkConnector.setBridgeTempDestinations(true);
1:8bf987b: 	    networkConnector.setPrefetchSize(1);
1:8bf987b: 	    broker.addNetworkConnector(networkConnector);
1:8bf987b:         
1:8bf987b: 		return broker;
1:8bf987b: 	}
1:8bf987b: 	
1:8bf987b: 	public void testRequestReply() throws Exception {
1:8bf987b: 
1:8bf987b: 		final int to = 0; // Send to the first broker
1:8bf987b: 		int from = brokers.length-1; // consume from the last broker..
1:8bf987b: 				
1:8bf987b: 	    LOG.info("Staring Final Consumer");
1:8bf987b: 
1:8bf987b: 	    Connection fromConnection = createConnection(from);
1:8bf987b: 		fromConnection.start();
1:8bf987b: 		Session fromSession = fromConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8bf987b: 		MessageConsumer consumer = fromSession.createConsumer(new ActiveMQQueue("Q"+from));
1:8bf987b: 		
1:8bf987b: 		final AtomicReference<ActiveMQTextMessage> lastMessageReceived = new AtomicReference<ActiveMQTextMessage>();
1:8bf987b: 		final AtomicLong producedMessages = new AtomicLong();
1:8bf987b: 		final AtomicLong receivedMessages = new AtomicLong();
1:8bf987b: 		final AtomicBoolean done = new AtomicBoolean();
1:8bf987b: 
1:8bf987b: 		// Setup the consumer..
1:8bf987b: 		consumer.setMessageListener(new MessageListener() {
1:8bf987b: 			public void onMessage(Message msg) {
1:8bf987b: 				ActiveMQTextMessage m = (ActiveMQTextMessage) msg;
1:8bf987b: 				ActiveMQTextMessage last = lastMessageReceived.get();
1:8bf987b: 				if( last!=null ) {
1:8bf987b: 					// Some order checking...
1:8bf987b: 					if( last.getMessageId().getProducerSequenceId() > m.getMessageId().getProducerSequenceId() ) {
1:8bf987b: 						System.out.println("Received an out of order message. Got "+m.getMessageId()+", expected something after "+last.getMessageId());
1:8bf987b: 					}
1:8bf987b: 				}
1:8bf987b: 				lastMessageReceived.set(m);
1:8bf987b: 				receivedMessages.incrementAndGet();
1:8bf987b: 			}
1:8bf987b: 		});
1:8bf987b: 
1:8bf987b: 	    LOG.info("Staring Initial Producer");
1:8bf987b: 		final Connection toConnection = createConnection(to);
1:8bf987b: 		Thread producer = new Thread("Producer") {
1:8bf987b: 			@Override
1:8bf987b: 			public void run() {
1:8bf987b: 				try {
1:8bf987b: 					toConnection.start();
1:8bf987b: 					Session toSession = toConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8bf987b: 					final MessageProducer producer = toSession.createProducer(new ActiveMQQueue("Q"+to));
1:8bf987b: 					producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:8bf987b: 					producer.setDisableMessageID(true);
1:8bf987b: 
1:8bf987b: 					for (int i = 0; !done.get(); i++) {
1:8bf987b: 						TextMessage msg = toSession.createTextMessage(createMessageText(i));
1:8bf987b: 						producer.send(msg);
1:8bf987b: 						producedMessages.incrementAndGet();
1:8bf987b: 					}
1:8bf987b: 				} catch (JMSException e) {
1:8bf987b: 					e.printStackTrace();
1:8bf987b: 				}
1:8bf987b: 			}
1:8bf987b: 			
1:8bf987b: 		    private String createMessageText(int index) {
1:8bf987b: 				StringBuffer buffer = new StringBuffer(MESSAGE_SIZE);
1:8bf987b: 				buffer.append(index + " on " + new Date() + " ...");
1:8bf987b: 				if (buffer.length() > MESSAGE_SIZE) {
1:8bf987b: 					return buffer.substring(0, MESSAGE_SIZE);
1:8bf987b: 				}
1:8bf987b: 				for (int i = buffer.length(); i < MESSAGE_SIZE; i++) {
1:8bf987b: 					buffer.append(' ');
1:8bf987b: 				}
1:8bf987b: 
1:8bf987b: 				return buffer.toString();
1:8bf987b: 			}
1:8bf987b: 		};
1:8bf987b: 		producer.start();
1:8bf987b: 	
1:8bf987b: 		
1:8bf987b: 		// Give the forwarding clients a chance to get going and fill the down
1:8bf987b: 		// stream broker queues..
1:8bf987b: 		Thread.sleep(BROKER_COUNT*200);
1:8bf987b: 		
1:8bf987b:         for (int i = 0; i < SAMPLES; i++) {
1:8bf987b: 
1:8bf987b:             long start = System.currentTimeMillis();
1:8bf987b:             producedMessages.set(0);
1:8bf987b:             receivedMessages.set(0);
1:8bf987b:             for (int j = 0; j < forwardingClients.length; j++) {
1:8bf987b:     			forwardingClients[j].forwardCounter.set(0);
1:8bf987b:     		}
1:8bf987b: 
1:8bf987b:             Thread.sleep(SAMPLE_DURATION);
1:8bf987b: 
1:8bf987b:             long end = System.currentTimeMillis();
1:8bf987b:             long r = receivedMessages.get();
1:8bf987b:             long p = producedMessages.get();
1:8bf987b: 
1:8bf987b:             LOG.info("published: " + p + " msgs at " + (p * 1000f / (end - start)) + " msgs/sec, " + "consumed: " + r + " msgs at " + (r * 1000f / (end - start)) + " msgs/sec");
1:8bf987b:             
1:8bf987b:             StringBuffer fwdingmsg = new StringBuffer(500);
1:8bf987b:             fwdingmsg.append("  forwarding counters: ");
1:8bf987b:             for (int j = 0; j < forwardingClients.length; j++) {
1:8bf987b:             	if( j!= 0 ) {
1:8bf987b:             		fwdingmsg.append(", ");
1:8bf987b:             	}
1:8bf987b:                 fwdingmsg.append(forwardingClients[j].forwardCounter.get());
1:8bf987b:     		}
1:8bf987b:             LOG.info(fwdingmsg.toString());
1:8bf987b: 
1:8bf987b:             // The test is just checking to make sure thaat the producer and consumer does not hang
1:8bf987b:             // due to the network hops take to route the message form the producer to the consumer.
1:8bf987b:             assertTrue("Recieved some messages since last sample", r>0);
1:8bf987b:             assertTrue("Produced some messages since last sample", p>0);
1:8bf987b:             
1:8bf987b:         }
1:8bf987b:         LOG.info("Sample done.");
1:8bf987b:         done.set(true);
1:8bf987b:         // Wait for the producer to finish.
1:8bf987b:         producer.join(1000*5);
1:8bf987b:         toConnection.close();
1:8bf987b:         fromConnection.close();
1:8bf987b:         
1:8bf987b: 	}
1:8bf987b: 
1:8bf987b: 
1:8bf987b: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
1: 
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Date;
1: import java.util.List;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicLong;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
1: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * This test case is used to load test store and forwarding between brokers.  It sets up
1:  * n brokers to which have a chain of queues which this test consumes and produces to. 
1:  * 
1:  * If the network bridges gets stuck at any point subsequent queues will not get messages.  This test 
1:  * samples the production and consumption stats every second and if the flow of messages
1:  * get stuck then this tast fails.  The test monitors the flow of messages for 1 min.
1:  *  
1:  * @author chirino
1:  */
1: public class NetworkLoadTest extends TestCase {
1: 
1: 	private static final transient Logger LOG = LoggerFactory.getLogger(NetworkLoadTest.class);
1: 
1: 	// How many times do we sample?
1:     private static final long SAMPLES = Integer.parseInt(System.getProperty("SAMPLES", ""+60*1/5)); 
1:     // Slower machines might need to make this bigger.
1:     private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty("SAMPLES_DURATION", "" + 1000 * 5));
1: 	protected static final int BROKER_COUNT = 4;
1: 	protected static final int MESSAGE_SIZE = 2000;
1:         String groupId;
1:         
1: 	class ForwardingClient {
1: 
1: 		private final AtomicLong forwardCounter = new AtomicLong();
1: 		private final Connection toConnection;
1: 		private final Connection fromConnection;
1: 
1: 		public ForwardingClient(int from, int to) throws JMSException {
1: 			toConnection = createConnection(from);
1: 			Session toSession = toConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 			final MessageProducer producer = toSession.createProducer(new ActiveMQQueue("Q"+to));
1: 			producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1: 			producer.setDisableMessageID(true);
1: 
1: 			fromConnection = createConnection(from);
1: 			Session fromSession = fromConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 			MessageConsumer consumer = fromSession.createConsumer(new ActiveMQQueue("Q"+from));
1: 			
1: 			consumer.setMessageListener(new MessageListener() {
1: 					public void onMessage(Message msg) {
1: 						try {
1: 							producer.send(msg);
1: 							forwardCounter.incrementAndGet();
1: 						} catch (JMSException e) {
1: 							// this is caused by the connection getting closed. 
1: 						}
1: 					}
1: 			});
1: 		}
1: 
1: 		public void start() throws JMSException {
1: 			toConnection.start();
1: 			fromConnection.start();
1: 		}
1: 		
1: 		public void stop() throws JMSException {
1: 		        toConnection.stop();
1: 			fromConnection.stop();
1: 		}
1: 		
1: 		public void close() throws JMSException {
1: 			toConnection.close();
1: 			fromConnection.close();
1: 		}
1: 	}
1: 
1: 	private BrokerService[] brokers;
1: 	private ForwardingClient[] forwardingClients;
1: 
1: 	
1: 	protected void setUp() throws Exception {
1: 	        groupId = "network-load-test-"+System.currentTimeMillis();
1: 		brokers = new BrokerService[BROKER_COUNT];
1: 		for (int i = 0; i < brokers.length; i++) {
1: 		    LOG.info("Starting broker: "+i);
1: 			brokers[i] = createBroker(i);
1: 			brokers[i].start();
1: 		}
1: 		
1: 		// Wait for the network connection to get setup.
1: 		// The wait is exponential since every broker has to connect to every other broker.
1: 		Thread.sleep(BROKER_COUNT*BROKER_COUNT*50);
1: 		
1: 		forwardingClients = new ForwardingClient[BROKER_COUNT-1];		
1: 		for (int i = 0; i < forwardingClients.length; i++) {
1: 		    LOG.info("Starting fowarding client "+i);
1: 			forwardingClients[i] = new ForwardingClient(i, i+1);
1: 			forwardingClients[i].start();
1: 		}
1: 	}
1: 
1: 	protected void tearDown() throws Exception {
1: 		for (int i = 0; i < forwardingClients.length; i++) {
1: 		    LOG.info("Stoping fowarding client "+i);
1: 			forwardingClients[i].close();
1: 		}
1: 		for (int i = 0; i < brokers.length; i++) {
1: 		    LOG.info("Stoping broker "+i);
1: 			brokers[i].stop();
1: 		}
1: 	}
1: 
1: 	protected Connection createConnection(int brokerId) throws JMSException {
1: 		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:"+(60000+brokerId));
1:         connectionFactory.setOptimizedMessageDispatch(true);
1:         connectionFactory.setCopyMessageOnSend(false);
1:         connectionFactory.setUseCompression(false);
1:         connectionFactory.setDispatchAsync(true);
1:         connectionFactory.setUseAsyncSend(false);
1:         connectionFactory.setOptimizeAcknowledge(false);
1:         connectionFactory.setWatchTopicAdvisories(false);
1:         ActiveMQPrefetchPolicy qPrefetchPolicy= new ActiveMQPrefetchPolicy();
1:         qPrefetchPolicy.setQueuePrefetch(100);
1:         qPrefetchPolicy.setTopicPrefetch(1000);
1:         connectionFactory.setPrefetchPolicy(qPrefetchPolicy);
1:         connectionFactory.setAlwaysSyncSend(true);
1: 		return connectionFactory.createConnection();
1: 	}
1: 
1: 	protected BrokerService createBroker(int brokerId) throws Exception {
1: 		BrokerService broker = new BrokerService();
1: 		broker.setBrokerName("broker-" + brokerId);
1: 		broker.setPersistent(false);
1: 		broker.setUseJmx(true);
1: 		broker.getManagementContext().setCreateConnector(false);
1: 
1: 		final SystemUsage memoryManager = new SystemUsage();
1: 		memoryManager.getMemoryUsage().setLimit(1024 * 1024 * 50); // 50 MB
1: 		broker.setSystemUsage(memoryManager);
1: 
1: 		final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
1: 		final PolicyEntry entry = new PolicyEntry();
1: 		entry.setQueue(">");
1: 		entry.setMemoryLimit(1024 * 1024 * 1); // Set to 1 MB
1: 		entry.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
1: 		entry.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
1: 		policyEntries.add(entry);
1: 
1: 		// This is to turn of the default behavior of storing topic messages for retroactive consumption
1: 		final PolicyEntry topicPolicyEntry = new PolicyEntry();
1: 		topicPolicyEntry.setTopic(">");
1: 		final NoSubscriptionRecoveryPolicy noSubscriptionRecoveryPolicy = new NoSubscriptionRecoveryPolicy();
1: 		topicPolicyEntry.setSubscriptionRecoveryPolicy(noSubscriptionRecoveryPolicy);
1: 
1: 		final PolicyMap policyMap = new PolicyMap();
1: 		policyMap.setPolicyEntries(policyEntries);
1: 		broker.setDestinationPolicy(policyMap);
1: 		
1:         TransportConnector transportConnector = new TransportConnector();
1:         transportConnector.setUri(new URI("tcp://localhost:"+(60000+brokerId)));
1:         
1:         transportConnector.setDiscoveryUri(new URI("multicast://default?group="+groupId));        
1:         broker.addConnector(transportConnector);
1:                         
1:         DiscoveryNetworkConnector networkConnector = new DiscoveryNetworkConnector();
1:         networkConnector.setUri(new URI("multicast://default?group="+groupId));
1: 	    networkConnector.setBridgeTempDestinations(true);
1: 	    networkConnector.setPrefetchSize(1);
1: 	    broker.addNetworkConnector(networkConnector);
1:         
1: 		return broker;
1: 	}
1: 	
1: 	public void testRequestReply() throws Exception {
1: 
1: 		final int to = 0; // Send to the first broker
1: 		int from = brokers.length-1; // consume from the last broker..
1: 				
1: 	    LOG.info("Staring Final Consumer");
1: 
1: 	    Connection fromConnection = createConnection(from);
1: 		fromConnection.start();
1: 		Session fromSession = fromConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 		MessageConsumer consumer = fromSession.createConsumer(new ActiveMQQueue("Q"+from));
1: 		
1: 		final AtomicReference<ActiveMQTextMessage> lastMessageReceived = new AtomicReference<ActiveMQTextMessage>();
1: 		final AtomicLong producedMessages = new AtomicLong();
1: 		final AtomicLong receivedMessages = new AtomicLong();
1: 		final AtomicBoolean done = new AtomicBoolean();
1: 
1: 		// Setup the consumer..
1: 		consumer.setMessageListener(new MessageListener() {
1: 			public void onMessage(Message msg) {
1: 				ActiveMQTextMessage m = (ActiveMQTextMessage) msg;
1: 				ActiveMQTextMessage last = lastMessageReceived.get();
1: 				if( last!=null ) {
1: 					// Some order checking...
1: 					if( last.getMessageId().getProducerSequenceId() > m.getMessageId().getProducerSequenceId() ) {
1: 						System.out.println("Received an out of order message. Got "+m.getMessageId()+", expected something after "+last.getMessageId());
1: 					}
1: 				}
1: 				lastMessageReceived.set(m);
1: 				receivedMessages.incrementAndGet();
1: 			}
1: 		});
1: 
1: 	    LOG.info("Staring Initial Producer");
1: 		final Connection toConnection = createConnection(to);
1: 		Thread producer = new Thread("Producer") {
1: 			@Override
1: 			public void run() {
1: 				try {
1: 					toConnection.start();
1: 					Session toSession = toConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 					final MessageProducer producer = toSession.createProducer(new ActiveMQQueue("Q"+to));
1: 					producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1: 					producer.setDisableMessageID(true);
1: 
1: 					for (int i = 0; !done.get(); i++) {
1: 						TextMessage msg = toSession.createTextMessage(createMessageText(i));
1: 						producer.send(msg);
1: 						producedMessages.incrementAndGet();
1: 					}
1: 				} catch (JMSException e) {
1: 					e.printStackTrace();
1: 				}
1: 			}
1: 			
1: 		    private String createMessageText(int index) {
1: 				StringBuffer buffer = new StringBuffer(MESSAGE_SIZE);
1: 				buffer.append(index + " on " + new Date() + " ...");
1: 				if (buffer.length() > MESSAGE_SIZE) {
1: 					return buffer.substring(0, MESSAGE_SIZE);
1: 				}
1: 				for (int i = buffer.length(); i < MESSAGE_SIZE; i++) {
1: 					buffer.append(' ');
1: 				}
1: 
1: 				return buffer.toString();
1: 			}
1: 		};
1: 		producer.start();
1: 	
1: 		
1: 		// Give the forwarding clients a chance to get going and fill the down
1: 		// stream broker queues..
1: 		Thread.sleep(BROKER_COUNT*200);
1: 		
1:         for (int i = 0; i < SAMPLES; i++) {
1: 
1:             long start = System.currentTimeMillis();
1:             producedMessages.set(0);
1:             receivedMessages.set(0);
1:             for (int j = 0; j < forwardingClients.length; j++) {
1:     			forwardingClients[j].forwardCounter.set(0);
1:     		}
1: 
1:             Thread.sleep(SAMPLE_DURATION);
1: 
1:             long end = System.currentTimeMillis();
1:             long r = receivedMessages.get();
1:             long p = producedMessages.get();
1: 
1:             LOG.info("published: " + p + " msgs at " + (p * 1000f / (end - start)) + " msgs/sec, " + "consumed: " + r + " msgs at " + (r * 1000f / (end - start)) + " msgs/sec");
1:             
1:             StringBuffer fwdingmsg = new StringBuffer(500);
1:             fwdingmsg.append("  forwarding counters: ");
1:             for (int j = 0; j < forwardingClients.length; j++) {
1:             	if( j!= 0 ) {
1:             		fwdingmsg.append(", ");
1:             	}
1:                 fwdingmsg.append(forwardingClients[j].forwardCounter.get());
1:     		}
1:             LOG.info(fwdingmsg.toString());
1: 
1:             // The test is just checking to make sure thaat the producer and consumer does not hang
1:             // due to the network hops take to route the message form the producer to the consumer.
1:             assertTrue("Recieved some messages since last sample", r>0);
1:             assertTrue("Produced some messages since last sample", p>0);
1:             
1:         }
1:         LOG.info("Sample done.");
1:         done.set(true);
1:         // Wait for the producer to finish.
1:         producer.join(1000*5);
1:         toConnection.close();
1:         fromConnection.close();
1:         
1: 	}
1: 
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:4a7e0b3
/////////////////////////////////////////////////////////////////////////
0:         transportConnector.setDiscoveryUri(new URI("multicast://default?group="+groupId));        
0:         networkConnector.setUri(new URI("multicast://default?group="+groupId));
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:47ea098
/////////////////////////////////////////////////////////////////////////
0:         String groupId;
0:         
/////////////////////////////////////////////////////////////////////////
0: 	        groupId = "network-load-test-"+System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
commit:a2033b3
/////////////////////////////////////////////////////////////////////////
0:         
0:         String groupId = "network-load-test-"+System.currentTimeMillis();
0:         transportConnector.setDiscoveryUri(new URI("multicast://"+groupId));        
0:         networkConnector.setUri(new URI("multicast://"+groupId));
commit:198dd34
/////////////////////////////////////////////////////////////////////////
0: 		        toConnection.stop();
commit:4fcacf7
/////////////////////////////////////////////////////////////////////////
0: 			toConnection = createConnection(from);
commit:75d43c0
/////////////////////////////////////////////////////////////////////////
0:  * n brokers to which have a chain of queues which this test consumes and produces to. 
/////////////////////////////////////////////////////////////////////////
0:     private static final long SAMPLES = Integer.parseInt(System.getProperty("SAMPLES", ""+60*1/5)); 
0:     private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty("SAMPLES_DURATION", "" + 1000 * 5));
0: 	protected static final int BROKER_COUNT = 4;
commit:e60828c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Date;
0: import javax.jms.DeliveryMode;
/////////////////////////////////////////////////////////////////////////
0: 	protected static final int MESSAGE_SIZE = 2000;
/////////////////////////////////////////////////////////////////////////
0: 			producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 			producer.setDisableMessageID(true);
0: 
0: 					public void onMessage(Message msg) {
0: 						try {
0: 							producer.send(msg);
0: 							forwardCounter.incrementAndGet();
0: 						} catch (JMSException e) {
0: 							// this is caused by the connection getting closed. 
0: 						}
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 					producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 					producer.setDisableMessageID(true);
0: 						TextMessage msg = toSession.createTextMessage(createMessageText(i));
/////////////////////////////////////////////////////////////////////////
0: 			
0: 		    private String createMessageText(int index) {
0: 				StringBuffer buffer = new StringBuffer(MESSAGE_SIZE);
0: 				buffer.append(index + " on " + new Date() + " ...");
0: 				if (buffer.length() > MESSAGE_SIZE) {
0: 					return buffer.substring(0, MESSAGE_SIZE);
0: 				}
0: 				for (int i = buffer.length(); i < MESSAGE_SIZE; i++) {
0: 					buffer.append(' ');
0: 				}
0: 
0: 				return buffer.toString();
0: 			}
0: 		// Give the forwarding clients a chance to get going and fill the down
0: 		// stream broker queues..
commit:b01374e
/////////////////////////////////////////////////////////////////////////
0: 		
0: 		// Wait for the network connection to get setup.
0: 		// The wait is exponential since every broker has to connect to every other broker.
0: 		Thread.sleep(BROKER_COUNT*BROKER_COUNT*50);
0: 		
/////////////////////////////////////////////////////////////////////////
0: 	
0: 		
0: 		// Give the forwarding clients a chance to get going and fill the down stream broker queues..
0: 		Thread.sleep(BROKER_COUNT*200);
commit:a9120b1
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq.network;
0: 
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicLong;
0: import java.util.concurrent.atomic.AtomicReference;
0: 
0: import javax.jms.Connection;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.jms.TextMessage;
0: 
0: import junit.framework.TestCase;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.ActiveMQPrefetchPolicy;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
0: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.usage.SystemUsage;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: /**
0:  * This test case is used to load test store and forwarding between brokers.  It sets up
0:  * 10 brokers to which have a chain of queues which this test consumes and produces to. 
0:  * 
0:  * If the network bridges gets stuck at any point subsequent queues will not get messages.  This test 
0:  * samples the production and consumption stats every second and if the flow of messages
0:  * get stuck then this tast fails.  The test monitors the flow of messages for 1 min.
0:  *  
0:  * @author chirino
0:  */
0: public class NetworkLoadTest extends TestCase {
0: 
0: 	private static final transient Log LOG = LogFactory.getLog(NetworkLoadTest.class);
0: 
0: 	// How many times do we sample?
0:     private static final long SAMPLES = Integer.parseInt(System.getProperty("SAMPLES", ""+60*1)); // 1 min since each sample is 1 sec long.
0:     // Slower machines might need to make this bigger.
0:     private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty("SAMPLES_DURATION", "" + 1000 * 1));
0: 	protected static final int BROKER_COUNT = 10;
0: 
0: 	class ForwardingClient {
0: 
0: 		private final AtomicLong forwardCounter = new AtomicLong();
0: 		private final Connection toConnection;
0: 		private final Connection fromConnection;
0: 
0: 		public ForwardingClient(int from, int to) throws JMSException {
0: 			toConnection = createConnection(to);
0: 			Session toSession = toConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			final MessageProducer producer = toSession.createProducer(new ActiveMQQueue("Q"+to));
0: 			
0: 			fromConnection = createConnection(from);
0: 			Session fromSession = fromConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			MessageConsumer consumer = fromSession.createConsumer(new ActiveMQQueue("Q"+from));
0: 			
0: 			
0: 			consumer.setMessageListener(new MessageListener() {
0: 				public void onMessage(Message msg) {
0: 					try {
0: 						producer.send(msg);
0: 						forwardCounter.incrementAndGet();
0: 					} catch (JMSException e) {
0: 						// this is caused by the connection getting closed. 
0: 					}
0: 				}
0: 			});
0: 		}
0: 
0: 		public void start() throws JMSException {
0: 			toConnection.start();
0: 			fromConnection.start();
0: 		}
0: 		
0: 		public void stop() throws JMSException {
0: 			fromConnection.stop();
0: 			toConnection.stop();
0: 		}
0: 		
0: 		public void close() throws JMSException {
0: 			toConnection.close();
0: 			fromConnection.close();
0: 		}
0: 	}
0: 
0: 	private BrokerService[] brokers;
0: 	private ForwardingClient[] forwardingClients;
0: 	
0: 	protected void setUp() throws Exception {
0: 		brokers = new BrokerService[BROKER_COUNT];
0: 		for (int i = 0; i < brokers.length; i++) {
0: 		    LOG.info("Starting broker: "+i);
0: 			brokers[i] = createBroker(i);
0: 			brokers[i].start();
0: 		}
0: 		// Wait for the brokers to finish starting up and establish thier network connections.
0: 		Thread.sleep(BROKER_COUNT*400);
0: 		forwardingClients = new ForwardingClient[BROKER_COUNT-1];		
0: 		for (int i = 0; i < forwardingClients.length; i++) {
0: 		    LOG.info("Starting fowarding client "+i);
0: 			forwardingClients[i] = new ForwardingClient(i, i+1);
0: 			forwardingClients[i].start();
0: 		}
0: 	}
0: 
0: 	protected void tearDown() throws Exception {
0: 		for (int i = 0; i < forwardingClients.length; i++) {
0: 		    LOG.info("Stoping fowarding client "+i);
0: 			forwardingClients[i].close();
0: 		}
0: 		for (int i = 0; i < brokers.length; i++) {
0: 		    LOG.info("Stoping broker "+i);
0: 			brokers[i].stop();
0: 		}
0: 	}
0: 
0: 	protected Connection createConnection(int brokerId) throws JMSException {
0: 		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:"+(60000+brokerId));
0:         connectionFactory.setOptimizedMessageDispatch(true);
0:         connectionFactory.setCopyMessageOnSend(false);
0:         connectionFactory.setUseCompression(false);
0:         connectionFactory.setDispatchAsync(true);
0:         connectionFactory.setUseAsyncSend(false);
0:         connectionFactory.setOptimizeAcknowledge(false);
0:         connectionFactory.setWatchTopicAdvisories(false);
0:         ActiveMQPrefetchPolicy qPrefetchPolicy= new ActiveMQPrefetchPolicy();
0:         qPrefetchPolicy.setQueuePrefetch(100);
0:         qPrefetchPolicy.setTopicPrefetch(1000);
0:         connectionFactory.setPrefetchPolicy(qPrefetchPolicy);
0:         connectionFactory.setAlwaysSyncSend(true);
0: 		return connectionFactory.createConnection();
0: 	}
0: 
0: 	protected BrokerService createBroker(int brokerId) throws Exception {
0: 		BrokerService broker = new BrokerService();
0: 		broker.setBrokerName("broker-" + brokerId);
0: 		broker.setPersistent(false);
0: 		broker.setUseJmx(true);
0: 		broker.getManagementContext().setCreateConnector(false);
0: 
0: 		final SystemUsage memoryManager = new SystemUsage();
0: 		memoryManager.getMemoryUsage().setLimit(1024 * 1024 * 50); // 50 MB
0: 		broker.setSystemUsage(memoryManager);
0: 
0: 		final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
0: 		final PolicyEntry entry = new PolicyEntry();
0: 		entry.setQueue(">");
0: 		entry.setMemoryLimit(1024 * 1024 * 1); // Set to 1 MB
0: 		entry.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
0: 		entry.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
0: 		policyEntries.add(entry);
0: 
0: 		// This is to turn of the default behavior of storing topic messages for retroactive consumption
0: 		final PolicyEntry topicPolicyEntry = new PolicyEntry();
0: 		topicPolicyEntry.setTopic(">");
0: 		final NoSubscriptionRecoveryPolicy noSubscriptionRecoveryPolicy = new NoSubscriptionRecoveryPolicy();
0: 		topicPolicyEntry.setSubscriptionRecoveryPolicy(noSubscriptionRecoveryPolicy);
0: 
0: 		final PolicyMap policyMap = new PolicyMap();
0: 		policyMap.setPolicyEntries(policyEntries);
0: 		broker.setDestinationPolicy(policyMap);
0: 		
0:         TransportConnector transportConnector = new TransportConnector();
0:         transportConnector.setUri(new URI("tcp://localhost:"+(60000+brokerId)));
0:         transportConnector.setDiscoveryUri(new URI("multicast://network-load-test"));        
0:         broker.addConnector(transportConnector);
0:                         
0:         DiscoveryNetworkConnector networkConnector = new DiscoveryNetworkConnector();
0:         networkConnector.setUri(new URI("multicast://network-load-test"));
0: 	    networkConnector.setBridgeTempDestinations(true);
0: 	    networkConnector.setPrefetchSize(1);
0: 	    broker.addNetworkConnector(networkConnector);
0:         
0: 		return broker;
0: 	}
0: 	
0: 	public void testRequestReply() throws Exception {
0: 
0: 		final int to = 0; // Send to the first broker
0: 		int from = brokers.length-1; // consume from the last broker..
0: 				
0: 	    LOG.info("Staring Final Consumer");
0: 
0: 	    Connection fromConnection = createConnection(from);
0: 		fromConnection.start();
0: 		Session fromSession = fromConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 		MessageConsumer consumer = fromSession.createConsumer(new ActiveMQQueue("Q"+from));
0: 		
0: 		final AtomicReference<ActiveMQTextMessage> lastMessageReceived = new AtomicReference<ActiveMQTextMessage>();
0: 		final AtomicLong producedMessages = new AtomicLong();
0: 		final AtomicLong receivedMessages = new AtomicLong();
0: 		final AtomicBoolean done = new AtomicBoolean();
0: 
0: 		// Setup the consumer..
0: 		consumer.setMessageListener(new MessageListener() {
0: 			public void onMessage(Message msg) {
0: 				ActiveMQTextMessage m = (ActiveMQTextMessage) msg;
0: 				ActiveMQTextMessage last = lastMessageReceived.get();
0: 				if( last!=null ) {
0: 					// Some order checking...
0: 					if( last.getMessageId().getProducerSequenceId() > m.getMessageId().getProducerSequenceId() ) {
0: 						System.out.println("Received an out of order message. Got "+m.getMessageId()+", expected something after "+last.getMessageId());
0: 					}
0: 				}
0: 				lastMessageReceived.set(m);
0: 				receivedMessages.incrementAndGet();
0: 			}
0: 		});
0: 
0: 	    LOG.info("Staring Initial Producer");
0: 		final Connection toConnection = createConnection(to);
0: 		Thread producer = new Thread("Producer") {
0: 			@Override
0: 			public void run() {
0: 				try {
0: 					toConnection.start();
0: 					Session toSession = toConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 					final MessageProducer producer = toSession.createProducer(new ActiveMQQueue("Q"+to));
0: 
0: 					for (int i = 0; !done.get(); i++) {
0: 						TextMessage msg = toSession.createTextMessage("test msg: " + i);
0: 						producer.send(msg);
0: 						producedMessages.incrementAndGet();
0: 					}
0: 				} catch (JMSException e) {
0: 					e.printStackTrace();
0: 				}
0: 			}
0: 		};
0: 		producer.start();
0: 		
0:         for (int i = 0; i < SAMPLES; i++) {
0: 
0:             long start = System.currentTimeMillis();
0:             producedMessages.set(0);
0:             receivedMessages.set(0);
0:             for (int j = 0; j < forwardingClients.length; j++) {
0:     			forwardingClients[j].forwardCounter.set(0);
0:     		}
0: 
0:             Thread.sleep(SAMPLE_DURATION);
0: 
0:             long end = System.currentTimeMillis();
0:             long r = receivedMessages.get();
0:             long p = producedMessages.get();
0: 
0:             LOG.info("published: " + p + " msgs at " + (p * 1000f / (end - start)) + " msgs/sec, " + "consumed: " + r + " msgs at " + (r * 1000f / (end - start)) + " msgs/sec");
0:             
0:             StringBuffer fwdingmsg = new StringBuffer(500);
0:             fwdingmsg.append("  forwarding counters: ");
0:             for (int j = 0; j < forwardingClients.length; j++) {
0:             	if( j!= 0 ) {
0:             		fwdingmsg.append(", ");
0:             	}
0:                 fwdingmsg.append(forwardingClients[j].forwardCounter.get());
0:     		}
0:             LOG.info(fwdingmsg);
0: 
0:             // The test is just checking to make sure thaat the producer and consumer does not hang
0:             // due to the network hops take to route the message form the producer to the consumer.
0:             assertTrue("Recieved some messages since last sample", r>0);
0:             assertTrue("Produced some messages since last sample", p>0);
0:             
0:         }
0:         LOG.info("Sample done.");
0:         done.set(true);
0:         // Wait for the producer to finish.
0:         producer.join(1000*5);
0:         toConnection.close();
0:         fromConnection.close();
0:         
0: 	}
0: 
0: 
0: }
============================================================================