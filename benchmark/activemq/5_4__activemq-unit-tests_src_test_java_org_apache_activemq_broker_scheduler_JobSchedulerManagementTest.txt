1:667f26a: /**
1:667f26a:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:667f26a:  * contributor license agreements.  See the NOTICE file distributed with
1:667f26a:  * this work for additional information regarding copyright ownership.
1:667f26a:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:667f26a:  * (the "License"); you may not use this file except in compliance with
1:667f26a:  * the License.  You may obtain a copy of the License at
1:667f26a:  *
1:667f26a:  *      http://www.apache.org/licenses/LICENSE-2.0
1:667f26a:  *
1:667f26a:  * Unless required by applicable law or agreed to in writing, software
1:667f26a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:667f26a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:667f26a:  * See the License for the specific language governing permissions and
1:667f26a:  * limitations under the License.
1:667f26a:  */
1:667f26a: package org.apache.activemq.broker.scheduler;
6:667f26a: 
1:74846bb: import static org.junit.Assert.assertEquals;
1:74846bb: import static org.junit.Assert.assertNotNull;
1:74846bb: import static org.junit.Assert.assertNull;
1:74846bb: import static org.junit.Assert.fail;
1:74846bb: 
1:667f26a: import java.util.concurrent.CountDownLatch;
1:667f26a: import java.util.concurrent.TimeUnit;
1:667f26a: 
1:667f26a: import javax.jms.Connection;
1:667f26a: import javax.jms.Destination;
1:667f26a: import javax.jms.Message;
1:667f26a: import javax.jms.MessageConsumer;
1:667f26a: import javax.jms.MessageListener;
1:667f26a: import javax.jms.MessageProducer;
1:667f26a: import javax.jms.Session;
1:667f26a: import javax.jms.TextMessage;
1:667f26a: 
1:667f26a: import org.apache.activemq.ScheduledMessage;
1:c691124: import org.apache.activemq.command.ActiveMQMessage;
1:667f26a: import org.apache.activemq.util.IdGenerator;
1:74846bb: import org.junit.Test;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:667f26a: 
1:74846bb: public class JobSchedulerManagementTest extends JobSchedulerTestSupport {
1:667f26a: 
1:8bf987b:     private static final transient Logger LOG = LoggerFactory.getLogger(JobSchedulerManagementTest.class);
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testRemoveAllScheduled() throws Exception {
1:667f26a:         final int COUNT = 5;
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         // Setup the scheduled Message
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(6), COUNT);
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a: 
1:667f26a:         // Create the eventual Consumer to receive the scheduled message
1:667f26a:         MessageConsumer consumer = session.createConsumer(destination);
1:667f26a: 
1:667f26a:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:667f26a:         consumer.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:667f26a:                 latch.countDown();
7:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         connection.start();
1:667f26a: 
2:667f26a:         // Send the remove request
1:667f26a:         MessageProducer producer = session.createProducer(management);
1:667f26a:         Message request = session.createMessage();
1:74846bb:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // Now wait and see if any get delivered, none should.
1:667f26a:         latch.await(10, TimeUnit.SECONDS);
1:667f26a:         assertEquals(latch.getCount(), COUNT);
1:5fd307c: 
1:5fd307c:         connection.close();
1:667f26a:     }
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testRemoveAllScheduledAtTime() throws Exception {
1:667f26a:         final int COUNT = 3;
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         // Setup the scheduled Message
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(6));
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(15));
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(20));
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a:         Destination browseDest = session.createTemporaryQueue();
1:667f26a: 
1:667f26a:         // Create the eventual Consumer to receive the scheduled message
1:667f26a:         MessageConsumer consumer = session.createConsumer(destination);
1:667f26a: 
1:667f26a:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:667f26a:         consumer.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:667f26a:                 latch.countDown();
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         // Create the "Browser"
1:667f26a:         MessageConsumer browser = session.createConsumer(browseDest);
1:667f26a:         final CountDownLatch browsedLatch = new CountDownLatch(COUNT);
1:667f26a:         browser.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:b3c1327:                 browsedLatch.countDown();
1:b3c1327:                 LOG.debug("Scheduled Message Browser got Message: " + message);
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         connection.start();
1:667f26a: 
1:667f26a:         long start = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(10);
1:667f26a:         long end = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(30);
1:667f26a: 
1:b3c1327:         // Send the remove request
1:667f26a:         MessageProducer producer = session.createProducer(management);
1:667f26a:         Message request = session.createMessage();
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME, Long.toString(start));
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME, Long.toString(end));
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // Send the browse request
1:667f26a:         request = session.createMessage();
1:74846bb:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:667f26a:         request.setJMSReplyTo(browseDest);
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // now see if we got back only the one remaining message.
1:667f26a:         latch.await(10, TimeUnit.SECONDS);
1:667f26a:         assertEquals(2, browsedLatch.getCount());
1:667f26a: 
1:667f26a:         // Now wait and see if any get delivered, none should.
1:667f26a:         latch.await(10, TimeUnit.SECONDS);
1:667f26a:         assertEquals(2, latch.getCount());
1:5fd307c: 
1:5fd307c:         connection.close();
1:667f26a:     }
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testBrowseAllScheduled() throws Exception {
1:667f26a:         final int COUNT = 10;
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         // Setup the scheduled Message
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(9), COUNT);
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination requestBrowse = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a:         Destination browseDest = session.createTemporaryQueue();
1:667f26a: 
1:667f26a:         // Create the eventual Consumer to receive the scheduled message
1:667f26a:         MessageConsumer consumer = session.createConsumer(destination);
1:667f26a: 
1:667f26a:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:667f26a:         consumer.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:667f26a:                 latch.countDown();
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         // Create the "Browser"
1:667f26a:         MessageConsumer browser = session.createConsumer(browseDest);
1:667f26a:         final CountDownLatch browsedLatch = new CountDownLatch(COUNT);
1:667f26a:         browser.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:b3c1327:                 browsedLatch.countDown();
1:b3c1327:                 LOG.debug("Scheduled Message Browser got Message: " + message);
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         connection.start();
1:667f26a: 
1:667f26a:         // Send the browse request
1:667f26a:         MessageProducer producer = session.createProducer(requestBrowse);
1:667f26a:         Message request = session.createMessage();
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:667f26a:         request.setJMSReplyTo(browseDest);
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // make sure the message isn't delivered early because we browsed it
1:667f26a:         Thread.sleep(2000);
1:667f26a:         assertEquals(latch.getCount(), COUNT);
1:667f26a: 
1:74846bb:         // now see if we got all the scheduled messages on the browse
1:74846bb:         // destination.
1:667f26a:         latch.await(10, TimeUnit.SECONDS);
1:667f26a:         assertEquals(browsedLatch.getCount(), 0);
1:667f26a: 
1:667f26a:         // now check that they all got delivered
1:667f26a:         latch.await(10, TimeUnit.SECONDS);
1:667f26a:         assertEquals(latch.getCount(), 0);
1:5fd307c: 
1:5fd307c:         connection.close();
1:667f26a:     }
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testBrowseWindowlScheduled() throws Exception {
1:667f26a:         final int COUNT = 10;
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         // Setup the scheduled Message
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(5));
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(10), COUNT);
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(20));
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination requestBrowse = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a:         Destination browseDest = session.createTemporaryQueue();
1:667f26a: 
1:667f26a:         // Create the eventual Consumer to receive the scheduled message
1:667f26a:         MessageConsumer consumer = session.createConsumer(destination);
1:667f26a: 
1:667f26a:         final CountDownLatch latch = new CountDownLatch(COUNT + 2);
1:667f26a:         consumer.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:667f26a:                 latch.countDown();
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         // Create the "Browser"
1:667f26a:         MessageConsumer browser = session.createConsumer(browseDest);
1:667f26a:         final CountDownLatch browsedLatch = new CountDownLatch(COUNT);
1:667f26a:         browser.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:b3c1327:                 browsedLatch.countDown();
1:b3c1327:                 LOG.debug("Scheduled Message Browser got Message: " + message);
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         connection.start();
1:667f26a: 
1:667f26a:         long start = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(6);
1:667f26a:         long end = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(15);
1:667f26a: 
1:667f26a:         // Send the browse request
1:667f26a:         MessageProducer producer = session.createProducer(requestBrowse);
1:667f26a:         Message request = session.createMessage();
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME, Long.toString(start));
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME, Long.toString(end));
1:667f26a:         request.setJMSReplyTo(browseDest);
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // make sure the message isn't delivered early because we browsed it
1:667f26a:         Thread.sleep(2000);
1:667f26a:         assertEquals(COUNT + 2, latch.getCount());
1:667f26a: 
1:74846bb:         // now see if we got all the scheduled messages on the browse
1:74846bb:         // destination.
1:667f26a:         latch.await(15, TimeUnit.SECONDS);
1:667f26a:         assertEquals(0, browsedLatch.getCount());
1:667f26a: 
1:74846bb:         // now see if we got all the scheduled messages on the browse
1:74846bb:         // destination.
1:667f26a:         latch.await(20, TimeUnit.SECONDS);
1:667f26a:         assertEquals(0, latch.getCount());
1:5fd307c: 
1:5fd307c:         connection.close();
1:667f26a:     }
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testRemoveScheduled() throws Exception {
1:667f26a:         final int COUNT = 10;
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         // Setup the scheduled Message
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(9), COUNT);
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a:         Destination browseDest = session.createTemporaryQueue();
1:667f26a: 
1:667f26a:         // Create the eventual Consumer to receive the scheduled message
1:667f26a:         MessageConsumer consumer = session.createConsumer(destination);
1:667f26a:         MessageProducer producer = session.createProducer(management);
1:667f26a: 
1:667f26a:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:667f26a:         consumer.setMessageListener(new MessageListener() {
1:b3c1327:             @Override
1:667f26a:             public void onMessage(Message message) {
1:667f26a:                 latch.countDown();
1:667f26a:             }
1:667f26a:         });
1:667f26a: 
1:667f26a:         // Create the "Browser"
1:667f26a:         Session browseSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a:         MessageConsumer browser = browseSession.createConsumer(browseDest);
1:667f26a: 
1:667f26a:         connection.start();
1:667f26a: 
1:667f26a:         // Send the browse request
1:667f26a:         Message request = session.createMessage();
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:667f26a:         request.setJMSReplyTo(browseDest);
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // Browse all the Scheduled Messages.
1:667f26a:         for (int i = 0; i < COUNT; ++i) {
1:b3c1327:             Message message = browser.receive(2000);
1:b3c1327:             assertNotNull(message);
1:667f26a: 
1:74846bb:             try {
1:b3c1327:                 Message remove = session.createMessage();
1:74846bb:                 remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE);
1:74846bb:                 remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID, message.getStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID));
1:b3c1327:                 producer.send(remove);
1:74846bb:             } catch (Exception e) {
1:b3c1327:             }
1:667f26a:         }
1:667f26a: 
1:667f26a:         // now check that they all got removed and are not delivered.
1:667f26a:         latch.await(11, TimeUnit.SECONDS);
1:667f26a:         assertEquals(COUNT, latch.getCount());
1:5fd307c: 
1:5fd307c:         connection.close();
1:667f26a:     }
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testRemoveNotScheduled() throws Exception {
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a: 
1:667f26a:         MessageProducer producer = session.createProducer(management);
1:667f26a: 
1:74846bb:         try {
1:667f26a:             // Send the remove request
1:b3c1327:             Message remove = session.createMessage();
1:74846bb:             remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:b3c1327:             remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID, new IdGenerator().generateId());
1:b3c1327:             producer.send(remove);
1:74846bb:         } catch (Exception e) {
1:b3c1327:             fail("Caught unexpected exception during remove of unscheduled message.");
1:5fd307c:         } finally {
1:5fd307c:             connection.close();
1:b3c1327:         }
1:667f26a:     }
1:667f26a: 
1:74846bb:     @Test
1:667f26a:     public void testBrowseWithSelector() throws Exception {
1:667f26a:         Connection connection = createConnection();
1:667f26a: 
1:667f26a:         // Setup the scheduled Message
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(9));
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(5));
1:667f26a:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(45));
1:667f26a: 
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a: 
1:667f26a:         // Create the Browse Destination and the Reply To location
1:667f26a:         Destination requestBrowse = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:667f26a:         Destination browseDest = session.createTemporaryTopic();
1:667f26a: 
1:667f26a:         // Create the "Browser"
1:74846bb:         MessageConsumer browser = session.createConsumer(browseDest, ScheduledMessage.AMQ_SCHEDULED_DELAY + " = 45000");
1:667f26a: 
1:667f26a:         connection.start();
1:667f26a: 
1:667f26a:         // Send the browse request
1:667f26a:         MessageProducer producer = session.createProducer(requestBrowse);
1:667f26a:         Message request = session.createMessage();
1:667f26a:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:667f26a:         request.setJMSReplyTo(browseDest);
1:667f26a:         producer.send(request);
1:667f26a: 
1:667f26a:         // Now try and receive the one we selected
1:667f26a:         Message message = browser.receive(5000);
2:667f26a:         assertNotNull(message);
1:667f26a:         assertEquals(45000, message.getLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY));
1:667f26a: 
1:c691124:         // Verify that original destination was preserved
1:c691124:         assertEquals(destination, ((ActiveMQMessage) message).getOriginalDestination());
1:c691124: 
1:667f26a:         // Now check if there are anymore, there shouldn't be
1:667f26a:         message = browser.receive(5000);
1:667f26a:         assertNull(message);
1:5fd307c: 
1:5fd307c:         connection.close();
1:667f26a:     }
1:667f26a: 
1:667f26a:     protected void scheduleMessage(Connection connection, long delay) throws Exception {
1:b3c1327:         scheduleMessage(connection, delay, 1);
1:667f26a:     }
1:667f26a: 
1:667f26a:     protected void scheduleMessage(Connection connection, long delay, int count) throws Exception {
1:667f26a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:667f26a:         MessageProducer producer = session.createProducer(destination);
1:667f26a:         TextMessage message = session.createTextMessage("test msg");
1:667f26a:         message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);
1:667f26a: 
1:74846bb:         for (int i = 0; i < count; ++i) {
1:b3c1327:             producer.send(message);
1:667f26a:         }
1:667f26a: 
1:667f26a:         producer.close();
1:667f26a:     }
1:667f26a: }
============================================================================
author:Erik Wramner
-------------------------------------------------------------------------------
commit:c691124
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:         // Verify that original destination was preserved
1:         assertEquals(destination, ((ActiveMQMessage) message).getOriginalDestination());
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:5fd307c
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.close();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             connection.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.close();
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
1: public class JobSchedulerManagementTest extends JobSchedulerTestSupport {
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         // now see if we got all the scheduled messages on the browse
1:         // destination.
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         // now see if we got all the scheduled messages on the browse
1:         // destination.
1:         // now see if we got all the scheduled messages on the browse
1:         // destination.
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE);
1:                 remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID, message.getStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID));
1:             } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:         } catch (Exception e) {
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer browser = session.createConsumer(browseDest, ScheduledMessage.AMQ_SCHEDULED_DELAY + " = 45000");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < count; ++i) {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:b3c1327
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                 browsedLatch.countDown();
1:                 LOG.debug("Scheduled Message Browser got Message: " + message);
/////////////////////////////////////////////////////////////////////////
0:                                   ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                 browsedLatch.countDown();
1:                 LOG.debug("Scheduled Message Browser got Message: " + message);
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                 browsedLatch.countDown();
1:                 LOG.debug("Scheduled Message Browser got Message: " + message);
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
0:                                   ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:             Message message = browser.receive(2000);
1:             assertNotNull(message);
0:             try{
1:                 Message remove = session.createMessage();
0:                 remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION,
0:                         ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE);
0:                 remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID,
0:                         message.getStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID));
1:                 producer.send(remove);
0:             } catch(Exception e) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:         try{
1:             // Send the remove request
1:             Message remove = session.createMessage();
0:             remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION,
0:                     ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:             remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID, new IdGenerator().generateId());
1:             producer.send(remove);
0:         } catch(Exception e) {
1:             fail("Caught unexpected exception during remove of unscheduled message.");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         scheduleMessage(connection, delay, 1);
/////////////////////////////////////////////////////////////////////////
1:             producer.send(message);
/////////////////////////////////////////////////////////////////////////
0:         answer.setPersistent(true);
commit:ef24cc9
commit:667f26a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.scheduler;
1: 
0: import java.io.File;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
0: import org.apache.activemq.EmbeddedBrokerTestSupport;
1: import org.apache.activemq.ScheduledMessage;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.util.IOHelper;
1: import org.apache.activemq.util.IdGenerator;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: public class JobSchedulerManagementTest extends EmbeddedBrokerTestSupport {
1: 
0:     private static final transient Log LOG = LogFactory.getLog(JobSchedulerManagementTest.class);
1: 
1:     public void testRemoveAllScheduled() throws Exception {
1:         final int COUNT = 5;
1:         Connection connection = createConnection();
1: 
1:         // Setup the scheduled Message
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(6), COUNT);
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1: 
1:         // Create the eventual Consumer to receive the scheduled message
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 latch.countDown();
1:             }
1:         });
1: 
1:         connection.start();
1: 
1:         // Send the remove request
1:         MessageProducer producer = session.createProducer(management);
1:         Message request = session.createMessage();
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:         producer.send(request);
1: 
1:         // Now wait and see if any get delivered, none should.
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(latch.getCount(), COUNT);
1:     }
1: 
1:     public void testRemoveAllScheduledAtTime() throws Exception {
1:         final int COUNT = 3;
1:         Connection connection = createConnection();
1: 
1:         // Setup the scheduled Message
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(6));
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(15));
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(20));
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:         Destination browseDest = session.createTemporaryQueue();
1: 
1:         // Create the eventual Consumer to receive the scheduled message
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 latch.countDown();
1:             }
1:         });
1: 
1:         // Create the "Browser"
1:         MessageConsumer browser = session.createConsumer(browseDest);
1:         final CountDownLatch browsedLatch = new CountDownLatch(COUNT);
1:         browser.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
0:             	browsedLatch.countDown();
0:             	LOG.debug("Scheduled Message Browser got Message: " + message);
1:             }
1:         });
1: 
1:         connection.start();
1: 
1:         long start = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(10);
1:         long end = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(30);
1: 
1:         // Send the remove request
1:         MessageProducer producer = session.createProducer(management);
1:         Message request = session.createMessage();
0:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION,
0:         					      ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME, Long.toString(start));
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME, Long.toString(end));
1:         producer.send(request);
1: 
1:         // Send the browse request
1:         request = session.createMessage();
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:         request.setJMSReplyTo(browseDest);
1:         producer.send(request);
1: 
1:         // now see if we got back only the one remaining message.
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(2, browsedLatch.getCount());
1: 
1:         // Now wait and see if any get delivered, none should.
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(2, latch.getCount());
1:     }
1: 
1:     public void testBrowseAllScheduled() throws Exception {
1:         final int COUNT = 10;
1:         Connection connection = createConnection();
1: 
1:         // Setup the scheduled Message
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(9), COUNT);
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination requestBrowse = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:         Destination browseDest = session.createTemporaryQueue();
1: 
1:         // Create the eventual Consumer to receive the scheduled message
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 latch.countDown();
1:             }
1:         });
1: 
1:         // Create the "Browser"
1:         MessageConsumer browser = session.createConsumer(browseDest);
1:         final CountDownLatch browsedLatch = new CountDownLatch(COUNT);
1:         browser.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
0:             	browsedLatch.countDown();
0:             	LOG.debug("Scheduled Message Browser got Message: " + message);
1:             }
1:         });
1: 
1:         connection.start();
1: 
1:         // Send the browse request
1:         MessageProducer producer = session.createProducer(requestBrowse);
1:         Message request = session.createMessage();
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:         request.setJMSReplyTo(browseDest);
1:         producer.send(request);
1: 
1:         // make sure the message isn't delivered early because we browsed it
1:         Thread.sleep(2000);
1:         assertEquals(latch.getCount(), COUNT);
1: 
0:         // now see if we got all the scheduled messages on the browse destination.
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(browsedLatch.getCount(), 0);
1: 
1:         // now check that they all got delivered
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(latch.getCount(), 0);
1:     }
1: 
1:     public void testBrowseWindowlScheduled() throws Exception {
1:         final int COUNT = 10;
1:         Connection connection = createConnection();
1: 
1:         // Setup the scheduled Message
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(5));
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(10), COUNT);
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(20));
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination requestBrowse = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:         Destination browseDest = session.createTemporaryQueue();
1: 
1:         // Create the eventual Consumer to receive the scheduled message
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         final CountDownLatch latch = new CountDownLatch(COUNT + 2);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 latch.countDown();
1:             }
1:         });
1: 
1:         // Create the "Browser"
1:         MessageConsumer browser = session.createConsumer(browseDest);
1:         final CountDownLatch browsedLatch = new CountDownLatch(COUNT);
1:         browser.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
0:             	browsedLatch.countDown();
0:             	LOG.debug("Scheduled Message Browser got Message: " + message);
1:             }
1:         });
1: 
1:         connection.start();
1: 
1:         long start = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(6);
1:         long end = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(15);
1: 
1:         // Send the browse request
1:         MessageProducer producer = session.createProducer(requestBrowse);
1:         Message request = session.createMessage();
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME, Long.toString(start));
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME, Long.toString(end));
1:         request.setJMSReplyTo(browseDest);
1:         producer.send(request);
1: 
1:         // make sure the message isn't delivered early because we browsed it
1:         Thread.sleep(2000);
1:         assertEquals(COUNT + 2, latch.getCount());
1: 
0:         // now see if we got all the scheduled messages on the browse destination.
1:         latch.await(15, TimeUnit.SECONDS);
1:         assertEquals(0, browsedLatch.getCount());
1: 
0:         // now see if we got all the scheduled messages on the browse destination.
1:         latch.await(20, TimeUnit.SECONDS);
1:         assertEquals(0, latch.getCount());
1:     }
1: 
1:     public void testRemoveScheduled() throws Exception {
1:         final int COUNT = 10;
1:         Connection connection = createConnection();
1: 
1:         // Setup the scheduled Message
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(9), COUNT);
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:         Destination browseDest = session.createTemporaryQueue();
1: 
1:         // Create the eventual Consumer to receive the scheduled message
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         MessageProducer producer = session.createProducer(management);
1: 
1:         final CountDownLatch latch = new CountDownLatch(COUNT);
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 latch.countDown();
1:             }
1:         });
1: 
1:         // Create the "Browser"
1:         Session browseSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer browser = browseSession.createConsumer(browseDest);
1: 
1:         connection.start();
1: 
1:         // Send the browse request
1:         Message request = session.createMessage();
0:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION,
0:         						  ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:         request.setJMSReplyTo(browseDest);
1:         producer.send(request);
1: 
1:         // Browse all the Scheduled Messages.
1:         for (int i = 0; i < COUNT; ++i) {
0:         	Message message = browser.receive(2000);
1:         	assertNotNull(message);
1: 
0:         	try{
0:         		Message remove = session.createMessage();
0:         		remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION,
0:         				ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE);
0:         		remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID,
0:         				message.getStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID));
0:         		producer.send(remove);
0:         	} catch(Exception e) {
1:         	}
1:         }
1: 
1:         // now check that they all got removed and are not delivered.
1:         latch.await(11, TimeUnit.SECONDS);
1:         assertEquals(COUNT, latch.getCount());
1:     }
1: 
1:     public void testRemoveNotScheduled() throws Exception {
1:         Connection connection = createConnection();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1: 
1:         MessageProducer producer = session.createProducer(management);
1: 
0:     	try{
1: 
1: 	        // Send the remove request
0: 			Message remove = session.createMessage();
0: 			remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION,
0: 					ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL);
0: 			remove.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_ID, new IdGenerator().generateId());
0: 			producer.send(remove);
0:     	} catch(Exception e) {
0:     		fail("Caught unexpected exception during remove of unscheduled message.");
1:     	}
1:     }
1: 
1:     public void testBrowseWithSelector() throws Exception {
1:         Connection connection = createConnection();
1: 
1:         // Setup the scheduled Message
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(9));
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(5));
1:         scheduleMessage(connection, TimeUnit.SECONDS.toMillis(45));
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         // Create the Browse Destination and the Reply To location
1:         Destination requestBrowse = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION);
1:         Destination browseDest = session.createTemporaryTopic();
1: 
1:         // Create the "Browser"
0:         MessageConsumer browser = session.createConsumer(browseDest, ScheduledMessage.AMQ_SCHEDULED_DELAY + " = 45000" );
1: 
1:         connection.start();
1: 
1:         // Send the browse request
1:         MessageProducer producer = session.createProducer(requestBrowse);
1:         Message request = session.createMessage();
1:         request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE);
1:         request.setJMSReplyTo(browseDest);
1:         producer.send(request);
1: 
1:         // Now try and receive the one we selected
1:         Message message = browser.receive(5000);
1:         assertNotNull(message);
1:         assertEquals(45000, message.getLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY));
1: 
1:         // Now check if there are anymore, there shouldn't be
1:         message = browser.receive(5000);
1:         assertNull(message);
1:     }
1: 
1: 
1:     protected void scheduleMessage(Connection connection, long delay) throws Exception {
0:     	scheduleMessage(connection, delay, 1);
1:     }
1: 
1:     protected void scheduleMessage(Connection connection, long delay, int count) throws Exception {
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(destination);
1:         TextMessage message = session.createTextMessage("test msg");
1:         message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);
1: 
0:         for(int i = 0; i < count; ++i ) {
0:         	producer.send(message);
1:         }
1: 
1:         producer.close();
1:     }
1: 
0:     @Override
0:     protected void setUp() throws Exception {
0:         bindAddress = "vm://localhost";
0:         super.setUp();
1:     }
1: 
0:     @Override
0:     protected BrokerService createBroker() throws Exception {
0:         return createBroker(true);
1:     }
1: 
0:     protected BrokerService createBroker(boolean delete) throws Exception {
0:         File schedulerDirectory = new File("target/scheduler");
0:         if (delete) {
0:             IOHelper.mkdirs(schedulerDirectory);
0:             IOHelper.deleteChildren(schedulerDirectory);
1:         }
0:         BrokerService answer = new BrokerService();
0:         answer.setPersistent(isPersistent());
0:         answer.setDeleteAllMessagesOnStartup(true);
0:         answer.setDataDirectory("target");
0:         answer.setSchedulerDirectoryFile(schedulerDirectory);
0:         answer.setUseJmx(false);
0:         answer.addConnector(bindAddress);
0:         return answer;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final transient Logger LOG = LoggerFactory.getLogger(JobSchedulerManagementTest.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:92b3ae2
/////////////////////////////////////////////////////////////////////////
0:         answer.setSchedulerSupport(true);
============================================================================