1:3953b9a: /**
1:3953b9a:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3953b9a:  * contributor license agreements.  See the NOTICE file distributed with
1:3953b9a:  * this work for additional information regarding copyright ownership.
1:3953b9a:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3953b9a:  * (the "License"); you may not use this file except in compliance with
1:3953b9a:  * the License.  You may obtain a copy of the License at
1:3953b9a:  *
1:3953b9a:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3953b9a:  *
1:3953b9a:  * Unless required by applicable law or agreed to in writing, software
1:3953b9a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3953b9a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3953b9a:  * See the License for the specific language governing permissions and
1:3953b9a:  * limitations under the License.
1:3953b9a:  */
1:3953b9a: package org.apache.activemq.network;
13:3953b9a: 
1:d206621: import static org.junit.Assert.assertEquals;
1:d206621: import static org.junit.Assert.assertTrue;
1:d206621: 
1:3953b9a: import java.io.File;
1:3953b9a: import java.net.URI;
1:3953b9a: import java.util.Arrays;
1:3953b9a: import java.util.Collection;
1:3953b9a: import java.util.List;
1:eb9c584: import java.util.concurrent.TimeUnit;
1:3953b9a: 
1:d206621: import javax.jms.Message;
1:3953b9a: import javax.jms.MessageConsumer;
1:a038655: import javax.jms.MessageProducer;
1:3953b9a: import javax.jms.Session;
1:3953b9a: 
1:3953b9a: import org.apache.activemq.ActiveMQConnectionFactory;
1:3953b9a: import org.apache.activemq.advisory.AdvisoryBroker;
1:d206621: import org.apache.activemq.broker.BrokerPlugin;
1:3953b9a: import org.apache.activemq.broker.BrokerService;
1:3953b9a: import org.apache.activemq.broker.TransportConnector;
1:d206621: import org.apache.activemq.broker.region.DestinationStatistics;
1:d206621: import org.apache.activemq.broker.region.virtual.CompositeTopic;
1:d206621: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1:3953b9a: import org.apache.activemq.command.ActiveMQDestination;
1:d206621: import org.apache.activemq.command.ActiveMQQueue;
1:3953b9a: import org.apache.activemq.command.ActiveMQTopic;
1:3953b9a: import org.apache.activemq.command.CommandTypes;
1:d206621: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationBroker;
1:d206621: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationPlugin;
1:eb9c584: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:eb9c584: import org.apache.activemq.store.kahadb.disk.journal.Journal.JournalDiskSyncStrategy;
1:3953b9a: import org.apache.activemq.util.Wait;
1:3953b9a: import org.apache.activemq.util.Wait.Condition;
1:3953b9a: import org.junit.After;
1:3953b9a: import org.junit.Assume;
1:3953b9a: import org.junit.Before;
1:eb9c584: import org.junit.Rule;
1:3953b9a: import org.junit.Test;
1:eb9c584: import org.junit.rules.Timeout;
1:3953b9a: import org.junit.runner.RunWith;
1:3953b9a: import org.junit.runners.Parameterized;
1:3953b9a: import org.junit.runners.Parameterized.Parameters;
1:3953b9a: import org.slf4j.Logger;
1:3953b9a: import org.slf4j.LoggerFactory;
1:3953b9a: 
1:3953b9a: import com.google.common.collect.Lists;
1:3953b9a: 
1:3953b9a: @RunWith(Parameterized.class)
1:b1c4b18: public class DurableSyncNetworkBridgeTest extends DynamicNetworkTestSupport {
1:b1c4b18: 
1:3953b9a:     protected static final Logger LOG = LoggerFactory.getLogger(DurableSyncNetworkBridgeTest.class);
1:3953b9a: 
1:d206621:     protected JavaRuntimeConfigurationBroker remoteRuntimeBroker;
1:a038655:     protected String staticIncludeTopics = "include.static.test";
1:a038655:     protected String includedTopics = "include.test.>";
1:b1c4b18:     protected String testTopicName2 = "include.test.bar2";
1:3953b9a:     private boolean dynamicOnly = false;
1:a038655:     private boolean forceDurable = false;
1:d206621:     private boolean useVirtualDestSubs = false;
1:3953b9a:     private byte remoteBrokerWireFormatVersion = CommandTypes.PROTOCOL_VERSION;
1:25703fb:     public static enum FLOW {FORWARD, REVERSE}
1:3953b9a: 
1:3953b9a:     private BrokerService broker1;
1:3953b9a:     private BrokerService broker2;
1:3953b9a:     private Session session1;
1:a038655:     private Session session2;
1:3953b9a:     private final FLOW flow;
1:3953b9a: 
1:eb9c584:     @Rule
1:eb9c584:     public Timeout globalTimeout = new Timeout(30, TimeUnit.SECONDS);
1:eb9c584: 
1:3953b9a:     @Parameters
1:3953b9a:     public static Collection<Object[]> data() {
1:3953b9a:         return Arrays.asList(new Object[][] {
1:3953b9a:                 {FLOW.FORWARD},
1:3953b9a:                 {FLOW.REVERSE}
1:3953b9a:         });
21:3953b9a:     }
1:3953b9a: 
1:ed0e786:     public static final String KEYSTORE_TYPE = "jks";
1:ed0e786:     public static final String PASSWORD = "password";
1:ed0e786:     public static final String SERVER_KEYSTORE = "src/test/resources/server.keystore";
1:ed0e786:     public static final String TRUST_KEYSTORE = "src/test/resources/client.keystore";
1:ed0e786: 
1:ed0e786:     static {
1:ed0e786:         System.setProperty("javax.net.ssl.trustStore", TRUST_KEYSTORE);
1:ed0e786:         System.setProperty("javax.net.ssl.trustStorePassword", PASSWORD);
1:ed0e786:         System.setProperty("javax.net.ssl.trustStoreType", KEYSTORE_TYPE);
1:ed0e786:         System.setProperty("javax.net.ssl.keyStore", SERVER_KEYSTORE);
1:ed0e786:         System.setProperty("javax.net.ssl.keyStoreType", KEYSTORE_TYPE);
1:ed0e786:         System.setProperty("javax.net.ssl.keyStorePassword", PASSWORD);
1:ed0e786:     }
1:ed0e786: 
1:3953b9a: 
1:3953b9a:     public DurableSyncNetworkBridgeTest(final FLOW flow) {
1:3953b9a:         this.flow = flow;
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Before
1:3953b9a:     public void setUp() throws Exception {
1:a038655:         includedTopics = "include.test.>";
1:a038655:         staticIncludeTopics = "include.static.test";
1:3953b9a:         dynamicOnly = false;
1:a038655:         forceDurable = false;
1:d206621:         useVirtualDestSubs = false;
1:3953b9a:         remoteBrokerWireFormatVersion = CommandTypes.PROTOCOL_VERSION;
1:3953b9a:         doSetUp(true, true, tempFolder.newFolder(), tempFolder.newFolder());
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @After
1:3953b9a:     public void tearDown() throws Exception {
1:3953b9a:         doTearDown();
1:3953b9a:     }
1:3953b9a: 
1:3953b9a: 
1:eb9c584:     @Test
1:3953b9a:     public void testRemoveSubscriptionPropagate() throws Exception {
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:3953b9a:         sub1.close();
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a: 
1:3953b9a:         removeSubscription(broker1, topic, subName);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testRemoveSubscriptionPropegateAfterRestart() throws Exception {
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:3953b9a:         sub1.close();
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a: 
1:3953b9a:         restartBrokers(true);
1:a038655:         assertBridgeStarted();
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a: 
1:3953b9a:         removeSubscription(broker1, topic, subName);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testRemoveSubscriptionWithBridgeOffline() throws Exception {
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:3953b9a:         sub1.close();
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:a038655:         restartBroker(broker2, false);
1:a038655: 
1:a038655:         //Send some messages to the NC sub and make sure it can still be deleted
1:a038655:         MessageProducer prod = session2.createProducer(topic);
1:a038655:         for (int i = 0; i < 10; i++) {
1:a038655:             prod.send(session2.createTextMessage("test"));
1:a038655:         }
1:a038655: 
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655:         removeSubscription(broker1, topic, subName);
1:a038655:         assertSubscriptionsCount(broker1, topic, 0);
1:a038655:         doTearDown();
1:a038655: 
1:a038655:         //Test that on successful reconnection of the bridge that
1:a038655:         //the NC sub will be removed
1:a038655:         restartBroker(broker2, true);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655:         restartBroker(broker1, true);
1:a038655:         assertBridgeStarted();
1:a038655:         assertNCDurableSubsCount(broker2, topic, 0);
1:a038655: 
1:a038655:     }
1:a038655: 
1:a038655:     @Test
1:a038655:     public void testRemoveSubscriptionWithBridgeOfflineIncludedChanged() throws Exception {
1:a038655:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:a038655:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:a038655:         sub1.close();
1:a038655: 
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655: 
1:a038655:         doTearDown();
1:a038655: 
1:a038655:         //change the included topics to make sure we still cleanup non-matching NC durables
1:a038655:         includedTopics = "different.topic";
1:a038655:         restartBroker(broker1, false);
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a:         removeSubscription(broker1, topic, subName);
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:a038655: 
1:3953b9a:         //Test that on successful reconnection of the bridge that
1:3953b9a:         //the NC sub will be removed
1:3953b9a:         restartBroker(broker2, true);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a:         restartBroker(broker1, true);
1:a038655:         assertBridgeStarted();
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:a038655:     public void testSubscriptionRemovedAfterIncludedChanged() throws Exception {
1:a038655:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:a038655:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:a038655:         sub1.close();
1:a038655: 
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655: 
1:a038655:         doTearDown();
1:a038655: 
1:a038655:         //change the included topics to make sure we still cleanup non-matching NC durables
1:a038655:         includedTopics = "different.topic";
1:a038655:         restartBroker(broker1, false);
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a: 
1:a038655:         //Test that on successful reconnection of the bridge that
1:a038655:         //the NC sub will be removed because even though the local subscription exists,
1:a038655:         //it no longer matches the included filter
1:a038655:         restartBroker(broker2, true);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655:         restartBroker(broker1, true);
1:a038655:         assertBridgeStarted();
1:a038655:         assertNCDurableSubsCount(broker2, topic, 0);
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655: 
1:a038655:     }
1:a038655: 
1:a038655:     @Test
1:a038655:     public void testSubscriptionRemovedAfterStaticChanged() throws Exception {
1:a038655:         forceDurable = true;
1:a038655:         this.restartBrokers(true);
1:a038655: 
1:a038655:         final ActiveMQTopic topic = new ActiveMQTopic(this.staticIncludeTopics);
1:a038655:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:a038655:         sub1.close();
1:a038655: 
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655: 
1:a038655:         doTearDown();
1:a038655: 
1:a038655:         //change the included topics to make sure we still cleanup non-matching NC durables
1:a038655:         staticIncludeTopics = "different.topic";
1:a038655:         this.restartBrokers(false);
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655: 
1:a038655:         //Send some messages to the NC sub and make sure it can still be deleted
1:a038655:         MessageProducer prod = session2.createProducer(topic);
1:a038655:         for (int i = 0; i < 10; i++) {
1:a038655:             prod.send(session2.createTextMessage("test"));
1:a038655:         }
1:a038655: 
1:a038655:         //Test that on successful reconnection of the bridge that
1:a038655:         //the NC sub will be removed because even though the local subscription exists,
1:a038655:         //it no longer matches the included static filter
1:a038655:         restartBroker(broker2, true);
1:a038655:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655:         restartBroker(broker1, true);
1:a038655:         assertBridgeStarted();
1:a038655:         assertNCDurableSubsCount(broker2, topic, 0);
1:a038655:         assertSubscriptionsCount(broker1, topic, 1);
1:a038655:     }
1:a038655: 
1:a038655:     @Test
1:3953b9a:     public void testAddAndRemoveSubscriptionWithBridgeOfflineMultiTopics() throws Exception {
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:b1c4b18:         final ActiveMQTopic topic2 = new ActiveMQTopic(testTopicName2);
1:3953b9a:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:3953b9a:         sub1.close();
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a:         session1.createDurableSubscriber(topic2, "sub2");
1:3953b9a:         removeSubscription(broker1, topic, subName);
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:3953b9a:         assertSubscriptionsCount(broker1, topic2, 1);
1:3953b9a: 
1:3953b9a:         //Test that on successful reconnection of the bridge that
1:3953b9a:         //the NC sub will be removed for topic1 but will stay for topic2
1:3953b9a: 
1:3953b9a:         //before sync, the old NC should exist
1:3953b9a:         restartBroker(broker2, true);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic2, 0);
1:3953b9a: 
1:3953b9a:         //After sync, remove old NC and create one for topic 2
1:3953b9a:         restartBroker(broker1, true);
1:a038655:         assertBridgeStarted();
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic2, 1);
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testAddSubscriptionsWithBridgeOffline() throws Exception {
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:b1c4b18:         final ActiveMQTopic topic2 = new ActiveMQTopic(testTopicName2);
1:3953b9a:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
1:25703fb: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:3953b9a:         //add three subs, should only create 2 NC subs because of conduit
1:3953b9a:         session1.createDurableSubscriber(topic, subName).close();
1:3953b9a:         session1.createDurableSubscriber(topic, "sub2").close();
1:3953b9a:         session1.createDurableSubscriber(topic2, "sub3").close();
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 2);
1:3953b9a:         assertSubscriptionsCount(broker1, topic2, 1);
1:3953b9a: 
1:3953b9a:         restartBrokers(true);
1:a038655:         assertBridgeStarted();
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic2, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:eb9c584:     public void testSyncLoadTest() throws Exception {
1:eb9c584:         String subName = this.subName;
1:eb9c584:         //Create 1000 subs
1:eb9c584:         for (int i = 0; i < 100; i++) {
1:eb9c584:             for (int j = 0; j < 10; j++) {
1:eb9c584:                 session1.createDurableSubscriber(new ActiveMQTopic("include.test." + i), subName + i + j).close();
1:eb9c584:             }
1:eb9c584:         }
1:eb9c584:         for (int i = 0; i < 100; i++) {
1:eb9c584:             assertNCDurableSubsCount(broker2, new ActiveMQTopic("include.test." + i), 1);
1:eb9c584:         }
1:eb9c584: 
1:eb9c584:         doTearDown();
1:eb9c584:         restartBroker(broker1, false);
1:eb9c584: 
1:eb9c584:         //with bridge off, remove 100 subs
1:eb9c584:         for (int i = 0; i < 10; i++) {
1:eb9c584:             for (int j = 0; j < 10; j++) {
1:eb9c584:                 removeSubscription(broker1, new ActiveMQTopic("include.test." + i), subName + i + j);
1:eb9c584:             }
1:eb9c584:         }
1:eb9c584: 
1:eb9c584:         //restart test that 900 are resynced and 100 are deleted
1:eb9c584:         restartBrokers(true);
1:eb9c584: 
1:eb9c584:         for (int i = 0; i < 10; i++) {
1:eb9c584:             assertNCDurableSubsCount(broker2, new ActiveMQTopic("include.test." + i), 0);
1:eb9c584:         }
1:eb9c584: 
1:eb9c584:         for (int i = 10; i < 100; i++) {
1:eb9c584:             assertNCDurableSubsCount(broker2, new ActiveMQTopic("include.test." + i), 1);
1:eb9c584:         }
1:eb9c584: 
1:a038655:         assertBridgeStarted();
1:eb9c584:     }
1:eb9c584: 
1:eb9c584: 
1:3953b9a:     /**
1:3953b9a:      * Using an older version of openwire should not sync but the network bridge
1:3953b9a:      * should still start without error
1:3953b9a:      */
1:3953b9a:     @Test
1:3953b9a:     public void testAddSubscriptionsWithBridgeOfflineOpenWire11() throws Exception {
1:3953b9a:         this.remoteBrokerWireFormatVersion = CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC - 1;
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:3953b9a:         session1.createDurableSubscriber(topic, subName).close();
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a: 
1:3953b9a:         //Since we are using an old version of openwire, the NC should
1:3953b9a:         //not be added
1:3953b9a:         restartBrokers(true);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:a038655:         assertBridgeStarted();
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testAddOfflineSubscriptionWithBridgeOfflineDynamicTrue() throws Exception {
1:3953b9a:         //set dynamicOnly to true
1:3953b9a:         this.dynamicOnly = true;
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:3953b9a:         session1.createDurableSubscriber(topic, subName).close();
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a: 
1:3953b9a:         restartBrokers(true);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:a038655:         assertBridgeStarted();
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testAddOnlineSubscriptionWithBridgeOfflineDynamicTrue() throws Exception {
1:3953b9a:         //set dynamicOnly to true
1:3953b9a:         this.dynamicOnly = true;
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:3953b9a:         session1.createDurableSubscriber(topic, subName).close();
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a: 
1:3953b9a:         restartBrokers(true);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a:         //bring online again
1:3953b9a:         session1.createDurableSubscriber(topic, subName);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:a038655:         assertBridgeStarted();
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testAddAndRemoveSubscriptionsWithBridgeOffline() throws Exception {
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
1:3953b9a: 
1:3953b9a:         session1.createDurableSubscriber(topic, subName).close();
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBroker(broker1, false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a:         removeSubscription(broker1, topic, subName);
1:3953b9a:         session1.createDurableSubscriber(topic, "sub2").close();
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 1);
1:3953b9a: 
1:3953b9a:         restartBrokers(true);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
1:a038655:         assertBridgeStarted();
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     @Test
1:3953b9a:     public void testAddOnlineSubscriptionsWithBridgeOffline() throws Exception {
1:3953b9a:         Assume.assumeTrue(flow == FLOW.FORWARD);
1:3953b9a: 
1:b1c4b18:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:3953b9a:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 0);
1:3953b9a: 
1:3953b9a:         doTearDown();
1:3953b9a:         restartBrokers(false);
1:3953b9a: 
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 0);
1:3953b9a: 
1:3953b9a:         //create durable that shouldn't be propagated
1:3953b9a:         session1.createDurableSubscriber(excludeTopic, "sub-exclude");
1:3953b9a: 
1:3953b9a:         //Add 3 online subs
1:3953b9a:         session1.createDurableSubscriber(topic, subName);
1:3953b9a:         session1.createDurableSubscriber(topic, "sub2");
1:3953b9a:         session1.createDurableSubscriber(topic, "sub3");
1:3953b9a:         assertSubscriptionsCount(broker1, topic, 3);
1:3953b9a: 
1:3953b9a:         //Restart brokers and make sure we don't have duplicate NCs created
1:3953b9a:         //between the sync command and the online durables that are added over
1:3953b9a:         //the consumer advisory
1:3953b9a:         restartBrokers(true);
1:a038655:         assertBridgeStarted();
1:3953b9a: 
1:3953b9a:         //Re-create
1:3953b9a:         session1.createDurableSubscriber(topic, subName);
1:3953b9a:         session1.createDurableSubscriber(topic, "sub2");
1:3953b9a:         session1.createDurableSubscriber(topic, "sub3");
1:3953b9a:         session1.createDurableSubscriber(excludeTopic, "sub-exclude");
1:3953b9a: 
1:3953b9a:         Thread.sleep(1000);
1:e73ab34:         assertNCDurableSubsCount(broker2, topic, 1);
1:e73ab34:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
1:3953b9a: 
1:3953b9a:     }
1:3953b9a: 
1:25703fb:     //Test that durable sync works with more than one bridge
1:25703fb:     @Test
1:25703fb:     public void testAddOnlineSubscriptionsTwoBridges() throws Exception {
1:25703fb: 
1:25703fb:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:25703fb:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
1:25703fb:         final ActiveMQTopic topic2 = new ActiveMQTopic("include.new.topic");
1:25703fb: 
1:25703fb:         assertSubscriptionsCount(broker1, topic, 0);
1:25703fb:         assertNCDurableSubsCount(broker2, topic, 0);
1:25703fb: 
1:25703fb:         //create durable that shouldn't be propagated
1:25703fb:         session1.createDurableSubscriber(excludeTopic, "sub-exclude");
1:3953b9a: 
1:25703fb:         //Add 3 online subs
1:25703fb:         session1.createDurableSubscriber(topic, subName);
1:25703fb:         session1.createDurableSubscriber(topic, "sub2");
1:25703fb:         session1.createDurableSubscriber(topic, "sub3");
1:25703fb:         //Add sub on second topic/bridge
1:25703fb:         session1.createDurableSubscriber(topic2, "secondTopicSubName");
1:25703fb:         assertSubscriptionsCount(broker1, topic, 3);
1:25703fb:         assertSubscriptionsCount(broker1, topic2, 1);
1:25703fb: 
1:25703fb:         //Add the second network connector
1:25703fb:         NetworkConnector secondConnector = configureLocalNetworkConnector();
1:25703fb:         secondConnector.setName("networkConnector2");
1:25703fb:         secondConnector.setDynamicallyIncludedDestinations(
1:25703fb:                 Lists.<ActiveMQDestination>newArrayList(
1:25703fb:                         new ActiveMQTopic("include.new.topic?forceDurable=" + forceDurable)));
1:25703fb:         localBroker.addNetworkConnector(secondConnector);
1:25703fb:         secondConnector.start();
1:25703fb: 
1:25703fb:         //Make sure both bridges are connected
1:25703fb:         assertTrue(Wait.waitFor(new Condition() {
1:25703fb:             @Override
1:25703fb:             public boolean isSatisified() throws Exception {
1:25703fb:                 return localBroker.getNetworkConnectors().get(0).activeBridges().size() == 1 &&
1:25703fb:                         localBroker.getNetworkConnectors().get(1).activeBridges().size() == 1;
1:25703fb:             }
1:25703fb:         }, 10000, 500));
1:25703fb: 
1:25703fb:         //Make sure NC durables exist for both bridges
1:25703fb:         assertNCDurableSubsCount(broker2, topic2, 1);
1:25703fb:         assertNCDurableSubsCount(broker2, topic, 1);
1:25703fb:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
1:25703fb: 
1:25703fb:         //Make sure message can reach remote broker
1:25703fb:         MessageProducer producer = session2.createProducer(topic2);
1:25703fb:         producer.send(session2.createTextMessage("test"));
1:25703fb:         waitForDispatchFromLocalBroker(broker2.getDestination(topic2).getDestinationStatistics(), 1);
1:25703fb:         assertLocalBrokerStatistics(broker2.getDestination(topic2).getDestinationStatistics(), 1);
1:25703fb:     }
1:25703fb: 
1:d206621:     @Test(timeout = 60 * 1000)
1:d206621:     public void testVirtualDestSubForceDurableSync() throws Exception {
1:d206621:         Assume.assumeTrue(flow == FLOW.FORWARD);
1:d206621:         forceDurable = true;
1:d206621:         useVirtualDestSubs = true;
1:d206621:         this.restartBrokers(true);
1:d206621: 
1:d206621:         //configure a virtual destination that forwards messages from topic testQueueName
1:d206621:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:d206621:                 new ActiveMQQueue("include.test.bar.bridge"));
1:d206621:         remoteRuntimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:d206621: 
1:d206621:         MessageProducer includedProducer = localSession.createProducer(included);
1:d206621:         Message test = localSession.createTextMessage("test");
1:d206621: 
1:d206621:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:d206621:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:d206621:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:d206621: 
1:d206621:         //Make sure that the NC durable is created because of the compositeTopic
1:d206621:         waitForConsumerCount(destinationStatistics, 1);
1:d206621:         assertNCDurableSubsCount(localBroker, included, 1);
1:d206621: 
1:d206621:         //Send message and make sure it is dispatched across the bridge
1:d206621:         includedProducer.send(test);
1:d206621:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:d206621:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:d206621:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:d206621: 
1:d206621:         //Stop the remote broker so the bridge stops and then send 500 messages so
1:d206621:         //the messages build up on the NC durable
1:d206621:         this.stopRemoteBroker();
1:d206621:         for (int i = 0; i < 500; i++) {
1:d206621:             includedProducer.send(test);
1:d206621:         }
1:d206621:         this.stopLocalBroker();
1:d206621: 
1:d206621:         //Restart the brokers
1:d206621:         this.restartRemoteBroker();
1:d206621:         remoteRuntimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:d206621:         this.restartLocalBroker(true);
1:d206621: 
1:d206621:         //We now need to verify that 501 messages made it to the queue on the remote side
1:d206621:         //which means that the NC durable was not deleted and recreated during the sync
1:d206621:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:d206621:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:d206621: 
1:d206621:         assertTrue(Wait.waitFor(new Condition() {
1:d206621: 
1:d206621:             @Override
1:d206621:             public boolean isSatisified() throws Exception {
1:d206621:                 return remoteDestStatistics2.getMessages().getCount() == 501;
1:d206621:             }
1:d206621:         }));
1:d206621: 
1:d206621:     }
1:d206621: 
1:d206621:     @Test(timeout = 60 * 1000)
1:d206621:     public void testForceDurableTopicSubSync() throws Exception {
1:d206621:         Assume.assumeTrue(flow == FLOW.FORWARD);
1:d206621:         forceDurable = true;
1:d206621:         this.restartBrokers(true);
1:d206621: 
1:d206621:         //configure a virtual destination that forwards messages from topic testQueueName
1:d206621:         remoteSession.createConsumer(included);
1:d206621: 
1:d206621:         MessageProducer includedProducer = localSession.createProducer(included);
1:d206621:         Message test = localSession.createTextMessage("test");
1:d206621: 
1:d206621:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:d206621: 
1:d206621:         //Make sure that the NC durable is created because of the compositeTopic
1:d206621:         waitForConsumerCount(destinationStatistics, 1);
1:d206621:         assertNCDurableSubsCount(localBroker, included, 1);
1:d206621: 
1:d206621:         //Send message and make sure it is dispatched across the bridge
1:d206621:         includedProducer.send(test);
1:d206621:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:d206621:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:d206621: 
1:d206621:         //Stop the network connector and send messages to the local broker so they build
1:d206621:         //up on the durable
1:d206621:         this.localBroker.getNetworkConnectorByName("networkConnector").stop();
1:d206621: 
1:d206621:         for (int i = 0; i < 500; i++) {
1:d206621:             includedProducer.send(test);
1:d206621:         }
1:d206621: 
1:d206621:         //restart the local broker and bridge
1:d206621:         this.stopLocalBroker();
1:d206621:         this.restartLocalBroker(true);
1:d206621: 
1:d206621:         //We now need to verify that the 500 messages on the NC durable are dispatched
1:d206621:         //on bridge sync which shows that the durable wasn't destroyed/recreated
1:d206621:         final DestinationStatistics destinationStatistics2 =
1:d206621:                 localBroker.getDestination(included).getDestinationStatistics();
1:d206621:         waitForDispatchFromLocalBroker(destinationStatistics2, 500);
1:d206621:         assertLocalBrokerStatistics(destinationStatistics2, 500);
1:d206621: 
1:d206621:     }
1:d206621: 
1:d206621:     protected CompositeTopic createCompositeTopic(String name, ActiveMQDestination...forwardTo) {
1:d206621:         CompositeTopic compositeTopic = new CompositeTopic();
1:d206621:         compositeTopic.setName(name);
1:d206621:         compositeTopic.setForwardOnly(true);
1:d206621:         compositeTopic.setForwardTo( Lists.newArrayList(forwardTo));
1:d206621: 
1:d206621:         return compositeTopic;
1:d206621:     }
1:d206621: 
1:3953b9a:     protected void restartBroker(BrokerService broker, boolean startNetworkConnector) throws Exception {
1:3953b9a:         if (broker.getBrokerName().equals("localBroker")) {
1:3953b9a:             restartLocalBroker(startNetworkConnector);
1:3953b9a:         } else  {
1:3953b9a:             restartRemoteBroker();
1:3953b9a:         }
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected void restartBrokers(boolean startNetworkConnector) throws Exception {
1:3953b9a:         doTearDown();
1:3953b9a:         doSetUp(false, startNetworkConnector, localBroker.getDataDirectoryFile(),
1:3953b9a:                 remoteBroker.getDataDirectoryFile());
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected void doSetUp(boolean deleteAllMessages, boolean startNetworkConnector, File localDataDir,
1:3953b9a:             File remoteDataDir) throws Exception {
1:b1c4b18:         included = new ActiveMQTopic(testTopicName);
1:e73ab34:         doSetUpRemoteBroker(deleteAllMessages, remoteDataDir, 0);
1:3953b9a:         doSetUpLocalBroker(deleteAllMessages, startNetworkConnector, localDataDir);
1:3953b9a:         //Give time for advisories to propagate
1:3953b9a:         Thread.sleep(1000);
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected void restartLocalBroker(boolean startNetworkConnector) throws Exception {
2:3953b9a:         stopLocalBroker();
1:3953b9a:         doSetUpLocalBroker(false, startNetworkConnector, localBroker.getDataDirectoryFile());
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected void restartRemoteBroker() throws Exception {
1:e73ab34:         int port = 0;
1:e73ab34:         if (remoteBroker != null) {
1:e73ab34:             List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:e73ab34:             port = transportConnectors.get(0).getConnectUri().getPort();
1:e73ab34:         }
2:3953b9a:         stopRemoteBroker();
1:e73ab34:         doSetUpRemoteBroker(false, remoteBroker.getDataDirectoryFile(), port);
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected void doSetUpLocalBroker(boolean deleteAllMessages, boolean startNetworkConnector,
1:3953b9a:             File dataDir) throws Exception {
1:3953b9a:         localBroker = createLocalBroker(dataDir, startNetworkConnector);
1:3953b9a:         localBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:3953b9a:         localBroker.start();
1:3953b9a:         localBroker.waitUntilStarted();
1:3953b9a:         URI localURI = localBroker.getVmConnectorURI();
1:3953b9a:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(localURI);
1:3953b9a:         fac.setAlwaysSyncSend(true);
1:3953b9a:         fac.setDispatchAsync(false);
1:3953b9a:         localConnection = fac.createConnection();
1:3953b9a:         localConnection.setClientID("clientId");
1:3953b9a:         localConnection.start();
1:3953b9a: 
1:eb9c584:         if (startNetworkConnector) {
1:3953b9a:             Wait.waitFor(new Condition() {
3:3953b9a:                 @Override
3:3953b9a:                 public boolean isSatisified() throws Exception {
1:3953b9a:                     return localBroker.getNetworkConnectors().get(0).activeBridges().size() == 1;
1:3953b9a:                 }
1:a038655:             }, 5000, 500);
1:3953b9a:         }
1:3953b9a:         localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3953b9a: 
1:3953b9a:         if (flow.equals(FLOW.FORWARD)) {
1:3953b9a:             broker1 = localBroker;
1:3953b9a:             session1 = localSession;
1:3953b9a:         } else {
1:3953b9a:             broker2 = localBroker;
1:a038655:             session2 = localSession;
1:3953b9a:         }
1:3953b9a:     }
1:3953b9a: 
1:e73ab34:     protected void doSetUpRemoteBroker(boolean deleteAllMessages, File dataDir, int port) throws Exception {
1:e73ab34:         remoteBroker = createRemoteBroker(dataDir, port);
1:3953b9a:         remoteBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:3953b9a:         remoteBroker.start();
1:3953b9a:         remoteBroker.waitUntilStarted();
1:3953b9a:         URI remoteURI = remoteBroker.getVmConnectorURI();
1:3953b9a:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(remoteURI);
1:3953b9a:         remoteConnection = fac.createConnection();
1:3953b9a:         remoteConnection.setClientID("clientId");
1:3953b9a:         remoteConnection.start();
1:3953b9a:         remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3953b9a: 
1:3953b9a:         if (flow.equals(FLOW.FORWARD)) {
1:3953b9a:             broker2 = remoteBroker;
1:a038655:             session2 = remoteSession;
1:d206621:             remoteRuntimeBroker = (JavaRuntimeConfigurationBroker)
1:d206621:                     remoteBroker.getBroker().getAdaptor(JavaRuntimeConfigurationBroker.class);
1:3953b9a:         } else {
1:3953b9a:             broker1 = remoteBroker;
1:3953b9a:             session1 = remoteSession;
1:3953b9a:         }
1:3953b9a:     }
1:d206621: 
1:3953b9a: 
1:3953b9a:     protected BrokerService createLocalBroker(File dataDir, boolean startNetworkConnector) throws Exception {
1:3953b9a:         BrokerService brokerService = new BrokerService();
1:3953b9a:         brokerService.setMonitorConnectionSplits(true);
1:3953b9a:         brokerService.setBrokerName("localBroker");
1:eb9c584:         brokerService.setDataDirectoryFile(dataDir);
1:eb9c584:         KahaDBPersistenceAdapter adapter = new KahaDBPersistenceAdapter();
1:eb9c584:         adapter.setDirectory(dataDir);
1:eb9c584:         adapter.setJournalDiskSyncStrategy(JournalDiskSyncStrategy.PERIODIC.name());
1:eb9c584:         brokerService.setPersistenceAdapter(adapter);
1:d206621:         brokerService.setUseVirtualDestSubs(useVirtualDestSubs);
1:d206621:         brokerService.setUseVirtualDestSubsOnCreation(useVirtualDestSubs);
1:d206621: 
1:3953b9a:         if (startNetworkConnector) {
1:3953b9a:             brokerService.addNetworkConnector(configureLocalNetworkConnector());
1:3953b9a:         }
1:3953b9a: 
1:ed0e786:         //Use auto+nio+ssl to test out the transport works with bridging
1:ed0e786:         brokerService.addConnector("auto+nio+ssl://localhost:0");
1:3953b9a: 
1:3953b9a:         return brokerService;
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected NetworkConnector configureLocalNetworkConnector() throws Exception {
1:3953b9a:         List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:3953b9a:         URI remoteURI = transportConnectors.get(0).getConnectUri();
1:3953b9a:         String uri = "static:(" + remoteURI + ")";
1:3953b9a:         NetworkConnector connector = new DiscoveryNetworkConnector(new URI(uri));
1:3953b9a:         connector.setName("networkConnector");
1:3953b9a:         connector.setDynamicOnly(dynamicOnly);
1:3953b9a:         connector.setDecreaseNetworkConsumerPriority(false);
1:3953b9a:         connector.setConduitSubscriptions(true);
1:3953b9a:         connector.setDuplex(true);
1:3953b9a:         connector.setStaticBridge(false);
1:3953b9a:         connector.setSyncDurableSubs(true);
1:d206621:         connector.setUseVirtualDestSubs(useVirtualDestSubs);
1:a038655:         connector.setStaticallyIncludedDestinations(
1:a038655:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(staticIncludeTopics + "?forceDurable=" + forceDurable)));
1:3953b9a:         connector.setDynamicallyIncludedDestinations(
1:d206621:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(includedTopics + "?forceDurable=" + forceDurable)));
1:3953b9a:         connector.setExcludedDestinations(
1:3953b9a:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(excludeTopicName)));
1:3953b9a:         return connector;
1:3953b9a:     }
1:3953b9a: 
1:3953b9a:     protected AdvisoryBroker remoteAdvisoryBroker;
1:3953b9a: 
1:e73ab34:     protected BrokerService createRemoteBroker(File dataDir, int port) throws Exception {
1:3953b9a:         BrokerService brokerService = new BrokerService();
1:3953b9a:         brokerService.setBrokerName("remoteBroker");
1:3953b9a:         brokerService.setUseJmx(false);
2:3953b9a:         brokerService.setDataDirectoryFile(dataDir);
1:eb9c584:         KahaDBPersistenceAdapter adapter = new KahaDBPersistenceAdapter();
1:eb9c584:         adapter.setDirectory(dataDir);
1:eb9c584:         adapter.setJournalDiskSyncStrategy(JournalDiskSyncStrategy.PERIODIC.name());
1:eb9c584:         brokerService.setPersistenceAdapter(adapter);
1:d206621:         brokerService.setUseVirtualDestSubs(useVirtualDestSubs);
1:d206621:         brokerService.setUseVirtualDestSubsOnCreation(useVirtualDestSubs);
1:3953b9a: 
1:d206621:         if (useVirtualDestSubs) {
1:d206621:             brokerService.setPlugins(new BrokerPlugin[] {new JavaRuntimeConfigurationPlugin()});
1:d206621:         }
1:3953b9a: 
1:3953b9a:         remoteAdvisoryBroker = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);
1:3953b9a: 
1:eb9c584:         //Need a larger cache size in order to handle all of the durables
1:ed0e786:         //Use auto+nio+ssl to test out the transport works with bridging
1:ed0e786:         brokerService.addConnector("auto+nio+ssl://localhost:" + port + "?wireFormat.cacheSize=2048&wireFormat.version=" + remoteBrokerWireFormatVersion);
1:3953b9a: 
1:3953b9a:         return brokerService;
1:3953b9a:     }
1:3953b9a: 
1:3953b9a: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:25703fb
/////////////////////////////////////////////////////////////////////////
1:     public static enum FLOW {FORWARD, REVERSE}
/////////////////////////////////////////////////////////////////////////
1:     //Test that durable sync works with more than one bridge
1:     @Test
1:     public void testAddOnlineSubscriptionsTwoBridges() throws Exception {
1: 
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
1:         final ActiveMQTopic topic2 = new ActiveMQTopic("include.new.topic");
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         assertNCDurableSubsCount(broker2, topic, 0);
1: 
1:         //create durable that shouldn't be propagated
1:         session1.createDurableSubscriber(excludeTopic, "sub-exclude");
1: 
1:         //Add 3 online subs
1:         session1.createDurableSubscriber(topic, subName);
1:         session1.createDurableSubscriber(topic, "sub2");
1:         session1.createDurableSubscriber(topic, "sub3");
1:         //Add sub on second topic/bridge
1:         session1.createDurableSubscriber(topic2, "secondTopicSubName");
1:         assertSubscriptionsCount(broker1, topic, 3);
1:         assertSubscriptionsCount(broker1, topic2, 1);
1: 
1:         //Add the second network connector
1:         NetworkConnector secondConnector = configureLocalNetworkConnector();
1:         secondConnector.setName("networkConnector2");
1:         secondConnector.setDynamicallyIncludedDestinations(
1:                 Lists.<ActiveMQDestination>newArrayList(
1:                         new ActiveMQTopic("include.new.topic?forceDurable=" + forceDurable)));
1:         localBroker.addNetworkConnector(secondConnector);
1:         secondConnector.start();
1: 
1:         //Make sure both bridges are connected
1:         assertTrue(Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localBroker.getNetworkConnectors().get(0).activeBridges().size() == 1 &&
1:                         localBroker.getNetworkConnectors().get(1).activeBridges().size() == 1;
1:             }
1:         }, 10000, 500));
1: 
1:         //Make sure NC durables exist for both bridges
1:         assertNCDurableSubsCount(broker2, topic2, 1);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
1: 
1:         //Make sure message can reach remote broker
1:         MessageProducer producer = session2.createProducer(topic2);
1:         producer.send(session2.createTextMessage("test"));
1:         waitForDispatchFromLocalBroker(broker2.getDestination(topic2).getDestinationStatistics(), 1);
1:         assertLocalBrokerStatistics(broker2.getDestination(topic2).getDestinationStatistics(), 1);
1:     }
1: 
commit:d206621
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Message;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.region.DestinationStatistics;
1: import org.apache.activemq.broker.region.virtual.CompositeTopic;
1: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationBroker;
1: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationPlugin;
/////////////////////////////////////////////////////////////////////////
1:     protected JavaRuntimeConfigurationBroker remoteRuntimeBroker;
1:     private boolean useVirtualDestSubs = false;
/////////////////////////////////////////////////////////////////////////
1:         useVirtualDestSubs = false;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testVirtualDestSubForceDurableSync() throws Exception {
1:         Assume.assumeTrue(flow == FLOW.FORWARD);
1:         forceDurable = true;
1:         useVirtualDestSubs = true;
1:         this.restartBrokers(true);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1:         remoteRuntimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         //Make sure that the NC durable is created because of the compositeTopic
1:         waitForConsumerCount(destinationStatistics, 1);
1:         assertNCDurableSubsCount(localBroker, included, 1);
1: 
1:         //Send message and make sure it is dispatched across the bridge
1:         includedProducer.send(test);
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1: 
1:         //Stop the remote broker so the bridge stops and then send 500 messages so
1:         //the messages build up on the NC durable
1:         this.stopRemoteBroker();
1:         for (int i = 0; i < 500; i++) {
1:             includedProducer.send(test);
1:         }
1:         this.stopLocalBroker();
1: 
1:         //Restart the brokers
1:         this.restartRemoteBroker();
1:         remoteRuntimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         this.restartLocalBroker(true);
1: 
1:         //We now need to verify that 501 messages made it to the queue on the remote side
1:         //which means that the NC durable was not deleted and recreated during the sync
1:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         assertTrue(Wait.waitFor(new Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteDestStatistics2.getMessages().getCount() == 501;
1:             }
1:         }));
1: 
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testForceDurableTopicSubSync() throws Exception {
1:         Assume.assumeTrue(flow == FLOW.FORWARD);
1:         forceDurable = true;
1:         this.restartBrokers(true);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         remoteSession.createConsumer(included);
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         //Make sure that the NC durable is created because of the compositeTopic
1:         waitForConsumerCount(destinationStatistics, 1);
1:         assertNCDurableSubsCount(localBroker, included, 1);
1: 
1:         //Send message and make sure it is dispatched across the bridge
1:         includedProducer.send(test);
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         //Stop the network connector and send messages to the local broker so they build
1:         //up on the durable
1:         this.localBroker.getNetworkConnectorByName("networkConnector").stop();
1: 
1:         for (int i = 0; i < 500; i++) {
1:             includedProducer.send(test);
1:         }
1: 
1:         //restart the local broker and bridge
1:         this.stopLocalBroker();
1:         this.restartLocalBroker(true);
1: 
1:         //We now need to verify that the 500 messages on the NC durable are dispatched
1:         //on bridge sync which shows that the durable wasn't destroyed/recreated
1:         final DestinationStatistics destinationStatistics2 =
1:                 localBroker.getDestination(included).getDestinationStatistics();
1:         waitForDispatchFromLocalBroker(destinationStatistics2, 500);
1:         assertLocalBrokerStatistics(destinationStatistics2, 500);
1: 
1:     }
1: 
1:     protected CompositeTopic createCompositeTopic(String name, ActiveMQDestination...forwardTo) {
1:         CompositeTopic compositeTopic = new CompositeTopic();
1:         compositeTopic.setName(name);
1:         compositeTopic.setForwardOnly(true);
1:         compositeTopic.setForwardTo( Lists.newArrayList(forwardTo));
1: 
1:         return compositeTopic;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             remoteRuntimeBroker = (JavaRuntimeConfigurationBroker)
1:                     remoteBroker.getBroker().getAdaptor(JavaRuntimeConfigurationBroker.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setUseVirtualDestSubs(useVirtualDestSubs);
1:         brokerService.setUseVirtualDestSubsOnCreation(useVirtualDestSubs);
/////////////////////////////////////////////////////////////////////////
1:         connector.setUseVirtualDestSubs(useVirtualDestSubs);
1:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(includedTopics + "?forceDurable=" + forceDurable)));
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setUseVirtualDestSubs(useVirtualDestSubs);
1:         brokerService.setUseVirtualDestSubsOnCreation(useVirtualDestSubs);
1: 
1:         if (useVirtualDestSubs) {
1:             brokerService.setPlugins(new BrokerPlugin[] {new JavaRuntimeConfigurationPlugin()});
1:         }
commit:a038655
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.MessageProducer;
/////////////////////////////////////////////////////////////////////////
1:     protected String staticIncludeTopics = "include.static.test";
1:     protected String includedTopics = "include.test.>";
1:     private boolean forceDurable = false;
1:     private Session session2;
/////////////////////////////////////////////////////////////////////////
1:         includedTopics = "include.test.>";
1:         staticIncludeTopics = "include.static.test";
1:         forceDurable = false;
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         restartBroker(broker2, false);
1: 
1:         //Send some messages to the NC sub and make sure it can still be deleted
1:         MessageProducer prod = session2.createProducer(topic);
1:         for (int i = 0; i < 10; i++) {
1:             prod.send(session2.createTextMessage("test"));
1:         }
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         removeSubscription(broker1, topic, subName);
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         doTearDown();
1: 
1:         //Test that on successful reconnection of the bridge that
1:         //the NC sub will be removed
1:         restartBroker(broker2, true);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         restartBroker(broker1, true);
1:         assertBridgeStarted();
1:         assertNCDurableSubsCount(broker2, topic, 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testRemoveSubscriptionWithBridgeOfflineIncludedChanged() throws Exception {
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1: 
1:         doTearDown();
1: 
1:         //change the included topics to make sure we still cleanup non-matching NC durables
1:         includedTopics = "different.topic";
1:         restartBroker(broker1, false);
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
1:     public void testSubscriptionRemovedAfterIncludedChanged() throws Exception {
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1: 
1:         doTearDown();
1: 
1:         //change the included topics to make sure we still cleanup non-matching NC durables
1:         includedTopics = "different.topic";
1:         restartBroker(broker1, false);
1:         assertSubscriptionsCount(broker1, topic, 1);
1: 
1:         //Test that on successful reconnection of the bridge that
1:         //the NC sub will be removed because even though the local subscription exists,
1:         //it no longer matches the included filter
1:         restartBroker(broker2, true);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         restartBroker(broker1, true);
1:         assertBridgeStarted();
1:         assertNCDurableSubsCount(broker2, topic, 0);
1:         assertSubscriptionsCount(broker1, topic, 1);
1: 
1:     }
1: 
1:     @Test
1:     public void testSubscriptionRemovedAfterStaticChanged() throws Exception {
1:         forceDurable = true;
1:         this.restartBrokers(true);
1: 
1:         final ActiveMQTopic topic = new ActiveMQTopic(this.staticIncludeTopics);
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1: 
1:         doTearDown();
1: 
1:         //change the included topics to make sure we still cleanup non-matching NC durables
1:         staticIncludeTopics = "different.topic";
1:         this.restartBrokers(false);
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1: 
1:         //Send some messages to the NC sub and make sure it can still be deleted
1:         MessageProducer prod = session2.createProducer(topic);
1:         for (int i = 0; i < 10; i++) {
1:             prod.send(session2.createTextMessage("test"));
1:         }
1: 
1:         //Test that on successful reconnection of the bridge that
1:         //the NC sub will be removed because even though the local subscription exists,
1:         //it no longer matches the included static filter
1:         restartBroker(broker2, true);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         restartBroker(broker1, true);
1:         assertBridgeStarted();
1:         assertNCDurableSubsCount(broker2, topic, 0);
1:         assertSubscriptionsCount(broker1, topic, 1);
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:         assertBridgeStarted();
/////////////////////////////////////////////////////////////////////////
1:             }, 5000, 500);
/////////////////////////////////////////////////////////////////////////
1:             session2 = localSession;
/////////////////////////////////////////////////////////////////////////
1:             session2 = remoteSession;
/////////////////////////////////////////////////////////////////////////
1:         connector.setStaticallyIncludedDestinations(
1:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(staticIncludeTopics + "?forceDurable=" + forceDurable)));
0:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(includedTopics)));
commit:ed0e786
/////////////////////////////////////////////////////////////////////////
1:     public static final String KEYSTORE_TYPE = "jks";
1:     public static final String PASSWORD = "password";
1:     public static final String SERVER_KEYSTORE = "src/test/resources/server.keystore";
1:     public static final String TRUST_KEYSTORE = "src/test/resources/client.keystore";
1: 
1:     static {
1:         System.setProperty("javax.net.ssl.trustStore", TRUST_KEYSTORE);
1:         System.setProperty("javax.net.ssl.trustStorePassword", PASSWORD);
1:         System.setProperty("javax.net.ssl.trustStoreType", KEYSTORE_TYPE);
1:         System.setProperty("javax.net.ssl.keyStore", SERVER_KEYSTORE);
1:         System.setProperty("javax.net.ssl.keyStoreType", KEYSTORE_TYPE);
1:         System.setProperty("javax.net.ssl.keyStorePassword", PASSWORD);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //Use auto+nio+ssl to test out the transport works with bridging
1:         brokerService.addConnector("auto+nio+ssl://localhost:0");
/////////////////////////////////////////////////////////////////////////
1:         //Use auto+nio+ssl to test out the transport works with bridging
1:         brokerService.addConnector("auto+nio+ssl://localhost:" + port + "?wireFormat.cacheSize=2048&wireFormat.version=" + remoteBrokerWireFormatVersion);
commit:eb9c584
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.store.kahadb.disk.journal.Journal.JournalDiskSyncStrategy;
1: import org.junit.Rule;
1: import org.junit.rules.Timeout;
/////////////////////////////////////////////////////////////////////////
1:     @Rule
1:     public Timeout globalTimeout = new Timeout(30, TimeUnit.SECONDS);
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testSyncLoadTest() throws Exception {
1:         String subName = this.subName;
1:         //Create 1000 subs
1:         for (int i = 0; i < 100; i++) {
1:             for (int j = 0; j < 10; j++) {
1:                 session1.createDurableSubscriber(new ActiveMQTopic("include.test." + i), subName + i + j).close();
1:             }
1:         }
1:         for (int i = 0; i < 100; i++) {
1:             assertNCDurableSubsCount(broker2, new ActiveMQTopic("include.test." + i), 1);
1:         }
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         //with bridge off, remove 100 subs
1:         for (int i = 0; i < 10; i++) {
1:             for (int j = 0; j < 10; j++) {
1:                 removeSubscription(broker1, new ActiveMQTopic("include.test." + i), subName + i + j);
1:             }
1:         }
1: 
1:         //restart test that 900 are resynced and 100 are deleted
1:         restartBrokers(true);
1: 
1:         for (int i = 0; i < 10; i++) {
1:             assertNCDurableSubsCount(broker2, new ActiveMQTopic("include.test." + i), 0);
1:         }
1: 
1:         for (int i = 10; i < 100; i++) {
1:             assertNCDurableSubsCount(broker2, new ActiveMQTopic("include.test." + i), 1);
1:         }
1: 
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (startNetworkConnector) {
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setDataDirectoryFile(dataDir);
1:         KahaDBPersistenceAdapter adapter = new KahaDBPersistenceAdapter();
1:         adapter.setDirectory(dataDir);
1:         adapter.setJournalDiskSyncStrategy(JournalDiskSyncStrategy.PERIODIC.name());
1:         brokerService.setPersistenceAdapter(adapter);
/////////////////////////////////////////////////////////////////////////
1:         KahaDBPersistenceAdapter adapter = new KahaDBPersistenceAdapter();
1:         adapter.setDirectory(dataDir);
1:         adapter.setJournalDiskSyncStrategy(JournalDiskSyncStrategy.PERIODIC.name());
1:         brokerService.setPersistenceAdapter(adapter);
1:         //Need a larger cache size in order to handle all of the durables
0:         brokerService.addConnector("tcp://localhost:" + port + "?wireFormat.cacheSize=2048&wireFormat.version=" + remoteBrokerWireFormatVersion);
commit:e73ab34
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic2, 0);
1:         assertNCDurableSubsCount(broker2, topic, 0);
1:         assertNCDurableSubsCount(broker2, topic2, 1);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, topic2, 1);
1:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
1:         assertNCDurableSubsCount(broker2, topic, 1);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 0);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(broker2, topic, 1);
1:         assertNCDurableSubsCount(broker2, excludeTopic, 0);
/////////////////////////////////////////////////////////////////////////
1:         doSetUpRemoteBroker(deleteAllMessages, remoteDataDir, 0);
/////////////////////////////////////////////////////////////////////////
1:         int port = 0;
1:         if (remoteBroker != null) {
1:             List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:             port = transportConnectors.get(0).getConnectUri().getPort();
1:         }
1:         doSetUpRemoteBroker(false, remoteBroker.getDataDirectoryFile(), port);
/////////////////////////////////////////////////////////////////////////
1:     protected void doSetUpRemoteBroker(boolean deleteAllMessages, File dataDir, int port) throws Exception {
1:         remoteBroker = createRemoteBroker(dataDir, port);
/////////////////////////////////////////////////////////////////////////
1:     protected BrokerService createRemoteBroker(File dataDir, int port) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         brokerService.addConnector("tcp://localhost:" + port + "?wireFormat.version=" + remoteBrokerWireFormatVersion);
commit:b1c4b18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class DurableSyncNetworkBridgeTest extends DynamicNetworkTestSupport {
1: 
1:     protected String testTopicName2 = "include.test.bar2";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:         final ActiveMQTopic topic2 = new ActiveMQTopic(testTopicName2);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
1:         final ActiveMQTopic topic2 = new ActiveMQTopic(testTopicName2);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQTopic topic = new ActiveMQTopic(testTopicName);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         included = new ActiveMQTopic(testTopicName);
commit:3953b9a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
1: 
0: import static org.junit.Assert.assertTrue;
1: 
1: import java.io.File;
1: import java.net.URI;
0: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.List;
1: 
0: import javax.jms.Connection;
1: import javax.jms.MessageConsumer;
1: import javax.jms.Session;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.advisory.AdvisoryBroker;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.region.DurableTopicSubscription;
0: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.util.SubscriptionKey;
1: import org.apache.activemq.util.Wait;
1: import org.apache.activemq.util.Wait.Condition;
1: import org.junit.After;
1: import org.junit.Assume;
1: import org.junit.Before;
0: import org.junit.Rule;
1: import org.junit.Test;
0: import org.junit.rules.TemporaryFolder;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
1: import org.junit.runners.Parameterized.Parameters;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import com.google.common.collect.Lists;
1: 
1: @RunWith(Parameterized.class)
0: public class DurableSyncNetworkBridgeTest {
1:     protected static final Logger LOG = LoggerFactory.getLogger(DurableSyncNetworkBridgeTest.class);
1: 
0:     protected Connection localConnection;
0:     protected Connection remoteConnection;
0:     protected BrokerService localBroker;
0:     protected BrokerService remoteBroker;
0:     protected Session localSession;
0:     protected Session remoteSession;
0:     protected ActiveMQTopic included;
0:     protected ActiveMQTopic excluded;
0:     protected String includeTopicName = "include.test.bar";
0:     protected String includeTopicName2 = "include.test.bar2";
0:     protected String excludeTopicName = "exclude.test.bar";
0:     protected String clientId = "clientId";
1:     private boolean dynamicOnly = false;
1:     private byte remoteBrokerWireFormatVersion = CommandTypes.PROTOCOL_VERSION;
0:     public static enum FLOW {FORWARD, REVERSE};
1: 
1:     private BrokerService broker1;
1:     private BrokerService broker2;
1:     private Session session1;
1:     private final FLOW flow;
1: 
0:     @Rule
0:     public TemporaryFolder tempFolder = new TemporaryFolder(new File("target"));
1: 
1:     @Parameters
1:     public static Collection<Object[]> data() {
1:         return Arrays.asList(new Object[][] {
1:                 {FLOW.FORWARD},
1:                 {FLOW.REVERSE}
1:         });
1:     }
1: 
1: 
1:     public DurableSyncNetworkBridgeTest(final FLOW flow) {
1:         this.flow = flow;
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         dynamicOnly = false;
1:         remoteBrokerWireFormatVersion = CommandTypes.PROTOCOL_VERSION;
1:         doSetUp(true, true, tempFolder.newFolder(), tempFolder.newFolder());
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         doTearDown();
1:     }
1: 
0:     protected void doTearDown() throws Exception {
1:         stopLocalBroker();
1:         stopRemoteBroker();
1:     }
1: 
0:     protected void stopLocalBroker() throws Exception {
0:         if (localConnection != null) {
0:             localConnection.close();
1:         }
0:         if (localBroker != null) {
0:             localBroker.stop();
0:             localBroker.waitUntilStopped();
1:         }
1:     }
1: 
0:     protected void stopRemoteBroker() throws Exception {
0:         if (remoteConnection != null) {
0:             remoteConnection.close();
1:         }
0:         if (remoteBroker != null) {
0:             remoteBroker.stop();
0:             remoteBroker.waitUntilStopped();
1:         }
1:     }
1: 
1:     @Test
1:     public void testRemoveSubscriptionPropagate() throws Exception {
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final String subName = "sub1";
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:         removeSubscription(broker1, topic, subName);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testRemoveSubscriptionPropegateAfterRestart() throws Exception {
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final String subName = "sub1";
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:         restartBrokers(true);
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:         removeSubscription(broker1, topic, subName);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testRemoveSubscriptionWithBridgeOffline() throws Exception {
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final String subName = "sub1";
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         removeSubscription(broker1, topic, subName);
1:         assertSubscriptionsCount(broker1, topic, 0);
1: 
1:         //Test that on successful reconnection of the bridge that
1:         //the NC sub will be removed
1:         restartBroker(broker2, true);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1:         restartBroker(broker1, true);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testAddAndRemoveSubscriptionWithBridgeOfflineMultiTopics() throws Exception {
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final ActiveMQTopic topic2 = new ActiveMQTopic(includeTopicName2);
0:         final String subName = "sub1";
1:         MessageConsumer sub1 = session1.createDurableSubscriber(topic, subName);
1:         sub1.close();
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         session1.createDurableSubscriber(topic2, "sub2");
1:         removeSubscription(broker1, topic, subName);
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         assertSubscriptionsCount(broker1, topic2, 1);
1: 
1:         //Test that on successful reconnection of the bridge that
1:         //the NC sub will be removed for topic1 but will stay for topic2
1: 
1:         //before sync, the old NC should exist
1:         restartBroker(broker2, true);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic2, 0);
1: 
1:         //After sync, remove old NC and create one for topic 2
1:         restartBroker(broker1, true);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic2, 1);
1: 
1:     }
1: 
1:     @Test
1:     public void testAddSubscriptionsWithBridgeOffline() throws Exception {
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final ActiveMQTopic topic2 = new ActiveMQTopic(includeTopicName2);
1:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
0:         final String subName = "sub1";
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         //add three subs, should only create 2 NC subs because of conduit
1:         session1.createDurableSubscriber(topic, subName).close();
1:         session1.createDurableSubscriber(topic, "sub2").close();
1:         session1.createDurableSubscriber(topic2, "sub3").close();
1:         assertSubscriptionsCount(broker1, topic, 2);
1:         assertSubscriptionsCount(broker1, topic2, 1);
1: 
1:         restartBrokers(true);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic2, 1);
0:         assertNCSubscriptionsCount(broker2, excludeTopic, 0);
1: 
1:     }
1: 
1:     /**
1:      * Using an older version of openwire should not sync but the network bridge
1:      * should still start without error
1:      */
1:     @Test
1:     public void testAddSubscriptionsWithBridgeOfflineOpenWire11() throws Exception {
1:         this.remoteBrokerWireFormatVersion = CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC - 1;
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final String subName = "sub1";
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         session1.createDurableSubscriber(topic, subName).close();
1:         assertSubscriptionsCount(broker1, topic, 1);
1: 
1:         //Since we are using an old version of openwire, the NC should
1:         //not be added
1:         restartBrokers(true);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testAddOfflineSubscriptionWithBridgeOfflineDynamicTrue() throws Exception {
1:         //set dynamicOnly to true
1:         this.dynamicOnly = true;
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final String subName = "sub1";
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         session1.createDurableSubscriber(topic, subName).close();
1:         assertSubscriptionsCount(broker1, topic, 1);
1: 
1:         restartBrokers(true);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1:     }
1: 
1:     @Test
1:     public void testAddOnlineSubscriptionWithBridgeOfflineDynamicTrue() throws Exception {
1:         //set dynamicOnly to true
1:         this.dynamicOnly = true;
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
0:         final String subName = "sub1";
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
1:         session1.createDurableSubscriber(topic, subName).close();
1:         assertSubscriptionsCount(broker1, topic, 1);
1: 
1:         restartBrokers(true);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1:         //bring online again
1:         session1.createDurableSubscriber(topic, subName);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:     }
1: 
1:     @Test
1:     public void testAddAndRemoveSubscriptionsWithBridgeOffline() throws Exception {
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
1:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
0:         final String subName = "sub1";
1: 
1:         session1.createDurableSubscriber(topic, subName).close();
1:         assertSubscriptionsCount(broker1, topic, 1);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
1: 
1:         doTearDown();
1:         restartBroker(broker1, false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 1);
1:         removeSubscription(broker1, topic, subName);
1:         session1.createDurableSubscriber(topic, "sub2").close();
1:         assertSubscriptionsCount(broker1, topic, 1);
1: 
1:         restartBrokers(true);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
0:         assertNCSubscriptionsCount(broker2, excludeTopic, 0);
1: 
1:     }
1: 
1:     @Test
1:     public void testAddOnlineSubscriptionsWithBridgeOffline() throws Exception {
1:         Assume.assumeTrue(flow == FLOW.FORWARD);
1: 
0:         final ActiveMQTopic topic = new ActiveMQTopic(includeTopicName);
1:         final ActiveMQTopic excludeTopic = new ActiveMQTopic(excludeTopicName);
0:         final String subName = "sub1";
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
0:         assertNCSubscriptionsCount(broker2, topic, 0);
1: 
1:         doTearDown();
1:         restartBrokers(false);
1: 
1:         assertSubscriptionsCount(broker1, topic, 0);
1: 
1:         //create durable that shouldn't be propagated
1:         session1.createDurableSubscriber(excludeTopic, "sub-exclude");
1: 
1:         //Add 3 online subs
1:         session1.createDurableSubscriber(topic, subName);
1:         session1.createDurableSubscriber(topic, "sub2");
1:         session1.createDurableSubscriber(topic, "sub3");
1:         assertSubscriptionsCount(broker1, topic, 3);
1: 
1:         //Restart brokers and make sure we don't have duplicate NCs created
1:         //between the sync command and the online durables that are added over
1:         //the consumer advisory
1:         restartBrokers(true);
1: 
1:         //Re-create
1:         session1.createDurableSubscriber(topic, subName);
1:         session1.createDurableSubscriber(topic, "sub2");
1:         session1.createDurableSubscriber(topic, "sub3");
1:         session1.createDurableSubscriber(excludeTopic, "sub-exclude");
1: 
1:         Thread.sleep(1000);
0:         assertNCSubscriptionsCount(broker2, topic, 1);
0:         assertNCSubscriptionsCount(broker2, excludeTopic, 0);
1: 
1:     }
1: 
0:     protected void removeSubscription(final BrokerService brokerService, final ActiveMQTopic topic,
0:             final String subName) throws Exception {
0:         final RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();
0:         info.setClientId(clientId);
0:         info.setSubscriptionName(subName);
1: 
0:         final ConnectionContext context = new ConnectionContext();
0:         context.setBroker(brokerService.getBroker());
0:         context.setClientId(clientId);
1: 
0:         brokerService.getBroker().removeSubscription(context, info);
1:     }
1: 
0:     protected void assertSubscriptionsCount(final BrokerService brokerService,
0:             final ActiveMQTopic dest, final int count) throws Exception {
0:         assertTrue(Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return count == getSubscriptions(brokerService, dest).size();
1:             }
0:         }, 10000, 500));
1:     }
1: 
0:     protected void assertNCSubscriptionsCount(final BrokerService brokerService,
0:             final ActiveMQTopic dest, final int count) throws Exception {
0:         assertTrue(Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return count == getNCSubscriptions(brokerService, dest).size();
1:             }
0:         }, 10000, 500));
1:     }
1: 
0:     protected List<DurableTopicSubscription> getSubscriptions(final BrokerService brokerService,
0:             final ActiveMQTopic dest) throws Exception {
0:         List<DurableTopicSubscription> subs = new ArrayList<>();
0:         Topic destination = (Topic) brokerService.getDestination(dest);
0:         for (SubscriptionKey key : destination.getDurableTopicSubs().keySet()) {
0:             if (!key.getSubscriptionName().startsWith(DemandForwardingBridge.DURABLE_SUB_PREFIX)) {
0:                 DurableTopicSubscription sub = destination.getDurableTopicSubs().get(key);
0:                 if (sub != null) {
0:                     subs.add(sub);
1:                 }
1:             }
1:         }
0:         return subs;
1:     }
1: 
0:     protected List<DurableTopicSubscription> getNCSubscriptions(final BrokerService brokerService,
0:             final ActiveMQTopic dest) throws Exception {
0:         List<DurableTopicSubscription> subs = new ArrayList<>();
0:         Topic destination = (Topic) brokerService.getDestination(dest);
0:         for (SubscriptionKey key : destination.getDurableTopicSubs().keySet()) {
0:             if (key.getSubscriptionName().startsWith(DemandForwardingBridge.DURABLE_SUB_PREFIX)) {
0:                 DurableTopicSubscription sub = destination.getDurableTopicSubs().get(key);
0:                 if (sub != null) {
0:                     subs.add(sub);
1:                 }
1:             }
1:         }
0:         return subs;
1:     }
1: 
1:     protected void restartBroker(BrokerService broker, boolean startNetworkConnector) throws Exception {
1:         if (broker.getBrokerName().equals("localBroker")) {
1:             restartLocalBroker(startNetworkConnector);
1:         } else  {
1:             restartRemoteBroker();
1:         }
1:     }
1: 
1:     protected void restartBrokers(boolean startNetworkConnector) throws Exception {
1:         doTearDown();
1:         doSetUp(false, startNetworkConnector, localBroker.getDataDirectoryFile(),
1:                 remoteBroker.getDataDirectoryFile());
1:     }
1: 
1:     protected void doSetUp(boolean deleteAllMessages, boolean startNetworkConnector, File localDataDir,
1:             File remoteDataDir) throws Exception {
0:         included = new ActiveMQTopic(includeTopicName);
0:         doSetUpRemoteBroker(deleteAllMessages, remoteDataDir);
1:         doSetUpLocalBroker(deleteAllMessages, startNetworkConnector, localDataDir);
1:         //Give time for advisories to propagate
1:         Thread.sleep(1000);
1:     }
1: 
1:     protected void restartLocalBroker(boolean startNetworkConnector) throws Exception {
1:         stopLocalBroker();
1:         doSetUpLocalBroker(false, startNetworkConnector, localBroker.getDataDirectoryFile());
1:     }
1: 
1:     protected void restartRemoteBroker() throws Exception {
1:         stopRemoteBroker();
0:         doSetUpRemoteBroker(false, remoteBroker.getDataDirectoryFile());
1:     }
1: 
1:     protected void doSetUpLocalBroker(boolean deleteAllMessages, boolean startNetworkConnector,
1:             File dataDir) throws Exception {
1:         localBroker = createLocalBroker(dataDir, startNetworkConnector);
1:         localBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:         localBroker.start();
1:         localBroker.waitUntilStarted();
1:         URI localURI = localBroker.getVmConnectorURI();
1:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(localURI);
1:         fac.setAlwaysSyncSend(true);
1:         fac.setDispatchAsync(false);
1:         localConnection = fac.createConnection();
1:         localConnection.setClientID("clientId");
1:         localConnection.start();
1: 
0:         if (startNetworkConnector) {        // brokerService.setPlugins(new BrokerPlugin[] {new
0:             // JavaRuntimeConfigurationPlugin()});
0:             // brokerService.setUseVirtualDestSubs(true);
0:             // brokerService.setUseVirtualDestSubsOnCreation(isUsevirtualDestinationSubscriptionsOnCreation);
1:             Wait.waitFor(new Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return localBroker.getNetworkConnectors().get(0).activeBridges().size() == 1;
1:                 }
0:             }, 10000, 500);
1:         }
1:         localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         if (flow.equals(FLOW.FORWARD)) {
1:             broker1 = localBroker;
1:             session1 = localSession;
1:         } else {
1:             broker2 = localBroker;
1:         }
1:     }
1: 
0:     protected void doSetUpRemoteBroker(boolean deleteAllMessages, File dataDir) throws Exception {
0:         remoteBroker = createRemoteBroker(dataDir);
1:         remoteBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:         remoteBroker.start();
1:         remoteBroker.waitUntilStarted();
1:         URI remoteURI = remoteBroker.getVmConnectorURI();
1:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(remoteURI);
1:         remoteConnection = fac.createConnection();
1:         remoteConnection.setClientID("clientId");
1:         remoteConnection.start();
1:         remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         if (flow.equals(FLOW.FORWARD)) {
1:             broker2 = remoteBroker;
1:         } else {
1:             broker1 = remoteBroker;
1:             session1 = remoteSession;
1:         }
1:     }
1: 
1:     protected BrokerService createLocalBroker(File dataDir, boolean startNetworkConnector) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setMonitorConnectionSplits(true);
1:         brokerService.setDataDirectoryFile(dataDir);
1:         brokerService.setBrokerName("localBroker");
1: 
1:         if (startNetworkConnector) {
1:             brokerService.addNetworkConnector(configureLocalNetworkConnector());
1:         }
1: 
0:         brokerService.addConnector("tcp://localhost:0");
1: 
1:         return brokerService;
1:     }
1: 
1:     protected NetworkConnector configureLocalNetworkConnector() throws Exception {
1:         List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:         URI remoteURI = transportConnectors.get(0).getConnectUri();
1:         String uri = "static:(" + remoteURI + ")";
1:         NetworkConnector connector = new DiscoveryNetworkConnector(new URI(uri));
1:         connector.setName("networkConnector");
1:         connector.setDynamicOnly(dynamicOnly);
1:         connector.setDecreaseNetworkConsumerPriority(false);
1:         connector.setConduitSubscriptions(true);
1:         connector.setDuplex(true);
1:         connector.setStaticBridge(false);
1:         connector.setSyncDurableSubs(true);
1:         connector.setDynamicallyIncludedDestinations(
0:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic("include.test.>")));
1:         connector.setExcludedDestinations(
1:                 Lists.<ActiveMQDestination>newArrayList(new ActiveMQTopic(excludeTopicName)));
1:         return connector;
1:     }
1: 
1:     protected AdvisoryBroker remoteAdvisoryBroker;
1: 
0:     protected BrokerService createRemoteBroker(File dataDir) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setBrokerName("remoteBroker");
1:         brokerService.setUseJmx(false);
1:         brokerService.setDataDirectoryFile(dataDir);
1: 
1:         remoteAdvisoryBroker = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);
1: 
0:         brokerService.addConnector("tcp://localhost:0?wireFormat.version=" + remoteBrokerWireFormatVersion);
1: 
1:         return brokerService;
1:     }
1: 
1: }
============================================================================