2:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:c1a1dd2:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:33cf032:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:40a7d3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:40a7d3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a7d3b:  * See the License for the specific language governing permissions and
1:40a7d3b:  * limitations under the License.
1:40a7d3b:  */
18:40a7d3b: 
1:f1a084e: package org.apache.activemq.web;
1:c1a1dd2: 
1:829787a: import java.io.Externalizable;
1:829787a: import java.io.IOException;
1:829787a: import java.io.ObjectInput;
1:829787a: import java.io.ObjectOutput;
1:4e5012c: import java.util.ArrayList;
1:829787a: import java.util.HashMap;
1:4e5012c: import java.util.Iterator;
1:4e5012c: import java.util.List;
1:829787a: import java.util.Map;
1:540dd5c: import java.util.concurrent.Semaphore;
1:33cf032: 
1:87f75b2: import javax.jms.Connection;
1:40a7d3b: import javax.jms.ConnectionFactory;
1:40a7d3b: import javax.jms.DeliveryMode;
1:40a7d3b: import javax.jms.Destination;
1:40a7d3b: import javax.jms.JMSException;
1:40a7d3b: import javax.jms.Message;
1:40a7d3b: import javax.jms.MessageConsumer;
1:40a7d3b: import javax.jms.MessageProducer;
1:40a7d3b: import javax.jms.Session;
1:40a7d3b: import javax.servlet.ServletContext;
1:c1a1dd2: import javax.servlet.http.HttpServletRequest;
1:40a7d3b: import javax.servlet.http.HttpSession;
1:40a7d3b: import javax.servlet.http.HttpSessionActivationListener;
1:4060ad9: import javax.servlet.http.HttpSessionBindingEvent;
1:4060ad9: import javax.servlet.http.HttpSessionBindingListener;
1:40a7d3b: import javax.servlet.http.HttpSessionEvent;
1:829787a: 
1:88d5857: import org.apache.activemq.ActiveMQConnectionFactory;
1:4060ad9: import org.apache.activemq.MessageAvailableConsumer;
1:0507ad3: import org.apache.activemq.broker.BrokerRegistry;
1:0507ad3: import org.apache.activemq.broker.BrokerService;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2b2b3e8: 
1:40a7d3b: /**
1:33cf032:  * Represents a messaging client used from inside a web container typically
1:540dd5c:  * stored inside a HttpSession TODO controls to prevent DOS attacks with users
1:540dd5c:  * requesting many consumers TODO configure consumers with small prefetch.
1:40ae055:  * 
1:40ae055:  *
1:b0c2a40:  *
1:40a7d3b:  */
1:4060ad9: public class WebClient implements HttpSessionActivationListener, HttpSessionBindingListener, Externalizable {
1:40a7d3b: 
1:540dd5c:     public static final String WEB_CLIENT_ATTRIBUTE = "org.apache.activemq.webclient";
1:540dd5c:     public static final String CONNECTION_FACTORY_ATTRIBUTE = "org.apache.activemq.connectionFactory";
1:540dd5c:     public static final String CONNECTION_FACTORY_PREFETCH_PARAM = "org.apache.activemq.connectionFactory.prefetch";
1:540dd5c:     public static final String CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM = "org.apache.activemq.connectionFactory.optimizeAck";
1:540dd5c:     public static final String BROKER_URL_INIT_PARAM = "org.apache.activemq.brokerURL";
1:7fe862c:     public static final String USERNAME_INIT_PARAM = "org.apache.activemq.username";
1:7fe862c:     public static final String PASSWORD_INIT_PARAM = "org.apache.activemq.password";
1:a05e84e:     public static final String SELECTOR_NAME = "org.apache.activemq.selectorName";
1:40a7d3b: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(WebClient.class);
1:40a7d3b: 
1:7fe862c:     private static transient ActiveMQConnectionFactory factory;
1:40a7d3b: 
1:540dd5c:     private transient Map<Destination, MessageConsumer> consumers = new HashMap<Destination, MessageConsumer>();
1:87f75b2:     private transient Connection connection;
1:87f75b2:     private transient Session session;
1:40a7d3b:     private transient MessageProducer producer;
1:40a7d3b:     private int deliveryMode = DeliveryMode.NON_PERSISTENT;
1:a05e84e:     public static String selectorName;
1:40a7d3b: 
1:829787a:     private final Semaphore semaphore = new Semaphore(1);
1:2b2b3e8: 
1:d4742f5:     private String username;
1:d4742f5:     private String password;
1:d4742f5: 
1:540dd5c:     public WebClient() {
1:540dd5c:         if (factory == null) {
1:540dd5c:             throw new IllegalStateException("initContext(ServletContext) not called");
1:540dd5c:         }
1:2b2b3e8:     }
1:2b2b3e8: 
1:c1a1dd2:     /**
1:c1a1dd2:      * Helper method to get the client for the current session, lazily creating
1:c1a1dd2:      * a client if there is none currently
1:540dd5c:      * 
1:c1a1dd2:      * @param request is the current HTTP request
1:c1a1dd2:      * @return the current client or a newly creates
1:c1a1dd2:      */
1:c1a1dd2:     public static WebClient getWebClient(HttpServletRequest request) {
1:c1a1dd2:         HttpSession session = request.getSession(true);
1:c1a1dd2:         WebClient client = getWebClient(session);
1:c1a1dd2:         if (client == null || client.isClosed()) {
1:c1a1dd2:             client = WebClient.createWebClient(request);
1:540dd5c:             session.setAttribute(WEB_CLIENT_ATTRIBUTE, client);
1:2b2b3e8:         }
1:829787a: 
1:c1a1dd2:         return client;
1:540dd5c:     }
1:540dd5c: 
1:40a7d3b:     /**
1:33cf032:      * @return the web client for the current HTTP session or null if there is
1:33cf032:      *         not a web client created yet
1:40a7d3b:      */
1:40a7d3b:     public static WebClient getWebClient(HttpSession session) {
1:540dd5c:         return (WebClient)session.getAttribute(WEB_CLIENT_ATTRIBUTE);
1:c1a1dd2:     }
1:829787a: 
1:40a7d3b:     public static void initContext(ServletContext context) {
1:4060ad9:         initConnectionFactory(context);
1:2b2b3e8:         context.setAttribute("webClients", new HashMap<String, WebClient>());
1:a05e84e:         if (selectorName == null) {
1:a05e84e:             selectorName = context.getInitParameter(SELECTOR_NAME);
1:a05e84e:         }
1:a05e84e:         if (selectorName == null) {
1:a05e84e:             selectorName = "selector";
1:a05e84e:         }        
1:c1a1dd2:     }
1:4443d32: 
1:40a7d3b:     public int getDeliveryMode() {
1:40a7d3b:         return deliveryMode;
7:40a7d3b:     }
1:33cf032: 
1:40a7d3b:     public void setDeliveryMode(int deliveryMode) {
1:40a7d3b:         this.deliveryMode = deliveryMode;
1:40a7d3b:     }
1:33cf032: 
1:d4742f5:     public String getUsername() {
1:d4742f5:         return username;
1:d4742f5:     }
1:d4742f5: 
1:d4742f5:     public void setUsername(String username) {
1:d4742f5:         this.username = username;
1:d4742f5:     }
1:d4742f5: 
1:d4742f5:     public String getPassword() {
1:d4742f5:         return password;
1:d4742f5:     }
1:d4742f5: 
1:d4742f5:     public void setPassword(String password) {
1:d4742f5:         this.password = password;
1:d4742f5:     }
1:d4742f5: 
1:33cf032:     public synchronized void closeConsumers() {
1:540dd5c:         for (Iterator<MessageConsumer> it = consumers.values().iterator(); it.hasNext();) {
1:540dd5c:             MessageConsumer consumer = it.next();
1:4060ad9:             it.remove();
1:33cf032:             try {
1:4060ad9:                 consumer.setMessageListener(null);
1:540dd5c:                 if (consumer instanceof MessageAvailableConsumer) {
1:540dd5c:                     ((MessageAvailableConsumer)consumer).setAvailableListener(null);
1:540dd5c:                 }
1:4060ad9:                 consumer.close();
1:540dd5c:             } catch (JMSException e) {
1:540dd5c:                 LOG.debug("caught exception closing consumer", e);
1:540dd5c:             }
1:33cf032:         }
1:40a7d3b:     }
1:40a7d3b: 
1:4060ad9:     public synchronized void close() {
2:40a7d3b:         try {
1:3c734ce:             if (consumers != null) {
1:3c734ce:                 closeConsumers();
1:3c734ce:             }
1:540dd5c:             if (connection != null) {
1:40a7d3b:                 connection.close();
1:2b2b3e8:             }
1:2b2b3e8:         } catch (Exception e) {
1:540dd5c:             LOG.debug("caught exception closing consumer", e);
1:540dd5c:         } finally {
1:40a7d3b:             producer = null;
1:40a7d3b:             session = null;
1:40a7d3b:             connection = null;
1:540dd5c:             if (consumers != null) {
1:4060ad9:                 consumers.clear();
1:540dd5c:             }
1:33cf032:             consumers = null;
1:3c734ce: 
1:40a7d3b:         }
1:40a7d3b:     }
1:33cf032: 
1:33cf032:     public boolean isClosed() {
1:33cf032:         return consumers == null;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public void writeExternal(ObjectOutput out) throws IOException {
1:33cf032:         if (consumers != null) {
1:4060ad9:             out.write(consumers.size());
1:540dd5c:             Iterator<Destination> i = consumers.keySet().iterator();
1:540dd5c:             while (i.hasNext()) {
1:4060ad9:                 out.writeObject(i.next().toString());
1:540dd5c:             }
1:540dd5c:         } else {
1:4060ad9:             out.write(-1);
1:540dd5c:         }
1:33cf032: 
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
1:4060ad9:         int size = in.readInt();
1:33cf032:         if (size >= 0) {
1:540dd5c:             consumers = new HashMap<Destination, MessageConsumer>();
1:33cf032:             for (int i = 0; i < size; i++) {
1:33cf032:                 String destinationName = in.readObject().toString();
1:33cf032: 
1:33cf032:                 try {
1:540dd5c:                     Destination destination = destinationName.startsWith("topic://") ? (Destination)getSession().createTopic(destinationName) : (Destination)getSession().createQueue(destinationName);
1:ce9f83c:                     consumers.put(destination, getConsumer(destination, null, true));
1:540dd5c:                 } catch (JMSException e) {
1:540dd5c:                     LOG.debug("Caought Exception ", e);
1:c171817:                     IOException ex = new IOException(e.getMessage());
1:c171817:                     ex.initCause(e.getCause() != null ? e.getCause() : e);
1:c171817:                     throw ex;
1:540dd5c: 
1:40a7d3b:                 }
1:40a7d3b:             }
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public void send(Destination destination, Message message) throws JMSException {
1:33cf032:         getProducer().send(destination, message);
1:540dd5c:         if (LOG.isDebugEnabled()) {
1:540dd5c:             LOG.debug("Sent! to destination: " + destination + " message: " + message);
1:33cf032:         }
1:40a7d3b:     }
1:33cf032: 
1:e7ca882:     public void send(Destination destination, Message message, boolean persistent, int priority, long timeToLive) throws JMSException {
1:33cf032:         int deliveryMode = persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;
1:33cf032:         getProducer().send(destination, message, deliveryMode, priority, timeToLive);
1:540dd5c:         if (LOG.isDebugEnabled()) {
1:540dd5c:             LOG.debug("Sent! to destination: " + destination + " message: " + message);
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public Session getSession() throws JMSException {
1:40a7d3b:         if (session == null) {
1:40a7d3b:             session = createSession();
1:40a7d3b:         }
1:40a7d3b:         return session;
1:40a7d3b:     }
1:40a7d3b: 
1:87f75b2:     public Connection getConnection() throws JMSException {
1:40a7d3b:         if (connection == null) {
1:76153ff:             if (username != null && password != null) {
1:76153ff:                 connection = factory.createConnection(username, password);
1:76153ff:             } else {
1:76153ff:                 connection = factory.createConnection();
1:76153ff:             }
1:40a7d3b:             connection.start();
1:40a7d3b:         }
1:40a7d3b:         return connection;
1:40a7d3b:     }
1:40a7d3b: 
1:87f75b2:     protected static synchronized void initConnectionFactory(ServletContext servletContext) {
1:540dd5c:         if (factory == null) {
1:7fe862c:             factory = (ActiveMQConnectionFactory)servletContext.getAttribute(CONNECTION_FACTORY_ATTRIBUTE);
1:540dd5c:         }
1:40a7d3b:         if (factory == null) {
1:7fe862c:             String brokerURL = getInitParameter(servletContext, BROKER_URL_INIT_PARAM);
1:40a7d3b: 
1:40a7d3b: 
1:40a7d3b:             if (brokerURL == null) {
1:0507ad3:                 LOG.debug("Couldn't find " + BROKER_URL_INIT_PARAM + " param, trying to find a broker embedded in a local VM");
1:0507ad3:                 BrokerService broker = BrokerRegistry.getInstance().findFirst();
1:0507ad3:                 if (broker == null) {
1:0507ad3:                     throw new IllegalStateException("missing brokerURL (specified via " + BROKER_URL_INIT_PARAM + " init-Param) or embedded broker");
1:0507ad3:                 } else {
1:0507ad3:                     brokerURL = "vm://" + broker.getBrokerName();
1:0507ad3:                 }
1:40a7d3b:             }
1:33cf032: 
1:0507ad3:             LOG.debug("Using broker URL: " + brokerURL);
1:7fe862c:             String username = getInitParameter(servletContext, USERNAME_INIT_PARAM);
1:7fe862c:             String password = getInitParameter(servletContext, PASSWORD_INIT_PARAM);
1:7fe862c:             ActiveMQConnectionFactory amqfactory = new ActiveMQConnectionFactory(username, password, brokerURL);
1:0507ad3: 
1:2391cb0:             // Set prefetch policy for factory
1:540dd5c:             if (servletContext.getInitParameter(CONNECTION_FACTORY_PREFETCH_PARAM) != null) {
1:7fe862c:                 int prefetch = Integer.valueOf(getInitParameter(servletContext, CONNECTION_FACTORY_PREFETCH_PARAM)).intValue();
1:2391cb0:                 amqfactory.getPrefetchPolicy().setAll(prefetch);
1:40a7d3b:             }
1:40a7d3b: 
1:2391cb0:             // Set optimize acknowledge setting
1:540dd5c:             if (servletContext.getInitParameter(CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM) != null) {
1:7fe862c:                 boolean optimizeAck = Boolean.valueOf(getInitParameter(servletContext, CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM)).booleanValue();
1:2391cb0:                 amqfactory.setOptimizeAcknowledge(optimizeAck);
1:40a7d3b:             }
1:40a7d3b: 
1:4060ad9:             factory = amqfactory;
1:33cf032: 
1:540dd5c:             servletContext.setAttribute(CONNECTION_FACTORY_ATTRIBUTE, factory);
1:2b2b3e8:         }
1:2b2b3e8:     }
1:2b2b3e8: 
1:7fe862c:     private static String getInitParameter(ServletContext servletContext, String initParam) {
1:7fe862c:         String result = servletContext.getInitParameter(initParam);
1:7fe862c:         if(result != null && result.startsWith("${") && result.endsWith("}"))
1:7fe862c:         {
1:7fe862c:             result = System.getProperty(result.substring(2,result.length()-1));
1:7fe862c:         }
1:7fe862c:         return result;
1:7fe862c:     }
1:7fe862c: 
1:33cf032:     public synchronized MessageProducer getProducer() throws JMSException {
1:33cf032:         if (producer == null) {
1:33cf032:             producer = getSession().createProducer(null);
1:33cf032:             producer.setDeliveryMode(deliveryMode);
1:33cf032:         }
1:33cf032:         return producer;
1:33cf032:     }
1:33cf032: 
1:33cf032:     public void setProducer(MessageProducer producer) {
1:33cf032:         this.producer = producer;
1:33cf032:     }
1:33cf032: 
1:ce9f83c:     public synchronized MessageConsumer getConsumer(Destination destination, String selector) throws JMSException {
1:ce9f83c:         return getConsumer(destination, selector, true);
1:40a7d3b:     }
1:40a7d3b: 
1:ce9f83c:     public synchronized MessageConsumer getConsumer(Destination destination, String selector, boolean create) throws JMSException {
1:540dd5c:         MessageConsumer consumer = consumers.get(destination);
1:4060ad9:         if (create && consumer == null) {
1:ce9f83c:             consumer = getSession().createConsumer(destination, selector);
1:4060ad9:             consumers.put(destination, consumer);
1:40a7d3b:         }
1:40a7d3b:         return consumer;
1:40a7d3b:     }
1:40a7d3b: 
1:4060ad9:     public synchronized void closeConsumer(Destination destination) throws JMSException {
1:540dd5c:         MessageConsumer consumer = consumers.get(destination);
1:4060ad9:         if (consumer != null) {
1:4060ad9:             consumers.remove(destination);
1:4060ad9:             consumer.setMessageListener(null);
1:540dd5c:             if (consumer instanceof MessageAvailableConsumer) {
1:540dd5c:                 ((MessageAvailableConsumer)consumer).setAvailableListener(null);
1:540dd5c:             }
1:4060ad9:             consumer.close();
1:40a7d3b:         }
1:40a7d3b:     }
1:33cf032: 
1:540dd5c:     public synchronized List<MessageConsumer> getConsumers() {
1:540dd5c:         return new ArrayList<MessageConsumer>(consumers.values());
1:40a7d3b:     }
1:40a7d3b: 
1:87f75b2:     protected Session createSession() throws JMSException {
1:87f75b2:         return getConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);
1:40a7d3b:     }
1:40a7d3b: 
1:829787a:     public Semaphore getSemaphore() {
1:829787a:         return semaphore;
1:829787a:     }
1:40a7d3b: 
1:40a7d3b:     public void sessionWillPassivate(HttpSessionEvent event) {
1:4060ad9:         close();
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public void sessionDidActivate(HttpSessionEvent event) {
1:40a7d3b:     }
1:40a7d3b: 
1:4060ad9:     public void valueBound(HttpSessionBindingEvent event) {
1:40a7d3b:     }
1:40a7d3b: 
1:4060ad9:     public void valueUnbound(HttpSessionBindingEvent event) {
1:4060ad9:         close();
1:40a7d3b:     }
1:c1a1dd2: 
1:c1a1dd2:     protected static WebClient createWebClient(HttpServletRequest request) {
1:d4742f5:         WebClient client = new WebClient();
1:7fe862c: 
1:d4742f5:         String auth = request.getHeader("Authorization");
1:7fe862c:         if (factory.getUserName() == null && factory.getPassword() == null && auth != null) {
1:d4742f5:             String[] tokens = auth.split(" ");
1:d4742f5:             if (tokens.length == 2) {
1:d4742f5:                 String encoded = tokens[1].trim();
1:d4742f5:                 String credentials = new String(javax.xml.bind.DatatypeConverter.parseBase64Binary(encoded));
1:d4742f5:                 String[] creds = credentials.split(":");
1:d4742f5:                 if (creds.length == 2) {
1:d4742f5:                     client.setUsername(creds[0]);
1:d4742f5:                     client.setPassword(creds[1]);
1:d4742f5:                 }
1:d4742f5:             }
1:d4742f5:         }
1:d4742f5:         return client;
1:c1a1dd2:     }
1:c1a1dd2: 
1:40a7d3b: }
============================================================================
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:7fe862c
/////////////////////////////////////////////////////////////////////////
1:     public static final String USERNAME_INIT_PARAM = "org.apache.activemq.username";
1:     public static final String PASSWORD_INIT_PARAM = "org.apache.activemq.password";
1:     private static transient ActiveMQConnectionFactory factory;
/////////////////////////////////////////////////////////////////////////
1:             factory = (ActiveMQConnectionFactory)servletContext.getAttribute(CONNECTION_FACTORY_ATTRIBUTE);
1:             String brokerURL = getInitParameter(servletContext, BROKER_URL_INIT_PARAM);
/////////////////////////////////////////////////////////////////////////
1:             String username = getInitParameter(servletContext, USERNAME_INIT_PARAM);
1:             String password = getInitParameter(servletContext, PASSWORD_INIT_PARAM);
1:             ActiveMQConnectionFactory amqfactory = new ActiveMQConnectionFactory(username, password, brokerURL);
1:                 int prefetch = Integer.valueOf(getInitParameter(servletContext, CONNECTION_FACTORY_PREFETCH_PARAM)).intValue();
1:                 boolean optimizeAck = Boolean.valueOf(getInitParameter(servletContext, CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM)).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:     private static String getInitParameter(ServletContext servletContext, String initParam) {
1:         String result = servletContext.getInitParameter(initParam);
1:         if(result != null && result.startsWith("${") && result.endsWith("}"))
1:         {
1:             result = System.getProperty(result.substring(2,result.length()-1));
1:         }
1:         return result;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (factory.getUserName() == null && factory.getPassword() == null && auth != null) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:062adbb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:0507ad3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerRegistry;
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Couldn't find " + BROKER_URL_INIT_PARAM + " param, trying to find a broker embedded in a local VM");
1:                 BrokerService broker = BrokerRegistry.getInstance().findFirst();
1:                 if (broker == null) {
1:                     throw new IllegalStateException("missing brokerURL (specified via " + BROKER_URL_INIT_PARAM + " init-Param) or embedded broker");
1:                 } else {
1:                     brokerURL = "vm://" + broker.getBrokerName();
1:                 }
1:             LOG.debug("Using broker URL: " + brokerURL);
1: 
commit:76153ff
/////////////////////////////////////////////////////////////////////////
1:             if (username != null && password != null) {
1:                 connection = factory.createConnection(username, password);
1:             } else {
1:                 connection = factory.createConnection();
1:             }
commit:d4742f5
/////////////////////////////////////////////////////////////////////////
1:     private String username;
1:     private String password;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public String getUsername() {
1:         return username;
1:     }
1: 
1:     public void setUsername(String username) {
1:         this.username = username;
1:     }
1: 
1:     public String getPassword() {
1:         return password;
1:     }
1: 
1:     public void setPassword(String password) {
1:         this.password = password;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             connection = factory.createConnection(username, password);
/////////////////////////////////////////////////////////////////////////
1:         WebClient client = new WebClient();
1:         String auth = request.getHeader("Authorization");
0:         if (auth != null) {
1:             String[] tokens = auth.split(" ");
1:             if (tokens.length == 2) {
1:                 String encoded = tokens[1].trim();
1:                 String credentials = new String(javax.xml.bind.DatatypeConverter.parseBase64Binary(encoded));
1:                 String[] creds = credentials.split(":");
1:                 if (creds.length == 2) {
1:                     client.setUsername(creds[0]);
1:                     client.setPassword(creds[1]);
1:                 }
1:             }
1:         }
1:         return client;
commit:40ae055
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(WebClient.class);
commit:3c734ce
/////////////////////////////////////////////////////////////////////////
1:             if (consumers != null) {
1:                 closeConsumers();
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
commit:a05e84e
/////////////////////////////////////////////////////////////////////////
1:     public static final String SELECTOR_NAME = "org.apache.activemq.selectorName";
/////////////////////////////////////////////////////////////////////////
1:     public static String selectorName;
/////////////////////////////////////////////////////////////////////////
1:         if (selectorName == null) {
1:             selectorName = context.getInitParameter(SELECTOR_NAME);
1:         }
1:         if (selectorName == null) {
1:             selectorName = "selector";
1:         }        
commit:ce9f83c
/////////////////////////////////////////////////////////////////////////
0:     public static final String SELECTOR_NAME = "org.apache.activemq.selector";
/////////////////////////////////////////////////////////////////////////
1:                     consumers.put(destination, getConsumer(destination, null, true));
/////////////////////////////////////////////////////////////////////////
1:     public synchronized MessageConsumer getConsumer(Destination destination, String selector) throws JMSException {
1:         return getConsumer(destination, selector, true);
1:     public synchronized MessageConsumer getConsumer(Destination destination, String selector, boolean create) throws JMSException {
1:             consumer = getSession().createConsumer(destination, selector);
commit:b514d3f
/////////////////////////////////////////////////////////////////////////
commit:2b2b3e8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.camel.component.ActiveMQComponent;
0: import org.apache.activemq.camel.component.ActiveMQConfiguration;
0: import org.apache.activemq.pool.PooledConnectionFactory;
0: import org.apache.camel.CamelContext;
0: import org.apache.camel.ProducerTemplate;
0: import org.apache.camel.impl.DefaultCamelContext;
0: import sun.util.logging.resources.logging;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private CamelContext camelContext;
0:     private ProducerTemplate producerTemplate;
1: 
/////////////////////////////////////////////////////////////////////////
1:         context.setAttribute("webClients", new HashMap<String, WebClient>());
/////////////////////////////////////////////////////////////////////////
0:             if (producerTemplate != null) {
0:             	producerTemplate.stop();
1:             }
1:         } catch (Exception e) {
0:             producerTemplate = null;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public synchronized CamelContext getCamelContext() {
0:     	if (camelContext == null) {
0:     		LOG.debug("Creating camel context");
0:     		camelContext = new DefaultCamelContext();
0:     		ActiveMQConfiguration conf = new ActiveMQConfiguration();
0:     		conf.setConnectionFactory(new PooledConnectionFactory((ActiveMQConnectionFactory)factory));
0:     		ActiveMQComponent component = new ActiveMQComponent(conf);
0:     		camelContext.addComponent("activemq", component);
1:     	}
0:     	return camelContext;
1:     }
1:     
0:     public synchronized ProducerTemplate getProducerTemplate() throws Exception {
0:     	if (producerTemplate == null) {
0:     		LOG.debug("Creating producer template");
0:     		producerTemplate = getCamelContext().createProducerTemplate();
0:     		producerTemplate.start();
1:     	}
0:     	return producerTemplate;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Semaphore;
/////////////////////////////////////////////////////////////////////////
1:  * stored inside a HttpSession TODO controls to prevent DOS attacks with users
1:  * requesting many consumers TODO configure consumers with small prefetch.
1:     public static final String WEB_CLIENT_ATTRIBUTE = "org.apache.activemq.webclient";
1:     public static final String CONNECTION_FACTORY_ATTRIBUTE = "org.apache.activemq.connectionFactory";
1:     public static final String CONNECTION_FACTORY_PREFETCH_PARAM = "org.apache.activemq.connectionFactory.prefetch";
1:     public static final String CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM = "org.apache.activemq.connectionFactory.optimizeAck";
1:     public static final String BROKER_URL_INIT_PARAM = "org.apache.activemq.brokerURL";
0:     private static final Log LOG = LogFactory.getLog(WebClient.class);
1:     private transient Map<Destination, MessageConsumer> consumers = new HashMap<Destination, MessageConsumer>();
/////////////////////////////////////////////////////////////////////////
1:     public WebClient() {
1:         if (factory == null) {
1:             throw new IllegalStateException("initContext(ServletContext) not called");
1:         }
1:     }
1:      * 
/////////////////////////////////////////////////////////////////////////
1:             session.setAttribute(WEB_CLIENT_ATTRIBUTE, client);
1: 
1:         return (WebClient)session.getAttribute(WEB_CLIENT_ATTRIBUTE);
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<MessageConsumer> it = consumers.values().iterator(); it.hasNext();) {
1:             MessageConsumer consumer = it.next();
1:                 if (consumer instanceof MessageAvailableConsumer) {
1:                     ((MessageAvailableConsumer)consumer).setAvailableListener(null);
1:                 }
1:             } catch (JMSException e) {
1:                 LOG.debug("caught exception closing consumer", e);
/////////////////////////////////////////////////////////////////////////
1:             if (connection != null) {
1:             }
1:         } catch (JMSException e) {
1:             LOG.debug("caught exception closing consumer", e);
1:         } finally {
1:             if (consumers != null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             Iterator<Destination> i = consumers.keySet().iterator();
1:             while (i.hasNext()) {
1:             }
1:         } else {
1:         }
1:             consumers = new HashMap<Destination, MessageConsumer>();
1:                     Destination destination = destinationName.startsWith("topic://") ? (Destination)getSession().createTopic(destinationName) : (Destination)getSession().createQueue(destinationName);
0:                 } catch (JMSException e) {
1:                     LOG.debug("Caought Exception ", e);
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Sent! to destination: " + destination + " message: " + message);
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Sent! to destination: " + destination + " message: " + message);
/////////////////////////////////////////////////////////////////////////
0:             factory = (ConnectionFactory)servletContext.getAttribute(CONNECTION_FACTORY_ATTRIBUTE);
1:         }
1:         if (factory == null) {
0:             String brokerURL = servletContext.getInitParameter(BROKER_URL_INIT_PARAM);
0:             LOG.debug("Value of: " + BROKER_URL_INIT_PARAM + " is: " + brokerURL);
0:                 throw new IllegalStateException("missing brokerURL (specified via " + BROKER_URL_INIT_PARAM + " init-Param");
1:             if (servletContext.getInitParameter(CONNECTION_FACTORY_PREFETCH_PARAM) != null) {
0:                 int prefetch = Integer.valueOf(servletContext.getInitParameter(CONNECTION_FACTORY_PREFETCH_PARAM)).intValue();
1:             if (servletContext.getInitParameter(CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM) != null) {
0:                 boolean optimizeAck = Boolean.valueOf(servletContext.getInitParameter(CONNECTION_FACTORY_OPTIMIZE_ACK_PARAM)).booleanValue();
1:             servletContext.setAttribute(CONNECTION_FACTORY_ATTRIBUTE, factory);
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = consumers.get(destination);
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = consumers.get(destination);
1:             if (consumer instanceof MessageAvailableConsumer) {
1:                 ((MessageAvailableConsumer)consumer).setAvailableListener(null);
1:             }
1:     public synchronized List<MessageConsumer> getConsumers() {
1:         return new ArrayList<MessageConsumer>(consumers.values());
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Semaphore;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:88d5857
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.ActiveMQSession;
commit:f1a084e
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.web;
/////////////////////////////////////////////////////////////////////////
0:     public static final String webClientAttribute = "org.apache.activemq.webclient";
0:     public static final String connectionFactoryAttribute = "org.apache.activemq.connectionFactory";
0:     public static final String queueConsumersAttribute = "org.apache.activemq.queueConsumers";
0:     public static final String brokerUrlInitParam = "org.apache.activemq.brokerURL";
commit:ceeb3a2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:829787a
/////////////////////////////////////////////////////////////////////////
1: import java.io.Externalizable;
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.activemq.ActiveMQConnection;
0: import org.activemq.ActiveMQConnectionFactory;
0: import org.activemq.ActiveMQSession;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.Semaphore;
/////////////////////////////////////////////////////////////////////////
1:     private final Semaphore semaphore = new Semaphore(1);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Semaphore getSemaphore() {
1:         return semaphore;
1:     }
author:James Strachan
-------------------------------------------------------------------------------
commit:e7ca882
/////////////////////////////////////////////////////////////////////////
1:     public void send(Destination destination, Message message, boolean persistent, int priority, long timeToLive) throws JMSException {
commit:87f75b2
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Connection;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private transient Connection connection;
1:     private transient Session session;
/////////////////////////////////////////////////////////////////////////
1:     public Connection getConnection() throws JMSException {
0:             connection = factory.createConnection();
1:     protected static synchronized void initConnectionFactory(ServletContext servletContext) {
/////////////////////////////////////////////////////////////////////////
0:             	throw new IllegalStateException("missing brokerURL (specified via "+brokerUrlInitParam+" init-Param");
/////////////////////////////////////////////////////////////////////////
1:     protected Session createSession() throws JMSException {
1:         return getConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);
commit:4443d32
/////////////////////////////////////////////////////////////////////////
1: 
0:             log.debug("Value of: " + brokerUrlInitParam + " is: " + brokerURL);
commit:c1a1dd2
/////////////////////////////////////////////////////////////////////////
1: import javax.servlet.http.HttpServletRequest;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Helper method to get the client for the current session, lazily creating
1:      * a client if there is none currently
1:      *
1:      * @param request is the current HTTP request
1:      * @return the current client or a newly creates
1:      */
1:     public static WebClient getWebClient(HttpServletRequest request) {
1:         HttpSession session = request.getSession(true);
1:         WebClient client = getWebClient(session);
1:         if (client == null || client.isClosed()) {
1:             client = WebClient.createWebClient(request);
0:             session.setAttribute(webClientAttribute, client);
1:         }
1:         return client;
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected static WebClient createWebClient(HttpServletRequest request) {
0:         return new WebClient();
1:     }
1: 
commit:33cf032
/////////////////////////////////////////////////////////////////////////
1:  * Represents a messaging client used from inside a web container typically
0:  * stored inside a HttpSession
0:  * TODO controls to prevent DOS attacks with users requesting many consumers
1:  * 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @return the web client for the current HTTP session or null if there is
1:      *         not a web client created yet
/////////////////////////////////////////////////////////////////////////
0:         if (factory == null)
1:     public synchronized void closeConsumers() {
1:             try {
0:                     ((MessageAvailableConsumer) consumer).setAvailableListener(null);
0:             catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
0:             if (connection != null)
1:         }
0:         catch (JMSException e) {
0:             if (consumers != null)
1:             consumers = null;
1: 
1:     public boolean isClosed() {
1:         return consumers == null;
1:         if (consumers != null) {
0:             Iterator i = consumers.keySet().iterator();
0:             while (i.hasNext())
1: 
1:         if (size >= 0) {
1:             for (int i = 0; i < size; i++) {
1:                 String destinationName = in.readObject().toString();
1: 
1:                 try {
0:                     Destination destination = destinationName.startsWith("topic://") ? (Destination) getSession().createTopic(destinationName)
0:                             : (Destination) getSession().createQueue(destinationName);
0:                     consumers.put(destination, getConsumer(destination, true));
0:                 catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
1:         getProducer().send(destination, message);
0:         if (log.isDebugEnabled()) {
0:             log.debug("Sent! to destination: " + destination + " message: " + message);
1:     }
1: 
0:     public void send(Destination destination, Message message, boolean persistent, int priority, int timeToLive) throws JMSException {
1:         int deliveryMode = persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;
1:         getProducer().send(destination, message, deliveryMode, priority, timeToLive);
/////////////////////////////////////////////////////////////////////////
0:         if (factory == null)
1: 
1: 
1: 
1: 
1:     public synchronized MessageProducer getProducer() throws JMSException {
1:         if (producer == null) {
1:             producer = getSession().createProducer(null);
1:             producer.setDeliveryMode(deliveryMode);
1:         }
1:         return producer;
1:     }
1: 
1:     public void setProducer(MessageProducer producer) {
1:         this.producer = producer;
1:     }
1: 
0:         return getConsumer(destination, true);
/////////////////////////////////////////////////////////////////////////
0:                 ((MessageAvailableConsumer) consumer).setAvailableListener(null);
1: 
0:     public synchronized List getConsumers() {
/////////////////////////////////////////////////////////////////////////
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * 
0:  * Copyright 2004 Protique Ltd
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); 
0:  * you may not use this file except in compliance with the License. 
0:  * You may obtain a copy of the License at 
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS, 
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
1:  * See the License for the specific language governing permissions and 
1:  * limitations under the License. 
0:  * 
0:  **/
1: 
0: package org.activemq.web;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
0: import org.activemq.ActiveMQConnection;
0: import org.activemq.ActiveMQConnectionFactory;
0: import org.activemq.ActiveMQSession;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
0: import javax.jms.Topic;
1: import javax.servlet.ServletContext;
1: import javax.servlet.http.HttpSession;
1: import javax.servlet.http.HttpSessionActivationListener;
1: import javax.servlet.http.HttpSessionEvent;
1: 
0: import java.io.Externalizable;
0: import java.io.IOException;
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import java.util.HashMap;
0: import java.util.Map;
1: 
1: /**
0:  * Represents a messaging client used from inside a web container
0:  * typically stored inside a HttpSession
0:  *
0:  * @version $Revision: 1.1.1.1 $
1:  */
0: public class WebClient implements HttpSessionActivationListener, Externalizable {
0:     public static final String webClientAttribute = "org.activemq.webclient";
0:     public static final String connectionFactoryAttribute = "org.activemq.connectionFactory";
0:     public static final String queueConsumersAttribute = "org.activemq.queueConsumers";
0:     public static final String brokerUrlInitParam = "org.activemq.brokerURL";
0:     public static final String embeddedBrokerInitParam = "org.activemq.embeddedBroker";
1: 
0:     private static final Log log = LogFactory.getLog(WebClient.class);
1: 
0:     private static transient ConnectionFactory factory;
0:     private static transient Map queueConsumers;
1: 
0:     private transient ServletContext context;
0:     private transient ActiveMQConnection connection;
0:     private transient ActiveMQSession session;
1:     private transient MessageProducer producer;
0:     private transient Map topicConsumers = new ConcurrentHashMap();
1:     private int deliveryMode = DeliveryMode.NON_PERSISTENT;
1: 
1: 
1:     /**
0:      * @return the web client for the current HTTP session or null if there is not a web client created yet
1:      */
1:     public static WebClient getWebClient(HttpSession session) {
0:         return (WebClient) session.getAttribute(webClientAttribute);
1:     }
1: 
1: 
1:     public static void initContext(ServletContext context) {
0:         factory = initConnectionFactory(context);
1:         if (factory == null) {
0:             log.warn("No ConnectionFactory available in the ServletContext for: " + connectionFactoryAttribute);
0:             factory = new ActiveMQConnectionFactory("vm://localhost");
0:             context.setAttribute(connectionFactoryAttribute, factory);
1:         }
0:         queueConsumers = initQueueConsumers(context);
1:     }
1: 
1:     /**
0:      * Only called by serialization
1:      */
0:     public WebClient() {
1:     }
1: 
0:     public WebClient(ServletContext context) {
0:         this.context = context;
0:         initContext(context);
1:     }
1: 
1:     
1:     public int getDeliveryMode() {
1:         return deliveryMode;
1:     }
1: 
1: 
1:     public void setDeliveryMode(int deliveryMode) {
1:         this.deliveryMode = deliveryMode;
1:     }
1: 
1: 
0:     public void start() throws JMSException {
1:     }
1: 
0:     public void stop() throws JMSException {
0:         System.out.println("Closing the WebClient!!! " + this);
1:         
1:         try {
1:             connection.close();
1:         }
0:         finally {
1:             producer = null;
1:             session = null;
1:             connection = null;
0:             topicConsumers.clear();
1:         }
1:     }
1: 
1:     public void writeExternal(ObjectOutput out) throws IOException {
1:     }
1: 
1:     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
0:         topicConsumers = new HashMap();
1:     }
1: 
1:     public void send(Destination destination, Message message) throws JMSException {
0:         if (producer == null) {
0:             producer = getSession().createProducer(null);
0:             producer.setDeliveryMode(deliveryMode );
1:         }
0:         producer.send(destination, message);
0:         if (log.isDebugEnabled()) {
0:             log.debug("Sent! to destination: " + destination + " message: " + message);
1:         }
1:     }
1: 
1:     public Session getSession() throws JMSException {
1:         if (session == null) {
1:             session = createSession();
1:         }
1:         return session;
1:     }
1: 
0:     public ActiveMQConnection getConnection() throws JMSException {
1:         if (connection == null) {
0:             connection = (ActiveMQConnection) factory.createConnection();
1:             connection.start();
1:         }
1:         return connection;
1:     }
1: 
1:     public void sessionWillPassivate(HttpSessionEvent event) {
1:         try {
0:             stop();
1:         }
0:         catch (JMSException e) {
0:             log.warn("Could not close connection: " + e, e);
1:         }
1:     }
1: 
1:     public void sessionDidActivate(HttpSessionEvent event) {
0:         // lets update the connection factory from the servlet context
0:         context = event.getSession().getServletContext();
0:         initContext(context);
1:     }
1: 
0:     public static Map initQueueConsumers(ServletContext context) {
0:         Map answer = (Map) context.getAttribute(queueConsumersAttribute);
0:         if (answer == null) {
0:             answer = new HashMap();
0:             context.setAttribute(queueConsumersAttribute, answer);
1:         }
0:         return answer;
1:     }
1: 
1: 
0:     public static ConnectionFactory initConnectionFactory(ServletContext servletContext) {
0:         ConnectionFactory connectionFactory = (ConnectionFactory) servletContext.getAttribute(connectionFactoryAttribute);
0:         if (connectionFactory == null) {
0:             String brokerURL = (String) servletContext.getInitParameter(brokerUrlInitParam);
1: 
0:             servletContext.log("Value of: " + brokerUrlInitParam + " is: " + brokerURL);
1: 
1:             if (brokerURL == null) {
0:                 brokerURL = "vm://localhost";
1:             }
1: 
0:             boolean embeddedBroker = MessageServletSupport.asBoolean(servletContext.getInitParameter(embeddedBrokerInitParam));
0:             servletContext.log("Use embedded broker: " + embeddedBroker);
1: 
0:             ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(brokerURL);
0:             factory.setUseEmbeddedBroker(embeddedBroker);
1: 
0:             connectionFactory = factory;
0:             servletContext.setAttribute(connectionFactoryAttribute, connectionFactory);
1:         }
0:         return connectionFactory;
1:     }
1: 
0:     public synchronized MessageConsumer getConsumer(Destination destination) throws JMSException {
0:         if (destination instanceof Topic) {
0:             MessageConsumer consumer = (MessageConsumer) topicConsumers.get(destination);
0:             if (consumer == null) {
0:                 consumer = getSession().createConsumer(destination);
0:                 topicConsumers.put(destination, consumer);
1:             }
1:             return consumer;
1:         }
0:         else {
0:             synchronized (queueConsumers) {
0:                 SessionConsumerPair pair = (SessionConsumerPair) queueConsumers.get(destination);
0:                 if (pair == null) {
0:                     pair = createSessionConsumerPair(destination);
0:                     queueConsumers.put(destination, pair);
1:                 }
0:                 return pair.consumer;
1:             }
1:         }
1:     }
1: 
0:     protected ActiveMQSession createSession() throws JMSException {
0:         return (ActiveMQSession) getConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);
1:     }
1: 
0:     protected SessionConsumerPair createSessionConsumerPair(Destination destination) throws JMSException {
0:         SessionConsumerPair answer = new SessionConsumerPair();
0:         answer.session = createSession();
0:         answer.consumer = answer.session.createConsumer(destination);
0:         return answer;
1:     }
1: 
0:     protected static class SessionConsumerPair {
0:         public Session session;
0:         public MessageConsumer consumer;
1:     }
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c171817
/////////////////////////////////////////////////////////////////////////
0:                 log.debug("caught exception closing consumer",e);
/////////////////////////////////////////////////////////////////////////
0:             log.debug("caught exception closing consumer",e);
/////////////////////////////////////////////////////////////////////////
0:                     log.debug("Caought Exception ",e);
1:                     IOException ex = new IOException(e.getMessage());
1:                     ex.initCause(e.getCause() != null ? e.getCause() : e);
1:                     throw ex;
0:                     
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:c4b11a6
/////////////////////////////////////////////////////////////////////////
0: 
0:     public static final String connectionFactoryPrefetchParam = "org.apache.activemq.connectionFactory.prefetch";
0:     public static final String connectionFactoryOptimizeAckParam = "org.apache.activemq.connectionFactory.optimizeAck";
/////////////////////////////////////////////////////////////////////////
0:             if (servletContext.getInitParameter(connectionFactoryPrefetchParam) != null) {
0:                 int prefetch = Integer.valueOf(servletContext.getInitParameter(connectionFactoryPrefetchParam)).intValue();
0:             if (servletContext.getInitParameter(connectionFactoryOptimizeAckParam) != null) {
0:                 boolean optimizeAck = Boolean.valueOf(servletContext.getInitParameter(connectionFactoryOptimizeAckParam)).booleanValue();
commit:2391cb0
/////////////////////////////////////////////////////////////////////////
0:     public static final String connectionFactoryPrefetch = "org.apache.activemq.connectionFactory.prefetch";
0:     public static final String connectionFactoryOptimizeAck = "org.apache.activemq.connectionFactory.optimizeAck";
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:             // Set prefetch policy for factory
0:             if (servletContext.getInitParameter(connectionFactoryPrefetch) != null) {
0:                 int prefetch = Integer.valueOf(servletContext.getInitParameter(connectionFactoryPrefetch)).intValue();
1:                 amqfactory.getPrefetchPolicy().setAll(prefetch);
0:             }
0: 
1:             // Set optimize acknowledge setting
0:             if (servletContext.getInitParameter(connectionFactoryOptimizeAck) != null) {
0:                 boolean optimizeAck = Boolean.valueOf(servletContext.getInitParameter(connectionFactoryOptimizeAck)).booleanValue();
1:                 amqfactory.setOptimizeAcknowledge(optimizeAck);
0:             }
0: 
author:Gregory John Wilkins
-------------------------------------------------------------------------------
commit:4060ad9
/////////////////////////////////////////////////////////////////////////
1: import javax.servlet.http.HttpSessionBindingEvent;
1: import javax.servlet.http.HttpSessionBindingListener;
1: import org.apache.activemq.MessageAvailableConsumer;
0:  * 
0:  * TODO controls to prevent DOS attacks with users requesting many consumers 
0:  * TODO configure consumers with small prefetch.
1: public class WebClient implements HttpSessionActivationListener, HttpSessionBindingListener, Externalizable {
0:     
0:     
0:     private transient Map consumers = new HashMap();
/////////////////////////////////////////////////////////////////////////
1:         initConnectionFactory(context);
0:         if (factory==null)
0:             throw new IllegalStateException("initContext(ServletContext) not called");
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void closeConsumers() 
0:     {
0:         for (Iterator it = consumers.values().iterator(); it.hasNext();) {
0:             MessageConsumer consumer = (MessageConsumer) it.next();
1:             it.remove();
0:             try{
1:                 consumer.setMessageListener(null);
0:                 if (consumer instanceof MessageAvailableConsumer)
0:                     ((MessageAvailableConsumer)consumer).setAvailableListener(null);
1:                 consumer.close();
0:             }
0:             catch(JMSException e)
0:             {
0:                 e.printStackTrace();
0:             }
0:         }
1:     public synchronized void close() {
0:             closeConsumers();
0:             if (connection!=null)
0:                 connection.close();
0:         } catch (JMSException e) {
0:             throw new RuntimeException(e);
0:             if (consumers!=null)
1:                 consumers.clear();
0:             consumers=null;
0:     
0:     public boolean isClosed()
0:     {
0:         return consumers==null;
0:     }
0:         
0:         if (consumers!=null)
0:         {
1:             out.write(consumers.size());
0:             Iterator i=consumers.keySet().iterator();
0:             while(i.hasNext())
1:                 out.writeObject(i.next().toString());
0:         }
0:         else
1:             out.write(-1);
0:             
1:         int size = in.readInt();
0:         if (size >=0) {
0:             consumers = new HashMap();
0:             for (int i=0;i<size;i++) {
0:                 String  destinationName = in.readObject().toString(); 
0:                 
0:                 try{
0:                     Destination destination = destinationName.startsWith("topic://")
0:                     ?(Destination)getSession().createTopic(destinationName)
0:                     :(Destination)getSession().createQueue(destinationName);
0:                     consumers.put(destination,getConsumer(destination, true));
0:                 }
0:                 catch (JMSException e)
0:                 {
0:                     e.printStackTrace(); // TODO better handling?
0:                 }
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public static synchronized void initConnectionFactory(ServletContext servletContext) {
0:         if (factory==null)
0:             factory = (ConnectionFactory) servletContext.getAttribute(connectionFactoryAttribute);
0:         if (factory == null) {
0:             String brokerURL = servletContext.getInitParameter(brokerUrlInitParam);
0:             
0:             
0:             
0:             ActiveMQConnectionFactory amqfactory = new ActiveMQConnectionFactory(brokerURL);
1:             factory = amqfactory;
0:            
0:             servletContext.setAttribute(connectionFactoryAttribute, factory);
0:         return getConsumer(destination,true);
0:     }
0: 
0:     public synchronized MessageConsumer getConsumer(Destination destination, boolean create) throws JMSException {
0:         
0:         MessageConsumer consumer = (MessageConsumer) consumers.get(destination);
1:         if (create && consumer == null) {
0:             consumer = getSession().createConsumer(destination);
1:             consumers.put(destination, consumer);
0:         return consumer;
0:     }
0: 
1:     public synchronized void closeConsumer(Destination destination) throws JMSException {
0:         MessageConsumer consumer = (MessageConsumer) consumers.get(destination);
1:         if (consumer != null) {
1:             consumers.remove(destination);
1:             consumer.setMessageListener(null);
0:             if (consumer instanceof MessageAvailableConsumer)
0:                 ((MessageAvailableConsumer)consumer).setAvailableListener(null);
1:             consumer.close();
0:         return new ArrayList(consumers.values());
0: 
0:     public void sessionWillPassivate(HttpSessionEvent event) {
1:         close();
0:     }
0: 
0:     public void sessionDidActivate(HttpSessionEvent event) {
0:     }
0: 
1:     public void valueBound(HttpSessionBindingEvent event) {
0:     }
0: 
1:     public void valueUnbound(HttpSessionBindingEvent event) {
1:         close();
0:     }
commit:4e5012c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public synchronized List getConsumers()
0:     {
0:         ArrayList list = new ArrayList(topicConsumers.size()+queueConsumers.size());
0:         
0:         // TODO check this double synchronization on queue but not on topics
0:         synchronized (queueConsumers) {
0:             list.addAll(queueConsumers.values());
0:         }
0:         list.addAll(topicConsumers.values());
0:         return list;
0:     }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:aa2188c
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator it = queueConsumers.values().iterator(); it.hasNext();) {
0:                 SessionConsumerPair pair = (SessionConsumerPair) it.next();
0:                 list.add(pair.consumer);
0:             }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
author:Frederick G. Oconer
-------------------------------------------------------------------------------
commit:b6b7cce
============================================================================