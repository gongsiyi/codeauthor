1:b550fb7: /**
1:b550fb7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b550fb7:  * contributor license agreements.  See the NOTICE file distributed with
1:b550fb7:  * this work for additional information regarding copyright ownership.
1:b550fb7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b550fb7:  * (the "License"); you may not use this file except in compliance with
1:b550fb7:  * the License.  You may obtain a copy of the License at
1:b550fb7:  *
1:b550fb7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b550fb7:  *
1:b550fb7:  * Unless required by applicable law or agreed to in writing, software
1:b550fb7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b550fb7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b550fb7:  * See the License for the specific language governing permissions and
1:b550fb7:  * limitations under the License.
1:b550fb7:  */
1:b550fb7: package org.apache.activemq.bugs;
28:b550fb7: 
1:21c3ba3: import static org.junit.Assert.assertEquals;
1:21c3ba3: 
1:b550fb7: import java.util.ArrayList;
1:54e2e3b: import java.util.Arrays;
1:b550fb7: import java.util.Collections;
1:b550fb7: import java.util.HashMap;
1:b550fb7: import java.util.List;
1:b550fb7: import java.util.Map;
1:b550fb7: import java.util.TreeSet;
1:b550fb7: import java.util.UUID;
1:21c3ba3: 
1:b550fb7: import javax.jms.Message;
1:b550fb7: import javax.jms.MessageConsumer;
1:b550fb7: import javax.jms.MessageProducer;
1:b550fb7: import javax.jms.Queue;
1:b550fb7: import javax.jms.QueueConnection;
1:b550fb7: import javax.jms.Session;
1:b550fb7: import javax.jms.TextMessage;
1:21c3ba3: 
1:b550fb7: import org.apache.activemq.ActiveMQConnection;
1:b550fb7: import org.apache.activemq.ActiveMQConnectionFactory;
1:b550fb7: import org.apache.activemq.RedeliveryPolicy;
1:3042797: import org.apache.activemq.TestSupport;
1:b550fb7: import org.apache.activemq.broker.BrokerService;
1:b550fb7: import org.apache.activemq.broker.TransportConnector;
1:b550fb7: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:b550fb7: import org.apache.activemq.broker.region.policy.PolicyMap;
1:b550fb7: import org.apache.activemq.command.ActiveMQQueue;
1:b550fb7: import org.junit.After;
1:b550fb7: import org.junit.Before;
1:b550fb7: import org.junit.Test;
1:54e2e3b: import org.junit.runner.RunWith;
1:54e2e3b: import org.junit.runners.Parameterized;
1:b550fb7: import org.slf4j.Logger;
1:b550fb7: import org.slf4j.LoggerFactory;
1:54e2e3b: 
1:b550fb7: /**
1:21c3ba3:  * Will kick of publisher and consumer simultaneously, and will usually result in
1:21c3ba3:  * stuck messages on the queue.
1:b550fb7:  */
1:54e2e3b: @RunWith(Parameterized.class)
1:b550fb7: public class AMQ5266Test {
1:b550fb7:     static Logger LOG = LoggerFactory.getLogger(AMQ5266Test.class);
1:21c3ba3: 
1:21c3ba3:     private String activemqURL;
1:21c3ba3:     private BrokerService brokerService;
1:b550fb7: 
1:54e2e3b:     public int messageSize = 1000;
1:54e2e3b: 
1:54e2e3b:     @Parameterized.Parameter(0)
1:54e2e3b:     public int publisherMessagesPerThread = 1000;
1:54e2e3b: 
1:54e2e3b:     @Parameterized.Parameter(1)
1:54e2e3b:     public int publisherThreadCount = 20;
1:54e2e3b: 
1:54e2e3b:     @Parameterized.Parameter(2)
1:54e2e3b:     public int consumerThreadsPerQueue = 5;
1:54e2e3b: 
1:54e2e3b:     @Parameterized.Parameter(3)
1:54e2e3b:     public int destMemoryLimit = 50 * 1024;
1:54e2e3b: 
1:54e2e3b:     @Parameterized.Parameter(4)
1:54e2e3b:     public boolean useCache = true;
1:54e2e3b: 
1:54e2e3b:     @Parameterized.Parameter(5)
1:3042797:     public TestSupport.PersistenceAdapterChoice persistenceAdapterChoice = TestSupport.PersistenceAdapterChoice.KahaDB;
1:54e2e3b: 
1:5861d86:     @Parameterized.Parameter(6)
1:5861d86:     public boolean optimizeDispatch = false;
1:5861d86: 
1:3042797:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},store:{5},optimizedDispatch:{6}")
1:54e2e3b:     public static Iterable<Object[]> parameters() {
1:54e2e3b:         return Arrays.asList(new Object[][]{
1:3042797:                 {1,    1,   1,   50*1024,   false, TestSupport.PersistenceAdapterChoice.JDBC, true},
1:3042797:                 {1000, 20,  5,   50*1024,   true,  TestSupport.PersistenceAdapterChoice.JDBC, false},
1:3042797:                 {100,  20,  5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.JDBC, false},
1:3042797:                 {1000, 5,   20,  50*1024,   true,  TestSupport.PersistenceAdapterChoice.JDBC, false},
1:3042797:                 {1000, 20,  20,  1024*1024, true,  TestSupport.PersistenceAdapterChoice.JDBC, false},
1:54e2e3b: 
1:3042797:                 {1,    1,   1,   50*1024,   false, TestSupport.PersistenceAdapterChoice.KahaDB, true},
1:3042797:                 {100,  5,   5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:3042797:                 {1000, 20,  5,   50*1024,   true,  TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:3042797:                 {100,  20,  5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:3042797:                 {1000, 5,   20,  50*1024,   true,  TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:3042797:                 {1000, 20,  20,  1024*1024, true,  TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:3042797: 
1:3042797:                 {1,    1,   1,   50*1024,   false, TestSupport.PersistenceAdapterChoice.LevelDB, true},
1:3042797:                 {100,  5,   5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:3042797:                 {1000, 20,  5,   50*1024,   true,  TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:3042797:                 {100,  20,  5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:3042797:                 {1000, 5,   20,  50*1024,   true,  TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:3042797:                 {1000, 20,  20,  1024*1024, true,  TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:3042797: 
1:54e2e3b:         });
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     public int consumerBatchSize = 5;
1:54e2e3b: 
1:b550fb7:     @Before
1:b550fb7:     public void startBroker() throws Exception {
1:b550fb7:         brokerService = new BrokerService();
1:3042797:         TestSupport.setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:b550fb7:         brokerService.setDeleteAllMessagesOnStartup(true);
1:5861d86:         brokerService.setUseJmx(false);
1:54e2e3b: 
1:b550fb7:         PolicyMap policyMap = new PolicyMap();
1:b550fb7:         PolicyEntry defaultEntry = new PolicyEntry();
1:54e2e3b:         defaultEntry.setUseConsumerPriority(false); // java.lang.IllegalArgumentException: Comparison method violates its general contract!
1:54e2e3b:         defaultEntry.setMaxAuditDepth(publisherThreadCount);
1:54e2e3b:         defaultEntry.setEnableAudit(true);
1:54e2e3b:         defaultEntry.setUseCache(useCache);
1:b550fb7:         defaultEntry.setMaxPageSize(1000);
1:5861d86:         defaultEntry.setOptimizedDispatch(optimizeDispatch);
1:54e2e3b:         defaultEntry.setMemoryLimit(destMemoryLimit);
1:b550fb7:         defaultEntry.setExpireMessagesPeriod(0);
1:b550fb7:         policyMap.setDefaultEntry(defaultEntry);
1:b550fb7:         brokerService.setDestinationPolicy(policyMap);
1:b550fb7: 
1:b550fb7:         brokerService.getSystemUsage().getMemoryUsage().setLimit(512 * 1024 * 1024);
1:b550fb7: 
1:b550fb7:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
1:b550fb7:         brokerService.start();
1:b550fb7:         activemqURL = transportConnector.getPublishableConnectString();
4:b550fb7:     }
1:b550fb7: 
1:b550fb7:     @After
1:b550fb7:     public void stopBroker() throws Exception {
1:b550fb7:         if (brokerService != null) {
1:b550fb7:             brokerService.stop();
1:b550fb7:         }
1:b550fb7:     }
1:b550fb7: 
1:b550fb7:     @Test
1:b550fb7:     public void test() throws Exception {
1:b550fb7: 
1:b550fb7:         String activemqQueues = "activemq,activemq2";//,activemq3,activemq4,activemq5,activemq6,activemq7,activemq8,activemq9";
1:b550fb7: 
1:b550fb7:         int consumerWaitForConsumption = 5 * 60 * 1000;
1:b550fb7: 
1:b550fb7:         ExportQueuePublisher publisher = null;
1:b550fb7:         ExportQueueConsumer consumer = null;
1:b550fb7: 
1:b550fb7:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
1:b550fb7:         LOG.info("\nBuilding Publisher...");
1:b550fb7: 
1:b550fb7:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
1:b550fb7: 
1:b550fb7:         LOG.info("Building Consumer...");
1:b550fb7: 
1:b550fb7:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
1:b550fb7: 
1:b550fb7:         LOG.info("Starting Publisher...");
1:b550fb7: 
1:b550fb7:         publisher.start();
1:b550fb7: 
1:b550fb7:         LOG.info("Starting Consumer...");
1:b550fb7: 
1:b550fb7:         consumer.start();
1:b550fb7: 
1:b550fb7:         int distinctPublishedCount = 0;
1:b550fb7: 
1:b550fb7:         LOG.info("Waiting For Publisher Completion...");
1:b550fb7: 
1:b550fb7:         publisher.waitForCompletion();
1:b550fb7: 
1:21c3ba3:         List<String> publishedIds = publisher.getIDs();
1:21c3ba3:         distinctPublishedCount = new TreeSet<String>(publishedIds).size();
1:b550fb7: 
1:54e2e3b:         LOG.info("Publisher Complete. Published: " + publishedIds.size() + ", Distinct IDs Published: " + distinctPublishedCount);
1:b550fb7: 
1:b550fb7:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
1:b550fb7:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
2:b550fb7:             try {
1:b550fb7:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
1:b550fb7:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
1:b550fb7:                 Thread.sleep(10000);
1:b550fb7:             } catch (Exception e) {
1:54e2e3b:             }
1:54e2e3b:         }
1:b550fb7: 
1:54e2e3b:         LOG.info("\nConsumer Complete: " + consumer.completed() +", Shutting Down.");
1:b550fb7: 
1:b550fb7:         consumer.shutdown();
1:54e2e3b: 
1:b550fb7:         LOG.info("Consumer Stats:");
1:b550fb7: 
1:b550fb7:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
1:b550fb7: 
1:b550fb7:             List<String> idList = entry.getValue();
1:b550fb7: 
1:b550fb7:             int distinctConsumed = new TreeSet<String>(idList).size();
1:b550fb7: 
1:b550fb7:             StringBuilder sb = new StringBuilder();
1:b550fb7:             sb.append("   Queue: " + entry.getKey() +
1:b550fb7:                     " -> Total Messages Consumed: " + idList.size() +
1:b550fb7:                     ", Distinct IDs Consumed: " + distinctConsumed);
1:b550fb7: 
1:b550fb7:             int diff = distinctPublishedCount - distinctConsumed;
1:b550fb7:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
1:b550fb7:             LOG.info(sb.toString());
1:b550fb7: 
1:b550fb7:             assertEquals("expect to get all messages!", 0, diff);
1:b550fb7:         }
1:b550fb7:     }
1:b550fb7: 
1:b550fb7:     public class ExportQueuePublisher {
1:b550fb7: 
1:b550fb7:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:b550fb7:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:b550fb7:         private ActiveMQConnectionFactory connectionFactory = null;
1:b550fb7:         private String activemqURL = null;
1:b550fb7:         private String activemqQueues = null;
1:b550fb7:         // Collection of distinct IDs that the publisher has published.
1:b550fb7:         // After a message is published, its UUID will be written to this list for tracking.
1:b550fb7:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
1:54e2e3b:         //private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:54e2e3b:         private List<String> ids = Collections.synchronizedList(new ArrayList<String>());
1:b550fb7:         private List<PublisherThread> threads;
1:b550fb7: 
1:b550fb7:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
1:b550fb7: 
1:b550fb7:             this.activemqURL = activemqURL;
1:b550fb7:             this.activemqQueues = activemqQueues;
1:b550fb7: 
1:b550fb7:             threads = new ArrayList<PublisherThread>();
1:b550fb7: 
1:b550fb7:             // Build the threads and tell them how many messages to publish
1:b550fb7:             for (int i = 0; i < threadCount; i++) {
1:b550fb7:                 PublisherThread pt = new PublisherThread(messagesPerThread);
1:b550fb7:                 threads.add(pt);
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7: 
1:54e2e3b:         public List<String> getIDs() {
1:b550fb7:             return ids;
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         // Kick off threads
1:b550fb7:         public void start() throws Exception {
1:b550fb7: 
1:b550fb7:             for (PublisherThread pt : threads) {
1:b550fb7:                 pt.start();
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         // Wait for threads to complete. They will complete once they've published all of their messages.
1:b550fb7:         public void waitForCompletion() throws Exception {
1:b550fb7: 
1:b550fb7:             for (PublisherThread pt : threads) {
1:b550fb7:                 pt.join();
1:b550fb7:                 pt.close();
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:b550fb7:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:b550fb7:         }
1:b550fb7: 
1:54e2e3b:         private synchronized QueueConnection newQueueConnection() throws Exception {
1:b550fb7: 
1:b550fb7:             if (connectionFactory == null) {
1:b550fb7:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:b550fb7:             // after the queue has had a certain number of failures (default is 6)
1:b550fb7:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:b550fb7:             policy.setMaximumRedeliveries(-1);
1:b550fb7: 
1:b550fb7:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:b550fb7:             amqConnection.start();
1:b550fb7:             return amqConnection;
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         private class PublisherThread extends Thread {
1:b550fb7: 
1:b550fb7:             private int count;
1:b550fb7:             private QueueConnection qc;
1:b550fb7:             private Session session;
1:b550fb7:             private MessageProducer mp;
1:b550fb7: 
1:b550fb7:             private PublisherThread(int count) throws Exception {
1:b550fb7: 
1:b550fb7:                 this.count = count;
1:b550fb7: 
1:b550fb7:                 // Each Thread has its own Connection and Session, so no sync worries
1:b550fb7:                 qc = newQueueConnection();
1:b550fb7:                 session = newSession(qc);
1:b550fb7: 
1:b550fb7:                 // In our code, when publishing to multiple queues,
1:b550fb7:                 // we're using composite destinations like below
1:b550fb7:                 Queue q = new ActiveMQQueue(activemqQueues);
1:b550fb7:                 mp = session.createProducer(q);
1:b550fb7:             }
1:b550fb7: 
1:21c3ba3:             @Override
1:b550fb7:             public void run() {
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7: 
1:b550fb7:                     // Loop until we've published enough messages
1:b550fb7:                     while (count-- > 0) {
1:b550fb7: 
1:54e2e3b:                         TextMessage tm = session.createTextMessage(getMessageText());
1:b550fb7:                         String id = UUID.randomUUID().toString();
1:b550fb7:                         tm.setStringProperty("KEY", id);
1:b550fb7:                         ids.add(id);                            // keep track of the key to compare against consumer
1:b550fb7: 
1:b550fb7:                         mp.send(tm);
1:b550fb7:                         session.commit();
1:b550fb7:                     }
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                     e.printStackTrace();
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             // Called by waitForCompletion
1:b550fb7:             public void close() {
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7:                     mp.close();
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                 }
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7:                     session.close();
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                 }
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7:                     qc.close();
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7:     }
1:b550fb7: 
1:54e2e3b:     String messageText;
1:54e2e3b:     private String getMessageText() {
1:54e2e3b: 
1:54e2e3b:         if (messageText == null) {
1:54e2e3b: 
1:54e2e3b:             synchronized (this) {
1:54e2e3b: 
1:54e2e3b:                 if (messageText == null) {
1:b550fb7: 
1:54e2e3b:                     StringBuilder sb = new StringBuilder();
1:54e2e3b:                     for (int i = 0; i < messageSize; i++) {
1:54e2e3b:                         sb.append("X");
1:54e2e3b:                     }
1:54e2e3b:                     messageText = sb.toString();
1:54e2e3b:                 }
1:54e2e3b:             }
1:54e2e3b:         }
1:54e2e3b: 
1:54e2e3b:         return messageText;
1:54e2e3b:     }
1:54e2e3b: 
1:b550fb7:     public class ExportQueueConsumer {
1:54e2e3b: 
1:b550fb7:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:b550fb7:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:b550fb7:         private final int totalToExpect;
1:b550fb7:         private ActiveMQConnectionFactory connectionFactory = null;
1:b550fb7:         private String activemqURL = null;
1:b550fb7:         private String activemqQueues = null;
1:b550fb7:         private String[] queues = null;
1:b550fb7:         // Map of IDs that were consumed, keyed by queue name.
1:b550fb7:         // We'll compare these against what was published to know if any got stuck or dropped.
1:b550fb7:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
1:b550fb7:         private Map<String, List<ConsumerThread>> threads;
1:b550fb7: 
1:b550fb7:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
1:b550fb7: 
1:b550fb7:             this.activemqURL = activemqURL;
1:b550fb7:             this.activemqQueues = activemqQueues;
1:b550fb7:             this.totalToExpect = totalToExpect;
1:b550fb7: 
1:b550fb7:             queues = this.activemqQueues.split(",");
1:b550fb7: 
1:b550fb7:             for (int i = 0; i < queues.length; i++) {
1:b550fb7:                 queues[i] = queues[i].trim();
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             threads = new HashMap<String, List<ConsumerThread>>();
1:b550fb7: 
1:b550fb7:             // For each queue, create a list of threads and set up the list of ids
1:b550fb7:             for (String q : queues) {
1:b550fb7: 
1:b550fb7:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
1:b550fb7: 
1:b550fb7:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
1:b550fb7: 
1:b550fb7:                 for (int i = 0; i < threadsPerQueue; i++) {
1:b550fb7:                     list.add(new ConsumerThread(q, batchSize));
1:b550fb7:                 }
1:b550fb7: 
1:b550fb7:                 threads.put(q, list);
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         public Map<String, List<String>> getIDs() {
1:b550fb7:             return idsByQueue;
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         // Start the threads
1:b550fb7:         public void start() throws Exception {
1:b550fb7:             for (List<ConsumerThread> list : threads.values()) {
1:b550fb7:                 for (ConsumerThread ct : list) {
1:b550fb7:                     ct.start();
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         // Tell the threads to stop
1:b550fb7:         // Then wait for them to stop
1:b550fb7:         public void shutdown() throws Exception {
1:b550fb7:             for (List<ConsumerThread> list : threads.values()) {
1:b550fb7:                 for (ConsumerThread ct : list) {
1:b550fb7:                     ct.shutdown();
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             for (List<ConsumerThread> list : threads.values()) {
1:b550fb7:                 for (ConsumerThread ct : list) {
1:b550fb7:                     ct.join();
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:b550fb7:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:b550fb7:         }
1:b550fb7: 
1:54e2e3b:         private synchronized QueueConnection newQueueConnection() throws Exception {
1:b550fb7: 
1:b550fb7:             if (connectionFactory == null) {
1:b550fb7:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:b550fb7:             // after the queue has had a certain number of failures (default is 6)
1:b550fb7:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:b550fb7:             policy.setMaximumRedeliveries(-1);
1:b550fb7: 
1:b550fb7:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:b550fb7:             amqConnection.start();
1:b550fb7:             return amqConnection;
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         public boolean completed() {
1:b550fb7:             for (List<ConsumerThread> list : threads.values()) {
1:b550fb7: 
1:b550fb7:                 for (ConsumerThread ct : list) {
1:b550fb7: 
1:b550fb7:                     if (ct.isAlive()) {
1:b550fb7:                         LOG.info("thread for {} is still alive.", ct.qName);
1:b550fb7:                         return false;
1:b550fb7:                     }
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7:             return true;
1:b550fb7:         }
1:b550fb7: 
1:b550fb7:         private class ConsumerThread extends Thread {
1:b550fb7: 
1:b550fb7:             private int batchSize;
1:b550fb7:             private QueueConnection qc;
1:b550fb7:             private Session session;
1:b550fb7:             private MessageConsumer mc;
1:b550fb7:             private List<String> idList;
1:b550fb7:             private boolean shutdown = false;
1:b550fb7:             private String qName;
1:b550fb7: 
1:b550fb7:             private ConsumerThread(String queueName, int batchSize) throws Exception {
1:b550fb7: 
1:b550fb7:                 this.batchSize = batchSize;
1:b550fb7: 
1:b550fb7:                 // Each thread has its own connection and session
1:b550fb7:                 qName = queueName;
1:b550fb7:                 qc = newQueueConnection();
1:b550fb7:                 session = newSession(qc);
1:54e2e3b:                 Queue q = session.createQueue(queueName + "?consumer.prefetchSize=" + batchSize);
1:b550fb7:                 mc = session.createConsumer(q);
1:b550fb7: 
1:b550fb7:                 idList = idsByQueue.get(queueName);
1:b550fb7:             }
1:b550fb7: 
1:21c3ba3:             @Override
1:b550fb7:             public void run() {
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7: 
1:b550fb7:                     int count = 0;
1:b550fb7: 
1:b550fb7:                     // Keep reading as long as it hasn't been told to shutdown
1:b550fb7:                     while (!shutdown) {
1:b550fb7: 
1:b550fb7:                         if (idList.size() >= totalToExpect) {
1:b550fb7:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
1:54e2e3b:                             session.commit();
1:b550fb7:                             break;
1:b550fb7:                         }
1:b550fb7:                         Message m = mc.receive(4000);
1:b550fb7: 
1:b550fb7:                         if (m != null) {
1:b550fb7: 
1:b550fb7:                             // We received a non-null message, add the ID to our list
1:b550fb7: 
1:b550fb7:                             idList.add(m.getStringProperty("KEY"));
1:b550fb7: 
1:b550fb7:                             count++;
1:b550fb7: 
1:b550fb7:                             // If we've reached our batch size, commit the batch and reset the count
1:b550fb7: 
1:b550fb7:                             if (count == batchSize) {
1:b550fb7:                                 session.commit();
1:b550fb7:                                 count = 0;
1:b550fb7:                             }
1:54e2e3b:                         } else {
1:b550fb7: 
1:b550fb7:                             // We didn't receive anything this time, commit any current batch and reset the count
1:b550fb7: 
1:b550fb7:                             session.commit();
1:b550fb7:                             count = 0;
1:b550fb7: 
1:b550fb7:                             try {
1:54e2e3b:                                 if (idList.size() < totalToExpect) {
1:54e2e3b:                                     LOG.info("did not receive on {}, current count: {}", qName, idList.size());
1:54e2e3b:                                 }
1:b550fb7:                             } catch (Exception e) {
1:54e2e3b:                             }
1:b550fb7:                         }
1:b550fb7:                     }
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                     e.printStackTrace();
1:b550fb7:                 } finally {
1:b550fb7:                     // Once we exit, close everything
1:b550fb7:                     close();
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             public void shutdown() {
1:b550fb7:                 shutdown = true;
1:b550fb7:             }
1:b550fb7: 
1:b550fb7:             public void close() {
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7:                     mc.close();
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                 }
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7:                     session.close();
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                 }
1:b550fb7: 
1:b550fb7:                 try {
1:b550fb7:                     qc.close();
1:b550fb7:                 } catch (Exception e) {
1:b550fb7:                 }
1:b550fb7:             }
1:b550fb7:         }
1:b550fb7:     }
1:b550fb7: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:21c3ba3
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:  * Will kick of publisher and consumer simultaneously, and will usually result in
1:  * stuck messages on the queue.
1: 
1:     private String activemqURL;
1:     private BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         List<String> publishedIds = publisher.getIDs();
1:         distinctPublishedCount = new TreeSet<String>(publishedIds).size();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:gtully
-------------------------------------------------------------------------------
commit:3042797
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.TestSupport;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TestSupport.PersistenceAdapterChoice persistenceAdapterChoice = TestSupport.PersistenceAdapterChoice.KahaDB;
1:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},store:{5},optimizedDispatch:{6}")
1:                 {1,    1,   1,   50*1024,   false, TestSupport.PersistenceAdapterChoice.JDBC, true},
1:                 {1000, 20,  5,   50*1024,   true,  TestSupport.PersistenceAdapterChoice.JDBC, false},
1:                 {100,  20,  5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.JDBC, false},
1:                 {1000, 5,   20,  50*1024,   true,  TestSupport.PersistenceAdapterChoice.JDBC, false},
1:                 {1000, 20,  20,  1024*1024, true,  TestSupport.PersistenceAdapterChoice.JDBC, false},
1:                 {1,    1,   1,   50*1024,   false, TestSupport.PersistenceAdapterChoice.KahaDB, true},
1:                 {100,  5,   5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:                 {1000, 20,  5,   50*1024,   true,  TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:                 {100,  20,  5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:                 {1000, 5,   20,  50*1024,   true,  TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:                 {1000, 20,  20,  1024*1024, true,  TestSupport.PersistenceAdapterChoice.KahaDB, false},
1: 
1:                 {1,    1,   1,   50*1024,   false, TestSupport.PersistenceAdapterChoice.LevelDB, true},
1:                 {100,  5,   5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:                 {1000, 20,  5,   50*1024,   true,  TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:                 {100,  20,  5,   50*1024,   false, TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:                 {1000, 5,   20,  50*1024,   true,  TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:                 {1000, 20,  20,  1024*1024, true,  TestSupport.PersistenceAdapterChoice.LevelDB, false},
1: 
/////////////////////////////////////////////////////////////////////////
1:         TestSupport.setPersistenceAdapter(brokerService, persistenceAdapterChoice);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5861d86
/////////////////////////////////////////////////////////////////////////
1:     @Parameterized.Parameter(6)
1:     public boolean optimizeDispatch = false;
1: 
0:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},useDefaultStore:{5},optimizedDispatch:{6}")
0:                 {1,    1,   1,   50*1024,   false, false, true},
0:                 {1000, 20,  5,   50*1024,   true,  false, false},
0:                 {100,  20,  5,   50*1024,   false, false, false},
0:                 {1000, 5,   20,  50*1024,   true,  false, false},
0:                 {1000, 20,  20,  1024*1024, true,  false, false},
0:                 {1,    1,   1,   50*1024,   false, true, true},
0:                 {100,  5,   5,   50*1024,   false, true, false},
0:                 {1000, 20,  5,   50*1024,   true,  true, false},
0:                 {100,  20,  5,   50*1024,   false, true, false},
0:                 {1000, 5,   20,  50*1024,   true,  true, false},
0:                 {1000, 20,  20,  1024*1024, true,  true, false},
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setUseJmx(false);
/////////////////////////////////////////////////////////////////////////
1:         defaultEntry.setOptimizedDispatch(optimizeDispatch);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
/////////////////////////////////////////////////////////////////////////
1: @RunWith(Parameterized.class)
1:     public int messageSize = 1000;
1: 
1:     @Parameterized.Parameter(0)
1:     public int publisherMessagesPerThread = 1000;
1: 
1:     @Parameterized.Parameter(1)
1:     public int publisherThreadCount = 20;
1: 
1:     @Parameterized.Parameter(2)
1:     public int consumerThreadsPerQueue = 5;
1: 
1:     @Parameterized.Parameter(3)
1:     public int destMemoryLimit = 50 * 1024;
1: 
1:     @Parameterized.Parameter(4)
1:     public boolean useCache = true;
1: 
1:     @Parameterized.Parameter(5)
0:     public boolean useDefaultStore = false;
1: 
0:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},useDefaultStore:{5}")
1:     public static Iterable<Object[]> parameters() {
1:         return Arrays.asList(new Object[][]{
0:                 // jdbc
0:                 {1000, 20,  5,   50*1024,   true,  false},
0:                 {100,  20,  5,   50*1024,   false, false},
0:                 {1000, 5,   20,  50*1024,   true,  false},
0:                 {1000, 20,  20,  1024*1024, true,  false},
0:                 {1000, 100, 100, 1024*1024, true,  false},
1: 
0:                 // default store
0:                 {1000, 20,  5,   50*1024,   true,  true},
0:                 {100,  20,  5,   50*1024,   false, true},
0:                 {1000, 5,   20,  50*1024,   true,  true},
0:                 {1000, 20,  20,  1024*1024, true,  true},
0:                 {1000, 100, 100, 1024*1024, true,  true}
1:         });
1:     }
1: 
1:     public int consumerBatchSize = 5;
1: 
/////////////////////////////////////////////////////////////////////////
0:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
0:         jdbcPersistenceAdapter.setDataSource(dataSource);
0:         jdbcPersistenceAdapter.setUseLock(false);
1: 
0:         if (!useDefaultStore) {
0:             brokerService.setPersistenceAdapter(jdbcPersistenceAdapter);
1:         } else {
0:             KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter) brokerService.getPersistenceAdapter();
0:             kahaDBPersistenceAdapter.setConcurrentStoreAndDispatchQueues(true);
1:         }
1:         defaultEntry.setUseConsumerPriority(false); // java.lang.IllegalArgumentException: Comparison method violates its general contract!
1:         defaultEntry.setMaxAuditDepth(publisherThreadCount);
1:         defaultEntry.setEnableAudit(true);
1:         defaultEntry.setUseCache(useCache);
1:         defaultEntry.setMemoryLimit(destMemoryLimit);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         List publishedIds = publisher.getIDs();
0:         distinctPublishedCount = new TreeSet(publishedIds).size();
1:         LOG.info("Publisher Complete. Published: " + publishedIds.size() + ", Distinct IDs Published: " + distinctPublishedCount);
0:                 if (!useDefaultStore) {
0:                     DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:                 }
1:         LOG.info("\nConsumer Complete: " + consumer.completed() +", Shutting Down.");
0:         TimeUnit.SECONDS.sleep(2);
0:         LOG.info("DB Contents START");
0:         if (!useDefaultStore) {
0:             DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:         }
0:         LOG.info("DB Contents END");
1: 
/////////////////////////////////////////////////////////////////////////
1:         //private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:         private List<String> ids = Collections.synchronizedList(new ArrayList<String>());
/////////////////////////////////////////////////////////////////////////
1:         public List<String> getIDs() {
/////////////////////////////////////////////////////////////////////////
1:         private synchronized QueueConnection newQueueConnection() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                         TextMessage tm = session.createTextMessage(getMessageText());
/////////////////////////////////////////////////////////////////////////
1:     String messageText;
1:     private String getMessageText() {
1: 
1:         if (messageText == null) {
1: 
1:             synchronized (this) {
1: 
1:                 if (messageText == null) {
1: 
1:                     StringBuilder sb = new StringBuilder();
1:                     for (int i = 0; i < messageSize; i++) {
1:                         sb.append("X");
1:                     }
1:                     messageText = sb.toString();
1:                 }
1:             }
1:         }
1: 
1:         return messageText;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         private synchronized QueueConnection newQueueConnection() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                 Queue q = session.createQueue(queueName + "?consumer.prefetchSize=" + batchSize);
/////////////////////////////////////////////////////////////////////////
1:                             session.commit();
/////////////////////////////////////////////////////////////////////////
1:                                 if (idList.size() < totalToExpect) {
1:                                     LOG.info("did not receive on {}, current count: {}", qName, idList.size());
1:                                 }
commit:b550fb7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
1: 
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
0: import java.util.Set;
1: import java.util.TreeSet;
1: import java.util.UUID;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.QueueConnection;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.RedeliveryPolicy;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
0: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
0: import static org.junit.Assert.assertEquals;
1: 
1: /**
0:  * Stuck messages test client.
0:  * <p/>
0:  * Will kick of publisher and consumer simultaneously, and will usually result in stuck messages on the queue.
1:  */
1: public class AMQ5266Test {
1:     static Logger LOG = LoggerFactory.getLogger(AMQ5266Test.class);
0:     String activemqURL = "tcp://localhost:61617";
0:     BrokerService brokerService;
0:     private EmbeddedDataSource dataSource;
1: 
1:     @Before
1:     public void startBroker() throws Exception {
1:         brokerService = new BrokerService();
1: 
0:         dataSource = new EmbeddedDataSource();
0:         dataSource.setDatabaseName("target/derbyDb");
0:         dataSource.setCreateDatabase("create");
1: 
0:         JDBCPersistenceAdapter persistenceAdapter = new JDBCPersistenceAdapter();
0:         persistenceAdapter.setDataSource(dataSource);
0:         brokerService.setPersistenceAdapter(persistenceAdapter);
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1: 
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
0:         defaultEntry.setEnableAudit(false);
0:         defaultEntry.setUseCache(false);
1:         defaultEntry.setMaxPageSize(1000);
0:         defaultEntry.setOptimizedDispatch(false);
0:         defaultEntry.setMemoryLimit(1024 * 1024);
1:         defaultEntry.setExpireMessagesPeriod(0);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         brokerService.getSystemUsage().getMemoryUsage().setLimit(512 * 1024 * 1024);
1: 
1:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
1:         brokerService.start();
1:         activemqURL = transportConnector.getPublishableConnectString();
1:     }
1: 
1:     @After
1:     public void stopBroker() throws Exception {
1:         if (brokerService != null) {
1:             brokerService.stop();
1:         }
1:         try {
0:             dataSource.setShutdownDatabase("shutdown");
0:             dataSource.getConnection();
0:         } catch (Exception ignored) {}
1:     }
1: 
1:     @Test
1:     public void test() throws Exception {
1: 
1:         String activemqQueues = "activemq,activemq2";//,activemq3,activemq4,activemq5,activemq6,activemq7,activemq8,activemq9";
1: 
0:         int publisherMessagesPerThread = 1000;
0:         int publisherThreadCount = 5;
1: 
0:         int consumerThreadsPerQueue = 5;
0:         int consumerBatchSize = 25;
1:         int consumerWaitForConsumption = 5 * 60 * 1000;
1: 
1:         ExportQueuePublisher publisher = null;
1:         ExportQueueConsumer consumer = null;
1: 
1:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
1:         LOG.info("\nBuilding Publisher...");
1: 
1:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
1: 
1:         LOG.info("Building Consumer...");
1: 
1:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
1: 
1: 
1:         LOG.info("Starting Publisher...");
1: 
1:         publisher.start();
1: 
1:         LOG.info("Starting Consumer...");
1: 
1:         consumer.start();
1: 
1:         int distinctPublishedCount = 0;
1: 
1: 
1:         LOG.info("Waiting For Publisher Completion...");
1: 
1:         publisher.waitForCompletion();
1: 
0:         distinctPublishedCount = publisher.getIDs().size();
1: 
0:         LOG.info("Publisher Complete. Distinct IDs Published: " + distinctPublishedCount);
1: 
1: 
1:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
1: 
1: 
1:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
1:             try {
1:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
1:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
0:                 DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:                 Thread.sleep(10000);
1:             } catch (Exception e) {
1:             }
1:         }
1: 
0:         LOG.info("\nConsumer Complete. Shutting Down.");
1: 
1:         consumer.shutdown();
1: 
1:         LOG.info("Consumer Stats:");
1: 
1:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
1: 
1:             List<String> idList = entry.getValue();
1: 
1:             int distinctConsumed = new TreeSet<String>(idList).size();
1: 
1:             StringBuilder sb = new StringBuilder();
1:             sb.append("   Queue: " + entry.getKey() +
1:                     " -> Total Messages Consumed: " + idList.size() +
1:                     ", Distinct IDs Consumed: " + distinctConsumed);
1: 
1:             int diff = distinctPublishedCount - distinctConsumed;
1:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
1:             LOG.info(sb.toString());
1: 
1:             assertEquals("expect to get all messages!", 0, diff);
1: 
1:         }
1:     }
1: 
1:     public class ExportQueuePublisher {
1: 
1:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private String activemqURL = null;
1:         private String activemqQueues = null;
1:         // Collection of distinct IDs that the publisher has published.
1:         // After a message is published, its UUID will be written to this list for tracking.
1:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
0:         private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:         private List<PublisherThread> threads;
1: 
1:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
1: 
1:             this.activemqURL = activemqURL;
1:             this.activemqQueues = activemqQueues;
1: 
1:             threads = new ArrayList<PublisherThread>();
1: 
1:             // Build the threads and tell them how many messages to publish
1:             for (int i = 0; i < threadCount; i++) {
1:                 PublisherThread pt = new PublisherThread(messagesPerThread);
1:                 threads.add(pt);
1:             }
1:         }
1: 
0:         public Set<String> getIDs() {
1:             return ids;
1:         }
1: 
1:         // Kick off threads
1:         public void start() throws Exception {
1: 
1:             for (PublisherThread pt : threads) {
1:                 pt.start();
1:             }
1:         }
1: 
1:         // Wait for threads to complete. They will complete once they've published all of their messages.
1:         public void waitForCompletion() throws Exception {
1: 
1:             for (PublisherThread pt : threads) {
1:                 pt.join();
1:                 pt.close();
1:             }
1:         }
1: 
1:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:         }
1: 
0:         private QueueConnection newQueueConnection() throws Exception {
1: 
1:             if (connectionFactory == null) {
1:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:             }
1: 
1:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:             // after the queue has had a certain number of failures (default is 6)
1:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:             policy.setMaximumRedeliveries(-1);
1: 
1:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:             amqConnection.start();
1:             return amqConnection;
1:         }
1: 
1:         private class PublisherThread extends Thread {
1: 
1:             private int count;
1:             private QueueConnection qc;
1:             private Session session;
1:             private MessageProducer mp;
1: 
1:             private PublisherThread(int count) throws Exception {
1: 
1:                 this.count = count;
1: 
1:                 // Each Thread has its own Connection and Session, so no sync worries
1:                 qc = newQueueConnection();
1:                 session = newSession(qc);
1: 
1:                 // In our code, when publishing to multiple queues,
1:                 // we're using composite destinations like below
1:                 Queue q = new ActiveMQQueue(activemqQueues);
1:                 mp = session.createProducer(q);
1:             }
1: 
1:             public void run() {
1: 
1:                 try {
1: 
1:                     // Loop until we've published enough messages
1:                     while (count-- > 0) {
1: 
0:                         TextMessage tm = session.createTextMessage("test");
1:                         String id = UUID.randomUUID().toString();
1:                         tm.setStringProperty("KEY", id);
1:                         ids.add(id);                            // keep track of the key to compare against consumer
1: 
1:                         mp.send(tm);
1:                         session.commit();
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1: 
1:             // Called by waitForCompletion
1:             public void close() {
1: 
1:                 try {
1:                     mp.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     qc.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:     }
1: 
1:     public class ExportQueueConsumer {
1: 
1:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:         private final int totalToExpect;
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private String activemqURL = null;
1:         private String activemqQueues = null;
1:         private String[] queues = null;
1:         // Map of IDs that were consumed, keyed by queue name.
1:         // We'll compare these against what was published to know if any got stuck or dropped.
1:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
1:         private Map<String, List<ConsumerThread>> threads;
1: 
1:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
1: 
1:             this.activemqURL = activemqURL;
1:             this.activemqQueues = activemqQueues;
1:             this.totalToExpect = totalToExpect;
1: 
1:             queues = this.activemqQueues.split(",");
1: 
1:             for (int i = 0; i < queues.length; i++) {
1:                 queues[i] = queues[i].trim();
1:             }
1: 
1:             threads = new HashMap<String, List<ConsumerThread>>();
1: 
1:             // For each queue, create a list of threads and set up the list of ids
1:             for (String q : queues) {
1: 
1:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
1: 
1:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
1: 
1:                 for (int i = 0; i < threadsPerQueue; i++) {
1:                     list.add(new ConsumerThread(q, batchSize));
1:                 }
1: 
1:                 threads.put(q, list);
1:             }
1:         }
1: 
1:         public Map<String, List<String>> getIDs() {
1:             return idsByQueue;
1:         }
1: 
1:         // Start the threads
1:         public void start() throws Exception {
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.start();
1:                 }
1:             }
1:         }
1: 
1:         // Tell the threads to stop
1:         // Then wait for them to stop
1:         public void shutdown() throws Exception {
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.shutdown();
1:                 }
1:             }
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.join();
1:                 }
1:             }
1:         }
1: 
1:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:         }
1: 
0:         private QueueConnection newQueueConnection() throws Exception {
1: 
1:             if (connectionFactory == null) {
1:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:             }
1: 
1:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:             // after the queue has had a certain number of failures (default is 6)
1:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:             policy.setMaximumRedeliveries(-1);
1: 
1:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:             amqConnection.start();
1:             return amqConnection;
1:         }
1: 
1:         public boolean completed() {
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     if (ct.isAlive()) {
1:                         LOG.info("thread for {} is still alive.", ct.qName);
1:                         return false;
1:                     }
1:                 }
1:             }
1:             return true;
1:         }
1: 
1:         private class ConsumerThread extends Thread {
1: 
1:             private int batchSize;
1:             private QueueConnection qc;
1:             private Session session;
1:             private MessageConsumer mc;
1:             private List<String> idList;
1:             private boolean shutdown = false;
1:             private String qName;
1: 
1:             private ConsumerThread(String queueName, int batchSize) throws Exception {
1: 
1:                 this.batchSize = batchSize;
1: 
1:                 // Each thread has its own connection and session
1:                 qName = queueName;
1:                 qc = newQueueConnection();
1:                 session = newSession(qc);
0:                 Queue q = session.createQueue(queueName);
1:                 mc = session.createConsumer(q);
1: 
1:                 idList = idsByQueue.get(queueName);
1:             }
1: 
1:             public void run() {
1: 
1:                 try {
1: 
1:                     int count = 0;
1: 
1:                     // Keep reading as long as it hasn't been told to shutdown
1:                     while (!shutdown) {
1: 
1:                         if (idList.size() >= totalToExpect) {
1:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
1:                             break;
1:                         }
1:                         Message m = mc.receive(4000);
1: 
1:                         if (m != null) {
1: 
1:                             // We received a non-null message, add the ID to our list
1: 
1:                             idList.add(m.getStringProperty("KEY"));
1: 
1:                             count++;
1: 
1:                             // If we've reached our batch size, commit the batch and reset the count
1: 
1:                             if (count == batchSize) {
1:                                 session.commit();
1:                                 count = 0;
1:                             }
0:                         } else {
1: 
1:                             // We didn't receive anything this time, commit any current batch and reset the count
1: 
1:                             session.commit();
1:                             count = 0;
1: 
0:                             // Sleep a little before trying to read after not getting a message
1: 
1:                             try {
0:                                 LOG.info("did not receive on {}, current count: {}", qName, idList.size());
0:                                 //sleep(3000);
1:                             } catch (Exception e) {
1:                             }
1:                         }
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 } finally {
1: 
1:                     // Once we exit, close everything
1:                     close();
1:                 }
1:             }
1: 
1:             public void shutdown() {
1:                 shutdown = true;
1:             }
1: 
1:             public void close() {
1: 
1:                 try {
1:                     mc.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     qc.close();
1:                 } catch (Exception e) {
1: 
1:                 }
1:             }
1:         }
1:     }
1: }
commit:6348d11
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq.bugs;
0: 
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.TreeSet;
0: import java.util.UUID;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Queue;
0: import javax.jms.QueueConnection;
0: import javax.jms.Session;
0: import javax.jms.TextMessage;
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.RedeliveryPolicy;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
0: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
0: import org.junit.After;
0: import org.junit.Before;
0: import org.junit.Test;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: 
0: import static org.junit.Assert.assertEquals;
0: 
0: /**
0:  * Stuck messages test client.
0:  * <p/>
0:  * Will kick of publisher and consumer simultaneously, and will usually result in stuck messages on the queue.
0:  */
0: public class AMQ5266Test {
0:     static Logger LOG = LoggerFactory.getLogger(AMQ5266Test.class);
0:     String activemqURL = "tcp://localhost:61617";
0:     BrokerService brokerService;
0:     private EmbeddedDataSource dataSource;
0: 
0:     @Before
0:     public void startBroker() throws Exception {
0:         brokerService = new BrokerService();
0: 
0:         dataSource = new EmbeddedDataSource();
0:         dataSource.setDatabaseName("target/derbyDb");
0:         dataSource.setCreateDatabase("create");
0: 
0:         JDBCPersistenceAdapter persistenceAdapter = new JDBCPersistenceAdapter();
0:         persistenceAdapter.setDataSource(dataSource);
0:         brokerService.setPersistenceAdapter(persistenceAdapter);
0:         brokerService.setDeleteAllMessagesOnStartup(true);
0: 
0: 
0:         PolicyMap policyMap = new PolicyMap();
0:         PolicyEntry defaultEntry = new PolicyEntry();
0:         defaultEntry.setEnableAudit(false);
0:         defaultEntry.setUseCache(false);
0:         defaultEntry.setMaxPageSize(1000);
0:         defaultEntry.setOptimizedDispatch(false);
0:         defaultEntry.setMemoryLimit(1024 * 1024);
0:         defaultEntry.setExpireMessagesPeriod(0);
0:         policyMap.setDefaultEntry(defaultEntry);
0:         brokerService.setDestinationPolicy(policyMap);
0: 
0:         brokerService.getSystemUsage().getMemoryUsage().setLimit(512 * 1024 * 1024);
0: 
0:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
0:         brokerService.start();
0:         activemqURL = transportConnector.getPublishableConnectString();
0:     }
0: 
0:     @After
0:     public void stopBroker() throws Exception {
0:         if (brokerService != null) {
0:             brokerService.stop();
0:         }
0:         try {
0:             dataSource.setShutdownDatabase("shutdown");
0:             dataSource.getConnection();
0:         } catch (Exception ignored) {}
0:     }
0: 
0:     @Test
0:     public void test() throws Exception {
0: 
0:         String activemqQueues = "activemq,activemq2";//,activemq3,activemq4,activemq5,activemq6,activemq7,activemq8,activemq9";
0: 
0:         int publisherMessagesPerThread = 1000;
0:         int publisherThreadCount = 5;
0: 
0:         int consumerThreadsPerQueue = 5;
0:         int consumerBatchSize = 25;
0:         int consumerWaitForConsumption = 5 * 60 * 1000;
0: 
0:         ExportQueuePublisher publisher = null;
0:         ExportQueueConsumer consumer = null;
0: 
0:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
0:         LOG.info("\nBuilding Publisher...");
0: 
0:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
0: 
0:         LOG.info("Building Consumer...");
0: 
0:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
0: 
0: 
0:         LOG.info("Starting Publisher...");
0: 
0:         publisher.start();
0: 
0:         LOG.info("Starting Consumer...");
0: 
0:         consumer.start();
0: 
0:         int distinctPublishedCount = 0;
0: 
0: 
0:         LOG.info("Waiting For Publisher Completion...");
0: 
0:         publisher.waitForCompletion();
0: 
0:         distinctPublishedCount = publisher.getIDs().size();
0: 
0:         LOG.info("Publisher Complete. Distinct IDs Published: " + distinctPublishedCount);
0: 
0: 
0:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
0: 
0: 
0:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
0:             try {
0:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
0:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
0:                 DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
0:                 Thread.sleep(10000);
0:             } catch (Exception e) {
0:             }
0:         }
0: 
0:         LOG.info("\nConsumer Complete. Shutting Down.");
0: 
0:         consumer.shutdown();
0: 
0:         LOG.info("Consumer Stats:");
0: 
0:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
0: 
0:             List<String> idList = entry.getValue();
0: 
0:             int distinctConsumed = new TreeSet<String>(idList).size();
0: 
0:             StringBuilder sb = new StringBuilder();
0:             sb.append("   Queue: " + entry.getKey() +
0:                     " -> Total Messages Consumed: " + idList.size() +
0:                     ", Distinct IDs Consumed: " + distinctConsumed);
0: 
0:             int diff = distinctPublishedCount - distinctConsumed;
0:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
0:             LOG.info(sb.toString());
0: 
0:             assertEquals("expect to get all messages!", 0, diff);
0: 
0:         }
0:     }
0: 
0:     public class ExportQueuePublisher {
0: 
0:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
0:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
0:         private ActiveMQConnectionFactory connectionFactory = null;
0:         private String activemqURL = null;
0:         private String activemqQueues = null;
0:         // Collection of distinct IDs that the publisher has published.
0:         // After a message is published, its UUID will be written to this list for tracking.
0:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
0:         private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
0:         private List<PublisherThread> threads;
0: 
0:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
0: 
0:             this.activemqURL = activemqURL;
0:             this.activemqQueues = activemqQueues;
0: 
0:             threads = new ArrayList<PublisherThread>();
0: 
0:             // Build the threads and tell them how many messages to publish
0:             for (int i = 0; i < threadCount; i++) {
0:                 PublisherThread pt = new PublisherThread(messagesPerThread);
0:                 threads.add(pt);
0:             }
0:         }
0: 
0:         public Set<String> getIDs() {
0:             return ids;
0:         }
0: 
0:         // Kick off threads
0:         public void start() throws Exception {
0: 
0:             for (PublisherThread pt : threads) {
0:                 pt.start();
0:             }
0:         }
0: 
0:         // Wait for threads to complete. They will complete once they've published all of their messages.
0:         public void waitForCompletion() throws Exception {
0: 
0:             for (PublisherThread pt : threads) {
0:                 pt.join();
0:                 pt.close();
0:             }
0:         }
0: 
0:         private Session newSession(QueueConnection queueConnection) throws Exception {
0:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
0:         }
0: 
0:         private QueueConnection newQueueConnection() throws Exception {
0: 
0:             if (connectionFactory == null) {
0:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
0:             }
0: 
0:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
0:             // after the queue has had a certain number of failures (default is 6)
0:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
0:             policy.setMaximumRedeliveries(-1);
0: 
0:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
0:             amqConnection.start();
0:             return amqConnection;
0:         }
0: 
0:         private class PublisherThread extends Thread {
0: 
0:             private int count;
0:             private QueueConnection qc;
0:             private Session session;
0:             private MessageProducer mp;
0: 
0:             private PublisherThread(int count) throws Exception {
0: 
0:                 this.count = count;
0: 
0:                 // Each Thread has its own Connection and Session, so no sync worries
0:                 qc = newQueueConnection();
0:                 session = newSession(qc);
0: 
0:                 // In our code, when publishing to multiple queues,
0:                 // we're using composite destinations like below
0:                 Queue q = new ActiveMQQueue(activemqQueues);
0:                 mp = session.createProducer(q);
0:             }
0: 
0:             public void run() {
0: 
0:                 try {
0: 
0:                     // Loop until we've published enough messages
0:                     while (count-- > 0) {
0: 
0:                         TextMessage tm = session.createTextMessage("test");
0:                         String id = UUID.randomUUID().toString();
0:                         tm.setStringProperty("KEY", id);
0:                         ids.add(id);                            // keep track of the key to compare against consumer
0: 
0:                         mp.send(tm);
0:                         session.commit();
0:                     }
0:                 } catch (Exception e) {
0:                     e.printStackTrace();
0:                 }
0:             }
0: 
0:             // Called by waitForCompletion
0:             public void close() {
0: 
0:                 try {
0:                     mp.close();
0:                 } catch (Exception e) {
0:                 }
0: 
0:                 try {
0:                     session.close();
0:                 } catch (Exception e) {
0:                 }
0: 
0:                 try {
0:                     qc.close();
0:                 } catch (Exception e) {
0:                 }
0:             }
0:         }
0: 
0:     }
0: 
0:     public class ExportQueueConsumer {
0: 
0:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
0:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
0:         private final int totalToExpect;
0:         private ActiveMQConnectionFactory connectionFactory = null;
0:         private String activemqURL = null;
0:         private String activemqQueues = null;
0:         private String[] queues = null;
0:         // Map of IDs that were consumed, keyed by queue name.
0:         // We'll compare these against what was published to know if any got stuck or dropped.
0:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
0:         private Map<String, List<ConsumerThread>> threads;
0: 
0:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
0: 
0:             this.activemqURL = activemqURL;
0:             this.activemqQueues = activemqQueues;
0:             this.totalToExpect = totalToExpect;
0: 
0:             queues = this.activemqQueues.split(",");
0: 
0:             for (int i = 0; i < queues.length; i++) {
0:                 queues[i] = queues[i].trim();
0:             }
0: 
0:             threads = new HashMap<String, List<ConsumerThread>>();
0: 
0:             // For each queue, create a list of threads and set up the list of ids
0:             for (String q : queues) {
0: 
0:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
0: 
0:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
0: 
0:                 for (int i = 0; i < threadsPerQueue; i++) {
0:                     list.add(new ConsumerThread(q, batchSize));
0:                 }
0: 
0:                 threads.put(q, list);
0:             }
0:         }
0: 
0:         public Map<String, List<String>> getIDs() {
0:             return idsByQueue;
0:         }
0: 
0:         // Start the threads
0:         public void start() throws Exception {
0: 
0:             for (List<ConsumerThread> list : threads.values()) {
0: 
0:                 for (ConsumerThread ct : list) {
0: 
0:                     ct.start();
0:                 }
0:             }
0:         }
0: 
0:         // Tell the threads to stop
0:         // Then wait for them to stop
0:         public void shutdown() throws Exception {
0: 
0:             for (List<ConsumerThread> list : threads.values()) {
0: 
0:                 for (ConsumerThread ct : list) {
0: 
0:                     ct.shutdown();
0:                 }
0:             }
0: 
0:             for (List<ConsumerThread> list : threads.values()) {
0: 
0:                 for (ConsumerThread ct : list) {
0: 
0:                     ct.join();
0:                 }
0:             }
0:         }
0: 
0:         private Session newSession(QueueConnection queueConnection) throws Exception {
0:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
0:         }
0: 
0:         private QueueConnection newQueueConnection() throws Exception {
0: 
0:             if (connectionFactory == null) {
0:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
0:             }
0: 
0:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
0:             // after the queue has had a certain number of failures (default is 6)
0:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
0:             policy.setMaximumRedeliveries(-1);
0: 
0:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
0:             amqConnection.start();
0:             return amqConnection;
0:         }
0: 
0:         public boolean completed() {
0:             for (List<ConsumerThread> list : threads.values()) {
0: 
0:                 for (ConsumerThread ct : list) {
0: 
0:                     if (ct.isAlive()) {
0:                         LOG.info("thread for {} is still alive.", ct.qName);
0:                         return false;
0:                     }
0:                 }
0:             }
0:             return true;
0:         }
0: 
0:         private class ConsumerThread extends Thread {
0: 
0:             private int batchSize;
0:             private QueueConnection qc;
0:             private Session session;
0:             private MessageConsumer mc;
0:             private List<String> idList;
0:             private boolean shutdown = false;
0:             private String qName;
0: 
0:             private ConsumerThread(String queueName, int batchSize) throws Exception {
0: 
0:                 this.batchSize = batchSize;
0: 
0:                 // Each thread has its own connection and session
0:                 qName = queueName;
0:                 qc = newQueueConnection();
0:                 session = newSession(qc);
0:                 Queue q = session.createQueue(queueName);
0:                 mc = session.createConsumer(q);
0: 
0:                 idList = idsByQueue.get(queueName);
0:             }
0: 
0:             public void run() {
0: 
0:                 try {
0: 
0:                     int count = 0;
0: 
0:                     // Keep reading as long as it hasn't been told to shutdown
0:                     while (!shutdown) {
0: 
0:                         if (idList.size() >= totalToExpect) {
0:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
0:                             break;
0:                         }
0:                         Message m = mc.receive(4000);
0: 
0:                         if (m != null) {
0: 
0:                             // We received a non-null message, add the ID to our list
0: 
0:                             idList.add(m.getStringProperty("KEY"));
0: 
0:                             count++;
0: 
0:                             // If we've reached our batch size, commit the batch and reset the count
0: 
0:                             if (count == batchSize) {
0:                                 session.commit();
0:                                 count = 0;
0:                             }
0:                         } else {
0: 
0:                             // We didn't receive anything this time, commit any current batch and reset the count
0: 
0:                             session.commit();
0:                             count = 0;
0: 
0:                             // Sleep a little before trying to read after not getting a message
0: 
0:                             try {
0:                                 LOG.info("did not receive on {}, current count: {}", qName, idList.size());
0:                                 //sleep(3000);
0:                             } catch (Exception e) {
0:                             }
0:                         }
0:                     }
0:                 } catch (Exception e) {
0:                     e.printStackTrace();
0:                 } finally {
0: 
0:                     // Once we exit, close everything
0:                     close();
0:                 }
0:             }
0: 
0:             public void shutdown() {
0:                 shutdown = true;
0:             }
0: 
0:             public void close() {
0: 
0:                 try {
0:                     mc.close();
0:                 } catch (Exception e) {
0:                 }
0: 
0:                 try {
0:                     session.close();
0:                 } catch (Exception e) {
0:                 }
0: 
0:                 try {
0:                     qc.close();
0:                 } catch (Exception e) {
0: 
0:                 }
0:             }
0:         }
0:     }
0: }
============================================================================