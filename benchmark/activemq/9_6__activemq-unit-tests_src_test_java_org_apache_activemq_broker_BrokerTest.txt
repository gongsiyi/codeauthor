1:3965f2c: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:3965f2c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
4:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:3965f2c:  */
1:d29ca2a: package org.apache.activemq.broker;
1:230a86c: 
1:3a7c673: import java.util.ArrayList;
1:933eb2f: import java.util.List;
1:3a7c673: import java.util.concurrent.TimeUnit;
1:230a86c: 
1:d29ca2a: import javax.jms.DeliveryMode;
1:3a7c673: 
1:d29ca2a: import junit.framework.Test;
1:3965f2c: 
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQQueue;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTopic;
1:d29ca2a: import org.apache.activemq.command.ConnectionInfo;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.LocalTransactionId;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.ProducerInfo;
1:eb6c082: import org.apache.activemq.command.RemoveInfo;
1:d29ca2a: import org.apache.activemq.command.SessionInfo;
1:3965f2c: 
1:d29ca2a: public class BrokerTest extends BrokerTestSupport {
1:230a86c: 
1:d29ca2a:     public ActiveMQDestination destination;
1:d29ca2a:     public int deliveryMode;
1:d29ca2a:     public int prefetch;
1:d29ca2a:     public byte destinationType;
1:d29ca2a:     public boolean durableConsumer;
1:7882eb7:     protected static final int MAX_NULL_WAIT=500;
1:230a86c: 
1:230a86c:     public void initCombosForTestQueueOnlyOnceDeliveryWith2Consumers() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:     }
1:230a86c: 
1:3a7c673:     public void testQueueOnlyOnceDeliveryWith2Consumers() throws Exception {
1:230a86c: 
1:3a7c673:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:230a86c: 
1:3a7c673:         // Setup a first connection
1:3a7c673:         StubConnection connection1 = createConnection();
1:3a7c673:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:3a7c673:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:3a7c673:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:3a7c673:         connection1.send(connectionInfo1);
1:3a7c673:         connection1.send(sessionInfo1);
1:3a7c673:         connection1.send(producerInfo);
1:230a86c: 
1:3a7c673:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:3a7c673:         consumerInfo1.setPrefetchSize(1);
1:d29ca2a:         connection1.request(consumerInfo1);
1:3a7c673: 
1:230a86c:         // Setup a second connection
1:3a7c673:         StubConnection connection2 = createConnection();
1:3a7c673:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:3a7c673:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:3a7c673:         consumerInfo2.setPrefetchSize(1);
1:3a7c673:         connection2.send(connectionInfo2);
1:3a7c673:         connection2.send(sessionInfo2);
1:7882eb7:         connection2.request(consumerInfo2);
1:230a86c: 
1:3a7c673:         // Send the messages
1:3a7c673:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:3a7c673:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:3a7c673:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:7882eb7:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:230a86c: 
1:230a86c:         for (int i = 0; i < 2; i++) {
1:3a7c673:             Message m1 = receiveMessage(connection1);
1:3a7c673:             Message m2 = receiveMessage(connection2);
1:230a86c: 
1:230a86c:             assertNotNull("m1 is null for index: " + i, m1);
1:230a86c:             assertNotNull("m2 is null for index: " + i, m2);
1:230a86c: 
1:3a7c673:             assertNotSame(m1.getMessageId(), m2.getMessageId());
4:d29ca2a:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:3a7c673:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.STANDARD_ACK_TYPE));
1:3a7c673:         }
1:7f5e666: 
7:d29ca2a:         assertNoMessagesLeft(connection1);
4:d29ca2a:         assertNoMessagesLeft(connection2);
1:3965f2c:     }
1:b4e35fe: 
1:230a57b:     public void initCombosForTestQueueBrowserWith2Consumers() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
42:d29ca2a:     }
1:9216c18: 
1:230a57b:     public void testQueueBrowserWith2Consumers() throws Exception {
1:230a86c: 
1:3965f2c:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:230a86c: 
1:3965f2c:         // Setup a first connection
1:3965f2c:         StubConnection connection1 = createConnection();
1:3965f2c:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:3965f2c:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:3965f2c:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:3965f2c:         connection1.send(connectionInfo1);
1:3965f2c:         connection1.send(sessionInfo1);
1:3965f2c:         connection1.send(producerInfo);
1:230a86c: 
1:3965f2c:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:3965f2c:         consumerInfo1.setPrefetchSize(10);
1:3965f2c:         connection1.request(consumerInfo1);
1:230a86c: 
1:3965f2c:         // Send the messages
1:3a7c673:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:3965f2c:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:3965f2c:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:7882eb7:         //as the messages are sent async - need to synchronize the last
1:7882eb7:         //one to ensure they arrive in the order we want
1:9216c18:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:3a7c673: 
1:3965f2c:         // Setup a second connection with a queue browser.
1:3965f2c:         StubConnection connection2 = createConnection();
1:3965f2c:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:3965f2c:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:3965f2c:         consumerInfo2.setPrefetchSize(1);
1:3965f2c:         consumerInfo2.setBrowser(true);
1:3965f2c:         connection2.send(connectionInfo2);
1:3965f2c:         connection2.send(sessionInfo2);
1:3965f2c:         connection2.request(consumerInfo2);
1:9216c18: 
1:933eb2f:         List<Message> messages = new ArrayList<Message>();
1:3a7c673: 
1:230a86c:         for (int i = 0; i < 4; i++) {
1:3965f2c:             Message m1 = receiveMessage(connection1);
1:230a86c:             assertNotNull("m1 is null for index: " + i, m1);
1:3965f2c:             messages.add(m1);
1:3965f2c:         }
1:230a86c: 
1:915333e:         for (int i = 0; i < 4; i++) {
1:933eb2f:             Message m1 = messages.get(i);
1:3965f2c:             Message m2 = receiveMessage(connection2);
1:230a86c:             assertNotNull("m2 is null for index: " + i, m2);
1:3965f2c:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:3965f2c:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:3965f2c:         }
1:230a86c: 
1:3965f2c:         assertNoMessagesLeft(connection1);
1:3965f2c:         assertNoMessagesLeft(connection2);
1:3965f2c:     }
1:230a86c: 
1:230a86c:     
1:9216c18:     /*
1:9216c18:      * change the order of the above test
1:9216c18:      */
1:9216c18:     public void testQueueBrowserWith2ConsumersBrowseFirst() throws Exception {
1:9216c18: 
1:9216c18:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:9216c18:         deliveryMode = DeliveryMode.NON_PERSISTENT;
1:9216c18:         
1:9216c18:         
1:9216c18:         // Setup a second connection with a queue browser.
1:9216c18:         StubConnection connection2 = createConnection();
1:9216c18:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:9216c18:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:9216c18:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:9216c18:         consumerInfo2.setPrefetchSize(10);
1:9216c18:         consumerInfo2.setBrowser(true);
1:9216c18:         connection2.send(connectionInfo2);
1:9216c18:         connection2.send(sessionInfo2);
1:9216c18:         connection2.request(consumerInfo2);
1:9216c18: 
1:9216c18:         // Setup a first connection
1:9216c18:         StubConnection connection1 = createConnection();
1:9216c18:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:9216c18:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:9216c18:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:9216c18:         connection1.send(connectionInfo1);
1:9216c18:         connection1.send(sessionInfo1);
1:9216c18:         connection1.send(producerInfo);
1:9216c18: 
1:9216c18:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:9216c18:         consumerInfo1.setPrefetchSize(10);
1:9216c18:         connection1.request(consumerInfo1);
1:9216c18: 
1:9216c18:         // Send the messages
1:9216c18:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:9216c18:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:9216c18:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:9216c18:         //as the messages are sent async - need to synchronize the last
1:9216c18:         //one to ensure they arrive in the order we want
1:9216c18:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:9216c18: 
1:9216c18: 
1:9216c18:         List<Message> messages = new ArrayList<Message>();
1:9216c18: 
1:9216c18:         for (int i = 0; i < 4; i++) {
1:9216c18:             Message m1 = receiveMessage(connection1);
1:9216c18:             assertNotNull("m1 is null for index: " + i, m1);
1:9216c18:             messages.add(m1);
1:9216c18:         }
1:9216c18: 
1:9216c18:         // no messages present in queue browser as there were no messages when it
1:9216c18:         // was created
1:9216c18:         assertNoMessagesLeft(connection1);
1:9216c18:         assertNoMessagesLeft(connection2);
1:9216c18:     }
1:9216c18: 
1:9216c18:     public void testQueueBrowserWith2ConsumersInterleaved() throws Exception {
1:9216c18: 
1:9216c18:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:9216c18:         deliveryMode = DeliveryMode.NON_PERSISTENT;
1:9216c18:         
1:9216c18:         // Setup a first connection
1:9216c18:         StubConnection connection1 = createConnection();
1:9216c18:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:9216c18:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:9216c18:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:9216c18:         connection1.send(connectionInfo1);
1:9216c18:         connection1.send(sessionInfo1);
1:9216c18:         connection1.send(producerInfo);
1:9216c18: 
1:9216c18:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:9216c18:         consumerInfo1.setPrefetchSize(10);
1:9216c18:         connection1.request(consumerInfo1);
1:9216c18: 
1:9216c18:         // Send the messages
1:9216c18:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:9216c18:         
1:9216c18:         // Setup a second connection with a queue browser.
1:9216c18:         StubConnection connection2 = createConnection();
1:9216c18:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:9216c18:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:9216c18:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:9216c18:         consumerInfo2.setPrefetchSize(1);
1:9216c18:         consumerInfo2.setBrowser(true);
1:9216c18:         connection2.send(connectionInfo2);
1:9216c18:         connection2.send(sessionInfo2);
1:9216c18:         connection2.request(consumerInfo2);
1:9216c18: 
1:9216c18:         
1:9216c18:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:9216c18:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:9216c18:         //as the messages are sent async - need to synchronize the last
1:9216c18:         //one to ensure they arrive in the order we want
1:7882eb7:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:9216c18: 
1:9216c18:         
1:9216c18:         List<Message> messages = new ArrayList<Message>();
1:9216c18: 
1:9216c18:         for (int i = 0; i < 4; i++) {
1:9216c18:             Message m1 = receiveMessage(connection1);
1:9216c18:             assertNotNull("m1 is null for index: " + i, m1);
1:9216c18:             messages.add(m1);
1:9216c18:         }
1:230a86c: 
1:b4e35fe:         // a browse is a snapshot - only guarantee to see messages produced before
1:b4e35fe:         // the browser
1:b4e35fe:         for (int i = 0; i < 1; i++) {
1:9216c18:             Message m1 = messages.get(i);
1:9216c18:             Message m2 = receiveMessage(connection2);
1:9216c18:             assertNotNull("m2 is null for index: " + i, m2);
1:9216c18:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:9216c18:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:9216c18:         }
1:9216c18: 
1:9216c18:         assertNoMessagesLeft(connection1);
1:9216c18: 
1:b4e35fe:         connection1.request(closeConnectionInfo(connectionInfo1));
1:b4e35fe:         connection1.stop();
1:b4e35fe:         connection2.request(closeConnectionInfo(connectionInfo2));
1:b4e35fe:         connection2.stop();
1:9216c18:     }
1:9216c18: 
1:3a7c673:     
1:230a86c:     public void initCombosForTestConsumerPrefetchAndStandardAck() {
1:230a86c:         addCombinationValues("deliveryMode", new Object[] {
1:230a86c:         // Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                              Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testConsumerPrefetchAndStandardAck() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
2:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:230a86c: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:230a86c: 
1:230a86c:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setPrefetchSize(1);
2:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:d29ca2a:         // Send 3 messages to the broker.
3:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:7882eb7:         connection.request(createMessage(producerInfo, destination, deliveryMode));
1:230a86c: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         Message m1 = receiveMessage(connection);
5:d29ca2a:         assertNotNull(m1);
1:d29ca2a:         assertNoMessagesLeft(connection);
1:230a86c: 
1:230a86c:         // Acknowledge the first message. This should cause the next message to
1:230a86c:         // get dispatched.
1:d29ca2a:         connection.send(createAck(consumerInfo, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:d29ca2a:         Message m2 = receiveMessage(connection);
1:230a86c:         assertNotNull(m2);
1:d29ca2a:         connection.send(createAck(consumerInfo, m2, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:d29ca2a:         Message m3 = receiveMessage(connection);
1:230a86c:         assertNotNull(m3);
1:d29ca2a:         connection.send(createAck(consumerInfo, m3, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:d29ca2a:         connection.send(closeConnectionInfo(connectionInfo));
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestTransactedAckWithPrefetchOfOne() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testTransactedAckWithPrefetchOfOne() throws Exception {
1:230a86c: 
7:d29ca2a:         // Setup a first connection
7:d29ca2a:         StubConnection connection1 = createConnection();
7:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
7:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
4:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
7:d29ca2a:         connection1.send(connectionInfo1);
7:d29ca2a:         connection1.send(sessionInfo1);
4:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
2:d29ca2a:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1:230a86c: 
5:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
3:d29ca2a:         consumerInfo1.setPrefetchSize(1);
1:3a7c673:         connection1.send(consumerInfo1);
1:230a86c: 
4:d29ca2a:         // Send the messages
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo1, destination, deliveryMode);
2:d29ca2a:             connection1.send(message);
1:d29ca2a:         }
1:230a86c: 
1:230a86c:        
1:230a86c: 
1:d29ca2a:         // Now get the messages.
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             // Begin the transaction.
1:d29ca2a:             LocalTransactionId txid = createLocalTransaction(sessionInfo1);
1:d29ca2a:             connection1.send(createBeginTransaction(connectionInfo1, txid));
5:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:             MessageAck ack = createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE);
1:d29ca2a:             ack.setTransactionId(txid);
1:d29ca2a:             connection1.send(ack);
1:d29ca2a:          // Commit the transaction.
1:d29ca2a:             connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
1:230a86c:         }
1:230a86c:         assertNoMessagesLeft(connection1);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestTransactedSend() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testTransactedSend() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
1:d29ca2a:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1:230a86c: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
2:d29ca2a:         consumerInfo1.setPrefetchSize(100);
6:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         // Begin the transaction.
1:d29ca2a:         LocalTransactionId txid = createLocalTransaction(sessionInfo1);
1:d29ca2a:         connection1.send(createBeginTransaction(connectionInfo1, txid));
1:230a86c: 
1:d29ca2a:         // Send the messages
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo1, destination, deliveryMode);
1:d29ca2a:             message.setTransactionId(txid);
1:7882eb7:             connection1.request(message);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // The point of this test is that message should not be delivered until
1:d29ca2a:         // send is committed.
1:7882eb7:         assertNull(receiveMessage(connection1,MAX_NULL_WAIT));
1:230a86c: 
1:d29ca2a:         // Commit the transaction.
1:d29ca2a:         connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
1:230a86c: 
1:d29ca2a:         // Now get the messages.
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection1);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestQueueTransactedAck() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testQueueTransactedAck() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
1:d29ca2a:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1:230a86c: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         // Send the messages
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo1, destination, deliveryMode);
1:d29ca2a:             connection1.send(message);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Begin the transaction.
1:d29ca2a:         LocalTransactionId txid = createLocalTransaction(sessionInfo1);
1:d29ca2a:         connection1.send(createBeginTransaction(connectionInfo1, txid));
1:230a86c: 
1:d29ca2a:         // Acknowledge the first 2 messages.
1:230a86c:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:230a86c:             assertNotNull("m1 is null for index: " + i, m1);
1:d29ca2a:             MessageAck ack = createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE);
1:d29ca2a:             ack.setTransactionId(txid);
1:d29ca2a:             connection1.request(ack);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Commit the transaction.
1:d29ca2a:         connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
1:230a86c: 
1:d29ca2a:         // The queue should now only have the remaining 2 messages
1:230a86c:         assertEquals(2, countMessagesInQueue(connection1, connectionInfo1, destination));
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testTopicDurableSubscriptionCanBeRestored() throws Exception {
1:230a86c: 
1:d29ca2a:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         connectionInfo1.setClientId("clientid1");
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:333158a:         consumerInfo1.setSubscriptionName("test");
1:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         // Send the messages
2:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:7882eb7:         connection1.request(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:230a86c: 
1:d29ca2a:         // Get the messages
1:230a86c:         Message m = null;
1:230a86c:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             m = receiveMessage(connection1);
3:d29ca2a:             assertNotNull(m);
1:d29ca2a:         }
1:d29ca2a:         // Ack the last message.
1:d29ca2a:         connection1.send(createAck(consumerInfo1, m, 2, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         // Close the connection.
1:d29ca2a:         connection1.request(closeConnectionInfo(connectionInfo1));
1:d29ca2a:         connection1.stop();
1:230a86c: 
1:230a86c:         // Setup a second connection
5:d29ca2a:         StubConnection connection2 = createConnection();
5:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:d29ca2a:         connectionInfo2.setClientId("clientid1");
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
4:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
2:d29ca2a:         consumerInfo2.setPrefetchSize(100);
1:333158a:         consumerInfo2.setSubscriptionName("test");
1:230a86c: 
5:d29ca2a:         connection2.send(connectionInfo2);
5:d29ca2a:         connection2.send(sessionInfo2);
1:3a7c673:         connection2.send(consumerInfo2);
1:230a86c: 
1:d29ca2a:         // Get the rest of the messages
1:230a86c:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection2);
1:230a86c:             assertNotNull("m1 is null for index: " + i, m1);
1:230a86c:         }
1:9216c18:         assertNoMessagesLeft(connection2);
1:3a7c673:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestGroupedMessagesDeliveredToOnlyOneConsumer() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:3a7c673:     }
1:230a86c: 
1:7f5213b:     public void testGroupedMessagesDeliveredToOnlyOneConsumer() throws Exception {
1:230a86c: 
3:d29ca2a:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
3:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
3:d29ca2a:         connection1.send(producerInfo);
1:230a86c: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(1);
1:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         // Send the messages.
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo, destination, deliveryMode);
1:d29ca2a:             message.setGroupID("TEST-GROUP");
1:230a86c:             message.setGroupSequence(i + 1);
1:d29ca2a:             connection1.request(message);
1:d29ca2a:         }
1:230a86c: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:230a86c: 
1:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
3:d29ca2a:         consumerInfo2.setPrefetchSize(1);
5:d29ca2a:         connection2.send(consumerInfo2);
1:230a86c: 
1:230a86c:         // All the messages should have been sent down connection 1.. just get
1:230a86c:         // the first 3
1:230a86c:         for (int i = 0; i < 3; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:230a86c:             assertNotNull("m1 is null for index: " + i, m1);
1:3a7c673:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Close the first consumer.
1:7882eb7:         connection1.request(closeConsumerInfo(consumerInfo1));
1:230a86c: 
1:230a86c:         // The last messages should now go the the second consumer.
1:9216c18:         for (int i = 0; i < 1; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection2);
1:230a86c:             assertNotNull("m1 is null for index: " + i, m1);
1:7882eb7:             connection2.request(createAck(consumerInfo2, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:3a7c673:         assertNoMessagesLeft(connection2);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestTopicConsumerOnlySeeMessagesAfterCreation() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:         addCombinationValues("durableConsumer", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testTopicConsumerOnlySeeMessagesAfterCreation() throws Exception {
1:230a86c: 
1:d29ca2a:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         connectionInfo1.setClientId("A");
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
1:d29ca2a:         // Send the 1st message
6:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:230a86c: 
1:d29ca2a:         // Create the durable subscription.
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:230a86c:         if (durableConsumer) {
1:333158a:             consumerInfo1.setSubscriptionName("test");
1:d29ca2a:         }
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         Message m = createMessage(producerInfo1, destination, deliveryMode);
1:d29ca2a:         connection1.send(m);
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:230a86c: 
1:d29ca2a:         // Subscription should skip over the first message
3:d29ca2a:         Message m2 = receiveMessage(connection1);
4:d29ca2a:         assertNotNull(m2);
2:d29ca2a:         assertEquals(m.getMessageId(), m2.getMessageId());
2:d29ca2a:         m2 = receiveMessage(connection1);
1:d29ca2a:         assertNotNull(m2);
1:230a86c: 
1:3a7c673:         assertNoMessagesLeft(connection1);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestTopicRetroactiveConsumerSeeMessagesBeforeCreation() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:         addCombinationValues("durableConsumer", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testTopicRetroactiveConsumerSeeMessagesBeforeCreation() throws Exception {
1:230a86c: 
1:d29ca2a:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         connectionInfo1.setClientId("A");
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         Message m = createMessage(producerInfo1, destination, deliveryMode);
1:d29ca2a:         connection1.send(m);
1:230a86c: 
1:d29ca2a:         // Create the durable subscription.
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:230a86c:         if (durableConsumer) {
1:333158a:             consumerInfo1.setSubscriptionName("test");
1:d29ca2a:         }
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         consumerInfo1.setRetroactive(true);
1:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.request(createMessage(producerInfo1, destination, deliveryMode));
1:230a86c: 
1:04968b6:         // the behavior is VERY dependent on the recovery policy used.
1:230a86c:         // But the default broker settings try to make it as consistent as
1:230a86c:         // possible
1:230a86c: 
1:04968b6:         // Subscription should see all messages sent.
1:04968b6:         Message m2 = receiveMessage(connection1);
1:04968b6:         assertNotNull(m2);
1:04968b6:         assertEquals(m.getMessageId(), m2.getMessageId());
1:230a86c:         for (int i = 0; i < 2; i++) {
1:04968b6:             m2 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m2);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection1);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     //
1:230a86c:     // TODO: need to reimplement this since we don't fail when we send to a
1:230a86c:     // non-existant
1:230a86c:     // destination. But if we can access the Region directly then we should be
1:230a86c:     // able to
1:230a86c:     // check that if the destination was removed.
1:230a86c:     // 
1:230a86c:     // public void initCombosForTestTempDestinationsRemovedOnConnectionClose() {
1:230a86c:     // addCombinationValues( "deliveryMode", new Object[]{
1:230a86c:     // Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:230a86c:     // Integer.valueOf(DeliveryMode.PERSISTENT)} );
1:230a86c:     // addCombinationValues( "destinationType", new Object[]{
1:230a86c:     // Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:230a86c:     // Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:230a86c:     // }
1:230a86c:     //    
1:230a86c:     // public void testTempDestinationsRemovedOnConnectionClose() throws
1:230a86c:     // Exception {
1:230a86c:     //        
1:230a86c:     // // Setup a first connection
1:230a86c:     // StubConnection connection1 = createConnection();
1:230a86c:     // ConnectionInfo connectionInfo1 = createConnectionInfo();
1:230a86c:     // SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:230a86c:     // ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:230a86c:     // connection1.send(connectionInfo1);
1:230a86c:     // connection1.send(sessionInfo1);
1:230a86c:     // connection1.send(producerInfo1);
1:230a86c:     //
1:230a86c:     // destination = createDestinationInfo(connection1, connectionInfo1,
1:230a86c:     // destinationType);
1:230a86c:     //        
1:230a86c:     // StubConnection connection2 = createConnection();
1:230a86c:     // ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:     // SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:230a86c:     // ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:230a86c:     // connection2.send(connectionInfo2);
1:230a86c:     // connection2.send(sessionInfo2);
1:230a86c:     // connection2.send(producerInfo2);
1:230a86c:     //
1:230a86c:     // // Send from connection2 to connection1's temp destination. Should
1:230a86c:     // succeed.
1:230a86c:     // connection2.send(createMessage(producerInfo2, destination,
1:230a86c:     // deliveryMode));
1:230a86c:     //        
1:230a86c:     // // Close connection 1
1:230a86c:     // connection1.request(closeConnectionInfo(connectionInfo1));
1:230a86c:     //        
1:230a86c:     // try {
1:230a86c:     // // Send from connection2 to connection1's temp destination. Should not
1:230a86c:     // succeed.
1:230a86c:     // connection2.request(createMessage(producerInfo2, destination,
1:230a86c:     // deliveryMode));
1:230a86c:     // fail("Expected JMSException.");
1:230a86c:     // } catch ( JMSException success ) {
1:230a86c:     // }
1:230a86c:     //        
1:230a86c:     // }
1:230a86c: 
1:230a86c:     // public void initCombosForTestTempDestinationsAreNotAutoCreated() {
1:230a86c:     // addCombinationValues( "deliveryMode", new Object[]{
1:230a86c:     // Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:230a86c:     // Integer.valueOf(DeliveryMode.PERSISTENT)} );
1:230a86c:     // addCombinationValues( "destinationType", new Object[]{
1:230a86c:     // Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:230a86c:     // Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:230a86c:     // }
1:230a86c:     //    
1:230a86c:     //   
1:230a86c: 
1:230a86c:     // We create temp destination on demand now so this test case is no longer
1:230a86c:     // valid.
1:230a86c:     //    
1:230a86c:     // public void testTempDestinationsAreNotAutoCreated() throws Exception {
1:230a86c:     //        
1:230a86c:     // // Setup a first connection
1:230a86c:     // StubConnection connection1 = createConnection();
1:230a86c:     // ConnectionInfo connectionInfo1 = createConnectionInfo();
1:230a86c:     // SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:230a86c:     // ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:230a86c:     // connection1.send(connectionInfo1);
1:230a86c:     // connection1.send(sessionInfo1);
1:230a86c:     // connection1.send(producerInfo1);
1:230a86c:     //
1:230a86c:     // destination =
1:230a86c:     // ActiveMQDestination.createDestination(connectionInfo1.getConnectionId()+":1",
1:230a86c:     // destinationType);
1:230a86c:     //            
1:230a86c:     // // Should not be able to send to a non-existant temp destination.
1:230a86c:     // try {
1:230a86c:     // connection1.request(createMessage(producerInfo1, destination,
1:230a86c:     // deliveryMode));
1:230a86c:     // fail("Expected JMSException.");
1:230a86c:     // } catch ( JMSException success ) {
1:230a86c:     // }
1:230a86c:     //        
1:230a86c:     // }
1:230a86c: 
1:230a86c:     
1:230a86c:     public void initCombosForTestExclusiveQueueDeliversToOnlyOneConsumer() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testExclusiveQueueDeliversToOnlyOneConsumer() throws Exception {
1:230a86c: 
1:d29ca2a:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo);
1:230a86c: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(1);
1:d29ca2a:         consumerInfo1.setExclusive(true);
1:d29ca2a:         connection1.send(consumerInfo1);
1:230a86c: 
1:d29ca2a:         // Send a message.. this should make consumer 1 the exclusive owner.
1:d29ca2a:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:3a7c673: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:d29ca2a:         consumerInfo2.setPrefetchSize(1);
1:d29ca2a:         consumerInfo2.setExclusive(true);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:d29ca2a:         connection2.request(consumerInfo2);
1:230a86c: 
1:230a86c:         // Second message should go to consumer 1 even though consumer 2 is
1:230a86c:         // ready
1:d29ca2a:         // for dispatch.
1:3965f2c:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:3965f2c:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:3a7c673: 
1:230a86c:         // Acknowledge the first 2 messages
1:230a86c:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:230a86c:             assertNotNull(m1);
1:d29ca2a:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Close the first consumer.
3:d29ca2a:         connection1.send(closeConsumerInfo(consumerInfo1));
1:230a86c: 
1:d29ca2a:         // The last two messages should now go the the second consumer.
11:d29ca2a:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:230a86c: 
1:230a86c:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection2);
1:230a86c:             assertNotNull(m1);
2:d29ca2a:             connection2.send(createAck(consumerInfo2, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection2);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestWildcardConsume() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testWildcardConsume() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:230a86c: 
1:d29ca2a:         // setup the wildcard consumer.
1:f812e34:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("WILD.*.TEST",
1:f812e34:                                                                                          destinationType);
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, compositeDestination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo1);
1:3a7c673: 
1:d29ca2a:         // These two message should NOT match the wild card.
1:f812e34:         connection1.send(createMessage(producerInfo1, ActiveMQDestination.createDestination("WILD.CARD",
1:f812e34:                                                                                             destinationType),
1:f812e34:                                        deliveryMode));
1:f812e34:         connection1.send(createMessage(producerInfo1, ActiveMQDestination.createDestination("WILD.TEST",
1:f812e34:                                                                                             destinationType),
1:f812e34:                                        deliveryMode));
1:3a7c673: 
1:d29ca2a:         // These two message should match the wild card.
1:d29ca2a:         ActiveMQDestination d1 = ActiveMQDestination.createDestination("WILD.CARD.TEST", destinationType);
1:d29ca2a:         connection1.send(createMessage(producerInfo1, d1, deliveryMode));
1:1c8cfd9:         
1:d29ca2a:         Message m = receiveMessage(connection1);
1:d29ca2a:         assertNotNull(m);
1:1c8cfd9:         assertEquals(d1, m.getDestination());
1:1c8cfd9: 
1:1c8cfd9:         ActiveMQDestination d2 = ActiveMQDestination.createDestination("WILD.FOO.TEST", destinationType);
1:1c8cfd9:         connection1.request(createMessage(producerInfo1, d2, deliveryMode));
1:d29ca2a:         m = receiveMessage(connection1);
1:1c8cfd9:         assertNotNull(m);
1:230a86c:         assertEquals(d2, m.getDestination());
1:3a7c673: 
1:230a86c:         assertNoMessagesLeft(connection1);
2:d29ca2a:         connection1.send(closeConnectionInfo(connectionInfo1));
1:d29ca2a:     }
1:3a7c673: 
1:230a86c:     public void initCombosForTestCompositeConsume() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testCompositeConsume() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:3a7c673: 
1:d29ca2a:         // setup the composite consumer.
1:f812e34:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("A,B",
1:f812e34:                                                                                          destinationType);
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, compositeDestination);
1:e5bbcb5:         consumerInfo1.setRetroactive(true);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo1);
1:3965f2c: 
1:d29ca2a:         // Publish to the two destinations
1:d29ca2a:         ActiveMQDestination destinationA = ActiveMQDestination.createDestination("A", destinationType);
1:d29ca2a:         ActiveMQDestination destinationB = ActiveMQDestination.createDestination("B", destinationType);
1:3965f2c: 
1:d29ca2a:         // Send a message to each destination .
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destinationA, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destinationB, deliveryMode));
1:3965f2c: 
1:d29ca2a:         // The consumer should get both messages.
1:230a86c:         for (int i = 0; i < 2; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:         }
1:3965f2c: 
1:230a86c:         assertNoMessagesLeft(connection1);
1:d29ca2a:         connection1.send(closeConnectionInfo(connectionInfo1));
1:d29ca2a:     }
1:3965f2c: 
1:230a86c:     public void initCombosForTestCompositeSend() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testCompositeSend() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:3965f2c: 
1:d29ca2a:         ActiveMQDestination destinationA = ActiveMQDestination.createDestination("A", destinationType);
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destinationA);
1:e5bbcb5:         consumerInfo1.setRetroactive(true);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:7882eb7:         connection1.request(consumerInfo1);
1:3965f2c: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:3965f2c: 
1:d29ca2a:         ActiveMQDestination destinationB = ActiveMQDestination.createDestination("B", destinationType);
1:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destinationB);
1:e5bbcb5:         consumerInfo2.setRetroactive(true);
1:d29ca2a:         consumerInfo2.setPrefetchSize(100);
1:d29ca2a:         connection2.request(consumerInfo2);
1:3965f2c: 
1:d29ca2a:         // Send the messages to the composite destination.
1:f812e34:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("A,B",
1:f812e34:                                                                                          destinationType);
1:230a86c:         for (int i = 0; i < 4; i++) {
1:7882eb7:             connection1.request(createMessage(producerInfo1, compositeDestination, deliveryMode));
1:d29ca2a:         }
1:04968b6: 
1:230a86c:         // The messages should have been delivered to both the A and B
1:230a86c:         // destination.
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
3:d29ca2a:             Message m2 = receiveMessage(connection2);
1:230a86c: 
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:             assertNotNull(m2);
1:04968b6: 
1:230a86c:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:230a86c:             assertEquals(compositeDestination, m1.getOriginalDestination());
1:230a86c:             assertEquals(compositeDestination, m2.getOriginalDestination());
1:230a86c: 
1:7882eb7:             connection1.request(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:7882eb7:             connection2.request(createAck(consumerInfo2, m2, 1, MessageAck.STANDARD_ACK_TYPE));
253:d29ca2a: 
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         assertNoMessagesLeft(connection1);
1:d29ca2a:         assertNoMessagesLeft(connection2);
1:d29ca2a: 
1:d29ca2a:         connection1.send(closeConnectionInfo(connectionInfo1));
1:d29ca2a:         connection2.send(closeConnectionInfo(connectionInfo2));
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void initCombosForTestConnectionCloseCascades() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"),
1:f812e34:                                                           new ActiveMQQueue("TEST")});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testConnectionCloseCascades() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         consumerInfo1.setNoLocal(true);
1:d29ca2a:         connection1.request(consumerInfo1);
1:230a86c: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
2:d29ca2a:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
2:d29ca2a:         connection2.send(producerInfo2);
1:230a86c: 
1:d29ca2a:         // Send the messages
5:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:230a86c: 
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:7f5e666:         // give the async ack a chance to perculate and validate all are currently consumed
1:6f3c999:         Message msg = receiveMessage(connection1, MAX_NULL_WAIT);
1:6f3c999:         assertNull("all messages were received " + msg, msg);
1:6f3c999:         
1:d29ca2a:         // Close the connection, this should in turn close the consumer.
1:d29ca2a:         connection1.request(closeConnectionInfo(connectionInfo1));
1:b4aa979: 
1:d29ca2a:         // Send another message, connection1 should not get the message.
1:d29ca2a:         connection2.request(createMessage(producerInfo2, destination, deliveryMode));
1:230a86c: 
1:6f3c999:         assertNull("no message received", receiveMessage(connection1, MAX_NULL_WAIT));
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestSessionCloseCascades() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"),
1:f812e34:                                                           new ActiveMQQueue("TEST")});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testSessionCloseCascades() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         consumerInfo1.setNoLocal(true);
1:d29ca2a:         connection1.request(consumerInfo1);
1:230a86c: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:d29ca2a:         connection2.send(producerInfo2);
1:230a86c: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:230a86c: 
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Close the session, this should in turn close the consumer.
1:d29ca2a:         connection1.request(closeSessionInfo(sessionInfo1));
1:230a86c: 
1:d29ca2a:         // Send another message, connection1 should not get the message.
1:7882eb7:         connection2.request(createMessage(producerInfo2, destination, deliveryMode));
1:230a86c: 
1:6f3c999:         Message msg = receiveMessage(connection1,MAX_NULL_WAIT);
1:f36aa55:         assertNull("no message received from connection1 after session close", msg);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestConsumerClose() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"),
1:f812e34:                                                           new ActiveMQQueue("TEST")});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testConsumerClose() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         consumerInfo1.setNoLocal(true);
1:d29ca2a:         connection1.request(consumerInfo1);
1:230a86c: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:d29ca2a:         connection2.send(producerInfo2);
1:230a86c: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:d29ca2a:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:230a86c: 
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:b4aa979:         // give the async ack a chance to perculate and validate all are currently consumed
1:6f3c999:         // use receive rather than poll as broker info is sent async and may still need to be dequeued
1:6f3c999:         Message result = receiveMessage(connection1, MAX_NULL_WAIT);
1:c94279e:         assertNull("no more messages " + result, result);
1:d29ca2a:  
1:d29ca2a:         // Close the consumer.
1:d29ca2a:         connection1.request(closeConsumerInfo(consumerInfo1));
1:230a86c: 
1:d29ca2a:         // Send another message, connection1 should not get the message.
1:7882eb7:         connection2.request(createMessage(producerInfo2, destination, deliveryMode));
1:230a86c: 
1:6f3c999:         result = receiveMessage(connection1, MAX_NULL_WAIT);
1:6f3c999:         assertNull("no message received after close " + result, result);
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void initCombosForTestTopicNoLocal() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testTopicNoLocal() throws Exception {
1:230a86c: 
1:d29ca2a:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:e5bbcb5:         consumerInfo1.setRetroactive(true);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         consumerInfo1.setNoLocal(true);
1:d29ca2a:         connection1.send(consumerInfo1);
1:d29ca2a: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:d29ca2a:         connection2.send(producerInfo2);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:e5bbcb5:         consumerInfo2.setRetroactive(true);
1:d29ca2a:         consumerInfo2.setPrefetchSize(100);
1:230a86c:         consumerInfo2.setNoLocal(true);
1:d29ca2a:         connection2.send(consumerInfo2);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a: 
1:d29ca2a:         // The 2nd connection should get the messages.
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection2);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Send a message with the 2nd connection
1:d29ca2a:         Message message = createMessage(producerInfo2, destination, deliveryMode);
1:d29ca2a:         connection2.send(message);
1:230a86c: 
1:230a86c:         // The first connection should not see the initial 4 local messages sent
1:230a86c:         // but should
1:d29ca2a:         // see the messages from connection 2.
1:d29ca2a:         Message m = receiveMessage(connection1);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertEquals(message.getMessageId(), m.getMessageId());
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection1);
1:d29ca2a:         assertNoMessagesLeft(connection2);
1:d29ca2a:     }
1:230a86c: 
1:e5bbcb5:     public void initCombosForTopicDispatchIsBroadcast() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testTopicDispatchIsBroadcast() throws Exception {
1:230a86c: 
1:d29ca2a:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:d29ca2a: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo1);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:e5bbcb5:         consumerInfo1.setRetroactive(true);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo1);
1:d29ca2a: 
1:230a86c:         // Setup a second connection
1:d29ca2a:         StubConnection connection2 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:e5bbcb5:         consumerInfo2.setRetroactive(true);
1:d29ca2a:         consumerInfo2.setPrefetchSize(100);
1:d29ca2a:         connection2.send(connectionInfo2);
1:d29ca2a:         connection2.send(sessionInfo2);
1:d29ca2a:         connection2.send(consumerInfo2);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:d29ca2a: 
1:d29ca2a:         // Get the messages
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
1:d29ca2a:             m1 = receiveMessage(connection2);
1:230a86c:             assertNotNull(m1);
1:230a86c:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestQueueDispatchedAreRedeliveredOnConsumerClose() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testQueueDispatchedAreRedeliveredOnConsumerClose() throws Exception {
1:230a86c: 
1:d29ca2a:         // Setup a first connection
1:d29ca2a:         StubConnection connection1 = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:d29ca2a:         connection1.send(connectionInfo1);
1:d29ca2a:         connection1.send(sessionInfo1);
1:d29ca2a:         connection1.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo1.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo1);
1:d29ca2a: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a: 
1:eb6c082:         long lastDeliveredSeq = -1;
1:d29ca2a:         // Get the messages
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:d29ca2a:             assertNotNull(m1);
2:d29ca2a:             assertFalse(m1.isRedelivered());
1:eb6c082:             lastDeliveredSeq = m1.getMessageId().getBrokerSequenceId();
1:d29ca2a:         }
1:d29ca2a:         // Close the consumer without sending any ACKS.
1:eb6c082:         RemoveInfo removeInfo = closeConsumerInfo(consumerInfo1);
1:eb6c082:         removeInfo.setLastDeliveredSequenceId(lastDeliveredSeq);
1:eb6c082:         connection1.send(removeInfo);
1:d29ca2a: 
1:d29ca2a:         // Drain any in flight messages..
1:230a86c:         while (connection1.getDispatchQueue().poll(0, TimeUnit.MILLISECONDS) != null) {
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         // Add the second consumer
2:d29ca2a:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo1, destination);
1:d29ca2a:         consumerInfo2.setPrefetchSize(100);
1:d29ca2a:         connection1.send(consumerInfo2);
1:d29ca2a: 
1:d29ca2a:         // Make sure the messages were re delivered to the 2nd consumer.
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m1 = receiveMessage(connection1);
1:230a86c:             assertNotNull(m1);
2:d29ca2a:             assertTrue(m1.isRedelivered());
1:230a86c:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestQueueBrowseMessages() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testQueueBrowseMessages() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a: 
1:d29ca2a:         // Use selector to skip first message.
4:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setBrowser(true);
1:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:230a86c:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message m = receiveMessage(connection);
1:230a86c:             assertNotNull(m);
1:d29ca2a:             connection.send(createAck(consumerInfo, m, 1, MessageAck.DELIVERED_ACK_TYPE));
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestQueueSendThenAddConsumer() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testQueueSendThenAddConsumer() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         // Send a message to the broker.
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:230a86c: 
1:d29ca2a:         // Start the consumer
1:230a86c:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         connection.send(consumerInfo);
1:d29ca2a: 
1:d29ca2a:         // Make sure the message was delivered.
1:d29ca2a:         Message m = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m);
1:230a86c: 
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestQueueAckRemovesMessage() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testQueueAckRemovesMessage() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         Message message1 = createMessage(producerInfo, destination, deliveryMode);
1:d29ca2a:         Message message2 = createMessage(producerInfo, destination, deliveryMode);
1:d29ca2a:         connection.send(message1);
1:d29ca2a:         connection.send(message2);
1:230a86c: 
1:d29ca2a:         // Make sure the message was delivered.
1:230a86c:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         connection.request(consumerInfo);
1:d29ca2a:         Message m = receiveMessage(connection);
1:230a86c:         assertNotNull(m);
1:230a86c:         assertEquals(m.getMessageId(), message1.getMessageId());
1:230a86c: 
1:230a86c:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination) == 2);
1:d29ca2a:         connection.send(createAck(consumerInfo, m, 1, MessageAck.DELIVERED_ACK_TYPE));
1:230a86c:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination) == 2);
1:d29ca2a:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination) == 1);
1:230a86c: 
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void initCombosForTestSelectorSkipsMessages() {
1:f812e34:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST_TOPIC"),
1:f812e34:                                                           new ActiveMQQueue("TEST_QUEUE")});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testSelectorSkipsMessages() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setSelector("JMSType='last'");
1:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:d29ca2a:         Message message1 = createMessage(producerInfo, destination, deliveryMode);
1:d29ca2a:         message1.setType("first");
1:d29ca2a:         Message message2 = createMessage(producerInfo, destination, deliveryMode);
1:d29ca2a:         message2.setType("last");
1:d29ca2a:         connection.send(message1);
1:d29ca2a:         connection.send(message2);
1:230a86c: 
1:d29ca2a:         // Use selector to skip first message.
1:d29ca2a:         Message m = receiveMessage(connection);
1:230a86c:         assertNotNull(m);
1:230a86c:         assertEquals(m.getMessageId(), message2.getMessageId());
1:d29ca2a:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:         connection.send(closeConsumerInfo(consumerInfo));
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestAddConsumerThenSend() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testAddConsumerThenSend() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:230a86c:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         connection.send(consumerInfo);
1:d29ca2a: 
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a: 
1:d29ca2a:         // Make sure the message was delivered.
1:d29ca2a:         Message m = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void initCombosForTestConsumerPrefetchAtOne() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:230a86c:     }
1:230a86c: 
1:7f5213b:     public void testConsumerPrefetchAtOne() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setPrefetchSize(1);
1:d29ca2a:         connection.send(consumerInfo);
1:d29ca2a: 
1:d29ca2a:         // Send 2 messages to the broker.
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:230a86c: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         Message m = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertNoMessagesLeft(connection);
1:230a86c: 
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestConsumerPrefetchAtTwo() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:230a86c:     }
1:d29ca2a: 
1:7f5213b:     public void testConsumerPrefetchAtTwo() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setPrefetchSize(2);
1:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:d29ca2a:         // Send 3 messages to the broker.
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:230a86c: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         Message m = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         m = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         assertNoMessagesLeft(connection);
1:230a86c: 
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestConsumerPrefetchAndDeliveredAck() {
1:f812e34:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:f812e34:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:f812e34:         addCombinationValues("destinationType",
1:f812e34:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:f812e34:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void testConsumerPrefetchAndDeliveredAck() throws Exception {
1:230a86c: 
1:d29ca2a:         // Start a producer and consumer
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:d29ca2a:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:d29ca2a: 
1:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setPrefetchSize(1);
1:7882eb7:         connection.request(consumerInfo);
1:d29ca2a: 
1:d29ca2a:         // Send 3 messages to the broker.
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:7882eb7:         connection.request(createMessage(producerInfo, destination, deliveryMode));
1:d29ca2a: 
1:d29ca2a:         // Make sure only 1 message was delivered.
1:d29ca2a:         Message m1 = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m1);
1:d29ca2a: 
1:d29ca2a:         assertNoMessagesLeft(connection);
1:d29ca2a: 
1:230a86c:         // Acknowledge the first message. This should cause the next message to
1:230a86c:         // get dispatched.
1:7882eb7:         connection.request(createAck(consumerInfo, m1, 1, MessageAck.DELIVERED_ACK_TYPE));
1:d29ca2a: 
1:d29ca2a:         Message m2 = receiveMessage(connection);
1:d29ca2a:         assertNotNull(m2);
1:7882eb7:         connection.request(createAck(consumerInfo, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:d29ca2a: 
1:d29ca2a:         Message m3 = receiveMessage(connection);
1:230a86c:         assertNotNull(m3);
1:7882eb7:         connection.request(createAck(consumerInfo, m3, 1, MessageAck.DELIVERED_ACK_TYPE));
1:d29ca2a:     }
1:d29ca2a: 
1:a72f26f:     public void testGetServices() throws Exception {
1:a72f26f:         assertTrue(broker.getServices().length != 0);
1:a72f26f:     }
1:a72f26f:     
1:d29ca2a:     public static Test suite() {
1:d29ca2a:         return suite(BrokerTest.class);
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public static void main(String[] args) {
1:d29ca2a:         junit.textui.TestRunner.run(suite());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:gtully
-------------------------------------------------------------------------------
commit:857597c
/////////////////////////////////////////////////////////////////////////
commit:b4e35fe
/////////////////////////////////////////////////////////////////////////
1:         // a browse is a snapshot - only guarantee to see messages produced before
1:         // the browser
1:         for (int i = 0; i < 1; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection1.request(closeConnectionInfo(connectionInfo1));
1:         connection1.stop();
1:         connection2.request(closeConnectionInfo(connectionInfo2));
1:         connection2.stop();
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         long lastDeliveredSeq = -1;
1:             lastDeliveredSeq = m1.getMessageId().getBrokerSequenceId();
1:         RemoveInfo removeInfo = closeConsumerInfo(consumerInfo1);
1:         removeInfo.setLastDeliveredSequenceId(lastDeliveredSeq);
1:         connection1.send(removeInfo);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:915333e
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 4; i++) {
author:Gary Tully
-------------------------------------------------------------------------------
commit:6f3c999
/////////////////////////////////////////////////////////////////////////
1:         Message msg = receiveMessage(connection1, MAX_NULL_WAIT);
1:         assertNull("all messages were received " + msg, msg);
1:         
1:         assertNull("no message received", receiveMessage(connection1, MAX_NULL_WAIT));
/////////////////////////////////////////////////////////////////////////
1:         Message msg = receiveMessage(connection1,MAX_NULL_WAIT);
/////////////////////////////////////////////////////////////////////////
1:         // use receive rather than poll as broker info is sent async and may still need to be dequeued
1:         Message result = receiveMessage(connection1, MAX_NULL_WAIT);
/////////////////////////////////////////////////////////////////////////
1:         result = receiveMessage(connection1, MAX_NULL_WAIT);
1:         assertNull("no message received after close " + result, result);
commit:f36aa55
/////////////////////////////////////////////////////////////////////////
0:         Object msg = connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS);
1:         assertNull("no message received from connection1 after session close", msg);
commit:c94279e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Object result = connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS);
1:         assertNull("no more messages " + result, result);
commit:a72f26f
/////////////////////////////////////////////////////////////////////////
1:     public void testGetServices() throws Exception {
1:         assertTrue(broker.getServices().length != 0);
1:     }
1:     
commit:7f5e666
/////////////////////////////////////////////////////////////////////////
1:         // give the async ack a chance to perculate and validate all are currently consumed
0:         assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
1: 
commit:9216c18
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
1:      * change the order of the above test
1:      */
1:     public void testQueueBrowserWith2ConsumersBrowseFirst() throws Exception {
1: 
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         deliveryMode = DeliveryMode.NON_PERSISTENT;
1:         
1:         
1:         // Setup a second connection with a queue browser.
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(10);
1:         consumerInfo2.setBrowser(true);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.request(consumerInfo2);
1: 
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(10);
1:         connection1.request(consumerInfo1);
1: 
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         //as the messages are sent async - need to synchronize the last
1:         //one to ensure they arrive in the order we want
1:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1: 
1: 
1:         List<Message> messages = new ArrayList<Message>();
1: 
1:         for (int i = 0; i < 4; i++) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull("m1 is null for index: " + i, m1);
1:             messages.add(m1);
1:         }
1: 
1:         // no messages present in queue browser as there were no messages when it
1:         // was created
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
1:     public void testQueueBrowserWith2ConsumersInterleaved() throws Exception {
1: 
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         deliveryMode = DeliveryMode.NON_PERSISTENT;
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(10);
1:         connection1.request(consumerInfo1);
1: 
1:         // Send the messages
1:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Setup a second connection with a queue browser.
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
1:         consumerInfo2.setBrowser(true);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.request(consumerInfo2);
1: 
1:         
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         //as the messages are sent async - need to synchronize the last
1:         //one to ensure they arrive in the order we want
1:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1: 
1:         
1:         List<Message> messages = new ArrayList<Message>();
1: 
1:         for (int i = 0; i < 4; i++) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull("m1 is null for index: " + i, m1);
1:             messages.add(m1);
1:         }
1: 
1:         for (int i = 0; i < 1; i++) {
1:             Message m1 = messages.get(i);
1:             Message m2 = receiveMessage(connection2);
1:             assertNotNull("m2 is null for index: " + i, m2);
1:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         }
1: 
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
1:     
commit:b4aa979
/////////////////////////////////////////////////////////////////////////
1:         // give the async ack a chance to perculate and validate all are currently consumed
0:         assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
1:  
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:1c8cfd9
/////////////////////////////////////////////////////////////////////////
1:         
1:         assertEquals(d1, m.getDestination());
1: 
1:         ActiveMQDestination d2 = ActiveMQDestination.createDestination("WILD.FOO.TEST", destinationType);
1:         connection1.request(createMessage(producerInfo1, d2, deliveryMode));
1:         assertNotNull(m);
commit:230a57b
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestQueueBrowserWith2Consumers() {
1:     public void testQueueBrowserWith2Consumers() throws Exception {
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         List<Message> messages = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:             Message m1 = messages.get(i);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     public void xtestQueueBrowserWith2Consumers() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         assertNull(connection1.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
0:         assertNull(connection1.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
0:         assertNull(connection1.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS));
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
0:                              new Object[] {Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("WILD.*.TEST",
1:                                                                                          destinationType);
1:         connection1.send(createMessage(producerInfo1, ActiveMQDestination.createDestination("WILD.CARD",
1:                                                                                             destinationType),
1:                                        deliveryMode));
1:         connection1.send(createMessage(producerInfo1, ActiveMQDestination.createDestination("WILD.TEST",
1:                                                                                             destinationType),
1:                                        deliveryMode));
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("A,B",
1:                                                                                          destinationType);
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("A,B",
1:                                                                                          destinationType);
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"),
1:                                                           new ActiveMQQueue("TEST")});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"),
1:                                                           new ActiveMQQueue("TEST")});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"),
1:                                                           new ActiveMQQueue("TEST")});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST_TOPIC"),
1:                                                           new ActiveMQQueue("TEST_QUEUE")});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                                                            Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType",
1:                              new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                            Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
0:                                            Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public void initCombosForTestQueueOnlyOnceDeliveryWith2Consumers() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1: 
1:         for (int i = 0; i < 2; i++) {
1: 
1:             assertNotNull("m1 is null for index: " + i, m1);
1:             assertNotNull("m2 is null for index: " + i, m2);
1: 
0:     public void initCombosForTestQueuBrowserWith2Consumers() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:     }
1: 
0:      * This test is being disabled for now since it is failing. Looks like the
0:      * queue browser has changed in trunk. It now seems to not give you message
0:      * that have been dispatched to another consumer but not yet acked. Created
0:      * JIRA issue: https://issues.apache.org/activemq/browse/AMQ-1268
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 4; i++) {
1:             assertNotNull("m1 is null for index: " + i, m1);
1: 
1:         for (int i = 0; i < 4; i++) {
0:             Message m1 = (Message)messages.get(i);
1:             assertNotNull("m2 is null for index: " + i, m2);
1: 
1:     public void initCombosForTestConsumerPrefetchAndStandardAck() {
1:         addCombinationValues("deliveryMode", new Object[] {
1:         // Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:                              Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1:         // Acknowledge the first message. This should cause the next message to
1:         // get dispatched.
1: 
1:         assertNotNull(m2);
1: 
1:         assertNotNull(m3);
1: 
1:     public void initCombosForTestTransactedAckWithPrefetchOfOne() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 4; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1:         assertNoMessagesLeft(connection1);
1:     }
1: 
1:     public void initCombosForTestTransactedSend() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1:     public void initCombosForTestQueueTransactedAck() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 4; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 2; i++) {
1:             assertNotNull("m1 is null for index: " + i, m1);
1: 
1: 
1:         assertEquals(2, countMessagesInQueue(connection1, connectionInfo1, destination));
0:     public void initCombosForTestConsumerCloseCausesRedelivery() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destination", new Object[] {new ActiveMQQueue("TEST")});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 4; i++) {
1:             assertNotNull("m1 is null for index: " + i, m1);
1: 
0:         // Close the consumer without acking.. this should cause re-delivery of
0:         // the messages.
1: 
1: 
1:         for (int i = 0; i < 4; i++) {
1:             assertNotNull("m1 is null for index: " + i, m1);
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         Message m = null;
1:         for (int i = 0; i < 2; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1:         for (int i = 0; i < 2; i++) {
1:             assertNotNull("m1 is null for index: " + i, m1);
1:     public void initCombosForTestGroupedMessagesDeliveredToOnlyOneConsumer() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 4; i++) {
1:             message.setGroupSequence(i + 1);
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1:         // All the messages should have been sent down connection 1.. just get
1:         // the first 3
1:         for (int i = 0; i < 3; i++) {
0:             assertNotNull("m1 is null for index: " + i, m1);
1: 
1:         // The last messages should now go the the second consumer.
0:         for (int i = 0; i < 1; i++) {
0:             assertNotNull("m1 is null for index: " + i, m1);
1: 
1:     public void initCombosForTestTopicConsumerOnlySeeMessagesAfterCreation() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("durableConsumer", new Object[] {Boolean.TRUE, Boolean.FALSE});
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (durableConsumer) {
1: 
1: 
1: 
1: 
1:     public void initCombosForTestTopicRetroactiveConsumerSeeMessagesBeforeCreation() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("durableConsumer", new Object[] {Boolean.TRUE, Boolean.FALSE});
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (durableConsumer) {
1: 
1:         // But the default broker settings try to make it as consistent as
1:         // possible
1: 
1:         for (int i = 0; i < 2; i++) {
1: 
1:     //
1:     // TODO: need to reimplement this since we don't fail when we send to a
1:     // non-existant
1:     // destination. But if we can access the Region directly then we should be
1:     // able to
1:     // check that if the destination was removed.
1:     // 
1:     // public void initCombosForTestTempDestinationsRemovedOnConnectionClose() {
1:     // addCombinationValues( "deliveryMode", new Object[]{
1:     // Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:     // Integer.valueOf(DeliveryMode.PERSISTENT)} );
1:     // addCombinationValues( "destinationType", new Object[]{
1:     // Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:     // Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     // }
1:     //    
1:     // public void testTempDestinationsRemovedOnConnectionClose() throws
1:     // Exception {
1:     //        
1:     // // Setup a first connection
1:     // StubConnection connection1 = createConnection();
1:     // ConnectionInfo connectionInfo1 = createConnectionInfo();
1:     // SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:     // ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:     // connection1.send(connectionInfo1);
1:     // connection1.send(sessionInfo1);
1:     // connection1.send(producerInfo1);
1:     //
1:     // destination = createDestinationInfo(connection1, connectionInfo1,
1:     // destinationType);
1:     //        
1:     // StubConnection connection2 = createConnection();
1:     // ConnectionInfo connectionInfo2 = createConnectionInfo();
1:     // SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:     // ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:     // connection2.send(connectionInfo2);
1:     // connection2.send(sessionInfo2);
1:     // connection2.send(producerInfo2);
1:     //
1:     // // Send from connection2 to connection1's temp destination. Should
1:     // succeed.
1:     // connection2.send(createMessage(producerInfo2, destination,
1:     // deliveryMode));
1:     //        
1:     // // Close connection 1
1:     // connection1.request(closeConnectionInfo(connectionInfo1));
1:     //        
1:     // try {
1:     // // Send from connection2 to connection1's temp destination. Should not
1:     // succeed.
1:     // connection2.request(createMessage(producerInfo2, destination,
1:     // deliveryMode));
1:     // fail("Expected JMSException.");
1:     // } catch ( JMSException success ) {
1:     // }
1:     //        
1:     // }
1:     // public void initCombosForTestTempDestinationsAreNotAutoCreated() {
1:     // addCombinationValues( "deliveryMode", new Object[]{
1:     // Integer.valueOf(DeliveryMode.NON_PERSISTENT),
1:     // Integer.valueOf(DeliveryMode.PERSISTENT)} );
1:     // addCombinationValues( "destinationType", new Object[]{
1:     // Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),
1:     // Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     // }
1:     //    
1:     //   
1:     // We create temp destination on demand now so this test case is no longer
1:     // valid.
1:     //    
1:     // public void testTempDestinationsAreNotAutoCreated() throws Exception {
1:     //        
1:     // // Setup a first connection
1:     // StubConnection connection1 = createConnection();
1:     // ConnectionInfo connectionInfo1 = createConnectionInfo();
1:     // SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:     // ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:     // connection1.send(connectionInfo1);
1:     // connection1.send(sessionInfo1);
1:     // connection1.send(producerInfo1);
1:     //
1:     // destination =
1:     // ActiveMQDestination.createDestination(connectionInfo1.getConnectionId()+":1",
1:     // destinationType);
1:     //            
1:     // // Should not be able to send to a non-existant temp destination.
1:     // try {
1:     // connection1.request(createMessage(producerInfo1, destination,
1:     // deliveryMode));
1:     // fail("Expected JMSException.");
1:     // } catch ( JMSException success ) {
1:     // }
1:     //        
1:     // }
0:     public void initCombosForTestTempDestinationsOnlyAllowsLocalConsumers() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
0:         // Only consumers local to the temp destination should be allowed to
0:         // subscribe.
0:         } catch (JMSException success) {
1: 
1:     public void initCombosForTestExclusiveQueueDeliversToOnlyOneConsumer() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1:         // Second message should go to consumer 1 even though consumer 2 is
1:         // ready
1:         // Acknowledge the first 2 messages
1:         for (int i = 0; i < 2; i++) {
1:             assertNotNull(m1);
1: 
1: 
1:         for (int i = 0; i < 2; i++) {
1:             assertNotNull(m1);
1: 
1:     public void initCombosForTestWildcardConsume() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(d1, m.getDestination());
1:         assertEquals(d2, m.getDestination());
1:         assertNoMessagesLeft(connection1);
1:     public void initCombosForTestCompositeConsume() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 2; i++) {
1:         assertNoMessagesLeft(connection1);
1:     public void initCombosForTestCompositeSend() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 4; i++) {
1:         // The messages should have been delivered to both the A and B
1:         // destination.
1:         for (int i = 0; i < 4; i++) {
1: 
1:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:             assertEquals(compositeDestination, m1.getOriginalDestination());
1:             assertEquals(compositeDestination, m2.getOriginalDestination());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void initCombosForTestConnectionCloseCascades() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"), new ActiveMQQueue("TEST")});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1: 
1: 
1: 
1:     public void initCombosForTestSessionCloseCascades() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"), new ActiveMQQueue("TEST")});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1: 
1: 
1: 
1:     public void initCombosForTestConsumerClose() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST"), new ActiveMQQueue("TEST")});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1: 
1: 
1: 
1:     public void initCombosForTestTopicNoLocal() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Setup a second connection
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1: 
1:         consumerInfo2.setNoLocal(true);
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 4; i++) {
1: 
1: 
1:         // The first connection should not see the initial 4 local messages sent
1:         // but should
1: 
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         // Setup a second connection
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < 4; i++) {
1:             assertNotNull(m1);
1:         }
1: 
1:     public void initCombosForTestQueueDispatchedAreRedeliveredOnConsumerClose() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
0:         for (int i = 0; i < 4; i++) {
/////////////////////////////////////////////////////////////////////////
1:         while (connection1.getDispatchQueue().poll(0, TimeUnit.MILLISECONDS) != null) {
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < 4; i++) {
1:             assertNotNull(m1);
1:         }
1: 
1:     public void initCombosForTestQueueBrowseMessages() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
0:         for (int i = 0; i < 4; i++) {
1:             assertNotNull(m);
1: 
1: 
1:     public void initCombosForTestQueueSendThenAddConsumer() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1: 
1: 
1:     public void initCombosForTestQueueAckRemovesMessage() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE),});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         assertNotNull(m);
1:         assertEquals(m.getMessageId(), message1.getMessageId());
1: 
1:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination) == 2);
1:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination) == 2);
1:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination) == 1);
1: 
1:     public void initCombosForTestSelectorSkipsMessages() {
0:         addCombinationValues("destination", new Object[] {new ActiveMQTopic("TEST_TOPIC"), new ActiveMQQueue("TEST_QUEUE")});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         assertNotNull(m);
1:         assertEquals(m.getMessageId(), message2.getMessageId());
1: 
1: 
1:     public void initCombosForTestAddConsumerThenSend() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1: 
1: 
1:     public void initCombosForTestConsumerPrefetchAtOne() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:     public void initCombosForTestConsumerPrefetchAtTwo() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1:     public void initCombosForTestConsumerPrefetchAndDeliveredAck() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
0:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:         // Acknowledge the first message. This should cause the next message to
1:         // get dispatched.
1: 
1: 
1:         assertNotNull(m3);
1: 
commit:3a7c673
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.concurrent.TimeUnit;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestQueueOnlyOnceDeliveryWith2Consumers() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
1:     }   
1:     public void testQueueOnlyOnceDeliveryWith2Consumers() throws Exception {
1:         
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(1);
1:         connection1.send(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(consumerInfo2);
1:         
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             Message m2 = receiveMessage(connection2);
1:             
0:             assertNotNull("m1 is null for index: " + i, m1); 
0:             assertNotNull("m2 is null for index: " + i, m2);  
1: 
1:             assertNotSame(m1.getMessageId(), m2.getMessageId());
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
1:     
/////////////////////////////////////////////////////////////////////////
commit:3965f2c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestQueuBrowserWith2Consumers() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }   
1:     
1:     /**
0:      * This test is being disabled for now since it is failing.  Looks like the queue browser has 
0:      * changed in trunk.  It now seems to not give you message that have been dispatched to another consumer but not 
0:      * yet acked.  Created JIRA issue: https://issues.apache.org/activemq/browse/AMQ-1268
1:      * 
0:      * @throws Exception
1:      */
0:     public void XtestQueueBrowserWith2Consumers() throws Exception {
1:         
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(10);
1:         connection1.request(consumerInfo1);
1:         
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1: 
1:         // Setup a second connection with a queue browser.
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
1:         consumerInfo2.setBrowser(true);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.request(consumerInfo2);
1: 
0:         ArrayList messages = new ArrayList();
1:         
0:         for( int i=0; i < 4; i++ ) {
1:             Message m1 = receiveMessage(connection1);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:             messages.add(m1);
1:         }
1:         
0:         for( int i=0; i < 4; i++ ) {
0:             Message m1 = (Message) messages.get(i);
1:             Message m2 = receiveMessage(connection2);
0:             assertNotNull("m2 is null for index: " + i, m2);  
1:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
commit:333158a
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo1.setSubscriptionName("test");
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo2.setSubscriptionName("test");
/////////////////////////////////////////////////////////////////////////
1:             consumerInfo1.setSubscriptionName("test");
/////////////////////////////////////////////////////////////////////////
1:             consumerInfo1.setSubscriptionName("test");
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void testConsumerPrefetchAndStandardAck() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTransactedAckWithPrefetchOfOne() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTransactedSend() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueueTransactedAck() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testConsumerCloseCausesRedelivery() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicDurableSubscriptionCanBeRestored() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testGroupedMessagesDeliveredToOnlyOneConsumer() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicConsumerOnlySeeMessagesAfterCreation() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicRetroactiveConsumerSeeMessagesBeforeCreation() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testTempDestinationsRemovedOnConnectionClose() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testTempDestinationsAreNotAutoCreated() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testTempDestinationsOnlyAllowsLocalConsumers() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testExclusiveQueueDeliversToOnlyOneConsumer() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testWildcardConsume() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testCompositeConsume() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testCompositeSend() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testConnectionCloseCascades() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testSessionCloseCascades() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testConsumerClose() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicNoLocal() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicDispatchIsBroadcast() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueueDispatchedAreRedeliveredOnConsumerClose() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueueBrowseMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testQueueBrowserWith2Consumers() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testQueueOnlyOnceDeliveryWith2Consumers() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueueSendThenAddConsumer() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueueAckRemovesMessage() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testSelectorSkipsMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testAddConsumerThenSend() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testConsumerPrefetchAtOne() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testConsumerPrefetchAtTwo() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testConsumerPrefetchAndDeliveredAck() throws Exception {
commit:04968b6
/////////////////////////////////////////////////////////////////////////
1: 
1:         // the behavior is VERY dependent on the recovery policy used.
0:         // But the default broker settings try to make it as consistent as possible
1:         // Subscription should see all messages sent.
1:         Message m2 = receiveMessage(connection1);
1:         assertNotNull(m2);
1:         assertEquals(m.getMessageId(), m2.getMessageId());
0:         for( int i=0; i < 2 ; i++ ) {
1:             m2 = receiveMessage(connection1);
1:             
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
0: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.broker;
1: 
1: import javax.jms.DeliveryMode;
0: import javax.jms.JMSException;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.SessionInfo;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
1: 
1: public class BrokerTest extends BrokerTestSupport {
1:     
1:     public ActiveMQDestination destination;
1:     public int deliveryMode;
1:     public int prefetch;
1:     public byte destinationType;
1:     public boolean durableConsumer;
1:     
0:     public void initCombosForTestConsumerPrefetchAndStandardAck() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0: //                new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)
0:                 } );
1:     }
1:     
0:     public void testConsumerPrefetchAndStandardAck() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);        
1:         consumerInfo.setPrefetchSize(1);
1:         connection.send(consumerInfo);
1:         
1:         // Send 3 messages to the broker.
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Make sure only 1 message was delivered.
1:         Message m1 = receiveMessage(connection);
1:         assertNotNull(m1);
1:         assertNoMessagesLeft(connection);
1:         
0:         // Acknowledge the first message.  This should cause the next message to get dispatched.
1:         connection.send(createAck(consumerInfo, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
1:         Message m2 = receiveMessage(connection);
1:         assertNotNull(m2);        
1:         connection.send(createAck(consumerInfo, m2, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
1:         Message m3 = receiveMessage(connection);
0:         assertNotNull(m3);        
1:         connection.send(createAck(consumerInfo, m3, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
1:         connection.send(closeConnectionInfo(connectionInfo));
1:     }
1: 
1: 
0:     public void initCombosForTestTransactedAckWithPrefetchOfOne() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)
0:                 } );
1:     }
1: 
0:     public void testTransactedAckWithPrefetchOfOne() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
1:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(1);
1:         connection1.send(consumerInfo1);
1: 
1:         // Send the messages
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message message = createMessage(producerInfo1, destination, deliveryMode);
1:             connection1.send(message);
1:         }
1: 
1:         // Begin the transaction.
1:         LocalTransactionId txid = createLocalTransaction(sessionInfo1);
1:         connection1.send(createBeginTransaction(connectionInfo1, txid));
1:         
1:         // Now get the messages.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:             MessageAck ack = createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection1.send(ack);
1:         }
1:         
1:         // Commit the transaction.
1:         connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
1:         
1:         assertNoMessagesLeft(connection1);
1:     }    
1: 
0:     public void initCombosForTestTransactedSend() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }    
0:     public void testTransactedSend() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1:         
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1: 
1:         // Begin the transaction.
1:         LocalTransactionId txid = createLocalTransaction(sessionInfo1);
1:         connection1.send(createBeginTransaction(connectionInfo1, txid));
1:         
1:         // Send the messages
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message message = createMessage(producerInfo1, destination, deliveryMode);
1:             message.setTransactionId(txid);
1:             connection1.send(message);
1:         }
1:         
1:         // The point of this test is that message should not be delivered until
1:         // send is committed.
0:         assertNull(receiveMessage(connection1));
1: 
1:         // Commit the transaction.
1:         connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
1:         
1:         // Now get the messages.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:         }
1:         
1:         assertNoMessagesLeft(connection1);
1:     }
1: 
0:     public void initCombosForTestQueueTransactedAck() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:         } );
1:     }
1:     
0:     public void testQueueTransactedAck() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1: 
1:         // Send the messages
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message message = createMessage(producerInfo1, destination, deliveryMode);
1:             connection1.send(message);
1:         }
1: 
1:         // Begin the transaction.
1:         LocalTransactionId txid = createLocalTransaction(sessionInfo1);
1:         connection1.send(createBeginTransaction(connectionInfo1, txid));
1:         
1:         // Acknowledge the first 2 messages.
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:             MessageAck ack = createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection1.request(ack);
1:         }
1:             
1:         // Commit the transaction.
1:         connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
1:         
1:         // The queue should now only have the remaining 2 messages
0:         assertEquals(2, countMessagesInQueue(connection1, connectionInfo1, destination));        
1:     }
1: 
0:     public void initCombosForTestConsumerCloseCausesRedelivery() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destination", new Object[]{ 
0:                 new ActiveMQQueue("TEST")} );
1:     }   
1:     
0:     public void testConsumerCloseCausesRedelivery() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.request(consumerInfo1);
1: 
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1: 
0:         // Receive the messages.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:             assertFalse(m1.isRedelivered());
1:         }
1:         
0:         // Close the consumer without acking.. this should cause re-delivery of the messages.
0:         connection1.send(consumerInfo1.createRemoveCommand());
1:         
0:         // Create another consumer that should get the messages again.
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo2.setPrefetchSize(100);
0:         connection1.request(consumerInfo2);
1:         
0:         // Receive the messages.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:             assertTrue(m1.isRedelivered());
1:         }
1:         assertNoMessagesLeft(connection1);
1:         
1:     }
1: 
0:     public void testTopicDurableSubscriptionCanBeRestored() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         connectionInfo1.setClientId("clientid1");
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
0:         consumerInfo1.setSubcriptionName("test");
1:         connection1.send(consumerInfo1);
1: 
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1:         connection1.send(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
1: 
1:         // Get the messages
0:         Message m=null;
0:         for( int i=0; i < 2 ; i++ ) {
1:             m = receiveMessage(connection1);
1:             assertNotNull(m);
1:         }
1:         // Ack the last message.
1:         connection1.send(createAck(consumerInfo1, m, 2, MessageAck.STANDARD_ACK_TYPE));
1:         // Close the connection.
1:         connection1.send(closeConnectionInfo(connectionInfo1));
1:         connection1.stop();
1:         
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:         connectionInfo2.setClientId("clientid1");
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(100);
0:         consumerInfo2.setSubcriptionName("test");
1:         
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(consumerInfo2);
1: 
1:         // Get the rest of the messages
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection2);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:         }
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
1: 
0:     public void initCombosForTestGroupedMessagesDeliveredToOnlyOneConsumer() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }
0:     public void testGroupedMessagesDeliveredToOnlyOneConsumer() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(1);
1:         connection1.send(consumerInfo1);
1:         
1:         // Send the messages.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message message = createMessage(producerInfo, destination, deliveryMode);
1:             message.setGroupID("TEST-GROUP");
0:             message.setGroupSequence(i+1);
1:             connection1.request(message);
1:         }
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1: 
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
1:         connection2.send(consumerInfo2);
1:         
0:         // All the messages should have been sent down connection 1.. just get the first 3 
0:         for( int i=0; i < 3 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         // Close the first consumer.
1:         connection1.send(closeConsumerInfo(consumerInfo1));
1: 
0:         // The last messages should now go the the second consumer.        
0:         for( int i=0; i < 1 ; i++ ) {
1:             Message m1 = receiveMessage(connection2);
0:             assertNotNull("m1 is null for index: " + i, m1); 
1:             connection2.send(createAck(consumerInfo2, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
0:     public void initCombosForTestTopicConsumerOnlySeeMessagesAfterCreation() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "durableConsumer", new Object[]{ 
0:                 Boolean.TRUE, 
0:                 Boolean.FALSE});
1:     }
1:     
0:     public void testTopicConsumerOnlySeeMessagesAfterCreation() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         connectionInfo1.setClientId("A");
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
1:         // Send the 1st message
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         
1:         // Create the durable subscription.
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
0:         if( durableConsumer ) {
0:             consumerInfo1.setSubcriptionName("test");
1:         }
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1:         
1:         Message m = createMessage(producerInfo1, destination, deliveryMode);
1:         connection1.send(m);
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         
1:         // Subscription should skip over the first message
1:         Message m2 = receiveMessage(connection1);
1:         assertNotNull(m2);
1:         assertEquals(m.getMessageId(), m2.getMessageId());
1:         m2 = receiveMessage(connection1);
1:         assertNotNull(m2);
1:         
1:         assertNoMessagesLeft(connection1);
1:     }
1:     
0:     public void initCombosForTestTopicRetroactiveConsumerSeeMessagesBeforeCreation() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "durableConsumer", new Object[]{ 
0:                 Boolean.TRUE, 
0:                 Boolean.FALSE});
1:     }
1:     
0:     public void testTopicRetroactiveConsumerSeeMessagesBeforeCreation() throws Throwable {
1:                 
1:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         connectionInfo1.setClientId("A");
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
1:         // Send the messages
1:         Message m = createMessage(producerInfo1, destination, deliveryMode);
1:         connection1.send(m);
1:         
1:         // Create the durable subscription.
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
0:         if( durableConsumer ) {
0:             consumerInfo1.setSubcriptionName("test");
1:         }
1:         consumerInfo1.setPrefetchSize(100);
1:         consumerInfo1.setRetroactive(true);
1:         connection1.send(consumerInfo1);
1:         
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         
0:         if( deliveryMode == DeliveryMode.NON_PERSISTENT && durableConsumer ) {
0:             // Durable subs don't keep non persistent messages around!
0:             for( int i=0; i < 2 ; i++ ) {
1:                 Message m2 = receiveMessage(connection1);
1:                 assertNotNull(m2);
1:             }
1:             
0:         } else {
1:             
0:             // Subscription should see all messages sent.
1:             Message m2 = receiveMessage(connection1);
1:             assertNotNull(m2);
1:             assertEquals(m.getMessageId(), m2.getMessageId());
0:             for( int i=0; i < 2 ; i++ ) {
1:                 m2 = receiveMessage(connection1);
1:                 assertNotNull(m2);
1:             }
1:             
1:         }
1:         
1:         assertNoMessagesLeft(connection1);
1:     }
1: 
0:     public void initCombosForTestTempDestinationsRemovedOnConnectionClose() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }
1:     
0:     public void testTempDestinationsRemovedOnConnectionClose() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
1:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1:         
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(producerInfo2);
1: 
0:         // Send from connection2 to connection1's temp destination.  Should succeed.
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         // Close connection 1
1:         connection1.request(closeConnectionInfo(connectionInfo1));
1:         
0:         try {
0:             // Send from connection2 to connection1's temp destination.  Should not succeed.
1:             connection2.request(createMessage(producerInfo2, destination, deliveryMode));
0:             fail("Expected JMSException.");
0:         } catch ( JMSException success ) {
1:         }
1:         
1:     }
1: 
0:     public void initCombosForTestTempDestinationsAreNotAutoCreated() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }
1:     
0:     public void testTempDestinationsAreNotAutoCreated() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
0:         destination = ActiveMQDestination.createDestination(connectionInfo1.getConnectionId()+":1", destinationType); 
1:             
0:         // Should not be able to send to a non-existant temp destination.
0:         try {
1:             connection1.request(createMessage(producerInfo1, destination, deliveryMode));
0:             fail("Expected JMSException.");
0:         } catch ( JMSException success ) {
1:         }
1:         
1:     }
1:     
0:     public void initCombosForTestTempDestinationsOnlyAllowsLocalConsumers() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }
1:     
0:     public void testTempDestinationsOnlyAllowsLocalConsumers() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1: 
0:         DestinationInfo destinationInfo = createTempDestinationInfo(connectionInfo1, destinationType);
0:         connection1.request(destinationInfo);
0:         destination = destinationInfo.getDestination();
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         
0:         // Only consumers local to the temp destination should be allowed to subscribe. 
0:         try {
1:             ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:             connection2.request(consumerInfo2);
0:             fail("Expected JMSException.");
0:         } catch ( JMSException success ) {
1:         }
1:         
0:         // This should succeed since it's local.
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         connection1.send(consumerInfo1);
1:     }
1: 
0:     public void initCombosForTestExclusiveQueueDeliversToOnlyOneConsumer() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }
0:     public void testExclusiveQueueDeliversToOnlyOneConsumer() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(1);
1:         consumerInfo1.setExclusive(true);
1:         connection1.send(consumerInfo1);
1:         
1:         // Send a message.. this should make consumer 1 the exclusive owner.
1:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
1:         consumerInfo2.setExclusive(true);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.request(consumerInfo2);
1:         
0:         // Second message should go to consumer 1 even though consumer 2 is ready 
1:         // for dispatch.
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1: 
0:         // Acknowledge the first 2 messages 
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1); 
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         // Close the first consumer.
1:         connection1.send(closeConsumerInfo(consumerInfo1));
1: 
1:         // The last two messages should now go the the second consumer.
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection2);
1:             assertNotNull(m1); 
1:             connection2.send(createAck(consumerInfo2, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
0:     public void initCombosForTestWildcardConsume() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE)} );
1:     }   
1:     
0:     public void testWildcardConsume() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         // setup the wildcard consumer.
0:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("WILD.*.TEST", destinationType);
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, compositeDestination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1: 
1:         // These two message should NOT match the wild card.
0:         connection1.send(createMessage(producerInfo1, ActiveMQDestination.createDestination("WILD.CARD", destinationType), deliveryMode));
0:         connection1.send(createMessage(producerInfo1, ActiveMQDestination.createDestination("WILD.TEST", destinationType), deliveryMode));
1: 
1:         // These two message should match the wild card.
1:         ActiveMQDestination d1 = ActiveMQDestination.createDestination("WILD.CARD.TEST", destinationType);
1:         connection1.send(createMessage(producerInfo1, d1, deliveryMode));
0:         ActiveMQDestination d2 = ActiveMQDestination.createDestination("WILD.FOO.TEST", destinationType);
0:         connection1.send(createMessage(producerInfo1, d2, deliveryMode));
1: 
1:         Message m = receiveMessage(connection1);
1:         assertNotNull(m);
0:         assertEquals(d1,m.getDestination());
1:         m = receiveMessage(connection1);
1:         assertNotNull(m);
0:         assertEquals(d2,m.getDestination());
1: 
1:         assertNoMessagesLeft(connection1);        
1:         connection1.send(closeConnectionInfo(connectionInfo1));
1:     }
1: 
0:     public void initCombosForTestCompositeConsume() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE)} );
1:     }   
1:     
0:     public void testCompositeConsume() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         // setup the composite consumer.
0:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("A,B", destinationType);
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, compositeDestination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1: 
1:         // Publish to the two destinations
1:         ActiveMQDestination destinationA = ActiveMQDestination.createDestination("A", destinationType);
1:         ActiveMQDestination destinationB = ActiveMQDestination.createDestination("B", destinationType);
1: 
1:         // Send a message to each destination .
1:         connection1.send(createMessage(producerInfo1, destinationA, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destinationB, deliveryMode));
1: 
1:         // The consumer should get both messages.
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:         }
1: 
1:         assertNoMessagesLeft(connection1);        
1:         connection1.send(closeConnectionInfo(connectionInfo1));
1:     }
1: 
0:     public void initCombosForTestCompositeSend() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE)} );
1:     }   
1:     
0:     public void testCompositeSend() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         
1:         ActiveMQDestination destinationA = ActiveMQDestination.createDestination("A", destinationType);
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destinationA);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1: 
1:         ActiveMQDestination destinationB = ActiveMQDestination.createDestination("B", destinationType);
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destinationB);
1:         consumerInfo2.setPrefetchSize(100);
1:         connection2.send(consumerInfo2);
1: 
1:         // Send the messages to the composite destination.
0:         ActiveMQDestination compositeDestination = ActiveMQDestination.createDestination("A,B", destinationType);
0:         for( int i=0; i < 4 ; i++ ) {
0:             connection1.send(createMessage(producerInfo1, compositeDestination, deliveryMode));
1:         }
1: 
0:         // The messages should have been delivered to both the A and B destination.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             Message m2 = receiveMessage(connection2);
1: 
1:             assertNotNull(m1);
1:             assertNotNull(m2);
1:             
0:             assertEquals( m1.getMessageId(), m2.getMessageId() );
0:             assertEquals( compositeDestination, m1.getOriginalDestination());
0:             assertEquals( compositeDestination, m2.getOriginalDestination());
1:             
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
0:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.STANDARD_ACK_TYPE));
1: 
1:         }
1: 
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:         
1:         connection1.send(closeConnectionInfo(connectionInfo1));
1:         connection2.send(closeConnectionInfo(connectionInfo2));
1:     }
1: 
0:     public void initCombosForTestConnectionCloseCascades() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destination", new Object[]{ 
0:                 new ActiveMQTopic("TEST"), 
0:                 new ActiveMQQueue("TEST")} );
1:     }   
1:     
0:     public void testConnectionCloseCascades() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         consumerInfo1.setNoLocal(true);
1:         connection1.request(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(producerInfo2);
1:         
1:         // Send the messages
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         // Close the connection, this should in turn close the consumer.
1:         connection1.request(closeConnectionInfo(connectionInfo1));
1:         
1:         // Send another message, connection1 should not get the message.
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         assertNull(connection1.getDispatchQueue().poll(MAX_WAIT, TimeUnit.MILLISECONDS));
1:     }
1:     
0:     public void initCombosForTestSessionCloseCascades() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destination", new Object[]{ 
0:                 new ActiveMQTopic("TEST"), 
0:                 new ActiveMQQueue("TEST")} );
1:     }   
1:     
0:     public void testSessionCloseCascades() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         consumerInfo1.setNoLocal(true);
1:         connection1.request(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(producerInfo2);
1:         
1:         // Send the messages
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         // Close the session, this should in turn close the consumer.
1:         connection1.request(closeSessionInfo(sessionInfo1));
1:         
1:         // Send another message, connection1 should not get the message.
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         assertNull(connection1.getDispatchQueue().poll(MAX_WAIT, TimeUnit.MILLISECONDS));
1:     }
1:     
0:     public void initCombosForTestConsumerClose() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destination", new Object[]{ 
0:                 new ActiveMQTopic("TEST"), 
0:                 new ActiveMQQueue("TEST")} );
1:     }   
1:     
0:     public void testConsumerClose() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         consumerInfo1.setNoLocal(true);
1:         connection1.request(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(producerInfo2);
1:         
1:         // Send the messages
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         // Close the consumer.
1:         connection1.request(closeConsumerInfo(consumerInfo1));
1:         
1:         // Send another message, connection1 should not get the message.
1:         connection2.send(createMessage(producerInfo2, destination, deliveryMode));
1:         
0:         assertNull(connection1.getDispatchQueue().poll(MAX_WAIT, TimeUnit.MILLISECONDS));
1:     }
0:     public void initCombosForTestTopicNoLocal() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }   
1:     
0:     public void testTopicNoLocal() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         consumerInfo1.setNoLocal(true);
1:         connection1.send(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(producerInfo2);
1:         
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(100);
0:         consumerInfo2.setNoLocal(true);        
1:         connection2.send(consumerInfo2);
1: 
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         
1:         // The 2nd connection should get the messages.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection2);
1:             assertNotNull(m1);
1:         }
1:         
1:         // Send a message with the 2nd connection
1:         Message message = createMessage(producerInfo2, destination, deliveryMode);
1:         connection2.send(message);
1:         
0:         // The first connection should not see the initial 4 local messages sent but should 
1:         // see the messages from connection 2.
1:         Message m = receiveMessage(connection1);
1:         assertNotNull(m);
1:         assertEquals(message.getMessageId(), m.getMessageId());
1:         
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1: 
1:     
0:     public void setUpTopicDispatchIsBroadcast() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }   
1:     
0:     public void testTopicDispatchIsBroadcast() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQTopic("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo1);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(100);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(consumerInfo2);
1: 
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo1, destination, deliveryMode));
1:         
1:         // Get the messages
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:             m1 = receiveMessage(connection2);
1:             assertNotNull(m1);   
1:         }        
1:     }
1:     
0:     public void initCombosForTestQueueDispatchedAreRedeliveredOnConsumerClose() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 } );
1:     }   
1:     
0:     public void testQueueDispatchedAreRedeliveredOnConsumerClose() throws Throwable {
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(100);
1:         connection1.send(consumerInfo1);
1:         
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Get the messages
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);
1:             assertFalse(m1.isRedelivered());
1:         }
1:         // Close the consumer without sending any ACKS.
1:         connection1.send(closeConsumerInfo(consumerInfo1));
1: 
1:         // Drain any in flight messages..
0:         while(connection1.getDispatchQueue().poll(0, TimeUnit.MILLISECONDS)!=null){
1:         }
1: 
1:         // Add the second consumer
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo2.setPrefetchSize(100);
1:         connection1.send(consumerInfo2);
1: 
1:         // Make sure the messages were re delivered to the 2nd consumer.
0:         for( int i=0; i < 4 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             assertNotNull(m1);   
1:             assertTrue(m1.isRedelivered());
1:         }        
1:     }
1:     
0:     public void initCombosForTestQueueBrowseMessages() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 } );
1:     }   
0:     public void testQueueBrowseMessages() throws Throwable {
1:                 
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1: 
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Use selector to skip first message.
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setBrowser(true);
1:         connection.send(consumerInfo);
1:         
0:         for( int i=0; i < 4; i++ ) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m); 
1:             connection.send(createAck(consumerInfo, m, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection);
1:     }
1: 
0:     public void initCombosForTestQueuBrowserWith2Consumers() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }   
1:     
0:     public void testQueueBrowserWith2Consumers() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(1);
1:         connection1.send(consumerInfo1);
1:         
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1: 
0:         // Setup a second connection with a queue browser.
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
0:         consumerInfo2.setBrowser(true);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(consumerInfo2);
1: 
0:         for( int i=0; i < 4; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             Message m2 = receiveMessage(connection2);
0:             assertNotNull("m1 is null for index: " + i, m1); 
0:             assertNotNull("m2 is null for index: " + i, m2);  
0:             assertEquals(m1.getMessageId(), m2.getMessageId());
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
0:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1:      
0:     public void initCombosForTestQueueOnlyOnceDeliveryWith2Consumers() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
1:     }   
0:     public void testQueueOnlyOnceDeliveryWith2Consumers() throws Throwable {
1:         
1:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup a first connection
1:         StubConnection connection1 = createConnection();
1:         ConnectionInfo connectionInfo1 = createConnectionInfo();
1:         SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo1);
1:         connection1.send(connectionInfo1);
1:         connection1.send(sessionInfo1);
1:         connection1.send(producerInfo);
1: 
1:         ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
1:         consumerInfo1.setPrefetchSize(1);
1:         connection1.send(consumerInfo1);
1: 
0:         // Setup a second connection 
1:         StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
0:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);        
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         connection2.send(consumerInfo2);
1:         
1:         // Send the messages
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection1.send(createMessage(producerInfo, destination, deliveryMode));
1:         
0:         for( int i=0; i < 2 ; i++ ) {
1:             Message m1 = receiveMessage(connection1);
1:             Message m2 = receiveMessage(connection2);
1:             
0:             assertNotNull("m1 is null for index: " + i, m1); 
0:             assertNotNull("m2 is null for index: " + i, m2);  
1: 
0:             assertNotSame(m1.getMessageId(), m2.getMessageId());
1:             connection1.send(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
0:             connection2.send(createAck(consumerInfo2, m2, 1, MessageAck.STANDARD_ACK_TYPE));
1:         }
1:         
1:         assertNoMessagesLeft(connection1);
1:         assertNoMessagesLeft(connection2);
1:     }
1:     
0:     public void initCombosForTestQueueSendThenAddConsumer() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 } );
1:     }   
0:     public void testQueueSendThenAddConsumer() throws Throwable {
1:         
1:         // Start a producer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         // Send a message to the broker.
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Start the consumer
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);        
1:         connection.send(consumerInfo);
1: 
1:         // Make sure the message was delivered.
1:         Message m = receiveMessage(connection);
1:         assertNotNull(m);
1:         
1:     }
1:     
0:     public void initCombosForTestQueueAckRemovesMessage() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 } );
1:     }
1:     
0:     public void testQueueAckRemovesMessage() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         Message message1 = createMessage(producerInfo, destination, deliveryMode);
1:         Message message2 = createMessage(producerInfo, destination, deliveryMode);
1:         connection.send(message1);
1:         connection.send(message2);
1:         
1:         // Make sure the message was delivered.
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);        
1:         connection.request(consumerInfo);
1:         Message m = receiveMessage(connection);
0:         assertNotNull(m); assertEquals(m.getMessageId(), message1.getMessageId());
1:         
0:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination)==2);
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.DELIVERED_ACK_TYPE));
0:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination)==2);
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
0:         assertTrue(countMessagesInQueue(connection, connectionInfo, destination)==1);
1:         
1:     }
1: 
0:     public void initCombosForTestSelectorSkipsMessages() {    
0:         addCombinationValues( "destination", new Object[]{ 
0:             new ActiveMQTopic("TEST_TOPIC"), 
0:             new ActiveMQQueue("TEST_QUEUE")} );
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }
1:     
0:     public void testSelectorSkipsMessages() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1: 
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSelector("JMSType='last'");
1:         connection.send(consumerInfo);
1:         
1:         Message message1 = createMessage(producerInfo, destination, deliveryMode);
1:         message1.setType("first");
1:         Message message2 = createMessage(producerInfo, destination, deliveryMode);
1:         message2.setType("last");
1:         connection.send(message1);
1:         connection.send(message2);
1:         
1:         // Use selector to skip first message.
1:         Message m = receiveMessage(connection);
0:         assertNotNull(m); assertEquals(m.getMessageId(), message2.getMessageId());
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         connection.send(closeConsumerInfo(consumerInfo));
1:         
1:         assertNoMessagesLeft(connection);
1:     }
1:     
0:     public void initCombosForTestAddConsumerThenSend() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }
1:     
0:     public void testAddConsumerThenSend() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);        
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1: 
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);        
1:         connection.send(consumerInfo);
1:         
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Make sure the message was delivered.
1:         Message m = receiveMessage(connection);
1:         assertNotNull(m);
1:     }
1: 
0:     public void initCombosForTestConsumerPrefetchAtOne() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }    
1:     
0:     public void testConsumerPrefetchAtOne() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1: 
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);  
1:         consumerInfo.setPrefetchSize(1);
1:         connection.send(consumerInfo);
1:         
1:         // Send 2 messages to the broker.
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Make sure only 1 message was delivered.
1:         Message m = receiveMessage(connection);
1:         assertNotNull(m);
1:         assertNoMessagesLeft(connection);
1:         
1:     }
1:     
0:     public void initCombosForTestConsumerPrefetchAtTwo() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }    
1: 
0:     public void testConsumerPrefetchAtTwo() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);        
1:         consumerInfo.setPrefetchSize(2);
1:         connection.send(consumerInfo);
1:         
1:         // Send 3 messages to the broker.
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Make sure only 1 message was delivered.
1:         Message m = receiveMessage(connection);
1:         assertNotNull(m);
1:         m = receiveMessage(connection);
1:         assertNotNull(m);
1:         assertNoMessagesLeft(connection);
1:         
1:     }
1:     
0:     public void initCombosForTestConsumerPrefetchAndDeliveredAck() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:             new Integer(DeliveryMode.NON_PERSISTENT), 
0:             new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
1:     }
1:     
0:     public void testConsumerPrefetchAndDeliveredAck() throws Throwable {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);        
1:         consumerInfo.setPrefetchSize(1);
1:         connection.send(consumerInfo);
1:         
1:         // Send 3 messages to the broker.
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         connection.send(createMessage(producerInfo, destination, deliveryMode));
1:         
1:         // Make sure only 1 message was delivered.
1:         Message m1 = receiveMessage(connection);
1:         assertNotNull(m1);
1:         
1:         assertNoMessagesLeft(connection);
1:         
0:         // Acknowledge the first message.  This should cause the next message to get dispatched.
0:         connection.send(createAck(consumerInfo, m1, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         
1:         Message m2 = receiveMessage(connection);
1:         assertNotNull(m2);
0:         connection.send(createAck(consumerInfo, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         
1:         Message m3 = receiveMessage(connection);
0:         assertNotNull(m3);        
0:         connection.send(createAck(consumerInfo, m3, 1, MessageAck.DELIVERED_ACK_TYPE));
1:     }
1: 
1:     public static Test suite() {
1:         return suite(BrokerTest.class);
1:     }
1:     
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:33724ec
/////////////////////////////////////////////////////////////////////////
0:     
commit:7882eb7
/////////////////////////////////////////////////////////////////////////
1:     protected static final int MAX_NULL_WAIT=500;
/////////////////////////////////////////////////////////////////////////
1:         connection1.request(consumerInfo1);
/////////////////////////////////////////////////////////////////////////
1:         connection2.request(consumerInfo2);
1:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
/////////////////////////////////////////////////////////////////////////
1:         //as the messages are sent async - need to synchronize the last
1:         //one to ensure they arrive in the order we want
1:         connection1.request(createMessage(producerInfo, destination, deliveryMode));
/////////////////////////////////////////////////////////////////////////
1:         connection.request(createMessage(producerInfo, destination, deliveryMode));
/////////////////////////////////////////////////////////////////////////
0:        
0:             // Begin the transaction.
0:             LocalTransactionId txid = createLocalTransaction(sessionInfo1);
0:             connection1.send(createBeginTransaction(connectionInfo1, txid));
0:          // Commit the transaction.
0:             connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));
/////////////////////////////////////////////////////////////////////////
1:             connection1.request(message);
1:         assertNull(receiveMessage(connection1,MAX_NULL_WAIT));
/////////////////////////////////////////////////////////////////////////
1:         connection1.request(createMessage(producerInfo1, destination, DeliveryMode.PERSISTENT));
/////////////////////////////////////////////////////////////////////////
1:         connection1.request(closeConsumerInfo(consumerInfo1));
1:             connection2.request(createAck(consumerInfo2, m1, 1, MessageAck.STANDARD_ACK_TYPE));
/////////////////////////////////////////////////////////////////////////
0:         connection1.request(createMessage(producerInfo1, destination, deliveryMode));
/////////////////////////////////////////////////////////////////////////
0:         connection1.request(createMessage(producerInfo1, d2, deliveryMode));
/////////////////////////////////////////////////////////////////////////
0:         connection1.request(consumerInfo1);
/////////////////////////////////////////////////////////////////////////
0:         connection2.request(consumerInfo2);
1:             connection1.request(createMessage(producerInfo1, compositeDestination, deliveryMode));
/////////////////////////////////////////////////////////////////////////
1:             connection1.request(createAck(consumerInfo1, m1, 1, MessageAck.STANDARD_ACK_TYPE));
1:             connection2.request(createAck(consumerInfo2, m2, 1, MessageAck.STANDARD_ACK_TYPE));
/////////////////////////////////////////////////////////////////////////
1:         connection2.request(createMessage(producerInfo2, destination, deliveryMode));
0:         assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
1:         connection2.request(createMessage(producerInfo2, destination, deliveryMode));
0:         assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
0:         connection2.request(createMessage(producerInfo2, destination, deliveryMode));
0:         assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
1:         connection.request(consumerInfo);
1:         connection.request(createMessage(producerInfo, destination, deliveryMode));
/////////////////////////////////////////////////////////////////////////
1:         connection.request(createAck(consumerInfo, m1, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         connection.request(createAck(consumerInfo, m2, 1, MessageAck.DELIVERED_ACK_TYPE));
1:         connection.request(createAck(consumerInfo, m3, 1, MessageAck.DELIVERED_ACK_TYPE));
commit:6f66aa0
/////////////////////////////////////////////////////////////////////////
0:         //assertEquals(d1, m.getDestination());
0:         //assertNotNull(m);
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0: //                Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0: //                Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0: //                Integer.valueOf(DeliveryMode.PERSISTENT)} );
0: //                Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0: //                Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0: //                Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0: //                Integer.valueOf(DeliveryMode.PERSISTENT)} );
0: //                Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0: //                Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
/////////////////////////////////////////////////////////////////////////
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
/////////////////////////////////////////////////////////////////////////
0:             Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:             Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
commit:eeafa1c
/////////////////////////////////////////////////////////////////////////
0:         connection1.request(closeConnectionInfo(connectionInfo1));
/////////////////////////////////////////////////////////////////////////
0:         connection1.request(consumerInfo1);
/////////////////////////////////////////////////////////////////////////
0:         connection2.request(consumerInfo2);
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0: //
0: //  TODO: need to reimplement this since we don't fail when we send to a non-existant
0: //  destination.  But if we can access the Region directly then we should be able to
0: //  check that if the destination was removed.
0: // 
0: //    public void initCombosForTestTempDestinationsRemovedOnConnectionClose() {    
0: //        addCombinationValues( "deliveryMode", new Object[]{ 
0: //                new Integer(DeliveryMode.NON_PERSISTENT), 
0: //                new Integer(DeliveryMode.PERSISTENT)} );
0: //        addCombinationValues( "destinationType", new Object[]{ 
0: //                new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0: //                new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
0: //    }
0: //    
0: //    public void testTempDestinationsRemovedOnConnectionClose() throws Exception {
0: //        
0: //        // Setup a first connection
0: //        StubConnection connection1 = createConnection();
0: //        ConnectionInfo connectionInfo1 = createConnectionInfo();
0: //        SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
0: //        ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
0: //        connection1.send(connectionInfo1);
0: //        connection1.send(sessionInfo1);
0: //        connection1.send(producerInfo1);
0: //
0: //        destination = createDestinationInfo(connection1, connectionInfo1, destinationType);
0: //        
0: //        StubConnection connection2 = createConnection();
0: //        ConnectionInfo connectionInfo2 = createConnectionInfo();
0: //        SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
0: //        ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
0: //        connection2.send(connectionInfo2);
0: //        connection2.send(sessionInfo2);
0: //        connection2.send(producerInfo2);
0: //
0: //        // Send from connection2 to connection1's temp destination.  Should succeed.
0: //        connection2.send(createMessage(producerInfo2, destination, deliveryMode));
0: //        
0: //        // Close connection 1
0: //        connection1.request(closeConnectionInfo(connectionInfo1));
0: //        
0: //        try {
0: //            // Send from connection2 to connection1's temp destination.  Should not succeed.
0: //            connection2.request(createMessage(producerInfo2, destination, deliveryMode));
0: //            fail("Expected JMSException.");
0: //        } catch ( JMSException success ) {
0: //        }
0: //        
0: //    }
0: //    public void initCombosForTestTempDestinationsAreNotAutoCreated() {    
0: //        addCombinationValues( "deliveryMode", new Object[]{ 
0: //                new Integer(DeliveryMode.NON_PERSISTENT), 
0: //                new Integer(DeliveryMode.PERSISTENT)} );
0: //        addCombinationValues( "destinationType", new Object[]{ 
0: //                new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0: //                new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)} );
0: //    }
0: //    
0: //   
0:     
0:     
0: //  We create temp destination on demand now so this test case is no longer 
0: //  valid.
0: //    
0: //    public void testTempDestinationsAreNotAutoCreated() throws Exception {
0: //        
0: //        // Setup a first connection
0: //        StubConnection connection1 = createConnection();
0: //        ConnectionInfo connectionInfo1 = createConnectionInfo();
0: //        SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
0: //        ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
0: //        connection1.send(connectionInfo1);
0: //        connection1.send(sessionInfo1);
0: //        connection1.send(producerInfo1);
0: //
0: //        destination = ActiveMQDestination.createDestination(connectionInfo1.getConnectionId()+":1", destinationType); 
0: //            
0: //        // Should not be able to send to a non-existant temp destination.
0: //        try {
0: //            connection1.request(createMessage(producerInfo1, destination, deliveryMode));
0: //            fail("Expected JMSException.");
0: //        } catch ( JMSException success ) {
0: //        }
0: //        
0: //    }
0: 
0: 
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:e5bbcb5
/////////////////////////////////////////////////////////////////////////
0:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo1.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo1.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo2.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo1.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo2.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTopicDispatchIsBroadcast() {
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo1.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo2.setRetroactive(true);
/////////////////////////////////////////////////////////////////////////
0:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
/////////////////////////////////////////////////////////////////////////
0:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
/////////////////////////////////////////////////////////////////////////
0:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
============================================================================