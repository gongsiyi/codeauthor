1:628add4: /**
1:628add4:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:628add4:  *  contributor license agreements.  See the NOTICE file distributed with
1:628add4:  *  this work for additional information regarding copyright ownership.
1:628add4:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:628add4:  *  (the "License"); you may not use this file except in compliance with
1:628add4:  *  the License.  You may obtain a copy of the License at
1:628add4:  *
1:628add4:  *     http://www.apache.org/licenses/LICENSE-2.0
1:628add4:  *
1:628add4:  *  Unless required by applicable law or agreed to in writing, software
1:628add4:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:628add4:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:628add4:  *  See the License for the specific language governing permissions and
1:628add4:  *  limitations under the License.
1:628add4:  */
1:56a6860: package org.apache.aries.samples.ariestrader.persist.jdbc;
17:628add4: 
1:628add4: import java.math.BigDecimal;
1:628add4: import java.util.Collection;
1:628add4: import java.util.ArrayList;
1:628add4: import javax.sql.DataSource;
1:628add4: 
1:56a6860: import org.apache.aries.samples.ariestrader.api.TradeServices;
1:56a6860: import org.apache.aries.samples.ariestrader.beans.AccountDataBeanImpl;
1:56a6860: import org.apache.aries.samples.ariestrader.beans.AccountProfileDataBeanImpl;
1:56a6860: import org.apache.aries.samples.ariestrader.beans.HoldingDataBeanImpl;
1:56a6860: import org.apache.aries.samples.ariestrader.beans.OrderDataBeanImpl;
1:56a6860: import org.apache.aries.samples.ariestrader.beans.QuoteDataBeanImpl;
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.AccountDataBean;
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.AccountProfileDataBean;
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.HoldingDataBean;
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.MarketSummaryDataBean;
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.OrderDataBean;
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.QuoteDataBean;
1:56a6860: import org.apache.aries.samples.ariestrader.util.FinancialUtils;
1:56a6860: import org.apache.aries.samples.ariestrader.util.Log;
1:a8a9116: import org.apache.aries.samples.ariestrader.util.ServiceUtilities;
1:56a6860: import org.apache.aries.samples.ariestrader.util.TradeConfig;
1:628add4: 
1:628add4: import java.sql.Connection;
1:628add4: import java.sql.PreparedStatement;
1:628add4: import java.sql.ResultSet;
1:628add4: import java.sql.Timestamp;
1:628add4: 
1:628add4: 
1:628add4: /**
1:af24676:  * TradeJdbc uses direct JDBC access to a
1:628add4:  * <code>javax.sql.DataSource</code> to implement the business methods of the
1:628add4:  * Trade online broker application. These business methods represent the
1:628add4:  * features and operations that can be performed by customers of the brokerage
1:628add4:  * such as login, logout, get a stock quote, buy or sell a stock, etc. and are
1:56a6860:  * specified in the {@link org.apache.aries.samples.ariestrader.TradeServices}
1:628add4:  * interface
1:628add4:  * 
1:628add4:  * Note: In order for this class to be thread-safe, a new TradeJDBC must be
1:628add4:  * created for each call to a method from the TradeInterface interface.
1:628add4:  * Otherwise, pooled connections may not be released.
1:628add4:  * 
1:56a6860:  * @see org.apache.aries.samples.ariestrader.TradeServices
1:628add4:  * 
1:628add4:  */
1:628add4: 
1:af24676: public class TradeJdbc implements TradeServices {
1:628add4: 
1:ea52306:     private DataSource dataSource= null;
1:628add4: 
1:628add4:     private static BigDecimal ZERO = new BigDecimal(0.0);
1:628add4: 
1:628add4:     private boolean inGlobalTxn = false;
1:628add4: 
1:628add4:     private boolean inSession = false;
1:628add4: 
1:628add4:     private static int connCount = 0;
1:628add4: 
1:628add4:     private static Integer lock = new Integer(0);
1:628add4: 
1:628add4:     private static boolean initialized = false;
1:628add4: 
1:628add4:     /**
1:af24676:      * Zero arg constructor for TradeJdbc
1:628add4:      */
1:af24676:     public TradeJdbc() {
10:628add4:     }
1:628add4: 
1:af24676:     public TradeJdbc(boolean inSession) {
1:628add4:         this.inSession = inSession;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * set data source
1:628add4:      */
1:628add4:     public void setDataSource(DataSource dataSource) {
1:628add4:             this.dataSource = dataSource;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * setInSession
1:628add4:      */
1:628add4:     public void setInSession(boolean inSession) {
1:628add4:         this.inSession = inSession;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getMarketSummary()
1:628add4:      */
1:628add4:     public MarketSummaryDataBean getMarketSummary() throws Exception {
1:628add4:         MarketSummaryDataBean marketSummaryData = null;
4:628add4:         Connection conn = null;
1:628add4: 
4:628add4:         try {
2:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getMarketSummary - inSession(" + this.inSession + ")");
1:628add4: 
4:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt =
1:628add4:                 getStatement(conn, getTSIAQuotesOrderByChangeSQL, ResultSet.TYPE_SCROLL_INSENSITIVE,
1:628add4:                     ResultSet.CONCUR_READ_ONLY);
1:628add4: 
1:628add4:             ArrayList topGainersData = new ArrayList(5);
1:628add4:             ArrayList topLosersData = new ArrayList(5);
1:628add4: 
2:628add4:             ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:             int count = 0;
1:628add4:             while (rs.next() && (count++ < 5)) {
1:628add4:                 QuoteDataBean quoteData = getQuoteDataFromResultSet(rs);
1:628add4:                 topLosersData.add(quoteData);
1:628add4:             }
1:628add4: 
3:628add4:             stmt.close();
1:628add4:             stmt =
1:628add4:                 getStatement(conn, "select * from quoteejb q where q.symbol like 's:1__' order by q.change1 DESC",
1:628add4:                     ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:628add4:             rs = stmt.executeQuery();
1:628add4: 
1:628add4:             count = 0;
1:628add4:             while (rs.next() && (count++ < 5)) {
1:628add4:                 QuoteDataBean quoteData = getQuoteDataFromResultSet(rs);
1:628add4:                 topGainersData.add(quoteData);
1:628add4:             }
1:628add4: 
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             BigDecimal TSIA = ZERO;
1:628add4:             BigDecimal openTSIA = ZERO;
1:628add4:             double volume = 0.0;
1:628add4: 
1:628add4:             if ((topGainersData.size() > 0) || (topLosersData.size() > 0)) {
1:628add4: 
1:628add4:                 stmt = getStatement(conn, getTSIASQL);
1:628add4:                 rs = stmt.executeQuery();
1:628add4: 
1:628add4:                 if (!rs.next())
1:af24676:                     Log.error("TradeJdbc:getMarketSummary -- error w/ getTSIASQL -- no results");
1:628add4:                 else
1:628add4:                     TSIA = rs.getBigDecimal("TSIA");
1:628add4:                 stmt.close();
1:628add4: 
1:628add4:                 stmt = getStatement(conn, getOpenTSIASQL);
1:628add4:                 rs = stmt.executeQuery();
1:628add4: 
1:628add4:                 if (!rs.next())
1:af24676:                     Log.error("TradeJdbc:getMarketSummary -- error w/ getOpenTSIASQL -- no results");
1:628add4:                 else
1:628add4:                     openTSIA = rs.getBigDecimal("openTSIA");
1:628add4:                 stmt.close();
1:628add4: 
1:628add4:                 stmt = getStatement(conn, getTSIATotalVolumeSQL);
1:628add4:                 rs = stmt.executeQuery();
1:628add4: 
1:628add4:                 if (!rs.next())
1:af24676:                     Log.error("TradeJdbc:getMarketSummary -- error w/ getTSIATotalVolumeSQL -- no results");
1:628add4:                 else
1:628add4:                     volume = rs.getDouble("totalVolume");
1:628add4:                 stmt.close();
1:628add4:             }
4:628add4:             commit(conn);
1:628add4: 
1:628add4:             marketSummaryData = new MarketSummaryDataBean(TSIA, openTSIA, volume, topGainersData, topLosersData);
1:628add4: 
1:628add4:         }
1:628add4: 
1:628add4:         catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getMarketSummary -- error getting summary", e);
4:628add4:             rollBack(conn, e);
4:628add4:         } finally {
4:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return marketSummaryData;
1:628add4: 
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#buy(String, String, double)
1:628add4:      */
1:628add4:     public OrderDataBean buy(String userID, String symbol, double quantity, int orderProcessingMode) throws Exception {
1:628add4: 
1:628add4:         Connection conn = null;
4:628add4:         OrderDataBean orderData = null;
1:628add4: 
1:628add4:         /*
1:628add4:          * total = (quantity * purchasePrice) + orderFee
1:628add4:          */
1:628add4:         BigDecimal total;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:buy - inSession(" + this.inSession + ")", userID, symbol, new Double(quantity));
1:628add4: 
1:628add4:             conn = getConn();
1:628add4: 
1:628add4:             AccountDataBean accountData = getAccountData(conn, userID);
1:628add4:             QuoteDataBean quoteData = getQuoteData(conn, symbol);
1:628add4:             HoldingDataBean holdingData = null; // the buy operation will create
1:628add4:             // the holding
1:628add4: 
1:628add4:             orderData = createOrder(conn, accountData, quoteData, holdingData, "buy", quantity);
1:628add4: 
1:628add4:             // Update -- account should be credited during completeOrder
1:628add4:             BigDecimal price = quoteData.getPrice();
1:628add4:             BigDecimal orderFee = orderData.getOrderFee();
1:628add4:             total = (new BigDecimal(quantity).multiply(price)).add(orderFee);
1:628add4:             // subtract total from account balance
1:628add4:             creditAccountBalance(conn, accountData, total.negate());
1:628add4: 
1:628add4:             completeOrder(conn, orderData.getOrderID());
1:628add4: 
1:628add4:             orderData = getOrderData(conn, orderData.getOrderID().intValue());
1:628add4: 
1:628add4:             commit(conn);
1:628add4: 
4:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:buy error - rolling back", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4: 
1:b8c0170:         //after the purchase or sale of a stock, update the stocks volume and
1:628add4:         // price
1:628add4:         updateQuotePriceVolume(symbol, TradeConfig.getRandomPriceChangeFactor(), quantity);
1:628add4: 
2:628add4:         return orderData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#sell(String, Integer)
1:628add4:      */
1:628add4:     public OrderDataBean sell(String userID, Integer holdingID, int orderProcessingMode) throws Exception {
1:628add4: 
1:628add4:         Connection conn = null;
1:628add4:         OrderDataBean orderData = null;
1:628add4: 
1:628add4:         /*
1:628add4:          * total = (quantity * purchasePrice) + orderFee
1:628add4:          */
1:628add4:         BigDecimal total;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:sell - inSession(" + this.inSession + ")", userID, holdingID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4: 
1:628add4:             AccountDataBean accountData = getAccountData(conn, userID);
1:628add4:             HoldingDataBean holdingData = getHoldingData(conn, holdingID.intValue());
2:628add4:             QuoteDataBean quoteData = null;
1:628add4:             if (holdingData != null)
1:628add4:                 quoteData = getQuoteData(conn, holdingData.getQuoteID());
1:628add4: 
1:628add4:             if ((accountData == null) || (holdingData == null) || (quoteData == null)) {
1:628add4:                 String error =
1:af24676:                     "TradeJdbc:sell -- error selling stock -- unable to find:  \n\taccount=" + accountData
1:628add4:                         + "\n\tholding=" + holdingData + "\n\tquote=" + quoteData + "\nfor user: " + userID
1:628add4:                         + " and holdingID: " + holdingID;
1:628add4:                 Log.error(error);
1:628add4:                 rollBack(conn, new Exception(error));
1:628add4: 
1:628add4:                 return orderData;
1:628add4:             }
1:628add4: 
1:628add4:             double quantity = holdingData.getQuantity();
1:628add4: 
1:628add4:             orderData = createOrder(conn, accountData, quoteData, holdingData, "sell", quantity);
1:628add4: 
1:628add4:             // Set the holdingSymbol purchaseDate to selling to signify the sell
1:628add4:             // is "inflight"
1:628add4:             updateHoldingStatus(conn, holdingData.getHoldingID(), holdingData.getQuoteID());
1:628add4: 
1:628add4:             // UPDATE -- account should be credited during completeOrder
1:628add4:             BigDecimal price = quoteData.getPrice();
1:628add4:             BigDecimal orderFee = orderData.getOrderFee();
1:628add4:             total = (new BigDecimal(quantity).multiply(price)).subtract(orderFee);
1:628add4:             creditAccountBalance(conn, accountData, total);
1:628add4: 
1:628add4:             completeOrder(conn, orderData.getOrderID());
1:628add4: 
1:628add4:             orderData = getOrderData(conn, orderData.getOrderID().intValue());
1:628add4: 
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:sell error", e);
1:628add4:             rollBack(conn, e);
1:628add4: 
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4: 
1:628add4:         if (!(orderData.getOrderStatus().equalsIgnoreCase("cancelled")))
1:628add4:             //after the purchase or sell of a stock, update the stocks volume
1:628add4:             // and price
1:628add4:             updateQuotePriceVolume(orderData.getSymbol(), TradeConfig.getRandomPriceChangeFactor(), orderData.getQuantity());
1:628add4: 
1:628add4:         return orderData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#queueOrder(Integer)
1:628add4:      */
1:628add4:     public void queueOrder(Integer orderID, boolean twoPhase) throws Exception {
1:628add4:         throw new RuntimeException("TradeServices#queueOrder(Integer) is not supported in this runtime mode");
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#completeOrder(Integer)
1:628add4:      */
1:628add4:     public OrderDataBean completeOrder(Integer orderID, boolean twoPhase) throws Exception {
1:628add4:         OrderDataBean orderData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try { // twoPhase
1:628add4: 
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:completeOrder - inSession(" + this.inSession + ")", orderID);
1:628add4:             setInGlobalTxn(!inSession && twoPhase);
1:628add4:             conn = getConn();
1:628add4:             orderData = completeOrder(conn, orderID);
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:completeOrder -- error completing order", e);
1:628add4:             rollBack(conn, e);
1:628add4:             cancelOrder(orderID, twoPhase);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4: 
1:628add4:         return orderData;
1:628add4: 
1:628add4:     }
1:628add4: 
1:628add4:     private OrderDataBean completeOrder(Connection conn, Integer orderID) throws Exception {
1:628add4: 
1:628add4:         OrderDataBean orderData = null;
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:completeOrderInternal - inSession(" + this.inSession + ")", orderID);
1:628add4: 
1:628add4:         PreparedStatement stmt = getStatement(conn, getOrderSQL);
1:628add4:         stmt.setInt(1, orderID.intValue());
1:628add4: 
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:         if (!rs.next()) {
1:af24676:             Log.error("TradeJdbc:completeOrder -- unable to find order: " + orderID);
1:628add4:             stmt.close();
1:628add4:             return orderData;
1:628add4:         }
1:628add4:         orderData = getOrderDataFromResultSet(rs);
1:628add4: 
1:628add4:         String orderType = orderData.getOrderType();
1:628add4:         String orderStatus = orderData.getOrderStatus();
1:628add4: 
1:628add4:         // if (order.isCompleted())
1:628add4:         if ((orderStatus.compareToIgnoreCase("completed") == 0)
1:628add4:             || (orderStatus.compareToIgnoreCase("alertcompleted") == 0)
1:628add4:             || (orderStatus.compareToIgnoreCase("cancelled") == 0))
1:af24676:             throw new Exception("TradeJdbc:completeOrder -- attempt to complete Order that is already completed");
1:628add4: 
1:628add4:         int accountID = rs.getInt("account_accountID");
1:628add4:         String quoteID = rs.getString("quote_symbol");
1:628add4:         int holdingID = rs.getInt("holding_holdingID");
1:628add4: 
1:628add4:         BigDecimal price = orderData.getPrice();
1:628add4:         double quantity = orderData.getQuantity();
1:628add4:         BigDecimal orderFee = orderData.getOrderFee();
1:628add4: 
1:628add4:         // get the data for the account and quote
1:628add4:         // the holding will be created for a buy or extracted for a sell
1:628add4: 
1:628add4:         /*
1:628add4:          * Use the AccountID and Quote Symbol from the Order AccountDataBean accountData = getAccountData(accountID,
1:628add4:          * conn); QuoteDataBean quoteData = getQuoteData(conn, quoteID);
1:628add4:          */
1:628add4:         String userID = getAccountProfileData(conn, new Integer(accountID)).getUserID();
1:628add4: 
2:628add4:         HoldingDataBean holdingData = null;
1:628add4: 
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:completeOrder--> Completing Order " + orderData.getOrderID() + "\n\t Order info: "
1:628add4:                 + orderData + "\n\t Account info: " + accountID + "\n\t Quote info: " + quoteID);
1:628add4: 
1:628add4:         // if (order.isBuy())
1:628add4:         if (orderType.compareToIgnoreCase("buy") == 0) {
1:628add4:             /*
1:628add4:              * Complete a Buy operation - create a new Holding for the Account - deduct the Order cost from the Account
1:628add4:              * balance
1:628add4:              */
1:628add4: 
1:628add4:             holdingData = createHolding(conn, accountID, quoteID, quantity, price);
1:628add4:             updateOrderHolding(conn, orderID.intValue(), holdingData.getHoldingID().intValue());
1:628add4:         }
1:628add4: 
1:628add4:         // if (order.isSell()) {
1:628add4:         if (orderType.compareToIgnoreCase("sell") == 0) {
1:628add4:             /*
1:628add4:              * Complete a Sell operation - remove the Holding from the Account - deposit the Order proceeds to the
1:628add4:              * Account balance
1:628add4:              */
1:628add4:             holdingData = getHoldingData(conn, holdingID);
1:628add4:             if (holdingData == null)
1:af24676:                 Log.debug("TradeJdbc:completeOrder:sell -- user: " + userID + " already sold holding: " + holdingID);
1:628add4:             else
1:628add4:                 removeHolding(conn, holdingID, orderID.intValue());
1:628add4: 
1:628add4:         }
1:628add4: 
1:628add4:         updateOrderStatus(conn, orderData.getOrderID(), "closed");
1:628add4: 
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:completeOrder--> Completed Order " + orderData.getOrderID() + "\n\t Order info: "
1:628add4:                 + orderData + "\n\t Account info: " + accountID + "\n\t Quote info: " + quoteID + "\n\t Holding info: "
1:628add4:                 + holdingData);
1:628add4: 
1:628add4:         stmt.close();
1:628add4: 
1:628add4:         commit(conn);
1:628add4: 
1:628add4:         // signify this order for user userID is complete
1:628add4:         orderCompleted(userID, orderID);
1:628add4: 
1:628add4:         return orderData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#cancelOrder(Integer, boolean)
1:628add4:      */
1:628add4:     public void cancelOrder(Integer orderID, boolean twoPhase) throws Exception {
1:628add4:         Connection conn = null;
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:cancelOrder - inSession(" + this.inSession + ")", orderID);
1:628add4:             setInGlobalTxn(!inSession && twoPhase);
1:628add4:             conn = getConn();
1:628add4:             cancelOrder(conn, orderID);
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:cancelOrder -- error cancelling order: " + orderID, e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     private void cancelOrder(Connection conn, Integer orderID) throws Exception {
1:628add4:         updateOrderStatus(conn, orderID, "cancelled");
1:628add4:     }
1:628add4: 
1:628add4:     public void orderCompleted(String userID, Integer orderID) throws Exception {
1:af24676: //        throw new UnsupportedOperationException("TradeJdbc:orderCompleted method not supported");
1:628add4:         if (Log.doTrace())
1:628add4:             Log.trace("OrderCompleted", userID, orderID);
1:628add4:     }
1:628add4: 
1:628add4:     private HoldingDataBean createHolding(Connection conn, int accountID, String symbol, double quantity,
1:628add4:         BigDecimal purchasePrice) throws Exception {
1:628add4: 
1:628add4:         Timestamp purchaseDate = new Timestamp(System.currentTimeMillis());
1:628add4:         PreparedStatement stmt = getStatement(conn, createHoldingSQL);
1:628add4: 
1:628add4:         Integer holdingID = KeySequenceDirect.getNextID(conn, "holding", inSession, getInGlobalTxn());
1:628add4:         stmt.setInt(1, holdingID.intValue());
1:628add4:         stmt.setTimestamp(2, purchaseDate);
1:628add4:         stmt.setBigDecimal(3, purchasePrice);
1:628add4:         stmt.setDouble(4, quantity);
1:628add4:         stmt.setString(5, symbol);
1:628add4:         stmt.setInt(6, accountID);
1:b8c0170:         stmt.executeUpdate();
1:628add4: 
1:628add4:         stmt.close();
1:628add4: 
1:628add4:         return getHoldingData(conn, holdingID.intValue());
1:628add4:     }
1:628add4: 
1:628add4:     private void removeHolding(Connection conn, int holdingID, int orderID) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, removeHoldingSQL);
1:628add4: 
1:628add4:         stmt.setInt(1, holdingID);
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4: 
1:628add4:         // set the HoldingID to NULL for the purchase and sell order now that
1:628add4:         // the holding as been removed
1:628add4:         stmt = getStatement(conn, removeHoldingFromOrderSQL);
1:628add4: 
1:628add4:         stmt.setInt(1, holdingID);
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4: 
1:628add4:     }
1:628add4: 
1:628add4:     private OrderDataBean createOrder(Connection conn, AccountDataBean accountData, QuoteDataBean quoteData,
1:628add4:         HoldingDataBean holdingData, String orderType, double quantity) throws Exception {
1:628add4:         Timestamp currentDate = new Timestamp(System.currentTimeMillis());
1:628add4: 
1:628add4:         PreparedStatement stmt = getStatement(conn, createOrderSQL);
1:628add4: 
1:628add4:         Integer orderID = KeySequenceDirect.getNextID(conn, "order", inSession, getInGlobalTxn());
1:628add4:         stmt.setInt(1, orderID.intValue());
1:628add4:         stmt.setString(2, orderType);
1:628add4:         stmt.setString(3, "open");
1:628add4:         stmt.setTimestamp(4, currentDate);
1:628add4:         stmt.setDouble(5, quantity);
1:628add4:         stmt.setBigDecimal(6, quoteData.getPrice().setScale(FinancialUtils.SCALE, FinancialUtils.ROUND));
1:628add4:         stmt.setBigDecimal(7, TradeConfig.getOrderFee(orderType));
1:628add4:         stmt.setInt(8, accountData.getAccountID().intValue());
1:628add4:         if (holdingData == null)
1:628add4:             stmt.setNull(9, java.sql.Types.INTEGER);
1:628add4:         else
1:628add4:             stmt.setInt(9, holdingData.getHoldingID().intValue());
1:628add4:         stmt.setString(10, quoteData.getSymbol());
1:b8c0170:         stmt.executeUpdate();
1:628add4: 
1:628add4:         stmt.close();
1:628add4: 
1:628add4:         return getOrderData(conn, orderID.intValue());
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getOrders(String)
1:628add4:      */
1:628add4:     public Collection getOrders(String userID) throws Exception {
1:628add4: 
1:628add4:         Collection orderDataBeans = new ArrayList();
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getOrders - inSession(" + this.inSession + ")", userID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, getOrdersByUserSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4: 
1:628add4:             ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:             // TODO: return top 5 orders for now -- next version will add a
1:628add4:             // getAllOrders method
1:628add4:             // also need to get orders sorted by order id descending
1:628add4:             int i = 0;
1:628add4:             while ((rs.next()) && (i++ < 5)) {
1:628add4:                 OrderDataBean orderData = getOrderDataFromResultSet(rs);
1:628add4:                 orderDataBeans.add(orderData);
1:628add4:             }
1:628add4: 
1:628add4:             stmt.close();
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getOrders -- error getting user orders", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return orderDataBeans;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getClosedOrders(String)
1:628add4:      */
1:628add4:     public Collection getClosedOrders(String userID) throws Exception {
1:628add4: 
1:628add4:         Collection orderDataBeans = new ArrayList();
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getClosedOrders - inSession(" + this.inSession + ")", userID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, getClosedOrdersSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4: 
1:628add4:             ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:             while (rs.next()) {
1:628add4:                 OrderDataBean orderData = getOrderDataFromResultSet(rs);
1:628add4:                 orderData.setOrderStatus("completed");
1:628add4:                 updateOrderStatus(conn, orderData.getOrderID(), orderData.getOrderStatus());
1:628add4:                 orderDataBeans.add(orderData);
1:628add4: 
1:628add4:             }
1:628add4: 
1:628add4:             stmt.close();
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getOrders -- error getting user orders", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return orderDataBeans;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#createQuote(String, String, BigDecimal)
1:628add4:      */
1:628add4:     public QuoteDataBean createQuote(String symbol, String companyName, BigDecimal price) throws Exception {
1:628add4: 
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.traceEnter("TradeJdbc:createQuote - inSession(" + this.inSession + ")");
1:628add4: 
1:628add4:             price = price.setScale(FinancialUtils.SCALE, FinancialUtils.ROUND);
1:628add4:             double volume = 0.0, change = 0.0;
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, createQuoteSQL);
1:628add4:             stmt.setString(1, symbol); // symbol
1:628add4:             stmt.setString(2, companyName); // companyName
1:628add4:             stmt.setDouble(3, volume); // volume
1:628add4:             stmt.setBigDecimal(4, price); // price
1:628add4:             stmt.setBigDecimal(5, price); // open
1:628add4:             stmt.setBigDecimal(6, price); // low
1:628add4:             stmt.setBigDecimal(7, price); // high
1:628add4:             stmt.setDouble(8, change); // change
1:628add4: 
1:628add4:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4:             commit(conn);
1:628add4: 
1:628add4:             quoteData = new QuoteDataBeanImpl(symbol, companyName, volume, price, price, price, price, change);
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.traceExit("TradeJdbc:createQuote");
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:createQuote -- error creating quote", e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
2:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getQuote(String)
1:628add4:      */
1:628add4: 
1:628add4:     public QuoteDataBean getQuote(String symbol) throws Exception {
1:628add4: 
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         if ((symbol == null) || (symbol.length() == 0) || (symbol.length() > 10)) {
1:628add4:             if (Log.doTrace()) {
1:af24676:                 Log.trace("TradeJdbc:getQuote   ---  primitive workload");
1:628add4:             }
1:628add4:             return new QuoteDataBeanImpl("Invalid symbol", "", 0.0, FinancialUtils.ZERO, FinancialUtils.ZERO, FinancialUtils.ZERO, FinancialUtils.ZERO, 0.0);
1:628add4:         }
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getQuote - inSession(" + this.inSession + ")", symbol);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             quoteData = getQuote(conn, symbol);
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getQuote -- error getting quote", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:628add4:     private QuoteDataBean getQuote(Connection conn, String symbol) throws Exception {
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         PreparedStatement stmt = getStatement(conn, getQuoteSQL);
1:628add4:         stmt.setString(1, symbol); // symbol
1:628add4: 
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getQuote -- failure no result.next() for symbol: " + symbol);
1:628add4: 
1:628add4:         else
1:628add4:             quoteData = getQuoteDataFromResultSet(rs);
1:628add4: 
1:628add4:         stmt.close();
1:628add4: 
1:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:628add4:     private QuoteDataBean getQuoteForUpdate(Connection conn, String symbol) throws Exception {
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         PreparedStatement stmt = getStatement(conn, getQuoteForUpdateSQL);
1:628add4:         stmt.setString(1, symbol); // symbol
1:628add4: 
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getQuote -- failure no result.next()");
1:628add4: 
1:628add4:         else
1:628add4:             quoteData = getQuoteDataFromResultSet(rs);
1:628add4: 
1:628add4:         stmt.close();
1:628add4: 
1:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getAllQuotes(String)
1:628add4:      */
1:628add4:     public Collection getAllQuotes() throws Exception {
1:628add4: 
1:628add4:         Collection quotes = new ArrayList();
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:getAllQuotes");
1:628add4: 
1:628add4:         try {
1:628add4:             conn = getConn();
1:628add4: 
1:628add4:             PreparedStatement stmt = getStatement(conn, getAllQuotesSQL);
1:628add4: 
1:628add4:             ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:             while (!rs.next()) {
1:628add4:                 quoteData = getQuoteDataFromResultSet(rs);
1:628add4:                 quotes.add(quoteData);
1:628add4:             }
1:628add4: 
1:628add4:             stmt.close();
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getAllQuotes", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4: 
1:628add4:         return quotes;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getHoldings(String)
1:628add4:      */
1:628add4:     public Collection getHoldings(String userID) throws Exception {
1:628add4: 
1:628add4:         Collection holdingDataBeans = new ArrayList();
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getHoldings - inSession(" + this.inSession + ")", userID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, getHoldingsForUserSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4: 
1:628add4:             ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:             while (rs.next()) {
1:628add4:                 HoldingDataBean holdingData = getHoldingDataFromResultSet(rs);
1:628add4:                 holdingDataBeans.add(holdingData);
1:628add4:             }
1:628add4: 
1:628add4:             stmt.close();
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getHoldings -- error getting user holings", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return holdingDataBeans;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getHolding(Integer)
1:628add4:      */
1:628add4:     public HoldingDataBean getHolding(Integer holdingID) throws Exception {
1:628add4: 
1:628add4:         HoldingDataBean holdingData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getHolding - inSession(" + this.inSession + ")", holdingID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             holdingData = getHoldingData(holdingID.intValue());
1:628add4: 
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getHolding -- error getting holding " + holdingID + "", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return holdingData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getAccountData(String)
1:628add4:      */
1:628add4:     public AccountDataBean getAccountData(String userID) throws Exception {
1:628add4: 
1:628add4:         try {
1:628add4:             AccountDataBean accountData = null;
1:628add4:             Connection conn = null;
1:628add4:             try {
1:628add4:                 if (Log.doTrace())
1:af24676:                     Log.trace("TradeJdbc:getAccountData - inSession(" + this.inSession + ")", userID);
1:628add4: 
1:628add4:                 conn = getConn();
1:628add4:                 accountData = getAccountData(conn, userID);
1:628add4:                 commit(conn);
1:628add4: 
1:628add4:             } catch (Exception e) {
1:af24676:                 Log.error("TradeJdbc:getAccountData -- error getting account data", e);
1:628add4:                 rollBack(conn, e);
1:628add4:             } finally {
1:628add4:                 releaseConn(conn);
1:628add4:             }
2:628add4:             return accountData;
1:628add4:         } catch (Exception e) {
1:628add4:             throw new Exception(e.getMessage(), e);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     private AccountDataBean getAccountData(Connection conn, String userID) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, getAccountForUserSQL);
1:628add4:         stmt.setString(1, userID);
1:628add4:         ResultSet rs = stmt.executeQuery();
2:628add4:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return accountData;
1:628add4:     }
1:628add4: 
1:628add4:     private AccountDataBean getAccountDataForUpdate(Connection conn, String userID) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, getAccountForUserForUpdateSQL);
1:628add4:         stmt.setString(1, userID);
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return accountData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getAccountData(String)
1:628add4:      */
1:628add4:     public AccountDataBean getAccountData(int accountID) throws Exception {
1:628add4:         AccountDataBean accountData = null;
1:628add4:         Connection conn = null;
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getAccountData - inSession(" + this.inSession + ")", new Integer(accountID));
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             accountData = getAccountData(accountID, conn);
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getAccountData -- error getting account data", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return accountData;
1:628add4:     }
1:628add4: 
1:628add4:     private AccountDataBean getAccountData(int accountID, Connection conn) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, getAccountSQL);
2:628add4:         stmt.setInt(1, accountID);
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return accountData;
1:628add4:     }
1:628add4: 
1:628add4:     private QuoteDataBean getQuoteData(Connection conn, String symbol) throws Exception {
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         PreparedStatement stmt = getStatement(conn, getQuoteSQL);
1:628add4:         stmt.setString(1, symbol);
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getQuoteData -- could not find quote for symbol=" + symbol);
1:628add4:         else
1:628add4:             quoteData = getQuoteDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:628add4:     private HoldingDataBean getHoldingData(int holdingID) throws Exception {
1:628add4:         HoldingDataBean holdingData = null;
1:628add4:         Connection conn = null;
1:628add4:         try {
1:628add4:             conn = getConn();
1:628add4:             holdingData = getHoldingData(conn, holdingID);
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getHoldingData -- error getting data", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return holdingData;
1:628add4:     }
1:628add4: 
1:628add4:     private HoldingDataBean getHoldingData(Connection conn, int holdingID) throws Exception {
1:628add4:         HoldingDataBean holdingData = null;
1:628add4:         PreparedStatement stmt = getStatement(conn, getHoldingSQL);
1:628add4:         stmt.setInt(1, holdingID);
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getHoldingData -- no results -- holdingID=" + holdingID);
1:628add4:         else
1:628add4:             holdingData = getHoldingDataFromResultSet(rs);
1:628add4: 
1:628add4:         stmt.close();
1:628add4:         return holdingData;
1:628add4:     }
1:628add4: 
1:628add4:     private OrderDataBean getOrderData(Connection conn, int orderID) throws Exception {
1:628add4:         OrderDataBean orderData = null;
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:getOrderData(conn, " + orderID + ")");
1:628add4:         PreparedStatement stmt = getStatement(conn, getOrderSQL);
1:628add4:         stmt.setInt(1, orderID);
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getOrderData -- no results for orderID:" + orderID);
1:628add4:         else
1:628add4:             orderData = getOrderDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return orderData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#getAccountProfileData(String)
1:628add4:      */
1:628add4:     public AccountProfileDataBean getAccountProfileData(String userID) throws Exception {
1:628add4: 
2:628add4:         AccountProfileDataBean accountProfileData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:getAccountProfileData - inSession(" + this.inSession + ")", userID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             accountProfileData = getAccountProfileData(conn, userID);
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getAccountProfileData -- error getting profile data", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
2:628add4:         return accountProfileData;
1:628add4:     }
1:628add4: 
1:628add4:     private AccountProfileDataBean getAccountProfileData(Connection conn, String userID) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, getAccountProfileSQL);
1:628add4:         stmt.setString(1, userID);
1:628add4: 
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:         AccountProfileDataBean accountProfileData = getAccountProfileDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return accountProfileData;
1:628add4:     }
1:628add4: 
1:628add4:     private AccountProfileDataBean getAccountProfileData(Connection conn, Integer accountID) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, getAccountProfileForAccountSQL);
1:628add4:         stmt.setInt(1, accountID.intValue());
1:628add4: 
1:628add4:         ResultSet rs = stmt.executeQuery();
1:628add4: 
1:628add4:         AccountProfileDataBean accountProfileData = getAccountProfileDataFromResultSet(rs);
1:628add4:         stmt.close();
1:628add4:         return accountProfileData;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#updateAccountProfile(AccountProfileDataBean)
1:628add4:      */
1:628add4:     public AccountProfileDataBean updateAccountProfile(String userID, String password, String fullName, String address, String email, String creditcard) throws Exception {                              
1:628add4: 
1:628add4:         AccountProfileDataBean accountProfileData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:updateAccountProfileData - inSession(" + this.inSession + ")", userID);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             updateAccountProfile(conn, userID, password, fullName, address, email, creditcard);
1:628add4: 
1:628add4:             accountProfileData = getAccountProfileData(conn, userID);
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:getAccountProfileData -- error getting profile data", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return accountProfileData;
1:628add4:     }
1:628add4: 
1:628add4:     private void creditAccountBalance(Connection conn, AccountDataBean accountData, BigDecimal credit) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, creditAccountBalanceSQL);
1:628add4: 
1:628add4:         stmt.setBigDecimal(1, credit);
1:628add4:         stmt.setInt(2, accountData.getAccountID().intValue());
1:628add4: 
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4: 
1:628add4:     }
1:628add4: 
1:628add4:     // Set Timestamp to zero to denote sell is inflight
1:628add4:     // UPDATE -- could add a "status" attribute to holding
1:628add4:     private void updateHoldingStatus(Connection conn, Integer holdingID, String symbol) throws Exception {
1:628add4:         Timestamp ts = new Timestamp(0);
1:628add4:         PreparedStatement stmt = getStatement(conn, "update holdingejb set purchasedate= ? where holdingid = ?");
1:628add4: 
1:628add4:         stmt.setTimestamp(1, ts);
1:628add4:         stmt.setInt(2, holdingID.intValue());
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4:     }
1:628add4: 
1:628add4:     private void updateOrderStatus(Connection conn, Integer orderID, String status) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, updateOrderStatusSQL);
1:628add4: 
1:628add4:         stmt.setString(1, status);
1:628add4:         stmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
1:628add4:         stmt.setInt(3, orderID.intValue());
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4:     }
1:628add4: 
1:628add4:     private void updateOrderHolding(Connection conn, int orderID, int holdingID) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, updateOrderHoldingSQL);
1:628add4: 
1:628add4:         stmt.setInt(1, holdingID);
1:628add4:         stmt.setInt(2, orderID);
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4:     }
1:628add4: 
1:628add4:     private void updateAccountProfile(Connection conn, String userID, String password, String fullName, String address, String email, String creditcard) throws Exception {
1:628add4:         PreparedStatement stmt = getStatement(conn, updateAccountProfileSQL);
1:628add4: 
1:628add4:         stmt.setString(1, password);
1:628add4:         stmt.setString(2, fullName);
1:628add4:         stmt.setString(3, address);
1:628add4:         stmt.setString(4, email);
1:628add4:         stmt.setString(5, creditcard);
1:628add4:         stmt.setString(6, userID);
1:628add4: 
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4:     }
1:628add4: 
1:628add4:     public QuoteDataBean updateQuotePriceVolume(String symbol, BigDecimal changeFactor, double sharesTraded)
1:628add4:         throws Exception {
1:628add4: 
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:updateQuotePriceVolume", symbol, changeFactor, new Double(sharesTraded));
1:628add4: 
1:628add4:         return updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, TradeConfig.getPublishQuotePriceChange());
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * Update a quote's price and volume
1:628add4:      * 
1:628add4:      * @param symbol
1:628add4:      *            The PK of the quote
1:628add4:      * @param changeFactor
1:628add4:      *            the percent to change the old price by (between 50% and 150%)
1:628add4:      * @param sharedTraded
1:628add4:      *            the ammount to add to the current volume
1:628add4:      * @param publishQuotePriceChange
1:628add4:      *            used by the PingJDBCWrite Primitive to ensure no JMS is used, should be true for all normal calls to
1:628add4:      *            this API
1:628add4:      */
1:628add4:     public QuoteDataBean updateQuotePriceVolumeInt(String symbol, BigDecimal changeFactor, double sharesTraded,
1:628add4:         boolean publishQuotePriceChange) throws Exception {
1:628add4: 
1:628add4:         if (TradeConfig.getUpdateQuotePrices() == false)
1:628add4:             return new QuoteDataBeanImpl();
1:628add4: 
1:628add4:         QuoteDataBean quoteData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:updateQuotePriceVolume - inSession(" + this.inSession + ")", symbol,
1:628add4:                     changeFactor, new Double(sharesTraded));
1:628add4: 
1:628add4:             conn = getConn();
1:628add4: 
1:628add4:             quoteData = getQuoteForUpdate(conn, symbol);
1:628add4:             BigDecimal oldPrice = quoteData.getPrice();
1:628add4:             double newVolume = quoteData.getVolume() + sharesTraded;
1:628add4: 
1:628add4:             if (oldPrice.equals(TradeConfig.PENNY_STOCK_PRICE)) {
1:628add4:                 changeFactor = TradeConfig.PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER;
1:628add4:             } else if (oldPrice.compareTo(TradeConfig.MAXIMUM_STOCK_PRICE) > 0) {
1:628add4:                 changeFactor = TradeConfig.MAXIMUM_STOCK_SPLIT_MULTIPLIER;
1:628add4:             }
1:628add4: 
1:628add4:             BigDecimal newPrice = changeFactor.multiply(oldPrice).setScale(2, BigDecimal.ROUND_HALF_UP);
1:d24b46e:             BigDecimal low = quoteData.getLow();
1:d24b46e:             BigDecimal high= quoteData.getHigh();
1:d24b46e:             if (newPrice.compareTo(high) == 1) high = newPrice;
1:d24b46e:             else if (newPrice.compareTo(low) == -1) low = newPrice;
1:628add4: 
1:d24b46e:             updateQuotePriceVolume(conn, quoteData.getSymbol(), newPrice, newVolume, low, high);
1:628add4:             quoteData = getQuote(conn, symbol);
1:628add4: 
1:628add4:             commit(conn);
1:628add4: 
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:updateQuotePriceVolume -- error updating quote price/volume for symbol:" + symbol);
1:628add4:             rollBack(conn, e);
1:628add4:             throw e;
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:d24b46e:     private void updateQuotePriceVolume(Connection conn, String symbol, BigDecimal newPrice, double newVolume, BigDecimal low, BigDecimal high)
1:628add4:         throws Exception {
1:628add4: 
1:628add4:         PreparedStatement stmt = getStatement(conn, updateQuotePriceVolumeSQL);
1:628add4: 
1:628add4:         stmt.setBigDecimal(1, newPrice);
1:628add4:         stmt.setBigDecimal(2, newPrice);
1:628add4:         stmt.setDouble(3, newVolume);
1:d24b46e:         stmt.setBigDecimal(4, low);
1:d24b46e:         stmt.setBigDecimal(5, high);
1:d24b46e:         stmt.setString(6, symbol);
1:628add4: 
1:b8c0170:         stmt.executeUpdate();
1:628add4:         stmt.close();
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#login(String, String)
1:628add4:      */
1:628add4: 
1:628add4:     public AccountDataBean login(String userID, String password) throws Exception {
1:628add4: 
1:628add4:         AccountDataBean accountData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.trace("TradeJdbc:login - inSession(" + this.inSession + ")", userID, password);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, getAccountProfileSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4: 
1:628add4:             ResultSet rs = stmt.executeQuery();
1:628add4:             if (!rs.next()) {
1:af24676:                 Log.error("TradeJdbc:login -- failure to find account for" + userID);
1:628add4:                 throw new RuntimeException("Cannot find account for" + userID);
1:628add4:             }
1:628add4: 
1:628add4:             String pw = rs.getString("passwd");
1:628add4:             stmt.close();
1:628add4:             if ((pw == null) || (pw.equals(password) == false)) {
1:628add4:                 String error =
1:af24676:                     "TradeJdbc:Login failure for user: " + userID + "\n\tIncorrect password-->" + userID + ":"
1:628add4:                         + password;
1:628add4:                 Log.error(error);
1:628add4:                 throw new Exception(error);
1:628add4:             }
1:628add4: 
1:628add4:             stmt = getStatement(conn, loginSQL);
1:628add4:             stmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
1:628add4:             stmt.setString(2, userID);
1:628add4: 
1:b8c0170:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             stmt = getStatement(conn, getAccountForUserSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4:             rs = stmt.executeQuery();
1:628add4: 
1:628add4:             accountData = getAccountDataFromResultSet(rs);
1:628add4: 
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:login -- error logging in user", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return accountData;
1:628add4: 
1:628add4:         /*
1:628add4:          * setLastLogin( new Timestamp(System.currentTimeMillis()) ); setLoginCount( getLoginCount() + 1 );
1:628add4:          */
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#logout(String)
1:628add4:      */
1:628add4:     public void logout(String userID) throws Exception {
1:628add4: 
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:logout - inSession(" + this.inSession + ")", userID);
1:628add4:         try {
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, logoutSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             commit(conn);
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:logout -- error logging out user", e);
1:628add4:             rollBack(conn, e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * @see TradeServices#register(String, String, String, String, String, String, BigDecimal, boolean)
1:628add4:      */
1:628add4: 
1:628add4:     public AccountDataBean register(String userID, String password, String fullname, String address, String email,
1:628add4:         String creditCard, BigDecimal openBalance) throws Exception {
1:628add4: 
1:628add4:         AccountDataBean accountData = null;
1:628add4:         Connection conn = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.traceEnter("TradeJdbc:register - inSession(" + this.inSession + ")");
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = getStatement(conn, createAccountSQL);
1:628add4: 
1:628add4:             Integer accountID = KeySequenceDirect.getNextID(conn, "account", inSession, getInGlobalTxn());
1:628add4:             BigDecimal balance = openBalance;
1:628add4:             Timestamp creationDate = new Timestamp(System.currentTimeMillis());
1:628add4:             Timestamp lastLogin = creationDate;
1:628add4:             int loginCount = 0;
1:628add4:             int logoutCount = 0;
1:628add4: 
1:628add4:             stmt.setInt(1, accountID.intValue());
1:628add4:             stmt.setTimestamp(2, creationDate);
1:628add4:             stmt.setBigDecimal(3, openBalance);
1:628add4:             stmt.setBigDecimal(4, balance);
1:628add4:             stmt.setTimestamp(5, lastLogin);
1:628add4:             stmt.setInt(6, loginCount);
1:628add4:             stmt.setInt(7, logoutCount);
1:628add4:             stmt.setString(8, userID);
1:628add4:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             stmt = getStatement(conn, createAccountProfileSQL);
1:628add4:             stmt.setString(1, userID);
1:628add4:             stmt.setString(2, password);
1:628add4:             stmt.setString(3, fullname);
1:628add4:             stmt.setString(4, address);
1:628add4:             stmt.setString(5, email);
1:628add4:             stmt.setString(6, creditCard);
1:628add4:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             commit(conn);
1:628add4: 
1:628add4:             accountData =
1:628add4:                 new AccountDataBeanImpl(accountID, loginCount, logoutCount, lastLogin, creationDate, balance, openBalance,
1:628add4:                     userID);
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.traceExit("TradeJdbc:register");
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:register -- error registering new user", e);
1:628add4:         } finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return accountData;
1:628add4:     }
1:628add4: 
1:628add4:     private AccountDataBean getAccountDataFromResultSet(ResultSet rs) throws Exception {
1:628add4:         AccountDataBean accountData = null;
1:628add4: 
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getAccountDataFromResultSet -- cannot find account data");
1:628add4: 
1:628add4:         else
1:628add4:             accountData =
1:628add4:                 new AccountDataBeanImpl(new Integer(rs.getInt("accountID")), rs.getInt("loginCount"), rs
1:628add4:                     .getInt("logoutCount"), rs.getTimestamp("lastLogin"), rs.getTimestamp("creationDate"), rs
1:628add4:                     .getBigDecimal("balance"), rs.getBigDecimal("openBalance"), rs.getString("profile_userID"));
1:628add4:         return accountData;
1:628add4:     }
1:628add4: 
1:628add4:     private AccountProfileDataBean getAccountProfileDataFromResultSet(ResultSet rs) throws Exception {
1:628add4:         AccountProfileDataBean accountProfileData = null;
1:628add4: 
1:628add4:         if (!rs.next())
1:af24676:             Log.error("TradeJdbc:getAccountProfileDataFromResultSet -- cannot find accountprofile data");
1:628add4:         else
1:628add4:             accountProfileData =
1:628add4:                 new AccountProfileDataBeanImpl(rs.getString("userID"), rs.getString("passwd"), rs.getString("fullName"), rs
1:628add4:                     .getString("address"), rs.getString("email"), rs.getString("creditCard"));
1:628add4: 
1:628add4:         return accountProfileData;
1:628add4:     }
1:628add4: 
1:628add4:     private HoldingDataBean getHoldingDataFromResultSet(ResultSet rs) throws Exception {
1:628add4:         HoldingDataBean holdingData = null;
1:628add4: 
1:628add4:         holdingData =
1:628add4:             new HoldingDataBeanImpl(new Integer(rs.getInt("holdingID")), rs.getDouble("quantity"), rs
1:628add4:                 .getBigDecimal("purchasePrice"), rs.getTimestamp("purchaseDate"), rs.getString("quote_symbol"));
1:628add4:         return holdingData;
1:628add4:     }
1:628add4: 
1:628add4:     private QuoteDataBean getQuoteDataFromResultSet(ResultSet rs) throws Exception {
1:628add4:         QuoteDataBean quoteData = null;
1:628add4: 
1:628add4:         quoteData =
1:628add4:             new QuoteDataBeanImpl(rs.getString("symbol"), rs.getString("companyName"), rs.getDouble("volume"), rs
1:628add4:                 .getBigDecimal("price"), rs.getBigDecimal("open1"), rs.getBigDecimal("low"), rs.getBigDecimal("high"),
1:628add4:                 rs.getDouble("change1"));
1:628add4:         return quoteData;
1:628add4:     }
1:628add4: 
1:628add4:     private OrderDataBean getOrderDataFromResultSet(ResultSet rs) throws Exception {
1:628add4:         OrderDataBean orderData = null;
1:628add4: 
1:628add4:         orderData =
1:628add4:             new OrderDataBeanImpl(new Integer(rs.getInt("orderID")), rs.getString("orderType"),
1:628add4:                 rs.getString("orderStatus"), rs.getTimestamp("openDate"), rs.getTimestamp("completionDate"), rs
1:628add4:                     .getDouble("quantity"), rs.getBigDecimal("price"), rs.getBigDecimal("orderFee"), rs
1:628add4:                     .getString("quote_symbol"));
1:628add4:         return orderData;
1:628add4:     }
1:628add4: 
1:628add4: 
1:628add4:     private void releaseConn(Connection conn) throws Exception {
1:628add4:         try {
1:628add4:             if (conn != null) {
1:628add4:                 conn.close();
1:628add4:                 if (Log.doTrace()) {
1:628add4:                     synchronized (lock) {
1:628add4:                         connCount--;
1:628add4:                     }
1:af24676:                     Log.trace("TradeJdbc:releaseConn -- connection closed, connCount=" + connCount);
1:628add4:                 }
1:628add4:             }
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:releaseConnection -- failed to close connection", e);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Lookup the TradeData DataSource
1:628add4:      */
1:ea52306:     private void lookupDataSource() throws Exception {
1:ea52306:         if (dataSource == null) {
1:a8a9116:             dataSource = (DataSource) ServiceUtilities.getOSGIService(DataSource.class.getName(),TradeConfig.OSGI_DS_NAME_FILTER);
1:ea52306:         }
1:ea52306:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Allocate a new connection to the datasource
1:628add4:      */
1:628add4:     private Connection getConn() throws Exception {
1:628add4: 
1:628add4:         Connection conn = null;
1:ea52306:         lookupDataSource();
1:628add4:         conn = dataSource.getConnection();
1:628add4:         conn.setAutoCommit(false);
1:628add4:         if (Log.doTrace()) {
1:628add4:             synchronized (lock) {
1:628add4:                 connCount++;
1:628add4:             }
1:af24676:             Log.trace("TradeJdbc:getConn -- new connection allocated, IsolationLevel="
1:628add4:                 + conn.getTransactionIsolation() + " connectionCount = " + connCount);
1:628add4:         }
1:628add4: 
1:628add4:         return conn;
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Commit the provided connection if not under Global Transaction scope - conn.commit() is not allowed in a global
1:628add4:      * transaction. the txn manager will perform the commit
1:628add4:      */
1:628add4:     private void commit(Connection conn) throws Exception {
1:628add4:         if (!inSession) {
1:628add4:             if ((getInGlobalTxn() == false) && (conn != null))
1:628add4:                 conn.commit();
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Rollback the statement for the given connection
1:628add4:      */
1:628add4:     private void rollBack(Connection conn, Exception e) throws Exception {
1:628add4:         if (!inSession) {
1:af24676:             Log.log("TradeJdbc:rollBack -- rolling back conn due to previously caught exception -- inGlobalTxn="
1:628add4:                 + getInGlobalTxn());
1:628add4:             if ((getInGlobalTxn() == false) && (conn != null))
1:628add4:                 conn.rollback();
1:628add4:             else
1:628add4:                 throw e; // Throw the exception
1:628add4:             // so the Global txn manager will rollBack
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Allocate a new prepared statment for this connection
1:628add4:      */
1:628add4:     private PreparedStatement getStatement(Connection conn, String sql) throws Exception {
1:628add4:         return conn.prepareStatement(sql);
1:628add4:     }
1:628add4: 
1:628add4:     private PreparedStatement getStatement(Connection conn, String sql, int type, int concurrency) throws Exception {
1:628add4:         return conn.prepareStatement(sql, type, concurrency);
1:628add4:     }
1:628add4: 
1:628add4:     private static final String createQuoteSQL =
1:628add4:         "insert into quoteejb " + "( symbol, companyName, volume, price, open1, low, high, change1 ) "
1:628add4:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  )";
1:628add4: 
1:628add4:     private static final String createAccountSQL =
1:628add4:         "insert into accountejb "
1:628add4:             + "( accountid, creationDate, openBalance, balance, lastLogin, loginCount, logoutCount, profile_userid) "
1:628add4:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  )";
1:628add4: 
1:628add4:     private static final String createAccountProfileSQL =
1:628add4:         "insert into accountprofileejb " + "( userid, passwd, fullname, address, email, creditcard ) "
1:628add4:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  )";
1:628add4: 
1:628add4:     private static final String createHoldingSQL =
1:628add4:         "insert into holdingejb "
1:628add4:             + "( holdingid, purchaseDate, purchasePrice, quantity, quote_symbol, account_accountid ) "
1:628add4:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ? )";
1:628add4: 
1:628add4:     private static final String createOrderSQL =
1:628add4:         "insert into orderejb "
1:628add4:             + "( orderid, ordertype, orderstatus, opendate, quantity, price, orderfee, account_accountid,  holding_holdingid, quote_symbol) "
1:628add4:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  , ? , ? , ?)";
1:628add4: 
1:628add4:     private static final String removeHoldingSQL = "delete from holdingejb where holdingid = ?";
1:628add4: 
1:628add4:     private static final String removeHoldingFromOrderSQL =
1:628add4:         "update orderejb set holding_holdingid=null where holding_holdingid = ?";
1:628add4: 
1:628add4:     private final static String updateAccountProfileSQL =
1:628add4:         "update accountprofileejb set " + "passwd = ?, fullname = ?, address = ?, email = ?, creditcard = ? "
1:628add4:             + "where userid = (select profile_userid from accountejb a " + "where a.profile_userid=?)";
1:628add4: 
1:628add4:     private final static String loginSQL =
1:628add4:         "update accountejb set lastLogin=?, logincount=logincount+1 " + "where profile_userid=?";
1:628add4: 
1:628add4:     private static final String logoutSQL =
1:628add4:         "update accountejb set logoutcount=logoutcount+1 " + "where profile_userid=?";
1:628add4: 
1:628add4:     private static final String getAccountSQL = "select * from accountejb a where a.accountid = ?";
1:628add4: 
1:628add4:     private final static String getAccountProfileSQL =
1:628add4:         "select * from accountprofileejb ap where ap.userid = "
1:628add4:             + "(select profile_userid from accountejb a where a.profile_userid=?)";
1:628add4: 
1:628add4:     private final static String getAccountProfileForAccountSQL =
1:628add4:         "select * from accountprofileejb ap where ap.userid = "
1:628add4:             + "(select profile_userid from accountejb a where a.accountid=?)";
1:628add4: 
1:628add4:     private static final String getAccountForUserSQL =
1:628add4:         "select * from accountejb a where a.profile_userid = "
1:628add4:             + "( select userid from accountprofileejb ap where ap.userid = ?)";
1:628add4: 
1:628add4:     private static final String getAccountForUserForUpdateSQL =
1:628add4:         "select * from accountejb a where a.profile_userid = "
1:628add4:             + "( select userid from accountprofileejb ap where ap.userid = ?) for update";
1:628add4: 
1:628add4:     private static final String getHoldingSQL = "select * from holdingejb h where h.holdingid = ?";
1:628add4: 
1:628add4:     private static final String getHoldingsForUserSQL =
1:628add4:         "select * from holdingejb h where h.account_accountid = "
1:628add4:             + "(select a.accountid from accountejb a where a.profile_userid = ?)";
1:628add4: 
1:628add4:     private static final String getOrderSQL = "select * from orderejb o where o.orderid = ?";
1:628add4: 
1:628add4:     private static final String getOrdersByUserSQL =
1:628add4:         "select * from orderejb o where o.account_accountid = "
1:628add4:             + "(select a.accountid from accountejb a where a.profile_userid = ?)";
1:628add4: 
1:628add4:     private static final String getClosedOrdersSQL =
1:628add4:         "select * from orderejb o " + "where o.orderstatus = 'closed' AND o.account_accountid = "
1:628add4:             + "(select a.accountid from accountejb a where a.profile_userid = ?)";
1:628add4: 
1:628add4:     private static final String getQuoteSQL = "select * from quoteejb q where q.symbol=?";
1:628add4: 
1:628add4:     private static final String getAllQuotesSQL = "select * from quoteejb q";
1:628add4: 
1:628add4:     private static final String getQuoteForUpdateSQL = "select * from quoteejb q where q.symbol=? For Update";
1:628add4: 
1:628add4:     private static final String getTSIAQuotesOrderByChangeSQL =
1:628add4:         "select * from quoteejb q " + "where q.symbol like 's:1__' order by q.change1";
1:628add4: 
1:628add4:     private static final String getTSIASQL =
1:628add4:         "select SUM(price)/count(*) as TSIA from quoteejb q " + "where q.symbol like 's:1__'";
1:628add4: 
1:628add4:     private static final String getOpenTSIASQL =
1:628add4:         "select SUM(open1)/count(*) as openTSIA from quoteejb q " + "where q.symbol like 's:1__'";
1:628add4: 
1:628add4:     private static final String getTSIATotalVolumeSQL =
1:628add4:         "select SUM(volume) as totalVolume from quoteejb q " + "where q.symbol like 's:1__'";
1:628add4: 
1:628add4:     private static final String creditAccountBalanceSQL =
1:628add4:         "update accountejb set " + "balance = balance + ? " + "where accountid = ?";
1:628add4: 
1:628add4:     private static final String updateOrderStatusSQL =
1:628add4:         "update orderejb set " + "orderstatus = ?, completiondate = ? " + "where orderid = ?";
1:628add4: 
1:628add4:     private static final String updateOrderHoldingSQL =
1:628add4:         "update orderejb set " + "holding_holdingID = ? " + "where orderid = ?";
1:628add4: 
1:628add4:     private static final String updateQuotePriceVolumeSQL =
1:d24b46e:         "update quoteejb set " + "price = ?, change1 = ? - open1, volume = ?, low = ?, high = ? " + "where symbol = ?";
1:628add4: 
1:628add4:     public void init() {
1:628add4:         if (initialized)
2:628add4:             return;
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:init -- *** initializing");
1:628add4: 
1:628add4:         if (Log.doTrace())
1:af24676:             Log.trace("TradeJdbc:init -- +++ initialized");
1:628add4: 
1:628add4:         initialized = true;
1:628add4:     }
1:628add4: 
1:628add4:     public void destroy() {
1:628add4:         try {
1:628add4:             if (!initialized)
1:628add4:                 return;
1:af24676:             Log.trace("TradeJdbc:destroy");
1:628add4:         } catch (Exception e) {
1:af24676:             Log.error("TradeJdbc:destroy", e);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * Gets the inGlobalTxn
1:628add4:      * 
1:628add4:      * @return Returns a boolean
1:628add4:      */
1:628add4:     private boolean getInGlobalTxn() {
1:628add4:         return inGlobalTxn;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * Sets the inGlobalTxn
1:628add4:      * 
1:628add4:      * @param inGlobalTxn
1:628add4:      *            The inGlobalTxn to set
1:628add4:      */
1:628add4:     private void setInGlobalTxn(boolean inGlobalTxn) {
1:628add4:         this.inGlobalTxn = inGlobalTxn;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * Get mode - returns the persistence mode (TradeConfig.JDBC)
1:628add4:      * 
1:8ef753d:      * @return TradeConfig.ModeType
1:628add4:      */
1:8ef753d:     public TradeConfig.ModeType getMode() {
1:8ef753d:         return TradeConfig.ModeType.JDBC;
1:628add4:     }
1:628add4: 
1:628add4: }
============================================================================
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:8ef753d
/////////////////////////////////////////////////////////////////////////
1:      * @return TradeConfig.ModeType
1:     public TradeConfig.ModeType getMode() {
1:         return TradeConfig.ModeType.JDBC;
commit:39f53f6
commit:d24b46e
/////////////////////////////////////////////////////////////////////////
1:             BigDecimal low = quoteData.getLow();
1:             BigDecimal high= quoteData.getHigh();
1:             if (newPrice.compareTo(high) == 1) high = newPrice;
1:             else if (newPrice.compareTo(low) == -1) low = newPrice;
1:             updateQuotePriceVolume(conn, quoteData.getSymbol(), newPrice, newVolume, low, high);
/////////////////////////////////////////////////////////////////////////
1:     private void updateQuotePriceVolume(Connection conn, String symbol, BigDecimal newPrice, double newVolume, BigDecimal low, BigDecimal high)
/////////////////////////////////////////////////////////////////////////
1:         stmt.setBigDecimal(4, low);
1:         stmt.setBigDecimal(5, high);
1:         stmt.setString(6, symbol);
/////////////////////////////////////////////////////////////////////////
1:         "update quoteejb set " + "price = ?, change1 = ? - open1, volume = ?, low = ?, high = ? " + "where symbol = ?";
commit:b8c0170
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         //after the purchase or sale of a stock, update the stocks volume and
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:             stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:880e087
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.samples.ariestrader.api.persistence.AccountDataBean;
1: import org.apache.aries.samples.ariestrader.api.persistence.AccountProfileDataBean;
1: import org.apache.aries.samples.ariestrader.api.persistence.HoldingDataBean;
1: import org.apache.aries.samples.ariestrader.api.persistence.MarketSummaryDataBean;
1: import org.apache.aries.samples.ariestrader.api.persistence.OrderDataBean;
1: import org.apache.aries.samples.ariestrader.api.persistence.QuoteDataBean;
commit:01ce653
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:989ba4e
commit:a8a9116
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.samples.ariestrader.util.ServiceUtilities;
/////////////////////////////////////////////////////////////////////////
0: //            dataSource = (DataSource) ServiceUtilities.getOSGIService(DataSource.class.getName(),"(osgi.jndi.serviceName=jdbc/TradeDataSource)");
1:             dataSource = (DataSource) ServiceUtilities.getOSGIService(DataSource.class.getName(),TradeConfig.OSGI_DS_NAME_FILTER);
commit:37fe36d
/////////////////////////////////////////////////////////////////////////
0:     private static String dsName = TradeConfig.DS_NAME;
commit:af24676
/////////////////////////////////////////////////////////////////////////
1:  * TradeJdbc uses direct JDBC access to a
/////////////////////////////////////////////////////////////////////////
1: public class TradeJdbc implements TradeServices {
/////////////////////////////////////////////////////////////////////////
1:      * Zero arg constructor for TradeJdbc
1:     public TradeJdbc() {
1:     public TradeJdbc(boolean inSession) {
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getMarketSummary - inSession(" + this.inSession + ")");
/////////////////////////////////////////////////////////////////////////
1:                     Log.error("TradeJdbc:getMarketSummary -- error w/ getTSIASQL -- no results");
/////////////////////////////////////////////////////////////////////////
1:                     Log.error("TradeJdbc:getMarketSummary -- error w/ getOpenTSIASQL -- no results");
/////////////////////////////////////////////////////////////////////////
1:                     Log.error("TradeJdbc:getMarketSummary -- error w/ getTSIATotalVolumeSQL -- no results");
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getMarketSummary -- error getting summary", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:buy - inSession(" + this.inSession + ")", userID, symbol, new Double(quantity));
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:buy error - rolling back", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:sell - inSession(" + this.inSession + ")", userID, holdingID);
/////////////////////////////////////////////////////////////////////////
1:                     "TradeJdbc:sell -- error selling stock -- unable to find:  \n\taccount=" + accountData
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:sell error", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:completeOrder - inSession(" + this.inSession + ")", orderID);
1:             Log.error("TradeJdbc:completeOrder -- error completing order", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:completeOrderInternal - inSession(" + this.inSession + ")", orderID);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:completeOrder -- unable to find order: " + orderID);
/////////////////////////////////////////////////////////////////////////
1:             throw new Exception("TradeJdbc:completeOrder -- attempt to complete Order that is already completed");
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:completeOrder--> Completing Order " + orderData.getOrderID() + "\n\t Order info: "
/////////////////////////////////////////////////////////////////////////
1:                 Log.debug("TradeJdbc:completeOrder:sell -- user: " + userID + " already sold holding: " + holdingID);
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:completeOrder--> Completed Order " + orderData.getOrderID() + "\n\t Order info: "
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:cancelOrder - inSession(" + this.inSession + ")", orderID);
1:             Log.error("TradeJdbc:cancelOrder -- error cancelling order: " + orderID, e);
/////////////////////////////////////////////////////////////////////////
1: //        throw new UnsupportedOperationException("TradeJdbc:orderCompleted method not supported");
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getOrders - inSession(" + this.inSession + ")", userID);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getOrders -- error getting user orders", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getClosedOrders - inSession(" + this.inSession + ")", userID);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getOrders -- error getting user orders", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.traceEnter("TradeJdbc:createQuote - inSession(" + this.inSession + ")");
/////////////////////////////////////////////////////////////////////////
1:                 Log.traceExit("TradeJdbc:createQuote");
1:             Log.error("TradeJdbc:createQuote -- error creating quote", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getQuote   ---  primitive workload");
1:                 Log.trace("TradeJdbc:getQuote - inSession(" + this.inSession + ")", symbol);
1:             Log.error("TradeJdbc:getQuote -- error getting quote", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getQuote -- failure no result.next() for symbol: " + symbol);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getQuote -- failure no result.next()");
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:getAllQuotes");
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getAllQuotes", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getHoldings - inSession(" + this.inSession + ")", userID);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getHoldings -- error getting user holings", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getHolding - inSession(" + this.inSession + ")", holdingID);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getHolding -- error getting holding " + holdingID + "", e);
/////////////////////////////////////////////////////////////////////////
1:                     Log.trace("TradeJdbc:getAccountData - inSession(" + this.inSession + ")", userID);
1:                 Log.error("TradeJdbc:getAccountData -- error getting account data", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getAccountData - inSession(" + this.inSession + ")", new Integer(accountID));
1:             Log.error("TradeJdbc:getAccountData -- error getting account data", e);
/////////////////////////////////////////////////////////////////////////
0:             Log.error("TradeJdbc:getQuoteData -- error getting data", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getQuoteData -- could not find quote for symbol=" + symbol);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getHoldingData -- error getting data", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getHoldingData -- no results -- holdingID=" + holdingID);
/////////////////////////////////////////////////////////////////////////
0:             Log.error("TradeJdbc:getOrderData -- error getting data", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:getOrderData(conn, " + orderID + ")");
1:             Log.error("TradeJdbc:getOrderData -- no results for orderID:" + orderID);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:getAccountProfileData - inSession(" + this.inSession + ")", userID);
1:             Log.error("TradeJdbc:getAccountProfileData -- error getting profile data", e);
/////////////////////////////////////////////////////////////////////////
0:                 Log.trace("TradeJdbc:getAccountProfileData", accountID);
1:             Log.error("TradeJdbc:getAccountProfileData -- error getting profile data", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:updateAccountProfileData - inSession(" + this.inSession + ")", userID);
/////////////////////////////////////////////////////////////////////////
0:             Log.error("TradeJdbc:getAccountProfileData -- error getting profile data", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:updateQuotePriceVolume", symbol, changeFactor, new Double(sharesTraded));
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:updateQuotePriceVolume - inSession(" + this.inSession + ")", symbol,
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:updateQuotePriceVolume -- error updating quote price/volume for symbol:" + symbol);
/////////////////////////////////////////////////////////////////////////
0:         Log.error("TradeJdbc:publishQuotePriceChange - is not implemented for this runtime mode");
0:         throw new UnsupportedOperationException("TradeJdbc:publishQuotePriceChange-  is not implemented for this runtime mode");
/////////////////////////////////////////////////////////////////////////
1:                 Log.trace("TradeJdbc:login - inSession(" + this.inSession + ")", userID, password);
/////////////////////////////////////////////////////////////////////////
1:                 Log.error("TradeJdbc:login -- failure to find account for" + userID);
/////////////////////////////////////////////////////////////////////////
1:                     "TradeJdbc:Login failure for user: " + userID + "\n\tIncorrect password-->" + userID + ":"
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:login -- error logging in user", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:logout - inSession(" + this.inSession + ")", userID);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:logout -- error logging out user", e);
/////////////////////////////////////////////////////////////////////////
1:                 Log.traceEnter("TradeJdbc:register - inSession(" + this.inSession + ")");
/////////////////////////////////////////////////////////////////////////
1:                 Log.traceExit("TradeJdbc:register");
1:             Log.error("TradeJdbc:register -- error registering new user", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getAccountDataFromResultSet -- cannot find account data");
/////////////////////////////////////////////////////////////////////////
1:             Log.error("TradeJdbc:getAccountProfileDataFromResultSet -- cannot find accountprofile data");
/////////////////////////////////////////////////////////////////////////
1:                     Log.trace("TradeJdbc:releaseConn -- connection closed, connCount=" + connCount);
1:             Log.error("TradeJdbc:releaseConnection -- failed to close connection", e);
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:getConn -- new connection allocated, IsolationLevel="
/////////////////////////////////////////////////////////////////////////
1:             Log.log("TradeJdbc:rollBack -- rolling back conn due to previously caught exception -- inGlobalTxn="
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:init -- *** initializing");
1:             Log.trace("TradeJdbc:init -- +++ initialized");
/////////////////////////////////////////////////////////////////////////
1:             Log.trace("TradeJdbc:destroy");
1:             Log.error("TradeJdbc:destroy", e);
commit:ea52306
/////////////////////////////////////////////////////////////////////////
1:     private DataSource dataSource= null;
/////////////////////////////////////////////////////////////////////////
1:     private void lookupDataSource() throws Exception {
1:         if (dataSource == null) {
0:             context = new InitialContext();
0:             dataSource = (DataSource) context.lookup(dsName);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         lookupDataSource();
commit:56a6860
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.samples.ariestrader.persist.jdbc;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.samples.ariestrader.api.TradeServices;
1: import org.apache.aries.samples.ariestrader.beans.AccountDataBeanImpl;
1: import org.apache.aries.samples.ariestrader.beans.AccountProfileDataBeanImpl;
1: import org.apache.aries.samples.ariestrader.beans.HoldingDataBeanImpl;
1: import org.apache.aries.samples.ariestrader.beans.OrderDataBeanImpl;
1: import org.apache.aries.samples.ariestrader.beans.QuoteDataBeanImpl;
0: import org.apache.aries.samples.ariestrader.persistence.api.AccountDataBean;
0: import org.apache.aries.samples.ariestrader.persistence.api.AccountProfileDataBean;
0: import org.apache.aries.samples.ariestrader.persistence.api.HoldingDataBean;
0: import org.apache.aries.samples.ariestrader.persistence.api.MarketSummaryDataBean;
0: import org.apache.aries.samples.ariestrader.persistence.api.OrderDataBean;
0: import org.apache.aries.samples.ariestrader.persistence.api.QuoteDataBean;
1: import org.apache.aries.samples.ariestrader.util.FinancialUtils;
1: import org.apache.aries.samples.ariestrader.util.Log;
1: import org.apache.aries.samples.ariestrader.util.TradeConfig;
/////////////////////////////////////////////////////////////////////////
1:  * specified in the {@link org.apache.aries.samples.ariestrader.TradeServices}
1:  * @see org.apache.aries.samples.ariestrader.TradeServices
commit:3be9855
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.samples.daytrader.persist.jdbc;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.samples.daytrader.api.TradeServices;
0: import org.apache.aries.samples.daytrader.beans.AccountDataBeanImpl;
0: import org.apache.aries.samples.daytrader.beans.AccountProfileDataBeanImpl;
0: import org.apache.aries.samples.daytrader.beans.HoldingDataBeanImpl;
0: import org.apache.aries.samples.daytrader.beans.OrderDataBeanImpl;
0: import org.apache.aries.samples.daytrader.beans.QuoteDataBeanImpl;
0: import org.apache.aries.samples.daytrader.persistence.api.AccountDataBean;
0: import org.apache.aries.samples.daytrader.persistence.api.AccountProfileDataBean;
0: import org.apache.aries.samples.daytrader.persistence.api.HoldingDataBean;
0: import org.apache.aries.samples.daytrader.persistence.api.MarketSummaryDataBean;
0: import org.apache.aries.samples.daytrader.persistence.api.OrderDataBean;
0: import org.apache.aries.samples.daytrader.persistence.api.QuoteDataBean;
0: import org.apache.aries.samples.daytrader.util.FinancialUtils;
0: import org.apache.aries.samples.daytrader.util.Log;
0: import org.apache.aries.samples.daytrader.util.TradeConfig;
/////////////////////////////////////////////////////////////////////////
0:  * specified in the {@link org.apache.aries.samples.daytrader.TradeServices}
0:  * @see org.apache.aries.samples.daytrader.TradeServices
commit:92b2ae7
commit:3d66c06
commit:628add4
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
0: package org.apache.geronimo.samples.daytrader.persist.jdbc;
1: 
1: import java.math.BigDecimal;
1: import java.util.Collection;
1: import java.util.ArrayList;
0: import javax.naming.InitialContext;
1: 
1: import javax.sql.DataSource;
1: 
0: import org.apache.geronimo.samples.daytrader.api.TradeServices;
0: import org.apache.geronimo.samples.daytrader.beans.AccountDataBeanImpl;
0: import org.apache.geronimo.samples.daytrader.beans.AccountProfileDataBeanImpl;
0: import org.apache.geronimo.samples.daytrader.beans.HoldingDataBeanImpl;
0: import org.apache.geronimo.samples.daytrader.beans.OrderDataBeanImpl;
0: import org.apache.geronimo.samples.daytrader.beans.QuoteDataBeanImpl;
0: import org.apache.geronimo.samples.daytrader.persistence.api.AccountDataBean;
0: import org.apache.geronimo.samples.daytrader.persistence.api.AccountProfileDataBean;
0: import org.apache.geronimo.samples.daytrader.persistence.api.HoldingDataBean;
0: import org.apache.geronimo.samples.daytrader.persistence.api.MarketSummaryDataBean;
0: import org.apache.geronimo.samples.daytrader.persistence.api.OrderDataBean;
0: import org.apache.geronimo.samples.daytrader.persistence.api.QuoteDataBean;
0: import org.apache.geronimo.samples.daytrader.util.FinancialUtils;
0: import org.apache.geronimo.samples.daytrader.util.Log;
0: import org.apache.geronimo.samples.daytrader.util.TradeConfig;
1: 
0: import java.rmi.RemoteException;
1: import java.sql.Connection;
0: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.Statement;
1: import java.sql.Timestamp;
1: 
1: 
1: /**
0:  * TradeJDBCDirect uses direct JDBC access to a
1:  * <code>javax.sql.DataSource</code> to implement the business methods of the
1:  * Trade online broker application. These business methods represent the
1:  * features and operations that can be performed by customers of the brokerage
1:  * such as login, logout, get a stock quote, buy or sell a stock, etc. and are
0:  * specified in the {@link org.apache.geronimo.samples.daytrader.TradeServices}
1:  * interface
1:  * 
1:  * Note: In order for this class to be thread-safe, a new TradeJDBC must be
1:  * created for each call to a method from the TradeInterface interface.
1:  * Otherwise, pooled connections may not be released.
1:  * 
0:  * @see org.apache.geronimo.samples.daytrader.TradeServices
1:  * 
1:  */
1: 
0: public class TradeJDBCDirect implements TradeServices {
1: 
0:     private static String dsName = TradeConfig.DATASOURCE;
1: 
0: //    private static DataSource dataSource = null;
0:     private DataSource dataSource;
1: 
1:     private static BigDecimal ZERO = new BigDecimal(0.0);
1: 
1:     private boolean inGlobalTxn = false;
1: 
1:     private boolean inSession = false;
1: 
0:     private static InitialContext context;
1: 
1:     private static int connCount = 0;
1: 
1:     private static Integer lock = new Integer(0);
1: 
1:     private static boolean initialized = false;
1: 
1:     /**
0:      * Zero arg constructor for TradeJDBCDirect
1:      */
0:     public TradeJDBCDirect() {
1:     }
1: 
0:     public TradeJDBCDirect(boolean inSession) {
1:         this.inSession = inSession;
1:     }
1: 
1:     /**
1:      * set data source
1:      */
1:     public void setDataSource(DataSource dataSource) {
1:             this.dataSource = dataSource;
1:     }
1: 
1:     /**
1:      * setInSession
1:      */
1:     public void setInSession(boolean inSession) {
1:         this.inSession = inSession;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getMarketSummary()
1:      */
1:     public MarketSummaryDataBean getMarketSummary() throws Exception {
1:         MarketSummaryDataBean marketSummaryData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getMarketSummary - inSession(" + this.inSession + ")");
1: 
1:             conn = getConn();
1:             PreparedStatement stmt =
1:                 getStatement(conn, getTSIAQuotesOrderByChangeSQL, ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                     ResultSet.CONCUR_READ_ONLY);
1: 
1:             ArrayList topGainersData = new ArrayList(5);
1:             ArrayList topLosersData = new ArrayList(5);
1: 
1:             ResultSet rs = stmt.executeQuery();
1: 
1:             int count = 0;
1:             while (rs.next() && (count++ < 5)) {
1:                 QuoteDataBean quoteData = getQuoteDataFromResultSet(rs);
1:                 topLosersData.add(quoteData);
1:             }
1: 
1:             stmt.close();
1:             stmt =
1:                 getStatement(conn, "select * from quoteejb q where q.symbol like 's:1__' order by q.change1 DESC",
1:                     ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:             rs = stmt.executeQuery();
1: 
1:             count = 0;
1:             while (rs.next() && (count++ < 5)) {
1:                 QuoteDataBean quoteData = getQuoteDataFromResultSet(rs);
1:                 topGainersData.add(quoteData);
1:             }
1: 
1:             stmt.close();
1: 
1:             BigDecimal TSIA = ZERO;
1:             BigDecimal openTSIA = ZERO;
1:             double volume = 0.0;
1: 
1:             if ((topGainersData.size() > 0) || (topLosersData.size() > 0)) {
1: 
1:                 stmt = getStatement(conn, getTSIASQL);
1:                 rs = stmt.executeQuery();
1: 
1:                 if (!rs.next())
0:                     Log.error("TradeJDBCDirect:getMarketSummary -- error w/ getTSIASQL -- no results");
1:                 else
1:                     TSIA = rs.getBigDecimal("TSIA");
1:                 stmt.close();
1: 
1:                 stmt = getStatement(conn, getOpenTSIASQL);
1:                 rs = stmt.executeQuery();
1: 
1:                 if (!rs.next())
0:                     Log.error("TradeJDBCDirect:getMarketSummary -- error w/ getOpenTSIASQL -- no results");
1:                 else
1:                     openTSIA = rs.getBigDecimal("openTSIA");
1:                 stmt.close();
1: 
1:                 stmt = getStatement(conn, getTSIATotalVolumeSQL);
1:                 rs = stmt.executeQuery();
1: 
1:                 if (!rs.next())
0:                     Log.error("TradeJDBCDirect:getMarketSummary -- error w/ getTSIATotalVolumeSQL -- no results");
1:                 else
1:                     volume = rs.getDouble("totalVolume");
1:                 stmt.close();
1:             }
1:             commit(conn);
1: 
1:             marketSummaryData = new MarketSummaryDataBean(TSIA, openTSIA, volume, topGainersData, topLosersData);
1: 
1:         }
1: 
1:         catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getMarketSummary -- error getting summary", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return marketSummaryData;
1: 
1:     }
1: 
1:     /**
1:      * @see TradeServices#buy(String, String, double)
1:      */
1:     public OrderDataBean buy(String userID, String symbol, double quantity, int orderProcessingMode) throws Exception {
1: 
1:         Connection conn = null;
1:         OrderDataBean orderData = null;
1: 
1:         /*
1:          * total = (quantity * purchasePrice) + orderFee
1:          */
1:         BigDecimal total;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:buy - inSession(" + this.inSession + ")", userID, symbol, new Double(quantity));
1: 
1:             conn = getConn();
1: 
1:             AccountDataBean accountData = getAccountData(conn, userID);
1:             QuoteDataBean quoteData = getQuoteData(conn, symbol);
1:             HoldingDataBean holdingData = null; // the buy operation will create
1:             // the holding
1: 
1:             orderData = createOrder(conn, accountData, quoteData, holdingData, "buy", quantity);
1: 
1:             // Update -- account should be credited during completeOrder
1:             BigDecimal price = quoteData.getPrice();
1:             BigDecimal orderFee = orderData.getOrderFee();
1:             total = (new BigDecimal(quantity).multiply(price)).add(orderFee);
1:             // subtract total from account balance
1:             creditAccountBalance(conn, accountData, total.negate());
1: 
1:             completeOrder(conn, orderData.getOrderID());
1: 
1:             orderData = getOrderData(conn, orderData.getOrderID().intValue());
1: 
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:buy error - rolling back", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1: 
0:         //after the purchase or sell of a stock, update the stocks volume and
1:         // price
1:         updateQuotePriceVolume(symbol, TradeConfig.getRandomPriceChangeFactor(), quantity);
1: 
1:         return orderData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#sell(String, Integer)
1:      */
1:     public OrderDataBean sell(String userID, Integer holdingID, int orderProcessingMode) throws Exception {
1: 
1:         Connection conn = null;
1:         OrderDataBean orderData = null;
1: 
1:         /*
1:          * total = (quantity * purchasePrice) + orderFee
1:          */
1:         BigDecimal total;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:sell - inSession(" + this.inSession + ")", userID, holdingID);
1: 
1:             conn = getConn();
1: 
1:             AccountDataBean accountData = getAccountData(conn, userID);
1:             HoldingDataBean holdingData = getHoldingData(conn, holdingID.intValue());
1:             QuoteDataBean quoteData = null;
1:             if (holdingData != null)
1:                 quoteData = getQuoteData(conn, holdingData.getQuoteID());
1: 
1:             if ((accountData == null) || (holdingData == null) || (quoteData == null)) {
1:                 String error =
0:                     "TradeJDBCDirect:sell -- error selling stock -- unable to find:  \n\taccount=" + accountData
1:                         + "\n\tholding=" + holdingData + "\n\tquote=" + quoteData + "\nfor user: " + userID
1:                         + " and holdingID: " + holdingID;
1:                 Log.error(error);
1:                 rollBack(conn, new Exception(error));
1: 
1:                 return orderData;
1:             }
1: 
1:             double quantity = holdingData.getQuantity();
1: 
1:             orderData = createOrder(conn, accountData, quoteData, holdingData, "sell", quantity);
1: 
1:             // Set the holdingSymbol purchaseDate to selling to signify the sell
1:             // is "inflight"
1:             updateHoldingStatus(conn, holdingData.getHoldingID(), holdingData.getQuoteID());
1: 
1:             // UPDATE -- account should be credited during completeOrder
1:             BigDecimal price = quoteData.getPrice();
1:             BigDecimal orderFee = orderData.getOrderFee();
1:             total = (new BigDecimal(quantity).multiply(price)).subtract(orderFee);
1:             creditAccountBalance(conn, accountData, total);
1: 
1:             completeOrder(conn, orderData.getOrderID());
1: 
1:             orderData = getOrderData(conn, orderData.getOrderID().intValue());
1: 
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:sell error", e);
1:             rollBack(conn, e);
1: 
1:         } finally {
1:             releaseConn(conn);
1:         }
1: 
1:         if (!(orderData.getOrderStatus().equalsIgnoreCase("cancelled")))
1:             //after the purchase or sell of a stock, update the stocks volume
1:             // and price
1:             updateQuotePriceVolume(orderData.getSymbol(), TradeConfig.getRandomPriceChangeFactor(), orderData.getQuantity());
1: 
1:         return orderData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#queueOrder(Integer)
1:      */
1:     public void queueOrder(Integer orderID, boolean twoPhase) throws Exception {
1:         throw new RuntimeException("TradeServices#queueOrder(Integer) is not supported in this runtime mode");
1:     }
1: 
1:     /**
1:      * @see TradeServices#completeOrder(Integer)
1:      */
1:     public OrderDataBean completeOrder(Integer orderID, boolean twoPhase) throws Exception {
1:         OrderDataBean orderData = null;
1:         Connection conn = null;
1: 
1:         try { // twoPhase
1: 
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:completeOrder - inSession(" + this.inSession + ")", orderID);
1:             setInGlobalTxn(!inSession && twoPhase);
1:             conn = getConn();
1:             orderData = completeOrder(conn, orderID);
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:completeOrder -- error completing order", e);
1:             rollBack(conn, e);
1:             cancelOrder(orderID, twoPhase);
1:         } finally {
1:             releaseConn(conn);
1:         }
1: 
1:         return orderData;
1: 
1:     }
1: 
1:     private OrderDataBean completeOrder(Connection conn, Integer orderID) throws Exception {
1: 
1:         OrderDataBean orderData = null;
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:completeOrderInternal - inSession(" + this.inSession + ")", orderID);
1: 
1:         PreparedStatement stmt = getStatement(conn, getOrderSQL);
1:         stmt.setInt(1, orderID.intValue());
1: 
1:         ResultSet rs = stmt.executeQuery();
1: 
1:         if (!rs.next()) {
0:             Log.error("TradeJDBCDirect:completeOrder -- unable to find order: " + orderID);
1:             stmt.close();
1:             return orderData;
1:         }
1:         orderData = getOrderDataFromResultSet(rs);
1: 
1:         String orderType = orderData.getOrderType();
1:         String orderStatus = orderData.getOrderStatus();
1: 
1:         // if (order.isCompleted())
1:         if ((orderStatus.compareToIgnoreCase("completed") == 0)
1:             || (orderStatus.compareToIgnoreCase("alertcompleted") == 0)
1:             || (orderStatus.compareToIgnoreCase("cancelled") == 0))
0:             throw new Exception("TradeJDBCDirect:completeOrder -- attempt to complete Order that is already completed");
1: 
1:         int accountID = rs.getInt("account_accountID");
1:         String quoteID = rs.getString("quote_symbol");
1:         int holdingID = rs.getInt("holding_holdingID");
1: 
1:         BigDecimal price = orderData.getPrice();
1:         double quantity = orderData.getQuantity();
1:         BigDecimal orderFee = orderData.getOrderFee();
1: 
1:         // get the data for the account and quote
1:         // the holding will be created for a buy or extracted for a sell
1: 
1:         /*
1:          * Use the AccountID and Quote Symbol from the Order AccountDataBean accountData = getAccountData(accountID,
1:          * conn); QuoteDataBean quoteData = getQuoteData(conn, quoteID);
1:          */
1:         String userID = getAccountProfileData(conn, new Integer(accountID)).getUserID();
1: 
1:         HoldingDataBean holdingData = null;
1: 
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:completeOrder--> Completing Order " + orderData.getOrderID() + "\n\t Order info: "
1:                 + orderData + "\n\t Account info: " + accountID + "\n\t Quote info: " + quoteID);
1: 
1:         // if (order.isBuy())
1:         if (orderType.compareToIgnoreCase("buy") == 0) {
1:             /*
1:              * Complete a Buy operation - create a new Holding for the Account - deduct the Order cost from the Account
1:              * balance
1:              */
1: 
1:             holdingData = createHolding(conn, accountID, quoteID, quantity, price);
1:             updateOrderHolding(conn, orderID.intValue(), holdingData.getHoldingID().intValue());
1:         }
1: 
1:         // if (order.isSell()) {
1:         if (orderType.compareToIgnoreCase("sell") == 0) {
1:             /*
1:              * Complete a Sell operation - remove the Holding from the Account - deposit the Order proceeds to the
1:              * Account balance
1:              */
1:             holdingData = getHoldingData(conn, holdingID);
1:             if (holdingData == null)
0:                 Log.debug("TradeJDBCDirect:completeOrder:sell -- user: " + userID + " already sold holding: " + holdingID);
1:             else
1:                 removeHolding(conn, holdingID, orderID.intValue());
1: 
1:         }
1: 
1:         updateOrderStatus(conn, orderData.getOrderID(), "closed");
1: 
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:completeOrder--> Completed Order " + orderData.getOrderID() + "\n\t Order info: "
1:                 + orderData + "\n\t Account info: " + accountID + "\n\t Quote info: " + quoteID + "\n\t Holding info: "
1:                 + holdingData);
1: 
1:         stmt.close();
1: 
1:         commit(conn);
1: 
1:         // signify this order for user userID is complete
1:         orderCompleted(userID, orderID);
1: 
1:         return orderData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#cancelOrder(Integer, boolean)
1:      */
1:     public void cancelOrder(Integer orderID, boolean twoPhase) throws Exception {
1:         OrderDataBean orderData = null;
1:         Connection conn = null;
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:cancelOrder - inSession(" + this.inSession + ")", orderID);
1:             setInGlobalTxn(!inSession && twoPhase);
1:             conn = getConn();
1:             cancelOrder(conn, orderID);
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:cancelOrder -- error cancelling order: " + orderID, e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:     }
1: 
1:     private void cancelOrder(Connection conn, Integer orderID) throws Exception {
1:         updateOrderStatus(conn, orderID, "cancelled");
1:     }
1: 
1:     public void orderCompleted(String userID, Integer orderID) throws Exception {
0: //        throw new UnsupportedOperationException("TradeJDBCDirect:orderCompleted method not supported");
1:         if (Log.doTrace())
1:             Log.trace("OrderCompleted", userID, orderID);
1:     }
1: 
1:     private HoldingDataBean createHolding(Connection conn, int accountID, String symbol, double quantity,
1:         BigDecimal purchasePrice) throws Exception {
1:         HoldingDataBean holdingData = null;
1: 
1:         Timestamp purchaseDate = new Timestamp(System.currentTimeMillis());
1:         PreparedStatement stmt = getStatement(conn, createHoldingSQL);
1: 
1:         Integer holdingID = KeySequenceDirect.getNextID(conn, "holding", inSession, getInGlobalTxn());
1:         stmt.setInt(1, holdingID.intValue());
1:         stmt.setTimestamp(2, purchaseDate);
1:         stmt.setBigDecimal(3, purchasePrice);
1:         stmt.setDouble(4, quantity);
1:         stmt.setString(5, symbol);
1:         stmt.setInt(6, accountID);
0:         int rowCount = stmt.executeUpdate();
1: 
1:         stmt.close();
1: 
1:         return getHoldingData(conn, holdingID.intValue());
1:     }
1: 
1:     private void removeHolding(Connection conn, int holdingID, int orderID) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, removeHoldingSQL);
1: 
1:         stmt.setInt(1, holdingID);
0:         int rowCount = stmt.executeUpdate();
1:         stmt.close();
1: 
1:         // set the HoldingID to NULL for the purchase and sell order now that
1:         // the holding as been removed
1:         stmt = getStatement(conn, removeHoldingFromOrderSQL);
1: 
1:         stmt.setInt(1, holdingID);
0:         rowCount = stmt.executeUpdate();
1:         stmt.close();
1: 
1:     }
1: 
1:     private OrderDataBean createOrder(Connection conn, AccountDataBean accountData, QuoteDataBean quoteData,
1:         HoldingDataBean holdingData, String orderType, double quantity) throws Exception {
1:         OrderDataBean orderData = null;
1: 
1:         Timestamp currentDate = new Timestamp(System.currentTimeMillis());
1: 
1:         PreparedStatement stmt = getStatement(conn, createOrderSQL);
1: 
1:         Integer orderID = KeySequenceDirect.getNextID(conn, "order", inSession, getInGlobalTxn());
1:         stmt.setInt(1, orderID.intValue());
1:         stmt.setString(2, orderType);
1:         stmt.setString(3, "open");
1:         stmt.setTimestamp(4, currentDate);
1:         stmt.setDouble(5, quantity);
1:         stmt.setBigDecimal(6, quoteData.getPrice().setScale(FinancialUtils.SCALE, FinancialUtils.ROUND));
1:         stmt.setBigDecimal(7, TradeConfig.getOrderFee(orderType));
1:         stmt.setInt(8, accountData.getAccountID().intValue());
1:         if (holdingData == null)
1:             stmt.setNull(9, java.sql.Types.INTEGER);
1:         else
1:             stmt.setInt(9, holdingData.getHoldingID().intValue());
1:         stmt.setString(10, quoteData.getSymbol());
0:         int rowCount = stmt.executeUpdate();
1: 
1:         stmt.close();
1: 
1:         return getOrderData(conn, orderID.intValue());
1:     }
1: 
1:     /**
1:      * @see TradeServices#getOrders(String)
1:      */
1:     public Collection getOrders(String userID) throws Exception {
1: 
1:         Collection orderDataBeans = new ArrayList();
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getOrders - inSession(" + this.inSession + ")", userID);
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, getOrdersByUserSQL);
1:             stmt.setString(1, userID);
1: 
1:             ResultSet rs = stmt.executeQuery();
1: 
1:             // TODO: return top 5 orders for now -- next version will add a
1:             // getAllOrders method
1:             // also need to get orders sorted by order id descending
1:             int i = 0;
1:             while ((rs.next()) && (i++ < 5)) {
1:                 OrderDataBean orderData = getOrderDataFromResultSet(rs);
1:                 orderDataBeans.add(orderData);
1:             }
1: 
1:             stmt.close();
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getOrders -- error getting user orders", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return orderDataBeans;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getClosedOrders(String)
1:      */
1:     public Collection getClosedOrders(String userID) throws Exception {
1: 
1:         Collection orderDataBeans = new ArrayList();
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getClosedOrders - inSession(" + this.inSession + ")", userID);
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, getClosedOrdersSQL);
1:             stmt.setString(1, userID);
1: 
1:             ResultSet rs = stmt.executeQuery();
1: 
1:             while (rs.next()) {
1:                 OrderDataBean orderData = getOrderDataFromResultSet(rs);
1:                 orderData.setOrderStatus("completed");
1:                 updateOrderStatus(conn, orderData.getOrderID(), orderData.getOrderStatus());
1:                 orderDataBeans.add(orderData);
1: 
1:             }
1: 
1:             stmt.close();
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getOrders -- error getting user orders", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return orderDataBeans;
1:     }
1: 
1:     /**
1:      * @see TradeServices#createQuote(String, String, BigDecimal)
1:      */
1:     public QuoteDataBean createQuote(String symbol, String companyName, BigDecimal price) throws Exception {
1: 
1:         QuoteDataBean quoteData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.traceEnter("TradeJDBCDirect:createQuote - inSession(" + this.inSession + ")");
1: 
1:             price = price.setScale(FinancialUtils.SCALE, FinancialUtils.ROUND);
1:             double volume = 0.0, change = 0.0;
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, createQuoteSQL);
1:             stmt.setString(1, symbol); // symbol
1:             stmt.setString(2, companyName); // companyName
1:             stmt.setDouble(3, volume); // volume
1:             stmt.setBigDecimal(4, price); // price
1:             stmt.setBigDecimal(5, price); // open
1:             stmt.setBigDecimal(6, price); // low
1:             stmt.setBigDecimal(7, price); // high
1:             stmt.setDouble(8, change); // change
1: 
1:             stmt.executeUpdate();
1:             stmt.close();
1:             commit(conn);
1: 
1:             quoteData = new QuoteDataBeanImpl(symbol, companyName, volume, price, price, price, price, change);
1:             if (Log.doTrace())
0:                 Log.traceExit("TradeJDBCDirect:createQuote");
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:createQuote -- error creating quote", e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return quoteData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getQuote(String)
1:      */
1: 
1:     public QuoteDataBean getQuote(String symbol) throws Exception {
1: 
1:         QuoteDataBean quoteData = null;
1:         Connection conn = null;
1: 
1:         if ((symbol == null) || (symbol.length() == 0) || (symbol.length() > 10)) {
1:             if (Log.doTrace()) {
0:                 Log.trace("TradeJDBCDirect:getQuote   ---  primitive workload");
1:             }
1:             return new QuoteDataBeanImpl("Invalid symbol", "", 0.0, FinancialUtils.ZERO, FinancialUtils.ZERO, FinancialUtils.ZERO, FinancialUtils.ZERO, 0.0);
1:         }
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getQuote - inSession(" + this.inSession + ")", symbol);
1: 
1:             conn = getConn();
1:             quoteData = getQuote(conn, symbol);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getQuote -- error getting quote", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return quoteData;
1:     }
1: 
1:     private QuoteDataBean getQuote(Connection conn, String symbol) throws Exception {
1:         QuoteDataBean quoteData = null;
1:         PreparedStatement stmt = getStatement(conn, getQuoteSQL);
1:         stmt.setString(1, symbol); // symbol
1: 
1:         ResultSet rs = stmt.executeQuery();
1: 
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getQuote -- failure no result.next() for symbol: " + symbol);
1: 
1:         else
1:             quoteData = getQuoteDataFromResultSet(rs);
1: 
1:         stmt.close();
1: 
1:         return quoteData;
1:     }
1: 
1:     private QuoteDataBean getQuoteForUpdate(Connection conn, String symbol) throws Exception {
1:         QuoteDataBean quoteData = null;
1:         PreparedStatement stmt = getStatement(conn, getQuoteForUpdateSQL);
1:         stmt.setString(1, symbol); // symbol
1: 
1:         ResultSet rs = stmt.executeQuery();
1: 
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getQuote -- failure no result.next()");
1: 
1:         else
1:             quoteData = getQuoteDataFromResultSet(rs);
1: 
1:         stmt.close();
1: 
1:         return quoteData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getAllQuotes(String)
1:      */
1:     public Collection getAllQuotes() throws Exception {
1: 
1:         Collection quotes = new ArrayList();
1:         QuoteDataBean quoteData = null;
1:         Connection conn = null;
1: 
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:getAllQuotes");
1: 
1:         try {
1:             conn = getConn();
1: 
1:             PreparedStatement stmt = getStatement(conn, getAllQuotesSQL);
1: 
1:             ResultSet rs = stmt.executeQuery();
1: 
1:             while (!rs.next()) {
1:                 quoteData = getQuoteDataFromResultSet(rs);
1:                 quotes.add(quoteData);
1:             }
1: 
1:             stmt.close();
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getAllQuotes", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1: 
1:         return quotes;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getHoldings(String)
1:      */
1:     public Collection getHoldings(String userID) throws Exception {
1: 
1:         Collection holdingDataBeans = new ArrayList();
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getHoldings - inSession(" + this.inSession + ")", userID);
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, getHoldingsForUserSQL);
1:             stmt.setString(1, userID);
1: 
1:             ResultSet rs = stmt.executeQuery();
1: 
1:             while (rs.next()) {
1:                 HoldingDataBean holdingData = getHoldingDataFromResultSet(rs);
1:                 holdingDataBeans.add(holdingData);
1:             }
1: 
1:             stmt.close();
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getHoldings -- error getting user holings", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return holdingDataBeans;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getHolding(Integer)
1:      */
1:     public HoldingDataBean getHolding(Integer holdingID) throws Exception {
1: 
1:         HoldingDataBean holdingData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getHolding - inSession(" + this.inSession + ")", holdingID);
1: 
1:             conn = getConn();
1:             holdingData = getHoldingData(holdingID.intValue());
1: 
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getHolding -- error getting holding " + holdingID + "", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return holdingData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getAccountData(String)
1:      */
1:     public AccountDataBean getAccountData(String userID) throws Exception {
1: 
1:         try {
1:             AccountDataBean accountData = null;
1:             Connection conn = null;
1:             try {
1:                 if (Log.doTrace())
0:                     Log.trace("TradeJDBCDirect:getAccountData - inSession(" + this.inSession + ")", userID);
1: 
1:                 conn = getConn();
1:                 accountData = getAccountData(conn, userID);
1:                 commit(conn);
1: 
1:             } catch (Exception e) {
0:                 Log.error("TradeJDBCDirect:getAccountData -- error getting account data", e);
1:                 rollBack(conn, e);
1:             } finally {
1:                 releaseConn(conn);
1:             }
1:             return accountData;
1:         } catch (Exception e) {
1:             throw new Exception(e.getMessage(), e);
1:         }
1:     }
1: 
1:     private AccountDataBean getAccountData(Connection conn, String userID) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, getAccountForUserSQL);
1:         stmt.setString(1, userID);
1:         ResultSet rs = stmt.executeQuery();
1:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:         stmt.close();
1:         return accountData;
1:     }
1: 
1:     private AccountDataBean getAccountDataForUpdate(Connection conn, String userID) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, getAccountForUserForUpdateSQL);
1:         stmt.setString(1, userID);
1:         ResultSet rs = stmt.executeQuery();
1:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:         stmt.close();
1:         return accountData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getAccountData(String)
1:      */
1:     public AccountDataBean getAccountData(int accountID) throws Exception {
1:         AccountDataBean accountData = null;
1:         Connection conn = null;
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getAccountData - inSession(" + this.inSession + ")", new Integer(accountID));
1: 
1:             conn = getConn();
1:             accountData = getAccountData(accountID, conn);
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getAccountData -- error getting account data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return accountData;
1:     }
1: 
1:     private AccountDataBean getAccountData(int accountID, Connection conn) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, getAccountSQL);
1:         stmt.setInt(1, accountID);
1:         ResultSet rs = stmt.executeQuery();
1:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:         stmt.close();
1:         return accountData;
1:     }
1: 
0:     private AccountDataBean getAccountDataForUpdate(int accountID, Connection conn) throws Exception {
0:         PreparedStatement stmt = getStatement(conn, getAccountForUpdateSQL);
1:         stmt.setInt(1, accountID);
1:         ResultSet rs = stmt.executeQuery();
1:         AccountDataBean accountData = getAccountDataFromResultSet(rs);
1:         stmt.close();
1:         return accountData;
1:     }
1: 
0:     private QuoteDataBean getQuoteData(String symbol) throws Exception {
1:         QuoteDataBean quoteData = null;
1:         Connection conn = null;
1:         try {
1:             conn = getConn();
0:             quoteData = getQuoteData(conn, symbol);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getQuoteData -- error getting data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return quoteData;
1:     }
1: 
1:     private QuoteDataBean getQuoteData(Connection conn, String symbol) throws Exception {
1:         QuoteDataBean quoteData = null;
1:         PreparedStatement stmt = getStatement(conn, getQuoteSQL);
1:         stmt.setString(1, symbol);
1:         ResultSet rs = stmt.executeQuery();
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getQuoteData -- could not find quote for symbol=" + symbol);
1:         else
1:             quoteData = getQuoteDataFromResultSet(rs);
1:         stmt.close();
1:         return quoteData;
1:     }
1: 
1:     private HoldingDataBean getHoldingData(int holdingID) throws Exception {
1:         HoldingDataBean holdingData = null;
1:         Connection conn = null;
1:         try {
1:             conn = getConn();
1:             holdingData = getHoldingData(conn, holdingID);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getHoldingData -- error getting data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return holdingData;
1:     }
1: 
1:     private HoldingDataBean getHoldingData(Connection conn, int holdingID) throws Exception {
1:         HoldingDataBean holdingData = null;
1:         PreparedStatement stmt = getStatement(conn, getHoldingSQL);
1:         stmt.setInt(1, holdingID);
1:         ResultSet rs = stmt.executeQuery();
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getHoldingData -- no results -- holdingID=" + holdingID);
1:         else
1:             holdingData = getHoldingDataFromResultSet(rs);
1: 
1:         stmt.close();
1:         return holdingData;
1:     }
1: 
0:     private OrderDataBean getOrderData(int orderID) throws Exception {
1:         OrderDataBean orderData = null;
1:         Connection conn = null;
1:         try {
1:             conn = getConn();
0:             orderData = getOrderData(conn, orderID);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getOrderData -- error getting data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return orderData;
1:     }
1: 
1:     private OrderDataBean getOrderData(Connection conn, int orderID) throws Exception {
1:         OrderDataBean orderData = null;
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:getOrderData(conn, " + orderID + ")");
1:         PreparedStatement stmt = getStatement(conn, getOrderSQL);
1:         stmt.setInt(1, orderID);
1:         ResultSet rs = stmt.executeQuery();
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getOrderData -- no results for orderID:" + orderID);
1:         else
1:             orderData = getOrderDataFromResultSet(rs);
1:         stmt.close();
1:         return orderData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#getAccountProfileData(String)
1:      */
1:     public AccountProfileDataBean getAccountProfileData(String userID) throws Exception {
1: 
1:         AccountProfileDataBean accountProfileData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getAccountProfileData - inSession(" + this.inSession + ")", userID);
1: 
1:             conn = getConn();
1:             accountProfileData = getAccountProfileData(conn, userID);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getAccountProfileData -- error getting profile data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return accountProfileData;
1:     }
1: 
1:     private AccountProfileDataBean getAccountProfileData(Connection conn, String userID) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, getAccountProfileSQL);
1:         stmt.setString(1, userID);
1: 
1:         ResultSet rs = stmt.executeQuery();
1: 
1:         AccountProfileDataBean accountProfileData = getAccountProfileDataFromResultSet(rs);
1:         stmt.close();
1:         return accountProfileData;
1:     }
1: 
0:     private AccountProfileDataBean getAccountProfileData(Integer accountID) throws Exception {
1:         AccountProfileDataBean accountProfileData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:getAccountProfileData", accountID);
1: 
1:             conn = getConn();
0:             accountProfileData = getAccountProfileData(conn, accountID);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getAccountProfileData -- error getting profile data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return accountProfileData;
1:     }
1: 
1:     private AccountProfileDataBean getAccountProfileData(Connection conn, Integer accountID) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, getAccountProfileForAccountSQL);
1:         stmt.setInt(1, accountID.intValue());
1: 
1:         ResultSet rs = stmt.executeQuery();
1: 
1:         AccountProfileDataBean accountProfileData = getAccountProfileDataFromResultSet(rs);
1:         stmt.close();
1:         return accountProfileData;
1:     }
1: 
1:     /**
1:      * @see TradeServices#updateAccountProfile(AccountProfileDataBean)
1:      */
1:     public AccountProfileDataBean updateAccountProfile(String userID, String password, String fullName, String address, String email, String creditcard) throws Exception {                              
1: 
1:         AccountProfileDataBean accountProfileData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:updateAccountProfileData - inSession(" + this.inSession + ")", userID);
1: 
1:             conn = getConn();
1:             updateAccountProfile(conn, userID, password, fullName, address, email, creditcard);
1: 
1:             accountProfileData = getAccountProfileData(conn, userID);
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:getAccountProfileData -- error getting profile data", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return accountProfileData;
1:     }
1: 
1:     private void creditAccountBalance(Connection conn, AccountDataBean accountData, BigDecimal credit) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, creditAccountBalanceSQL);
1: 
1:         stmt.setBigDecimal(1, credit);
1:         stmt.setInt(2, accountData.getAccountID().intValue());
1: 
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1: 
1:     }
1: 
1:     // Set Timestamp to zero to denote sell is inflight
1:     // UPDATE -- could add a "status" attribute to holding
1:     private void updateHoldingStatus(Connection conn, Integer holdingID, String symbol) throws Exception {
1:         Timestamp ts = new Timestamp(0);
1:         PreparedStatement stmt = getStatement(conn, "update holdingejb set purchasedate= ? where holdingid = ?");
1: 
1:         stmt.setTimestamp(1, ts);
1:         stmt.setInt(2, holdingID.intValue());
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1:     }
1: 
1:     private void updateOrderStatus(Connection conn, Integer orderID, String status) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, updateOrderStatusSQL);
1: 
1:         stmt.setString(1, status);
1:         stmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
1:         stmt.setInt(3, orderID.intValue());
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1:     }
1: 
1:     private void updateOrderHolding(Connection conn, int orderID, int holdingID) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, updateOrderHoldingSQL);
1: 
1:         stmt.setInt(1, holdingID);
1:         stmt.setInt(2, orderID);
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1:     }
1: 
1:     private void updateAccountProfile(Connection conn, String userID, String password, String fullName, String address, String email, String creditcard) throws Exception {
1:         PreparedStatement stmt = getStatement(conn, updateAccountProfileSQL);
1: 
1:         stmt.setString(1, password);
1:         stmt.setString(2, fullName);
1:         stmt.setString(3, address);
1:         stmt.setString(4, email);
1:         stmt.setString(5, creditcard);
1:         stmt.setString(6, userID);
1: 
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1:     }
1: 
0:     private void updateQuoteVolume(Connection conn, QuoteDataBean quoteData, double quantity) throws Exception {
0:         PreparedStatement stmt = getStatement(conn, updateQuoteVolumeSQL);
1: 
0:         stmt.setDouble(1, quantity);
0:         stmt.setString(2, quoteData.getSymbol());
1: 
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1:     }
1: 
1:     public QuoteDataBean updateQuotePriceVolume(String symbol, BigDecimal changeFactor, double sharesTraded)
1:         throws Exception {
1: 
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:updateQuotePriceVolume", symbol, changeFactor, new Double(sharesTraded));
1: 
1:         return updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, TradeConfig.getPublishQuotePriceChange());
1:     }
1: 
1:     /**
1:      * Update a quote's price and volume
1:      * 
1:      * @param symbol
1:      *            The PK of the quote
1:      * @param changeFactor
1:      *            the percent to change the old price by (between 50% and 150%)
1:      * @param sharedTraded
1:      *            the ammount to add to the current volume
1:      * @param publishQuotePriceChange
1:      *            used by the PingJDBCWrite Primitive to ensure no JMS is used, should be true for all normal calls to
1:      *            this API
1:      */
1:     public QuoteDataBean updateQuotePriceVolumeInt(String symbol, BigDecimal changeFactor, double sharesTraded,
1:         boolean publishQuotePriceChange) throws Exception {
1: 
1:         if (TradeConfig.getUpdateQuotePrices() == false)
1:             return new QuoteDataBeanImpl();
1: 
1:         QuoteDataBean quoteData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:updateQuotePriceVolume - inSession(" + this.inSession + ")", symbol,
1:                     changeFactor, new Double(sharesTraded));
1: 
1:             conn = getConn();
1: 
1:             quoteData = getQuoteForUpdate(conn, symbol);
1:             BigDecimal oldPrice = quoteData.getPrice();
1:             double newVolume = quoteData.getVolume() + sharesTraded;
1: 
1:             if (oldPrice.equals(TradeConfig.PENNY_STOCK_PRICE)) {
1:                 changeFactor = TradeConfig.PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER;
1:             } else if (oldPrice.compareTo(TradeConfig.MAXIMUM_STOCK_PRICE) > 0) {
1:                 changeFactor = TradeConfig.MAXIMUM_STOCK_SPLIT_MULTIPLIER;
1:             }
1: 
1:             BigDecimal newPrice = changeFactor.multiply(oldPrice).setScale(2, BigDecimal.ROUND_HALF_UP);
1: 
0:             updateQuotePriceVolume(conn, quoteData.getSymbol(), newPrice, newVolume);
1:             quoteData = getQuote(conn, symbol);
1: 
1:             commit(conn);
1: 
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:updateQuotePriceVolume -- error updating quote price/volume for symbol:" + symbol);
1:             rollBack(conn, e);
1:             throw e;
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return quoteData;
1:     }
1: 
0:     private void updateQuotePriceVolume(Connection conn, String symbol, BigDecimal newPrice, double newVolume)
1:         throws Exception {
1: 
1:         PreparedStatement stmt = getStatement(conn, updateQuotePriceVolumeSQL);
1: 
1:         stmt.setBigDecimal(1, newPrice);
1:         stmt.setBigDecimal(2, newPrice);
1:         stmt.setDouble(3, newVolume);
0:         stmt.setString(4, symbol);
1: 
0:         int count = stmt.executeUpdate();
1:         stmt.close();
1:     }
1: 
0:     private void publishQuotePriceChange(QuoteDataBean quoteData, BigDecimal oldPrice, BigDecimal changeFactor,
0:         double sharesTraded) throws Exception {
0:         if (!TradeConfig.getPublishQuotePriceChange())
1:             return;
0:         Log.error("TradeJDBCDirect:publishQuotePriceChange - is not implemented for this runtime mode");
0:         throw new UnsupportedOperationException("TradeJDBCDirect:publishQuotePriceChange-  is not implemented for this runtime mode");
1:     }
1: 
1:     /**
1:      * @see TradeServices#login(String, String)
1:      */
1: 
1:     public AccountDataBean login(String userID, String password) throws Exception {
1: 
1:         AccountDataBean accountData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.trace("TradeJDBCDirect:login - inSession(" + this.inSession + ")", userID, password);
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, getAccountProfileSQL);
1:             stmt.setString(1, userID);
1: 
1:             ResultSet rs = stmt.executeQuery();
1:             if (!rs.next()) {
0:                 Log.error("TradeJDBCDirect:login -- failure to find account for" + userID);
1:                 throw new RuntimeException("Cannot find account for" + userID);
1:             }
1: 
1:             String pw = rs.getString("passwd");
1:             stmt.close();
1:             if ((pw == null) || (pw.equals(password) == false)) {
1:                 String error =
0:                     "TradeJDBCDirect:Login failure for user: " + userID + "\n\tIncorrect password-->" + userID + ":"
1:                         + password;
1:                 Log.error(error);
1:                 throw new Exception(error);
1:             }
1: 
1:             stmt = getStatement(conn, loginSQL);
1:             stmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
1:             stmt.setString(2, userID);
1: 
0:             int rows = stmt.executeUpdate();
0:             // ?assert rows==1?
1:             stmt.close();
1: 
1:             stmt = getStatement(conn, getAccountForUserSQL);
1:             stmt.setString(1, userID);
1:             rs = stmt.executeQuery();
1: 
1:             accountData = getAccountDataFromResultSet(rs);
1: 
1:             stmt.close();
1: 
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:login -- error logging in user", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return accountData;
1: 
1:         /*
1:          * setLastLogin( new Timestamp(System.currentTimeMillis()) ); setLoginCount( getLoginCount() + 1 );
1:          */
1:     }
1: 
1:     /**
1:      * @see TradeServices#logout(String)
1:      */
1:     public void logout(String userID) throws Exception {
1: 
1:         Connection conn = null;
1: 
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:logout - inSession(" + this.inSession + ")", userID);
1:         try {
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, logoutSQL);
1:             stmt.setString(1, userID);
1:             stmt.executeUpdate();
1:             stmt.close();
1: 
1:             commit(conn);
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:logout -- error logging out user", e);
1:             rollBack(conn, e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:     }
1: 
1:     /**
1:      * @see TradeServices#register(String, String, String, String, String, String, BigDecimal, boolean)
1:      */
1: 
1:     public AccountDataBean register(String userID, String password, String fullname, String address, String email,
1:         String creditCard, BigDecimal openBalance) throws Exception {
1: 
1:         AccountDataBean accountData = null;
1:         Connection conn = null;
1: 
1:         try {
1:             if (Log.doTrace())
0:                 Log.traceEnter("TradeJDBCDirect:register - inSession(" + this.inSession + ")");
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = getStatement(conn, createAccountSQL);
1: 
1:             Integer accountID = KeySequenceDirect.getNextID(conn, "account", inSession, getInGlobalTxn());
1:             BigDecimal balance = openBalance;
1:             Timestamp creationDate = new Timestamp(System.currentTimeMillis());
1:             Timestamp lastLogin = creationDate;
1:             int loginCount = 0;
1:             int logoutCount = 0;
1: 
1:             stmt.setInt(1, accountID.intValue());
1:             stmt.setTimestamp(2, creationDate);
1:             stmt.setBigDecimal(3, openBalance);
1:             stmt.setBigDecimal(4, balance);
1:             stmt.setTimestamp(5, lastLogin);
1:             stmt.setInt(6, loginCount);
1:             stmt.setInt(7, logoutCount);
1:             stmt.setString(8, userID);
1:             stmt.executeUpdate();
1:             stmt.close();
1: 
1:             stmt = getStatement(conn, createAccountProfileSQL);
1:             stmt.setString(1, userID);
1:             stmt.setString(2, password);
1:             stmt.setString(3, fullname);
1:             stmt.setString(4, address);
1:             stmt.setString(5, email);
1:             stmt.setString(6, creditCard);
1:             stmt.executeUpdate();
1:             stmt.close();
1: 
1:             commit(conn);
1: 
1:             accountData =
1:                 new AccountDataBeanImpl(accountID, loginCount, logoutCount, lastLogin, creationDate, balance, openBalance,
1:                     userID);
1:             if (Log.doTrace())
0:                 Log.traceExit("TradeJDBCDirect:register");
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:register -- error registering new user", e);
1:         } finally {
1:             releaseConn(conn);
1:         }
1:         return accountData;
1:     }
1: 
1:     private AccountDataBean getAccountDataFromResultSet(ResultSet rs) throws Exception {
1:         AccountDataBean accountData = null;
1: 
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getAccountDataFromResultSet -- cannot find account data");
1: 
1:         else
1:             accountData =
1:                 new AccountDataBeanImpl(new Integer(rs.getInt("accountID")), rs.getInt("loginCount"), rs
1:                     .getInt("logoutCount"), rs.getTimestamp("lastLogin"), rs.getTimestamp("creationDate"), rs
1:                     .getBigDecimal("balance"), rs.getBigDecimal("openBalance"), rs.getString("profile_userID"));
1:         return accountData;
1:     }
1: 
1:     private AccountProfileDataBean getAccountProfileDataFromResultSet(ResultSet rs) throws Exception {
1:         AccountProfileDataBean accountProfileData = null;
1: 
1:         if (!rs.next())
0:             Log.error("TradeJDBCDirect:getAccountProfileDataFromResultSet -- cannot find accountprofile data");
1:         else
1:             accountProfileData =
1:                 new AccountProfileDataBeanImpl(rs.getString("userID"), rs.getString("passwd"), rs.getString("fullName"), rs
1:                     .getString("address"), rs.getString("email"), rs.getString("creditCard"));
1: 
1:         return accountProfileData;
1:     }
1: 
1:     private HoldingDataBean getHoldingDataFromResultSet(ResultSet rs) throws Exception {
1:         HoldingDataBean holdingData = null;
1: 
1:         holdingData =
1:             new HoldingDataBeanImpl(new Integer(rs.getInt("holdingID")), rs.getDouble("quantity"), rs
1:                 .getBigDecimal("purchasePrice"), rs.getTimestamp("purchaseDate"), rs.getString("quote_symbol"));
1:         return holdingData;
1:     }
1: 
1:     private QuoteDataBean getQuoteDataFromResultSet(ResultSet rs) throws Exception {
1:         QuoteDataBean quoteData = null;
1: 
1:         quoteData =
1:             new QuoteDataBeanImpl(rs.getString("symbol"), rs.getString("companyName"), rs.getDouble("volume"), rs
1:                 .getBigDecimal("price"), rs.getBigDecimal("open1"), rs.getBigDecimal("low"), rs.getBigDecimal("high"),
1:                 rs.getDouble("change1"));
1:         return quoteData;
1:     }
1: 
1:     private OrderDataBean getOrderDataFromResultSet(ResultSet rs) throws Exception {
1:         OrderDataBean orderData = null;
1: 
1:         orderData =
1:             new OrderDataBeanImpl(new Integer(rs.getInt("orderID")), rs.getString("orderType"),
1:                 rs.getString("orderStatus"), rs.getTimestamp("openDate"), rs.getTimestamp("completionDate"), rs
1:                     .getDouble("quantity"), rs.getBigDecimal("price"), rs.getBigDecimal("orderFee"), rs
1:                     .getString("quote_symbol"));
1:         return orderData;
1:     }
1: 
1: 
1:     private void releaseConn(Connection conn) throws Exception {
1:         try {
1:             if (conn != null) {
1:                 conn.close();
1:                 if (Log.doTrace()) {
1:                     synchronized (lock) {
1:                         connCount--;
1:                     }
0:                     Log.trace("TradeJDBCDirect:releaseConn -- connection closed, connCount=" + connCount);
1:                 }
1:             }
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:releaseConnection -- failed to close connection", e);
1:         }
1:     }
1: 
1:     /*
1:      * Lookup the TradeData DataSource
1:      */
0: //  private void getDataSource() throws Exception {
0: //      if (dataSource == null) {
0: //          context = new InitialContext();
0: //          dataSource = (DataSource) context.lookup(dsName);
0: //      }
0: //  }
1: 
1:     /*
1:      * Allocate a new connection to the datasource
1:      */
1:     private Connection getConn() throws Exception {
1: 
1:         Connection conn = null;
0: //        getDataSource();
1:         conn = dataSource.getConnection();
1:         conn.setAutoCommit(false);
1:         if (Log.doTrace()) {
1:             synchronized (lock) {
1:                 connCount++;
1:             }
0:             Log.trace("TradeJDBCDirect:getConn -- new connection allocated, IsolationLevel="
1:                 + conn.getTransactionIsolation() + " connectionCount = " + connCount);
1:         }
1: 
1:         return conn;
1:     }
1: 
1:     /*
1:      * Commit the provided connection if not under Global Transaction scope - conn.commit() is not allowed in a global
1:      * transaction. the txn manager will perform the commit
1:      */
1:     private void commit(Connection conn) throws Exception {
1:         if (!inSession) {
1:             if ((getInGlobalTxn() == false) && (conn != null))
1:                 conn.commit();
1:         }
1:     }
1: 
1:     /*
1:      * Rollback the statement for the given connection
1:      */
1:     private void rollBack(Connection conn, Exception e) throws Exception {
1:         if (!inSession) {
0:             Log.log("TradeJDBCDirect:rollBack -- rolling back conn due to previously caught exception -- inGlobalTxn="
1:                 + getInGlobalTxn());
1:             if ((getInGlobalTxn() == false) && (conn != null))
1:                 conn.rollback();
1:             else
1:                 throw e; // Throw the exception
1:             // so the Global txn manager will rollBack
1:         }
1:     }
1: 
1:     /*
1:      * Allocate a new prepared statment for this connection
1:      */
1:     private PreparedStatement getStatement(Connection conn, String sql) throws Exception {
1:         return conn.prepareStatement(sql);
1:     }
1: 
1:     private PreparedStatement getStatement(Connection conn, String sql, int type, int concurrency) throws Exception {
1:         return conn.prepareStatement(sql, type, concurrency);
1:     }
1: 
1:     private static final String createQuoteSQL =
1:         "insert into quoteejb " + "( symbol, companyName, volume, price, open1, low, high, change1 ) "
1:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  )";
1: 
1:     private static final String createAccountSQL =
1:         "insert into accountejb "
1:             + "( accountid, creationDate, openBalance, balance, lastLogin, loginCount, logoutCount, profile_userid) "
1:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  )";
1: 
1:     private static final String createAccountProfileSQL =
1:         "insert into accountprofileejb " + "( userid, passwd, fullname, address, email, creditcard ) "
1:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  )";
1: 
1:     private static final String createHoldingSQL =
1:         "insert into holdingejb "
1:             + "( holdingid, purchaseDate, purchasePrice, quantity, quote_symbol, account_accountid ) "
1:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ? )";
1: 
1:     private static final String createOrderSQL =
1:         "insert into orderejb "
1:             + "( orderid, ordertype, orderstatus, opendate, quantity, price, orderfee, account_accountid,  holding_holdingid, quote_symbol) "
1:             + "VALUES (  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  ,  ?  , ? , ? , ?)";
1: 
1:     private static final String removeHoldingSQL = "delete from holdingejb where holdingid = ?";
1: 
1:     private static final String removeHoldingFromOrderSQL =
1:         "update orderejb set holding_holdingid=null where holding_holdingid = ?";
1: 
1:     private final static String updateAccountProfileSQL =
1:         "update accountprofileejb set " + "passwd = ?, fullname = ?, address = ?, email = ?, creditcard = ? "
1:             + "where userid = (select profile_userid from accountejb a " + "where a.profile_userid=?)";
1: 
1:     private final static String loginSQL =
1:         "update accountejb set lastLogin=?, logincount=logincount+1 " + "where profile_userid=?";
1: 
1:     private static final String logoutSQL =
1:         "update accountejb set logoutcount=logoutcount+1 " + "where profile_userid=?";
1: 
1:     private static final String getAccountSQL = "select * from accountejb a where a.accountid = ?";
1: 
0:     private static final String getAccountForUpdateSQL = "select * from accountejb a where a.accountid = ? for update";
1: 
1:     private final static String getAccountProfileSQL =
1:         "select * from accountprofileejb ap where ap.userid = "
1:             + "(select profile_userid from accountejb a where a.profile_userid=?)";
1: 
1:     private final static String getAccountProfileForAccountSQL =
1:         "select * from accountprofileejb ap where ap.userid = "
1:             + "(select profile_userid from accountejb a where a.accountid=?)";
1: 
1:     private static final String getAccountForUserSQL =
1:         "select * from accountejb a where a.profile_userid = "
1:             + "( select userid from accountprofileejb ap where ap.userid = ?)";
1: 
1:     private static final String getAccountForUserForUpdateSQL =
1:         "select * from accountejb a where a.profile_userid = "
1:             + "( select userid from accountprofileejb ap where ap.userid = ?) for update";
1: 
1:     private static final String getHoldingSQL = "select * from holdingejb h where h.holdingid = ?";
1: 
1:     private static final String getHoldingsForUserSQL =
1:         "select * from holdingejb h where h.account_accountid = "
1:             + "(select a.accountid from accountejb a where a.profile_userid = ?)";
1: 
1:     private static final String getOrderSQL = "select * from orderejb o where o.orderid = ?";
1: 
1:     private static final String getOrdersByUserSQL =
1:         "select * from orderejb o where o.account_accountid = "
1:             + "(select a.accountid from accountejb a where a.profile_userid = ?)";
1: 
1:     private static final String getClosedOrdersSQL =
1:         "select * from orderejb o " + "where o.orderstatus = 'closed' AND o.account_accountid = "
1:             + "(select a.accountid from accountejb a where a.profile_userid = ?)";
1: 
1:     private static final String getQuoteSQL = "select * from quoteejb q where q.symbol=?";
1: 
1:     private static final String getAllQuotesSQL = "select * from quoteejb q";
1: 
1:     private static final String getQuoteForUpdateSQL = "select * from quoteejb q where q.symbol=? For Update";
1: 
1:     private static final String getTSIAQuotesOrderByChangeSQL =
1:         "select * from quoteejb q " + "where q.symbol like 's:1__' order by q.change1";
1: 
1:     private static final String getTSIASQL =
1:         "select SUM(price)/count(*) as TSIA from quoteejb q " + "where q.symbol like 's:1__'";
1: 
1:     private static final String getOpenTSIASQL =
1:         "select SUM(open1)/count(*) as openTSIA from quoteejb q " + "where q.symbol like 's:1__'";
1: 
1:     private static final String getTSIATotalVolumeSQL =
1:         "select SUM(volume) as totalVolume from quoteejb q " + "where q.symbol like 's:1__'";
1: 
1:     private static final String creditAccountBalanceSQL =
1:         "update accountejb set " + "balance = balance + ? " + "where accountid = ?";
1: 
1:     private static final String updateOrderStatusSQL =
1:         "update orderejb set " + "orderstatus = ?, completiondate = ? " + "where orderid = ?";
1: 
1:     private static final String updateOrderHoldingSQL =
1:         "update orderejb set " + "holding_holdingID = ? " + "where orderid = ?";
1: 
0:     private static final String updateQuoteVolumeSQL =
0:         "update quoteejb set " + "volume = volume + ? " + "where symbol = ?";
1: 
1:     private static final String updateQuotePriceVolumeSQL =
0:         "update quoteejb set " + "price = ?, change1 = ? - open1, volume = ? " + "where symbol = ?";
1: 
1:     public void init() {
1:         if (initialized)
1:             return;
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:init -- *** initializing");
1: 
1:         if (Log.doTrace())
0:             Log.trace("TradeJDBCDirect:init -- +++ initialized");
1: 
1:         initialized = true;
1:     }
1: 
1:     public void destroy() {
1:         try {
1:             if (!initialized)
1:                 return;
0:             Log.trace("TradeJDBCDirect:destroy");
1:         } catch (Exception e) {
0:             Log.error("TradeJDBCDirect:destroy", e);
1:         }
1:     }
1: 
1:     /**
1:      * Gets the inGlobalTxn
1:      * 
1:      * @return Returns a boolean
1:      */
1:     private boolean getInGlobalTxn() {
1:         return inGlobalTxn;
1:     }
1: 
1:     /**
1:      * Sets the inGlobalTxn
1:      * 
1:      * @param inGlobalTxn
1:      *            The inGlobalTxn to set
1:      */
1:     private void setInGlobalTxn(boolean inGlobalTxn) {
1:         this.inGlobalTxn = inGlobalTxn;
1:     }
1: 
1:     /**
1:      * Get mode - returns the persistence mode (TradeConfig.JDBC)
1:      * 
0:      * @return int mode
1:      */
0:     public int getMode() {
0:         return TradeConfig.JDBC;
1:     }
1: 
1: }
============================================================================