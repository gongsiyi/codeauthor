1:cd603d2: /*
1:cd603d2:  * Licensed to the Apache Software Foundation (ASF) under one
1:cd603d2:  * or more contributor license agreements.  See the NOTICE file
1:cd603d2:  * distributed with this work for additional information
1:cd603d2:  * regarding copyright ownership.  The ASF licenses this file
1:cd603d2:  * to you under the Apache License, Version 2.0 (the
1:cd603d2:  * "License"); you may not use this file except in compliance
1:cd603d2:  * with the License.  You may obtain a copy of the License at
1:cd603d2:  *
1:cd603d2:  *   http://www.apache.org/licenses/LICENSE-2.0
1:cd603d2:  *
1:cd603d2:  * Unless required by applicable law or agreed to in writing,
1:cd603d2:  * software distributed under the License is distributed on an
1:cd603d2:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:cd603d2:  * KIND, either express or implied.  See the License for the
1:cd603d2:  * specific language governing permissions and limitations
1:cd603d2:  * under the License.
1:cd603d2:  */
1:cd603d2: package org.apache.aries.blueprint.container;
4:cd603d2: 
1:c6816ad: import java.net.URI;
1:c6816ad: import java.net.URL;
1:c6816ad: import java.security.AccessControlContext;
1:c6816ad: import java.util.ArrayList;
1:c6816ad: import java.util.Arrays;
1:c6816ad: import java.util.Collection;
1:c6816ad: import java.util.Collections;
1:c6816ad: import java.util.LinkedHashSet;
1:c6816ad: import java.util.List;
1:c6816ad: import java.util.Map;
1:c6816ad: import java.util.Set;
1:c6816ad: import java.util.concurrent.atomic.AtomicBoolean;
1:c6816ad: 
1:cd603d2: import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
1:cd603d2: import org.apache.aries.blueprint.ExtendedBeanMetadata;
1:cd603d2: import org.apache.aries.blueprint.Processor;
1:cd603d2: import org.apache.aries.blueprint.di.Recipe;
1:cd603d2: import org.apache.aries.blueprint.di.Repository;
1:cd603d2: import org.apache.aries.blueprint.parser.ComponentDefinitionRegistryImpl;
1:cc4ce69: import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
1:cd603d2: import org.apache.aries.blueprint.parser.Parser;
1:cd603d2: import org.apache.aries.blueprint.reflect.MetadataUtil;
1:28d2e82: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
1:cd603d2: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:cd603d2: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:cd603d2: import org.osgi.service.blueprint.container.Converter;
1:cd603d2: import org.osgi.service.blueprint.container.NoSuchComponentException;
1:c6816ad: import org.osgi.service.blueprint.reflect.BeanArgument;
1:c6816ad: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.BeanProperty;
1:c6816ad: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.MapEntry;
1:c6816ad: import org.osgi.service.blueprint.reflect.MapMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.Metadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.PropsMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.RefMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:c6816ad: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:c6816ad: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:c6816ad: import org.osgi.service.blueprint.reflect.Target;
1:cd603d2: import org.slf4j.Logger;
1:cd603d2: import org.slf4j.LoggerFactory;
1:cd603d2: 
1:cd603d2: public class BlueprintContainerImpl implements ExtendedBlueprintContainer {
1:cd603d2: 
1:cd603d2:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintContainerImpl.class);
1:cd603d2: 
1:cd603d2:     private final ClassLoader loader;
1:cd603d2:     private final List<URL> resources;
1:cd603d2:     private final AggregateConverter converter;
1:cd603d2:     private final ComponentDefinitionRegistryImpl componentDefinitionRegistry;
1:cd603d2:     private final AtomicBoolean destroyed = new AtomicBoolean(false);
1:cd603d2:     private final IdSpace tempRecipeIdSpace = new IdSpace();
1:cd603d2:     private BlueprintRepository repository;
1:cd603d2:     private List<Processor> processors = new ArrayList<Processor>();
1:7782911:     private Map<String, String> properties;
1:c6816ad:     private NamespaceHandlerSet nsHandlerSet;
1:c6816ad:     
1:cd603d2:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources) throws Exception {
1:7782911:         this(loader, resources, null, true);
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources, boolean init) throws Exception {
1:7782911:         this(loader, resources, null, init);
1:7782911:     }
1:7782911: 
1:7782911:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources, Map<String, String> properties, boolean init) throws Exception {
1:c6816ad:         this(loader, resources, properties, null, init);
1:c6816ad:     }
1:c6816ad:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources, Map<String, String> properties, 
1:c6816ad:                                   NamespaceHandlerSet nsHandlerSet, boolean init) throws Exception {
1:cd603d2:         this.loader = loader;
1:cd603d2:         this.converter = new AggregateConverter(this);
1:cd603d2:         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl();
1:cd603d2:         this.resources = resources;
1:7782911:         this.properties = properties;
1:c6816ad:         this.nsHandlerSet = nsHandlerSet;
1:cd603d2:         if (init) {
1:cd603d2:             init();
1:cd603d2:         }
1:cd603d2:     }
1:7782911:     public String getProperty(String key) {
1:7782911:         if (properties != null && properties.containsKey(key)) {
1:7782911:             return properties.get(key);
1:7782911:         }
1:7782911:         return System.getProperty(key);
1:7782911:     }
1:7782911: 
1:cc4ce69:     protected NamespaceHandlerSet createNamespaceHandlerSet(Set<URI> namespaces) {
1:c6816ad:         NamespaceHandlerSet handlerSet = createNamespaceHandlerSet();
1:cd603d2:         // Check namespaces
1:cd603d2:         Set<URI> unsupported = new LinkedHashSet<URI>();
1:cd603d2:         for (URI ns : namespaces) {
1:cd603d2:             if (!handlerSet.getNamespaces().contains(ns)) {
1:cd603d2:                 unsupported.add(ns);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         if (unsupported.size() > 0) {
1:cd603d2:             throw new IllegalArgumentException("Unsupported namespaces: " + unsupported.toString());
1:cd603d2:         }
1:cc4ce69:         return handlerSet;
1:cc4ce69:     }
1:cc4ce69: 
1:c6816ad:     protected NamespaceHandlerSet createNamespaceHandlerSet() {
1:c6816ad:         return nsHandlerSet == null ? new SimpleNamespaceHandlerSet() : nsHandlerSet;
1:c6816ad:     } 
1:c6816ad:     
1:cc4ce69:     public void init() throws Exception {
1:1db978a:         init(true);
1:1db978a:     }
1:1db978a:     public void init(boolean validate) throws Exception {
1:cc4ce69:         // Parse xml resources
1:cc4ce69:         Parser parser = new Parser();
1:cc4ce69:         parser.parse(getResources());
1:cc4ce69:         // Check namespaces
1:cc4ce69:         Set<URI> namespaces = parser.getNamespaces();
1:cc4ce69:         // Create handler set
1:cc4ce69:         NamespaceHandlerSet handlerSet = createNamespaceHandlerSet(namespaces);
1:28d2e82:         // Add predefined beans
1:28d2e82:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
1:1db978a:         if (validate) {
1:1db978a:             // Validate
1:1db978a:             parser.validate(handlerSet.getSchema());
1:1db978a:         }
1:cd603d2:         // Populate
1:cd603d2:         parser.populate(handlerSet, componentDefinitionRegistry);
1:cd603d2:         // Create repository
1:cd603d2:         repository = new NoOsgiRecipeBuilder(this, tempRecipeIdSpace).createRepository();
1:cd603d2:         // Processors handling
1:cd603d2:         processTypeConverters();
1:cd603d2:         processProcessors();
1:cd603d2:         // Instantiate eager singletons
1:cd603d2:         instantiateEagerComponents();
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public void destroy() {
1:cd603d2:         repository.destroy();
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public List<URL> getResources() {
1:cd603d2:         return resources;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public Converter getConverter() {
1:cd603d2:         return converter;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public Class loadClass(String name) throws ClassNotFoundException {
1:cd603d2:         return loader.loadClass(name);
1:cd603d2:     }
1:cd603d2: 
1:28d2e82:     public URL getResource(String name) {
1:28d2e82:         return loader.getResource(name);
1:28d2e82:     }
1:28d2e82: 
1:cd603d2:     public AccessControlContext getAccessControlContext() {
1:cd603d2:         return null;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public ComponentDefinitionRegistryImpl getComponentDefinitionRegistry() {
1:cd603d2:         return componentDefinitionRegistry;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public <T extends Processor> List<T> getProcessors(Class<T> clazz) {
1:cd603d2:         List<T> p = new ArrayList<T>();
1:cd603d2:         for (Processor processor : processors) {
1:cd603d2:             if (clazz.isInstance(processor)) {
1:cd603d2:                 p.add(clazz.cast(processor));
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         return p;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public Set<String> getComponentIds() {
1:cd603d2:         return new LinkedHashSet<String>(componentDefinitionRegistry.getComponentDefinitionNames());
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public Object getComponentInstance(String id) {
1:cd603d2:         if (repository == null || destroyed.get()) {
1:cd603d2:             throw new NoSuchComponentException(id);
1:cd603d2:         }
1:cd603d2:         try {
1:cd603d2:             LOGGER.debug("Instantiating component {}", id);
1:cd603d2:             return repository.create(id);
1:cd603d2:         } catch (NoSuchComponentException e) {
1:cd603d2:             throw e;
1:cd603d2:         } catch (ComponentDefinitionException e) {
1:cd603d2:             throw e;
1:cd603d2:         } catch (Throwable t) {
1:cd603d2:             throw new ComponentDefinitionException("Cound not create component instance for " + id, t);
1:cd603d2:         }
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public ComponentMetadata getComponentMetadata(String id) {
1:cd603d2:         ComponentMetadata metadata = componentDefinitionRegistry.getComponentDefinition(id);
1:cd603d2:         if (metadata == null) {
1:cd603d2:             throw new NoSuchComponentException(id);
1:cd603d2:         }
1:cd603d2:         return metadata;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public <T extends ComponentMetadata> Collection<T> getMetadata(Class<T> clazz) {
1:cd603d2:         Collection<T> metadatas = new ArrayList<T>();
1:cd603d2:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:cd603d2:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:cd603d2:             getMetadata(clazz, component, metadatas);
1:cd603d2:         }
1:cd603d2:         metadatas = Collections.unmodifiableCollection(metadatas);
1:cd603d2:         return metadatas;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     public BlueprintRepository getRepository() {
1:cd603d2:         return repository;
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     private <T extends ComponentMetadata> void getMetadata(Class<T> clazz, Metadata component, Collection<T> metadatas) {
1:cd603d2:         if (component == null) {
1:cd603d2:             return;
1:cd603d2:         }
1:cd603d2:         if (clazz.isInstance(component)) {
1:cd603d2:             metadatas.add(clazz.cast(component));
1:cd603d2:         }
1:cd603d2:         if (component instanceof BeanMetadata) {
1:cd603d2:             getMetadata(clazz, ((BeanMetadata) component).getFactoryComponent(), metadatas);
1:cd603d2:             for (BeanArgument arg : ((BeanMetadata) component).getArguments()) {
1:cd603d2:                 getMetadata(clazz, arg.getValue(), metadatas);
1:cd603d2:             }
1:cd603d2:             for (BeanProperty prop : ((BeanMetadata) component).getProperties()) {
1:cd603d2:                 getMetadata(clazz, prop.getValue(), metadatas);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         if (component instanceof CollectionMetadata) {
1:cd603d2:             for (Metadata m : ((CollectionMetadata) component).getValues()) {
1:cd603d2:                 getMetadata(clazz, m, metadatas);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         if (component instanceof MapMetadata) {
1:cd603d2:             for (MapEntry m : ((MapMetadata) component).getEntries()) {
1:cd603d2:                 getMetadata(clazz, m.getKey(), metadatas);
1:cd603d2:                 getMetadata(clazz, m.getValue(), metadatas);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         if (component instanceof PropsMetadata) {
1:cd603d2:             for (MapEntry m : ((PropsMetadata) component).getEntries()) {
1:cd603d2:                 getMetadata(clazz, m.getKey(), metadatas);
1:cd603d2:                 getMetadata(clazz, m.getValue(), metadatas);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         if (component instanceof ServiceReferenceMetadata) {
1:cd603d2:             for (ReferenceListener l : ((ServiceReferenceMetadata) component).getReferenceListeners()) {
1:cd603d2:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         if (component instanceof ServiceMetadata) {
1:cd603d2:             getMetadata(clazz, ((ServiceMetadata) component).getServiceComponent(), metadatas);
1:cd603d2:             for (MapEntry m : ((ServiceMetadata) component).getServiceProperties()) {
1:cd603d2:                 getMetadata(clazz, m.getKey(), metadatas);
1:cd603d2:                 getMetadata(clazz, m.getValue(), metadatas);
1:cd603d2:             }
1:cd603d2:             for (RegistrationListener l : ((ServiceMetadata) component).getRegistrationListeners()) {
1:cd603d2:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     private void processTypeConverters() throws Exception {
1:cd603d2:         List<String> typeConverters = new ArrayList<String>();
1:cd603d2:         for (Target target : componentDefinitionRegistry.getTypeConverters()) {
1:cd603d2:             if (target instanceof ComponentMetadata) {
1:cd603d2:                 typeConverters.add(((ComponentMetadata) target).getId());
1:cd603d2:             } else if (target instanceof RefMetadata) {
1:cd603d2:                 typeConverters.add(((RefMetadata) target).getComponentId());
1:cd603d2:             } else {
1:cd603d2:                 throw new ComponentDefinitionException("Unexpected metadata for type converter: " + target);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2: 
1:cd603d2:         Map<String, Object> objects = repository.createAll(typeConverters, Arrays.<Class<?>>asList(Converter.class));
1:cd603d2:         for (String name : typeConverters) {
1:cd603d2:             Object obj = objects.get(name);
1:cd603d2:             if (obj instanceof Converter) {
1:cd603d2:                 converter.registerConverter((Converter) obj);
1:cd603d2:             } else {
1:cd603d2:                 throw new ComponentDefinitionException("Type converter " + obj + " does not implement the " + Converter.class.getName() + " interface");
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     private void processProcessors() throws Exception {
1:cd603d2:         // Instantiate ComponentDefinitionRegistryProcessor and BeanProcessor
1:cd603d2:         for (BeanMetadata bean : getMetadata(BeanMetadata.class)) {
1:cd603d2:             if (bean instanceof ExtendedBeanMetadata && !((ExtendedBeanMetadata) bean).isProcessor()) {
1:cd603d2:                 continue;
1:cd603d2:             }
1:cd603d2: 
1:cd603d2:             Class clazz = null;
1:cd603d2:             if (bean instanceof ExtendedBeanMetadata) {
1:cd603d2:                 clazz = ((ExtendedBeanMetadata) bean).getRuntimeClass();
1:cd603d2:             }
1:cd603d2:             if (clazz == null && bean.getClassName() != null) {
1:cd603d2:                 clazz = loadClass(bean.getClassName());
1:cd603d2:             }
1:cd603d2:             if (clazz == null) {
1:cd603d2:                 continue;
1:cd603d2:             }
1:cd603d2: 
1:cd603d2:             if (ComponentDefinitionRegistryProcessor.class.isAssignableFrom(clazz)) {
1:cd603d2:                 Object obj = repository.create(bean.getId(), Arrays.<Class<?>>asList(ComponentDefinitionRegistryProcessor.class));
1:cd603d2:                 ((ComponentDefinitionRegistryProcessor) obj).process(componentDefinitionRegistry);
1:cd603d2:             } else if (Processor.class.isAssignableFrom(clazz)) {
1:cd603d2:                 Object obj = repository.create(bean.getId(), Arrays.<Class<?>>asList(Processor.class));
1:cd603d2:                 this.processors.add((Processor) obj);
1:cd603d2:             } else {
1:cd603d2:                 continue;
1:cd603d2:             }
1:cd603d2:             updateUninstantiatedRecipes();
1:cd603d2:         }
1:cd603d2:     }
1:cd603d2:     private void updateUninstantiatedRecipes() {
1:cd603d2:         Repository tmpRepo = new NoOsgiRecipeBuilder(this, tempRecipeIdSpace).createRepository();
1:cd603d2: 
1:cd603d2:         LOGGER.debug("Updating blueprint repository");
1:cd603d2: 
1:cd603d2:         for (String name : repository.getNames()) {
1:cd603d2:             if (repository.getInstance(name) == null) {
1:cd603d2:                 LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
1:cd603d2:                 repository.removeRecipe(name);
1:cd603d2:             } else {
1:cd603d2:                 LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2: 
1:cd603d2:         for (String name : tmpRepo.getNames()) {
1:cd603d2:             if (repository.getInstance(name) == null) {
1:cd603d2:                 LOGGER.debug("Adding new recipe {}", new Object[] { name });
1:cd603d2:                 Recipe r = tmpRepo.getRecipe(name);
1:cd603d2:                 if (r != null) {
1:cd603d2:                     repository.putRecipe(name, r);
1:cd603d2:                 }
1:cd603d2:             } else {
1:cd603d2:                 LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:     }
1:cd603d2: 
1:cd603d2:     protected void instantiateEagerComponents() {
1:cd603d2:         List<String> components = new ArrayList<String>();
1:cd603d2:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:cd603d2:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:cd603d2:             boolean eager = component.getActivation() == ComponentMetadata.ACTIVATION_EAGER;
1:cd603d2:             if (component instanceof BeanMetadata) {
1:cd603d2:                 BeanMetadata local = (BeanMetadata) component;
1:cd603d2:                 eager &= MetadataUtil.isSingletonScope(local);
1:cd603d2:             }
1:cd603d2:             if (eager) {
1:cd603d2:                 components.add(name);
1:cd603d2:             }
1:cd603d2:         }
1:cd603d2:         LOGGER.debug("Instantiating components: {}", components);
1:cd603d2:         try {
1:cd603d2:             repository.createAll(components);
1:cd603d2:         } catch (ComponentDefinitionException e) {
1:cd603d2:             throw e;
1:cd603d2:         } catch (Throwable t) {
1:cd603d2:             throw new ComponentDefinitionException("Unable to instantiate components", t);
1:cd603d2:         }
1:cd603d2:     }
1:cd603d2: 
1:cd603d2: 
1:cd603d2: 
1:cd603d2: }
============================================================================
author:Sergey Beryozkin
-------------------------------------------------------------------------------
commit:c6816ad
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.net.URL;
1: import java.security.AccessControlContext;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.LinkedHashSet;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.BeanArgument;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.MapEntry;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.PropsMetadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.Target;
/////////////////////////////////////////////////////////////////////////
1:     private NamespaceHandlerSet nsHandlerSet;
1:     
/////////////////////////////////////////////////////////////////////////
1:         this(loader, resources, properties, null, init);
1:     }
1:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources, Map<String, String> properties, 
1:                                   NamespaceHandlerSet nsHandlerSet, boolean init) throws Exception {
1:         this.nsHandlerSet = nsHandlerSet;
/////////////////////////////////////////////////////////////////////////
1:         NamespaceHandlerSet handlerSet = createNamespaceHandlerSet();
/////////////////////////////////////////////////////////////////////////
1:     protected NamespaceHandlerSet createNamespaceHandlerSet() {
1:         return nsHandlerSet == null ? new SimpleNamespaceHandlerSet() : nsHandlerSet;
1:     } 
1:     
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:1db978a
/////////////////////////////////////////////////////////////////////////
1:         init(true);
1:     }
1:     public void init(boolean validate) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         if (validate) {
1:             // Validate
1:             parser.validate(handlerSet.getSchema());
1:         }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:cc4ce69
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
/////////////////////////////////////////////////////////////////////////
1:     protected NamespaceHandlerSet createNamespaceHandlerSet(Set<URI> namespaces) {
0:         NamespaceHandlerSet handlerSet = new SimpleNamespaceHandlerSet();
/////////////////////////////////////////////////////////////////////////
1:         return handlerSet;
1:     }
1: 
1:     public void init() throws Exception {
1:         // Parse xml resources
1:         Parser parser = new Parser();
1:         parser.parse(getResources());
1:         // Check namespaces
1:         Set<URI> namespaces = parser.getNamespaces();
1:         // Create handler set
1:         NamespaceHandlerSet handlerSet = createNamespaceHandlerSet(namespaces);
commit:7782911
/////////////////////////////////////////////////////////////////////////
1:     private Map<String, String> properties;
1:         this(loader, resources, null, true);
1:         this(loader, resources, null, init);
1:     }
1: 
1:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources, Map<String, String> properties, boolean init) throws Exception {
1:         this.properties = properties;
1:     public String getProperty(String key) {
1:         if (properties != null && properties.containsKey(key)) {
1:             return properties.get(key);
1:         }
1:         return System.getProperty(key);
1:     }
1: 
commit:28d2e82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
/////////////////////////////////////////////////////////////////////////
1:         // Add predefined beans
1:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
/////////////////////////////////////////////////////////////////////////
1:     public URL getResource(String name) {
1:         return loader.getResource(name);
1:     }
1: 
commit:cd603d2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.container;
1: 
1: import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
1: import org.apache.aries.blueprint.ExtendedBeanMetadata;
1: import org.apache.aries.blueprint.Processor;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.Repository;
1: import org.apache.aries.blueprint.parser.ComponentDefinitionRegistryImpl;
1: import org.apache.aries.blueprint.parser.Parser;
1: import org.apache.aries.blueprint.reflect.MetadataUtil;
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.container.Converter;
1: import org.osgi.service.blueprint.container.NoSuchComponentException;
0: import org.osgi.service.blueprint.reflect.*;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import java.net.URI;
0: import java.net.URL;
0: import java.security.AccessControlContext;
0: import java.util.*;
0: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: public class BlueprintContainerImpl implements ExtendedBlueprintContainer {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintContainerImpl.class);
1: 
1:     private final ClassLoader loader;
1:     private final List<URL> resources;
1:     private final AggregateConverter converter;
1:     private final ComponentDefinitionRegistryImpl componentDefinitionRegistry;
1:     private final AtomicBoolean destroyed = new AtomicBoolean(false);
1:     private final IdSpace tempRecipeIdSpace = new IdSpace();
1:     private BlueprintRepository repository;
1:     private List<Processor> processors = new ArrayList<Processor>();
1: 
1:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources) throws Exception {
0:         this(loader, resources,  true);
1:     }
1: 
1:     public BlueprintContainerImpl(ClassLoader loader, List<URL> resources, boolean init) throws Exception {
1:         this.loader = loader;
1:         this.converter = new AggregateConverter(this);
1:         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl();
1:         this.resources = resources;
1:         if (init) {
1:             init();
1:         }
1:     }
1: 
0:     public void init() throws Exception {
0:         // Parse xml resources
0:         Parser parser = new Parser();
0:         parser.parse(getResources());
0:         // Create handler set
0:         SimpleNamespaceHandlerSet handlerSet = new SimpleNamespaceHandlerSet();
1:         // Check namespaces
0:         Set<URI> namespaces = parser.getNamespaces();
1:         Set<URI> unsupported = new LinkedHashSet<URI>();
1:         for (URI ns : namespaces) {
1:             if (!handlerSet.getNamespaces().contains(ns)) {
1:                 unsupported.add(ns);
1:             }
1:         }
1:         if (unsupported.size() > 0) {
1:             throw new IllegalArgumentException("Unsupported namespaces: " + unsupported.toString());
1:         }
0:         // Validate
0:         parser.validate(handlerSet.getSchema());
1:         // Populate
1:         parser.populate(handlerSet, componentDefinitionRegistry);
1:         // Create repository
1:         repository = new NoOsgiRecipeBuilder(this, tempRecipeIdSpace).createRepository();
1:         // Processors handling
1:         processTypeConverters();
1:         processProcessors();
1:         // Instantiate eager singletons
1:         instantiateEagerComponents();
1:     }
1: 
1:     public void destroy() {
1:         repository.destroy();
1:     }
1: 
1:     public List<URL> getResources() {
1:         return resources;
1:     }
1: 
1:     public Converter getConverter() {
1:         return converter;
1:     }
1: 
1:     public Class loadClass(String name) throws ClassNotFoundException {
1:         return loader.loadClass(name);
1:     }
1: 
1:     public AccessControlContext getAccessControlContext() {
1:         return null;
1:     }
1: 
1:     public ComponentDefinitionRegistryImpl getComponentDefinitionRegistry() {
1:         return componentDefinitionRegistry;
1:     }
1: 
1:     public <T extends Processor> List<T> getProcessors(Class<T> clazz) {
1:         List<T> p = new ArrayList<T>();
1:         for (Processor processor : processors) {
1:             if (clazz.isInstance(processor)) {
1:                 p.add(clazz.cast(processor));
1:             }
1:         }
1:         return p;
1:     }
1: 
1:     public Set<String> getComponentIds() {
1:         return new LinkedHashSet<String>(componentDefinitionRegistry.getComponentDefinitionNames());
1:     }
1: 
1:     public Object getComponentInstance(String id) {
1:         if (repository == null || destroyed.get()) {
1:             throw new NoSuchComponentException(id);
1:         }
1:         try {
1:             LOGGER.debug("Instantiating component {}", id);
1:             return repository.create(id);
1:         } catch (NoSuchComponentException e) {
1:             throw e;
1:         } catch (ComponentDefinitionException e) {
1:             throw e;
1:         } catch (Throwable t) {
1:             throw new ComponentDefinitionException("Cound not create component instance for " + id, t);
1:         }
1:     }
1: 
1:     public ComponentMetadata getComponentMetadata(String id) {
1:         ComponentMetadata metadata = componentDefinitionRegistry.getComponentDefinition(id);
1:         if (metadata == null) {
1:             throw new NoSuchComponentException(id);
1:         }
1:         return metadata;
1:     }
1: 
1:     public <T extends ComponentMetadata> Collection<T> getMetadata(Class<T> clazz) {
1:         Collection<T> metadatas = new ArrayList<T>();
1:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:             getMetadata(clazz, component, metadatas);
1:         }
1:         metadatas = Collections.unmodifiableCollection(metadatas);
1:         return metadatas;
1:     }
1: 
1:     public BlueprintRepository getRepository() {
1:         return repository;
1:     }
1: 
1:     private <T extends ComponentMetadata> void getMetadata(Class<T> clazz, Metadata component, Collection<T> metadatas) {
1:         if (component == null) {
1:             return;
1:         }
1:         if (clazz.isInstance(component)) {
1:             metadatas.add(clazz.cast(component));
1:         }
1:         if (component instanceof BeanMetadata) {
1:             getMetadata(clazz, ((BeanMetadata) component).getFactoryComponent(), metadatas);
1:             for (BeanArgument arg : ((BeanMetadata) component).getArguments()) {
1:                 getMetadata(clazz, arg.getValue(), metadatas);
1:             }
1:             for (BeanProperty prop : ((BeanMetadata) component).getProperties()) {
1:                 getMetadata(clazz, prop.getValue(), metadatas);
1:             }
1:         }
1:         if (component instanceof CollectionMetadata) {
1:             for (Metadata m : ((CollectionMetadata) component).getValues()) {
1:                 getMetadata(clazz, m, metadatas);
1:             }
1:         }
1:         if (component instanceof MapMetadata) {
1:             for (MapEntry m : ((MapMetadata) component).getEntries()) {
1:                 getMetadata(clazz, m.getKey(), metadatas);
1:                 getMetadata(clazz, m.getValue(), metadatas);
1:             }
1:         }
1:         if (component instanceof PropsMetadata) {
1:             for (MapEntry m : ((PropsMetadata) component).getEntries()) {
1:                 getMetadata(clazz, m.getKey(), metadatas);
1:                 getMetadata(clazz, m.getValue(), metadatas);
1:             }
1:         }
1:         if (component instanceof ServiceReferenceMetadata) {
1:             for (ReferenceListener l : ((ServiceReferenceMetadata) component).getReferenceListeners()) {
1:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:             }
1:         }
1:         if (component instanceof ServiceMetadata) {
1:             getMetadata(clazz, ((ServiceMetadata) component).getServiceComponent(), metadatas);
1:             for (MapEntry m : ((ServiceMetadata) component).getServiceProperties()) {
1:                 getMetadata(clazz, m.getKey(), metadatas);
1:                 getMetadata(clazz, m.getValue(), metadatas);
1:             }
1:             for (RegistrationListener l : ((ServiceMetadata) component).getRegistrationListeners()) {
1:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:             }
1:         }
1:     }
1: 
1:     private void processTypeConverters() throws Exception {
1:         List<String> typeConverters = new ArrayList<String>();
1:         for (Target target : componentDefinitionRegistry.getTypeConverters()) {
1:             if (target instanceof ComponentMetadata) {
1:                 typeConverters.add(((ComponentMetadata) target).getId());
1:             } else if (target instanceof RefMetadata) {
1:                 typeConverters.add(((RefMetadata) target).getComponentId());
1:             } else {
1:                 throw new ComponentDefinitionException("Unexpected metadata for type converter: " + target);
1:             }
1:         }
1: 
1:         Map<String, Object> objects = repository.createAll(typeConverters, Arrays.<Class<?>>asList(Converter.class));
1:         for (String name : typeConverters) {
1:             Object obj = objects.get(name);
1:             if (obj instanceof Converter) {
1:                 converter.registerConverter((Converter) obj);
1:             } else {
1:                 throw new ComponentDefinitionException("Type converter " + obj + " does not implement the " + Converter.class.getName() + " interface");
1:             }
1:         }
1:     }
1: 
1:     private void processProcessors() throws Exception {
1:         // Instantiate ComponentDefinitionRegistryProcessor and BeanProcessor
1:         for (BeanMetadata bean : getMetadata(BeanMetadata.class)) {
1:             if (bean instanceof ExtendedBeanMetadata && !((ExtendedBeanMetadata) bean).isProcessor()) {
1:                 continue;
1:             }
1: 
1:             Class clazz = null;
1:             if (bean instanceof ExtendedBeanMetadata) {
1:                 clazz = ((ExtendedBeanMetadata) bean).getRuntimeClass();
1:             }
1:             if (clazz == null && bean.getClassName() != null) {
1:                 clazz = loadClass(bean.getClassName());
1:             }
1:             if (clazz == null) {
1:                 continue;
1:             }
1: 
1:             if (ComponentDefinitionRegistryProcessor.class.isAssignableFrom(clazz)) {
1:                 Object obj = repository.create(bean.getId(), Arrays.<Class<?>>asList(ComponentDefinitionRegistryProcessor.class));
1:                 ((ComponentDefinitionRegistryProcessor) obj).process(componentDefinitionRegistry);
1:             } else if (Processor.class.isAssignableFrom(clazz)) {
1:                 Object obj = repository.create(bean.getId(), Arrays.<Class<?>>asList(Processor.class));
1:                 this.processors.add((Processor) obj);
1:             } else {
1:                 continue;
1:             }
1:             updateUninstantiatedRecipes();
1:         }
1:     }
1:     private void updateUninstantiatedRecipes() {
1:         Repository tmpRepo = new NoOsgiRecipeBuilder(this, tempRecipeIdSpace).createRepository();
1: 
1:         LOGGER.debug("Updating blueprint repository");
1: 
1:         for (String name : repository.getNames()) {
1:             if (repository.getInstance(name) == null) {
1:                 LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
1:                 repository.removeRecipe(name);
1:             } else {
1:                 LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
1:             }
1:         }
1: 
1:         for (String name : tmpRepo.getNames()) {
1:             if (repository.getInstance(name) == null) {
1:                 LOGGER.debug("Adding new recipe {}", new Object[] { name });
1:                 Recipe r = tmpRepo.getRecipe(name);
1:                 if (r != null) {
1:                     repository.putRecipe(name, r);
1:                 }
1:             } else {
1:                 LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
1:             }
1:         }
1:     }
1: 
1:     protected void instantiateEagerComponents() {
1:         List<String> components = new ArrayList<String>();
1:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:             boolean eager = component.getActivation() == ComponentMetadata.ACTIVATION_EAGER;
1:             if (component instanceof BeanMetadata) {
1:                 BeanMetadata local = (BeanMetadata) component;
1:                 eager &= MetadataUtil.isSingletonScope(local);
1:             }
1:             if (eager) {
1:                 components.add(name);
1:             }
1:         }
1:         LOGGER.debug("Instantiating components: {}", components);
1:         try {
1:             repository.createAll(components);
1:         } catch (ComponentDefinitionException e) {
1:             throw e;
1:         } catch (Throwable t) {
1:             throw new ComponentDefinitionException("Unable to instantiate components", t);
1:         }
1:     }
1: 
1: 
1: 
1: }
============================================================================