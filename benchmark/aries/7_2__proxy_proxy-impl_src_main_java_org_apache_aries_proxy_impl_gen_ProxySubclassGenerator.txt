1:e436ced: /*
1:e436ced:  * Licensed to the Apache Software Foundation (ASF) under one
1:e436ced:  * or more contributor license agreements.  See the NOTICE file
1:e436ced:  * distributed with this work for additional information
1:e436ced:  * regarding copyright ownership.  The ASF licenses this file
1:e436ced:  * to you under the Apache License, Version 2.0 (the
1:e436ced:  * "License"); you may not use this file except in compliance
1:e436ced:  * with the License.  You may obtain a copy of the License at
1:e436ced:  *
1:e436ced:  *   http://www.apache.org/licenses/LICENSE-2.0
1:e436ced:  *
1:e436ced:  * Unless required by applicable law or agreed to in writing,
1:e436ced:  * software distributed under the License is distributed on an
1:e436ced:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e436ced:  * KIND, either express or implied.  See the License for the
1:e436ced:  * specific language governing permissions and limitations
1:e436ced:  * under the License.
1:e436ced:  */
1:e436ced: package org.apache.aries.proxy.impl.gen;
1:e436ced: 
1:e436ced: import static java.lang.reflect.Modifier.isFinal;
1:e436ced: 
1:e436ced: import java.io.IOException;
1:e436ced: import java.lang.reflect.Constructor;
1:e436ced: import java.lang.reflect.InvocationHandler;
1:e436ced: import java.lang.reflect.InvocationTargetException;
1:e436ced: import java.lang.reflect.Method;
1:e436ced: import java.lang.reflect.Modifier;
1:e436ced: import java.security.ProtectionDomain;
1:e436ced: import java.util.ArrayList;
1:e436ced: import java.util.Collections;
1:e436ced: import java.util.List;
1:e436ced: import java.util.Map;
1:e436ced: import java.util.WeakHashMap;
1:e436ced: import java.util.concurrent.ConcurrentHashMap;
1:e436ced: import java.util.concurrent.ConcurrentMap;
1:e436ced: 
1:e436ced: import org.apache.aries.proxy.FinalModifierException;
1:e436ced: import org.apache.aries.proxy.UnableToProxyException;
1:e436ced: import org.apache.aries.proxy.impl.NLS;
1:e436ced: import org.objectweb.asm.ClassReader;
1:e436ced: import org.objectweb.asm.ClassVisitor;
1:e436ced: import org.objectweb.asm.ClassWriter;
1:e436ced: import org.slf4j.Logger;
1:e436ced: import org.slf4j.LoggerFactory;
1:e436ced: 
1:e436ced: import sun.reflect.ReflectionFactory;
1:e436ced: 
1:e436ced: public class ProxySubclassGenerator
1:e436ced: {
1:e436ced: 
1:e436ced:   private final static Logger LOGGER = LoggerFactory.getLogger(ProxySubclassGenerator.class);
1:e436ced: 
1:e436ced:   // This map holds references to the names of classes created by this Class
1:e436ced:   // It is a weak map (so when a ClassLoader is garbage collected we remove
1:e436ced:   // the map of
1:e436ced:   // Class names to sub-Class names)
1:e436ced:   private static final Map<ClassLoader, ConcurrentMap<String, String>> proxyClassesByClassLoader;
1:e436ced:   
1:e436ced:   private static final ClassLoader defaultClassLoader = new ClassLoader() {};
1:e436ced: 
1:e436ced:   static {
1:e436ced:     // Ensure that this is a synchronized map as we may use it from multiple
1:e436ced:     // threads concurrently
1:e436ced:     //
1:e436ced:     proxyClassesByClassLoader = Collections
1:e436ced:         .synchronizedMap(new WeakHashMap<ClassLoader, ConcurrentMap<String, String>>());
1:e436ced:   }
1:e436ced: 
1:e436ced:   private static final char FINAL_MODIFIER = '!';
1:e436ced:   private static final char UNABLE_TO_PROXY = '#';
1:e436ced: 
1:e436ced:   public static Class<?> getProxySubclass(Class<?> aClass) throws UnableToProxyException
1:e436ced:   {
1:cc94d79:     return getProxySubclass(aClass, aClass.getClassLoader());
1:cc94d79:   }
1:cc94d79: 
1:cc94d79:   public static Class<?> getProxySubclass(Class<?> aClass, ClassLoader loader) throws UnableToProxyException
1:cc94d79:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "getProxySubclass", new Object[] { aClass });
1:e436ced: 
1:e436ced:     // in the special case where the loader is null we use a default classloader
1:e436ced:     // this is for subclassing java.* or javax.* packages, so that one will do
1:e436ced:     if (loader == null) loader = defaultClassLoader;
1:e436ced: 
1:e436ced:     ConcurrentMap<String, String> proxyMap;
1:e436ced:     synchronized (loader) {
1:e436ced:       proxyMap = proxyClassesByClassLoader.get(loader);
1:e436ced:       if (proxyMap == null) {
1:e436ced:         proxyMap = new ConcurrentHashMap<String, String>();
1:e436ced:         proxyClassesByClassLoader.put(loader, proxyMap);
1:e436ced:       }
1:e436ced:     }
1:e436ced: 
1:e436ced:     // check the map to see if we have already generated a subclass for this
1:e436ced:     // class
1:e436ced:     // if we have return the mapped class object
1:e436ced:     // if we haven't generate the subclass and return it
1:e436ced:     Class<?> classToReturn = null;
1:e436ced:     synchronized (aClass) {
1:e436ced:       String key = aClass.getName();
1:e436ced:       String className = proxyMap.get(key);
1:e436ced:       if (className != null) {
1:e436ced: 
1:e436ced:         LOGGER.debug("Found proxy subclass with key {} and name {}.", key, className);
1:e436ced: 
1:e436ced:         if (className.charAt(0) == FINAL_MODIFIER) {
1:e436ced:           String[] exceptionParts = className.substring(1).split(":");
1:e436ced:           if (exceptionParts.length == 1) {
1:e436ced:             throw new FinalModifierException(aClass);
1:e436ced:           } else {
1:e436ced:             throw new FinalModifierException(aClass, exceptionParts[1]);
1:e436ced:           }
1:e436ced:         } else if (className.charAt(0) == UNABLE_TO_PROXY) {
1:e436ced:           throw new UnableToProxyException(aClass);
1:e436ced:         }
1:e436ced: 
1:e436ced:         try {
1:e436ced:           classToReturn = loader.loadClass(className);
1:e436ced:         } catch (ClassNotFoundException cnfe) {
1:e436ced:           LOGGER.debug(Constants.LOG_EXCEPTION, cnfe);
1:e436ced:           throw new UnableToLoadProxyException(className, cnfe);
1:e436ced:         }
1:e436ced:       } else {
1:e436ced: 
1:e436ced:         LOGGER.debug("Need to generate subclass. Using key {}.", key);
1:e436ced:         try {
1:e436ced:           scanForFinalModifiers(aClass);
1:e436ced: 
1:e436ced:           classToReturn = generateAndLoadSubclass(aClass, loader);
1:e436ced: 
1:e436ced:           if (classToReturn != null) {
1:e436ced:             proxyMap.put(key, classToReturn.getName());
1:e436ced:           } else {
1:e436ced:             proxyMap.put(key, UNABLE_TO_PROXY + aClass.getName());
1:e436ced:             throw new UnableToProxyException(aClass);
1:e436ced:           }
1:e436ced:         } catch (FinalModifierException e) {
1:e436ced:           if (e.isFinalClass()) {
1:e436ced:             proxyMap.put(key, FINAL_MODIFIER + e.getClassName());
1:e436ced:             throw e;
1:e436ced:           } else {
1:e436ced:             proxyMap.put(key, FINAL_MODIFIER + e.getClassName() + ':' + e.getFinalMethods());
1:e436ced:             throw e;
1:e436ced:           }
1:e436ced:         }
1:e436ced: 
1:e436ced:       }
1:e436ced:     }
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "getProxySubclass", classToReturn);
1:e436ced: 
1:e436ced:     return classToReturn;
1:e436ced:   }
1:e436ced: 
1:e436ced:   public static Object newProxySubclassInstance(Class<?> classToProxy, InvocationHandler ih)
1:e436ced:       throws UnableToProxyException
1:e436ced:   {
1:cc94d79:     return newProxySubclassInstance(classToProxy, classToProxy.getClassLoader(), ih);
1:cc94d79:   }
1:cc94d79: 
1:cc94d79:   public static Object newProxySubclassInstance(Class<?> classToProxy, ClassLoader loader, InvocationHandler ih)
1:cc94d79:       throws UnableToProxyException
1:cc94d79:   {
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "newProxySubclassInstance", new Object[] {
1:cc94d79:         classToProxy, loader, ih });
1:e436ced: 
1:e436ced:     Object proxySubclassInstance = null;
1:e436ced:     try {
1:cc94d79:       Class<?> generatedProxySubclass = getProxySubclass(classToProxy, loader);
1:e436ced:       LOGGER.debug("Getting the proxy subclass constructor");
1:e436ced:       // Because the newer JVMs throw a VerifyError if a class attempts to in a constructor other than their superclasses constructor,
1:e436ced:       // and because we can't know what objects/values we need to pass into the class being proxied constructor, 
1:e436ced:       // we instantiate the proxy class using the ReflectionFactory.newConstructorForSerialization() method which allows us to instantiate the 
1:e436ced:       // proxy class without calling the proxy class' constructor. It is in fact using the java.lang.Object constructor so is in effect 
1:e436ced:       // doing what we were doing before.
1:e436ced:       ReflectionFactory factory = ReflectionFactory.getReflectionFactory();
1:e436ced:       Constructor<?> constr = Object.class.getConstructor();
1:e436ced:       Constructor<?> subclassConstructor = factory.newConstructorForSerialization(generatedProxySubclass, constr);
1:e436ced:       proxySubclassInstance = subclassConstructor.newInstance();
1:e436ced:       
1:e436ced:       Method setIHMethod = proxySubclassInstance.getClass().getMethod("setInvocationHandler", InvocationHandler.class);
1:e436ced:       setIHMethod.invoke(proxySubclassInstance, ih);
1:e436ced:       LOGGER.debug("Invoked proxy subclass constructor");
1:e436ced:     } catch (NoSuchMethodException nsme) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, nsme);
1:e436ced:       throw new ProxyClassInstantiationException(classToProxy, nsme);
1:e436ced:     } catch (InvocationTargetException ite) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, ite);
1:e436ced:       throw new ProxyClassInstantiationException(classToProxy, ite);
1:e436ced:     } catch (InstantiationException ie) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, ie);
1:e436ced:       throw new ProxyClassInstantiationException(classToProxy, ie);
1:e436ced:     } catch (IllegalAccessException iae) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, iae);
1:e436ced:       throw new ProxyClassInstantiationException(classToProxy, iae);
1:e436ced:     } catch (VerifyError ve) {
1:e436ced:         LOGGER.info(NLS.MESSAGES.getMessage("no.nonprivate.noargs.constructor", classToProxy));
1:e436ced:         LOGGER.debug(Constants.LOG_EXCEPTION, ve);
1:e436ced:         throw new ProxyClassInstantiationException(classToProxy, ve);
1:e436ced:     }
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "newProxySubclassInstance", proxySubclassInstance);
1:e436ced: 
1:e436ced:     return proxySubclassInstance;
1:e436ced:   }
1:e436ced: 
1:e436ced:   private static Class<?> generateAndLoadSubclass(Class<?> aClass, ClassLoader loader)
1:e436ced:       throws UnableToProxyException
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "generateAndLoadSubclass", new Object[] { aClass,
1:e436ced:         loader });
1:e436ced: 
1:e436ced:     // set the newClassName
1:e436ced:     String newClassName = "$" + aClass.getSimpleName() + aClass.hashCode();
1:e436ced:     String packageName = aClass.getPackage().getName();
1:e436ced:     if (packageName.startsWith("java.") || packageName.startsWith("javax.")) {
1:e436ced:       packageName = "org.apache.aries.blueprint.proxy." + packageName;
1:e436ced:     }
1:e436ced:     String fullNewClassName = (packageName + "." + newClassName).replaceAll("\\.", "/");
1:e436ced: 
1:e436ced:     LOGGER.debug("New class name: {}", newClassName);
1:e436ced:     LOGGER.debug("Full new class name: {}", fullNewClassName);
1:e436ced: 
1:e436ced:     Class<?> clazz = null;
1:e436ced:     try {
1:e436ced:       ClassReader cReader = new ClassReader(loader.getResourceAsStream(aClass.getName().replaceAll(
1:e436ced:           "\\.", "/")
1:e436ced:           + ".class"));
1:e436ced:       ClassWriter cWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
1:e436ced:       ClassVisitor dynamicSubclassAdapter = new ProxySubclassAdapter(cWriter, fullNewClassName,
1:e436ced:           loader);
1:e436ced:       byte[] byteClassData = processClass(cReader, cWriter, dynamicSubclassAdapter);
1:e436ced:       clazz = loadClassFromBytes(loader, getBinaryName(fullNewClassName), byteClassData, aClass
1:e436ced:           .getName());
1:e436ced:     } catch (IOException ioe) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, ioe);
1:e436ced:       throw new ProxyClassBytecodeGenerationException(aClass.getName(), ioe);
1:e436ced:     } catch (TypeNotPresentException tnpe) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, tnpe);
1:e436ced:       throw new ProxyClassBytecodeGenerationException(tnpe.typeName(), tnpe.getCause());
1:e436ced:     }
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "generateAndLoadSubclass", clazz);
1:e436ced: 
1:e436ced:     return clazz;
1:e436ced:   }
1:e436ced: 
1:e436ced:   private static byte[] processClass(ClassReader cReader, ClassWriter cWriter, ClassVisitor cVisitor)
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "processClass", new Object[] { cReader, cWriter,
1:e436ced:         cVisitor });
1:e436ced: 
1:e436ced:     cReader.accept(cVisitor, ClassReader.SKIP_DEBUG);
1:e436ced:     byte[] byteClassData = cWriter.toByteArray();
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "processClass", byteClassData);
1:e436ced: 
1:e436ced:     return byteClassData;
1:e436ced:   }
1:e436ced: 
1:e436ced:   private static String getBinaryName(String name)
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "getBinaryName", name);
1:e436ced: 
1:e436ced:     String binaryName = name.replaceAll("/", "\\.");
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "getBinaryName", binaryName);
1:e436ced: 
1:e436ced:     return binaryName;
1:e436ced:   }
1:e436ced: 
1:e436ced:   private static Class<?> loadClassFromBytes(ClassLoader loader, String name, byte[] classData,
1:e436ced:       String classToProxyName) throws UnableToProxyException
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "loadClassFromBytes", new Object[] { loader, name,
1:e436ced:         classData });
1:e436ced: 
1:e436ced:     Class<?> clazz = null;
1:e436ced:     try {
1:e436ced:       Method defineClassMethod = Class.forName("java.lang.ClassLoader").getDeclaredMethod(
1:e436ced:           "defineClass", String.class, byte[].class, int.class, int.class, ProtectionDomain.class);
1:e436ced:       defineClassMethod.setAccessible(true);
1:e436ced:       // define the class in the same classloader where aClass is loaded,
1:e436ced:       // but use the protection domain of our code
1:e436ced:       clazz = (Class<?>) defineClassMethod.invoke(loader, name, classData, 0, classData.length,
1:e436ced:           ProxySubclassGenerator.class.getProtectionDomain());
1:e436ced:       defineClassMethod.setAccessible(false);
1:e436ced:     } catch (ClassNotFoundException cnfe) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, cnfe);
1:e436ced:       throw new ProxyClassDefinitionException(classToProxyName, cnfe);
1:e436ced:     } catch (NoSuchMethodException nsme) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, nsme);
1:e436ced:       throw new ProxyClassDefinitionException(classToProxyName, nsme);
1:e436ced:     } catch (InvocationTargetException ite) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, ite);
1:e436ced:       throw new ProxyClassDefinitionException(classToProxyName, ite);
1:e436ced:     } catch (IllegalAccessException iae) {
1:e436ced:       LOGGER.debug(Constants.LOG_EXCEPTION, iae);
1:e436ced:       throw new ProxyClassDefinitionException(classToProxyName, iae);
1:e436ced:     }
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "loadClassFromBytes", clazz);
1:e436ced: 
1:e436ced:     return clazz;
1:e436ced:   }
1:e436ced: 
1:e436ced:   public static boolean isProxySubclass(Class<?> aClass)
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "isProxySubclass", new Object[] { aClass });
1:e436ced: 
1:e436ced:     // We will always have a proxy map for the class loader of any proxy
1:e436ced:     // class, so if
1:e436ced:     // this is null we know to return false
1:e436ced:     Map<String, String> proxies = proxyClassesByClassLoader.get(aClass.getClassLoader());
1:e436ced: 
1:e436ced:     boolean isProxySubclass = (proxies != null && proxies.containsValue(aClass.getName()));
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "isProxySubclass", isProxySubclass);
1:e436ced: 
1:e436ced:     return isProxySubclass;
1:e436ced:   }
1:e436ced: 
1:e436ced:   private static void scanForFinalModifiers(Class<?> clazz) throws FinalModifierException
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "scanForFinalModifiers", new Object[] { clazz });
1:e436ced: 
1:e436ced:     if (isFinal(clazz.getModifiers())) {
1:e436ced:       throw new FinalModifierException(clazz);
1:e436ced:     }
1:e436ced: 
1:e436ced:     List<String> finalMethods = new ArrayList<String>();
1:e436ced: 
1:e436ced:     // we don't want to check for final methods on java.* or javax.* Class
1:e436ced:     // also, clazz can never be null here (we will always hit
1:e436ced:     // java.lang.Object first)
1:e436ced:     while (!clazz.getName().startsWith("java.") && !clazz.getName().startsWith("javax.")) {
1:e436ced:       for (Method m : clazz.getDeclaredMethods()) {
1:e436ced:         //Static finals are ok, because we won't be overriding them :)
1:e436ced:         if (isFinal(m.getModifiers()) && !Modifier.isStatic(m.getModifiers())) {
1:e436ced:           finalMethods.add(m.toGenericString());
1:e436ced:         }
1:e436ced:       }
1:e436ced:       clazz = clazz.getSuperclass();
1:e436ced:     }
1:e436ced: 
1:e436ced:     if (!finalMethods.isEmpty()) {
1:e436ced: 
1:e436ced:       String methodList = finalMethods.toString();
1:e436ced:       methodList = methodList.substring(1, methodList.length() - 1);
1:e436ced:       throw new FinalModifierException(clazz, methodList);
1:e436ced:     }
1:e436ced: 
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "scanForFinalModifiers");
1:e436ced: 
1:e436ced:   }
1:e436ced: 
1:e436ced:   public static InvocationHandler getInvocationHandler(Object o)
1:e436ced:   {
1:e436ced:     LOGGER.debug(Constants.LOG_ENTRY, "getInvoationHandler", new Object[] { o });
1:e436ced: 
1:e436ced:     InvocationHandler ih = null;
1:e436ced:     if (isProxySubclass(o.getClass())) {
1:e436ced:       // we have to catch exceptions here, but we just log them
1:e436ced:       // the reason for this is that it should be impossible to get these
1:e436ced:       // exceptions
1:e436ced:       // since the Object we are dealing with is a class we generated on
1:e436ced:       // the fly
1:e436ced:       try {
1:e436ced:         ih = (InvocationHandler) o.getClass().getDeclaredMethod("getInvocationHandler",
1:e436ced:             new Class[] {}).invoke(o, new Object[] {});
1:e436ced:       } catch (IllegalArgumentException e) {
1:e436ced:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:e436ced:       } catch (SecurityException e) {
1:e436ced:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:e436ced:       } catch (IllegalAccessException e) {
1:e436ced:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:e436ced:       } catch (InvocationTargetException e) {
1:e436ced:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:e436ced:       } catch (NoSuchMethodException e) {
1:e436ced:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:e436ced:       }
1:e436ced:     }
1:e436ced:     LOGGER.debug(Constants.LOG_EXIT, "getInvoationHandler", ih);
1:e436ced:     return ih;
1:e436ced:   }
1:e436ced: 
1:e436ced: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:cc94d79
/////////////////////////////////////////////////////////////////////////
1:     return getProxySubclass(aClass, aClass.getClassLoader());
1:   }
1: 
1:   public static Class<?> getProxySubclass(Class<?> aClass, ClassLoader loader) throws UnableToProxyException
1:   {
/////////////////////////////////////////////////////////////////////////
1:     return newProxySubclassInstance(classToProxy, classToProxy.getClassLoader(), ih);
1:   }
1: 
1:   public static Object newProxySubclassInstance(Class<?> classToProxy, ClassLoader loader, InvocationHandler ih)
1:       throws UnableToProxyException
1:   {
1:         classToProxy, loader, ih });
1:       Class<?> generatedProxySubclass = getProxySubclass(classToProxy, loader);
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:e436ced
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.proxy.impl.gen;
1: 
1: import static java.lang.reflect.Modifier.isFinal;
1: 
1: import java.io.IOException;
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.InvocationHandler;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.security.ProtectionDomain;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.WeakHashMap;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: 
1: import org.apache.aries.proxy.FinalModifierException;
1: import org.apache.aries.proxy.UnableToProxyException;
1: import org.apache.aries.proxy.impl.NLS;
1: import org.objectweb.asm.ClassReader;
1: import org.objectweb.asm.ClassVisitor;
1: import org.objectweb.asm.ClassWriter;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import sun.reflect.ReflectionFactory;
1: 
1: public class ProxySubclassGenerator
1: {
1: 
1:   private final static Logger LOGGER = LoggerFactory.getLogger(ProxySubclassGenerator.class);
1: 
1:   // This map holds references to the names of classes created by this Class
1:   // It is a weak map (so when a ClassLoader is garbage collected we remove
1:   // the map of
1:   // Class names to sub-Class names)
1:   private static final Map<ClassLoader, ConcurrentMap<String, String>> proxyClassesByClassLoader;
1:   
1:   private static final ClassLoader defaultClassLoader = new ClassLoader() {};
1: 
1:   static {
1:     // Ensure that this is a synchronized map as we may use it from multiple
1:     // threads concurrently
1:     //
1:     proxyClassesByClassLoader = Collections
1:         .synchronizedMap(new WeakHashMap<ClassLoader, ConcurrentMap<String, String>>());
1:   }
1: 
1:   private static final char FINAL_MODIFIER = '!';
1:   private static final char UNABLE_TO_PROXY = '#';
1: 
1:   public static Class<?> getProxySubclass(Class<?> aClass) throws UnableToProxyException
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "getProxySubclass", new Object[] { aClass });
1: 
0:     ClassLoader loader = aClass.getClassLoader();
1:     // in the special case where the loader is null we use a default classloader
1:     // this is for subclassing java.* or javax.* packages, so that one will do
1:     if (loader == null) loader = defaultClassLoader;
1: 
1:     ConcurrentMap<String, String> proxyMap;
1:     synchronized (loader) {
1:       proxyMap = proxyClassesByClassLoader.get(loader);
1:       if (proxyMap == null) {
1:         proxyMap = new ConcurrentHashMap<String, String>();
1:         proxyClassesByClassLoader.put(loader, proxyMap);
1:       }
1:     }
1: 
1:     // check the map to see if we have already generated a subclass for this
1:     // class
1:     // if we have return the mapped class object
1:     // if we haven't generate the subclass and return it
1:     Class<?> classToReturn = null;
1:     synchronized (aClass) {
1:       String key = aClass.getName();
1:       String className = proxyMap.get(key);
1:       if (className != null) {
1: 
1:         LOGGER.debug("Found proxy subclass with key {} and name {}.", key, className);
1: 
1:         if (className.charAt(0) == FINAL_MODIFIER) {
1:           String[] exceptionParts = className.substring(1).split(":");
1:           if (exceptionParts.length == 1) {
1:             throw new FinalModifierException(aClass);
1:           } else {
1:             throw new FinalModifierException(aClass, exceptionParts[1]);
1:           }
1:         } else if (className.charAt(0) == UNABLE_TO_PROXY) {
1:           throw new UnableToProxyException(aClass);
1:         }
1: 
1:         try {
1:           classToReturn = loader.loadClass(className);
1:         } catch (ClassNotFoundException cnfe) {
1:           LOGGER.debug(Constants.LOG_EXCEPTION, cnfe);
1:           throw new UnableToLoadProxyException(className, cnfe);
1:         }
1:       } else {
1: 
1:         LOGGER.debug("Need to generate subclass. Using key {}.", key);
1:         try {
1:           scanForFinalModifiers(aClass);
1: 
1:           classToReturn = generateAndLoadSubclass(aClass, loader);
1: 
1:           if (classToReturn != null) {
1:             proxyMap.put(key, classToReturn.getName());
1:           } else {
1:             proxyMap.put(key, UNABLE_TO_PROXY + aClass.getName());
1:             throw new UnableToProxyException(aClass);
1:           }
1:         } catch (FinalModifierException e) {
1:           if (e.isFinalClass()) {
1:             proxyMap.put(key, FINAL_MODIFIER + e.getClassName());
1:             throw e;
1:           } else {
1:             proxyMap.put(key, FINAL_MODIFIER + e.getClassName() + ':' + e.getFinalMethods());
1:             throw e;
1:           }
1:         }
1: 
1:       }
1:     }
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "getProxySubclass", classToReturn);
1: 
1:     return classToReturn;
1:   }
1: 
1:   public static Object newProxySubclassInstance(Class<?> classToProxy, InvocationHandler ih)
1:       throws UnableToProxyException
1:   {
1: 
1:     LOGGER.debug(Constants.LOG_ENTRY, "newProxySubclassInstance", new Object[] {
0:         classToProxy, ih });
1: 
1:     Object proxySubclassInstance = null;
1:     try {
0:       Class<?> generatedProxySubclass = getProxySubclass(classToProxy);
1:       LOGGER.debug("Getting the proxy subclass constructor");
1:       // Because the newer JVMs throw a VerifyError if a class attempts to in a constructor other than their superclasses constructor,
1:       // and because we can't know what objects/values we need to pass into the class being proxied constructor, 
1:       // we instantiate the proxy class using the ReflectionFactory.newConstructorForSerialization() method which allows us to instantiate the 
1:       // proxy class without calling the proxy class' constructor. It is in fact using the java.lang.Object constructor so is in effect 
1:       // doing what we were doing before.
1:       ReflectionFactory factory = ReflectionFactory.getReflectionFactory();
1:       Constructor<?> constr = Object.class.getConstructor();
1:       Constructor<?> subclassConstructor = factory.newConstructorForSerialization(generatedProxySubclass, constr);
1:       proxySubclassInstance = subclassConstructor.newInstance();
1:       
1:       Method setIHMethod = proxySubclassInstance.getClass().getMethod("setInvocationHandler", InvocationHandler.class);
1:       setIHMethod.invoke(proxySubclassInstance, ih);
1:       LOGGER.debug("Invoked proxy subclass constructor");
1:     } catch (NoSuchMethodException nsme) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, nsme);
1:       throw new ProxyClassInstantiationException(classToProxy, nsme);
1:     } catch (InvocationTargetException ite) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, ite);
1:       throw new ProxyClassInstantiationException(classToProxy, ite);
1:     } catch (InstantiationException ie) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, ie);
1:       throw new ProxyClassInstantiationException(classToProxy, ie);
1:     } catch (IllegalAccessException iae) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, iae);
1:       throw new ProxyClassInstantiationException(classToProxy, iae);
1:     } catch (VerifyError ve) {
1:         LOGGER.info(NLS.MESSAGES.getMessage("no.nonprivate.noargs.constructor", classToProxy));
1:         LOGGER.debug(Constants.LOG_EXCEPTION, ve);
1:         throw new ProxyClassInstantiationException(classToProxy, ve);
1:     }
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "newProxySubclassInstance", proxySubclassInstance);
1: 
1:     return proxySubclassInstance;
1:   }
1: 
1:   private static Class<?> generateAndLoadSubclass(Class<?> aClass, ClassLoader loader)
1:       throws UnableToProxyException
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "generateAndLoadSubclass", new Object[] { aClass,
1:         loader });
1: 
1:     // set the newClassName
1:     String newClassName = "$" + aClass.getSimpleName() + aClass.hashCode();
1:     String packageName = aClass.getPackage().getName();
1:     if (packageName.startsWith("java.") || packageName.startsWith("javax.")) {
1:       packageName = "org.apache.aries.blueprint.proxy." + packageName;
1:     }
1:     String fullNewClassName = (packageName + "." + newClassName).replaceAll("\\.", "/");
1: 
1:     LOGGER.debug("New class name: {}", newClassName);
1:     LOGGER.debug("Full new class name: {}", fullNewClassName);
1: 
1:     Class<?> clazz = null;
1:     try {
1:       ClassReader cReader = new ClassReader(loader.getResourceAsStream(aClass.getName().replaceAll(
1:           "\\.", "/")
1:           + ".class"));
1:       ClassWriter cWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
1:       ClassVisitor dynamicSubclassAdapter = new ProxySubclassAdapter(cWriter, fullNewClassName,
1:           loader);
1:       byte[] byteClassData = processClass(cReader, cWriter, dynamicSubclassAdapter);
1:       clazz = loadClassFromBytes(loader, getBinaryName(fullNewClassName), byteClassData, aClass
1:           .getName());
1:     } catch (IOException ioe) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, ioe);
1:       throw new ProxyClassBytecodeGenerationException(aClass.getName(), ioe);
1:     } catch (TypeNotPresentException tnpe) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, tnpe);
1:       throw new ProxyClassBytecodeGenerationException(tnpe.typeName(), tnpe.getCause());
1:     }
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "generateAndLoadSubclass", clazz);
1: 
1:     return clazz;
1:   }
1: 
1:   private static byte[] processClass(ClassReader cReader, ClassWriter cWriter, ClassVisitor cVisitor)
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "processClass", new Object[] { cReader, cWriter,
1:         cVisitor });
1: 
1:     cReader.accept(cVisitor, ClassReader.SKIP_DEBUG);
1:     byte[] byteClassData = cWriter.toByteArray();
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "processClass", byteClassData);
1: 
1:     return byteClassData;
1:   }
1: 
1:   private static String getBinaryName(String name)
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "getBinaryName", name);
1: 
1:     String binaryName = name.replaceAll("/", "\\.");
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "getBinaryName", binaryName);
1: 
1:     return binaryName;
1:   }
1: 
1:   private static Class<?> loadClassFromBytes(ClassLoader loader, String name, byte[] classData,
1:       String classToProxyName) throws UnableToProxyException
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "loadClassFromBytes", new Object[] { loader, name,
1:         classData });
1: 
1:     Class<?> clazz = null;
1:     try {
1:       Method defineClassMethod = Class.forName("java.lang.ClassLoader").getDeclaredMethod(
1:           "defineClass", String.class, byte[].class, int.class, int.class, ProtectionDomain.class);
1:       defineClassMethod.setAccessible(true);
1:       // define the class in the same classloader where aClass is loaded,
1:       // but use the protection domain of our code
1:       clazz = (Class<?>) defineClassMethod.invoke(loader, name, classData, 0, classData.length,
1:           ProxySubclassGenerator.class.getProtectionDomain());
1:       defineClassMethod.setAccessible(false);
1:     } catch (ClassNotFoundException cnfe) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, cnfe);
1:       throw new ProxyClassDefinitionException(classToProxyName, cnfe);
1:     } catch (NoSuchMethodException nsme) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, nsme);
1:       throw new ProxyClassDefinitionException(classToProxyName, nsme);
1:     } catch (InvocationTargetException ite) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, ite);
1:       throw new ProxyClassDefinitionException(classToProxyName, ite);
1:     } catch (IllegalAccessException iae) {
1:       LOGGER.debug(Constants.LOG_EXCEPTION, iae);
1:       throw new ProxyClassDefinitionException(classToProxyName, iae);
1:     }
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "loadClassFromBytes", clazz);
1: 
1:     return clazz;
1:   }
1: 
1:   public static boolean isProxySubclass(Class<?> aClass)
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "isProxySubclass", new Object[] { aClass });
1: 
1:     // We will always have a proxy map for the class loader of any proxy
1:     // class, so if
1:     // this is null we know to return false
1:     Map<String, String> proxies = proxyClassesByClassLoader.get(aClass.getClassLoader());
1: 
1:     boolean isProxySubclass = (proxies != null && proxies.containsValue(aClass.getName()));
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "isProxySubclass", isProxySubclass);
1: 
1:     return isProxySubclass;
1:   }
1: 
1:   private static void scanForFinalModifiers(Class<?> clazz) throws FinalModifierException
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "scanForFinalModifiers", new Object[] { clazz });
1: 
1:     if (isFinal(clazz.getModifiers())) {
1:       throw new FinalModifierException(clazz);
1:     }
1: 
1:     List<String> finalMethods = new ArrayList<String>();
1: 
1:     // we don't want to check for final methods on java.* or javax.* Class
1:     // also, clazz can never be null here (we will always hit
1:     // java.lang.Object first)
1:     while (!clazz.getName().startsWith("java.") && !clazz.getName().startsWith("javax.")) {
1:       for (Method m : clazz.getDeclaredMethods()) {
1:         //Static finals are ok, because we won't be overriding them :)
1:         if (isFinal(m.getModifiers()) && !Modifier.isStatic(m.getModifiers())) {
1:           finalMethods.add(m.toGenericString());
1:         }
1:       }
1:       clazz = clazz.getSuperclass();
1:     }
1: 
1:     if (!finalMethods.isEmpty()) {
1: 
1:       String methodList = finalMethods.toString();
1:       methodList = methodList.substring(1, methodList.length() - 1);
1:       throw new FinalModifierException(clazz, methodList);
1:     }
1: 
1:     LOGGER.debug(Constants.LOG_EXIT, "scanForFinalModifiers");
1: 
1:   }
1: 
1:   public static InvocationHandler getInvocationHandler(Object o)
1:   {
1:     LOGGER.debug(Constants.LOG_ENTRY, "getInvoationHandler", new Object[] { o });
1: 
1:     InvocationHandler ih = null;
1:     if (isProxySubclass(o.getClass())) {
1:       // we have to catch exceptions here, but we just log them
1:       // the reason for this is that it should be impossible to get these
1:       // exceptions
1:       // since the Object we are dealing with is a class we generated on
1:       // the fly
1:       try {
1:         ih = (InvocationHandler) o.getClass().getDeclaredMethod("getInvocationHandler",
1:             new Class[] {}).invoke(o, new Object[] {});
1:       } catch (IllegalArgumentException e) {
1:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:       } catch (SecurityException e) {
1:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:       } catch (IllegalAccessException e) {
1:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:       } catch (InvocationTargetException e) {
1:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:       } catch (NoSuchMethodException e) {
1:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
1:       }
1:     }
1:     LOGGER.debug(Constants.LOG_EXIT, "getInvoationHandler", ih);
1:     return ih;
1:   }
1: 
1: }
author:Holly Cummins
-------------------------------------------------------------------------------
commit:2ab8aa5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.proxy.impl.NLS;
/////////////////////////////////////////////////////////////////////////
0:     } catch (VerifyError ve) {
0:         LOGGER.info(NLS.MESSAGES.getMessage("no.nonprivate.noargs.constructor", classToProxy));
0:         LOGGER.debug(Constants.LOG_EXCEPTION, ve);
0:         throw new ProxyClassInstantiationException(classToProxy, ve);
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:d064976
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Modifier;
/////////////////////////////////////////////////////////////////////////
0:         //Static finals are ok, because we won't be overriding them :)
0:         if (isFinal(m.getModifiers()) && !Modifier.isStatic(m.getModifiers())) {
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:24455ce
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.proxy.impl.gen;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.proxy.FinalModifierException;
0: import org.apache.aries.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_ENTRY, "getProxySubclass", new Object[] { aClass });
/////////////////////////////////////////////////////////////////////////
0:           LOGGER.debug(Constants.LOG_EXCEPTION, cnfe);
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_EXIT, "getProxySubclass", classToReturn);
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_ENTRY, "newProxySubclassInstance", new Object[] {
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.debug(Constants.LOG_EXCEPTION, nsme);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, ite);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, ie);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, iae);
0:     LOGGER.debug(Constants.LOG_EXIT, "newProxySubclassInstance", proxySubclassInstance);
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_ENTRY, "generateAndLoadSubclass", new Object[] { aClass,
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.debug(Constants.LOG_EXCEPTION, ioe);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, tnpe);
0:     LOGGER.debug(Constants.LOG_EXIT, "generateAndLoadSubclass", clazz);
0:     LOGGER.debug(Constants.LOG_ENTRY, "processClass", new Object[] { cReader, cWriter,
0:     LOGGER.debug(Constants.LOG_EXIT, "processClass", byteClassData);
0:     LOGGER.debug(Constants.LOG_ENTRY, "getBinaryName", name);
0:     LOGGER.debug(Constants.LOG_EXIT, "getBinaryName", binaryName);
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_ENTRY, "loadClassFromBytes", new Object[] { loader, name,
/////////////////////////////////////////////////////////////////////////
0:       LOGGER.debug(Constants.LOG_EXCEPTION, cnfe);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, nsme);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, ite);
0:       LOGGER.debug(Constants.LOG_EXCEPTION, iae);
0:     LOGGER.debug(Constants.LOG_EXIT, "loadClassFromBytes", clazz);
0:     LOGGER.debug(Constants.LOG_ENTRY, "isProxySubclass", new Object[] { aClass });
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_EXIT, "isProxySubclass", isProxySubclass);
0:     LOGGER.debug(Constants.LOG_ENTRY, "scanForFinalModifiers", new Object[] { clazz });
/////////////////////////////////////////////////////////////////////////
0:     LOGGER.debug(Constants.LOG_EXIT, "scanForFinalModifiers");
0:     LOGGER.debug(Constants.LOG_ENTRY, "getInvoationHandler", new Object[] { o });
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
0:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
0:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
0:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
0:         LOGGER.debug(Constants.LOG_EXCEPTION, e);
0:     LOGGER.debug(Constants.LOG_EXIT, "getInvoationHandler", ih);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:a5e19d7
/////////////////////////////////////////////////////////////////////////
0:   
0:   private static final ClassLoader defaultClassLoader = new ClassLoader() {};
/////////////////////////////////////////////////////////////////////////
0:     // in the special case where the loader is null we use a default classloader
0:     // this is for subclassing java.* or javax.* packages, so that one will do
0:     if (loader == null) loader = defaultClassLoader;
commit:0e57013
/////////////////////////////////////////////////////////////////////////
0:       packageName = "org.apache.aries.blueprint.proxy." + packageName;
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:6a4e3c8
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.blueprint.proxy;
0: 
0: import static java.lang.reflect.Modifier.isFinal;
0: 
0: import java.io.IOException;
0: import java.lang.reflect.Constructor;
0: import java.lang.reflect.InvocationHandler;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
0: import java.security.ProtectionDomain;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.WeakHashMap;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.ConcurrentMap;
0: 
0: import org.objectweb.asm.ClassReader;
0: import org.objectweb.asm.ClassVisitor;
0: import org.objectweb.asm.ClassWriter;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: public class ProxySubclassGenerator
0: {
0: 
0:   private final static Logger LOGGER = LoggerFactory.getLogger(ProxySubclassGenerator.class);
0: 
0:   // This map holds references to the names of classes created by this Class
0:   // It is a weak map (so when a ClassLoader is garbage collected we remove
0:   // the map of
0:   // Class names to sub-Class names)
0:   private static final Map<ClassLoader, ConcurrentMap<String, String>> proxyClassesByClassLoader;
0: 
0:   static {
0:     // Ensure that this is a synchronized map as we may use it from multiple
0:     // threads concurrently
0:     //
0:     proxyClassesByClassLoader = Collections
0:         .synchronizedMap(new WeakHashMap<ClassLoader, ConcurrentMap<String, String>>());
0:   }
0: 
0:   private static final char FINAL_MODIFIER = '!';
0:   private static final char UNABLE_TO_PROXY = '#';
0: 
0:   public static Class<?> getProxySubclass(Class<?> aClass) throws UnableToProxyException
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "getProxySubclass", new Object[] { aClass });
0: 
0:     ClassLoader loader = aClass.getClassLoader();
0:     // in the special case where the loader is null we use the thread
0:     // ContextClassLoader
0:     // this is for subclassing java.* or javax.* packages
0:     if (loader == null) loader = Thread.currentThread().getContextClassLoader();
0: 
0:     ConcurrentMap<String, String> proxyMap;
0:     synchronized (loader) {
0:       proxyMap = proxyClassesByClassLoader.get(loader);
0:       if (proxyMap == null) {
0:         proxyMap = new ConcurrentHashMap<String, String>();
0:         proxyClassesByClassLoader.put(loader, proxyMap);
0:       }
0:     }
0: 
0:     // check the map to see if we have already generated a subclass for this
0:     // class
0:     // if we have return the mapped class object
0:     // if we haven't generate the subclass and return it
0:     Class<?> classToReturn = null;
0:     synchronized (aClass) {
0:       String key = aClass.getName();
0:       String className = proxyMap.get(key);
0:       if (className != null) {
0: 
0:         LOGGER.debug("Found proxy subclass with key {} and name {}.", key, className);
0: 
0:         if (className.charAt(0) == FINAL_MODIFIER) {
0:           String[] exceptionParts = className.substring(1).split(":");
0:           if (exceptionParts.length == 1) {
0:             throw new FinalModifierException(aClass);
0:           } else {
0:             throw new FinalModifierException(aClass, exceptionParts[1]);
0:           }
0:         } else if (className.charAt(0) == UNABLE_TO_PROXY) {
0:           throw new UnableToProxyException(aClass);
0:         }
0: 
0:         try {
0:           classToReturn = loader.loadClass(className);
0:         } catch (ClassNotFoundException cnfe) {
0:           LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, cnfe);
0:           throw new UnableToLoadProxyException(className, cnfe);
0:         }
0:       } else {
0: 
0:         LOGGER.debug("Need to generate subclass. Using key {}.", key);
0:         try {
0:           scanForFinalModifiers(aClass);
0: 
0:           classToReturn = generateAndLoadSubclass(aClass, loader);
0: 
0:           if (classToReturn != null) {
0:             proxyMap.put(key, classToReturn.getName());
0:           } else {
0:             proxyMap.put(key, UNABLE_TO_PROXY + aClass.getName());
0:             throw new UnableToProxyException(aClass);
0:           }
0:         } catch (FinalModifierException e) {
0:           if (e.isFinalClass()) {
0:             proxyMap.put(key, FINAL_MODIFIER + e.getClassName());
0:             throw e;
0:           } else {
0:             proxyMap.put(key, FINAL_MODIFIER + e.getClassName() + ':' + e.getFinalMethods());
0:             throw e;
0:           }
0:         }
0: 
0:       }
0:     }
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "getProxySubclass", classToReturn);
0: 
0:     return classToReturn;
0:   }
0: 
0:   public static Object newProxySubclassInstance(Class<?> classToProxy, InvocationHandler ih)
0:       throws UnableToProxyException
0:   {
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "newProxySubclassInstance", new Object[] {
0:         classToProxy, ih });
0: 
0:     Object proxySubclassInstance = null;
0:     try {
0:       Class<?> generatedProxySubclass = getProxySubclass(classToProxy);
0:       LOGGER.debug("Getting the proxy subclass constructor");
0:       Constructor<?> subclassConstructor = generatedProxySubclass
0:           .getConstructor(new Class[] { InvocationHandler.class });
0:       LOGGER.debug("Invoking the proxy subclass constructor");
0:       proxySubclassInstance = subclassConstructor.newInstance(ih);
0:       LOGGER.debug("Invoked proxy subclass constructor");
0:     } catch (NoSuchMethodException nsme) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, nsme);
0:       throw new ProxyClassInstantiationException(classToProxy, nsme);
0:     } catch (InvocationTargetException ite) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, ite);
0:       throw new ProxyClassInstantiationException(classToProxy, ite);
0:     } catch (InstantiationException ie) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, ie);
0:       throw new ProxyClassInstantiationException(classToProxy, ie);
0:     } catch (IllegalAccessException iae) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, iae);
0:       throw new ProxyClassInstantiationException(classToProxy, iae);
0:     }
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "newProxySubclassInstance", proxySubclassInstance);
0: 
0:     return proxySubclassInstance;
0:   }
0: 
0:   private static Class<?> generateAndLoadSubclass(Class<?> aClass, ClassLoader loader)
0:       throws UnableToProxyException
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "generateAndLoadSubclass", new Object[] { aClass,
0:         loader });
0: 
0:     // set the newClassName
0:     String newClassName = "$" + aClass.getSimpleName() + aClass.hashCode();
0:     String packageName = aClass.getPackage().getName();
0:     if (packageName.startsWith("java.") || packageName.startsWith("javax.")) {
0:       packageName = "com.ibm.osgi.blueprint.proxy." + packageName;
0:     }
0:     String fullNewClassName = (packageName + "." + newClassName).replaceAll("\\.", "/");
0: 
0:     LOGGER.debug("New class name: {}", newClassName);
0:     LOGGER.debug("Full new class name: {}", fullNewClassName);
0: 
0:     Class<?> clazz = null;
0:     try {
0:       ClassReader cReader = new ClassReader(loader.getResourceAsStream(aClass.getName().replaceAll(
0:           "\\.", "/")
0:           + ".class"));
0:       ClassWriter cWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
0:       ClassVisitor dynamicSubclassAdapter = new ProxySubclassAdapter(cWriter, fullNewClassName,
0:           loader);
0:       byte[] byteClassData = processClass(cReader, cWriter, dynamicSubclassAdapter);
0:       clazz = loadClassFromBytes(loader, getBinaryName(fullNewClassName), byteClassData, aClass
0:           .getName());
0:     } catch (IOException ioe) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, ioe);
0:       throw new ProxyClassBytecodeGenerationException(aClass.getName(), ioe);
0:     } catch (TypeNotPresentException tnpe) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, tnpe);
0:       throw new ProxyClassBytecodeGenerationException(tnpe.typeName(), tnpe.getCause());
0:     }
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "generateAndLoadSubclass", clazz);
0: 
0:     return clazz;
0:   }
0: 
0:   private static byte[] processClass(ClassReader cReader, ClassWriter cWriter, ClassVisitor cVisitor)
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "processClass", new Object[] { cReader, cWriter,
0:         cVisitor });
0: 
0:     cReader.accept(cVisitor, ClassReader.SKIP_DEBUG);
0:     byte[] byteClassData = cWriter.toByteArray();
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "processClass", byteClassData);
0: 
0:     return byteClassData;
0:   }
0: 
0:   private static String getBinaryName(String name)
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "getBinaryName", name);
0: 
0:     String binaryName = name.replaceAll("/", "\\.");
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "getBinaryName", binaryName);
0: 
0:     return binaryName;
0:   }
0: 
0:   private static Class<?> loadClassFromBytes(ClassLoader loader, String name, byte[] classData,
0:       String classToProxyName) throws UnableToProxyException
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "loadClassFromBytes", new Object[] { loader, name,
0:         classData });
0: 
0:     Class<?> clazz = null;
0:     try {
0:       Method defineClassMethod = Class.forName("java.lang.ClassLoader").getDeclaredMethod(
0:           "defineClass", String.class, byte[].class, int.class, int.class, ProtectionDomain.class);
0:       defineClassMethod.setAccessible(true);
0:       // define the class in the same classloader where aClass is loaded,
0:       // but use the protection domain of our code
0:       clazz = (Class<?>) defineClassMethod.invoke(loader, name, classData, 0, classData.length,
0:           ProxySubclassGenerator.class.getProtectionDomain());
0:       defineClassMethod.setAccessible(false);
0:     } catch (ClassNotFoundException cnfe) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, cnfe);
0:       throw new ProxyClassDefinitionException(classToProxyName, cnfe);
0:     } catch (NoSuchMethodException nsme) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, nsme);
0:       throw new ProxyClassDefinitionException(classToProxyName, nsme);
0:     } catch (InvocationTargetException ite) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, ite);
0:       throw new ProxyClassDefinitionException(classToProxyName, ite);
0:     } catch (IllegalAccessException iae) {
0:       LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, iae);
0:       throw new ProxyClassDefinitionException(classToProxyName, iae);
0:     }
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "loadClassFromBytes", clazz);
0: 
0:     return clazz;
0:   }
0: 
0:   public static boolean isProxySubclass(Class<?> aClass)
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "isProxySubclass", new Object[] { aClass });
0: 
0:     // We will always have a proxy map for the class loader of any proxy
0:     // class, so if
0:     // this is null we know to return false
0:     Map<String, String> proxies = proxyClassesByClassLoader.get(aClass.getClassLoader());
0: 
0:     boolean isProxySubclass = (proxies != null && proxies.containsValue(aClass.getName()));
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "isProxySubclass", isProxySubclass);
0: 
0:     return isProxySubclass;
0:   }
0: 
0:   private static void scanForFinalModifiers(Class<?> clazz) throws FinalModifierException
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "scanForFinalModifiers", new Object[] { clazz });
0: 
0:     if (isFinal(clazz.getModifiers())) {
0:       throw new FinalModifierException(clazz);
0:     }
0: 
0:     List<String> finalMethods = new ArrayList<String>();
0: 
0:     // we don't want to check for final methods on java.* or javax.* Class
0:     // also, clazz can never be null here (we will always hit
0:     // java.lang.Object first)
0:     while (!clazz.getName().startsWith("java.") && !clazz.getName().startsWith("javax.")) {
0:       for (Method m : clazz.getDeclaredMethods()) {
0:         if (isFinal(m.getModifiers())) {
0:           finalMethods.add(m.toGenericString());
0:         }
0:       }
0:       clazz = clazz.getSuperclass();
0:     }
0: 
0:     if (!finalMethods.isEmpty()) {
0: 
0:       String methodList = finalMethods.toString();
0:       methodList = methodList.substring(1, methodList.length() - 1);
0:       throw new FinalModifierException(clazz, methodList);
0:     }
0: 
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "scanForFinalModifiers");
0: 
0:   }
0: 
0:   public static InvocationHandler getInvocationHandler(Object o)
0:   {
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_ENTRY, "getInvoationHandler", new Object[] { o });
0: 
0:     InvocationHandler ih = null;
0:     if (isProxySubclass(o.getClass())) {
0:       // we have to catch exceptions here, but we just log them
0:       // the reason for this is that it should be impossible to get these
0:       // exceptions
0:       // since the Object we are dealing with is a class we generated on
0:       // the fly
0:       try {
0:         ih = (InvocationHandler) o.getClass().getDeclaredMethod("getInvocationHandler",
0:             new Class[] {}).invoke(o, new Object[] {});
0:       } catch (IllegalArgumentException e) {
0:         LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, e);
0:       } catch (SecurityException e) {
0:         LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, e);
0:       } catch (IllegalAccessException e) {
0:         LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, e);
0:       } catch (InvocationTargetException e) {
0:         LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, e);
0:       } catch (NoSuchMethodException e) {
0:         LOGGER.debug(AsmInterceptorWrapper.LOG_EXCEPTION, e);
0:       }
0:     }
0:     LOGGER.debug(AsmInterceptorWrapper.LOG_EXIT, "getInvoationHandler", ih);
0:     return ih;
0:   }
0: 
0: }
============================================================================