1:fdf3952: /**
1:fdf3952:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:fdf3952:  *  contributor license agreements.  See the NOTICE file distributed with
1:fdf3952:  *  this work for additional information regarding copyright ownership.
1:fdf3952:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:fdf3952:  *  (the "License"); you may not use this file except in compliance with
1:fdf3952:  *  the License.  You may obtain a copy of the License at
1:fdf3952:  *
1:fdf3952:  *     http://www.apache.org/licenses/LICENSE-2.0
1:fdf3952:  *
1:fdf3952:  *  Unless required by applicable law or agreed to in writing, software
1:fdf3952:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:fdf3952:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdf3952:  *  See the License for the specific language governing permissions and
1:fdf3952:  *  limitations under the License.
1:fdf3952:  */
1:fdf3952: package org.apache.aries.jmx.util;
1:fdf3952: 
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.ACTIVE;
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.INSTALLED;
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.RESOLVED;
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.STARTING;
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.STOPPING;
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.UNINSTALLED;
1:fdf3952: import static org.osgi.jmx.framework.BundleStateMBean.UNKNOWN;
1:fdf3952: 
1:fdf3952: import java.io.IOException;
1:fdf3952: import java.util.ArrayList;
1:fdf3952: import java.util.Collection;
1:fdf3952: import java.util.Dictionary;
1:fdf3952: import java.util.HashSet;
1:fdf3952: import java.util.List;
1:fdf3952: import java.util.Set;
1:fdf3952: 
1:fdf3952: import org.apache.aries.util.ManifestHeaderUtils;
1:fdf3952: import org.osgi.framework.Bundle;
1:fdf3952: import org.osgi.framework.BundleContext;
1:fdf3952: import org.osgi.framework.Constants;
1:fdf3952: import org.osgi.framework.InvalidSyntaxException;
1:fdf3952: import org.osgi.framework.ServiceReference;
1:fdf3952: import org.osgi.service.packageadmin.ExportedPackage;
1:fdf3952: import org.osgi.service.packageadmin.PackageAdmin;
1:fdf3952: import org.osgi.service.packageadmin.RequiredBundle;
1:fdf3952: 
1:fdf3952: /**
1:fdf3952:  * This class contains common utilities related to Framework operations for the MBean implementations
1:fdf3952:  * 
1:fdf3952:  * @version $Rev$ $Date$
1:fdf3952:  */
1:fdf3952: public class FrameworkUtils {
1:fdf3952: 
1:fdf3952:     private FrameworkUtils() {
1:fdf3952:         super();
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * 
1:fdf3952:      * Returns the Bundle object for a given id
1:fdf3952:      * 
1:fdf3952:      * @param bundleContext
1:fdf3952:      * @param bundleId
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if no Bundle is found with matching bundleId
1:fdf3952:      */
1:fdf3952:     public static Bundle resolveBundle(BundleContext bundleContext, long bundleId) throws IOException {
1:fdf3952:         if (bundleContext == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundleContext cannot be null");
1:fdf3952:         }
1:fdf3952:         Bundle bundle = bundleContext.getBundle(bundleId);
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IOException("Bundle with id [" + bundleId + "] not found");
1:fdf3952:         }
1:fdf3952:         return bundle;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns an array of bundleIds
1:fdf3952:      * 
1:fdf3952:      * @param bundles
1:fdf3952:      *            array of <code>Bundle</code> objects
1:fdf3952:      * @return bundleIds in sequence
1:fdf3952:      */
1:fdf3952:     public static long[] getBundleIds(Bundle[] bundles) {
1:fdf3952:         long[] result;
1:fdf3952:         if (bundles == null) {
1:fdf3952:             result = new long[0];
1:fdf3952:         } else {
1:fdf3952:             result = new long[bundles.length];
1:fdf3952:             for (int i = 0; i < bundles.length; i++) {
1:fdf3952:                 result[i] = bundles[i].getBundleId();
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952:     
1:fdf3952:     public static long[] getBundleIds(List<Bundle> bundles) { 
1:fdf3952:         long[] result;
1:fdf3952:         if (bundles == null) {
1:fdf3952:             result = new long[0];
1:fdf3952:         } else {
1:fdf3952:             result = new long[bundles.size()];
1:fdf3952:             for (int i = 0; i < bundles.size(); i++) {
1:fdf3952:                 result[i] = bundles.get(i).getBundleId();
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * 
1:fdf3952:      * Returns the ServiceReference object with matching service.id
1:fdf3952:      * 
1:fdf3952:      * @param bundleContext
1:fdf3952:      * @param serviceId
1:fdf3952:      * @return ServiceReference with matching service.id property
1:fdf3952:      * @throws IllegalArgumentException if bundleContext is null
1:fdf3952:      * @throws IOException if no service is found with the given id
1:fdf3952:      */
1:fdf3952:     public static ServiceReference resolveService(BundleContext bundleContext, long serviceId) throws IOException {
1:fdf3952:         if (bundleContext == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundleContext cannot be null");
1:fdf3952:         }
1:fdf3952:         ServiceReference result = null;
1:fdf3952:         try {
1:fdf3952:             ServiceReference[] references = bundleContext.getAllServiceReferences(null, "(" + Constants.SERVICE_ID
1:fdf3952:                     + "=" + serviceId + ")");
1:fdf3952:             if (references == null || references.length < 1) {
1:fdf3952:                 throw new IOException("Service with id [" + serviceId + "] not found");
1:fdf3952:             } else {
1:fdf3952:                 result = references[0];
1:fdf3952:             }
1:fdf3952:         } catch (InvalidSyntaxException e) {
1:fdf3952:             IOException ioex = new IOException("Failure when resolving service ");
1:fdf3952:             ioex.initCause(e);
1:fdf3952:             throw ioex;
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns an array of service.id values
1:fdf3952:      * 
1:fdf3952:      * @param serviceReferences
1:fdf3952:      *            array of <code>ServiceReference</code> objects
1:fdf3952:      * @return service.id values in sequence
1:fdf3952:      */
1:fdf3952:     public static long[] getServiceIds(ServiceReference[] serviceReferences) {
1:fdf3952:         long result[] = (serviceReferences == null) ? new long[0] : new long[serviceReferences.length];
1:fdf3952:         for (int i = 0; i < result.length; i++) {
1:fdf3952:             result[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the packages exported by the specified bundle
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static String[] getBundleExportedPackages(Bundle bundle, PackageAdmin packageAdmin)
1:fdf3952:             throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         String[] exportedPackages;
1:fdf3952:         ExportedPackage[] exported = packageAdmin.getExportedPackages(bundle);
1:fdf3952:         if (exported != null) {
1:fdf3952:             exportedPackages = new String[exported.length];
1:fdf3952:             for (int i = 0; i < exported.length; i++) {
1:fdf3952:                 exportedPackages[i] = exported[i].getName() + ";" + exported[i].getVersion().toString();
1:fdf3952:             }
1:fdf3952:         } else {
1:fdf3952:             exportedPackages = new String[0];
1:fdf3952:         }
1:fdf3952:         return exportedPackages;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the bundle ids of any resolved fragments
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static long[] getFragmentIds(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         long[] fragmentIds;
1:fdf3952:         Bundle[] fragments = packageAdmin.getFragments(bundle);
1:fdf3952:         if (fragments != null) {
1:fdf3952:             fragmentIds = getBundleIds(fragments);
1:fdf3952:         } else {
1:fdf3952:             fragmentIds = new long[0];
1:fdf3952:         }
1:fdf3952:         return fragmentIds;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the bundle ids of any resolved hosts
1:fdf3952:      * 
1:fdf3952:      * @param fragment
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if fragment or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static long[] getHostIds(Bundle fragment, PackageAdmin packageAdmin) throws IllegalArgumentException {
1:fdf3952:         if (fragment == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         long[] hostIds;
1:fdf3952:         Bundle[] hosts = packageAdmin.getHosts(fragment);
1:fdf3952:         if (hosts != null) {
1:fdf3952:             hostIds = getBundleIds(hosts);
1:fdf3952:         } else {
1:fdf3952:             hostIds = new long[0];
1:fdf3952:         }
1:fdf3952:         return hostIds;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the resolved package imports for the given bundle
1:fdf3952:      * 
1:fdf3952:      * @param localBundleContext
1:fdf3952:      *            BundleContext object of this bundle/caller
1:fdf3952:      * @param bundle
1:fdf3952:      *            target Bundle object to query imported packages for
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * 
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if fragment or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static String[] getBundleImportedPackages(BundleContext localBundleContext, Bundle bundle,
1:fdf3952:             PackageAdmin packageAdmin) throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         
1:fdf3952:         List<String> result = new ArrayList<String>();
1:fdf3952:         for (ExportedPackage ep : getBundleImportedPackagesRaw(localBundleContext, bundle, packageAdmin)) {
1:fdf3952:           result.add(ep.getName()+";"+ep.getVersion());
1:fdf3952:         }
1:fdf3952:         
1:fdf3952:         return result.toArray(new String[0]);
1:fdf3952:     }
1:fdf3952:     
1:fdf3952:     @SuppressWarnings("unchecked")
1:fdf3952:     private static Collection<ExportedPackage> getBundleImportedPackagesRaw(BundleContext localBundleContext, Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException 
1:fdf3952:     {
1:fdf3952:       List<ExportedPackage> result = new ArrayList<ExportedPackage>();
1:fdf3952:       Dictionary<String, String> bundleHeaders = bundle.getHeaders();
1:fdf3952:       String dynamicImportHeader = bundleHeaders.get(Constants.DYNAMICIMPORT_PACKAGE);
1:fdf3952:       // if DynamicImport-Package used, then do full iteration
1:fdf3952:       // else means no dynamic import or has dynamic import but no wildcard "*" in it.
1:fdf3952:       if (dynamicImportHeader != null && dynamicImportHeader.contains("*")) {
1:fdf3952:           Bundle[] bundles = localBundleContext.getBundles();
1:fdf3952:           for (Bundle candidate : bundles) {
1:fdf3952:               if (candidate.equals(bundle)) {
1:fdf3952:                   continue;
1:fdf3952:               }
1:fdf3952:               ExportedPackage[] candidateExports = packageAdmin.getExportedPackages(candidate);
1:fdf3952:               if (candidateExports != null) {
1:fdf3952:                   for (ExportedPackage exportedPackage : candidateExports) {
1:fdf3952:                       Bundle[] userBundles = exportedPackage.getImportingBundles();
1:fdf3952:                       if (userBundles != null && arrayContains(userBundles, bundle)) {
1:fdf3952:                           result.add(exportedPackage);
1:fdf3952:                       }
1:fdf3952:                   }// end for candidateExports
1:fdf3952:               }
1:fdf3952:           }// end for bundles
1:fdf3952:       } else { // only query ExportPackage for package names declared as imported
1:fdf3952:           List<String> importPackages = new ArrayList<String>();
1:fdf3952:           String importPackageHeader = bundleHeaders.get(Constants.IMPORT_PACKAGE);
1:fdf3952:           if (importPackageHeader != null && importPackageHeader.length() > 0) {
1:fdf3952:             importPackages.addAll(extractHeaderDeclaration(importPackageHeader));
1:fdf3952:           }
1:fdf3952:           if (dynamicImportHeader != null) {
1:fdf3952:             importPackages.addAll(extractHeaderDeclaration(dynamicImportHeader));
1:fdf3952:           }
1:fdf3952:           for (String packageName : importPackages) {
1:fdf3952:               ExportedPackage[] candidateExports = packageAdmin.getExportedPackages(packageName);
1:fdf3952:               if (candidateExports != null) {
1:fdf3952:                   for (ExportedPackage exportedPackage : candidateExports) {
1:fdf3952:                       Bundle[] userBundles = exportedPackage.getImportingBundles();
1:fdf3952:                       if (userBundles != null && arrayContains(userBundles, bundle)) {
1:fdf3952:                           result.add(exportedPackage);
1:fdf3952:                       }
1:fdf3952:                   }// end for candidateExports
1:fdf3952:               }
1:fdf3952:           }
1:fdf3952:       }
1:fdf3952:       return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the service.id values for services registered by the given bundle
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle is null
1:fdf3952:      * @throws IlleglStateException
1:fdf3952:      *             if bundle has been uninstalled
1:fdf3952:      */
1:fdf3952:     public static long[] getRegisteredServiceIds(Bundle bundle) throws IllegalArgumentException, IllegalStateException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         long[] serviceIds;
1:fdf3952:         ServiceReference[] serviceReferences = bundle.getRegisteredServices();
1:fdf3952:         if (serviceReferences != null) {
1:fdf3952:             serviceIds = new long[serviceReferences.length];
1:fdf3952:             for (int i = 0; i < serviceReferences.length; i++) {
1:fdf3952:                 serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
1:fdf3952:             }
1:fdf3952:         } else {
1:fdf3952:             serviceIds = new long[0];
1:fdf3952:         }
1:fdf3952:         return serviceIds;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the service.id values of services being used by the given bundle
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle is null
1:fdf3952:      * @throws IlleglStateException
1:fdf3952:      *             if bundle has been uninstalled
1:fdf3952:      */
1:fdf3952:     public static long[] getServicesInUseByBundle(Bundle bundle) throws IllegalArgumentException, IllegalStateException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         long[] serviceIds;
1:fdf3952:         ServiceReference[] serviceReferences = bundle.getServicesInUse();
1:fdf3952:         if (serviceReferences != null) {
1:fdf3952:             serviceIds = new long[serviceReferences.length];
1:fdf3952:             for (int i = 0; i < serviceReferences.length; i++) {
1:fdf3952:                 serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
1:fdf3952:             }
1:fdf3952:         } else {
1:fdf3952:             serviceIds = new long[0];
1:fdf3952:         }
1:fdf3952:         return serviceIds;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns the status of pending removal
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @return true if the bundle is pending removal
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static boolean isBundlePendingRemoval(Bundle bundle, PackageAdmin packageAdmin)
1:fdf3952:             throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         boolean result = false;
1:fdf3952:         ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
1:fdf3952:         if (exportedPackages != null) {
1:fdf3952:             for (ExportedPackage exportedPackage : exportedPackages) {
1:fdf3952:                 if (exportedPackage.isRemovalPending()) {
1:fdf3952:                     result = true;
1:fdf3952:                     break;
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         if (!result) {
1:fdf3952:             RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
1:fdf3952:             if (requiredBundles != null) {
1:fdf3952:                 for (RequiredBundle requiredBundle : requiredBundles) {
1:fdf3952:                     Bundle required = requiredBundle.getBundle();
1:fdf3952:                     if (required == bundle) {
1:fdf3952:                         result = requiredBundle.isRemovalPending();
1:fdf3952:                         break;
1:fdf3952:                     }
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Checks if the given bundle is currently required by other bundles
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static boolean isBundleRequiredByOthers(Bundle bundle, PackageAdmin packageAdmin)
1:fdf3952:             throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         boolean result = false;
1:fdf3952:         // Check imported packages (statically or dynamically)
1:fdf3952:         ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
1:fdf3952:         if (exportedPackages != null) {
1:fdf3952:             for (ExportedPackage exportedPackage : exportedPackages) {
1:fdf3952:                 Bundle[] importingBundles = exportedPackage.getImportingBundles();
1:fdf3952:                 if (importingBundles != null && importingBundles.length > 0) {
1:fdf3952:                     result = true;
1:fdf3952:                     break;
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         if (!result) {
1:fdf3952:             // Check required bundles
1:fdf3952:             RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
1:fdf3952:             if (requiredBundles != null) {
1:fdf3952:                 for (RequiredBundle requiredBundle : requiredBundles) {
1:fdf3952:                     Bundle required = requiredBundle.getBundle();
1:fdf3952:                     if (required == bundle) {
1:fdf3952:                         Bundle[] requiring = requiredBundle.getRequiringBundles();
1:fdf3952:                         if (requiring != null && requiring.length > 0) {
1:fdf3952:                             result = true;
1:fdf3952:                             break;
1:fdf3952:                         }
1:fdf3952:                     }
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         if (!result) {
1:fdf3952:             // Check fragment bundles
1:fdf3952:             Bundle[] fragments = packageAdmin.getFragments(bundle);
1:fdf3952:             if (fragments != null && fragments.length > 0) {
1:fdf3952:                 result = true;
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns an array of ids of bundles the given bundle depends on
1:fdf3952:      * 
1:fdf3952:      * @param localBundleContext
1:fdf3952:      *            BundleContext object of this bundle/caller
1:fdf3952:      * @param bundle
1:fdf3952:      *            target Bundle object to query dependencies for
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * 
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     @SuppressWarnings("unchecked")
1:fdf3952:     public static long[] getBundleDependencies(BundleContext localBundleContext, 
1:fdf3952:                                                Bundle bundle,
1:fdf3952:                                                PackageAdmin packageAdmin) throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }
1:fdf3952:         Set<Bundle> dependencies = new HashSet<Bundle>();
1:fdf3952:         
1:fdf3952:         for (ExportedPackage ep : getBundleImportedPackagesRaw(localBundleContext, bundle, packageAdmin)) {
1:fdf3952:           dependencies.add(ep.getExportingBundle());
1:fdf3952:         }
1:fdf3952:         
1:fdf3952:         // Handle required bundles
1:fdf3952:         Dictionary<String, String> bundleHeaders = bundle.getHeaders();
1:fdf3952:         String requireBundleHeader = bundleHeaders.get(Constants.REQUIRE_BUNDLE);
1:fdf3952:         if (requireBundleHeader != null) { // only check if Require-Bundle is used
1:fdf3952:         	List<String> bundleSymbolicNames = extractHeaderDeclaration(requireBundleHeader);
1:fdf3952:             for (String bundleSymbolicName: bundleSymbolicNames) {
1:fdf3952:                 RequiredBundle[] candidateRequiredBundles = packageAdmin.getRequiredBundles(bundleSymbolicName);
1:fdf3952:                 if (candidateRequiredBundles != null) {
1:fdf3952:                     for (RequiredBundle candidateRequiredBundle : candidateRequiredBundles) {
1:fdf3952:                         Bundle[] bundlesRequiring = candidateRequiredBundle.getRequiringBundles();
1:fdf3952:                         if (bundlesRequiring != null && arrayContains(bundlesRequiring, bundle)) {
1:fdf3952:                             dependencies.add(candidateRequiredBundle.getBundle());
1:fdf3952:                         }
1:fdf3952:                     }
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         // Handle fragment bundles
1:fdf3952:         Bundle[] hosts = packageAdmin.getHosts(bundle);
1:fdf3952:         if (hosts != null) {
1:fdf3952:             for (Bundle host : hosts) {
1:fdf3952:                 dependencies.add(host);
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return getBundleIds(dependencies.toArray(new Bundle[dependencies.size()]));
1:fdf3952:     }
1:fdf3952:     
1:fdf3952:     /**
1:fdf3952:      * Returns an array of ids of bundles that depend on the given bundle
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @param packageAdmin
1:fdf3952:      * @return
1:fdf3952:      * @throws IllegalArgumentException
1:fdf3952:      *             if bundle or packageAdmin are null
1:fdf3952:      */
1:fdf3952:     public static long[] getDependentBundles(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException {
1:fdf3952:         if (bundle == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:fdf3952:         }
1:fdf3952:         if (packageAdmin == null) {
1:fdf3952:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:fdf3952:         }        
1:fdf3952:         Set<Bundle> dependencies = new HashSet<Bundle>();
1:fdf3952:         // Handle imported packages (statically or dynamically)
1:fdf3952:         ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
1:fdf3952:         if (exportedPackages != null) {
1:fdf3952:             for (ExportedPackage exportedPackage : exportedPackages) {
1:fdf3952:                 Bundle[] importingBundles = exportedPackage.getImportingBundles();
1:fdf3952:                 if (importingBundles != null) {
1:fdf3952:                     for (Bundle importingBundle : importingBundles) {
1:fdf3952:                         dependencies.add(importingBundle);
1:fdf3952:                     }
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         // Handle required bundles
1:fdf3952:         RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
1:fdf3952:         if (requiredBundles != null) {
1:fdf3952:             for (RequiredBundle requiredBundle : requiredBundles) {
1:fdf3952:                 Bundle required = requiredBundle.getBundle();
1:fdf3952:                 if (required == bundle) {
1:fdf3952:                     Bundle[] requiringBundles = requiredBundle.getRequiringBundles();
1:fdf3952:                     if (requiringBundles != null) {
1:fdf3952:                         for (Bundle requiringBundle : requiringBundles) {
1:fdf3952:                             dependencies.add(requiringBundle);
1:fdf3952:                         }
1:fdf3952:                     }
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         // Handle fragment bundles
1:fdf3952:         Bundle[] fragments = packageAdmin.getFragments(bundle);
1:fdf3952:         if (fragments != null) {
1:fdf3952:             for (Bundle fragment : fragments) {
1:fdf3952:                 dependencies.add(fragment);
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return getBundleIds(dependencies.toArray(new Bundle[dependencies.size()]));
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /**
1:fdf3952:      * Returns a String representation of the bundles state
1:fdf3952:      * 
1:fdf3952:      * @param bundle
1:fdf3952:      * @return
1:fdf3952:      */
1:fdf3952:     public static String getBundleState(Bundle bundle) {
1:fdf3952:         String state = UNKNOWN;
1:fdf3952:         switch (bundle.getState()) {
1:fdf3952:         case Bundle.INSTALLED:
1:fdf3952:             state = INSTALLED;
1:fdf3952:             break;
1:fdf3952:         case Bundle.RESOLVED:
1:fdf3952:             state = RESOLVED;
1:fdf3952:             break;
1:fdf3952:         case Bundle.STARTING:
1:fdf3952:             state = STARTING;
1:fdf3952:             break;
1:fdf3952:         case Bundle.ACTIVE:
1:fdf3952:             state = ACTIVE;
1:fdf3952:             break;
1:fdf3952:         case Bundle.STOPPING:
1:fdf3952:             state = STOPPING;
1:fdf3952:             break;
1:fdf3952:         case Bundle.UNINSTALLED:
1:fdf3952:             state = UNINSTALLED;
1:fdf3952:         }
1:fdf3952:         return state;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /*
1:fdf3952:      * Checks if an object exists in the given array (based on object equality)
1:fdf3952:      */
1:fdf3952:     public static boolean arrayContains(Object[] array, Object value) {
1:fdf3952:         boolean result = false;
1:fdf3952:         if (array != null && value != null) {
1:fdf3952:             for (Object element : array) {
1:fdf3952:                 if (value.equals(element)) {
1:fdf3952:                     result = true;
1:fdf3952:                     break;
1:fdf3952:                 }
1:fdf3952:             }
1:fdf3952:         }
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952: 
1:fdf3952:     /*
1:fdf3952:      * Will parse a header value, strip out trailing attributes and return a list of declarations
1:fdf3952:      */
1:fdf3952:     public static List<String> extractHeaderDeclaration(String headerStatement) {
1:fdf3952:         List<String> result = new ArrayList<String>();
1:fdf3952:         
1:fdf3952:         for (String headerDeclaration : ManifestHeaderUtils.split(headerStatement, ",")) {
1:fdf3952:             String name = headerDeclaration.contains(";") ? headerDeclaration.substring(0, headerDeclaration
1:fdf3952:                     .indexOf(";")) : headerDeclaration;
1:fdf3952:             result.add(name);
1:fdf3952:         }
1:fdf3952:         
1:fdf3952:         return result;
1:fdf3952:     }
1:fdf3952:     
1:fdf3952:     
1:fdf3952: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:0273964
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
1: package org.apache.aries.jmx.util;
1: 
1: import static org.osgi.jmx.framework.BundleStateMBean.ACTIVE;
1: import static org.osgi.jmx.framework.BundleStateMBean.INSTALLED;
1: import static org.osgi.jmx.framework.BundleStateMBean.RESOLVED;
1: import static org.osgi.jmx.framework.BundleStateMBean.STARTING;
1: import static org.osgi.jmx.framework.BundleStateMBean.STOPPING;
1: import static org.osgi.jmx.framework.BundleStateMBean.UNINSTALLED;
1: import static org.osgi.jmx.framework.BundleStateMBean.UNKNOWN;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Dictionary;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Set;
1: 
1: import org.apache.aries.util.ManifestHeaderUtils;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.packageadmin.ExportedPackage;
1: import org.osgi.service.packageadmin.PackageAdmin;
1: import org.osgi.service.packageadmin.RequiredBundle;
1: 
1: /**
1:  * This class contains common utilities related to Framework operations for the MBean implementations
1:  * 
1:  * @version $Rev$ $Date$
1:  */
1: public class FrameworkUtils {
1: 
1:     private FrameworkUtils() {
1:         super();
1:     }
1: 
1:     /**
1:      * 
1:      * Returns the Bundle object for a given id
1:      * 
1:      * @param bundleContext
1:      * @param bundleId
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if no Bundle is found with matching bundleId
1:      */
1:     public static Bundle resolveBundle(BundleContext bundleContext, long bundleId) throws IOException {
1:         if (bundleContext == null) {
1:             throw new IllegalArgumentException("Argument bundleContext cannot be null");
1:         }
1:         Bundle bundle = bundleContext.getBundle(bundleId);
1:         if (bundle == null) {
1:             throw new IOException("Bundle with id [" + bundleId + "] not found");
1:         }
1:         return bundle;
1:     }
1: 
1:     /**
1:      * Returns an array of bundleIds
1:      * 
1:      * @param bundles
1:      *            array of <code>Bundle</code> objects
1:      * @return bundleIds in sequence
1:      */
1:     public static long[] getBundleIds(Bundle[] bundles) {
1:         long[] result;
1:         if (bundles == null) {
1:             result = new long[0];
1:         } else {
1:             result = new long[bundles.length];
1:             for (int i = 0; i < bundles.length; i++) {
1:                 result[i] = bundles[i].getBundleId();
1:             }
1:         }
1:         return result;
1:     }
1:     
1:     public static long[] getBundleIds(List<Bundle> bundles) { 
1:         long[] result;
1:         if (bundles == null) {
1:             result = new long[0];
1:         } else {
1:             result = new long[bundles.size()];
1:             for (int i = 0; i < bundles.size(); i++) {
1:                 result[i] = bundles.get(i).getBundleId();
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * 
1:      * Returns the ServiceReference object with matching service.id
1:      * 
1:      * @param bundleContext
1:      * @param serviceId
1:      * @return ServiceReference with matching service.id property
1:      * @throws IllegalArgumentException if bundleContext is null
1:      * @throws IOException if no service is found with the given id
1:      */
1:     public static ServiceReference resolveService(BundleContext bundleContext, long serviceId) throws IOException {
1:         if (bundleContext == null) {
1:             throw new IllegalArgumentException("Argument bundleContext cannot be null");
1:         }
1:         ServiceReference result = null;
1:         try {
1:             ServiceReference[] references = bundleContext.getAllServiceReferences(null, "(" + Constants.SERVICE_ID
1:                     + "=" + serviceId + ")");
1:             if (references == null || references.length < 1) {
1:                 throw new IOException("Service with id [" + serviceId + "] not found");
1:             } else {
1:                 result = references[0];
1:             }
1:         } catch (InvalidSyntaxException e) {
1:             IOException ioex = new IOException("Failure when resolving service ");
1:             ioex.initCause(e);
1:             throw ioex;
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Returns an array of service.id values
1:      * 
1:      * @param serviceReferences
1:      *            array of <code>ServiceReference</code> objects
1:      * @return service.id values in sequence
1:      */
1:     public static long[] getServiceIds(ServiceReference[] serviceReferences) {
1:         long result[] = (serviceReferences == null) ? new long[0] : new long[serviceReferences.length];
1:         for (int i = 0; i < result.length; i++) {
1:             result[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Returns the packages exported by the specified bundle
1:      * 
1:      * @param bundle
1:      * @param packageAdmin
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle or packageAdmin are null
1:      */
1:     public static String[] getBundleExportedPackages(Bundle bundle, PackageAdmin packageAdmin)
1:             throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         String[] exportedPackages;
1:         ExportedPackage[] exported = packageAdmin.getExportedPackages(bundle);
1:         if (exported != null) {
1:             exportedPackages = new String[exported.length];
1:             for (int i = 0; i < exported.length; i++) {
1:                 exportedPackages[i] = exported[i].getName() + ";" + exported[i].getVersion().toString();
1:             }
1:         } else {
1:             exportedPackages = new String[0];
1:         }
1:         return exportedPackages;
1:     }
1: 
1:     /**
1:      * Returns the bundle ids of any resolved fragments
1:      * 
1:      * @param bundle
1:      * @param packageAdmin
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle or packageAdmin are null
1:      */
1:     public static long[] getFragmentIds(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         long[] fragmentIds;
1:         Bundle[] fragments = packageAdmin.getFragments(bundle);
1:         if (fragments != null) {
1:             fragmentIds = getBundleIds(fragments);
1:         } else {
1:             fragmentIds = new long[0];
1:         }
1:         return fragmentIds;
1:     }
1: 
1:     /**
1:      * Returns the bundle ids of any resolved hosts
1:      * 
1:      * @param fragment
1:      * @param packageAdmin
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if fragment or packageAdmin are null
1:      */
1:     public static long[] getHostIds(Bundle fragment, PackageAdmin packageAdmin) throws IllegalArgumentException {
1:         if (fragment == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         long[] hostIds;
1:         Bundle[] hosts = packageAdmin.getHosts(fragment);
1:         if (hosts != null) {
1:             hostIds = getBundleIds(hosts);
1:         } else {
1:             hostIds = new long[0];
1:         }
1:         return hostIds;
1:     }
1: 
1:     /**
1:      * Returns the resolved package imports for the given bundle
1:      * 
1:      * @param localBundleContext
1:      *            BundleContext object of this bundle/caller
1:      * @param bundle
1:      *            target Bundle object to query imported packages for
1:      * @param packageAdmin
1:      * 
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if fragment or packageAdmin are null
1:      */
1:     public static String[] getBundleImportedPackages(BundleContext localBundleContext, Bundle bundle,
1:             PackageAdmin packageAdmin) throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         
1:         List<String> result = new ArrayList<String>();
1:         for (ExportedPackage ep : getBundleImportedPackagesRaw(localBundleContext, bundle, packageAdmin)) {
1:           result.add(ep.getName()+";"+ep.getVersion());
1:         }
1:         
1:         return result.toArray(new String[0]);
1:     }
1:     
1:     @SuppressWarnings("unchecked")
1:     private static Collection<ExportedPackage> getBundleImportedPackagesRaw(BundleContext localBundleContext, Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException 
1:     {
1:       List<ExportedPackage> result = new ArrayList<ExportedPackage>();
1:       Dictionary<String, String> bundleHeaders = bundle.getHeaders();
1:       String dynamicImportHeader = bundleHeaders.get(Constants.DYNAMICIMPORT_PACKAGE);
1:       // if DynamicImport-Package used, then do full iteration
1:       // else means no dynamic import or has dynamic import but no wildcard "*" in it.
1:       if (dynamicImportHeader != null && dynamicImportHeader.contains("*")) {
1:           Bundle[] bundles = localBundleContext.getBundles();
1:           for (Bundle candidate : bundles) {
1:               if (candidate.equals(bundle)) {
1:                   continue;
1:               }
1:               ExportedPackage[] candidateExports = packageAdmin.getExportedPackages(candidate);
1:               if (candidateExports != null) {
1:                   for (ExportedPackage exportedPackage : candidateExports) {
1:                       Bundle[] userBundles = exportedPackage.getImportingBundles();
1:                       if (userBundles != null && arrayContains(userBundles, bundle)) {
1:                           result.add(exportedPackage);
1:                       }
1:                   }// end for candidateExports
1:               }
1:           }// end for bundles
1:       } else { // only query ExportPackage for package names declared as imported
1:           List<String> importPackages = new ArrayList<String>();
1:           String importPackageHeader = bundleHeaders.get(Constants.IMPORT_PACKAGE);
1:           if (importPackageHeader != null && importPackageHeader.length() > 0) {
1:             importPackages.addAll(extractHeaderDeclaration(importPackageHeader));
1:           }
1:           if (dynamicImportHeader != null) {
1:             importPackages.addAll(extractHeaderDeclaration(dynamicImportHeader));
1:           }
1:           for (String packageName : importPackages) {
1:               ExportedPackage[] candidateExports = packageAdmin.getExportedPackages(packageName);
1:               if (candidateExports != null) {
1:                   for (ExportedPackage exportedPackage : candidateExports) {
1:                       Bundle[] userBundles = exportedPackage.getImportingBundles();
1:                       if (userBundles != null && arrayContains(userBundles, bundle)) {
1:                           result.add(exportedPackage);
1:                       }
1:                   }// end for candidateExports
1:               }
1:           }
1:       }
1:       return result;
1:     }
1: 
1:     /**
1:      * Returns the service.id values for services registered by the given bundle
1:      * 
1:      * @param bundle
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle is null
1:      * @throws IlleglStateException
1:      *             if bundle has been uninstalled
1:      */
1:     public static long[] getRegisteredServiceIds(Bundle bundle) throws IllegalArgumentException, IllegalStateException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         long[] serviceIds;
1:         ServiceReference[] serviceReferences = bundle.getRegisteredServices();
1:         if (serviceReferences != null) {
1:             serviceIds = new long[serviceReferences.length];
1:             for (int i = 0; i < serviceReferences.length; i++) {
1:                 serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
1:             }
1:         } else {
1:             serviceIds = new long[0];
1:         }
1:         return serviceIds;
1:     }
1: 
1:     /**
1:      * Returns the service.id values of services being used by the given bundle
1:      * 
1:      * @param bundle
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle is null
1:      * @throws IlleglStateException
1:      *             if bundle has been uninstalled
1:      */
1:     public static long[] getServicesInUseByBundle(Bundle bundle) throws IllegalArgumentException, IllegalStateException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         long[] serviceIds;
1:         ServiceReference[] serviceReferences = bundle.getServicesInUse();
1:         if (serviceReferences != null) {
1:             serviceIds = new long[serviceReferences.length];
1:             for (int i = 0; i < serviceReferences.length; i++) {
1:                 serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
1:             }
1:         } else {
1:             serviceIds = new long[0];
1:         }
1:         return serviceIds;
1:     }
1: 
1:     /**
1:      * Returns the status of pending removal
1:      * 
1:      * @param bundle
1:      * @return true if the bundle is pending removal
1:      * @throws IllegalArgumentException
1:      *             if bundle or packageAdmin are null
1:      */
1:     public static boolean isBundlePendingRemoval(Bundle bundle, PackageAdmin packageAdmin)
1:             throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         boolean result = false;
1:         ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
1:         if (exportedPackages != null) {
1:             for (ExportedPackage exportedPackage : exportedPackages) {
1:                 if (exportedPackage.isRemovalPending()) {
1:                     result = true;
1:                     break;
1:                 }
1:             }
1:         }
1:         if (!result) {
1:             RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
1:             if (requiredBundles != null) {
1:                 for (RequiredBundle requiredBundle : requiredBundles) {
1:                     Bundle required = requiredBundle.getBundle();
1:                     if (required == bundle) {
1:                         result = requiredBundle.isRemovalPending();
1:                         break;
1:                     }
1:                 }
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Checks if the given bundle is currently required by other bundles
1:      * 
1:      * @param bundle
1:      * @param packageAdmin
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle or packageAdmin are null
1:      */
1:     public static boolean isBundleRequiredByOthers(Bundle bundle, PackageAdmin packageAdmin)
1:             throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         boolean result = false;
1:         // Check imported packages (statically or dynamically)
1:         ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
1:         if (exportedPackages != null) {
1:             for (ExportedPackage exportedPackage : exportedPackages) {
1:                 Bundle[] importingBundles = exportedPackage.getImportingBundles();
1:                 if (importingBundles != null && importingBundles.length > 0) {
1:                     result = true;
1:                     break;
1:                 }
1:             }
1:         }
1:         if (!result) {
1:             // Check required bundles
1:             RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
1:             if (requiredBundles != null) {
1:                 for (RequiredBundle requiredBundle : requiredBundles) {
1:                     Bundle required = requiredBundle.getBundle();
1:                     if (required == bundle) {
1:                         Bundle[] requiring = requiredBundle.getRequiringBundles();
1:                         if (requiring != null && requiring.length > 0) {
1:                             result = true;
1:                             break;
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:         if (!result) {
1:             // Check fragment bundles
1:             Bundle[] fragments = packageAdmin.getFragments(bundle);
1:             if (fragments != null && fragments.length > 0) {
1:                 result = true;
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Returns an array of ids of bundles the given bundle depends on
1:      * 
1:      * @param localBundleContext
1:      *            BundleContext object of this bundle/caller
1:      * @param bundle
1:      *            target Bundle object to query dependencies for
1:      * @param packageAdmin
1:      * 
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle or packageAdmin are null
1:      */
1:     @SuppressWarnings("unchecked")
1:     public static long[] getBundleDependencies(BundleContext localBundleContext, 
1:                                                Bundle bundle,
1:                                                PackageAdmin packageAdmin) throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }
1:         Set<Bundle> dependencies = new HashSet<Bundle>();
1:         
1:         for (ExportedPackage ep : getBundleImportedPackagesRaw(localBundleContext, bundle, packageAdmin)) {
1:           dependencies.add(ep.getExportingBundle());
1:         }
1:         
1:         // Handle required bundles
1:         Dictionary<String, String> bundleHeaders = bundle.getHeaders();
1:         String requireBundleHeader = bundleHeaders.get(Constants.REQUIRE_BUNDLE);
1:         if (requireBundleHeader != null) { // only check if Require-Bundle is used
1:         	List<String> bundleSymbolicNames = extractHeaderDeclaration(requireBundleHeader);
1:             for (String bundleSymbolicName: bundleSymbolicNames) {
1:                 RequiredBundle[] candidateRequiredBundles = packageAdmin.getRequiredBundles(bundleSymbolicName);
1:                 if (candidateRequiredBundles != null) {
1:                     for (RequiredBundle candidateRequiredBundle : candidateRequiredBundles) {
1:                         Bundle[] bundlesRequiring = candidateRequiredBundle.getRequiringBundles();
1:                         if (bundlesRequiring != null && arrayContains(bundlesRequiring, bundle)) {
1:                             dependencies.add(candidateRequiredBundle.getBundle());
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:         // Handle fragment bundles
1:         Bundle[] hosts = packageAdmin.getHosts(bundle);
1:         if (hosts != null) {
1:             for (Bundle host : hosts) {
1:                 dependencies.add(host);
1:             }
1:         }
1:         return getBundleIds(dependencies.toArray(new Bundle[dependencies.size()]));
1:     }
1:     
1:     /**
1:      * Returns an array of ids of bundles that depend on the given bundle
1:      * 
1:      * @param bundle
1:      * @param packageAdmin
1:      * @return
1:      * @throws IllegalArgumentException
1:      *             if bundle or packageAdmin are null
1:      */
1:     public static long[] getDependentBundles(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException {
1:         if (bundle == null) {
1:             throw new IllegalArgumentException("Argument bundle cannot be null");
1:         }
1:         if (packageAdmin == null) {
1:             throw new IllegalArgumentException("Argument packageAdmin cannot be null");
1:         }        
1:         Set<Bundle> dependencies = new HashSet<Bundle>();
1:         // Handle imported packages (statically or dynamically)
1:         ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
1:         if (exportedPackages != null) {
1:             for (ExportedPackage exportedPackage : exportedPackages) {
1:                 Bundle[] importingBundles = exportedPackage.getImportingBundles();
1:                 if (importingBundles != null) {
1:                     for (Bundle importingBundle : importingBundles) {
1:                         dependencies.add(importingBundle);
1:                     }
1:                 }
1:             }
1:         }
1:         // Handle required bundles
1:         RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
1:         if (requiredBundles != null) {
1:             for (RequiredBundle requiredBundle : requiredBundles) {
1:                 Bundle required = requiredBundle.getBundle();
1:                 if (required == bundle) {
1:                     Bundle[] requiringBundles = requiredBundle.getRequiringBundles();
1:                     if (requiringBundles != null) {
1:                         for (Bundle requiringBundle : requiringBundles) {
1:                             dependencies.add(requiringBundle);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:         // Handle fragment bundles
1:         Bundle[] fragments = packageAdmin.getFragments(bundle);
1:         if (fragments != null) {
1:             for (Bundle fragment : fragments) {
1:                 dependencies.add(fragment);
1:             }
1:         }
1:         return getBundleIds(dependencies.toArray(new Bundle[dependencies.size()]));
1:     }
1: 
1:     /**
1:      * Returns a String representation of the bundles state
1:      * 
1:      * @param bundle
1:      * @return
1:      */
1:     public static String getBundleState(Bundle bundle) {
1:         String state = UNKNOWN;
1:         switch (bundle.getState()) {
1:         case Bundle.INSTALLED:
1:             state = INSTALLED;
1:             break;
1:         case Bundle.RESOLVED:
1:             state = RESOLVED;
1:             break;
1:         case Bundle.STARTING:
1:             state = STARTING;
1:             break;
1:         case Bundle.ACTIVE:
1:             state = ACTIVE;
1:             break;
1:         case Bundle.STOPPING:
1:             state = STOPPING;
1:             break;
1:         case Bundle.UNINSTALLED:
1:             state = UNINSTALLED;
1:         }
1:         return state;
1:     }
1: 
1:     /*
1:      * Checks if an object exists in the given array (based on object equality)
1:      */
1:     public static boolean arrayContains(Object[] array, Object value) {
1:         boolean result = false;
1:         if (array != null && value != null) {
1:             for (Object element : array) {
1:                 if (value.equals(element)) {
1:                     result = true;
1:                     break;
1:                 }
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     /*
1:      * Will parse a header value, strip out trailing attributes and return a list of declarations
1:      */
1:     public static List<String> extractHeaderDeclaration(String headerStatement) {
1:         List<String> result = new ArrayList<String>();
1:         
1:         for (String headerDeclaration : ManifestHeaderUtils.split(headerStatement, ",")) {
1:             String name = headerDeclaration.contains(";") ? headerDeclaration.substring(0, headerDeclaration
1:                     .indexOf(";")) : headerDeclaration;
1:             result.add(name);
1:         }
1:         
1:         return result;
1:     }
1:     
1:     
1: }
============================================================================