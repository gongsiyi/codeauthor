2:f13c6ac: /**
1:f13c6ac:  *
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:f13c6ac:  * contributor license agreements.  See the NOTICE file distributed with
1:f13c6ac:  * this work for additional information regarding copyright ownership.
1:f13c6ac:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:f13c6ac:  * (the "License"); you may not use this file except in compliance with
1:f13c6ac:  * the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *     http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  *  Unless required by applicable law or agreed to in writing, software
1:f13c6ac:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:f13c6ac:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f13c6ac:  *  See the License for the specific language governing permissions and
1:f13c6ac:  *  limitations under the License.
2:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:f13c6ac: import java.util.ArrayList;
1:f13c6ac: import java.util.Arrays;
1:f13c6ac: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:f13c6ac: import java.util.HashMap;
1:f13c6ac: import java.util.HashSet;
1:f13c6ac: import java.util.Iterator;
1:f13c6ac: import java.util.LinkedHashMap;
1:f13c6ac: import java.util.LinkedList;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Map;
1:f13c6ac: import java.util.Set;
1:f13c6ac: import java.util.concurrent.ConcurrentHashMap;
1:88a0e3f: import java.util.concurrent.ConcurrentMap;
1:f13c6ac: import java.util.concurrent.CopyOnWriteArrayList;
1:88a0e3f: import java.util.concurrent.ExecutionException;
1:88a0e3f: import java.util.concurrent.Future;
1:f13c6ac: 
1:27523b5: import org.apache.aries.blueprint.reflect.MetadataUtil;
1:09a7647: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:5e2bd49: import org.apache.aries.blueprint.container.BeanRecipe.UnwrapperedBeanHolder;
1:6414875: import org.apache.aries.blueprint.di.CircularDependencyException;
1:6414875: import org.apache.aries.blueprint.di.ExecutionContext;
1:6414875: import org.apache.aries.blueprint.di.IdRefRecipe;
1:6414875: import org.apache.aries.blueprint.di.Recipe;
1:6414875: import org.apache.aries.blueprint.di.RefRecipe;
1:6414875: import org.apache.aries.blueprint.di.Repository;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:f13c6ac: import org.osgi.service.blueprint.container.ReifiedType;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.container.NoSuchComponentException;
1:27523b5: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:27523b5: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * The default repository implementation
1:f13c6ac:  */
1:f13c6ac: public class BlueprintRepository implements Repository, ExecutionContext {
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * The blueprint container
1:f13c6ac:      */
1:f13c6ac:     private final ExtendedBlueprintContainer blueprintContainer;
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Contains object recipes
1:f13c6ac:      */
1:f13c6ac:     private final Map<String, Recipe> recipes = new ConcurrentHashMap<String, Recipe>();
1:f13c6ac: 
1:f13c6ac:     /**
1:88a0e3f:      * Contains object instances. Objects are stored as futures by the first task that wants to create it.
1:88a0e3f:      * All other listeners should call get on the future.
1:f13c6ac:      */
1:88a0e3f:     private final ConcurrentMap<String, Future<Object>> instances = new ConcurrentHashMap<String, Future<Object>>();
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Keep track of creation order
1:f13c6ac:      */
1:f13c6ac:     private final List<String> creationOrder = new CopyOnWriteArrayList<String>();
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Contains partial objects.
1:f13c6ac:      */
1:88a0e3f:     private final ThreadLocal<Map<String, Object>> partialObjects = new ThreadLocal<Map<String,Object>>();
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Before each recipe is executed it is pushed on the stack.  The
1:f13c6ac:      * stack is used to detect circular dependencies.
1:f13c6ac:      */
1:88a0e3f:     private final ThreadLocal<LinkedList<Recipe>> stack = new ThreadLocal<LinkedList<Recipe>>();
1:f13c6ac:     
1:f13c6ac:     public BlueprintRepository(ExtendedBlueprintContainer container) {
1:f13c6ac:         blueprintContainer = container;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Object getInstance(String name) {
1:88a0e3f:         Future<Object> future = instances.get(name);
1:88a0e3f:         if (future != null && future.isDone()) {
1:5e2bd49:             try {
1:88a0e3f:                 return future.get();
1:88a0e3f:             } catch (InterruptedException e) {
1:88a0e3f:                 Thread.currentThread().interrupt();
1:88a0e3f:                 return null;
1:88a0e3f:             } catch (ExecutionException e) {
1:88a0e3f:                 return null;
1:f13c6ac:             }
1:88a0e3f:         } else {
1:88a0e3f:             return null;
1:5e2bd49:         }
1:5e2bd49:     }
1:f13c6ac: 
1:f13c6ac:     public Recipe getRecipe(String name) {
1:f13c6ac:         return recipes.get(name);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Set<String> getNames() {
1:f13c6ac:         Set<String> names = new HashSet<String>();
1:f13c6ac:         names.addAll(recipes.keySet());
1:f13c6ac:         names.addAll(instances.keySet());
1:f13c6ac:         return names;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void putRecipe(String name, Recipe recipe) {
1:88a0e3f:         if (instances.containsKey(name)) {
1:88a0e3f:             throw new ComponentDefinitionException("Name " + name + " is already registered to instance " + getInstance(name));
1:f13c6ac:         }
1:f13c6ac:         recipes.put(name, recipe);
1:f13c6ac:     }
1:f13c6ac:     
1:9f9d944:     public void removeRecipe(String name) {
1:88a0e3f:         if (instances.containsKey(name))
1:88a0e3f:             throw new ComponentDefinitionException("Name " + name + " is already instanciated as " + getInstance(name) + " and cannot be removed.");
1:f13c6ac: 
1:9f9d944:         recipes.remove(name);
1:5e2bd49:     }
1:f13c6ac: 
1:f13c6ac:     private Object convert(String name, Object instance) throws ComponentDefinitionException {
1:f13c6ac:         try {
1:f13c6ac:             // Make sure to go through the conversion step in case we have a Convertible object
1:f13c6ac:             return convert(instance, new ReifiedType(Object.class));
1:f13c6ac:         } catch (Exception e) {
1:f13c6ac:             throw new ComponentDefinitionException("Unable to convert instance " + name, e);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:         
1:f13c6ac:     public Object create(String name) throws ComponentDefinitionException {
1:f13c6ac:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:f13c6ac:         try {
1:f13c6ac:             Object instance = createInstance(name);                       
1:f13c6ac:             return convert(name, instance);
1:f13c6ac:         } finally {
1:f13c6ac:             ExecutionContext.Holder.setContext(oldContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:5e2bd49:     public Object create(String name, Collection<Class<?>> proxyInterfaces) throws ComponentDefinitionException {
1:f13c6ac:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:f13c6ac:         try {
1:5e2bd49:             Object instance = createInstance(name); 
1:5e2bd49:             if(instance instanceof UnwrapperedBeanHolder)
1:5e2bd49:                 instance = BeanRecipe.wrap((UnwrapperedBeanHolder) instance, proxyInterfaces);
1:5e2bd49:             return convert(name, instance);
1:5e2bd49: 		} finally {
1:5e2bd49:             ExecutionContext.Holder.setContext(oldContext);
1:f13c6ac:         }
1:5e2bd49:     }
1:5e2bd49:     
1:5e2bd49:     public Map<String, Object> createAll(Collection<String> names, Collection<Class<?>> proxyInterfaces) throws ComponentDefinitionException {
1:5e2bd49:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:88a0e3f:         try {
1:f13c6ac:             Map<String, Object> instances = createInstances(names);
1:f13c6ac:             for (String name : instances.keySet()) {
1:f13c6ac:                 Object obj = instances.get(name);
1:5e2bd49:                 if(obj instanceof UnwrapperedBeanHolder)
1:5e2bd49:                 	obj = BeanRecipe.wrap((UnwrapperedBeanHolder) obj, proxyInterfaces);
1:f13c6ac:                 instances.put(name, convert(name, obj));
1:f13c6ac:             }
1:f13c6ac:             return instances;
1:f13c6ac:         } finally {
1:f13c6ac:             ExecutionContext.Holder.setContext(oldContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:5e2bd49:     public void createAll(Collection<String> names) throws ComponentDefinitionException {
1:5e2bd49:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:5e2bd49:         try {
1:5e2bd49:             createInstances(names);
1:5e2bd49:             return;
1:5e2bd49:         } finally {
1:5e2bd49:             ExecutionContext.Holder.setContext(oldContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:5e2bd49: 
1:f13c6ac:     public <T> List<T> getAllRecipes(Class<T> clazz, String... names) {
1:f13c6ac:         List<T> recipes = new ArrayList<T>();
1:f13c6ac:         for (Recipe r : getAllRecipes(names)) {
1:f13c6ac:             if (clazz.isInstance(r)) {
1:f13c6ac:                 recipes.add(clazz.cast(r));
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return recipes;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Set<Recipe> getAllRecipes(String... names) {
1:f13c6ac:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:f13c6ac:         try {
1:f13c6ac:             Set<Recipe> allRecipes = new HashSet<Recipe>();
1:f13c6ac:             Collection<String> topLevel = names != null && names.length > 0 ? Arrays.asList(names) : recipes.keySet();
1:f13c6ac:             for (String name : topLevel) {
1:f13c6ac:                 internalGetAllRecipes(allRecipes, getRecipe(name));
1:f13c6ac:             }
1:f13c6ac:             return allRecipes;
1:f13c6ac:         } finally {
1:f13c6ac:             ExecutionContext.Holder.setContext(oldContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     /*
1:f13c6ac:      * This method should not be called directly, only from one of the getAllRecipes() methods.
1:f13c6ac:      */
1:f13c6ac:     private void internalGetAllRecipes(Set<Recipe> allRecipes, Recipe r) {
1:f13c6ac:         if (r != null) {
1:f13c6ac:             if (allRecipes.add(r)) {
1:f13c6ac:                 for (Recipe c : r.getDependencies()) {
1:f13c6ac:                     internalGetAllRecipes(allRecipes, c);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object createInstance(String name) {
1:f13c6ac:         Object instance = getInstance(name);
1:f13c6ac:         if (instance == null) {
1:f13c6ac:             Map <String, Object> instances = createInstances(Arrays.asList(name));
1:f13c6ac:             instance = instances.get(name); 
1:f13c6ac:             if (instance == null) {
1:f13c6ac:                 throw new NoSuchComponentException(name);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return instance;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Map<String, Object> createInstances(Collection<String> names) {
1:88a0e3f:         // Instance creation is synchronized inside each create method (via the use of futures), so that 
1:88a0e3f:         // a recipe will only created once where appropriate
1:f13c6ac:         DependencyGraph graph = new DependencyGraph(this);
1:f13c6ac:         HashMap<String, Object> objects = new LinkedHashMap<String, Object>();
1:f13c6ac:         for (Map.Entry<String, Recipe> entry : graph.getSortedRecipes(names).entrySet()) {
1:27523b5:             String name = entry.getKey();
1:27523b5:             ComponentMetadata component = blueprintContainer.getComponentDefinitionRegistry().getComponentDefinition(name);
1:27523b5:             boolean prototype = (component instanceof BeanMetadata)
1:27523b5:                     && MetadataUtil.isPrototypeScope((BeanMetadata) component);
1:27523b5:             if (!prototype || names.contains(name)) {
1:27523b5:                 objects.put(
1:27523b5:                         name,
1:27523b5:                         entry.getValue().create());
1:27523b5:             }
1:f13c6ac:         }
1:f13c6ac:         return objects;
1:f13c6ac:     }
1:f13c6ac:         
1:f13c6ac:     public void validate() {
1:f13c6ac:         for (Recipe recipe : getAllRecipes()) {
1:f13c6ac:             // Check that references are satisfied
1:f13c6ac:             String ref = null;
1:f13c6ac:             if (recipe instanceof RefRecipe) {
1:f13c6ac:                 ref = ((RefRecipe) recipe).getIdRef();
1:f13c6ac:             } else if (recipe instanceof IdRefRecipe) {
1:f13c6ac:                 ref = ((IdRefRecipe) recipe).getIdRef();
1:f13c6ac:             }
1:f13c6ac:             if (ref != null && getRecipe(ref) == null) {
1:f13c6ac:                 throw new ComponentDefinitionException("Unresolved ref/idref to component: " + ref);
1:f13c6ac:             }
1:f13c6ac:             // Check service
1:f13c6ac:             if (recipe instanceof ServiceRecipe) {
1:f13c6ac:                 Recipe r = ((ServiceRecipe) recipe).getServiceRecipe();
1:f13c6ac:                 if (r instanceof RefRecipe) {
1:f13c6ac:                     r = getRecipe(((RefRecipe) r).getIdRef());
1:f13c6ac:                 }
1:f13c6ac:                 if (r instanceof ServiceRecipe) {
1:f13c6ac:                     throw new ComponentDefinitionException("The target for a <service> element must not be <service> element");
1:f13c6ac:                 }
1:f13c6ac:                 if (r instanceof ReferenceListRecipe) {
1:f13c6ac:                     throw new ComponentDefinitionException("The target for a <service> element must not be <reference-list> element");
1:f13c6ac:                 }
1:f13c6ac:                 CollectionRecipe listeners = ((ServiceRecipe) recipe).getListenersRecipe();
1:f13c6ac:                 for (Recipe lr : listeners.getDependencies()) {
1:f13c6ac:                     // The listener recipe is a bean recipe with the listener being set in a property
1:f13c6ac:                     for (Recipe l : lr.getDependencies()) {
1:f13c6ac:                         if (l instanceof RefRecipe) {
1:f13c6ac:                             l = getRecipe(((RefRecipe) l).getIdRef());
1:f13c6ac:                         }
1:f13c6ac:                         if (l instanceof ServiceRecipe) {
1:f13c6ac:                             throw new ComponentDefinitionException("The target for a <registration-listener> element must not be <service> element");
1:f13c6ac:                         }
1:f13c6ac:                         if (l instanceof ReferenceListRecipe) {
1:f13c6ac:                             throw new ComponentDefinitionException("The target for a <registration-listener> element must not be <reference-list> element");
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             // Check references
1:f13c6ac:             if (recipe instanceof AbstractServiceReferenceRecipe) {
1:f13c6ac:                 CollectionRecipe listeners = ((AbstractServiceReferenceRecipe) recipe).getListenersRecipe();
1:f13c6ac:                 for (Recipe lr : listeners.getDependencies()) {
1:f13c6ac:                     // The listener recipe is a bean recipe with the listener being set in a property
1:f13c6ac:                     for (Recipe l : lr.getDependencies()) {
1:f13c6ac:                         if (l instanceof RefRecipe) {
1:f13c6ac:                             l = getRecipe(((RefRecipe) l).getIdRef());
1:f13c6ac:                         }
1:f13c6ac:                         if (l instanceof ServiceRecipe) {
1:f13c6ac:                             throw new ComponentDefinitionException("The target for a <reference-listener> element must not be <service> element");
1:f13c6ac:                         }
1:f13c6ac:                         if (l instanceof ReferenceListRecipe) {
1:f13c6ac:                             throw new ComponentDefinitionException("The target for a <reference-listener> element must not be <reference-list> element");
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void destroy() {
1:f13c6ac:         // destroy objects in reverse creation order
1:f13c6ac:         List<String> order = new ArrayList<String>(creationOrder);
1:f13c6ac:         Collections.reverse(order);
1:f13c6ac:         for (String name : order) {
1:f13c6ac:             Recipe recipe = recipes.get(name);
1:f13c6ac:             if (recipe != null) {
1:88a0e3f:                 recipe.destroy(getInstance(name));
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         instances.clear();
1:f13c6ac:         creationOrder.clear();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void push(Recipe recipe) {
1:b4fc651:         LinkedList<Recipe> list = stack.get();
1:b4fc651:         if (list != null && list.contains(recipe)) {
1:b4fc651:             ArrayList<Recipe> circularity = new ArrayList<Recipe>(list.subList(list.indexOf(recipe), list.size()));
1:f13c6ac: 
1:f13c6ac:             // remove anonymous nodes from circularity list
1:f13c6ac:             for (Iterator<Recipe> iterator = circularity.iterator(); iterator.hasNext();) {
1:f13c6ac:                 Recipe item = iterator.next();
1:f13c6ac:                 if (item != recipe && item.getName() == null) {
1:f13c6ac:                     iterator.remove();
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac: 
1:f13c6ac:             // add ending node to list so a full circuit is shown
1:f13c6ac:             circularity.add(recipe);
1:f13c6ac: 
1:f13c6ac:             throw new CircularDependencyException(circularity);
1:f13c6ac:         }
1:b4fc651:         if (list == null) {
1:b4fc651:             list = new LinkedList<Recipe>();
1:b4fc651:             stack.set(list);
1:f13c6ac:         }
1:b4fc651:         list.add(recipe);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Recipe pop() {
1:b4fc651:         LinkedList<Recipe> list = stack.get();
1:b4fc651:         return list.removeLast();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public boolean containsObject(String name) {
1:88a0e3f:         return instances.containsKey(name) || getRecipe(name) != null;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Object getObject(String name) {
1:88a0e3f:         Future<Object> future = instances.get(name);
1:88a0e3f:         Object result = null;
1:88a0e3f:         if (future != null && future.isDone()) {
1:88a0e3f:             try {
1:88a0e3f:                 result = future.get();
1:88a0e3f:             } catch (InterruptedException e) {
1:88a0e3f:                 Thread.currentThread().interrupt();
1:88a0e3f:                 result = getRecipe(name);
1:88a0e3f:             } catch (ExecutionException e) {
1:88a0e3f:                 result = getRecipe(name);
1:f13c6ac:             }
1:88a0e3f:         } else {
1:88a0e3f:             result = getRecipe(name);
1:f13c6ac:         }
1:f13c6ac:         
1:88a0e3f:         return result;
1:f13c6ac:     }
1:f13c6ac: 
1:88a0e3f:     public Future<Object> addFullObject(String name, Future<Object> object) {
1:88a0e3f:         return instances.putIfAbsent(name, object);
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void addPartialObject(String name, Object object) {
1:88a0e3f:         if (partialObjects.get() == null)
1:88a0e3f:             partialObjects.set(new HashMap<String, Object>());
1:f13c6ac: 
1:88a0e3f:         partialObjects.get().put(name, object);
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Object getPartialObject(String name) {
1:88a0e3f:         return (partialObjects.get() != null) ? partialObjects.get().get(name) : null;
1:f13c6ac:     }
1:f13c6ac:     
1:88a0e3f:     public void removePartialObject(String name) {
1:f13c6ac:         creationOrder.add(name); 
1:88a0e3f:         if (partialObjects.get() != null) 
1:88a0e3f:             partialObjects.get().remove(name);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Object convert(Object value, ReifiedType type) throws Exception {
1:f13c6ac:         return blueprintContainer.getConverter().convert(value, type);
1:f13c6ac:     }
1:f13c6ac:     
1:cab8bfe:     public boolean canConvert(Object value, ReifiedType type) {
1:cab8bfe:         return blueprintContainer.getConverter().canConvert(value, type);
1:f13c6ac:     }
3:88a0e3f: 
1:f13c6ac:     public Class loadClass(String typeName) throws ClassNotFoundException {
1:f13c6ac:         return blueprintContainer.loadClass(typeName);
1:f13c6ac:     }
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:27523b5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.reflect.MetadataUtil;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
/////////////////////////////////////////////////////////////////////////
1:             String name = entry.getKey();
1:             ComponentMetadata component = blueprintContainer.getComponentDefinitionRegistry().getComponentDefinition(name);
1:             boolean prototype = (component instanceof BeanMetadata)
1:                     && MetadataUtil.isPrototypeScope((BeanMetadata) component);
1:             if (!prototype || names.contains(name)) {
1:                 objects.put(
1:                         name,
1:                         entry.getValue().create());
1:             }
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: 
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.di.CircularDependencyException;
0: import org.apache.geronimo.blueprint.di.ExecutionContext;
0: import org.apache.geronimo.blueprint.di.IdRefRecipe;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.RefRecipe;
0: import org.apache.geronimo.blueprint.di.Repository;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
1: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.container.NoSuchComponentException;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * The default repository implementation
1:  */
1: public class BlueprintRepository implements Repository, ExecutionContext {
1: 
0:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintRepository.class);
1: 
1:     /**
1:      * The blueprint container
1:      */
1:     private final ExtendedBlueprintContainer blueprintContainer;
1: 
1:     /**
1:      * Contains object recipes
1:      */
1:     private final Map<String, Recipe> recipes = new ConcurrentHashMap<String, Recipe>();
1: 
1:     /**
0:      * Contains object instances
1:      */
0:     private final Map<String, Object> instances = new ConcurrentHashMap<String, Object>();
1: 
1:     /**
1:      * Keep track of creation order
1:      */
1:     private final List<String> creationOrder = new CopyOnWriteArrayList<String>();
1: 
1:     /**
0:      * Lock for object instance creation
1:      */
0:     private final Object instanceLock = new Object();
1: 
1:     /**
1:      * Contains partial objects.
1:      */
0:     private final Map<String, Object> partialObjects = new ConcurrentHashMap<String, Object>();
1: 
1:     /**
1:      * Before each recipe is executed it is pushed on the stack.  The
1:      * stack is used to detect circular dependencies.
1:      */
0:     private final LinkedList<Recipe> stack = new LinkedList<Recipe>();
1:     
1:     public BlueprintRepository(ExtendedBlueprintContainer container) {
1:         blueprintContainer = container;
1:     }
1:     
1:     public Object getInstance(String name) {
0:         return instances.get(name);
1:     }
1: 
1:     public Recipe getRecipe(String name) {
1:         return recipes.get(name);
1:     }
1: 
1:     public Set<String> getNames() {
1:         Set<String> names = new HashSet<String>();
1:         names.addAll(recipes.keySet());
1:         names.addAll(instances.keySet());
1:         return names;
1:     }
1: 
1:     public void putRecipe(String name, Recipe recipe) {
0:         if (instances.get(name) != null) {
0:             throw new ComponentDefinitionException("Name " + name + " is already registered to instance " + instances.get(name));
1:         }
1:         recipes.put(name, recipe);
1:     }
1: 
1:     private Object convert(String name, Object instance) throws ComponentDefinitionException {
1:         try {
1:             // Make sure to go through the conversion step in case we have a Convertible object
1:             return convert(instance, new ReifiedType(Object.class));
1:         } catch (Exception e) {
1:             throw new ComponentDefinitionException("Unable to convert instance " + name, e);
1:         }
1:     }
1:         
1:     public Object create(String name) throws ComponentDefinitionException {
1:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:         try {
1:             Object instance = createInstance(name);                       
1:             return convert(name, instance);
1:         } finally {
1:             ExecutionContext.Holder.setContext(oldContext);
1:         }
1:     }
1:     
0:     public Map<String, Object> createAll(Collection<String> names) throws ComponentDefinitionException {
1:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:         try {
1:             Map<String, Object> instances = createInstances(names);
1:             for (String name : instances.keySet()) {
1:                 Object obj = instances.get(name);
1:                 instances.put(name, convert(name, obj));
1:             }
1:             return instances;
1:         } finally {
1:             ExecutionContext.Holder.setContext(oldContext);
1:         }
1:     }
1: 
1:     public <T> List<T> getAllRecipes(Class<T> clazz, String... names) {
1:         List<T> recipes = new ArrayList<T>();
1:         for (Recipe r : getAllRecipes(names)) {
1:             if (clazz.isInstance(r)) {
1:                 recipes.add(clazz.cast(r));
1:             }
1:         }
1:         return recipes;
1:     }
1: 
1:     public Set<Recipe> getAllRecipes(String... names) {
1:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:         try {
1:             Set<Recipe> allRecipes = new HashSet<Recipe>();
1:             Collection<String> topLevel = names != null && names.length > 0 ? Arrays.asList(names) : recipes.keySet();
1:             for (String name : topLevel) {
1:                 internalGetAllRecipes(allRecipes, getRecipe(name));
1:             }
1:             return allRecipes;
1:         } finally {
1:             ExecutionContext.Holder.setContext(oldContext);
1:         }
1:     }
1: 
1:     /*
1:      * This method should not be called directly, only from one of the getAllRecipes() methods.
1:      */
1:     private void internalGetAllRecipes(Set<Recipe> allRecipes, Recipe r) {
1:         if (r != null) {
1:             if (allRecipes.add(r)) {
1:                 for (Recipe c : r.getDependencies()) {
1:                     internalGetAllRecipes(allRecipes, c);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private Object createInstance(String name) {
1:         Object instance = getInstance(name);
1:         if (instance == null) {
1:             Map <String, Object> instances = createInstances(Arrays.asList(name));
1:             instance = instances.get(name); 
1:             if (instance == null) {
1:                 throw new NoSuchComponentException(name);
1:             }
1:         }
1:         return instance;
1:     }
1: 
1:     private Map<String, Object> createInstances(Collection<String> names) {
0:         // We need to synchronize recipe creation on the repository
0:         // so that we don't end up with multiple threads creating the
0:         // same instance at the same time.
0:         synchronized (instanceLock) {
1:             DependencyGraph graph = new DependencyGraph(this);
1:             HashMap<String, Object> objects = new LinkedHashMap<String, Object>();
1:             for (Map.Entry<String, Recipe> entry : graph.getSortedRecipes(names).entrySet()) {
0:                 String name = entry.getKey();
0:                 Object object = instances.get(name);
0:                 if (object == null) {
0:                     Recipe recipe = entry.getValue();
0:                     object = recipe.create();
1:                 }
0:                 objects.put(name, object);
1:             }
1:             return objects;
1:         }
1:     }
1:         
1:     public void validate() {
1:         for (Recipe recipe : getAllRecipes()) {
1:             // Check that references are satisfied
1:             String ref = null;
1:             if (recipe instanceof RefRecipe) {
1:                 ref = ((RefRecipe) recipe).getIdRef();
1:             } else if (recipe instanceof IdRefRecipe) {
1:                 ref = ((IdRefRecipe) recipe).getIdRef();
1:             }
1:             if (ref != null && getRecipe(ref) == null) {
1:                 throw new ComponentDefinitionException("Unresolved ref/idref to component: " + ref);
1:             }
1:             // Check service
1:             if (recipe instanceof ServiceRecipe) {
1:                 Recipe r = ((ServiceRecipe) recipe).getServiceRecipe();
1:                 if (r instanceof RefRecipe) {
1:                     r = getRecipe(((RefRecipe) r).getIdRef());
1:                 }
1:                 if (r instanceof ServiceRecipe) {
1:                     throw new ComponentDefinitionException("The target for a <service> element must not be <service> element");
1:                 }
1:                 if (r instanceof ReferenceListRecipe) {
1:                     throw new ComponentDefinitionException("The target for a <service> element must not be <reference-list> element");
1:                 }
1:                 CollectionRecipe listeners = ((ServiceRecipe) recipe).getListenersRecipe();
1:                 for (Recipe lr : listeners.getDependencies()) {
1:                     // The listener recipe is a bean recipe with the listener being set in a property
1:                     for (Recipe l : lr.getDependencies()) {
1:                         if (l instanceof RefRecipe) {
1:                             l = getRecipe(((RefRecipe) l).getIdRef());
1:                         }
1:                         if (l instanceof ServiceRecipe) {
1:                             throw new ComponentDefinitionException("The target for a <registration-listener> element must not be <service> element");
1:                         }
1:                         if (l instanceof ReferenceListRecipe) {
1:                             throw new ComponentDefinitionException("The target for a <registration-listener> element must not be <reference-list> element");
1:                         }
1:                     }
1:                 }
1:             }
1:             // Check references
1:             if (recipe instanceof AbstractServiceReferenceRecipe) {
1:                 CollectionRecipe listeners = ((AbstractServiceReferenceRecipe) recipe).getListenersRecipe();
1:                 for (Recipe lr : listeners.getDependencies()) {
1:                     // The listener recipe is a bean recipe with the listener being set in a property
1:                     for (Recipe l : lr.getDependencies()) {
1:                         if (l instanceof RefRecipe) {
1:                             l = getRecipe(((RefRecipe) l).getIdRef());
1:                         }
1:                         if (l instanceof ServiceRecipe) {
1:                             throw new ComponentDefinitionException("The target for a <reference-listener> element must not be <service> element");
1:                         }
1:                         if (l instanceof ReferenceListRecipe) {
1:                             throw new ComponentDefinitionException("The target for a <reference-listener> element must not be <reference-list> element");
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public void destroy() {
1:         // destroy objects in reverse creation order
1:         List<String> order = new ArrayList<String>(creationOrder);
1:         Collections.reverse(order);
1:         for (String name : order) {
1:             Recipe recipe = recipes.get(name);
1:             if (recipe != null) {
0:                 recipe.destroy(instances.get(name));
1:             }
1:         }
1:         instances.clear();
1:         creationOrder.clear();
1:     }
1: 
0:     public Object getInstanceLock() {
0:         return instanceLock;
1:     }
1: 
1:     public void push(Recipe recipe) {
0:         if (stack.contains(recipe)) {
0:             ArrayList<Recipe> circularity = new ArrayList<Recipe>(stack.subList(stack.indexOf(recipe), stack.size()));
1: 
1:             // remove anonymous nodes from circularity list
1:             for (Iterator<Recipe> iterator = circularity.iterator(); iterator.hasNext();) {
1:                 Recipe item = iterator.next();
1:                 if (item != recipe && item.getName() == null) {
1:                     iterator.remove();
1:                 }
1:             }
1: 
1:             // add ending node to list so a full circuit is shown
1:             circularity.add(recipe);
1: 
1:             throw new CircularDependencyException(circularity);
1:         }
0:         stack.add(recipe);
1:     }
1: 
1:     public Recipe pop() {
0:         return stack.removeLast();
1:     }
1: 
0:     public LinkedList<Recipe> getStack() {
0:         return new LinkedList<Recipe>(stack);
1:     }
1: 
1:     public boolean containsObject(String name) {
0:         return getInstance(name) != null
0:                 || getRecipe(name) != null;
1:     }
1: 
1:     public Object getObject(String name) {
0:         Object object = getInstance(name);
0:         if (object == null) {
0:             object = getRecipe(name);
1:         }
0:         return object;
1:     }
1: 
0:     public void addFullObject(String name, Object object) {
0:         if (instances.get(name) != null) {
0:             throw new ComponentDefinitionException("Name " + name + " is already registered to instance " + instances.get(name));
1:         }
0:         instances.put(name, object);
1:         creationOrder.add(name); 
0:         partialObjects.remove(name);
1:     }
1:     
1:     public void addPartialObject(String name, Object object) {
0:         partialObjects.put(name, object);
1:     }
1:     
0:     public Object removePartialObject(String name) {
0:         return partialObjects.remove(name);
1:     }
1:     
1:     public Object getPartialObject(String name) {
0:         Object obj = partialObjects.get(name);
0:         if (obj == null) {
0:             obj = getInstance(name);
1:         }
0:         return obj;
1:     }
1: 
1:     public Object convert(Object value, ReifiedType type) throws Exception {
1:         return blueprintContainer.getConverter().convert(value, type);
1:     }
1: 
1:     public Class loadClass(String typeName) throws ClassNotFoundException {
1:         return blueprintContainer.loadClass(typeName);
1:     }
1: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5e2bd49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.container.BeanRecipe.UnwrapperedBeanHolder;
/////////////////////////////////////////////////////////////////////////
1:     public Object create(String name, Collection<Class<?>> proxyInterfaces) throws ComponentDefinitionException {
1:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:         try {
1:             Object instance = createInstance(name); 
1:             if(instance instanceof UnwrapperedBeanHolder)
1:                 instance = BeanRecipe.wrap((UnwrapperedBeanHolder) instance, proxyInterfaces);
1:             return convert(name, instance);
1: 		} finally {
1:             ExecutionContext.Holder.setContext(oldContext);
1:         }
1:     }
1:     
1:     public Map<String, Object> createAll(Collection<String> names, Collection<Class<?>> proxyInterfaces) throws ComponentDefinitionException {
1:                 if(obj instanceof UnwrapperedBeanHolder)
1:                 	obj = BeanRecipe.wrap((UnwrapperedBeanHolder) obj, proxyInterfaces);
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void createAll(Collection<String> names) throws ComponentDefinitionException {
1:         ExecutionContext oldContext = ExecutionContext.Holder.setContext(this);
1:         try {
1:             createInstances(names);
1:             return;
1:         } finally {
1:             ExecutionContext.Holder.setContext(oldContext);
1:         }
1:     }
commit:b4fc651
/////////////////////////////////////////////////////////////////////////
1:         LinkedList<Recipe> list = stack.get();
1:         if (list != null && list.contains(recipe)) {
1:             ArrayList<Recipe> circularity = new ArrayList<Recipe>(list.subList(list.indexOf(recipe), list.size()));
/////////////////////////////////////////////////////////////////////////
1:         if (list == null) {
1:             list = new LinkedList<Recipe>();
1:             stack.set(list);
1:         list.add(recipe);
1:         LinkedList<Recipe> list = stack.get();
1:         return list.removeLast();
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:88a0e3f
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.Future;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Contains object instances. Objects are stored as futures by the first task that wants to create it.
1:      * All other listeners should call get on the future.
1:     private final ConcurrentMap<String, Future<Object>> instances = new ConcurrentHashMap<String, Future<Object>>();
/////////////////////////////////////////////////////////////////////////
1:     private final ThreadLocal<Map<String, Object>> partialObjects = new ThreadLocal<Map<String,Object>>();
1:     private final ThreadLocal<LinkedList<Recipe>> stack = new ThreadLocal<LinkedList<Recipe>>();
1:         Future<Object> future = instances.get(name);
1:         if (future != null && future.isDone()) {
1:             try {
1:                 return future.get();
1:             } catch (InterruptedException e) {
1:                 Thread.currentThread().interrupt();
1:                 return null;
1:             } catch (ExecutionException e) {
1:                 return null;
0:             }
1:         } else {
1:             return null;
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (instances.containsKey(name)) {
1:             throw new ComponentDefinitionException("Name " + name + " is already registered to instance " + getInstance(name));
1:         if (instances.containsKey(name))
1:             throw new ComponentDefinitionException("Name " + name + " is already instanciated as " + getInstance(name) + " and cannot be removed.");
/////////////////////////////////////////////////////////////////////////
1:         // Instance creation is synchronized inside each create method (via the use of futures), so that 
1:         // a recipe will only created once where appropriate
0:         DependencyGraph graph = new DependencyGraph(this);
0:         HashMap<String, Object> objects = new LinkedHashMap<String, Object>();
0:         for (Map.Entry<String, Recipe> entry : graph.getSortedRecipes(names).entrySet()) {
0:             objects.put(
0:                     entry.getKey(), 
0:                     entry.getValue().create());
0:         return objects;
/////////////////////////////////////////////////////////////////////////
1:                 recipe.destroy(getInstance(name));
0:         if (stack.get() != null && stack.get().contains(recipe)) {
0:             ArrayList<Recipe> circularity = new ArrayList<Recipe>(stack.get().subList(stack.get().indexOf(recipe), stack.get().size()));
/////////////////////////////////////////////////////////////////////////
0:         if (stack.get() == null) {
0:             stack.set(new LinkedList<Recipe>());
0:         }
0:         stack.get().add(recipe);
0:         return stack.get().removeLast();
1:         return instances.containsKey(name) || getRecipe(name) != null;
1:         Future<Object> future = instances.get(name);
1:         Object result = null;
1:         if (future != null && future.isDone()) {
1:             try {
1:                 result = future.get();
1:             } catch (InterruptedException e) {
1:                 Thread.currentThread().interrupt();
1:                 result = getRecipe(name);
1:             } catch (ExecutionException e) {
1:                 result = getRecipe(name);
0:             }
1:         } else {
1:             result = getRecipe(name);
1:         
1:         return result;
1:     public Future<Object> addFullObject(String name, Future<Object> object) {
1:         return instances.putIfAbsent(name, object);
1:         if (partialObjects.get() == null)
1:             partialObjects.set(new HashMap<String, Object>());
1: 
1:         partialObjects.get().put(name, object);
1:         return (partialObjects.get() != null) ? partialObjects.get().get(name) : null;
0:     }
1:     
1:     public void removePartialObject(String name) {
0:         creationOrder.add(name); 
1:         if (partialObjects.get() != null) 
1:             partialObjects.get().remove(name);
commit:cab8bfe
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean canConvert(Object value, ReifiedType type) {
1:         return blueprintContainer.getConverter().canConvert(value, type);
0:     }
commit:9f9d944
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void removeRecipe(String name) {
0:         if (instances.get(name) != null)
0:             throw new ComponentDefinitionException("Name " + name + " is already instanciated as " + instances.get(name) + " and cannot be removed.");
0: 
1:         recipes.remove(name);
0:     }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.di.CircularDependencyException;
1: import org.apache.aries.blueprint.di.ExecutionContext;
1: import org.apache.aries.blueprint.di.IdRefRecipe;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.RefRecipe;
1: import org.apache.aries.blueprint.di.Repository;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
============================================================================