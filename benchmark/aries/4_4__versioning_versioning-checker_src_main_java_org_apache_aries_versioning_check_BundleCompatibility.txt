1:e305ed5: /*
1:e305ed5:  * Licensed to the Apache Software Foundation (ASF) under one
1:e305ed5:  * or more contributor license agreements.  See the NOTICE file
1:e305ed5:  * distributed with this work for additional information
1:e305ed5:  * regarding copyright ownership.  The ASF licenses this file
1:e305ed5:  * to you under the Apache License, Version 2.0 (the
1:e305ed5:  * "License"); you may not use this file except in compliance
1:e305ed5:  * with the License.  You may obtain a copy of the License at
4:e305ed5:  *
1:e305ed5:  *  http://www.apache.org/licenses/LICENSE-2.0
1:e305ed5:  *
1:e305ed5:  * Unless required by applicable law or agreed to in writing,
1:e305ed5:  * software distributed under the License is distributed on an
1:e305ed5:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e305ed5:  * KIND, either express or implied.  See the License for the
1:e305ed5:  * specific language governing permissions and limitations
1:e305ed5:  * under the License.
5:e305ed5:  */
55:e305ed5: 
1:e305ed5: 
1:e305ed5: package org.apache.aries.versioning.check;
1:e305ed5: 
1:c573eea: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.oneLineBreak;
1:c573eea: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.twoLineBreaks;
1:c573eea: 
1:e305ed5: import java.io.BufferedReader;
1:e305ed5: import java.io.File;
1:e305ed5: import java.io.IOException;
1:e305ed5: import java.io.InputStream;
1:e305ed5: import java.io.InputStreamReader;
1:e305ed5: import java.net.URLClassLoader;
1:c3177de: import java.util.ArrayList;
1:e305ed5: import java.util.Collection;
1:e305ed5: import java.util.HashMap;
1:e305ed5: import java.util.Iterator;
1:e305ed5: import java.util.List;
1:e305ed5: import java.util.Map;
1:e305ed5: 
1:e305ed5: import org.apache.aries.util.filesystem.FileSystem;
1:e305ed5: import org.apache.aries.util.filesystem.IDirectory;
1:e305ed5: import org.apache.aries.util.filesystem.IFile;
1:e305ed5: import org.apache.aries.util.io.IOUtils;
1:e305ed5: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1:e305ed5: import org.apache.aries.versioning.utils.BinaryCompatibilityStatus;
1:e305ed5: import org.apache.aries.versioning.utils.ClassDeclaration;
1:e305ed5: import org.apache.aries.versioning.utils.FieldDeclaration;
1:e305ed5: import org.apache.aries.versioning.utils.MethodDeclaration;
1:e305ed5: import org.apache.aries.versioning.utils.SemanticVersioningClassVisitor;
1:e305ed5: import org.apache.aries.versioning.utils.SemanticVersioningUtils;
1:84181ac: import org.apache.aries.versioning.utils.SerialVersionClassVisitor;
1:e305ed5: import org.objectweb.asm.ClassReader;
1:e305ed5: import org.osgi.framework.Constants;
1:e305ed5: import org.osgi.framework.Version;
1:e305ed5: import org.slf4j.Logger;
1:e305ed5: import org.slf4j.LoggerFactory;
1:e305ed5: 
4:e305ed5: /**
1:cb248d1:  * @version $Rev:$ $Date:$
1:cb248d1:  */
1:e305ed5: public class BundleCompatibility {
1:cb248d1:   private static final Logger _logger = LoggerFactory.getLogger(BundleCompatibility.class);
1:e305ed5: 
1:e305ed5: 
1:cb248d1:   private URLClassLoader oldJarsLoader;
1:cb248d1:   private URLClassLoader newJarsLoader;
1:cb248d1:   private String bundleSymbolicName;
1:cb248d1:   private String bundleElement;
1:cb248d1:   private boolean bundleVersionCorrect;
1:cb248d1:   private BundleInfo currentBundle;
1:cb248d1:   private BundleInfo baseBundle;
1:cb248d1:   private StringBuilder pkgElements = new StringBuilder();
1:c3177de:   private List<String> pkgElementsList = new ArrayList<String>();
1:c3177de:   private List<String> excludes;
1:e305ed5: 
1:cb248d1:   private VersionChange bundleChange;
1:cb248d1:   private final Map<String, VersionChange> packageChanges = new HashMap<String, VersionChange>();
1:1ad65cc: 
1:cb248d1:   public BundleCompatibility(String bundleSymbolicName, BundleInfo currentBundle, BundleInfo baseBundle, URLClassLoader oldJarsLoader, URLClassLoader newJarsLoader) {
1:c3177de:     this(bundleSymbolicName,
1:c3177de:          currentBundle,
1:c3177de:          baseBundle,
1:c3177de:          oldJarsLoader,
1:c3177de:          newJarsLoader,
1:c3177de:          null);
1:c3177de:   }
1:c3177de:   
1:c3177de:   public BundleCompatibility(String bundleSymbolicName, BundleInfo currentBundle, BundleInfo baseBundle, URLClassLoader oldJarsLoader, URLClassLoader newJarsLoader, List<String> excludes) {
1:cb248d1:     this.bundleSymbolicName = bundleSymbolicName;
1:cb248d1:     this.currentBundle = currentBundle;
1:cb248d1:     this.baseBundle = baseBundle;
1:cb248d1:     this.oldJarsLoader = oldJarsLoader;
1:cb248d1:     this.newJarsLoader = newJarsLoader;
1:c3177de:     this.excludes = excludes != null ? excludes : new ArrayList<String>();
1:cb248d1:   }
1:c573eea: 
1:cb248d1:   public VersionChange getBundleChange() {
1:cb248d1:     return bundleChange;
1:cb248d1:   }
1:1ad65cc: 
1:cb248d1:   public Map<String, VersionChange> getPackageChanges() {
1:cb248d1:     return packageChanges;
1:cb248d1:   }
1:1ad65cc: 
1:cb248d1:   public String getBundleElement() {
1:cb248d1:     return bundleElement;
1:cb248d1:   }
1:cee3393: 
1:cb248d1:   public StringBuilder getPkgElements() {
1:cb248d1:     return pkgElements;
1:cb248d1:   }
1:c3177de:   
1:c3177de:   private boolean ignoreChange(String reason) {
1:c3177de:     if ((reason == null) || (this.excludes.isEmpty())) return false;
1:c3177de:     
1:c3177de:     for (String exclude : this.excludes) {
1:c3177de:       // Could have interpreted each exclude as a regex, but that makes it easy to write loose rules
1:c3177de:       // that match more strings than intended.
1:c3177de:       if ((reason != null) && reason.contains(exclude)) return true; 
1:c3177de:     }
1:c3177de:     
1:c3177de:     return false;
1:c3177de:   }
1:c3177de:   
1:cb248d1:   public boolean isBundleVersionCorrect() {
1:cb248d1:     return bundleVersionCorrect;
1:cb248d1:   }
1:e305ed5: 
1:cb248d1:   public BundleCompatibility invoke() throws IOException {
1:cb248d1:     String reason = null;
1:cb248d1:     // open the manifest and scan the export package and find the package name and exported version
1:cb248d1:     // The tool assume the one particular package just exports under one version
1:cb248d1:     Map<String, PackageContent> currBundleExpPkgContents = getAllExportedPkgContents(currentBundle);
1:cb248d1:     Map<String, PackageContent> baseBundleExpPkgContents;
1:cb248d1:     boolean pkg_major_change = false;
1:cb248d1:     boolean pkg_minor_change = false;
1:cb248d1:     String fatal_package = null;
1:cb248d1:     if (!!!currBundleExpPkgContents.isEmpty()) {
1:cb248d1:       baseBundleExpPkgContents = getAllExportedPkgContents(baseBundle);
1:cb248d1:       // compare each class right now
1:cb248d1:       for (Map.Entry<String, PackageContent> pkg : baseBundleExpPkgContents.entrySet()) {
1:cb248d1:         String pkgName = pkg.getKey();
1:cb248d1:         Map<String, IFile> baseClazz = pkg.getValue().getClasses();
1:cb248d1:         Map<String, IFile> baseXsds = pkg.getValue().getXsds();
1:cb248d1:         PackageContent currPkgContents = currBundleExpPkgContents.get(pkgName);
1:cb248d1:         if (currPkgContents == null) {
1:cb248d1:           // The package is no longer exported any more. This should lead to bundle major version change.
1:cb248d1:           pkg_major_change = true;
1:cb248d1:           fatal_package = pkgName;
1:cb248d1:           _logger.debug("The package " + pkgName + " in the bundle of " + bundleSymbolicName + " is no longer to be exported. Major change.");
1:c573eea:         } else {
1:cb248d1:           Map<String, IFile> curClazz = currPkgContents.getClasses();
1:cb248d1:           Map<String, IFile> curXsds = currPkgContents.getXsds();
1:cb248d1:           //check whether there should be major change/minor change/micro change in this package.
1:cb248d1:           //1. Use ASM to visit all classes in the package
1:cb248d1:           VersionChangeReason majorChange = new VersionChangeReason();
1:cb248d1:           VersionChangeReason minorChange = new VersionChangeReason();
1:cb248d1:           // check all classes to see whether there are minor or major changes
1:cb248d1:           visitPackage(pkgName, baseClazz, curClazz, majorChange, minorChange);
1:cb248d1:           // If there is no binary compatibility changes, check whether xsd files have been added, changed or deleted
1:cb248d1:           if (!!!majorChange.isChange()) {
1:cb248d1:             checkXsdChangesInPkg(pkgName, baseXsds, curXsds, majorChange);
1:cb248d1:             // If everything is ok with the existing classes. Need to find out whether there are more API (abstract classes) in the current bundle.
1:cb248d1:             // loop through curClazz and visit it and find out whether one of them is abstract.
1:cb248d1:             // check whether there are more xsd or abstract classes added
1:cb248d1:             if (!!!(majorChange.isChange() || minorChange.isChange())) {
1:cb248d1:               checkAdditionalClassOrXsds(pkgName, curClazz, curXsds, minorChange);
1:cb248d1:             }
1:cee3393:           }
1:cb248d1:           // We have scanned the whole packages, report the result
1:cb248d1:           //                    if (majorChange.isChange() || minorChange.isChange()) {
1:cb248d1:           String oldVersion = pkg.getValue().getPackageVersion();
1:cb248d1:           String newVersion = currPkgContents.getPackageVersion();
1:c3177de:           if (majorChange.isChange() && !!!ignoreChange(majorChange.getReason())) {
1:cb248d1:             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion));
1:cb248d1:             pkg_major_change = true;
1:cb248d1:             fatal_package = pkgName;
1:cb248d1:             if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion)) {
1:c3177de:               pkgElementsList.add(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));
1:cb248d1:             }
1:c3177de:           } else if (minorChange.isChange() && !!!ignoreChange(minorChange.getReason())) {
1:cb248d1:             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion));
1:cb248d1:             pkg_minor_change = true;
1:cb248d1:             if (fatal_package == null) fatal_package = pkgName;
1:cb248d1:             if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion)) {
1:c3177de:               pkgElementsList.add(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
1:cb248d1:             }
1:cb248d1:           }  else {
1:cb248d1:             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion));
1:c3177de:             pkgElementsList.add(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.NO_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), "", ""));
1:cb248d1:           }
1:cb248d1:       }
1:1ad65cc:       }
1:cb248d1:       // If there is a package version change, the bundle version needs to be updated.
1:cb248d1:       // If there is a major change in one of the packages, the bundle major version needs to be increased.
1:cb248d1:       // If there is a minor change in one of the packages, the bundle minor version needs to be increased.
1:cb248d1:       String oldVersion = baseBundle.getBundleManifest().getVersion().toString();
1:cb248d1:       String newVersion = currentBundle.getBundleManifest().getVersion().toString();
1:e305ed5: 
1:e305ed5: 
1:cb248d1:       if (pkg_major_change || pkg_minor_change) {
1:e305ed5: 
1:cb248d1:         if (pkg_major_change) {
1:cb248d1:           // The bundle version's major value should be increased.
1:cb248d1:           bundleChange = new VersionChange(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
1:cb248d1:           reason = "Some packages have major changes. For an instance, the package " + fatal_package + " has major version changes.";
1:cb248d1:           bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, reason);
1:cb248d1:           bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
1:cb248d1:         } else if (pkg_minor_change) {
1:cb248d1:           bundleChange = new VersionChange(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
1:cb248d1:           reason = "Some packages have minor changes. For an instance, the package " + fatal_package + " has minor version changes.";
1:cb248d1:           bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion, reason);
1:cb248d1:           bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
1:1ad65cc:         }
1:cb248d1:       } else {
1:cb248d1:         bundleChange = new VersionChange(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
1:cb248d1:         bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
1:cb248d1:         if (!bundleVersionCorrect) {
1:cb248d1:           reason = "The bundle has no version changes.";
1:cb248d1:           bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion, reason);
1:cb248d1:         }
1:cb248d1:       }
84:e305ed5:     }
1:cb248d1:     return this;
1:cb248d1:   }
1:e305ed5: 
1:cb248d1:   private Map<String, PackageContent> getAllExportedPkgContents(BundleInfo currentBundle) {
1:cb248d1:     String packageExports = currentBundle.getBundleManifest().getRawAttributes().getValue(Constants.EXPORT_PACKAGE);
1:cb248d1:     List<ManifestHeaderProcessor.NameValuePair> exportPackageLists = ManifestHeaderProcessor.parseExportString(packageExports);
1:cb248d1:     // only perform validation if there are some packages exported. Otherwise, not interested.
1:cb248d1:     Map<String, PackageContent> exportedPackages = new HashMap<String, PackageContent>();
1:cb248d1:     if (!!!exportPackageLists.isEmpty()) {
1:cb248d1:       File bundleFile = currentBundle.getBundle();
1:cb248d1:       IDirectory bundleDir = FileSystem.getFSRoot(bundleFile);
1:cb248d1:       for (ManifestHeaderProcessor.NameValuePair exportedPackage : exportPackageLists) {
1:cb248d1:         String packageName = exportedPackage.getName();
1:cb248d1:         String packageVersion = exportedPackage.getAttributes().get(Constants.VERSION_ATTRIBUTE);
1:cb248d1:         // need to go through each package and scan every class
1:cb248d1:         exportedPackages.put(packageName, new PackageContent(packageName, packageVersion));
1:cb248d1:       }
1:cb248d1:       // scan the jar and list all the files under each package
1:cb248d1:       List<IFile> allFiles = bundleDir.listAllFiles();
1:cb248d1:       for (IFile file : allFiles) {
1:cb248d1:         String directoryFullPath = file.getName();
1:cb248d1:         String directoryName = null;
1:cb248d1:         String fileName = null;
1:cb248d1:         if (file.isFile() && ((file.getName().endsWith(SemanticVersioningUtils.classExt) || (file.getName().endsWith(SemanticVersioningUtils.schemaExt))))) {
1:cb248d1:           if (directoryFullPath.lastIndexOf("/") != -1) {
1:cb248d1:             directoryName = directoryFullPath.substring(0, directoryFullPath.lastIndexOf("/"));
1:cb248d1:             fileName = directoryFullPath.substring(directoryFullPath.lastIndexOf("/") + 1);
1:cb248d1:           }
1:cb248d1:         }
1:e305ed5: 
1:cb248d1:         if (directoryName != null) {
1:cb248d1:           String pkgName = directoryName.replaceAll("/", ".");
1:cb248d1:           PackageContent pkgContent = exportedPackages.get(pkgName);
1:cb248d1:           if (pkgContent != null) {
1:cb248d1:             if (file.getName().endsWith(SemanticVersioningUtils.classExt)) {
1:cb248d1:               pkgContent.addClass(fileName, file);
1:cb248d1:             } else {
1:cb248d1:               pkgContent.addXsd(fileName, file);
1:e305ed5:             }
1:cb248d1:             exportedPackages.put(pkgName, pkgContent);
1:cb248d1:           }
1:cb248d1:         }
1:cb248d1:       }
1:e305ed5:     }
1:cb248d1:     return exportedPackages;
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   private String getBundleStatusText(String bundleFileName, String bundleSymbolicName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason) {
1:cb248d1:     if (!isVersionCorrect(status, oldVersionStr, newVersionStr)) {
1:cb248d1:       return "The bundle " + bundleSymbolicName + " has the following changes:\r\n" + reason + "\r\nThe bundle version should be " + getRecommendedVersion(status, oldVersionStr) + ".";
1:cb248d1:     } else {
1:cb248d1:       return "";
1:cb248d1:     } 
1:cb248d1: 
1:cb248d1: 
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   /**
1:cb248d1:    * Visit the whole package to scan each class to see whether we need to log minor or major changes.
1:cb248d1:    *
1:cb248d1:    * @param pkgName
1:cb248d1:    * @param baseClazz
1:cb248d1:    * @param curClazz
1:cb248d1:    * @param majorChange
1:cb248d1:    * @param minorChange
1:cb248d1:    */
1:cb248d1:   private void visitPackage(String pkgName, Map<String, IFile> baseClazz,
1:cb248d1:       Map<String, IFile> curClazz, VersionChangeReason majorChange, VersionChangeReason minorChange) {
1:cb248d1:     StringBuilder major_reason = new StringBuilder();
1:cb248d1:     StringBuilder minor_reason = new StringBuilder();
1:cb248d1:     boolean is_major_change = false;
1:cb248d1:     boolean is_minor_change = false;
1:cb248d1:     String fatal_class = null;
1:cb248d1:     boolean foundNewAbstract = false;
1:cb248d1:     for (Map.Entry<String, IFile> file : baseClazz.entrySet()) {
1:cb248d1:       // scan the latest version of the class
1:cb248d1:       IFile curFile = curClazz.get(file.getKey());
1:cb248d1:       String changeClass = file.getValue().getName();
1:cb248d1:       //Scan the base version
1:cb248d1:       SemanticVersioningClassVisitor oldcv = getVisitor(file.getValue(), oldJarsLoader);
1:cb248d1:       // skip the property files as they are compiled as class file as well
1:cb248d1:       ClassDeclaration cd = oldcv.getClassDeclaration();
1:cb248d1:       if ((cd != null) && (!SemanticVersioningUtils.isPropertyFile(cd))) {
1:cb248d1: 
1:cb248d1:         if (curFile == null) {
1:bf75a0e:           // the class we are scanning has been deleted from the current version of the bundle
1:cb248d1:           // This should be a major increase
1:cb248d1:           major_reason.append(twoLineBreaks + "The class/interface " + getClassName(changeClass) + " has been deleted from the package.");
1:cb248d1:           //majorChange.update(reason, changeClass);
1:cb248d1:           is_major_change = true;
1:cb248d1:           // only replace the fatal class if not set as the class won't be found in cmvc due to the fact it has been deleted.
1:cb248d1:           if (fatal_class == null) {
1:cb248d1:             fatal_class = changeClass;
1:cb248d1:           }
1:cb248d1:         } else {
1:cb248d1:           // check for binary compatibility
1:bf75a0e:           // load the class from the current version of the bundle
1:cb248d1:           // remove it from the curClazz collection as we would like to know whether there are more classes added
1:cb248d1:           curClazz.remove(file.getKey());
1:cb248d1:           SemanticVersioningClassVisitor newcv = getVisitor(curFile, newJarsLoader);
1:cb248d1:           // check for binary compatibility
1:cb248d1:           ClassDeclaration newcd = newcv.getClassDeclaration();
1:cb248d1:           BinaryCompatibilityStatus bcs = newcd.getBinaryCompatibleStatus(oldcv.getClassDeclaration());
1:cb248d1: 
1:cb248d1:           if (!bcs.isCompatible()) {
1:cb248d1:             major_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following changes have been made since the last release.");
1:cb248d1:             // break binary compatibility
1:cb248d1:             for (String reason : bcs) {
1:cb248d1:               major_reason.append(oneLineBreak).append(reason);
1:cb248d1:             }
1:cb248d1:             is_major_change = true;
1:cb248d1:             fatal_class = changeClass;
1:cb248d1:           } else {
1:cb248d1:             //check to see whether more methods are added
1:cb248d1:             ClassDeclaration oldcd = oldcv.getClassDeclaration();
1:cb248d1:             Collection<MethodDeclaration> extraMethods = newcd.getExtraMethods(oldcd);
1:cb248d1: 
1:cb248d1:             boolean containsConcrete = false;
1:cb248d1:             boolean containsAbstract = false;
1:cb248d1: 
1:cb248d1:             boolean abstractClass = newcd.isAbstract();
1:cb248d1: 
1:cb248d1:             StringBuilder subRemarks = new StringBuilder();
1:cb248d1:             String concreteSubRemarks = null;
1:cb248d1:             for (MethodDeclaration extraMethod : extraMethods) {
1:cb248d1:               //only interested in the visible methods not the system generated ones
1:cb248d1:               if (!extraMethod.getName().contains("$")) {
1:cb248d1:                 if (abstractClass) {
1:cb248d1:                   if (extraMethod.isAbstract()) {
1:cb248d1:                     foundNewAbstract = true;
1:cb248d1:                     containsAbstract = true;
1:cb248d1:                     subRemarks.append(oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()));
1:cb248d1:                   } else {
1:cb248d1:                     //only list one abstract method, no need to list all
1:cb248d1:                     containsConcrete = true;
1:cb248d1:                     concreteSubRemarks = oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
1:cb248d1:                   }
1:cb248d1:                 } else {
1:cb248d1:                   containsConcrete = true;
1:cb248d1:                   concreteSubRemarks = oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
1:cb248d1:                   break;
1:cb248d1:                 }
1:cb248d1:               }
1:cb248d1:             }
1:cb248d1: 
1:cb248d1:             if (containsConcrete || containsAbstract) {
1:cb248d1:               is_minor_change = true;
1:cb248d1:               if (!is_major_change) {
1:cb248d1:                 fatal_class = changeClass;
1:cb248d1:               }
1:cb248d1:               if (containsAbstract) {
1:cb248d1: 
1:bf75a0e:                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following abstract methods have been added since the last release of this bundle.");
1:cb248d1:                 minor_reason.append(subRemarks);
1:cb248d1:               } else {
1:bf75a0e:                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following method has been added since the last release of this bundle.");
1:cb248d1:                 minor_reason.append(concreteSubRemarks);
1:cb248d1:               }
1:cb248d1:             }
1:cb248d1:             //check to see whether there are extra public/protected fields if there is no additional methods
1:cb248d1: 
1:cb248d1:             if (!is_minor_change) {
1:cb248d1:               for (FieldDeclaration field : newcd.getExtraFields(oldcd)) {
1:cb248d1:                 if (field.isPublic() || field.isProtected()) {
1:cb248d1:                   is_minor_change = true;
1:cb248d1:                   String extraFieldRemarks = oneLineBreak + " " + SemanticVersioningUtils.transform(field.getDesc()) + " " + field.getName();
1:cb248d1:                   if (!is_major_change) {
1:cb248d1:                     fatal_class = changeClass;
1:cb248d1:                   }
1:bf75a0e:                   minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following fields have been added since the last release of this bundle.");
1:cb248d1:                   minor_reason.append(extraFieldRemarks);
1:cb248d1:                   break;
1:cb248d1:                 }
1:cb248d1:               }
1:cb248d1: 
1:cb248d1:             }
1:cb248d1: 
1:cb248d1:           }
1:cb248d1:         }
1:cb248d1:       }
1:cb248d1:     }
1:cb248d1:     if (is_major_change) {
1:cb248d1:       majorChange.update(major_reason.toString(), fatal_class, false);
1:cb248d1:     }
1:cb248d1:     if (is_minor_change) {
1:cb248d1:       minorChange.update(minor_reason.toString(), fatal_class, (foundNewAbstract ? true : false));
1:cb248d1:     }
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   /**
1:cb248d1:    * Check whether the package has xsd file changes or deleted. If yes, log a minor change.
1:cb248d1:    *
1:cb248d1:    * @param pkgName
1:cb248d1:    * @param baseXsds
1:cb248d1:    * @param curXsds
1:cb248d1:    * @param majorChange
1:cb248d1:    * @throws java.io.IOException
1:cb248d1:    */
1:cb248d1: 
1:cb248d1:   private void checkXsdChangesInPkg(String pkgName, Map<String, IFile> baseXsds,
1:cb248d1:       Map<String, IFile> curXsds, VersionChangeReason majorChange) throws IOException {
1:cb248d1:     String reason;
1:cb248d1:     for (Map.Entry<String, IFile> file : baseXsds.entrySet()) {
1:cb248d1:       // scan the latest version of the class
1:cb248d1:       IFile curXsd = curXsds.get(file.getKey());
1:cb248d1:       String changeClass = file.getValue().getName();
1:cb248d1:       // check whether the xsd have been deleted or changed or added
1:cb248d1:       if (curXsd == null) {
1:cb248d1:         reason = "In the package " + pkgName + ", The schema file has been deleted: " + file.getKey() + ".";
1:cb248d1:         majorChange.update(reason, changeClass, false);
1:cb248d1:         break;
1:cb248d1:       } else {
1:cb248d1:         // check whether it is the same
1:cb248d1:         //read the current xsd file
1:cb248d1:         curXsds.remove(file.getKey());
1:cb248d1:         String curFileContent = readXsdFile(curXsd.open());
1:cb248d1:         String oldFileContent = readXsdFile(file.getValue().open());
1:cb248d1:         if (!!!(curFileContent.equals(oldFileContent))) {
1:cb248d1: 
1:cb248d1:           reason = "In the package " + pkgName + ", The schema file has been updated: " + file.getKey() + ".";
1:cb248d1:           majorChange.update(reason, changeClass, false);
1:cb248d1:           break;
1:cb248d1:         }
1:cb248d1:       }
1:cb248d1:     }
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   /**
1:cb248d1:    * Check whether the package has gained additional class or xsd files. If yes, log a minor change.
1:cb248d1:    *
1:cb248d1:    * @param pkgName
1:cb248d1:    * @param curClazz
1:cb248d1:    * @param curXsds
1:cb248d1:    * @param minorChange
1:cb248d1:    */
1:cb248d1:   private void checkAdditionalClassOrXsds(String pkgName, Map<String, IFile> curClazz,
1:cb248d1:       Map<String, IFile> curXsds, VersionChangeReason minorChange) {
1:cb248d1:     String reason;
1:cb248d1:     Collection<IFile> ifiles = curClazz.values();
1:cb248d1:     Iterator<IFile> iterator = ifiles.iterator();
1:cb248d1:     while (iterator.hasNext()) {
1:cb248d1:       IFile ifile = iterator.next();
1:cb248d1:       String changeClass = ifile.getName();
1:cb248d1:       SemanticVersioningClassVisitor cv = getVisitor(ifile, newJarsLoader);
1:cb248d1:       if (cv.getClassDeclaration() != null) {
1:cb248d1:         // If this is a public/protected class, it will need to increase the minor version of the package.
1:cb248d1:         minorChange.setChange(true);
1:cb248d1:         if (minorChange.isChange()) {
1:cb248d1:           reason = "The package " + pkgName + " has gained at least one class : " + getClassName(changeClass) + ".";
1:cb248d1:           minorChange.update(reason, changeClass, false);
1:cb248d1:           break;
1:cb248d1:         }
1:cb248d1:       }
1:cb248d1:     }
1:cb248d1:     if (!!!(minorChange.isChange() || curXsds.isEmpty())) {
1:cb248d1:       /// a new xsd file was added, it is a minor change
1:cb248d1:       IFile firstXsd = null;
1:cb248d1:       Iterator<IFile> xsdIterator = curXsds.values().iterator();
1:cb248d1:       firstXsd = xsdIterator.next();
1:cb248d1: 
1:cb248d1:       reason = "In the package " + pkgName + ", The schema file(s) are added: " + curXsds.keySet() + ".";
1:cb248d1:       minorChange.update(reason, firstXsd.getName(), false);
1:cb248d1:     }
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   static boolean isVersionCorrect(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
1:cb248d1:     boolean versionCorrect = false;
1:cb248d1: 
1:cb248d1:     Version oldVersion = Version.parseVersion(oldVersionStr);
1:cb248d1:     Version newVersion = Version.parseVersion(newVersionStr);
1:cb248d1: 
1:cb248d1:     if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
1:cb248d1:       if (newVersion.getMajor() > oldVersion.getMajor()) {
1:cb248d1:         versionCorrect = true;
1:cb248d1:       }
1:cb248d1:     } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
1:cb248d1:       if ((newVersion.getMajor() > oldVersion.getMajor()) || (newVersion.getMinor() > oldVersion.getMinor())) {
1:cb248d1:         versionCorrect = true;
1:cb248d1:       }
1:cb248d1:     } else {
1:cb248d1:       if ((newVersion.getMajor() >= oldVersion.getMajor()) && (newVersion.getMinor() >= oldVersion.getMinor())) {
1:cb248d1:         versionCorrect = true;
1:cb248d1:       }
1:cb248d1:     }
1:cb248d1:     return versionCorrect;
1:cb248d1:   }
1:cb248d1:   private String getRecommendedVersion( VERSION_CHANGE_TYPE status, String oldVersionStr) {
1:cb248d1:     Version oldVersion = Version.parseVersion(oldVersionStr);
1:cb248d1:     Version recommendedNewVersion;
1:cb248d1: 
1:cb248d1:     if (status == BundleCompatibility.VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
1:cb248d1:       recommendedNewVersion = new Version(oldVersion.getMajor() + 1, 0, 0);
1:cb248d1:     } else if (status == BundleCompatibility.VERSION_CHANGE_TYPE.MINOR_CHANGE) {
1:cb248d1:       recommendedNewVersion = new Version(oldVersion.getMajor(), oldVersion.getMinor() + 1, 0);
1:cb248d1:     } else {
1:cb248d1:       recommendedNewVersion = oldVersion;
1:cb248d1:     }
1:cb248d1:     return recommendedNewVersion.toString();
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   private String getPkgStatusText(String pkgName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason, String key_class) {
1:cb248d1: 
1:cb248d1: 
1:cb248d1: 
1:cb248d1: 
1:cb248d1:     if (!isVersionCorrect(status, oldVersionStr, newVersionStr)) {
1:cb248d1:       return "The package " + pkgName + " has the following changes:" + reason + "\r\nThe package version should be " + getRecommendedVersion(status, oldVersionStr) + ".";
1:cb248d1:     } else {
1:cb248d1:       return "";
1:cb248d1:     }
1:cb248d1: 
1:c573eea:   }
1:cb248d1: 
1:cb248d1: 
1:c573eea: 
1:cb248d1:   private String getClassName(String fullClassPath) {
1:cb248d1:     String[] chunks = fullClassPath.split("/");
1:cb248d1:     String className = chunks[chunks.length - 1];
1:cb248d1:     className = className.replace(SemanticVersioningUtils.classExt, SemanticVersioningUtils.javaExt);
1:cb248d1:     return className;
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   private String readXsdFile(InputStream is) {
1:cb248d1:     BufferedReader br = new BufferedReader(new InputStreamReader(is));
1:cb248d1:     StringBuilder sb = new StringBuilder();
1:cb248d1:     String line = null;
1:cb248d1:     try {
1:cb248d1:       while ((line = br.readLine()) != null) {
1:cb248d1:         sb.append(line);
1:cb248d1:       }
1:cb248d1:     } catch (IOException ioe) {
1:cb248d1:       IOUtils.close(br);
1:cb248d1:     }
1:cb248d1:     return sb.toString();
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   private SemanticVersioningClassVisitor getVisitor(IFile file, URLClassLoader loader) {
1:84181ac:    
1:84181ac:     SerialVersionClassVisitor sv = new SerialVersionClassVisitor(null);
1:84181ac:     SemanticVersioningClassVisitor oldcv = new SemanticVersioningClassVisitor(loader, sv);
1:cb248d1:     try {
1:cb248d1:       ClassReader cr = new ClassReader(file.open());
1:cb248d1:       cr.accept(oldcv, 0);
1:cb248d1:     } catch (IOException ioe) {
1:cb248d1:       _logger.debug("The file " + file + "cannot be opened.");
1:cb248d1:     }
1:cb248d1:     return oldcv;
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   enum VERSION_CHANGE_TYPE {
1:cb248d1:     MAJOR_CHANGE("major"), MINOR_CHANGE("minor"), NO_CHANGE("no");
1:cb248d1:     private final String text;
1:cb248d1: 
1:cb248d1:     VERSION_CHANGE_TYPE(String text) {
1:cb248d1:       this.text = text;
1:c573eea:     }
1:c573eea: 
1:cb248d1:     public String text() {
1:cb248d1:       return this.text;
1:cb248d1:     }
1:c573eea: 
1:c573eea:   }
1:c573eea: 
1:cb248d1:   private static class PackageContent {
1:cb248d1:     private final String packageName;
1:cb248d1:     private final String packageVersion;
1:cb248d1:     private final Map<String, IFile> classes = new HashMap<String, IFile>();
1:cb248d1:     private final Map<String, IFile> xsds = new HashMap<String, IFile>();
1:c573eea: 
1:cb248d1:     PackageContent(String pkgName, String pkgVersion) {
1:cb248d1:       packageName = pkgName;
1:cb248d1:       packageVersion = pkgVersion;
1:e305ed5:     }
1:c573eea: 
1:cb248d1:     public void addClass(String className, IFile file) {
1:cb248d1:       classes.put(className, file);
1:e305ed5:     }
1:c573eea: 
1:cb248d1:     public void addXsd(String className, IFile file) {
1:cb248d1:       xsds.put(className, file);
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public Map<String, IFile> getClasses() {
1:cb248d1:       return classes;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public Map<String, IFile> getXsds() {
1:cb248d1:       return xsds;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public String getPackageVersion() {
1:cb248d1:       return packageVersion;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public String getPackageName() {
1:cb248d1:       return packageName;
1:cb248d1:     }
1:cb248d1:   }
1:cb248d1: 
1:cb248d1:   private static class VersionChangeReason {
1:cb248d1:     boolean change = false;
1:cb248d1:     String reason = null;
1:cb248d1:     String changeClass = null;
1:cb248d1:     boolean moreAbstractMethod = false;
1:cb248d1: 
1:cb248d1: 
1:cb248d1:     public boolean isMoreAbstractMethod() {
1:cb248d1:       return moreAbstractMethod;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public boolean isChange() {
1:cb248d1:       return change;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public void setChange(boolean change) {
1:cb248d1:       this.change = change;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public String getReason() {
1:cb248d1:       return reason;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public String getChangeClass() {
1:cb248d1:       return changeClass;
1:cb248d1:     }
1:cb248d1: 
1:cb248d1:     public void update(String reason, String changeClass, boolean moreAbstractMethod) {
1:cb248d1:       this.change = true;
1:cb248d1:       this.reason = reason;
1:cb248d1:       this.changeClass = changeClass;
1:cb248d1:       this.moreAbstractMethod = moreAbstractMethod;
1:cb248d1:     }
1:cb248d1:   }
1:cb248d1: 
1:e305ed5: }
============================================================================
author:Jeremy Hughes
-------------------------------------------------------------------------------
commit:c3177de
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:   private List<String> pkgElementsList = new ArrayList<String>();
1:   private List<String> excludes;
1:     this(bundleSymbolicName,
1:          currentBundle,
1:          baseBundle,
1:          oldJarsLoader,
1:          newJarsLoader,
1:          null);
1:   }
1:   
1:   public BundleCompatibility(String bundleSymbolicName, BundleInfo currentBundle, BundleInfo baseBundle, URLClassLoader oldJarsLoader, URLClassLoader newJarsLoader, List<String> excludes) {
1:     this.excludes = excludes != null ? excludes : new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:   
1:   private boolean ignoreChange(String reason) {
1:     if ((reason == null) || (this.excludes.isEmpty())) return false;
1:     
1:     for (String exclude : this.excludes) {
1:       // Could have interpreted each exclude as a regex, but that makes it easy to write loose rules
1:       // that match more strings than intended.
1:       if ((reason != null) && reason.contains(exclude)) return true; 
1:     }
1:     
1:     return false;
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:           if (majorChange.isChange() && !!!ignoreChange(majorChange.getReason())) {
1:               pkgElementsList.add(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));
1:           } else if (minorChange.isChange() && !!!ignoreChange(minorChange.getReason())) {
1:               pkgElementsList.add(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
1:             pkgElementsList.add(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.NO_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), "", ""));
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:bf75a0e
/////////////////////////////////////////////////////////////////////////
1:           // the class we are scanning has been deleted from the current version of the bundle
/////////////////////////////////////////////////////////////////////////
1:           // load the class from the current version of the bundle
/////////////////////////////////////////////////////////////////////////
1:                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following abstract methods have been added since the last release of this bundle.");
1:                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following method has been added since the last release of this bundle.");
/////////////////////////////////////////////////////////////////////////
1:                   minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following fields have been added since the last release of this bundle.");
author:Emily Jiang
-------------------------------------------------------------------------------
commit:84181ac
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.versioning.utils.SerialVersionClassVisitor;
/////////////////////////////////////////////////////////////////////////
1:    
1:     SerialVersionClassVisitor sv = new SerialVersionClassVisitor(null);
1:     SemanticVersioningClassVisitor oldcv = new SemanticVersioningClassVisitor(loader, sv);
commit:cb248d1
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev:$ $Date:$
1:  */
1:   private static final Logger _logger = LoggerFactory.getLogger(BundleCompatibility.class);
1:   private URLClassLoader oldJarsLoader;
1:   private URLClassLoader newJarsLoader;
1:   private String bundleSymbolicName;
1:   private String bundleElement;
1:   private boolean bundleVersionCorrect;
1:   private BundleInfo currentBundle;
1:   private BundleInfo baseBundle;
1:   private StringBuilder pkgElements = new StringBuilder();
1:   private VersionChange bundleChange;
1:   private final Map<String, VersionChange> packageChanges = new HashMap<String, VersionChange>();
1:   public BundleCompatibility(String bundleSymbolicName, BundleInfo currentBundle, BundleInfo baseBundle, URLClassLoader oldJarsLoader, URLClassLoader newJarsLoader) {
1:     this.bundleSymbolicName = bundleSymbolicName;
1:     this.currentBundle = currentBundle;
1:     this.baseBundle = baseBundle;
1:     this.oldJarsLoader = oldJarsLoader;
1:     this.newJarsLoader = newJarsLoader;
1:   }
1:   public VersionChange getBundleChange() {
1:     return bundleChange;
1:   }
1:   public Map<String, VersionChange> getPackageChanges() {
1:     return packageChanges;
1:   }
1:   public String getBundleElement() {
1:     return bundleElement;
1:   }
1:   public StringBuilder getPkgElements() {
1:     return pkgElements;
1:   }
1:   public boolean isBundleVersionCorrect() {
1:     return bundleVersionCorrect;
1:   }
1:   public BundleCompatibility invoke() throws IOException {
1:     String reason = null;
1:     // open the manifest and scan the export package and find the package name and exported version
1:     // The tool assume the one particular package just exports under one version
1:     Map<String, PackageContent> currBundleExpPkgContents = getAllExportedPkgContents(currentBundle);
1:     Map<String, PackageContent> baseBundleExpPkgContents;
1:     boolean pkg_major_change = false;
1:     boolean pkg_minor_change = false;
1:     String fatal_package = null;
1:     if (!!!currBundleExpPkgContents.isEmpty()) {
1:       baseBundleExpPkgContents = getAllExportedPkgContents(baseBundle);
1:       // compare each class right now
1:       for (Map.Entry<String, PackageContent> pkg : baseBundleExpPkgContents.entrySet()) {
1:         String pkgName = pkg.getKey();
1:         Map<String, IFile> baseClazz = pkg.getValue().getClasses();
1:         Map<String, IFile> baseXsds = pkg.getValue().getXsds();
1:         PackageContent currPkgContents = currBundleExpPkgContents.get(pkgName);
1:         if (currPkgContents == null) {
1:           // The package is no longer exported any more. This should lead to bundle major version change.
1:           pkg_major_change = true;
1:           fatal_package = pkgName;
1:           _logger.debug("The package " + pkgName + " in the bundle of " + bundleSymbolicName + " is no longer to be exported. Major change.");
1:           Map<String, IFile> curClazz = currPkgContents.getClasses();
1:           Map<String, IFile> curXsds = currPkgContents.getXsds();
1:           //check whether there should be major change/minor change/micro change in this package.
1:           //1. Use ASM to visit all classes in the package
1:           VersionChangeReason majorChange = new VersionChangeReason();
1:           VersionChangeReason minorChange = new VersionChangeReason();
1:           // check all classes to see whether there are minor or major changes
1:           visitPackage(pkgName, baseClazz, curClazz, majorChange, minorChange);
1:           // If there is no binary compatibility changes, check whether xsd files have been added, changed or deleted
1:           if (!!!majorChange.isChange()) {
1:             checkXsdChangesInPkg(pkgName, baseXsds, curXsds, majorChange);
1:             // If everything is ok with the existing classes. Need to find out whether there are more API (abstract classes) in the current bundle.
1:             // loop through curClazz and visit it and find out whether one of them is abstract.
1:             // check whether there are more xsd or abstract classes added
1:             if (!!!(majorChange.isChange() || minorChange.isChange())) {
1:               checkAdditionalClassOrXsds(pkgName, curClazz, curXsds, minorChange);
1:           }
1:           // We have scanned the whole packages, report the result
1:           //                    if (majorChange.isChange() || minorChange.isChange()) {
1:           String oldVersion = pkg.getValue().getPackageVersion();
1:           String newVersion = currPkgContents.getPackageVersion();
0:           if (majorChange.isChange()) {
1:             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion));
1:             pkg_major_change = true;
1:             fatal_package = pkgName;
1:             if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion)) {
0:               pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));
1:             }
0:           } else if (minorChange.isChange()) {
1:             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion));
1:             pkg_minor_change = true;
1:             if (fatal_package == null) fatal_package = pkgName;
1:             if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion)) {
0:               pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
1:             }
1:           }  else {
1:             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion));
0:             pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.NO_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), "", ""));
1:           }
0:           pkgElements.append("\r\n");
0:           //                    }
1:       }
1:       // If there is a package version change, the bundle version needs to be updated.
1:       // If there is a major change in one of the packages, the bundle major version needs to be increased.
1:       // If there is a minor change in one of the packages, the bundle minor version needs to be increased.
1:       String oldVersion = baseBundle.getBundleManifest().getVersion().toString();
1:       String newVersion = currentBundle.getBundleManifest().getVersion().toString();
1:       if (pkg_major_change || pkg_minor_change) {
1:         if (pkg_major_change) {
1:           // The bundle version's major value should be increased.
1:           bundleChange = new VersionChange(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
1:           reason = "Some packages have major changes. For an instance, the package " + fatal_package + " has major version changes.";
1:           bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, reason);
1:           bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
1:         } else if (pkg_minor_change) {
1:           bundleChange = new VersionChange(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
1:           reason = "Some packages have minor changes. For an instance, the package " + fatal_package + " has minor version changes.";
1:           bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion, reason);
1:           bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
1:       } else {
1:         bundleChange = new VersionChange(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
1:         bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
1:         if (!bundleVersionCorrect) {
1:           reason = "The bundle has no version changes.";
1:           bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion, reason);
1:         }
1:       }
1:     return this;
1:   }
1:   private Map<String, PackageContent> getAllExportedPkgContents(BundleInfo currentBundle) {
1:     String packageExports = currentBundle.getBundleManifest().getRawAttributes().getValue(Constants.EXPORT_PACKAGE);
1:     List<ManifestHeaderProcessor.NameValuePair> exportPackageLists = ManifestHeaderProcessor.parseExportString(packageExports);
1:     // only perform validation if there are some packages exported. Otherwise, not interested.
1:     Map<String, PackageContent> exportedPackages = new HashMap<String, PackageContent>();
1:     if (!!!exportPackageLists.isEmpty()) {
1:       File bundleFile = currentBundle.getBundle();
1:       IDirectory bundleDir = FileSystem.getFSRoot(bundleFile);
1:       for (ManifestHeaderProcessor.NameValuePair exportedPackage : exportPackageLists) {
1:         String packageName = exportedPackage.getName();
1:         String packageVersion = exportedPackage.getAttributes().get(Constants.VERSION_ATTRIBUTE);
1:         // need to go through each package and scan every class
1:         exportedPackages.put(packageName, new PackageContent(packageName, packageVersion));
1:       }
1:       // scan the jar and list all the files under each package
1:       List<IFile> allFiles = bundleDir.listAllFiles();
1:       for (IFile file : allFiles) {
1:         String directoryFullPath = file.getName();
1:         String directoryName = null;
1:         String fileName = null;
1:         if (file.isFile() && ((file.getName().endsWith(SemanticVersioningUtils.classExt) || (file.getName().endsWith(SemanticVersioningUtils.schemaExt))))) {
1:           if (directoryFullPath.lastIndexOf("/") != -1) {
1:             directoryName = directoryFullPath.substring(0, directoryFullPath.lastIndexOf("/"));
1:             fileName = directoryFullPath.substring(directoryFullPath.lastIndexOf("/") + 1);
1:           }
1:         }
1:         if (directoryName != null) {
1:           String pkgName = directoryName.replaceAll("/", ".");
1:           PackageContent pkgContent = exportedPackages.get(pkgName);
1:           if (pkgContent != null) {
1:             if (file.getName().endsWith(SemanticVersioningUtils.classExt)) {
1:               pkgContent.addClass(fileName, file);
1:             } else {
1:               pkgContent.addXsd(fileName, file);
1:             exportedPackages.put(pkgName, pkgContent);
1:           }
1:       }
1:     }
1:     return exportedPackages;
1:   }
1: 
1:   private String getBundleStatusText(String bundleFileName, String bundleSymbolicName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason) {
1:     if (!isVersionCorrect(status, oldVersionStr, newVersionStr)) {
1:       return "The bundle " + bundleSymbolicName + " has the following changes:\r\n" + reason + "\r\nThe bundle version should be " + getRecommendedVersion(status, oldVersionStr) + ".";
1:     } else {
1:       return "";
1:     } 
1: 
1: 
1:   }
1: 
1:   /**
1:    * Visit the whole package to scan each class to see whether we need to log minor or major changes.
1:    *
1:    * @param pkgName
1:    * @param baseClazz
1:    * @param curClazz
1:    * @param majorChange
1:    * @param minorChange
1:    */
1:   private void visitPackage(String pkgName, Map<String, IFile> baseClazz,
1:       Map<String, IFile> curClazz, VersionChangeReason majorChange, VersionChangeReason minorChange) {
1:     StringBuilder major_reason = new StringBuilder();
1:     StringBuilder minor_reason = new StringBuilder();
1:     boolean is_major_change = false;
1:     boolean is_minor_change = false;
1:     String fatal_class = null;
1:     boolean foundNewAbstract = false;
1:     for (Map.Entry<String, IFile> file : baseClazz.entrySet()) {
1:       // scan the latest version of the class
1:       IFile curFile = curClazz.get(file.getKey());
1:       String changeClass = file.getValue().getName();
1:       //Scan the base version
1:       SemanticVersioningClassVisitor oldcv = getVisitor(file.getValue(), oldJarsLoader);
1:       // skip the property files as they are compiled as class file as well
1:       ClassDeclaration cd = oldcv.getClassDeclaration();
1:       if ((cd != null) && (!SemanticVersioningUtils.isPropertyFile(cd))) {
1: 
1:         if (curFile == null) {
0:           // the class we are scanning has been deleted from the current version of WAS
1:           // This should be a major increase
1:           major_reason.append(twoLineBreaks + "The class/interface " + getClassName(changeClass) + " has been deleted from the package.");
1:           //majorChange.update(reason, changeClass);
1:           is_major_change = true;
1:           // only replace the fatal class if not set as the class won't be found in cmvc due to the fact it has been deleted.
1:           if (fatal_class == null) {
1:             fatal_class = changeClass;
1:           }
1:         } else {
1:           // check for binary compatibility
0:           // load the class from the current version of WAS
1:           // remove it from the curClazz collection as we would like to know whether there are more classes added
1:           curClazz.remove(file.getKey());
1:           SemanticVersioningClassVisitor newcv = getVisitor(curFile, newJarsLoader);
1:           // check for binary compatibility
1:           ClassDeclaration newcd = newcv.getClassDeclaration();
1:           BinaryCompatibilityStatus bcs = newcd.getBinaryCompatibleStatus(oldcv.getClassDeclaration());
1: 
1:           if (!bcs.isCompatible()) {
1:             major_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following changes have been made since the last release.");
1:             // break binary compatibility
1:             for (String reason : bcs) {
1:               major_reason.append(oneLineBreak).append(reason);
1:             }
1:             is_major_change = true;
1:             fatal_class = changeClass;
1:           } else {
1:             //check to see whether more methods are added
1:             ClassDeclaration oldcd = oldcv.getClassDeclaration();
1:             Collection<MethodDeclaration> extraMethods = newcd.getExtraMethods(oldcd);
1: 
1:             boolean containsConcrete = false;
1:             boolean containsAbstract = false;
1: 
1:             boolean abstractClass = newcd.isAbstract();
1: 
1:             StringBuilder subRemarks = new StringBuilder();
1:             String concreteSubRemarks = null;
1:             for (MethodDeclaration extraMethod : extraMethods) {
1:               //only interested in the visible methods not the system generated ones
1:               if (!extraMethod.getName().contains("$")) {
1:                 if (abstractClass) {
1:                   if (extraMethod.isAbstract()) {
1:                     foundNewAbstract = true;
1:                     containsAbstract = true;
1:                     subRemarks.append(oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()));
1:                   } else {
1:                     //only list one abstract method, no need to list all
1:                     containsConcrete = true;
1:                     concreteSubRemarks = oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
1:                   }
1:                 } else {
1:                   containsConcrete = true;
1:                   concreteSubRemarks = oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
1:                   break;
1:                 }
1:               }
1:             }
1: 
1:             if (containsConcrete || containsAbstract) {
1:               is_minor_change = true;
1:               if (!is_major_change) {
1:                 fatal_class = changeClass;
1:               }
1:               if (containsAbstract) {
1: 
0:                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following abstract methods have been added since the last release of WAS.");
1:                 minor_reason.append(subRemarks);
1:               } else {
0:                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following method has been added since the last release of WAS.");
1:                 minor_reason.append(concreteSubRemarks);
1:               }
1:             }
1:             //check to see whether there are extra public/protected fields if there is no additional methods
1: 
1:             if (!is_minor_change) {
1:               for (FieldDeclaration field : newcd.getExtraFields(oldcd)) {
1:                 if (field.isPublic() || field.isProtected()) {
1:                   is_minor_change = true;
1:                   String extraFieldRemarks = oneLineBreak + " " + SemanticVersioningUtils.transform(field.getDesc()) + " " + field.getName();
1:                   if (!is_major_change) {
1:                     fatal_class = changeClass;
1:                   }
0:                   minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following fields have been added since the last release of WAS.");
1:                   minor_reason.append(extraFieldRemarks);
1:                   break;
1:                 }
1:               }
1: 
1:             }
1: 
1:           }
1:         }
1:       }
1:     }
1:     if (is_major_change) {
1:       majorChange.update(major_reason.toString(), fatal_class, false);
1:     }
1:     if (is_minor_change) {
1:       minorChange.update(minor_reason.toString(), fatal_class, (foundNewAbstract ? true : false));
1:     }
1:   }
1: 
1:   /**
1:    * Check whether the package has xsd file changes or deleted. If yes, log a minor change.
1:    *
1:    * @param pkgName
1:    * @param baseXsds
1:    * @param curXsds
1:    * @param majorChange
1:    * @throws java.io.IOException
1:    */
1: 
1:   private void checkXsdChangesInPkg(String pkgName, Map<String, IFile> baseXsds,
1:       Map<String, IFile> curXsds, VersionChangeReason majorChange) throws IOException {
1:     String reason;
1:     for (Map.Entry<String, IFile> file : baseXsds.entrySet()) {
1:       // scan the latest version of the class
1:       IFile curXsd = curXsds.get(file.getKey());
1:       String changeClass = file.getValue().getName();
1:       // check whether the xsd have been deleted or changed or added
1:       if (curXsd == null) {
1:         reason = "In the package " + pkgName + ", The schema file has been deleted: " + file.getKey() + ".";
1:         majorChange.update(reason, changeClass, false);
1:         break;
1:       } else {
1:         // check whether it is the same
1:         //read the current xsd file
1:         curXsds.remove(file.getKey());
1:         String curFileContent = readXsdFile(curXsd.open());
1:         String oldFileContent = readXsdFile(file.getValue().open());
1:         if (!!!(curFileContent.equals(oldFileContent))) {
1: 
1:           reason = "In the package " + pkgName + ", The schema file has been updated: " + file.getKey() + ".";
1:           majorChange.update(reason, changeClass, false);
1:           break;
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Check whether the package has gained additional class or xsd files. If yes, log a minor change.
1:    *
1:    * @param pkgName
1:    * @param curClazz
1:    * @param curXsds
1:    * @param minorChange
1:    */
1:   private void checkAdditionalClassOrXsds(String pkgName, Map<String, IFile> curClazz,
1:       Map<String, IFile> curXsds, VersionChangeReason minorChange) {
1:     String reason;
1:     Collection<IFile> ifiles = curClazz.values();
1:     Iterator<IFile> iterator = ifiles.iterator();
1:     while (iterator.hasNext()) {
1:       IFile ifile = iterator.next();
1:       String changeClass = ifile.getName();
1:       SemanticVersioningClassVisitor cv = getVisitor(ifile, newJarsLoader);
1:       if (cv.getClassDeclaration() != null) {
1:         // If this is a public/protected class, it will need to increase the minor version of the package.
1:         minorChange.setChange(true);
1:         if (minorChange.isChange()) {
1:           reason = "The package " + pkgName + " has gained at least one class : " + getClassName(changeClass) + ".";
1:           minorChange.update(reason, changeClass, false);
1:           break;
1:         }
1:       }
1:     }
1:     if (!!!(minorChange.isChange() || curXsds.isEmpty())) {
1:       /// a new xsd file was added, it is a minor change
1:       IFile firstXsd = null;
1:       Iterator<IFile> xsdIterator = curXsds.values().iterator();
1:       firstXsd = xsdIterator.next();
1: 
1:       reason = "In the package " + pkgName + ", The schema file(s) are added: " + curXsds.keySet() + ".";
1:       minorChange.update(reason, firstXsd.getName(), false);
1:     }
1:   }
1: 
1:   static boolean isVersionCorrect(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
1:     boolean versionCorrect = false;
1: 
1:     Version oldVersion = Version.parseVersion(oldVersionStr);
1:     Version newVersion = Version.parseVersion(newVersionStr);
1: 
1:     if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
1:       if (newVersion.getMajor() > oldVersion.getMajor()) {
1:         versionCorrect = true;
1:       }
1:     } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
1:       if ((newVersion.getMajor() > oldVersion.getMajor()) || (newVersion.getMinor() > oldVersion.getMinor())) {
1:         versionCorrect = true;
1:       }
1:     } else {
1:       if ((newVersion.getMajor() >= oldVersion.getMajor()) && (newVersion.getMinor() >= oldVersion.getMinor())) {
1:         versionCorrect = true;
1:       }
1:     }
1:     return versionCorrect;
1:   }
1:   private String getRecommendedVersion( VERSION_CHANGE_TYPE status, String oldVersionStr) {
1:     Version oldVersion = Version.parseVersion(oldVersionStr);
1:     Version recommendedNewVersion;
1: 
1:     if (status == BundleCompatibility.VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
1:       recommendedNewVersion = new Version(oldVersion.getMajor() + 1, 0, 0);
1:     } else if (status == BundleCompatibility.VERSION_CHANGE_TYPE.MINOR_CHANGE) {
1:       recommendedNewVersion = new Version(oldVersion.getMajor(), oldVersion.getMinor() + 1, 0);
1:     } else {
1:       recommendedNewVersion = oldVersion;
1:     }
1:     return recommendedNewVersion.toString();
1:   }
1: 
1:   private String getPkgStatusText(String pkgName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason, String key_class) {
1: 
1: 
1: 
1: 
1:     if (!isVersionCorrect(status, oldVersionStr, newVersionStr)) {
1:       return "The package " + pkgName + " has the following changes:" + reason + "\r\nThe package version should be " + getRecommendedVersion(status, oldVersionStr) + ".";
1:     } else {
1:       return "";
1:   }
1: 
1: 
1: 
1:   private String getClassName(String fullClassPath) {
1:     String[] chunks = fullClassPath.split("/");
1:     String className = chunks[chunks.length - 1];
1:     className = className.replace(SemanticVersioningUtils.classExt, SemanticVersioningUtils.javaExt);
1:     return className;
1:   }
1: 
1:   private String readXsdFile(InputStream is) {
1:     BufferedReader br = new BufferedReader(new InputStreamReader(is));
1:     StringBuilder sb = new StringBuilder();
1:     String line = null;
1:     try {
1:       while ((line = br.readLine()) != null) {
1:         sb.append(line);
1:       }
1:     } catch (IOException ioe) {
1:       IOUtils.close(br);
1:     }
1:     return sb.toString();
1:   }
1: 
1:   private SemanticVersioningClassVisitor getVisitor(IFile file, URLClassLoader loader) {
0:     SemanticVersioningClassVisitor oldcv = new SemanticVersioningClassVisitor(loader);
1:     try {
1:       ClassReader cr = new ClassReader(file.open());
1:       cr.accept(oldcv, 0);
1:     } catch (IOException ioe) {
1:       _logger.debug("The file " + file + "cannot be opened.");
1:     }
1:     return oldcv;
1:   }
1: 
1:   enum VERSION_CHANGE_TYPE {
1:     MAJOR_CHANGE("major"), MINOR_CHANGE("minor"), NO_CHANGE("no");
1:     private final String text;
1: 
1:     VERSION_CHANGE_TYPE(String text) {
1:       this.text = text;
1:     public String text() {
1:       return this.text;
1:   }
1:   private static class PackageContent {
1:     private final String packageName;
1:     private final String packageVersion;
1:     private final Map<String, IFile> classes = new HashMap<String, IFile>();
1:     private final Map<String, IFile> xsds = new HashMap<String, IFile>();
1:     PackageContent(String pkgName, String pkgVersion) {
1:       packageName = pkgName;
1:       packageVersion = pkgVersion;
1:     public void addClass(String className, IFile file) {
1:       classes.put(className, file);
1:     public void addXsd(String className, IFile file) {
1:       xsds.put(className, file);
1:     }
1: 
1:     public Map<String, IFile> getClasses() {
1:       return classes;
1:     }
1: 
1:     public Map<String, IFile> getXsds() {
1:       return xsds;
1:     }
1: 
1:     public String getPackageVersion() {
1:       return packageVersion;
1:     }
1: 
1:     public String getPackageName() {
1:       return packageName;
1:     }
1:   }
1: 
1:   private static class VersionChangeReason {
1:     boolean change = false;
1:     String reason = null;
1:     String changeClass = null;
1:     boolean moreAbstractMethod = false;
1: 
1: 
1:     public boolean isMoreAbstractMethod() {
1:       return moreAbstractMethod;
1:     }
1: 
1:     public boolean isChange() {
1:       return change;
1:     }
1: 
1:     public void setChange(boolean change) {
1:       this.change = change;
1:     }
1: 
1:     public String getReason() {
1:       return reason;
1:     }
1: 
1:     public String getChangeClass() {
1:       return changeClass;
1:     }
1: 
1:     public void update(String reason, String changeClass, boolean moreAbstractMethod) {
1:       this.change = true;
1:       this.reason = reason;
1:       this.changeClass = changeClass;
1:       this.moreAbstractMethod = moreAbstractMethod;
1:     }
1:   }
1: 
commit:c573eea
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.oneLineBreak;
1: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.twoLineBreaks;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       if (!isVersionCorrect(status, oldVersionStr, newVersionStr)) {
0:         return "The bundle " + bundleSymbolicName + " has the following changes:\r\n" + reason + "\r\nThe bundle version should be " + getRecommendedVersion(status, oldVersionStr) + ".";
1:       } else {
0:         return "";
1:       } 
1:       
1:       
/////////////////////////////////////////////////////////////////////////
0:                     major_reason.append(twoLineBreaks + "The class/interface " + getClassName(changeClass) + " has been deleted from the package.");
/////////////////////////////////////////////////////////////////////////
0:                         major_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following changes have been made since the last release.");
0:                             major_reason.append(oneLineBreak).append(reason);
/////////////////////////////////////////////////////////////////////////
0:                                         subRemarks.append(oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()));
0:                                         concreteSubRemarks = oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
0:                                     concreteSubRemarks = oneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
/////////////////////////////////////////////////////////////////////////
0:                                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following abstract methods have been added since the last release of WAS.");
0:                                 minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following method has been added since the last release of WAS.");
/////////////////////////////////////////////////////////////////////////
0:                                     String extraFieldRemarks = oneLineBreak + " " + SemanticVersioningUtils.transform(field.getDesc()) + " " + field.getName();
0:                                     minor_reason.append(twoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following fields have been added since the last release of WAS.");
/////////////////////////////////////////////////////////////////////////
0:     private String getRecommendedVersion( VERSION_CHANGE_TYPE status, String oldVersionStr) {
0:       Version oldVersion = Version.parseVersion(oldVersionStr);
0:       Version recommendedNewVersion;
1:       
0:       if (status == BundleCompatibility.VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:           recommendedNewVersion = new Version(oldVersion.getMajor() + 1, 0, 0);
0:       } else if (status == BundleCompatibility.VERSION_CHANGE_TYPE.MINOR_CHANGE) {
0:           recommendedNewVersion = new Version(oldVersion.getMajor(), oldVersion.getMinor() + 1, 0);
0:       } else {
0:           recommendedNewVersion = oldVersion;
1:       }
0:       return recommendedNewVersion.toString();
1:     }
1:        
1:         
1: 
0:         if (!isVersionCorrect(status, oldVersionStr, newVersionStr)) {
0:           return "The package " + pkgName + " has the following changes:" + reason + "\r\nThe package version should be " + getRecommendedVersion(status, oldVersionStr) + ".";
0:         } else {
0:           return "";
1:         
1:    
author:David Jencks
-------------------------------------------------------------------------------
commit:cee3393
/////////////////////////////////////////////////////////////////////////
0:     private StringBuilder pkgElements = new StringBuilder();
0:     public BundleCompatibility(String bundleSymbolicName, BundleInfo currentBundle, BundleInfo baseBundle, URLClassLoader oldJarsLoader, URLClassLoader newJarsLoader) {
/////////////////////////////////////////////////////////////////////////
0:     public StringBuilder getPkgElements() {
0:         return pkgElements;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0: //                    if (majorChange.isChange() || minorChange.isChange()) {
/////////////////////////////////////////////////////////////////////////
0:                             pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.NO_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), "", ""));
0: //                    }
/////////////////////////////////////////////////////////////////////////
0:         return versionChange.toString();
commit:1ad65cc
/////////////////////////////////////////////////////////////////////////
0:     private VersionChange bundleChange;
0:     private final Map<String, VersionChange> packageChanges = new HashMap<String, VersionChange>();
1: 
/////////////////////////////////////////////////////////////////////////
0:     public VersionChange getBundleChange() {
0:         return bundleChange;
1:     }
1: 
0:     public Map<String, VersionChange> getPackageChanges() {
0:         return packageChanges;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     VersionChangeReason majorChange = new VersionChangeReason();
0:                     VersionChangeReason minorChange = new VersionChangeReason();
/////////////////////////////////////////////////////////////////////////
0:                             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion));
0:                             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion));
0:                         }  else {
0:                             packageChanges.put(pkgName, new VersionChange(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion));
/////////////////////////////////////////////////////////////////////////
0:                     bundleChange = new VersionChange(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
0:                     bundleChange = new VersionChange(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
0:                 bundleChange = new VersionChange(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
/////////////////////////////////////////////////////////////////////////
0:                               Map<String, IFile> curClazz, VersionChangeReason majorChange, VersionChangeReason minorChange) {
/////////////////////////////////////////////////////////////////////////
0:                                       Map<String, IFile> curXsds, VersionChangeReason majorChange) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                                             Map<String, IFile> curXsds, VersionChangeReason minorChange) {
/////////////////////////////////////////////////////////////////////////
0:         VersionChange versionChange = new VersionChange(status, oldVersionStr, newVersionStr);
0:         return " oldVersion=\"" + versionChange.getOldVersion()
0:                 + "\" currentVersion=\"" + versionChange.getNewVersion() +
0:                 "\" recommendedVersion=\"" + versionChange.getRecommendedNewVersion() + "\" correct=\"" + versionChange.isCorrect();
/////////////////////////////////////////////////////////////////////////
0:     private static class VersionChangeReason {
commit:e305ed5
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *  http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: 
1: package org.apache.aries.versioning.check;
1: 
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.net.URLClassLoader;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import org.apache.aries.util.filesystem.FileSystem;
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.apache.aries.util.filesystem.IFile;
1: import org.apache.aries.util.io.IOUtils;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1: import org.apache.aries.versioning.utils.BinaryCompatibilityStatus;
1: import org.apache.aries.versioning.utils.ClassDeclaration;
1: import org.apache.aries.versioning.utils.FieldDeclaration;
1: import org.apache.aries.versioning.utils.MethodDeclaration;
1: import org.apache.aries.versioning.utils.SemanticVersioningClassVisitor;
1: import org.apache.aries.versioning.utils.SemanticVersioningUtils;
1: import org.objectweb.asm.ClassReader;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Version;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlOneLineBreak;
0: import static org.apache.aries.versioning.utils.SemanticVersioningUtils.htmlTwoLineBreaks;
1: 
1: /**
0: * @version $Rev:$ $Date:$
1: */
1: public class BundleCompatibility {
0:     private static final Logger _logger = LoggerFactory.getLogger(BundleCompatibility.class);
1: 
1: 
0:     private URLClassLoader oldJarsLoader;
0:     private URLClassLoader newJarsLoader;
0:     private String bundleSymbolicName;
0:     private String bundleElement;
0:     private boolean bundleVersionCorrect;
0:     private BundleInfo currentBundle;
0:     private BundleInfo baseBundle;
0:     private StringBuilder pkgElements;
1: 
0:     public BundleCompatibility(String bundleSymbolicName, String bundleElement, boolean bundleVersionCorrect, BundleInfo currentBundle, BundleInfo baseBundle, StringBuilder pkgElements, URLClassLoader oldJarsLoader, URLClassLoader newJarsLoader) {
0:         this.bundleSymbolicName = bundleSymbolicName;
0:         this.bundleElement = bundleElement;
0:         this.bundleVersionCorrect = bundleVersionCorrect;
0:         this.currentBundle = currentBundle;
0:         this.baseBundle = baseBundle;
0:         this.pkgElements = pkgElements;
0:         this.oldJarsLoader = oldJarsLoader;
0:         this.newJarsLoader = newJarsLoader;
1:     }
1: 
0:     public String getBundleElement() {
0:         return bundleElement;
1:     }
1: 
0:     public boolean isBundleVersionCorrect() {
0:         return bundleVersionCorrect;
1:     }
1: 
0: //        private BundleCompatibility BundleCompatibility(String bundleSymbolicName, String bundleElement, boolean bundleVersionCorrect, BundleInfo currentBundle, BundleInfo baseBundle, StringBuilder pkgElements) throws IOException {
0: //            String reason = null;
0: //            // open the manifest and scan the export package and find the package name and exported version
0: //            // The tool assume the one particular package just exports under one version
0: //            Map<String, PackageContent> currBundleExpPkgContents = getAllExportedPkgContents(currentBundle);
0: //            Map<String, PackageContent> baseBundleExpPkgContents;
0: //            boolean pkg_major_change = false;
0: //            boolean pkg_minor_change = false;
0: //            String fatal_package = null;
0: //            if (!!!currBundleExpPkgContents.isEmpty()) {
0: //                baseBundleExpPkgContents = getAllExportedPkgContents(baseBundle);
0: //                // compare each class right now
0: //                for (Map.Entry<String, PackageContent> pkg : baseBundleExpPkgContents.entrySet()) {
0: //                    String pkgName = pkg.getKey();
0: //                    Map<String, IFile> baseClazz = pkg.getValue().getClasses();
0: //                    Map<String, IFile> baseXsds = pkg.getValue().getXsds();
0: //                    PackageContent currPkgContents = currBundleExpPkgContents.get(pkgName);
0: //                    if (currPkgContents == null) {
0: //                        // The package is no longer exported any more. This should lead to bundle major version change.
0: //                        pkg_major_change = true;
0: //                        fatal_package = pkgName;
0: //                        _logger.debug("The package " + pkgName + " in the bundle of " + bundleSymbolicName + " is no longer to be exported. Major change.");
0: //                    } else {
0: //                        Map<String, IFile> curClazz = currPkgContents.getClasses();
0: //                        Map<String, IFile> curXsds = currPkgContents.getXsds();
0: //                        //check whether there should be major change/minor change/micro change in this package.
0: //                        //1. Use ASM to visit all classes in the package
0: //                        VersionChange majorChange = new VersionChange();
0: //                        VersionChange minorChange = new VersionChange();
0: //                        // check all classes to see whether there are minor or major changes
0: //                        visitPackage(pkgName, baseClazz, curClazz, majorChange, minorChange);
0: //                        // If there is no binary compatibility changes, check whether xsd files have been added, changed or deleted
0: //                        if (!!!majorChange.isChange()) {
0: //                            checkXsdChangesInPkg(pkgName, baseXsds, curXsds, majorChange);
0: //                            // If everything is ok with the existing classes. Need to find out whether there are more API (abstract classes) in the current bundle.
0: //                            // loop through curClazz and visit it and find out whether one of them is abstract.
0: //                            // check whether there are more xsd or abstract classes added
0: //                            if (!!!(majorChange.isChange() || minorChange.isChange())) {
0: //                                checkAdditionalClassOrXsds(pkgName, curClazz, curXsds, minorChange);
0: //                            }
0: //                        }
0: //                        // We have scanned the whole packages, report the result
0: //                        if (majorChange.isChange() || minorChange.isChange()) {
0: //                            String oldVersion = pkg.getValue().getPackageVersion();
0: //                            String newVersion = currPkgContents.getPackageVersion();
0: //                            if (majorChange.isChange()) {
0: //                                pkg_major_change = true;
0: //                                fatal_package = pkgName;
0: //                                if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion)) {
0: //                                    pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));
0: //                                }
0: //                            } else if (minorChange.isChange()) {
0: //                                pkg_minor_change = true;
0: //                                if (fatal_package == null) fatal_package = pkgName;
0: //                                if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion)) {
0: //                                    pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
0: //                                }
0: //                            }
0: //                            pkgElements.append("\r\n");
0: //                        }
0: //                    }
0: //                }
0: //                // If there is a package version change, the bundle version needs to be updated.
0: //                // If there is a major change in one of the packages, the bundle major version needs to be increased.
0: //                // If there is a minor change in one of the packages, the bundle minor version needs to be increased.
0: //                String oldVersion = baseBundle.getBundleManifest().getVersion().toString();
0: //                String newVersion = currentBundle.getBundleManifest().getVersion().toString();
0: //
0: //
0: //                if (pkg_major_change || pkg_minor_change) {
0: //
0: //                    if (pkg_major_change) {
0: //                        // The bundle version's major value should be increased.
0: //                        reason = "Some packages have major changes. For an instance, the package " + fatal_package + " has major version changes.";
0: //                        bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, reason);
0: //                        bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
0: //                    } else if (pkg_minor_change) {
0: //                        reason = "Some packages have minor changes. For an instance, the package " + fatal_package + " has minor version changes.";
0: //                        bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion, reason);
0: //                        bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
0: //                    }
0: //                } else {
0: //                    reason = "The bundle has no version changes.";
0: //                    bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion, reason);
0: //                    bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
0: //                }
0: //            }
0: //            return this;
0: //        }
1: 
0:     public BundleCompatibility invoke() throws IOException {
0:         String reason = null;
0:         // open the manifest and scan the export package and find the package name and exported version
0:         // The tool assume the one particular package just exports under one version
0:         Map<String, PackageContent> currBundleExpPkgContents = getAllExportedPkgContents(currentBundle);
0:         Map<String, PackageContent> baseBundleExpPkgContents;
0:         boolean pkg_major_change = false;
0:         boolean pkg_minor_change = false;
0:         String fatal_package = null;
0:         if (!!!currBundleExpPkgContents.isEmpty()) {
0:             baseBundleExpPkgContents = getAllExportedPkgContents(baseBundle);
0:             // compare each class right now
0:             for (Map.Entry<String, PackageContent> pkg : baseBundleExpPkgContents.entrySet()) {
0:                 String pkgName = pkg.getKey();
0:                 Map<String, IFile> baseClazz = pkg.getValue().getClasses();
0:                 Map<String, IFile> baseXsds = pkg.getValue().getXsds();
0:                 PackageContent currPkgContents = currBundleExpPkgContents.get(pkgName);
0:                 if (currPkgContents == null) {
0:                     // The package is no longer exported any more. This should lead to bundle major version change.
0:                     pkg_major_change = true;
0:                     fatal_package = pkgName;
0:                     _logger.debug("The package " + pkgName + " in the bundle of " + bundleSymbolicName + " is no longer to be exported. Major change.");
0:                 } else {
0:                     Map<String, IFile> curClazz = currPkgContents.getClasses();
0:                     Map<String, IFile> curXsds = currPkgContents.getXsds();
0:                     //check whether there should be major change/minor change/micro change in this package.
0:                     //1. Use ASM to visit all classes in the package
0:                     VersionChange majorChange = new VersionChange();
0:                     VersionChange minorChange = new VersionChange();
0:                     // check all classes to see whether there are minor or major changes
0:                     visitPackage(pkgName, baseClazz, curClazz, majorChange, minorChange);
0:                     // If there is no binary compatibility changes, check whether xsd files have been added, changed or deleted
0:                     if (!!!majorChange.isChange()) {
0:                         checkXsdChangesInPkg(pkgName, baseXsds, curXsds, majorChange);
0:                         // If everything is ok with the existing classes. Need to find out whether there are more API (abstract classes) in the current bundle.
0:                         // loop through curClazz and visit it and find out whether one of them is abstract.
0:                         // check whether there are more xsd or abstract classes added
0:                         if (!!!(majorChange.isChange() || minorChange.isChange())) {
0:                             checkAdditionalClassOrXsds(pkgName, curClazz, curXsds, minorChange);
1:                         }
1:                     }
0:                     // We have scanned the whole packages, report the result
0:                     if (majorChange.isChange() || minorChange.isChange()) {
0:                         String oldVersion = pkg.getValue().getPackageVersion();
0:                         String newVersion = currPkgContents.getPackageVersion();
0:                         if (majorChange.isChange()) {
0:                             pkg_major_change = true;
0:                             fatal_package = pkgName;
0:                             if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion)) {
0:                                 pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, majorChange.getReason(), majorChange.getChangeClass()));
1:                             }
0:                         } else if (minorChange.isChange()) {
0:                             pkg_minor_change = true;
0:                             if (fatal_package == null) fatal_package = pkgName;
0:                             if (!!!isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion)) {
0:                                 pkgElements.append(getPkgStatusText(pkgName, VERSION_CHANGE_TYPE.MINOR_CHANGE, pkg.getValue().getPackageVersion(), currPkgContents.getPackageVersion(), minorChange.getReason(), minorChange.getChangeClass()));
1:                             }
1:                         }
0:                         pkgElements.append("\r\n");
1:                     }
1:                 }
1:             }
0:             // If there is a package version change, the bundle version needs to be updated.
0:             // If there is a major change in one of the packages, the bundle major version needs to be increased.
0:             // If there is a minor change in one of the packages, the bundle minor version needs to be increased.
0:             String oldVersion = baseBundle.getBundleManifest().getVersion().toString();
0:             String newVersion = currentBundle.getBundleManifest().getVersion().toString();
1: 
1: 
0:             if (pkg_major_change || pkg_minor_change) {
1: 
0:                 if (pkg_major_change) {
0:                     // The bundle version's major value should be increased.
0:                     reason = "Some packages have major changes. For an instance, the package " + fatal_package + " has major version changes.";
0:                     bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion, reason);
0:                     bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MAJOR_CHANGE, oldVersion, newVersion);
0:                 } else if (pkg_minor_change) {
0:                     reason = "Some packages have minor changes. For an instance, the package " + fatal_package + " has minor version changes.";
0:                     bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion, reason);
0:                     bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.MINOR_CHANGE, oldVersion, newVersion);
1:                 }
0:             } else {
0:                 reason = "The bundle has no version changes.";
0:                 bundleElement = getBundleStatusText(currentBundle.getBundle().getName(), bundleSymbolicName, VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion, reason);
0:                 bundleVersionCorrect = isVersionCorrect(VERSION_CHANGE_TYPE.NO_CHANGE, oldVersion, newVersion);
1:             }
1:         }
0:         return this;
1:     }
1: 
0:     private Map<String, PackageContent> getAllExportedPkgContents(BundleInfo currentBundle) {
0:         String packageExports = currentBundle.getBundleManifest().getRawAttributes().getValue(Constants.EXPORT_PACKAGE);
0:         List<ManifestHeaderProcessor.NameValuePair> exportPackageLists = ManifestHeaderProcessor.parseExportString(packageExports);
0:         // only perform validation if there are some packages exported. Otherwise, not interested.
0:         Map<String, PackageContent> exportedPackages = new HashMap<String, PackageContent>();
0:         if (!!!exportPackageLists.isEmpty()) {
0:             File bundleFile = currentBundle.getBundle();
0:             IDirectory bundleDir = FileSystem.getFSRoot(bundleFile);
0:             for (ManifestHeaderProcessor.NameValuePair exportedPackage : exportPackageLists) {
0:                 String packageName = exportedPackage.getName();
0:                 String packageVersion = exportedPackage.getAttributes().get(Constants.VERSION_ATTRIBUTE);
0:                 // need to go through each package and scan every class
0:                 exportedPackages.put(packageName, new PackageContent(packageName, packageVersion));
1:             }
0:             // scan the jar and list all the files under each package
0:             List<IFile> allFiles = bundleDir.listAllFiles();
0:             for (IFile file : allFiles) {
0:                 String directoryFullPath = file.getName();
0:                 String directoryName = null;
0:                 String fileName = null;
0:                 if (file.isFile() && ((file.getName().endsWith(SemanticVersioningUtils.classExt) || (file.getName().endsWith(SemanticVersioningUtils.schemaExt))))) {
0:                     if (directoryFullPath.lastIndexOf("/") != -1) {
0:                         directoryName = directoryFullPath.substring(0, directoryFullPath.lastIndexOf("/"));
0:                         fileName = directoryFullPath.substring(directoryFullPath.lastIndexOf("/") + 1);
1:                     }
1:                 }
1: 
0:                 if (directoryName != null) {
0:                     String pkgName = directoryName.replaceAll("/", ".");
0:                     PackageContent pkgContent = exportedPackages.get(pkgName);
0:                     if (pkgContent != null) {
0:                         if (file.getName().endsWith(SemanticVersioningUtils.classExt)) {
0:                             pkgContent.addClass(fileName, file);
0:                         } else {
0:                             pkgContent.addXsd(fileName, file);
1:                         }
0:                         exportedPackages.put(pkgName, pkgContent);
1:                     }
1:                 }
1:             }
1:         }
0:         return exportedPackages;
1:     }
1: 
0:     private String getBundleStatusText(String bundleFileName, String bundleSymbolicName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason) {
0:         return "<bundle fileName=\"" + bundleFileName + "\" bundleSymbolicName =\"" + bundleSymbolicName + "\"" + getStatusText(status, oldVersionStr, newVersionStr) + "\" reason=\"" + transformForXml(reason) + "\" change=\"" + status.text() + "\">";
1:     }
1: 
1:     /**
0:      * Visit the whole package to scan each class to see whether we need to log minor or major changes.
1:      *
0:      * @param pkgName
0:      * @param baseClazz
0:      * @param curClazz
0:      * @param majorChange
0:      * @param minorChange
1:      */
0:     private void visitPackage(String pkgName, Map<String, IFile> baseClazz,
0:                               Map<String, IFile> curClazz, VersionChange majorChange, VersionChange minorChange) {
0:         StringBuilder major_reason = new StringBuilder();
0:         StringBuilder minor_reason = new StringBuilder();
0:         boolean is_major_change = false;
0:         boolean is_minor_change = false;
0:         String fatal_class = null;
0:         boolean foundNewAbstract = false;
0:         for (Map.Entry<String, IFile> file : baseClazz.entrySet()) {
0:             // scan the latest version of the class
0:             IFile curFile = curClazz.get(file.getKey());
0:             String changeClass = file.getValue().getName();
0:             //Scan the base version
0:             SemanticVersioningClassVisitor oldcv = getVisitor(file.getValue(), oldJarsLoader);
0:             // skip the property files as they are compiled as class file as well
0:             ClassDeclaration cd = oldcv.getClassDeclaration();
0:             if ((cd != null) && (!SemanticVersioningUtils.isPropertyFile(cd))) {
1: 
0:                 if (curFile == null) {
0:                     // the class we are scanning has been deleted from the current version of WAS
0:                     // This should be a major increase
0:                     major_reason.append(htmlTwoLineBreaks + "The class/interface " + getClassName(changeClass) + " has been deleted from the package.");
0:                     //majorChange.update(reason, changeClass);
0:                     is_major_change = true;
0:                     // only replace the fatal class if not set as the class won't be found in cmvc due to the fact it has been deleted.
0:                     if (fatal_class == null) {
0:                         fatal_class = changeClass;
1:                     }
0:                 } else {
0:                     // check for binary compatibility
0:                     // load the class from the current version of WAS
0:                     // remove it from the curClazz collection as we would like to know whether there are more classes added
0:                     curClazz.remove(file.getKey());
0:                     SemanticVersioningClassVisitor newcv = getVisitor(curFile, newJarsLoader);
0:                     // check for binary compatibility
0:                     ClassDeclaration newcd = newcv.getClassDeclaration();
0:                     BinaryCompatibilityStatus bcs = newcd.getBinaryCompatibleStatus(oldcv.getClassDeclaration());
1: 
0:                     if (!bcs.isCompatible()) {
0:                         major_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following changes have been made since the last release.");
0:                         // break binary compatibility
0:                         for (String reason : bcs) {
0:                             major_reason.append(htmlOneLineBreak).append(reason);
1:                         }
0:                         is_major_change = true;
0:                         fatal_class = changeClass;
0:                     } else {
0:                         //check to see whether more methods are added
0:                         ClassDeclaration oldcd = oldcv.getClassDeclaration();
0:                         Collection<MethodDeclaration> extraMethods = newcd.getExtraMethods(oldcd);
1: 
0:                         boolean containsConcrete = false;
0:                         boolean containsAbstract = false;
1: 
0:                         boolean abstractClass = newcd.isAbstract();
1: 
0:                         StringBuilder subRemarks = new StringBuilder();
0:                         String concreteSubRemarks = null;
0:                         for (MethodDeclaration extraMethod : extraMethods) {
0:                             //only interested in the visible methods not the system generated ones
0:                             if (!extraMethod.getName().contains("$")) {
0:                                 if (abstractClass) {
0:                                     if (extraMethod.isAbstract()) {
0:                                         foundNewAbstract = true;
0:                                         containsAbstract = true;
0:                                         subRemarks.append(htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc()));
0:                                     } else {
0:                                         //only list one abstract method, no need to list all
0:                                         containsConcrete = true;
0:                                         concreteSubRemarks = htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
1:                                     }
0:                                 } else {
0:                                     containsConcrete = true;
0:                                     concreteSubRemarks = htmlOneLineBreak + SemanticVersioningUtils.getReadableMethodSignature(extraMethod.getName(), extraMethod.getDesc());
0:                                     break;
1:                                 }
1:                             }
1:                         }
1: 
0:                         if (containsConcrete || containsAbstract) {
0:                             is_minor_change = true;
0:                             if (!is_major_change) {
0:                                 fatal_class = changeClass;
1:                             }
0:                             if (containsAbstract) {
1: 
0:                                 minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following abstract methods have been added since the last release of WAS.");
0:                                 minor_reason.append(subRemarks);
0:                             } else {
0:                                 minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following method has been added since the last release of WAS.");
0:                                 minor_reason.append(concreteSubRemarks);
1:                             }
1:                         }
0:                         //check to see whether there are extra public/protected fields if there is no additional methods
1: 
0:                         if (!is_minor_change) {
0:                             for (FieldDeclaration field : newcd.getExtraFields(oldcd)) {
0:                                 if (field.isPublic() || field.isProtected()) {
0:                                     is_minor_change = true;
0:                                     String extraFieldRemarks = htmlOneLineBreak + " " + SemanticVersioningUtils.transform(field.getDesc()) + " " + field.getName();
0:                                     if (!is_major_change) {
0:                                         fatal_class = changeClass;
1:                                     }
0:                                     minor_reason.append(htmlTwoLineBreaks + "In the " + getClassName(changeClass) + " class or its supers, the following fields have been added since the last release of WAS.");
0:                                     minor_reason.append(extraFieldRemarks);
0:                                     break;
1:                                 }
1:                             }
1: 
1:                         }
1: 
1:                     }
1:                 }
1:             }
1:         }
0:         if (is_major_change) {
0:             majorChange.update(major_reason.toString(), fatal_class, false);
1:         }
0:         if (is_minor_change) {
0:             minorChange.update(minor_reason.toString(), fatal_class, (foundNewAbstract ? true : false));
1:         }
1:     }
1: 
1:     /**
0:      * Check whether the package has xsd file changes or deleted. If yes, log a minor change.
1:      *
0:      * @param pkgName
0:      * @param baseXsds
0:      * @param curXsds
0:      * @param majorChange
0:      * @throws java.io.IOException
1:      */
1: 
0:     private void checkXsdChangesInPkg(String pkgName, Map<String, IFile> baseXsds,
0:                                       Map<String, IFile> curXsds, VersionChange majorChange) throws IOException {
0:         String reason;
0:         for (Map.Entry<String, IFile> file : baseXsds.entrySet()) {
0:             // scan the latest version of the class
0:             IFile curXsd = curXsds.get(file.getKey());
0:             String changeClass = file.getValue().getName();
0:             // check whether the xsd have been deleted or changed or added
0:             if (curXsd == null) {
0:                 reason = "In the package " + pkgName + ", The schema file has been deleted: " + file.getKey() + ".";
0:                 majorChange.update(reason, changeClass, false);
0:                 break;
0:             } else {
0:                 // check whether it is the same
0:                 //read the current xsd file
0:                 curXsds.remove(file.getKey());
0:                 String curFileContent = readXsdFile(curXsd.open());
0:                 String oldFileContent = readXsdFile(file.getValue().open());
0:                 if (!!!(curFileContent.equals(oldFileContent))) {
1: 
0:                     reason = "In the package " + pkgName + ", The schema file has been updated: " + file.getKey() + ".";
0:                     majorChange.update(reason, changeClass, false);
0:                     break;
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
0:      * Check whether the package has gained additional class or xsd files. If yes, log a minor change.
1:      *
0:      * @param pkgName
0:      * @param curClazz
0:      * @param curXsds
0:      * @param minorChange
1:      */
0:     private void checkAdditionalClassOrXsds(String pkgName, Map<String, IFile> curClazz,
0:                                             Map<String, IFile> curXsds, VersionChange minorChange) {
0:         String reason;
0:         Collection<IFile> ifiles = curClazz.values();
0:         Iterator<IFile> iterator = ifiles.iterator();
0:         while (iterator.hasNext()) {
0:             IFile ifile = iterator.next();
0:             String changeClass = ifile.getName();
0:             SemanticVersioningClassVisitor cv = getVisitor(ifile, newJarsLoader);
0:             if (cv.getClassDeclaration() != null) {
0:                 // If this is a public/protected class, it will need to increase the minor version of the package.
0:                 minorChange.setChange(true);
0:                 if (minorChange.isChange()) {
0:                     reason = "The package " + pkgName + " has gained at least one class : " + getClassName(changeClass) + ".";
0:                     minorChange.update(reason, changeClass, false);
0:                     break;
1:                 }
1:             }
1:         }
0:         if (!!!(minorChange.isChange() || curXsds.isEmpty())) {
0:             /// a new xsd file was added, it is a minor change
0:             IFile firstXsd = null;
0:             Iterator<IFile> xsdIterator = curXsds.values().iterator();
0:             firstXsd = xsdIterator.next();
1: 
0:             reason = "In the package " + pkgName + ", The schema file(s) are added: " + curXsds.keySet() + ".";
0:             minorChange.update(reason, firstXsd.getName(), false);
1:         }
1:     }
1: 
0:     static boolean isVersionCorrect(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
0:         boolean versionCorrect = false;
1: 
0:         Version oldVersion = Version.parseVersion(oldVersionStr);
0:         Version newVersion = Version.parseVersion(newVersionStr);
1: 
0:         if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:             if (newVersion.getMajor() > oldVersion.getMajor()) {
0:                 versionCorrect = true;
1:             }
0:         } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
0:             if ((newVersion.getMajor() > oldVersion.getMajor()) || (newVersion.getMinor() > oldVersion.getMinor())) {
0:                 versionCorrect = true;
1:             }
0:         } else {
0:             if ((newVersion.getMajor() == oldVersion.getMajor()) && (newVersion.getMinor() == oldVersion.getMinor())) {
0:                 versionCorrect = true;
1:             }
1:         }
0:         return versionCorrect;
1:     }
1: 
0:     private String getPkgStatusText(String pkgName, VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr, String reason, String key_class) {
1: 
0:         String modified_key_class = key_class;
0:         if (key_class.endsWith(SemanticVersioningUtils.classExt)) {
0:             modified_key_class = key_class.substring(0, key_class.lastIndexOf(SemanticVersioningUtils.classExt)) + SemanticVersioningUtils.javaExt;
1:         }
1: 
0:         return "<package name=\"" + pkgName + "\"" + getStatusText(status, oldVersionStr, newVersionStr) + "\" reason=\"" + transformForXml(reason) + "\" key_class=\"" + modified_key_class + "\" change=\"" + status.text() + "\"/>";
1:     }
1: 
0:     private String getStatusText(VERSION_CHANGE_TYPE status, String oldVersionStr, String newVersionStr) {
1: 
0:         Version oldVersion = Version.parseVersion(oldVersionStr);
0:         Version newVersion = Version.parseVersion(newVersionStr);
0:         Version recommendedVersion = Version.parseVersion(oldVersionStr);
0:         if (status == VERSION_CHANGE_TYPE.MAJOR_CHANGE) {
0:             recommendedVersion = new Version(oldVersion.getMajor() + 1, 0, 0);
0:         } else if (status == VERSION_CHANGE_TYPE.MINOR_CHANGE) {
0:             recommendedVersion = new Version(oldVersion.getMajor(), oldVersion.getMinor() + 1, 0);
0:         } else {
0:             recommendedVersion = oldVersion;
1:         }
0:         return " oldVersion=\"" + oldVersion
0:                 + "\" currentVersion=\"" + newVersion +
0:                 "\" recommendedVersion=\"" + recommendedVersion + "\" correct=\"" + BundleCompatibility.isVersionCorrect(status, oldVersionStr, newVersionStr);
1:     }
1: 
0:     private String transformForXml(String str) {
0:         str = str.replaceAll("<", "&lt;");
0:         str = str.replaceAll(">", "&gt;");
0:         return str;
1:     }
1: 
0:     private String getClassName(String fullClassPath) {
0:         String[] chunks = fullClassPath.split("/");
0:         String className = chunks[chunks.length - 1];
0:         className = className.replace(SemanticVersioningUtils.classExt, SemanticVersioningUtils.javaExt);
0:         return className;
1:     }
1: 
0:     private String readXsdFile(InputStream is) {
0:         BufferedReader br = new BufferedReader(new InputStreamReader(is));
0:         StringBuilder sb = new StringBuilder();
0:         String line = null;
0:         try {
0:             while ((line = br.readLine()) != null) {
0:                 sb.append(line);
1:             }
0:         } catch (IOException ioe) {
0:             IOUtils.close(br);
1:         }
0:         return sb.toString();
1:     }
1: 
0:     private SemanticVersioningClassVisitor getVisitor(IFile file, URLClassLoader loader) {
0:         SemanticVersioningClassVisitor oldcv = new SemanticVersioningClassVisitor(loader);
0:         try {
0:             ClassReader cr = new ClassReader(file.open());
0:             cr.accept(oldcv, 0);
0:         } catch (IOException ioe) {
0:             _logger.debug("The file " + file + "cannot be opened.");
1:         }
0:         return oldcv;
1:     }
1: 
0:     enum VERSION_CHANGE_TYPE {
0:         MAJOR_CHANGE("major"), MINOR_CHANGE("minor"), NO_CHANGE("no");
0:         private final String text;
1: 
0:         VERSION_CHANGE_TYPE(String text) {
0:             this.text = text;
1:         }
1: 
0:         public String text() {
0:             return this.text;
1:         }
1: 
1:     }
1: 
0:     private static class PackageContent {
0:         private final String packageName;
0:         private final String packageVersion;
0:         private final Map<String, IFile> classes = new HashMap<String, IFile>();
0:         private final Map<String, IFile> xsds = new HashMap<String, IFile>();
1: 
0:         PackageContent(String pkgName, String pkgVersion) {
0:             packageName = pkgName;
0:             packageVersion = pkgVersion;
1:         }
1: 
0:         public void addClass(String className, IFile file) {
0:             classes.put(className, file);
1:         }
1: 
0:         public void addXsd(String className, IFile file) {
0:             xsds.put(className, file);
1:         }
1: 
0:         public Map<String, IFile> getClasses() {
0:             return classes;
1:         }
1: 
0:         public Map<String, IFile> getXsds() {
0:             return xsds;
1:         }
1: 
0:         public String getPackageVersion() {
0:             return packageVersion;
1:         }
1: 
0:         public String getPackageName() {
0:             return packageName;
1:         }
1:     }
1: 
0:     private static class VersionChange {
0:         boolean change = false;
0:         String reason = null;
0:         String changeClass = null;
0:         boolean moreAbstractMethod = false;
1: 
1: 
0:         public boolean isMoreAbstractMethod() {
0:             return moreAbstractMethod;
1:         }
1: 
0:         public boolean isChange() {
0:             return change;
1:         }
1: 
0:         public void setChange(boolean change) {
0:             this.change = change;
1:         }
1: 
0:         public String getReason() {
0:             return reason;
1:         }
1: 
0:         public String getChangeClass() {
0:             return changeClass;
1:         }
1: 
0:         public void update(String reason, String changeClass, boolean moreAbstractMethod) {
0:             this.change = true;
0:             this.reason = reason;
0:             this.changeClass = changeClass;
0:             this.moreAbstractMethod = moreAbstractMethod;
1:         }
1:     }
1: 
1: }
============================================================================