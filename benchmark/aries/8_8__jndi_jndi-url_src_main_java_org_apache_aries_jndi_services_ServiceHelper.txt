1:fc02f66: /*
1:fc02f66:  * Licensed to the Apache Software Foundation (ASF) under one
1:fc02f66:  * or more contributor license agreements.  See the NOTICE file
1:fc02f66:  * distributed with this work for additional information
1:fc02f66:  * regarding copyright ownership.  The ASF licenses this file
1:fc02f66:  * to you under the Apache License, Version 2.0 (the
1:fc02f66:  * "License"); you may not use this file except in compliance
1:fc02f66:  * with the License.  You may obtain a copy of the License at
8:fc02f66:  *
1:fc02f66:  *   http://www.apache.org/licenses/LICENSE-2.0
1:fc02f66:  *
1:fc02f66:  * Unless required by applicable law or agreed to in writing,
1:fc02f66:  * software distributed under the License is distributed on an
1:3c19a77:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:fc02f66:  * KIND, either express or implied.  See the License for the
1:fc02f66:  * specific language governing permissions and limitations
1:fc02f66:  * under the License.
9:fc02f66:  */
1:fc02f66: package org.apache.aries.jndi.services;
2:b792590: 
1:2ed6d5c: import java.lang.ref.WeakReference;
1:2ed6d5c: import java.security.AccessController;
1:2ed6d5c: import java.security.PrivilegedAction;
1:e9395b8: import java.util.ArrayList;
1:e100639: import java.util.Arrays;
1:25c259c: import java.util.Collection;
1:e100639: import java.util.Comparator;
1:caa372f: import java.util.HashSet;
1:2ed6d5c: import java.util.Iterator;
1:fc02f66: import java.util.List;
1:e9395b8: import java.util.Map;
1:caa372f: import java.util.Set;
1:f8842fe: import java.util.concurrent.Callable;
1:2ed6d5c: import java.util.concurrent.ConcurrentHashMap;
1:2ed6d5c: import java.util.concurrent.ConcurrentMap;
1:b792590: 
1:e9395b8: import javax.naming.NamingException;
1:b792590: 
1:e19d5ba: import org.apache.aries.jndi.url.Activator;
1:ba5ec82: import org.apache.aries.jndi.url.OsgiName;
1:e19d5ba: import org.apache.aries.proxy.ProxyManager;
1:e19d5ba: import org.apache.aries.proxy.UnableToProxyException;
1:9c42dfb: import org.apache.aries.util.nls.MessageUtil;
1:e9395b8: import org.osgi.framework.Bundle;
1:fc02f66: import org.osgi.framework.BundleContext;
1:2ed6d5c: import org.osgi.framework.BundleEvent;
1:2ed6d5c: import org.osgi.framework.BundleListener;
1:47d7c2a: import org.osgi.framework.Constants;
1:fc02f66: import org.osgi.framework.InvalidSyntaxException;
1:2ed6d5c: import org.osgi.framework.ServiceEvent;
1:e9395b8: import org.osgi.framework.ServiceException;
1:2ed6d5c: import org.osgi.framework.ServiceListener;
1:fc02f66: import org.osgi.framework.ServiceReference;
1:696374b: import org.osgi.service.jndi.JNDIConstants;
1:b792590: 
1:e0757f1: /**
1:fc02f66:  * This helper provides access to services registered in the OSGi service registry.
1:fc02f66:  * If a matching service cannot be located null may be returned. A caller should not
1:fc02f66:  * expect to get the same object if multiple requests are made to this API. A caller
1:fc02f66:  * should not expect to get a different object if multiple requests are made to this API.
1:fc02f66:  * A caller should avoid caching the returned service. OSGi is a dynamic environment and
1:fc02f66:  * the service may become unavailable while a reference to it is held. To minimize this
1:fc02f66:  * risk the caller should hold onto the service for the minimum length of time.
1:fc02f66:  * 
1:fc02f66:  * <p>This API should not be used from within an OSGi bundle. When in an OSGi environment
1:fc02f66:  *   the BundleContext for the bundle should be used to obtain the service.
1:fc02f66:  * </p>
1:e0757f1:  */
1:2ed6d5c: public final class ServiceHelper
2:2ed6d5c: {
1:2ed6d5c:   public static final class CacheClearoutListener implements BundleListener, ServiceListener
1:2ed6d5c:   {
1:2ed6d5c:     /** The cache to purge */
1:2ed6d5c:     private final ConcurrentMap<ServiceKey, WeakReference<Object>> cache;
1:b792590: 
1:b792590: 
1:2ed6d5c:     public CacheClearoutListener(ConcurrentMap<ServiceKey, WeakReference<Object>> pc)
1:2ed6d5c:     {
1:2ed6d5c:       cache = pc;
1:b792590:     }
1:5240f2a: 
1:2ed6d5c:     public void bundleChanged(BundleEvent event)
1:2ed6d5c:     {
1:2ed6d5c:       if (event.getType() == BundleEvent.STOPPED) {
1:2ed6d5c:         Bundle b = event.getBundle();
1:2ed6d5c:         Iterator<ServiceKey> keys = cache.keySet().iterator();
1:2ed6d5c:         while (keys.hasNext()) {
1:2ed6d5c:           ServiceKey key = keys.next();
1:2ed6d5c:           if (key.requesting == b) keys.remove();
1:2ed6d5c:         }
1:2ed6d5c:       }
1:5240f2a:     }
1:b792590: 
1:2ed6d5c:     public void serviceChanged(ServiceEvent event)
1:2ed6d5c:     {
1:2ed6d5c:       if (event.getType() == ServiceEvent.UNREGISTERING) {
1:2ed6d5c:         ServiceReference ref = event.getServiceReference();
1:2ed6d5c:         Long serviceId = (Long) ref.getProperty(Constants.SERVICE_ID);
1:2ed6d5c:         Bundle registeringBundle = ref.getBundle();
1:2ed6d5c:         Iterator<ServiceKey> keys = cache.keySet().iterator();
1:2ed6d5c:         while (keys.hasNext()) {
1:2ed6d5c:           ServiceKey key = keys.next();
1:2ed6d5c:           if (key.registering == registeringBundle && serviceId.equals(key.serviceId)) {
1:2ed6d5c:             keys.remove();
1:2ed6d5c:             break;
1:2ed6d5c:           }
1:2ed6d5c:         }
1:b792590:       }
1:b792590:     }
1:b792590: 
1:2ed6d5c:     public void add(final BundleContext ctx, ServiceKey k)
1:2ed6d5c:     {
1:2ed6d5c:       // try to use the system bundle for our listener, if that fails we fall back to the calling context
1:2ed6d5c:       BundleContext systemBundle = AccessController.doPrivileged(new PrivilegedAction<BundleContext>() {
1:2ed6d5c:         public BundleContext run()
1:2ed6d5c:         {
1:fa4f318:         	 Bundle system = ctx.getBundle(0); 
1:fa4f318:         	 return system == null ? null : system.getBundleContext(); 
1:2ed6d5c:         }
1:2ed6d5c:       });
1:2ed6d5c:       if (systemBundle == null) systemBundle = ctx;
1:2ed6d5c:       systemBundle.addBundleListener(cacheClearoutListener);
1:2ed6d5c:       systemBundle.addServiceListener(cacheClearoutListener);
1:2ed6d5c:     }
1:2ed6d5c:   }
1:2ed6d5c: 
1:2ed6d5c:   private static final class ServiceKey
1:2ed6d5c:   {
1:2ed6d5c:     private final Bundle requesting;
1:2ed6d5c:     private final Bundle registering;
1:2ed6d5c:     private final Long serviceId;
1:2ed6d5c:     private final int hash;
1:2ed6d5c: 
1:2ed6d5c:     public ServiceKey(Bundle owningBundle, Bundle registeringBundle, Long property)
1:2ed6d5c:     {
1:2ed6d5c:       requesting = owningBundle;
1:2ed6d5c:       registering = registeringBundle;
1:2ed6d5c:       serviceId = property;
1:2ed6d5c:       hash = serviceId.intValue() * 100003 + System.identityHashCode(requesting);
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     public int hashCode()
1:2ed6d5c:     {
1:2ed6d5c:       return hash;
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     public boolean equals(Object other)
1:2ed6d5c:     {
1:2ed6d5c:       if (other == this) return true;
1:2ed6d5c:       if (other == null) return false;
1:2ed6d5c: 
1:2ed6d5c:       if (other instanceof ServiceKey) {
1:2ed6d5c:         ServiceKey otherKey = (ServiceKey) other;
1:2ed6d5c:         return (otherKey.requesting == requesting && otherKey.serviceId.equals(serviceId));
1:2ed6d5c:       }
1:2ed6d5c: 
1:2ed6d5c:       return false;
1:2ed6d5c:     }
1:2ed6d5c:   }
1:2ed6d5c: 
1:f8842fe:   private static class JNDIServiceDamper implements Callable<Object>
1:2ed6d5c:   {
1:2ed6d5c:     private BundleContext ctx;
1:2ed6d5c:     private ServicePair pair;
1:2ed6d5c:     private String interfaceName;
1:2ed6d5c:     private String filter;
1:2ed6d5c:     private boolean dynamic;
1:c20c37b:     private int rebindTimeout;
1:2ed6d5c: 
1:2ed6d5c:     public JNDIServiceDamper(BundleContext context, String i, String f, ServicePair service,
1:c20c37b:         boolean d, int timeout)
1:2ed6d5c:     {
1:2ed6d5c:       ctx = context;
1:2ed6d5c:       pair = service;
1:2ed6d5c:       interfaceName = i;
1:2ed6d5c:       filter = f;
1:2ed6d5c:       dynamic = d;
1:c20c37b:       rebindTimeout = timeout;
1:2ed6d5c:     }
1:2ed6d5c: 
1:f8842fe:     public Object call() throws NamingException {
1:2ed6d5c:       if (pair == null || pair.ref.getBundle() == null) {
1:2ed6d5c:         if (dynamic) {
1:2ed6d5c:           pair = findService(ctx, interfaceName, filter);
1:c20c37b:           if (pair == null && rebindTimeout > 0) {
1:c20c37b:             long startTime = System.currentTimeMillis();
1:c20c37b:             try {
1:c20c37b:               while (pair == null && System.currentTimeMillis() - startTime < rebindTimeout) {
1:c20c37b:                 Thread.sleep(100);
1:c20c37b:                 pair = findService(ctx, interfaceName, filter);
1:c20c37b:               }
1:c20c37b:             } catch (InterruptedException e) {
1:c20c37b:             }
1:c20c37b:           }
1:e65b402:         } else {
1:2ed6d5c:           pair = null;
1:2ed6d5c:         }
1:2ed6d5c:       }
1:f935731: 
1:2ed6d5c:       if (pair == null) {
1:2ed6d5c:         throw new ServiceException(interfaceName, ServiceException.UNREGISTERED);
1:2ed6d5c:       }
1:f8842fe:       return pair.service;
1:2ed6d5c:     }
1:2ed6d5c:   }
1:b792590: 
1:2ed6d5c:   private static class ServicePair
1:2ed6d5c:   {
1:2ed6d5c:     private ServiceReference ref;
1:2ed6d5c:     private Object service;
1:2ed6d5c:   }
1:b792590: 
1:2ed6d5c:   /** A cache of proxies returned to the client */
1:2ed6d5c:   private static final ConcurrentMap<ServiceKey, WeakReference<Object>> proxyCache = new ConcurrentHashMap<ServiceKey, WeakReference<Object>>();
1:f8842fe:   private static final CacheClearoutListener cacheClearoutListener = new CacheClearoutListener(proxyCache);
1:2e8ed0b:   private static final MessageUtil MESSAGES = MessageUtil.createMessageUtil(ServiceHelper.class, "org.apache.aries.jndi.nls.jndiUrlMessages");
1:b792590: 
1:2ed6d5c:   public static Object getService(BundleContext ctx, OsgiName lookupName, String id,
1:f8842fe:                                   boolean dynamicRebind, Map<String, Object> env, boolean requireProxy) throws NamingException
1:2ed6d5c:   {    
1:2ed6d5c:     String interfaceName = lookupName.getInterface();
1:2ed6d5c:     String filter = lookupName.getFilter();
1:2ed6d5c:     String serviceName = lookupName.getServiceName();
1:ba5ec82: 
1:2ed6d5c:     if (id != null) {
1:2ed6d5c:       if (filter == null) {
1:2ed6d5c:         filter = '(' + Constants.SERVICE_ID + '=' + id + ')';
1:2ed6d5c:       } else {
1:2ed6d5c:         filter = "(&(" + Constants.SERVICE_ID + '=' + id + ')' + filter + ')';
1:2ed6d5c:       }
1:f935731:     }
1:ba5ec82: 
1:2ed6d5c:     ServicePair pair = null;
1:2ed6d5c: 
1:2ed6d5c:     if (!!!lookupName.isServiceNameBased()) {
1:2ed6d5c:       pair = findService(ctx, interfaceName, filter);
1:e456d8f:     }
1:2ed6d5c: 
1:2ed6d5c:     if (pair == null) {
1:2ed6d5c:       interfaceName = null;
1:2ed6d5c:       if (id == null) {
1:2ed6d5c:         filter = "(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + ')';
1:2ed6d5c:       } else {
1:2ed6d5c:         filter = "(&(" + Constants.SERVICE_ID + '=' + id + ")(" + JNDIConstants.JNDI_SERVICENAME
1:2ed6d5c:             + "=" + serviceName + "))";
1:2ed6d5c:       }
1:2ed6d5c:       pair = findService(ctx, interfaceName, filter);
1:b792590:     }
1:2ed6d5c: 
2:2ed6d5c:     Object result = null;
1:2ed6d5c:     
1:2ed6d5c:     if (pair != null) {
1:e65b402:       if (requireProxy) {
1:c20c37b:         Object obj = env.get(org.apache.aries.jndi.api.JNDIConstants.REBIND_TIMEOUT);
1:c20c37b:         int timeout = 0;
1:c20c37b:         if (obj instanceof String) {
1:c20c37b:           timeout = Integer.parseInt((String)obj);
1:c20c37b:         } else if (obj instanceof Integer) {
1:c20c37b:           timeout = (Integer)obj;
1:c20c37b:         }
1:c20c37b:         
1:c20c37b:         result = proxy(interfaceName, filter, dynamicRebind, ctx, pair, timeout);
1:b792590:       } else {
1:e65b402:         result = pair.service;
1:b792590:       }
1:b792590:     }
1:2ed6d5c: 
2:2ed6d5c:     return result;
1:2ed6d5c:   }
1:2ed6d5c: 
1:2ed6d5c:   private static Object proxy(final String interface1, final String filter, final boolean rebind,
1:c20c37b:                               final BundleContext ctx, final ServicePair pair, final int timeout)
1:2ed6d5c:   {
1:2ed6d5c:     Object result = null;
1:2ed6d5c:     Bundle owningBundle = ctx.getBundle();
1:e65b402:     ServiceKey k = new ServiceKey(owningBundle, pair.ref.getBundle(), (Long) pair.ref.getProperty(Constants.SERVICE_ID));
1:2ed6d5c: 
1:2ed6d5c:     WeakReference<Object> proxyRef = proxyCache.get(k);
1:2ed6d5c: 
1:2ed6d5c:     if (proxyRef != null) {
1:2ed6d5c:       result = proxyRef.get();
1:2ed6d5c:       if (result == null) {
1:2ed6d5c:         proxyCache.remove(k, proxyRef);
1:2ed6d5c:       }
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     if (result == null) {
1:2ed6d5c:       result = AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:2ed6d5c:         public Object run()
1:2ed6d5c:         {
1:25c259c:           return proxyPrivileged(interface1, filter, rebind, ctx, pair, timeout);
1:2ed6d5c:         }
1:2ed6d5c:       });
1:2ed6d5c: 
1:2ed6d5c:       proxyRef = new WeakReference<Object>(result);
1:2ed6d5c:       // if we have two threads doing a put and then clashing we ignore it. The code to ensure only
1:2ed6d5c:       // one wins is quite complex to save a few bytes of memory and millis of execution time.
1:2ed6d5c:       proxyCache.putIfAbsent(k, proxyRef);
1:2ed6d5c:       cacheClearoutListener.add(ctx, k);
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     return result;
1:2ed6d5c:   }
1:2ed6d5c: 
1:25c259c:   private static Object proxyPrivileged(String interface1, String filter, boolean dynamicRebind, BundleContext ctx, ServicePair pair, int timeout)
1:2ed6d5c:   {
1:2ed6d5c:     String[] interfaces = null;
1:2ed6d5c:     if (interface1 != null) {
1:2ed6d5c:       interfaces = new String[] { interface1 };
1:2ed6d5c:     } else {
1:2ed6d5c:       interfaces = (String[]) pair.ref.getProperty(Constants.OBJECTCLASS);
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     List<Class<?>> clazz = new ArrayList<Class<?>>(interfaces.length);
1:2ed6d5c: 
1:25c259c:     // We load the interface classes the service is registered under using the defining bundle. 
1:25c259c:     // This is ok because the service must be able to see the classes to be registered using them. 
1:25c259c:     // We then check to see if isAssignableTo on the reference  works for the owning bundle and 
1:25c259c:     // the interface name and only use the interface if true is returned there.
1:2ed6d5c: 
1:25c259c:     // This might seem odd, but equinox and felix return true for isAssignableTo if the 
1:25c259c:     // Bundle provided does not import the package. This is under the assumption the
1:25c259c:     // caller will then use reflection. The upshot of doing it this way is that a utility
1:25c259c:     // bundle can be created which centralizes JNDI lookups, but the service will be used
1:25c259c:     // by another bundle. It is true that class space consistency is less safe, but we
1:2ed6d5c:     // are enabling a slightly odd use case anyway.
1:25c259c:     
1:25c259c:     // August 13th 2013: We've found valid use cases in which a Bundle is exporting 
1:25c259c:     // services that the Bundle itself cannot load. We deal with this rare case by
1:25c259c:     // noting the classes that we failed to load. If as a result we have no classes 
1:25c259c:     // to proxy, we try those classes again but instead pull the Class objects off 
1:25c259c:     // the service rather than from the bundle exporting that service. 
1:2ed6d5c: 
1:2ed6d5c:     Bundle serviceProviderBundle = pair.ref.getBundle();
1:2ed6d5c:     Bundle owningBundle = ctx.getBundle();
1:e19d5ba:     ProxyManager proxyManager = Activator.getProxyManager();
1:2ed6d5c: 
1:25c259c:     Collection<String> classesNotFound = new ArrayList<String>();
1:2ed6d5c:     for (String interfaceName : interfaces) {
1:2ed6d5c:       try {
1:2ed6d5c:         Class<?> potentialClass = serviceProviderBundle.loadClass(interfaceName);
1:2ed6d5c:         if (pair.ref.isAssignableTo(owningBundle, interfaceName)) {
1:2ed6d5c:           clazz.add(potentialClass);
1:2ed6d5c:         }
1:2ed6d5c:       } catch (ClassNotFoundException e) {
1:25c259c:       	classesNotFound.add(interfaceName);
1:2ed6d5c:       }
1:2ed6d5c:     }
1:25c259c:     
1:25c259c:     if (clazz.isEmpty() && !classesNotFound.isEmpty()) { 
1:25c259c: 			Class<?> ifacesOnService[] = ctx.getService(pair.ref).getClass().getInterfaces();
1:25c259c:     	for (String interfaceName : classesNotFound) {
1:25c259c:     		Class<?> thisClass = null;
1:caa372f:     		for (Class<?> c : getAllInterfaces(ifacesOnService)) { 
1:caa372f:     			if (c.getName().equals(interfaceName)) { 
1:25c259c:     				thisClass = c;
1:caa372f:     				break;
1:25c259c:     			}
1:25c259c:     		}
1:25c259c:     		if (thisClass != null) { 
1:25c259c:     			if (pair.ref.isAssignableTo(owningBundle, interfaceName)) {
1:25c259c:     				clazz.add(thisClass);
1:25c259c:     			}
1:25c259c:     		}
1:25c259c:     	}
1:25c259c:     }
1:25c259c:     
1:2ed6d5c:     if (clazz.isEmpty()) {
1:2ed6d5c:       throw new IllegalArgumentException(Arrays.asList(interfaces).toString());
1:2ed6d5c:     }
1:2ed6d5c: 
1:c20c37b:     Callable<Object> ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind, timeout);
1:2ed6d5c: 
1:2ed6d5c:     // The ClassLoader needs to be able to load the service interface
1:2ed6d5c:     // classes so it needs to be
1:2ed6d5c:     // wrapping the service provider bundle. The class is actually defined
1:2ed6d5c:     // on this adapter.
1:2ed6d5c: 
1:2ed6d5c:     try {
1:1e75fdb:       return proxyManager.createDelegatingProxy(serviceProviderBundle, clazz, ih, null);
1:e19d5ba:     } catch (UnableToProxyException e) {
1:e19d5ba:       throw new IllegalArgumentException(e);
1:e65b402:     } catch (RuntimeException e) {
1:9c42dfb:       throw new IllegalArgumentException(MESSAGES.getMessage("unable.to.create.proxy", pair.ref), e);
1:2ed6d5c:     }
1:f935731:   }
1:2ed6d5c: 
1:2ed6d5c:   private static ServicePair findService(BundleContext ctx, String interface1, String filter)
1:2ed6d5c:       throws NamingException
1:2ed6d5c:   {
1:2ed6d5c:     ServicePair p = null;
1:2ed6d5c: 
1:2ed6d5c:     try {
1:2ed6d5c:       ServiceReference[] refs = ctx.getServiceReferences(interface1, filter);
1:2ed6d5c: 
1:2ed6d5c:       if (refs != null) {
1:2ed6d5c:         // natural order is the exact opposite of the order we desire.
1:2ed6d5c:         Arrays.sort(refs, new Comparator<ServiceReference>() {
1:2ed6d5c:           public int compare(ServiceReference o1, ServiceReference o2)
1:2ed6d5c:           {
1:2ed6d5c:             return o2.compareTo(o1);
1:2ed6d5c:           }
1:2ed6d5c:         });
1:2ed6d5c: 
1:2ed6d5c:         for (ServiceReference ref : refs) {
1:2ed6d5c:           Object service = ctx.getService(ref);
1:2ed6d5c: 
2:2ed6d5c:           if (service != null) {
1:2ed6d5c:             p = new ServicePair();
1:2ed6d5c:             p.ref = ref;
1:2ed6d5c:             p.service = service;
1:2ed6d5c:             break;
1:2ed6d5c:           }
1:2ed6d5c:         }
1:2ed6d5c:       }
1:2ed6d5c: 
1:2ed6d5c:     } catch (InvalidSyntaxException e) {
1:2ed6d5c:       // If we get an invalid syntax exception we just ignore it. Null
1:2ed6d5c:       // will be returned which
1:2ed6d5c:       // is valid and that may result in a NameNotFoundException if that
1:2ed6d5c:       // is the right thing to do
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     return p;
1:2ed6d5c:   }
1:2ed6d5c: 
1:2ed6d5c:   public static ServiceReference[] getServiceReferences(BundleContext ctx, String interface1,
1:2ed6d5c:       String filter, String serviceName, Map<String, Object> env) throws NamingException
1:2ed6d5c:   {
1:2ed6d5c:     ServiceReference[] refs = null;
1:2ed6d5c: 
1:2ed6d5c:     try {
1:2ed6d5c:       refs = ctx.getServiceReferences(interface1, filter);
1:2ed6d5c: 
1:2ed6d5c:       if (refs == null || refs.length == 0) {
1:b49a314:         refs = ctx.getServiceReferences((String) null, "(" + JNDIConstants.JNDI_SERVICENAME + "="
1:2ed6d5c:             + serviceName + ')');
1:2ed6d5c:       }
1:2ed6d5c:     } catch (InvalidSyntaxException e) {
1:2ed6d5c:       throw (NamingException) new NamingException(e.getFilter()).initCause(e);
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     if (refs != null) {
1:2ed6d5c:       // natural order is the exact opposite of the order we desire.
1:2ed6d5c:       Arrays.sort(refs, new Comparator<ServiceReference>() {
1:2ed6d5c:         public int compare(ServiceReference o1, ServiceReference o2)
1:2ed6d5c:         {
1:2ed6d5c:           return o2.compareTo(o1);
1:2ed6d5c:         }
1:2ed6d5c:       });
1:2ed6d5c:     }
1:2ed6d5c: 
1:2ed6d5c:     return refs;
1:2ed6d5c:   }
1:2ed6d5c: 
1:2ed6d5c:   public static Object getService(BundleContext ctx, ServiceReference ref)
1:2ed6d5c:   {
1:2ed6d5c:     Object service = ctx.getService(ref);
1:08490c1:     if (service == null) {
1:08490c1:       return null;
1:2ed6d5c:     }
1:2ed6d5c: 
1:08490c1:     ServicePair pair = new ServicePair();
1:08490c1:     pair.ref = ref;
1:08490c1:     pair.service = service;
1:08490c1:     return proxy(null, null, false, ctx, pair, 0);
1:2ed6d5c:   }
1:2ed6d5c:  
1:caa372f:   static Collection<Class<?>> getAllInterfaces (Class<?>[] baseInterfaces) 
1:caa372f:   {
1:caa372f:   	Set<Class<?>> result = new HashSet<Class<?>>();
1:caa372f:   	for (Class<?> c : baseInterfaces) {
1:caa372f:   		if (!c.equals(Object.class)) { 
1:caa372f:   			result.add (c);
1:caa372f:   			Class<?> ifaces[] = c.getInterfaces();
1:caa372f:   			if (ifaces.length != 0) { 
1:caa372f:   				result.addAll(getAllInterfaces(ifaces));
1:caa372f:   			}
1:caa372f:   		}
1:caa372f:   	}
1:caa372f:   	return result;
1:caa372f:   }
1:5240f2a: }
============================================================================
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:b49a314
/////////////////////////////////////////////////////////////////////////
1:         refs = ctx.getServiceReferences((String) null, "(" + JNDIConstants.JNDI_SERVICENAME + "="
author:Christian Schneider
-------------------------------------------------------------------------------
commit:08490c1
/////////////////////////////////////////////////////////////////////////
1:     if (service == null) {
1:       return null;
1:     ServicePair pair = new ServicePair();
1:     pair.ref = ref;
1:     pair.service = service;
1:     return proxy(null, null, false, ctx, pair, 0);
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:caa372f
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     		for (Class<?> c : getAllInterfaces(ifacesOnService)) { 
1:     			if (c.getName().equals(interfaceName)) { 
1:     				break;
/////////////////////////////////////////////////////////////////////////
1:   static Collection<Class<?>> getAllInterfaces (Class<?>[] baseInterfaces) 
1:   {
1:   	Set<Class<?>> result = new HashSet<Class<?>>();
1:   	for (Class<?> c : baseInterfaces) {
1:   		if (!c.equals(Object.class)) { 
1:   			result.add (c);
1:   			Class<?> ifaces[] = c.getInterfaces();
1:   			if (ifaces.length != 0) { 
1:   				result.addAll(getAllInterfaces(ifaces));
1:   			}
1:   		}
1:   	}
1:   	return result;
1:   }
commit:25c259c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:           return proxyPrivileged(interface1, filter, rebind, ctx, pair, timeout);
/////////////////////////////////////////////////////////////////////////
1:   private static Object proxyPrivileged(String interface1, String filter, boolean dynamicRebind, BundleContext ctx, ServicePair pair, int timeout)
/////////////////////////////////////////////////////////////////////////
1:     // We load the interface classes the service is registered under using the defining bundle. 
1:     // This is ok because the service must be able to see the classes to be registered using them. 
1:     // We then check to see if isAssignableTo on the reference  works for the owning bundle and 
1:     // the interface name and only use the interface if true is returned there.
1:     // This might seem odd, but equinox and felix return true for isAssignableTo if the 
1:     // Bundle provided does not import the package. This is under the assumption the
1:     // caller will then use reflection. The upshot of doing it this way is that a utility
1:     // bundle can be created which centralizes JNDI lookups, but the service will be used
1:     // by another bundle. It is true that class space consistency is less safe, but we
1:     
1:     // August 13th 2013: We've found valid use cases in which a Bundle is exporting 
1:     // services that the Bundle itself cannot load. We deal with this rare case by
1:     // noting the classes that we failed to load. If as a result we have no classes 
1:     // to proxy, we try those classes again but instead pull the Class objects off 
1:     // the service rather than from the bundle exporting that service. 
1:     Collection<String> classesNotFound = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:       	classesNotFound.add(interfaceName);
1:     
1:     if (clazz.isEmpty() && !classesNotFound.isEmpty()) { 
1: 			Class<?> ifacesOnService[] = ctx.getService(pair.ref).getClass().getInterfaces();
1:     	for (String interfaceName : classesNotFound) {
1:     		Class<?> thisClass = null;
0:     		for (Class<?> c : ifacesOnService) { 
0:     			inner: if (c.getName().equals(interfaceName)) { 
1:     				thisClass = c;
0:     				break inner;
1:     			}
1:     		}
1:     		if (thisClass != null) { 
1:     			if (pair.ref.isAssignableTo(owningBundle, interfaceName)) {
1:     				clazz.add(thisClass);
1:     			}
1:     		}
1:     	}
1:     }
1:     
commit:fa4f318
/////////////////////////////////////////////////////////////////////////
1:         	 Bundle system = ctx.getBundle(0); 
1:         	 return system == null ? null : system.getBundleContext(); 
author:Jeremy Hughes
-------------------------------------------------------------------------------
commit:2e8ed0b
/////////////////////////////////////////////////////////////////////////
1:   private static final MessageUtil MESSAGES = MessageUtil.createMessageUtil(ServiceHelper.class, "org.apache.aries.jndi.nls.jndiUrlMessages");
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:9c42dfb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.nls.MessageUtil;
/////////////////////////////////////////////////////////////////////////
0:   public static final MessageUtil MESSAGES = MessageUtil.createMessageUtil(ServiceHelper.class, "org.apache.aries.jndi.nls.jndiUrlMessages");
/////////////////////////////////////////////////////////////////////////
1:       throw new IllegalArgumentException(MESSAGES.getMessage("unable.to.create.proxy", pair.ref), e);
commit:c20c37b
/////////////////////////////////////////////////////////////////////////
1:     private int rebindTimeout;
1:         boolean d, int timeout)
1:       rebindTimeout = timeout;
1:           if (pair == null && rebindTimeout > 0) {
1:             long startTime = System.currentTimeMillis();
1:             try {
1:               while (pair == null && System.currentTimeMillis() - startTime < rebindTimeout) {
1:                 Thread.sleep(100);
1:                 pair = findService(ctx, interfaceName, filter);
1:               }
1:             } catch (InterruptedException e) {
1:             }
1:           }
/////////////////////////////////////////////////////////////////////////
1:         Object obj = env.get(org.apache.aries.jndi.api.JNDIConstants.REBIND_TIMEOUT);
1:         int timeout = 0;
1:         if (obj instanceof String) {
1:           timeout = Integer.parseInt((String)obj);
1:         } else if (obj instanceof Integer) {
1:           timeout = (Integer)obj;
1:         }
1:         
1:         result = proxy(interfaceName, filter, dynamicRebind, ctx, pair, timeout);
/////////////////////////////////////////////////////////////////////////
1:                               final BundleContext ctx, final ServicePair pair, final int timeout)
/////////////////////////////////////////////////////////////////////////
0:           return proxyPriviledged(interface1, filter, rebind, ctx, pair, timeout);
/////////////////////////////////////////////////////////////////////////
0:   private static Object proxyPriviledged(String interface1, String filter, boolean dynamicRebind, BundleContext ctx, ServicePair pair, int timeout)
/////////////////////////////////////////////////////////////////////////
1:     Callable<Object> ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind, timeout);
/////////////////////////////////////////////////////////////////////////
0:       result = proxy(null, null, false, ctx, pair, 0);
commit:e19d5ba
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.jndi.url.Activator;
1: import org.apache.aries.proxy.ProxyManager;
1: import org.apache.aries.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     ProxyManager proxyManager = Activator.getProxyManager();
/////////////////////////////////////////////////////////////////////////
0:       return proxyManager.createProxy(serviceProviderBundle, clazz, ih);
1:     } catch (UnableToProxyException e) {
1:       throw new IllegalArgumentException(e);
/////////////////////////////////////////////////////////////////////////
commit:5abc961
/////////////////////////////////////////////////////////////////////////
0:       return proxyFactory.createProxy(serviceProviderBundle, clazz, ih);
/////////////////////////////////////////////////////////////////////////
0:         Class.forName("net.sf.cglib.proxy.Enhancer");
commit:2ed6d5c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.ref.WeakReference;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.util.Iterator;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.BundleEvent;
1: import org.osgi.framework.BundleListener;
1: import org.osgi.framework.ServiceEvent;
1: import org.osgi.framework.ServiceListener;
/////////////////////////////////////////////////////////////////////////
1: public final class ServiceHelper
1: {
1:   public static final class CacheClearoutListener implements BundleListener, ServiceListener
1:   {
1:     /** The cache to purge */
1:     private final ConcurrentMap<ServiceKey, WeakReference<Object>> cache;
1:     public CacheClearoutListener(ConcurrentMap<ServiceKey, WeakReference<Object>> pc)
1:     {
1:       cache = pc;
1:     public void bundleChanged(BundleEvent event)
1:     {
1:       if (event.getType() == BundleEvent.STOPPED) {
1:         Bundle b = event.getBundle();
1:         Iterator<ServiceKey> keys = cache.keySet().iterator();
1:         while (keys.hasNext()) {
1:           ServiceKey key = keys.next();
1:           if (key.requesting == b) keys.remove();
1:         }
1:       }
1:     public void serviceChanged(ServiceEvent event)
1:     {
1:       if (event.getType() == ServiceEvent.UNREGISTERING) {
1:         ServiceReference ref = event.getServiceReference();
1:         Long serviceId = (Long) ref.getProperty(Constants.SERVICE_ID);
1:         Bundle registeringBundle = ref.getBundle();
1:         Iterator<ServiceKey> keys = cache.keySet().iterator();
1:         while (keys.hasNext()) {
1:           ServiceKey key = keys.next();
1:           if (key.registering == registeringBundle && serviceId.equals(key.serviceId)) {
1:             keys.remove();
1:             break;
1:           }
1:       }
1:     public void add(final BundleContext ctx, ServiceKey k)
1:     {
1:       // try to use the system bundle for our listener, if that fails we fall back to the calling context
1:       BundleContext systemBundle = AccessController.doPrivileged(new PrivilegedAction<BundleContext>() {
1:         public BundleContext run()
1:         {
0:           return ctx.getBundle(0).getBundleContext();
1:         }
1:       });
1:       if (systemBundle == null) systemBundle = ctx;
1:       systemBundle.addBundleListener(cacheClearoutListener);
1:       systemBundle.addServiceListener(cacheClearoutListener);
1:     }
1:   }
1: 
1:   private static final class ServiceKey
1:   {
1:     private final Bundle requesting;
1:     private final Bundle registering;
1:     private final Long serviceId;
1:     private final int hash;
1: 
1:     public ServiceKey(Bundle owningBundle, Bundle registeringBundle, Long property)
1:     {
1:       requesting = owningBundle;
1:       registering = registeringBundle;
1:       serviceId = property;
1:       hash = serviceId.intValue() * 100003 + System.identityHashCode(requesting);
1:     }
1: 
1:     public int hashCode()
1:     {
1:       return hash;
1:     }
1: 
1:     public boolean equals(Object other)
1:     {
1:       if (other == this) return true;
1:       if (other == null) return false;
1: 
1:       if (other instanceof ServiceKey) {
1:         ServiceKey otherKey = (ServiceKey) other;
1:         return (otherKey.requesting == requesting && otherKey.serviceId.equals(serviceId));
1:       }
1: 
1:       return false;
1:     }
1:   }
1: 
0:   private static class JNDIServiceDamper implements InvocationHandler
1:   {
1:     private BundleContext ctx;
1:     private ServicePair pair;
1:     private String interfaceName;
1:     private String filter;
1:     private boolean dynamic;
1: 
1:     public JNDIServiceDamper(BundleContext context, String i, String f, ServicePair service,
0:         boolean d)
1:     {
1:       ctx = context;
1:       pair = service;
1:       interfaceName = i;
1:       filter = f;
1:       dynamic = d;
1:     }
1: 
0:     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
1:     {
1:       if (pair == null || pair.ref.getBundle() == null) {
1:         if (dynamic) {
1:           pair = findService(ctx, interfaceName, filter);
1:           pair = null;
1:       }
1:       if (pair == null) {
1:         throw new ServiceException(interfaceName, ServiceException.UNREGISTERED);
1:       }
1:       try {
0:         return method.invoke(pair.service, args);
0:       } catch (InvocationTargetException ite) {
0:         throw ite.getTargetException();
1:       }
1:     }
1:   }
1:   private static class ServicePair
1:   {
1:     private ServiceReference ref;
1:     private Object service;
1:   }
1:   /** A cache of proxies returned to the client */
1:   private static final ConcurrentMap<ServiceKey, WeakReference<Object>> proxyCache = new ConcurrentHashMap<ServiceKey, WeakReference<Object>>();
0:   private static final CacheClearoutListener cacheClearoutListener = new CacheClearoutListener(
0:       proxyCache);
1:   public static Object getService(BundleContext ctx, OsgiName lookupName, String id,
0:       boolean dynamicRebind, Map<String, Object> env) throws NamingException
1:   {
1:     Object result = null;
1:     String interfaceName = lookupName.getInterface();
1:     String filter = lookupName.getFilter();
1:     String serviceName = lookupName.getServiceName();
1:     if (id != null) {
1:       if (filter == null) {
1:         filter = '(' + Constants.SERVICE_ID + '=' + id + ')';
1:       } else {
1:         filter = "(&(" + Constants.SERVICE_ID + '=' + id + ')' + filter + ')';
1:       }
1:     ServicePair pair = null;
1:     if (!!!lookupName.isServiceNameBased()) {
1:       pair = findService(ctx, interfaceName, filter);
1:     if (pair == null) {
1:       interfaceName = null;
1:       if (id == null) {
1:         filter = "(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + ')';
1:       } else {
1:         filter = "(&(" + Constants.SERVICE_ID + '=' + id + ")(" + JNDIConstants.JNDI_SERVICENAME
1:             + "=" + serviceName + "))";
1:       }
1:       pair = findService(ctx, interfaceName, filter);
1:     if (pair != null) {
0:       result = proxy(interfaceName, filter, dynamicRebind, ctx, pair);
1:     return result;
1:   }
1: 
1:   private static Object proxy(final String interface1, final String filter, final boolean rebind,
0:       final BundleContext ctx, final ServicePair pair)
1:   {
1:     Object result = null;
1:     Bundle owningBundle = ctx.getBundle();
0:     ServiceKey k = new ServiceKey(owningBundle, pair.ref.getBundle(), (Long) pair.ref
0:         .getProperty(Constants.SERVICE_ID));
1: 
1:     WeakReference<Object> proxyRef = proxyCache.get(k);
1: 
1:     if (proxyRef != null) {
1:       result = proxyRef.get();
1:       if (result == null) {
1:         proxyCache.remove(k, proxyRef);
1:       }
1:     }
1: 
1:     if (result == null) {
1:       result = AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:         public Object run()
1:         {
0:           return proxyPriviledged(interface1, filter, rebind, ctx, pair);
1:         }
1:       });
1: 
1:       proxyRef = new WeakReference<Object>(result);
1:       // if we have two threads doing a put and then clashing we ignore it. The code to ensure only
1:       // one wins is quite complex to save a few bytes of memory and millis of execution time.
1:       proxyCache.putIfAbsent(k, proxyRef);
1:       cacheClearoutListener.add(ctx, k);
1:     }
1: 
1:     return result;
1:   }
1: 
0:   private static Object proxyPriviledged(String interface1, String filter, boolean dynamicRebind,
0:       BundleContext ctx, ServicePair pair)
1:   {
1:     String[] interfaces = null;
1:     if (interface1 != null) {
1:       interfaces = new String[] { interface1 };
1:     } else {
1:       interfaces = (String[]) pair.ref.getProperty(Constants.OBJECTCLASS);
1:     }
1: 
1:     List<Class<?>> clazz = new ArrayList<Class<?>>(interfaces.length);
1: 
0:     // We load the interface classes the service is registered under using
0:     // the defining
0:     // bundle. This is ok because the service must be able to see the
0:     // classes to be
0:     // registered using them. We then check to see if isAssignableTo on the
0:     // reference
0:     // works for the owning bundle and the interface name and only use the
0:     // interface if
0:     // true is returned there.
1: 
0:     // This might seem odd, but equinox and felix return true for
0:     // isAssignableTo if the
0:     // Bundle provided does not import the package. This is under the
0:     // assumption the
0:     // caller will then use reflection. The upshot of doing it this way is
0:     // that a utility
0:     // bundle can be created which centralizes JNDI lookups, but the service
0:     // will be used
0:     // by another bundle. It is true that class space consistency is less
0:     // safe, but we
1:     // are enabling a slightly odd use case anyway.
1: 
1:     Bundle serviceProviderBundle = pair.ref.getBundle();
1:     Bundle owningBundle = ctx.getBundle();
1: 
1:     for (String interfaceName : interfaces) {
1:       try {
1:         Class<?> potentialClass = serviceProviderBundle.loadClass(interfaceName);
1: 
1:         if (pair.ref.isAssignableTo(owningBundle, interfaceName)) {
1:           clazz.add(potentialClass);
1:         }
1:       } catch (ClassNotFoundException e) {
1:       }
1:     }
1: 
1:     if (clazz.isEmpty()) {
1:       throw new IllegalArgumentException(Arrays.asList(interfaces).toString());
1:     }
1: 
0:     InvocationHandler ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind);
1: 
1:     // The ClassLoader needs to be able to load the service interface
1:     // classes so it needs to be
1:     // wrapping the service provider bundle. The class is actually defined
1:     // on this adapter.
1: 
0:     return Proxy.newProxyInstance(new BundleToClassLoaderAdapter(serviceProviderBundle), clazz
0:         .toArray(new Class<?>[clazz.size()]), ih);
1:   }
1: 
1:   private static ServicePair findService(BundleContext ctx, String interface1, String filter)
1:       throws NamingException
1:   {
1:     ServicePair p = null;
1: 
1:     try {
1:       ServiceReference[] refs = ctx.getServiceReferences(interface1, filter);
1: 
1:       if (refs != null) {
1:         // natural order is the exact opposite of the order we desire.
1:         Arrays.sort(refs, new Comparator<ServiceReference>() {
1:           public int compare(ServiceReference o1, ServiceReference o2)
1:           {
1:             return o2.compareTo(o1);
1:           }
1:         });
1: 
1:         for (ServiceReference ref : refs) {
1:           Object service = ctx.getService(ref);
1: 
1:           if (service != null) {
1:             p = new ServicePair();
1:             p.ref = ref;
1:             p.service = service;
1:             break;
1:           }
1:         }
1:       }
1: 
1:     } catch (InvalidSyntaxException e) {
1:       // If we get an invalid syntax exception we just ignore it. Null
1:       // will be returned which
1:       // is valid and that may result in a NameNotFoundException if that
1:       // is the right thing to do
1:     }
1: 
1:     return p;
1:   }
1: 
1:   public static ServiceReference[] getServiceReferences(BundleContext ctx, String interface1,
1:       String filter, String serviceName, Map<String, Object> env) throws NamingException
1:   {
1:     ServiceReference[] refs = null;
1: 
1:     try {
1:       refs = ctx.getServiceReferences(interface1, filter);
1: 
1:       if (refs == null || refs.length == 0) {
0:         refs = ctx.getServiceReferences(null, "(" + JNDIConstants.JNDI_SERVICENAME + "="
1:             + serviceName + ')');
1:       }
1:     } catch (InvalidSyntaxException e) {
1:       throw (NamingException) new NamingException(e.getFilter()).initCause(e);
1:     }
1: 
1:     if (refs != null) {
1:       // natural order is the exact opposite of the order we desire.
1:       Arrays.sort(refs, new Comparator<ServiceReference>() {
1:         public int compare(ServiceReference o1, ServiceReference o2)
1:         {
1:           return o2.compareTo(o1);
1:         }
1:       });
1:     }
1: 
1:     return refs;
1:   }
1: 
1:   public static Object getService(BundleContext ctx, ServiceReference ref)
1:   {
1:     Object service = ctx.getService(ref);
1: 
1:     Object result = null;
1: 
1:     if (service != null) {
0:       ServicePair pair = new ServicePair();
0:       pair.ref = ref;
0:       pair.service = service;
1: 
0:       result = proxy(null, null, false, ctx, pair);
1:     }
1: 
1:     return result;
1:   }
1: 
commit:ba5ec82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.jndi.url.OsgiName;
/////////////////////////////////////////////////////////////////////////
0:   public static Object getService(OsgiName lookupName, String id, boolean dynamicRebind, Map<String, Object> env) throws NamingException
0:     String interfaceName = lookupName.getInterface();
0:     String filter = lookupName.getFilter();
0:     String serviceName = lookupName.getServiceName();
1:     
/////////////////////////////////////////////////////////////////////////
0:     ServicePair pair = null;
1:     
0:     if (!!!lookupName.isServiceNameBased()) pair = findService(ctx, interfaceName, filter);
0:       interfaceName = null;
0:       pair = findService(ctx, interfaceName, filter);
0:       result = proxy(interfaceName, filter, dynamicRebind, ctx, pair);
/////////////////////////////////////////////////////////////////////////
0:       // If we get an invalid syntax exception we just ignore it. Null will be returned which
0:       // is valid and that may result in a NameNotFoundException if that is the right thing to do
commit:f935731
/////////////////////////////////////////////////////////////////////////
0:   private static BundleContext getBundleContext(final ClassLoader cl2)
0:     return AccessController.doPrivileged(new PrivilegedAction<BundleContext>() {
0:       public BundleContext run()
0:       {
0:         ClassLoader cl = cl2;
0:         BundleContext result = null;
0:         while (result == null && cl != null) {
0:           if (cl instanceof BundleReference) {
0:             result = ((BundleReference)cl).getBundle().getBundleContext();
0:           } else if (cl != null) {
0:             cl = cl.getParent();
1:           }
1:         }
1:         
0:         return result;
0:     });
commit:e456d8f
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
0:       try {
0:         return method.invoke(pair.service, args);
0:       } catch (InvocationTargetException ite) {
0:         throw ite.getTargetException();
1:       }
commit:5240f2a
/////////////////////////////////////////////////////////////////////////
1:   
0:   private static Object proxy(final String interface1, final String filter, final boolean rebind, 
0:                               final BundleContext ctx, final ServicePair pair)
0:   {
0:     return AccessController.doPrivileged(new PrivilegedAction<Object>() {
0:       public Object run()
0:       {
0:         return proxyPriviledged(interface1, filter, rebind, ctx, pair);
1:       }
0:     });
1:   }
0:   private static Object proxyPriviledged(String interface1, String filter, boolean dynamicRebind,
commit:b792590
/////////////////////////////////////////////////////////////////////////
0:         if (!!!foundLookup && ("lookup".equals(stackTrace[i].getMethodName()) ||
0:                                "list".equals(stackTrace[i].getMethodName()) ||
0:                                "listBindings".equals(stackTrace[i].getMethodName()))) {
/////////////////////////////////////////////////////////////////////////
0:   public static Object getService(String interface1, String filter, String serviceName, String id, boolean dynamicRebind, Map<String, Object> env) throws NamingException
0:     if (id != null && filter == null) {
0:       filter = '(' + Constants.SERVICE_ID + '=' + id + ')';
0:     } else if (id != null && filter != null) {
0:       filter = "(&(" + Constants.SERVICE_ID + '=' + id + ')' + filter + ')'; 
1:     }
1:     
0:       if (id == null) {
0:         filter = "(osgi.jndi.service.name=" + serviceName + ')';
1:       } else {
0:         filter = "(&(" + Constants.SERVICE_ID + '=' + id + ")(osgi.jndi.service.name=" + serviceName + "))";
1:       }
0:       result = proxy(interface1, filter, dynamicRebind, ctx, pair);
0:   private static Object proxy(String interface1, String filter, boolean dynamicRebind,
0:       BundleContext ctx, ServicePair pair)
0:   {
0:     Object result;
0:     String[] interfaces = (String[]) pair.ref.getProperty(Constants.OBJECTCLASS);
1:     
0:     List<Class<?>> clazz = new ArrayList<Class<?>>(interfaces.length);
1:     
0:     // We load the interface classes the service is registered under using the defining
0:     // bundle. This is ok because the service must be able to see the classes to be 
0:     // registered using them. We then check to see if isAssignableTo on the reference
0:     // works for the owning bundle and the interface name and only use the interface if
0:     // true is returned there.
1:     
0:     // This might seem odd, but equinox and felix return true for isAssignableTo if the
0:     // Bundle provided does not import the package. This is under the assumption the
0:     // caller will then use reflection. The upshot of doing it this way is that a utility
0:     // bundle can be created which centralizes JNDI lookups, but the service will be used
0:     // by another bundle. It is true that class space consistency is less safe, but we
0:     // are enabling a slightly odd use case anyway.
1:     
0:     Bundle serviceProviderBundle = pair.ref.getBundle();
0:     Bundle owningBundle = ctx.getBundle();
1:     
0:     for (String interfaceName : interfaces) {
0:       try {
0:         Class<?> potentialClass = serviceProviderBundle.loadClass(interfaceName);
1:         
0:         if (pair.ref.isAssignableTo(owningBundle, interfaceName)) clazz.add(potentialClass);
0:       } catch (ClassNotFoundException e) {
1:       }
1:     }
1:     
0:     if (clazz.isEmpty()) {
0:       throw new IllegalArgumentException(Arrays.asList(interfaces).toString());
1:     }
1:     
0:     InvocationHandler ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind);
1:     
0:     // The ClassLoader needs to be able to load the service interface classes so it needs to be
0:     // wrapping the service provider bundle. The class is actually defined on this adapter.
1:     
0:     result = Proxy.newProxyInstance(new BundleToClassLoaderAdapter(serviceProviderBundle), clazz.toArray(new Class<?>[clazz.size()]), ih);
0:     return result;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:   public static ServiceReference[] getServiceReferences(String interface1, String filter,
0:       String serviceName, Map<String, Object> env) throws NamingException
0:   {
0:     BundleContext ctx = getBundleContext(env);
0:     ServiceReference[] refs = null;
0: 
0:     try {
0:       refs = ctx.getServiceReferences(interface1, filter);
0:       
0:       if (refs == null || refs.length == 0) {
0:         refs = ctx.getServiceReferences(null, "(osgi.jndi.service.name=" + serviceName + ')');
0:       }
0:     } catch (InvalidSyntaxException e) {
0:       throw (NamingException) new NamingException(e.getFilter()).initCause(e);
0:     }
0:     
0:     if (refs != null) {
0:       // natural order is the exact opposite of the order we desire.
0:       Arrays.sort(refs, new Comparator<ServiceReference>() {
0:         public int compare(ServiceReference o1, ServiceReference o2)
0:         {
0:           return o2.compareTo(o1);
0:         }
0:       });
0:     }
0:     
0:     return refs;
0:   }
0: 
0:   public static Object getService(BundleContext ctx, ServiceReference ref)
0:   {
0:     Object service = ctx.getService(ref);
0:     
0:     Object result = null;
0:     
0:     if (service != null) {
0:       ServicePair pair = new ServicePair();
0:       pair.ref = ref;
0:       pair.service = service;
0:       
0:       result = proxy(null, null, false, ctx, pair);
0:     }
0:     
0:     return result;
0:   }
0: 
commit:bf172b0
/////////////////////////////////////////////////////////////////////////
0:       // We load the interface classes the service is registered under using the defining
0:       // bundle. This is ok because the service must be able to see the classes to be 
0:       // registered using them. We then check to see if isAssignableTo on the reference
0:       // works for the owning bundle and the interface name and only use the interface if
0:       // true is returned there.
0:       
0:       // This might seem odd, but equinox and felix return true for isAssignableTo if the
0:       // Bundle provided does not import the package. This is under the assumption the
0:       // caller will then use reflection. The upshot of doing it this way is that a utility
0:       // bundle can be created which centralizes JNDI lookups, but the service will be used
0:       // by another bundle. It is true that class space consistency is less safe, but we
0:       // are enabling a slightly odd use case anyway.
0:       
/////////////////////////////////////////////////////////////////////////
0:       // The ClassLoader needs to be able to load the service interface classes so it needs to be
0:       // wrapping the service provider bundle. The class is actually defined on this adapter.
0:       
commit:b4109f9
/////////////////////////////////////////////////////////////////////////
0:       Bundle serviceProviderBundle = pair.ref.getBundle();
0:       Bundle owningBundle = ctx.getBundle();
0:           Class<?> potentialClass = serviceProviderBundle.loadClass(interfaceName);
0:           
0:           if (pair.ref.isAssignableTo(owningBundle, interfaceName)) clazz.add(potentialClass);
/////////////////////////////////////////////////////////////////////////
0:       // TODO not sure this is quite right, but it'll do for now
0:       result = Proxy.newProxyInstance(new BundleToClassLoaderAdapter(serviceProviderBundle), clazz.toArray(new Class<?>[clazz.size()]), ih);
/////////////////////////////////////////////////////////////////////////
0:         Bundle b = ctx.getBundle();
0:         
commit:47d7c2a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Constants;
/////////////////////////////////////////////////////////////////////////
0:       filter = "(osgi.jndi.service.name=" + serviceName + ")";
0:       String[] interfaces = (String[]) pair.ref.getProperty(Constants.OBJECTCLASS);
/////////////////////////////////////////////////////////////////////////
0:         throw new IllegalArgumentException(Arrays.asList(interfaces).toString());
/////////////////////////////////////////////////////////////////////////
0:   private static ServicePair findService(BundleContext ctx, String interface1, String filter) throws NamingException
/////////////////////////////////////////////////////////////////////////
0:       throw (NamingException) new NamingException(e.getMessage()).initCause(e);
commit:33282f3
/////////////////////////////////////////////////////////////////////////
0:       StackTraceElement[] stackTrace =  Thread.currentThread().getStackTrace();
/////////////////////////////////////////////////////////////////////////
0:         i--; // we need to move back an item because the previous loop leaves us one after where we wanted to be
commit:e9395b8
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationHandler;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.Proxy;
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
1: import java.util.ArrayList;
1: import java.util.Map;
1: import javax.naming.NamingException;
0: 
0: import org.apache.aries.util.BundleToClassLoaderAdapter;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.ServiceException;
/////////////////////////////////////////////////////////////////////////
0:   public static class StackFinder extends SecurityManager
0:     public Class<?>[] getClassContext()
0:     {
0:       return super.getClassContext();
0:     }
0:   }
0: 
0:   private static class JNDIServiceDamper implements InvocationHandler
0:   {
0:     private BundleContext ctx;
0:     private ServicePair pair;
0:     private String interfaceName;
0:     private String filter;
0:     private boolean dynamic;
0:     
0:     public JNDIServiceDamper(BundleContext context, String i, String f, ServicePair service, boolean d)
0:     {
0:       ctx = context;
0:       pair = service;
0:       interfaceName = i;
0:       filter = f;
0:       dynamic = d;
0:     }
0:     
0:     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
0:     {
0:       if (pair.ref.getBundle() == null) {
0:         if (dynamic) pair = findService(ctx, interfaceName, filter);
0:         else pair = null;
0:       }
0:       
0:       if (pair == null) {
0:         throw new ServiceException(interfaceName, ServiceException.UNREGISTERED);
0:       }
0:       
0:       return method.invoke(pair.service, args);
0:     }
0:   }
0:   
0:   private static class ServicePair
0:   {
0:     private ServiceReference ref;
0:     private Object service;
0:    * @param env 
0:    * @return the bundle context for the caller.
0:    * @throws NamingException 
0:   public static BundleContext getBundleContext(Map<String, Object> env) throws NamingException
0:     BundleContext result = null;
0:     
0:     Object bc = env.get("osgi.service.jndi.bundleContext");
0:     
0:     if (bc != null && bc instanceof BundleContext) result = (BundleContext) bc;
0:     else {
0:       ClassLoader cl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
0:         public ClassLoader run()
0:         {
0:           return Thread.currentThread().getContextClassLoader();
0:         }
0:       });
0:       result = getBundleContext(cl);
0:     if (result == null) {
0:       StackTraceElement[] stackTrace = AccessController.doPrivileged(new PrivilegedAction<StackTraceElement[]>() {
0:         public StackTraceElement[] run()
0:         {
0:           return Thread.currentThread().getStackTrace();
0:         }
0:       });
0:       
0:       StackFinder finder = new StackFinder();
0:       Class<?>[] classStack = finder.getClassContext();
0:       
0:       boolean found = false;
0:       boolean foundLookup = false;
0:       int i = 0;
0:       for (; i < stackTrace.length && !!!found; i++) {
0:         if (!!!foundLookup && "lookup".equals(stackTrace[i].getMethodName())) {
0:           foundLookup = true;
0:         } else if (foundLookup && !!!(stackTrace[i].getClassName().startsWith("org.apache.aries.jndi") ||
0:                                 stackTrace[i].getClassName().startsWith("javax.naming"))) {
0:           found = true;
0:         }
0:       }
0:       
0:       if (found) {
0:         Set<Integer> classLoadersChecked = new HashSet<Integer>();
0:         for (; i < classStack.length && result == null; i++) {
0:           ClassLoader cl = classStack[i].getClassLoader();
0:           int hash = System.identityHashCode(cl);
0:           if (!!!classLoadersChecked.contains(hash)) {
0:             classLoadersChecked.add(hash);
0:             result = getBundleContext(cl);
0:           }
0:         }
0:         // Now we walk the stack looking for the BundleContext
0:       }
0:     
0:     if (result == null) throw new NamingException("Unable to find BundleContext");
0:     
0:     return result;
0:   private static BundleContext getBundleContext(ClassLoader cl)
0:     BundleContext result = null;
0:     while (result == null && cl != null) {
0:       if (cl instanceof BundleReference) {
0:         result = ((BundleReference)cl).getBundle().getBundleContext();
0:       } else if (cl != null) {
0:         cl = cl.getParent();
0:       }
0:     }
0:     
0:     return result;
0:   }
0: 
0:   public static Object getService(String interface1, String filter, String serviceName, boolean dynamicRebind, Map<String, Object> env) throws NamingException
0:   {
0:     Object result = null;
0:     
0:     BundleContext ctx = getBundleContext(env);
0:     
0:     ServicePair pair = findService(ctx, interface1, filter);
0:     
0:     if (pair == null) {
0:       interface1 = null;
0:       filter = "(osgi.jndi.serviceName=" + serviceName + ")";
0:       pair = findService(ctx, interface1, filter);
0:     }
0:     
0:     if (pair != null) {
0:       String[] interfaces = (String[]) pair.ref.getProperty("objectClass");
0:       
0:       List<Class<?>> clazz = new ArrayList<Class<?>>(interfaces.length);
0:       
0:       Bundle b = ctx.getBundle();
0:       
0:       for (String interfaceName : interfaces) {
0:         try {
0:           clazz.add(b.loadClass(interfaceName));
0:         } catch (ClassNotFoundException e) {
0:           // TODO Auto-generated catch block
0:           e.printStackTrace();
0:         }
0:       }
0:       
0:       if (clazz.isEmpty()) {
0:         throw new IllegalArgumentException();
0:       }
0:       
0:       InvocationHandler ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind);
0:       
0:       result = Proxy.newProxyInstance(new BundleToClassLoaderAdapter(b), clazz.toArray(new Class<?>[clazz.size()]), ih);
0:     }
0:     
0:     return result;
0:   }
0: 
0:   private static ServicePair findService(BundleContext ctx, String interface1, String filter)
0:   {
0:     ServicePair p = null;
0:     
0:       ServiceReference[] refs = ctx.getServiceReferences(interface1, filter);
0:         // natural order is the exact opposite of the order we desire.
/////////////////////////////////////////////////////////////////////////
0:           Object service = ctx.getService(ref);
0:           
0:           if (service != null) {
0:             p = new ServicePair();
0:             p.ref = ref;
0:             p.service = service;
0:       }
0:       
0:       // TODO Auto-generated catch block
0:       e.printStackTrace();
0:     return p;
commit:e100639
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Comparator;
/////////////////////////////////////////////////////////////////////////
0:       ServiceReference[] refs = callerCtx.getServiceReferences(className, filter);
0:         // we need to sort the references returned in case they are out of order
0:         // we need to sort in the reverse natural order, services with higher 
0:         // ranking or lower id should be processed first so should be earlier in the array.
0:         Arrays.sort(refs, new Comparator<ServiceReference>() {
0:           public int compare(ServiceReference o1, ServiceReference o2)
0:           {
0:             return o2.compareTo(o1);
0:           }
0:         });
0:         
commit:31e43eb
/////////////////////////////////////////////////////////////////////////
0:     BundleContext result = null;
0:     while (result == null && cl != null) {
0:       if (cl instanceof BundleReference) {
0:         result = ((BundleReference)cl).getBundle().getBundleContext();
0:       } else if (cl != null) {
0:         cl = cl.getParent();
0:       }
/////////////////////////////////////////////////////////////////////////
0: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:1e75fdb
/////////////////////////////////////////////////////////////////////////
1:       return proxyManager.createDelegatingProxy(serviceProviderBundle, clazz, ih, null);
commit:69e59b8
/////////////////////////////////////////////////////////////////////////
0:       return proxyManager.createDelegatingProxy(serviceProviderBundle, clazz, ih);
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:3602045
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     Class[] classArray = clazz.toArray(new Class[clazz.size()]);
0:       return proxyFactory.createProxy(serviceProviderBundle, classArray, ih);
/////////////////////////////////////////////////////////////////////////
0:  
commit:e65b402
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
0:   {    
/////////////////////////////////////////////////////////////////////////
0:     Object result = null;
0:     
1:       if (requireProxy) {
0:         result = proxy(interfaceName, filter, dynamicRebind, ctx, pair);
1:       } else {
1:         result = pair.service;
0:       }
0:                               final BundleContext ctx, final ServicePair pair)
1:     ServiceKey k = new ServiceKey(owningBundle, pair.ref.getBundle(), (Long) pair.ref.getProperty(Constants.SERVICE_ID));
/////////////////////////////////////////////////////////////////////////
0:           return proxyPriviledged(interface1, filter, rebind, ctx, pair);
/////////////////////////////////////////////////////////////////////////
0:   private static Object proxyPriviledged(String interface1, String filter, boolean dynamicRebind, BundleContext ctx, ServicePair pair)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       return proxyFactory.createProxy(new BundleToClassLoaderAdapter(serviceProviderBundle), toClassArray(clazz), ih);
0:       throw e;
1:     } catch (RuntimeException e) {
0:       throw new IllegalArgumentException("Unable to create proxy for " + pair.ref, e);
/////////////////////////////////////////////////////////////////////////
0:       result = proxy(null, null, false, ctx, pair);
/////////////////////////////////////////////////////////////////////////
0:   private static Class<?>[] getInterfaces(Class<?>[] classes) {
0:     Set<Class<?>> interfaces = new HashSet<Class<?>>();
0:     for (Class<?> clazz : classes) {
/////////////////////////////////////////////////////////////////////////
0:   private static Class<?>[] toClassArray(Collection<Class<?>> classes) {
/////////////////////////////////////////////////////////////////////////
0:       return Proxy.newProxyInstance(classLoader, classes, new InvocationHandler() {
commit:7b2544b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static Object getService(BundleContext ctx,
0:                                     OsgiName lookupName,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static Object proxy(String interface1,
0:                                 String filter,
0:                                 boolean dynamicRebind,
0:                                 BundleContext ctx,
0:                                 ServicePair pair) {
/////////////////////////////////////////////////////////////////////////
0:     public static ServiceReference[] getServiceReferences(BundleContext ctx,
0:                                                           String interface1,
commit:e0757f1
/////////////////////////////////////////////////////////////////////////
0: public final class ServiceHelper {
0:     
0:     public static class StackFinder extends SecurityManager {
0:         public Class<?>[] getClassContext() {
0:             return super.getClassContext();
0:         }
0:     private static class JNDIServiceDamper implements InvocationHandler {
0:         private BundleContext ctx;
0:         private ServicePair pair;
0: 
0:         private String interfaceName;
0: 
0:         private String filter;
0: 
0:         private boolean dynamic;
0: 
0:         public JNDIServiceDamper(BundleContext context,
0:                                  String i,
0:                                  String f,
0:                                  ServicePair service,
0:                                  boolean d) {
0:             ctx = context;
0:             pair = service;
0:             interfaceName = i;
0:             filter = f;
0:             dynamic = d;
0:         }
0: 
0:         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
0:             if (pair == null || pair.ref.getBundle() == null) {
0:                 if (dynamic) {
0:                     pair = findService(ctx, interfaceName, filter);
0:                 } else {
0:                     pair = null;
0:                 }
0:             }
0: 
0:             if (pair == null) {
0:                 throw new ServiceException(interfaceName, ServiceException.UNREGISTERED);
0:             }
0: 
0:             try {
0:                 return method.invoke(pair.service, args);
0:             } catch (InvocationTargetException ite) {
0:                 throw ite.getTargetException();
0:             }
0:         }
0:     }
0: 
0:     private static class ServicePair {
0:         private ServiceReference ref;
0:         private Object service;
0:     }
0: 
1:     /**
0:      * @param env
0:      * @return the bundle context for the caller.
0:      * @throws NamingException
1:      */
0:     public static BundleContext getBundleContext(Map<String, Object> env) throws NamingException {
0: 
0:         Object bc = env.get(JNDIConstants.BUNDLE_CONTEXT);
0: 
0:         if (bc != null && bc instanceof BundleContext) {
0:             result = (BundleContext) bc;
0:         } else {
0:             ClassLoader cl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
0:                 public ClassLoader run() {
0:                     return Thread.currentThread().getContextClassLoader();
0:                 }
0:             });
0: 
0:             result = getBundleContext(cl);
0:         }
0: 
0:         if (result == null) {
0:             StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
0: 
0:             StackFinder finder = new StackFinder();
0:             Class<?>[] classStack = finder.getClassContext();
0: 
0:             boolean found = false;
0:             boolean foundLookup = false;
0:             int i = 0;
0:             for (; i < stackTrace.length && !!!found; i++) {
0:                 if (!!!foundLookup
0:                     && ("lookup".equals(stackTrace[i].getMethodName())
0:                         || "list".equals(stackTrace[i].getMethodName()) 
0:                         || "listBindings".equals(stackTrace[i].getMethodName()))) {
0:                     foundLookup = true;
0:                 } else if (foundLookup
0:                            && !!!(stackTrace[i].getClassName().startsWith("org.apache.aries.jndi") 
0:                                    || stackTrace[i].getClassName().startsWith("javax.naming"))) {
0:                     found = true;
0:                 }
0:             }
0: 
0:             if (found) {
0:                 i--; // we need to move back an item because the previous loop
0:                      // leaves us one after where we wanted to be
0:                 Set<Integer> classLoadersChecked = new HashSet<Integer>();
0:                 for (; i < classStack.length && result == null; i++) {
0:                     ClassLoader cl = classStack[i].getClassLoader();
0:                     int hash = System.identityHashCode(cl);
0:                     if (!!!classLoadersChecked.contains(hash)) {
0:                         classLoadersChecked.add(hash);
0:                         result = getBundleContext(cl);
0:                     }
0:                 }
0:                 // Now we walk the stack looking for the BundleContext
0:             }
0:         }
0: 
0:         if (result == null) {
0:             throw new NamingException("Unable to find BundleContext");
0:     }
0:     private static BundleContext getBundleContext(final ClassLoader cl2) {
0:         return AccessController.doPrivileged(new PrivilegedAction<BundleContext>() {
0:             public BundleContext run() {
0:                 ClassLoader cl = cl2;
0:                 BundleContext result = null;
0:                 while (result == null && cl != null) {
0:                     if (cl instanceof BundleReference) {
0:                         result = ((BundleReference) cl).getBundle().getBundleContext();
0:                     } else if (cl != null) {
0:                         cl = cl.getParent();
0:                     }
0:                 }
0:                 return result;
0:             }
0:     }
0: 
0:     public static Object getService(OsgiName lookupName,
0:                                     String id,
0:                                     boolean dynamicRebind,
0:                                     Map<String, Object> env) throws NamingException {
0:         Object result = null;
0: 
0:         String interfaceName = lookupName.getInterface();
0:         String filter = lookupName.getFilter();
0:         String serviceName = lookupName.getServiceName();
0: 
0:         BundleContext ctx = getBundleContext(env);
0: 
0:         if (id != null) {
0:             if (filter == null) {
0:                 filter = '(' + Constants.SERVICE_ID + '=' + id + ')';
0:             } else {
0:                 filter = "(&(" + Constants.SERVICE_ID + '=' + id + ')' + filter + ')';
0:             }
0:         }
0: 
0:         ServicePair pair = null;
0: 
0:         if (!!!lookupName.isServiceNameBased()) {
0:             pair = findService(ctx, interfaceName, filter);
0:         }
0:         if (pair == null) {
0:             interfaceName = null;
0:             if (id == null) {
0:                 filter = "(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + ')';
0:             } else {
0:                 filter = "(&(" + Constants.SERVICE_ID + '=' + id + ")(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + "))";
0:             }
0:             pair = findService(ctx, interfaceName, filter);
0:         if (pair != null) {
0:             result = proxy(interfaceName, filter, dynamicRebind, ctx, pair);
0:         return result;
0: 
0:     private static Object proxy(final String interface1,
0:                                 final String filter,
0:                                 final boolean rebind,
0:                                 final BundleContext ctx,
0:                                 final ServicePair pair) {
0:         return AccessController.doPrivileged(new PrivilegedAction<Object>() {
0:             public Object run() {
0:                 return proxyPriviledged(interface1, filter, rebind, ctx, pair);
0:             }
0:         });
0:     }
0: 
0:     private static Object proxyPriviledged(String interface1,
0:                                            String filter,
0:                                            boolean dynamicRebind,
0:                                            BundleContext ctx,
0:                                            ServicePair pair) {
0:         String[] interfaces = null;   
0:         if (interface1 != null) {
0:             interfaces = new String [] { interface1 };
0:         } else {
0:             interfaces = (String[]) pair.ref.getProperty(Constants.OBJECTCLASS);
0:         }
0: 
0:         List<Class<?>> clazz = new ArrayList<Class<?>>(interfaces.length);
0: 
0:         // We load the interface classes the service is registered under using
0:         // the defining
0:         // bundle. This is ok because the service must be able to see the
0:         // classes to be
0:         // registered using them. We then check to see if isAssignableTo on the
0:         // reference
0:         // works for the owning bundle and the interface name and only use the
0:         // interface if
0:         // true is returned there.
0: 
0:         // This might seem odd, but equinox and felix return true for
0:         // isAssignableTo if the
0:         // Bundle provided does not import the package. This is under the
0:         // assumption the
0:         // caller will then use reflection. The upshot of doing it this way is
0:         // that a utility
0:         // bundle can be created which centralizes JNDI lookups, but the service
0:         // will be used
0:         // by another bundle. It is true that class space consistency is less
0:         // safe, but we
0:         // are enabling a slightly odd use case anyway.
0: 
0:         Bundle serviceProviderBundle = pair.ref.getBundle();
0:         Bundle owningBundle = ctx.getBundle();
0: 
0:         for (String interfaceName : interfaces) {
0:             try {
0:                 Class<?> potentialClass = serviceProviderBundle.loadClass(interfaceName);
0: 
0:                 if (pair.ref.isAssignableTo(owningBundle, interfaceName)) {
0:                     clazz.add(potentialClass);
0:                 }
0:             } catch (ClassNotFoundException e) {
0:             }
0:         }
0: 
0:         if (clazz.isEmpty()) {
0:             throw new IllegalArgumentException(Arrays.asList(interfaces).toString());
0:         }
0: 
0:         InvocationHandler ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind);
0: 
0:         // The ClassLoader needs to be able to load the service interface
0:         // classes so it needs to be
0:         // wrapping the service provider bundle. The class is actually defined
0:         // on this adapter.
0: 
0:         return Proxy.newProxyInstance(new BundleToClassLoaderAdapter(serviceProviderBundle),
0:                                       clazz.toArray(new Class<?>[clazz.size()]), 
0:                                       ih);
0:     }
0: 
0:     private static ServicePair findService(BundleContext ctx, String interface1, String filter)
0:             throws NamingException {
0:         ServicePair p = null;
0: 
0:         try {
0:             ServiceReference[] refs = ctx.getServiceReferences(interface1, filter);
0: 
0:             if (refs != null) {
0:                 // natural order is the exact opposite of the order we desire.
0:                 Arrays.sort(refs, new Comparator<ServiceReference>() {
0:                     public int compare(ServiceReference o1, ServiceReference o2) {
0:                         return o2.compareTo(o1);
0:                     }
0:                 });
0: 
0:                 for (ServiceReference ref : refs) {
0:                     Object service = ctx.getService(ref);
0: 
0:                     if (service != null) {
0:                         p = new ServicePair();
0:                         p.ref = ref;
0:                         p.service = service;
0:                         break;
0:                     }
0:                 }
0:             }
0: 
0:         } catch (InvalidSyntaxException e) {
0:             // If we get an invalid syntax exception we just ignore it. Null
0:             // will be returned which
0:             // is valid and that may result in a NameNotFoundException if that
0:             // is the right thing to do
0:         }
0: 
0:         return p;
0:     }
0: 
0:     public static ServiceReference[] getServiceReferences(String interface1,
0:                                                           String filter,
0:                                                           String serviceName,
0:                                                           Map<String, Object> env)
0:             throws NamingException {
0:         BundleContext ctx = getBundleContext(env);
0:         ServiceReference[] refs = null;
0: 
0:         try {
0:             refs = ctx.getServiceReferences(interface1, filter);
0: 
0:             if (refs == null || refs.length == 0) {
0:                 refs = ctx.getServiceReferences(null, "(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + ')');
0:             }
0:         } catch (InvalidSyntaxException e) {
0:             throw (NamingException) new NamingException(e.getFilter()).initCause(e);
0:         }
0: 
0:         if (refs != null) {
0:             // natural order is the exact opposite of the order we desire.
0:             Arrays.sort(refs, new Comparator<ServiceReference>() {
0:                 public int compare(ServiceReference o1, ServiceReference o2) {
0:                     return o2.compareTo(o1);
0:                 }
0:             });
0:         }
0: 
0:         return refs;
0:     }
0: 
0:     public static Object getService(BundleContext ctx, ServiceReference ref) {
0:         Object service = ctx.getService(ref);
0: 
0:         Object result = null;
0: 
0:         if (service != null) {
0:             ServicePair pair = new ServicePair();
0:             pair.ref = ref;
0:             pair.service = service;
0: 
0:             result = proxy(null, null, false, ctx, pair);
0:         }
0: 
0:         return result;
0:     }
commit:696374b
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.jndi.JNDIConstants;
/////////////////////////////////////////////////////////////////////////
0:       if (pair == null || pair.ref.getBundle() == null) {
0:         if (dynamic) {
0:             pair = findService(ctx, interfaceName, filter);
0:         } else {
0:             pair = null;
0:         }
/////////////////////////////////////////////////////////////////////////
0:     Object bc = env.get(JNDIConstants.BUNDLE_CONTEXT);
/////////////////////////////////////////////////////////////////////////
0:         filter = "(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + ')';
0:         filter = "(&(" + Constants.SERVICE_ID + '=' + id + ")(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + "))";
/////////////////////////////////////////////////////////////////////////
0:         refs = ctx.getServiceReferences(null, "(" + JNDIConstants.JNDI_SERVICENAME + "=" + serviceName + ')');
commit:3c19a77
/////////////////////////////////////////////////////////////////////////
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
commit:e6f69cc
commit:fc02f66
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.jndi.services;
0: 
0: import java.util.HashSet;
0: import java.util.LinkedList;
1: import java.util.List;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.ConcurrentMap;
0: 
1: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.BundleReference;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
0: 
0: /**
1:  * This helper provides access to services registered in the OSGi service registry.
1:  * If a matching service cannot be located null may be returned. A caller should not
1:  * expect to get the same object if multiple requests are made to this API. A caller
1:  * should not expect to get a different object if multiple requests are made to this API.
1:  * A caller should avoid caching the returned service. OSGi is a dynamic environment and
1:  * the service may become unavailable while a reference to it is held. To minimize this
1:  * risk the caller should hold onto the service for the minimum length of time.
1:  * 
1:  * <p>This API should not be used from within an OSGi bundle. When in an OSGi environment
1:  *   the BundleContext for the bundle should be used to obtain the service.
1:  * </p>
1:  */
0: public final class ServiceHelper
0: {
0:   /** The bundle context used for service registry queries */
0:   private static BundleContext context;
0:   /** A cache of what service was returned last time the query was performed */
0:   private static ConcurrentMap<ServiceKey, Set<ServiceReference>> cache = new ConcurrentHashMap<ServiceKey, Set<ServiceReference>>();
0: 
0:   public static void setBundleContext(BundleContext ctx)
0:   {
0:     context = ctx;
0:   }
0:   
0:   /**
0:    * This class is used as the key into the cache. It holds information to identify 
0:    * who performed the query, along with the className and filter used. The thread context
0:    * class loader is used in the key, so two different modules will potentially get different
0:    * services.
1:    */
0:   private static final class ServiceKey
0:   {
0:     /** The class loader of the invoking application */
0:     private ClassLoader classLoader;
0:     /** The name of the class being queried from the registry */
0:     private String className;
0:     /** the registry filter, this may be null */
0:     private String filter;
0:     /** The cached hashCode */
0:     private final int hashCode;
0: 
0:     /**
0:      * Boring unimportant comment.
1:      * 
0:      * @param cl
0:      * @param cn
0:      * @param f
1:      */
0:     public ServiceKey(ClassLoader cl, String cn, String f)
0:     {
0:       classLoader = cl;
0:       className = cn;
0:       filter = f;
0:       
0:       int classNameHash = (className == null) ? 0 : className.hashCode();
0:       hashCode = System.identityHashCode(classLoader) * 1000003 + classNameHash;
0:     }
0: 
0:     @Override
0:     public int hashCode()
0:     {
0:       return hashCode;
0:     }
0: 
0:     @Override
0:     public boolean equals(Object other)
0:     {
0:       if (other == this) return true;
0:       if (other == null) return false;
0: 
0:       if (other instanceof ServiceKey) {
0:         ServiceKey otherKey = (ServiceKey) other;
0:         if (hashCode != otherKey.hashCode) return false;
0: 
0:         if (classLoader != otherKey.classLoader) return false;
0:         if (!!!comparePossiblyNullObjects(className, otherKey.className)) return false;
0:         return comparePossiblyNullObjects(filter, otherKey.filter);
0:       }
0: 
0:       return false;
0:     }
0:     
0:     /**
0:      * Compares two objects where one or other (or both) may be null.
1:      * 
0:      * @param a the first object to compare.
0:      * @param b the second object to compare.
0:      * @return true if they are ==, both null or identity equals, false otherwise.
1:      */
0:     public boolean comparePossiblyNullObjects(Object a, Object b) {
0:       if (a == b) return true;
0:       else if (a == null) return false;
0:       else return a.equals(b);
0:     }
0:   }
0: 
0:   /**
0:    * This method is used to obtain a single instance of a desired service from the OSGi
0:    * service registry. If the filter and class name identify multiple services the first
0:    * one is returned. If no service is found null will be returned.
1:    * 
0:    * @param className The class name used to register the desired service. If null is provided
0:    *                  then all services are eligible to be returned.
0:    * @param filter    An RFC 1960 query into the properties of the registered services. e.g.
0:    *                  (service.description=really useful)
0:    * @return          The desired service
1:    * 
0:    * @throws IllegalArgumentException If the filter is not valid. See RFC 1960 to work out what 
0:    *                                  it should be.
1:    */
0:   public static Object getService(String className, String filter) throws IllegalArgumentException
0:   {
0:     Object service = null;
0:     try {
0:       BundleContext callerCtx = getBundleContext();
0:       ServiceReference[] refs = callerCtx.getAllServiceReferences(className, filter);
0:       
0:       if (refs != null) {
0:         for (ServiceReference ref : refs) {
0:           List<Object> services = getServices(callerCtx, className, filter, ref);
0:           if (!!!services.isEmpty()) {
0:             service = services.get(0);
0:             break;
0:           }
0:         }
0:       }      
0:     } catch (InvalidSyntaxException e) {
0:       throw new IllegalArgumentException(e.getMessage(), e);
0:     }
0:     
0:     return service;
0:   }
0:   
0:   /**
0:    * This method is used to obtain a list of service instances from the OSGi
0:    * service registry. If no service is found an empty list will be returned.
1:    * 
0:    * @param className The class name used to register the desired service. If null is provided
0:    *                  then all services are eligible to be returned.
0:    * @param filter    An RFC 1960 query into the properties of the registered services. e.g.
0:    *                  (service.description=really useful)
0:    * @return          A list of matching services.
1:    * 
0:    * @throws IllegalArgumentException If the filter is not valid. See RFC 1960 to work out what 
0:    *                                  it should be.
1:    */
0:   public static List<?> getServices(String className, String filter)
0:       throws IllegalArgumentException
0:   {
0:     List<Object> services;
0:     try {
0:       BundleContext callerCtx = getBundleContext();
0:       ServiceReference[] refs = callerCtx.getAllServiceReferences(className, filter);
0:       
0:       services = getServices(callerCtx, className, filter, refs);
0:     } catch (InvalidSyntaxException e) {
0:       throw new IllegalArgumentException(e.getMessage(), e);
0:     }
0:     
0:     return services;
0:   }
0:   
0:   /**
0:    * @return the bundle context for the caller.
1:    */
0:   private static BundleContext getBundleContext()
0:   {
0:     BundleContext result = context;
0:     ClassLoader cl = Thread.currentThread().getContextClassLoader();
0:     if (cl instanceof BundleReference) {
0:       result = ((BundleReference)cl).getBundle().getBundleContext();
0:     } 
0:     
0:     if (result == null) result = context;
0:     return result;
0:   }
0: 
0:   /**
0:    * This worker method obtains the requested service(s) and if the service(s) 
0:    * exist updates the cache and releases the previous service(s).
1:    * 
0:    * @param callerCtx The caller context.
0:    * @param className The class name used to query for the service.
0:    * @param filter    The filter name used to query for the service.
0:    * @param refs      The references to get.
0:    * @return          The service, if one was found, or null.
1:    */
0:   private static List<Object> getServices(BundleContext callerCtx, String className, String filter, ServiceReference...refs)
0:   {
0:     List<Object> data = new LinkedList<Object>();
0:     
0:     if (refs != null) {
0:       Set<ServiceReference> refSet = new HashSet<ServiceReference>();
0:       for (ServiceReference ref : refs) {
0:         Object service = callerCtx.getService(ref);
0:         if (service != null) {
0:           data.add(service);
0:           refSet.add(ref);
0:         }
0:       }
0:       
0:       ClassLoader cl = Thread.currentThread().getContextClassLoader();
0:       ServiceKey key = new ServiceKey(cl, className, filter);
0:       
0:       // we do not need any synchronization around this. The map is concurrent
0:       // and until here we do not touch any shared state.
0:       refSet = cache.put(key, refSet);
0:       
0:       if (refSet != null) {
0:         for (ServiceReference ref : refSet) {
0:           callerCtx.ungetService(ref);
0:         }
0:       }
0:     }
0:     
0:     return data;
0:   }
commit:1a3015d
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.jndi.services;
0: 
0: import java.util.HashSet;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.ConcurrentMap;
0: 
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.BundleReference;
0: import org.osgi.framework.InvalidSyntaxException;
0: import org.osgi.framework.ServiceReference;
0: 
0: /**
0:  * This helper provides access to services registered in the OSGi service registry.
0:  * If a matching service cannot be located null may be returned. A caller should not
0:  * expect to get the same object if multiple requests are made to this API. A caller
0:  * should not expect to get a different object if multiple requests are made to this API.
0:  * A caller should avoid caching the returned service. OSGi is a dynamic environment and
0:  * the service may become unavailable while a reference to it is held. To minimize this
0:  * risk the caller should hold onto the service for the minimum length of time.
0:  * 
0:  * <p>This API should not be used from within an OSGi bundle. When in an OSGi environment
0:  *   the BundleContext for the bundle should be used to obtain the service.
0:  * </p>
0:  */
0: public final class ServiceHelper
0: {
0:   /** The bundle context used for service registry queries */
0:   private static BundleContext context;
0:   /** A cache of what service was returned last time the query was performed */
0:   private static ConcurrentMap<ServiceKey, Set<ServiceReference>> cache = new ConcurrentHashMap<ServiceKey, Set<ServiceReference>>();
0: 
0:   public static void setBundleContext(BundleContext ctx)
0:   {
0:     context = ctx;
0:   }
0:   
0:   /**
0:    * This class is used as the key into the cache. It holds information to identify 
0:    * who performed the query, along with the className and filter used. The thread context
0:    * class loader is used in the key, so two different modules will potentially get different
0:    * services.
0:    */
0:   private static final class ServiceKey
0:   {
0:     /** The class loader of the invoking application */
0:     private ClassLoader classLoader;
0:     /** The name of the class being queried from the registry */
0:     private String className;
0:     /** the registry filter, this may be null */
0:     private String filter;
0:     /** The cached hashCode */
0:     private final int hashCode;
0: 
0:     /**
0:      * Boring unimportant comment.
0:      * 
0:      * @param cl
0:      * @param cn
0:      * @param f
0:      */
0:     public ServiceKey(ClassLoader cl, String cn, String f)
0:     {
0:       classLoader = cl;
0:       className = cn;
0:       filter = f;
0:       
0:       int classNameHash = (className == null) ? 0 : className.hashCode();
0:       hashCode = System.identityHashCode(classLoader) * 1000003 + classNameHash;
0:     }
0: 
0:     @Override
0:     public int hashCode()
0:     {
0:       return hashCode;
0:     }
0: 
0:     @Override
0:     public boolean equals(Object other)
0:     {
0:       if (other == this) return true;
0:       if (other == null) return false;
0: 
0:       if (other instanceof ServiceKey) {
0:         ServiceKey otherKey = (ServiceKey) other;
0:         if (hashCode != otherKey.hashCode) return false;
0: 
0:         if (classLoader != otherKey.classLoader) return false;
0:         if (!!!comparePossiblyNullObjects(className, otherKey.className)) return false;
0:         return comparePossiblyNullObjects(filter, otherKey.filter);
0:       }
0: 
0:       return false;
0:     }
0:     
0:     /**
0:      * Compares two objects where one or other (or both) may be null.
0:      * 
0:      * @param a the first object to compare.
0:      * @param b the second object to compare.
0:      * @return true if they are ==, both null or identity equals, false otherwise.
0:      */
0:     public boolean comparePossiblyNullObjects(Object a, Object b) {
0:       if (a == b) return true;
0:       else if (a == null) return false;
0:       else return a.equals(b);
0:     }
0:   }
0: 
0:   /**
0:    * This method is used to obtain a single instance of a desired service from the OSGi
0:    * service registry. If the filter and class name identify multiple services the first
0:    * one is returned. If no service is found null will be returned.
0:    * 
0:    * @param className The class name used to register the desired service. If null is provided
0:    *                  then all services are eligible to be returned.
0:    * @param filter    An RFC 1960 query into the properties of the registered services. e.g.
0:    *                  (service.description=really useful)
0:    * @return          The desired service
0:    * 
0:    * @throws IllegalArgumentException If the filter is not valid. See RFC 1960 to work out what 
0:    *                                  it should be.
0:    */
0:   public static Object getService(String className, String filter) throws IllegalArgumentException
0:   {
0:     Object service = null;
0:     try {
0:       BundleContext callerCtx = getBundleContext();
0:       ServiceReference[] refs = callerCtx.getAllServiceReferences(className, filter);
0:       
0:       if (refs != null) {
0:         for (ServiceReference ref : refs) {
0:           List<Object> services = getServices(callerCtx, className, filter, ref);
0:           if (!!!services.isEmpty()) {
0:             service = services.get(0);
0:             break;
0:           }
0:         }
0:       }      
0:     } catch (InvalidSyntaxException e) {
0:       throw new IllegalArgumentException(e.getMessage(), e);
0:     }
0:     
0:     return service;
0:   }
0:   
0:   /**
0:    * This method is used to obtain a list of service instances from the OSGi
0:    * service registry. If no service is found an empty list will be returned.
0:    * 
0:    * @param className The class name used to register the desired service. If null is provided
0:    *                  then all services are eligible to be returned.
0:    * @param filter    An RFC 1960 query into the properties of the registered services. e.g.
0:    *                  (service.description=really useful)
0:    * @return          A list of matching services.
0:    * 
0:    * @throws IllegalArgumentException If the filter is not valid. See RFC 1960 to work out what 
0:    *                                  it should be.
0:    */
0:   public static List<?> getServices(String className, String filter)
0:       throws IllegalArgumentException
0:   {
0:     List<Object> services;
0:     try {
0:       BundleContext callerCtx = getBundleContext();
0:       ServiceReference[] refs = callerCtx.getAllServiceReferences(className, filter);
0:       
0:       services = getServices(callerCtx, className, filter, refs);
0:     } catch (InvalidSyntaxException e) {
0:       throw new IllegalArgumentException(e.getMessage(), e);
0:     }
0:     
0:     return services;
0:   }
0:   
0:   /**
0:    * @return the bundle context for the caller.
0:    */
0:   private static BundleContext getBundleContext()
0:   {
0:     BundleContext result = context;
0:     ClassLoader cl = Thread.currentThread().getContextClassLoader();
0:     if (cl instanceof BundleReference) {
0:       result = ((BundleReference)cl).getBundle().getBundleContext();
0:     } 
0:     
0:     if (result == null) result = context;
0:     return result;
0:   }
0: 
0:   /**
0:    * This worker method obtains the requested service(s) and if the service(s) 
0:    * exist updates the cache and releases the previous service(s).
0:    * 
0:    * @param callerCtx The caller context.
0:    * @param className The class name used to query for the service.
0:    * @param filter    The filter name used to query for the service.
0:    * @param refs      The references to get.
0:    * @return          The service, if one was found, or null.
0:    */
0:   private static List<Object> getServices(BundleContext callerCtx, String className, String filter, ServiceReference...refs)
0:   {
0:     List<Object> data = new LinkedList<Object>();
0:     
0:     if (refs != null) {
0:       Set<ServiceReference> refSet = new HashSet<ServiceReference>();
0:       for (ServiceReference ref : refs) {
0:         Object service = callerCtx.getService(ref);
0:         if (service != null) {
0:           data.add(service);
0:           refSet.add(ref);
0:         }
0:       }
0:       
0:       ClassLoader cl = Thread.currentThread().getContextClassLoader();
0:       ServiceKey key = new ServiceKey(cl, className, filter);
0:       
0:       // we do not need any synchronization around this. The map is concurrent
0:       // and until here we do not touch any shared state.
0:       refSet = cache.put(key, refSet);
0:       
0:       if (refSet != null) {
0:         for (ServiceReference ref : refSet) {
0:           callerCtx.ungetService(ref);
0:         }
0:       }
0:     }
0:     
0:     return data;
0:   }
0: }
author:David Jencks
-------------------------------------------------------------------------------
commit:f8842fe
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Modifier;
0: import java.util.HashSet;
0: import java.util.Set;
1: import java.util.concurrent.Callable;
0: import net.sf.cglib.proxy.Dispatcher;
0: import net.sf.cglib.proxy.Enhancer;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:   private static class JNDIServiceDamper implements Callable<Object>
/////////////////////////////////////////////////////////////////////////
1:     public Object call() throws NamingException {
/////////////////////////////////////////////////////////////////////////
1:       return pair.service;
/////////////////////////////////////////////////////////////////////////
1:   private static final CacheClearoutListener cacheClearoutListener = new CacheClearoutListener(proxyCache);
0: 
0:   private static ProxyFactory proxyFactory;
1:                                   boolean dynamicRebind, Map<String, Object> env, boolean requireProxy) throws NamingException
/////////////////////////////////////////////////////////////////////////
0:       result = proxy(interfaceName, filter, dynamicRebind, ctx, pair, requireProxy);
0:                               final BundleContext ctx, final ServicePair pair, final boolean requireProxy)
/////////////////////////////////////////////////////////////////////////
0:           return proxyPriviledged(interface1, filter, rebind, ctx, pair, requireProxy);
/////////////////////////////////////////////////////////////////////////
0:   private static Object proxyPriviledged(String interface1, String filter, boolean dynamicRebind, BundleContext ctx, ServicePair pair, boolean requireProxy)
/////////////////////////////////////////////////////////////////////////
0:     ProxyFactory proxyFactory = getProxyFactory();
0: 
0:         if (Modifier.isFinal(potentialClass.getModifiers())) {
0:           if (requireProxy) {
0:             continue;
0:           }
0:           return pair.service;
0:         }
0:         if (!potentialClass.isInterface()) {
0:           if (requireProxy && !proxyFactory.proxiesClasses()) {
0:             continue;
0:           }
0:           try {
0:             potentialClass.getConstructor(new Class[0]);
0:           } catch (NoSuchMethodException e) {
0:             if (requireProxy) {
0:               continue;
0:             }
0:             return pair.service;
0:           }
0:         }
0:         if (!requireProxy) {
0:           return pair.service;
0:         }
/////////////////////////////////////////////////////////////////////////
0:     Callable<Object> ih = new JNDIServiceDamper(ctx, interface1, filter, pair, dynamicRebind);
0:     try {
0:       return proxyFactory.createProxy(new BundleToClassLoaderAdapter(serviceProviderBundle), clazz
0:           .toArray(new Class<?>[clazz.size()]), ih);
0:     } catch (IllegalArgumentException e) {
0:       if (requireProxy) {
0:         throw e;
0:       }
0:       return pair.service;
0:     }
/////////////////////////////////////////////////////////////////////////
0:       result = proxy(null, null, false, ctx, pair, true);
0:   protected static synchronized ProxyFactory getProxyFactory() {
0:     if (proxyFactory == null) {
0:       try {
0:         // Try load load a cglib class (to make sure it's actually available
0:         // then create the cglib factory
0:         ServiceHelper.class.getClassLoader().loadClass("net.sf.cglib.proxy.Enhancer");
0:         proxyFactory = new CgLibProxyFactory();
0:       } catch (Throwable t) {
0:         proxyFactory = new JdkProxyFactory();
0:       }
0:     }
0:     return proxyFactory;
0:   }
0: 
0:   private static Class[] getInterfaces(Class[] classes) {
0:     Set<Class> interfaces = new HashSet<Class>();
0:     for (Class clazz : classes) {
0:       if (clazz.isInterface()) {
0:         interfaces.add(clazz);
0:       }
0:     }
0:     return toClassArray(interfaces);
0:   }
0: 
0:   private static Class[] toClassArray(Set<Class> classes) {
0:     return classes.toArray(new Class[classes.size()]);
0:   }
0: 
0:   public static interface ProxyFactory {
0: 
0:     Object createProxy(ClassLoader classLoader, Class[] classes, Callable<Object> dispatcher);
0: 
0:     boolean proxiesClasses();
0:   }
0: 
0:   public static class JdkProxyFactory implements ProxyFactory {
0: 
0:     public Object createProxy(final ClassLoader classLoader, final Class[] classes, final Callable<Object> dispatcher) {
0:       return Proxy.newProxyInstance(classLoader, getInterfaces(classes), new InvocationHandler() {
0:         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
0:           try {
0:             return method.invoke(dispatcher.call(), args);
0:           } catch (InvocationTargetException ite) {
0:             throw ite.getTargetException();
0:           }
0:         }
0:       });
0:     }
0: 
0:     public boolean proxiesClasses() {
0:       return false;
0:     }
0: 
0:   }
0: 
0:   public static class CgLibProxyFactory implements ProxyFactory {
0: 
0:     public Object createProxy(final ClassLoader classLoader, final Class[] classes, final Callable<Object> dispatcher) {
0:       Enhancer e = new Enhancer();
0:       e.setClassLoader(classLoader);
0:       e.setSuperclass(getTargetClass(classes));
0:       e.setInterfaces(getInterfaces(classes));
0:       e.setInterceptDuringConstruction(false);
0:       e.setCallback(new Dispatcher() {
0:         public Object loadObject() throws Exception {
0:           return dispatcher.call();
0:         }
0:       });
0:       e.setUseFactory(false);
0:       return e.create();
0:     }
0: 
0:     public boolean proxiesClasses() {
0:       return true;
0:     }
0: 
0:     protected Class<?> getTargetClass(Class<?>[] interfaceNames) {
0:       // Only allow class proxying if specifically asked to
0:       Class<?> root = Object.class;
0:       for (Class<?> clazz : interfaceNames) {
0:         if (!clazz.isInterface()) {
0:           if (root.isAssignableFrom(clazz)) {
0:             root = clazz;
0:           } else if (clazz.isAssignableFrom(root)) {
0:             //nothing to do, root is correct
0:           } else {
0:             throw new IllegalArgumentException("Classes " + root.getClass().getName() + " and " + clazz.getName() + " are not in the same hierarchy");
0:           }
0:         }
0:       }
0:       return root;
0:     }
0: 
0:   }
0: 
0: 
============================================================================