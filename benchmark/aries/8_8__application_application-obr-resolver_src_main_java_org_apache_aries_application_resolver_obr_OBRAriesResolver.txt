1:0aad0ca: /*
1:0aad0ca:  * Licensed to the Apache Software Foundation (ASF) under one
1:0aad0ca:  * or more contributor license agreements.  See the NOTICE file
1:0aad0ca:  * distributed with this work for additional information
1:0aad0ca:  * regarding copyright ownership.  The ASF licenses this file
1:0aad0ca:  * to you under the Apache License, Version 2.0 (the
1:0aad0ca:  * "License"); you may not use this file except in compliance
1:0aad0ca:  * with the License.  You may obtain a copy of the License at
1:792f3de:  *
1:0aad0ca:  *  http://www.apache.org/licenses/LICENSE-2.0
2:0aad0ca:  *
1:0aad0ca:  * Unless required by applicable law or agreed to in writing,
1:0aad0ca:  * software distributed under the License is distributed on an
1:0aad0ca:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:0aad0ca:  * KIND, either express or implied.  See the License for the
1:0aad0ca:  * specific language governing permissions and limitations
1:0aad0ca:  * under the License.
1:792f3de:  */
1:04c5141: 
1:0aad0ca: package org.apache.aries.application.resolver.obr;
1:58f55bd: 
1:792f3de: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1:792f3de: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1:58f55bd: 
1:248447e: import java.io.ByteArrayInputStream;
1:248447e: import java.io.ByteArrayOutputStream;
1:04c5141: import java.io.InputStream;
1:248447e: import java.io.InputStreamReader;
1:04c5141: import java.io.Reader;
1:792f3de: import java.net.URI;
1:248447e: import java.util.ArrayList;
1:792f3de: import java.util.Arrays;
1:792f3de: import java.util.Collection;
1:792f3de: import java.util.Collections;
1:0aad0ca: import java.util.HashMap;
1:0aad0ca: import java.util.HashSet;
1:792f3de: import java.util.Iterator;
1:482c954: import java.util.List;
1:0aad0ca: import java.util.Map;
1:0aad0ca: import java.util.Set;
1:58f55bd: 
1:e8ec7a5: import org.apache.aries.application.ApplicationMetadata;
1:0aad0ca: import org.apache.aries.application.Content;
1:89f804e: import org.apache.aries.application.InvalidAttributeException;
1:0aad0ca: import org.apache.aries.application.management.AriesApplication;
1:0aad0ca: import org.apache.aries.application.management.BundleInfo;
1:bfd7c4d: import org.apache.aries.application.management.ResolveConstraint;
1:0aad0ca: import org.apache.aries.application.management.ResolverException;
1:89f804e: import org.apache.aries.application.management.spi.repository.PlatformRepository;
1:89f804e: import org.apache.aries.application.management.spi.resolve.AriesApplicationResolver;
1:792f3de: import org.apache.aries.application.modelling.ImportedBundle;
1:792f3de: import org.apache.aries.application.modelling.ModelledResource;
1:58f55bd: import org.apache.aries.application.modelling.ModellingConstants;
1:58f55bd: import org.apache.aries.application.modelling.ModellingManager;
1:58f55bd: import org.apache.aries.application.modelling.utils.ModellingHelper;
1:792f3de: import org.apache.aries.application.resolver.internal.MessageUtil;
1:17170a0: import org.apache.aries.application.resolver.obr.ext.ModelledBundleResource;
1:e8ec7a5: import org.apache.aries.application.resolver.obr.impl.ApplicationResourceImpl;
1:0aad0ca: import org.apache.aries.application.resolver.obr.impl.OBRBundleInfo;
1:d04041b: import org.apache.aries.application.resolver.obr.impl.RepositoryGeneratorImpl;
1:8702237: import org.apache.aries.application.resolver.obr.impl.ResourceWrapper;
1:57dfd78: import org.apache.aries.application.utils.AppConstants;
1:910fec0: import org.apache.aries.application.utils.manifest.ContentFactory;
1:910fec0: import org.apache.aries.util.VersionRange;
1:c6cb34d: import org.apache.aries.util.io.IOUtils;
1:910fec0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1:792f3de: import org.apache.felix.bundlerepository.Capability;
1:248447e: import org.apache.felix.bundlerepository.DataModelHelper;
1:248447e: import org.apache.felix.bundlerepository.Reason;
1:248447e: import org.apache.felix.bundlerepository.Repository;
1:248447e: import org.apache.felix.bundlerepository.RepositoryAdmin;
1:792f3de: import org.apache.felix.bundlerepository.Requirement;
1:248447e: import org.apache.felix.bundlerepository.Resolver;
1:248447e: import org.apache.felix.bundlerepository.Resource;
1:248447e: import org.osgi.framework.Constants;
1:248447e: import org.osgi.framework.InvalidSyntaxException;
1:0aad0ca: import org.osgi.framework.Version;
1:ad59cd3: import org.slf4j.Logger;
1:ad59cd3: import org.slf4j.LoggerFactory;
1:58f55bd: 
1:58f55bd: /**
1:0aad0ca:  * @version $Rev$ $Date$
1:792f3de:  */
1:0aad0ca: public class OBRAriesResolver implements AriesApplicationResolver
1:792f3de: {
1:ad59cd3:   private static Logger log = LoggerFactory.getLogger(OBRAriesResolver.class);
1:58f55bd: 
1:9b0cfd6:   private final RepositoryAdmin repositoryAdmin;  
1:9b0cfd6:   private boolean returnOptionalResources = true;
1:792f3de:   private PlatformRepository platformRepository;
1:58f55bd:   private ModellingManager modellingManager;
1:58f55bd:   private ModellingHelper modellingHelper;
1:9b0cfd6:   
1:58f55bd:   public void setModellingManager (ModellingManager m) { 
1:58f55bd:     modellingManager = m;
1:58f55bd:   }
1:8702237:   
1:58f55bd:   public void setModellingHelper (ModellingHelper mh) { 
1:58f55bd:     modellingHelper = mh;
1:2901df4:   }
1:9b0cfd6:   
1:792f3de:   public PlatformRepository getPlatformRepository()
1:8702237:   {
1:792f3de:     return platformRepository;
1:58f55bd:   }
1:9b0cfd6: 
1:9b0cfd6:  
1:17170a0:   
1:792f3de:   public  RepositoryAdmin getRepositoryAdmin() {
1:792f3de:     return this.repositoryAdmin;
1:58f55bd:   }
1:792f3de:   public void setPlatformRepository(PlatformRepository platformRepository)
1:2901df4:   {
1:792f3de:     this.platformRepository = platformRepository;
1:58f55bd:   }
1:2901df4: 
1:0aad0ca:   public OBRAriesResolver(RepositoryAdmin repositoryAdmin)
1:58f55bd:   {
1:0aad0ca:     this.repositoryAdmin = repositoryAdmin;
1:792f3de:   }
1:2901df4: 
1:9b0cfd6:   public void setReturnOptionalResources(boolean optional) 
1:9b0cfd6:   {
1:9b0cfd6:     this.returnOptionalResources = optional;
1:9b0cfd6:   }
1:9b0cfd6:   
1:9b0cfd6:   public boolean getReturnOptionalResources() 
1:9b0cfd6:   {
1:9b0cfd6:     return returnOptionalResources;
1:9b0cfd6:   }
1:9b0cfd6:   
1:2901df4: /**
1:58f55bd:    * Resolve a list of resources from the OBR bundle repositories by OBR
1:58f55bd:    * resolver.
1:58f55bd:    * 
1:58f55bd:    * @param appName - application name
1:58f55bd:    * @param appVersion - application version
1:58f55bd:    * @param byValueBundles - by value bundles
1:58f55bd:    * @param inputs - other constraints
1:2901df4:    * @param platformRepository - a platform repository to use instead of the one provided as a service
1:58f55bd:    * @return a collection of modelled resources required by this application
1:58f55bd:    * @throws ResolverException
1:58f55bd:    */
1:58f55bd:   @Override
1:2901df4:   public Collection<ModelledResource> resolve(String appName, String appVersion,
1:17170a0: 			Collection<ModelledResource> byValueBundles, Collection<Content> inputs)
1:2901df4: 			throws ResolverException {
1:cce7f7c:       
1:cce7f7c:     log.debug(LOG_ENTRY, "resolve", new Object[]{appName, appVersion,byValueBundles, inputs});
1:58f55bd:     Collection<ImportedBundle> importedBundles = toImportedBundle(inputs);
1:04c5141:     
1:cce7f7c:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles, false);
1:792f3de:     // add a resource describing the requirements of the application metadata.
1:58f55bd:     obrResolver.add(createApplicationResource( appName, appVersion, importedBundles));
1:58f55bd:     
1:cce7f7c:     log.debug(LOG_EXIT, "resolve");
1:cce7f7c:     return doResolve(obrResolver, appName);    
1:58f55bd:   }
1:cce7f7c:   
1:cce7f7c:   private Collection<ModelledResource> doResolve(Resolver obrResolver, String appName) throws ResolverException
1:cce7f7c:   {
1:cce7f7c:       log.debug(LOG_ENTRY, "doResolve");
1:cce7f7c:       Collection<ModelledResource> toReturn = new ArrayList<ModelledResource>();
1:58f55bd: 
1:cce7f7c:       if (obrResolver.resolve()) {
1:cce7f7c:           
1:cce7f7c:           List<Resource> requiredResources = retrieveRequiredResources(obrResolver);
1:cce7f7c: 
1:cce7f7c:           if (requiredResources == null) {
1:cce7f7c:             log.debug("resolver.getRequiredResources() returned null");
1:cce7f7c:           } else {
1:cce7f7c: 
1:cce7f7c:             for (Resource r : requiredResources) {
1:cce7f7c:               Map<String, String> attribs = new HashMap<String, String>();
1:cce7f7c:               attribs.put(Constants.VERSION_ATTRIBUTE, "[" + r.getVersion() + ',' + r.getVersion() + "]");
1:cce7f7c:               ModelledResource modelledResourceForThisMatch = null; 
1:cce7f7c:               // OBR may give us back the global capabilities. Typically these do not have a bundle symbolic name - they're a 
1:cce7f7c:               // list of packages available in the target runtime environment. If the resource has no symbolic name, we can ignore it
1:cce7f7c:               if (r.getSymbolicName() != null) { 
1:cce7f7c:                 try { 
1:cce7f7c:                   modelledResourceForThisMatch = new ModelledBundleResource (r, modellingManager, modellingHelper);
1:cce7f7c:                 } catch (InvalidAttributeException iax) { 
1:cce7f7c:                   ResolverException re = new ResolverException("Internal error occurred: " + iax);
1:cce7f7c:                   log.debug(LOG_EXIT, "doResolve", re);
1:cce7f7c:                   throw re;
1:cce7f7c:                 }
1:cce7f7c:                 toReturn.add(modelledResourceForThisMatch);
1:cce7f7c:               }
1:cce7f7c:             }
1:cce7f7c:           }
1:cce7f7c:           log.debug(LOG_EXIT, toReturn);
1:cce7f7c:           return toReturn;
1:cce7f7c:         } else {
1:cce7f7c:           Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
1:cce7f7c:           // let's refine the list by removing the indirect unsatisfied bundles that are caused by unsatisfied packages or other bundles
1:cce7f7c:           Map<String,Set<String>> refinedReqs = refineUnsatisfiedRequirements(obrResolver, reasons);
1:cce7f7c:           StringBuffer reqList = new StringBuffer();
1:cce7f7c:           Map<String, String> unsatisfiedRequirements = extractConsumableMessageInfo(refinedReqs);
1:cce7f7c: 
1:cce7f7c:           for (String reason : unsatisfiedRequirements.keySet()) {
1:cce7f7c:             reqList.append('\n');
1:cce7f7c:             reqList.append(reason);
1:cce7f7c:           }
1:cce7f7c: 
1:cce7f7c:           ResolverException re = new ResolverException(MessageUtil.getMessage("RESOLVER_UNABLE_TO_RESOLVE", new Object[] { appName, reqList }));
1:cce7f7c:           re.setUnsatisfiedRequirementsAndReasons(unsatisfiedRequirements);
1:cce7f7c: 
1:cce7f7c:           log.debug(LOG_EXIT, "doResolve", re);
1:cce7f7c:           throw re;
1:cce7f7c:         }
1:cce7f7c:   }
1:cce7f7c:   
1:cce7f7c: 
1:cce7f7c:   @Override
1:cce7f7c:   public Collection<ModelledResource> resolveInIsolation(String appName,
1:cce7f7c:           String appVersion, Collection<ModelledResource> byValueBundles,
1:cce7f7c:           Collection<Content> inputs) throws ResolverException {
1:cce7f7c:       
1:cce7f7c:       log.debug(LOG_ENTRY, "resolve", new Object[]{appName, appVersion,byValueBundles, inputs});
1:cce7f7c:       Collection<ImportedBundle> importedBundles = toImportedBundle(inputs);
1:cce7f7c:       
1:cce7f7c:       Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles, true);
1:cce7f7c:       // add a resource describing the requirements of the application metadata.
1:cce7f7c:       obrResolver.add(createApplicationResource( appName, appVersion, importedBundles));
1:cce7f7c:       
1:cce7f7c:       log.debug(LOG_EXIT, "resolve");
1:cce7f7c:       return doResolve(obrResolver, appName);   
1:cce7f7c:   }  
1:cce7f7c:   
1:2901df4:   private Resolver getConfiguredObrResolver(String appName, String appVersion,
1:cce7f7c:       Collection<ModelledResource> byValueBundles, boolean noExtraRepositories) throws ResolverException
1:792f3de:   {
1:57dfd78:     log.debug(LOG_ENTRY, "getConfiguredObrResolver", new Object[]{appName, appVersion,byValueBundles });
1:58f55bd:     DataModelHelper helper = repositoryAdmin.getHelper();
1:58f55bd:     Repository appRepo;
1:8589750:     try {      
1:58f55bd:       ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:58f55bd:       RepositoryGeneratorImpl.generateRepository(repositoryAdmin, appName + "_" + appVersion, byValueBundles, bytesOut);
1:58f55bd:       appRepo = helper.readRepository(new InputStreamReader(new ByteArrayInputStream(bytesOut.toByteArray())));
2:58f55bd:     } catch (Exception e) {
1:58f55bd:       throw new ResolverException(e);
1:2901df4:     } 
1:9b0cfd6:         
1:58f55bd:     List<Repository> resolveRepos = new ArrayList<Repository>();
1:9b0cfd6:     // add system repository
1:9b0cfd6:     resolveRepos.add(repositoryAdmin.getSystemRepository());
1:cce7f7c: 
1:9b0cfd6:     // add application repository
1:58f55bd:     resolveRepos.add(appRepo);
1:cce7f7c:     
1:cce7f7c:     if (!!!noExtraRepositories) {
1:cce7f7c:         // add local repository if configured
1:cce7f7c:         if (!(excludeLocalRuntime())) {
1:cce7f7c:           resolveRepos.add(getLocalRepository(repositoryAdmin));
1:cce7f7c:         }
1:cce7f7c:         // Need to refresh the repositories added to repository admin 
1:cce7f7c:         // add user-defined repositories
1:cce7f7c:         Repository[] repos = repositoryAdmin.listRepositories();
1:cce7f7c:         for (Repository r : repos) {
1:cce7f7c:           resolveRepos.add(r);      
1:cce7f7c:         }     
1:cce7f7c:     }
1:9b0cfd6: 
1:58f55bd:     Resolver obrResolver = repositoryAdmin.resolver(resolveRepos.toArray(new Repository[resolveRepos.size()]));
1:2901df4:     addPlatformRepositories (obrResolver, appName, platformRepository);
1:57dfd78:     log.debug(LOG_EXIT, "getConfiguredObrResolver", obrResolver);
1:57dfd78:     return obrResolver;
1:58f55bd:   }
1:2901df4:  
1:8589750:   
1:792f3de:   @Deprecated
1:58f55bd:   @Override
1:248447e:   public Set<BundleInfo> resolve(AriesApplication app, ResolveConstraint... constraints) throws ResolverException
1:792f3de:   {
1:ad59cd3:     log.trace("resolving {}", app);
1:e8ec7a5:     ApplicationMetadata appMeta = app.getApplicationMetadata();
1:04c5141: 
1:e8ec7a5:     String appName = appMeta.getApplicationSymbolicName();
1:e8ec7a5:     Version appVersion = appMeta.getApplicationVersion();
1:e8ec7a5:     List<Content> appContent = appMeta.getApplicationContents();
1:04c5141: 
1:792f3de:     Collection<Content> useBundleContent = appMeta.getUseBundles();
1:792f3de:     List<Content> contents = new ArrayList<Content>();
1:792f3de:     contents.addAll(appContent);
1:792f3de:     contents.addAll(useBundleContent);
1:792f3de:     if ((constraints != null ) && (constraints.length > 0 )) {
1:792f3de:       for (ResolveConstraint con: constraints) {
1:910fec0:         contents.add(ContentFactory.parseContent(con.getBundleName(), con.getVersionRange().toString()));
1:58f55bd:       }
1:58f55bd:     }
1:04c5141: 
1:cce7f7c:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion.toString(), toModelledResource(app.getBundleInfo()), false);
1:58f55bd:     // add a resource describing the requirements of the application metadata.
1:792f3de:     obrResolver.add(createApplicationResource( appName, appVersion, contents));
1:58f55bd:     if (obrResolver.resolve()) {
1:792f3de:      Set<BundleInfo> result = new HashSet<BundleInfo>();
1:58f55bd:       List<Resource> requiredResources = retrieveRequiredResources(obrResolver);
1:04c5141:       
1:792f3de:       for (Resource resource: requiredResources) {
1:9b0cfd6:         BundleInfo bundleInfo = toBundleInfo(resource, false);
2:248447e:         result.add(bundleInfo);
1:58f55bd:       }
1:9b0cfd6:       if (returnOptionalResources) {
1:9b0cfd6:         for (Resource resource: obrResolver.getOptionalResources()) {
1:9b0cfd6:           BundleInfo bundleInfo = toBundleInfo(resource, true);
1:9b0cfd6:           result.add(bundleInfo);
1:9b0cfd6:         }
1:58f55bd:       }
1:58f55bd:             
1:792f3de:       return result;
1:58f55bd:     } else {
1:58f55bd:       Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
1:792f3de:       //refine the list by removing the indirect unsatisfied bundles that are caused by unsatisfied packages or other bundles
1:58f55bd:       Map<String,Set<String>> refinedReqs = refineUnsatisfiedRequirements(obrResolver, reasons);
1:58f55bd:       StringBuffer reqList = new StringBuffer();
1:9da7040:       Map<String, String> unsatisfiedRequirements = extractConsumableMessageInfo(refinedReqs);
1:58f55bd: 
1:605729d:       for (String reason : unsatisfiedRequirements.keySet()) {
1:58f55bd:         reqList.append('\n');
1:58f55bd:         reqList.append(reason);
1:58f55bd:       }
1:58f55bd: 
1:58f55bd:       ResolverException re = new ResolverException(MessageUtil.getMessage("RESOLVER_UNABLE_TO_RESOLVE", 
1:792f3de:           new Object[] { app.getApplicationMetadata().getApplicationName(), reqList }));
1:9da7040:       re.setUnsatisfiedRequirementsAndReasons(unsatisfiedRequirements);
1:8589750:       log.debug(LOG_EXIT, "resolve", re);
1:8589750:       
1:8589750:       throw re;
1:8589750:     }
1:792f3de:   }
1:58f55bd: 
1:58f55bd:   
1:d04041b:   
1:58f55bd:   @Override
1:0aad0ca:   public BundleInfo getBundleInfo(String bundleSymbolicName, Version bundleVersion)
1:792f3de:   {
1:de5b346:     Map<String, String> attribs = new HashMap<String, String>();
1:fe213c6:     // bundleVersion is an exact version - so ensure right version filter is generated
1:fe213c6:     VersionRange range = ManifestHeaderProcessor.parseVersionRange(bundleVersion.toString(), true);
1:fe213c6:     attribs.put(Resource.VERSION, range.toString());
1:482c954:     String filterString = ManifestHeaderProcessor.generateFilter(Resource.SYMBOLIC_NAME, bundleSymbolicName, attribs);
1:248447e:     Resource[] resources;
1:58f55bd:     try {
1:248447e:       resources = repositoryAdmin.discoverResources(filterString);
1:248447e:       if (resources != null && resources.length > 0) {
1:9b0cfd6:         return toBundleInfo(resources[0], false);
4:792f3de:       } else {
1:248447e:         return null;
1:792f3de:       }
1:248447e:     } catch (InvalidSyntaxException e) {
1:9b0cfd6:       log.error("Invalid filter", e);
2:0aad0ca:       return null;
1:792f3de:     }
1:792f3de:   }
1:792f3de: 
1:04c5141:   /* A 'platform repository' describes capabilities of the target runtime environment
1:04c5141:    * These should be added to the resolver without being listed as coming from a particular 
1:04c5141:    * repository or bundle.  
1:04c5141:    */
1:2901df4:   private void addPlatformRepositories (Resolver obrResolver, String appName, PlatformRepository platformRepository)
1:04c5141:   { 
1:4c637b1:     log.debug(LOG_ENTRY, "addPlatformRepositories", new Object[]{obrResolver, appName});
1:04c5141:     DataModelHelper helper = repositoryAdmin.getHelper();
1:04c5141:     if (platformRepository != null) {
1:04c5141:       Collection<URI> uris = platformRepository.getPlatformRepositoryURLs();
1:04c5141:       if ((uris != null) && (!uris.isEmpty())) {
1:04c5141:         for (URI uri : uris) {
1:04c5141:           InputStream is = null;
1:04c5141:           try {
1:04c5141:             is = uri.toURL().openStream();
1:04c5141:             Reader repoReader = new InputStreamReader(is);
1:04c5141:             Repository aPlatformRepo = helper.readRepository(repoReader);
1:04c5141:             Resource resources[] = aPlatformRepo.getResources();
1:04c5141:             for (Resource r : resources) { 
1:04c5141:               Capability[] caps = r.getCapabilities();
1:04c5141:               for (Capability c : caps) { 
1:04c5141:                 obrResolver.addGlobalCapability(c);
1:04c5141:               }
1:04c5141:             }
1:04c5141:           } catch (Exception e) {
1:2901df4:             // not a big problem
1:04c5141:             log.error(MessageUtil.getMessage("RESOLVER_UNABLE_TO_READ_REPOSITORY_EXCEPTION", new Object[]{appName, uri}) );
1:04c5141:           } finally { 
1:04c5141:             IOUtils.close(is);
1:04c5141:           }
1:04c5141:         }
1:04c5141:       }
1:04c5141:     }
1:4c637b1:     log.debug(LOG_EXIT, "addPlatformRepositories");
1:04c5141:   }
1:04c5141:   
1:58f55bd:   private Resource createApplicationResource( String appName, Version appVersion,
1:58f55bd:       List<Content> appContent)
1:58f55bd:   {
1:58f55bd:     return new ApplicationResourceImpl(appName, appVersion, appContent);
1:58f55bd:   }
1:58f55bd:   
1:58f55bd:   private Resource createApplicationResource( String appName, String appVersion,
1:58f55bd:       Collection<ImportedBundle> inputs)
1:58f55bd:   {
1:58f55bd:     return new ApplicationResourceImpl(appName, Version.parseVersion(appVersion), inputs);
1:58f55bd:   }
1:58f55bd:   
1:9b0cfd6:   private BundleInfo toBundleInfo(Resource resource, boolean optional) 
1:792f3de:   {
1:9b0cfd6:     Map<String, String> directives = null;
1:9b0cfd6:     if (optional) {
1:9b0cfd6:       directives = new HashMap<String, String>();
1:9b0cfd6:       directives.put(Constants.RESOLUTION_DIRECTIVE, Constants.RESOLUTION_OPTIONAL);
1:9b0cfd6:     }
1:58f55bd:     
1:58f55bd: 
1:0aad0ca:     return new OBRBundleInfo(resource.getSymbolicName(),
1:9b0cfd6:                              resource.getVersion(),
1:792f3de:                              resource.getURI(),
1:9b0cfd6:                              null,
1:9b0cfd6:                              null,
1:9b0cfd6:                              null,
1:9b0cfd6:                              null,
1:9b0cfd6:                              null, 
1:9b0cfd6:                              null,
1:9b0cfd6:                              directives,
1:9b0cfd6:                              null);
1:792f3de:     
1:9b0cfd6:   }
1:792f3de:   
2:792f3de:   /**
1:792f3de:    * Get the list of resources returned by the resolver
1:792f3de:    * @param resolver OBR resolver
1:792f3de:    * @return a list of required resources
1:958fb7e:    */
1:792f3de:   protected List<Resource> retrieveRequiredResources(Resolver resolver)
1:792f3de:   {
1:792f3de:     log.debug(LOG_ENTRY,"retrieveRequiredResources", resolver);
1:792f3de:     Map<String, List<Resource>> resourcesByName = new HashMap<String, List<Resource>>();
1:792f3de: 
1:792f3de:     for (Resource r : resolver.getRequiredResources()) {
1:792f3de:       resourcesByName.put(r.getSymbolicName(), mergeResource(resolver, r, resourcesByName.get(r
1:792f3de:           .getSymbolicName())));
1:792f3de:     }
1:792f3de: 
1:792f3de:     List<Resource> result = new ArrayList<Resource>();
1:792f3de:     for (List<Resource> res : resourcesByName.values()) {
1:792f3de:       result.addAll(res);
1:792f3de:     }
1:792f3de: 
1:792f3de:     log.debug(LOG_EXIT,  "retrieveRequiredResources", result);
1:248447e:     return result;
1:792f3de:   }
1:792f3de: 
1:792f3de:   
1:792f3de: /**
1:792f3de:  * Get rid of the redundant resources
1:792f3de:  * @param resolver OBR resolver
1:792f3de:  * @param r a resource
1:792f3de:  * @param list similar resources
1:792f3de:  * @return the list of minimum resources
1:792f3de:  */
1:792f3de:   protected List<Resource> mergeResource(Resolver resolver, Resource r,
1:792f3de:       List<Resource> list)
1:792f3de:   {
1:792f3de:     log.debug(LOG_ENTRY, "mergeResource", new Object[]{resolver, r, list});
1:792f3de:     
1:792f3de:     if (list == null) {
1:792f3de:       log.debug(LOG_EXIT, "mergeResource", Arrays.asList(r));
1:792f3de:       return Arrays.asList(r);
1:58f55bd:     } else {
1:792f3de:       List<Resource> result = new ArrayList<Resource>();
1:792f3de: 
1:792f3de:       for (Resource old : list) {
1:792f3de:         boolean oldRedundant = satisfiesAll(r, resolver.getReason(old));
1:792f3de:         boolean newRedundant = satisfiesAll(old, resolver.getReason(r));
1:792f3de:         if (oldRedundant && newRedundant) {
1:792f3de:           int comp = old.getVersion().compareTo(r.getVersion());
1:792f3de:           oldRedundant = comp < 0;
1:792f3de:           newRedundant = comp >= 0;
1:792f3de:         }
1:792f3de:         
1:792f3de:         if (newRedundant) {
1:792f3de:           log.debug(LOG_EXIT, "mergeResource", list);
1:792f3de:           return list;
1:792f3de:         } else if (oldRedundant) {
1:792f3de:           // do nothing -> so don't add the old resource to the new list
1:792f3de:         } else {
1:792f3de:           result.add(old);
1:792f3de:         }
1:792f3de:       }
1:792f3de: 
1:792f3de:       result.add(r);
1:792f3de: 
1:792f3de:       log.debug(LOG_EXIT, "mergeResource", result);
42:792f3de:       
1:792f3de:       return result;
1:792f3de:     }
32:792f3de:   }
1:792f3de:   protected boolean satisfiesAll(Resource res, Reason[] reasons)
1:792f3de:   {
1:792f3de:     log.debug(LOG_ENTRY,"satisfiesAll", new Object[] {res, Arrays.toString(reasons)});
1:792f3de:     //Let's convert the reason to requirement
1:792f3de:     List<Requirement> reqs = new ArrayList<Requirement>();
1:792f3de:     for (Reason reason : reasons) {
1:792f3de:       reqs.add(reason.getRequirement());
1:792f3de:     }
1:792f3de:     boolean result = true;
1:792f3de:     
1:792f3de:     outer: for (Requirement r : reqs) {
1:792f3de:       boolean found = false;
1:792f3de:       inner: for (Capability c : res.getCapabilities()) {
1:792f3de:         if (r.isSatisfied(c)) {
1:792f3de:           found = true;
1:792f3de:           break inner;
1:792f3de:         }
1:792f3de:       }
1:792f3de:       
1:792f3de:       if (!!!found && !!!r.isOptional()) {
1:792f3de:         result = false;
1:792f3de:         break outer;
1:792f3de:       }
1:792f3de:     }
1:792f3de:     log.debug(LOG_EXIT, "satisfiesAll", result);
1:792f3de:     return result;
1:792f3de:   }
1:792f3de: 
1:792f3de:   private static final Set<String> SPECIAL_FILTER_ATTRS = Collections
1:792f3de:   .unmodifiableSet(new HashSet<String>(Arrays.asList(ModellingConstants.OBR_PACKAGE,
1:792f3de:       ModellingConstants.OBR_SYMBOLIC_NAME, ModellingConstants.OBR_SERVICE, Constants.VERSION_ATTRIBUTE)));
1:792f3de: 
1:792f3de:   /**
1:792f3de:    * Turn a requirement into a human readable String for debug.
1:792f3de:    * @param filter The filter that is failing
1:792f3de:    * @param bundlesFailing For problems with a bundle, the set of bundles that have a problem
1:792f3de:    * @return human readable form
1:792f3de:    */
1:9da7040:   private Map<String, String> extractConsumableMessageInfo(
1:9da7040:       Map<String, Set<String>> refinedReqs) {
1:9da7040:     log.debug(LOG_ENTRY, "extractConsumableMessageInfo", refinedReqs);
1:792f3de: 
1:9da7040:     Map<String, String> unsatisfiedRequirements = new HashMap<String, String>();
1:792f3de: 
1:9da7040:     for (Map.Entry<String, Set<String>> filterEntry : refinedReqs.entrySet()) {
1:58f55bd: 
1:9da7040:       String filter = filterEntry.getKey();
1:9da7040:       Set<String> bundlesFailing = filterEntry.getValue();
1:58f55bd: 
1:9da7040:       log.debug("unable to satisfy the filter , filter = "
1:9da7040:           + filter + "required by " + Arrays.toString(bundlesFailing.toArray()));
1:58f55bd: 
1:9da7040:       Map<String, String> attrs = ManifestHeaderProcessor.parseFilter(filter);
1:9da7040:       Map<String, String> customAttrs = new HashMap<String, String>();
1:9da7040:       for (Map.Entry<String, String> e : attrs.entrySet()) {
1:9da7040:         if (!SPECIAL_FILTER_ATTRS.contains(e.getKey())) {
1:9da7040:           customAttrs.put(e.getKey(), e.getValue());
1:58f55bd:         }
1:58f55bd:       }
1:9da7040: 
1:9da7040:       StringBuilder msgKey = new StringBuilder();
1:9da7040:       List<Object> inserts = new ArrayList<Object>();
1:9da7040: 
1:9da7040:       final String type;
1:9da7040:       boolean unknownType = false;
1:9da7040:       if (attrs.containsKey(ModellingConstants.OBR_PACKAGE)) {
1:9da7040:         type = ModellingConstants.OBR_PACKAGE;
1:9da7040:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_PACKAGE");
1:9da7040:         inserts.add(attrs.get(ModellingConstants.OBR_PACKAGE));
1:9da7040:       } else if (attrs.containsKey(ModellingConstants.OBR_SYMBOLIC_NAME)) {
1:9da7040:         type = ModellingConstants.OBR_SYMBOLIC_NAME;
1:9da7040:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_BUNDLE");
1:9da7040:         inserts.add(attrs.get(ModellingConstants.OBR_SYMBOLIC_NAME));
1:9da7040:       } else if (attrs.containsKey(ModellingConstants.OBR_SERVICE)) {
1:9da7040:         type = ModellingConstants.OBR_SERVICE;
1:9da7040:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_SERVICE");
1:9da7040:         // No insert for service name as the name must be "*" to match any
1:9da7040:         // Service capability
1:9da7040:       } else {
1:9da7040:         type = ModellingConstants.OBR_UNKNOWN;
1:9da7040:         unknownType = true;
1:9da7040:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_FILTER");
1:9da7040:         inserts.add(filter);
1:9da7040:       }
1:9da7040: 
1:9da7040:       if (bundlesFailing != null && bundlesFailing.size() != 0) {
1:9da7040:         msgKey.append("_REQUIRED_BY_BUNDLE");
1:9da7040:         if (bundlesFailing.size() == 1)
1:9da7040:           inserts.add(bundlesFailing.iterator().next()); // Just take the string
1:9da7040:                                                          // if there's only one
1:9da7040:                                                          // of them
1:9da7040:         else
1:9da7040:           inserts.add(bundlesFailing.toString()); // Add the whole set if there
1:9da7040:                                                   // isn't exactly one
1:9da7040:       }
1:9da7040:       if (!unknownType && !customAttrs.isEmpty()) {
1:9da7040:         msgKey.append("_WITH_ATTRS");
1:9da7040:         inserts.add(customAttrs);
1:9da7040:       }
1:9da7040: 
1:9da7040:       if (!unknownType && attrs.containsKey(Constants.VERSION_ATTRIBUTE)) {
1:9da7040:         msgKey.append("_WITH_VERSION");
1:9da7040:         VersionRange vr = ManifestHeaderProcessor.parseVersionRange(attrs
1:9da7040:             .get(Constants.VERSION_ATTRIBUTE));
1:9da7040:         inserts.add(vr.getMinimumVersion());
1:9da7040: 
1:9da7040:         if (!!!vr.isExactVersion()) {
1:9da7040:           msgKey.append(vr.isMinimumExclusive() ? "_LOWEX" : "_LOW");
1:9da7040:           if (vr.getMaximumVersion() != null) {
1:9da7040:             msgKey.append(vr.isMaximumExclusive() ? "_UPEX" : "_UP");
1:9da7040:             inserts.add(vr.getMaximumVersion());
1:9da7040:           }
1:9da7040:         }
1:9da7040:       }
1:9da7040: 
1:9da7040:       String msgKeyStr = msgKey.toString();
1:9da7040: 
1:9da7040:       String msg = MessageUtil.getMessage(msgKeyStr, inserts.toArray());
1:9da7040:       unsatisfiedRequirements.put(msg, type);
1:58f55bd:     }
1:58f55bd: 
1:9da7040:     log.debug(LOG_EXIT, "extractConsumableMessageInfo", unsatisfiedRequirements);
1:58f55bd: 
1:9da7040:     return unsatisfiedRequirements;
1:792f3de:   }
1:792f3de:   
1:792f3de:   /**
1:792f3de:    * Refine the unsatisfied requirements ready for later human comsumption
1:792f3de:    * 
1:792f3de:    * @param resolver The resolver to be used to refine the requirements
1:792f3de:    * @param reasons The reasons
1:792f3de:    * @return A map of the unsatifiedRequirement to the set of bundles that have that requirement unsatisfied (values associated with the keys can be null) 
1:792f3de:    */
1:792f3de:   private Map<String,Set<String>> refineUnsatisfiedRequirements(Resolver resolver, Reason[] reasons) {
1:792f3de:     log.debug(LOG_ENTRY, "refineUnsatisfiedRequirements", new Object[]{resolver, Arrays.toString(reasons)});
1:792f3de:     
1:792f3de:     Map<Requirement,Set<String>> req_resources = new HashMap<Requirement,Set<String>>();
1:792f3de:     // add the reasons to the map, use the requirement as the key, the resources required the requirement as the values
1:792f3de:     Set<Resource> resources = new HashSet<Resource>();
1:792f3de:     for (Reason reason: reasons) {
1:792f3de:       resources.add(reason.getResource());
1:792f3de:       Requirement key = reason.getRequirement();
1:792f3de:       String value = reason.getResource().getSymbolicName()+"_" + reason.getResource().getVersion().toString();
1:792f3de:       Set<String> values = req_resources.get(key);
1:792f3de:       if (values == null) {
1:792f3de:         values = new HashSet<String>();
1:792f3de:       }
1:792f3de:       values.add(value);
1:792f3de:       req_resources.put(key, values);
1:792f3de:     }
1:792f3de:     
1:792f3de:     // remove the requirements that can be satisifed by the resources. It is listed because the resources are not satisfied by other requirements.
1:792f3de:     // For an instance, the unsatisfied reasons are [package a, required by bundle aa], [package b, required by bundle bb] and [package c, required by bundle cc], 
1:792f3de:     // If the bundle aa exports the package a and c. In our error message, we only want to display package a is needed by bundle aa.
1:792f3de:     // Go through each requirement and find out whether the requirement can be satisfied by the reasons.
1:792f3de:     Set<Capability> caps = new HashSet<Capability>();
1:792f3de:     for (Resource res : resources) {
1:792f3de:       if ((res !=null) && (res.getCapabilities() != null)) {
1:792f3de:         
1:792f3de:       List<Capability> capList = Arrays.asList(res.getCapabilities());
1:792f3de:       if (capList != null) {
1:792f3de:       caps.addAll(capList);
1:792f3de:       }
1:792f3de:       }
1:792f3de:     }
1:792f3de:     Iterator<Map.Entry<Requirement, Set<String>>> iterator = req_resources.entrySet().iterator();
1:792f3de:     while (iterator.hasNext()) {
1:792f3de:       Map.Entry<Requirement, Set<String>> entry = iterator.next();
1:792f3de:       Requirement req = entry.getKey();
1:792f3de:       for (Capability cap :caps) {
1:3c9b85a:         if (req.isSatisfied(cap)){ // remove the key from the map
1:792f3de:           iterator.remove();
1:3c9b85a:           break;
1:792f3de:         }
1:792f3de:       }
1:792f3de:     }
1:792f3de:     //Now the map only contains the necessary missing requirements
1:792f3de:     
1:792f3de:       Map<String,Set<String>> result = new HashMap<String, Set<String>>();
1:792f3de:       for (Map.Entry<Requirement, Set<String>> req_res : req_resources.entrySet()) {
1:792f3de:         result.put(req_res.getKey().getFilter(), req_res.getValue());
1:792f3de:       }
1:792f3de:       log.debug(LOG_EXIT, "refineUnsatisfiedRequirements", new Object[]{result});
1:792f3de:       
1:792f3de:     return result;
1:cce7f7c:    }
1:792f3de:   
1:792f3de:  
1:792f3de:    
1:792f3de:    private Collection<ImportedBundle> toImportedBundle(Collection<Content> content) throws ResolverException
1:792f3de:    {
1:792f3de:      log.debug(LOG_ENTRY, "toImportedBundle", content);
1:792f3de: 
1:792f3de:      List<ImportedBundle> result = new ArrayList<ImportedBundle>();
1:792f3de:      for (Content c : content) {
1:58f55bd:        try {
1:58f55bd:        result.add(modellingManager.getImportedBundle(c.getContentName(), c.getVersion().toString()));
1:792f3de:        } catch (InvalidAttributeException iae) {
1:792f3de:          throw new ResolverException(iae);
1:792f3de:        }
1:792f3de:      }
1:792f3de:      log.debug(LOG_EXIT, "toImportedBundle", result);
1:792f3de:      return result;
1:792f3de:    }
1:792f3de:    
1:792f3de:    private Collection<ModelledResource> toModelledResource(Collection<BundleInfo> bundleInfos) throws ResolverException{
1:792f3de: 
1:792f3de:      Collection<ModelledResource> result = new ArrayList<ModelledResource>();
1:792f3de:     
1:792f3de:      if ((bundleInfos != null) && (!!!bundleInfos.isEmpty())) {
1:792f3de:        for (BundleInfo bi : bundleInfos) {
1:58f55bd:          try {
1:58f55bd:          result.add(modellingManager.getModelledResource(null, bi, null, null));
1:792f3de:          } catch (InvalidAttributeException iae) {
1:792f3de:            throw new ResolverException(iae);
1:792f3de:          }
1:792f3de:        }
1:792f3de:      }
1:792f3de:      return result;
1:792f3de:    }
1:792f3de:   
1:8702237:    private Repository getLocalRepository(RepositoryAdmin admin) 
1:792f3de:    {
1:8702237:        Repository localRepository = repositoryAdmin.getLocalRepository();
1:792f3de:        
1:8702237:        Resource[] resources = localRepository.getResources();
1:8702237: 
1:8702237:        Resource[] newResources = new Resource[resources.length];
1:8702237:        for (int i = 0; i < resources.length; i++) {
1:8702237:            newResources[i] = new ResourceWrapper(resources[i]); 
1:8702237:        }
1:8702237:        
1:8702237:        return repositoryAdmin.getHelper().repository(newResources);
1:8702237:    }
1:8702237:    
1:792f3de: 
1:57dfd78:    private boolean excludeLocalRuntime() {   
1:57dfd78:      return Boolean.parseBoolean(System.getProperty(AppConstants.PROVISON_EXCLUDE_LOCAL_REPO_SYSPROP));     
1:792f3de:    }
1:792f3de: 
1:792f3de: }
============================================================================
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:cce7f7c
/////////////////////////////////////////////////////////////////////////
1:       
1:     log.debug(LOG_ENTRY, "resolve", new Object[]{appName, appVersion,byValueBundles, inputs});
1:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles, false);
1:     log.debug(LOG_EXIT, "resolve");
1:     return doResolve(obrResolver, appName);    
1:   
1:   private Collection<ModelledResource> doResolve(Resolver obrResolver, String appName) throws ResolverException
1:   {
1:       log.debug(LOG_ENTRY, "doResolve");
1:       Collection<ModelledResource> toReturn = new ArrayList<ModelledResource>();
1:       if (obrResolver.resolve()) {
1:           
1:           List<Resource> requiredResources = retrieveRequiredResources(obrResolver);
1: 
1:           if (requiredResources == null) {
1:             log.debug("resolver.getRequiredResources() returned null");
1:           } else {
1: 
1:             for (Resource r : requiredResources) {
1:               Map<String, String> attribs = new HashMap<String, String>();
1:               attribs.put(Constants.VERSION_ATTRIBUTE, "[" + r.getVersion() + ',' + r.getVersion() + "]");
1:               ModelledResource modelledResourceForThisMatch = null; 
1:               // OBR may give us back the global capabilities. Typically these do not have a bundle symbolic name - they're a 
1:               // list of packages available in the target runtime environment. If the resource has no symbolic name, we can ignore it
1:               if (r.getSymbolicName() != null) { 
1:                 try { 
1:                   modelledResourceForThisMatch = new ModelledBundleResource (r, modellingManager, modellingHelper);
1:                 } catch (InvalidAttributeException iax) { 
1:                   ResolverException re = new ResolverException("Internal error occurred: " + iax);
1:                   log.debug(LOG_EXIT, "doResolve", re);
1:                   throw re;
1:                 }
1:                 toReturn.add(modelledResourceForThisMatch);
1:               }
1:             }
1:           }
1:           log.debug(LOG_EXIT, toReturn);
1:           return toReturn;
1:         } else {
1:           Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
1:           // let's refine the list by removing the indirect unsatisfied bundles that are caused by unsatisfied packages or other bundles
1:           Map<String,Set<String>> refinedReqs = refineUnsatisfiedRequirements(obrResolver, reasons);
1:           StringBuffer reqList = new StringBuffer();
1:           Map<String, String> unsatisfiedRequirements = extractConsumableMessageInfo(refinedReqs);
1: 
1:           for (String reason : unsatisfiedRequirements.keySet()) {
1:             reqList.append('\n');
1:             reqList.append(reason);
1:           }
1: 
1:           ResolverException re = new ResolverException(MessageUtil.getMessage("RESOLVER_UNABLE_TO_RESOLVE", new Object[] { appName, reqList }));
1:           re.setUnsatisfiedRequirementsAndReasons(unsatisfiedRequirements);
1: 
1:           log.debug(LOG_EXIT, "doResolve", re);
1:           throw re;
1:         }
1:   }
1:   
1: 
1:   @Override
1:   public Collection<ModelledResource> resolveInIsolation(String appName,
1:           String appVersion, Collection<ModelledResource> byValueBundles,
1:           Collection<Content> inputs) throws ResolverException {
1:       
1:       log.debug(LOG_ENTRY, "resolve", new Object[]{appName, appVersion,byValueBundles, inputs});
1:       Collection<ImportedBundle> importedBundles = toImportedBundle(inputs);
1:       
1:       Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles, true);
1:       // add a resource describing the requirements of the application metadata.
1:       obrResolver.add(createApplicationResource( appName, appVersion, importedBundles));
1:       
1:       log.debug(LOG_EXIT, "resolve");
1:       return doResolve(obrResolver, appName);   
1:   }  
1:   
1:       Collection<ModelledResource> byValueBundles, boolean noExtraRepositories) throws ResolverException
/////////////////////////////////////////////////////////////////////////
1: 
1:     
1:     if (!!!noExtraRepositories) {
1:         // add local repository if configured
1:         if (!(excludeLocalRuntime())) {
1:           resolveRepos.add(getLocalRepository(repositoryAdmin));
1:         }
1:         // Need to refresh the repositories added to repository admin 
1:         // add user-defined repositories
1:         Repository[] repos = repositoryAdmin.listRepositories();
1:         for (Repository r : repos) {
1:           resolveRepos.add(r);      
1:         }     
1:     }
/////////////////////////////////////////////////////////////////////////
1:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion.toString(), toModelledResource(app.getBundleInfo()), false);
/////////////////////////////////////////////////////////////////////////
1:    }
commit:c6cb34d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.io.IOUtils;
commit:de5b346
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:           Map<String, String> attribs = new HashMap<String, String>();
commit:910fec0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.utils.manifest.ContentFactory;
1: import org.apache.aries.util.VersionRange;
0: import org.apache.aries.util.filesystem.IOUtils;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
/////////////////////////////////////////////////////////////////////////
1:         contents.add(ContentFactory.parseContent(con.getBundleName(), con.getVersionRange().toString()));
commit:89f804e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.InvalidAttributeException;
1: import org.apache.aries.application.management.spi.repository.PlatformRepository;
0: import org.apache.aries.application.management.spi.repository.RepositoryGenerator;
1: import org.apache.aries.application.management.spi.resolve.AriesApplicationResolver;
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:fe213c6
/////////////////////////////////////////////////////////////////////////
1:     // bundleVersion is an exact version - so ensure right version filter is generated
1:     VersionRange range = ManifestHeaderProcessor.parseVersionRange(bundleVersion.toString(), true);
1:     attribs.put(Resource.VERSION, range.toString());
commit:8702237
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.resolver.obr.impl.ResourceWrapper;
/////////////////////////////////////////////////////////////////////////
0:     resolveRepos.add(getLocalRepository(repositoryAdmin));
/////////////////////////////////////////////////////////////////////////
1:   private Repository getLocalRepository(RepositoryAdmin admin) 
1:   {
1:       Repository localRepository = repositoryAdmin.getLocalRepository();
1:       
1:       Resource[] resources = localRepository.getResources();
1: 
1:       Resource[] newResources = new Resource[resources.length];
1:       for (int i = 0; i < resources.length; i++) {
1:           newResources[i] = new ResourceWrapper(resources[i]); 
1:       }
1:       
1:       return repositoryAdmin.getHelper().repository(newResources);
1:   }
1:   
commit:9b0cfd6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private final RepositoryAdmin repositoryAdmin;  
1:   private boolean returnOptionalResources = true;
1:   
1:   public void setReturnOptionalResources(boolean optional) 
1:   {
1:     this.returnOptionalResources = optional;
1:   }
1:   
1:   public boolean getReturnOptionalResources() 
1:   {
1:     return returnOptionalResources;
1:   }
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:     
1:     // add system repository
1:     resolveRepos.add(repositoryAdmin.getSystemRepository());
1:     
0:     // add local repository
0:     resolveRepos.add(repositoryAdmin.getLocalRepository());
1:     
1:     // add application repository
0:     // add user-defined repositories
0:     Repository[] repos = repositoryAdmin.listRepositories();
0:       resolveRepos.add(r);      
1:         
1:         BundleInfo bundleInfo = toBundleInfo(resource, false);
1:       if (returnOptionalResources) {
1:         for (Resource resource: obrResolver.getOptionalResources()) {
1:           BundleInfo bundleInfo = toBundleInfo(resource, true);
1:           result.add(bundleInfo);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return toBundleInfo(resources[0], false);
1:       log.error("Invalid filter", e);
/////////////////////////////////////////////////////////////////////////
1:   private BundleInfo toBundleInfo(Resource resource, boolean optional)
1:     Map<String, String> directives = null;
1:     if (optional) {
1:       directives = new HashMap<String, String>();
1:       directives.put(Constants.RESOLUTION_DIRECTIVE, Constants.RESOLUTION_OPTIONAL);
1:     }
1:                              resource.getVersion(),
0:                              location,
1:                              null,
1:                              null,
1:                              null,
1:                              null,
1:                              null, 
1:                              null,
1:                              directives,
1:                              null);
1: }
author:Holly Cummins
-------------------------------------------------------------------------------
commit:17170a0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.resolver.obr.ext.ModelledBundleResource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			Collection<ModelledResource> byValueBundles, Collection<Content> inputs)
0:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles);
/////////////////////////////////////////////////////////////////////////
0:       Collection<ModelledResource> byValueBundles) throws ResolverException
/////////////////////////////////////////////////////////////////////////
1: 
commit:605729d
/////////////////////////////////////////////////////////////////////////
1:       for (String reason : unsatisfiedRequirements.keySet()) {
/////////////////////////////////////////////////////////////////////////
0:       for (String reason : unsatisfiedRequirements.keySet()) {
commit:9da7040
/////////////////////////////////////////////////////////////////////////
1:       Map<String, String> unsatisfiedRequirements = extractConsumableMessageInfo(refinedReqs);
0:       for (String reason : unsatisfiedRequirements.values()) {
1:       re.setUnsatisfiedRequirementsAndReasons(unsatisfiedRequirements);
/////////////////////////////////////////////////////////////////////////
0:       Map<String, String> unsatisfiedRequirements = extractConsumableMessageInfo(refinedReqs);
0:       for (String reason : unsatisfiedRequirements.values()) {
0:       re.setUnsatisfiedRequirementsAndReasons(unsatisfiedRequirements);
/////////////////////////////////////////////////////////////////////////
1:   private Map<String, String> extractConsumableMessageInfo(
1:       Map<String, Set<String>> refinedReqs) {
1:     log.debug(LOG_ENTRY, "extractConsumableMessageInfo", refinedReqs);
1:     Map<String, String> unsatisfiedRequirements = new HashMap<String, String>();
1:     for (Map.Entry<String, Set<String>> filterEntry : refinedReqs.entrySet()) {
1:       String filter = filterEntry.getKey();
1:       Set<String> bundlesFailing = filterEntry.getValue();
1:       log.debug("unable to satisfy the filter , filter = "
1:           + filter + "required by " + Arrays.toString(bundlesFailing.toArray()));
1:       Map<String, String> attrs = ManifestHeaderProcessor.parseFilter(filter);
1:       Map<String, String> customAttrs = new HashMap<String, String>();
1:       for (Map.Entry<String, String> e : attrs.entrySet()) {
1:         if (!SPECIAL_FILTER_ATTRS.contains(e.getKey())) {
1:           customAttrs.put(e.getKey(), e.getValue());
1: 
1:       StringBuilder msgKey = new StringBuilder();
1:       List<Object> inserts = new ArrayList<Object>();
1: 
1:       final String type;
1:       boolean unknownType = false;
1:       if (attrs.containsKey(ModellingConstants.OBR_PACKAGE)) {
1:         type = ModellingConstants.OBR_PACKAGE;
1:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_PACKAGE");
1:         inserts.add(attrs.get(ModellingConstants.OBR_PACKAGE));
1:       } else if (attrs.containsKey(ModellingConstants.OBR_SYMBOLIC_NAME)) {
1:         type = ModellingConstants.OBR_SYMBOLIC_NAME;
1:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_BUNDLE");
1:         inserts.add(attrs.get(ModellingConstants.OBR_SYMBOLIC_NAME));
1:       } else if (attrs.containsKey(ModellingConstants.OBR_SERVICE)) {
1:         type = ModellingConstants.OBR_SERVICE;
1:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_SERVICE");
1:         // No insert for service name as the name must be "*" to match any
1:         // Service capability
1:       } else {
1:         type = ModellingConstants.OBR_UNKNOWN;
1:         unknownType = true;
1:         msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_FILTER");
1:         inserts.add(filter);
1:       }
1: 
1:       if (bundlesFailing != null && bundlesFailing.size() != 0) {
1:         msgKey.append("_REQUIRED_BY_BUNDLE");
1:         if (bundlesFailing.size() == 1)
1:           inserts.add(bundlesFailing.iterator().next()); // Just take the string
1:                                                          // if there's only one
1:                                                          // of them
1:         else
1:           inserts.add(bundlesFailing.toString()); // Add the whole set if there
1:                                                   // isn't exactly one
1:       }
1:       if (!unknownType && !customAttrs.isEmpty()) {
1:         msgKey.append("_WITH_ATTRS");
1:         inserts.add(customAttrs);
1:       }
1: 
1:       if (!unknownType && attrs.containsKey(Constants.VERSION_ATTRIBUTE)) {
1:         msgKey.append("_WITH_VERSION");
1:         VersionRange vr = ManifestHeaderProcessor.parseVersionRange(attrs
1:             .get(Constants.VERSION_ATTRIBUTE));
1:         inserts.add(vr.getMinimumVersion());
1: 
1:         if (!!!vr.isExactVersion()) {
1:           msgKey.append(vr.isMinimumExclusive() ? "_LOWEX" : "_LOW");
1:           if (vr.getMaximumVersion() != null) {
1:             msgKey.append(vr.isMaximumExclusive() ? "_UPEX" : "_UP");
1:             inserts.add(vr.getMaximumVersion());
1:           }
1:         }
1:       }
1: 
1:       String msgKeyStr = msgKey.toString();
1: 
1:       String msg = MessageUtil.getMessage(msgKeyStr, inserts.toArray());
1:       unsatisfiedRequirements.put(msg, type);
1:     log.debug(LOG_EXIT, "extractConsumableMessageInfo", unsatisfiedRequirements);
1:     return unsatisfiedRequirements;
commit:2901df4
/////////////////////////////////////////////////////////////////////////
0: 	public Collection<ModelledResource> resolve(String appName,
0: 			String appVersion, Collection<ModelledResource> byValueBundles,
0: 			Collection<Content> inputs) throws ResolverException {
0: 		return resolve(appName, appVersion, byValueBundles,
0: 				inputs, this.platformRepository);
1: 	}
1: 
1: /**
/////////////////////////////////////////////////////////////////////////
1:    * @param platformRepository - a platform repository to use instead of the one provided as a service
1:   public Collection<ModelledResource> resolve(String appName, String appVersion,
0: 			Collection<ModelledResource> byValueBundles, Collection<Content> inputs, PlatformRepository platformRepository)
1: 			throws ResolverException {
0:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles, platformRepository);
/////////////////////////////////////////////////////////////////////////
0: 	      Collection<ModelledResource> byValueBundles) throws ResolverException
1: 	      {
1: 	 
0: 	  return getConfiguredObrResolver(appName, appVersion, byValueBundles, platformRepository);
1: 	      }
1: 
1:   private Resolver getConfiguredObrResolver(String appName, String appVersion,
0:       Collection<ModelledResource> byValueBundles, PlatformRepository platformRepository) throws ResolverException
/////////////////////////////////////////////////////////////////////////
1:     addPlatformRepositories (obrResolver, appName, platformRepository);
/////////////////////////////////////////////////////////////////////////
1:   private void addPlatformRepositories (Resolver obrResolver, String appName, PlatformRepository platformRepository)
/////////////////////////////////////////////////////////////////////////
1:             // not a big problem
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:06fa967
/////////////////////////////////////////////////////////////////////////
0:         log.debug("unable to satisfy the filter , filter = " + filterEntry.getKey() + "required by "+filterEntry.getValue());
commit:1c24caa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       inserts.add(customAttrs);
commit:3c9b85a
/////////////////////////////////////////////////////////////////////////
1:         if (req.isSatisfied(cap)){ // remove the key from the map
1:           break;
commit:8589750
/////////////////////////////////////////////////////////////////////////
0:           // OBR may give us back the global capabilities. Typically these do not have a bundle symbolic name - they're a 
0:           // list of packages available in the target runtime environment. If the resource has no symbolic name, we can ignore it
0:           if (r.getSymbolicName() != null) { 
1:             try { 
0:               modelledResourceForThisMatch = new ModelledBundleResource (r, modellingManager, modellingHelper);
0:             } catch (InvalidAttributeException iax) { 
1:               
0:               ResolverException re = new ResolverException("Internal error occurred: " + iax.toString());
1:               log.debug(LOG_EXIT, "resolve", re);
1:               
1:               throw re;
1:             }
0:             toReturn.add(modelledResourceForThisMatch);
commit:4c637b1
/////////////////////////////////////////////////////////////////////////
1:     log.debug(LOG_ENTRY, "addPlatformRepositories", new Object[]{obrResolver, appName});
/////////////////////////////////////////////////////////////////////////
1:     log.debug(LOG_EXIT, "addPlatformRepositories");
commit:04c5141
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.utils.filesystem.IOUtils;
/////////////////////////////////////////////////////////////////////////
1:     
1: 
1:     
/////////////////////////////////////////////////////////////////////////
0:     addPlatformRepositories (obrResolver, appName);
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
0:     addPlatformRepositories (obrResolver, appName);
1:     
/////////////////////////////////////////////////////////////////////////
1:   /* A 'platform repository' describes capabilities of the target runtime environment
1:    * These should be added to the resolver without being listed as coming from a particular 
1:    * repository or bundle.  
1:    */
0:   private void addPlatformRepositories (Resolver obrResolver, String appName)
1:   { 
1:     DataModelHelper helper = repositoryAdmin.getHelper();
1:     if (platformRepository != null) {
1:       Collection<URI> uris = platformRepository.getPlatformRepositoryURLs();
1:       if ((uris != null) && (!uris.isEmpty())) {
1:         for (URI uri : uris) {
1:           InputStream is = null;
1:           try {
1:             is = uri.toURL().openStream();
1:             Reader repoReader = new InputStreamReader(is);
1:             Repository aPlatformRepo = helper.readRepository(repoReader);
1:             Resource resources[] = aPlatformRepo.getResources();
1:             for (Resource r : resources) { 
1:               Capability[] caps = r.getCapabilities();
1:               for (Capability c : caps) { 
1:                 obrResolver.addGlobalCapability(c);
1:               }
1:             }
1:           } catch (Exception e) {
0:             // no a big problem
1:             log.error(MessageUtil.getMessage("RESOLVER_UNABLE_TO_READ_REPOSITORY_EXCEPTION", new Object[]{appName, uri}) );
1:           } finally { 
1:             IOUtils.close(is);
1:           }
1:         }
1:       }
1:     }
1:   }
1:   
commit:58f55bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.ModellingConstants;
1: import org.apache.aries.application.modelling.ModellingManager;
1: import org.apache.aries.application.modelling.utils.ModellingHelper;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private ModellingManager modellingManager;
1:   private ModellingHelper modellingHelper;
1:   
1:   public void setModellingManager (ModellingManager m) { 
1:     modellingManager = m;
1:   }
1:   
1:   public void setModellingHelper (ModellingHelper mh) { 
1:     modellingHelper = mh;
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:   
1:   /**
1:    * Resolve a list of resources from the OBR bundle repositories by OBR
1:    * resolver.
1:    * 
1:    * @param appName - application name
1:    * @param appVersion - application version
1:    * @param byValueBundles - by value bundles
1:    * @param inputs - other constraints
1:    * @return a collection of modelled resources required by this application
1:    * @throws ResolverException
1:    */
1:   @Override
0:    public Collection<ModelledResource> resolve(String appName, String appVersion,
0:       Collection<ModelledResource> byValueBundles, Collection<Content> inputs) throws ResolverException
1:   {
0:      log.debug(LOG_ENTRY, "resolve", new Object[]{appName, appVersion,byValueBundles, inputs});
1:     Collection<ImportedBundle> importedBundles = toImportedBundle(inputs);
1:     DataModelHelper helper = repositoryAdmin.getHelper();
1: 
1:    
0:     Collection<ModelledResource> toReturn = new ArrayList<ModelledResource>();
1:     Repository appRepo;
1:     try {      
1:       ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:       RepositoryGeneratorImpl.generateRepository(repositoryAdmin, appName + "_" + appVersion, byValueBundles, bytesOut);
1:       appRepo = helper.readRepository(new InputStreamReader(new ByteArrayInputStream(bytesOut.toByteArray())));
1:     } catch (Exception e) {
1:       throw new ResolverException(e);
1:     } 
1:         
1:     List<Repository> resolveRepos = new ArrayList<Repository>();
0:     // add system repository
0:     resolveRepos.add(repositoryAdmin.getSystemRepository());
0:     // add local repository
0:     resolveRepos.add(getLocalRepository(repositoryAdmin));
0:     // add application repository
1:     resolveRepos.add(appRepo);
0:     // add the user-defined repositories 
0:     if (platformRepository != null) {
0:       Collection<URI> uris = platformRepository.getPlatformRepositoryURLs();
0:       if ((uris != null) && (!uris.isEmpty())) {
0:         for (URI uri : uris) {
1:           try {
0:             resolveRepos.add(helper.readRepository(uri.toString()));
1:           } catch (Exception e) {
0:             // no a big problem
0:             log.error(MessageUtil.getMessage("RESOLVER_UNABLE_TO_READ_REPOSITORY_EXCEPTION", new Object[]{appName, uri}) );
1:           }
1:         }
1:       }
1:     }
0:    // Need to refresh the repositories added to repository admin
1:     
0:     // add user-defined repositories
0:     Repository[] repos = repositoryAdmin.listRepositories();
0:     for (Repository r : repos) {
0:       resolveRepos.add(r);      
1:     }     
1:     Resolver obrResolver = repositoryAdmin.resolver(resolveRepos.toArray(new Repository[resolveRepos.size()]));
1:     // add a resource describing the requirements of the application metadata.
1:     obrResolver.add(createApplicationResource( appName, appVersion, importedBundles));
1:     if (obrResolver.resolve()) {
1:       
1:       List<Resource> requiredResources = retrieveRequiredResources(obrResolver);
1: 
0:       if (requiredResources == null) {
0:         log.debug("resolver.getRequiredResources() returned null");
1:       } else {
1: 
0:         for (Resource r : requiredResources) {
0:           NameValueMap<String, String> attribs = new NameValueMap<String, String>();
0:           attribs.put(Constants.VERSION_ATTRIBUTE, "[" + r.getVersion() + ',' + r.getVersion()
0:               + "]");
0:           ModelledResource modelledResourceForThisMatch = null; 
1:           try { 
0:             modelledResourceForThisMatch = new ModelledBundleResource (r, modellingManager, modellingHelper);
0:           } catch (InvalidAttributeException iax) { 
1:             
0:             ResolverException re = new ResolverException("Internal error occurred: " + iax.toString());
0:             log.debug(LOG_EXIT, "resolve", re);
1:             
0:             throw re;
1:           }
0:           toReturn.add(modelledResourceForThisMatch);
1:         }
1:       }
0:       log.debug(LOG_EXIT, "resolve", toReturn); 
0:       return toReturn;
1:     } else {
1:       Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
0:       // let's refine the list by removing the indirect unsatisfied bundles that are caused by unsatisfied packages or other bundles
1:       Map<String,Set<String>> refinedReqs = refineUnsatisfiedRequirements(obrResolver, reasons);
1:       StringBuffer reqList = new StringBuffer();
0:       List<String> unsatisfiedRequirements = new LinkedList<String>();
1: 
0:       for (Map.Entry<String, Set<String>> filterEntry : refinedReqs.entrySet()) {
0:         log.debug("unable to satisfied the filter , filter = " + filterEntry.getKey() + "required by "+filterEntry.getValue());
1:        
0:         String reason = extractConsumableMessageInfo(filterEntry.getKey(),filterEntry.getValue());
1: 
1:         reqList.append('\n');
1:         reqList.append(reason);
0:         unsatisfiedRequirements.add(reason);
1:       }
1: 
1:       ResolverException re = new ResolverException(MessageUtil.getMessage("RESOLVER_UNABLE_TO_RESOLVE", 
0:           new Object[] { appName, reqList }));
0:       re.setUnsatisfiedRequirements(unsatisfiedRequirements);
0:       log.debug(LOG_EXIT, "resolve", re);
1:       
0:       throw re;
1:     }
1:     
1:   }
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   @Override
/////////////////////////////////////////////////////////////////////////
1:   private Resource createApplicationResource( String appName, Version appVersion,
1:       List<Content> appContent)
1:   {
1:     return new ApplicationResourceImpl(appName, appVersion, appContent);
1:   }
1:   
1:   private Resource createApplicationResource( String appName, String appVersion,
1:       Collection<ImportedBundle> inputs)
1:   {
1:     return new ApplicationResourceImpl(appName, Version.parseVersion(appVersion), inputs);
1:   }
/////////////////////////////////////////////////////////////////////////
0:   private String extractConsumableMessageInfo(String filter, Set<String> bundlesFailing)
/////////////////////////////////////////////////////////////////////////
1:  
/////////////////////////////////////////////////////////////////////////
1:        result.add(modellingManager.getImportedBundle(c.getContentName(), c.getVersion().toString()));
/////////////////////////////////////////////////////////////////////////
1:          result.add(modellingManager.getModelledResource(null, bi, null, null));
commit:d04041b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.resolver.obr.impl.RepositoryGeneratorImpl;
/////////////////////////////////////////////////////////////////////////
1:  
/////////////////////////////////////////////////////////////////////////
0:       RepositoryGeneratorImpl.generateRepository(repositoryAdmin, appName + "_" + appVersion, toModelledResource(app.getBundleInfo()), bytesOut);
/////////////////////////////////////////////////////////////////////////
0:       RepositoryGeneratorImpl.generateRepository(repositoryAdmin, appName + "_" + appVersion, byValueBundles, bytesOut);
commit:792f3de
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1: 
1: import java.net.URI;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Iterator;
0: import java.util.LinkedList;
0: import org.apache.aries.application.VersionRange;
0: import org.apache.aries.application.management.InvalidAttributeException;
0: import org.apache.aries.application.management.PlatformRepository;
0: import org.apache.aries.application.management.RepositoryGenerator;
1: import org.apache.aries.application.modelling.ImportedBundle;
1: import org.apache.aries.application.modelling.ModelledResource;
0: import org.apache.aries.application.modelling.utils.ModellingConstants;
0: import org.apache.aries.application.modelling.utils.ModellingManager;
1: import org.apache.aries.application.resolver.internal.MessageUtil;
0: import org.apache.aries.application.resolver.obr.impl.ModelledBundleResource;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValueMap;
1: import org.apache.felix.bundlerepository.Capability;
1: import org.apache.felix.bundlerepository.Requirement;
/////////////////////////////////////////////////////////////////////////
1:   private PlatformRepository platformRepository;
1:   public PlatformRepository getPlatformRepository()
1:   {
1:     return platformRepository;
1:   }
1: 
0:   private RepositoryGenerator repositoryGenerator;
0:   public void setRepositoryGenerator(RepositoryGenerator rg) {
0:     this.repositoryGenerator=rg;
1:   }
1:   
0:   public RepositoryGenerator getRepositoryGenerator() {
0:     return this.repositoryGenerator;
1:   }
1:   
1:   public  RepositoryAdmin getRepositoryAdmin() {
1:     return this.repositoryAdmin;
1:   }
1:   public void setPlatformRepository(PlatformRepository platformRepository)
1:   {
1:     this.platformRepository = platformRepository;
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:  
1:   @Deprecated
1:     
1:     Collection<Content> useBundleContent = appMeta.getUseBundles();
1:     List<Content> contents = new ArrayList<Content>();
1:     contents.addAll(appContent);
1:     contents.addAll(useBundleContent);
1:     if ((constraints != null ) && (constraints.length > 0 )) {
1:       for (ResolveConstraint con: constraints) {
0:         contents.add(ManifestHeaderProcessor.parseContent(con.getBundleName(), con.getVersionRange().toString()));
1:       }
1:     }
1: 
0:       repositoryGenerator.generateRepository(appName + "_" + appVersion, toModelledResource(app.getBundleInfo()), bytesOut);
/////////////////////////////////////////////////////////////////////////
0:  // add local repository
0:     // add the user-defined repositories 
0:     if (platformRepository != null) {
0:       Collection<URI> uris = platformRepository.getPlatformRepositoryURLs();
0:       //No need to add repository admin as it does not contain bundles.
0:       // Just pass to the resolver when doing resolving.
0:       if ((uris != null) && (!uris.isEmpty())) {
0:         for (URI uri : uris) {
0:           try {
0:             resolveRepos.add(helper.readRepository(uri.toString()));
0:           } catch (Exception e) {
0:             // no a big problem
0:             log.error(MessageUtil.getMessage("RESOLVER_UNABLE_TO_READ_REPOSITORY_EXCEPTION", new Object[]{appName, uri}) );
1:           }
1:         }
1:       }
0:       // add these real repositories to the repository admin as the bundles within can be discovered when calling getBundleInfo();
1:     }
1:     }    
1:     obrResolver.add(createApplicationResource( appName, appVersion, contents));
1:      Set<BundleInfo> result = new HashSet<BundleInfo>();
0:       List<Resource> requiredResources = retrieveRequiredResources(obrResolver);
1:       
1:       for (Resource resource: requiredResources) {
/////////////////////////////////////////////////////////////////////////
1:             
0:       Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
1:       //refine the list by removing the indirect unsatisfied bundles that are caused by unsatisfied packages or other bundles
0:       Map<String,Set<String>> refinedReqs = refineUnsatisfiedRequirements(obrResolver, reasons);
0:       StringBuffer reqList = new StringBuffer();
0:       List<String> unsatisfiedRequirements = new LinkedList<String>();
0:       for (Map.Entry<String, Set<String>> filterEntry : refinedReqs.entrySet()) {
0:         log.debug("unable to satisfied the filter , filter = " + filterEntry.getKey() + "required by "+filterEntry.getValue());
1:        
0:         String reason = extractConsumableMessageInfo(filterEntry.getKey(),filterEntry.getValue());
0:         reqList.append('\n');
0:         reqList.append(reason);
0:         unsatisfiedRequirements.add(reason);
1: 
0:       ResolverException re = new ResolverException(MessageUtil.getMessage("RESOLVER_UNABLE_TO_RESOLVE", 
1:           new Object[] { app.getApplicationMetadata().getApplicationName(), reqList }));
0:       re.setUnsatisfiedRequirements(unsatisfiedRequirements);
0:       log.debug(LOG_EXIT, "resolve", re);
0:       throw re;
1:     }
1:       
0:   private Resource createApplicationResource( String appName, Version appVersion,
1:   
0:   private Resource createApplicationResource( String appName, String appVersion,
0:       Collection<ImportedBundle> inputs)
1:   {
0:     return new ApplicationResourceImpl(appName, Version.parseVersion(appVersion), inputs);
1:   }
/////////////////////////////////////////////////////////////////////////
1:   
0:   private BundleInfo toBundleInfo(Resource resource, boolean optional) 
1:     
1: 
1:                              resource.getURI(),
/////////////////////////////////////////////////////////////////////////
1:     
1:   
1:   /**
1:    * Get the list of resources returned by the resolver
1:    * @param resolver OBR resolver
1:    * @return a list of required resources
1:    */
1:   protected List<Resource> retrieveRequiredResources(Resolver resolver)
1:   {
1:     log.debug(LOG_ENTRY,"retrieveRequiredResources", resolver);
1:     Map<String, List<Resource>> resourcesByName = new HashMap<String, List<Resource>>();
1: 
1:     for (Resource r : resolver.getRequiredResources()) {
1:       resourcesByName.put(r.getSymbolicName(), mergeResource(resolver, r, resourcesByName.get(r
1:           .getSymbolicName())));
1:     }
1: 
1:     List<Resource> result = new ArrayList<Resource>();
1:     for (List<Resource> res : resourcesByName.values()) {
1:       result.addAll(res);
1:     }
1: 
1:     log.debug(LOG_EXIT,  "retrieveRequiredResources", result);
1:     return result;
1:   }
1: 
1:   
1: /**
1:  * Get rid of the redundant resources
1:  * @param resolver OBR resolver
1:  * @param r a resource
1:  * @param list similar resources
1:  * @return the list of minimum resources
1:  */
1:   protected List<Resource> mergeResource(Resolver resolver, Resource r,
1:       List<Resource> list)
1:   {
1:     log.debug(LOG_ENTRY, "mergeResource", new Object[]{resolver, r, list});
1:     
1:     if (list == null) {
1:       log.debug(LOG_EXIT, "mergeResource", Arrays.asList(r));
1:       return Arrays.asList(r);
1:     } else {
1:       List<Resource> result = new ArrayList<Resource>();
1: 
1:       for (Resource old : list) {
1:         boolean oldRedundant = satisfiesAll(r, resolver.getReason(old));
1:         boolean newRedundant = satisfiesAll(old, resolver.getReason(r));
1:         if (oldRedundant && newRedundant) {
1:           int comp = old.getVersion().compareTo(r.getVersion());
1:           oldRedundant = comp < 0;
1:           newRedundant = comp >= 0;
1:         }
1:         
1:         if (newRedundant) {
1:           log.debug(LOG_EXIT, "mergeResource", list);
1:           return list;
1:         } else if (oldRedundant) {
1:           // do nothing -> so don't add the old resource to the new list
1:         } else {
1:           result.add(old);
1:         }
1:       }
1: 
1:       result.add(r);
1: 
1:       log.debug(LOG_EXIT, "mergeResource", result);
1:       
1:       return result;
1:     }
1:   }
1:   protected boolean satisfiesAll(Resource res, Reason[] reasons)
1:   {
1:     log.debug(LOG_ENTRY,"satisfiesAll", new Object[] {res, Arrays.toString(reasons)});
1:     //Let's convert the reason to requirement
1:     List<Requirement> reqs = new ArrayList<Requirement>();
1:     for (Reason reason : reasons) {
1:       reqs.add(reason.getRequirement());
1:     }
1:     boolean result = true;
1:     
1:     outer: for (Requirement r : reqs) {
1:       boolean found = false;
1:       inner: for (Capability c : res.getCapabilities()) {
1:         if (r.isSatisfied(c)) {
1:           found = true;
1:           break inner;
1:         }
1:       }
1:       
1:       if (!!!found && !!!r.isOptional()) {
1:         result = false;
1:         break outer;
1:       }
1:     }
1:     log.debug(LOG_EXIT, "satisfiesAll", result);
1:     return result;
1:   }
1: 
1:   private static final Set<String> SPECIAL_FILTER_ATTRS = Collections
1:   .unmodifiableSet(new HashSet<String>(Arrays.asList(ModellingConstants.OBR_PACKAGE,
1:       ModellingConstants.OBR_SYMBOLIC_NAME, ModellingConstants.OBR_SERVICE, Constants.VERSION_ATTRIBUTE)));
1: 
1:   /**
1:    * Turn a requirement into a human readable String for debug.
1:    * @param filter The filter that is failing
1:    * @param bundlesFailing For problems with a bundle, the set of bundles that have a problem
1:    * @return human readable form
1:    */
0:   public String extractConsumableMessageInfo(String filter, Set<String> bundlesFailing)
1:   {
0:     log.debug(LOG_ENTRY, "extractConsumableMessageInfo", new Object[] {filter, bundlesFailing});
1:     
0:     Map<String, String> attrs = ManifestHeaderProcessor.parseFilter(filter);
0:     Map<String, String> customAttrs = new HashMap<String, String>();
0:     for (Map.Entry<String, String> e : attrs.entrySet()) {
0:       if (!SPECIAL_FILTER_ATTRS.contains(e.getKey())) {
0:         customAttrs.put(e.getKey(), e.getValue());
1:       }
1:     }
1: 
0:     StringBuilder msgKey = new StringBuilder();
0:     List<Object> inserts = new ArrayList<Object>();
1: 
0:     boolean unknownType = false;
0:     if (attrs.containsKey(ModellingConstants.OBR_PACKAGE)) {
0:       msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_PACKAGE");
0:       inserts.add(attrs.get(ModellingConstants.OBR_PACKAGE));
0:     } else if (attrs.containsKey(ModellingConstants.OBR_SYMBOLIC_NAME)) {
0:       msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_BUNDLE");
0:       inserts.add(attrs.get(ModellingConstants.OBR_SYMBOLIC_NAME));
0:     } else if (attrs.containsKey(ModellingConstants.OBR_SERVICE)) {
0:       msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_SERVICE");
0:       //No insert for service name as the name must be "*" to match any Service capability
1:     } else {
0:       unknownType = true;
0:       msgKey.append("RESOLVER_UNABLE_TO_RESOLVE_FILTER");
0:       inserts.add(filter);
1:     }
1: 
0:     if (!unknownType && !customAttrs.isEmpty()) {
0:       inserts.add(customAttrs);    
1:     }
0:     if (bundlesFailing != null && bundlesFailing.size() != 0) {
0:       msgKey.append("_REQUIRED_BY_BUNDLE");
0:       if (bundlesFailing.size() == 1)
0:         inserts.add(bundlesFailing.iterator().next()); // Just take the string if there's only one of them
0:       else
0:         inserts.add(bundlesFailing.toString()); // Add the whole set if there isn't exactly one
1:     }
0:     if (!unknownType && !customAttrs.isEmpty()) {
0:       msgKey.append("_WITH_ATTRS");
1:     }
1: 
0:     if (!unknownType && attrs.containsKey(Constants.VERSION_ATTRIBUTE)) {
0:       msgKey.append("_WITH_VERSION");
0:       VersionRange vr = ManifestHeaderProcessor.parseVersionRange(attrs
0:           .get(Constants.VERSION_ATTRIBUTE));
0:       inserts.add(vr.getMinimumVersion());
1: 
0:       if (!!!vr.isExactVersion()) {
0:         msgKey.append(vr.isMinimumExclusive() ? "_LOWEX" : "_LOW");
0:         if (vr.getMaximumVersion() != null) {
0:           msgKey.append(vr.isMaximumExclusive() ? "_UPEX" : "_UP");
0:           inserts.add(vr.getMaximumVersion());
1:         }
1:       }
1:     }
1: 
0:     String msgKeyStr = msgKey.toString();
1:     
0:     String msg = MessageUtil.getMessage(msgKeyStr, inserts.toArray());
1: 
0:     log.debug(LOG_EXIT, "extractConsumableMessageInfo", msg);
1:     
0:     return msg;
1:   }
1:   
1:   /**
1:    * Refine the unsatisfied requirements ready for later human comsumption
1:    * 
1:    * @param resolver The resolver to be used to refine the requirements
1:    * @param reasons The reasons
1:    * @return A map of the unsatifiedRequirement to the set of bundles that have that requirement unsatisfied (values associated with the keys can be null) 
1:    */
1:   private Map<String,Set<String>> refineUnsatisfiedRequirements(Resolver resolver, Reason[] reasons) {
1:     log.debug(LOG_ENTRY, "refineUnsatisfiedRequirements", new Object[]{resolver, Arrays.toString(reasons)});
1:     
1:     Map<Requirement,Set<String>> req_resources = new HashMap<Requirement,Set<String>>();
1:     // add the reasons to the map, use the requirement as the key, the resources required the requirement as the values
1:     Set<Resource> resources = new HashSet<Resource>();
1:     for (Reason reason: reasons) {
1:       resources.add(reason.getResource());
1:       Requirement key = reason.getRequirement();
1:       String value = reason.getResource().getSymbolicName()+"_" + reason.getResource().getVersion().toString();
1:       Set<String> values = req_resources.get(key);
1:       if (values == null) {
1:         values = new HashSet<String>();
1:       }
1:       values.add(value);
1:       req_resources.put(key, values);
1:     }
1:     
1:     // remove the requirements that can be satisifed by the resources. It is listed because the resources are not satisfied by other requirements.
1:     // For an instance, the unsatisfied reasons are [package a, required by bundle aa], [package b, required by bundle bb] and [package c, required by bundle cc], 
1:     // If the bundle aa exports the package a and c. In our error message, we only want to display package a is needed by bundle aa.
1:     // Go through each requirement and find out whether the requirement can be satisfied by the reasons.
1:     Set<Capability> caps = new HashSet<Capability>();
1:     for (Resource res : resources) {
1:       if ((res !=null) && (res.getCapabilities() != null)) {
1:         
1:       List<Capability> capList = Arrays.asList(res.getCapabilities());
1:       if (capList != null) {
1:       caps.addAll(capList);
1:       }
1:       }
1:     }
1:     Iterator<Map.Entry<Requirement, Set<String>>> iterator = req_resources.entrySet().iterator();
1:     while (iterator.hasNext()) {
1:       Map.Entry<Requirement, Set<String>> entry = iterator.next();
1:       Requirement req = entry.getKey();
1:       for (Capability cap :caps) {
0:         if (req.isSatisfied(cap)){
0:           // remove the key from the map
1:           iterator.remove();
1:         }
1:       }
1:     }
1:     //Now the map only contains the necessary missing requirements
1:     
1:       Map<String,Set<String>> result = new HashMap<String, Set<String>>();
1:       for (Map.Entry<Requirement, Set<String>> req_res : req_resources.entrySet()) {
1:         result.put(req_res.getKey().getFilter(), req_res.getValue());
1:       }
1:       log.debug(LOG_EXIT, "refineUnsatisfiedRequirements", new Object[]{result});
1:       
1:     return result;
1:     }
1:   
1:   /**
0:    * Resolve a list of resources from the OBR bundle repositories by OBR
0:    * resolver.
1:    * 
0:    * @param appName - application name
0:    * @param appVersion - application version
0:    * @param byValueBundles - by value bundles
0:    * @param inputs - other constraints
0:    * @return a collection of modelled resources required by this application
0:    * @throws ResolverException
1:    */
0:    public Collection<ModelledResource> resolve(String appName, String appVersion,
0:       Collection<ModelledResource> byValueBundles, Collection<Content> inputs) throws ResolverException
1:   {
0:      log.debug(LOG_ENTRY, "resolve", new Object[]{appName, appVersion,byValueBundles, inputs});
0:     Collection<ImportedBundle> importedBundles = toImportedBundle(inputs);
0:     DataModelHelper helper = repositoryAdmin.getHelper();
1: 
1:    
0:     Collection<ModelledResource> toReturn = new ArrayList<ModelledResource>();
0:     Repository appRepo;
0:     try {      
0:       ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
0:       repositoryGenerator.generateRepository(appName + "_" + appVersion, byValueBundles, bytesOut);
0:       appRepo = helper.readRepository(new InputStreamReader(new ByteArrayInputStream(bytesOut.toByteArray())));
0:     } catch (Exception e) {
0:       throw new ResolverException(e);
1:     } 
1:         
0:     List<Repository> resolveRepos = new ArrayList<Repository>();
0:     // add system repository
0:     resolveRepos.add(repositoryAdmin.getSystemRepository());
0:     // add local repository
0:     resolveRepos.add(getLocalRepository(repositoryAdmin));
0:     // add application repository
0:     resolveRepos.add(appRepo);
0:     // add the user-defined repositories 
0:     if (platformRepository != null) {
0:       Collection<URI> uris = platformRepository.getPlatformRepositoryURLs();
0:       if ((uris != null) && (!uris.isEmpty())) {
0:         for (URI uri : uris) {
0:           try {
0:             resolveRepos.add(helper.readRepository(uri.toString()));
0:           } catch (Exception e) {
0:             // no a big problem
0:             log.error(MessageUtil.getMessage("RESOLVER_UNABLE_TO_READ_REPOSITORY_EXCEPTION", new Object[]{appName, uri}) );
1:           }
1:         }
1:       }
1:     }
0:    // Need to refresh the repositories added to repository admin
1:     
0:     // add user-defined repositories
0:     Repository[] repos = repositoryAdmin.listRepositories();
0:     for (Repository r : repos) {
0:       resolveRepos.add(r);      
1:     }     
0:     Resolver obrResolver = repositoryAdmin.resolver(resolveRepos.toArray(new Repository[resolveRepos.size()]));
1:     // add a resource describing the requirements of the application metadata.
0:     obrResolver.add(createApplicationResource( appName, appVersion, importedBundles));
0:     if (obrResolver.resolve()) {
1:       
0:       List<Resource> requiredResources = retrieveRequiredResources(obrResolver);
1: 
0:       if (requiredResources == null) {
0:         log.debug("resolver.getRequiredResources() returned null");
1:       } else {
1: 
0:         for (Resource r : requiredResources) {
0:           NameValueMap<String, String> attribs = new NameValueMap<String, String>();
0:           attribs.put(Constants.VERSION_ATTRIBUTE, "[" + r.getVersion() + ',' + r.getVersion()
0:               + "]");
0:           ModelledResource modelledResourceForThisMatch = null; 
0:           try { 
0:             modelledResourceForThisMatch = new ModelledBundleResource (r);
0:           } catch (InvalidAttributeException iax) { 
1:             
0:             ResolverException re = new ResolverException("Internal error occurred: " + iax.toString());
0:             log.debug(LOG_EXIT, "resolve", re);
1:             
0:             throw re;
1:           }
0:           toReturn.add(modelledResourceForThisMatch);
1:         }
1:       }
0:       log.debug(LOG_EXIT, "resolve", toReturn); 
0:       return toReturn;
1:     } else {
0:       Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
0:       // let's refine the list by removing the indirect unsatisfied bundles that are caused by unsatisfied packages or other bundles
0:       Map<String,Set<String>> refinedReqs = refineUnsatisfiedRequirements(obrResolver, reasons);
0:       StringBuffer reqList = new StringBuffer();
0:       List<String> unsatisfiedRequirements = new LinkedList<String>();
1: 
0:       for (Map.Entry<String, Set<String>> filterEntry : refinedReqs.entrySet()) {
0:         log.debug("unable to satisfied the filter , filter = " + filterEntry.getKey() + "required by "+filterEntry.getValue());
1:        
0:         String reason = extractConsumableMessageInfo(filterEntry.getKey(),filterEntry.getValue());
1: 
0:         reqList.append('\n');
0:         reqList.append(reason);
0:         unsatisfiedRequirements.add(reason);
1:       }
1: 
0:       ResolverException re = new ResolverException(MessageUtil.getMessage("RESOLVER_UNABLE_TO_RESOLVE", 
0:           new Object[] { appName, reqList }));
0:       re.setUnsatisfiedRequirements(unsatisfiedRequirements);
0:       log.debug(LOG_EXIT, "resolve", re);
1:       
0:       throw re;
1:     }
1:     
1:   }
1:    
1:    private Collection<ImportedBundle> toImportedBundle(Collection<Content> content) throws ResolverException
1:    {
1:      log.debug(LOG_ENTRY, "toImportedBundle", content);
1: 
1:      List<ImportedBundle> result = new ArrayList<ImportedBundle>();
1:      for (Content c : content) {
0:        try {
0:        result.add(ModellingManager.getImportedBundle(c.getContentName(), c.getVersion().toString()));
1:        } catch (InvalidAttributeException iae) {
1:          throw new ResolverException(iae);
1:        }
1:      }
1:      log.debug(LOG_EXIT, "toImportedBundle", result);
1:      return result;
1:    }
1:    
1:    private Collection<ModelledResource> toModelledResource(Collection<BundleInfo> bundleInfos) throws ResolverException{
1: 
1:      Collection<ModelledResource> result = new ArrayList<ModelledResource>();
1:     
1:      if ((bundleInfos != null) && (!!!bundleInfos.isEmpty())) {
1:        for (BundleInfo bi : bundleInfos) {
0:          try {
0:          result.add(ModellingManager.getModelledResource(null, bi, null, null));
1:          } catch (InvalidAttributeException iae) {
1:            throw new ResolverException(iae);
1:          }
1:        }
1:      }
1:      return result;
1:    }
1:   
0:    private Repository getLocalRepository(RepositoryAdmin admin) 
1:    {
0:        Repository localRepository = repositoryAdmin.getLocalRepository();
1:        
0:        Resource[] resources = localRepository.getResources();
1: 
0:        Resource[] newResources = new Resource[resources.length];
0:        for (int i = 0; i < resources.length; i++) {
0:            newResources[i] = new ResourceWrapper(resources[i]); 
1:        }
1:        
0:        return repositoryAdmin.getHelper().repository(newResources);
1:    }
1:    
1: 
1: 
author:Emily Jiang
-------------------------------------------------------------------------------
commit:57dfd78
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.utils.AppConstants;
/////////////////////////////////////////////////////////////////////////
0:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion, byValueBundles);
0:     
/////////////////////////////////////////////////////////////////////////
0: 
0:   private Resolver getConfiguredObrResolver(String appName, String appVersion,
0:       Collection<ModelledResource> byValueBundles) throws ResolverException
0:   {
1:     log.debug(LOG_ENTRY, "getConfiguredObrResolver", new Object[]{appName, appVersion,byValueBundles });
0:     DataModelHelper helper = repositoryAdmin.getHelper();
0:     Repository appRepo;
0:     try {      
0:       ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
0:       RepositoryGeneratorImpl.generateRepository(repositoryAdmin, appName + "_" + appVersion, byValueBundles, bytesOut);
0:       appRepo = helper.readRepository(new InputStreamReader(new ByteArrayInputStream(bytesOut.toByteArray())));
0:     } catch (Exception e) {
0:       throw new ResolverException(e);
0:     } 
0:         
0:     List<Repository> resolveRepos = new ArrayList<Repository>();
0:     // add system repository
0:     resolveRepos.add(repositoryAdmin.getSystemRepository());
0:     // add local repository if configured
0:     if (!(excludeLocalRuntime())) {
0:       resolveRepos.add(getLocalRepository(repositoryAdmin));
0:     }
0:     // add application repository
0:     resolveRepos.add(appRepo);
0:     // Need to refresh the repositories added to repository admin 
0:     // add user-defined repositories
0:     Repository[] repos = repositoryAdmin.listRepositories();
0:     for (Repository r : repos) {
0:       resolveRepos.add(r);      
0:     }     
0:     Resolver obrResolver = repositoryAdmin.resolver(resolveRepos.toArray(new Repository[resolveRepos.size()]));
0:     addPlatformRepositories (obrResolver, appName);
1:     log.debug(LOG_EXIT, "getConfiguredObrResolver", obrResolver);
1:     return obrResolver;
0:   }
0:   
/////////////////////////////////////////////////////////////////////////
0:     Resolver obrResolver = getConfiguredObrResolver(appName, appVersion.toString(), toModelledResource(app.getBundleInfo()));
/////////////////////////////////////////////////////////////////////////
0: 
0:   
/////////////////////////////////////////////////////////////////////////
1:    private boolean excludeLocalRuntime() {   
1:      return Boolean.parseBoolean(System.getProperty(AppConstants.PROVISON_EXCLUDE_LOCAL_REPO_SYSPROP));     
0:    }
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:248447e
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.InputStreamReader;
1: import java.util.ArrayList;
0: import java.util.jar.Attributes;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.felix.bundlerepository.DataModelHelper;
1: import org.apache.felix.bundlerepository.Reason;
1: import org.apache.felix.bundlerepository.Repository;
1: import org.apache.felix.bundlerepository.RepositoryAdmin;
1: import org.apache.felix.bundlerepository.Resolver;
1: import org.apache.felix.bundlerepository.Resource;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
/////////////////////////////////////////////////////////////////////////
1:   public Set<BundleInfo> resolve(AriesApplication app, ResolveConstraint... constraints) throws ResolverException
0:     DataModelHelper helper = repositoryAdmin.getHelper();
0: 
0: 
0:     Repository appRepo;
0:       ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
0:       TransformerFactory.newInstance().newTransformer().transform(new DOMSource(doc), new StreamResult(bytesOut));
0:       appRepo = helper.readRepository(new InputStreamReader(new ByteArrayInputStream(bytesOut.toByteArray())));
0:     Repository[] repos = repositoryAdmin.listRepositories();
0:     
0:     List<Repository> resolveRepos = new ArrayList<Repository>();
0:     resolveRepos.add(appRepo);
0:     
0:     for (Repository r : repos) {
0:       if (!!!Repository.LOCAL.equals(r.getURI())) {
0:         resolveRepos.add(r);
0:     
0:     Resolver obrResolver = repositoryAdmin.resolver(resolveRepos.toArray(new Repository[resolveRepos.size()]));
0:     // add a resource describing the requirements of the application metadata.
0:     obrResolver.add(createApplicationResource(helper, appName, appVersion, appContent));
0:     if (obrResolver.resolve()) {
0:       Set<BundleInfo> result = new HashSet<BundleInfo>();
0:       for (Resource resource: obrResolver.getRequiredResources()) {
0:         BundleInfo bundleInfo = toBundleInfo(resource);
1:         result.add(bundleInfo);
0:       }
0:       for (Resource resource: obrResolver.getOptionalResources()) {
0:         BundleInfo bundleInfo = toBundleInfo(resource);
1:         result.add(bundleInfo);
0:       }
1:       return result;
0:     } else {
0:       throw new ResolverException("Could not resolve requirements: " + getUnsatisfiedRequirements(obrResolver));
0:     }
0:   }
0: 
0:   private Resource createApplicationResource(DataModelHelper helper, String appName, Version appVersion,
0:       List<Content> appContent)
0:   {
0:     return new ApplicationResourceImpl(appName, appVersion, appContent);
/////////////////////////////////////////////////////////////////////////
1:     Resource[] resources;
0:     try {
1:       resources = repositoryAdmin.discoverResources(filterString);
1:       if (resources != null && resources.length > 0) {
0:         return toBundleInfo(resources[0]);
0:       } else {
1:         return null;
0:       }
1:     } catch (InvalidSyntaxException e) {
0:       // TODO Auto-generated catch block
0:       e.printStackTrace();
0:     Reason[] reqs = resolver.getUnsatisfiedRequirements();
0:         sb.append("   " + reqs[reqIdx].getRequirement().getFilter()).append("\n");
0:         Resource resource = reqs[reqIdx].getResource();
0:         sb.append("      " + resource.getPresentationName()).append("\n");
/////////////////////////////////////////////////////////////////////////
0:     String location = resource.getURI();
commit:64b41bb
/////////////////////////////////////////////////////////////////////////
0:         Set<BundleInfo> result = new HashSet<BundleInfo>();
commit:0c70965
/////////////////////////////////////////////////////////////////////////
0:   public synchronized Set<BundleInfo> resolve(AriesApplication app, ResolveConstraint... constraints) throws ResolverException
commit:958fb7e
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.net.URL;
0: import javax.xml.transform.TransformerFactory;
0: import javax.xml.transform.dom.DOMSource;
0: import javax.xml.transform.stream.StreamResult;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.resolver.obr.generator.RepositoryDescriptorGenerator;
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.Document;
/////////////////////////////////////////////////////////////////////////
0:   /**
0:    * This method is synchronized because it changes the repositories understood by OBR, and we don't
0:    * want one apps by value content being used to resolve another. I'll ask for an OBR enhancement.
1:    */
/////////////////////////////////////////////////////////////////////////
0: 
0:     URL appRepoURL = null;
0:     try {
0:       Document doc = RepositoryDescriptorGenerator.generateRepositoryDescriptor(appName + "_" + appVersion, app.getBundleInfo());
0:       
0:       File f = File.createTempFile(appName + "_" + appVersion, "repository.xml");
0:       TransformerFactory.newInstance().newTransformer().transform(new DOMSource(doc), new StreamResult(f));
0:       
0:       appRepoURL = f.toURI().toURL();
0:       
0:       repositoryAdmin.addRepository(appRepoURL);
0:       f.delete();
0:     } catch (Exception e) {
0:       throw new ResolverException(e);
0:     } 
0:     try {
0:       if (obrResolver.resolve()) {
0:         Set<BundleInfo> result = new HashSet<BundleInfo>(app.getBundleInfo());
0:         for (Resource resource: obrResolver.getRequiredResources()) {
0:           BundleInfo bundleInfo = toBundleInfo(resource);
0:           result.add(bundleInfo);
0:         }
0:         for (Resource resource: obrResolver.getOptionalResources()) {
0:           BundleInfo bundleInfo = toBundleInfo(resource);
0:           result.add(bundleInfo);
0:         }
0:         return result;
0:       } else {
0:         throw new ResolverException("Could not resolve requirements: " + getUnsatifiedRequirements(obrResolver));
0:     } finally {
0:       if (appRepoURL != null) {
0:         repositoryAdmin.removeRepository(appRepoURL);
/////////////////////////////////////////////////////////////////////////
0:             null, 
0:             null,
0:             null,
commit:e8ec7a5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.ApplicationMetadata;
1: import org.apache.aries.application.resolver.obr.impl.ApplicationResourceImpl;
/////////////////////////////////////////////////////////////////////////
0:     
1:     ApplicationMetadata appMeta = app.getApplicationMetadata();
0:     
1:     String appName = appMeta.getApplicationSymbolicName();
1:     Version appVersion = appMeta.getApplicationVersion();
1:     List<Content> appContent = appMeta.getApplicationContents();
0: 
0:     // add a resource describing the requirements of the application metadata.
0:     obrResolver.add(new ApplicationResourceImpl(appName, appVersion, appContent));
0:     
0:     // TODO we need to resolve against the app content so we need to generate an OBR.xml for the content
0:     
/////////////////////////////////////////////////////////////////////////
0: }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:90a9b06
/////////////////////////////////////////////////////////////////////////
0:         throw new ResolverException("Could not resolve requirements: " + getUnsatisfiedRequirements(obrResolver));
/////////////////////////////////////////////////////////////////////////
0:   private String getUnsatisfiedRequirements(Resolver resolver)
commit:bfd7c4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.management.ResolveConstraint;
/////////////////////////////////////////////////////////////////////////
0:   public Set<BundleInfo> resolve(AriesApplication app, ResolveConstraint... constraints) throws ResolverException
commit:482c954
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Collection;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:       throw new ResolverException("Could not resolve requirements: " + getUnsatifiedRequirements(obrResolver));
0:     attribs.put(Resource.VERSION, bundleVersion.toString());
1:     String filterString = ManifestHeaderProcessor.generateFilter(Resource.SYMBOLIC_NAME, bundleSymbolicName, attribs);
/////////////////////////////////////////////////////////////////////////
0:   private String getUnsatifiedRequirements(Resolver resolver)
0:     Requirement[] reqs = resolver.getUnsatisfiedRequirements();
0:     if (reqs != null) {
0:       StringBuilder sb = new StringBuilder();
0:       for (int reqIdx = 0; reqIdx < reqs.length; reqIdx++) {
0:         sb.append("   " + reqs[reqIdx].getFilter()).append("\n");
0:         Resource[] resources = resolver.getResources(reqs[reqIdx]);
0:         for (int resIdx = 0; resIdx < resources.length; resIdx++) {
0:           sb.append("      " + resources[resIdx].getPresentationName()).append("\n");
0:         }
0:       }
0:       return sb.toString();
0:     }
/////////////////////////////////////////////////////////////////////////
0:             null,
0:             null,
0:     List<Requirement> requirements = new ArrayList<Requirement>();
0:     requirements.addAll(toRequirements(bundleInfo.getImportPackage(), "package"));
0:     requirements.addAll(toRequirements(bundleInfo.getImportService(), "service"));
0:     List<Capability> capabilities = new ArrayList<Capability>();
0:     capabilities.addAll(toPackageCapabilities(bundleInfo.getExportPackage()));
0:     capabilities.addAll(toServiceCapabilities(bundleInfo.getExportService()));
/////////////////////////////////////////////////////////////////////////
0:             requirements.toArray(new Requirement[requirements.size()]),
0:             capabilities.toArray(new Capability[capabilities.size()]),
0:   private Collection<Requirement> toRequirements(Set<Content> imports, String type) throws ResolverException
0:     Collection<Requirement> requirements = new ArrayList<Requirement>(imports.size());
0:     for (Content content: imports) {
0:       requirements.add(toRequirement(content, type));
0:   private Requirement toRequirement(Content content, String type) throws ResolverException
/////////////////////////////////////////////////////////////////////////
0:     String filterString = ManifestHeaderProcessor.generateFilter(type, content.getContentName(), attributes);
/////////////////////////////////////////////////////////////////////////
0:   private Collection<Capability> toPackageCapabilities(Set<Content> exportPackage)
0:     Collection<Capability> capabilities = new ArrayList<Capability>(exportPackage.size());
0:       capabilities.add(toPackageCapability(content));
0:   private Capability toPackageCapability(Content content)
0:     Map<String,String> props = new HashMap<String,String>();
0:     props.put("package", content.getContentName());
0:     props.put("version", content.getVersion() != null ? content.getVersion().getMinimumVersion().toString() : Version.emptyVersion.toString());
0:     return new CapabilityImpl("package", props);
0: 
0:   private Collection<Capability> toServiceCapabilities(Set<Content> exportPackage)
0:   {
0:     Collection<Capability> capabilities = new ArrayList<Capability>(exportPackage.size());
0:     for (Content content: exportPackage) {
0:       capabilities.add(toServiceCapability(content));
0:     }
0:     return capabilities;
0:   }
0: 
0:   private Capability toServiceCapability(Content content)
0:   {
0:     Map<String,String> props = new HashMap<String,String>();
0:     props.put("service", content.getContentName());
0:     return new CapabilityImpl("service", props);
0:   }
0: 
author:David Jencks
-------------------------------------------------------------------------------
commit:ad59cd3
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:   private static Logger log = LoggerFactory.getLogger(OBRAriesResolver.class);
/////////////////////////////////////////////////////////////////////////
1:     log.trace("resolving {}", app);
commit:0aad0ca
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *  http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  */
0: 
0: 
1: package org.apache.aries.application.resolver.obr;
0: 
0: import java.net.MalformedURLException;
0: import java.net.URL;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Map;
1: import java.util.Set;
0: 
1: import org.apache.aries.application.Content;
1: import org.apache.aries.application.management.AriesApplication;
0: import org.apache.aries.application.management.AriesApplicationResolver;
1: import org.apache.aries.application.management.BundleInfo;
1: import org.apache.aries.application.management.ResolverException;
0: import org.apache.aries.application.resolver.obr.impl.CapabilityImpl;
1: import org.apache.aries.application.resolver.obr.impl.OBRBundleInfo;
0: import org.apache.aries.application.resolver.obr.impl.RequirementImpl;
0: import org.apache.aries.application.resolver.obr.impl.ResourceImpl;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor;
0: import org.osgi.framework.Filter;
0: import org.osgi.framework.FrameworkUtil;
0: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.Version;
0: import org.osgi.service.obr.Capability;
0: import org.osgi.service.obr.RepositoryAdmin;
0: import org.osgi.service.obr.Requirement;
0: import org.osgi.service.obr.Resolver;
0: import org.osgi.service.obr.Resource;
0: 
0: /**
1:  * @version $Rev$ $Date$
0:  */
1: public class OBRAriesResolver implements AriesApplicationResolver
0: {
0: 
0:   private final RepositoryAdmin repositoryAdmin;
0: 
1:   public OBRAriesResolver(RepositoryAdmin repositoryAdmin)
0:   {
1:     this.repositoryAdmin = repositoryAdmin;
0:   }
0: 
0:   public Set<BundleInfo> resolve(AriesApplication app) throws ResolverException
0:   {
0:     Resolver obrResolver = repositoryAdmin.resolver();
0:     for (BundleInfo bundleInfo: app.getBundleInfo()) {
0:       Resource resource = toResource(bundleInfo);
0:       obrResolver.add(resource);
0:     }
0:     if (obrResolver.resolve()) {
0:       Set<BundleInfo> result = new HashSet<BundleInfo>(app.getBundleInfo());
0:       for (Resource resource: obrResolver.getRequiredResources()) {
0:         BundleInfo bundleInfo = toBundleInfo(resource);
0:         result.add(bundleInfo);
0:       }
0:       for (Resource resource: obrResolver.getOptionalResources()) {
0:         BundleInfo bundleInfo = toBundleInfo(resource);
0:         result.add(bundleInfo);
0:       }
0:       return result;
0:     } else {
0:       throw new ResolverException("Could not resolve requirements: " + toString(obrResolver.getUnsatisfiedRequirements()));
0:     }
0:   }
0: 
1:   public BundleInfo getBundleInfo(String bundleSymbolicName, Version bundleVersion)
0:   {
0:     Map<String, String> attribs = new HashMap<String, String>();
0:     attribs.put("BundleSymbolic-Name", bundleSymbolicName);
0:     attribs.put("Bundle-Version", bundleVersion.toString());
0:     String filterString = ManifestHeaderProcessor.generateFilter("bundle", bundleSymbolicName, attribs);
0:     Resource[] resources = repositoryAdmin.discoverResources(filterString);
0:     if (resources != null && resources.length > 0) {
0:       return toBundleInfo(resources[0]);
0:     } else {
1:       return null;
0:     }
0:   }
0: 
0:   private String toString(Requirement[] unsatisfiedRequirements)
0:   {
1:     return null;
0:   }
0: 
0:   private BundleInfo toBundleInfo(Resource resource)
0:   {
0:     String location = resource.getURL().toExternalForm();
1:     return new OBRBundleInfo(resource.getSymbolicName(),
0:             resource.getVersion(),
0:             location,
0:             null,
0:             null,
0:             null);
0:   }
0: 
0:   private Resource toResource(BundleInfo bundleInfo) throws ResolverException
0:   {
0:     String id = bundleInfo.getSymbolicName() + "_" + bundleInfo.getVersion();
0:     Requirement[] requirements = toRequirements(bundleInfo.getImportPackage());
0:     Capability[] capabilities = toCapabilities(bundleInfo.getExportPackage());
0:     URL url;
0:     try {
0:       url = new URL(bundleInfo.getLocation());
0:     } catch (MalformedURLException e) {
0:       throw new ResolverException(e);
0:     }
0:     return new ResourceImpl(bundleInfo.getHeaders(),
0:             bundleInfo.getSymbolicName(),
0:             bundleInfo.getSymbolicName(),
0:             bundleInfo.getVersion(),
0:             id,
0:             url,
0:             requirements,
0:             capabilities,
0:             null,
0:             null);
0:   }
0: 
0:   private Requirement[] toRequirements(Set<Content> importPackage) throws ResolverException
0:   {
0:     Requirement[] requirements = new Requirement[importPackage.size()];
0:     int i = 0;
0:     for (Content content: importPackage) {
0:       requirements[i++] = toRequirement(content);
0:     }
0:     return requirements;
0:   }
0: 
0:   private Requirement toRequirement(Content content) throws ResolverException
0:   {
0:     Map<String, String> attributes = new HashMap<String, String>();
0:     for (Map.Entry<String, String> entry: content.getNameValueMap().entrySet()) {
0:       //leave out resolution:=optional, etc
0:       if (!entry.getKey().endsWith(":")) {
0:         attributes.put(entry.getKey(), entry.getValue());
0:       }
0:     }
0:     String filterString = ManifestHeaderProcessor.generateFilter("package", content.getContentName(), attributes);
0:     Filter filter = null;
0:     try {
0:       filter = FrameworkUtil.createFilter(filterString);
0:     } catch (InvalidSyntaxException e) {
0:       throw new ResolverException(e);
0:     }
0:     boolean multiple = false;
0:     boolean optional = "optional".equals(content.getNameValueMap().get("resolution:"));
0:     boolean extend = false;
0:     return new RequirementImpl("package",
0:             filter,
0:             multiple,
0:             optional,
0:             extend,
0:             null);
0:   }
0: 
0:   private Capability[] toCapabilities(Set<Content> exportPackage)
0:   {
0:     Capability[] capabilities = new Capability[exportPackage.size()];
0:     int i = 0;
0:     for (Content content: exportPackage) {
0:       capabilities[i++] = toCapability(content);
0:     }
0:     return capabilities;
0:   }
0: 
0:   private Capability toCapability(Content content)
0:   {
0:     return new CapabilityImpl(content.getContentName(), content.getNameValueMap());
0:   }
0: }
============================================================================