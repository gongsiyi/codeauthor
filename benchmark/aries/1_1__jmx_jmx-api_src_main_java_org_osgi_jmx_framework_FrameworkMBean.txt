1:fdf3952: /*
1:fdf3952:  * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
1:c13e6cc:  *
1:fdf3952:  * Licensed under the Apache License, Version 2.0 (the "License");
1:fdf3952:  * you may not use this file except in compliance with the License.
1:fdf3952:  * You may obtain a copy of the License at
1:c13e6cc:  *
1:fdf3952:  *      http://www.apache.org/licenses/LICENSE-2.0
42:fdf3952:  *
1:fdf3952:  * Unless required by applicable law or agreed to in writing, software
1:fdf3952:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fdf3952:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdf3952:  * See the License for the specific language governing permissions and
1:fdf3952:  * limitations under the License.
1:fdf3952:  */
1:fdf3952: 
1:fdf3952: package org.osgi.jmx.framework;
1:fdf3952: 
1:fdf3952: import java.io.IOException;
1:fdf3952: 
1:fdf3952: import javax.management.openmbean.CompositeData;
1:fdf3952: import javax.management.openmbean.CompositeType;
1:fdf3952: import javax.management.openmbean.SimpleType;
1:fdf3952: 
1:fdf3952: import org.osgi.jmx.Item;
1:fdf3952: import org.osgi.jmx.JmxConstants;
1:fdf3952: 
2:fdf3952: /**
1:fdf3952:  * The FrameworkMbean provides mechanisms to exert control over the framework.
1:fdf3952:  * For many operations, it provides a batch mechanism to avoid excessive message
1:fdf3952:  * passing when interacting remotely.
1:c13e6cc:  *
1:fdf3952:  * @version $Revision$
1:fdf3952:  * @ThreadSafe
1:fdf3952:  */
1:fdf3952: public interface FrameworkMBean {
1:fdf3952: 	/**
1:fdf3952: 	 * The fully qualified object name of this mbean.
1:fdf3952: 	 */
1:fdf3952: 	String			OBJECTNAME						= JmxConstants.OSGI_CORE
1:7b6fac5: 															+ ":type=framework,version=1.7";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The SUCCESS, used in {@link #SUCCESS_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String			SUCCESS							= "Success";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item that indicates if this operation was successful. The key is
1:fdf3952: 	 * {@link #SUCCESS} and the type is {@link SimpleType#BOOLEAN}. It is used
1:fdf3952: 	 * in {@link #BATCH_ACTION_RESULT_TYPE} and
1:fdf3952: 	 * {@link #BATCH_INSTALL_RESULT_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item			SUCCESS_ITEM					= new Item(
1:fdf3952: 															SUCCESS,
1:fdf3952: 															"Whether the operation was successful",
1:fdf3952: 															SimpleType.BOOLEAN);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key ERROR, used in {@link #ERROR_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String			ERROR							= "Error";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the error message of the batch operation. The key is
1:fdf3952: 	 * {@link #ERROR} and the type is {@link SimpleType#STRING}. It is used in
1:fdf3952: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item			ERROR_ITEM						= new Item(
1:fdf3952: 															ERROR,
1:fdf3952: 															"The error message if unsuccessful",
1:fdf3952: 															SimpleType.STRING);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key COMPLETED, used in {@link #COMPLETED_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String			COMPLETED						= "Completed";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the list of bundles completing the batch operation.
1:fdf3952: 	 * The key is {@link #COMPLETED} and the type is
1:fdf3952: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}. It is used in
1:fdf3952: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item			COMPLETED_ITEM					= new Item(
1:fdf3952: 															COMPLETED,
1:fdf3952: 															"The bundle ids of the successfully completed installs",
1:fdf3952: 															JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key for BUNDLE_IN_ERROR. This key is used with two different items:
1:fdf3952: 	 * {@link #BUNDLE_IN_ERROR_ID_ITEM} and
1:fdf3952: 	 * {@link #BUNDLE_IN_ERROR_LOCATION_ITEM} that each have a different type
1:fdf3952: 	 * for this key. It is used in {@link #BATCH_ACTION_RESULT_TYPE} and
1:fdf3952: 	 * {@link #BATCH_INSTALL_RESULT_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	String			BUNDLE_IN_ERROR					= "BundleInError";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle which caused the error during the batch
1:fdf3952: 	 * operation. This item describes the bundle in error as an id. The key is
1:fdf3952: 	 * {@link #BUNDLE_IN_ERROR} and the type is {@link SimpleType#LONG}. It is
1:fdf3952: 	 * used in {@link #BATCH_ACTION_RESULT_TYPE}.
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BUNDLE_IN_ERROR_LOCATION_ITEM BUNDLE_IN_ERROR_LOCATION_ITEM for the
1:fdf3952: 	 *      item that has a location for the bundle in error.
1:fdf3952: 	 */
1:fdf3952: 	Item			BUNDLE_IN_ERROR_ID_ITEM			= new Item(
1:fdf3952: 															BUNDLE_IN_ERROR,
1:fdf3952: 															"The id of the bundle causing the error",
1:fdf3952: 															SimpleType.LONG);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The key REMAINING, used in {@link #REMAINING_ID_ITEM} and
1:fdf3952: 	 * {@link #REMAINING_LOCATION_ITEM}.
1:fdf3952: 	 */
1:fdf3952: 	String			REMAINING						= "Remaining";
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the list of remaining bundles unprocessed by the
1:fdf3952: 	 * failing batch operation. The key is {@link #REMAINING} and the type is
1:fdf3952: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}. It is used in
1:fdf3952: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item			REMAINING_ID_ITEM				= new Item(
1:fdf3952: 															REMAINING,
1:fdf3952: 															"The ids of the remaining bundles",
1:fdf3952: 															JmxConstants.LONG_ARRAY_TYPE);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Composite Type for a batch action result.
1:fdf3952: 	 * {@link #refreshBundle(long)} and {@link #refreshBundles(long[])}.
1:fdf3952: 	 * Notice that a batch action result returns uses an id for the
1:fdf3952: 	 * {@link #BUNDLE_IN_ERROR} while the {@link #BATCH_INSTALL_RESULT_TYPE}
1:fdf3952: 	 * uses a location.
1:c13e6cc: 	 *
1:fdf3952: 	 * This Composite Type consists of the following items:
1:fdf3952: 	 * <ul>
1:fdf3952: 	 * <li>{@link #BUNDLE_IN_ERROR_ID_ITEM}</li>
1:fdf3952: 	 * <li>{@link #COMPLETED_ITEM}</li>
1:fdf3952: 	 * <li>{@link #ERROR_ITEM}</li>
1:fdf3952: 	 * <li>{@link #REMAINING_ID_ITEM}</li>
1:fdf3952: 	 * <li>{@link #SUCCESS_ITEM}</li>
1:fdf3952: 	 * </ul>
1:fdf3952: 	 */
1:fdf3952: 	CompositeType	BATCH_ACTION_RESULT_TYPE		= Item
1:fdf3952: 															.compositeType(
1:fdf3952: 																	"BUNDLE_ACTION_RESULT",
1:fdf3952: 																	"This type encapsulates a bundle batch install action result",
1:fdf3952: 																	BUNDLE_IN_ERROR_ID_ITEM,
1:fdf3952: 																	COMPLETED_ITEM,
1:fdf3952: 																	ERROR_ITEM,
1:fdf3952: 																	REMAINING_ID_ITEM,
1:af3b4b3: 																	SUCCESS_ITEM
1:fdf3952: 															);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the bundle which caused the error during the batch
1:fdf3952: 	 * operation. This item describes the bundle in error as a location. The key
1:fdf3952: 	 * is {@link #BUNDLE_IN_ERROR} and the type is {@link SimpleType#STRING}. It
1:fdf3952: 	 * is used in {@link #BATCH_INSTALL_RESULT_TYPE}.
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BUNDLE_IN_ERROR_ID_ITEM BUNDLE_IN_ERROR_ID_ITEM for the item that
1:fdf3952: 	 *      has the id for the bundle in error.
1:fdf3952: 	 */
1:fdf3952: 	Item			BUNDLE_IN_ERROR_LOCATION_ITEM	= new Item(
1:fdf3952: 															BUNDLE_IN_ERROR,
1:fdf3952: 															"The location of the bundle causing the error",
1:fdf3952: 															SimpleType.STRING);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The item containing the list of remaining bundles unprocessed by the
1:fdf3952: 	 * failing batch operation. The key is {@link #REMAINING} and the type is
1:fdf3952: 	 * {@link JmxConstants#STRING_ARRAY_TYPE}. It is used in
1:fdf3952: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1:fdf3952: 	 */
1:fdf3952: 	Item			REMAINING_LOCATION_ITEM			= new Item(
1:fdf3952: 															REMAINING,
1:fdf3952: 															"The locations of the remaining bundles",
1:fdf3952: 															JmxConstants.STRING_ARRAY_TYPE);
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * The Composite Type which represents the result of a batch install
1:fdf3952: 	 * operation. It is used in {@link #installBundles(String[])} and
1:fdf3952: 	 * {@link #installBundlesFromURL(String[], String[])}.
1:c13e6cc: 	 *
1:fdf3952: 	 * This Composite Type consists of the following items:
1:fdf3952: 	 * <ul>
1:fdf3952: 	 * <li>{@link #BUNDLE_IN_ERROR_LOCATION_ITEM}</li>
1:fdf3952: 	 * <li>{@link #COMPLETED_ITEM}</li>
1:fdf3952: 	 * <li>{@link #ERROR_ITEM}</li>
1:fdf3952: 	 * <li>{@link #REMAINING_LOCATION_ITEM P }</li>
1:fdf3952: 	 * <li>{@link #SUCCESS_ITEM}</li>
1:fdf3952: 	 * </ul>
1:fdf3952: 	 */
1:fdf3952: 	CompositeType	BATCH_INSTALL_RESULT_TYPE		= Item
1:fdf3952: 															.compositeType(
1:fdf3952: 																	"BATCH_INSTALL_RESULT",
1:fdf3952: 																	"This type encapsulates a bundle batch install action result",
1:fdf3952: 																	BUNDLE_IN_ERROR_LOCATION_ITEM,
1:fdf3952: 																	COMPLETED_ITEM,
1:fdf3952: 																	ERROR_ITEM,
1:fdf3952: 																	REMAINING_LOCATION_ITEM,
1:af3b4b3: 																	SUCCESS_ITEM
1:fdf3952: 															);
1:fdf3952: 
1:af3b4b3:     /**
1:af3b4b3:      * The Composite Type which represents the result of a batch resolve
1:af3b4b3:      * operation. It is used in {@link #refreshBundlesAndWait(String[])}.
1:af3b4b3:      *
1:af3b4b3:      * This Composite Type consists of the following items:
1:af3b4b3:      * <ul>
1:af3b4b3:      * <li>{@link #COMPLETED_ITEM}</li>
1:af3b4b3:      * <li>{@link #SUCCESS_ITEM}</li>
1:af3b4b3:      * </ul>
1:af3b4b3:      */
1:af3b4b3:     CompositeType   BATCH_RESOLVE_RESULT_TYPE       = Item
1:af3b4b3:                                                             .compositeType(
1:af3b4b3:                                                                     "BATCH_RESOLVE_RESULT",
1:af3b4b3:                                                                     "This type encapsulates a bundle batch resolve action result",
1:af3b4b3:                                                                     COMPLETED_ITEM,
1:af3b4b3:                                                                     SUCCESS_ITEM);
1:af3b4b3: 
1:f94132d:     /**
1:f94132d:      * Returns the dependency closure for the specified bundles.
1:f94132d:      *
1:f94132d:      * <p>
1:f94132d:      * A graph of bundles is computed starting with the specified bundles. The
1:f94132d:      * graph is expanded by adding any bundle that is either wired to a package
1:f94132d:      * that is currently exported by a bundle in the graph or requires a bundle
1:f94132d:      * in the graph. The graph is fully constructed when there is no bundle
1:f94132d:      * outside the graph that is wired to a bundle in the graph. The graph may
1:f94132d:      * contain {@code UNINSTALLED} bundles that are
1:f94132d:      * {@link #getRemovalPendingBundles() removal pending}.
1:f94132d:      *
1:f94132d:      * @param bundles The initial bundles IDs for which to generate the dependency
1:f94132d:      *        closure.
1:f94132d:      * @return A bundle ID array containing a snapshot of the dependency closure of
1:f94132d:      *         the specified bundles, or an empty array if there were no
1:f94132d:      *         specified bundles.
1:f94132d:      * @throws IOException if the operation failed
1:f94132d:      */
1:f94132d:     long[] getDependencyClosure(long[] bundles) throws IOException;
1:f94132d: 
1:f94132d:     /**
1:fdf3952: 	 * Retrieve the framework start level
1:c13e6cc: 	 *
1:fdf3952: 	 * @return the framework start level
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	int getFrameworkStartLevel() throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Answer the initial start level assigned to a bundle when it is first
1:fdf3952: 	 * started
1:c13e6cc: 	 *
1:fdf3952: 	 * @return the start level
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	int getInitialBundleStartLevel() throws IOException;
1:fdf3952: 
1:21be559:     /**
1:21be559:      * Returns the value of the specified property. If the key is not found in
1:21be559:      * the Framework properties, the system properties are then searched. The
1:21be559:      * method returns {@code null} if the property is not found.
1:21be559:      *
1:21be559:      * @param key The name of the requested property.
1:21be559:      * @return The value of the requested property, or {@code null} if the
1:21be559:      *         property is undefined.
1:21be559:      * @throws IOException if the operation failed
1:21be559:      */
1:8a05ae7:     String getProperty(String key) throws IOException;
1:21be559: 
1:fdf3952: 	/**
1:f94132d:      * Returns the bundles IDs that have non-current, in use bundle wirings. This
1:f94132d:      * is typically the bundles which have been updated or uninstalled since the
1:f94132d:      * last call to {@link #refreshBundles(long[])}.
1:f94132d:      *
1:f94132d:      * @return A bundle ID array containing a snapshot of the bundles which
1:f94132d:      *         have non-current, in use bundle wirings, or an empty
1:f94132d:      *         array if there are no such bundles.
1:f94132d:      * @throws IOException if the operation failed
1:f94132d:      */
1:f94132d:     long[] getRemovalPendingBundles() throws IOException;
1:f94132d: 
1:f94132d: 	/**
1:fdf3952: 	 * Install the bundle indicated by the bundleLocations
1:c13e6cc: 	 *
1:fdf3952: 	 * @param location the location of the bundle to install
1:fdf3952: 	 * @return the bundle id the installed bundle
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	long installBundle(String location) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Install the bundle indicated by the bundleLocations
1:c13e6cc: 	 *
1:fdf3952: 	 * @param location the location to assign to the bundle
1:fdf3952: 	 * @param url the URL which will supply the bytes for the bundle
1:fdf3952: 	 * @return the bundle id the installed bundle
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	long installBundleFromURL(String location, String url) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch install the bundles indicated by the list of bundleLocationUrls
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_INSTALL_RESULT_TYPE BATCH_INSTALL_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param locations the array of locations of the bundles to install
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData installBundles(String[] locations) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch install the bundles indicated by the list of bundleLocationUrls
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_INSTALL_RESULT_TYPE BATCH_INSTALL_RESULT_TYPE
1:fdf3952: 	 *      BatchBundleResult for the precise specification of the CompositeData
1:fdf3952: 	 *      type representing the returned result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param locations the array of locations to assign to the installed
1:fdf3952: 	 *        bundles
1:fdf3952: 	 * @param urls the array of urls which supply the bundle bytes
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData installBundlesFromURL(String[] locations, String[] urls)
1:fdf3952: 			throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Force the update, replacement or removal of the packages identified by
1:fdf3952: 	 * the specified bundle.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void refreshBundle(long bundleIdentifier) throws IOException;
1:c13e6cc: 	boolean refreshBundleAndWait(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Force the update, replacement or removal of the packages identified by
1:fdf3952: 	 * the list of bundles.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers The identifiers of the bundles to refresh, or
1:fdf3952: 	 *        <code>null</code> for all bundles with packages pending removal.
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void refreshBundles(long[] bundleIdentifiers) throws IOException;
1:c13e6cc: 	CompositeData refreshBundlesAndWait(long[] bundleIdentifiers) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Resolve the bundle indicated by the unique symbolic name and version
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @return <code>true</code> if the bundle was resolved, false otherwise
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	boolean resolveBundle(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch resolve the bundles indicated by the list of bundle identifiers
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers The identifiers of the bundles to resolve, or
1:fdf3952: 	 *        <code>null</code> to resolve all unresolved bundles.
1:fdf3952: 	 * @return <code>true</code> if the bundles were resolved, false otherwise
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	boolean resolveBundles(long[] bundleIdentifiers) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:8b67a25: 	 * Same as {@link #resolveBundles(long[])} but with a more detailed return type.
1:8b67a25: 	 * @param bundleIdentifiers
1:8b67a25: 	 * @return
1:8b67a25: 	 * @throws IOException
1:8b67a25: 	 */
1:8b67a25: 	CompositeData resolve(long[] bundleIdentifiers) throws IOException;
1:8b67a25: 
1:8b67a25: 	/**
1:fdf3952: 	 * Restart the framework by updating the system bundle
1:c13e6cc: 	 *
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void restartFramework() throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Set the start level for the bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @param newlevel the new start level for the bundle
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void setBundleStartLevel(long bundleIdentifier, int newlevel)
1:fdf3952: 			throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Set the start levels for the list of bundles.
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers the array of bundle identifiers
1:fdf3952: 	 * @param newlevels the array of new start level for the bundles
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData setBundleStartLevels(long[] bundleIdentifiers, int[] newlevels)
1:fdf3952: 			throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Set the start level for the framework
1:c13e6cc: 	 *
1:fdf3952: 	 * @param newlevel the new start level
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void setFrameworkStartLevel(int newlevel) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Set the initial start level assigned to a bundle when it is first started
1:c13e6cc: 	 *
1:fdf3952: 	 * @param newlevel the new start level
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void setInitialBundleStartLevel(int newlevel) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Shutdown the framework by stopping the system bundle
1:c13e6cc: 	 *
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void shutdownFramework() throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Start the bundle indicated by the bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	void startBundle(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch start the bundles indicated by the list of bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers the array of bundle identifiers
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData startBundles(long[] bundleIdentifiers) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Stop the bundle indicated by the bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	void stopBundle(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch stop the bundles indicated by the list of bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers the array of bundle identifiers
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData stopBundles(long[] bundleIdentifiers) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Uninstall the bundle indicated by the bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	void uninstallBundle(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch uninstall the bundles indicated by the list of bundle identifiers
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers the array of bundle identifiers
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData uninstallBundles(long[] bundleIdentifiers) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Update the bundle indicated by the bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	void updateBundle(long bundleIdentifier) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Update the bundle identified by the bundle identifier
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifier the bundle identifier
1:fdf3952: 	 * @param url the URL to use to update the bundle
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	void updateBundleFromURL(long bundleIdentifier, String url) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Batch update the bundles indicated by the list of bundle identifier.
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:c13e6cc: 	 *
1:fdf3952: 	 * @param bundleIdentifiers the array of bundle identifiers
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 */
1:fdf3952: 	CompositeData updateBundles(long[] bundleIdentifiers) throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Update the bundle uniquely identified by the bundle symbolic name and
1:fdf3952: 	 * version using the contents of the supplied urls.
1:c13e6cc: 	 *
1:fdf3952: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1:fdf3952: 	 *      specification of the CompositeData type representing the returned
1:fdf3952: 	 *      result.
1:fdf3952: 	 *
1:fdf3952: 	 * @param bundleIdentifiers the array of bundle identifiers
1:fdf3952: 	 * @param urls the array of URLs to use to update the bundles
1:fdf3952: 	 * @return the resulting state from executing the operation
1:fdf3952: 	 * @throws IOException if the operation does not succeed
1:fdf3952: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1:fdf3952: 	 */
1:fdf3952: 	CompositeData updateBundlesFromURL(long[] bundleIdentifiers, String[] urls)
1:fdf3952: 			throws IOException;
1:fdf3952: 
1:fdf3952: 	/**
1:fdf3952: 	 * Update the framework by updating the system bundle.
1:c13e6cc: 	 *
1:fdf3952: 	 * @throws IOException if the operation failed
1:fdf3952: 	 */
1:fdf3952: 	void updateFramework() throws IOException;
1:fdf3952: 
1:fdf3952:  }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:8a05ae7
/////////////////////////////////////////////////////////////////////////
1:     String getProperty(String key) throws IOException;
commit:0273964
commit:7b6fac5
/////////////////////////////////////////////////////////////////////////
1: 															+ ":type=framework,version=1.7";
commit:21be559
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the value of the specified property. If the key is not found in
1:      * the Framework properties, the system properties are then searched. The
1:      * method returns {@code null} if the property is not found.
1:      *
1:      * @param key The name of the requested property.
1:      * @return The value of the requested property, or {@code null} if the
1:      *         property is undefined.
1:      * @throws IOException if the operation failed
1:      */
0:     String getProperty(String key);
1: 
commit:f94132d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the dependency closure for the specified bundles.
1:      *
1:      * <p>
1:      * A graph of bundles is computed starting with the specified bundles. The
1:      * graph is expanded by adding any bundle that is either wired to a package
1:      * that is currently exported by a bundle in the graph or requires a bundle
1:      * in the graph. The graph is fully constructed when there is no bundle
1:      * outside the graph that is wired to a bundle in the graph. The graph may
1:      * contain {@code UNINSTALLED} bundles that are
1:      * {@link #getRemovalPendingBundles() removal pending}.
1:      *
1:      * @param bundles The initial bundles IDs for which to generate the dependency
1:      *        closure.
1:      * @return A bundle ID array containing a snapshot of the dependency closure of
1:      *         the specified bundles, or an empty array if there were no
1:      *         specified bundles.
1:      * @throws IOException if the operation failed
1:      */
1:     long[] getDependencyClosure(long[] bundles) throws IOException;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Returns the bundles IDs that have non-current, in use bundle wirings. This
1:      * is typically the bundles which have been updated or uninstalled since the
1:      * last call to {@link #refreshBundles(long[])}.
1:      *
1:      * @return A bundle ID array containing a snapshot of the bundles which
1:      *         have non-current, in use bundle wirings, or an empty
1:      *         array if there are no such bundles.
1:      * @throws IOException if the operation failed
1:      */
1:     long[] getRemovalPendingBundles() throws IOException;
1: 
1: 	/**
commit:8b67a25
/////////////////////////////////////////////////////////////////////////
1: 	 * Same as {@link #resolveBundles(long[])} but with a more detailed return type.
1: 	 * @param bundleIdentifiers
1: 	 * @return
1: 	 * @throws IOException
1: 	 */
1: 	CompositeData resolve(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
commit:af3b4b3
/////////////////////////////////////////////////////////////////////////
1: 																	SUCCESS_ITEM
/////////////////////////////////////////////////////////////////////////
1: 																	SUCCESS_ITEM
1:     /**
1:      * The Composite Type which represents the result of a batch resolve
1:      * operation. It is used in {@link #refreshBundlesAndWait(String[])}.
1:      *
1:      * This Composite Type consists of the following items:
1:      * <ul>
1:      * <li>{@link #COMPLETED_ITEM}</li>
1:      * <li>{@link #SUCCESS_ITEM}</li>
1:      * </ul>
1:      */
1:     CompositeType   BATCH_RESOLVE_RESULT_TYPE       = Item
1:                                                             .compositeType(
1:                                                                     "BATCH_RESOLVE_RESULT",
1:                                                                     "This type encapsulates a bundle batch resolve action result",
1:                                                                     COMPLETED_ITEM,
1:                                                                     SUCCESS_ITEM);
1: 
commit:c13e6cc
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	boolean refreshBundleAndWait(long bundleIdentifier) throws IOException;
1: 	 *
1: 	CompositeData refreshBundlesAndWait(long[] bundleIdentifiers) throws IOException;
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
1:  * 
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.osgi.jmx.framework;
1: 
1: import java.io.IOException;
1: 
1: import javax.management.openmbean.CompositeData;
1: import javax.management.openmbean.CompositeType;
1: import javax.management.openmbean.SimpleType;
1: 
1: import org.osgi.jmx.Item;
1: import org.osgi.jmx.JmxConstants;
1: 
1: /**
1:  * The FrameworkMbean provides mechanisms to exert control over the framework.
1:  * For many operations, it provides a batch mechanism to avoid excessive message
1:  * passing when interacting remotely.
1:  * 
1:  * @version $Revision$
1:  * @ThreadSafe
1:  */
1: public interface FrameworkMBean {
1: 	/**
1: 	 * The fully qualified object name of this mbean.
1: 	 */
1: 	String			OBJECTNAME						= JmxConstants.OSGI_CORE
0: 															+ ":type=framework,version=1.5";
1: 
1: 	/**
1: 	 * The SUCCESS, used in {@link #SUCCESS_ITEM}.
1: 	 */
1: 	String			SUCCESS							= "Success";
1: 
1: 	/**
1: 	 * The item that indicates if this operation was successful. The key is
1: 	 * {@link #SUCCESS} and the type is {@link SimpleType#BOOLEAN}. It is used
1: 	 * in {@link #BATCH_ACTION_RESULT_TYPE} and
1: 	 * {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 */
1: 	Item			SUCCESS_ITEM					= new Item(
1: 															SUCCESS,
1: 															"Whether the operation was successful",
1: 															SimpleType.BOOLEAN);
1: 
1: 	/**
1: 	 * The key ERROR, used in {@link #ERROR_ITEM}.
1: 	 */
1: 	String			ERROR							= "Error";
1: 
1: 	/**
1: 	 * The item containing the error message of the batch operation. The key is
1: 	 * {@link #ERROR} and the type is {@link SimpleType#STRING}. It is used in
1: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 */
1: 	Item			ERROR_ITEM						= new Item(
1: 															ERROR,
1: 															"The error message if unsuccessful",
1: 															SimpleType.STRING);
1: 
1: 	/**
1: 	 * The key COMPLETED, used in {@link #COMPLETED_ITEM}.
1: 	 */
1: 	String			COMPLETED						= "Completed";
1: 
1: 	/**
1: 	 * The item containing the list of bundles completing the batch operation.
1: 	 * The key is {@link #COMPLETED} and the type is
1: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}. It is used in
1: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 */
1: 	Item			COMPLETED_ITEM					= new Item(
1: 															COMPLETED,
1: 															"The bundle ids of the successfully completed installs",
1: 															JmxConstants.LONG_ARRAY_TYPE);
1: 
1: 	/**
1: 	 * The key for BUNDLE_IN_ERROR. This key is used with two different items:
1: 	 * {@link #BUNDLE_IN_ERROR_ID_ITEM} and
1: 	 * {@link #BUNDLE_IN_ERROR_LOCATION_ITEM} that each have a different type
1: 	 * for this key. It is used in {@link #BATCH_ACTION_RESULT_TYPE} and
1: 	 * {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 */
1: 	String			BUNDLE_IN_ERROR					= "BundleInError";
1: 
1: 	/**
1: 	 * The item containing the bundle which caused the error during the batch
1: 	 * operation. This item describes the bundle in error as an id. The key is
1: 	 * {@link #BUNDLE_IN_ERROR} and the type is {@link SimpleType#LONG}. It is
1: 	 * used in {@link #BATCH_ACTION_RESULT_TYPE}.
1: 	 * 
1: 	 * @see #BUNDLE_IN_ERROR_LOCATION_ITEM BUNDLE_IN_ERROR_LOCATION_ITEM for the
1: 	 *      item that has a location for the bundle in error.
1: 	 */
1: 	Item			BUNDLE_IN_ERROR_ID_ITEM			= new Item(
1: 															BUNDLE_IN_ERROR,
1: 															"The id of the bundle causing the error",
1: 															SimpleType.LONG);
1: 
1: 	/**
1: 	 * The key REMAINING, used in {@link #REMAINING_ID_ITEM} and
1: 	 * {@link #REMAINING_LOCATION_ITEM}.
1: 	 */
1: 	String			REMAINING						= "Remaining";
1: 
1: 	/**
1: 	 * The item containing the list of remaining bundles unprocessed by the
1: 	 * failing batch operation. The key is {@link #REMAINING} and the type is
1: 	 * {@link JmxConstants#LONG_ARRAY_TYPE}. It is used in
1: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 */
1: 	Item			REMAINING_ID_ITEM				= new Item(
1: 															REMAINING,
1: 															"The ids of the remaining bundles",
1: 															JmxConstants.LONG_ARRAY_TYPE);
1: 
1: 	/**
1: 	 * The Composite Type for a batch action result.
1: 	 * {@link #refreshBundle(long)} and {@link #refreshBundles(long[])}.
1: 	 * Notice that a batch action result returns uses an id for the
1: 	 * {@link #BUNDLE_IN_ERROR} while the {@link #BATCH_INSTALL_RESULT_TYPE}
1: 	 * uses a location.
1: 	 * 
1: 	 * This Composite Type consists of the following items:
1: 	 * <ul>
1: 	 * <li>{@link #BUNDLE_IN_ERROR_ID_ITEM}</li>
1: 	 * <li>{@link #COMPLETED_ITEM}</li>
1: 	 * <li>{@link #ERROR_ITEM}</li>
1: 	 * <li>{@link #REMAINING_ID_ITEM}</li>
1: 	 * <li>{@link #SUCCESS_ITEM}</li>
1: 	 * </ul>
1: 	 */
1: 	CompositeType	BATCH_ACTION_RESULT_TYPE		= Item
1: 															.compositeType(
1: 																	"BUNDLE_ACTION_RESULT",
1: 																	"This type encapsulates a bundle batch install action result",
1: 																	BUNDLE_IN_ERROR_ID_ITEM,
1: 																	COMPLETED_ITEM,
1: 																	ERROR_ITEM,
1: 																	REMAINING_ID_ITEM,
0: 																	SUCCESS_ITEM //
1: 															);
1: 
1: 	/**
1: 	 * The item containing the bundle which caused the error during the batch
1: 	 * operation. This item describes the bundle in error as a location. The key
1: 	 * is {@link #BUNDLE_IN_ERROR} and the type is {@link SimpleType#STRING}. It
1: 	 * is used in {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 * 
1: 	 * @see #BUNDLE_IN_ERROR_ID_ITEM BUNDLE_IN_ERROR_ID_ITEM for the item that
1: 	 *      has the id for the bundle in error.
1: 	 */
1: 	Item			BUNDLE_IN_ERROR_LOCATION_ITEM	= new Item(
1: 															BUNDLE_IN_ERROR,
1: 															"The location of the bundle causing the error",
1: 															SimpleType.STRING);
1: 
1: 	/**
1: 	 * The item containing the list of remaining bundles unprocessed by the
1: 	 * failing batch operation. The key is {@link #REMAINING} and the type is
1: 	 * {@link JmxConstants#STRING_ARRAY_TYPE}. It is used in
1: 	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
1: 	 */
1: 	Item			REMAINING_LOCATION_ITEM			= new Item(
1: 															REMAINING,
1: 															"The locations of the remaining bundles",
1: 															JmxConstants.STRING_ARRAY_TYPE);
1: 
1: 	/**
1: 	 * The Composite Type which represents the result of a batch install
1: 	 * operation. It is used in {@link #installBundles(String[])} and
1: 	 * {@link #installBundlesFromURL(String[], String[])}.
1: 	 * 
1: 	 * This Composite Type consists of the following items:
1: 	 * <ul>
1: 	 * <li>{@link #BUNDLE_IN_ERROR_LOCATION_ITEM}</li>
1: 	 * <li>{@link #COMPLETED_ITEM}</li>
1: 	 * <li>{@link #ERROR_ITEM}</li>
1: 	 * <li>{@link #REMAINING_LOCATION_ITEM P }</li>
1: 	 * <li>{@link #SUCCESS_ITEM}</li>
1: 	 * </ul>
1: 	 */
1: 	CompositeType	BATCH_INSTALL_RESULT_TYPE		= Item
1: 															.compositeType(
1: 																	"BATCH_INSTALL_RESULT",
1: 																	"This type encapsulates a bundle batch install action result",
1: 																	BUNDLE_IN_ERROR_LOCATION_ITEM,
1: 																	COMPLETED_ITEM,
1: 																	ERROR_ITEM,
1: 																	REMAINING_LOCATION_ITEM,
0: 																	SUCCESS_ITEM //
1: 															);
1: 
1: 	/**
1: 	 * Retrieve the framework start level
1: 	 * 
1: 	 * @return the framework start level
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	int getFrameworkStartLevel() throws IOException;
1: 
1: 	/**
1: 	 * Answer the initial start level assigned to a bundle when it is first
1: 	 * started
1: 	 * 
1: 	 * @return the start level
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	int getInitialBundleStartLevel() throws IOException;
1: 
1: 	/**
1: 	 * Install the bundle indicated by the bundleLocations
1: 	 * 
1: 	 * @param location the location of the bundle to install
1: 	 * @return the bundle id the installed bundle
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	long installBundle(String location) throws IOException;
1: 
1: 	/**
1: 	 * Install the bundle indicated by the bundleLocations
1: 	 * 
1: 	 * @param location the location to assign to the bundle
1: 	 * @param url the URL which will supply the bytes for the bundle
1: 	 * @return the bundle id the installed bundle
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	long installBundleFromURL(String location, String url) throws IOException;
1: 
1: 	/**
1: 	 * Batch install the bundles indicated by the list of bundleLocationUrls
1: 	 * 
1: 	 * @see #BATCH_INSTALL_RESULT_TYPE BATCH_INSTALL_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param locations the array of locations of the bundles to install
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	CompositeData installBundles(String[] locations) throws IOException;
1: 
1: 	/**
1: 	 * Batch install the bundles indicated by the list of bundleLocationUrls
1: 	 * 
1: 	 * @see #BATCH_INSTALL_RESULT_TYPE BATCH_INSTALL_RESULT_TYPE
1: 	 *      BatchBundleResult for the precise specification of the CompositeData
1: 	 *      type representing the returned result.
1: 	 * 
1: 	 * @param locations the array of locations to assign to the installed
1: 	 *        bundles
1: 	 * @param urls the array of urls which supply the bundle bytes
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	CompositeData installBundlesFromURL(String[] locations, String[] urls)
1: 			throws IOException;
1: 
1: 	/**
1: 	 * Force the update, replacement or removal of the packages identified by
1: 	 * the specified bundle.
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void refreshBundle(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Force the update, replacement or removal of the packages identified by
1: 	 * the list of bundles.
1: 	 * 
1: 	 * @param bundleIdentifiers The identifiers of the bundles to refresh, or
1: 	 *        <code>null</code> for all bundles with packages pending removal.
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void refreshBundles(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
1: 	 * Resolve the bundle indicated by the unique symbolic name and version
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @return <code>true</code> if the bundle was resolved, false otherwise
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	boolean resolveBundle(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Batch resolve the bundles indicated by the list of bundle identifiers
1: 	 * 
1: 	 * @param bundleIdentifiers The identifiers of the bundles to resolve, or
1: 	 *        <code>null</code> to resolve all unresolved bundles.
1: 	 * @return <code>true</code> if the bundles were resolved, false otherwise
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	boolean resolveBundles(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
1: 	 * Restart the framework by updating the system bundle
1: 	 * 
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void restartFramework() throws IOException;
1: 
1: 	/**
1: 	 * Set the start level for the bundle identifier
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @param newlevel the new start level for the bundle
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void setBundleStartLevel(long bundleIdentifier, int newlevel)
1: 			throws IOException;
1: 
1: 	/**
1: 	 * Set the start levels for the list of bundles.
1: 	 * 
1: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param bundleIdentifiers the array of bundle identifiers
1: 	 * @param newlevels the array of new start level for the bundles
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	CompositeData setBundleStartLevels(long[] bundleIdentifiers, int[] newlevels)
1: 			throws IOException;
1: 
1: 	/**
1: 	 * Set the start level for the framework
1: 	 * 
1: 	 * @param newlevel the new start level
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void setFrameworkStartLevel(int newlevel) throws IOException;
1: 
1: 	/**
1: 	 * Set the initial start level assigned to a bundle when it is first started
1: 	 * 
1: 	 * @param newlevel the new start level
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void setInitialBundleStartLevel(int newlevel) throws IOException;
1: 
1: 	/**
1: 	 * Shutdown the framework by stopping the system bundle
1: 	 * 
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void shutdownFramework() throws IOException;
1: 
1: 	/**
1: 	 * Start the bundle indicated by the bundle identifier
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	void startBundle(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Batch start the bundles indicated by the list of bundle identifier
1: 	 * 
1: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param bundleIdentifiers the array of bundle identifiers
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	CompositeData startBundles(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
1: 	 * Stop the bundle indicated by the bundle identifier
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	void stopBundle(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Batch stop the bundles indicated by the list of bundle identifier
1: 	 * 
1: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param bundleIdentifiers the array of bundle identifiers
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	CompositeData stopBundles(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
1: 	 * Uninstall the bundle indicated by the bundle identifier
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	void uninstallBundle(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Batch uninstall the bundles indicated by the list of bundle identifiers
1: 	 * 
1: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param bundleIdentifiers the array of bundle identifiers
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	CompositeData uninstallBundles(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
1: 	 * Update the bundle indicated by the bundle identifier
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	void updateBundle(long bundleIdentifier) throws IOException;
1: 
1: 	/**
1: 	 * Update the bundle identified by the bundle identifier
1: 	 * 
1: 	 * @param bundleIdentifier the bundle identifier
1: 	 * @param url the URL to use to update the bundle
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	void updateBundleFromURL(long bundleIdentifier, String url) throws IOException;
1: 
1: 	/**
1: 	 * Batch update the bundles indicated by the list of bundle identifier.
1: 	 * 
1: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param bundleIdentifiers the array of bundle identifiers
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 */
1: 	CompositeData updateBundles(long[] bundleIdentifiers) throws IOException;
1: 
1: 	/**
1: 	 * Update the bundle uniquely identified by the bundle symbolic name and
1: 	 * version using the contents of the supplied urls.
1: 	 * 
1: 	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
1: 	 *      specification of the CompositeData type representing the returned
1: 	 *      result.
1: 	 * 
1: 	 * @param bundleIdentifiers the array of bundle identifiers
1: 	 * @param urls the array of URLs to use to update the bundles
1: 	 * @return the resulting state from executing the operation
1: 	 * @throws IOException if the operation does not succeed
1: 	 * @throws IllegalArgumentException if the bundle indicated does not exist
1: 	 */
1: 	CompositeData updateBundlesFromURL(long[] bundleIdentifiers, String[] urls)
1: 			throws IOException;
1: 
1: 	/**
1: 	 * Update the framework by updating the system bundle.
1: 	 * 
1: 	 * @throws IOException if the operation failed
1: 	 */
1: 	void updateFramework() throws IOException;
1: 
1:  }
============================================================================