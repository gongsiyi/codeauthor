1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
3:f13c6ac: 
1:f13c6ac: import java.lang.reflect.Method;
1:e3bd874: import java.security.AccessControlContext;
1:e3bd874: import java.security.AccessController;
1:e3bd874: import java.security.DomainCombiner;
1:e3bd874: import java.security.Permission;
1:e3bd874: import java.security.PrivilegedAction;
1:e3bd874: import java.security.ProtectionDomain;
1:f13c6ac: import java.util.ArrayList;
1:b5f484e: import java.util.Arrays;
1:f13c6ac: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:f13c6ac: import java.util.HashMap;
1:f13c6ac: import java.util.HashSet;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Map;
1:f13c6ac: import java.util.Set;
1:f13c6ac: import java.util.concurrent.Callable;
1:f13c6ac: import java.util.concurrent.atomic.AtomicBoolean;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.BlueprintConstants;
1:ae7707a: import org.apache.aries.blueprint.ExtendedReferenceMetadata;
1:6414875: import org.apache.aries.blueprint.ExtendedServiceReferenceMetadata;
1:6414875: import org.apache.aries.blueprint.di.AbstractRecipe;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:d46274e: import org.apache.aries.blueprint.di.ExecutionContext;
1:96a82ee: import org.apache.aries.blueprint.di.Recipe;
1:d46274e: import org.apache.aries.blueprint.di.ValueRecipe;
1:4dfd2d8: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:6414875: import org.apache.aries.blueprint.utils.ReflectionUtils;
1:b13e703: import org.osgi.framework.BundleContext;
1:f13c6ac: import org.osgi.framework.Constants;
1:f13c6ac: import org.osgi.framework.InvalidSyntaxException;
1:f13c6ac: import org.osgi.framework.ServiceEvent;
1:f13c6ac: import org.osgi.framework.ServiceListener;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.container.ReifiedType;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * Abstract class for service reference recipes.
1:f13c6ac:  *
1:f13c6ac:  * TODO: if we have a single interface (which is the standard behavior), then we should be able to get rid of
1:f13c6ac:  *       the proxyClassloader and just use this interface classloader to define the proxy
1:f13c6ac:  *
1:f13c6ac:  * TODO: it is allowed to have no interface defined at all, which should result in an empty proxy
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:9728962: @SuppressWarnings("rawtypes")
1:f13c6ac: public abstract class AbstractServiceReferenceRecipe extends AbstractRecipe implements ServiceListener, SatisfiableRecipe {
1:f13c6ac: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractServiceReferenceRecipe.class);
1:f13c6ac: 
1:f13c6ac:     protected final ExtendedBlueprintContainer blueprintContainer;
1:f13c6ac:     protected final ServiceReferenceMetadata metadata;
1:d46274e:     protected final ValueRecipe filterRecipe;
1:f13c6ac:     protected final CollectionRecipe listenersRecipe;
1:f13c6ac:     protected final List<Recipe> explicitDependencies;
1:f13c6ac:     protected final boolean optional;
1:f13c6ac:     /** The OSGi filter for tracking references */
1:f13c6ac:     protected final String filter;
1:f13c6ac:     /** The list of listeners for this reference.  This list will be lazy created */
1:f13c6ac:     protected List<Listener> listeners;
1:f13c6ac: 
1:f13c6ac:     private final AtomicBoolean started = new AtomicBoolean();
1:f13c6ac:     private final AtomicBoolean satisfied = new AtomicBoolean();
1:e5c40e5:     private volatile SatisfactionListener satisfactionListener;
1:f13c6ac: 
1:27e02c9:     private final AccessControlContext accessControlContext;
1:f13c6ac: 
1:b5f484e:     private final Tracked tracked = new Tracked();
1:b5f484e: 
1:f13c6ac:     protected AbstractServiceReferenceRecipe(String name,
1:f13c6ac:                                              ExtendedBlueprintContainer blueprintContainer,
1:f13c6ac:                                              ServiceReferenceMetadata metadata,
1:d46274e:                                              ValueRecipe filterRecipe,
1:f13c6ac:                                              CollectionRecipe listenersRecipe,
1:f13c6ac:                                              List<Recipe> explicitDependencies) {
1:f13c6ac:         super(name);
1:f13c6ac:         this.prototype = false;
1:f13c6ac:         this.blueprintContainer = blueprintContainer;
1:f13c6ac:         this.metadata = metadata;
1:d46274e:         this.filterRecipe = filterRecipe;
1:f13c6ac:         this.listenersRecipe = listenersRecipe;
1:f13c6ac:         this.explicitDependencies = explicitDependencies;
1:f13c6ac:         
1:f13c6ac:         
1:f13c6ac:         this.optional = (metadata.getAvailability() == ReferenceMetadata.AVAILABILITY_OPTIONAL);
1:d46274e:         this.filter = createOsgiFilter(metadata, null);
1:f13c6ac:         
1:9728962:         accessControlContext = (System.getSecurityManager() != null) ? createAccessControlContext() : null;
30:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: 
1:f13c6ac: 
1:f13c6ac:     public CollectionRecipe getListenersRecipe() {
1:f13c6ac:         return listenersRecipe;
1:774ce31:     }
1:f13c6ac: 
1:f13c6ac:     public void start(SatisfactionListener listener) {
1:f13c6ac:         if (listener == null) throw new NullPointerException("satisfactionListener is null");
1:f13c6ac:         if (started.compareAndSet(false, true)) {
1:3e11f4a:             try {
1:f13c6ac:                 satisfactionListener = listener;
1:f13c6ac:                 satisfied.set(optional);
1:f13c6ac:                 // Synchronized block on references so that service events won't interfere with initial references tracking
1:f13c6ac:                 // though this may not be sufficient because we don't control ordering of those events
1:b5f484e:                 synchronized (tracked) {
1:b13e703:                     getBundleContextForServiceLookup().addServiceListener(this, getOsgiFilter());
1:b49a314:                     ServiceReference[] references = getBundleContextForServiceLookup().getServiceReferences((String) null, getOsgiFilter());
1:b5f484e:                     tracked.setInitial(references != null ? references : new ServiceReference[0]);
1:8c4aa3a:                 }
1:b5f484e:                 tracked.trackInitial();
1:b5f484e:                 satisfied.set(optional || !tracked.isEmpty());
1:b5f484e:                 retrack();
1:b5f484e:                 LOGGER.debug("Found initial references {} for OSGi service {}", getServiceReferences(), getOsgiFilter());
1:f13c6ac:             } catch (InvalidSyntaxException e) {
2:f13c6ac:                 throw new ComponentDefinitionException(e);
1:774ce31:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void stop() {
1:f13c6ac:         if (started.compareAndSet(true, false)) {
1:b5f484e:             tracked.close();
1:b5f484e:             try {
1:b5f484e:                 getBundleContextForServiceLookup().removeServiceListener(this);
1:b5f484e:             } catch (IllegalStateException e) {
1:b5f484e:                 // Ignore in case bundle context is already invalidated
1:3e11f4a:             }
1:b5f484e:             doStop();
1:b5f484e:             for (ServiceReference ref : getServiceReferences()) {
1:b5f484e:                 untrack(ref);
1:b5f484e:             }
1:b5f484e:             satisfied.set(false);
1:27e02c9:             satisfactionListener = null;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void doStop() {
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected boolean isStarted() {
1:f13c6ac:         return started.get();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public boolean isSatisfied() {
1:f13c6ac:         return satisfied.get();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     @Override
1:f13c6ac:     public List<Recipe> getConstructorDependencies() {
1:f13c6ac:         List<Recipe> recipes = new ArrayList<Recipe>();
1:f13c6ac:         if (explicitDependencies != null) {
1:f13c6ac:             recipes.addAll(explicitDependencies);
1:f13c6ac:         }
1:f13c6ac:         return recipes;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public List<Recipe> getDependencies() {
1:f13c6ac:         List<Recipe> recipes = new ArrayList<Recipe>();
1:f13c6ac:         if (listenersRecipe != null) {
1:f13c6ac:             recipes.add(listenersRecipe);
1:f13c6ac:         }
1:f13c6ac:         recipes.addAll(getConstructorDependencies());
1:f13c6ac:         return recipes;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public String getOsgiFilter() {
1:d46274e:         if (filterRecipe != null && blueprintContainer instanceof BlueprintContainerImpl) {
1:d46274e:             BlueprintContainerImpl.State state = ((BlueprintContainerImpl) blueprintContainer).getState();
1:d46274e:             switch (state) {
1:d46274e:                 case InitialReferencesSatisfied:
1:d46274e:                 case WaitForInitialReferences2:
1:d46274e:                 case Create:
1:d46274e:                 case Created:
1:d46274e:                     return createOsgiFilter(metadata, getExtendedOsgiFilter());
1:d46274e:             }
1:d46274e:         }
1:f13c6ac:         return filter;
1:f13c6ac:     }
1:f13c6ac: 
1:d46274e:     private String getExtendedOsgiFilter() {
1:d46274e:         if (filterRecipe != null) {
1:d46274e:             Object object;
1:d46274e:             BlueprintRepository repository = ((BlueprintContainerImpl) blueprintContainer).getRepository();
1:d46274e:             ExecutionContext oldContext = null;
1:d46274e:             try {
1:d46274e:                 oldContext = ExecutionContext.Holder.setContext(repository);
1:d46274e:                 object = filterRecipe.create();
1:d46274e:             } finally {
1:d46274e:                 ExecutionContext.Holder.setContext(oldContext);
1:d46274e:             }
1:d46274e:             if (object != null) {
1:d46274e:                 String flt = object.toString();
1:d46274e:                 if (flt != null && flt.length() > 0) {
1:d46274e:                     if (!flt.startsWith("(")) {
1:d46274e:                         flt = "(" + flt + ")";
1:d46274e:                     }
1:d46274e:                     return flt;
1:d46274e:                 }
1:d46274e:             }
1:d46274e:         }
1:d46274e:         return null;
1:d46274e:     }
1:d46274e: 
1:9728962:     @SuppressWarnings("unchecked")
1:9728962:     protected Object getServiceSecurely(final ServiceReference serviceReference) {
1:9728962:         if (accessControlContext == null) {
1:9728962:             return getBundleContextForServiceLookup().getService(serviceReference);
1:774ce31:         } else {
1:9728962:             // If we're operating with security, use the privileges of the bundle
1:9728962:             // we're managing to do the lookup
1:9728962:             return AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:9728962:                 public Object run() {
1:9728962:                     return getBundleContextForServiceLookup().getService(serviceReference);
1:774ce31:                 }
1:9728962:             }, accessControlContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:9728962:     /**
1:9728962:      * We may need to execute code within a doPrivileged block, and if so, it should be the privileges of the
1:9728962:      * bundle with the blueprint file that get used, not the privileges of blueprint-core. To achieve this we
1:9728962:      * use an access context.
1:9728962:      * 
1:9728962:      * @return
1:9728962:      */
1:9728962:     private AccessControlContext createAccessControlContext() {
1:9728962:         return new AccessControlContext(AccessController.getContext(), new DomainCombiner() {
1:9728962:             public ProtectionDomain[] combine(ProtectionDomain[] arg0, ProtectionDomain[] arg1) {
1:9728962:                 ProtectionDomain protectionDomain = new ProtectionDomain(null, null) {
1:9728962:                     public boolean implies(Permission permission) {
1:9728962:                         return getBundleContextForServiceLookup().getBundle().hasPermission(permission);
1:f13c6ac:                     }
1:9728962:                 };
1:9728962:                 return new ProtectionDomain[] {
1:9728962:                     protectionDomain
1:9728962:                 };
1:f13c6ac:             }
1:2c635b1:         });
1:f13c6ac:     }
1:f13c6ac: 
1:9728962:     @SuppressWarnings("unchecked")
1:f13c6ac:     protected void createListeners() {
1:f13c6ac:         if (listenersRecipe != null) {
1:9728962:             List<Listener> listeners = (List<Listener>)listenersRecipe.create();
1:f13c6ac:             for (Listener listener : listeners) {
1:9728962:                 List<Class> classList = new ArrayList<Class>();
1:9728962:                 Class clz = getInterfaceClass();
1:9728962:                 if (clz != null) {
1:9728962:                     classList.add(clz);
1:f13c6ac:                 } else {
1:9728962:                     classList.add(Object.class);
1:f13c6ac:                 }
1:9728962:                 listener.init(classList);
1:f13c6ac:             }
1:f13c6ac:             this.listeners = listeners;
1:f13c6ac:         } else {
1:f13c6ac:             this.listeners = Collections.emptyList();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:24455ce:     protected List<Class<?>> loadAllClasses(Iterable<String> interfaceNames) {
1:24455ce:         List<Class<?>> classes = new ArrayList<Class<?>>();
1:f13c6ac:         for (String name : interfaceNames) {
1:24455ce:             Class<?> clazz = loadClass(name);
1:f13c6ac:             classes.add(clazz);
1:f13c6ac:         }
1:f13c6ac:         return classes;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected ReifiedType loadType(String typeName, ClassLoader fromClassLoader) {
1:f13c6ac:         if (typeName == null) {
1:f13c6ac:             return null;
1:f13c6ac:         }
1:2c635b1:         try {
1:f13c6ac:             // this method is overriden to use the blueprint container directly
1:f13c6ac:             // because proxies can be created outside of the recipe creation which
1:f13c6ac:             // would lead to an exception because the context is not set
1:f13c6ac:             // TODO: consider having the context as a property on the recipe rather than a thread local
1:f13c6ac:             return GenericType.parse(typeName, fromClassLoader != null ? fromClassLoader : blueprintContainer);
2:f13c6ac:         } catch (ClassNotFoundException e) {
1:f13c6ac:             throw new ComponentDefinitionException("Unable to load class " + typeName + " from recipe " + this, e);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: 
1:24455ce:     protected Object createProxy(final Callable<Object> dispatcher, Set<Class<?>> interfaces) throws Exception {
1:f13c6ac:         if (!interfaces.iterator().hasNext()) {
1:f13c6ac:             return new Object();
1:f13c6ac:         } else {
1:d4b3ee0:             // Check class proxying
1:d4b3ee0:             boolean proxyClass = false;
1:d4b3ee0:             if (metadata instanceof ExtendedServiceReferenceMetadata) {
1:d4b3ee0:                 proxyClass = (((ExtendedServiceReferenceMetadata) metadata).getProxyMethod() & ExtendedServiceReferenceMetadata.PROXY_METHOD_CLASSES) != 0;
1:d4b3ee0:             }
1:d4b3ee0:             if (!proxyClass) {
1:d4b3ee0:                 for (Class cl : interfaces) {
1:d4b3ee0:                     if (!cl.isInterface()) {
1:d4b3ee0:                         throw new ComponentDefinitionException("A class " + cl.getName() + " was found in the interfaces list, but class proxying is not allowed by default. The ext:proxy-method='classes' attribute needs to be added to this service reference.");
1:d4b3ee0:                     }
1:d4b3ee0:                 }
1:d4b3ee0:             }
1:d4b3ee0:             //We don't use the #getBundleContextForServiceLookup() method here, the bundle requesting the proxy is the
1:b13e703:             //blueprint client, not the context of the lookup
1:4dfd2d8:             return blueprintContainer.getProxyManager().createDelegatingProxy(blueprintContainer.getBundleContext().getBundle(), interfaces, dispatcher, null);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void serviceChanged(ServiceEvent event) {
1:8351107:       int eventType = event.getType();
1:8351107:       ServiceReference ref = event.getServiceReference();
1:2c635b1:       switch (eventType) {
1:2c635b1:           case ServiceEvent.REGISTERED:
1:b5f484e:               serviceAdded(ref, event);
1:2c635b1:               break;
1:2c635b1:           case ServiceEvent.MODIFIED:
1:b5f484e:               serviceModified(ref, event);
1:2c635b1:               break;
1:2c635b1:           case ServiceEvent.UNREGISTERING:
1:b5f484e:               serviceRemoved(ref, event);
1:2c635b1:               break;
1:2c635b1:       }
1:2c635b1:     }  
1:f13c6ac: 
1:f13c6ac: 
1:b5f484e:     private void serviceAdded(ServiceReference ref, ServiceEvent event) {
1:f13c6ac:         LOGGER.debug("Tracking reference {} for OSGi service {}", ref, getOsgiFilter());
3:27e02c9:         if (isStarted()) {
1:b5f484e:             tracked.track(ref, event);
1:f13c6ac:             boolean satisfied;
1:b5f484e:             synchronized (tracked) {
1:b5f484e:                 satisfied = optional || !tracked.isEmpty();
1:f592a28:             }
1:f13c6ac:             setSatisfied(satisfied);
1:b5f484e:             track(ref);
1:b5f484e:         }
1:b5f484e:     }
1:b5f484e: 
1:b5f484e:     private void serviceModified(ServiceReference ref, ServiceEvent event) {
1:b5f484e:         // ref must be in references and must be satisfied
1:b5f484e:         if (isStarted()) {
1:b5f484e:             tracked.track(ref, event);
1:b5f484e:             track(ref);
1:b5f484e:         }
1:b5f484e:     }
1:b5f484e: 
1:b5f484e:     private void serviceRemoved(ServiceReference ref, ServiceEvent event) {
1:b5f484e:         if (isStarted()) {
1:b5f484e:             LOGGER.debug("Untracking reference {} for OSGi service {}", ref, getOsgiFilter());
1:b5f484e:             tracked.untrack(ref, event);
1:b5f484e:             boolean satisfied;
1:b5f484e:             synchronized (tracked) {
1:b5f484e:                 satisfied = optional || !tracked.isEmpty();
1:b5f484e:             }
1:b5f484e:             setSatisfied(satisfied);
1:b5f484e:             untrack(ref);
1:8351107:         }
1:8351107:     }
1:f13c6ac:     
1:2a55096:     protected Class getInterfaceClass() {
1:2a55096:         Class clz = getRuntimeClass(metadata);
1:2a55096:         if (clz != null)
1:2a55096:             return clz;
1:2a55096:         else if (metadata.getInterface() != null)
1:2a55096:             return loadClass(metadata.getInterface());
1:f13c6ac:         return null;
1:f13c6ac:     }
1:f13c6ac:     
1:2a55096:     protected static Class getRuntimeClass(ServiceReferenceMetadata metadata) {
1:774ce31:         if (metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
1:2a55096:            return ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface();
1:f13c6ac:         } 
2:2a55096:         return null;
1:f13c6ac:     }
1:f13c6ac: 
1:b13e703:     protected BundleContext getBundleContextForServiceLookup() {
1:774ce31:         if (metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
1:b13e703:             BundleContext context = ((ExtendedServiceReferenceMetadata) metadata).getBundleContext();
1:b13e703:             if(context != null) {
1:b13e703:               return context;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:          
1:b13e703:         return blueprintContainer.getBundleContext();
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     protected void setSatisfied(boolean s) {
1:f13c6ac:         // This check will ensure an atomic comparision and set
1:f13c6ac:         // so that it will only be true if the value actually changed
1:f13c6ac:         if (satisfied.getAndSet(s) != s) {
1:f13c6ac:             LOGGER.debug("Service reference with filter {} satisfied {}", getOsgiFilter(), this.satisfied);
1:e5c40e5:             SatisfactionListener listener = this.satisfactionListener;
1:e5c40e5:             if (listener != null) {
1:e5c40e5:                 listener.notifySatisfaction(this);
1:e5c40e5:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected abstract void track(ServiceReference reference);
1:f13c6ac: 
1:f13c6ac:     protected abstract void untrack(ServiceReference reference);
1:f13c6ac: 
1:f13c6ac:     protected abstract void retrack();
1:f13c6ac: 
1:b5f484e:     protected void updateListeners() {
1:b5f484e:         boolean empty;
1:b5f484e:         synchronized (tracked) {
1:b5f484e:             empty = tracked.isEmpty();
1:b5f484e:         }
1:b5f484e:         if (empty) {
1:f13c6ac:             unbind(null, null);
1:f13c6ac:         } else {
1:f13c6ac:             retrack();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     protected void bind(ServiceReference reference, Object service) {
1:f13c6ac:         if (listeners != null) {    
1:f13c6ac:             for (Listener listener : listeners) {
1:f13c6ac:                 if (listener != null) {
1:f13c6ac:                     listener.bind(reference, service);
1:f13c6ac:                 }
1:f13c6ac:             } 
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     protected void unbind(ServiceReference reference, Object service) {
1:f13c6ac:         if (listeners != null) {    
1:f13c6ac:             for (Listener listener : listeners) {
1:f13c6ac:                 if (listener != null) {
1:f13c6ac:                     listener.unbind(reference, service);
1:f13c6ac:                 }
1:f13c6ac:             } 
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public List<ServiceReference> getServiceReferences() {
1:b5f484e:         ServiceReference[] refs;
1:b5f484e:         synchronized (tracked) {
1:b5f484e:             refs = new ServiceReference[tracked.size()];
1:b5f484e:             tracked.copyKeys(refs);
1:f13c6ac:         }
1:b5f484e:         return Arrays.asList(refs);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public ServiceReference getBestServiceReference() {
1:b5f484e:         List<ServiceReference> references = getServiceReferences();
1:b5f484e:         int length = references.size();
1:b5f484e:         if (length == 0) { /* if no service is being tracked */
1:b5f484e:             return null;
1:b5f484e:         }
1:b5f484e:         int index = 0;
1:b5f484e:         if (length > 1) { /* if more than one service, select highest ranking */
1:b5f484e:             int maxRanking = Integer.MIN_VALUE;
1:b5f484e:             long minId = Long.MAX_VALUE;
1:b5f484e:             for (int i = 0; i < length; i++) {
1:b5f484e:                 Object property = references.get(i).getProperty(Constants.SERVICE_RANKING);
1:b5f484e:                 int ranking = (property instanceof Integer) ? (Integer) property : 0;
1:b5f484e:                 long id = (Long) references.get(i).getProperty(Constants.SERVICE_ID);
1:b5f484e:                 if ((ranking > maxRanking) || (ranking == maxRanking && id < minId)) {
1:b5f484e:                     index = i;
1:b5f484e:                     maxRanking = ranking;
1:b5f484e:                     minId = id;
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:b5f484e:         return references.get(index);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static class Listener {
1:f13c6ac: 
1:f13c6ac:         private static final Logger LOGGER = LoggerFactory.getLogger(Listener.class);
1:f13c6ac: 
1:f13c6ac:         private Object listener;
1:f13c6ac:         private ReferenceListener metadata;
1:f13c6ac:         private ExtendedBlueprintContainer blueprintContainer;
1:f13c6ac: 
1:f13c6ac:         private Set<Method> bindMethodsReference = new HashSet<Method>();
1:f13c6ac:         private Set<Method> bindMethodsObjectProp = new HashSet<Method>();
1:f13c6ac:         private Set<Method> bindMethodsObject = new HashSet<Method>();
1:f13c6ac:         private Set<Method> unbindMethodsReference = new HashSet<Method>();
1:f13c6ac:         private Set<Method> unbindMethodsObject = new HashSet<Method>();
1:f13c6ac:         private Set<Method> unbindMethodsObjectProp = new HashSet<Method>();
1:f13c6ac: 
1:f13c6ac:         public void setListener(Object listener) {
1:f13c6ac:             this.listener = listener;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void setMetadata(ReferenceListener metadata) {
1:f13c6ac:             this.metadata = metadata;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void setBlueprintContainer(ExtendedBlueprintContainer blueprintContainer) {
1:f13c6ac:             this.blueprintContainer = blueprintContainer;
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         public void init(Collection<Class> classes) {
1:f13c6ac:             Set<Class> clazzes = new HashSet<Class>(classes);
1:f13c6ac:             clazzes.add(Object.class);
1:f13c6ac:             Class listenerClass = listener.getClass();
1:f13c6ac:             String bindName = metadata.getBindMethod();
1:f13c6ac:             if (bindName != null) {
1:f13c6ac:                 bindMethodsReference.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, bindName, new Class[] { ServiceReference.class }));
1:f13c6ac:                 for (Class clazz : clazzes) {
1:f13c6ac:                     bindMethodsObject.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, bindName, new Class[] { clazz }));
1:f13c6ac:                     bindMethodsObjectProp.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, bindName, new Class[] { clazz, Map.class }));
1:f13c6ac:                 }
1:f13c6ac:                 if (bindMethodsReference.size() + bindMethodsObject.size() + bindMethodsObjectProp.size() == 0) {
1:f13c6ac:                     throw new ComponentDefinitionException("No matching methods found for listener bind method: " + bindName);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             String unbindName = metadata.getUnbindMethod();
1:f13c6ac:             if (unbindName != null) {
1:f13c6ac:                 unbindMethodsReference.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, unbindName, new Class[] { ServiceReference.class }));
1:f13c6ac:                 for (Class clazz : clazzes) {
1:f13c6ac:                     unbindMethodsObject.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, unbindName, new Class[] { clazz }));
1:f13c6ac:                     unbindMethodsObjectProp.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, unbindName, new Class[] { clazz, Map.class }));
1:f13c6ac:                 }
1:f13c6ac:                 if (unbindMethodsReference.size() + unbindMethodsObject.size() + unbindMethodsObjectProp.size() == 0) {
1:f13c6ac:                     throw new ComponentDefinitionException("No matching methods found for listener unbind method: " + unbindName);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void bind(ServiceReference reference, Object service) {
1:f13c6ac:             invokeMethods(bindMethodsReference, bindMethodsObject, bindMethodsObjectProp, reference, service);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void unbind(ServiceReference reference, Object service) {
1:f13c6ac:             invokeMethods(unbindMethodsReference, unbindMethodsObject, unbindMethodsObjectProp, reference, service);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         private void invokeMethods(Set<Method> referenceMethods, Set<Method> objectMethods, Set<Method> objectPropMethods, ServiceReference reference, Object service) {
1:f13c6ac:             for (Method method : referenceMethods) {
1:8c4aa3a:                 try {
1:f13c6ac:                     ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), 
1:f13c6ac:                                            method, listener, reference);
1:f13c6ac:                 } catch (Exception e) {
1:f13c6ac:                     LOGGER.error("Error calling listener method " + method, e);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             for (Method method : objectMethods) {
1:774ce31:                 try {
1:f13c6ac:                     ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), 
1:f13c6ac:                                            method, listener, service);
1:f13c6ac:                 } catch (Exception e) {
1:f13c6ac:                     LOGGER.error("Error calling listener method " + method, e);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             Map<String, Object> props = null;
1:f13c6ac:             for (Method method : objectPropMethods) {
1:f13c6ac:                 if (props == null) {
1:f13c6ac:                     props = new HashMap<String, Object>();
1:f13c6ac:                     if (reference != null) {
1:f13c6ac:                         for (String name : reference.getPropertyKeys()) {
1:f13c6ac:                             props.put(name, reference.getProperty(name));
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                 }
7:f13c6ac:                 try {
1:f13c6ac:                     ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), 
1:f13c6ac:                                            method, listener, service, props);
1:f13c6ac:                 } catch (Exception e) {
1:f13c6ac:                     LOGGER.error("Error calling listener method " + method, e);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Create the OSGi filter corresponding to the ServiceReferenceMetadata constraints
1:f13c6ac:      *
1:f13c6ac:      * @param metadata the service reference metadata
1:f13c6ac:      * @return the OSGi filter
1:f13c6ac:      */
1:d46274e:     private static String createOsgiFilter(ServiceReferenceMetadata metadata, String extendedFilter) {
1:f13c6ac:         List<String> members = new ArrayList<String>();
1:f13c6ac:         // Handle filter
1:f13c6ac:         String flt = metadata.getFilter();
1:f13c6ac:         if (flt != null && flt.length() > 0) {
1:f13c6ac:             if (!flt.startsWith("(")) {
1:f13c6ac:                 flt = "(" + flt + ")";
1:f13c6ac:             }
1:f13c6ac:             members.add(flt);
1:f13c6ac:         }
1:d46274e:         // Handle extended filter
1:d46274e:         if (extendedFilter != null && extendedFilter.length() > 0) {
1:d46274e:             if (!extendedFilter.startsWith("(")) {
1:d46274e:                 extendedFilter = "(" + extendedFilter + ")";
1:d46274e:             }
1:d46274e:             members.add(extendedFilter);
1:d46274e:         }
1:f13c6ac:         // Handle interfaces
1:f13c6ac:         String interfaceName = metadata.getInterface();
1:2a55096:         Class runtimeClass = getRuntimeClass(metadata);
1:2a55096:         if (runtimeClass != null) {
1:2a55096:             interfaceName = runtimeClass.getName();
1:774ce31:         }
1:f13c6ac:         if (interfaceName != null && interfaceName.length() > 0) {
1:ae7707a:             if (metadata instanceof ExtendedReferenceMetadata) {
1:ae7707a:                 ExtendedReferenceMetadata erm = (ExtendedReferenceMetadata)metadata;
1:ae7707a:                 if (!erm.getExtraInterfaces().isEmpty()) {
1:ae7707a:                     StringBuilder sb = new StringBuilder("(&");
1:ae7707a:                     sb.append("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");
1:ae7707a:                     for (String s : erm.getExtraInterfaces()) {
1:ae7707a:                         sb.append("(" + Constants.OBJECTCLASS + "=" + s + ")");                        
1:f13c6ac:                     }
1:ae7707a:                     sb.append(")");
1:ae7707a:                     members.add(sb.toString());
2:9728962:                 } else {
1:f13c6ac:                     members.add("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");                    
1:f13c6ac:                 }
1:9728962:             } else {
2:ae7707a:                 members.add("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Handle component name
1:f13c6ac:         String componentName = metadata.getComponentName();
1:f13c6ac:         if (componentName != null && componentName.length() > 0) {
1:f13c6ac:             members.add("(" + BlueprintConstants.COMPONENT_NAME_PROPERTY + "=" + componentName + ")");
1:f13c6ac:         }
1:f13c6ac:         // Create filter
1:f13c6ac:         if (members.isEmpty()) {
1:f13c6ac:             throw new IllegalStateException("No constraints were specified on the service reference");
1:f13c6ac:         }
1:f13c6ac:         if (members.size() == 1) {
1:f13c6ac:             return members.get(0);
1:f13c6ac:         }
1:f13c6ac:         StringBuilder sb = new StringBuilder("(&");
1:f13c6ac:         for (String member : members) {
1:f13c6ac:             sb.append(member);
1:f13c6ac:         }
1:f13c6ac:         sb.append(")");
1:f13c6ac:         return sb.toString();
1:f13c6ac:     }
1:f13c6ac: 
1:b5f484e:     private class Tracked extends AbstractTracked<ServiceReference, ServiceReference, ServiceEvent> {
1:b5f484e:         @Override
1:b5f484e:         ServiceReference customizerAdding(ServiceReference item, ServiceEvent related) {
1:b5f484e:             return item;
1:f13c6ac:         }
1:b5f484e:         @Override
1:b5f484e:         void customizerModified(ServiceReference item, ServiceEvent related, ServiceReference object) {
1:b5f484e:         }
1:b5f484e:         @Override
1:b5f484e:         void customizerRemoved(ServiceReference item, ServiceEvent related, ServiceReference object) {
1:b5f484e:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:e5c40e5
/////////////////////////////////////////////////////////////////////////
1:     private volatile SatisfactionListener satisfactionListener;
/////////////////////////////////////////////////////////////////////////
1:             SatisfactionListener listener = this.satisfactionListener;
1:             if (listener != null) {
1:                 listener.notifySatisfaction(this);
1:             }
commit:b5f484e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     private final Tracked tracked = new Tracked();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 synchronized (tracked) {
1:                     tracked.setInitial(references != null ? references : new ServiceReference[0]);
1:                 tracked.trackInitial();
1:                 satisfied.set(optional || !tracked.isEmpty());
1:                 retrack();
1:                 LOGGER.debug("Found initial references {} for OSGi service {}", getServiceReferences(), getOsgiFilter());
/////////////////////////////////////////////////////////////////////////
1:             tracked.close();
1:             try {
1:                 getBundleContextForServiceLookup().removeServiceListener(this);
1:             } catch (IllegalStateException e) {
1:                 // Ignore in case bundle context is already invalidated
1:             doStop();
1:             for (ServiceReference ref : getServiceReferences()) {
1:                 untrack(ref);
1:             }
1:             satisfied.set(false);
/////////////////////////////////////////////////////////////////////////
1:               serviceAdded(ref, event);
1:               serviceModified(ref, event);
1:               serviceRemoved(ref, event);
1:     private void serviceAdded(ServiceReference ref, ServiceEvent event) {
1:             tracked.track(ref, event);
1:             synchronized (tracked) {
1:                 satisfied = optional || !tracked.isEmpty();
1:             track(ref);
1:         }
1:     }
1: 
1:     private void serviceModified(ServiceReference ref, ServiceEvent event) {
1:         // ref must be in references and must be satisfied
1:         if (isStarted()) {
1:             tracked.track(ref, event);
1:             track(ref);
1:         }
1:     }
1: 
1:     private void serviceRemoved(ServiceReference ref, ServiceEvent event) {
1:         if (isStarted()) {
1:             LOGGER.debug("Untracking reference {} for OSGi service {}", ref, getOsgiFilter());
1:             tracked.untrack(ref, event);
1:             boolean satisfied;
1:             synchronized (tracked) {
1:                 satisfied = optional || !tracked.isEmpty();
1:             }
1:             setSatisfied(satisfied);
1:             untrack(ref);
/////////////////////////////////////////////////////////////////////////
1:     protected void updateListeners() {
1:         boolean empty;
1:         synchronized (tracked) {
1:             empty = tracked.isEmpty();
1:         }
1:         if (empty) {
/////////////////////////////////////////////////////////////////////////
1:         ServiceReference[] refs;
1:         synchronized (tracked) {
1:             refs = new ServiceReference[tracked.size()];
1:             tracked.copyKeys(refs);
1:         return Arrays.asList(refs);
1:         List<ServiceReference> references = getServiceReferences();
1:         int length = references.size();
1:         if (length == 0) { /* if no service is being tracked */
1:             return null;
1:         }
1:         int index = 0;
1:         if (length > 1) { /* if more than one service, select highest ranking */
1:             int maxRanking = Integer.MIN_VALUE;
1:             long minId = Long.MAX_VALUE;
1:             for (int i = 0; i < length; i++) {
1:                 Object property = references.get(i).getProperty(Constants.SERVICE_RANKING);
1:                 int ranking = (property instanceof Integer) ? (Integer) property : 0;
1:                 long id = (Long) references.get(i).getProperty(Constants.SERVICE_ID);
1:                 if ((ranking > maxRanking) || (ranking == maxRanking && id < minId)) {
1:                     index = i;
1:                     maxRanking = ranking;
1:                     minId = id;
1:         return references.get(index);
/////////////////////////////////////////////////////////////////////////
1:     private class Tracked extends AbstractTracked<ServiceReference, ServiceReference, ServiceEvent> {
1:         @Override
1:         ServiceReference customizerAdding(ServiceReference item, ServiceEvent related) {
1:             return item;
1:         @Override
1:         void customizerModified(ServiceReference item, ServiceEvent related, ServiceReference object) {
1:         }
1:         @Override
1:         void customizerRemoved(ServiceReference item, ServiceEvent related, ServiceReference object) {
1:         }
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.di.ExecutionContext;
1: import org.apache.aries.blueprint.di.ValueRecipe;
/////////////////////////////////////////////////////////////////////////
1:     protected final ValueRecipe filterRecipe;
/////////////////////////////////////////////////////////////////////////
1:                                              ValueRecipe filterRecipe,
1:         this.filterRecipe = filterRecipe;
1:         this.filter = createOsgiFilter(metadata, null);
/////////////////////////////////////////////////////////////////////////
1:         if (filterRecipe != null && blueprintContainer instanceof BlueprintContainerImpl) {
1:             BlueprintContainerImpl.State state = ((BlueprintContainerImpl) blueprintContainer).getState();
1:             switch (state) {
1:                 case InitialReferencesSatisfied:
1:                 case WaitForInitialReferences2:
1:                 case Create:
1:                 case Created:
1:                     return createOsgiFilter(metadata, getExtendedOsgiFilter());
1:             }
1:         }
1:     private String getExtendedOsgiFilter() {
1:         if (filterRecipe != null) {
1:             Object object;
1:             BlueprintRepository repository = ((BlueprintContainerImpl) blueprintContainer).getRepository();
1:             ExecutionContext oldContext = null;
1:             try {
1:                 oldContext = ExecutionContext.Holder.setContext(repository);
1:                 object = filterRecipe.create();
1:             } finally {
1:                 ExecutionContext.Holder.setContext(oldContext);
1:             }
1:             if (object != null) {
1:                 String flt = object.toString();
1:                 if (flt != null && flt.length() > 0) {
1:                     if (!flt.startsWith("(")) {
1:                         flt = "(" + flt + ")";
1:                     }
1:                     return flt;
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static String createOsgiFilter(ServiceReferenceMetadata metadata, String extendedFilter) {
/////////////////////////////////////////////////////////////////////////
1:         // Handle extended filter
1:         if (extendedFilter != null && extendedFilter.length() > 0) {
1:             if (!extendedFilter.startsWith("(")) {
1:                 extendedFilter = "(" + extendedFilter + ")";
1:             }
1:             members.add(extendedFilter);
1:         }
commit:3e11f4a
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     getBundleContextForServiceLookup().removeServiceListener(this);
0:                 } catch (IllegalStateException e) {
0:                     // Ignore in case bundle context is already invalidated
1:                 }
commit:b069aa4
/////////////////////////////////////////////////////////////////////////
0:     protected final Object monitor = new Object();
/////////////////////////////////////////////////////////////////////////
0:                 synchronized (monitor) {
/////////////////////////////////////////////////////////////////////////
0:             synchronized (monitor) {
/////////////////////////////////////////////////////////////////////////
0:             synchronized (monitor) {
/////////////////////////////////////////////////////////////////////////
0:             synchronized (monitor) {
/////////////////////////////////////////////////////////////////////////
0:             synchronized (monitor) {
/////////////////////////////////////////////////////////////////////////
0:         synchronized (monitor) {
0:         synchronized (monitor) {
commit:2c635b1
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.RejectedExecutionException;
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             blueprintContainer.getExecutors().submit(new Runnable() {
0:                 public void run() {
1:                     switch (eventType) {
1:                         case ServiceEvent.REGISTERED:
0:                             serviceAdded(ref);
1:                             break;
1:                         case ServiceEvent.MODIFIED:
0:                             serviceModified(ref);
1:                             break;
1:                         case ServiceEvent.UNREGISTERING:
0:                             serviceRemoved(ref);
1:                             break;
1:                     }
1:             });
0:         } catch (RejectedExecutionException e) {
0:             // The job has been rejected because the executor is shut down
0:             // so ignore the exception
1:         }
commit:f592a28
/////////////////////////////////////////////////////////////////////////
0:             if (references.contains(ref)) {
0:                 return;
1:             }
commit:8351107
/////////////////////////////////////////////////////////////////////////
0:     public void serviceChanged(final ServiceEvent event) {
0:         blueprintContainer.getExecutors().submit(new Runnable() {
0:             public void run() {
1:                 int eventType = event.getType();
1:                 ServiceReference ref = event.getServiceReference();
0:                 switch (eventType) {
0:                     case ServiceEvent.REGISTERED:
0:                         serviceAdded(ref);
0:                         break;
0:                     case ServiceEvent.MODIFIED:
0:                         serviceModified(ref);
0:                         break;
0:                     case ServiceEvent.UNREGISTERING:
0:                         serviceRemoved(ref);
0:                         break;
1:                 }
1:             }
0:         });
commit:d4b3ee0
/////////////////////////////////////////////////////////////////////////
1:             // Check class proxying
1:             boolean proxyClass = false;
1:             if (metadata instanceof ExtendedServiceReferenceMetadata) {
1:                 proxyClass = (((ExtendedServiceReferenceMetadata) metadata).getProxyMethod() & ExtendedServiceReferenceMetadata.PROXY_METHOD_CLASSES) != 0;
1:             }
1:             if (!proxyClass) {
1:                 for (Class cl : interfaces) {
1:                     if (!cl.isInterface()) {
1:                         throw new ComponentDefinitionException("A class " + cl.getName() + " was found in the interfaces list, but class proxying is not allowed by default. The ext:proxy-method='classes' attribute needs to be added to this service reference.");
1:                     }
1:                 }
1:             }
1:             //We don't use the #getBundleContextForServiceLookup() method here, the bundle requesting the proxy is the
commit:4dfd2d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
/////////////////////////////////////////////////////////////////////////
1:             return blueprintContainer.getProxyManager().createDelegatingProxy(blueprintContainer.getBundleContext().getBundle(), interfaces, dispatcher, null);
commit:8c4aa3a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 return AsmInterceptorWrapper.createProxyObject(classLoader, null, null, dispatcher, classes);
0:             } catch (UnableToProxyException e) {
0:                 throw new ComponentDefinitionException("Unable to create asm proxy", e);
1:             }
commit:071e3fe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.proxy.AsmInterceptorWrapper;
/////////////////////////////////////////////////////////////////////////
0:                 // Try load load a asm class (to make sure it's actually available
0:                 // then create the asm factory
0:                 getClass().getClassLoader().loadClass("org.objectweb.asm.ClassVisitor");
0:                 proxyFactory = new AsmProxyFactory();
/////////////////////////////////////////////////////////////////////////
0:     public static class AsmProxyFactory implements ProxyFactory {
0:             return AsmInterceptorWrapper.createProxyObject(classLoader, null, null, dispatcher, classes);
commit:774ce31
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
/////////////////////////////////////////////////////////////////////////
0:       Class typeClass = metadata instanceof ExtendedServiceReferenceMetadata
0:                                 ? ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() : null;
0:       if (typeName == null && typeClass == null) {
/////////////////////////////////////////////////////////////////////////
0:       if (typeClass != null) {
0:           interfaceClassLoader = typeClass.getClassLoader();
1:       } else {
1:         try {
0:           Bundle clientBundle = blueprintContainer.getBundleContext().getBundle();
0:           interfaceClassLoader = clientBundle.loadClass(typeName).getClassLoader();
0:         } catch (ClassNotFoundException cnfe) {
0:           throw new ComponentDefinitionException("Unable to load class " + typeName + " from recipe " + this, cnfe);
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     if (metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
0:                         cl.add(((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface());
0:                     } else if (metadata.getInterface() != null) {
/////////////////////////////////////////////////////////////////////////
0:     protected Object createProxy(final Callable<Object> dispatcher, Set<Class> interfaces) throws Exception {
0:             return getProxyFactory().createProxy(proxyClassLoader, toClassArray(interfaces), dispatcher);
/////////////////////////////////////////////////////////////////////////
0:                 Set<Class> interfaces = new HashSet<Class>();
0:                 if (metadata.getInterface() != null) {
0:                     interfaces.add(loadClass(metadata.getInterface()));
1:                 }
0:                 if (metadata instanceof ExtendedReferenceListMetadata
0:                             && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
0:                         interfaces.add(((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface());
1:                     }
0:                 for (Class cl : interfaces) {
/////////////////////////////////////////////////////////////////////////
1:         if (metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
0:             interfaceName = ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface().getName();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         Set<Class> interfaces = new HashSet<Class>();
/////////////////////////////////////////////////////////////////////////
0:     private static Class[] toClassArray(Set<Class> classes) {
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
0: import java.lang.reflect.InvocationHandler;
1: import java.lang.reflect.Method;
0: import java.lang.reflect.Proxy;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.HashSet;
0: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
0: import java.util.Arrays;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
0: import net.sf.cglib.proxy.Dispatcher;
0: import net.sf.cglib.proxy.Enhancer;
0: import org.apache.geronimo.blueprint.BlueprintConstants;
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.ExtendedServiceReferenceMetadata;
0: import org.apache.geronimo.blueprint.di.AbstractRecipe;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
0: import org.apache.geronimo.blueprint.utils.BundleDelegatingClassLoader;
0: import org.apache.geronimo.blueprint.utils.ReflectionUtils;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceEvent;
1: import org.osgi.framework.ServiceListener;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Abstract class for service reference recipes.
1:  *
1:  * TODO: if we have a single interface (which is the standard behavior), then we should be able to get rid of
1:  *       the proxyClassloader and just use this interface classloader to define the proxy
1:  *
1:  * TODO: it is allowed to have no interface defined at all, which should result in an empty proxy
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public abstract class AbstractServiceReferenceRecipe extends AbstractRecipe implements ServiceListener, SatisfiableRecipe {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractServiceReferenceRecipe.class);
1: 
1:     protected final ExtendedBlueprintContainer blueprintContainer;
1:     protected final ServiceReferenceMetadata metadata;
1:     protected final CollectionRecipe listenersRecipe;
1:     protected final List<Recipe> explicitDependencies;
0:     protected final ClassLoader proxyClassLoader;
1:     protected final boolean optional;
1:     /** The OSGi filter for tracking references */
1:     protected final String filter;
1:     /** The list of listeners for this reference.  This list will be lazy created */
1:     protected List<Listener> listeners;
1: 
0:     private final List<ServiceReference> references = new ArrayList<ServiceReference>();
1:     private final AtomicBoolean started = new AtomicBoolean();
1:     private final AtomicBoolean satisfied = new AtomicBoolean();
0:     private SatisfactionListener satisfactionListener;
0:     private volatile ProxyFactory proxyFactory;
1: 
1:     protected AbstractServiceReferenceRecipe(String name,
1:                                              ExtendedBlueprintContainer blueprintContainer,
1:                                              ServiceReferenceMetadata metadata,
1:                                              CollectionRecipe listenersRecipe,
1:                                              List<Recipe> explicitDependencies) {
1:         super(name);
1:         this.prototype = false;
1:         this.blueprintContainer = blueprintContainer;
1:         this.metadata = metadata;
1:         this.listenersRecipe = listenersRecipe;
1:         this.explicitDependencies = explicitDependencies;
0:         // Create a ClassLoader delegating to the bundle, but also being able to see our bundle classes
0:         // so that the created proxy can access cglib classes.
0:         // TODO: use a doPrivileged block
0:         // TODO: we should be able to get rid of this classloader when using JDK 1.4 proxies with a single interface
0:         //         (the case defined by the spec) and use the interface classloader instead
0:         this.proxyClassLoader = new BundleDelegatingClassLoader(blueprintContainer.getBundleContext().getBundle(),
0:                                                                 getClass().getClassLoader());
1: 
1:         this.optional = (metadata.getAvailability() == ReferenceMetadata.AVAILABILITY_OPTIONAL);
0:         this.filter = createOsgiFilter(metadata);
1:     }
1: 
1:     public CollectionRecipe getListenersRecipe() {
1:         return listenersRecipe;
1:     }
1: 
1:     public void start(SatisfactionListener listener) {
1:         if (listener == null) throw new NullPointerException("satisfactionListener is null");
1:         if (started.compareAndSet(false, true)) {
1:             try {
1:                 satisfactionListener = listener;
1:                 satisfied.set(optional);
1:                 // Synchronized block on references so that service events won't interfere with initial references tracking
1:                 // though this may not be sufficient because we don't control ordering of those events
0:                 synchronized (references) {
0:                     blueprintContainer.getBundleContext().addServiceListener(this, getOsgiFilter());
0:                     ServiceReference[] references = blueprintContainer.getBundleContext().getServiceReferences(null, getOsgiFilter());
0:                     if (references != null) {
0:                         for (ServiceReference reference : references) {
0:                             this.references.add(reference);
0:                             track(reference);                           
1:                         }
0:                         satisfied.set(optional || !this.references.isEmpty());
1:                     }
0:                     LOGGER.debug("Found initial references {} for OSGi service {}", references, getOsgiFilter());
1:                 }
1:             } catch (InvalidSyntaxException e) {
1:                 throw new ComponentDefinitionException(e);
1:             }
1:         }
1:     }
1: 
1:     public void stop() {
1:         if (started.compareAndSet(true, false)) {
0:             synchronized (references) {
0:                 blueprintContainer.getBundleContext().removeServiceListener(this);
0:                 doStop();
0:                 for (Iterator<ServiceReference> it = references.iterator(); it.hasNext();) {
0:                     ServiceReference ref = it.next();
0:                     it.remove();
0:                     untrack(ref);
1:                 }
0:                 satisfied.set(false);
1:             }
1:         }
1:     }
1: 
1:     protected void doStop() {
1:     }
1: 
1:     protected boolean isStarted() {
1:         return started.get();
1:     }
1: 
1:     public boolean isSatisfied() {
1:         return satisfied.get();
1:     }
1: 
1:     @Override
1:     public List<Recipe> getConstructorDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         if (explicitDependencies != null) {
1:             recipes.addAll(explicitDependencies);
1:         }
1:         return recipes;
1:     }
1:     
1:     public List<Recipe> getDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         if (listenersRecipe != null) {
1:             recipes.add(listenersRecipe);
1:         }
1:         recipes.addAll(getConstructorDependencies());
1:         return recipes;
1:     }
1: 
1:     public String getOsgiFilter() {
1:         return filter;
1:     }
1: 
1:     protected void createListeners() {
1:         try {
1:             if (listenersRecipe != null) {
0:                 List<Listener> listeners = (List<Listener>) listenersRecipe.create();
1:                 for (Listener listener : listeners) {
0:                     List<Class> cl = new ArrayList<Class>();
0:                     if (metadata.getInterface() != null) {
0:                         cl.addAll(loadAllClasses(Collections.singletonList(metadata.getInterface())));
1:                     } else {
0:                         cl.add(Object.class);
1:                     }
0:                     listener.init(cl);
1:                 }
1:                 this.listeners = listeners;
1:             } else {
1:                 this.listeners = Collections.emptyList();
1:             }
1:         } catch (ClassNotFoundException e) {
1:             throw new ComponentDefinitionException(e);
1:         }
1:     }
1: 
0:     protected List<Class> loadAllClasses(Iterable<String> interfaceNames) throws ClassNotFoundException {
0:         List<Class> classes = new ArrayList<Class>();
1:         for (String name : interfaceNames) {
0:             Class clazz = loadClass(name);
1:             classes.add(clazz);
1:         }
1:         return classes;
1:     }
1: 
1:     protected ReifiedType loadType(String typeName, ClassLoader fromClassLoader) {
1:         if (typeName == null) {
1:             return null;
1:         }
1:         try {
1:             // this method is overriden to use the blueprint container directly
1:             // because proxies can be created outside of the recipe creation which
1:             // would lead to an exception because the context is not set
1:             // TODO: consider having the context as a property on the recipe rather than a thread local
1:             return GenericType.parse(typeName, fromClassLoader != null ? fromClassLoader : blueprintContainer);
1:         } catch (ClassNotFoundException e) {
1:             throw new ComponentDefinitionException("Unable to load class " + typeName + " from recipe " + this, e);
1:         }
1:     }
1: 
1: 
0:     protected Object createProxy(final Callable<Object> dispatcher, Iterable<String> interfaces) throws Exception {
1:         if (!interfaces.iterator().hasNext()) {
1:             return new Object();
1:         } else {
0:             return getProxyFactory().createProxy(proxyClassLoader, toClassArray(loadAllClasses(interfaces)), dispatcher);
1:         }
1:     }
1: 
0:     protected synchronized ProxyFactory getProxyFactory() throws ClassNotFoundException {
0:         if (proxyFactory == null) {
0:             boolean proxyClass = false;
0:             if (metadata instanceof ExtendedServiceReferenceMetadata) {
0:                 proxyClass = (((ExtendedServiceReferenceMetadata) metadata).getProxyMethod() & ExtendedServiceReferenceMetadata.PROXY_METHOD_CLASSES) != 0;
1:             }
0:             List<Class> classes = loadAllClasses(Collections.singletonList(this.metadata.getInterface()));
0:             if (!proxyClass) {
0:                 for (Class cl : classes) {
0:                     if (!cl.isInterface()) {
0:                         throw new ComponentDefinitionException("A class " + cl.getName() + " was found in the interfaces list, but class proxying is not allowed by default. The ext:proxy-method='class' attribute needs to be added to this service reference.");
1:                     }
1:                 }
1:             }
1:             try {
0:                 // Try load load a cglib class (to make sure it's actually available
0:                 // then create the cglib factory
0:                 getClass().getClassLoader().loadClass("net.sf.cglib.proxy.Enhancer");
0:                 proxyFactory = new CgLibProxyFactory();
0:             } catch (Throwable t) {
0:                 if (proxyClass) {
0:                     throw new ComponentDefinitionException("Class proxying has been enabled but cglib can not be used", t);
1:                 }
0:                 proxyFactory = new JdkProxyFactory();
1:             }
1:         }
0:         return proxyFactory;
1:     }
1: 
1:     public void serviceChanged(ServiceEvent event) {
0:         int eventType = event.getType();
0:         ServiceReference ref = event.getServiceReference();
0:         switch (eventType) {
0:             case ServiceEvent.REGISTERED:
0:                 serviceAdded(ref);
0:                 break;
0:             case ServiceEvent.MODIFIED:
0:                 serviceModified(ref);
0:                 break;
0:             case ServiceEvent.UNREGISTERING:
0:                 serviceRemoved(ref);
0:                 break;
1:         }
1:     }
1: 
0:     private void serviceAdded(ServiceReference ref) {
1:         LOGGER.debug("Tracking reference {} for OSGi service {}", ref, getOsgiFilter());
0:         synchronized (references) {
0:             references.add(ref);
1:         }
0:         track(ref);
0:         setSatisfied(true);
1:     }
1: 
0:     private void serviceModified(ServiceReference ref) {
0:         // ref must be in references and must be satisfied
0:         track(ref);
1:     }
1: 
0:     private void serviceRemoved(ServiceReference ref) {
0:         LOGGER.debug("Untracking reference {} for OSGi service {}", ref, getOsgiFilter());
0:         boolean removed;
1:         boolean satisfied;
0:         synchronized (references) {
0:             removed = references.remove(ref);
0:             satisfied = optional || !references.isEmpty();
1:         }
0:         if (removed) {
0:             untrack(ref);
1:         }
1:         setSatisfied(satisfied);
1:     }
1: 
1:     protected void setSatisfied(boolean s) {
1:         // This check will ensure an atomic comparision and set
1:         // so that it will only be true if the value actually changed
1:         if (satisfied.getAndSet(s) != s) {
1:             LOGGER.debug("Service reference with filter {} satisfied {}", getOsgiFilter(), this.satisfied);
0:             this.satisfactionListener.notifySatisfaction(this);
1:         }
1:     }
1: 
1:     protected abstract void track(ServiceReference reference);
1: 
1:     protected abstract void untrack(ServiceReference reference);
1: 
1:     protected abstract void retrack();
1: 
0:     protected void updateListeners() {  
0:         if (references.isEmpty()) {
1:             unbind(null, null);
1:         } else {
1:             retrack();
1:         }
1:     }
1:     
1:     protected void bind(ServiceReference reference, Object service) {
1:         if (listeners != null) {    
1:             for (Listener listener : listeners) {
1:                 if (listener != null) {
1:                     listener.bind(reference, service);
1:                 }
1:             } 
1:         }
1:     }
1:     
1:     protected void unbind(ServiceReference reference, Object service) {
1:         if (listeners != null) {    
1:             for (Listener listener : listeners) {
1:                 if (listener != null) {
1:                     listener.unbind(reference, service);
1:                 }
1:             } 
1:         }
1:     }
1:     
1:     public List<ServiceReference> getServiceReferences() {
0:         synchronized (references) {
0:             return new ArrayList<ServiceReference>(references);
1:         }
1:     }
1: 
1:     public ServiceReference getBestServiceReference() {
0:         synchronized (references) {
0:             int length = references.size();
0:             if (length == 0) { /* if no service is being tracked */
1:                 return null;
1:             }
0:             int index = 0;
0:             if (length > 1) { /* if more than one service, select highest ranking */
0:                 int maxRanking = Integer.MIN_VALUE;
0:                 long minId = Long.MAX_VALUE;
0:                 for (int i = 0; i < length; i++) {
0:                     Object property = references.get(i).getProperty(Constants.SERVICE_RANKING);
0:                     int ranking = (property instanceof Integer) ? (Integer) property : 0;
0:                     long id = (Long) references.get(i).getProperty(Constants.SERVICE_ID);
0:                     if ((ranking > maxRanking) || (ranking == maxRanking && id < minId)) {
0:                         index = i;
0:                         maxRanking = ranking;
0:                         minId = id;
1:                     }
1:                 }
1:             }
0:             return references.get(index);
1:         }
1:     }
1: 
1:     public static class Listener {
1: 
1:         private static final Logger LOGGER = LoggerFactory.getLogger(Listener.class);
1: 
1:         private Object listener;
1:         private ReferenceListener metadata;
1:         private ExtendedBlueprintContainer blueprintContainer;
1: 
1:         private Set<Method> bindMethodsReference = new HashSet<Method>();
1:         private Set<Method> bindMethodsObjectProp = new HashSet<Method>();
1:         private Set<Method> bindMethodsObject = new HashSet<Method>();
1:         private Set<Method> unbindMethodsReference = new HashSet<Method>();
1:         private Set<Method> unbindMethodsObject = new HashSet<Method>();
1:         private Set<Method> unbindMethodsObjectProp = new HashSet<Method>();
1: 
1:         public void setListener(Object listener) {
1:             this.listener = listener;
1:         }
1: 
1:         public void setMetadata(ReferenceListener metadata) {
1:             this.metadata = metadata;
1:         }
1: 
1:         public void setBlueprintContainer(ExtendedBlueprintContainer blueprintContainer) {
1:             this.blueprintContainer = blueprintContainer;
1:         }
1:         
1:         public void init(Collection<Class> classes) {
1:             Set<Class> clazzes = new HashSet<Class>(classes);
1:             clazzes.add(Object.class);
1:             Class listenerClass = listener.getClass();
1:             String bindName = metadata.getBindMethod();
1:             if (bindName != null) {
1:                 bindMethodsReference.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, bindName, new Class[] { ServiceReference.class }));
1:                 for (Class clazz : clazzes) {
1:                     bindMethodsObject.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, bindName, new Class[] { clazz }));
1:                     bindMethodsObjectProp.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, bindName, new Class[] { clazz, Map.class }));
1:                 }
1:                 if (bindMethodsReference.size() + bindMethodsObject.size() + bindMethodsObjectProp.size() == 0) {
1:                     throw new ComponentDefinitionException("No matching methods found for listener bind method: " + bindName);
1:                 }
1:             }
1:             String unbindName = metadata.getUnbindMethod();
1:             if (unbindName != null) {
1:                 unbindMethodsReference.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, unbindName, new Class[] { ServiceReference.class }));
1:                 for (Class clazz : clazzes) {
1:                     unbindMethodsObject.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, unbindName, new Class[] { clazz }));
1:                     unbindMethodsObjectProp.addAll(ReflectionUtils.findCompatibleMethods(listenerClass, unbindName, new Class[] { clazz, Map.class }));
1:                 }
1:                 if (unbindMethodsReference.size() + unbindMethodsObject.size() + unbindMethodsObjectProp.size() == 0) {
1:                     throw new ComponentDefinitionException("No matching methods found for listener unbind method: " + unbindName);
1:                 }
1:             }
1:         }
1: 
1:         public void bind(ServiceReference reference, Object service) {
1:             invokeMethods(bindMethodsReference, bindMethodsObject, bindMethodsObjectProp, reference, service);
1:         }
1: 
1:         public void unbind(ServiceReference reference, Object service) {
1:             invokeMethods(unbindMethodsReference, unbindMethodsObject, unbindMethodsObjectProp, reference, service);
1:         }
1: 
1:         private void invokeMethods(Set<Method> referenceMethods, Set<Method> objectMethods, Set<Method> objectPropMethods, ServiceReference reference, Object service) {
1:             for (Method method : referenceMethods) {
1:                 try {
1:                     ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), 
1:                                            method, listener, reference);
1:                 } catch (Exception e) {
1:                     LOGGER.error("Error calling listener method " + method, e);
1:                 }
1:             }
1:             for (Method method : objectMethods) {
1:                 try {
1:                     ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), 
1:                                            method, listener, service);
1:                 } catch (Exception e) {
1:                     LOGGER.error("Error calling listener method " + method, e);
1:                 }
1:             }
1:             Map<String, Object> props = null;
1:             for (Method method : objectPropMethods) {
1:                 if (props == null) {
1:                     props = new HashMap<String, Object>();
1:                     if (reference != null) {
1:                         for (String name : reference.getPropertyKeys()) {
1:                             props.put(name, reference.getProperty(name));
1:                         }
1:                     }
1:                 }
1:                 try {
1:                     ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), 
1:                                            method, listener, service, props);
1:                 } catch (Exception e) {
1:                     LOGGER.error("Error calling listener method " + method, e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Create the OSGi filter corresponding to the ServiceReferenceMetadata constraints
1:      *
1:      * @param metadata the service reference metadata
1:      * @return the OSGi filter
1:      */
0:     private static String createOsgiFilter(ServiceReferenceMetadata metadata) {
1:         List<String> members = new ArrayList<String>();
1:         // Handle filter
1:         String flt = metadata.getFilter();
1:         if (flt != null && flt.length() > 0) {
1:             if (!flt.startsWith("(")) {
1:                 flt = "(" + flt + ")";
1:             }
1:             members.add(flt);
1:         }
1:         // Handle interfaces
1:         String interfaceName = metadata.getInterface();
1:         if (interfaceName != null && interfaceName.length() > 0) {
1:             members.add("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");
1:         }
1:         // Handle component name
1:         String componentName = metadata.getComponentName();
1:         if (componentName != null && componentName.length() > 0) {
1:             members.add("(" + BlueprintConstants.COMPONENT_NAME_PROPERTY + "=" + componentName + ")");
1:         }
1:         // Create filter
1:         if (members.isEmpty()) {
1:             throw new IllegalStateException("No constraints were specified on the service reference");
1:         }
1:         if (members.size() == 1) {
1:             return members.get(0);
1:         }
1:         StringBuilder sb = new StringBuilder("(&");
1:         for (String member : members) {
1:             sb.append(member);
1:         }
1:         sb.append(")");
1:         return sb.toString();
1:     }
1: 
0:     private static Class[] getInterfaces(Class[] classes) {
0:         List<Class> interfaces = new ArrayList<Class>();
0:         for (Class clazz : classes) {
0:             if (clazz.isInterface()) {
0:                 interfaces.add(clazz);
1:             }
1:         }
0:         return toClassArray(interfaces);
1:     }
1: 
0:     private static Class[] toClassArray(List<Class> classes) {
0:         return classes.toArray(new Class [classes.size()]);
1:     }
1: 
0:     public static interface ProxyFactory {
1: 
0:         public Object createProxy(ClassLoader classLoader, Class[] classes, Callable<Object> dispatcher);
1: 
1:     }
1: 
0:     public static class JdkProxyFactory implements ProxyFactory {
1: 
0:         public Object createProxy(final ClassLoader classLoader, final Class[] classes, final Callable<Object> dispatcher) {
0:             return Proxy.newProxyInstance(classLoader, getInterfaces(classes), new InvocationHandler() {
0:                 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
0:                     return method.invoke(dispatcher.call(), args);
1:                 }
0:             });
1:         }
1: 
1:     }
1: 
0:     public static class CgLibProxyFactory implements ProxyFactory {
1: 
0:         public Object createProxy(final ClassLoader classLoader, final Class[] classes, final Callable<Object> dispatcher) {
0:             Enhancer e = new Enhancer();
0:             e.setClassLoader(classLoader);
0:             e.setSuperclass(getTargetClass(classes));
0:             e.setInterfaces(getInterfaces(classes));
0:             e.setInterceptDuringConstruction(false);
0:             e.setCallback(new Dispatcher() {
0:                 public Object loadObject() throws Exception {
0:                     return dispatcher.call();
1:                 }
0:             });
0:             e.setUseFactory(false);
0:             return e.create();
1:         }
1: 
0:         protected Class getTargetClass(Class[] interfaceNames) {
0:             // Only allow class proxying if specifically asked to
0:             Class root = Object.class;
0:             for (Class clazz : interfaceNames) {
0:                 if (!clazz.isInterface()) {
0:                     if (root == Object.class) {
0:                         root = clazz;
0:                         continue;
1:                     }
0:                     // Check that all classes are in the same hierarchy
0:                     for (Class p = clazz; p != Object.class; p = p.getSuperclass()) {
0:                         if (p == root) {
0:                             root = clazz;
0:                             continue;
1:                         }
1:                     }
0:                     for (Class p = root; p != Object.class; p = p.getSuperclass()) {
0:                         if (p == clazz) {
0:                             continue;
1:                         }
1:                     }
0:                     throw new ComponentDefinitionException("Classes " + root.getClass().getName() + " and " + clazz.getName() + " are not in the same hierarchy");
1:                 }
1:             }
0:             return root;
1:         }
1: 
1:     }
1: 
1: }
author:Christian Schneider
-------------------------------------------------------------------------------
commit:9728962
/////////////////////////////////////////////////////////////////////////
1: @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
1:         accessControlContext = (System.getSecurityManager() != null) ? createAccessControlContext() : null;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
1:     protected Object getServiceSecurely(final ServiceReference serviceReference) {
1:         if (accessControlContext == null) {
1:             return getBundleContextForServiceLookup().getService(serviceReference);
1:         } else {
1:             // If we're operating with security, use the privileges of the bundle
1:             // we're managing to do the lookup
1:             return AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:                 public Object run() {
1:                     return getBundleContextForServiceLookup().getService(serviceReference);
1:             }, accessControlContext);
0:         }
0:     }
0: 
1:     /**
1:      * We may need to execute code within a doPrivileged block, and if so, it should be the privileges of the
1:      * bundle with the blueprint file that get used, not the privileges of blueprint-core. To achieve this we
1:      * use an access context.
1:      * 
1:      * @return
1:      */
1:     private AccessControlContext createAccessControlContext() {
1:         return new AccessControlContext(AccessController.getContext(), new DomainCombiner() {
1:             public ProtectionDomain[] combine(ProtectionDomain[] arg0, ProtectionDomain[] arg1) {
1:                 ProtectionDomain protectionDomain = new ProtectionDomain(null, null) {
1:                     public boolean implies(Permission permission) {
1:                         return getBundleContextForServiceLookup().getBundle().hasPermission(permission);
0:                     }
1:                 };
1:                 return new ProtectionDomain[] {
1:                     protectionDomain
1:                 };
0:             }
1:     @SuppressWarnings("unchecked")
0:         if (listenersRecipe != null) {
1:             List<Listener> listeners = (List<Listener>)listenersRecipe.create();
0:             for (Listener listener : listeners) {
1:                 List<Class> classList = new ArrayList<Class>();
1:                 Class clz = getInterfaceClass();
1:                 if (clz != null) {
1:                     classList.add(clz);
1:                 } else {
1:                     classList.add(Object.class);
1:                 listener.init(classList);
0:             this.listeners = listeners;
1:         } else {
0:             this.listeners = Collections.emptyList();
0:         }
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:b49a314
/////////////////////////////////////////////////////////////////////////
1:                     ServiceReference[] references = getBundleContextForServiceLookup().getServiceReferences((String) null, getOsgiFilter());
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:ae7707a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ExtendedReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:             if (metadata instanceof ExtendedReferenceMetadata) {
1:                 ExtendedReferenceMetadata erm = (ExtendedReferenceMetadata)metadata;
1:                 if (!erm.getExtraInterfaces().isEmpty()) {
1:                     StringBuilder sb = new StringBuilder("(&");
1:                     sb.append("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");
1:                     for (String s : erm.getExtraInterfaces()) {
1:                         sb.append("(" + Constants.OBJECTCLASS + "=" + s + ")");                        
0:                     }
1:                     sb.append(")");
1:                     members.add(sb.toString());
0:                 } else {
1:                     members.add("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");                    
0:                 }
0:             } else {
1:                 members.add("(" + Constants.OBJECTCLASS + "=" + interfaceName + ")");
0:             }
commit:27e02c9
/////////////////////////////////////////////////////////////////////////
1:     private final AccessControlContext accessControlContext;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     static boolean waited = false;
/////////////////////////////////////////////////////////////////////////
1:             satisfactionListener = null;
/////////////////////////////////////////////////////////////////////////
0:         final int eventType = event.getType();
0:         final ServiceReference ref = event.getServiceReference();
/////////////////////////////////////////////////////////////////////////
1:         if (isStarted()) {
0:             synchronized (references) {
0:                 if (references.contains(ref)) {
0:                     return;
0:                 }
0:                 references.add(ref);
0:             track(ref);
0:             setSatisfied(true);
1:         if (isStarted()) {
0:             synchronized (references) {
0:                 if (references.contains(ref)) {
0:                     track(ref);
0:                 }
0:             }
0:         }
1:         if (isStarted()) {
0:             LOGGER.debug("Untracking reference {} for OSGi service {}", ref, getOsgiFilter());
0:             boolean removed;
0:             boolean satisfied;
0:             synchronized (references) {
0:                 removed = references.remove(ref);
0:                 satisfied = optional || !references.isEmpty();
0:             }
0:             if (removed) {
0:                 untrack(ref);
0:             }
0:             setSatisfied(satisfied);
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:491e803
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void serviceChanged(ServiceEvent event) {
0:       int eventType = event.getType();
0:       ServiceReference ref = event.getServiceReference();
0:       switch (eventType) {
0:           case ServiceEvent.REGISTERED:
0:               serviceAdded(ref);
0:               break;
0:           case ServiceEvent.MODIFIED:
0:               serviceModified(ref);
0:               break;
0:           case ServiceEvent.UNREGISTERING:
0:               serviceRemoved(ref);
0:               break;
0:       }
0:     }  
0: 
author:Holly Cummins
-------------------------------------------------------------------------------
commit:e3bd874
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessControlContext;
1: import java.security.AccessController;
1: import java.security.DomainCombiner;
1: import java.security.Permission;
1: import java.security.PrivilegedAction;
1: import java.security.ProtectionDomain;
/////////////////////////////////////////////////////////////////////////
0: 	private final AccessControlContext accessControlContext;
0: 
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (System.getSecurityManager() != null) {
0:             accessControlContext = createAccessControlContext();
0:         } else
0:         {
0:         	accessControlContext = null;
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 	protected Object getServiceSecurely(final ServiceReference serviceReference) {
0: 		if (accessControlContext == null) {
0: 			return getBundleContextForServiceLookup().getService(
0: 					serviceReference);
0: 
0: 		} else {
0: 			// If we're operating with security, use the privileges of the bundle
0: 			// we're managing to do the lookup
0: 			return AccessController.doPrivileged(
0: 					new PrivilegedAction<Object>() {
0: 						public Object run() {
0: 							return getBundleContextForServiceLookup()
0: 									.getService(serviceReference);
0: 						}
0: 					}, accessControlContext);
0: 		}
0: 	}
0:     
0: 
0: 	/**
0: 	 * We may need to execute code within a doPrivileged block, and if so, it should be the 
0: 	 * privileges of the bundle with the blueprint file that get used, not the privileges 
0: 	 * of blueprint-core. To achieve this we use an access context. 
0: 	 * @return
0: 	 */
0:     private AccessControlContext createAccessControlContext() {
0:         return new AccessControlContext(AccessController.getContext(),
0:                 new DomainCombiner() {               
0:                     public ProtectionDomain[] combine(ProtectionDomain[] arg0,
0:                                                       ProtectionDomain[] arg1) {                    
0:                         return new ProtectionDomain[] { new ProtectionDomain(null, null) {                        
0:                             public boolean implies(Permission permission) {                                                           
0:                                 return getBundleContextForServiceLookup().getBundle().hasPermission(permission);
0:                             }
0:                         } 
0:                     };
0:                 }
0:         });
0:     }
0: 
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:d4c2b25
/////////////////////////////////////////////////////////////////////////
commit:b13e703
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
1:                     getBundleContextForServiceLookup().addServiceListener(this, getOsgiFilter());
0:                     ServiceReference[] references = getBundleContextForServiceLookup().getServiceReferences(null, getOsgiFilter());
/////////////////////////////////////////////////////////////////////////
0:                 getBundleContextForServiceLookup().removeServiceListener(this);
/////////////////////////////////////////////////////////////////////////
0:             //We don't use the #getBundleContextForServiceLookup() method here, the bundle requesting the proxy is the 
1:             //blueprint client, not the context of the lookup
/////////////////////////////////////////////////////////////////////////
1:     protected BundleContext getBundleContextForServiceLookup() {
0:         if (metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
1:             BundleContext context = ((ExtendedServiceReferenceMetadata) metadata).getBundleContext();
1:             if(context != null) {
1:               return context;
0:             }
0:         }
0:          
1:         return blueprintContainer.getBundleContext();
0:     }
0:     
commit:69e59b8
/////////////////////////////////////////////////////////////////////////
0:             return BlueprintExtender.getProxyManager().createDelegatingProxy(blueprintContainer.getBundleContext().getBundle(), interfaces, dispatcher, null);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:de42ee7
/////////////////////////////////////////////////////////////////////////
0:         protected Class<?> getTargetClass(Class<?>[] interfaceNames) {
0:             Class<?> root = Object.class;
0:             for (Class<?> clazz : interfaceNames) {
0:                     if (root.isAssignableFrom(clazz)) {
0:                     } else if (clazz.isAssignableFrom(root)) {
0:                         //nothing to do, root is correct
0:                     } else {
0:                         throw new ComponentDefinitionException("Classes " + root.getClass().getName() + " and " + clazz.getName() + " are not in the same hierarchy");
commit:322f2c3
/////////////////////////////////////////////////////////////////////////
0:           return new DualClassloader(interfaceClassLoader);
0: 
0:     private static class DualClassloader extends ClassLoader {
0:       DualClassloader(ClassLoader parent) {
0:         super(parent);
0:       }
0:       
0:       @Override
0:       protected Class<?> findClass(String name) throws ClassNotFoundException {
0:         return getClass().getClassLoader().loadClass(name);
0:       }
0: 
0:       @Override
0:       protected URL findResource(String name) {
0:         return getClass().getClassLoader().getResource(name);
0:       }
0:     }
commit:96a82ee
/////////////////////////////////////////////////////////////////////////
0: import java.net.URL;
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0: 
1: import org.apache.aries.blueprint.di.Recipe;
0: import org.osgi.framework.Bundle;
0: import org.osgi.service.blueprint.container.ReifiedType;
/////////////////////////////////////////////////////////////////////////
0:         
0:         
0:         this.proxyClassLoader = makeProxyClassLoader(blueprintContainer, metadata);
0: 
0: 
0:     // Create a ClassLoader delegating to the bundle, but also being able to see our bundle classes
0:     // so that the created proxy can access cglib classes.
0:     // TODO: we should be able to get rid of this classloader when using JDK 1.4 proxies with a single interface
0:     //         (the case defined by the spec) and use the interface classloader instead
0:     private ClassLoader makeProxyClassLoader(
0:         final ExtendedBlueprintContainer blueprintContainer,
0:         ServiceReferenceMetadata metadata) {
0:       
0:       String typeName = metadata.getInterface();
0:       
0:       if (typeName == null) {
0:         return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
0:           public ClassLoader run() {
0:             return new BundleDelegatingClassLoader(blueprintContainer.getBundleContext().getBundle(),
0:                 AbstractServiceReferenceRecipe.class.getClassLoader());
0:           }      
0:         });
0:       }
0:       
0:       final ClassLoader interfaceClassLoader;
0:       try {
0:         Bundle clientBundle = blueprintContainer.getBundleContext().getBundle();
0:         interfaceClassLoader = clientBundle.loadClass(typeName).getClassLoader();
0:       } catch (ClassNotFoundException cnfe) {
0:         throw new ComponentDefinitionException("Unable to load class " + typeName + " from recipe " + this, cnfe);
0:       }
0:       
0:       final ClassLoader blueprintClassLoader = AbstractServiceReferenceRecipe.class.getClassLoader();
0:       class DualClassloader extends ClassLoader {
0:         DualClassloader() {
0:           super(interfaceClassLoader);
0:         }
0:         
0:         @Override
0:         protected Class<?> findClass(String name) throws ClassNotFoundException {
0:           return blueprintClassLoader.loadClass(name);
0:         }
0: 
0:         @Override
0:         protected URL findResource(String name) {
0:           return blueprintClassLoader.getResource(name);
0:         }
0:       }
0:       
0:       return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
0:         public ClassLoader run() {
0:           return new DualClassloader();
0:         }      
0:       });
0:     }
0:     
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:24455ce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected List<Class<?>> loadAllClasses(Iterable<String> interfaceNames) {
1:         List<Class<?>> classes = new ArrayList<Class<?>>();
1:             Class<?> clazz = loadClass(name);
/////////////////////////////////////////////////////////////////////////
1:     protected Object createProxy(final Callable<Object> dispatcher, Set<Class<?>> interfaces) throws Exception {
0:             return BlueprintExtender.getProxyManager().createProxy(blueprintContainer.getBundleContext().getBundle(), interfaces, dispatcher);
/////////////////////////////////////////////////////////////////////////
commit:ad88189
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
0:                     try {
0:                         return method.invoke(dispatcher.call(), args);
0:                     } catch (InvocationTargetException ite) {
0:                       throw ite.getTargetException();
0:                     }
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:2a55096
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       Class typeClass = getInterfaceClass();
0:       if (typeClass == null) {
/////////////////////////////////////////////////////////////////////////
0:       final ClassLoader interfaceClassLoader = typeClass.getClassLoader();
/////////////////////////////////////////////////////////////////////////
0:                     List<Class> classList = new ArrayList<Class>();
0:                     Class clz = getInterfaceClass();
0:                     if (clz != null) { 
0:                         classList.add(clz);
0:                         classList.add(Object.class);
0:                     listener.init(classList);
0:     protected List<Class> loadAllClasses(Iterable<String> interfaceNames) {
/////////////////////////////////////////////////////////////////////////
0:                 Class clz = getInterfaceClass();
0:                 if (clz != null) interfaces.add(clz);
0:                 
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected Class getInterfaceClass() {
1:         Class clz = getRuntimeClass(metadata);
1:         if (clz != null)
1:             return clz;
1:         else if (metadata.getInterface() != null)
1:             return loadClass(metadata.getInterface());
1:         return null;
0:     }
0:     
1:     protected static Class getRuntimeClass(ServiceReferenceMetadata metadata) {
0:         if (metadata instanceof ExtendedServiceReferenceMetadata && ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface() != null) {
1:            return ((ExtendedServiceReferenceMetadata) metadata).getRuntimeInterface();
0:         } 
1:         return null;
0:     }
/////////////////////////////////////////////////////////////////////////
1:         Class runtimeClass = getRuntimeClass(metadata);
1:         if (runtimeClass != null) {
1:             interfaceName = runtimeClass.getName();
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.BlueprintConstants;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.ExtendedServiceReferenceMetadata;
1: import org.apache.aries.blueprint.di.AbstractRecipe;
0: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
0: import org.apache.aries.blueprint.utils.BundleDelegatingClassLoader;
1: import org.apache.aries.blueprint.utils.ReflectionUtils;
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:4af938f
/////////////////////////////////////////////////////////////////////////
0:                         throw new ComponentDefinitionException("A class " + cl.getName() + " was found in the interfaces list, but class proxying is not allowed by default. The ext:proxy-method='classes' attribute needs to be added to this service reference.");
============================================================================