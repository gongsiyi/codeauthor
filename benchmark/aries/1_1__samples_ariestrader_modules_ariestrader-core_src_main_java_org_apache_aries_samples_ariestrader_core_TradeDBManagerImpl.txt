1:628add4: /**
1:628add4:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:628add4:  *  contributor license agreements.  See the NOTICE file distributed with
1:628add4:  *  this work for additional information regarding copyright ownership.
1:628add4:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:628add4:  *  (the "License"); you may not use this file except in compliance with
1:628add4:  *  the License.  You may obtain a copy of the License at
1:628add4:  *
1:628add4:  *     http://www.apache.org/licenses/LICENSE-2.0
1:628add4:  *
1:628add4:  *  Unless required by applicable law or agreed to in writing, software
1:628add4:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:628add4:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:628add4:  *  See the License for the specific language governing permissions and
1:628add4:  *  limitations under the License.
1:628add4:  */
1:56a6860: package org.apache.aries.samples.ariestrader.core;
4:628add4: 
1:628add4: import javax.sql.DataSource;
1:628add4: 
1:880e087: import org.apache.aries.samples.ariestrader.api.persistence.RunStatsDataBean;
1:56a6860: import org.apache.aries.samples.ariestrader.util.Log;
1:56a6860: import org.apache.aries.samples.ariestrader.util.MDBStats;
1:a8a9116: import org.apache.aries.samples.ariestrader.util.ServiceUtilities;
1:56a6860: import org.apache.aries.samples.ariestrader.util.TradeConfig;
1:56a6860: import org.apache.aries.samples.ariestrader.api.TradeDBManager;
1:628add4: 
1:628add4: import java.sql.Connection;
1:628add4: import java.sql.DatabaseMetaData;
1:628add4: import java.sql.PreparedStatement;
1:628add4: import java.sql.ResultSet;
1:628add4: import java.sql.SQLException;
1:628add4: import java.sql.Statement;
1:628add4: 
1:628add4: 
1:628add4: /**
1:628add4:  * TradeDBManagerImpl centralizes and simplifies the DB
1:b8c0170:  * configuration methods that are shared by some TradeServices
1:628add4:  * implementations.
1:628add4:  * 
1:628add4:  * @see
1:56a6860:  *      org.apache.aries.samples.ariestrader.api.TradeDBManager
1:628add4:  */
1:628add4: 
1:628add4: public class TradeDBManagerImpl implements TradeDBManager {
1:628add4: 
1:ea52306:     private DataSource dataSource = null;
1:628add4: 
1:628add4:     private static boolean initialized = false;
1:628add4: 
1:628add4:     private static int connCount = 0;
1:628add4: 
1:628add4:     private static Integer lock = new Integer(0);
1:628add4: 
1:628add4:     /**
1:628add4:      * Zero arg constructor for TradeDBManagerImpl
1:628add4:      */
1:628add4:     public TradeDBManagerImpl() {
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:628add4:      * set data source
1:628add4:      */
1:628add4:     public void setDataSource(DataSource dataSource) {
1:628add4:             this.dataSource = dataSource;
1:628add4:     }
1:628add4: 
1:628add4: 
1:628add4:     /**
1:628add4:      * Return a String containing the DBProductName configured for
1:628add4:      * the current DataSource
1:628add4:      * 
1:628add4:      * used by TradeBuildDB
1:628add4:      *
1:628add4:      * @return A String of the currently configured DataSource
1:628add4:      * 
1:628add4:      */
1:628add4:     public String checkDBProductName() throws Exception {
1:628add4:         Connection conn = null;
1:628add4:         String dbProductName = null;
1:628add4: 
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:628add4:                 Log.traceEnter("TradeDBManagerImpl:checkDBProductName");
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             DatabaseMetaData dbmd = conn.getMetaData();
1:628add4:             dbProductName = dbmd.getDatabaseProductName();
1:628add4:         }
1:628add4:         catch (SQLException e) {
1:56a6860:             Log.error(e, "TradeDBManagerImpl:checkDBProductName() -- Error checking the AriesTrader Database Product Name");
1:628add4:         }
1:628add4:         finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return dbProductName;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:56a6860:      * Recreate DataBase Tables for AriesTrader
1:628add4:      * 
1:628add4:      * used by TradeBuildDB
1:628add4:      *
1:628add4:      * @return boolean of success/failure in recreate of DB tables
1:628add4:      * 
1:628add4:      */
1:628add4:     public boolean recreateDBTables(Object[] sqlBuffer, java.io.PrintWriter out) throws Exception {
1:628add4:         // Clear MDB Statistics
1:628add4:         MDBStats.getInstance().reset();
1:628add4: 
1:628add4:         Connection conn = null;
1:628add4:         boolean success = false;
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:628add4:                 Log.traceEnter("TradeDBManagerImpl:recreateDBTables");
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             Statement stmt = conn.createStatement();
1:628add4:             int bufferLength = sqlBuffer.length;
1:628add4:             for (int i = 0; i < bufferLength; i++) {
1:628add4:                 try {
1:628add4:                     stmt.executeUpdate((String) sqlBuffer[i]);
1:628add4:                 }
1:628add4:                 catch (SQLException ex) {
1:628add4:                     // Ignore DROP statements as tables won't always exist.
1:628add4:                     if (((String) sqlBuffer[i]).indexOf("DROP TABLE") < 0) {
1:628add4:                         Log.error("TradeDBManagerImpl:recreateDBTables SQL Exception thrown on executing the foll sql command: "
1:628add4:                                   + sqlBuffer[i], ex);
1:628add4:                         out.println("<BR>SQL Exception thrown on executing the foll sql command: <I>" + sqlBuffer[i]
1:628add4:                                     + "</I> . Check log for details.</BR>");
1:628add4:                     }
1:628add4:                 }
1:628add4:             }
1:628add4:             stmt.close();
1:628add4:             commit(conn);
1:628add4:             success = true;
1:628add4:         }
1:628add4:         catch (Exception e) {
1:628add4:             Log.error(e, "TradeDBManagerImpl:recreateDBTables() -- Error dropping and recreating the database tables");
1:628add4:         }
1:628add4:         finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return success;
1:628add4:     }
1:628add4: 
1:628add4:     /**
1:56a6860:      * Reset the statistics for the Test AriesTrader Scenario
1:628add4:      * 
1:628add4:      * used by TradeConfigServlet
1:628add4:      *
1:628add4:      * @return the RunStatsDataBean
1:628add4:      * 
1:628add4:      */
1:628add4:     public RunStatsDataBean resetTrade(boolean deleteAll) throws Exception {
1:628add4:         // Clear MDB Statistics
1:628add4:         MDBStats.getInstance().reset();
1:628add4: 
1:628add4:         // Reset Trade
1:628add4: 
1:628add4:         RunStatsDataBean runStatsData = new RunStatsDataBean();
1:628add4:         Connection conn = null;
1:628add4:         try {
1:628add4:             if (Log.doTrace())
1:af24676:                 Log.traceEnter("TradeDBManagerImpl:resetTrade deleteAll rows=" + deleteAll);
1:628add4: 
1:628add4:             conn = getConn();
1:628add4:             PreparedStatement stmt = null;
1:628add4:             ResultSet rs = null;
1:628add4: 
1:628add4:             if (deleteAll) {
1:628add4:                 try {
1:628add4:                     stmt = getStatement(conn, "delete from quoteejb");
1:628add4:                     stmt.executeUpdate();
1:628add4:                     stmt.close();
1:628add4:                     stmt = getStatement(conn, "delete from accountejb");
1:628add4:                     stmt.executeUpdate();
1:628add4:                     stmt.close();
1:628add4:                     stmt = getStatement(conn, "delete from accountprofileejb");
1:628add4:                     stmt.executeUpdate();
1:628add4:                     stmt.close();
1:628add4:                     stmt = getStatement(conn, "delete from holdingejb");
1:628add4:                     stmt.executeUpdate();
1:628add4:                     stmt.close();
1:628add4:                     stmt = getStatement(conn, "delete from orderejb");
1:628add4:                     stmt.executeUpdate();
1:628add4:                     stmt.close();
1:628add4:                     // FUTURE: - DuplicateKeyException - For now, don't start at
1:628add4:                     // zero as KeySequenceDirect and KeySequenceBean will still
1:628add4:                     // give out
1:628add4:                     // the cached Block and then notice this change. Better
1:628add4:                     // solution is
1:628add4:                     // to signal both classes to drop their cached blocks
1:628add4:                     // stmt = getStatement(conn, "delete from keygenejb");
1:628add4:                     // stmt.executeUpdate();
1:628add4:                     // stmt.close();
1:628add4:                     commit(conn);
1:628add4:                 }
1:628add4:                 catch (Exception e) {
1:af24676:                     Log.error(e, "TradeDBManagerImpl:resetTrade(deleteAll) -- Error deleting Trade users and stock from the Trade database");
1:628add4:                 }
1:628add4:                 return runStatsData;
1:628add4:             }
1:628add4: 
1:628add4:             stmt = getStatement(conn, "delete from holdingejb where holdingejb.account_accountid is null");
1:b8c0170:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             // Count and Delete newly registered users (users w/ id that start
1:628add4:             // "ru:%":
1:628add4:             stmt = getStatement(conn, "delete from accountprofileejb where userid like 'ru:%'");
1:b8c0170:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "delete from orderejb where account_accountid in (select accountid from accountejb a where a.profile_userid like 'ru:%')");
1:b8c0170:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "delete from holdingejb where account_accountid in (select accountid from accountejb a where a.profile_userid like 'ru:%')");
1:b8c0170:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             stmt = getStatement(conn, "delete from accountejb where profile_userid like 'ru:%'");
1:628add4:             int newUserCount = stmt.executeUpdate();
1:628add4:             runStatsData.setNewUserCount(newUserCount);
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             // Count of trade users
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select count(accountid) as \"tradeUserCount\" from accountejb a where a.profile_userid like 'uid:%'");
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int tradeUserCount = rs.getInt("tradeUserCount");
1:628add4:             runStatsData.setTradeUserCount(tradeUserCount);
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             rs.close();
1:628add4:             // Count of trade stocks
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select count(symbol) as \"tradeStockCount\" from quoteejb a where a.symbol like 's:%'");
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int tradeStockCount = rs.getInt("tradeStockCount");
1:628add4:             runStatsData.setTradeStockCount(tradeStockCount);
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             // Count of trade users login, logout
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select sum(loginCount) as \"sumLoginCount\", sum(logoutCount) as \"sumLogoutCount\" from accountejb a where  a.profile_userID like 'uid:%'");
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int sumLoginCount = rs.getInt("sumLoginCount");
1:628add4:             int sumLogoutCount = rs.getInt("sumLogoutCount");
1:628add4:             runStatsData.setSumLoginCount(sumLoginCount);
1:628add4:             runStatsData.setSumLogoutCount(sumLogoutCount);
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             rs.close();
1:628add4:             // Update logoutcount and loginCount back to zero
1:628add4: 
1:628add4:             stmt =
1:628add4:             getStatement(conn, "update accountejb set logoutCount=0,loginCount=0 where profile_userID like 'uid:%'");
1:b8c0170:             stmt.executeUpdate();
1:628add4:             stmt.close();
1:628add4: 
1:628add4:             // count holdings for trade users
1:628add4:             stmt = getStatement(conn,
1:628add4:                                "select count(holdingid) as \"holdingCount\" from holdingejb h where h.account_accountid in "
1:628add4:                                + "(select accountid from accountejb a where a.profile_userid like 'uid:%')");
1:628add4: 
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int holdingCount = rs.getInt("holdingCount");
1:628add4:             runStatsData.setHoldingCount(holdingCount);
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4: 
1:628add4:             // count orders for trade users
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select count(orderid) as \"orderCount\" from orderejb o where o.account_accountid in "
1:628add4:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')");
1:628add4: 
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int orderCount = rs.getInt("orderCount");
1:628add4:             runStatsData.setOrderCount(orderCount);
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4: 
1:628add4:             // count orders by type for trade users
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select count(orderid) \"buyOrderCount\"from orderejb o where (o.account_accountid in "
1:628add4:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')) AND "
1:628add4:                                 + " (o.orderType='buy')");
1:628add4: 
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int buyOrderCount = rs.getInt("buyOrderCount");
1:628add4:             runStatsData.setBuyOrderCount(buyOrderCount);
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4: 
1:628add4:             // count orders by type for trade users
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select count(orderid) \"sellOrderCount\"from orderejb o where (o.account_accountid in "
1:628add4:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')) AND "
1:628add4:                                 + " (o.orderType='sell')");
1:628add4: 
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int sellOrderCount = rs.getInt("sellOrderCount");
1:628add4:             runStatsData.setSellOrderCount(sellOrderCount);
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4: 
1:628add4:             // Delete cancelled orders
1:628add4:             stmt = getStatement(conn, "delete from orderejb where orderStatus='cancelled'");
1:628add4:             int cancelledOrderCount = stmt.executeUpdate();
1:628add4:             runStatsData.setCancelledOrderCount(cancelledOrderCount);
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4: 
1:628add4:             // count open orders by type for trade users
1:628add4:             stmt = getStatement(conn,
1:628add4:                                 "select count(orderid) \"openOrderCount\"from orderejb o where (o.account_accountid in "
1:628add4:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')) AND "
1:628add4:                                 + " (o.orderStatus='open')");
1:628add4: 
1:628add4:             rs = stmt.executeQuery();
1:628add4:             rs.next();
1:628add4:             int openOrderCount = rs.getInt("openOrderCount");
1:628add4:             runStatsData.setOpenOrderCount(openOrderCount);
1:628add4: 
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4:             // Delete orders for holding which have been purchased and sold
1:628add4:             stmt = getStatement(conn, "delete from orderejb where holding_holdingid is null");
1:628add4:             int deletedOrderCount = stmt.executeUpdate();
1:628add4:             runStatsData.setDeletedOrderCount(deletedOrderCount);
1:628add4:             stmt.close();
1:628add4:             rs.close();
1:628add4: 
1:628add4:             commit(conn);
1:628add4: 
1:af24676:             System.out.println("TradeDBManagerImpl:reset Run stats data\n\n" + runStatsData);
1:628add4:         }
1:628add4:         catch (Exception e) {
1:628add4:             Log.error(e, "Failed to reset Trade");
1:628add4:             rollBack(conn, e);
1:628add4:             throw e;
1:628add4:         }
1:628add4:         finally {
1:628add4:             releaseConn(conn);
1:628add4:         }
1:628add4:         return runStatsData;
1:628add4: 
1:628add4:     }
1:628add4: 
1:628add4:     private void releaseConn(Connection conn) throws Exception {
1:628add4:         try {
1:628add4:             if (conn != null) {
1:628add4:                 conn.close();
1:628add4:                 if (Log.doTrace()) {
1:628add4:                     synchronized (lock) {
1:628add4:                         connCount--;
1:628add4:                     }
1:628add4:                     Log.trace("TradeDBManagerImpl:releaseConn -- connection closed, connCount=" + connCount);
1:628add4:                 }
1:628add4:             }
1:628add4:         }
1:628add4:         catch (Exception e) {
1:628add4:             Log.error("TradeDBManagerImpl:releaseConnection -- failed to close connection", e);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Lookup the TradeData DataSource
1:628add4:      */
1:ea52306:     private void lookupDataSource() throws Exception {
1:ea52306:         if (dataSource == null) {
1:a8a9116:             dataSource = (DataSource) ServiceUtilities.getOSGIService(DataSource.class.getName(),TradeConfig.OSGI_DS_NAME_FILTER);
1:ea52306:         }
1:ea52306:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Allocate a new connection to the datasource
1:628add4:      */
1:628add4:     private Connection getConn() throws Exception {
1:628add4: 
1:628add4:         Connection conn = null;
1:ea52306:         lookupDataSource();
1:628add4:         conn = dataSource.getConnection();
1:628add4:         conn.setAutoCommit(false);
1:628add4:         if (Log.doTrace()) {
1:628add4:             synchronized (lock) {
1:628add4:                 connCount++;
1:628add4:             }
1:628add4:             Log.trace("TradeDBManagerImpl:getConn -- new connection allocated, IsolationLevel="
1:628add4:                       + conn.getTransactionIsolation() + " connectionCount = " + connCount);
1:628add4:         }
1:628add4: 
1:628add4:         return conn;
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Commit the provided connection 
1:628add4:      */
1:628add4:     private void commit(Connection conn) throws Exception {
1:628add4:         if (conn != null)
1:628add4:             conn.commit();
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:628add4:      * Rollback the statement for the given connection
1:628add4:      */
1:628add4:     private void rollBack(Connection conn, Exception e) throws Exception {
1:628add4:         Log.log("TradeDBManagerImpl:rollBack -- rolling back conn due to previously caught exception");
1:628add4:         if (conn != null)
1:628add4:             conn.rollback();
1:628add4:         else
1:628add4:             throw e; // Throw the exception
1:628add4:     }
1:628add4: 
1:628add4:     /*
1:b8c0170:      * Allocate a new prepared statement for this connection
1:628add4:      */
1:628add4:     private PreparedStatement getStatement(Connection conn, String sql) throws Exception {
1:628add4:         return conn.prepareStatement(sql);
1:628add4:     }
1:628add4: 
1:628add4: 
1:628add4:     public void init() {
1:628add4:         if (initialized)
1:628add4:             return;
1:628add4:         if (Log.doTrace())
1:628add4:             Log.trace("TradeDBManagerImpl:init -- *** initializing");
1:628add4: 
1:628add4:         if (Log.doTrace())
1:628add4:             Log.trace("TradeDBManagerImpl:init -- +++ initialized");
1:628add4: 
1:628add4:         initialized = true;
1:628add4:     }
1:628add4: 
1:628add4:     public void destroy() {
1:628add4:         try {
1:628add4:             Log.trace("TradeDBManagerImpl:destroy");
1:628add4:             if (!initialized)
1:628add4:                 return;
1:628add4:         }
1:628add4:         catch (Exception e) {
1:628add4:             Log.error("TradeDBManagerImpl:destroy", e);
1:628add4:         }
1:628add4:     }
1:628add4: 
1:628add4: }
============================================================================
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:39f53f6
commit:b8c0170
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * configuration methods that are shared by some TradeServices
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             stmt.executeUpdate();
1:             stmt.executeUpdate();
1:             stmt.executeUpdate();
1:             stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:             stmt.executeUpdate();
/////////////////////////////////////////////////////////////////////////
1:      * Allocate a new prepared statement for this connection
commit:880e087
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.samples.ariestrader.api.persistence.RunStatsDataBean;
commit:01ce653
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:989ba4e
commit:a8a9116
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.samples.ariestrader.util.ServiceUtilities;
/////////////////////////////////////////////////////////////////////////
0: //            dataSource = (DataSource) ServiceUtilities.getOSGIService(DataSource.class.getName(),"(osgi.jndi.serviceName=jdbc/TradeDataSource)");
1:             dataSource = (DataSource) ServiceUtilities.getOSGIService(DataSource.class.getName(),TradeConfig.OSGI_DS_NAME_FILTER);
commit:37fe36d
/////////////////////////////////////////////////////////////////////////
0:     private static String dsName = TradeConfig.DS_NAME;
commit:af24676
/////////////////////////////////////////////////////////////////////////
1:                 Log.traceEnter("TradeDBManagerImpl:resetTrade deleteAll rows=" + deleteAll);
/////////////////////////////////////////////////////////////////////////
1:                     Log.error(e, "TradeDBManagerImpl:resetTrade(deleteAll) -- Error deleting Trade users and stock from the Trade database");
/////////////////////////////////////////////////////////////////////////
1:             System.out.println("TradeDBManagerImpl:reset Run stats data\n\n" + runStatsData);
commit:ea52306
/////////////////////////////////////////////////////////////////////////
1:     private DataSource dataSource = null;
/////////////////////////////////////////////////////////////////////////
1:     private void lookupDataSource() throws Exception {
1:         if (dataSource == null) {
0:             context = new InitialContext();
0:             dataSource = (DataSource) context.lookup(dsName);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         lookupDataSource();
commit:56a6860
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.samples.ariestrader.core;
0: import org.apache.aries.samples.ariestrader.persistence.api.RunStatsDataBean;
1: import org.apache.aries.samples.ariestrader.util.Log;
1: import org.apache.aries.samples.ariestrader.util.MDBStats;
1: import org.apache.aries.samples.ariestrader.util.TradeConfig;
1: import org.apache.aries.samples.ariestrader.api.TradeDBManager;
/////////////////////////////////////////////////////////////////////////
1:  *      org.apache.aries.samples.ariestrader.api.TradeDBManager
/////////////////////////////////////////////////////////////////////////
1:             Log.error(e, "TradeDBManagerImpl:checkDBProductName() -- Error checking the AriesTrader Database Product Name");
/////////////////////////////////////////////////////////////////////////
1:      * Recreate DataBase Tables for AriesTrader
/////////////////////////////////////////////////////////////////////////
1:      * Reset the statistics for the Test AriesTrader Scenario
commit:3be9855
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.samples.daytrader.core;
0: import org.apache.aries.samples.daytrader.persistence.api.RunStatsDataBean;
0: import org.apache.aries.samples.daytrader.util.Log;
0: import org.apache.aries.samples.daytrader.util.MDBStats;
0: import org.apache.aries.samples.daytrader.util.TradeConfig;
0: import org.apache.aries.samples.daytrader.api.TradeDBManager;
/////////////////////////////////////////////////////////////////////////
0:  *      org.apache.aries.samples.daytrader.api.TradeDBManager
commit:92b2ae7
commit:3d66c06
commit:628add4
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
0: package org.apache.geronimo.samples.daytrader.core;
1: 
0: import javax.naming.InitialContext;
1: 
1: import javax.sql.DataSource;
1: 
0: import org.apache.geronimo.samples.daytrader.persistence.api.RunStatsDataBean;
0: import org.apache.geronimo.samples.daytrader.util.Log;
0: import org.apache.geronimo.samples.daytrader.util.MDBStats;
0: import org.apache.geronimo.samples.daytrader.util.TradeConfig;
0: import org.apache.geronimo.samples.daytrader.api.TradeDBManager;
1: 
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: 
1: /**
1:  * TradeDBManagerImpl centralizes and simplifies the DB
0:  * configuartion methods that are shared by some TradeServices
1:  * implementations.
1:  * 
1:  * @see
0:  *      org.apache.geronimo.samples.daytrader.api.TradeDBManager
1:  */
1: 
1: public class TradeDBManagerImpl implements TradeDBManager {
1: 
0:     private static String dsName = TradeConfig.DATASOURCE;
1: 
0: //    private static DataSource dataSource = null;
0:     private DataSource dataSource;
1: 
0:     private static InitialContext context;
1: 
1:     private static boolean initialized = false;
1: 
1:     private static int connCount = 0;
1: 
1:     private static Integer lock = new Integer(0);
1: 
1:     /**
1:      * Zero arg constructor for TradeDBManagerImpl
1:      */
1:     public TradeDBManagerImpl() {
1:     }
1: 
1:     /**
1:      * set data source
1:      */
1:     public void setDataSource(DataSource dataSource) {
1:             this.dataSource = dataSource;
1:     }
1: 
1: 
1:     /**
1:      * Return a String containing the DBProductName configured for
1:      * the current DataSource
1:      * 
1:      * used by TradeBuildDB
1:      *
1:      * @return A String of the currently configured DataSource
1:      * 
1:      */
1:     public String checkDBProductName() throws Exception {
1:         Connection conn = null;
1:         String dbProductName = null;
1: 
1:         try {
1:             if (Log.doTrace())
1:                 Log.traceEnter("TradeDBManagerImpl:checkDBProductName");
1: 
1:             conn = getConn();
1:             DatabaseMetaData dbmd = conn.getMetaData();
1:             dbProductName = dbmd.getDatabaseProductName();
1:         }
1:         catch (SQLException e) {
0:             Log.error(e, "TradeDBManagerImpl:checkDBProductName() -- Error checking the Daytrader Database Product Name");
1:         }
1:         finally {
1:             releaseConn(conn);
1:         }
1:         return dbProductName;
1:     }
1: 
1:     /**
0:      * Recreate DataBase Tables for DayTrader
1:      * 
1:      * used by TradeBuildDB
1:      *
1:      * @return boolean of success/failure in recreate of DB tables
1:      * 
1:      */
1:     public boolean recreateDBTables(Object[] sqlBuffer, java.io.PrintWriter out) throws Exception {
1:         // Clear MDB Statistics
1:         MDBStats.getInstance().reset();
1: 
1:         Connection conn = null;
1:         boolean success = false;
1:         try {
1:             if (Log.doTrace())
1:                 Log.traceEnter("TradeDBManagerImpl:recreateDBTables");
1: 
1:             conn = getConn();
1:             Statement stmt = conn.createStatement();
1:             int bufferLength = sqlBuffer.length;
1:             for (int i = 0; i < bufferLength; i++) {
1:                 try {
1:                     stmt.executeUpdate((String) sqlBuffer[i]);
1:                 }
1:                 catch (SQLException ex) {
1:                     // Ignore DROP statements as tables won't always exist.
1:                     if (((String) sqlBuffer[i]).indexOf("DROP TABLE") < 0) {
1:                         Log.error("TradeDBManagerImpl:recreateDBTables SQL Exception thrown on executing the foll sql command: "
1:                                   + sqlBuffer[i], ex);
1:                         out.println("<BR>SQL Exception thrown on executing the foll sql command: <I>" + sqlBuffer[i]
1:                                     + "</I> . Check log for details.</BR>");
1:                     }
1:                 }
1:             }
1:             stmt.close();
1:             commit(conn);
1:             success = true;
1:         }
1:         catch (Exception e) {
1:             Log.error(e, "TradeDBManagerImpl:recreateDBTables() -- Error dropping and recreating the database tables");
1:         }
1:         finally {
1:             releaseConn(conn);
1:         }
1:         return success;
1:     }
1: 
1:     /**
0:      * Reset the statistics for the Test Daytrader Scenario
1:      * 
1:      * used by TradeConfigServlet
1:      *
1:      * @return the RunStatsDataBean
1:      * 
1:      */
1:     public RunStatsDataBean resetTrade(boolean deleteAll) throws Exception {
1:         // Clear MDB Statistics
1:         MDBStats.getInstance().reset();
1: 
1:         // Reset Trade
1: 
1:         RunStatsDataBean runStatsData = new RunStatsDataBean();
1:         Connection conn = null;
1:         try {
1:             if (Log.doTrace())
0:                 Log.traceEnter("TradeJDBCDirect:resetTrade deleteAll rows=" + deleteAll);
1: 
1:             conn = getConn();
1:             PreparedStatement stmt = null;
1:             ResultSet rs = null;
1: 
1:             if (deleteAll) {
1:                 try {
1:                     stmt = getStatement(conn, "delete from quoteejb");
1:                     stmt.executeUpdate();
1:                     stmt.close();
1:                     stmt = getStatement(conn, "delete from accountejb");
1:                     stmt.executeUpdate();
1:                     stmt.close();
1:                     stmt = getStatement(conn, "delete from accountprofileejb");
1:                     stmt.executeUpdate();
1:                     stmt.close();
1:                     stmt = getStatement(conn, "delete from holdingejb");
1:                     stmt.executeUpdate();
1:                     stmt.close();
1:                     stmt = getStatement(conn, "delete from orderejb");
1:                     stmt.executeUpdate();
1:                     stmt.close();
1:                     // FUTURE: - DuplicateKeyException - For now, don't start at
1:                     // zero as KeySequenceDirect and KeySequenceBean will still
1:                     // give out
1:                     // the cached Block and then notice this change. Better
1:                     // solution is
1:                     // to signal both classes to drop their cached blocks
1:                     // stmt = getStatement(conn, "delete from keygenejb");
1:                     // stmt.executeUpdate();
1:                     // stmt.close();
1:                     commit(conn);
1:                 }
1:                 catch (Exception e) {
0:                     Log.error(e, "TradeJDBCDirect:resetTrade(deleteAll) -- Error deleting Trade users and stock from the Trade database");
1:                 }
1:                 return runStatsData;
1:             }
1: 
1:             stmt = getStatement(conn, "delete from holdingejb where holdingejb.account_accountid is null");
0:             int x = stmt.executeUpdate();
1:             stmt.close();
1: 
1:             // Count and Delete newly registered users (users w/ id that start
1:             // "ru:%":
1:             stmt = getStatement(conn, "delete from accountprofileejb where userid like 'ru:%'");
0:             int rowCount = stmt.executeUpdate();
1:             stmt.close();
1: 
1:             stmt = getStatement(conn,
1:                                 "delete from orderejb where account_accountid in (select accountid from accountejb a where a.profile_userid like 'ru:%')");
0:             rowCount = stmt.executeUpdate();
1:             stmt.close();
1: 
1:             stmt = getStatement(conn,
1:                                 "delete from holdingejb where account_accountid in (select accountid from accountejb a where a.profile_userid like 'ru:%')");
0:             rowCount = stmt.executeUpdate();
1:             stmt.close();
1: 
1:             stmt = getStatement(conn, "delete from accountejb where profile_userid like 'ru:%'");
1:             int newUserCount = stmt.executeUpdate();
1:             runStatsData.setNewUserCount(newUserCount);
1:             stmt.close();
1: 
1:             // Count of trade users
1:             stmt = getStatement(conn,
1:                                 "select count(accountid) as \"tradeUserCount\" from accountejb a where a.profile_userid like 'uid:%'");
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int tradeUserCount = rs.getInt("tradeUserCount");
1:             runStatsData.setTradeUserCount(tradeUserCount);
1:             stmt.close();
1: 
1:             rs.close();
1:             // Count of trade stocks
1:             stmt = getStatement(conn,
1:                                 "select count(symbol) as \"tradeStockCount\" from quoteejb a where a.symbol like 's:%'");
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int tradeStockCount = rs.getInt("tradeStockCount");
1:             runStatsData.setTradeStockCount(tradeStockCount);
1:             stmt.close();
1: 
1:             // Count of trade users login, logout
1:             stmt = getStatement(conn,
1:                                 "select sum(loginCount) as \"sumLoginCount\", sum(logoutCount) as \"sumLogoutCount\" from accountejb a where  a.profile_userID like 'uid:%'");
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int sumLoginCount = rs.getInt("sumLoginCount");
1:             int sumLogoutCount = rs.getInt("sumLogoutCount");
1:             runStatsData.setSumLoginCount(sumLoginCount);
1:             runStatsData.setSumLogoutCount(sumLogoutCount);
1:             stmt.close();
1: 
1:             rs.close();
1:             // Update logoutcount and loginCount back to zero
1: 
1:             stmt =
1:             getStatement(conn, "update accountejb set logoutCount=0,loginCount=0 where profile_userID like 'uid:%'");
0:             rowCount = stmt.executeUpdate();
1:             stmt.close();
1: 
1:             // count holdings for trade users
1:             stmt = getStatement(conn,
1:                                "select count(holdingid) as \"holdingCount\" from holdingejb h where h.account_accountid in "
1:                                + "(select accountid from accountejb a where a.profile_userid like 'uid:%')");
1: 
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int holdingCount = rs.getInt("holdingCount");
1:             runStatsData.setHoldingCount(holdingCount);
1:             stmt.close();
1:             rs.close();
1: 
1:             // count orders for trade users
1:             stmt = getStatement(conn,
1:                                 "select count(orderid) as \"orderCount\" from orderejb o where o.account_accountid in "
1:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')");
1: 
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int orderCount = rs.getInt("orderCount");
1:             runStatsData.setOrderCount(orderCount);
1:             stmt.close();
1:             rs.close();
1: 
1:             // count orders by type for trade users
1:             stmt = getStatement(conn,
1:                                 "select count(orderid) \"buyOrderCount\"from orderejb o where (o.account_accountid in "
1:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')) AND "
1:                                 + " (o.orderType='buy')");
1: 
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int buyOrderCount = rs.getInt("buyOrderCount");
1:             runStatsData.setBuyOrderCount(buyOrderCount);
1:             stmt.close();
1:             rs.close();
1: 
1:             // count orders by type for trade users
1:             stmt = getStatement(conn,
1:                                 "select count(orderid) \"sellOrderCount\"from orderejb o where (o.account_accountid in "
1:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')) AND "
1:                                 + " (o.orderType='sell')");
1: 
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int sellOrderCount = rs.getInt("sellOrderCount");
1:             runStatsData.setSellOrderCount(sellOrderCount);
1:             stmt.close();
1:             rs.close();
1: 
1:             // Delete cancelled orders
1:             stmt = getStatement(conn, "delete from orderejb where orderStatus='cancelled'");
1:             int cancelledOrderCount = stmt.executeUpdate();
1:             runStatsData.setCancelledOrderCount(cancelledOrderCount);
1:             stmt.close();
1:             rs.close();
1: 
1:             // count open orders by type for trade users
1:             stmt = getStatement(conn,
1:                                 "select count(orderid) \"openOrderCount\"from orderejb o where (o.account_accountid in "
1:                                 + "(select accountid from accountejb a where a.profile_userid like 'uid:%')) AND "
1:                                 + " (o.orderStatus='open')");
1: 
1:             rs = stmt.executeQuery();
1:             rs.next();
1:             int openOrderCount = rs.getInt("openOrderCount");
1:             runStatsData.setOpenOrderCount(openOrderCount);
1: 
1:             stmt.close();
1:             rs.close();
1:             // Delete orders for holding which have been purchased and sold
1:             stmt = getStatement(conn, "delete from orderejb where holding_holdingid is null");
1:             int deletedOrderCount = stmt.executeUpdate();
1:             runStatsData.setDeletedOrderCount(deletedOrderCount);
1:             stmt.close();
1:             rs.close();
1: 
1:             commit(conn);
1: 
0:             System.out.println("TradeJDBCDirect:reset Run stats data\n\n" + runStatsData);
1:         }
1:         catch (Exception e) {
1:             Log.error(e, "Failed to reset Trade");
1:             rollBack(conn, e);
1:             throw e;
1:         }
1:         finally {
1:             releaseConn(conn);
1:         }
1:         return runStatsData;
1: 
1:     }
1: 
1:     private void releaseConn(Connection conn) throws Exception {
1:         try {
1:             if (conn != null) {
1:                 conn.close();
1:                 if (Log.doTrace()) {
1:                     synchronized (lock) {
1:                         connCount--;
1:                     }
1:                     Log.trace("TradeDBManagerImpl:releaseConn -- connection closed, connCount=" + connCount);
1:                 }
1:             }
1:         }
1:         catch (Exception e) {
1:             Log.error("TradeDBManagerImpl:releaseConnection -- failed to close connection", e);
1:         }
1:     }
1: 
1:     /*
1:      * Lookup the TradeData DataSource
1:      */
0: //  private void getDataSource() throws Exception {
0: //      if (dataSource == null) {
0: //          context = new InitialContext();
0: //          dataSource = (DataSource) context.lookup(dsName);
0: //      }
0: //  }
1: 
1:     /*
1:      * Allocate a new connection to the datasource
1:      */
1:     private Connection getConn() throws Exception {
1: 
1:         Connection conn = null;
0: //        getDataSource();
1:         conn = dataSource.getConnection();
1:         conn.setAutoCommit(false);
1:         if (Log.doTrace()) {
1:             synchronized (lock) {
1:                 connCount++;
1:             }
1:             Log.trace("TradeDBManagerImpl:getConn -- new connection allocated, IsolationLevel="
1:                       + conn.getTransactionIsolation() + " connectionCount = " + connCount);
1:         }
1: 
1:         return conn;
1:     }
1: 
1:     /*
1:      * Commit the provided connection 
1:      */
1:     private void commit(Connection conn) throws Exception {
1:         if (conn != null)
1:             conn.commit();
1:     }
1: 
1:     /*
1:      * Rollback the statement for the given connection
1:      */
1:     private void rollBack(Connection conn, Exception e) throws Exception {
1:         Log.log("TradeDBManagerImpl:rollBack -- rolling back conn due to previously caught exception");
1:         if (conn != null)
1:             conn.rollback();
1:         else
1:             throw e; // Throw the exception
1:     }
1: 
1:     /*
0:      * Allocate a new prepared statment for this connection
1:      */
1:     private PreparedStatement getStatement(Connection conn, String sql) throws Exception {
1:         return conn.prepareStatement(sql);
1:     }
1: 
1: 
1:     public void init() {
1:         if (initialized)
1:             return;
1:         if (Log.doTrace())
1:             Log.trace("TradeDBManagerImpl:init -- *** initializing");
1: 
1:         if (Log.doTrace())
1:             Log.trace("TradeDBManagerImpl:init -- +++ initialized");
1: 
1:         initialized = true;
1:     }
1: 
1:     public void destroy() {
1:         try {
1:             Log.trace("TradeDBManagerImpl:destroy");
1:             if (!initialized)
1:                 return;
1:         }
1:         catch (Exception e) {
1:             Log.error("TradeDBManagerImpl:destroy", e);
1:         }
1:     }
1: 
1: }
============================================================================