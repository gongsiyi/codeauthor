1:f13c6ac: /**
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:f13c6ac:  * contributor license agreements.  See the NOTICE file distributed with
1:f13c6ac:  * this work for additional information regarding copyright ownership.
1:f13c6ac:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:f13c6ac:  * (the "License"); you may not use this file except in compliance with
1:f13c6ac:  * the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *      http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing, software
1:f13c6ac:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f13c6ac:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f13c6ac:  * See the License for the specific language governing permissions and
1:f13c6ac:  * limitations under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:f13c6ac: 
1:f13c6ac: import java.util.ArrayList;
1:6726c3e: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:f13c6ac: import java.util.Dictionary;
1:f13c6ac: import java.util.HashSet;
1:f13c6ac: import java.util.Hashtable;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Map;
1:f13c6ac: import java.util.Set;
1:f13c6ac: import java.util.concurrent.atomic.AtomicBoolean;
1:285f3a8: import java.util.concurrent.atomic.AtomicInteger;
1:3ed12df: import java.util.concurrent.atomic.AtomicReference;
1:f13c6ac: 
1:24455ce: import org.apache.aries.blueprint.BlueprintConstants;
1:24455ce: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:24455ce: import org.apache.aries.blueprint.Interceptor;
1:24455ce: import org.apache.aries.blueprint.ServiceProcessor;
1:5e2bd49: import org.apache.aries.blueprint.container.AggregateConverter.Convertible;
1:5e2bd49: import org.apache.aries.blueprint.container.BeanRecipe.UnwrapperedBeanHolder;
1:6414875: import org.apache.aries.blueprint.di.AbstractRecipe;
1:6414875: import org.apache.aries.blueprint.di.CollectionRecipe;
1:5e2bd49: import org.apache.aries.blueprint.di.ExecutionContext;
1:6414875: import org.apache.aries.blueprint.di.MapRecipe;
1:6414875: import org.apache.aries.blueprint.di.Recipe;
1:6414875: import org.apache.aries.blueprint.di.Repository;
1:285f3a8: import org.apache.aries.blueprint.proxy.CollaboratorFactory;
1:24455ce: import org.apache.aries.blueprint.proxy.ProxyUtils;
1:6414875: import org.apache.aries.blueprint.utils.JavaUtils;
1:6414875: import org.apache.aries.blueprint.utils.ReflectionUtils;
1:e2445d0: import org.apache.aries.blueprint.utils.ServiceListener;
1:69e59b8: import org.apache.aries.proxy.InvocationListener;
1:047a2ae: import org.apache.aries.util.AriesFrameworkUtil;
1:f13c6ac: import org.osgi.framework.Bundle;
1:f13c6ac: import org.osgi.framework.Constants;
1:24455ce: import org.osgi.framework.FrameworkUtil;
1:f13c6ac: import org.osgi.framework.ServiceFactory;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:f13c6ac: import org.osgi.framework.ServiceRegistration;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:5e2bd49: import org.osgi.service.blueprint.container.ReifiedType;
1:da163d0: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:8c4aa3a: 
1:f13c6ac: /**
1:f13c6ac:  * A <code>Recipe</code> to export services into the OSGi registry.
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public class ServiceRecipe extends AbstractRecipe {
1:f13c6ac: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRecipe.class);
1:8f4d7a3:     final static String LOG_ENTRY = "Method entry: {}, args {}";
1:8f4d7a3:     final static String LOG_EXIT = "Method exit: {}, returning {}";
1:f13c6ac: 
1:4bdcda3:     private final BlueprintContainerImpl blueprintContainer;
1:f13c6ac:     private final ServiceMetadata metadata;
1:f13c6ac:     private final Recipe serviceRecipe;
1:f13c6ac:     private final CollectionRecipe listenersRecipe;
1:f13c6ac:     private final MapRecipe propertiesRecipe;
1:f13c6ac:     private final List<Recipe> explicitDependencies;
1:f13c6ac: 
1:f13c6ac:     private Map properties;
1:3ed12df:     private final AtomicReference<ServiceRegistration> registration = new AtomicReference<ServiceRegistration>();
1:f13c6ac:     private Map registrationProperties;
1:f13c6ac:     private List<ServiceListener> listeners;
1:f13c6ac:     private volatile Object service;
1:285f3a8: 
1:3d072a4:     private final Object monitor = new Object();
1:285f3a8:     private final AtomicInteger activeCalls = new AtomicInteger(0);
1:285f3a8:     private volatile boolean quiesce;
2:3d072a4:     /** Only ever access when holding a lock on <code>monitor</code> */
1:109b82f:     private Collection<DestroyCallback> destroyCallbacks = new ArrayList<DestroyCallback>();
1:285f3a8: 
1:98df476:     private boolean initialServiceRegistration = true;
1:f13c6ac:     
1:f13c6ac:     public ServiceRecipe(String name,
1:4bdcda3:                          BlueprintContainerImpl blueprintContainer,
1:f13c6ac:                          ServiceMetadata metadata,
1:f13c6ac:                          Recipe serviceRecipe,
1:f13c6ac:                          CollectionRecipe listenersRecipe,
1:f13c6ac:                          MapRecipe propertiesRecipe,
1:f13c6ac:                          List<Recipe> explicitDependencies) {
1:f13c6ac:         super(name);
1:f13c6ac:         this.prototype = false;
1:f13c6ac:         this.blueprintContainer = blueprintContainer;
1:f13c6ac:         this.metadata = metadata;
1:f13c6ac:         this.serviceRecipe = serviceRecipe;
1:f13c6ac:         this.listenersRecipe = listenersRecipe;
1:f13c6ac:         this.propertiesRecipe = propertiesRecipe;
1:f13c6ac:         this.explicitDependencies = explicitDependencies;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Recipe getServiceRecipe() {
1:f13c6ac:         return serviceRecipe;
1:f13c6ac:     }
1:f13c6ac:     public CollectionRecipe getListenersRecipe() {
1:f13c6ac:         return listenersRecipe;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     @Override
1:f13c6ac:     public List<Recipe> getConstructorDependencies() {
1:f13c6ac:         List<Recipe> recipes = new ArrayList<Recipe>();
1:f13c6ac:         if (explicitDependencies != null) {
1:f13c6ac:             recipes.addAll(explicitDependencies);
1:f13c6ac:         }
1:f13c6ac:         return recipes;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public List<Recipe> getDependencies() {
1:f13c6ac:         List<Recipe> recipes = new ArrayList<Recipe>();
1:f13c6ac:         if (serviceRecipe != null) {
1:f13c6ac:             recipes.add(serviceRecipe);
1:f13c6ac:         }
1:f13c6ac:         if (listenersRecipe != null) {
1:f13c6ac:             recipes.add(listenersRecipe);
1:f13c6ac:         }
1:f13c6ac:         if (propertiesRecipe != null) {
1:f13c6ac:             recipes.add(propertiesRecipe);
1:f13c6ac:         }        
1:f13c6ac:         recipes.addAll(getConstructorDependencies());        
1:f13c6ac:         return recipes;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected Object internalCreate() throws ComponentDefinitionException {
1:f13c6ac:         ServiceRegistrationProxy proxy = new ServiceRegistrationProxy();
1:f13c6ac:         addPartialObject(proxy);
1:f13c6ac:         internalGetService(null, null); // null bundle means we don't want to retrieve the actual service when used with a ServiceFactory
1:f13c6ac:         return proxy;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public boolean isRegistered() {
1:4596747:         return registration.get() != null;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void register() {
1:a215c32:         int state = blueprintContainer.getBundleContext().getBundle().getState();
1:a215c32:         if (state != Bundle.ACTIVE && state != Bundle.STARTING) {
1:a215c32:             return;
1:a215c32:         }
1:4596747:         createExplicitDependencies();
1:f13c6ac: 
1:4596747:         Hashtable props = new Hashtable();
1:4596747:         if (properties == null) {
1:4596747:             properties = (Map) createRecipe(propertiesRecipe);
1:4596747:         }
1:4596747:         props.putAll(properties);
1:4596747:         if (metadata.getRanking() == 0) {
1:4596747:             props.remove(Constants.SERVICE_RANKING);
1:4596747:         } else {
1:4596747:             props.put(Constants.SERVICE_RANKING, metadata.getRanking());
1:4596747:         }
1:4596747:         String componentName = getComponentName();
1:4596747:         if (componentName != null) {
1:4596747:             props.put(BlueprintConstants.COMPONENT_NAME_PROPERTY, componentName);
1:4596747:         } else {
1:4596747:             props.remove(BlueprintConstants.COMPONENT_NAME_PROPERTY);
1:4596747:         }
1:4596747:         for (ServiceProcessor processor : blueprintContainer.getProcessors(ServiceProcessor.class)) {
1:4596747:             processor.updateProperties(new PropertiesUpdater(), props);
1:4596747:         }
1:f13c6ac: 
1:4596747:         registrationProperties = props;
1:f13c6ac: 
1:4596747:         Set<String> classes = getClasses();
1:4596747:         String[] classArray = classes.toArray(new String[classes.size()]);
1:f13c6ac: 
1:4596747:         LOGGER.debug("Registering service {} with interfaces {} and properties {}",
1:4596747:                      new Object[] { name, classes, props });
1:4596747: 
1:4596747:         if (registration.get() == null) {
1:4596747:             ServiceRegistration reg = blueprintContainer.registerService(classArray, new TriggerServiceFactory(this, metadata), props);
1:4596747:             if (!registration.compareAndSet(null, reg) && registration.get() != reg) {
1:bc681f8:                 AriesFrameworkUtil.safeUnregisterService(reg);
1:4596747:             }
1:f13c6ac:         }
1:98df476:         initialServiceRegistration = false;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void unregister() {
1:4596747:         ServiceRegistration reg = registration.get();
1:4596747:         if (reg != null) {
1:f13c6ac:             LOGGER.debug("Unregistering service {}", name);
1:f13c6ac:             // This method needs to allow reentrance, so if we need to make sure the registration is
1:f13c6ac:             // set to null before actually unregistering the service
1:1276403:             if (listeners != null) {
1:f13c6ac:                 LOGGER.debug("Calling listeners for service unregistration");
1:1276403:                 for (ServiceListener listener : listeners) {
1:f13c6ac:                     listener.unregister(service, registrationProperties);
1:f13c6ac:                 }
1:f13c6ac:             }
1:047a2ae:             AriesFrameworkUtil.safeUnregisterService(reg);
1:f13c6ac:             
1:3ed12df:             registration.compareAndSet(reg, null);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected ServiceReference getReference() {
1:3ed12df:     	ServiceRegistration reg = registration.get();
1:3ed12df:         if (reg == null) {
1:f13c6ac:             throw new IllegalStateException("Service is not registered");
1:1276403:         } else {
1:3ed12df:             return reg.getReference();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected void setProperties(Dictionary props) {
2:3ed12df:     	ServiceRegistration reg = registration.get();
1:3ed12df:         if (reg == null) {
1:f13c6ac:             throw new IllegalStateException("Service is not registered");
4:f13c6ac:         } else {
1:3ed12df:             reg.setProperties(props);
1:f13c6ac:             // TODO: set serviceProperties? convert somehow? should listeners be notified of this?
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: 
1:f13c6ac:     protected Object internalGetService() {
1:f13c6ac:         return internalGetService(blueprintContainer.getBundleContext().getBundle(), null);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Create the service object.
1:f13c6ac:      *
1:f13c6ac:      * @param bundle
1:f13c6ac:      * @param registration
1:f13c6ac:      * @return
1:f13c6ac:      */
1:f13c6ac:     private Object internalGetService(Bundle bundle, ServiceRegistration registration) {
1:f13c6ac:         LOGGER.debug("Retrieving service for bundle {} and service registration {}", bundle, registration);
1:98df476:         createService();
1:98df476: 
1:f13c6ac:         Object service = this.service;
1:f13c6ac:         // We need the real service ...
1:f13c6ac:         if (bundle != null) {
1:f13c6ac:         	if (service instanceof ServiceFactory) {
1:f13c6ac:         		service = ((ServiceFactory) service).getService(bundle, registration);
1:f13c6ac:         	}
1:f13c6ac:         	if (service == null) {
1:f13c6ac:         		throw new IllegalStateException("service is null");
1:f13c6ac:         	}
1:f13c6ac:         	// Check if the service actually implement all the requested interfaces
1:f13c6ac:         	validateClasses(service);
1:f13c6ac:         	// We're not really interested in the service, but perform some sanity checks nonetheless
1:f13c6ac:         } else {
1:f13c6ac:         	if (!(service instanceof ServiceFactory)) {
1:f13c6ac:         		// Check if the service actually implement all the requested interfaces
1:f13c6ac:         		validateClasses(service);
1:f13c6ac:         	}
1:f13c6ac:         }
1:5e2bd49:         
1:f13c6ac:         return service;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void createService() {
1:f13c6ac:         try {
1:98df476:             if (service == null) {
1:98df476:                 LOGGER.debug("Creating service instance");
1:98df476:                 //We can't use the BlueprintRepository because we don't know what interfaces
1:98df476:                 //to use yet! We have to be a bit smarter.
1:98df476:                 ExecutionContext old = ExecutionContext.Holder.setContext(blueprintContainer.getRepository());
1:98df476: 
1:98df476:                 try {
1:98df476:                     Object o = serviceRecipe.create();
1:98df476: 
1:98df476:                     if (o instanceof Convertible) {
1:98df476:                         o = blueprintContainer.getRepository().convert(o, new ReifiedType(Object.class));
1:98df476:                         validateClasses(o);
1:98df476:                     } else if (o instanceof UnwrapperedBeanHolder) {
1:98df476:                         UnwrapperedBeanHolder holder = (UnwrapperedBeanHolder) o;
1:30d612a:                         if (holder.unwrapperedBean instanceof ServiceFactory) {
1:30d612a:                             //If a service factory is used, make sure the proxy classes implement this
1:30d612a:                             //interface so that later on, internalGetService will create the real
1:30d612a:                             //service from it.
1:30d612a:                             LOGGER.debug("{} implements ServiceFactory, creating proxy that also implements this", holder.unwrapperedBean);
1:30d612a:                             Collection<Class<?>> cls = getClassesForProxying(holder.unwrapperedBean);
1:30d612a:                             cls.add(blueprintContainer.loadClass("org.osgi.framework.ServiceFactory"));
1:30d612a:                             o = BeanRecipe.wrap(holder, cls);
1:98df476:                         } else {
1:98df476:                             validateClasses(holder.unwrapperedBean);
1:98df476:                             o = BeanRecipe.wrap(holder, getClassesForProxying(holder.unwrapperedBean));
1:98df476:                         }
1:30d612a:                     } else if (!(o instanceof ServiceFactory)) {
1:98df476:                         validateClasses(o);
1:f13c6ac:                     }
1:98df476:                     service = o;
1:98df476:                 } catch (Exception e) {
1:98df476:                     LOGGER.error("Error retrieving service from " + this, e);
1:98df476:                     throw new ComponentDefinitionException(e);
1:98df476:                 } finally {
1:98df476:                     ExecutionContext.Holder.setContext(old);
1:f13c6ac:                 }
1:98df476:                 LOGGER.debug("Service created: {}", service);
1:98df476:             }
1:98df476: 
1:f13c6ac:             // When the service is first requested, we need to create listeners and call them
1:98df476:             if (!initialServiceRegistration && listeners == null) {
1:f13c6ac:                 LOGGER.debug("Creating listeners");
1:f13c6ac:                 if (listenersRecipe != null) {
1:f13c6ac:                     listeners = (List) createRecipe(listenersRecipe);
1:f13c6ac:                 } else {
1:f13c6ac:                     listeners = Collections.emptyList();
1:f13c6ac:                 }
1:f13c6ac:                 LOGGER.debug("Listeners created: {}", listeners);
1:4596747:                 if (registration.get() != null) {
1:f13c6ac:                     LOGGER.debug("Calling listeners for initial service registration");
2:f13c6ac:                     for (ServiceListener listener : listeners) {
1:1276403:                         listener.register(service, registrationProperties);
1:1276403:                     }
1:f13c6ac:                 } else {
1:f13c6ac:                     LOGGER.debug("Calling listeners for initial service unregistration");
1:f13c6ac:                     for (ServiceListener listener : listeners) {
1:f13c6ac:                         listener.unregister(service, registrationProperties);
1:1276403:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         } catch (RuntimeException e) {
1:f13c6ac:             LOGGER.error("Error retrieving service from " + this, e);
1:f13c6ac:             throw e;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private void validateClasses(Object service) {
1:f13c6ac:         // Check if the service actually implement all the requested interfaces
1:f13c6ac:         if (metadata.getAutoExport() == ServiceMetadata.AUTO_EXPORT_DISABLED) {
1:f13c6ac:             Set<String> allClasses = new HashSet<String>();
1:f13c6ac:             ReflectionUtils.getSuperClasses(allClasses, service.getClass());
1:f13c6ac:             ReflectionUtils.getImplementedInterfaces(allClasses, service.getClass());
1:5e2bd49:             //This call is safe because we know that we don't need to call internalGet to get the answer
2:f13c6ac:             Set<String> classes = getClasses();
1:f13c6ac:             classes.removeAll(allClasses);
1:f13c6ac:             if (!classes.isEmpty()) {
1:f13c6ac:                 throw new ComponentDefinitionException("The service implementation does not implement the required interfaces: " + classes);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:3ed12df:     public Object getService(Bundle bundle, ServiceRegistration registration) {
1:f13c6ac:         /** getService() can get called before registerService() returns with the registration object.
1:f13c6ac:          *  So we need to set the registration object in case registration listeners call 
1:f13c6ac:          *  getServiceReference(). 
1:f13c6ac:          */
1:3ed12df:     	this.registration.compareAndSet(null, registration);
1:f13c6ac:         return internalGetService(bundle, registration);
1:f13c6ac:     }
1:f13c6ac: 
1:3ed12df:     public void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
1:f13c6ac:         if (this.service instanceof ServiceFactory) {
1:f13c6ac:             ((ServiceFactory) this.service).ungetService(bundle, registration, service);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:5e2bd49:     /**
1:5e2bd49:      * Be careful to avoid calling this method from internalGetService or createService before the service
1:5e2bd49:      * field has been set. If you get this wrong you will get a StackOverflowError!
1:5e2bd49:      * @return
1:5e2bd49:      */
1:f13c6ac:     private Set<String> getClasses() {
1:f13c6ac:         Set<String> classes;
1:f13c6ac:         switch (metadata.getAutoExport()) {
1:f13c6ac:             case ServiceMetadata.AUTO_EXPORT_INTERFACES:
1:f13c6ac:                 classes = ReflectionUtils.getImplementedInterfaces(new HashSet<String>(), internalGetService().getClass());
1:f13c6ac:                 break;
1:f13c6ac:             case ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY:
1:f13c6ac:                 classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), internalGetService().getClass());
1:f13c6ac:                 break;
1:f13c6ac:             case ServiceMetadata.AUTO_EXPORT_ALL_CLASSES:
1:f13c6ac:                 classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), internalGetService().getClass());
1:f13c6ac:                 classes = ReflectionUtils.getImplementedInterfaces(classes, internalGetService().getClass());
1:f13c6ac:                 break;
1:f13c6ac:             default:
1:f13c6ac:                 classes = new HashSet<String>(metadata.getInterfaces());
1:f13c6ac:                 break;
1:f13c6ac:         }
1:f13c6ac:         return classes;
1:f13c6ac:     }
1:f13c6ac:     
1:6726c3e:     /**
1:6726c3e:      * Get the classes we need to proxy, for auto-export interfaces only, those 
1:6726c3e:      * will be just the interfaces implemented by the bean, for auto-export classes
1:6726c3e:      * or everything, then just proxying the real bean class will give us everything we
1:6726c3e:      * need, if none of the above then we need the class forms of the interfaces in
1:6726c3e:      * the metadata
1:5e2bd49:      * 
1:5e2bd49:      * Note that we use a template object here because we have already instantiated the bean
1:5e2bd49:      * that we're going to proxy. We can't call internalGetService because it would Stack Overflow.
1:6726c3e:      * @return
1:6726c3e:      * @throws ClassNotFoundException
1:6726c3e:      */
1:5e2bd49:     private Collection<Class<?>> getClassesForProxying(Object template) throws ClassNotFoundException {
1:6726c3e:       Collection<Class<?>> classes;
1:6726c3e:       switch (metadata.getAutoExport()) {
1:6726c3e:           case ServiceMetadata.AUTO_EXPORT_INTERFACES:
1:5e2bd49:               classes = ReflectionUtils.getImplementedInterfacesAsClasses(new HashSet<Class<?>>(), template.getClass());
1:6726c3e:               break;
1:6726c3e:           case ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY:
1:6726c3e:           case ServiceMetadata.AUTO_EXPORT_ALL_CLASSES:
1:5e2bd49:             classes = ProxyUtils.asList(template.getClass());
1:6726c3e:               break;
1:6726c3e:           default:
1:6726c3e:               classes = new HashSet<Class<?>>(convertStringsToClasses(metadata.getInterfaces()));
1:6726c3e:               break;
1:f13c6ac:       }
1:6726c3e:       return classes;
1:f13c6ac:   }
1:5e2bd49: 
1:6726c3e:     private Collection<? extends Class<?>> convertStringsToClasses(
1:6726c3e:         List<String> interfaces) throws ClassNotFoundException {
1:6726c3e:       Set<Class<?>> classes = new HashSet<Class<?>>();
1:6726c3e:       for(String s : interfaces) {
1:6726c3e:         classes.add(blueprintContainer.loadClass(s)); 
1:f13c6ac:       }
1:6726c3e:       return classes;
1:f13c6ac:     }
1:5e2bd49: 
1:f13c6ac:     private void createExplicitDependencies() {
1:f13c6ac:         if (explicitDependencies != null) {
1:f13c6ac:             for (Recipe recipe : explicitDependencies) {
1:f13c6ac:                 createRecipe(recipe);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private Object createRecipe(Recipe recipe) {
1:f13c6ac:         String name = recipe.getName();
1:f13c6ac:         Repository repo = blueprintContainer.getRepository();
1:f13c6ac:         if (repo.getRecipe(name) != recipe) {
1:f13c6ac:             repo.putRecipe(name, recipe);
1:f13c6ac:         }
1:f13c6ac:         return repo.create(name);
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private String getComponentName() {
1:f13c6ac:         if (metadata.getServiceComponent() instanceof RefMetadata) {
1:f13c6ac:             RefMetadata ref = (RefMetadata) metadata.getServiceComponent();
1:f13c6ac:             return ref.getComponentId();
1:f13c6ac:         } else {
1:f13c6ac:             return null;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:da163d0:     protected void incrementActiveCalls()
1:109b82f:     {
1:285f3a8:         // can be improved with LongAdder but Java 8 or backport (like guava) is needed
1:285f3a8:         activeCalls.incrementAndGet();
1:f13c6ac:     }
1:f13c6ac:     
1:109b82f:   	protected void decrementActiveCalls() 
1:109b82f:   	{
1:285f3a8:         int currentCount = activeCalls.decrementAndGet();
1:285f3a8: 
1:285f3a8:         if (currentCount == 0 && quiesce) {
1:285f3a8:             List<DestroyCallback> callbacksToCall;
1:285f3a8:             synchronized (monitor) {
1:285f3a8:                 callbacksToCall = new ArrayList<DestroyCallback>(destroyCallbacks);
1:285f3a8:                 destroyCallbacks.clear();
1:285f3a8:             }
1:285f3a8:             for(DestroyCallback cbk : callbacksToCall) {
1:285f3a8:                 cbk.callback();
1:285f3a8:             }
1:285f3a8:         }
1:f13c6ac:   	}
1:285f3a8: 
1:285f3a8:     /*
1:285f3a8:       The following problem is possible sometimes:
1:285f3a8:         some threads already got a service and start to call it but incrementActiveCalls have not called yet
1:285f3a8:         as a result activeCalls after service unregistration is not strongly decreasing and can be 0 but then not 0
1:285f3a8:     */
1:da163d0:     public void quiesce(DestroyCallback destroyCallback)
1:109b82f:     {
1:285f3a8:         unregister();
1:285f3a8:         quiesce = true;
1:285f3a8: 
1:285f3a8:         DestroyCallback safeDestroyCallback = new DestroyOnceCallback(destroyCallback);
1:285f3a8: 
1:285f3a8:         synchronized (monitor) {
1:285f3a8:             destroyCallbacks.add(safeDestroyCallback);
1:f13c6ac:         }
1:285f3a8: 
1:285f3a8:         if (activeCalls.get() == 0) {
1:285f3a8:             safeDestroyCallback.callback();
1:285f3a8:             synchronized (monitor) {
1:285f3a8:                 destroyCallbacks.remove(safeDestroyCallback);
1:285f3a8:             }
1:285f3a8:         }
1:285f3a8:     }
1:285f3a8: 
1:285f3a8:     private static class DestroyOnceCallback implements DestroyCallback {
1:285f3a8:         private final DestroyCallback destroyCallback;
1:285f3a8:         private final AtomicBoolean isDestroyed = new AtomicBoolean(false);
1:285f3a8: 
1:285f3a8:         public DestroyOnceCallback(DestroyCallback destroyCallback) {
1:285f3a8:             this.destroyCallback = destroyCallback;
1:285f3a8:         }
1:285f3a8: 
1:285f3a8: 
1:285f3a8:         @Override
1:285f3a8:         public void callback() {
1:285f3a8:             if (isDestroyed.compareAndSet(false, true)) {
1:285f3a8:                 destroyCallback.callback();
1:285f3a8:             }
1:285f3a8:         }
1:f13c6ac:     }
1:f13c6ac:      
1:da163d0:     private class TriggerServiceFactory implements ServiceFactory 
19:da163d0:     {
1:da163d0:     	private ServiceRecipe serviceRecipe;
1:da163d0:     	private ComponentMetadata cm;
1:8f4d7a3:     	private ServiceMetadata sm;
1:8c4aa3a:         private boolean isQuiesceAvailable;
1:8f4d7a3:     	public TriggerServiceFactory(ServiceRecipe serviceRecipe, ServiceMetadata cm)
1:da163d0:     	{
1:da163d0:     		this.serviceRecipe = serviceRecipe;
1:da163d0:     		this.cm = cm;
1:8f4d7a3:     		this.sm = cm;
1:8c4aa3a:             this.isQuiesceAvailable = isClassAvailable("org.apache.aries.quiesce.participant.QuiesceParticipant");
1:f13c6ac:     	}
1:5e2bd49:     	
1:f13c6ac:         public Object getService(Bundle bundle, ServiceRegistration registration) {
1:8c4aa3a:             Object original = ServiceRecipe.this.getService(bundle, registration);
1:8f4d7a3:             LOGGER.debug(LOG_ENTRY, "getService", original);
1:6726c3e: 
1:da163d0:             List<Interceptor> interceptors = new ArrayList<Interceptor>();
1:72d8402:             ComponentDefinitionRegistry reg = blueprintContainer.getComponentDefinitionRegistry();
1:72d8402:             List<Interceptor> registeredInterceptors = reg.getInterceptors(cm);
1:8c4aa3a:             if (registeredInterceptors != null) {
1:8c4aa3a:                 interceptors.addAll(registeredInterceptors);
1:f13c6ac:             }
1:8c4aa3a:             // Add quiesce interceptor if needed
1:8c4aa3a:             if (isQuiesceAvailable)
1:8c4aa3a:             {
1:8c4aa3a:                 interceptors.add(new QuiesceInterceptor(serviceRecipe));
1:8c4aa3a:             }
1:8c4aa3a:             // Exit if no interceptors configured
1:8c4aa3a:             if (interceptors.isEmpty()) {
1:8c4aa3a:                 return original;
1:8c4aa3a:             }
1:6726c3e: 
1:8c4aa3a:             Object intercepted;
1:8c4aa3a:             try {
1:24455ce:                 Bundle b = FrameworkUtil.getBundle(original.getClass());
1:ef2091c:                 if (b == null) {
1:ef2091c:                   // we have a class from the framework parent, so use our bundle for proxying.
1:ef2091c:                   b = blueprintContainer.getBundleContext().getBundle();
1:8c4aa3a:                 }
1:285f3a8:                 InvocationListener collaborator = CollaboratorFactory.create(cm, interceptors);
1:6726c3e: 
1:4dfd2d8:                 intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
1:5e2bd49:                         getClassesForProxying(original), original, collaborator);
1:6726c3e:             } catch (Exception u) {
1:ef2091c:                 Bundle b = blueprintContainer.getBundleContext().getBundle();
1:db4243b:                 LOGGER.info("Unable to create a proxy object for the service " + getName() + " defined in bundle " + b.getSymbolicName() + "/" + b.getVersion() + " with id. Returning the original object instead.", u);
1:071e3fe:                 LOGGER.debug(LOG_EXIT, "getService", original);
1:071e3fe:                 return original;
1:f13c6ac:             }
1:3ed12df: 
1:071e3fe:             LOGGER.debug(LOG_EXIT, "getService", intercepted);
1:071e3fe:             return intercepted;
1:071e3fe:         }
1:071e3fe: 
1:f13c6ac:         public void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
1:f13c6ac:             ServiceRecipe.this.ungetService(bundle, registration, service);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private class ServiceRegistrationProxy implements ServiceRegistration {
1:f13c6ac: 
1:f13c6ac:         public ServiceReference getReference() {
1:f13c6ac:             return ServiceRecipe.this.getReference();
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void setProperties(Dictionary properties) {
1:f13c6ac:             ServiceRecipe.this.setProperties(properties);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void unregister() {
1:f13c6ac:             throw new UnsupportedOperationException();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private class PropertiesUpdater implements ServiceProcessor.ServicePropertiesUpdater {
1:f13c6ac: 
1:f13c6ac:         public String getId() {
1:f13c6ac:             return metadata.getId();
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public void updateProperties(Dictionary properties) {
1:f13c6ac:             Hashtable table = JavaUtils.getProperties(ServiceRecipe.this.getReference());
1:f13c6ac:             JavaUtils.copy(table, properties);
1:f13c6ac:             ServiceRecipe.this.setProperties(table);
1:f13c6ac:         }        
1:f13c6ac:     }
1:f13c6ac: 
1:8c4aa3a:     private boolean isClassAvailable(String clazz) {
1:8c4aa3a:         try {
1:8c4aa3a:             getClass().getClassLoader().loadClass(clazz);
1:8c4aa3a:             return true;
1:8c4aa3a:         }
1:8c4aa3a:         catch (ClassNotFoundException e) {
1:8c4aa3a:             return false;
1:8c4aa3a:         }
1:8c4aa3a:         catch (NoClassDefFoundError e) {
1:8c4aa3a:             return false;
1:8c4aa3a:         }
1:8c4aa3a:     }
1:8c4aa3a: 
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:bc681f8
/////////////////////////////////////////////////////////////////////////
1:                 AriesFrameworkUtil.safeUnregisterService(reg);
commit:285f3a8
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.proxy.CollaboratorFactory;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private final AtomicInteger activeCalls = new AtomicInteger(0);
1:     private volatile boolean quiesce;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // can be improved with LongAdder but Java 8 or backport (like guava) is needed
1:         activeCalls.incrementAndGet();
1:         int currentCount = activeCalls.decrementAndGet();
1: 
1:         if (currentCount == 0 && quiesce) {
1:             List<DestroyCallback> callbacksToCall;
1:             synchronized (monitor) {
1:                 callbacksToCall = new ArrayList<DestroyCallback>(destroyCallbacks);
1:                 destroyCallbacks.clear();
1:             }
1:             for(DestroyCallback cbk : callbacksToCall) {
1:                 cbk.callback();
1:             }
1:         }
1: 
1:     /*
1:       The following problem is possible sometimes:
1:         some threads already got a service and start to call it but incrementActiveCalls have not called yet
1:         as a result activeCalls after service unregistration is not strongly decreasing and can be 0 but then not 0
1:     */
1:         unregister();
1:         quiesce = true;
1: 
1:         DestroyCallback safeDestroyCallback = new DestroyOnceCallback(destroyCallback);
1: 
1:         synchronized (monitor) {
1:             destroyCallbacks.add(safeDestroyCallback);
1: 
1:         if (activeCalls.get() == 0) {
1:             safeDestroyCallback.callback();
1:             synchronized (monitor) {
1:                 destroyCallbacks.remove(safeDestroyCallback);
1:             }
1:         }
1:     }
1: 
1:     private static class DestroyOnceCallback implements DestroyCallback {
1:         private final DestroyCallback destroyCallback;
1:         private final AtomicBoolean isDestroyed = new AtomicBoolean(false);
1: 
1:         public DestroyOnceCallback(DestroyCallback destroyCallback) {
1:             this.destroyCallback = destroyCallback;
1:         }
1: 
1: 
1:         @Override
1:         public void callback() {
1:             if (isDestroyed.compareAndSet(false, true)) {
1:                 destroyCallback.callback();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 InvocationListener collaborator = CollaboratorFactory.create(cm, interceptors);
commit:db4243b
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.info("Unable to create a proxy object for the service " + getName() + " defined in bundle " + b.getSymbolicName() + "/" + b.getVersion() + " with id. Returning the original object instead.", u);
commit:f1eabd5
/////////////////////////////////////////////////////////////////////////
commit:98df476
/////////////////////////////////////////////////////////////////////////
1:     private boolean initialServiceRegistration = true;
/////////////////////////////////////////////////////////////////////////
1:         initialServiceRegistration = false;
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.debug("Stack trace", new Throwable());
1:         createService();
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (service == null) {
1:                 LOGGER.debug("Creating service instance");
1:                 //We can't use the BlueprintRepository because we don't know what interfaces
1:                 //to use yet! We have to be a bit smarter.
1:                 ExecutionContext old = ExecutionContext.Holder.setContext(blueprintContainer.getRepository());
1: 
1:                 try {
1:                     Object o = serviceRecipe.create();
1: 
1:                     if (o instanceof Convertible) {
1:                         o = blueprintContainer.getRepository().convert(o, new ReifiedType(Object.class));
1:                         validateClasses(o);
1:                     } else if (o instanceof UnwrapperedBeanHolder) {
1:                         UnwrapperedBeanHolder holder = (UnwrapperedBeanHolder) o;
1:                         validateClasses(holder.unwrapperedBean);
1:                         o = BeanRecipe.wrap(holder, getClassesForProxying(holder.unwrapperedBean));
1:                     } else {
1:                         validateClasses(o);
1:                     }
1:                     service = o;
1:                 } catch (Exception e) {
1:                     LOGGER.error("Error retrieving service from " + this, e);
1:                     throw new ComponentDefinitionException(e);
1:                 } finally {
1:                     ExecutionContext.Holder.setContext(old);
1:                 LOGGER.debug("Service created: {}", service);
1:             }
1: 
1:             if (!initialServiceRegistration && listeners == null) {
commit:1276403
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 if (listeners != null) {
0:                     LOGGER.debug("Calling listeners for service registration");
1:                     for (ServiceListener listener : listeners) {
1:                         listener.register(service, registrationProperties);
1:                     }
1:                 }
commit:3d072a4
/////////////////////////////////////////////////////////////////////////
1:     private final Object monitor = new Object();
1:     /** Only ever access when holding a lock on <code>monitor</code> */
1:     /** Only ever access when holding a lock on <code>monitor</code> */
/////////////////////////////////////////////////////////////////////////
0:     	  synchronized(monitor)
/////////////////////////////////////////////////////////////////////////
0:       	synchronized(monitor)
/////////////////////////////////////////////////////////////////////////
0:     	  synchronized (monitor) {
commit:4596747
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return registration.get() != null;
/////////////////////////////////////////////////////////////////////////
1:         createExplicitDependencies();
1:         Hashtable props = new Hashtable();
1:         if (properties == null) {
1:             properties = (Map) createRecipe(propertiesRecipe);
1:         }
1:         props.putAll(properties);
1:         if (metadata.getRanking() == 0) {
1:             props.remove(Constants.SERVICE_RANKING);
1:         } else {
1:             props.put(Constants.SERVICE_RANKING, metadata.getRanking());
1:         }
1:         String componentName = getComponentName();
1:         if (componentName != null) {
1:             props.put(BlueprintConstants.COMPONENT_NAME_PROPERTY, componentName);
1:         } else {
1:             props.remove(BlueprintConstants.COMPONENT_NAME_PROPERTY);
1:         }
1:         for (ServiceProcessor processor : blueprintContainer.getProcessors(ServiceProcessor.class)) {
1:             processor.updateProperties(new PropertiesUpdater(), props);
1:         }
1:         registrationProperties = props;
1:         Set<String> classes = getClasses();
1:         String[] classArray = classes.toArray(new String[classes.size()]);
1:         LOGGER.debug("Registering service {} with interfaces {} and properties {}",
1:                      new Object[] { name, classes, props });
1: 
1:         if (registration.get() == null) {
1:             ServiceRegistration reg = blueprintContainer.registerService(classArray, new TriggerServiceFactory(this, metadata), props);
1:             if (!registration.compareAndSet(null, reg) && registration.get() != reg) {
0:                 reg.unregister();
1:             }
1:         ServiceRegistration reg = registration.get();
1:         if (reg != null) {
/////////////////////////////////////////////////////////////////////////
1:                 if (registration.get() != null) {
commit:4dfd2d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
commit:8c4aa3a
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.*;
0: import org.apache.aries.blueprint.proxy.FinalModifierException;
/////////////////////////////////////////////////////////////////////////
0: import static java.lang.reflect.Modifier.isFinal;
1: 
/////////////////////////////////////////////////////////////////////////
1:         private boolean isQuiesceAvailable;
0:         private boolean isAsmAvailable;
1:             this.isQuiesceAvailable = isClassAvailable("org.apache.aries.quiesce.participant.QuiesceParticipant");
0:             this.isAsmAvailable = isClassAvailable("org.objectweb.asm.ClassVisitor");
1:             Object original = ServiceRecipe.this.getService(bundle, registration);
1:             if (registeredInterceptors != null) {
1:                 interceptors.addAll(registeredInterceptors);
1:             // Add quiesce interceptor if needed
1:             if (isQuiesceAvailable)
1:             {
1:                 interceptors.add(new QuiesceInterceptor(serviceRecipe));
1:             }
1:             // Exit if no interceptors configured
1:             if (interceptors.isEmpty()) {
1:                 return original;
1:             }
0:             // If asm is not available, exit
0:             if (!isAsmAvailable) {
0:                 LOGGER.info("ASM is not available to create a proxy object. Returning the original object instead.");
1:             Object intercepted;
1:                 try {
0:                     // Try with subclass proxying first
0:                 } catch (FinalModifierException u) {
0:                     LOGGER.debug("Error creating asm proxy (final modifier), trying with interfaces");
0:                     List<Class> classes = new ArrayList<Class>();
0:                     for (String className : getClasses()) {
0:                         classes.add(blueprintContainer.loadClass(className));
1:                     }
0:                     intercepted = AsmInterceptorWrapper.createProxyObject(
0:                             original.getClass().getClassLoader(), cm,
0:                             interceptors, AsmInterceptorWrapper.passThrough(original),
0:                             classes.toArray(new Class[classes.size()]));
0:                 LOGGER.info("A problem occurred trying to create a proxy object. Returning the original object instead.", u);
/////////////////////////////////////////////////////////////////////////
1:     private boolean isClassAvailable(String clazz) {
1:         try {
1:             getClass().getClassLoader().loadClass(clazz);
1:             return true;
1:         }
1:         catch (ClassNotFoundException e) {
1:             return false;
1:         }
1:         catch (NoClassDefFoundError e) {
1:             return false;
1:         }
1:     }
1: 
commit:a215c32
/////////////////////////////////////////////////////////////////////////
1:         int state = blueprintContainer.getBundleContext().getBundle().getState();
1:         if (state != Bundle.ACTIVE && state != Bundle.STARTING) {
1:             return;
1:         }
commit:071e3fe
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.concurrent.Callable;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Object intercepted;
/////////////////////////////////////////////////////////////////////////
0:                 LOGGER
0:                         .info("A problem occurred trying to create a proxy object. Returning the original object instead.");
1:                 LOGGER.debug(LOG_EXIT, "getService", original);
1:                 return original;
0:                 Set<String> interfaces = getClasses();
0:                 // check for the case where interfaces is null or empty
0:                 if (interfaces == null || interfaces.isEmpty()) {
0:                             interceptors, AsmInterceptorWrapper.passThrough(original),
0:                             original.getClass());
1:                     LOGGER.debug(LOG_EXIT, "getService", intercepted);
1:                     return intercepted;
0:                 Class[] classesToProxy = new Class[interfaces.size()];
0:                 Iterator<String> it = interfaces.iterator();
0:                 for (int i = 0; i < interfaces.size(); i++) {
0:                     classesToProxy[i] = Class.forName(it.next(),
0:                             true, original.getClass().getClassLoader());
1:                 }
1: 
0:                 // if asm is available we can proxy the original object with
0:                 // the AsmInterceptorWrapper
0:                 intercepted = AsmInterceptorWrapper.createProxyObject(
0:                         original.getClass().getClassLoader(), cm,
0:                         interceptors, AsmInterceptorWrapper.passThrough(original),
0:                         classesToProxy);
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.Dictionary;
1: import java.util.HashSet;
1: import java.util.Hashtable;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
0: import org.apache.geronimo.blueprint.BlueprintConstants;
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.ServiceProcessor;
0: import org.apache.geronimo.blueprint.di.AbstractRecipe;
0: import org.apache.geronimo.blueprint.di.CollectionRecipe;
0: import org.apache.geronimo.blueprint.di.MapRecipe;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.Repository;
0: import org.apache.geronimo.blueprint.utils.JavaUtils;
0: import org.apache.geronimo.blueprint.utils.ReflectionUtils;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.ServiceFactory;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A <code>Recipe</code> to export services into the OSGi registry.
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 776360 $, $Date: 2009-05-19 17:40:47 +0200 (Tue, 19 May 2009) $
1:  */
1: public class ServiceRecipe extends AbstractRecipe {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRecipe.class);
1: 
0:     private final ExtendedBlueprintContainer blueprintContainer;
1:     private final ServiceMetadata metadata;
1:     private final Recipe serviceRecipe;
1:     private final CollectionRecipe listenersRecipe;
1:     private final MapRecipe propertiesRecipe;
1:     private final List<Recipe> explicitDependencies;
1: 
1:     private Map properties;
0:     private final AtomicBoolean registered = new AtomicBoolean();
0:     private volatile ServiceRegistration registration;
1:     private Map registrationProperties;
1:     private List<ServiceListener> listeners;
1:     private volatile Object service;
1:     
1:     public ServiceRecipe(String name,
0:                          ExtendedBlueprintContainer blueprintContainer,
1:                          ServiceMetadata metadata,
1:                          Recipe serviceRecipe,
1:                          CollectionRecipe listenersRecipe,
1:                          MapRecipe propertiesRecipe,
1:                          List<Recipe> explicitDependencies) {
1:         super(name);
1:         this.prototype = false;
1:         this.blueprintContainer = blueprintContainer;
1:         this.metadata = metadata;
1:         this.serviceRecipe = serviceRecipe;
1:         this.listenersRecipe = listenersRecipe;
1:         this.propertiesRecipe = propertiesRecipe;
1:         this.explicitDependencies = explicitDependencies;
1:     }
1:     
1:     public Recipe getServiceRecipe() {
1:         return serviceRecipe;
1:     }
1: 
1:     public CollectionRecipe getListenersRecipe() {
1:         return listenersRecipe;
1:     }
1: 
1:     @Override
1:     public List<Recipe> getConstructorDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         if (explicitDependencies != null) {
1:             recipes.addAll(explicitDependencies);
1:         }
1:         return recipes;
1:     }
1:     
1:     public List<Recipe> getDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         if (serviceRecipe != null) {
1:             recipes.add(serviceRecipe);
1:         }
1:         if (listenersRecipe != null) {
1:             recipes.add(listenersRecipe);
1:         }
1:         if (propertiesRecipe != null) {
1:             recipes.add(propertiesRecipe);
1:         }        
1:         recipes.addAll(getConstructorDependencies());        
1:         return recipes;
1:     }
1: 
1:     protected Object internalCreate() throws ComponentDefinitionException {
1:         ServiceRegistrationProxy proxy = new ServiceRegistrationProxy();
1:         addPartialObject(proxy);
1:         internalGetService(null, null); // null bundle means we don't want to retrieve the actual service when used with a ServiceFactory
1:         return proxy;
1:     }
1: 
1:     public boolean isRegistered() {
0:         return registered.get();
1:     }
1: 
1:     public void register() {
0:         if (registered.compareAndSet(false, true)) {
0:             createExplicitDependencies();
1:             
0:             Hashtable props = new Hashtable();
0:             if (properties == null) {
0:                 properties = (Map) createRecipe(propertiesRecipe);
1:             }
0:             props.putAll(properties);
0:             if (metadata.getRanking() == 0) {
0:                 props.remove(Constants.SERVICE_RANKING);
1:             } else {
0:                 props.put(Constants.SERVICE_RANKING, metadata.getRanking());
1:             }
0:             String componentName = getComponentName();
0:             if (componentName != null) {
0:                 props.put(BlueprintConstants.COMPONENT_NAME_PROPERTY, componentName);
1:             } else {
0:                 props.remove(BlueprintConstants.COMPONENT_NAME_PROPERTY);
1:             }
0:             for (ServiceProcessor processor : blueprintContainer.getProcessors(ServiceProcessor.class)) {
0:                 processor.updateProperties(new PropertiesUpdater(), props);
1:             }
1: 
1:             Set<String> classes = getClasses();
0:             String[] classArray = classes.toArray(new String[classes.size()]);
1: 
0:             LOGGER.debug("Registering service {} with interfaces {} and properties {}",
0:                          new Object[] { name, classes, props });
1: 
0:             registrationProperties = props;
0:             registration = blueprintContainer.registerService(classArray, new TriggerServiceFactory(), props);            
1:         }
1:     }
1: 
1:     public void unregister() {
0:         if (registered.compareAndSet(true, false)) {
1:             LOGGER.debug("Unregistering service {}", name);
1:             // This method needs to allow reentrance, so if we need to make sure the registration is
1:             // set to null before actually unregistering the service
0:             ServiceRegistration reg = registration;
0:             if (listeners != null) {
1:                 LOGGER.debug("Calling listeners for service unregistration");
1:                 for (ServiceListener listener : listeners) {
1:                     listener.unregister(service, registrationProperties);
1:                 }
1:             }
0:             if (reg != null) {
0:                 reg.unregister();
1:             }
0:             // We need to do this hack in order to support reantrancy
0:             if (registration == reg) {
0:                 registration = null;
1:             }
1:         }
1:     }
1: 
1:     protected ServiceReference getReference() {
0:         if (registration == null) {
1:             throw new IllegalStateException("Service is not registered");
1:         } else {
0:             return registration.getReference();
1:         }
1:     }
1: 
1:     protected void setProperties(Dictionary props) {
0:         if (registration == null) {
1:             throw new IllegalStateException("Service is not registered");
1:         } else {
0:             registration.setProperties(props);
1:             // TODO: set serviceProperties? convert somehow? should listeners be notified of this?
1:         }
1:     }
1: 
1: 
1:     protected Object internalGetService() {
1:         return internalGetService(blueprintContainer.getBundleContext().getBundle(), null);
1:     }
1: 
1:     /**
1:      * Create the service object.
0:      * We need to synchronize the access to the repository,
0:      * but not on this ServiceRecipe instance to avoid deadlock.
0:      * When using internalCreate(), no other lock but the on the repository
0:      * should be held.
1:      *
1:      * @param bundle
1:      * @param registration
1:      * @return
1:      */
1:     private Object internalGetService(Bundle bundle, ServiceRegistration registration) {
1:         LOGGER.debug("Retrieving service for bundle {} and service registration {}", bundle, registration);
0:         if (this.service == null) {
0:             synchronized (blueprintContainer.getRepository().getInstanceLock()) {
0:                 if (this.service == null) {
0:                     createService();
1:                 }
1:             }
1:         }
1:         Object service = this.service;
1:         // We need the real service ...
1:         if (bundle != null) {
1:             if (service instanceof ServiceFactory) {
1:                 service = ((ServiceFactory) service).getService(bundle, registration);
1:             }
1:             if (service == null) {
1:                 throw new IllegalStateException("service is null");
1:             }
1:             // Check if the service actually implement all the requested interfaces
1:             validateClasses(service);
1:         // We're not really interested in the service, but perform some sanity checks nonetheless
1:         } else {
1:              if (!(service instanceof ServiceFactory)) {
1:                  // Check if the service actually implement all the requested interfaces
1:                  validateClasses(service);
1:              }
1:         }
1:         return service;
1:     }
1: 
1:     private void createService() {
1:         try {
0:             LOGGER.debug("Creating service instance");
0:             service = createRecipe(serviceRecipe);
0:             LOGGER.debug("Service created: {}", service);
1:             // When the service is first requested, we need to create listeners and call them
0:             if (listeners == null) {
1:                 LOGGER.debug("Creating listeners");
1:                 if (listenersRecipe != null) {
1:                     listeners = (List) createRecipe(listenersRecipe);
1:                 } else {
1:                     listeners = Collections.emptyList();
1:                 }
1:                 LOGGER.debug("Listeners created: {}", listeners);
0:                 if (registered.get()) {
1:                     LOGGER.debug("Calling listeners for initial service registration");
1:                     for (ServiceListener listener : listeners) {
0:                         listener.register(service, registrationProperties);
1:                     }
1:                 } else {
1:                     LOGGER.debug("Calling listeners for initial service unregistration");
1:                     for (ServiceListener listener : listeners) {
1:                         listener.unregister(service, registrationProperties);
1:                     }
1:                 }
1:             }
1:         } catch (RuntimeException e) {
1:             LOGGER.error("Error retrieving service from " + this, e);
1:             throw e;
1:         }
1:     }
1:     
1:     private void validateClasses(Object service) {
1:         // Check if the service actually implement all the requested interfaces
1:         if (metadata.getAutoExport() == ServiceMetadata.AUTO_EXPORT_DISABLED) {
1:             Set<String> allClasses = new HashSet<String>();
1:             ReflectionUtils.getSuperClasses(allClasses, service.getClass());
1:             ReflectionUtils.getImplementedInterfaces(allClasses, service.getClass());
1:             Set<String> classes = getClasses();
1:             classes.removeAll(allClasses);
1:             if (!classes.isEmpty()) {
1:                 throw new ComponentDefinitionException("The service implementation does not implement the required interfaces: " + classes);
1:             }
1:         }
1:     }
1: 
0:     public synchronized Object getService(Bundle bundle, ServiceRegistration registration) {
1:         /** getService() can get called before registerService() returns with the registration object.
1:          *  So we need to set the registration object in case registration listeners call 
1:          *  getServiceReference(). 
1:          */
0:         if (this.registration == null) {
0:             this.registration = registration;
1:         }
1:         return internalGetService(bundle, registration);
1:     }
1: 
0:     public synchronized void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
1:         if (this.service instanceof ServiceFactory) {
1:             ((ServiceFactory) this.service).ungetService(bundle, registration, service);
1:         }
1:     }
1: 
1:     private Set<String> getClasses() {
1:         Set<String> classes;
1:         switch (metadata.getAutoExport()) {
1:             case ServiceMetadata.AUTO_EXPORT_INTERFACES:
1:                 classes = ReflectionUtils.getImplementedInterfaces(new HashSet<String>(), internalGetService().getClass());
1:                 break;
1:             case ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY:
1:                 classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), internalGetService().getClass());
1:                 break;
1:             case ServiceMetadata.AUTO_EXPORT_ALL_CLASSES:
1:                 classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), internalGetService().getClass());
1:                 classes = ReflectionUtils.getImplementedInterfaces(classes, internalGetService().getClass());
1:                 break;
1:             default:
1:                 classes = new HashSet<String>(metadata.getInterfaces());
1:                 break;
1:         }
1:         return classes;
1:     }
1: 
1:     private void createExplicitDependencies() {
1:         if (explicitDependencies != null) {
1:             for (Recipe recipe : explicitDependencies) {
1:                 createRecipe(recipe);
1:             }
1:         }
1:     }
1:     
1:     private Object createRecipe(Recipe recipe) {
1:         String name = recipe.getName();
1:         Repository repo = blueprintContainer.getRepository();
1:         if (repo.getRecipe(name) != recipe) {
1:             repo.putRecipe(name, recipe);
1:         }
1:         return repo.create(name);
1:     }
1:    
1:     private String getComponentName() {
1:         if (metadata.getServiceComponent() instanceof RefMetadata) {
1:             RefMetadata ref = (RefMetadata) metadata.getServiceComponent();
1:             return ref.getComponentId();
1:         } else {
1:             return null;
1:         }
1:     }
1: 
0:     private class TriggerServiceFactory implements ServiceFactory {
1: 
1:         public Object getService(Bundle bundle, ServiceRegistration registration) {
0:             return ServiceRecipe.this.getService(bundle, registration);
1:         }
1: 
1:         public void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
1:             ServiceRecipe.this.ungetService(bundle, registration, service);
1:         }
1: 
1:     }
1: 
1:     private class ServiceRegistrationProxy implements ServiceRegistration {
1: 
1:         public ServiceReference getReference() {
1:             return ServiceRecipe.this.getReference();
1:         }
1: 
1:         public void setProperties(Dictionary properties) {
1:             ServiceRecipe.this.setProperties(properties);
1:         }
1: 
1:         public void unregister() {
1:             throw new UnsupportedOperationException();
1:         }
1:     }
1: 
1:     private class PropertiesUpdater implements ServiceProcessor.ServicePropertiesUpdater {
1: 
1:         public String getId() {
1:             return metadata.getId();
1:         }
1: 
1:         public void updateProperties(Dictionary properties) {
1:             Hashtable table = JavaUtils.getProperties(ServiceRecipe.this.getReference());
1:             JavaUtils.copy(table, properties);
1:             ServiceRecipe.this.setProperties(table);
1:         }        
1:     }
1: 
1: }
author:Jeremy Hughes
-------------------------------------------------------------------------------
commit:30d612a
/////////////////////////////////////////////////////////////////////////
1:                         if (holder.unwrapperedBean instanceof ServiceFactory) {
1:                             //If a service factory is used, make sure the proxy classes implement this
1:                             //interface so that later on, internalGetService will create the real
1:                             //service from it.
1:                             LOGGER.debug("{} implements ServiceFactory, creating proxy that also implements this", holder.unwrapperedBean);
1:                             Collection<Class<?>> cls = getClassesForProxying(holder.unwrapperedBean);
1:                             cls.add(blueprintContainer.loadClass("org.osgi.framework.ServiceFactory"));
1:                             o = BeanRecipe.wrap(holder, cls);
0:                         } else {
0:                             validateClasses(holder.unwrapperedBean);
0:                             o = BeanRecipe.wrap(holder, getClassesForProxying(holder.unwrapperedBean));
0:                         }
1:                     } else if (!(o instanceof ServiceFactory)) {
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5e2bd49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.container.AggregateConverter.Convertible;
1: import org.apache.aries.blueprint.container.BeanRecipe.UnwrapperedBeanHolder;
1: import org.apache.aries.blueprint.di.ExecutionContext;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.container.ReifiedType;
/////////////////////////////////////////////////////////////////////////
0:             //We can't use the BlueprintRepository because we don't know what interfaces
0:             //to use yet! We have to be a bit smarter.
0:             ExecutionContext old = ExecutionContext.Holder.setContext(blueprintContainer.getRepository());
1:            
0:             try {
0:             	Object o = serviceRecipe.create();
1:             
0:             	if (o instanceof Convertible) {
0:             		o = blueprintContainer.getRepository().convert(o, new ReifiedType(Object.class));
0:                     validateClasses(o);
0:             	} else if (o instanceof UnwrapperedBeanHolder) {
0:                     UnwrapperedBeanHolder holder = (UnwrapperedBeanHolder) o;
0:                     validateClasses(holder.unwrapperedBean);
0:                     o = BeanRecipe.wrap(holder, getClassesForProxying(holder.unwrapperedBean));
0:                 } else {
0:                     validateClasses(o);
0:                 }
0:             	service = o;
0: 			} catch (Exception e) {
0: 				LOGGER.error("Error retrieving service from " + this, e);
0: 				throw new ComponentDefinitionException(e);
0: 			} finally {
0: 				ExecutionContext.Holder.setContext(old);
0: 			}
1:             
/////////////////////////////////////////////////////////////////////////
1:             //This call is safe because we know that we don't need to call internalGet to get the answer
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Be careful to avoid calling this method from internalGetService or createService before the service
1:      * field has been set. If you get this wrong you will get a StackOverflowError!
1:      * @return
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * Note that we use a template object here because we have already instantiated the bean
1:      * that we're going to proxy. We can't call internalGetService because it would Stack Overflow.
1:     private Collection<Class<?>> getClassesForProxying(Object template) throws ClassNotFoundException {
1:               classes = ReflectionUtils.getImplementedInterfacesAsClasses(new HashSet<Class<?>>(), template.getClass());
1:             classes = ProxyUtils.asList(template.getClass());
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:                         getClassesForProxying(original), original, collaborator);
commit:e2445d0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.utils.ServiceListener;
commit:109b82f
/////////////////////////////////////////////////////////////////////////
0:     /** Only ever access when holding a lock on <code>this</code> */
0:     /** Only ever access when holding a lock on <code>this</code> */
1:     private Collection<DestroyCallback> destroyCallbacks = new ArrayList<DestroyCallback>();
/////////////////////////////////////////////////////////////////////////
0:     	  synchronized(this) 
1:     	  {
0:     		    activeCalls++;	
0: 		    }
1:   	protected void decrementActiveCalls() 
1:   	{
0:   	    List<DestroyCallback> callbacksToCall = new ArrayList<DestroyCallback>();
0:       	synchronized(this) 
1:       	{
0:       	    activeCalls--;
0:   			    if(quiesce && activeCalls == 0) {
0:   			        callbacksToCall.addAll(destroyCallbacks);
0:   			        destroyCallbacks.clear();
0:   			    }
0:       	}
0:       	if(!!!callbacksToCall.isEmpty()) {
0:       	    for(DestroyCallback cbk : callbacksToCall)
0:       	        cbk.callback();
0:       	}
0:   	}
0:     	  unregister();
0:     	  int calls;
0:     	  synchronized (this) {
0:             if(activeCalls != 0)
0:               destroyCallbacks.add(destroyCallback);
0:     	      quiesce = true;
0:             calls = activeCalls;
0:         }
0:     	  if(calls == 0) {
0:     	      destroyCallback.callback();
0:     	  }
commit:6726c3e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the classes we need to proxy, for auto-export interfaces only, those 
1:      * will be just the interfaces implemented by the bean, for auto-export classes
1:      * or everything, then just proxying the real bean class will give us everything we
1:      * need, if none of the above then we need the class forms of the interfaces in
1:      * the metadata
1:      * @return
1:      * @throws ClassNotFoundException
1:      */
0:     private Collection<Class<?>> getClassesForProxying() throws ClassNotFoundException {
1:       Collection<Class<?>> classes;
1:       switch (metadata.getAutoExport()) {
1:           case ServiceMetadata.AUTO_EXPORT_INTERFACES:
0:               classes = ReflectionUtils.getImplementedInterfacesAsClasses(new HashSet<Class<?>>(), internalGetService().getClass());
1:               break;
1:           case ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY:
1:           case ServiceMetadata.AUTO_EXPORT_ALL_CLASSES:
0:             classes = ProxyUtils.asList(internalGetService().getClass());
1:               break;
1:           default:
1:               classes = new HashSet<Class<?>>(convertStringsToClasses(metadata.getInterfaces()));
1:               break;
0:       }
1:       return classes;
0:   }
1: 
1:     private Collection<? extends Class<?>> convertStringsToClasses(
1:         List<String> interfaces) throws ClassNotFoundException {
1:       Set<Class<?>> classes = new HashSet<Class<?>>();
1:       for(String s : interfaces) {
1:         classes.add(blueprintContainer.loadClass(s)); 
0:       }
1:       return classes;
0:     }
/////////////////////////////////////////////////////////////////////////
1: 
0:                 intercepted = BlueprintExtender.getProxyManager().createInterceptingProxy(b, 
0:                         getClassesForProxying(), original, collaborator);
1:             } catch (Exception u) {
commit:69e59b8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.InvocationListener;
/////////////////////////////////////////////////////////////////////////
0:                 InvocationListener collaborator = new Collaborator(cm, interceptors);
0:                     intercepted = BlueprintExtender.getProxyManager().createInterceptingProxy(b, 
0:                         ProxyUtils.asList(original.getClass()), original, collaborator);
0:                     intercepted = BlueprintExtender.getProxyManager().createInterceptingProxy(b, 
0:                         classes, original, collaborator);
commit:047a2ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.AriesFrameworkUtil;
/////////////////////////////////////////////////////////////////////////
1:             AriesFrameworkUtil.safeUnregisterService(reg);
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:4bdcda3
/////////////////////////////////////////////////////////////////////////
1:     private final BlueprintContainerImpl blueprintContainer;
/////////////////////////////////////////////////////////////////////////
1:                          BlueprintContainerImpl blueprintContainer,
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:88a0e3f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             createService();
commit:3ed12df
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicReference<ServiceRegistration> registration = new AtomicReference<ServiceRegistration>();
/////////////////////////////////////////////////////////////////////////
0:             registration.set(blueprintContainer.registerService(classArray, new TriggerServiceFactory(), props));            
/////////////////////////////////////////////////////////////////////////
1:             ServiceRegistration reg = registration.get();
/////////////////////////////////////////////////////////////////////////
1:             
1:             registration.compareAndSet(reg, null);
1:     	ServiceRegistration reg = registration.get();
1:         if (reg == null) {
1:             return reg.getReference();
1:     	ServiceRegistration reg = registration.get();
1:         if (reg == null) {
1:             reg.setProperties(props);
/////////////////////////////////////////////////////////////////////////
0:         
0:         	if (service instanceof ServiceFactory) {
0:         		service = ((ServiceFactory) service).getService(bundle, registration);
0:         	}
0:         	if (service == null) {
0:         		throw new IllegalStateException("service is null");
0:         	}
0:         	// Check if the service actually implement all the requested interfaces
0:         	validateClasses(service);
0:         	// We're not really interested in the service, but perform some sanity checks nonetheless
0:         	if (!(service instanceof ServiceFactory)) {
0:         		// Check if the service actually implement all the requested interfaces
0:         		validateClasses(service);
0:         	}
0:         
/////////////////////////////////////////////////////////////////////////
1:     public Object getService(Bundle bundle, ServiceRegistration registration) {
1:     	this.registration.compareAndSet(null, registration);
1:     public void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:ef2091c
/////////////////////////////////////////////////////////////////////////
1:                 if (b == null) {
1:                   // we have a class from the framework parent, so use our bundle for proxying.
1:                   b = blueprintContainer.getBundleContext().getBundle();
0:                 }
/////////////////////////////////////////////////////////////////////////
1:                 Bundle b = blueprintContainer.getBundleContext().getBundle();
0:                 LOGGER.info("Unable to create a proxy object for the service " + getName() + " defined in bundle " + b.getSymbolicName() + " at version " + b.getVersion() + " with id " + b.getBundleId() + ". Returning the original object instead.", u);
commit:5254613
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:24455ce
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.BlueprintConstants;
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.Interceptor;
1: import org.apache.aries.blueprint.ServiceProcessor;
0: import org.apache.aries.blueprint.proxy.Collaborator;
1: import org.apache.aries.blueprint.proxy.ProxyUtils;
0: import org.apache.aries.proxy.InvocationHandlerWrapper;
1: import org.osgi.framework.FrameworkUtil;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 Bundle b = FrameworkUtil.getBundle(original.getClass());
0:                 Callable<Object> target = ProxyUtils.passThrough(original);
0:                 InvocationHandlerWrapper collaborator = new Collaborator(cm, interceptors);
0:                     intercepted = BlueprintExtender.getProxyManager().createProxy(b, 
0:                         ProxyUtils.asList(original.getClass()), target, collaborator);
0:                 } catch (org.apache.aries.proxy.FinalModifierException u) {
0:                     List<Class<?>> classes = new ArrayList<Class<?>>();
0:                     intercepted = BlueprintExtender.getProxyManager().createProxy(b, 
0:                         classes, target, collaborator);
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:72d8402
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
/////////////////////////////////////////////////////////////////////////
0:             //check for any registered interceptors for this metadata
1:             ComponentDefinitionRegistry reg = blueprintContainer.getComponentDefinitionRegistry();
1:             List<Interceptor> registeredInterceptors = reg.getInterceptors(cm);
0:             //add the registered interceptors to the list of interceptors
0:             if (registeredInterceptors != null && registeredInterceptors.size()>0){
0:               interceptors.addAll(registeredInterceptors);
0:             }
0:             
author:Lin Sun
-------------------------------------------------------------------------------
commit:8f4d7a3
/////////////////////////////////////////////////////////////////////////
1:     final static String LOG_ENTRY = "Method entry: {}, args {}";
1:     final static String LOG_EXIT = "Method exit: {}, returning {}";
/////////////////////////////////////////////////////////////////////////
1:     	private ServiceMetadata sm;
1:     	public TriggerServiceFactory(ServiceRecipe serviceRecipe, ServiceMetadata cm)
1:     		this.sm = cm;
0:         public Object getService(Bundle bundle, ServiceRegistration registration) {
0:             Object original = ServiceRecipe.this.getService(bundle,
0:                     registration);
1:             LOGGER.debug(LOG_ENTRY, "getService", original);
0:             Object intercepted = null;
0: 
0:             if (interceptor == null) {
0:                 interceptor = new QuiesceInterceptor(serviceRecipe);
0: 
0: 
0:             try {
0:             } catch (Throwable t) {
0:                 try {
0:                 } catch (Throwable u) {
0:                     LOGGER
0:                             .info("A problem occurred trying to create a proxy object. Returning the original object instead.");
0:                     LOGGER.debug(LOG_EXIT, "getService", original);
0:                     return original;
0: 
0:             try {
0:                 if (asmAvailable) {
0:                     List<String> interfaces = sm.getInterfaces();
0: 
0:                     // check for the case where interfaces is null or empty
0:                     if (interfaces == null || interfaces.isEmpty()) {
0:                         intercepted = AsmInterceptorWrapper.createProxyObject(
0:                                 original.getClass().getClassLoader(), cm,
0:                                 interceptors, original, original.getClass());
0:                         LOGGER.debug(LOG_EXIT, "getService", intercepted);
0:                         return intercepted;
0:                     }
0:                     Class[] classesToProxy = new Class[interfaces.size()];
0:                     for (int i = 0; i < interfaces.size(); i++) {
0:                         classesToProxy[i] = Class.forName(interfaces.get(i),
0:                                 true, original.getClass().getClassLoader());
0:                     }
0: 
0:                     // if asm is available we can proxy the original object with
0:                     // the
0:                     // AsmInterceptorWrapper
0:                     intercepted = AsmInterceptorWrapper.createProxyObject(
0:                             original.getClass().getClassLoader(), cm,
0:                             interceptors, original, classesToProxy);
0:                 } else if (cglibAvailable) {
0:                     LOGGER.debug("cglib available for interceptors");
0:                     // otherwise we're using cglib and need to use the
0:                     // interfaces
0:                     // with the CgLibInterceptorWrapper
0:                     intercepted = CgLibInterceptorWrapper.createProxyObject(
0:                             original.getClass().getClassLoader(), cm,
0:                             interceptors, original, original.getClass()
0:                                     .getInterfaces());
0:                 } else {
0:                     LOGGER.debug(LOG_EXIT, "getService", original);
0:                     return original;
0:                 }
0:             } catch (Throwable u) {
0:                 LOGGER
0:                         .info("A problem occurred trying to create a proxy object. Returning the original object instead.");
0:                 LOGGER.debug(LOG_EXIT, "getService", original);
0:                 return original;
0: 
0:             LOGGER.debug(LOG_EXIT, "getService", intercepted);
author:Holly Cummins
-------------------------------------------------------------------------------
commit:da163d0
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.Interceptor;
0: import org.apache.aries.blueprint.proxy.AsmInterceptorWrapper;
0: import org.apache.aries.blueprint.proxy.CgLibInterceptorWrapper;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
/////////////////////////////////////////////////////////////////////////
0:     private int activeCalls;
0:     private boolean quiesce;
0:     private DestroyCallback destroyCallback;
/////////////////////////////////////////////////////////////////////////
0:             registration.set(blueprintContainer.registerService(classArray, new TriggerServiceFactory(this, metadata), props));            
/////////////////////////////////////////////////////////////////////////
1:     protected void incrementActiveCalls()
1:     {
0:     	synchronized(this) 
1:     	{
0:     		activeCalls++;	
0: 		}
0:     }
0:     
0: 	protected void decrementActiveCalls() 
1: 	{
0: 		
0:     	synchronized(this) 
1:     	{
0:     		activeCalls--;
0: 			if (quiesce && activeCalls == 0)
1: 			{
0: 				destroyCallback.callback(service);
0: 			}
0:     	}
0: 	}
0: 	
1:     public void quiesce(DestroyCallback destroyCallback)
1:     {
0:     	this.destroyCallback = destroyCallback;
0:     	quiesce = true;
0:     	unregister();
0:     	if(activeCalls == 0)
1: 		{
0: 			destroyCallback.callback(service);
0: 		}
0:     }
0:      
1:     private class TriggerServiceFactory implements ServiceFactory 
1:     {
0:     	private QuiesceInterceptor interceptor;
1:     	private ServiceRecipe serviceRecipe;
1:     	private ComponentMetadata cm;
0:     	public TriggerServiceFactory(ServiceRecipe serviceRecipe, ComponentMetadata cm)
1:     	{
1:     		this.serviceRecipe = serviceRecipe;
1:     		this.cm = cm;
0:     	}
0:     	
0:         public Object getService(Bundle bundle, ServiceRegistration registration) 
1:         {
0:         	Object original = ServiceRecipe.this.getService(bundle, registration);
0:         	Object intercepted = null;
0:             boolean asmAvailable = false;
0:             boolean cglibAvailable = false;
0:             
0:             if (interceptor == null)
1:             {
0:             	interceptor = new QuiesceInterceptor(serviceRecipe);
0:             }
0:             
1:             List<Interceptor> interceptors = new ArrayList<Interceptor>();
0:             interceptors.add(interceptor);
0:             
0:             try 
1:             {
0:                 // Try load load an asm class (to make sure it's actually
0:                 // available)
0:                 getClass().getClassLoader().loadClass(
0:                         "org.objectweb.asm.ClassVisitor");
0:                 LOGGER.debug("asm available for interceptors");
0:                 asmAvailable = true;
0:             } 
0:             catch (Throwable t) 
1:             {
0:                 try 
1:                 {
0:                     // Try load load a cglib class (to make sure it's actually
0:                     // available)
0:                     getClass().getClassLoader().loadClass(
0:                             "net.sf.cglib.proxy.Enhancer");
0:                     cglibAvailable = true;
0:                 } 
0:                 catch (Throwable u) 
1:                 {
0:                 	LOGGER.info("No quiesce support is available, so blueprint components will not participate in quiesce operations");
0:                 	return original;
0:                 }
0:             }
0:             
0:             try
1:             {
0: 	            if (asmAvailable) 
1: 	            {
0: 	                // if asm is available we can proxy the original object with the
0: 	                // AsmInterceptorWrapper
0: 	                intercepted = AsmInterceptorWrapper.createProxyObject(original
0: 	                        .getClass().getClassLoader(), cm, interceptors,
0: 	                        original, original.getClass());
0: 	            } 
0: 	            else if (cglibAvailable)
1: 	            {
0: 	                LOGGER.debug("cglib available for interceptors");
0: 	                // otherwise we're using cglib and need to use the interfaces
0: 	                // with the CgLibInterceptorWrapper
0: 	                intercepted = CgLibInterceptorWrapper.createProxyObject(
0: 	                        original.getClass().getClassLoader(), cm,
0: 	                        interceptors, original, original.getClass()
0: 	                                .getInterfaces());
0: 	            }
0: 	            else
1: 	            {
0: 	            	return original;
0: 	            }
0:             }
0:             catch (Throwable u) 
1:             {
0:             	LOGGER.info("No quiesce support is available, so blueprint components will not participate in quiesce operations");
0:             	return original;
0:             }
0:             
0:             return intercepted;
0: 
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:69489a8
/////////////////////////////////////////////////////////////////////////
0:             registrationProperties = props;
0: 
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.BlueprintConstants;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
0: import org.apache.aries.blueprint.ServiceProcessor;
1: import org.apache.aries.blueprint.di.AbstractRecipe;
1: import org.apache.aries.blueprint.di.CollectionRecipe;
1: import org.apache.aries.blueprint.di.MapRecipe;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.Repository;
1: import org.apache.aries.blueprint.utils.JavaUtils;
1: import org.apache.aries.blueprint.utils.ReflectionUtils;
============================================================================