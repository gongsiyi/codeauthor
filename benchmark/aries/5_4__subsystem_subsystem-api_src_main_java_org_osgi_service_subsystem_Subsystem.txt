1:6f4b079: /*
1:d6eb080:  * Copyright (c) OSGi Alliance (2012, 2013). All Rights Reserved.
1:ead9c04:  * 
1:6c6c8a4:  * Licensed under the Apache License, Version 2.0 (the "License");
1:6c6c8a4:  * you may not use this file except in compliance with the License.
1:6c6c8a4:  * You may obtain a copy of the License at
1:b1d7587:  *
1:6c6c8a4:  *      http://www.apache.org/licenses/LICENSE-2.0
6:2e06be4:  *
1:6c6c8a4:  * Unless required by applicable law or agreed to in writing, software
1:6c6c8a4:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6c6c8a4:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6c6c8a4:  * See the License for the specific language governing permissions and
1:6c6c8a4:  * limitations under the License.
5:6f4b079:  */
1:452554c: 
1:b1d7587: package org.osgi.service.subsystem;
1:1c9c28b: 
1:6f4b079: import java.io.InputStream;
1:6c6c8a4: import java.util.Collection;
1:1c9c28b: import java.util.Locale;
1:6c6c8a4: import java.util.Map;
1:d6eb080: import org.osgi.annotation.versioning.ProviderType;
1:1c9c28b: import org.osgi.framework.BundleContext;
1:6c6c8a4: import org.osgi.framework.Version;
1:a1c6951: import org.osgi.framework.namespace.IdentityNamespace;
1:71fe81a: import org.osgi.resource.Resource;
1:1c9c28b: 
5:6f4b079: /**
1:1c9c28b:  * A subsystem is a collection of resources constituting a logical, possibly
1:1c9c28b:  * isolated, unit of functionality.
1:452554c:  * 
1:452554c:  * <p>
1:452554c:  * A subsystem may be <i>scoped</i> or <i>unscoped</i>. Scoped subsystems are
1:452554c:  * isolated by implicit or explicit sharing policies. Unscoped subsystems are
1:452554c:  * not isolated and, therefore, have no sharing policy. There are three standard
1:a1c6951:  * {@link SubsystemConstants#SUBSYSTEM_TYPE types} of subsystems.
1:a1c6951:  * <ul>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application} - An
1:a1c6951:  * implicitly scoped subsystem. Nothing is exported, and imports are computed
1:aac6a2a:  * based on any unsatisfied content requirements.</li>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite} - An
1:a1c6951:  * explicitly scoped subsystem. The sharing policy is defined by metadata within
1:a1c6951:  * the subsystem archive.</li>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature} - An unscoped
1:a1c6951:  * subsystem.</li>
1:a1c6951:  * </ul>
1:1c9c28b:  * Conceptually, a subsystem may be thought of as existing in an isolated region
1:1c9c28b:  * along with zero or more other subsystems. Each region has one and only one
1:1c9c28b:  * scoped subsystem, which dictates the sharing policy. The region may, however,
1:1c9c28b:  * have many unscoped subsystems. It is, therefore, possible to have shared
1:1c9c28b:  * constituents across multiple subsystems within a region. Associated with each
1:1c9c28b:  * region is a bundle whose context may be {@link #getBundleContext() retrieved}
1:1c9c28b:  * from any subsystem within that region. This context may be used to monitor
1:1c9c28b:  * activity occurring within the region.
1:452554c:  * 
1:452554c:  * <p>
1:1c9c28b:  * A subsystem may have {@link #getChildren() children} and, unless it's the
1:1c9c28b:  * root subsystem, must have at least one {@link #getParents() parent}.
1:1c9c28b:  * Subsystems become children of the subsystem in which they are installed.
1:1c9c28b:  * Unscoped subsystems have more than one parent if they are installed in more
1:aac6a2a:  * than one subsystem within the same region. The subsystem graph may be thought
1:452554c:  * of as an <a
1:452554c:  * href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">acyclic
1:452554c:  * digraph</a> with one and only one source vertex, which is the root subsystem.
1:452554c:  * The edges have the child as the head and parent as the tail.
1:452554c:  * 
1:452554c:  * <p>
1:aac6a2a:  * A subsystem has several identifiers.
2:1c9c28b:  * <ul>
1:a1c6951:  * <li>{@link #getLocation() Location} - An identifier specified by the client
1:a1c6951:  * as part of installation. It is guaranteed to be unique within the same
1:a1c6951:  * framework.</li>
1:a1c6951:  * <li>{@link #getSubsystemId() ID} - An identifier generated by the
1:a1c6951:  * implementation as part of installation. It is guaranteed to be unique within
1:d6eb080:  * the same framework.</li>
1:a1c6951:  * <li>{@link #getSymbolicName() Symbolic Name}/{@link #getVersion() Version} -
1:a1c6951:  * The combination of symbolic name and version is guaranteed to be unique
1:a1c6951:  * within the same region. Although {@link #getType() type} is not formally part
1:a1c6951:  * of the identity, two subsystems with the same symbolic names and versions but
1:a1c6951:  * different types are not considered to be equal.</li>
2:1c9c28b:  * </ul>
1:1c9c28b:  * A subsystem has a well-defined {@link State life cycle}. Which stage a
1:1c9c28b:  * subsystem is in may be obtained from the subsystem's {@link #getState()
1:1c9c28b:  * state} and is dependent on which life cycle operation is currently active or
1:452554c:  * was last invoked.
1:452554c:  * 
1:452554c:  * <p>
1:452554c:  * A subsystem archive is a ZIP file having an {@code .esa} extension and
1:452554c:  * containing metadata describing the subsystem. The form of the metadata may be
1:452554c:  * a subsystem or deployment manifest, as well as any content resource files.
1:452554c:  * The manifests are optional and will be computed if not present. The subsystem
1:1c9c28b:  * manifest headers may be {@link #getSubsystemHeaders(Locale) retrieved} in raw
1:452554c:  * or localized forms. There are five standard
1:a1c6951:  * {@link IdentityNamespace#CAPABILITY_TYPE_ATTRIBUTE types} of resources that
1:a1c6951:  * may be included in a subsystem.
1:1c9c28b:  * <ul>
1:a1c6951:  * <li>{@link IdentityNamespace#TYPE_BUNDLE Bundle} - A bundle that is not a
1:a1c6951:  * fragment.</li>
1:a1c6951:  * <li>{@link IdentityNamespace#TYPE_FRAGMENT Fragment} - A fragment bundle.</li>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application
1:452554c:  * Subsystem} - An application subsystem.</li>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite Subsystem} -
1:452554c:  * A composite subsystem.</li>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature Subsystem} - A
1:452554c:  * feature subsystem.</li>
1:1c9c28b:  * </ul>
1:1c9c28b:  * Resources contained by a subsystem are called {@link #getConstituents()
1:1c9c28b:  * constituents}. There are several ways a resource may become a constituent of
1:452554c:  * a subsystem:
1:1c9c28b:  * <ul>
1:452554c:  * <li>A resource is listed as part of the subsystem's content.</li>
1:a1c6951:  * <li>A subsystem resource is a child of the subsystem.</li>
1:a1c6951:  * <li>The subsystem has a provision policy of accept dependencies.</li>
1:452554c:  * <li>A bundle resource is installed using the region bundle context.</li>
1:452554c:  * <li>A bundle resource is installed using the bundle context of another
1:a1c6951:  * resource contained by the subsystem.</li>
1:1c9c28b:  * </ul>
1:452554c:  * 
1:452554c:  * <p>
1:1c9c28b:  * In addition to invoking one of the install methods, a subsystem instance may
1:452554c:  * be obtained through the service registry. Each installed subsystem has a
1:1c9c28b:  * corresponding service registration. A subsystem service has the following
1:1c9c28b:  * properties.
1:452554c:  * 
1:1c9c28b:  * <ul>
1:452554c:  * <li>{@link SubsystemConstants#SUBSYSTEM_ID_PROPERTY ID} - The ID of the
1:452554c:  * subsystem.</li>
1:a1c6951:  * <li>{@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME_PROPERTY Symbolic Name}
1:452554c:  * - The symbolic name of the subsystem.</li>
1:452554c:  * <li>{@link SubsystemConstants#SUBSYSTEM_VERSION_PROPERTY Version} - The
1:452554c:  * version of the subsystem.</li>
1:452554c:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_PROPERTY Type} - The type of the
1:452554c:  * subsystem.</li>
1:452554c:  * <li>{@link SubsystemConstants#SUBSYSTEM_STATE_PROPERTY State} - The state of
1:452554c:  * the subsystem.</li>
1:1c9c28b:  * </ul>
1:452554c:  * 
1:452554c:  * <p>
1:1c9c28b:  * Because a subsystem must be used to install other subsystems, a root
1:452554c:  * subsystem is provided as a starting point. The root subsystem may only be
1:452554c:  * obtained as a service and has the following characteristics.
1:452554c:  * 
1:1c9c28b:  * <ul>
1:a1c6951:  * <li>The ID is {@code 0}.</li>
1:452554c:  * <li>The symbolic name is
1:452554c:  * {@link SubsystemConstants#ROOT_SUBSYSTEM_SYMBOLICNAME
1:452554c:  * org.osgi.service.subsystem.root}.</li>
1:a1c6951:  * <li>The version matches this specification's version.</li>
1:a1c6951:  * <li>It has no parents.</li>
1:452554c:  * <li>All existing bundles, including the system and subsystem implementation
1:452554c:  * bundles, are constituents.</li>
1:452554c:  * <li>The type is {@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION
1:452554c:  * osgi.subsystem.application} with no imports.</li>
1:452554c:  * <li>The provision policy is
1:452554c:  * {@link SubsystemConstants#PROVISION_POLICY_ACCEPT_DEPENDENCIES
1:452554c:  * acceptDependencies}.</li>
1:1c9c28b:  * </ul>
1:ead9c04:  * 
1:6f4b079:  * @ThreadSafe
1:d6eb080:  * @author $Id: 46dbc3d05b6c0fcd6962ffe433b62cbd284c3d0d $
1:6f4b079:  */
1:d6eb080: @ProviderType
1:6c6c8a4: public interface Subsystem {
1:6f4b079: 	/**
1:1c9c28b: 	 * An enumeration of the possible states of a subsystem.
1:452554c: 	 * 
1:452554c: 	 * <p>
1:1c9c28b: 	 * These states are a reflection of what constituent resources are permitted
1:452554c: 	 * to do and not an aggregation of constituent resource states.
1:6f4b079: 	 */
1:6f4b079: 	public static enum State {
1:6f4b079: 		/**
1:1c9c28b: 		 * The subsystem is in the process of installing.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code INSTALLING} state when the
1:452554c: 		 * {@link Subsystem#install(String, InputStream) install} method of its
1:452554c: 		 * parent is active, and attempts are being made to install its content
1:452554c: 		 * resources. If the install method completes without exception, then
1:452554c: 		 * the subsystem has successfully installed and must move to the
1:452554c: 		 * {@link #INSTALLED} state. Otherwise, the subsystem has failed to
1:452554c: 		 * install and must move to the {@link #INSTALL_FAILED} state.
1:6f4b079: 		 */
1:b1d7587: 		INSTALLING,
1:6f4b079: 		/**
1:1c9c28b: 		 * The subsystem is installed but not yet resolved.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code INSTALLED} state when it has been
1:452554c: 		 * installed in a parent subsystem but is not or cannot be resolved.
1:452554c: 		 * This state is visible if the dependencies of the subsystem's content
1:452554c: 		 * resources cannot be resolved.
1:6f4b079: 		 */
1:6f4b079: 		INSTALLED,
1:6f4b079: 		/**
1:1c9c28b: 		 * The subsystem failed to install.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code INSTALL_FAILED} state when an
1:452554c: 		 * unrecoverable error occurred during installation. The subsystem is in
1:452554c: 		 * an unusable state but references to the subsystem object may still be
1:452554c: 		 * available and used for introspection.
1:1c9c28b: 		 */
1:1c9c28b: 		INSTALL_FAILED,
1:1c9c28b: 		/**
1:1c9c28b: 		 * The subsystem is in the process of resolving.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code RESOLVING} state when the
1:452554c: 		 * {@link Subsystem#start() start} method is active, and attempts are
1:452554c: 		 * being made to resolve its content resources. If the resolve method
1:452554c: 		 * completes without exception, then the subsystem has successfully
1:452554c: 		 * resolved and must move to the {@link #RESOLVED} state. Otherwise, the
1:452554c: 		 * subsystem has failed to resolve and must move to the INSTALLED state.
1:b1d7587: 		 */
1:b1d7587: 		RESOLVING,
1:b1d7587: 		/**
1:1c9c28b: 		 * The subsystem is resolved and able to be started.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code RESOLVED} state when all of its content
1:1c9c28b: 		 * resources are resolved. Note that the subsystem is not active yet.
1:6f4b079: 		 */
1:6f4b079: 		RESOLVED,
1:6f4b079: 		/**
1:1c9c28b: 		 * The subsystem is in the process of starting.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code STARTING} state when its
1:452554c: 		 * {@link Subsystem#start() start} method is active, and attempts are
1:452554c: 		 * being made to start its content and dependencies. If the start method
1:452554c: 		 * completes without exception, then the subsystem has successfully
1:452554c: 		 * started and must move to the {@link #ACTIVE} state. Otherwise, the
1:452554c: 		 * subsystem has failed to start and must move to the {@link #RESOLVED}
1:452554c: 		 * state.
1:6f4b079: 		 */
1:6f4b079: 		STARTING,
1:6f4b079: 		/**
1:1c9c28b: 		 * The subsystem is now running.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code ACTIVE} state when its content and
1:452554c: 		 * dependencies have been successfully started.
1:b1d7587: 		 */
1:b1d7587: 		ACTIVE,
1:b1d7587: 		/**
1:1c9c28b: 		 * The subsystem is in the process of stopping.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code STOPPING} state when its
1:452554c: 		 * {@link Subsystem#stop() stop} method is active, and attempts are
1:452554c: 		 * being made to stop its content and dependencies. When the stop method
1:452554c: 		 * completes, the subsystem is stopped and must move to the
1:452554c: 		 * {@link #RESOLVED} state.
1:6f4b079: 		 */
1:6f4b079: 		STOPPING,
1:1c9c28b: 		/**
1:1c9c28b: 		 * The subsystem is in the process of uninstalling.
1:452554c: 		 * <p>
1:452554c: 		 * A subsystem is in the {@code UNINSTALLING} state when its
1:452554c: 		 * {@link Subsystem#uninstall() uninstall} method is active, and
1:452554c: 		 * attempts are being made to uninstall its constituent and
1:452554c: 		 * dependencies. When the uninstall method completes, the subsystem is
1:452554c: 		 * uninstalled and must move to the {@link #UNINSTALLED} state.
1:1c9c28b: 		 */
1:b1d7587: 		UNINSTALLING,
1:6f4b079: 		/**
1:1c9c28b: 		 * The subsystem is uninstalled and may not be used.
1:452554c: 		 * <p>
1:452554c: 		 * The {@code UNINSTALLED} state is only visible after a subsystem's
1:452554c: 		 * constituent and dependencies are uninstalled. The subsystem is in an
1:1c9c28b: 		 * unusable state but references to the subsystem object may still be
1:1c9c28b: 		 * available and used for introspection.
1:6f4b079: 		 */
1:6f4b079: 		UNINSTALLED
1:6f4b079: 	}
1:452554c: 
1:b1d7587: 	/**
1:1c9c28b: 	 * Returns the bundle context of the region within which this subsystem
1:1c9c28b: 	 * resides.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The bundle context offers the same perspective of any resource contained
1:1c9c28b: 	 * by a subsystem within the region. It may be used, for example, to monitor
1:1c9c28b: 	 * events internal to the region as well as external events visible to the
1:1c9c28b: 	 * region. All subsystems within the same region have the same bundle
1:1c9c28b: 	 * context. If this subsystem is in a state where the bundle context would
1:452554c: 	 * be invalid, {@code null} is returned.
1:1c9c28b: 	 * 
1:1c9c28b: 	 * @return The bundle context of the region within which this subsystem
1:452554c: 	 *         resides or {@code null} if this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:1c9c28b: 	 *         {@link SubsystemPermission}[this,CONTEXT], and the runtime
2:1c9c28b: 	 *         supports permissions.
1:b1d7587: 	 */
1:1c9c28b: 	public BundleContext getBundleContext();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the child subsystems of this subsystem.
1:ead9c04: 	 * 
1:452554c: 	 * @return The child subsystems of this subsystem. The returned collection
1:452554c: 	 *         is an unmodifiable snapshot of all subsystems that are installed
1:452554c: 	 *         in this subsystem. The collection will be empty if no subsystems
1:452554c: 	 *         are installed in this subsystem.
3:1c9c28b: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:6f4b079: 	 */
1:6f4b079: 	public Collection<Subsystem> getChildren();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the headers for this subsystem's subsystem manifest.
1:452554c: 	 * <p>
1:452554c: 	 * Each key in the map is a header name and the value of the key is the
1:452554c: 	 * corresponding header value. Because header names are case-insensitive,
1:452554c: 	 * the methods of the map must treat the keys in a case-insensitive manner.
1:452554c: 	 * If the header name is not found, {@code null} is returned. Both original
1:452554c: 	 * and derived headers will be included in the map.
1:452554c: 	 * <p>
1:1c9c28b: 	 * This method must continue to return the headers while this subsystem is
1:452554c: 	 * in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:452554c: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:ead9c04: 	 * 
1:452554c: 	 * @param locale The locale for which translations are desired. The header
1:452554c: 	 *        values are translated according to the specified locale. If the
1:452554c: 	 *        specified locale is {@code null} or not supported, the raw values
1:452554c: 	 *        are returned. If the translation for a particular header is not
1:452554c: 	 *        found, the raw value is returned.
1:452554c: 	 * @return The headers for this subsystem's subsystem manifest. The returned
1:452554c: 	 *         map is unmodifiable.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:1c9c28b: 	 *         {@link SubsystemPermission}[this,METADATA], and the runtime
1:1c9c28b: 	 *         supports permissions.
1:6f4b079: 	 */
1:1c9c28b: 	public Map<String, String> getSubsystemHeaders(Locale locale);
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the location identifier of this subsystem.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The location identifier is the {@code location} that was passed to the
1:452554c: 	 * {@link #install(String, InputStream) install} method of the
1:452554c: 	 * {@link #getParents() parent} subsystem. It is unique within the
1:452554c: 	 * framework.
1:452554c: 	 * <p>
1:1c9c28b: 	 * This method must continue to return this subsystem's headers while this
1:452554c: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:452554c: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:b1d7587: 	 * 
1:1c9c28b: 	 * @return The location identifier of this subsystem.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:1c9c28b: 	 *         {@link SubsystemPermission}[this,METADATA], and the runtime
1:1c9c28b: 	 *         supports permissions.
1:6f4b079: 	 */
1:6f4b079: 	public String getLocation();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the parent subsystems of this subsystem.
1:2e06be4: 	 * 
1:452554c: 	 * @return The parent subsystems of this subsystem. The returned collection
1:452554c: 	 *         is an unmodifiable snapshot of all subsystems in which this
1:452554c: 	 *         subsystem is installed. The collection will be empty for the root
1:452554c: 	 *         subsystem; otherwise, it must contain at least one parent. Scoped
1:452554c: 	 *         subsystems always have only one parent. Unscoped subsystems may
1:452554c: 	 *         have multiple parents.
1:452554c: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:6f4b079: 	 */
1:1c9c28b: 	public Collection<Subsystem> getParents();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the constituent resources of this subsystem.
1:1c9c28b: 	 * 
1:452554c: 	 * @return The constituent resources of this subsystem. The returned
1:452554c: 	 *         collection is an unmodifiable snapshot of the constituent
1:452554c: 	 *         resources of this subsystem. If this subsystem has no
1:452554c: 	 *         constituents, the collection will be empty.
1:452554c: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:1c9c28b: 	 */
1:1c9c28b: 	public Collection<Resource> getConstituents();
1:452554c: 
1:1c9c28b: 	/**
1:d6eb080: 	 * Returns the headers for this subsystem's deployment manifest.
1:d6eb080: 	 * <p>
1:d6eb080: 	 * Each key in the map is a header name and the value of the key is the
1:d6eb080: 	 * corresponding header value. Because header names are case-insensitive,
1:d6eb080: 	 * the methods of the map must treat the keys in a case-insensitive manner.
1:d6eb080: 	 * If the header name is not found, {@code null} is returned. Both original
1:d6eb080: 	 * and derived headers will be included in the map.
1:d6eb080: 	 * <p>
1:d6eb080: 	 * This method must continue to return the headers while this subsystem is
1:d6eb080: 	 * in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:d6eb080: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:d6eb080: 	 * 
1:d6eb080: 	 * @return The headers for this subsystem's deployment manifest. The
1:d6eb080: 	 *         returned map is unmodifiable.
1:d6eb080: 	 * @throws SecurityException If the caller does not have the appropriate
1:d6eb080: 	 *         {@link SubsystemPermission}[this,METADATA], and the runtime
1:d6eb080: 	 *         supports permissions.
1:d6eb080: 	 * @since 1.1
1:d6eb080: 	 */
1:d6eb080: 	public Map<String, String> getDeploymentHeaders();
1:d6eb080: 
1:d6eb080: 	/**
1:1c9c28b: 	 * Returns the current state of this subsystem.
1:452554c: 	 * <p>
1:1c9c28b: 	 * This method must continue to return this subsystem's state while this
1:452554c: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:452554c: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:1c9c28b: 	 * 
1:1c9c28b: 	 * @return The current state of this subsystem.
1:6f4b079: 	 */
1:6f4b079: 	public State getState();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the identifier of this subsystem.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The identifier is a monotonically increasing, non-negative integer
1:1c9c28b: 	 * automatically generated at installation time and guaranteed to be unique
1:1c9c28b: 	 * within the framework. The identifier of the root subsystem is zero.
1:452554c: 	 * <p>
1:1c9c28b: 	 * This method must continue to return this subsystem's identifier while
1:1c9c28b: 	 * this subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:1c9c28b: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:1c9c28b: 	 * 
1:1c9c28b: 	 * @return The identifier of this subsystem.
1:6f4b079: 	 */
1:6f4b079: 	public long getSubsystemId();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the symbolic name of this subsystem.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The subsystem symbolic name conforms to the same grammar rules as the
1:1c9c28b: 	 * bundle symbolic name and is derived from one of the following, in order.
1:1c9c28b: 	 * <ul>
1:452554c: 	 * <li>The value of the {@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME
1:452554c: 	 * Subsystem-SymbolicName} header, if specified.</li>
1:452554c: 	 * <li>The subsystem URI if passed as the {@code location} along with the
1:452554c: 	 * {@code content} to the {@link #install(String, InputStream) install}
1:452554c: 	 * method.</li>
1:452554c: 	 * <li>Optionally generated in an implementation specific way.</li>
1:1c9c28b: 	 * </ul>
1:452554c: 	 * The combination of subsystem symbolic name and {@link #getVersion()
1:452554c: 	 * version} is unique within a region. The symbolic name of the root
1:452554c: 	 * subsystem is {@link SubsystemConstants#ROOT_SUBSYSTEM_SYMBOLICNAME
1:1c9c28b: 	 * org.osgi.service.subsystem.root}.
1:452554c: 	 * <p>
1:1c9c28b: 	 * This method must continue to return this subsystem's symbolic name while
1:1c9c28b: 	 * this subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:1c9c28b: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:ead9c04: 	 * 
1:6f4b079: 	 * @return The symbolic name of this subsystem.
1:6f4b079: 	 */
1:6f4b079: 	public String getSymbolicName();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Returns the {@link SubsystemConstants#SUBSYSTEM_TYPE type} of this
1:1c9c28b: 	 * subsystem.
1:452554c: 	 * <p>
1:b8ad309: 	 * This method must continue to return this subsystem's type while this
1:b8ad309: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:b8ad309: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:1c9c28b: 	 * 
1:1c9c28b: 	 * @return The type of this subsystem.
1:1c9c28b: 	 */
1:1c9c28b: 	public String getType();
1:452554c: 
1:1c9c28b: 	/**
1:1c9c28b: 	 * Returns the {@link SubsystemConstants#SUBSYSTEM_VERSION version} of this
1:1c9c28b: 	 * subsystem.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The subsystem version conforms to the same grammar rules as the bundle
1:1c9c28b: 	 * version and is derived from one of the following, in order.
1:1c9c28b: 	 * <ul>
1:452554c: 	 * <li>The value of the {@link SubsystemConstants#SUBSYSTEM_VERSION
1:452554c: 	 * Subsystem-Version} header, if specified.</li>
1:452554c: 	 * <li>The subsystem URI if passed as the {@code location} along with the
1:452554c: 	 * {@code content} to the {@link #install(String, InputStream) install}
1:452554c: 	 * method.</li>
1:452554c: 	 * <li>Defaults to {@code 0.0.0}.</li>
1:1c9c28b: 	 * </ul>
1:452554c: 	 * The combination of subsystem {@link #getSymbolicName() symbolic name} and
1:452554c: 	 * version is unique within a region. The version of the root subsystem
1:452554c: 	 * matches this specification's version.
1:452554c: 	 * <p>
1:1c9c28b: 	 * This method must continue to return this subsystem's version while this
1:452554c: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1:452554c: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1:ead9c04: 	 * 
1:6f4b079: 	 * @return The version of this subsystem.
1:6f4b079: 	 */
1:6f4b079: 	public Version getVersion();
1:452554c: 
1:6f4b079: 	/**
1:452554c: 	 * Installs a subsystem from the specified location identifier.
1:452554c: 	 * <p>
1:452554c: 	 * This method performs the same function as calling
1:452554c: 	 * {@link #install(String, InputStream)} with the specified location
1:452554c: 	 * identifier and {@code null} as the content.
1:1c9c28b: 	 * 
1:452554c: 	 * @param location The location identifier of the subsystem to install.
1:6f4b079: 	 * @return The installed subsystem.
1:452554c: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
1:452554c: 	 *         INSTALL_FAILED}, {@link State#UNINSTALLING UNINSTALLING},
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:1c9c28b: 	 * @throws SubsystemException If the installation failed.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:1c9c28b: 	 *         {@link SubsystemPermission}[installed subsystem,LIFECYCLE], and
1:1c9c28b: 	 *         the runtime supports permissions.
1:1c9c28b: 	 * @see #install(String, InputStream)
1:6f4b079: 	 */
1:452554c: 	public Subsystem install(String location);
1:452554c: 
1:6f4b079: 	/**
1:452554c: 	 * Installs a subsystem from the specified content.
1:452554c: 	 * <p>
1:452554c: 	 * The specified location will be used as an identifier of the subsystem.
1:452554c: 	 * Every installed subsystem is uniquely identified by its location, which
1:452554c: 	 * is typically in the form of a URI. If the specified location conforms to
1:452554c: 	 * the {@code subsystem-uri} grammar, the required symbolic name and
1:452554c: 	 * optional version information will be used as default values.
1:452554c: 	 * <p>
1:452554c: 	 * If the specified content is {@code null}, a new input stream must be
1:1c9c28b: 	 * created from which to read the subsystem by interpreting, in an
1:452554c: 	 * implementation dependent manner, the specified location.
1:452554c: 	 * <p>
1:1c9c28b: 	 * A subsystem installation must be persistent. That is, an installed
1:1c9c28b: 	 * subsystem must remain installed across Framework and VM restarts.
1:452554c: 	 * <p>
1:1c9c28b: 	 * All references to changing the state of this subsystem include both
1:1c9c28b: 	 * changing the state of the subsystem object as well as the state property
1:a1c6951: 	 * of the subsystem service registration.
1:452554c: 	 * <p>
1:a1c6951: 	 * The following steps are required to install a subsystem.
1:1c9c28b: 	 * <ol>
1:452554c: 	 * <li>If an installed subsystem with the specified location identifier
1:452554c: 	 * already exists, return the installed subsystem.</li>
1:452554c: 	 * <li>Read the specified content in order to determine the symbolic name,
1:452554c: 	 * version, and type of the installing subsystem. If an error occurs while
1:452554c: 	 * reading the content, an installation failure results.</li>
1:1c9c28b: 	 * <li>If an installed subsystem with the same symbolic name and version
1:a1c6951: 	 * already exists within this subsystem's region, complete the installation
1:d6eb080: 	 * with one of the following.
1:d6eb080: 	 * <ul>
1:d6eb080: 	 * <li>If the installing and installed subsystems' types are not equal, an
1:d6eb080: 	 * installation failure results.</li>
1:d6eb080: 	 * <li>If the installing and installed subsystems' types are equal, and the
1:a1c6951: 	 * installed subsystem is already a child of this subsystem, return the
1:d6eb080: 	 * installed subsystem.</li>
1:d6eb080: 	 * <li>If the installing and installed subsystems' types are equal, and the
1:a1c6951: 	 * installed subsystem is not already a child of this subsystem, add the
1:a1c6951: 	 * installed subsystem as a child of this subsystem, increment the installed
1:d6eb080: 	 * subsystem's reference count by one, and return the installed subsystem.</li>
1:d6eb080: 	 * </ul>
1:452554c: 	 * <li>Create a new subsystem based on the specified location and content.</li>
1:452554c: 	 * <li>If the subsystem is scoped, install and start a new region context
1:a1c6951: 	 * bundle.</li>
1:452554c: 	 * <li>Change the state to {@link State#INSTALLING INSTALLING} and register
1:452554c: 	 * a new subsystem service.</li>
1:a1c6951: 	 * <li>Discover the subsystem's content resources. If any mandatory resource
1:a1c6951: 	 * is missing, an installation failure results.</li>
1:a1c6951: 	 * <li>Discover the dependencies required by the content resources. If any
1:a1c6951: 	 * mandatory dependency is missing, an installation failure results.</li>
1:452554c: 	 * <li>Using a framework {@code ResolverHook}, disable runtime resolution
1:452554c: 	 * for the resources.</li>
1:1c9c28b: 	 * <li>For each resource, increment the reference count by one. If the
1:452554c: 	 * reference count is one, install the resource. If an error occurs while
1:a1c6951: 	 * installing a resource, an install failure results with that error as the
1:a1c6951: 	 * cause.</li>
1:a1c6951: 	 * <li>If the subsystem is scoped, enable the import sharing policy.</li>
1:a1c6951: 	 * <li>Enable runtime resolution for the resources.</li>
1:452554c: 	 * <li>Change the state of the subsystem to {@link State#INSTALLED
1:452554c: 	 * INSTALLED}.</li>
1:a1c6951: 	 * <li>Return the new subsystem.</li>
1:1c9c28b: 	 * </ol>
1:452554c: 	 * <p>
1:452554c: 	 * Implementations should be sensitive to the potential for long running
1:452554c: 	 * operations and periodically check the current thread for interruption. An
1:452554c: 	 * interrupted thread should result in a {@link SubsystemException} with an
1:452554c: 	 * InterruptedException as the cause and be treated as an installation
1:452554c: 	 * failure.
1:452554c: 	 * <p>
1:452554c: 	 * All installation failure flows include the following, in order.
1:452554c: 	 * <ol>
1:452554c: 	 * <li>Change the state to {@link State#INSTALL_FAILED INSTALL_FAILED}.</li>
1:452554c: 	 * <li>Change the state to {@link State#UNINSTALLING UNINSTALLING}.</li>
1:452554c: 	 * <li>All content and dependencies which may have been installed by the
1:d6eb080: 	 * installing process must be uninstalled.</li>
1:452554c: 	 * <li>Change the state to {@link State#UNINSTALLED UNINSTALLED}.</li>
1:452554c: 	 * <li>Unregister the subsystem service.</li>
1:452554c: 	 * <li>If the subsystem is a scoped subsystem then, uninstall the region
1:452554c: 	 * context bundle.</li>
1:452554c: 	 * <li>Throw a {@link SubsystemException} with the cause of the installation
1:452554c: 	 * failure.</li>
1:452554c: 	 * </ol>
1:1c9c28b: 	 * 
1:452554c: 	 * @param location The location identifier of the subsystem to be installed.
1:452554c: 	 * @param content The input stream from which this subsystem will be read or
1:452554c: 	 *        {@code null} to indicate the input stream must be created from the
1:1c9c28b: 	 *        specified location identifier. The input stream will always be
1:1c9c28b: 	 *        closed when this method completes, even if an exception is thrown.
1:6f4b079: 	 * @return The installed subsystem.
1:452554c: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
1:452554c: 	 *         INSTALL_FAILED}, {@link State#UNINSTALLING UNINSTALLING},
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:1c9c28b: 	 * @throws SubsystemException If the installation failed.
1:a1c6951: 	 * @throws SecurityException If the caller does not have the appropriate
1:452554c: 	 *         {@link SubsystemPermission}[installed subsystem,LIFECYCLE], and
1:452554c: 	 *         the runtime supports permissions.
1:6f4b079: 	 */
1:452554c: 	public Subsystem install(String location, InputStream content);
1:452554c: 
1:6f4b079: 	/**
1:d6eb080: 	 * Installs a subsystem from the specified content according to the
1:d6eb080: 	 * specified deployment manifest.
1:d6eb080: 	 * <p>
1:d6eb080: 	 * This method installs a subsystem using the provided deployment manifest
1:d6eb080: 	 * instead of the one in the archive, if any, or a computed one. If the
1:d6eb080: 	 * deployment manifest is {@code null}, the behavior is exactly the same as
1:d6eb080: 	 * in the {@link #install(String, InputStream)} method. Implementations must
1:d6eb080: 	 * support deployment manifest input streams in the format described by
1:d6eb080: 	 * section 134.2 of the Subsystem Service Specification. If the deployment
1:d6eb080: 	 * manifest does not conform to the subsystem manifest (see 134.15.2), the
1:d6eb080: 	 * installation fails.
1:d6eb080: 	 * 
1:d6eb080: 	 * @param location The location identifier of the subsystem to be installed.
1:d6eb080: 	 * @param content The input stream from which this subsystem will be read or
1:d6eb080: 	 *        {@code null} to indicate the input stream must be created from the
1:d6eb080: 	 *        specified location identifier. The input stream will always be
1:d6eb080: 	 *        closed when this method completes, even if an exception is thrown.
1:d6eb080: 	 * @param deploymentManifest The deployment manifest to use in lieu of the
1:d6eb080: 	 *        one in the archive, if any, or a computed one.
1:d6eb080: 	 * @return The installed subsystem.
1:d6eb080: 	 * @throws IllegalStateException If this subsystem's state is in
1:d6eb080: 	 *         {@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
1:d6eb080: 	 *         INSTALL_FAILED}, {@link State#UNINSTALLING UNINSTALLING},
1:d6eb080: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:d6eb080: 	 * @throws SubsystemException If the installation failed.
1:d6eb080: 	 * @throws SecurityException If the caller does not have the appropriate
1:d6eb080: 	 *         {@link SubsystemPermission}[installed subsystem,LIFECYCLE], and
1:d6eb080: 	 *         the runtime supports permissions.
1:d6eb080: 	 * @since 1.1
1:d6eb080: 	 */
1:d6eb080: 	public Subsystem install(String location, InputStream content, InputStream deploymentManifest);
1:d6eb080: 
1:d6eb080: 	/**
1:1c9c28b: 	 * Starts this subsystem.
1:452554c: 	 * <p>
2:1c9c28b: 	 * The following table shows which actions are associated with each state.
1:452554c: 	 * An action of {@code Wait} means this method will block until a state
1:452554c: 	 * transition occurs, upon which the new state will be evaluated in order to
1:452554c: 	 * determine how to proceed. If a state transition does not occur in a
1:452554c: 	 * reasonable time while waiting then no action is taken and a
1:452554c: 	 * SubsystemException is thrown to indicate the subsystem was unable to be
1:452554c: 	 * started. An action of {@code Return} means this method returns
2:1c9c28b: 	 * immediately without taking any other action.
1:452554c: 	 * </p>
1:452554c: 	 * <table>
1:452554c: 	 * <tr>
1:452554c: 	 * <th>State</th>
1:452554c: 	 * <th width="4">Action</th>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALLING INSTALLING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALLED INSTALLED}</td>
1:d6eb080: 	 * <td>{@code Resolve}, {@code Start}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALL_FAILED INSTALL_FAILED}</td>
1:452554c: 	 * <td>{@code IllegalStateException}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#RESOLVING RESOLVING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#RESOLVED RESOLVED}</td>
1:452554c: 	 * <td>{@code Start}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#STARTING STARTING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#ACTIVE ACTIVE}</td>
1:452554c: 	 * <td>{@code Return}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#STOPPING STOPPING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#UNINSTALLING UNINSTALLING}</td>
1:452554c: 	 * <td>{@code IllegalStateException}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#UNINSTALLED UNINSTALLED}</td>
1:452554c: 	 * <td>{@code IllegalStateException}</td>
1:452554c: 	 * </tr>
3:1c9c28b: 	 * </table>
1:452554c: 	 * <p>
1:1c9c28b: 	 * All references to changing the state of this subsystem include both
1:1c9c28b: 	 * changing the state of the subsystem object as well as the state property
2:1c9c28b: 	 * of the subsystem service registration.
1:452554c: 	 * <p>
1:1c9c28b: 	 * A subsystem must be persistently started. That is, a started subsystem
1:1c9c28b: 	 * must be restarted across Framework and VM restarts, even if a start
1:1c9c28b: 	 * failure occurs.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The following steps are required to start this subsystem.
1:1c9c28b: 	 * <ol>
1:452554c: 	 * <li>Set the subsystem <i>autostart setting</i> to <i>started</i>.</li>
1:452554c: 	 * <li>If this subsystem is in the {@link State#RESOLVED RESOLVED} state,
1:452554c: 	 * proceed to step 7.</li>
1:452554c: 	 * <li>Change the state to {@link State#RESOLVING RESOLVING}.</li>
1:452554c: 	 * <li>Resolve the content resources. A resolution failure results in a
1:452554c: 	 * start failure with a state of {@link State#INSTALLED INSTALLED}.</li>
1:452554c: 	 * <li>Change the state to {@link State#RESOLVED RESOLVED}.</li>
1:452554c: 	 * <li>If this subsystem is scoped, enable the export sharing policy.</li>
1:452554c: 	 * <li>Change the state to {@link State#STARTING STARTING}.</li>
1:452554c: 	 * <li>For each eligible resource, increment the active use count by one. If
1:452554c: 	 * the active use count is one, start the resource. All dependencies must be
1:452554c: 	 * started before any content resource, and content resources must be
1:452554c: 	 * started according to the specified
1:452554c: 	 * {@link SubsystemConstants#START_ORDER_DIRECTIVE start order}. If an error
1:452554c: 	 * occurs while starting a resource, a start failure results with that error
1:452554c: 	 * as the cause.</li>
1:452554c: 	 * <li>Change the state to {@link State#ACTIVE ACTIVE}.</li>
1:1c9c28b: 	 * </ol>
1:452554c: 	 * <p>
1:452554c: 	 * Implementations should be sensitive to the potential for long running
1:452554c: 	 * operations and periodically check the current thread for interruption. An
1:452554c: 	 * interrupted thread should be treated as a start failure with an
1:452554c: 	 * {@code InterruptedException} as the cause.
1:452554c: 	 * <p>
1:452554c: 	 * All start failure flows include the following, in order.
1:452554c: 	 * <ol>
1:452554c: 	 * <li>If the subsystem state is {@link State#STARTING STARTING} then change
1:452554c: 	 * the state to {@link State#STOPPING STOPPING} and stop all resources that
1:452554c: 	 * were started as part of this operation.</li>
1:452554c: 	 * <li>Change the state to either {@link State#INSTALLED INSTALLED} or
1:452554c: 	 * {@link State#RESOLVED RESOLVED}.</li>
1:452554c: 	 * <li>Throw a SubsystemException with the specified cause.</li>
1:452554c: 	 * </ol>
1:452554c: 	 * 
1:452554c: 	 * @throws SubsystemException If this subsystem fails to start.
1:1c9c28b: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1:452554c: 	 *         {@link State#UNINSTALLING UNINSTALLING}, or
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}, or if the state of at
1:452554c: 	 *         least one of this subsystem's parents is not in
1:452554c: 	 *         {@link State#STARTING STARTING}, {@link State#ACTIVE ACTIVE}.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:452554c: 	 *         {@link SubsystemPermission}[this,EXECUTE], and the runtime
1:452554c: 	 *         supports permissions.
1:6f4b079: 	 */
1:452554c: 	public void start();
1:452554c: 
1:6f4b079: 	/**
1:1c9c28b: 	 * Stops this subsystem.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The following table shows which actions are associated with each state.
1:452554c: 	 * An action of {@code Wait} means this method will block until a state
1:452554c: 	 * transition occurs, upon which the new state will be evaluated in order to
1:452554c: 	 * determine how to proceed. If a state transition does not occur in a
1:452554c: 	 * reasonable time while waiting then no action is taken and a
1:452554c: 	 * SubsystemException is thrown to indicate the subsystem was unable to be
1:452554c: 	 * stopped. An action of {@code Return} means this method returns
1:1c9c28b: 	 * immediately without taking any other action.
1:452554c: 	 * </p>
1:452554c: 	 * <table>
1:452554c: 	 * <tr>
1:452554c: 	 * <th>State</th>
1:452554c: 	 * <th width="4">Action</th>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALLING INSTALLING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALLED INSTALLED}</td>
1:452554c: 	 * <td>{@code Return}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALL_FAILED INSTALL_FAILED}</td>
1:452554c: 	 * <td>{@code IllegalStateException}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#RESOLVING RESOLVING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#RESOLVED RESOLVED}</td>
1:452554c: 	 * <td>{@code Return}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#STARTING STARTING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#ACTIVE ACTIVE}</td>
1:452554c: 	 * <td>{@code Stop}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#STOPPING STOPPING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#UNINSTALLING UNINSTALLING}</td>
1:452554c: 	 * <td>{@code IllegalStateException}</td>
1:452554c: 	 * <td>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#UNINSTALLED UNINSTALLED}</td>
1:452554c: 	 * <td>{@code IllegalStateException}</td>
1:452554c: 	 * <td>
1:1c9c28b: 	 * </table>
1:452554c: 	 * <p>
1:1c9c28b: 	 * A subsystem must be persistently stopped. That is, a stopped subsystem
1:1c9c28b: 	 * must remain stopped across Framework and VM restarts.
1:452554c: 	 * <p>
1:1c9c28b: 	 * All references to changing the state of this subsystem include both
1:1c9c28b: 	 * changing the state of the subsystem object as well as the state property
1:1c9c28b: 	 * of the subsystem service registration.
1:452554c: 	 * <p>
1:1c9c28b: 	 * The following steps are required to stop this subsystem.
1:1c9c28b: 	 * <ol>
1:452554c: 	 * <li>Set the subsystem <i>autostart setting</i> to <i>stopped</i>.</li>
1:452554c: 	 * <li>Change the state to {@link State#STOPPING STOPPING}.</li>
1:452554c: 	 * <li>For each eligible resource, decrement the active use count by one. If
1:452554c: 	 * the active use count is zero, stop the resource. All content resources
1:452554c: 	 * must be stopped before any dependencies, and content resources must be
1:452554c: 	 * stopped in reverse {@link SubsystemConstants#START_ORDER_DIRECTIVE start
1:452554c: 	 * order}.</li>
1:452554c: 	 * <li>Change the state to {@link State#RESOLVED RESOLVED}.</li>
1:1c9c28b: 	 * </ol>
1:1c9c28b: 	 * With regard to error handling, once this subsystem has transitioned to
1:452554c: 	 * the {@link State#STOPPING STOPPING} state, every part of each step above
1:452554c: 	 * must be attempted. Errors subsequent to the first should be logged. Once
1:452554c: 	 * the stop process has completed, a SubsystemException must be thrown with
1:452554c: 	 * the initial error as the specified cause.
1:452554c: 	 * <p>
4:1c9c28b: 	 * Implementations should be sensitive to the potential for long running
2:1c9c28b: 	 * operations and periodically check the current thread for interruption, in
2:1c9c28b: 	 * which case a SubsystemException with an InterruptedException as the cause
2:1c9c28b: 	 * should be thrown. If an interruption occurs while waiting, this method
1:452554c: 	 * should terminate immediately. Once the transition to the
1:452554c: 	 * {@link State#STOPPING STOPPING} state has occurred, however, this method
1:452554c: 	 * must not terminate due to an interruption until the stop process has
1:452554c: 	 * completed.
1:452554c: 	 * 
1:452554c: 	 * @throws SubsystemException If this subsystem fails to stop cleanly.
1:452554c: 	 * @throws IllegalStateException If this subsystem's state is in
1:452554c: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1:452554c: 	 *         {@link State#UNINSTALLING UNINSTALLING}, or
1:452554c: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:452554c: 	 *         {@link SubsystemPermission}[this,EXECUTE], and the runtime
1:452554c: 	 *         supports permissions.
1:452554c: 	 */
1:452554c: 	public void stop();
1:452554c: 
1:452554c: 	/**
1:452554c: 	 * Uninstalls this subsystem.
1:452554c: 	 * <p>
1:452554c: 	 * The following table shows which actions are associated with each state.
1:452554c: 	 * An action of {@code Wait} means this method will block until a state
1:452554c: 	 * transition occurs, upon which the new state will be evaluated in order to
1:452554c: 	 * determine how to proceed. If a state transition does not occur in a
1:452554c: 	 * reasonable time while waiting then no action is taken and a
1:452554c: 	 * SubsystemException is thrown to indicate the subsystem was unable to be
1:452554c: 	 * uninstalled. An action of {@code Return} means this method returns
1:452554c: 	 * immediately without taking any other action.
1:452554c: 	 * <table>
1:452554c: 	 * <tr>
1:452554c: 	 * <th>State</th>
1:452554c: 	 * <th width="4">Action</th>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALLING INSTALLING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALLED INSTALLED}</td>
1:452554c: 	 * <td>{@code Uninstall}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#INSTALL_FAILED INSTALL_FAILED}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#RESOLVING RESOLVING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#RESOLVED RESOLVED}</td>
1:452554c: 	 * <td>{@code Uninstall}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#STARTING STARTING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#ACTIVE ACTIVE}</td>
1:d6eb080: 	 * <td>{@code Stop}, {@code Uninstall}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#STOPPING STOPPING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#UNINSTALLING UNINSTALLING}</td>
1:452554c: 	 * <td>{@code Wait}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * <tr>
1:452554c: 	 * <td>{@link State#UNINSTALLED UNINSTALLED}</td>
1:452554c: 	 * <td>{@code Return}</td>
1:452554c: 	 * </tr>
1:452554c: 	 * </table>
1:452554c: 	 * <p>
1:1c9c28b: 	 * All references to changing the state of this subsystem include both
1:1c9c28b: 	 * changing the state of the subsystem object as well as the state property
1:1c9c28b: 	 * of the subsystem service registration.
1:452554c: 	 * <p>
1:452554c: 	 * The following steps are required to uninstall this subsystem after being
1:452554c: 	 * stopped if necessary.
1:1c9c28b: 	 * <ol>
1:452554c: 	 * <li>Change the state to {@link State#INSTALLED INSTALLED}.</li>
1:452554c: 	 * <li>Change the state to {@link State#UNINSTALLING UNINSTALLING}.</li>
1:452554c: 	 * <li>For each referenced resource, decrement the reference count by one.
1:452554c: 	 * If the reference count is zero, uninstall the resource. All content
1:452554c: 	 * resources must be uninstalled before any dependencies.</li>
1:452554c: 	 * <li>Change the state to {@link State#UNINSTALLED UNINSTALLED}.</li>
1:452554c: 	 * <li>Unregister the subsystem service.</li>
1:452554c: 	 * <li>If the subsystem is scoped, uninstall the region context bundle.</li>
1:1c9c28b: 	 * </ol>
1:1c9c28b: 	 * With regard to error handling, once this subsystem has transitioned to
1:452554c: 	 * the {@link State#UNINSTALLING UNINSTALLING} state, every part of each
1:452554c: 	 * step above must be attempted. Errors subsequent to the first should be
1:452554c: 	 * logged. Once the uninstall process has completed, a
1:452554c: 	 * {@code SubsystemException} must be thrown with the specified cause.
1:452554c: 	 * <p>
1:452554c: 	 * Implementations should be sensitive to the potential for long running
1:452554c: 	 * operations and periodically check the current thread for interruption, in
1:452554c: 	 * which case a {@code SubsystemException} with an
1:452554c: 	 * {@code InterruptedException} as the cause should be thrown. If an
1:452554c: 	 * interruption occurs while waiting, this method should terminate
1:452554c: 	 * immediately. Once the transition to the {@link State#UNINSTALLING
1:452554c: 	 * UNINSTALLING} state has occurred, however, this method must not terminate
1:452554c: 	 * due to an interruption until the uninstall process has completed.
1:452554c: 	 * 
1:1c9c28b: 	 * @throws SubsystemException If this subsystem fails to uninstall cleanly.
1:452554c: 	 * @throws SecurityException If the caller does not have the appropriate
1:452554c: 	 *         {@link SubsystemPermission}[this,LIFECYCLE], and the runtime
1:452554c: 	 *         supports permissions.
1:6f4b079: 	 */
1:452554c: 	public void uninstall();
2:6c6c8a4: }
============================================================================
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
1:  * Copyright (c) OSGi Alliance (2012, 2013). All Rights Reserved.
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.annotation.versioning.ProviderType;
/////////////////////////////////////////////////////////////////////////
1:  * the same framework.</li>
/////////////////////////////////////////////////////////////////////////
1:  * @author $Id: 46dbc3d05b6c0fcd6962ffe433b62cbd284c3d0d $
1: @ProviderType
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns the headers for this subsystem's deployment manifest.
1: 	 * <p>
1: 	 * Each key in the map is a header name and the value of the key is the
1: 	 * corresponding header value. Because header names are case-insensitive,
1: 	 * the methods of the map must treat the keys in a case-insensitive manner.
1: 	 * If the header name is not found, {@code null} is returned. Both original
1: 	 * and derived headers will be included in the map.
1: 	 * <p>
1: 	 * This method must continue to return the headers while this subsystem is
1: 	 * in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 	 * 
1: 	 * @return The headers for this subsystem's deployment manifest. The
1: 	 *         returned map is unmodifiable.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 	 *         {@link SubsystemPermission}[this,METADATA], and the runtime
1: 	 *         supports permissions.
1: 	 * @since 1.1
1: 	 */
1: 	public Map<String, String> getDeploymentHeaders();
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	 * with one of the following.
1: 	 * <ul>
1: 	 * <li>If the installing and installed subsystems' types are not equal, an
1: 	 * installation failure results.</li>
1: 	 * <li>If the installing and installed subsystems' types are equal, and the
1: 	 * installed subsystem.</li>
1: 	 * <li>If the installing and installed subsystems' types are equal, and the
1: 	 * subsystem's reference count by one, and return the installed subsystem.</li>
1: 	 * </ul>
/////////////////////////////////////////////////////////////////////////
1: 	 * installing process must be uninstalled.</li>
/////////////////////////////////////////////////////////////////////////
1: 	 * Installs a subsystem from the specified content according to the
1: 	 * specified deployment manifest.
1: 	 * <p>
1: 	 * This method installs a subsystem using the provided deployment manifest
1: 	 * instead of the one in the archive, if any, or a computed one. If the
1: 	 * deployment manifest is {@code null}, the behavior is exactly the same as
1: 	 * in the {@link #install(String, InputStream)} method. Implementations must
1: 	 * support deployment manifest input streams in the format described by
1: 	 * section 134.2 of the Subsystem Service Specification. If the deployment
1: 	 * manifest does not conform to the subsystem manifest (see 134.15.2), the
1: 	 * installation fails.
1: 	 * 
1: 	 * @param location The location identifier of the subsystem to be installed.
1: 	 * @param content The input stream from which this subsystem will be read or
1: 	 *        {@code null} to indicate the input stream must be created from the
1: 	 *        specified location identifier. The input stream will always be
1: 	 *        closed when this method completes, even if an exception is thrown.
1: 	 * @param deploymentManifest The deployment manifest to use in lieu of the
1: 	 *        one in the archive, if any, or a computed one.
1: 	 * @return The installed subsystem.
1: 	 * @throws IllegalStateException If this subsystem's state is in
1: 	 *         {@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
1: 	 *         INSTALL_FAILED}, {@link State#UNINSTALLING UNINSTALLING},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 	 * @throws SubsystemException If the installation failed.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 	 *         {@link SubsystemPermission}[installed subsystem,LIFECYCLE], and
1: 	 *         the runtime supports permissions.
1: 	 * @since 1.1
1: 	 */
1: 	public Subsystem install(String location, InputStream content, InputStream deploymentManifest);
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	 * <td>{@code Resolve}, {@code Start}</td>
/////////////////////////////////////////////////////////////////////////
1: 	 * <td>{@code Stop}, {@code Uninstall}</td>
author:John Ross
-------------------------------------------------------------------------------
commit:452554c
/////////////////////////////////////////////////////////////////////////
1: 
1:  * 
1:  * <p>
1:  * A subsystem may be <i>scoped</i> or <i>unscoped</i>. Scoped subsystems are
1:  * isolated by implicit or explicit sharing policies. Unscoped subsystems are
1:  * not isolated and, therefore, have no sharing policy. There are three standard
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * <p>
1:  * of as an <a
1:  * href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">acyclic
1:  * digraph</a> with one and only one source vertex, which is the root subsystem.
1:  * The edges have the child as the head and parent as the tail.
1:  * 
1:  * <p>
/////////////////////////////////////////////////////////////////////////
1:  * was last invoked.
1:  * 
1:  * <p>
1:  * A subsystem archive is a ZIP file having an {@code .esa} extension and
1:  * containing metadata describing the subsystem. The form of the metadata may be
1:  * a subsystem or deployment manifest, as well as any content resource files.
1:  * The manifests are optional and will be computed if not present. The subsystem
1:  * or localized forms. There are five standard
/////////////////////////////////////////////////////////////////////////
1:  * Subsystem} - An application subsystem.</li>
1:  * A composite subsystem.</li>
1:  * feature subsystem.</li>
1:  * a subsystem:
1:  * <li>A resource is listed as part of the subsystem's content.</li>
1:  * <li>A bundle resource is installed using the region bundle context.</li>
1:  * <li>A bundle resource is installed using the bundle context of another
1:  * 
1:  * <p>
1:  * be obtained through the service registry. Each installed subsystem has a
1:  * 
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_ID_PROPERTY ID} - The ID of the
1:  * subsystem.</li>
1:  * - The symbolic name of the subsystem.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_VERSION_PROPERTY Version} - The
1:  * version of the subsystem.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_PROPERTY Type} - The type of the
1:  * subsystem.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_STATE_PROPERTY State} - The state of
1:  * the subsystem.</li>
1:  * 
1:  * <p>
1:  * subsystem is provided as a starting point. The root subsystem may only be
1:  * obtained as a service and has the following characteristics.
1:  * 
1:  * <li>The symbolic name is
1:  * {@link SubsystemConstants#ROOT_SUBSYSTEM_SYMBOLICNAME
1:  * org.osgi.service.subsystem.root}.</li>
1:  * <li>All existing bundles, including the system and subsystem implementation
1:  * bundles, are constituents.</li>
1:  * <li>The type is {@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION
1:  * osgi.subsystem.application} with no imports.</li>
1:  * <li>The provision policy is
1:  * {@link SubsystemConstants#PROVISION_POLICY_ACCEPT_DEPENDENCIES
1:  * acceptDependencies}.</li>
0:  * @version $Id: 73028a6997272cbac7e90ae00eb0f28afd14c8ee $
1: 	 * 
1: 	 * <p>
1: 	 * to do and not an aggregation of constituent resource states.
1: 		 * <p>
1: 		 * A subsystem is in the {@code INSTALLING} state when the
1: 		 * {@link Subsystem#install(String, InputStream) install} method of its
1: 		 * parent is active, and attempts are being made to install its content
1: 		 * resources. If the install method completes without exception, then
1: 		 * the subsystem has successfully installed and must move to the
1: 		 * {@link #INSTALLED} state. Otherwise, the subsystem has failed to
1: 		 * install and must move to the {@link #INSTALL_FAILED} state.
1: 		 * <p>
1: 		 * A subsystem is in the {@code INSTALLED} state when it has been
1: 		 * installed in a parent subsystem but is not or cannot be resolved.
1: 		 * This state is visible if the dependencies of the subsystem's content
1: 		 * resources cannot be resolved.
1: 		 * <p>
1: 		 * A subsystem is in the {@code INSTALL_FAILED} state when an
1: 		 * unrecoverable error occurred during installation. The subsystem is in
1: 		 * an unusable state but references to the subsystem object may still be
1: 		 * available and used for introspection.
1: 		 * <p>
1: 		 * A subsystem is in the {@code RESOLVING} state when the
1: 		 * {@link Subsystem#start() start} method is active, and attempts are
1: 		 * being made to resolve its content resources. If the resolve method
1: 		 * completes without exception, then the subsystem has successfully
1: 		 * resolved and must move to the {@link #RESOLVED} state. Otherwise, the
1: 		 * subsystem has failed to resolve and must move to the INSTALLED state.
1: 		 * <p>
1: 		 * A subsystem is in the {@code RESOLVED} state when all of its content
1: 		 * <p>
1: 		 * A subsystem is in the {@code STARTING} state when its
1: 		 * {@link Subsystem#start() start} method is active, and attempts are
1: 		 * being made to start its content and dependencies. If the start method
1: 		 * completes without exception, then the subsystem has successfully
1: 		 * started and must move to the {@link #ACTIVE} state. Otherwise, the
1: 		 * subsystem has failed to start and must move to the {@link #RESOLVED}
1: 		 * state.
1: 		 * <p>
1: 		 * A subsystem is in the {@code ACTIVE} state when its content and
1: 		 * dependencies have been successfully started.
1: 		 * <p>
1: 		 * A subsystem is in the {@code STOPPING} state when its
1: 		 * {@link Subsystem#stop() stop} method is active, and attempts are
1: 		 * being made to stop its content and dependencies. When the stop method
1: 		 * completes, the subsystem is stopped and must move to the
1: 		 * {@link #RESOLVED} state.
1: 		 * <p>
1: 		 * A subsystem is in the {@code UNINSTALLING} state when its
1: 		 * {@link Subsystem#uninstall() uninstall} method is active, and
1: 		 * attempts are being made to uninstall its constituent and
1: 		 * dependencies. When the uninstall method completes, the subsystem is
1: 		 * uninstalled and must move to the {@link #UNINSTALLED} state.
1: 		 * <p>
1: 		 * The {@code UNINSTALLED} state is only visible after a subsystem's
1: 		 * constituent and dependencies are uninstalled. The subsystem is in an
1: 
1: 	 * <p>
1: 	 * be invalid, {@code null} is returned.
1: 	 *         resides or {@code null} if this subsystem's state is in
1: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 
1: 	 * @return The child subsystems of this subsystem. The returned collection
1: 	 *         is an unmodifiable snapshot of all subsystems that are installed
1: 	 *         in this subsystem. The collection will be empty if no subsystems
1: 	 *         are installed in this subsystem.
1: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 
1: 	 * <p>
1: 	 * Each key in the map is a header name and the value of the key is the
1: 	 * corresponding header value. Because header names are case-insensitive,
1: 	 * the methods of the map must treat the keys in a case-insensitive manner.
1: 	 * If the header name is not found, {@code null} is returned. Both original
1: 	 * and derived headers will be included in the map.
1: 	 * <p>
1: 	 * in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 	 * @param locale The locale for which translations are desired. The header
1: 	 *        values are translated according to the specified locale. If the
1: 	 *        specified locale is {@code null} or not supported, the raw values
1: 	 *        are returned. If the translation for a particular header is not
1: 	 *        found, the raw value is returned.
1: 	 * @return The headers for this subsystem's subsystem manifest. The returned
1: 	 *         map is unmodifiable.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 
1: 	 * <p>
1: 	 * {@link #install(String, InputStream) install} method of the
1: 	 * {@link #getParents() parent} subsystem. It is unique within the
1: 	 * framework.
1: 	 * <p>
1: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 
1: 	 * @return The parent subsystems of this subsystem. The returned collection
1: 	 *         is an unmodifiable snapshot of all subsystems in which this
1: 	 *         subsystem is installed. The collection will be empty for the root
1: 	 *         subsystem; otherwise, it must contain at least one parent. Scoped
1: 	 *         subsystems always have only one parent. Unscoped subsystems may
1: 	 *         have multiple parents.
1: 	 * @throws IllegalStateException If this subsystem's state is in
1: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 
1: 	 * @return The constituent resources of this subsystem. The returned
1: 	 *         collection is an unmodifiable snapshot of the constituent
1: 	 *         resources of this subsystem. If this subsystem has no
1: 	 *         constituents, the collection will be empty.
1: 	 * @throws IllegalStateException If this subsystem's state is in
1: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 
1: 	 * <p>
1: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 
1: 	 * <p>
1: 	 * <p>
/////////////////////////////////////////////////////////////////////////
1: 
1: 	 * <p>
1: 	 * <li>The value of the {@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME
1: 	 * Subsystem-SymbolicName} header, if specified.</li>
1: 	 * <li>The subsystem URI if passed as the {@code location} along with the
1: 	 * {@code content} to the {@link #install(String, InputStream) install}
1: 	 * method.</li>
1: 	 * <li>Optionally generated in an implementation specific way.</li>
1: 	 * The combination of subsystem symbolic name and {@link #getVersion()
1: 	 * version} is unique within a region. The symbolic name of the root
1: 	 * subsystem is {@link SubsystemConstants#ROOT_SUBSYSTEM_SYMBOLICNAME
1: 	 * <p>
/////////////////////////////////////////////////////////////////////////
1: 
1: 	 * <p>
/////////////////////////////////////////////////////////////////////////
1: 
1: 	 * <p>
1: 	 * <li>The value of the {@link SubsystemConstants#SUBSYSTEM_VERSION
1: 	 * Subsystem-Version} header, if specified.</li>
1: 	 * <li>The subsystem URI if passed as the {@code location} along with the
1: 	 * {@code content} to the {@link #install(String, InputStream) install}
1: 	 * method.</li>
1: 	 * <li>Defaults to {@code 0.0.0}.</li>
1: 	 * The combination of subsystem {@link #getSymbolicName() symbolic name} and
1: 	 * version is unique within a region. The version of the root subsystem
1: 	 * matches this specification's version.
1: 	 * <p>
1: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 
1: 	 * Installs a subsystem from the specified location identifier.
1: 	 * <p>
1: 	 * This method performs the same function as calling
1: 	 * {@link #install(String, InputStream)} with the specified location
1: 	 * identifier and {@code null} as the content.
1: 	 * @param location The location identifier of the subsystem to install.
1: 	 * @throws IllegalStateException If this subsystem's state is in
1: 	 *         {@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
1: 	 *         INSTALL_FAILED}, {@link State#UNINSTALLING UNINSTALLING},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 	public Subsystem install(String location);
1: 
1: 	 * Installs a subsystem from the specified content.
1: 	 * <p>
1: 	 * The specified location will be used as an identifier of the subsystem.
1: 	 * Every installed subsystem is uniquely identified by its location, which
1: 	 * is typically in the form of a URI. If the specified location conforms to
1: 	 * the {@code subsystem-uri} grammar, the required symbolic name and
1: 	 * optional version information will be used as default values.
1: 	 * <p>
1: 	 * If the specified content is {@code null}, a new input stream must be
1: 	 * implementation dependent manner, the specified location.
1: 	 * <p>
1: 	 * <p>
1: 	 * <p>
1: 	 * <li>If an installed subsystem with the specified location identifier
1: 	 * already exists, return the installed subsystem.</li>
1: 	 * <li>Read the specified content in order to determine the symbolic name,
1: 	 * version, and type of the installing subsystem. If an error occurs while
1: 	 * reading the content, an installation failure results.</li>
0: 	 * with one of the following.<br/>
0: 	 * - If the installing and installed subsystems' types are not equal, an
0: 	 * installation failure results.<br/>
0: 	 * - If the installing and installed subsystems' types are equal, and the
0: 	 * installed subsystem.<br/>
0: 	 * - If the installing and installed subsystems' types are equal, and the
0: 	 * subsystem's reference count by one, and return the installed subsystem.
1: 	 * <li>Create a new subsystem based on the specified location and content.</li>
1: 	 * <li>If the subsystem is scoped, install and start a new region context
1: 	 * <li>Change the state to {@link State#INSTALLING INSTALLING} and register
1: 	 * a new subsystem service.</li>
1: 	 * <li>Using a framework {@code ResolverHook}, disable runtime resolution
1: 	 * for the resources.</li>
1: 	 * reference count is one, install the resource. If an error occurs while
1: 	 * <li>Change the state of the subsystem to {@link State#INSTALLED
1: 	 * INSTALLED}.</li>
1: 	 * <p>
1: 	 * Implementations should be sensitive to the potential for long running
1: 	 * operations and periodically check the current thread for interruption. An
1: 	 * interrupted thread should result in a {@link SubsystemException} with an
1: 	 * InterruptedException as the cause and be treated as an installation
1: 	 * failure.
1: 	 * <p>
1: 	 * All installation failure flows include the following, in order.
1: 	 * <ol>
1: 	 * <li>Change the state to {@link State#INSTALL_FAILED INSTALL_FAILED}.</li>
1: 	 * <li>Change the state to {@link State#UNINSTALLING UNINSTALLING}.</li>
1: 	 * <li>All content and dependencies which may have been installed by the
0: 	 * installing process must be uninstalled.
1: 	 * <li>Change the state to {@link State#UNINSTALLED UNINSTALLED}.</li>
1: 	 * <li>Unregister the subsystem service.</li>
1: 	 * <li>If the subsystem is a scoped subsystem then, uninstall the region
1: 	 * context bundle.</li>
1: 	 * <li>Throw a {@link SubsystemException} with the cause of the installation
1: 	 * failure.</li>
1: 	 * </ol>
1: 	 * @param location The location identifier of the subsystem to be installed.
1: 	 * @param content The input stream from which this subsystem will be read or
1: 	 *        {@code null} to indicate the input stream must be created from the
1: 	 * @throws IllegalStateException If this subsystem's state is in
1: 	 *         {@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
1: 	 *         INSTALL_FAILED}, {@link State#UNINSTALLING UNINSTALLING},
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 	 *         {@link SubsystemPermission}[installed subsystem,LIFECYCLE], and
1: 	 *         the runtime supports permissions.
1: 	public Subsystem install(String location, InputStream content);
1: 
1: 	 * <p>
1: 	 * An action of {@code Wait} means this method will block until a state
1: 	 * transition occurs, upon which the new state will be evaluated in order to
1: 	 * determine how to proceed. If a state transition does not occur in a
1: 	 * reasonable time while waiting then no action is taken and a
1: 	 * SubsystemException is thrown to indicate the subsystem was unable to be
1: 	 * started. An action of {@code Return} means this method returns
1: 	 * </p>
1: 	 * <table>
1: 	 * <tr>
1: 	 * <th>State</th>
1: 	 * <th width="4">Action</th>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALLING INSTALLING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALLED INSTALLED}</td>
0: 	 * <td>{@code Resolve}<br/>
0: 	 * {@code Start}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALL_FAILED INSTALL_FAILED}</td>
1: 	 * <td>{@code IllegalStateException}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#RESOLVING RESOLVING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#RESOLVED RESOLVED}</td>
1: 	 * <td>{@code Start}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#STARTING STARTING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#ACTIVE ACTIVE}</td>
1: 	 * <td>{@code Return}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#STOPPING STOPPING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#UNINSTALLING UNINSTALLING}</td>
1: 	 * <td>{@code IllegalStateException}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#UNINSTALLED UNINSTALLED}</td>
1: 	 * <td>{@code IllegalStateException}</td>
1: 	 * </tr>
1: 	 * <p>
1: 	 * <p>
1: 	 * <p>
1: 	 * <li>Set the subsystem <i>autostart setting</i> to <i>started</i>.</li>
1: 	 * <li>If this subsystem is in the {@link State#RESOLVED RESOLVED} state,
1: 	 * proceed to step 7.</li>
1: 	 * <li>Change the state to {@link State#RESOLVING RESOLVING}.</li>
1: 	 * <li>Resolve the content resources. A resolution failure results in a
1: 	 * start failure with a state of {@link State#INSTALLED INSTALLED}.</li>
1: 	 * <li>Change the state to {@link State#RESOLVED RESOLVED}.</li>
1: 	 * <li>If this subsystem is scoped, enable the export sharing policy.</li>
1: 	 * <li>Change the state to {@link State#STARTING STARTING}.</li>
1: 	 * <li>For each eligible resource, increment the active use count by one. If
1: 	 * the active use count is one, start the resource. All dependencies must be
1: 	 * started before any content resource, and content resources must be
1: 	 * started according to the specified
1: 	 * {@link SubsystemConstants#START_ORDER_DIRECTIVE start order}. If an error
1: 	 * occurs while starting a resource, a start failure results with that error
1: 	 * as the cause.</li>
1: 	 * <li>Change the state to {@link State#ACTIVE ACTIVE}.</li>
1: 	 * <p>
1: 	 * Implementations should be sensitive to the potential for long running
1: 	 * operations and periodically check the current thread for interruption. An
1: 	 * interrupted thread should be treated as a start failure with an
1: 	 * {@code InterruptedException} as the cause.
1: 	 * <p>
1: 	 * All start failure flows include the following, in order.
1: 	 * <ol>
1: 	 * <li>If the subsystem state is {@link State#STARTING STARTING} then change
1: 	 * the state to {@link State#STOPPING STOPPING} and stop all resources that
1: 	 * were started as part of this operation.</li>
1: 	 * <li>Change the state to either {@link State#INSTALLED INSTALLED} or
1: 	 * {@link State#RESOLVED RESOLVED}.</li>
1: 	 * <li>Throw a SubsystemException with the specified cause.</li>
1: 	 * </ol>
1: 	 * 
1: 	 * @throws SubsystemException If this subsystem fails to start.
1: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1: 	 *         {@link State#UNINSTALLING UNINSTALLING}, or
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}, or if the state of at
1: 	 *         least one of this subsystem's parents is not in
1: 	 *         {@link State#STARTING STARTING}, {@link State#ACTIVE ACTIVE}.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 	 *         {@link SubsystemPermission}[this,EXECUTE], and the runtime
1: 	 *         supports permissions.
1: 	public void start();
1: 
1: 	 * <p>
1: 	 * An action of {@code Wait} means this method will block until a state
1: 	 * transition occurs, upon which the new state will be evaluated in order to
1: 	 * determine how to proceed. If a state transition does not occur in a
1: 	 * reasonable time while waiting then no action is taken and a
1: 	 * SubsystemException is thrown to indicate the subsystem was unable to be
1: 	 * stopped. An action of {@code Return} means this method returns
1: 	 * </p>
1: 	 * <table>
1: 	 * <tr>
1: 	 * <th>State</th>
1: 	 * <th width="4">Action</th>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALLING INSTALLING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALLED INSTALLED}</td>
1: 	 * <td>{@code Return}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALL_FAILED INSTALL_FAILED}</td>
1: 	 * <td>{@code IllegalStateException}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#RESOLVING RESOLVING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#RESOLVED RESOLVED}</td>
1: 	 * <td>{@code Return}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#STARTING STARTING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#ACTIVE ACTIVE}</td>
1: 	 * <td>{@code Stop}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#STOPPING STOPPING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#UNINSTALLING UNINSTALLING}</td>
1: 	 * <td>{@code IllegalStateException}</td>
1: 	 * <td>
1: 	 * <tr>
1: 	 * <td>{@link State#UNINSTALLED UNINSTALLED}</td>
1: 	 * <td>{@code IllegalStateException}</td>
1: 	 * <td>
1: 	 * <p>
1: 	 * <p>
1: 	 * <p>
1: 	 * <li>Set the subsystem <i>autostart setting</i> to <i>stopped</i>.</li>
1: 	 * <li>Change the state to {@link State#STOPPING STOPPING}.</li>
1: 	 * <li>For each eligible resource, decrement the active use count by one. If
1: 	 * the active use count is zero, stop the resource. All content resources
1: 	 * must be stopped before any dependencies, and content resources must be
1: 	 * stopped in reverse {@link SubsystemConstants#START_ORDER_DIRECTIVE start
1: 	 * order}.</li>
1: 	 * <li>Change the state to {@link State#RESOLVED RESOLVED}.</li>
1: 	 * the {@link State#STOPPING STOPPING} state, every part of each step above
1: 	 * must be attempted. Errors subsequent to the first should be logged. Once
1: 	 * the stop process has completed, a SubsystemException must be thrown with
1: 	 * the initial error as the specified cause.
1: 	 * <p>
1: 	 * should terminate immediately. Once the transition to the
1: 	 * {@link State#STOPPING STOPPING} state has occurred, however, this method
1: 	 * must not terminate due to an interruption until the stop process has
1: 	 * completed.
1: 	 * 
1: 	 * @throws SubsystemException If this subsystem fails to stop cleanly.
1: 	 * @throws IllegalStateException If this subsystem's state is in
1: 	 *         {@link State#INSTALL_FAILED INSTALL_FAILED},
1: 	 *         {@link State#UNINSTALLING UNINSTALLING}, or
1: 	 *         {@link State#UNINSTALLED UNINSTALLED}.
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 	 *         {@link SubsystemPermission}[this,EXECUTE], and the runtime
1: 	 *         supports permissions.
1: 	 */
1: 	public void stop();
1: 
1: 	/**
1: 	 * Uninstalls this subsystem.
1: 	 * <p>
1: 	 * The following table shows which actions are associated with each state.
1: 	 * An action of {@code Wait} means this method will block until a state
1: 	 * transition occurs, upon which the new state will be evaluated in order to
1: 	 * determine how to proceed. If a state transition does not occur in a
1: 	 * reasonable time while waiting then no action is taken and a
1: 	 * SubsystemException is thrown to indicate the subsystem was unable to be
1: 	 * uninstalled. An action of {@code Return} means this method returns
1: 	 * immediately without taking any other action.
1: 	 * <table>
1: 	 * <tr>
1: 	 * <th>State</th>
1: 	 * <th width="4">Action</th>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALLING INSTALLING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALLED INSTALLED}</td>
1: 	 * <td>{@code Uninstall}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#INSTALL_FAILED INSTALL_FAILED}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#RESOLVING RESOLVING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#RESOLVED RESOLVED}</td>
1: 	 * <td>{@code Uninstall}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#STARTING STARTING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#ACTIVE ACTIVE}</td>
0: 	 * <td>{@code Stop}<br/>
0: 	 * {@code Uninstall}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#STOPPING STOPPING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#UNINSTALLING UNINSTALLING}</td>
1: 	 * <td>{@code Wait}</td>
1: 	 * </tr>
1: 	 * <tr>
1: 	 * <td>{@link State#UNINSTALLED UNINSTALLED}</td>
1: 	 * <td>{@code Return}</td>
1: 	 * </tr>
1: 	 * </table>
1: 	 * <p>
1: 	 * <p>
1: 	 * The following steps are required to uninstall this subsystem after being
1: 	 * stopped if necessary.
1: 	 * <li>Change the state to {@link State#INSTALLED INSTALLED}.</li>
1: 	 * <li>Change the state to {@link State#UNINSTALLING UNINSTALLING}.</li>
1: 	 * <li>For each referenced resource, decrement the reference count by one.
1: 	 * If the reference count is zero, uninstall the resource. All content
1: 	 * resources must be uninstalled before any dependencies.</li>
1: 	 * <li>Change the state to {@link State#UNINSTALLED UNINSTALLED}.</li>
1: 	 * <li>Unregister the subsystem service.</li>
1: 	 * <li>If the subsystem is scoped, uninstall the region context bundle.</li>
1: 	 * the {@link State#UNINSTALLING UNINSTALLING} state, every part of each
1: 	 * step above must be attempted. Errors subsequent to the first should be
1: 	 * logged. Once the uninstall process has completed, a
1: 	 * {@code SubsystemException} must be thrown with the specified cause.
1: 	 * <p>
1: 	 * Implementations should be sensitive to the potential for long running
1: 	 * operations and periodically check the current thread for interruption, in
1: 	 * which case a {@code SubsystemException} with an
1: 	 * {@code InterruptedException} as the cause should be thrown. If an
1: 	 * interruption occurs while waiting, this method should terminate
1: 	 * immediately. Once the transition to the {@link State#UNINSTALLING
1: 	 * UNINSTALLING} state has occurred, however, this method must not terminate
1: 	 * due to an interruption until the uninstall process has completed.
1: 	 * 
1: 	 * @throws SecurityException If the caller does not have the appropriate
1: 	 *         {@link SubsystemPermission}[this,LIFECYCLE], and the runtime
1: 	 *         supports permissions.
1: 	public void uninstall();
commit:aac6a2a
/////////////////////////////////////////////////////////////////////////
1:  * based on any unsatisfied content requirements.</li>
/////////////////////////////////////////////////////////////////////////
1:  * than one subsystem within the same region. The subsystem graph may be thought
0:  * of as is an acyclic digraph with one and only one source vertex, which is the
0:  * root subsystem. The edges have the child as the head and parent as the tail.
1:  * A subsystem has several identifiers.
/////////////////////////////////////////////////////////////////////////
0: 	 * 		<li>The value of the {@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME
0: 	 *          Subsystem-SymbolicName} header, if specified.
/////////////////////////////////////////////////////////////////////////
0: 	 * <li>Change the state to UNINSTALLING.</li>
0: 	 * <li>All content and dependencies which may have been installed by 
0: 	 *     the installing process must be uninstalled.
0: 	 * <li>Change the state to UNINSTALLED.</li>
0: 	 * <li>If the subsystem is a scoped subsystem then, uninstall the region context bundle.</li>
/////////////////////////////////////////////////////////////////////////
0: 	 *              started, Wait. Otherwise, Start.</td>
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * 		<li>Change the state to INSTALLED.
0: 	 * 		<li>For each referenced resource, decrement the reference count by one. 
0: 	 * 			If the reference count is zero, uninstall the resource. All content
commit:71fe81a
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.resource.Resource;
commit:a1c6951
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.namespace.IdentityNamespace;
/////////////////////////////////////////////////////////////////////////
0:  * and, therefore, have no sharing policy. There are three standard
1:  * {@link SubsystemConstants#SUBSYSTEM_TYPE types} of subsystems.
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application} - An
1:  * implicitly scoped subsystem. Nothing is exported, and imports are computed
0:  * based on any unsatisfied content dependencies.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite} - An
1:  * explicitly scoped subsystem. The sharing policy is defined by metadata within
1:  * the subsystem archive.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature} - An unscoped
1:  * subsystem.</li>
/////////////////////////////////////////////////////////////////////////
1:  * <li>{@link #getLocation() Location} - An identifier specified by the client
1:  * as part of installation. It is guaranteed to be unique within the same
1:  * framework.</li>
1:  * <li>{@link #getSubsystemId() ID} - An identifier generated by the
1:  * implementation as part of installation. It is guaranteed to be unique within
0:  * the same framework.
1:  * <li>{@link #getSymbolicName() Symbolic Name}/{@link #getVersion() Version} -
1:  * The combination of symbolic name and version is guaranteed to be unique
1:  * within the same region. Although {@link #getType() type} is not formally part
1:  * of the identity, two subsystems with the same symbolic names and versions but
1:  * different types are not considered to be equal.</li>
/////////////////////////////////////////////////////////////////////////
0:  * <tr align="center">
0:  * <th>Operation</th>
0:  * <th>From State</th>
0:  * <th>To State</th>
0:  * </tr>
0:  * <tr align="center">
0:  * <td>{@link #install(String, InputStream) Install}</td>
0:  * <td></td>
0:  * <td>{@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
0:  * INSTALL_FAILED}, {@link State#INSTALLED INSTALLED}</td>
0:  * </tr>
0:  * <tr align="center">
0:  * <td>{@link #start() Start}</td>
0:  * <td>{@link State#INSTALLED INSTALLED}, {@link State#RESOLVED RESOLVED}</td>
0:  * <td>{@link State#INSTALLED INSTALLED}, {@link State#RESOLVING RESOLVING},
0:  * {@link State#RESOLVED RESOLVED}, {@link State#STARTING STARTING},
0:  * {@link State#ACTIVE ACTIVE}</td>
0:  * </tr>
0:  * <tr align="center">
0:  * <td>{@link #stop() Stop}</td>
0:  * <td>{@link State#ACTIVE ACTIVE}</td>
0:  * <td>{@link State#RESOLVED RESOLVED}, {@link State#STOPPING STOPPING}</td>
0:  * </tr>
0:  * <tr align="center">
0:  * <td>{@link #uninstall() Uninstall}</td>
0:  * <td>{@link State#INSTALLED INSTALLED}, {@link State#RESOLVED RESOLVED},
0:  * {@link State#ACTIVE ACTIVE}</td>
0:  * <td>{@link State#UNINSTALLING UNINSTALLING}, {@link State#UNINSTALLED
0:  * UNINSTALLED}</td>
0:  * </tr>
/////////////////////////////////////////////////////////////////////////
0:  * or localized formats. There are five standard
1:  * {@link IdentityNamespace#CAPABILITY_TYPE_ATTRIBUTE types} of resources that
1:  * may be included in a subsystem.
1:  * <li>{@link IdentityNamespace#TYPE_BUNDLE Bundle} - A bundle that is not a
1:  * fragment.</li>
1:  * <li>{@link IdentityNamespace#TYPE_FRAGMENT Fragment} - A fragment bundle.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application
0:  * Subsystem} - An application subsystem defined by this specification.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite Subsystem} -
0:  * A composite subsystem defined by this specification.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature Subsystem} - A
0:  * feature subsystem defined by this specification.</li>
0:  * <li>A resource was listed as part of the subsystem's content.</li>
1:  * <li>A subsystem resource is a child of the subsystem.</li>
1:  * <li>The subsystem has a provision policy of accept dependencies.</li>
0:  * <li>A bundle resource was installed using the region bundle context.</li>
0:  * <li>A bundle resource was installed using the bundle context of another
1:  * resource contained by the subsystem.</li>
/////////////////////////////////////////////////////////////////////////
0:  * <li>{@link SubsystemConstants#SUBSYSTEM_ID_PROPERTY ID} - Matches the ID of
0:  * the subsystem.</li>
1:  * <li>{@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME_PROPERTY Symbolic Name}
0:  * - Matches the symbolic name of the subsystem.</li>
0:  * <li>{@link SubsystemConstants#SUBSYSTEM_VERSION_PROPERTY Version} - Matches
0:  * the version of the subsystem.</li>
0:  * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_PROPERTY Type} - Matches the
0:  * type of the subsystem.</li>
0:  * <li>{@link SubsystemConstants#SUBSYSTEM_STATE_PROPERTY State} - Matches the
0:  * state of the subsystem.</li>
1:  * <li>The ID is {@code 0}.</li>
0:  * <li>The symbolic name is {@code org.osgi.service.subsystem.root}.</li>
1:  * <li>The version matches this specification's version.</li>
1:  * <li>It has no parents.</li>
0:  * <li>All existing bundles, including the system and subsystems implementation
0:  * bundles, become constituents.</li>
0:  * <li>The type is {@code osgi.subsystem.application} with no imports.</li>
0:  * <li>The provision policy is {@code acceptDependencies}.</li>
/////////////////////////////////////////////////////////////////////////
0: 		 * its content and dependencies. If the start method completes
/////////////////////////////////////////////////////////////////////////
0: 		 * A subsystem is in the ACTIVE state when its content and dependencies
0: 		 * have been successfully started and activated.
/////////////////////////////////////////////////////////////////////////
0: 		 * content and dependencies. When the stop method completes, the
/////////////////////////////////////////////////////////////////////////
0: 		 * to uninstall its constituent and dependencies. When the
/////////////////////////////////////////////////////////////////////////
0: 		 * and dependencies are uninstalled. The subsystem is in an
/////////////////////////////////////////////////////////////////////////
0: 	 * implementation dependent manner, the specified {@code location}.
1: 	 * of the subsystem service registration.
/////////////////////////////////////////////////////////////////////////
0: 	 * <li>Uninstall all resources installed as part of this operation.</li>
0: 	 * <li>Change the state to INSTALL_FAILED.</li>
0: 	 * <li>Unregister the subsystem service.</li>
0: 	 * <li>Uninstall the region context bundle.</li>
0: 	 * <li>Throw a SubsystemException with the specified cause.</li>
1: 	 * The following steps are required to install a subsystem.
0: 	 * identifier already exists, return the installed subsystem.</li>
0: 	 * name, version, and type of the installing subsystem. If an error occurs
0: 	 * while reading the content, an installation failure results.</li>
1: 	 * already exists within this subsystem's region, complete the installation
0: 	 * with one of the following.
1: 	 * <ul>
0: 	 * <li>If the installing and installed subsystems' types are not equal, an
0: 	 * installation failure results.</li>
0: 	 * <li>If the installing and installed subsystems' types are equal, and the
1: 	 * installed subsystem is already a child of this subsystem, return the
0: 	 * installed subsystem.</li>
0: 	 * <li>If the installing and installed subsystems' types are equal, and the
1: 	 * installed subsystem is not already a child of this subsystem, add the
1: 	 * installed subsystem as a child of this subsystem, increment the installed
0: 	 * subsystem's reference count by one, and return the installed subsystem.</li>
1: 	 * </ul>
0: 	 * {@code content}.</li>
1: 	 * bundle.</li>
0: 	 * <li>Change the state to INSTALLING and register a new subsystem service.</li>
1: 	 * <li>Discover the subsystem's content resources. If any mandatory resource
1: 	 * is missing, an installation failure results.</li>
1: 	 * <li>Discover the dependencies required by the content resources. If any
1: 	 * mandatory dependency is missing, an installation failure results.</li>
0: 	 * <li>{@link ResolverHook Disable} runtime resolution for the resources.</li>
0: 	 * reference count is one, install the resource. All dependencies must be
0: 	 * installed before any content resource. If an error occurs while
1: 	 * installing a resource, an install failure results with that error as the
1: 	 * cause.</li>
1: 	 * <li>If the subsystem is scoped, enable the import sharing policy.</li>
1: 	 * <li>Enable runtime resolution for the resources.</li>
0: 	 * <li>Change the state of the subsystem to INSTALLED.</li>
1: 	 * <li>Return the new subsystem.</li>
/////////////////////////////////////////////////////////////////////////
1: 	 * @throws SecurityException If the caller does not have the appropriate
0: 	 *         SubsystemPermission[installed subsystem,LIFECYCLE], and the
0: 	 *         runtime supports permissions.
/////////////////////////////////////////////////////////////////////////
0: 	 *          dependencies must be started before any content
/////////////////////////////////////////////////////////////////////////
0: 	 *          content resources must be stopped before any dependencies,
0: 	 *          and content resources must be stopped in reverse
/////////////////////////////////////////////////////////////////////////
0: 	 * 			resources must be uninstalled before any dependencies. If
commit:b8ad309
/////////////////////////////////////////////////////////////////////////
0:  * Copyright (c) OSGi Alliance (2012). All Rights Reserved.
/////////////////////////////////////////////////////////////////////////
0:  * 			<td> </td>
/////////////////////////////////////////////////////////////////////////
0:  * A subsystem archive is a ZIP file having an ESA extension and containing
0:  * or localized formats. There are five standard {@link
/////////////////////////////////////////////////////////////////////////
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application 
0:  *          Subsystem} - An application subsystem defined by this specification.
0:  * 		</li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite  
0:  *          Subsystem} - A composite subsystem defined by this specification.
0:  * 		</li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature 
0:  *          Subsystem} - A feature subsystem defined by this specification.
/////////////////////////////////////////////////////////////////////////
0:  *      <li>The type is {@code osgi.application} with no imports.
/////////////////////////////////////////////////////////////////////////
0: 	 * returned. Both original and derived headers will be included.
/////////////////////////////////////////////////////////////////////////
1: 	 * This method must continue to return this subsystem's type while this
1: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
/////////////////////////////////////////////////////////////////////////
0: 	 * <table border="1">
0: 	 * 			<th>State</th>
0: 	 * 			<th>Action</th>
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
1: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.hooks.resolver.ResolverHook;
0: import org.osgi.framework.resource.ResourceConstants;
0: import org.osgi.service.repository.Repository;
0: import org.osgi.service.resolver.Resolver;
1:  * A subsystem is a collection of resources constituting a logical, possibly
1:  * isolated, unit of functionality.
0:  * <p/>
0:  * A subsystem may be scoped or unscoped. Scoped subsystems are isolated by
0:  * implicit or explicit sharing policies. Unscoped subsystems are not isolated
0:  * and, therefore, have no sharing policy. There are three standard {@link
0:  * SubsystemConstants#SUBSYSTEM_TYPE types} of subsystems.
1:  * <ul>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application} -
0:  *          An implicitly scoped subsystem. Nothing is exported, and imports are
0:  *          computed based on any unsatisfied content dependencies.
0:  * 		</li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite} - An
0:  *          explicitly scoped subsystem. The sharing policy is defined by
0:  *          metadata within the subsystem archive.
0:  * 		</li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature} - An
0:  *          unscoped subsystem.
0:  * 		</li>
1:  * </ul>
1:  * Conceptually, a subsystem may be thought of as existing in an isolated region
1:  * along with zero or more other subsystems. Each region has one and only one
1:  * scoped subsystem, which dictates the sharing policy. The region may, however,
1:  * have many unscoped subsystems. It is, therefore, possible to have shared
1:  * constituents across multiple subsystems within a region. Associated with each
1:  * region is a bundle whose context may be {@link #getBundleContext() retrieved}
1:  * from any subsystem within that region. This context may be used to monitor
1:  * activity occurring within the region.
0:  * <p/>
1:  * A subsystem may have {@link #getChildren() children} and, unless it's the
1:  * root subsystem, must have at least one {@link #getParents() parent}.
1:  * Subsystems become children of the subsystem in which they are installed.
1:  * Unscoped subsystems have more than one parent if they are installed in more
0:  * than one subsystem within the same region. A scoped subsystem always has only
0:  * one parent. The subsystem graph may be thought of as is an acyclic digraph
0:  * with one and only one source vertex, which is the root subsystem. The edges
0:  * have the child as the head and parent as the tail.
0:  * <p/>
0:  * A subsystem has several unique identifiers.
1:  * <ul>
0:  * 		<li>{@link #getLocation() Location} - An identifier specified by the
0:  *          client as part of installation. It is guaranteed to be unique within
0:  *          the same framework.
0:  *     </li>
0:  * 		<li>{@link #getSubsystemId() ID} - An identifier generated by the
0:  *          implementation as part of installation. It is guaranteed to be
0:  *          unique within the same framework.
0:  * 		<li>{@link #getSymbolicName() Symbolic Name}/{@link #getVersion()
0:  *          Version} - The combination of symbolic name and version is
0:  *          guaranteed to be unique within the same region. Although {@link
0:  *          #getType() type} is not formally part of the identity, two
0:  *          subsystems with the same symbolic names and versions but different
0:  *          types are not considered to be equal.
0:  *     </li>
1:  * </ul>
1:  * A subsystem has a well-defined {@link State life cycle}. Which stage a
1:  * subsystem is in may be obtained from the subsystem's {@link #getState()
1:  * state} and is dependent on which life cycle operation is currently active or
0:  * was last invoked. The following table summarizes the relationship between
0:  * life cycle operations and states.
0:  * <p/>
0:  * <table border="1">
0:  * 		<tr align="center">
0:  * 			<th>Operation</th>
0:  * 			<th>From State</th>
0:  * 			<th>To State</th>
0:  * 		</tr>
0:  * 		<tr align="center">
0:  * 			<td>{@link #install(String, InputStream) Install}</td>
0:  * 			<td>&nbsp;</td>
0:  * 			<td>{@link State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED
0:  *              INSTALL_FAILED}, {@link State#INSTALLED INSTALLED}
0:  *      	</td>
0:  * 		</tr>
0:  * 		<tr align="center">
0:  * 			<td>{@link #start() Start}</td>
0:  * 			<td>{@link State#INSTALLED INSTALLED}, {@link State#RESOLVED 
0:  *              RESOLVED}
0:  *          </td>
0:  * 			<td>{@link State#INSTALLED INSTALLED}, {@link State#RESOLVING
0:  *              RESOLVING}, {@link State#RESOLVED RESOLVED}, {@link
0:  *              State#STARTING STARTING}, {@link State#ACTIVE ACTIVE}
0:  *      	</td>
0:  * 		</tr>
0:  * 		<tr align="center">
0:  * 			<td>{@link #stop() Stop}</td>
0:  * 			<td>{@link State#ACTIVE ACTIVE}</td>
0:  * 			<td>{@link State#RESOLVED RESOLVED}, {@link State#STOPPING STOPPING}
0:  *      	</td>
0:  * 		</tr>
0:  * 		<tr align="center">
0:  * 			<td>{@link #uninstall() Uninstall}</td>
0:  * 			<td>{@link State#INSTALLED INSTALLED}, {@link State#RESOLVED
0:  *              RESOLVED}, {@link State#ACTIVE ACTIVE}
0:  *      	</td>
0:  * 			<td>{@link State#UNINSTALLING UNINSTALLING}, {@link
0:  *              State#UNINSTALLED UNINSTALLED}
0:  *      	</td>
0:  * 		</tr>
1:  * </table>
0:  * <p/>
0:  * A subsystem archive is a ZIP file having an SSA extension and containing
0:  * metadata describing the subsystem. The form of the metadata may be a
0:  * subsystem or deployment manifest, as well as any content resource files. The
0:  * manifests are optional and will be computed if not present. The subsystem
1:  * manifest headers may be {@link #getSubsystemHeaders(Locale) retrieved} in raw
0:  * or localized formats. There are three standard {@link
0:  * ResourceConstants#IDENTITY_TYPE_ATTRIBUTE types} of resources that may be
0:  * included in a subsystem.
1:  * <ul>
0:  * 		<li>{@link ResourceConstants#IDENTITY_TYPE_BUNDLE Bundle} - A bundle
0:  *          that is not a fragment.
0:  * 		</li>
0:  * 		<li>{@link ResourceConstants#IDENTITY_TYPE_FRAGMENT Fragment} - A
0:  *          fragment bundle.
0:  * 		</li>
0:  * 		<li>{@link SubsystemConstants#IDENTITY_TYPE_SUBSYSTEM Subsystem} - A
0:  *          subsystem defined by this specification.
0:  * 		</li>
1:  * </ul>
1:  * Resources contained by a subsystem are called {@link #getConstituents()
1:  * constituents}. There are several ways a resource may become a constituent of
0:  * a subsystem, at least some of which are listed below.
0:  * <p/>
1:  * <ul>
0:  * 		<li>A resource was listed as part of the subsystem's content.
0:  * 		</li>
0:  * 		<li>A subsystem resource is a child of the subsystem.
0:  * 		</li>
0:  * 		<li>The subsystem has a provision policy of accept transitive.
0:  * 		</li>
0:  * 		<li>A bundle resource was installed using the region bundle context.
0:  * 		</li>
0:  * 		<li>A bundle resource was installed using the bundle context of
0:  *          another resource contained by the subsystem.
0:  *      </li>
1:  * </ul>
1:  * In addition to invoking one of the install methods, a subsystem instance may
0:  * be obtained through the service registry. Every installed subsystem has a
1:  * corresponding service registration. A subsystem service has the following
1:  * properties.
0:  * <p/>
1:  * <ul>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_ID_PROPERTY ID} - Matches the ID
0:  *          of the subsystem.
0:  * 		</li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME_PROPERTY Symbolic
0:  *          Name} - Matches the symbolic name of the subsystem.
0:  *      </li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_VERSION_PROPERTY Version} -
0:  *          Matches the version of the subsystem.
0:  *      </li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_TYPE_PROPERTY Type} - Matches
0:  *          the type of the subsystem.
0:  *      </li>
0:  * 		<li>{@link SubsystemConstants#SUBSYSTEM_STATE_PROPERTY State} - Matches
0:  *          the state of the subsystem.
0:  *      </li>
1:  * </ul>
1:  * Because a subsystem must be used to install other subsystems, a root
0:  * subsystem is provided as a starting point and has the following
0:  * characteristics. The root subsystem may only be obtained as a service.
0:  * <p/>
1:  * <ul>
0:  * 		<li>The ID is {@code 0}.
0:  * 		</li>
0:  * 		<li>The symbolic name is {@code org.osgi.service.subsystem.root}.
0:  * 		</li>
0:  * 		<li>The version matches this specification's version.
0:  * 		</li>
0:  * 		<li>It has no parents.
0:  * 		</li>
0:  * 		<li>All existing bundles, including the system and subsystems
0:  *          implementation bundles, become constituents.
0:  *      </li>
0:  *      <li>The type is {@code osgi.composite} with no imports or exports.
0:  *      </li>
0:  * 		<li>The provision policy is {@code acceptTransitive}.
0:  * 		</li>
1:  * </ul>
1: 	 * An enumeration of the possible states of a subsystem.
0: 	 * <p/>
1: 	 * These states are a reflection of what constituent resources are permitted
0: 	 * to do, not an aggregation of resource states. 
1: 		 * The subsystem is in the process of installing.
0: 		 * <p/>
0: 		 * A subsystem is in the INSTALLING state when the {@link Subsystem#
0: 		 * install(String, InputStream) install} method of its parent is active,
0: 		 * and attempts are being made to install its content resources. If the
0: 		 * install method completes without exception, then the subsystem has
0: 		 * successfully installed and must move to the INSTALLED state.
0: 		 * Otherwise, the subsystem has failed to install and must move to the
0: 		 * INSTALL_FAILED state.
1: 		 * The subsystem is installed but not yet resolved.
0: 		 * <p/>
0: 		 * A subsystem is in the INSTALLED state when it has been installed in
0: 		 * a parent subsystem but is not or cannot be resolved. This state is
0: 		 * visible if the dependencies of the subsystem's content resources
0: 		 * cannot be resolved.
1: 		 * The subsystem failed to install.
0: 		 * <p/>
0: 		 * A subsystem is in the INSTALL_FAILED state when an unrecoverable
0: 		 * error occurred during installation. The subsystem is in an unusable
0: 		 * state but references to the subsystem object may still be available
0: 		 * and used for introspection.
1: 		 */
1: 		INSTALL_FAILED,
1: 		/**
1: 		 * The subsystem is in the process of resolving.
0: 		 * <p/>
0: 		 * A subsystem is in the RESOLVING state when the {@link Subsystem#
0: 		 * start() start} method is active, and attempts are being made to
0: 		 * resolve its content resources. If the resolve method completes
0: 		 * without exception, then the subsystem has successfully resolved and
0: 		 * must move to the RESOLVED state. Otherwise, the subsystem has failed
0: 		 * to resolve and must move to the INSTALLED state.
1: 		 * The subsystem is resolved and able to be started.
0: 		 * <p/>
0: 		 * A subsystem is in the RESOLVED state when all of its content
1: 		 * resources are resolved. Note that the subsystem is not active yet.
1: 		 * The subsystem is in the process of starting.
0: 		 * <p/>
0: 		 * A subsystem is in the STARTING state when its {@link Subsystem#
0: 		 * start() start} method is active, and attempts are being made to start
0: 		 * its content and transitive resources. If the start method completes
0: 		 * without exception, then the subsystem has successfully started and
0: 		 * must move to the ACTIVE state. Otherwise, the subsystem has failed to
0: 		 * start and must move to the RESOLVED state.
1: 		 * The subsystem is now running.
0: 		 * <p/>
0: 		 * A subsystem is in the ACTIVE state when its content and transitive
0: 		 * resources have been successfully started and activated.
1: 		 * The subsystem is in the process of stopping.
0: 		 * <p/>
0: 		 * A subsystem is in the STOPPING state when its {@link Subsystem#stop()
0: 		 * stop} method is active, and attempts are being made to stop its
0: 		 * content and transitive resources. When the stop method completes, the
0: 		 * subsystem is stopped and must move to the RESOLVED state.
1: 		/**
1: 		 * The subsystem is in the process of uninstalling.
0: 		 * <p/>
0: 		 * A subsystem is in the UNINSTALLING state when its {@link Subsystem#
0: 		 * uninstall() uninstall} method is active, and attempts are being made
0: 		 * to uninstall its constituent and transitive resources. When the
0: 		 * uninstall method completes, the subsystem is uninstalled and must
0: 		 * move to the UNINSTALLED state.
1: 		 */
1: 		 * The subsystem is uninstalled and may not be used.
0: 		 * <p/>
0: 		 * The UNINSTALLED state is only visible after a subsystem's constituent
0: 		 * and transitive resources are uninstalled. The subsystem is in an
1: 		 * unusable state but references to the subsystem object may still be
1: 		 * available and used for introspection.
1: 	 * Returns the bundle context of the region within which this subsystem
1: 	 * resides.
0: 	 * <p/>
1: 	 * The bundle context offers the same perspective of any resource contained
1: 	 * by a subsystem within the region. It may be used, for example, to monitor
1: 	 * events internal to the region as well as external events visible to the
1: 	 * region. All subsystems within the same region have the same bundle
1: 	 * context. If this subsystem is in a state where the bundle context would
0: 	 * be invalid, null is returned.
1: 	 * 
1: 	 * @return The bundle context of the region within which this subsystem
0: 	 *         resides or null if this subsystem's state is in {{@link
0: 	 *         State#INSTALL_FAILED INSTALL_FAILED}, {@link State#UNINSTALLED
0: 	 *         UNINSTALLED}}.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
1: 	 *         {@link SubsystemPermission}[this,CONTEXT], and the runtime
1: 	 *         supports permissions.
1: 	public BundleContext getBundleContext();
1: 	 * Returns the child subsystems of this subsystem.
0: 	 * <p/>
0: 	 * The returned collection is an immutable snapshot of all subsystems that
0: 	 * are installed in this subsystem. The collection will be empty if no
0: 	 * subsystems are installed in this subsystem.
0: 	 * @return The child subsystems of this subsystem.
1: 	 * @throws IllegalStateException If this subsystem's state is in
0: 	 *         {{@link State#INSTALL_FAILED INSTALL_FAILED}, {@link
0: 	 *         State#UNINSTALLED UNINSTALLED}}.
1: 	 * Returns the headers for this subsystem's subsystem manifest.
0: 	 * <p/>
0: 	 * The returned map is unmodifiable. Each map key is a header name, and each
0: 	 * map value is the corresponding header value. Because header names are
0: 	 * case-insensitive, the methods of the map must treat them in a
0: 	 * case-insensitive manner. If the header name is not found, null is
0: 	 * returned. Both original and synthesized headers will be included.
0: 	 * <p/>
0: 	 * The header values are translated according to the specified locale. If
0: 	 * the specified locale is null or not supported, the raw values are
0: 	 * returned. If the translation for a particular header is not found, the
0: 	 * raw value is returned.
0: 	 * <p/>
1: 	 * This method must continue to return the headers while this subsystem is
0: 	 * in the {@link State#INSTALL_FAILED INSTALL_FAILED} or {@link
0: 	 * State#UNINSTALLED UNINSTALLED} states.
0: 	 * @param locale The locale for which translations are desired.
0: 	 * @return The headers for this subsystem's subsystem manifest.
1: 	 *         {@link SubsystemPermission}[this,METADATA], and the runtime
1: 	 *         supports permissions.
1: 	public Map<String, String> getSubsystemHeaders(Locale locale);
1: 	 * Returns the location identifier of this subsystem.
0: 	 * <p/>
1: 	 * The location identifier is the {@code location} that was passed to the
0: 	 * {@link #install(String, InputStream) install} method of the {@link
0: 	 * #getParents() parent} subsystem. It is unique within the framework.
0: 	 * <p/>
1: 	 * This method must continue to return this subsystem's headers while this
0: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or {@link
0: 	 * State#UNINSTALLED UNINSTALLED} states.
1: 	 * @return The location identifier of this subsystem.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
1: 	 *         {@link SubsystemPermission}[this,METADATA], and the runtime
1: 	 *         supports permissions.
1: 	 * Returns the parent subsystems of this subsystem.
0: 	 * <p/>
0: 	 * The returned collection is an immutable snapshot of all subsystems in
0: 	 * which this subsystem is installed. The collection will be empty for the
0: 	 * root subsystem; otherwise, it will contain at least one parent. Scoped
0: 	 * subsystems always have only one parent. Unscoped subsystems may have
0: 	 * multiple parents.
0: 	 * @return The parent subsystems of this subsystem.
0: 	 * @throws IllegalStateException If this subsystem's state is in {{@link
0: 	 *         State#INSTALL_FAILED INSTALL_FAILED}, {@link State#UNINSTALLED
0: 	 *         UNINSTALLED}}.
1: 	public Collection<Subsystem> getParents();
1: 	 * Returns the constituent resources of this subsystem.
0: 	 * <p/>
0: 	 * The returned collection is an immutable snapshot of the constituent
0: 	 * resources of this subsystem. If this subsystem has no constituents,
0: 	 * the collection will be empty.
1: 	 * 
0: 	 * @return The constituent resources of this subsystem.
0: 	 * @throws IllegalStateException If this subsystem's state is in {{@link
0: 	 *         State#INSTALL_FAILED INSTALL_FAILED}, {@link State#UNINSTALLED
0: 	 *         UNINSTALLED}}.
1: 	 */
1: 	public Collection<Resource> getConstituents();
1: 	
1: 	/**
1: 	 * Returns the current state of this subsystem.
0: 	 * <p/>
1: 	 * This method must continue to return this subsystem's state while this
0: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or {@link
0: 	 * State#UNINSTALLED UNINSTALLED} states.
1: 	 * 
1: 	 * @return The current state of this subsystem.
1: 	 * Returns the identifier of this subsystem.
0: 	 * <p/>
1: 	 * The identifier is a monotonically increasing, non-negative integer
1: 	 * automatically generated at installation time and guaranteed to be unique
1: 	 * within the framework. The identifier of the root subsystem is zero.
0: 	 * <p/>
1: 	 * This method must continue to return this subsystem's identifier while
1: 	 * this subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 	 * 
1: 	 * @return The identifier of this subsystem.
1: 	 * Returns the symbolic name of this subsystem.
0: 	 * <p/>
1: 	 * The subsystem symbolic name conforms to the same grammar rules as the
1: 	 * bundle symbolic name and is derived from one of the following, in order.
1: 	 * <ul>
0: 	 * 		<li>The value of the {@link SubsystemConstants#SUBSYSTEM_CONTENT
0: 	 *          Subsystem-Content} header, if specified.
0: 	 * 		</li>
0: 	 * 		<li>The subsystem URI if passed as the {@code location} along with
0: 	 *          the {@code content} to the {@link #install(String, InputStream)
0: 	 *          install} method.
0: 	 *      </li>
0: 	 * 		<li>Optionally generated in an implementation specific way.
0: 	 * 		</li>
1: 	 * </ul>
0: 	 * The combination of symbolic name and {@link #getVersion() version} is
0: 	 * unique within a region. The symbolic name of the root subsystem is {@code
1: 	 * org.osgi.service.subsystem.root}.
0: 	 * <p/>
1: 	 * This method must continue to return this subsystem's symbolic name while
1: 	 * this subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or
1: 	 * {@link State#UNINSTALLED UNINSTALLED} states.
1: 	 * Returns the {@link SubsystemConstants#SUBSYSTEM_TYPE type} of this
1: 	 * subsystem.
0: 	 * <p/>
0: 	 * The type of the root subsystem is {@link
0: 	 * SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE composite}. This method must
0: 	 * continue to return this subsystem's type while this subsystem is in the
0: 	 * {@link State#INSTALL_FAILED INSTALL_FAILED} or {@link State#UNINSTALLED
0: 	 * UNINSTALLED} states.
1: 	 * 
1: 	 * @return The type of this subsystem.
1: 	 */
1: 	public String getType();
1: 	
1: 	/**
1: 	 * Returns the {@link SubsystemConstants#SUBSYSTEM_VERSION version} of this
1: 	 * subsystem.
0: 	 * <p/>
1: 	 * The subsystem version conforms to the same grammar rules as the bundle
1: 	 * version and is derived from one of the following, in order.
1: 	 * <ul>
0: 	 * 		<li>The value of the {@code Subsystem-Version} header, if specified.
0: 	 * 		</li>
0: 	 * 		<li>The subsystem URI if passed as the {@code location} along with
0: 	 *          the {@code content} to the {@link #install(String, InputStream)
0: 	 *          install} method.
0: 	 *      </li>
0: 	 * 		<li>Defaults to {@code 0.0.0}.
0: 	 * 		</li>
1: 	 * </ul>
0: 	 * The combination of {@link #getSymbolicName() symbolic name} and version
0: 	 * is unique within a region. The version of the root subsystem matches this
0: 	 * specification's version.
0: 	 * <p/>
1: 	 * This method must continue to return this subsystem's version while this
0: 	 * subsystem is in the {@link State#INSTALL_FAILED INSTALL_FAILED} or {@link
0: 	 * State#UNINSTALLED UNINSTALLED} states.
0: 	 * Installs a subsystem from the specified {@code location} identifier.
0: 	 * <p/>
0: 	 * This method performs the same function as calling {@link
0: 	 * #install(String, InputStream)} with the specified {@code location}
0: 	 * identifier and {@code null} as the {@code content}.
1: 	 * 
0: 	 * @param location - The location identifier of the subsystem to install.
0: 	 * @throws IllegalStateException If this subsystem's state is in {{@link
0: 	 * State#INSTALLING INSTALLING}, {@link State#INSTALL_FAILED INSTALL_FAILED}
0: 	 * , {@link State#UNINSTALLING UNINSTALLING}, {@link State#UNINSTALLED
0: 	 * UNINSTALLED}}.
1: 	 * @throws SubsystemException If the installation failed.
1: 	 *         {@link SubsystemPermission}[installed subsystem,LIFECYCLE], and
1: 	 *         the runtime supports permissions.
1: 	 * @see #install(String, InputStream)
0: 	 * Installs a subsystem from the specified {@code content}.
0: 	 * The specified {@code location} will be used as an identifier of the
0: 	 * subsystem. Every installed subsystem is uniquely identified by its
0: 	 * location, which is typically in the form of a URI. If the specified
0: 	 * {@code location} conforms to the {@code subsystem-uri} grammar, the
0: 	 * required symbolic name and optional version information will be used as
0: 	 * default values.
0: 	 * If the specified {@code content} is null, a new input stream must be
1: 	 * created from which to read the subsystem by interpreting, in an
0: 	 * implementation dependent manner, the specified {@code location}. 
1: 	 * A subsystem installation must be persistent. That is, an installed
1: 	 * subsystem must remain installed across Framework and VM restarts.
1: 	 * All references to changing the state of this subsystem include both
1: 	 * changing the state of the subsystem object as well as the state property
1: 	 * of the subsystem service registration. 
1: 	 * Implementations should be sensitive to the potential for long running
0: 	 * operations and periodically check the current thread for interruption. An
0: 	 * interrupted thread should result in a SubsystemException with an
0: 	 * InterruptedException as the cause and be treated as an installation
0: 	 * failure.
0: 	 * <p/>
0: 	 * All installation failure flows include the following, in order.
0: 	 * 		<li>Uninstall all resources installed as part of this operation.
0: 	 *      </li>
0: 	 * 		<li>Change the state to INSTALL_FAILED.
0: 	 * 		</li>
0: 	 *      <li>Unregister the subsystem service.
0: 	 *      </li>
0: 	 *      <li>Uninstall the region context bundle.
0: 	 *      </li>
0: 	 *      <li>Throw a SubsystemException with the specified cause.
0: 	 *      </li>
0: 	 * The following steps are required to install a subsystem. 
1: 	 * <ol>
0: 	 * <li>If an installed subsystem with the specified {@code location}
0: 	 *     identifier already exists, return the installed subsystem.
0: 	 * </li>
0: 	 * <li>Read the specified {@code content} in order to determine the symbolic
0: 	 *     name, version, and type of the installing subsystem. If an error
0: 	 *     occurs while reading the content, an installation failure results.
0: 	 * </li>
1: 	 * <li>If an installed subsystem with the same symbolic name and version
0: 	 *     already exists within this subsystem's region, complete the
0: 	 *     installation with one of the following.
0: 	 *     <ul>
0: 	 *     <li>If the installing and installed subsystems' types are not equal,
0: 	 *         an installation failure results.
0: 	 *     </li>
0: 	 *     <li>If the installing and installed subsystems' types are equal, and
0: 	 *         the installed subsystem is already a child of this subsystem,
0: 	 *         return the installed subsystem.
0: 	 *     </li>
0: 	 *     <li>If the installing and installed subsystems' types are equal, and
0: 	 *         the installed subsystem is not already a child of this subsystem,
0: 	 *         add the installed subsystem as a child of this subsystem,
0: 	 *         increment the installed subsystem's reference count by one, and
0: 	 *         return the installed subsystem.
0: 	 *     </li>
0: 	 *     </ul>
0: 	 * </li>
0: 	 * <li>Create a new subsystem based on the specified {@code location} and
0: 	 *     {@code content}.
0: 	 * </li>
0: 	 * <li>If the subsystem is scoped, install and activate a new region context
0: 	 *     bundle.
0: 	 * </li>
0: 	 * <li>Change the state to INSTALLING and register a new subsystem service.
0: 	 * </li>
0: 	 * <li>{@link Repository Discover} the subsystem's content resources. If any
0: 	 *     mandatory resource is missing, an installation failure results.
0: 	 * </li>
0: 	 * <li>{@link Resolver Discover} the transitive resources required by the
0: 	 *     content resources. If any transitive resource is missing, an
0: 	 *     installation failure results.
0: 	 * </li>
0: 	 * <li>{@link ResolverHook Disable} runtime resolution for the resources.
0: 	 * </li>
1: 	 * <li>For each resource, increment the reference count by one. If the
0: 	 *     reference count is one, install the resource. All transitive
0: 	 *     resources must be installed before any content resource. If an error
0: 	 *     occurs while installing a resource, an install failure results with
0: 	 *     that error as the cause.
0: 	 * </li>
0: 	 * <li>If the subsystem is scoped, enable the import sharing policy.
0: 	 * </li>
0: 	 * <li>Enable runtime resolution for the resources.
0: 	 * </li>
0: 	 * <li>Change the state of the subsystem to INSTALLED.
0: 	 * </li>
0: 	 * <li>Return the new subsystem.
0: 	 * </li>
1: 	 * </ol>
1: 	 * 
0: 	 * @param location - The location identifier of the subsystem to be
0: 	 *        installed.
0: 	 * @param content - The input stream from which this subsystem will be read
0: 	 *        or null to indicate the input stream must be created from the
1: 	 *        specified location identifier. The input stream will always be
1: 	 *        closed when this method completes, even if an exception is thrown.
0: 	 * @throws IllegalStateException If this subsystem's state is in {INSTALLING
0: 	 *         , INSTALL_FAILED, UNINSTALLING, UNINSTALLED}.
1: 	 * @throws SubsystemException If the installation failed.
0: 	 *         SubsystemPermission[installed subsystem,LIFECYCLE], and the runtime
1: 	 *         supports permissions.
1: 	 * Starts this subsystem.
0: 	 * <p/>
1: 	 * The following table shows which actions are associated with each state.
0: 	 * An action of Wait means this method will block until a state transition
0: 	 * occurs, upon which the new state will be evaluated in order to
0: 	 * determine how to proceed. An action of Return means this method returns
1: 	 * immediately without taking any other action.
0: 	 * <p/>
0: 	 * <table border="1">
0: 	 * 		<tr>
0: 	 * 			<th>State</td>
0: 	 * 			<th>Action</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALLING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALLED</td>
0: 	 * 			<td>Resolve, Start</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALL_FAILED</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>RESOLVING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>RESOLVED</td>
0: 	 * 			<td>If this subsystem is in the process of being<br/>
0: 	 *              started, Wait. Otherwise, Uninstall.</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>STARTING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>ACTIVE</td>
0: 	 * 			<td>Return</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>STOPPING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>UNINSTALLING</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>UNINSTALLED</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
1: 	 * </table>
0: 	 * <p/>
1: 	 * All references to changing the state of this subsystem include both
1: 	 * changing the state of the subsystem object as well as the state property
1: 	 * of the subsystem service registration.
0: 	 * <p/>
1: 	 * Implementations should be sensitive to the potential for long running
0: 	 * operations and periodically check the current thread for interruption. An
0: 	 * interrupted thread should be treated as a start failure with an
0: 	 * InterruptedException as the cause.
0: 	 * <p/>
0: 	 * All start failure flows include the following, in order.
1: 	 * <ol>
0: 	 * 		<li>Stop all resources that were started as part of this operation.
0: 	 *      </li>
0: 	 *      <li>Disable the export sharing policy.
0: 	 *      </li>
0: 	 *      <li>Change the state to either INSTALLED or RESOLVED.
0: 	 * 		</li>
0: 	 * 		<li>Throw a SubsystemException with the specified cause.
0: 	 *      </li>
1: 	 * </ol>
0: 	 * <p/>
1: 	 * A subsystem must be persistently started. That is, a started subsystem
1: 	 * must be restarted across Framework and VM restarts, even if a start
1: 	 * failure occurs.
0: 	 * <p/>
1: 	 * The following steps are required to start this subsystem.
1: 	 * <ol>
0: 	 * 		<li>If this subsystem is in the RESOLVED state, proceed to step 5.
0: 	 * 		</li>
0: 	 *      <li>Change the state to RESOLVING.
0: 	 *      </li>
0: 	 *      <li>Resolve the content resources. A resolution failure results in
0: 	 *          a start failure with a state of INSTALLED.
0: 	 *      </li>
0: 	 *      <li>Change the state to RESOLVED.
0: 	 *      </li>
0: 	 *      <li>If this subsystem is scoped, enable the export sharing policy.
0: 	 * 		</li>
0: 	 * 		<li>Change the state to STARTING.
0: 	 *      </li>
0: 	 *      <li>For each eligible resource, increment the activation count by
0: 	 *          one. If the activation count is one, start the resource. All
0: 	 *          transitive resources must be started before any content
0: 	 *          resource, and content resources must be started according to the
0: 	 *          specified {@link SubsystemConstants#START_LEVEL_DIRECTIVE start
0: 	 *          order}. If an error occurs while starting a resource, a start
0: 	 *          failure results with that error as the cause.
0: 	 *      </li>
0: 	 *      <li>Change the state to ACTIVE.
0: 	 * 		</li>
1: 	 * </ol>
0: 	 * <p/> 
0: 	 * @throws SubsystemException If this subsystem fails to start. 
1: 	 * @throws IllegalStateException If this subsystem's state is in
0: 	 *         {INSTALL_FAILED, UNINSTALLING, or UNINSTALLED}, or if the state
0: 	 *         of at least one of this subsystem's parents is not in {STARTING,
0: 	 *         ACTIVE}.
0: 	 *         SubsystemPermission[this,EXECUTE], and the runtime supports 
1: 	 * Stops this subsystem.
0: 	 * <p/>
1: 	 * The following table shows which actions are associated with each state.
0: 	 * An action of Wait means this method will block until a state transition
0: 	 * occurs, upon which the new state will be evaluated in order to
0: 	 * determine how to proceed. An action of Return means this method returns
1: 	 * immediately without taking any other action.
0: 	 * <p/>
0: 	 * <table border="1"">
0: 	 * 		<tr>
0: 	 * 			<th>State</td>
0: 	 * 			<th>Action</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALLING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALLED</td>
0: 	 * 			<td>Return</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALL_FAILED</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>RESOLVING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>RESOLVED</td>
0: 	 * 			<td>If this subsystem is in the process of being<br/>
0: 	 *              started, Wait. Otherwise, Return.</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>STARTING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>ACTIVE</td>
0: 	 * 			<td>Stop</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>STOPPING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>UNINSTALLING</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>UNINSTALLED</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
1: 	 * </table>
0: 	 * <p/>
1: 	 * Implementations should be sensitive to the potential for long running
1: 	 * operations and periodically check the current thread for interruption, in
1: 	 * which case a SubsystemException with an InterruptedException as the cause
1: 	 * should be thrown. If an interruption occurs while waiting, this method
0: 	 * should terminate immediately. Once the transition to the STOPPING
0: 	 * state has occurred, however, this method must not terminate due to an
0: 	 * interruption until the stop process has completed.
0: 	 * <p/>
1: 	 * A subsystem must be persistently stopped. That is, a stopped subsystem
1: 	 * must remain stopped across Framework and VM restarts.
0: 	 * <p/>
1: 	 * All references to changing the state of this subsystem include both
1: 	 * changing the state of the subsystem object as well as the state property
1: 	 * of the subsystem service registration.
0: 	 * <p/>
1: 	 * The following steps are required to stop this subsystem.
1: 	 * <ol>
0: 	 * 		<li>Change the state to STOPPING.
0: 	 * 		</li>
0: 	 * 		<li>For each eligible resource, decrement the activation count by
0: 	 *          one. If the activation count is zero, stop the resource. All
0: 	 *          content resources must be stopped before any transitive
0: 	 *          resource, and content resources must be stopped in reverse
0: 	 *          {@link SubsystemConstants#START_LEVEL_DIRECTIVE start order}. If
0: 	 *          an error occurs while stopping a resource, a stop failure
0: 	 *          results with that error as the cause.
0: 	 *      </li>
0: 	 *      <li>Change the state to RESOLVED.
0: 	 *      </li>
1: 	 * </ol>
1: 	 * With regard to error handling, once this subsystem has transitioned to
0: 	 * the STOPPING state, every part of each step above must be attempted.
0: 	 * Errors subsequent to the first should be logged. Once the stop process
0: 	 * has completed, a SubsystemException must be thrown with the initial error
0: 	 * as the specified cause.
0: 	 * <p/>
0: 	 * @throws SubsystemException If this subsystem fails to stop cleanly.
1: 	 * @throws IllegalStateException If this subsystem's state is in
0: 	 *         {INSTALL_FAILED, UNINSTALLING, or UNINSTALLED}.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         SubsystemPermission[this,EXECUTE], and the runtime supports 
0: 	 * Uninstalls this subsystem.
1: 	 * The following table shows which actions are associated with each state.
0: 	 * An action of Wait means this method will block until a state transition
0: 	 * occurs, upon which the new state will be evaluated in order to
0: 	 * determine how to proceed. An action of Return means this method returns
1: 	 * immediately without taking any other action.
0: 	 * <p/>
0: 	 * <table border="1">
0: 	 * 		<tr>
0: 	 * 			<th>State</td>
0: 	 * 			<th>Action</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALLING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALLED</td>
0: 	 * 			<td>Uninstall</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>INSTALL_FAILED</td>
0: 	 * 			<td>IllegalStateException</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>RESOLVING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>RESOLVED</td>
0: 	 * 			<td>If this subsystem is in the process of being<br/>
0: 	 *              started, Wait. Otherwise, Uninstall.</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>STARTING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>ACTIVE</td>
0: 	 * 			<td>Stop, Uninstall</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>STOPPING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>UNINSTALLING</td>
0: 	 * 			<td>Wait</td>
0: 	 * 		</tr>
0: 	 * 		<tr align="center">
0: 	 * 			<td>UNINSTALLED</td>
0: 	 * 			<td>Return</td>
0: 	 * 		</tr>
1: 	 * </table>
0: 	 * <p/>
1: 	 * Implementations should be sensitive to the potential for long running
1: 	 * operations and periodically check the current thread for interruption, in
1: 	 * which case a SubsystemException with an InterruptedException as the cause
1: 	 * should be thrown. If an interruption occurs while waiting, this method
0: 	 * should terminate immediately. Once the transition to the UNINSTALLING
0: 	 * state has occurred, however, this method must not terminate due to an
0: 	 * interruption until the uninstall process has completed.
0: 	 * <p/>
1: 	 * All references to changing the state of this subsystem include both
1: 	 * changing the state of the subsystem object as well as the state property
1: 	 * of the subsystem service registration.
0: 	 * <p/>
0: 	 * The following steps are required to uninstall this subsystem.
0: 	 * 		<li>Change the state to UNINSTALLING.
0: 	 * 		</li>
0: 	 * 		<li>For each resource, decrement the reference count by one. If the
0: 	 * 			reference count is zero, uninstall the resource. All content
0: 	 * 			resources must be uninstalled before any transitive resource. If
0: 	 *          an error occurs while uninstalling a resource, an uninstall
0: 	 *          failure results with that error as the cause.
0: 	 *      </li>
0: 	 *      <li>Change the state to UNINSTALLED.
0: 	 *      </li>
0: 	 *      <li>Unregister the subsystem service.
0: 	 *      </li>
0: 	 *      <li>Uninstall the region context bundle.
0: 	 *      </li>
1: 	 * With regard to error handling, once this subsystem has transitioned to
0: 	 * the UNINSTALLING state, every part of each step above must be attempted.
0: 	 * Errors subsequent to the first should be logged. Once the uninstall
0: 	 * process has completed, a SubsystemException must be thrown with the
0: 	 * specified cause.
0: 	 * <p/>
1: 	 * @throws SubsystemException If this subsystem fails to uninstall cleanly.
1: 	 * @throws IllegalStateException If this subsystem's state is in
0: 	 *         {INSTALL_FAILED}. 
0: 	 *         SubsystemPermission[this,LIFECYCLE], and the runtime supports
0: 	 *         permissions.
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.resource.Resource;
/////////////////////////////////////////////////////////////////////////
1: 	 * 
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
/////////////////////////////////////////////////////////////////////////
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
0: 	 * is equivalent to calling getHeaders(null).
1: 	 * 
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
1: 	 * 
0: 	 *         specified locale.
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
/////////////////////////////////////////////////////////////////////////
1: 	 * 
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
/////////////////////////////////////////////////////////////////////////
1: 	 * 
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
1: 	 * 
0: 	 * @throws IllegalStateException If the subsystem is in the {@link 
0: 	 *         State#INSTALLING installing state} or transitioned to the {@link 
0: 	 *         State#UNINSTALLED uninstalled state} due to a failed 
0: 	 *         installation.
/////////////////////////////////////////////////////////////////////////
0: 	 *          identifier as the subsystem to be installed, then the existing
0: 	 *          subsystem is returned.</li>
0: 	 * 		<li>If this is a new install, then a new Subsystem is created with 
0: 	 *          its id set to the next available value (ascending order).</li>
0: 	 * 		<li>The subsystem's state is set to INSTALLING and if EventAdmin is 
0: 	 *          available, an event of type INSTALLING is fired.</li>
0: 	 *      <li>The following installation steps are then started and performed 
0: 	 *          asynchronously and the new subsystem is returned to the caller.</li>
0: 	 * 		<li>If the subsystem requires isolation (i.e. is an application or 
0: 	 *          a composite), then isolation is set up while the install is in 
0: 	 *          progress, such that none of the content bundles can be resolved.
0: 	 *          This isolation is not changed until the subsystem is explicitly 
0: 	 *          requested to resolve (i.e. as a result of a Subsystem.start() 
0: 	 *          operation).</li>
0: 	 * 		<li>If the subsystem does not include a deployment manifest, then 
0: 	 *          the subsystem runtime must calculate one.</li>
0: 	 * 		<li>The resources identified in the deployment manifest are 
0: 	 *          installed into the framework.  All content resources are 
0: 	 *          installed into the Subsystem, whereas transitive dependencies 
0: 	 *          are installed into an ancestor subsystem. If any resources fail 
0: 	 *          to install, then the entire installation is failed. Transitive 
0: 	 *          resources are free to resolve and start independent of the 
0: 	 *          subsystem they were installed for.</li>
0: 	 * 		<li>The subsystem's state is set to INSTALLED and if EventAdmin is 
0: 	 *          available an INSTALLED event is fired.</li>
/////////////////////////////////////////////////////////////////////////
0: 	 * related to this subsystem that it is able to remove. If this subsystem 
0: 	 * has exported any packages, the Framework must continue to make these 
0: 	 * packages available to their importing bundles or subsystems until the 
commit:b1d7587
/////////////////////////////////////////////////////////////////////////
0:  * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
1:  * 
/////////////////////////////////////////////////////////////////////////
1: package org.osgi.service.subsystem;
0: import org.osgi.framework.wiring.Resource;
/////////////////////////////////////////////////////////////////////////
0: 		 * A subsystem is in the INSTALLING state when it is initially created.
1: 		INSTALLING,
0: 		 * A subsystem is in the INSTALLED state when all resources are
0: 		 * successfully installed.
0: 		 * A subsystem in the RESOLVING is allowed to have its content bundles 
0: 		 * resolved.
1: 		 */
1: 		RESOLVING,
1: 		/**
0: 		 * A subsystem is in the RESOLVED state when all resources are 
/////////////////////////////////////////////////////////////////////////
0: 		 * A subsystem is in the ACTIVE state when it has reached the beginning 
0: 		 * start-level (for starting it's contents), and all its persistently 
0: 		 * started content bundles that are resolved and have had their 
0: 		 * start-levels met have completed, or failed, their activator start 
0: 		 * method.
1: 		 */
1: 		ACTIVE,
1: 		/**
0: 		 * A subsystem in the STOPPING state is in the process of taking its 
0: 		UPDATING,
1: 		UNINSTALLING,
0: 	
1: 	/**
0: 	 * Cancels the currently executing asynchronous life-cycle operation, if
0: 	 * any.
0: 	 * @throws SubsystemException - If this subsystem is not in one of the
0: 	 *         transitional states or the currently executing operation cannot
0: 	 *         be cancelled for any reason.
1: 	 */
0: 	public void cancel() throws SubsystemException;
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	 * Returns a snapshot of all {@code Resources} currently constituting this 
0: 	 * {@link Subsystem}. If this {@code Subsystem} has no {@code Resources}, 
0: 	 * the {@link Collection} will be empty.
1: 	 * 
0: 	 * @return A snapshot of all {@code Resources} currently constituting this
0: 	 *         {@code Subsystem}.
0: 	public Collection<Resource> getConstituents();
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	 * Subsystem.install. This identifier does not change while this subsystem 
0: 	 * remains installed, even after Subsystem.update. This location identifier 
0: 	 * is used in Subsystem.update if no other update source is specified. 
0: 	
0: 	 * Gets the parent Subsystem that scopes this subsystem instance.
0: 	 * @return The Subsystem that scopes this subsystem or null if there is no 
0: 	 *         parent subsystem (e.g. if the outer scope is the framework).
0: 	
0: 	
0: 	
0: 	
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
author:Graham Charters
-------------------------------------------------------------------------------
commit:6f4b079
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: /*
0:  * TODO
0:  * (1) How will the root subsystem handle install, start, stop, update, and
0:  * uninstall?
0:  * (2) ResourceProcesser will accept Coordination again. No chaining. Processor
0:  * is responsible for failing the coordination or throwing exception from ended
0:  * or failed.
0:  * (3) Remove coordination from Resource.
0:  * (4) Do we need to return Resources and Bundles? Just Resources? What?
0:  * (5) Add description of root subsystem. List unsupported operations.
1:  */
0: 
0:  * A representation of a subsystem in the framework. A subsystem is a 
0:  * collection of bundles and/or other resource. A subsystem has isolation 
0:  * semantics. Subsystem types are defined that have different default isolation 
0:  * semantics. For example, an Application subsystem does not export any of the 
0:  * packages or services provided by its content bundles, and imports any 
0:  * packages or services that are required to satisfy unresolved package or 
0:  * service dependencies of the content bundles. A subsystem is defined using a 
0:  * manifest format. 
1:  * @ThreadSafe
0:  * @noimplement
1: 	/**
0: 	 * The states of a subsystem in the framework. These states match those of 
0: 	 * a Bundle and are derived using the same rules as CompositeBundles. As 
0: 	 * such, they are more a reflection of what content bundles are permitted 
0: 	 * to do rather than an aggregation of the content bundle states. 
1: 	 */
1: 	public static enum State {
1: 		/**
0: 		 * A subsystem is in the ACTIVE state when it has reached the beginning 
0: 		 * start-level (for starting it's contents), and all its persistently 
0: 		 * started content bundles that are resolved and have had their 
0: 		 * start-levels met have completed, or failed, their activator start 
0: 		 * method.
1: 		 */
0: 		ACTIVE,
1: 		/**
0: 		 * A subsystem is in the INSTALLED state when it is initially created.
1: 		 */
1: 		INSTALLED,
1: 		/**
0: 		 * A subsystem in the RESOLVED is allowed to have its content bundles 
0: 		 * resolved.
1: 		 */
1: 		RESOLVED,
1: 		/**
0: 		 * A subsystem is in the STARTING state when all its content bundles 
0: 		 * are enabled for activation.
1: 		 */
1: 		STARTING,
1: 		/**
0: 		 * A subsystem in the STOPPING state is in the process of taking its 
0: 		 * its active start level to zero, stopping all the content bundles.
1: 		 */
1: 		STOPPING,
1: 		/**
0: 		 * A subsystem is in the UNINSTALLED state when all its content bundles 
0: 		 * and uninstalled and its system bundle context is invalidated.
1: 		 */
1: 		UNINSTALLED
1: 	}
1: 	/**
0: 	 * Gets the subsystems managed by this service. This only includes the 
0: 	 * top-level Subsystems installed in the Framework, CoompositeBundle or 
0: 	 * Subsystem from which this service has been retrieved.
0: 	 * @return The Subsystems managed by this service.
1: 	 */
1: 	public Collection<Subsystem> getChildren();
1: 	/**
0: 	 * Gets the content bundles of this subsystem.
0: 	 * @return The content of this subsystem.
1: 	 */
0: 	// TODO Should constituents actually be resources instead of bundles?
0: 	public Collection<Bundle> getConstituents();
1: 	/**
0: 	 * Gets the headers used to define this subsystem. The headers will be 
0: 	 * localized using the locale returned by java.util.Locale.getDefault. This 
0: 	 * is equivalent to calling getHeaders(null). 
0: 	 * @return The headers used to define this subsystem.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         AdminPermission[this,METADATA] and the runtime supports 
0: 	 *         permissions.
1: 	 */
0: 	public Map<String, String> getHeaders();
1: 	/**
0: 	 * Gets the headers used to define this subsystem.
0: 	 * @param locale The locale name to be used to localize the headers. If the 
0: 	 *        locale is null then the locale returned by 
0: 	 *        java.util.Locale.getDefault is used. If the value is the empty 
0: 	 *        string then the returned headers are returned unlocalized. 
0: 	 * @return the headers used to define this subsystem, localized to the 
0: 	 *         specified locale. 
1: 	 */
0: 	public Map<String, String> getHeaders(String locale);
1: 	/**
0: 	 * The location identifier used to install this subsystem through 
0: 	 * SubsystemAdmin.install. This identifier does not change while this 
0: 	 * subsystem remains installed, even after SubsystemAdmin.update. This 
0: 	 * location identifier is used in SubsystemAdmin.update if no other update 
0: 	 * source is specified. 
0: 	 * @return The string representation of the subsystem's location identifier.
1: 	 */
1: 	public String getLocation();
1: 	/**
0: 	 * Gets the parent Subsystem that scopes this subsystem admin instance.
0: 	 * @return The Subsystem that scopes this subsystem admin or null if there 
0: 	 * is no parent subsystem (e.g. if the outer scope is the framework).
1: 	 */
0: 	public Subsystem getParent();
1: 	/**
0: 	 * Gets the state of the subsystem.
0: 	 * @return The state of the subsystem.
1: 	 */
1: 	public State getState();
1: 	/**
0: 	 * Gets the identifier of the subsystem. Subsystem identifiers are assigned 
0: 	 * when the subsystem is installed and are unique within the framework. 
0: 	 * @return The identifier of the subsystem.
1: 	 */
1: 	public long getSubsystemId();
1: 	/**
0: 	 * Gets the symbolic name of this subsystem.
1: 	 * @return The symbolic name of this subsystem.
1: 	 */
1: 	public String getSymbolicName();
1: 	/**
0: 	 * Gets the version of this subsystem.
1: 	 * @return The version of this subsystem.
1: 	 */
1: 	public Version getVersion();
1: 	/**
0: 	 * Install a new subsystem from the specified location identifier.
0: 	 * <p>
0: 	 * This method performs the same function as calling install(String, 
0: 	 * InputStream) with the specified location identifier and a null 
0: 	 * InputStream.
0: 	 * @param location The location identifier of the subsystem to be installed.
1: 	 * @return The installed subsystem.
0: 	 * @throws SubsystemException If the subsystem could not be installed for
0: 	 *         any reason.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         AdminPermission[installed subsystem,LIFECYCLE], and the Java 
0: 	 *         Runtime Environment supports permissions.
1: 	 */
0: 	public Subsystem install(String location) throws SubsystemException;
1: 	/**
0: 	 * Install a new subsystem from the specified InputStream object.
0: 	 * <p/>
0: 	 * If the specified InputStream is null, the InputStream must be created 
0: 	 * from the specified location.
0: 	 * <p/>
0: 	 * The specified location identifier will be used as the identity of the 
0: 	 * subsystem. Every installed subsystem is uniquely identified by its 
0: 	 * location identifier which is typically in the form of a URL.
0: 	 * <p/>
0: 	 * TODO: Understand whether this all change when we can install the same 
0: 	 * bundle multiple times.
0: 	 * <p/>
0: 	 * A subsystem and its contents must remain installed across Framework and 
0: 	 * VM restarts. The subsystem itself is installed atomically, however its 
0: 	 * contents are not.
0: 	 * <p/>
0: 	 * The following steps are required to install a subsystem:
0: 	 * <ol>
0: 	 * 		<li>If there is an existing subsystem containing the same location 
0: 	 *          identifier as the Subsystem to be installed, then a Future is 
0: 	 *          returned that has the existing subsystem immediately available 
0: 	 *          as its result.</li>
0: 	 * 		<li>If there is already an install in progress for a subsystem with 
0: 	 *          the same location identifier, then the Future returned is the 
0: 	 *          same as the Future returned for the first install and a new 
0: 	 *          install is not started.</li>
0: 	 * 		<li>If this is a new install, then a new Future is returned with 
0: 	 *          the installation process following the remaining step.</li>
0: 	 * 		<li>The subsystem content is read from the input stream.</li>
0: 	 * 		<li>Isolation is set up while the install is in progress, such that 
0: 	 *          none of the content can be resolved with bundles outside the 
0: 	 *          subsystem.</li>
0: 	 * 		<li>The resources are into the framework through the use of 
0: 	 *          ResourceProcessors.</li>
0: 	 * 		<li>Isolation is configured appropriate for the subsystem such that 
0: 	 *          the content can be resolved with bundles outside the subsystem.</li>
0: 	 * 		<li>The subsystem's state is set to INSTALLED.</li>
0: 	 * 		<li>The subsystem event of type INSTALLED is fired.</li>
0: 	 * 		<li>The subsystem content is started.</li>
0: 	 * 		<li>The subsystem object for the newly installed subsystem is made 
0: 	 *          available from the Future.</li>
0: 	 * </ol>
0: 	 * @param location The location identifier of the subsystem to be installed.
0: 	 * @param content The InputStream from where the subsystem is to be 
0: 	 *        installed or null if the location is to be used to create the 
0: 	 *        InputStream.
1: 	 * @return The installed subsystem.
0: 	 * @throws SubsystemException If the subsystem could not be installed for
0: 	 *         any reason.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         AdminPermission[installed subsystem,LIFECYCLE], and the Java 
0: 	 *         Runtime Environment supports permissions.
1: 	 */
0: 	public Subsystem install(String location, InputStream content) throws SubsystemException;
1: 	/**
0: 	 * Starts the subsystem. The subsystem is started according to the rules 
0: 	 * defined for Bundles and the content bundles are enabled for activation. 
0: 	 * @throws SubsystemException If this subsystem could not be started. 
0: 	 * @throws IllegalStateException If this subsystem has been uninstalled. 
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         AdminPermission[this,EXECUTE] and the runtime supports 
0: 	 *         permissions.
1: 	 */
0: 	public void start() throws SubsystemException;
1: 	/**
0: 	 * Stops the subsystem. The subsystem is stopped according to the rules 
0: 	 * defined for Bundles and the content bundles are disabled for activation 
0: 	 * and stopped.
0: 	 * @throws SubsystemException If an internal exception is thrown while 
0: 	 *         stopping the subsystem (e.g. a BundleException from Bundle.stop). 
0: 	 * @throws IllegalStateException - If this subsystem has been uninstalled. 
0: 	 * @throws SecurityException - If the caller does not have the appropriate 
0: 	 *         AdminPermission[this,EXECUTE] and the runtime supports 
0: 	 *         permissions.
1: 	 */
0: 	public void stop() throws SubsystemException;
1: 	/**
0: 	 * Uninstall the given subsystem.
0: 	 * <p/>
0: 	 * This method causes the Framework to notify other bundles and subsystems 
0: 	 * that this subsystem is being uninstalled, and then puts this subsystem 
0: 	 * into the UNINSTALLED state. The Framework must remove any resources 
0: 	 * related to this subsystem that it is able to remove. It does so using the 
0: 	 * appropriate ResourceProcessor.uninstall(Subsystem, Resource, 
0: 	 * Coordination) for the resource namespace. If this subsystem has exported 
0: 	 * any packages, the Framework must continue to make these packages 
0: 	 * available to their importing bundles or subsystems until the 
0: 	 * org.osgi.service.packageadmin.PackageAdmin.refreshPackages(
0: 	 * org.osgi.framework.Bundle[]) method has been called or the Framework is 
0: 	 * relaunched. The following steps are required to uninstall a subsystem:
0: 	 * <ol>
0: 	 * 		<li>If this subsystem's state is UNINSTALLED then an 
0: 	 *          IllegalStateException is thrown.</li>
0: 	 * 		<li>If this subsystem's state is ACTIVE, STARTING or STOPPING, this 
0: 	 *          subsystem is stopped as described in the Subsystem.stop() 
0: 	 *          method. If Subsystem.stop() throws an exception, a Framework 
0: 	 *          event of type FrameworkEvent.ERROR is fired containing the 
0: 	 *          exception.</li>
0: 	 * 		<li>This subsystem's state is set to UNINSTALLED.</li>
0: 	 * 		<li>A subsystem event of type SubsystemEvent.UNINSTALLED is fired.</li>
0: 	 * 		<li>This subsystem and any persistent storage area provided for this 
0: 	 *          subsystem by the Framework are removed.</li>
0: 	 * </ol>
0: 	 * @throws SubsystemException If the uninstall failed.
0: 	 * @throws IllegalStateException If the subsystem is already in the 
0: 	 *         UNISTALLED state.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         AdminPermission[this,LIFECYCLE] and the Java Runtime Environment 
0: 	 *         supports permissions.
1: 	 */
0: 	public void uninstall() throws SubsystemException;
1: 	/**
0: 	 * Update the given subsystem.
0: 	 * <p/>
0: 	 * This method performs the same function as calling update(Subsystem, 
0: 	 * InputStream) with the specified subsystem and a null InputStream.
0: 	 * @throws SubsystemException If the subsystem could not be updated for any
0: 	 *         reason.
1: 	 */
0: 	public void update() throws SubsystemException;
1: 	/**
0: 	 * Update the given subsystem from an InputStream.
0: 	 * <p/>
0: 	 * If the specified InputStream is null, the InputStream must be created 
0: 	 * from the subsystem's Subsystem-UpdateLocation Manifest header if present, 
0: 	 * or this subsystem's location provided when the subsystem was originally 
0: 	 * installed.
0: 	 * <p/>
0: 	 * TODO: expand on this description. For example, we need details on how 
0: 	 * update works for individual resources. We could follow the 
0: 	 * deploymentadmin approach and uninstall bundles that are removed and 
0: 	 * install new ones. This would happen if we had a different (updated) 
0: 	 * deployment calculated for the same version of the application.
0: 	 * @param content The InputStream from which to update the subsystem or null 
0: 	 *        if the Subsystem-UpdateLocation or original location are to be 
0: 	 *        used.
0: 	 * @throws SubsystemException
0: 	 * @throws IllegalStateException If the subsystem is in the UNINSTALLED 
0: 	 *         state.
0: 	 * @throws SecurityException If the caller does not have the appropriate 
0: 	 *         AdminPermission[this,LIFECYCLE] for both the current subsystem 
0: 	 *         and the updated subsystem and the Java Runtime Environment 
0: 	 *         supports permissions.
1: 	 */
0: 	public void update(InputStream content) throws SubsystemException;
commit:2e06be4
/////////////////////////////////////////////////////////////////////////
0:  * A representation of a subsystem in the framework. A subsystem is a
0:  * collection of bundles and/or other resource. A subsystem has isolation
0:  * semantics. Subsystem types are defined that have different default isolation
0:  * semantics. For example, an Application subsystem does not export any of the
0:  * packages or services provided by its content bundles, and imports any
0:  * packages or services that are required to satisfy unresolved package or
0:  * service dependencies of the content bundles.
1:  * 
0:  * A subsystem is defined using a manifest format.
0:     /**
0:      * The states of a subsystem in the framework. These states match those of a
0:      * Bundle and are derived using the same rules as CompositeBundles. As such,
0:      * they are more a reflection of what content bundles are permitted to do
0:      * rather than an aggregation of the content bundle states.
0:      */
0:         /**
0:          * A subsystem is in the INSTALLED state when it is initially created.
0:          * It may or may not contain content bundles. No content bundles are
0:          * permitted to be resolved while the subsystem is in the INSTALLED
0:          * state.
0:          */
0: 
0:         /**
0:          * A subsystem in the RESOLVED is allowed to have its content bundles
0:          * resolved. The content bundles are not allowed to activate while the
0:          * subsystem is in the RESOLVED state.
0:          */
0: 
0:         /**
0:          * A subsystem is in the STARTING state when all its content bundles are
0:          * enabled for activation. The content bundles are started according to
0:          * the start-level specification.
0:          */
0: 
0:         /**
0:          * A subsystem in the STOPPING state is in the process of taking its its active start level to
0:          * zero, stopping all the content bundles.
0:          */
0: 
0:         /**
0:          * A subsystem is in the ACTIVE state when it has reached the beginning
0:          * start-level (for starting it's contents), and all its persistently
0:          * started content bundles that are resolved and have had their
0:          * start-levels met have completed, or failed, their activator start
0:          * method.
0:          */
0: 
0:         /**
0:          * A subsystem is in the UNINSTALLED state when all its content bundles
0:          * and uninstalled and its system bundle context is invalidated.
0:          */
0:      * Gets the state of the subsystem.
0:      * @return the state of the subsystem.
0:      * Starts the subsystem. The subsystem is started according to the rules
0:      * defined for Bundles and the content bundles are enabled for activation.
1:      * 
0:      * @throws SubsystemException
0:      *             If this subsystem could not be started.
0:      * @throws IllegalStateException
0:      *             If this subsystem has been uninstalled.
0:      * @throws SecurityException
0:      *             If the caller does not have the appropriate
0:      *             AdminPermission[this,EXECUTE] and the runtime supports
0:      *             permissions.
0:      * Stops the subsystem. The subsystem is stopped according to the rules
0:      * defined for Bundles and the content bundles are disabled for activation
0:      * and stopped.
1:      * 
0:      * @throws SubsystemException
0:      *             TODO: does not fit with BundleException from Bundle.stop.
0:      *             What are the circumstances that cause this to be throw? When
0:      *             an exception is thrown from a content bundle?
0:      * @throws IllegalStateException
0:      *             If this subsystem has been uninstalled.
0:      * @throws SecurityException
0:      *             If the caller does not have the appropriate
0:      *             AdminPermission[this,EXECUTE] and the runtime supports
0:      *             permissions.
0:      * Gets the identifier of the subsystem. Subsystem identifiers are assigned
0:      * when the subsystem is installed and are unique within the framework.
1:      * 
0:      * @return the identifier for the subsystem.
0:      * The location identifier used to install this subsystem through
0:      * SubsystemAdmin.install. This identifier does not change while this
0:      * subsystem remains installed, even after SubsystemAdmin.update. This
0:      * location identifier is used in SubsystemAdmin.update if no other update
0:      * source is specified.
1:      * 
0:      * @return The string representation of the subsystem's location identifier.
0:      * Gets the symbolic name of this subsystem.
0:      * @return the symbolic name of this subsystem.
0:      * Gets the version of this subsystem.
0:      * @return the version of this subsystem.
0:      * Gets the headers used to define this subsystem. The headers will be
0:      * localized using the locale returned by java.util.Locale.getDefault. This
0:      * is equivalent to calling <code>getHeaders(null)</code>.
1:      * 
0:      * @return the headers used to define this subsystem.
0:      * @throws SecurityException
0:      *             If the caller does not have the appropriate
0:      *             AdminPermission[this,METADATA] and the runtime supports
0:      *             permissions.
0:      * Gets the headers used to define this subsystem.
1:      * 
0:      * @param locale
0:      *            The locale name to be used to localize the headers. If the
0:      *            locale is <code>null</code> then the locale returned by
0:      *            java.util.Locale.getDefault is used. If the value is the empty
0:      *            string then the returned headers are returned unlocalized.
0:      * @return the headers used to define this subsystem, localized to the
0:      *         specified locale.
0:      * @throws SecurityException
0:      *             If the caller does not have the appropriate
0:      *             AdminPermission[this,METADATA] and the runtime supports
0:      *             permissions.
0:      * Gets the content bundles of this subsystem.
0:      * @return the content of this subsystem.
author:Lin Sun
-------------------------------------------------------------------------------
commit:99850b9
/////////////////////////////////////////////////////////////////////////
0:     Collection<Bundle> getBundles();
0:     //long getParentId();
0:     
0:     public void updateHeaders(Map<String, String> headers);
0:     
0:     /**
0:      * return the subsystem managed by the subsystem
0:      * @return
0:      */
0:     Collection<Subsystem> getChildrenSubsystems();
0:     
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:5d0a8e8
/////////////////////////////////////////////////////////////////////////
commit:ebaf29e
/////////////////////////////////////////////////////////////////////////
0:      *  <code>getSymbolicName() + "_" + getVersion().toString()</code>.
commit:c85d8b3
/////////////////////////////////////////////////////////////////////////
0:      * Retrieve the scope of the subsystem.
0:      * The scope is computed as
0:      *  <code>getSymbolicName() + getVersion().toString()</code>.
0:      * It is guaranteed to be unique in the parent composite bundle
0:      * or framework, but it not guaranteed to be unique in the whole
0:      * OSGi framework, nor immutable as the value can change if
0:      * the subsystem is updated. 
0:      * @return
0:      */
0:     String getScope();
0: 
0:     /**
commit:0214d67
/////////////////////////////////////////////////////////////////////////
0:     void start() throws SubsystemException;
0:     void stop() throws SubsystemException;
commit:fd8a57c
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Interface representing an installed subsystem
0:  */
0:         INSTALLED,
0:         RESOLVED,
0:         STARTING,
0:         STOPPING,
0:         ACTIVE,
0:         UNINSTALLED
0:     /**
0:      * Retrieve the state of the subsystem.
0:      *
0:      * @return
0:      */
0:     /**
0:      * Start the subsystem (i.e. start all its constituent bundles according to their start level).
0:      */
0:     /**
0:      * Stop the subsystem (i.e. stop all its constituent bundles).
0:      */
0:     /**
0:      * The identifier of the subsystem.  Must be unique in the framework.
0:      *
0:      * @return
0:      */
0:     /**
0:      * The location of the subsystem.
0:      * The location will be used when updating a subsystem to load the new
0:      * content and/or identify subsystems to update.
0:      *
0:      * @return
0:      */
0:     /**
0:      * Retrieve the symbolic name of this subsystem.
0:      *
0:      * @return
0:      */
0:     /**
0:      * Retrieve the version of this subsystem.
0:      *
0:      * @return
0:      */
0:     /**
0:      * Return the subsystem headers
0:      *
0:      * @return
0:      */
0:     /**
0:      * Return the subsystem headers
0:      *
0:      * @return
0:      */
0:     /**
0:      * Retrieve the constituent bundles of this subsystem.
0:      *
0:      * @return
0:      */
commit:6c6c8a4
/////////////////////////////////////////////////////////////////////////
0: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: package org.apache.aries.subsystem;
0: 
0: import java.io.InputStream;
1: import java.util.Collection;
1: import java.util.Map;
0: 
0: import org.osgi.framework.Bundle;
1: import org.osgi.framework.Version;
0: 
1: public interface Subsystem {
0: 
0:     public enum State {
0: 
0:         Installed,
0:         Resolved,
0:         Starting,
0:         Stopping,
0:         Active,
0:         Uninstalled
0: 
1:     }
0: 
0:     State getState();
0: 
0:     void resolve();
0: 
0:     void start();
0: 
0:     void stop();
0: 
0:     void update();
0: 
0:     void update(InputStream is);
0: 
0:     void uninstall();
0: 
0:     long getSubsystemId();
0: 
0:     String getLocation();
0: 
0:     String getSymbolicName();
0: 
0:     Version getVersion();
0: 
0:     Map<String, String> getHeaders();
0: 
0:     Map<String, String> getHeaders(String locale);
0: 
0:     Collection<Bundle> getConstituents();
0: 
1: }
============================================================================