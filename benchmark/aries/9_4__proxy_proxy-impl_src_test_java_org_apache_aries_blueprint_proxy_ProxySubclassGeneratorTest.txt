1:e436ced: /*
1:e436ced:  * Licensed to the Apache Software Foundation (ASF) under one
1:e436ced:  * or more contributor license agreements.  See the NOTICE file
1:e436ced:  * distributed with this work for additional information
1:e436ced:  * regarding copyright ownership.  The ASF licenses this file
1:e436ced:  * to you under the Apache License, Version 2.0 (the
1:e436ced:  * "License"); you may not use this file except in compliance
1:e436ced:  * with the License.  You may obtain a copy of the License at
1:e436ced:  *
1:e436ced:  *   http://www.apache.org/licenses/LICENSE-2.0
1:e436ced:  *
1:e436ced:  * Unless required by applicable law or agreed to in writing,
1:e436ced:  * software distributed under the License is distributed on an
1:e436ced:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e436ced:  * KIND, either express or implied.  See the License for the
1:e436ced:  * specific language governing permissions and limitations
1:e436ced:  * under the License.
1:e436ced:  */
1:e436ced: package org.apache.aries.blueprint.proxy;
1:e436ced: 
1:e436ced: import static org.junit.Assert.assertEquals;
1:e436ced: import static org.junit.Assert.assertFalse;
1:e436ced: import static org.junit.Assert.assertNotNull;
1:e436ced: import static org.junit.Assert.assertTrue;
1:e436ced: 
1:cc94d79: import java.io.ByteArrayOutputStream;
1:cc94d79: import java.io.IOException;
1:cc94d79: import java.io.InputStream;
1:e436ced: import java.lang.reflect.InvocationHandler;
1:e436ced: import java.lang.reflect.InvocationTargetException;
1:e436ced: import java.lang.reflect.Method;
1:e436ced: import java.lang.reflect.Modifier;
1:e436ced: import java.util.ArrayList;
1:cc94d79: import java.util.Arrays;
1:cc94d79: import java.util.Collections;
1:4426e1e: import java.util.HashMap;
1:e436ced: import java.util.List;
1:4426e1e: import java.util.Map;
1:cc94d79: import java.util.Set;
1:e436ced: import java.util.concurrent.Callable;
1:e436ced: 
1:e436ced: import org.apache.aries.proxy.FinalModifierException;
1:e436ced: import org.apache.aries.proxy.InvocationListener;
1:e436ced: import org.apache.aries.proxy.UnableToProxyException;
1:e436ced: import org.apache.aries.proxy.impl.AbstractProxyManager;
1:e436ced: import org.apache.aries.proxy.impl.AsmProxyManager;
1:e436ced: import org.apache.aries.proxy.impl.ProxyHandler;
1:e436ced: import org.apache.aries.proxy.impl.SingleInstanceDispatcher;
1:e436ced: import org.apache.aries.proxy.impl.gen.ProxySubclassGenerator;
1:e436ced: import org.apache.aries.proxy.impl.gen.ProxySubclassMethodHashSet;
1:cc94d79: import org.apache.aries.util.io.IOUtils;
1:e436ced: import org.junit.Before;
1:e436ced: import org.junit.Test;
1:e436ced: 
1:e436ced: /**
1:e436ced:  * This class uses the {@link ProxySubclassGenerator} to test
1:e436ced:  */
1:e436ced: public class ProxySubclassGeneratorTest extends AbstractProxyTest
1:e436ced: {
1:e436ced:   private static final Class<?> FINAL_METHOD_CLASS = ProxyTestClassFinalMethod.class;
1:e436ced:   private static final Class<?> FINAL_CLASS = ProxyTestClassFinal.class;
1:e436ced:   private static final Class<?> GENERIC_CLASS = ProxyTestClassGeneric.class;
1:e436ced:   private static final Class<?> COVARIANT_CLASS = ProxyTestClassCovariantOverride.class;
1:e436ced:   private static ProxySubclassMethodHashSet<String> expectedMethods = new ProxySubclassMethodHashSet<String>(
1:e436ced:       12);
1:e436ced:   private InvocationHandler ih = null;
1:e436ced:   Class<?> generatedProxySubclass = null;
1:e436ced:   Object o = null;
1:e436ced: 
1:e436ced:   /**
1:e436ced:    * @throws java.lang.Exception
1:e436ced:    */
1:e436ced:   @Before
1:e436ced:   public void setUp() throws Exception
1:e436ced:   {
1:e436ced:     ih = new FakeInvocationHandler();
1:e436ced:     ((FakeInvocationHandler)ih).setDelegate(getTestClass().newInstance());
1:e436ced:     generatedProxySubclass = getGeneratedSubclass();
1:e436ced:     o = getProxyInstance(generatedProxySubclass);
1:e436ced:   }
1:e436ced: 
1:e436ced: 
1:e436ced:   /**
1:e436ced:    * Test that the methods found declared on the generated proxy subclass are
1:e436ced:    * the ones that we expect.
1:e436ced:    */
1:e436ced:   @Test
1:e436ced:   public void testExpectedMethods() throws Exception
1:e436ced:   {
1:e436ced:     Class<?> superclass = getTestClass();
1:e436ced: 
1:e436ced:     do {
1:e436ced:       Method[] declaredMethods = superclass.getDeclaredMethods();
1:e436ced:       List<Method> listOfDeclaredMethods = new ArrayList<Method>();
1:e436ced:       for (Method m : declaredMethods) {
1:e436ced:         int i = m.getModifiers();
1:e436ced:         if (Modifier.isPrivate(i) || Modifier.isFinal(i)) {
1:e436ced:           // private or final don't get added
1:e436ced:         } else if (!(Modifier.isPublic(i) || Modifier.isPrivate(i) || Modifier.isProtected(i))) {
1:e436ced:           // the method is default visibility, check the package
1:e436ced:           if (m.getDeclaringClass().getPackage().equals(getTestClass().getPackage())) {
1:e436ced:             // default vis with same package gets added
1:e436ced:             listOfDeclaredMethods.add(m);
1:e436ced:           }
1:e436ced:         } else {
1:e436ced:           listOfDeclaredMethods.add(m);
1:e436ced:         }
1:e436ced:       }
1:e436ced: 
1:e436ced:       declaredMethods = listOfDeclaredMethods.toArray(new Method[] {});
1:e436ced:       ProxySubclassMethodHashSet<String> foundMethods = new ProxySubclassMethodHashSet<String>(
1:e436ced:           declaredMethods.length);
1:e436ced:       foundMethods.addMethodArray(declaredMethods);
1:e436ced:       // as we are using a set we shouldn't get duplicates
1:e436ced:       expectedMethods.addAll(foundMethods);
1:e436ced:       superclass = superclass.getSuperclass();
1:e436ced:     } while (superclass != null);
1:e436ced: 
1:e436ced:     // add the getter and setter for the invocation handler to the expected
1:e436ced:     // set
1:e436ced:     // and the unwrapObject method
1:e436ced:     Method[] ihMethods = new Method[] {
1:e436ced:         generatedProxySubclass.getMethod("setInvocationHandler",
1:e436ced:             new Class[] { InvocationHandler.class }),
1:e436ced:         generatedProxySubclass.getMethod("getInvocationHandler", new Class[] {}) };
1:e436ced:     expectedMethods.addMethodArray(ihMethods);
1:e436ced: 
1:e436ced:     Method[] generatedProxySubclassMethods = generatedProxySubclass.getDeclaredMethods();
1:e436ced:     ProxySubclassMethodHashSet<String> generatedMethods = new ProxySubclassMethodHashSet<String>(
1:e436ced:         generatedProxySubclassMethods.length);
1:e436ced:     generatedMethods.addMethodArray(generatedProxySubclassMethods);
1:e436ced: 
1:e436ced:     // check that all the methods we have generated were expected
1:e436ced:     for (String gen : generatedMethods) {
1:e436ced:       assertTrue("Unexpected method: " + gen, expectedMethods.contains(gen));
1:e436ced:     }
1:e436ced:     // check that all the expected methods were generated
1:e436ced:     for (String exp : expectedMethods) {
1:e436ced:       assertTrue("Method was not generated: " + exp, generatedMethods.contains(exp));
1:e436ced:     }
1:e436ced:     // check the sets were the same
1:e436ced:     assertEquals("Sets were not the same", expectedMethods, generatedMethods);
1:bfd8df1: 
1:e436ced:   }
1:e436ced:   
1:e436ced:   /**
1:e436ced:    * Test a method marked final
1:e436ced:    */
1:e436ced:   @Test
1:e436ced:   public void testFinalMethod() throws Exception
1:e436ced:   {
1:e436ced:     try {
1:e436ced:       ProxySubclassGenerator.getProxySubclass(FINAL_METHOD_CLASS);
1:e436ced:     } catch (FinalModifierException e) {
1:e436ced:       assertFalse("Should have found final method not final class", e.isFinalClass());
1:e436ced:     }
1:e436ced:   }
1:e436ced: 
1:e436ced:   /**
1:e436ced:    * Test a class marked final
1:e436ced:    */
1:e436ced:   @Test
1:e436ced:   public void testFinalClass() throws Exception
1:e436ced:   {
1:e436ced:     try {
1:e436ced:       ProxySubclassGenerator.getProxySubclass(FINAL_CLASS);
1:e436ced:     } catch (FinalModifierException e) {
1:e436ced:       assertTrue("Should have found final class", e.isFinalClass());
1:e436ced:     }
1:e436ced:   }
1:e436ced: 
1:e436ced:   /**
1:e436ced:    * Test a private constructor
1:e436ced:    */
1:e436ced:   @Test
1:e436ced:   public void testPrivateConstructor() throws Exception
1:e436ced:   {
1:e436ced:     Object o = ProxySubclassGenerator.newProxySubclassInstance(
1:e436ced:         ProxyTestClassPrivateConstructor.class, ih);
1:e436ced:     assertNotNull("The new instance was null", o);
1:bfd8df1: 
1:e436ced:   }
1:e436ced: 
1:bfd8df1:   /**
1:bfd8df1:    * Test a generating proxy class of class with package access constructor.
1:bfd8df1:    */
1:bfd8df1:   @SuppressWarnings("unchecked")
1:bfd8df1:   @Test
1:bfd8df1:   public void testPackageAccessCtor() throws Exception  {
1:bfd8df1:       Class<ProxyTestClassPackageAccessCtor> proxyClass = 
1:bfd8df1:               (Class<ProxyTestClassPackageAccessCtor>) ProxySubclassGenerator.getProxySubclass(ProxyTestClassPackageAccessCtor.class);
1:bfd8df1:       ProxyTestClassPackageAccessCtor proxy = (ProxyTestClassPackageAccessCtor) getProxyInstance(proxyClass); 
1:bfd8df1:       assertNotNull("The new instance was null", proxy);
1:bfd8df1:   }
1:e436ced: //  /**
1:e436ced: //   * Test object equality between real and proxy using a Collaborator
1:e436ced: //   */
1:e436ced: //  @Test
1:e436ced: //  public void testObjectEquality() throws Exception
1:e436ced: //  {
1:e436ced: //    Object delegate = getTestClass().newInstance();
1:e436ced: //    InvocationHandler collaborator = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
1:e436ced: //    Object o = ProxySubclassGenerator.newProxySubclassInstance(getTestClass(), collaborator);
1:e436ced: //    //Calling equals on the proxy with an arg of the unwrapped object should be true
1:e436ced: //    assertTrue("The proxy object should be equal to its delegate",o.equals(delegate));
1:e436ced: //    InvocationHandler collaborator2 = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
1:e436ced: //    Object o2 = ProxySubclassGenerator.newProxySubclassInstance(getTestClass(), collaborator2);
1:e436ced: //    //The proxy of a delegate should equal another proxy of the same delegate
1:e436ced: //    assertTrue("The proxy object should be equal to another proxy instance of the same delegate", o2.equals(o));
1:e436ced: //  }
1:e436ced: //  
1:e436ced: //  private static class ProxyTestOverridesFinalize {
1:e436ced: //      public boolean finalizeCalled = false;
1:e436ced: //      
1:e436ced: //      @Override
1:e436ced: //      protected void finalize() {
1:e436ced: //          finalizeCalled = true;
1:e436ced: //      }
1:e436ced: //  }
1:e436ced: //  
1:e436ced: //  @Test
1:e436ced: //  public void testFinalizeNotCalled() throws Exception {
1:e436ced: //      ProxyTestOverridesFinalize testObj = new ProxyTestOverridesFinalize();
1:e436ced: //      InvocationHandler ih = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(testObj));
1:e436ced: //      Object o = ProxySubclassGenerator.newProxySubclassInstance(ProxyTestOverridesFinalize.class, ih);
1:e436ced: //      
1:e436ced: //      Method m = o.getClass().getDeclaredMethod("finalize");
1:e436ced: //      m.setAccessible(true);
1:e436ced: //      m.invoke(o);
1:e436ced: //      
1:e436ced: //      assertFalse(testObj.finalizeCalled);
1:e436ced: //  }
1:e436ced:   
1:e436ced: 
1:e436ced:   /**
1:e436ced:    * Test a covariant override method
1:e436ced:    */
1:e436ced:   @Test
1:e436ced:   public void testCovariant() throws Exception
1:e436ced:   {
1:e436ced:     ((FakeInvocationHandler)ih).setDelegate(COVARIANT_CLASS.newInstance());
1:e436ced:     o = ProxySubclassGenerator.newProxySubclassInstance(COVARIANT_CLASS, ih);
1:e436ced:     generatedProxySubclass = o.getClass();
1:e436ced:     Method m = generatedProxySubclass.getDeclaredMethod("getCovariant", new Class[] {});
1:e436ced:     Object returned = m.invoke(o);
1:e436ced:     assertTrue("Object was of wrong type: " + returned.getClass().getSimpleName(), COVARIANT_CLASS
1:e436ced:         .isInstance(returned));
1:e436ced:   }
1:e436ced:   
1:e436ced:   /**
1:e436ced:    * Test a covariant override method
1:e436ced:    */
1:e436ced:   @Test
1:e436ced:   public void testGenerics() throws Exception
1:e436ced:   {
1:e436ced:     ((FakeInvocationHandler)ih).setDelegate(GENERIC_CLASS.newInstance());
1:e436ced:     super.testGenerics();
1:e436ced:   }
1:e436ced: 
1:cc94d79:   @Test
1:cc94d79:   public void testClassLoaders() throws Exception {
1:cc94d79:     ClassLoader clA = new LimitedClassLoader("org.apache.aries.proxy.test.a", null, null);
1:cc94d79:     ClassLoader clB = new LimitedClassLoader("org.apache.aries.proxy.test.b", "org.apache.aries.proxy.test.a", clA);
1:cc94d79:     ClassLoader clC = new LimitedClassLoader("org.apache.aries.proxy.test.c", "org.apache.aries.proxy.test.b", clB);
1:e436ced: 
1:cc94d79:     Class<?> clazzA = clA.loadClass("org.apache.aries.proxy.test.a.ProxyTestClassA");
1:cc94d79:     Class<?> clazzB = clB.loadClass("org.apache.aries.proxy.test.b.ProxyTestClassB");
1:cc94d79:     Class<?> clazzC = clC.loadClass("org.apache.aries.proxy.test.c.ProxyTestClassC");
1:e436ced: 
1:cc94d79:     final Object object = clazzC.getConstructor(String.class).newInstance("hello");
2:cc94d79: 
1:cc94d79:     o = new AsmProxyManager().createNewProxy(null, Arrays.asList(clazzA, clazzB, clazzC), constantly(object), null);
1:cc94d79:     generatedProxySubclass = o.getClass();
1:cc94d79:     Method m = generatedProxySubclass.getDeclaredMethod("hello", new Class[] {});
1:cc94d79:     Object returned = m.invoke(o);
1:cc94d79:     assertEquals("hello", returned);
1:cc94d79:   }
1:cc94d79: 
1:cc94d79:   private static class LimitedClassLoader extends ClassLoader {
1:cc94d79:     Set<String> providedPackages;
1:cc94d79:     Set<String> importedPackages;
1:cc94d79:     List<ClassLoader> parents;
1:cc94d79: 
1:cc94d79:     public LimitedClassLoader(String provided, String imported, ClassLoader parent) {
1:cc94d79:       providedPackages = Collections.singleton(provided);
1:cc94d79:       importedPackages = imported != null ? Collections.singleton(imported) : Collections.<String>emptySet();
1:cc94d79:       parents = parent != null ? Collections.singletonList(parent) : Collections.<ClassLoader>emptyList();
1:cc94d79:     }
1:4426e1e:     
1:4426e1e:     final Map<String, Object> clLocks = new HashMap<String, Object>();
1:b6de52e:     protected synchronized Object getClassLoadingLock (String name) {
1:4426e1e:     	if (!clLocks.containsKey(name)) { 
1:4426e1e:     		clLocks.put(name, new Object());
1:4426e1e:     	}
1:4426e1e:     	return clLocks.get(name);
1:4426e1e:     }
1:cc94d79: 
1:cc94d79:     @Override
1:cc94d79:     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:cc94d79:       synchronized (getClassLoadingLock(name)) {
1:cc94d79:         // First, check if the class has already been loaded
1:cc94d79:         Class<?> c = findLoadedClass(name);
1:cc94d79:         if (c == null) {
1:cc94d79:           String pkg = name.substring(0, name.lastIndexOf('.'));
1:cc94d79:           if (pkg.startsWith("java.") || pkg.startsWith("sun.reflect")) {
1:cc94d79:             return getClass().getClassLoader().loadClass(name);
1:cc94d79:           } else if (providedPackages.contains(pkg)) {
1:cc94d79:             c = findClass(name);
1:cc94d79:           } else if (importedPackages.contains(pkg)) {
1:cc94d79:             for (ClassLoader cl : parents) {
1:cc94d79:               try {
1:cc94d79:                 c = cl.loadClass(name);
1:cc94d79:               } catch (ClassNotFoundException e) {
1:cc94d79:                 // Ignore
1:cc94d79:               }
1:cc94d79:             }
1:cc94d79:           }
1:cc94d79:         }
1:cc94d79:         if (c == null) {
1:cc94d79:           throw new ClassNotFoundException(name);
1:cc94d79:         }
1:cc94d79:         if (resolve) {
1:cc94d79:           resolveClass(c);
1:cc94d79:         }
1:cc94d79:         return c;
1:cc94d79:       }
1:cc94d79:     }
1:cc94d79: 
1:cc94d79:     @Override
1:cc94d79:     protected Class<?> findClass(String name) throws ClassNotFoundException {
1:cc94d79:       String pkg = name.substring(0, name.lastIndexOf('.'));
1:cc94d79:       if (getPackage(pkg) == null) {
1:cc94d79:         definePackage(pkg, null, null, null, null, null, null, null);
1:cc94d79:       }
1:cc94d79:       String path = name.replace('.', '/').concat(".class");
1:cc94d79:       InputStream is = LimitedClassLoader.class.getClassLoader().getResourceAsStream(path);
1:cc94d79:       ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:cc94d79:       try {
1:cc94d79:         IOUtils.copy(is, baos);
1:cc94d79:       } catch (IOException e) {
1:cc94d79:         throw new ClassNotFoundException(name, e);
1:cc94d79:       }
1:cc94d79:       byte[] buf = baos.toByteArray();
1:cc94d79:       return defineClass(name, buf, 0, buf.length);
1:cc94d79:     }
1:cc94d79:   }
1:cc94d79:   
1:e436ced:   private Class<?> getGeneratedSubclass() throws Exception
1:e436ced:   {
1:e436ced:     return getProxyClass(getTestClass());
1:e436ced:   }
1:e436ced: 
1:e436ced:   private class FakeInvocationHandler implements InvocationHandler
1:e436ced:   {
1:e436ced:     private Object delegate = null;
1:e436ced:     /*
1:e436ced:      * (non-Javadoc)
1:e436ced:      * 
1:e436ced:      * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object,
1:e436ced:      * java.lang.reflect.Method, java.lang.Object[])
1:e436ced:      */
1:e436ced:     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
1:e436ced:     {
1:e436ced:       try {
1:e436ced:       Object result = (delegate instanceof Callable) ? 
1:e436ced:           method.invoke(((Callable<?>)delegate).call(), args) : 
1:e436ced:           method.invoke(delegate, args) ;
1:e436ced:       return result;
1:e436ced:       } catch (InvocationTargetException ite) {
1:e436ced:         throw ite.getTargetException();
1:e436ced:       }
1:e436ced:     }
1:e436ced: 
1:e436ced:     void setDelegate(Object delegate){
1:e436ced:       this.delegate = delegate;
1:e436ced:     }
1:e436ced:     
1:e436ced:   }
1:e436ced: 
1:e436ced:   @Override
1:e436ced:   protected Object getProxyInstance(Class<?> proxyClass) {
1:e436ced:     return getProxyInstance(proxyClass, ih);
1:e436ced:   }
1:e436ced:   
1:e436ced:   private Object getProxyInstance(Class<?> proxyClass, InvocationHandler ih) {
1:e436ced:     try {
1:e436ced:       if(proxyClass.equals(ProxyTestClassChildOfAbstract.class))
1:e436ced:         return proxyClass.newInstance();
1:e436ced:       
1:e436ced:       Object proxyInstance = proxyClass.getConstructor().newInstance();
1:e436ced:       Method setIH = proxyInstance.getClass().getMethod("setInvocationHandler", InvocationHandler.class);
1:e436ced:       setIH.invoke(proxyInstance, ih);
1:e436ced:       return proxyInstance;
1:e436ced:     } catch (Exception e) {
1:e436ced:       return null;
1:e436ced:     }
1:e436ced:   }
1:e436ced: 
1:e436ced:   @Override
1:e436ced:   protected Class<?> getProxyClass(Class<?> clazz) {
1:e436ced:     try {
1:e436ced:       return ProxySubclassGenerator.getProxySubclass(clazz);
1:e436ced:     } catch (UnableToProxyException e) {
1:e436ced:       return null;
1:e436ced:     }
1:e436ced:   }
1:e436ced: 
1:e436ced: 
1:e436ced:   @Override
1:e436ced:   protected Object setDelegate(Object proxy, Callable<Object> dispatcher) {
1:e436ced:     AbstractProxyManager apm = new AsmProxyManager();
1:e436ced:     return getProxyInstance(proxy.getClass(), new ProxyHandler(apm, dispatcher, null));  
1:e436ced:   }
1:e436ced: 
1:e436ced: 
1:e436ced:   @Override
1:e436ced:   protected Object getProxyInstance(Class<?> proxyClass,
1:e436ced:       InvocationListener listener) {
1:e436ced:     AbstractProxyManager apm = new AsmProxyManager();
1:e436ced:     return getProxyInstance(proxyClass, new ProxyHandler(apm, new SingleInstanceDispatcher(getProxyInstance(proxyClass)), listener));  
1:e436ced:   }
1:e436ced: 
1:e436ced: 
1:e436ced:   @Override
1:e436ced:   protected Object getP3() {
1:e436ced:     return new ProxyTestClassGeneral();
1:e436ced:   }
1:cc94d79: 
1:cc94d79:   private Callable<Object> constantly(final Object result) {
1:cc94d79:     return new Callable<Object>() {
1:cc94d79:       public Object call() throws Exception {
1:cc94d79:         return result;
1:e436ced:       }
1:cc94d79:     };
1:cc94d79:   }
1:cc94d79: }
============================================================================
author:Sam Bratton
-------------------------------------------------------------------------------
commit:bfd8df1
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1:    * Test a generating proxy class of class with package access constructor.
1:    */
1:   @SuppressWarnings("unchecked")
1:   @Test
1:   public void testPackageAccessCtor() throws Exception  {
1:       Class<ProxyTestClassPackageAccessCtor> proxyClass = 
1:               (Class<ProxyTestClassPackageAccessCtor>) ProxySubclassGenerator.getProxySubclass(ProxyTestClassPackageAccessCtor.class);
1:       ProxyTestClassPackageAccessCtor proxy = (ProxyTestClassPackageAccessCtor) getProxyInstance(proxyClass); 
1:       assertNotNull("The new instance was null", proxy);
1:   }
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:b6de52e
/////////////////////////////////////////////////////////////////////////
1:     protected synchronized Object getClassLoadingLock (String name) {
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:4426e1e
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     
1:     final Map<String, Object> clLocks = new HashMap<String, Object>();
0:     private synchronized Object getClassLoadingLock (String name) {
1:     	if (!clLocks.containsKey(name)) { 
1:     		clLocks.put(name, new Object());
1:     	}
1:     	return clLocks.get(name);
1:     }
commit:e436ced
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.proxy;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.lang.reflect.InvocationHandler;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.concurrent.Callable;
1: 
1: import org.apache.aries.proxy.FinalModifierException;
1: import org.apache.aries.proxy.InvocationListener;
1: import org.apache.aries.proxy.UnableToProxyException;
1: import org.apache.aries.proxy.impl.AbstractProxyManager;
1: import org.apache.aries.proxy.impl.AsmProxyManager;
1: import org.apache.aries.proxy.impl.ProxyHandler;
1: import org.apache.aries.proxy.impl.SingleInstanceDispatcher;
1: import org.apache.aries.proxy.impl.gen.ProxySubclassGenerator;
1: import org.apache.aries.proxy.impl.gen.ProxySubclassMethodHashSet;
1: import org.junit.Before;
1: import org.junit.Test;
1: 
1: /**
1:  * This class uses the {@link ProxySubclassGenerator} to test
1:  */
1: public class ProxySubclassGeneratorTest extends AbstractProxyTest
1: {
1:   private static final Class<?> FINAL_METHOD_CLASS = ProxyTestClassFinalMethod.class;
1:   private static final Class<?> FINAL_CLASS = ProxyTestClassFinal.class;
1:   private static final Class<?> GENERIC_CLASS = ProxyTestClassGeneric.class;
1:   private static final Class<?> COVARIANT_CLASS = ProxyTestClassCovariantOverride.class;
1:   private static ProxySubclassMethodHashSet<String> expectedMethods = new ProxySubclassMethodHashSet<String>(
1:       12);
1:   private InvocationHandler ih = null;
1:   Class<?> generatedProxySubclass = null;
1:   Object o = null;
1: 
1:   /**
1:    * @throws java.lang.Exception
1:    */
1:   @Before
1:   public void setUp() throws Exception
1:   {
1:     ih = new FakeInvocationHandler();
1:     ((FakeInvocationHandler)ih).setDelegate(getTestClass().newInstance());
1:     generatedProxySubclass = getGeneratedSubclass();
1:     o = getProxyInstance(generatedProxySubclass);
1:   }
1: 
1: 
1:   /**
1:    * Test that the methods found declared on the generated proxy subclass are
1:    * the ones that we expect.
1:    */
1:   @Test
1:   public void testExpectedMethods() throws Exception
1:   {
1:     Class<?> superclass = getTestClass();
1: 
1:     do {
1:       Method[] declaredMethods = superclass.getDeclaredMethods();
1:       List<Method> listOfDeclaredMethods = new ArrayList<Method>();
1:       for (Method m : declaredMethods) {
1:         int i = m.getModifiers();
1:         if (Modifier.isPrivate(i) || Modifier.isFinal(i)) {
1:           // private or final don't get added
1:         } else if (!(Modifier.isPublic(i) || Modifier.isPrivate(i) || Modifier.isProtected(i))) {
1:           // the method is default visibility, check the package
1:           if (m.getDeclaringClass().getPackage().equals(getTestClass().getPackage())) {
1:             // default vis with same package gets added
1:             listOfDeclaredMethods.add(m);
1:           }
1:         } else {
1:           listOfDeclaredMethods.add(m);
1:         }
1:       }
1: 
1:       declaredMethods = listOfDeclaredMethods.toArray(new Method[] {});
1:       ProxySubclassMethodHashSet<String> foundMethods = new ProxySubclassMethodHashSet<String>(
1:           declaredMethods.length);
1:       foundMethods.addMethodArray(declaredMethods);
1:       // as we are using a set we shouldn't get duplicates
1:       expectedMethods.addAll(foundMethods);
1:       superclass = superclass.getSuperclass();
1:     } while (superclass != null);
1: 
1:     // add the getter and setter for the invocation handler to the expected
1:     // set
1:     // and the unwrapObject method
1:     Method[] ihMethods = new Method[] {
1:         generatedProxySubclass.getMethod("setInvocationHandler",
1:             new Class[] { InvocationHandler.class }),
1:         generatedProxySubclass.getMethod("getInvocationHandler", new Class[] {}) };
1:     expectedMethods.addMethodArray(ihMethods);
1: 
1:     Method[] generatedProxySubclassMethods = generatedProxySubclass.getDeclaredMethods();
1:     ProxySubclassMethodHashSet<String> generatedMethods = new ProxySubclassMethodHashSet<String>(
1:         generatedProxySubclassMethods.length);
1:     generatedMethods.addMethodArray(generatedProxySubclassMethods);
1: 
1:     // check that all the methods we have generated were expected
1:     for (String gen : generatedMethods) {
1:       assertTrue("Unexpected method: " + gen, expectedMethods.contains(gen));
1:     }
1:     // check that all the expected methods were generated
1:     for (String exp : expectedMethods) {
1:       assertTrue("Method was not generated: " + exp, generatedMethods.contains(exp));
1:     }
1:     // check the sets were the same
1:     assertEquals("Sets were not the same", expectedMethods, generatedMethods);
1: 
1:   }
1: 
1:   /**
1:    * Test a method marked final
1:    */
1:   @Test
1:   public void testFinalMethod() throws Exception
1:   {
1:     try {
1:       ProxySubclassGenerator.getProxySubclass(FINAL_METHOD_CLASS);
1:     } catch (FinalModifierException e) {
1:       assertFalse("Should have found final method not final class", e.isFinalClass());
1:     }
1:   }
1: 
1:   /**
1:    * Test a class marked final
1:    */
1:   @Test
1:   public void testFinalClass() throws Exception
1:   {
1:     try {
1:       ProxySubclassGenerator.getProxySubclass(FINAL_CLASS);
1:     } catch (FinalModifierException e) {
1:       assertTrue("Should have found final class", e.isFinalClass());
1:     }
1:   }
1: 
1:   /**
1:    * Test a private constructor
1:    */
1:   @Test
1:   public void testPrivateConstructor() throws Exception
1:   {
1:     Object o = ProxySubclassGenerator.newProxySubclassInstance(
1:         ProxyTestClassPrivateConstructor.class, ih);
1:     assertNotNull("The new instance was null", o);
1: 
1:   }
1:   
1: //  /**
1: //   * Test object equality between real and proxy using a Collaborator
1: //   */
1: //  @Test
1: //  public void testObjectEquality() throws Exception
1: //  {
1: //    Object delegate = getTestClass().newInstance();
1: //    InvocationHandler collaborator = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
1: //    Object o = ProxySubclassGenerator.newProxySubclassInstance(getTestClass(), collaborator);
1: //    //Calling equals on the proxy with an arg of the unwrapped object should be true
1: //    assertTrue("The proxy object should be equal to its delegate",o.equals(delegate));
1: //    InvocationHandler collaborator2 = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
1: //    Object o2 = ProxySubclassGenerator.newProxySubclassInstance(getTestClass(), collaborator2);
1: //    //The proxy of a delegate should equal another proxy of the same delegate
1: //    assertTrue("The proxy object should be equal to another proxy instance of the same delegate", o2.equals(o));
1: //  }
1: //  
1: //  private static class ProxyTestOverridesFinalize {
1: //      public boolean finalizeCalled = false;
1: //      
1: //      @Override
1: //      protected void finalize() {
1: //          finalizeCalled = true;
1: //      }
1: //  }
1: //  
1: //  @Test
1: //  public void testFinalizeNotCalled() throws Exception {
1: //      ProxyTestOverridesFinalize testObj = new ProxyTestOverridesFinalize();
1: //      InvocationHandler ih = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(testObj));
1: //      Object o = ProxySubclassGenerator.newProxySubclassInstance(ProxyTestOverridesFinalize.class, ih);
1: //      
1: //      Method m = o.getClass().getDeclaredMethod("finalize");
1: //      m.setAccessible(true);
1: //      m.invoke(o);
1: //      
1: //      assertFalse(testObj.finalizeCalled);
1: //  }
1:   
1: 
1:   /**
1:    * Test a covariant override method
1:    */
1:   @Test
1:   public void testCovariant() throws Exception
1:   {
1:     ((FakeInvocationHandler)ih).setDelegate(COVARIANT_CLASS.newInstance());
1:     o = ProxySubclassGenerator.newProxySubclassInstance(COVARIANT_CLASS, ih);
1:     generatedProxySubclass = o.getClass();
1:     Method m = generatedProxySubclass.getDeclaredMethod("getCovariant", new Class[] {});
1:     Object returned = m.invoke(o);
1:     assertTrue("Object was of wrong type: " + returned.getClass().getSimpleName(), COVARIANT_CLASS
1:         .isInstance(returned));
1:   }
1:   
1:   /**
1:    * Test a covariant override method
1:    */
1:   @Test
1:   public void testGenerics() throws Exception
1:   {
1:     ((FakeInvocationHandler)ih).setDelegate(GENERIC_CLASS.newInstance());
1:     super.testGenerics();
1:   }
1:   
1:   private Class<?> getGeneratedSubclass() throws Exception
1:   {
1:     return getProxyClass(getTestClass());
1:   }
1: 
1:   private class FakeInvocationHandler implements InvocationHandler
1:   {
1:     private Object delegate = null;
1:     /*
1:      * (non-Javadoc)
1:      * 
1:      * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object,
1:      * java.lang.reflect.Method, java.lang.Object[])
1:      */
1:     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
1:     {
1:       try {
1:       Object result = (delegate instanceof Callable) ? 
1:           method.invoke(((Callable<?>)delegate).call(), args) : 
1:           method.invoke(delegate, args) ;
1:       return result;
1:       } catch (InvocationTargetException ite) {
1:         throw ite.getTargetException();
1:       }
1:     }
1: 
1:     void setDelegate(Object delegate){
1:       this.delegate = delegate;
1:     }
1:     
1:   }
1: 
1:   @Override
1:   protected Object getProxyInstance(Class<?> proxyClass) {
1:     return getProxyInstance(proxyClass, ih);
1:   }
1:   
1:   private Object getProxyInstance(Class<?> proxyClass, InvocationHandler ih) {
1:     try {
1:       if(proxyClass.equals(ProxyTestClassChildOfAbstract.class))
1:         return proxyClass.newInstance();
1:       
1:       Object proxyInstance = proxyClass.getConstructor().newInstance();
1:       Method setIH = proxyInstance.getClass().getMethod("setInvocationHandler", InvocationHandler.class);
1:       setIH.invoke(proxyInstance, ih);
1:       return proxyInstance;
1:     } catch (Exception e) {
1:       return null;
1:     }
1:   }
1: 
1:   @Override
1:   protected Class<?> getProxyClass(Class<?> clazz) {
1:     try {
1:       return ProxySubclassGenerator.getProxySubclass(clazz);
1:     } catch (UnableToProxyException e) {
1:       return null;
1:     }
1:   }
1: 
1: 
1:   @Override
1:   protected Object setDelegate(Object proxy, Callable<Object> dispatcher) {
1:     AbstractProxyManager apm = new AsmProxyManager();
1:     return getProxyInstance(proxy.getClass(), new ProxyHandler(apm, dispatcher, null));  
1:   }
1: 
1: 
1:   @Override
1:   protected Object getProxyInstance(Class<?> proxyClass,
1:       InvocationListener listener) {
1:     AbstractProxyManager apm = new AsmProxyManager();
1:     return getProxyInstance(proxyClass, new ProxyHandler(apm, new SingleInstanceDispatcher(getProxyInstance(proxyClass)), listener));  
1:   }
1: 
1: 
1:   @Override
1:   protected Object getP3() {
1:     return new ProxyTestClassGeneral();
1:   }
1: }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:cc94d79
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.io.IOUtils;
/////////////////////////////////////////////////////////////////////////
1: 
1:   @Test
1:   public void testClassLoaders() throws Exception {
1:     ClassLoader clA = new LimitedClassLoader("org.apache.aries.proxy.test.a", null, null);
1:     ClassLoader clB = new LimitedClassLoader("org.apache.aries.proxy.test.b", "org.apache.aries.proxy.test.a", clA);
1:     ClassLoader clC = new LimitedClassLoader("org.apache.aries.proxy.test.c", "org.apache.aries.proxy.test.b", clB);
1: 
1:     Class<?> clazzA = clA.loadClass("org.apache.aries.proxy.test.a.ProxyTestClassA");
1:     Class<?> clazzB = clB.loadClass("org.apache.aries.proxy.test.b.ProxyTestClassB");
1:     Class<?> clazzC = clC.loadClass("org.apache.aries.proxy.test.c.ProxyTestClassC");
1: 
1:     final Object object = clazzC.getConstructor(String.class).newInstance("hello");
1: 
1:     o = new AsmProxyManager().createNewProxy(null, Arrays.asList(clazzA, clazzB, clazzC), constantly(object), null);
1:     generatedProxySubclass = o.getClass();
1:     Method m = generatedProxySubclass.getDeclaredMethod("hello", new Class[] {});
1:     Object returned = m.invoke(o);
1:     assertEquals("hello", returned);
1:   }
1: 
1:   private static class LimitedClassLoader extends ClassLoader {
1:     Set<String> providedPackages;
1:     Set<String> importedPackages;
1:     List<ClassLoader> parents;
1: 
1:     public LimitedClassLoader(String provided, String imported, ClassLoader parent) {
1:       providedPackages = Collections.singleton(provided);
1:       importedPackages = imported != null ? Collections.singleton(imported) : Collections.<String>emptySet();
1:       parents = parent != null ? Collections.singletonList(parent) : Collections.<ClassLoader>emptyList();
1:     }
1: 
1:     @Override
1:     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:       synchronized (getClassLoadingLock(name)) {
1:         // First, check if the class has already been loaded
1:         Class<?> c = findLoadedClass(name);
1:         if (c == null) {
1:           String pkg = name.substring(0, name.lastIndexOf('.'));
1:           if (pkg.startsWith("java.") || pkg.startsWith("sun.reflect")) {
1:             return getClass().getClassLoader().loadClass(name);
1:           } else if (providedPackages.contains(pkg)) {
1:             c = findClass(name);
1:           } else if (importedPackages.contains(pkg)) {
1:             for (ClassLoader cl : parents) {
1:               try {
1:                 c = cl.loadClass(name);
1:               } catch (ClassNotFoundException e) {
1:                 // Ignore
1:               }
1:             }
1:           }
1:         }
1:         if (c == null) {
1:           throw new ClassNotFoundException(name);
1:         }
1:         if (resolve) {
1:           resolveClass(c);
1:         }
1:         return c;
1:       }
1:     }
1: 
1:     @Override
1:     protected Class<?> findClass(String name) throws ClassNotFoundException {
1:       String pkg = name.substring(0, name.lastIndexOf('.'));
1:       if (getPackage(pkg) == null) {
1:         definePackage(pkg, null, null, null, null, null, null, null);
1:       }
1:       String path = name.replace('.', '/').concat(".class");
1:       InputStream is = LimitedClassLoader.class.getClassLoader().getResourceAsStream(path);
1:       ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:       try {
1:         IOUtils.copy(is, baos);
1:       } catch (IOException e) {
1:         throw new ClassNotFoundException(name, e);
1:       }
1:       byte[] buf = baos.toByteArray();
1:       return defineClass(name, buf, 0, buf.length);
1:     }
1:   }
/////////////////////////////////////////////////////////////////////////
0: 
1:   private Callable<Object> constantly(final Object result) {
1:     return new Callable<Object>() {
1:       public Object call() throws Exception {
1:         return result;
1:       }
1:     };
1:   }
commit:071e3fe
/////////////////////////////////////////////////////////////////////////
0:     InvocationHandler collaborator = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
0:     InvocationHandler collaborator2 = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
/////////////////////////////////////////////////////////////////////////
0:       InvocationHandler ih = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(testObj));
author:Holly Cummins
-------------------------------------------------------------------------------
commit:2ab8aa5
/////////////////////////////////////////////////////////////////////////
0:   @org.junit.Ignore("Fails on JDK's 1.6.0_u33 and newer as you cannot call a private constructor from subclass")
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:8f852b6
/////////////////////////////////////////////////////////////////////////
0:     ((FakeInvocationHandler)ih).setDelegate(getTestClass().newInstance());
/////////////////////////////////////////////////////////////////////////
0:     Class<?> superclass = getTestClass();
/////////////////////////////////////////////////////////////////////////
0:           if (m.getDeclaringClass().getPackage().equals(getTestClass().getPackage())) {
/////////////////////////////////////////////////////////////////////////
0: //    Object delegate = getTestClass().newInstance();
0: //    Object o = ProxySubclassGenerator.newProxySubclassInstance(getTestClass(), collaborator);
0: //    Object o2 = ProxySubclassGenerator.newProxySubclassInstance(getTestClass(), collaborator2);
/////////////////////////////////////////////////////////////////////////
0:     return getProxyClass(getTestClass());
/////////////////////////////////////////////////////////////////////////
0:           method.invoke(((Callable<?>)delegate).call(), args) : 
commit:d014a6c
/////////////////////////////////////////////////////////////////////////
0:       if(proxyClass.equals(ProxyTestClassChildOfAbstract.class))
0:         return proxyClass.newInstance();
0:       
commit:96d4e06
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
0: import java.util.concurrent.Callable;
0: import org.apache.aries.proxy.InvocationListener;
0: import org.apache.aries.proxy.UnableToProxyException;
0: import org.apache.aries.proxy.impl.AbstractProxyManager;
0: import org.apache.aries.proxy.impl.AsmProxyManager;
0: import org.apache.aries.proxy.impl.ProxyHandler;
0: import org.apache.aries.proxy.impl.SingleInstanceDispatcher;
0: /**
0:  * This class uses the {@link ProxySubclassGenerator} to test
0:  */
0: public class ProxySubclassGeneratorTest extends AbstractProxyTest
/////////////////////////////////////////////////////////////////////////
0:   Class<?> generatedProxySubclass = null;
0:   Object o = null;
/////////////////////////////////////////////////////////////////////////
0:     o = getProxyInstance(generatedProxySubclass);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   /**
0:    * Test a covariant override method
0:    */
0:   @Test
0:   public void testCovariant() throws Exception
0:   {
0:     ((FakeInvocationHandler)ih).setDelegate(COVARIANT_CLASS.newInstance());
0:     o = ProxySubclassGenerator.newProxySubclassInstance(COVARIANT_CLASS, ih);
0:     generatedProxySubclass = o.getClass();
0:     Method m = generatedProxySubclass.getDeclaredMethod("getCovariant", new Class[] {});
0:     Object returned = m.invoke(o);
0:     assertTrue("Object was of wrong type: " + returned.getClass().getSimpleName(), COVARIANT_CLASS
0:         .isInstance(returned));
0:   }
0:   
0:   /**
0:    * Test a covariant override method
0:    */
0:   @Test
0:   public void testGenerics() throws Exception
0:   {
0:     ((FakeInvocationHandler)ih).setDelegate(GENERIC_CLASS.newInstance());
0:     super.testGenerics();
0:   }
0:   
0:     return getProxyClass(TEST_CLASS);
/////////////////////////////////////////////////////////////////////////
0:       try {
0:       Object result = (delegate instanceof Callable) ? 
0:           method.invoke(((Callable)delegate).call(), args) : 
0:           method.invoke(delegate, args) ;
0:       } catch (InvocationTargetException ite) {
0:         throw ite.getTargetException();
0:       }
/////////////////////////////////////////////////////////////////////////
0: 
0:   @Override
0:   protected Object getProxyInstance(Class<?> proxyClass) {
0:     return getProxyInstance(proxyClass, ih);
0:   }
0:   
0:   private Object getProxyInstance(Class<?> proxyClass, InvocationHandler ih) {
0:     try {
0:       return proxyClass.getConstructor(InvocationHandler.class).newInstance(ih);
0:     } catch (Exception e) {
0:       return null;
0:     }
0:   }
0: 
0:   @Override
0:   protected Class<?> getProxyClass(Class<?> clazz) {
0:     try {
0:       return ProxySubclassGenerator.getProxySubclass(clazz);
0:     } catch (UnableToProxyException e) {
0:       return null;
0:     }
0:   }
0: 
0: 
0:   @Override
0:   protected Object setDelegate(Object proxy, Callable<Object> dispatcher) {
0:     AbstractProxyManager apm = new AsmProxyManager();
0:     return getProxyInstance(proxy.getClass(), new ProxyHandler(apm, dispatcher, null));  
0:   }
0: 
0: 
0:   @Override
0:   protected Object getProxyInstance(Class<?> proxyClass,
0:       InvocationListener listener) {
0:     AbstractProxyManager apm = new AsmProxyManager();
0:     return getProxyInstance(proxyClass, new ProxyHandler(apm, new SingleInstanceDispatcher(getProxyInstance(proxyClass)), listener));  
0:   }
0: 
0: 
0:   @Override
0:   protected Object getP3() {
0:     return new ProxyTestClassGeneral();
0:   }
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:24455ce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.proxy.FinalModifierException;
0: import org.apache.aries.proxy.impl.gen.ProxySubclassGenerator;
0: import org.apache.aries.proxy.impl.gen.ProxySubclassMethodHashSet;
/////////////////////////////////////////////////////////////////////////
0:    * {@link org.apache.aries.proxy.impl.ProxySubclassGenerator#generateAndLoadSubclass()}
/////////////////////////////////////////////////////////////////////////
0: //  /**
0: //   * Test object equality between real and proxy using a Collaborator
0: //   */
0: //  @Test
0: //  public void testObjectEquality() throws Exception
0: //  {
0: //    Object delegate = TEST_CLASS.newInstance();
0: //    InvocationHandler collaborator = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
0: //    Object o = ProxySubclassGenerator.newProxySubclassInstance(TEST_CLASS, collaborator);
0: //    //Calling equals on the proxy with an arg of the unwrapped object should be true
0: //    assertTrue("The proxy object should be equal to its delegate",o.equals(delegate));
0: //    InvocationHandler collaborator2 = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(delegate));
0: //    Object o2 = ProxySubclassGenerator.newProxySubclassInstance(TEST_CLASS, collaborator2);
0: //    //The proxy of a delegate should equal another proxy of the same delegate
0: //    assertTrue("The proxy object should be equal to another proxy instance of the same delegate", o2.equals(o));
0: //  }
0: //  
0: //  private static class ProxyTestOverridesFinalize {
0: //      public boolean finalizeCalled = false;
0: //      
0: //      @Override
0: //      protected void finalize() {
0: //          finalizeCalled = true;
0: //      }
0: //  }
0: //  
0: //  @Test
0: //  public void testFinalizeNotCalled() throws Exception {
0: //      ProxyTestOverridesFinalize testObj = new ProxyTestOverridesFinalize();
0: //      InvocationHandler ih = new Collaborator(null, null, AsmInterceptorWrapper.passThrough(testObj));
0: //      Object o = ProxySubclassGenerator.newProxySubclassInstance(ProxyTestOverridesFinalize.class, ih);
0: //      
0: //      Method m = o.getClass().getDeclaredMethod("finalize");
0: //      m.setAccessible(true);
0: //      m.invoke(o);
0: //      
0: //      assertFalse(testObj.finalizeCalled);
0: //  }
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:dcf950a
/////////////////////////////////////////////////////////////////////////
0:   private static class ProxyTestOverridesFinalize {
0:       public boolean finalizeCalled = false;
0:       
0:       @Override
0:       protected void finalize() {
0:           finalizeCalled = true;
0:       }
0:   }
0:   
0:   @Test
0:   public void testFinalizeNotCalled() throws Exception {
0:       ProxyTestOverridesFinalize testObj = new ProxyTestOverridesFinalize();
0:       InvocationHandler ih = new Collaborator(null, null, testObj);
0:       Object o = ProxySubclassGenerator.newProxySubclassInstance(ProxyTestOverridesFinalize.class, ih);
0:       
0:       Method m = o.getClass().getDeclaredMethod("finalize");
0:       m.setAccessible(true);
0:       m.invoke(o);
0:       
0:       assertFalse(testObj.finalizeCalled);
0:   }
0:   
commit:0e57013
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:    * {@link org.apache.aries.blueprint.proxy.ProxySubclassGenerator#generateAndLoadSubclass()}
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:6a4e3c8
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.blueprint.proxy;
0: 
0: import static org.junit.Assert.*;
0: 
0: import java.lang.reflect.InvocationHandler;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.Modifier;
0: import java.util.ArrayList;
0: import java.util.List;
0: 
0: import org.junit.Before;
0: import org.junit.Test;
0: 
0: import org.apache.aries.blueprint.proxy.FinalModifierException;
0: import org.apache.aries.blueprint.proxy.ProxySubclassGenerator;
0: import org.apache.aries.blueprint.proxy.ProxySubclassMethodHashSet;
0: 
0: public class ProxySubclassGeneratorTest
0: {
0:   private static final Class<?> TEST_CLASS = ProxyTestClassGeneral.class;
0:   private static final Class<?> FINAL_METHOD_CLASS = ProxyTestClassFinalMethod.class;
0:   private static final Class<?> FINAL_CLASS = ProxyTestClassFinal.class;
0:   private static final Class<?> GENERIC_CLASS = ProxyTestClassGeneric.class;
0:   private static final Class<?> COVARIANT_CLASS = ProxyTestClassCovariantOverride.class;
0:   private static ProxySubclassMethodHashSet<String> expectedMethods = new ProxySubclassMethodHashSet<String>(
0:       12);
0:   private InvocationHandler ih = null;
0:   private Class<?> generatedProxySubclass = null;
0:   private Object o = null;
0: 
0:   /**
0:    * @throws java.lang.Exception
0:    */
0:   @Before
0:   public void setUp() throws Exception
0:   {
0:     ih = new FakeInvocationHandler();
0:     ((FakeInvocationHandler)ih).setDelegate(TEST_CLASS.newInstance());
0:     generatedProxySubclass = getGeneratedSubclass();
0:     o = getSubclassInstance(generatedProxySubclass);
0:   }
0: 
0:   /**
0:    * This test uses the ProxySubclassGenerator to generate and load a subclass
0:    * of the specified TEST_CLASS.
0:    * 
0:    * Once the subclass is generated we check that it wasn't null. We check
0:    * that the InvocationHandler constructor doesn't return a null object
0:    * either
0:    * 
0:    * Test method for
0:    * {@link com.ibm.osgi.blueprint.internal.proxy.ProxySubclassGenerator#generateAndLoadSubclass()}
0:    * .
0:    */
0:   @Test
0:   public void testGenerateAndLoadSubclass() throws Exception
0:   {
0:     assertNotNull("Generated proxy subclass was null", generatedProxySubclass);
0:     assertNotNull("Generated proxy subclass instance was null", o);
0:   }
0: 
0:   /**
0:    * Test that the methods found declared on the generated proxy subclass are
0:    * the ones that we expect.
0:    */
0:   @Test
0:   public void testExpectedMethods() throws Exception
0:   {
0:     Class<?> superclass = TEST_CLASS;
0: 
0:     do {
0:       Method[] declaredMethods = superclass.getDeclaredMethods();
0:       List<Method> listOfDeclaredMethods = new ArrayList<Method>();
0:       for (Method m : declaredMethods) {
0:         int i = m.getModifiers();
0:         if (Modifier.isPrivate(i) || Modifier.isFinal(i)) {
0:           // private or final don't get added
0:         } else if (!(Modifier.isPublic(i) || Modifier.isPrivate(i) || Modifier.isProtected(i))) {
0:           // the method is default visibility, check the package
0:           if (m.getDeclaringClass().getPackage().equals(TEST_CLASS.getPackage())) {
0:             // default vis with same package gets added
0:             listOfDeclaredMethods.add(m);
0:           }
0:         } else {
0:           listOfDeclaredMethods.add(m);
0:         }
0:       }
0: 
0:       declaredMethods = listOfDeclaredMethods.toArray(new Method[] {});
0:       ProxySubclassMethodHashSet<String> foundMethods = new ProxySubclassMethodHashSet<String>(
0:           declaredMethods.length);
0:       foundMethods.addMethodArray(declaredMethods);
0:       // as we are using a set we shouldn't get duplicates
0:       expectedMethods.addAll(foundMethods);
0:       superclass = superclass.getSuperclass();
0:     } while (superclass != null);
0: 
0:     // add the getter and setter for the invocation handler to the expected
0:     // set
0:     // and the unwrapObject method
0:     Method[] ihMethods = new Method[] {
0:         generatedProxySubclass.getMethod("setInvocationHandler",
0:             new Class[] { InvocationHandler.class }),
0:         generatedProxySubclass.getMethod("getInvocationHandler", new Class[] {}) };
0:     expectedMethods.addMethodArray(ihMethods);
0: 
0:     Method[] generatedProxySubclassMethods = generatedProxySubclass.getDeclaredMethods();
0:     ProxySubclassMethodHashSet<String> generatedMethods = new ProxySubclassMethodHashSet<String>(
0:         generatedProxySubclassMethods.length);
0:     generatedMethods.addMethodArray(generatedProxySubclassMethods);
0: 
0:     // check that all the methods we have generated were expected
0:     for (String gen : generatedMethods) {
0:       assertTrue("Unexpected method: " + gen, expectedMethods.contains(gen));
0:     }
0:     // check that all the expected methods were generated
0:     for (String exp : expectedMethods) {
0:       assertTrue("Method was not generated: " + exp, generatedMethods.contains(exp));
0:     }
0:     // check the sets were the same
0:     assertEquals("Sets were not the same", expectedMethods, generatedMethods);
0: 
0:   }
0: 
0:   /**
0:    * Test a basic method invocation on the proxy subclass
0:    */
0:   @Test
0:   public void testMethodInvocation() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("testMethod", new Class[] { String.class,
0:         int.class, Object.class });
0:     String x = "x";
0:     String returned = (String) m.invoke(o, x, 1, new Object());
0:     assertEquals("Object returned from invocation was not correct.", x, returned);
0:   }
0: 
0:   /**
0:    * Test different argument types on a method invocation
0:    */
0:   @Test
0:   public void testMethodArgs() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("testArgs", new Class[] { double.class,
0:         short.class, long.class, char.class, byte.class, boolean.class });
0:     Character xc = Character.valueOf('x');
0:     String x = xc.toString();
0:     String returned = (String) m.invoke(o, Double.MAX_VALUE, Short.MIN_VALUE, Long.MAX_VALUE, xc
0:         .charValue(), Byte.MIN_VALUE, false);
0:     assertEquals("Object returned from invocation was not correct.", x, returned);
0:   }
0: 
0:   /**
0:    * Test a method that returns void
0:    */
0:   @Test
0:   public void testReturnVoid() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("testReturnVoid", new Class[] {});
0:     m.invoke(o);
0:   }
0: 
0:   /**
0:    * Test a method that returns an int
0:    */
0:   @Test
0:   public void testReturnInt() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("testReturnInt", new Class[] {});
0:     Integer returned = (Integer) m.invoke(o);
0:     assertEquals("Expected object was not returned from invocation", Integer.valueOf(17), returned);
0:   }
0: 
0:   /**
0:    * Test a method that returns an Integer
0:    */
0:   @Test
0:   public void testReturnInteger() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("testReturnInteger", new Class[] {});
0:     Integer returned = (Integer) m.invoke(o);
0:     assertEquals("Expected object was not returned from invocation", Integer.valueOf(1), returned);
0:   }
0: 
0:   /**
0:    * Test a public method declared higher up the superclass hierarchy
0:    */
0:   @Test
0:   public void testPublicHierarchyMethod() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("bMethod", new Class[] {});
0:     m.invoke(o);
0:   }
0: 
0:   /**
0:    * Test a protected method declared higher up the superclass hierarchy
0:    */
0:   @Test
0:   public void testProtectedHierarchyMethod() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("bProMethod", new Class[] {});
0:     m.invoke(o);
0:   }
0: 
0:   /**
0:    * Test a default method declared higher up the superclass hierarchy
0:    */
0:   @Test
0:   public void testDefaultHierarchyMethod() throws Exception
0:   {
0:     Method m = generatedProxySubclass.getDeclaredMethod("bDefMethod", new Class[] {});
0:     m.invoke(o);
0:   }
0: 
0:   /**
0:    * Test a covariant override method
0:    */
0:   @Test
0:   public void testCovariant() throws Exception
0:   {
0:     ((FakeInvocationHandler)ih).setDelegate(COVARIANT_CLASS.newInstance());
0:     o = ProxySubclassGenerator.newProxySubclassInstance(COVARIANT_CLASS, ih);
0:     generatedProxySubclass = o.getClass();
0:     Method m = generatedProxySubclass.getDeclaredMethod("getCovariant", new Class[] {});
0:     Object returned = m.invoke(o);
0:     assertTrue("Object was of wrong type: " + returned.getClass().getSimpleName(), COVARIANT_CLASS
0:         .isInstance(returned));
0:   }
0: 
0:   /**
0:    * Test a method with generics
0:    */
0:   @Test
0:   public void testGenerics() throws Exception
0:   {
0:     ((FakeInvocationHandler)ih).setDelegate(GENERIC_CLASS.newInstance());
0:     o = ProxySubclassGenerator.newProxySubclassInstance(GENERIC_CLASS, ih);
0:     generatedProxySubclass = o.getClass();
0:     Method m = generatedProxySubclass.getDeclaredMethod("setSomething",
0:         new Class[] { String.class });
0:     m.invoke(o, "aString");
0:     m = generatedProxySubclass.getDeclaredMethod("getSomething", new Class[] {});
0:     Object returned = m.invoke(o);
0:     assertTrue("Object was of wrong type", String.class.isInstance(returned));
0:     assertEquals("String had wrong value", "aString", returned);
0:   }
0: 
0:   /**
0:    * Test a method marked final
0:    */
0:   @Test
0:   public void testFinalMethod() throws Exception
0:   {
0:     try {
0:       ProxySubclassGenerator.getProxySubclass(FINAL_METHOD_CLASS);
0:     } catch (FinalModifierException e) {
0:       assertFalse("Should have found final method not final class", e.isFinalClass());
0:     }
0:   }
0: 
0:   /**
0:    * Test a class marked final
0:    */
0:   @Test
0:   public void testFinalClass() throws Exception
0:   {
0:     try {
0:       ProxySubclassGenerator.getProxySubclass(FINAL_CLASS);
0:     } catch (FinalModifierException e) {
0:       assertTrue("Should have found final class", e.isFinalClass());
0:     }
0:   }
0: 
0:   /**
0:    * Test that we don't generate classes twice
0:    */
0:   @Test
0:   public void testRetrieveClass() throws Exception
0:   {
0:     Class<?> retrieved = ProxySubclassGenerator.getProxySubclass(TEST_CLASS);
0:     assertNotNull("The new class was null", retrieved);
0:     assertEquals("The same class was not returned", generatedProxySubclass, retrieved);
0: 
0:   }
0: 
0:   /**
0:    * Test a private constructor
0:    */
0:   @Test
0:   public void testPrivateConstructor() throws Exception
0:   {
0:     Object o = ProxySubclassGenerator.newProxySubclassInstance(
0:         ProxyTestClassPrivateConstructor.class, ih);
0:     assertNotNull("The new instance was null", o);
0: 
0:   }
0:   
0:   /**
0:    * Test object equality between real and proxy using a Collaborator
0:    */
0:   @Test
0:   public void testObjectEquality() throws Exception
0:   {
0:     Object delegate = TEST_CLASS.newInstance();
0:     InvocationHandler collaborator = new Collaborator(null, null, delegate);
0:     Object o = ProxySubclassGenerator.newProxySubclassInstance(TEST_CLASS, collaborator);
0:     //Calling equals on the proxy with an arg of the unwrapped object should be true
0:     assertTrue("The proxy object should be equal to its delegate",o.equals(delegate));
0:     InvocationHandler collaborator2 = new Collaborator(null, null, delegate);
0:     Object o2 = ProxySubclassGenerator.newProxySubclassInstance(TEST_CLASS, collaborator2);
0:     //The proxy of a delegate should equal another proxy of the same delegate
0:     assertTrue("The proxy object should be equal to another proxy instance of the same delegate", o2.equals(o));
0:   }
0:   
0: 
0:   private Class<?> getGeneratedSubclass() throws Exception
0:   {
0:     return ProxySubclassGenerator.getProxySubclass(TEST_CLASS);
0:   }
0: 
0:   private Object getSubclassInstance(Class<?> clazz) throws Exception
0:   {
0:     return clazz.getConstructor(InvocationHandler.class).newInstance(ih);
0:   }
0: 
0:   private class FakeInvocationHandler implements InvocationHandler
0:   {
0:     private Object delegate = null;
0:     /*
0:      * (non-Javadoc)
0:      * 
0:      * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object,
0:      * java.lang.reflect.Method, java.lang.Object[])
0:      */
0:     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
0:     {
0:       Object result = method.invoke(delegate, args);
0:       return result;
0:     }
0: 
0:     void setDelegate(Object delegate){
0:       this.delegate = delegate;
0:     }
0:     
0:   }
0: }
============================================================================