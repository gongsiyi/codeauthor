1:46cfc09: /**
1:46cfc09:  * Licensed to the Apache Software Foundation (ASF) under one
1:46cfc09:  * or more contributor license agreements.  See the NOTICE file
1:46cfc09:  * distributed with this work for additional information
1:46cfc09:  * regarding copyright ownership.  The ASF licenses this file
1:46cfc09:  * to you under the Apache License, Version 2.0 (the
1:46cfc09:  * "License"); you may not use this file except in compliance
1:46cfc09:  * with the License.  You may obtain a copy of the License at
1:aeab80c:  * <p/>
1:218954f:  * http://www.apache.org/licenses/LICENSE-2.0
1:aeab80c:  * <p/>
1:46cfc09:  * Unless required by applicable law or agreed to in writing,
1:46cfc09:  * software distributed under the License is distributed on an
1:46cfc09:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:46cfc09:  * KIND, either express or implied.  See the License for the
1:46cfc09:  * specific language governing permissions and limitations
1:46cfc09:  * under the License.
1:46cfc09:  */
1:46cfc09: package org.apache.aries.blueprint.plugin.model;
1:fff2e99: 
1:c201f83: import org.apache.aries.blueprint.plugin.Extensions;
1:a04c623: import org.apache.aries.blueprint.plugin.spi.BeanAnnotationHandler;
1:0d2c0ec: import org.apache.aries.blueprint.plugin.spi.BeanEnricher;
1:0d2c0ec: import org.apache.aries.blueprint.plugin.spi.ContextEnricher;
1:868c96f: import org.apache.aries.blueprint.plugin.spi.CustomDependencyAnnotationHandler;
1:64f241a: import org.apache.aries.blueprint.plugin.spi.FieldAnnotationHandler;
1:c201f83: import org.apache.aries.blueprint.plugin.spi.InjectLikeHandler;
1:a04c623: import org.apache.aries.blueprint.plugin.spi.MethodAnnotationHandler;
1:0d2c0ec: import org.apache.aries.blueprint.plugin.spi.XmlWriter;
1:218954f: 
1:218954f: import java.lang.annotation.Annotation;
1:7583a4c: import java.lang.reflect.AnnotatedElement;
1:218954f: import java.lang.reflect.Constructor;
1:46cfc09: import java.lang.reflect.Field;
1:46cfc09: import java.lang.reflect.Method;
1:218954f: import java.util.ArrayList;
1:c201f83: import java.util.HashMap;
1:fff2e99: import java.util.HashSet;
1:66fc490: import java.util.List;
1:c201f83: import java.util.Map;
1:fff2e99: import java.util.Set;
1:46cfc09: import java.util.SortedSet;
1:46cfc09: import java.util.TreeSet;
1:f36cef0: 
1:fc7ae19: import static org.apache.aries.blueprint.plugin.model.AnnotationHelper.findName;
1:c201f83: import static org.apache.aries.blueprint.plugin.model.AnnotationHelper.findValue;
1:b5bf406: 
1:0d2c0ec: public class Bean extends BeanRef implements BeanEnricher {
1:218954f:     public SortedSet<Property> properties = new TreeSet<>();
1:218954f:     public List<Argument> constructorArguments = new ArrayList<>();
1:f36cef0:     public boolean isPrototype;
1:c201f83:     public final Map<String, String> attributes = new HashMap<>();
1:868c96f:     public final Set<BeanRef> refs = new HashSet<>();
1:0d2c0ec:     public final Map<String, XmlWriter> beanContentWriters = new HashMap<>();
1:0d2c0ec:     protected final ContextEnricher contextEnricher;
1:b5bf406: 
1:0d2c0ec:     public Bean(Class<?> clazz, ContextEnricher contextEnricher) {
1:9b08497:         super(clazz, BeanRef.getBeanName(clazz));
1:0d2c0ec:         this.contextEnricher = contextEnricher;
1:05c904d:         Introspector introspector = new Introspector(clazz);
9:46cfc09: 
1:f36cef0:         this.isPrototype = isPrototype(clazz);
1:46cfc09: 
1:218954f:         setQualifiersFromAnnotations(clazz.getAnnotations());
1:46cfc09: 
1:868c96f:         handleCustomBeanAnnotations();
1:46cfc09: 
1:64f241a:         handleFieldsAnnotation(introspector);
1:46cfc09: 
1:a04c623:         handleMethodsAnnotation(introspector);
5:46cfc09:     }
1:218954f: 
1:a2ed671:     public void resolve(BlueprintRegister blueprintRegister) {
1:a2ed671:         resolveArguments(blueprintRegister);
1:a2ed671:         resolveFields(blueprintRegister);
1:a2ed671:         resolveMethods(blueprintRegister);
1:218954f:     }
1:f36cef0: 
1:a04c623:     private void handleMethodsAnnotation(Introspector introspector) {
1:a04c623:         for (MethodAnnotationHandler methodAnnotationHandler : Extensions.methodAnnotationHandlers) {
1:a04c623:             List<Method> methods = introspector.methodsWith(methodAnnotationHandler.getAnnotation());
1:a04c623:             if (methods.size() > 0) {
1:0d2c0ec:                 methodAnnotationHandler.handleMethodAnnotation(clazz, methods, contextEnricher, this);
1:218954f:             }
1:f36cef0:         }
1:0b1a9fb:     }
1:0b1a9fb: 
1:64f241a:     private void handleFieldsAnnotation(Introspector introspector) {
1:64f241a:         for (FieldAnnotationHandler fieldAnnotationHandler : Extensions.fieldAnnotationHandlers) {
1:64f241a:             List<Field> fields = introspector.fieldsWith(fieldAnnotationHandler.getAnnotation());
1:64f241a:             if (fields.size() > 0) {
1:fc7ae19:                 fieldAnnotationHandler.handleFieldAnnotation(clazz, fields, contextEnricher, this);
1:0b1a9fb:             }
1:0b1a9fb:         }
1:0b1a9fb:     }
1:0b1a9fb: 
1:868c96f:     private void handleCustomBeanAnnotations() {
1:a04c623:         for (BeanAnnotationHandler beanAnnotationHandler : Extensions.BEAN_ANNOTATION_HANDLERs) {
1:a04c623:             Object annotation = AnnotationHelper.findAnnotation(clazz.getAnnotations(), beanAnnotationHandler.getAnnotation());
1:868c96f:             if (annotation != null) {
1:0d2c0ec:                 beanAnnotationHandler.handleBeanAnnotation(clazz, id, contextEnricher, this);
1:0b1a9fb:             }
1:0b1a9fb:         }
1:46cfc09:     }
1:0b1a9fb: 
1:218954f:     private boolean isPrototype(Class<?> clazz) {
1:c201f83:         return !findSingleton(clazz);
1:46cfc09:     }
1:0b1a9fb: 
1:c201f83:     private boolean findSingleton(Class clazz) {
1:c201f83:         for (Class<?> singletonAnnotation : Extensions.singletons) {
1:c201f83:             if (clazz.getAnnotation(singletonAnnotation) != null) {
1:c201f83:                 return true;
1:46cfc09:             }
1:46cfc09:         }
1:c201f83:         return false;
1:46cfc09:     }
1:0b1a9fb: 
1:0b1a9fb: 
1:a2ed671:     private void resolveMethods(BlueprintRegister blueprintRegister) {
1:c201f83:         for (Method method : new Introspector(clazz).methodsWith(AnnotationHelper.injectDependencyAnnotations)) {
1:a2ed671:             Property prop = Property.create(blueprintRegister, method);
1:d22e134:             if (prop != null) {
1:d22e134:                 properties.add(prop);
1:46cfc09:             }
1:46cfc09:         }
1:46cfc09:     }
1:0b1a9fb: 
1:a2ed671:     private void resolveFields(BlueprintRegister matcher) {
1:c201f83:         for (Field field : new Introspector(clazz).fieldsWith(AnnotationHelper.injectDependencyAnnotations)) {
1:46cfc09:             Property prop = Property.create(matcher, field);
1:46cfc09:             if (prop != null) {
1:46cfc09:                 properties.add(prop);
1:46cfc09:             }
1:46cfc09:         }
1:46cfc09:     }
1:46cfc09: 
1:a2ed671:     protected void resolveArguments(BlueprintRegister matcher) {
1:aeab80c:         Constructor<?>[] declaredConstructors = clazz.getDeclaredConstructors();
1:aeab80c:         for (Constructor constructor : declaredConstructors) {
1:c201f83:             if (declaredConstructors.length == 1 || shouldInject(constructor)) {
1:7f12763:                 resolveArguments(matcher, constructor.getParameterTypes(), constructor.getParameterAnnotations());
1:868c96f:                 break;
1:46cfc09:             }
1:46cfc09:         }
1:46cfc09:     }
1:5ab57d7: 
1:c201f83:     private boolean shouldInject(AnnotatedElement annotatedElement) {
1:c201f83:         for (InjectLikeHandler injectLikeHandler : Extensions.beanInjectLikeHandlers) {
1:c201f83:             if (annotatedElement.getAnnotation(injectLikeHandler.getAnnotation()) != null) {
1:c201f83:                 return true;
1:46cfc09:             }
1:46cfc09:         }
1:c201f83:         return false;
1:46cfc09:     }
1:46cfc09: 
1:a2ed671:     protected void resolveArguments(BlueprintRegister blueprintRegister, Class[] parameterTypes, Annotation[][] parameterAnnotations) {
1:5ab57d7:         for (int i = 0; i < parameterTypes.length; ++i) {
1:5ab57d7:             Annotation[] annotations = parameterAnnotations[i];
1:c201f83:             String value = findValue(annotations);
1:868c96f:             String ref = findName(annotations);
1:5ab57d7: 
1:868c96f:             for (CustomDependencyAnnotationHandler customDependencyAnnotationHandler : Extensions.customDependencyAnnotationHandlers) {
1:868c96f:                 Annotation annotation = (Annotation) AnnotationHelper.findAnnotation(annotations, customDependencyAnnotationHandler.getAnnotation());
1:868c96f:                 if (annotation != null) {
1:a2ed671:                     String generatedRef = customDependencyAnnotationHandler.handleDependencyAnnotation(parameterTypes[i], annotation, ref, blueprintRegister);
1:868c96f:                     if (generatedRef != null) {
1:868c96f:                         ref = generatedRef;
1:218954f:                         break;
1:5ab57d7:                     }
1:5ab57d7:                 }
1:218954f:             }
1:5ab57d7: 
1:868c96f:             if (ref == null && value == null) {
1:5ab57d7:                 BeanRef template = new BeanRef(parameterTypes[i]);
1:5ab57d7:                 template.setQualifiersFromAnnotations(annotations);
1:a2ed671:                 BeanRef bean = blueprintRegister.getMatching(template);
1:5ab57d7:                 if (bean != null) {
1:5ab57d7:                     ref = bean.id;
1:5ab57d7:                 } else {
1:c201f83:                     String name = findName(annotations);
1:868c96f:                     if (name != null) {
1:c201f83:                         ref = name;
1:5ab57d7:                     } else {
1:5ab57d7:                         ref = getBeanName(parameterTypes[i]);
1:5ab57d7:                     }
1:5ab57d7:                 }
1:5ab57d7:             }
1:5ab57d7: 
1:5ab57d7:             constructorArguments.add(new Argument(ref, value));
1:5ab57d7:         }
1:5ab57d7:     }
1:5ab57d7: 
1:46cfc09:     @Override
1:46cfc09:     public String toString() {
1:46cfc09:         return clazz.getName();
1:218954f:     }
1:218954f: 
1:46cfc09:     public void writeProperties(PropertyWriter writer) {
1:46cfc09:         for (Property property : properties) {
1:46cfc09:             writer.writeProperty(property);
1:218954f:         }
1:218954f:     }
1:218954f: 
1:218954f:     public void writeArguments(ArgumentWriter writer) {
1:218954f:         for (Argument argument : constructorArguments) {
1:218954f:             writer.writeArgument(argument);
1:218954f:         }
1:218954f:     }
1:218954f: 
1:9632b7d:     public boolean needFieldInjection() {
1:9632b7d:         for (Property property : properties) {
1:9632b7d:             if (property.isField) {
1:9632b7d:                 return true;
1:218954f:             }
1:218954f:         }
1:9632b7d:         return false;
1:218954f:     }
1:218954f: 
1:46cfc09:     @Override
1:a04c623:     public void addAttribute(String key, String value) {
1:a04c623:         attributes.put(key, value);
1:218954f:     }
1:46cfc09: 
1:46cfc09:     @Override
1:0d2c0ec:     public void addBeanContentWriter(String id, XmlWriter blueprintWriter) {
1:0d2c0ec:         beanContentWriters.put(id, blueprintWriter);
1:218954f:     }
1:46cfc09: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:808409a
commit:7f12763
/////////////////////////////////////////////////////////////////////////
0:         resolveArguments(matcher);
/////////////////////////////////////////////////////////////////////////
0:     protected void resolveArguments(Matcher matcher) {
1:                 resolveArguments(matcher, constructor.getParameterTypes(), constructor.getParameterAnnotations());
0:     protected void resolveArguments(Matcher matcher, Class[] parameterTypes, Annotation[][] parameterAnnotations) {
commit:5ab57d7
/////////////////////////////////////////////////////////////////////////
0:     protected void resolveConstructorArguments(Matcher matcher) {
/////////////////////////////////////////////////////////////////////////
0:                 resolveParametersForConstructor(matcher, parameterTypes, parameterAnnotations);
0:     protected void resolveParametersForConstructor(Matcher matcher, Class[] parameterTypes, Annotation[][] parameterAnnotations) {
1:         for (int i = 0; i < parameterTypes.length; ++i) {
1:             Annotation[] annotations = parameterAnnotations[i];
0:             String ref = null;
0:             String value = null;
0:             Value valueAnnotation = findAnnotation(annotations, Value.class);
0:             OsgiService osgiServiceAnnotation = findAnnotation(annotations, OsgiService.class);
1: 
0:             if (valueAnnotation != null) {
0:                 value = valueAnnotation.value();
1:             }
1: 
0:             if (osgiServiceAnnotation != null) {
0:                 Named namedAnnotation = findAnnotation(annotations, Named.class);
0:                 ref = namedAnnotation != null ? namedAnnotation.value() : getBeanNameFromSimpleName(parameterTypes[i].getSimpleName());
0:                 OsgiServiceRef osgiServiceRef = new OsgiServiceRef(parameterTypes[i], osgiServiceAnnotation, ref);
0:                 serviceRefs.add(osgiServiceRef);
1:             }
1: 
0:             if (ref == null && value == null && osgiServiceAnnotation == null) {
1:                 BeanRef template = new BeanRef(parameterTypes[i]);
1:                 template.setQualifiersFromAnnotations(annotations);
0:                 BeanRef bean = matcher.getMatching(template);
1:                 if (bean != null) {
1:                     ref = bean.id;
1:                 } else {
0:                     Named namedAnnotation = findAnnotation(annotations, Named.class);
0:                     if (namedAnnotation != null) {
0:                         ref = namedAnnotation.value();
1:                     } else {
1:                         ref = getBeanName(parameterTypes[i]);
1:                     }
1:                 }
1:             }
1: 
1:             constructorArguments.add(new Argument(ref, value));
1:         }
1:     }
1: 
commit:aeab80c
/////////////////////////////////////////////////////////////////////////
1:  * <p/>
1:  * <p/>
/////////////////////////////////////////////////////////////////////////
1:         Constructor<?>[] declaredConstructors = clazz.getDeclaredConstructors();
1:         for (Constructor constructor : declaredConstructors) {
0:             if (inject != null || autowired != null || declaredConstructors.length == 1) {
commit:218954f
/////////////////////////////////////////////////////////////////////////
0:  * <p>
1:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * <p>
/////////////////////////////////////////////////////////////////////////
0: import org.ops4j.pax.cdi.api.OsgiService;
0: import org.springframework.beans.factory.annotation.Autowired;
0: import org.springframework.beans.factory.annotation.Value;
0: import org.springframework.stereotype.Component;
1: 
0: import javax.annotation.PostConstruct;
0: import javax.annotation.PreDestroy;
0: import javax.inject.Inject;
0: import javax.inject.Named;
0: import javax.inject.Singleton;
0: import javax.persistence.PersistenceContext;
0: import javax.persistence.PersistenceUnit;
1: import java.lang.annotation.Annotation;
1: import java.lang.reflect.Constructor;
1: import java.util.ArrayList;
1:     public SortedSet<Property> properties = new TreeSet<>();
1:     public List<Argument> constructorArguments = new ArrayList<>();
0:     public Set<OsgiServiceRef> serviceRefs = new HashSet<>();
0:     public Set<TransactionalDef> transactionDefs = new HashSet<>();
/////////////////////////////////////////////////////////////////////////
1:         setQualifiersFromAnnotations(clazz.getAnnotations());
1:     private boolean isPrototype(Class<?> clazz) {
0:         resolveConstructorArguments(matcher);
/////////////////////////////////////////////////////////////////////////
0:     private void resolveConstructorArguments(Matcher matcher) {
0:         for (Constructor constructor : clazz.getDeclaredConstructors()) {
0:             Annotation inject = constructor.getAnnotation(Inject.class);
0:             Annotation autowired = constructor.getAnnotation(Autowired.class);
0:             if (inject != null || autowired != null) {
0:                 Class[] parameterTypes = constructor.getParameterTypes();
0:                 Annotation[][] parameterAnnotations = constructor.getParameterAnnotations();
0:                 for (int i = 0; i < parameterTypes.length; ++i) {
0:                     Annotation[] annotations = parameterAnnotations[i];
0:                     String ref = null;
0:                     String value = null;
0:                     Value valueAnnotation = findAnnotation(annotations, Value.class);
0:                     OsgiService osgiServiceAnnotation = findAnnotation(annotations, OsgiService.class);
0:                     if (valueAnnotation != null) {
0:                         value = valueAnnotation.value();
1:                     }
0:                     if (osgiServiceAnnotation != null) {
0:                         Named namedAnnotation = findAnnotation(annotations, Named.class);
0:                         ref = namedAnnotation != null ? namedAnnotation.value() : getBeanNameFromSimpleName(parameterTypes[i].getSimpleName());
0:                         OsgiServiceRef osgiServiceRef = new OsgiServiceRef(parameterTypes[i], osgiServiceAnnotation, ref);
0:                         serviceRefs.add(osgiServiceRef);
1:                     }
1: 
0:                     if (ref == null && value == null && osgiServiceAnnotation == null) {
0:                         BeanRef template = new BeanRef(parameterTypes[i]);
0:                         template.setQualifiersFromAnnotations(annotations);
0:                         BeanRef bean = matcher.getMatching(template);
0:                         if (bean != null) {
0:                             ref = bean.id;
0:                         } else {
0:                             Named namedAnnotation = findAnnotation(annotations, Named.class);
0:                             if (namedAnnotation != null) {
0:                                 ref = namedAnnotation.value();
0:                             } else {
0:                                 ref = getBeanName(parameterTypes[i]);
1:                             }
1:                         }
1:                     }
1: 
0:                     constructorArguments.add(new Argument(ref, value));
1:                 }
1:                 break;
1:             }
1:         }
1:     }
1: 
0:     private static <T> T findAnnotation(Annotation[] annotations, Class<T> annotation) {
0:         for (Annotation a : annotations) {
0:             if (a.annotationType() == annotation) {
0:                 return annotation.cast(a);
1:             }
1:         }
0:         return null;
/////////////////////////////////////////////////////////////////////////
1:     public void writeArguments(ArgumentWriter writer) {
1:         for (Argument argument : constructorArguments) {
1:             writer.writeArgument(argument);
1:         }
1:     }
1: 
1: 
commit:05c904d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Introspector introspector = new Introspector(clazz);
0:         Method initMethod = introspector.methodWith(PostConstruct.class);
0:         Method destroyMethod = introspector.methodWith(PreDestroy.class);
/////////////////////////////////////////////////////////////////////////
0:         this.persistenceFields = introspector.fieldsWith(PersistenceContext.class, PersistenceUnit.class);
/////////////////////////////////////////////////////////////////////////
0:         for (Field field : new Introspector(clazz).fieldsWith(Value.class, Autowired.class, Inject.class)) {
/////////////////////////////////////////////////////////////////////////
commit:3aa60ba
/////////////////////////////////////////////////////////////////////////
0: import javax.inject.Inject;
0: import org.springframework.beans.factory.annotation.Autowired;
0: import org.springframework.beans.factory.annotation.Value;
/////////////////////////////////////////////////////////////////////////
0:     public List<Field> persistenceFields;
/////////////////////////////////////////////////////////////////////////
0:         this.persistenceFields = new FieldFinder(PersistenceContext.class, PersistenceUnit.class).findFields(clazz);
/////////////////////////////////////////////////////////////////////////
0:         for (Field field : new FieldFinder(Value.class, Autowired.class, Inject.class).findFields(clazz)) {
commit:fff2e99
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     public Set<TransactionalDef> transactionDefs = new HashSet<TransactionalDef>();
/////////////////////////////////////////////////////////////////////////
1: 
0:         // Transactional methods
0:         transactionDefs.addAll(new JavaxTransactionFactory().create(clazz));
0:         transactionDefs.addAll(new SpringTransactionFactory().create(clazz));
commit:f36cef0
/////////////////////////////////////////////////////////////////////////
0: import javax.inject.Singleton;
0: import org.springframework.stereotype.Component;
1: 
1:     public boolean isPrototype;
/////////////////////////////////////////////////////////////////////////
1:         this.isPrototype = isPrototype(clazz);
/////////////////////////////////////////////////////////////////////////
0:     private boolean isPrototype(Class<?> clazz)
0:     {
0:         return clazz.getAnnotation(Singleton.class) == null && clazz.getAnnotation(Component.class) == null;
1:     }
1: 
commit:9b08497
/////////////////////////////////////////////////////////////////////////
1:         super(clazz, BeanRef.getBeanName(clazz));
commit:65ec8ae
/////////////////////////////////////////////////////////////////////////
0:         while (curClass != null && curClass != Object.class) {
commit:b5bf406
/////////////////////////////////////////////////////////////////////////
0: public class Bean extends BeanRef {
0:     public TransactionalDef transactionDef;
1: 
0:         super(clazz);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:66fc490
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: import java.util.List;
0: import javax.persistence.PersistenceContext;
/////////////////////////////////////////////////////////////////////////
0:     public Field[] persistenceFields;
/////////////////////////////////////////////////////////////////////////
0:         this.persistenceFields = getPersistenceFields();
/////////////////////////////////////////////////////////////////////////
0:     private Field[] getPersistenceFields() {
0:         List<Field> persistenceFields = new ArrayList<Field>();
0:             PersistenceContext persistenceContext = field.getAnnotation(PersistenceContext.class);
0:             if (persistenceContext !=null || persistenceUnit != null) {
0:                  persistenceFields.add(field);
0:         return persistenceFields.toArray(new Field[]{});
commit:0b1a9fb
/////////////////////////////////////////////////////////////////////////
0: import java.lang.annotation.Annotation;
/////////////////////////////////////////////////////////////////////////
0:             PostConstruct postConstruct = getEffectiveAnnotation(method, PostConstruct.class);
0:             PreDestroy preDestroy = getEffectiveAnnotation(method, PreDestroy.class);
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static <T extends Annotation> T getEffectiveAnnotation(Method method, Class<T> annotationClass) {
0:         final Class<?> methodClass = method.getDeclaringClass();
0:         final String name = method.getName();
0:         final Class<?>[] params = method.getParameterTypes();
1: 
0:         // 1. Current class
0:         final T rootAnnotation = method.getAnnotation(annotationClass);
0:         if (rootAnnotation != null) {
0:             return rootAnnotation;
1:         }
1: 
0:         // 2. Superclass
0:         final Class<?> superclass = methodClass.getSuperclass();
0:         if (superclass != null) {
0:             final T annotation = getMethodAnnotation(superclass, name, params, annotationClass);
0:             if (annotation != null)
0:                 return annotation;
1:         }
1: 
0:         // 3. Interfaces
0:         for (final Class<?> intfs : methodClass.getInterfaces()) {
0:             final T annotation = getMethodAnnotation(intfs, name, params, annotationClass);
0:             if (annotation != null)
0:                 return annotation;
1:         }
1: 
0:         return null;
1:     }
1: 
0:     private static <T extends Annotation> T getMethodAnnotation(Class<?> searchClass, String name, Class<?>[] params,
0:             Class<T> annotationClass) {
0:         try {
0:             Method method = searchClass.getMethod(name, params);
0:             return getEffectiveAnnotation(method, annotationClass);
0:         } catch (NoSuchMethodException e) {
0:             return null;
1:         }
1:     }
1:     
commit:46cfc09
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.blueprint.plugin.model;
1: 
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Method;
1: import java.util.SortedSet;
1: import java.util.TreeSet;
1: 
0: import javax.annotation.PostConstruct;
0: import javax.annotation.PreDestroy;
0: import javax.inject.Named;
0: import javax.persistence.PersistenceUnit;
1: 
0: import org.springframework.stereotype.Component;
1: 
0: public class Bean implements Comparable<Bean>{
0:     public String id;
0:     public Class<?> clazz;
0:     public String initMethod;
0:     public String destroyMethod;
0:     public SortedSet<Property> properties;
0:     public Field persistenceUnitField;
0:     public TransactionalDef transactionDef; 
1:     
0:     public Bean(Class<?> clazz) {
0:         this.clazz = clazz;
0:         this.id = getBeanName(clazz);
0:         for (Method method : clazz.getDeclaredMethods()) {
0:             PostConstruct postConstruct = method.getAnnotation(PostConstruct.class);
0:             if (postConstruct != null) {
0:                 this.initMethod = method.getName();
1:             }
0:             PreDestroy preDestroy = method.getAnnotation(PreDestroy.class);
0:             if (preDestroy != null) {
0:                 this.destroyMethod = method.getName();
1:             }
1:         }
0:         this.persistenceUnitField = getPersistenceUnit();
0:         this.transactionDef = new JavaxTransactionFactory().create(clazz);
0:         if (this.transactionDef == null) {
0:             this.transactionDef = new SpringTransactionFactory().create(clazz);
1:         }
0:         properties = new TreeSet<Property>();
1:     }
1: 
0:     private Field getPersistenceUnit() {
0:         Field[] fields = clazz.getDeclaredFields();
0:         for (Field field : fields) {
0:             PersistenceUnit persistenceUnit = field.getAnnotation(PersistenceUnit.class);
0:             if (persistenceUnit !=null) {
0:                  return field;
1:             }
1:         }
0:         return null;
1:     }
1:     
0:     public void resolve(Matcher matcher) {
0:         Class<?> curClass = this.clazz;
0:         while (curClass != Object.class) {
0:             resolveProperties(matcher, curClass);
0:             curClass = curClass.getSuperclass();
1:         }
1:     }
1:     
0:     private void resolveProperties(Matcher matcher, Class<?> curClass) {
0:         for (Field field : curClass.getDeclaredFields()) {
1:             Property prop = Property.create(matcher, field);
1:             if (prop != null) {
1:                 properties.add(prop);
1:             }
1:         }
1:     }
1: 
0:     public static String getBeanName(Class<?> clazz) {
0:         Component component = clazz.getAnnotation(Component.class);
0:         Named named = clazz.getAnnotation(Named.class);
0:         if (component != null && !"".equals(component.value())) {
0:             return component.value();
0:         } else if (named != null && !"".equals(named.value())) {
0:             return named.value();    
0:         } else {
0:             String name = clazz.getSimpleName();
0:             return getBeanNameFromSimpleName(name);
1:         }
1:     }
1: 
0:     private static String getBeanNameFromSimpleName(String name) {
0:         return name.substring(0, 1).toLowerCase() + name.substring(1, name.length());
1:     }
1: 
0:     public boolean matches(Class<?> destType, String destId) {
0:         boolean assignable = destType.isAssignableFrom(this.clazz);
0:         return assignable && ((destId == null) || id.equals(destId));
1:     }
1: 
1:     @Override
0:     public int compareTo(Bean other) {
0:         return this.clazz.getName().compareTo(other.clazz.getName());
1:     }
1: 
1:     @Override
0:     public int hashCode() {
0:         final int prime = 31;
0:         int result = 1;
0:         result = prime * result + ((clazz == null) ? 0 : clazz.getName().hashCode());
0:         result = prime * result + ((id == null) ? 0 : id.hashCode());
0:         return result;
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return clazz.getName();
1:     }
1: 
1:     public void writeProperties(PropertyWriter writer) {
1:         for (Property property : properties) {
1:             writer.writeProperty(property);
1:         }
1:     }
1:     
1: }
author:Dominik Przybysz
-------------------------------------------------------------------------------
commit:fc7ae19
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.blueprint.plugin.model.AnnotationHelper.findName;
/////////////////////////////////////////////////////////////////////////
1:                 fieldAnnotationHandler.handleFieldAnnotation(clazz, fields, contextEnricher, this);
/////////////////////////////////////////////////////////////////////////
commit:a2ed671
/////////////////////////////////////////////////////////////////////////
1:     public void resolve(BlueprintRegister blueprintRegister) {
1:         resolveArguments(blueprintRegister);
1:         resolveFields(blueprintRegister);
1:         resolveMethods(blueprintRegister);
/////////////////////////////////////////////////////////////////////////
1:     private void resolveMethods(BlueprintRegister blueprintRegister) {
1:             Property prop = Property.create(blueprintRegister, method);
1:     private void resolveFields(BlueprintRegister matcher) {
/////////////////////////////////////////////////////////////////////////
1:     protected void resolveArguments(BlueprintRegister matcher) {
/////////////////////////////////////////////////////////////////////////
1:     protected void resolveArguments(BlueprintRegister blueprintRegister, Class[] parameterTypes, Annotation[][] parameterAnnotations) {
/////////////////////////////////////////////////////////////////////////
1:                     String generatedRef = customDependencyAnnotationHandler.handleDependencyAnnotation(parameterTypes[i], annotation, ref, blueprintRegister);
/////////////////////////////////////////////////////////////////////////
1:                 BeanRef bean = blueprintRegister.getMatching(template);
commit:64f241a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.plugin.spi.FieldAnnotationHandler;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         handleFieldsAnnotation(introspector);
0: 
/////////////////////////////////////////////////////////////////////////
1:     private void handleFieldsAnnotation(Introspector introspector) {
1:         for (FieldAnnotationHandler fieldAnnotationHandler : Extensions.fieldAnnotationHandlers) {
1:             List<Field> fields = introspector.fieldsWith(fieldAnnotationHandler.getAnnotation());
1:             if (fields.size() > 0) {
0:                 fieldAnnotationHandler.handleMethodAnnotation(clazz, fields, contextEnricher, this);
0:             }
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:0d2c0ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.plugin.spi.BeanEnricher;
1: import org.apache.aries.blueprint.plugin.spi.ContextEnricher;
1: import org.apache.aries.blueprint.plugin.spi.XmlWriter;
/////////////////////////////////////////////////////////////////////////
1: public class Bean extends BeanRef implements BeanEnricher {
1:     public final Map<String, XmlWriter> beanContentWriters = new HashMap<>();
1:     protected final ContextEnricher contextEnricher;
1:     public Bean(Class<?> clazz, ContextEnricher contextEnricher) {
1:         this.contextEnricher = contextEnricher;
/////////////////////////////////////////////////////////////////////////
0:     public void resolve(BlueprinRegister blueprinRegister) {
0:         resolveArguments(blueprinRegister);
0:         resolveFields(blueprinRegister);
0:         resolveMethods(blueprinRegister);
0:     }
0: 
1:                 methodAnnotationHandler.handleMethodAnnotation(clazz, methods, contextEnricher, this);
/////////////////////////////////////////////////////////////////////////
1:                 beanAnnotationHandler.handleBeanAnnotation(clazz, id, contextEnricher, this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Override
1:     public void addBeanContentWriter(String id, XmlWriter blueprintWriter) {
1:         beanContentWriters.put(id, blueprintWriter);
0:     }
commit:a04c623
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.plugin.spi.BeanEnricher;
1: import org.apache.aries.blueprint.plugin.spi.BeanAnnotationHandler;
1: import org.apache.aries.blueprint.plugin.spi.MethodAnnotationHandler;
/////////////////////////////////////////////////////////////////////////
0: public class Bean extends BeanRef implements ContextEnricher, BeanEnricher {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:         handleMethodsAnnotation(introspector);
1:     private void handleMethodsAnnotation(Introspector introspector) {
1:         for (MethodAnnotationHandler methodAnnotationHandler : Extensions.methodAnnotationHandlers) {
1:             List<Method> methods = introspector.methodsWith(methodAnnotationHandler.getAnnotation());
1:             if (methods.size() > 0) {
0:                 methodAnnotationHandler.handleMethodAnnotation(clazz, methods, this);
1:         for (BeanAnnotationHandler beanAnnotationHandler : Extensions.BEAN_ANNOTATION_HANDLERs) {
1:             Object annotation = AnnotationHelper.findAnnotation(clazz.getAnnotations(), beanAnnotationHandler.getAnnotation());
0:                 beanAnnotationHandler.handleBeanAnnotation(clazz, id, this, this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Override
1:     public void addAttribute(String key, String value) {
1:         attributes.put(key, value);
0:     }
commit:868c96f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.plugin.spi.BlueprintWriter;
0: import org.apache.aries.blueprint.plugin.spi.ContextEnricher;
0: import org.apache.aries.blueprint.plugin.spi.CustomBeanAnnotationHandler;
1: import org.apache.aries.blueprint.plugin.spi.CustomDependencyAnnotationHandler;
0: import org.apache.aries.blueprint.plugin.spi.NamedLikeHandler;
/////////////////////////////////////////////////////////////////////////
0: public class Bean extends BeanRef implements ContextEnricher {
1:     public final Set<BeanRef> refs = new HashSet<>();
0:     public final Map<String, BlueprintWriter> blueprintWriters = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
0: 
1:         handleCustomBeanAnnotations();
/////////////////////////////////////////////////////////////////////////
1:     private void handleCustomBeanAnnotations() {
0:         for (CustomBeanAnnotationHandler customBeanAnnotationHandler : Extensions.customBeanAnnotationHandlers) {
0:             Object annotation = AnnotationHelper.findAnnotation(clazz.getAnnotations(), customBeanAnnotationHandler.getAnnotation());
1:             if (annotation != null) {
0:                 customBeanAnnotationHandler.handleBeanAnnotation(clazz, id, this);
0:             }
/////////////////////////////////////////////////////////////////////////
0:     public void resolve(BlueprinRegister matcher) {
0:     private void resolveMethods(BlueprinRegister blueprinRegister) {
0:             Property prop = Property.create(blueprinRegister, method);
0:     private void resolveFields(BlueprinRegister matcher) {
/////////////////////////////////////////////////////////////////////////
0:     protected void resolveArguments(BlueprinRegister matcher) {
/////////////////////////////////////////////////////////////////////////
0:     protected void resolveArguments(BlueprinRegister blueprinRegister, Class[] parameterTypes, Annotation[][] parameterAnnotations) {
1:             String ref = findName(annotations);
1:             for (CustomDependencyAnnotationHandler customDependencyAnnotationHandler : Extensions.customDependencyAnnotationHandlers) {
1:                 Annotation annotation = (Annotation) AnnotationHelper.findAnnotation(annotations, customDependencyAnnotationHandler.getAnnotation());
1:                 if (annotation != null) {
0:                     String generatedRef = customDependencyAnnotationHandler.handleDependencyAnnotation(parameterTypes[i], annotation, ref, blueprinRegister);
1:                     if (generatedRef != null) {
1:                         ref = generatedRef;
1:                         break;
0:                     }
0:                 }
1:             if (ref == null && value == null) {
0:                 BeanRef bean = blueprinRegister.getMatching(template);
/////////////////////////////////////////////////////////////////////////
0:     private String findName(Annotation[] annotations) {
0:         for (NamedLikeHandler namedLikeHandler : Extensions.namedLikeHandlers) {
0:             Object annotation = AnnotationHelper.findAnnotation(annotations, namedLikeHandler.getAnnotation());
0:             if (annotation != null) {
0:                 String name = namedLikeHandler.getName(annotation);
1:                 if (name != null) {
0:                     return name;
0:                 }
0:             }
0:         }
0:         return null;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Override
0:     public void addBean(String id, Class<?> clazz) {
0:         refs.add(new BeanRef(clazz, id));
0:     }
0: 
0:     @Override
0:     public void addBlueprintWriter(String id, BlueprintWriter blueprintWriter) {
0:         blueprintWriters.put(id, blueprintWriter);
0:     }
commit:c201f83
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.plugin.Extensions;
0: import org.apache.aries.blueprint.plugin.spi.BeanAttributesResolver;
1: import org.apache.aries.blueprint.plugin.spi.InjectLikeHandler;
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
0: import static org.apache.aries.blueprint.plugin.model.AnnotationHelper.findAnnotation;
0: import static org.apache.aries.blueprint.plugin.model.AnnotationHelper.findName;
1: import static org.apache.aries.blueprint.plugin.model.AnnotationHelper.findValue;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public final Map<String, String> attributes = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
0: 
0:         resolveBeanAttributes();
0:     private void resolveBeanAttributes() {
0:         for (BeanAttributesResolver beanAttributesResolver : Extensions.beanAttributesResolvers) {
0:             if (clazz.getAnnotation(beanAttributesResolver.getAnnotation()) != null) {
0:                 attributes.putAll(beanAttributesResolver.resolveAttributes(clazz, clazz));
0:             }
/////////////////////////////////////////////////////////////////////////
0:         for (AbstractTransactionalFactory transactionalFactory : Extensions.transactionalFactories) {
0:             transactionDefs.addAll(transactionalFactory.create(clazz));
0:         }
/////////////////////////////////////////////////////////////////////////
1:         return !findSingleton(clazz);
0:     }
0: 
1:     private boolean findSingleton(Class clazz) {
1:         for (Class<?> singletonAnnotation : Extensions.singletons) {
1:             if (clazz.getAnnotation(singletonAnnotation) != null) {
1:                 return true;
0:             }
0:         }
1:         return false;
0:         resolveFields(matcher);
1:         for (Method method : new Introspector(clazz).methodsWith(AnnotationHelper.injectDependencyAnnotations)) {
/////////////////////////////////////////////////////////////////////////
0:     private void resolveFields(Matcher matcher) {
1:         for (Field field : new Introspector(clazz).fieldsWith(AnnotationHelper.injectDependencyAnnotations)) {
/////////////////////////////////////////////////////////////////////////
1:             if (declaredConstructors.length == 1 || shouldInject(constructor)) {
1:     private boolean shouldInject(AnnotatedElement annotatedElement) {
1:         for (InjectLikeHandler injectLikeHandler : Extensions.beanInjectLikeHandlers) {
1:             if (annotatedElement.getAnnotation(injectLikeHandler.getAnnotation()) != null) {
1:                 return true;
0:             }
0:         }
1:         return false;
0:     }
0: 
1:             String value = findValue(annotations);
0: 
1:                 String name = findName(annotations);
0:                 ref = name != null ? name : getBeanNameFromSimpleName(parameterTypes[i].getSimpleName());
/////////////////////////////////////////////////////////////////////////
0:                     String name = findName(annotations);
0:                     if (name != null) {
1:                         ref = name;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0eb5481
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.StringUtils;
0: import org.springframework.context.annotation.DependsOn;
/////////////////////////////////////////////////////////////////////////
0:     public String dependsOn;
0:         dependsOn = getDependsOn(clazz);
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected String getDependsOn(AnnotatedElement annotatedElement) {
0:         DependsOn annotation = annotatedElement.getAnnotation(DependsOn.class);
0:         if (annotation == null || annotation.value().length == 0) {
0:             return null;
0:         }
0:         String[] value = annotation.value();
0:         return StringUtils.join(value, " ");
0:     }
0: 
commit:7583a4c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.plugin.Activation;
0: import org.springframework.context.annotation.Lazy;
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.AnnotatedElement;
/////////////////////////////////////////////////////////////////////////
0:     public Activation activation;
0:         activation = getActivation(clazz);
/////////////////////////////////////////////////////////////////////////
0:     protected Activation getActivation(AnnotatedElement annotatedElement) {
0:         Lazy lazy = annotatedElement.getAnnotation(Lazy.class);
0:         if (lazy == null) {
0:             return null;
0:         }
0:         return lazy.value() ? Activation.LAZY : Activation.EAGER;
0:     }
0: 
commit:9632b7d
/////////////////////////////////////////////////////////////////////////
1:     public boolean needFieldInjection() {
1:         for (Property property : properties) {
1:             if (property.isField) {
1:                 return true;
0:             }
0:         }
1:         return false;
0:     }
commit:4f3e047
/////////////////////////////////////////////////////////////////////////
0:     public final String initMethod;
/////////////////////////////////////////////////////////////////////////
0:         initMethod = findMethodAnnotatedWith(introspector, PostConstruct.class);
0:         destroyMethod = findMethodAnnotatedWith(introspector, PreDestroy.class);
0:         interpretTransactionalMethods(clazz);
0:         this.persistenceFields = findPersistenceFields(introspector);
0: 
0:         interpretServiceProvider();
0:     }
0: 
0:     private void interpretServiceProvider() {
0:         if (serviceProvider != null) {
0:     private List<Field> findPersistenceFields(Introspector introspector) {
0:         return introspector.fieldsWith(PersistenceContext.class, PersistenceUnit.class);
0:     }
0: 
0:     private void interpretTransactionalMethods(Class<?> clazz) {
0:         transactionDefs.addAll(new JavaxTransactionFactory().create(clazz));
0:         transactionDefs.addAll(new SpringTransactionFactory().create(clazz));
0:     }
0: 
0:     private String findMethodAnnotatedWith(Introspector introspector, Class<? extends Annotation> annotation) {
0:         Method initMethod = introspector.methodWith(annotation);
0:         if (initMethod == null) {
0:             return null;
0:         }
0:         return initMethod.getName();
0:     }
0: 
0:         resolveFiields(matcher);
0:         resolveMethods(matcher);
0:     }
0: 
0:     private void resolveMethods(Matcher matcher) {
0:         for (Method method : new Introspector(clazz).methodsWith(Value.class, Autowired.class, Inject.class)) {
0:             Property prop = Property.create(matcher, method);
0:     }
0: 
0:     private void resolveFiields(Matcher matcher) {
0:         for (Field field : new Introspector(clazz).fieldsWith(Value.class, Autowired.class, Inject.class)) {
0:             Property prop = Property.create(matcher, field);
commit:d22e134
/////////////////////////////////////////////////////////////////////////
0:         for (Method method : new Introspector(clazz).methodsWith(Value.class, Autowired.class, Inject.class)) {
0:             Property prop = Property.create(matcher, method);
1:             if (prop != null) {
1:                 properties.add(prop);
0:             }
0:         }
commit:3d350f5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.plugin.model.service.ServiceProvider;
/////////////////////////////////////////////////////////////////////////
0:     public List<ServiceProvider> serviceProviders = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0: 
0:         ServiceProvider serviceProvider = ServiceProvider.fromBean(this);
0:         if(serviceProvider != null){
0:             serviceProviders.add(serviceProvider);
0:         }
author:asf-sync-process
-------------------------------------------------------------------------------
commit:d1eab6d
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Preconditions;
0: import com.google.common.collect.Iterables;
0: 
/////////////////////////////////////////////////////////////////////////
0:         // Init method
0:         Method initMethod = getMethodWithAnnotation(clazz, PostConstruct.class);
0:         if (initMethod != null) {
0:             this.initMethod = initMethod.getName();
0:         }
0: 
0:         // Destroy method
0:         Method destroyMethod = getMethodWithAnnotation(clazz, PreDestroy.class);
0:         if (destroyMethod != null) {
0:             this.destroyMethod = destroyMethod.getName();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static <T extends Annotation> Method getMethodWithAnnotation(Class<?> classToSearch,
0:                                                                          Class<T> annotationClass) {
0:         List<Method> methods = getMethodsWithAnnotation(classToSearch, annotationClass);
0:         Preconditions.checkArgument(methods.size() <= 1,
0:                                     "Found %d methods annotated with %s in class %s, but only 1 allowed",
0:                                     methods.size(), annotationClass.getName(), classToSearch.getName());
0:         return Iterables.getOnlyElement(methods, null);
0:     private static <T extends Annotation> List<Method> getMethodsWithAnnotation(Class<?> classToSearch,
0:                                                                                 Class<T> annotationClass) {
0:         List<Method> methods = new ArrayList<>();
0:         for (Method method : classToSearch.getMethods()) {
0:             T annotation = method.getAnnotation(annotationClass);
0:             if (annotation != null) {
0:                 methods.add(method);
0:             }
0:         return methods;
/////////////////////////////////////////////////////////////////////////
0: 
============================================================================