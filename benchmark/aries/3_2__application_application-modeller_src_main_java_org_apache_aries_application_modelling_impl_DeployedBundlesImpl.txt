1:4fec049: /*
1:4fec049:  * Licensed to the Apache Software Foundation (ASF) under one
1:4fec049:  * or more contributor license agreements.  See the NOTICE file
1:4fec049:  * distributed with this work for additional information
1:4fec049:  * regarding copyright ownership.  The ASF licenses this file
1:4fec049:  * to you under the Apache License, Version 2.0 (the
1:4fec049:  * "License"); you may not use this file except in compliance
1:4fec049:  * with the License.  You may obtain a copy of the License at
1:4fec049:  *
1:4fec049:  *   http://www.apache.org/licenses/LICENSE-2.0
1:4fec049:  *
1:4fec049:  * Unless required by applicable law or agreed to in writing,
1:4fec049:  * software distributed under the License is distributed on an
1:4fec049:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:4fec049:  * KIND, either express or implied.  See the License for the
1:4fec049:  * specific language governing permissions and limitations
1:4fec049:  * under the License.
1:4fec049:  */
1:58f55bd: package org.apache.aries.application.modelling.impl;
12:4fec049: 
1:4fec049: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1:4fec049: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1:4fec049: 
1:4fec049: import java.util.ArrayList;
1:4fec049: import java.util.Arrays;
1:4fec049: import java.util.Collection;
1:4fec049: import java.util.Collections;
1:4fec049: import java.util.HashMap;
1:4fec049: import java.util.HashSet;
1:4fec049: import java.util.Iterator;
1:4fec049: import java.util.List;
1:4fec049: import java.util.Map;
1:4fec049: import java.util.Set;
1:4fec049: 
1:4fec049: import org.apache.aries.application.management.ResolverException;
1:58f55bd: import org.apache.aries.application.modelling.DeployedBundles;
1:4fec049: import org.apache.aries.application.modelling.DeploymentMFElement;
1:4fec049: import org.apache.aries.application.modelling.ExportedBundle;
1:4fec049: import org.apache.aries.application.modelling.ExportedPackage;
1:4fec049: import org.apache.aries.application.modelling.ExportedService;
1:4fec049: import org.apache.aries.application.modelling.ImportedBundle;
1:4fec049: import org.apache.aries.application.modelling.ImportedPackage;
1:4fec049: import org.apache.aries.application.modelling.ImportedService;
1:4fec049: import org.apache.aries.application.modelling.ModelledResource;
1:4fec049: import org.apache.aries.application.modelling.internal.MessageUtil;
1:4fec049: import org.apache.aries.application.modelling.internal.PackageRequirementMerger;
1:4fec049: import org.apache.aries.application.utils.AppConstants;
1:4fec049: import org.osgi.framework.Constants;
1:4fec049: import org.slf4j.Logger;
1:4fec049: import org.slf4j.LoggerFactory;
1:4fec049: /**
1:4fec049:  * Class to generate DEPLOYMENT.MF manifest entries for resolved bundles based on
1:4fec049:  * corresponding APPLICATION.MF entries.
1:4fec049:  */
1:58f55bd: public final class DeployedBundlesImpl implements DeployedBundles
3:4fec049: {
1:58f55bd:   private final Logger logger = LoggerFactory.getLogger(DeployedBundlesImpl.class);
1:4fec049:   private final String assetName;
1:fb74280:   
1:fb74280:   private String cachedImportPackage;
1:fb74280:   private Collection<ModelledResource> cachedRequiredUseBundle;
1:fb74280:   private Collection<ImportedPackage> cachedExternalRequirements;
1:fb74280:   private String cachedDeployedImportService;
1:4fec049: 
1:4fec049:   /** Content from APPLICATION.MF */
1:4fec049:   private final Set<ImportedBundle> appContent = new HashSet<ImportedBundle>();
1:4fec049:   /** Use Bundle from APPLICATION.MF */
1:4fec049:   private final Set<ImportedBundle> appUseBundle = new HashSet<ImportedBundle>();
1:4fec049:   /** Content for deployment.mf deployed-content. */
1:4fec049:   private final Set<ModelledResource> deployedContent = new HashSet<ModelledResource>();
1:4fec049:   /** Content for deployment.mf use-bundle. */
1:4fec049:   private final Set<ModelledResource> deployedUseBundle = new HashSet<ModelledResource>();
1:4fec049:   /** Content for deployment.mf provision-bundle. */
1:4fec049:   private final Set<ModelledResource> deployedProvisionBundle = new HashSet<ModelledResource>();
1:4fec049:   /** Content for deployment.mf DeployedImport-Service. */
1:4fec049:   private final Collection<ImportedService> deployedImportService = new HashSet<ImportedService>(); 
1:4fec049:   private final Collection<ModelledResource> fakeDeployedBundles = new HashSet<ModelledResource>();
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Constructor for cases when we have one or more '
1:4fec049:    * @param assetName         the name of the asset being deployed.
1:4fec049:    * @param appContentNames   the bundle names specified in Deployed-Content.
1:4fec049:    * @param appUseBundleNames the bundle names specified in Deployed-Use-Bundle.
1:4fec049:    * @param fakeServiceProvidingBundles  bundles that we're pretending are part of the deployed content. Can be null. 
1:4fec049:    *                                     These bundles are proxies for bundles provided (for example by SCA) that export
1:4fec049:    *                                     services matching Application-ImportService. 
1:4fec049:    */
1:58f55bd:   public DeployedBundlesImpl(String assetName, Collection<ImportedBundle> appContentNames, 
1:4fec049:       Collection<ImportedBundle> appUseBundleNames, Collection<ModelledResource> fakeServiceProvidingBundles)
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "DeployedBundles", new Object[]{appContentNames, appUseBundleNames, fakeServiceProvidingBundles});
1:4fec049:     
1:4fec049:     this.assetName = assetName;
1:4fec049: 
1:4fec049:     appContent.addAll(appContentNames);
1:4fec049:     appUseBundle.addAll(appUseBundleNames);
1:4fec049:     if (fakeServiceProvidingBundles != null) { 
1:4fec049:       fakeDeployedBundles.addAll(fakeServiceProvidingBundles);
7:4fec049:     }
1:4fec049:     logger.debug(LOG_EXIT, "DeployedBundles");
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Add provisioned version information for a specific bundle name. This will be added to the
1:4fec049:    * appropriate manifest header for the specified bundle.
1:4fec049:    * @param resolvedBundle the bundle that has been provisioned.
1:4fec049:    * @param resolvedVersion the specific version provisioned.
1:4fec049:    */
1:4fec049:   public void addBundle(ModelledResource modelledBundle)
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "addBundle", new Object[]{modelledBundle});
1:4fec049:     // Identify the deployment.mf entries the bundle should be added to by matching
1:4fec049:     // both the bundle name and resolved version against the name and version range
1:4fec049:     // defined in application.mf.
1:4fec049:     
1:4fec049:     ExportedBundle resolvedBundle = modelledBundle.getExportedBundle();
1:4fec049:     
1:4fec049:     if (isBundleMatch(appContent, resolvedBundle))
1:4fec049:     {
1:4fec049:       logger.debug("Added to " + AppConstants.DEPLOYMENT_CONTENT + ": " + resolvedBundle);
1:4fec049:      
1:4fec049:       deployedContent.add(modelledBundle);
1:4fec049:       
1:4fec049:       // Add any service dependencies to the list
1:4fec049:       deployedImportService.addAll(modelledBundle.getImportedServices());
1:4fec049:     }
1:4fec049:     else if (isBundleMatch(appUseBundle, resolvedBundle))
1:4fec049:     {
1:4fec049:       logger.debug("Added to " + AppConstants.DEPLOYMENT_USE_BUNDLE + ": " + resolvedBundle);
1:4fec049:       deployedUseBundle.add(modelledBundle);
1:4fec049:     } else
1:4fec049:     {
1:4fec049:       logger.debug("Added to " + AppConstants.DEPLOYMENT_PROVISION_BUNDLE + ": " + resolvedBundle);
1:4fec049:       deployedProvisionBundle.add(modelledBundle);
1:4fec049:     }
1:fb74280:     
1:fb74280:     // Invalidate caches
1:fb74280:     cachedImportPackage = null;
1:fb74280:     cachedRequiredUseBundle = null;
1:fb74280:     cachedDeployedImportService = null;
1:fb74280:     cachedExternalRequirements = null;
1:fb74280:     
1:4fec049:    logger.debug(LOG_EXIT, "addBundle");    
1:4fec049:   }
1:4fec049: 
1:4fec049:   /**
1:4fec049:    * Check if a match is found between the supplied map of application bundle name/version information,
1:4fec049:    * and the supplied bundle name and version.
1:4fec049:    * @param imports Imported bundles
1:4fec049:    * @param potentialMatch the exported bundle or composite we're interested in
1:4fec049:    * @return true if a match is found; otherwise false.
1:4fec049:    */
1:4fec049:   private boolean isBundleMatch(Set<ImportedBundle> imports, ExportedBundle potentialMatch)
1:4fec049:   {
1:4fec049:     boolean result = false;
1:4fec049:     
1:4fec049:     for (ImportedBundle ib : imports)
1:4fec049:     {
1:4fec049:       if (ib.isSatisfied(potentialMatch))
1:4fec049:       {
1:4fec049:         result = true;
1:4fec049:         break;
1:4fec049:       }
1:4fec049:     }
1:4fec049:   
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the value corresponding to the Deployed-Content header in the deployment.mf.
1:4fec049:    * @return a manifest entry, or an empty string if there is no content.
1:4fec049:    */
1:4fec049:   public String getContent()
1:4fec049:   {
1:4fec049:     return createManifestString(deployedContent);
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the value corresponding to the Deployed-Use-Bundle header in the deployment.mf.
1:4fec049:    * @return a manifest entry, or an empty string if there is no content.
1:4fec049:    */
1:4fec049:   public String getUseBundle()
1:4fec049:   {
1:4fec049:     return createManifestString(deployedUseBundle);
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the value corresponding to the Provision-Bundle header in the deployment.mf.
1:4fec049:    * @return a manifest entry, or an empty string if there is no content.
1:4fec049:    */
1:4fec049:   public String getProvisionBundle()
1:4fec049:   {
1:4fec049:     return createManifestString(deployedProvisionBundle);
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the value corresponding to the Import-Package header in the deployment.mf. 
1:4fec049:    * @return a manifest entry, or an empty string if there is no content.
1:4fec049:    * @throws ResolverException if the requirements could not be resolved.
1:4fec049:    */
1:58f55bd:   public String getImportPackage() throws ResolverException
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "getImportPackage");
1:4fec049:     
1:fb74280:     String result = cachedImportPackage; 
1:fb74280:     if (result == null)
1:4fec049:     {
1:fb74280:       
1:fb74280:       Collection<ImportedPackage> externalReqs = new ArrayList<ImportedPackage>(getExternalPackageRequirements());
1:fb74280:   
1:fb74280:       //Validate that we don't have attributes that will break until RFC138 is used
1:fb74280:       validateOtherImports(externalReqs);
1:fb74280:       
1:fb74280:       // Find the matching capabilities from bundles in use bundle, and prune
1:fb74280:       // matched requirements out of the external requirements collection.
1:fb74280:       Map<ImportedPackage,ExportedPackage> useBundlePkgs = new HashMap<ImportedPackage,ExportedPackage>();
1:fb74280:       for (Iterator<ImportedPackage> iter = externalReqs.iterator(); iter.hasNext(); )
1:4fec049:       {
1:fb74280:         ImportedPackage req = iter.next();
1:fb74280:         ExportedPackage match = getPackageMatch(req, deployedUseBundle);
1:fb74280:         if (match != null)
1:fb74280:         {
1:fb74280:           useBundlePkgs.put(req, match);
1:fb74280:           iter.remove();
1:fb74280:         }
1:4fec049:       }
1:fb74280:       
1:fb74280:       StringBuilder useBundleImports = new StringBuilder();
1:fb74280:       for(Map.Entry<ImportedPackage, ExportedPackage> entry : useBundlePkgs.entrySet()) {
1:fb74280:         useBundleImports.append(entry.getValue().toDeploymentString());
1:fb74280:         ImportedPackage key = entry.getKey();
1:fb74280:         if(key.isOptional())
1:fb74280:           useBundleImports.append(";" + Constants.RESOLUTION_DIRECTIVE +":=" + Constants.RESOLUTION_OPTIONAL);
1:fb74280:         useBundleImports.append(",");
1:fb74280:       }
1:fb74280:       
1:fb74280:       result = useBundleImports.toString() + createManifestString(externalReqs);
1:fb74280:       
1:fb74280:       if(result.endsWith(","))
1:fb74280:         result = result.substring(0, result.length() - 1);
1:fb74280:       
1:fb74280:       cachedImportPackage = result;
1:4fec049:     }
1:4fec049:     
1:4fec049:     logger.debug(LOG_EXIT, "getImportPackage", result);
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the Deployed-ImportService header. 
1:4fec049:    * this.deployedImportService contains all the service import filters for every 
1:4fec049:    * blueprint component within the application. We will only write an entry
1:4fec049:    * to Deployed-ImportService if
1:4fec049:    *   a) the reference isMultiple(), or
1:4fec049:    *   b) the service was not available internally when the app was first deployed
1:4fec049:    *   
1:4fec049:    */
1:4fec049:   public String getDeployedImportService() { 
1:4fec049:     logger.debug(LOG_ENTRY,"getDeployedImportService");
1:fb74280:     
1:fb74280:     String result = cachedDeployedImportService;
1:fb74280:     if (result == null)
1:fb74280:     {
1:fb74280:       Collection<ImportedService> deployedBundleServiceImports = new ArrayList<ImportedService>();
1:fb74280:       Collection<ExportedService> servicesExportedWithinIsolatedContent = new ArrayList<ExportedService>();
1:fb74280:       for (ModelledResource mRes : getDeployedContent()) { 
1:fb74280:         servicesExportedWithinIsolatedContent.addAll(mRes.getExportedServices());
1:fb74280:       }
1:fb74280:       for (ModelledResource mRes : fakeDeployedBundles) { 
1:fb74280:         servicesExportedWithinIsolatedContent.addAll(mRes.getExportedServices());
1:fb74280:       }
1:fb74280:       for (ImportedService impService : deployedImportService) { 
1:fb74280:         if (impService.isMultiple()) { 
2:4fec049:           deployedBundleServiceImports.add(impService);
1:fb74280:         } else { 
1:fb74280:           boolean serviceProvidedWithinIsolatedContent = false;
1:fb74280:           Iterator<ExportedService> it = servicesExportedWithinIsolatedContent.iterator();
1:fb74280:           while (!serviceProvidedWithinIsolatedContent && it.hasNext()) { 
1:fb74280:             ExportedService svc = it.next(); 
1:fb74280:             serviceProvidedWithinIsolatedContent |= impService.isSatisfied(svc);
1:fb74280:           }
1:fb74280:           if (!serviceProvidedWithinIsolatedContent) { 
1:fb74280:             deployedBundleServiceImports.add(impService);
1:fb74280:           }
1:4fec049:         }
1:4fec049:       }
1:fb74280:       
1:fb74280:       result = createManifestString(deployedBundleServiceImports);
1:fb74280:       cachedDeployedImportService = result;
1:4fec049:     }
1:4fec049:     logger.debug(LOG_EXIT,"getDeployedImportService", result);
1:4fec049:     
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   /**
1:4fec049:    * Get all the requirements of bundles in deployed content that are not satisfied
1:4fec049:    * by other bundles in deployed content.
1:4fec049:    * @return a collection of package requirements.
1:4fec049:    * @throws ResolverException if the requirements could not be resolved.
1:4fec049:    */
1:4fec049:   private Collection<ImportedPackage> getExternalPackageRequirements()
3:4fec049:     throws ResolverException
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY,"getExternalPackageRequirements");
1:4fec049:     
1:fb74280:     Collection<ImportedPackage> result = cachedExternalRequirements;
1:fb74280:     if (result == null)
1:4fec049:     {
1:fb74280:       // Get all the internal requirements.
1:fb74280:       Collection<ImportedPackage> requirements = new ArrayList<ImportedPackage>();
1:fb74280:       Collection<ExportedPackage> internalExports = new ArrayList<ExportedPackage>();
1:fb74280:       for (ModelledResource bundle : deployedContent)
1:4fec049:       {
1:fb74280:         requirements.addAll(bundle.getImportedPackages());
1:fb74280:         internalExports.addAll(bundle.getExportedPackages());
1:4fec049:       }
1:fb74280:           
1:fb74280:       // Filter out requirements satisfied by internal capabilities.
1:fb74280:       result = new ArrayList<ImportedPackage>();
1:fb74280:       for (ImportedPackage req : requirements)
1:4fec049:       {
1:fb74280:         boolean satisfied = false;
1:fb74280:         for (ExportedPackage export : internalExports)
1:fb74280:         {
1:fb74280:           if (req.isSatisfied(export))
1:fb74280:           {
1:fb74280:             satisfied = true;
1:fb74280:             break;
1:fb74280:           }
1:fb74280:         }
1:fb74280:         //If we didn't find a match then it must come from outside
1:fb74280:         if (!satisfied)
1:fb74280:           result.add(req);
1:4fec049:       }
1:4fec049:       
1:fb74280:       PackageRequirementMerger merger = new PackageRequirementMerger(result);
1:fb74280:       if (!merger.isMergeSuccessful())
1:fb74280:       {
1:fb74280:         List<String> pkgNames = new ArrayList<String>(merger.getInvalidRequirements());
1:fb74280:         
1:fb74280:         StringBuilder buff = new StringBuilder();
1:fb74280:         for (String pkgName : merger.getInvalidRequirements())
1:fb74280:         {
1:fb74280:           buff.append(pkgName).append(", ");
1:fb74280:         }
1:fb74280:   
1:fb74280:         int buffLen = buff.length();
1:fb74280:         String pkgString = (buffLen > 0 ? buff.substring(0, buffLen - 2) : "");
1:fb74280:   
1:fb74280:         ResolverException re = new ResolverException(MessageUtil.getMessage(
1:fb74280:             "INCOMPATIBLE_PACKAGE_VERSION_REQUIREMENTS", new Object[] { assetName, pkgString }));
1:fb74280:         re.setUnsatisfiedRequirements(pkgNames);
1:fb74280:         logger.debug(LOG_EXIT,"getExternalPackageRequirements", re);
1:fb74280:         
1:fb74280:         throw re;
1:fb74280:       }
1:fb74280:       
1:fb74280:       result = merger.getMergedRequirements();
1:fb74280:       cachedExternalRequirements = result;
1:4fec049:     }
1:4fec049:     logger.debug(LOG_EXIT,"getExternalPackageRequirements", result);
1:4fec049:     
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Create entries for the Import-Package header corresponding to the supplied
1:4fec049:    * packages, referring to bundles not in Use-Bundle.
1:4fec049:    * @param requirements packages for which entries should be created.
1:4fec049:    * @return manifest header entries.
1:4fec049:    * @throws ResolverException if the imports are invalid.
1:4fec049:    */
1:4fec049:   private void validateOtherImports(Collection<ImportedPackage> requirements)
1:4fec049:     throws ResolverException
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "validateOtherImports", requirements);
2:4fec049:     for (ImportedPackage req : requirements)
1:4fec049:     {
1:4fec049:       String pkgName = req.getPackageName();
1:4fec049: 
1:4fec049:       for (String name : req.getAttributes().keySet())
1:4fec049:       {
1:4fec049:         if (Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE.equals(name)
1:4fec049:             || Constants.BUNDLE_VERSION_ATTRIBUTE.equals(name))
1:4fec049:         {
2:4fec049:           ResolverException re = new ResolverException(MessageUtil.getMessage(
1:4fec049:               "INVALID_PACKAGE_REQUIREMENT_ATTRIBUTES", new Object[] { assetName, name, pkgName }));
1:4fec049:           re.setUnsatisfiedRequirements(Arrays.asList(pkgName));
1:4fec049:           logger.debug(LOG_EXIT, "validateOtherImports", re);
2:4fec049:           throw re;
1:4fec049:         }
1:4fec049:       }
1:4fec049:     }
1:4fec049:     logger.debug(LOG_EXIT, "validateOtherImports");
1:4fec049:   }
1:4fec049: 
1:4fec049:   /**
1:4fec049:    * Get a package match between the specified requirement and a capability of the supplied
1:4fec049:    * bundles. The resulting match object might not refer to any matching capability.
1:4fec049:    * @param requirement the {@link ImportedPackageImpl} to be matched.
1:4fec049:    * @param bundles the bundles to be searched for matching capabilities.
1:4fec049:    * @return an ExportedPackageImpl or null if no match is found.
1:4fec049:    */
1:4fec049:   private ExportedPackage getPackageMatch(ImportedPackage requirement, Collection<ModelledResource> bundles)
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "getPackageMatch", new Object[]{requirement, bundles});
1:4fec049:     ExportedPackage result = null;
1:4fec049:     
1:4fec049:     outer: for (ModelledResource bundle : bundles)
1:4fec049:     {
1:4fec049:       for (ExportedPackage pkg : bundle.getExportedPackages())
1:4fec049:       {
1:4fec049:         if(requirement.isSatisfied(pkg)) {
1:4fec049:           result = pkg;
1:4fec049:           break outer;
1:4fec049:         }
1:4fec049:       }
1:4fec049:     }
1:4fec049:     logger.debug(LOG_EXIT, "getPackageMatch", new Object[]{result});
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   
1:4fec049:   private String createManifestString(Collection<? extends DeploymentMFElement> values)
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "createManifestString", new Object[]{values});
1:4fec049:     StringBuilder builder = new StringBuilder();
1:4fec049:     for (DeploymentMFElement value : values)
1:4fec049:     {
1:4fec049:       builder.append(value.toDeploymentString()).append(",");
1:4fec049:     }
1:4fec049:     
1:4fec049:     int length = builder.length();
1:4fec049:     String result = (length > 0 ? builder.substring(0, length - 1) : "");
1:4fec049:     logger.debug(LOG_EXIT, "createManifestString", new Object[]{result});
1:4fec049:     return result;
1:4fec049:   }
1:4fec049:   
1:4fec049: 
1:6fe82e7:   @Override
1:4fec049:   public String toString()
1:4fec049:   {
1:4fec049:     return AppConstants.DEPLOYMENT_CONTENT + '=' + deployedContent + ' ' +
1:4fec049:         AppConstants.DEPLOYMENT_USE_BUNDLE + '=' + deployedUseBundle + ' ' +
1:a1f07b5:         AppConstants.DEPLOYMENT_PROVISION_BUNDLE + '=' + deployedProvisionBundle;
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the set of bundles that are going to be deployed into an isolated framework
1:4fec049:    * @return a set of bundle metadata
1:4fec049:    */
1:4fec049:   public Collection<ModelledResource> getDeployedContent()
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "getDeployedContent");
1:4fec049:     logger.debug(LOG_EXIT,"getDeployedContent", deployedContent);
1:4fec049:     return Collections.unmodifiableCollection(deployedContent);
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the set of bundles that map to Provision-Bundle: these plus 
1:4fec049:    * getRequiredUseBundle combined give the bundles that will be provisioned
1:4fec049:    * into the shared bundle space
1:4fec049:    * 'getProvisionBundle' returns the manifest header string, so this method 
1:4fec049:    * needs to be called something else. 
1:4fec049:    *
1:4fec049:    */
1:4fec049:   public Collection<ModelledResource> getDeployedProvisionBundle () 
1:4fec049:   { 
1:4fec049:     logger.debug(LOG_ENTRY,"getDeployedProvisionBundle");
1:4fec049:     logger.debug(LOG_EXIT, "getDeployedProvisionBundle", deployedContent);
1:4fec049:     return Collections.unmodifiableCollection(deployedProvisionBundle);
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Get the subset of bundles specified in use-bundle that are actually required to
1:4fec049:    * satisfy direct requirements of deployed content.
1:4fec049:    * @return a set of bundle metadata.
1:4fec049:    * @throws ResolverException if the requirements could not be resolved.
1:4fec049:    */
1:58f55bd:   public Collection<ModelledResource> getRequiredUseBundle() throws ResolverException
1:4fec049:   {
1:4fec049:     logger.debug(LOG_ENTRY, "getRequiredUseBundle");
1:fb74280:     
1:fb74280:     Collection<ModelledResource> usedUseBundles =  cachedRequiredUseBundle;
1:fb74280:     if (usedUseBundles == null)
1:4fec049:     {
1:fb74280:       Collection<ImportedPackage> externalReqs = getExternalPackageRequirements();
1:fb74280:       usedUseBundles = new HashSet<ModelledResource>();
1:fb74280:       for (ImportedPackage req : externalReqs)
1:4fec049:       {
1:fb74280:         // Find a match from the supplied bundle capabilities.
1:fb74280:         ExportedPackage match = getPackageMatch(req, deployedUseBundle);
1:fb74280:         if (match != null)
1:fb74280:         {
1:fb74280:             usedUseBundles.add(match.getBundle());
1:fb74280:         }
1:4fec049:       }
1:fb74280:       cachedRequiredUseBundle = usedUseBundles;
1:4fec049:     }
1:fb74280:     
1:4fec049:     logger.debug(LOG_EXIT, "getRequiredUseBundle", usedUseBundles);
1:4fec049:     return usedUseBundles;
1:4fec049:   }
1:6fe82e7: 
1:6fe82e7:   /** This method will be overridden by a PostResolveTransformer returning an extended version of
1:6fe82e7:    * DeployedBundles 
1:6fe82e7:    */
1:6fe82e7:   public Map<String, String> getExtraHeaders() {
1:6fe82e7:     logger.debug (LOG_ENTRY, "getExtraHeaders");
1:6fe82e7:     Map<String, String> result = Collections.emptyMap();
1:6fe82e7:     logger.debug (LOG_EXIT, "getExtraHeaders", result);
1:6fe82e7:     return result;
1:6fe82e7:   }
1:4fec049: }
============================================================================
author:Chris Wilkinson
-------------------------------------------------------------------------------
commit:fb74280
/////////////////////////////////////////////////////////////////////////
1:   
1:   private String cachedImportPackage;
1:   private Collection<ModelledResource> cachedRequiredUseBundle;
1:   private Collection<ImportedPackage> cachedExternalRequirements;
1:   private String cachedDeployedImportService;
/////////////////////////////////////////////////////////////////////////
1:     
1:     // Invalidate caches
1:     cachedImportPackage = null;
1:     cachedRequiredUseBundle = null;
1:     cachedDeployedImportService = null;
1:     cachedExternalRequirements = null;
1:     
/////////////////////////////////////////////////////////////////////////
1:     String result = cachedImportPackage; 
1:     if (result == null)
1:       
1:       Collection<ImportedPackage> externalReqs = new ArrayList<ImportedPackage>(getExternalPackageRequirements());
1:   
1:       //Validate that we don't have attributes that will break until RFC138 is used
1:       validateOtherImports(externalReqs);
1:       
1:       // Find the matching capabilities from bundles in use bundle, and prune
1:       // matched requirements out of the external requirements collection.
1:       Map<ImportedPackage,ExportedPackage> useBundlePkgs = new HashMap<ImportedPackage,ExportedPackage>();
1:       for (Iterator<ImportedPackage> iter = externalReqs.iterator(); iter.hasNext(); )
1:         ImportedPackage req = iter.next();
1:         ExportedPackage match = getPackageMatch(req, deployedUseBundle);
1:         if (match != null)
1:         {
1:           useBundlePkgs.put(req, match);
1:           iter.remove();
1:         }
1:       
1:       StringBuilder useBundleImports = new StringBuilder();
1:       for(Map.Entry<ImportedPackage, ExportedPackage> entry : useBundlePkgs.entrySet()) {
1:         useBundleImports.append(entry.getValue().toDeploymentString());
1:         ImportedPackage key = entry.getKey();
1:         if(key.isOptional())
1:           useBundleImports.append(";" + Constants.RESOLUTION_DIRECTIVE +":=" + Constants.RESOLUTION_OPTIONAL);
1:         useBundleImports.append(",");
1:       }
1:       
1:       result = useBundleImports.toString() + createManifestString(externalReqs);
1:       
1:       if(result.endsWith(","))
1:         result = result.substring(0, result.length() - 1);
1:       
1:       cachedImportPackage = result;
/////////////////////////////////////////////////////////////////////////
1:     
1:     String result = cachedDeployedImportService;
1:     if (result == null)
1:     {
1:       Collection<ImportedService> deployedBundleServiceImports = new ArrayList<ImportedService>();
1:       Collection<ExportedService> servicesExportedWithinIsolatedContent = new ArrayList<ExportedService>();
1:       for (ModelledResource mRes : getDeployedContent()) { 
1:         servicesExportedWithinIsolatedContent.addAll(mRes.getExportedServices());
1:       }
1:       for (ModelledResource mRes : fakeDeployedBundles) { 
1:         servicesExportedWithinIsolatedContent.addAll(mRes.getExportedServices());
1:       }
1:       for (ImportedService impService : deployedImportService) { 
1:         if (impService.isMultiple()) { 
1:         } else { 
1:           boolean serviceProvidedWithinIsolatedContent = false;
1:           Iterator<ExportedService> it = servicesExportedWithinIsolatedContent.iterator();
1:           while (!serviceProvidedWithinIsolatedContent && it.hasNext()) { 
1:             ExportedService svc = it.next(); 
1:             serviceProvidedWithinIsolatedContent |= impService.isSatisfied(svc);
1:           }
1:           if (!serviceProvidedWithinIsolatedContent) { 
1:             deployedBundleServiceImports.add(impService);
1:           }
1:       
1:       result = createManifestString(deployedBundleServiceImports);
1:       cachedDeployedImportService = result;
/////////////////////////////////////////////////////////////////////////
1:     Collection<ImportedPackage> result = cachedExternalRequirements;
1:     if (result == null)
1:       // Get all the internal requirements.
1:       Collection<ImportedPackage> requirements = new ArrayList<ImportedPackage>();
1:       Collection<ExportedPackage> internalExports = new ArrayList<ExportedPackage>();
1:       for (ModelledResource bundle : deployedContent)
1:         requirements.addAll(bundle.getImportedPackages());
1:         internalExports.addAll(bundle.getExportedPackages());
1:           
1:       // Filter out requirements satisfied by internal capabilities.
1:       result = new ArrayList<ImportedPackage>();
1:       for (ImportedPackage req : requirements)
1:         boolean satisfied = false;
1:         for (ExportedPackage export : internalExports)
1:         {
1:           if (req.isSatisfied(export))
1:           {
1:             satisfied = true;
1:             break;
1:           }
1:         }
1:         //If we didn't find a match then it must come from outside
1:         if (!satisfied)
1:           result.add(req);
1:       PackageRequirementMerger merger = new PackageRequirementMerger(result);
1:       if (!merger.isMergeSuccessful())
1:       {
1:         List<String> pkgNames = new ArrayList<String>(merger.getInvalidRequirements());
1:         
1:         StringBuilder buff = new StringBuilder();
1:         for (String pkgName : merger.getInvalidRequirements())
1:         {
1:           buff.append(pkgName).append(", ");
1:         }
1:   
1:         int buffLen = buff.length();
1:         String pkgString = (buffLen > 0 ? buff.substring(0, buffLen - 2) : "");
1:   
1:         ResolverException re = new ResolverException(MessageUtil.getMessage(
1:             "INCOMPATIBLE_PACKAGE_VERSION_REQUIREMENTS", new Object[] { assetName, pkgString }));
1:         re.setUnsatisfiedRequirements(pkgNames);
1:         logger.debug(LOG_EXIT,"getExternalPackageRequirements", re);
1:         
1:         throw re;
1:       }
1:       
1:       result = merger.getMergedRequirements();
1:       cachedExternalRequirements = result;
/////////////////////////////////////////////////////////////////////////
1:     
1:     Collection<ModelledResource> usedUseBundles =  cachedRequiredUseBundle;
1:     if (usedUseBundles == null)
1:       Collection<ImportedPackage> externalReqs = getExternalPackageRequirements();
1:       usedUseBundles = new HashSet<ModelledResource>();
1:       for (ImportedPackage req : externalReqs)
1:         // Find a match from the supplied bundle capabilities.
1:         ExportedPackage match = getPackageMatch(req, deployedUseBundle);
1:         if (match != null)
1:         {
1:             usedUseBundles.add(match.getBundle());
1:         }
1:       cachedRequiredUseBundle = usedUseBundles;
1:     
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:3d7f5b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:6fe82e7
/////////////////////////////////////////////////////////////////////////
1: 
1:   /** This method will be overridden by a PostResolveTransformer returning an extended version of
1:    * DeployedBundles 
1:    */
1:   @Override
1:   public Map<String, String> getExtraHeaders() {
1:     logger.debug (LOG_ENTRY, "getExtraHeaders");
1:     Map<String, String> result = Collections.emptyMap();
1:     logger.debug (LOG_EXIT, "getExtraHeaders", result);
1:     return result;
1:   }
commit:58f55bd
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.application.modelling.impl;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.DeployedBundles;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public final class DeployedBundlesImpl implements DeployedBundles
1:   private final Logger logger = LoggerFactory.getLogger(DeployedBundlesImpl.class);
/////////////////////////////////////////////////////////////////////////
1:   public DeployedBundlesImpl(String assetName, Collection<ImportedBundle> appContentNames, 
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
1:   public String getImportPackage() throws ResolverException
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
/////////////////////////////////////////////////////////////////////////
0:   @Override
1:   public Collection<ModelledResource> getRequiredUseBundle() throws ResolverException
commit:a1f07b5
/////////////////////////////////////////////////////////////////////////
1:         AppConstants.DEPLOYMENT_PROVISION_BUNDLE + '=' + deployedProvisionBundle;
commit:4fec049
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.aries.application.modelling.utils;
1: 
1: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import org.apache.aries.application.management.ResolverException;
1: import org.apache.aries.application.modelling.DeploymentMFElement;
1: import org.apache.aries.application.modelling.ExportedBundle;
1: import org.apache.aries.application.modelling.ExportedPackage;
1: import org.apache.aries.application.modelling.ExportedService;
1: import org.apache.aries.application.modelling.ImportedBundle;
1: import org.apache.aries.application.modelling.ImportedPackage;
1: import org.apache.aries.application.modelling.ImportedService;
1: import org.apache.aries.application.modelling.ModelledResource;
0: import org.apache.aries.application.modelling.impl.ImportedPackageImpl;
1: import org.apache.aries.application.modelling.internal.MessageUtil;
1: import org.apache.aries.application.modelling.internal.PackageRequirementMerger;
1: import org.apache.aries.application.utils.AppConstants;
1: import org.osgi.framework.Constants;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: /**
1:  * Class to generate DEPLOYMENT.MF manifest entries for resolved bundles based on
1:  * corresponding APPLICATION.MF entries.
1:  */
0: public final class DeployedBundles
1: {
0:   private final Logger logger = LoggerFactory.getLogger(DeployedBundles.class);
1:   private final String assetName;
1: 
1:   /** Content from APPLICATION.MF */
1:   private final Set<ImportedBundle> appContent = new HashSet<ImportedBundle>();
1:   /** Use Bundle from APPLICATION.MF */
1:   private final Set<ImportedBundle> appUseBundle = new HashSet<ImportedBundle>();
1:   /** Content for deployment.mf deployed-content. */
1:   private final Set<ModelledResource> deployedContent = new HashSet<ModelledResource>();
1:   /** Content for deployment.mf use-bundle. */
1:   private final Set<ModelledResource> deployedUseBundle = new HashSet<ModelledResource>();
1:   /** Content for deployment.mf provision-bundle. */
1:   private final Set<ModelledResource> deployedProvisionBundle = new HashSet<ModelledResource>();
1:   /** Content for deployment.mf DeployedImport-Service. */
1:   private final Collection<ImportedService> deployedImportService = new HashSet<ImportedService>(); 
1:   private final Collection<ModelledResource> fakeDeployedBundles = new HashSet<ModelledResource>();
1:   
1:   /**
1:    * Constructor for cases when we have one or more '
1:    * @param assetName         the name of the asset being deployed.
1:    * @param appContentNames   the bundle names specified in Deployed-Content.
1:    * @param appUseBundleNames the bundle names specified in Deployed-Use-Bundle.
1:    * @param fakeServiceProvidingBundles  bundles that we're pretending are part of the deployed content. Can be null. 
1:    *                                     These bundles are proxies for bundles provided (for example by SCA) that export
1:    *                                     services matching Application-ImportService. 
1:    */
0:   public DeployedBundles(String assetName, Collection<ImportedBundle> appContentNames, 
1:       Collection<ImportedBundle> appUseBundleNames, Collection<ModelledResource> fakeServiceProvidingBundles)
1:   {
1:     logger.debug(LOG_ENTRY, "DeployedBundles", new Object[]{appContentNames, appUseBundleNames, fakeServiceProvidingBundles});
1:     
1:     this.assetName = assetName;
1: 
1:     appContent.addAll(appContentNames);
1:     appUseBundle.addAll(appUseBundleNames);
1:     if (fakeServiceProvidingBundles != null) { 
1:       fakeDeployedBundles.addAll(fakeServiceProvidingBundles);
1:     }
1:     logger.debug(LOG_EXIT, "DeployedBundles");
1:   }
1:   
1:   /**
1:    * Add provisioned version information for a specific bundle name. This will be added to the
1:    * appropriate manifest header for the specified bundle.
1:    * @param resolvedBundle the bundle that has been provisioned.
1:    * @param resolvedVersion the specific version provisioned.
1:    */
1:   public void addBundle(ModelledResource modelledBundle)
1:   {
1:     logger.debug(LOG_ENTRY, "addBundle", new Object[]{modelledBundle});
1:     // Identify the deployment.mf entries the bundle should be added to by matching
1:     // both the bundle name and resolved version against the name and version range
1:     // defined in application.mf.
1:     
1:     ExportedBundle resolvedBundle = modelledBundle.getExportedBundle();
1:     
1:     if (isBundleMatch(appContent, resolvedBundle))
1:     {
1:       logger.debug("Added to " + AppConstants.DEPLOYMENT_CONTENT + ": " + resolvedBundle);
1:      
1:       deployedContent.add(modelledBundle);
1:       
1:       // Add any service dependencies to the list
1:       deployedImportService.addAll(modelledBundle.getImportedServices());
1:     }
1:     else if (isBundleMatch(appUseBundle, resolvedBundle))
1:     {
1:       logger.debug("Added to " + AppConstants.DEPLOYMENT_USE_BUNDLE + ": " + resolvedBundle);
1:       deployedUseBundle.add(modelledBundle);
1:     } else
1:     {
1:       logger.debug("Added to " + AppConstants.DEPLOYMENT_PROVISION_BUNDLE + ": " + resolvedBundle);
1:       deployedProvisionBundle.add(modelledBundle);
1:     }
1:    logger.debug(LOG_EXIT, "addBundle");    
1:   }
1: 
1:   /**
1:    * Check if a match is found between the supplied map of application bundle name/version information,
1:    * and the supplied bundle name and version.
1:    * @param imports Imported bundles
1:    * @param potentialMatch the exported bundle or composite we're interested in
1:    * @return true if a match is found; otherwise false.
1:    */
1:   private boolean isBundleMatch(Set<ImportedBundle> imports, ExportedBundle potentialMatch)
1:   {
1:     boolean result = false;
1:     
1:     for (ImportedBundle ib : imports)
1:     {
1:       if (ib.isSatisfied(potentialMatch))
1:       {
1:         result = true;
1:         break;
1:       }
1:     }
1:   
1:     return result;
1:   }
1:   
1:   /**
1:    * Get the value corresponding to the Deployed-Content header in the deployment.mf.
1:    * @return a manifest entry, or an empty string if there is no content.
1:    */
1:   public String getContent()
1:   {
1:     return createManifestString(deployedContent);
1:   }
1:   
1:   /**
1:    * Get the value corresponding to the Deployed-Use-Bundle header in the deployment.mf.
1:    * @return a manifest entry, or an empty string if there is no content.
1:    */
1:   public String getUseBundle()
1:   {
1:     return createManifestString(deployedUseBundle);
1:   }
1:   
1:   /**
1:    * Get the value corresponding to the Provision-Bundle header in the deployment.mf.
1:    * @return a manifest entry, or an empty string if there is no content.
1:    */
1:   public String getProvisionBundle()
1:   {
1:     return createManifestString(deployedProvisionBundle);
1:   }
1:   
1:   /**
1:    * Get the value corresponding to the Import-Package header in the deployment.mf. 
1:    * @return a manifest entry, or an empty string if there is no content.
1:    * @throws ResolverException if the requirements could not be resolved.
1:    */
0:   public String getImportPackage()
1:     throws ResolverException
1:   {
1:     logger.debug(LOG_ENTRY, "getImportPackage");
0:     Collection<ImportedPackage> externalReqs = new ArrayList<ImportedPackage>(getExternalPackageRequirements());
1: 
0:     //Validate that we don't have attributes that will break until RFC138 is used
0:     validateOtherImports(externalReqs);
1:     
0:     // Find the matching capabilities from bundles in use bundle, and prune
0:     // matched requirements out of the external requirements collection.
0:     Map<ImportedPackage,ExportedPackage> useBundlePkgs = new HashMap<ImportedPackage,ExportedPackage>();
0:     for (Iterator<ImportedPackage> iter = externalReqs.iterator(); iter.hasNext(); )
1:     {
0:       ImportedPackage req = iter.next();
0:       ExportedPackage match = getPackageMatch(req, deployedUseBundle);
0:       if (match != null)
1:       {
0:         useBundlePkgs.put(req, match);
0:         iter.remove();
1:       }
1:     }
1:     
1:     
0:     StringBuilder useBundleImports = new StringBuilder();
0:     for(Map.Entry<ImportedPackage, ExportedPackage> entry : useBundlePkgs.entrySet()) {
0:       useBundleImports.append(entry.getValue().toDeploymentString());
0:       ImportedPackage key = entry.getKey();
0:       if(key.isOptional())
0:         useBundleImports.append(";" + Constants.RESOLUTION_DIRECTIVE +":=" + Constants.RESOLUTION_OPTIONAL);
0:       useBundleImports.append(",");
1:     }
1:     
0:     String result = useBundleImports.toString() + createManifestString(externalReqs);
1:     
0:     if(result.endsWith(","))
0:       result = result.substring(0, result.length() - 1);
1:     logger.debug(LOG_EXIT, "getImportPackage", result);
1:     return result;
1:   }
1:   
1:   /**
1:    * Get the Deployed-ImportService header. 
1:    * this.deployedImportService contains all the service import filters for every 
1:    * blueprint component within the application. We will only write an entry
1:    * to Deployed-ImportService if
1:    *   a) the reference isMultiple(), or
1:    *   b) the service was not available internally when the app was first deployed
1:    *   
1:    */
1:   public String getDeployedImportService() { 
1:     logger.debug(LOG_ENTRY,"getDeployedImportService");
0:     Collection<ImportedService> deployedBundleServiceImports = new ArrayList<ImportedService>();
0:     Collection<ExportedService> servicesExportedWithinIsolatedContent = new ArrayList<ExportedService>();
0:     for (ModelledResource mRes : getDeployedContent()) { 
0:       servicesExportedWithinIsolatedContent.addAll(mRes.getExportedServices());
1:     }
0:     for (ModelledResource mRes : fakeDeployedBundles) { 
0:       servicesExportedWithinIsolatedContent.addAll(mRes.getExportedServices());
1:     }
0:     for (ImportedService impService : deployedImportService) { 
0:       if (impService.isMultiple()) { 
1:         deployedBundleServiceImports.add(impService);
0:       } else { 
0:         boolean serviceProvidedWithinIsolatedContent = false;
0:         Iterator<ExportedService> it = servicesExportedWithinIsolatedContent.iterator();
0:         while (!serviceProvidedWithinIsolatedContent && it.hasNext()) { 
0:           ExportedService svc = it.next(); 
0:           serviceProvidedWithinIsolatedContent |= impService.isSatisfied(svc);
1:         }
0:         if (!serviceProvidedWithinIsolatedContent) { 
1:           deployedBundleServiceImports.add(impService);
1:         }
1:       }
1:     }
1:     
0:     String result = createManifestString(deployedBundleServiceImports);
1:     logger.debug(LOG_EXIT,"getDeployedImportService", result);
1:     
1:     return result;
1:   }
1:   /**
1:    * Get all the requirements of bundles in deployed content that are not satisfied
1:    * by other bundles in deployed content.
1:    * @return a collection of package requirements.
1:    * @throws ResolverException if the requirements could not be resolved.
1:    */
1:   private Collection<ImportedPackage> getExternalPackageRequirements()
1:     throws ResolverException
1:   {
1:     logger.debug(LOG_ENTRY,"getExternalPackageRequirements");
1:     
0:     // Get all the internal requirements.
0:     Collection<ImportedPackage> requirements = new ArrayList<ImportedPackage>();
0:     for (ModelledResource bundle : deployedContent)
1:     {
0:       requirements.addAll(bundle.getImportedPackages());
1:     }
1:     
0:     // Filter out requirements satisfied by internal capabilities.
0:     Collection<ImportedPackage> result = new ArrayList<ImportedPackage>();
1:     for (ImportedPackage req : requirements)
1:     {
0:       ExportedPackage match = getPackageMatch(req, deployedContent);
0:       //If we didn't find a match then it must come from outside
0:       if (match == null)
1:       {
0:         result.add(req);
1:       }
1:     }
1:     
0:     PackageRequirementMerger merger = new PackageRequirementMerger(result);
0:     if (!merger.isMergeSuccessful())
1:     {
0:       List<String> pkgNames = new ArrayList<String>(merger.getInvalidRequirements());
1:       
0:       StringBuilder buff = new StringBuilder();
0:       for (String pkgName : merger.getInvalidRequirements())
1:       {
0:         buff.append(pkgName).append(", ");
1:       }
1: 
0:       int buffLen = buff.length();
0:       String pkgString = (buffLen > 0 ? buff.substring(0, buffLen - 2) : "");
1: 
1:       ResolverException re = new ResolverException(MessageUtil.getMessage(
0:           "INCOMPATIBLE_PACKAGE_VERSION_REQUIREMENTS", new Object[] { assetName, pkgString }));
0:       re.setUnsatisfiedRequirements(pkgNames);
0:       logger.debug(LOG_EXIT,"getExternalPackageRequirements", re);
1:       
1:       throw re;
1:     }
1:     
0:     result = merger.getMergedRequirements();
1:     logger.debug(LOG_EXIT,"getExternalPackageRequirements", result);
1:     
1:     return result;
1:   }
1:   
1:   /**
1:    * Create entries for the Import-Package header corresponding to the supplied
1:    * packages, referring to bundles not in Use-Bundle.
1:    * @param requirements packages for which entries should be created.
1:    * @return manifest header entries.
1:    * @throws ResolverException if the imports are invalid.
1:    */
1:   private void validateOtherImports(Collection<ImportedPackage> requirements)
1:     throws ResolverException
1:   {
1:     logger.debug(LOG_ENTRY, "validateOtherImports", requirements);
1:     for (ImportedPackage req : requirements)
1:     {
1:       String pkgName = req.getPackageName();
1: 
1:       for (String name : req.getAttributes().keySet())
1:       {
1:         if (Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE.equals(name)
1:             || Constants.BUNDLE_VERSION_ATTRIBUTE.equals(name))
1:         {
1:           ResolverException re = new ResolverException(MessageUtil.getMessage(
1:               "INVALID_PACKAGE_REQUIREMENT_ATTRIBUTES", new Object[] { assetName, name, pkgName }));
1:           re.setUnsatisfiedRequirements(Arrays.asList(pkgName));
1:           logger.debug(LOG_EXIT, "validateOtherImports", re);
1:           throw re;
1:         }
1:       }
1:     }
1:     logger.debug(LOG_EXIT, "validateOtherImports");
1:   }
1: 
1:   /**
1:    * Get a package match between the specified requirement and a capability of the supplied
1:    * bundles. The resulting match object might not refer to any matching capability.
1:    * @param requirement the {@link ImportedPackageImpl} to be matched.
1:    * @param bundles the bundles to be searched for matching capabilities.
1:    * @return an ExportedPackageImpl or null if no match is found.
1:    */
1:   private ExportedPackage getPackageMatch(ImportedPackage requirement, Collection<ModelledResource> bundles)
1:   {
1:     logger.debug(LOG_ENTRY, "getPackageMatch", new Object[]{requirement, bundles});
1:     ExportedPackage result = null;
1:     
1:     outer: for (ModelledResource bundle : bundles)
1:     {
1:       for (ExportedPackage pkg : bundle.getExportedPackages())
1:       {
1:         if(requirement.isSatisfied(pkg)) {
1:           result = pkg;
1:           break outer;
1:         }
1:       }
1:     }
1:     logger.debug(LOG_EXIT, "getPackageMatch", new Object[]{result});
1:     return result;
1:   }
1:   
1:   private String createManifestString(Collection<? extends DeploymentMFElement> values)
1:   {
1:     logger.debug(LOG_ENTRY, "createManifestString", new Object[]{values});
1:     StringBuilder builder = new StringBuilder();
1:     for (DeploymentMFElement value : values)
1:     {
1:       builder.append(value.toDeploymentString()).append(",");
1:     }
1:     
1:     int length = builder.length();
1:     String result = (length > 0 ? builder.substring(0, length - 1) : "");
1:     logger.debug(LOG_EXIT, "createManifestString", new Object[]{result});
1:     return result;
1:   }
1:   
1: 
1:   public String toString()
1:   {
1:     return AppConstants.DEPLOYMENT_CONTENT + '=' + deployedContent + ' ' +
1:         AppConstants.DEPLOYMENT_USE_BUNDLE + '=' + deployedUseBundle + ' ' +
0:         AppConstants.DEPLOYMENT_PROVISION_BUNDLE + '=' + deployedProvisionBundle;/* + ' ' /*+
0:         AppConstants.WAS_FEATURE_REQUIRED + "=" + requiredFeatures;*/
1:   }
1:   
1:   /**
1:    * Get the set of bundles that are going to be deployed into an isolated framework
1:    * @return a set of bundle metadata
1:    */
1:   public Collection<ModelledResource> getDeployedContent()
1:   {
1:     logger.debug(LOG_ENTRY, "getDeployedContent");
1:     logger.debug(LOG_EXIT,"getDeployedContent", deployedContent);
1:     return Collections.unmodifiableCollection(deployedContent);
1:   }
1:   
1:   /**
1:    * Get the set of bundles that map to Provision-Bundle: these plus 
1:    * getRequiredUseBundle combined give the bundles that will be provisioned
1:    * into the shared bundle space
1:    * 'getProvisionBundle' returns the manifest header string, so this method 
1:    * needs to be called something else. 
1:    *
1:    */
1:   public Collection<ModelledResource> getDeployedProvisionBundle () 
1:   { 
1:     logger.debug(LOG_ENTRY,"getDeployedProvisionBundle");
1:     logger.debug(LOG_EXIT, "getDeployedProvisionBundle", deployedContent);
1:     return Collections.unmodifiableCollection(deployedProvisionBundle);
1:   }
1:   
1:   /**
1:    * Get the subset of bundles specified in use-bundle that are actually required to
1:    * satisfy direct requirements of deployed content.
1:    * @return a set of bundle metadata.
1:    * @throws ResolverException if the requirements could not be resolved.
1:    */
0:   public Collection<ModelledResource> getRequiredUseBundle()
1:     throws ResolverException
1:   {
1:     logger.debug(LOG_ENTRY, "getRequiredUseBundle");
0:     Collection<ImportedPackage> externalReqs = getExternalPackageRequirements();
0:     Collection<ModelledResource> usedUseBundles = new HashSet<ModelledResource>();
0:     for (ImportedPackage req : externalReqs)
1:     {
0:       // Find a match from the supplied bundle capabilities.
0:       ExportedPackage match = getPackageMatch(req, deployedUseBundle);
0:       if (match != null)
1:       {
0:           usedUseBundles.add(match.getBundle());
1:       }
1:     }
1:     logger.debug(LOG_EXIT, "getRequiredUseBundle", usedUseBundles);
1:     return usedUseBundles;
1:   }
1: }
============================================================================