9:1409552: /*
1:1409552:  * Licensed to the Apache Software Foundation (ASF) under one
1:1409552:  * or more contributor license agreements.  See the NOTICE file
1:1409552:  * distributed with this work for additional information
1:1409552:  * regarding copyright ownership.  The ASF licenses this file
1:1409552:  * to you under the Apache License, Version 2.0 (the
1:1409552:  * "License"); you may not use this file except in compliance
1:1409552:  * with the License.  You may obtain a copy of the License at
10:1409552:  *
1:1409552:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1409552:  *
1:1409552:  * Unless required by applicable law or agreed to in writing,
1:1409552:  * software distributed under the License is distributed on an
1:1409552:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:1409552:  * KIND, either express or implied.  See the License for the
1:1409552:  * specific language governing permissions and limitations
1:1409552:  * under the License.
1:1409552:  */
1:1409552: package org.apache.aries.util;
4:1409552: 
1:1409552: import java.util.regex.Matcher;
1:1409552: import java.util.regex.Pattern;
1:1409552: 
1:1409552: import org.apache.aries.util.internal.MessageUtil;
1:1409552: import org.osgi.framework.Version;
1:1409552: 
1:1409552: public final class VersionRange {
1:1409552:     
1:1409552:     /** A string representation of the version. */
1:1409552:     private String version;
1:1409552: 
1:1409552:     /** The minimum desired version for the bundle */
1:1409552:     private Version minimumVersion;
1:1409552: 
1:1409552:     /** The maximum desired version for the bundle */
1:1409552:     private Version maximumVersion;
1:1409552: 
1:1409552:     /** True if the match is exclusive of the minimum version */
1:1409552:     private boolean minimumExclusive;
1:1409552: 
1:1409552:     /** True if the match is exclusive of the maximum version */
1:1409552:     private boolean maximumExclusive;
1:1409552: 
1:1409552:     /** A regexp to select the version */
1:1409552:     private static final Pattern versionCapture = Pattern.compile("\"?(.*?)\"?$");
1:1409552: 
1:1409552:     /**
1:1409552:      * 
1:1409552:      * @param version
1:1409552:      *            version for the verioninfo
1:1409552:      */
1:1409552:     public VersionRange(String version) {
2:1409552:         this.version = version;
1:380fbe7:         processVersionAttribute(version);
2:1409552:     }
1:1409552: 
1:1409552:     /**
1:380fbe7:      * This method should be used to create a version range from a single
1:380fbe7:      * version string.
1:1409552:      * @param version
1:1409552:      *            version for the versioninfo
1:1409552:      * @param exactVersion
1:380fbe7:      *            whether this is an exact version {@code true} or goes to infinity
1:380fbe7:      *            {@code false}
1:1409552:      */
1:1409552:     public VersionRange(String version, boolean exactVersion) {
1:380fbe7:         
1:1409552:         if (exactVersion) {
1:51d6f0e:             // Do not store this string as it might be just a version, or a range!
1:51d6f0e:             processExactVersionAttribute(version);
1:1409552:         } else {
1:380fbe7:             this.version = version;
2:1409552:             processVersionAttribute(this.version);
1:1409552:         }
1:51d6f0e: 
1:1409552:         assertInvariants();
1:1409552:     }
1:380fbe7: 
1:1409552:     /**
1:1409552:      * Constructor designed for internal use only.
1:1409552:      * 
1:1409552:      * @param maximumVersion
1:1409552:      * @param maximumExclusive
1:1409552:      * @param minimumVersion
1:1409552:      * @param minimumExclusive
1:1409552:      * @throws IllegalArgumentException
1:1409552:      *             if parameters are not valid.
1:1409552:      */
1:1409552:     private VersionRange(Version maximumVersion,
1:1409552:                          boolean maximumExclusive,
1:1409552:                          Version minimumVersion,
1:1409552:                          boolean minimumExclusive) {
1:1409552:         this.maximumVersion = maximumVersion;
1:1409552:         this.maximumExclusive = maximumExclusive;
1:1409552:         this.minimumVersion = minimumVersion;
1:1409552:         this.minimumExclusive = minimumExclusive;
1:1409552: 
1:1409552:         assertInvariants();
1:1409552:     }
1:1409552: 
1:1409552:     /*
9:1409552:      * (non-Javadoc)
1:1409552:      * 
1:1409552:      * @see org.apache.aries.application.impl.VersionRange#toString()
1:1409552:      */
1:1409552:     @Override
1:1409552:     public String toString() {
1:380fbe7:         // Some constructors don't take in a string that we can return directly, 
1:380fbe7:         // so construct one if needed
1:1409552:         if (version == null) {
2:1409552:             if (maximumVersion == null) {
1:1409552:                 version = minimumVersion.toString();
1:1409552:             } else {
1:1409552:                 version = (minimumExclusive ? "(" : "[") + minimumVersion + "," + maximumVersion
1:1409552:                           + (maximumExclusive ? ")" : "]");
1:1409552:             }
1:1409552:         }
1:1409552:         return this.version;
1:1409552:     }
1:1409552: 
1:1409552:     @Override
1:1409552:     public int hashCode() {
1:1409552:         int result = 17;
1:1409552:         result = 31 * result + minimumVersion.hashCode();
1:1409552:         result = 31 * result + (minimumExclusive ? 1 : 0);
1:1409552:         result = 31 * result + (maximumVersion != null ? maximumVersion.hashCode() : 0);
1:1409552:         result = 31 * result + (maximumExclusive ? 1 : 0);
1:1409552:         return result;
1:1409552:     }
1:1409552: 
1:1409552:     @Override
1:1409552:     public boolean equals(Object other) {
1:1409552:         boolean result = false;
1:1409552:         if (this == other) {
1:1409552:             result = true;
1:1409552:         } else if (other instanceof VersionRange) {
1:1409552:             VersionRange vr = (VersionRange) other;
1:1409552:             result = minimumVersion.equals(vr.minimumVersion)
1:1409552:                      && minimumExclusive == vr.minimumExclusive
1:1409552:                      && (maximumVersion == null ? vr.maximumVersion == null : maximumVersion
1:1409552:                              .equals(vr.maximumVersion)) && maximumExclusive == vr.maximumExclusive;
1:1409552:         }
1:1409552: 
1:1409552:         return result;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * this method returns the exact version from the versionInfo obj.
1:910fec0:      * this is used for DeploymentContent only to return a valid exact version
1:910fec0:      * otherwise, null is returned.
1:910fec0:      * @return the exact version
1:1409552:      */
1:1409552:     public Version getExactVersion() {
1:1409552:         Version v = null;
1:1409552:         if (isExactVersion()) {
1:1409552:             v = getMinimumVersion();
1:1409552:         }
1:1409552:         return v;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * get the maximum version
1:910fec0:      * @return    the maximum version
1:1409552:      */
1:1409552:     public Version getMaximumVersion() {
1:1409552:         return maximumVersion;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * get the minimum version
1:910fec0:      * @return    the minimum version
1:1409552:      */
1:1409552:     public Version getMinimumVersion() {
1:1409552:         return minimumVersion;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * is the maximum version exclusive
1:910fec0:      * @return is the max version in the range.
1:1409552:      */
1:1409552:     public boolean isMaximumExclusive() {
1:1409552:         return maximumExclusive;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * is the maximum version unbounded
1:910fec0:      * @return true if no upper bound was specified.
1:1409552:      */
1:1409552:     public boolean isMaximumUnbounded() {
1:1409552:         boolean unbounded = maximumVersion == null;
1:1409552:         return unbounded;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * is the minimum version exclusive
1:910fec0:      * @return true if the min version is in range.
1:1409552:      */
1:1409552:     public boolean isMinimumExclusive() {
1:1409552:         return minimumExclusive;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:1409552:      * this is designed for deployed-version as that is the exact version.
1:1409552:      * 
1:1409552:      * @param version
1:1409552:      * @return
1:1409552:      * @throws IllegalArgumentException
1:1409552:      */
1:1409552:     private boolean processExactVersionAttribute(String version) throws IllegalArgumentException {
1:1409552:         boolean success = processVersionAttribute(version);
1:1409552: 
1:51d6f0e:         if (maximumVersion == null) {
1:51d6f0e:             maximumVersion = minimumVersion;
1:51d6f0e:         }
1:51d6f0e: 
1:1409552:         if (!minimumVersion.equals(maximumVersion)) {
1:1409552:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0011E", version));
1:1409552:         }
1:1409552: 
1:1409552:         if (!!!isExactVersion()) {
1:1409552:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version));
1:1409552:         }
1:1409552: 
1:1409552:         return success;
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:1409552:      * process the version attribute,
1:1409552:      * 
1:1409552:      * @param version
1:1409552:      *            the value to be processed
1:1409552:      * @return
1:1409552:      * @throws IllegalArgumentException
1:1409552:      */
1:1409552:     private boolean processVersionAttribute(String version) throws IllegalArgumentException {
1:1409552:         boolean success = false;
1:1409552: 
1:1409552:         if (version == null) {
1:1409552:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0010E"));
1:1409552:         }
1:1409552: 
1:1409552:         Matcher matches = versionCapture.matcher(version);
1:1409552: 
1:1409552:         if (matches.matches()) {
1:1409552:             String versions = matches.group(1);
1:1409552: 
1:1409552:             if ((versions.startsWith("[") || versions.startsWith("("))
1:1409552:                 && (versions.endsWith("]") || versions.endsWith(")"))) {
1:1409552:                 if (versions.startsWith("["))
1:1409552:                     minimumExclusive = false;
1:1409552:                 else if (versions.startsWith("("))
1:1409552:                     minimumExclusive = true;
1:1409552: 
1:1409552:                 if (versions.endsWith("]"))
1:1409552:                     maximumExclusive = false;
1:1409552:                 else if (versions.endsWith(")"))
1:1409552:                     maximumExclusive = true;
1:1409552: 
1:1409552:                 int index = versions.indexOf(',');
1:1409552:                 String minVersion = versions.substring(1, index);
1:1409552:                 String maxVersion = versions.substring(index + 1, versions.length() - 1);
1:1409552: 
1:1409552:                 try {
1:1409552:                     minimumVersion = new Version(minVersion.trim());
1:1409552:                     maximumVersion = new Version(maxVersion.trim());
1:1409552:                     success = true;
1:1409552:                 } catch (NumberFormatException nfe) {
1:1409552:                     throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version), nfe);
1:1409552:                 }
1:1409552:             } else {
1:1409552:                 try {
1:1409552:                     if (versions.trim().length() == 0)
1:1409552:                         minimumVersion = new Version(0, 0, 0);
1:1409552:                     else
1:1409552:                         minimumVersion = new Version(versions.trim());
1:1409552:                     success = true;
1:1409552:                 } catch (NumberFormatException nfe) {
1:1409552:                     throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version), nfe);
1:1409552:                 }
1:1409552:             }
1:1409552:         } else {
1:1409552:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version));
1:1409552:         }
1:1409552: 
1:1409552:         return success;
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:1409552:      * Assert object invariants. Called by constructors to verify that arguments
1:1409552:      * were valid.
1:1409552:      * 
1:1409552:      * @throws IllegalArgumentException
1:1409552:      *             if invariants are violated.
1:1409552:      */
1:1409552:     private void assertInvariants() {
1:1409552:         if (minimumVersion == null
1:1409552:             || !isRangeValid(minimumVersion, minimumExclusive, maximumVersion, maximumExclusive)) {
1:1409552:             IllegalArgumentException e = new IllegalArgumentException();
1:1409552:             throw e;
1:1409552:         }
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:1409552:      * Check if the supplied parameters describe a valid version range.
1:1409552:      * 
1:1409552:      * @param min
1:1409552:      *            the minimum version.
1:1409552:      * @param minExclusive
1:1409552:      *            whether the minimum version is exclusive.
1:1409552:      * @param max
1:1409552:      *            the maximum version.
1:1409552:      * @param maxExclusive
1:1409552:      *            whether the maximum version is exclusive.
1:1409552:      * @return true is the range is valid; otherwise false.
1:1409552:      */
1:1409552:     private boolean isRangeValid(Version min,
1:1409552:                                  boolean minExclusive,
1:1409552:                                  Version max,
1:1409552:                                  boolean maxExclusive) {
1:1409552:         boolean result;
1:1409552: 
1:1409552:         // A null maximum version is unbounded so means that minimum is smaller
1:1409552:         // than
1:1409552:         // maximum.
1:1409552:         int minMaxCompare = (max == null ? -1 : min.compareTo(max));
1:1409552:         if (minMaxCompare > 0) {
1:1409552:             // Minimum larger than maximum is invalid.
1:1409552:             result = false;
1:1409552:         } else if (minMaxCompare == 0 && (minExclusive || maxExclusive)) {
1:1409552:             // If min and max are the same, and either are exclusive, no valid
1:1409552:             // range
1:1409552:             // exists.
1:1409552:             result = false;
1:1409552:         } else {
1:1409552:             // Range is valid.
1:1409552:             result = true;
1:1409552:         }
1:1409552: 
1:1409552:         return result;
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:1409552:      * This method checks that the provided version matches the desired version.
1:1409552:      * 
1:1409552:      * @param version
1:1409552:      *            the version.
1:1409552:      * @return true if the version matches, false otherwise.
1:1409552:      */
1:1409552:     public boolean matches(Version version) {
1:1409552:         boolean result;
1:1409552:         if (this.getMaximumVersion() == null) {
1:1409552:             result = this.getMinimumVersion().compareTo(version) <= 0;
1:1409552:         } else {
1:1409552:             int minN = this.isMinimumExclusive() ? 0 : 1;
1:1409552:             int maxN = this.isMaximumExclusive() ? 0 : 1;
1:1409552: 
1:1409552:             result = (this.getMinimumVersion().compareTo(version) < minN)
1:1409552:                      && (version.compareTo(this.getMaximumVersion()) < maxN);
1:1409552:         }
1:1409552:         return result;
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:910fec0:      * check if the versioninfo is the exact version
1:910fec0:      * @return true if the range will match 1 exact version.
1:1409552:      */
1:1409552:     public boolean isExactVersion() {
1:1409552:         return minimumVersion.equals(maximumVersion) && minimumExclusive == maximumExclusive
1:1409552:                && !!!minimumExclusive;
1:1409552:     }
1:1409552: 
1:910fec0:     /**
1:910fec0:      * Create a new version range that is the intersection of {@code this} and the argument.
1:910fec0:      * In other words, the largest version range that lies within both {@code this} and
1:910fec0:      * the parameter.
1:7937e00:      * @param r a version range to be intersected with {@code this}.
1:910fec0:      * @return a new version range, or {@code null} if no intersection is possible.
1:1409552:      */
1:1409552:     public VersionRange intersect(VersionRange r) {
1:1409552:         // Use the highest minimum version.
1:1409552:         final Version newMinimumVersion;
1:1409552:         final boolean newMinimumExclusive;
1:1409552:         int minCompare = minimumVersion.compareTo(r.getMinimumVersion());
1:1409552:         if (minCompare > 0) {
1:1409552:             newMinimumVersion = minimumVersion;
1:1409552:             newMinimumExclusive = minimumExclusive;
1:1409552:         } else if (minCompare < 0) {
1:1409552:             newMinimumVersion = r.getMinimumVersion();
1:1409552:             newMinimumExclusive = r.isMinimumExclusive();
1:1409552:         } else {
1:1409552:             newMinimumVersion = minimumVersion;
1:1409552:             newMinimumExclusive = (minimumExclusive || r.isMinimumExclusive());
1:1409552:         }
1:1409552: 
1:1409552:         // Use the lowest maximum version.
1:1409552:         final Version newMaximumVersion;
1:1409552:         final boolean newMaximumExclusive;
1:1409552:         // null maximum version means unbounded, so the highest possible value.
1:1409552:         if (maximumVersion == null) {
1:1409552:             newMaximumVersion = r.getMaximumVersion();
1:1409552:             newMaximumExclusive = r.isMaximumExclusive();
1:1409552:         } else if (r.getMaximumVersion() == null) {
1:1409552:             newMaximumVersion = maximumVersion;
1:1409552:             newMaximumExclusive = maximumExclusive;
1:1409552:         } else {
1:1409552:             int maxCompare = maximumVersion.compareTo(r.getMaximumVersion());
1:1409552:             if (maxCompare < 0) {
1:1409552:                 newMaximumVersion = maximumVersion;
1:1409552:                 newMaximumExclusive = maximumExclusive;
1:1409552:             } else if (maxCompare > 0) {
1:1409552:                 newMaximumVersion = r.getMaximumVersion();
1:1409552:                 newMaximumExclusive = r.isMaximumExclusive();
1:1409552:             } else {
1:1409552:                 newMaximumVersion = maximumVersion;
1:1409552:                 newMaximumExclusive = (maximumExclusive || r.isMaximumExclusive());
1:1409552:             }
1:1409552:         }
1:1409552: 
1:1409552:         VersionRange result;
1:1409552:         if (isRangeValid(newMinimumVersion, newMinimumExclusive, newMaximumVersion,
1:1409552:                 newMaximumExclusive)) {
1:1409552:             result = new VersionRange(newMaximumVersion, newMaximumExclusive, newMinimumVersion,
1:1409552:                     newMinimumExclusive);
1:1409552:         } else {
1:1409552:             result = null;
1:1409552:         }
1:1409552:         return result;
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:1409552:      * Parse a version range..
1:1409552:      * 
1:1409552:      * @param s
1:1409552:      * @return VersionRange object.
1:1409552:      * @throws IllegalArgumentException
1:1409552:      *             if the String could not be parsed as a VersionRange
1:1409552:      */
1:1409552:     public static VersionRange parseVersionRange(String s) throws IllegalArgumentException {
1:1409552:         return new VersionRange(s);
1:1409552:     }
1:1409552: 
1:1409552:     /**
1:1409552:      * Parse a version range and indicate if the version is an exact version
1:1409552:      * 
1:1409552:      * @param s
1:1409552:      * @param exactVersion
1:1409552:      * @return VersionRange object.
1:1409552:      * @throws IllegalArgumentException
1:1409552:      *             if the String could not be parsed as a VersionRange
1:1409552:      */
1:1409552:     public static VersionRange parseVersionRange(String s, boolean exactVersion)
1:1409552:             throws IllegalArgumentException {
1:1409552:         return new VersionRange(s, exactVersion);
1:1409552:     }
1:1409552: }
============================================================================
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:7937e00
/////////////////////////////////////////////////////////////////////////
1:      * @param r a version range to be intersected with {@code this}.
author:David Jencks
-------------------------------------------------------------------------------
commit:6df3ad3
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * this method returns the exact version from the versionInfo obj.
1:      * this is used for DeploymentContent only to return a valid exact version
1:      * otherwise, null is returned.
1:      * @return the exact version
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * get the maximum version
1:      * @return    the maximum version
1:     /**
1:      * get the minimum version
1:      * @return    the minimum version
1:     /**
1:      * is the maximum version exclusive
1:      * @return is the max version in the range.
1:     /**
1:      * is the maximum version unbounded
1:      * @return true if no upper bound was specified.
1:     /**
1:      * is the minimum version exclusive
1:      * @return true if the min version is in range.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * check if the versioninfo is the exact version
1:      * @return true if the range will match 1 exact version.
1:     /**
1:      * Create a new version range that is the intersection of {@code this} and the argument.
1:      * In other words, the largest version range that lies within both {@code this} and
1:      * the parameter.
0:      * @param range a version range to be intersected with {@code this}.
1:      * @return a new version range, or {@code null} if no intersection is possible.
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:51d6f0e
/////////////////////////////////////////////////////////////////////////
1:             // Do not store this string as it might be just a version, or a range!
1:             processExactVersionAttribute(version);
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (maximumVersion == null) {
1:             maximumVersion = minimumVersion;
1:         }
1: 
commit:380fbe7
/////////////////////////////////////////////////////////////////////////
1:         processVersionAttribute(version);
1:      * This method should be used to create a version range from a single
1:      * version string.
1:      *            whether this is an exact version {@code true} or goes to infinity
1:      *            {@code false}
1:         
0:             // Store the correct version string 
0:             this.version = "[" + version + "," + version + "]";
0:             // Use the modified version string to parse
1:             this.version = version;
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Some constructors don't take in a string that we can return directly, 
1:         // so construct one if needed
/////////////////////////////////////////////////////////////////////////
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:1409552
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.util;
1: 
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: 
1: import org.apache.aries.util.internal.MessageUtil;
1: import org.osgi.framework.Version;
1: 
1: public final class VersionRange {
1:     
1:     /** A string representation of the version. */
1:     private String version;
1: 
1:     /** The minimum desired version for the bundle */
1:     private Version minimumVersion;
1: 
1:     /** The maximum desired version for the bundle */
1:     private Version maximumVersion;
1: 
1:     /** True if the match is exclusive of the minimum version */
1:     private boolean minimumExclusive;
1: 
1:     /** True if the match is exclusive of the maximum version */
1:     private boolean maximumExclusive;
1: 
1:     /** A regexp to select the version */
1:     private static final Pattern versionCapture = Pattern.compile("\"?(.*?)\"?$");
1: 
1:     /**
1:      * 
1:      * @param version
1:      *            version for the verioninfo
1:      */
1:     public VersionRange(String version) {
1:         this.version = version;
1:         processVersionAttribute(this.version);
1:     }
1: 
1:     /**
1:      * 
1:      * @param version
1:      *            version for the versioninfo
1:      * @param exactVersion
0:      *            whether this is an exact version
1:      */
1:     public VersionRange(String version, boolean exactVersion) {
1:         this.version = version;
1:         if (exactVersion) {
0:             processExactVersionAttribute(this.version);
1:         } else {
1:             processVersionAttribute(this.version);
1:         }
1: 
1:         assertInvariants();
1:     }
1: 
1:     /**
1:      * Constructor designed for internal use only.
1:      * 
1:      * @param maximumVersion
1:      * @param maximumExclusive
1:      * @param minimumVersion
1:      * @param minimumExclusive
1:      * @throws IllegalArgumentException
1:      *             if parameters are not valid.
1:      */
1:     private VersionRange(Version maximumVersion,
1:                          boolean maximumExclusive,
1:                          Version minimumVersion,
1:                          boolean minimumExclusive) {
1:         this.maximumVersion = maximumVersion;
1:         this.maximumExclusive = maximumExclusive;
1:         this.minimumVersion = minimumVersion;
1:         this.minimumExclusive = minimumExclusive;
1: 
1:         assertInvariants();
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
1:      * @see org.apache.aries.application.impl.VersionRange#toString()
1:      */
1:     @Override
1:     public String toString() {
0:         // Some constructors don't take in a string, so construct one if needed
1:         if (version == null) {
1:             if (maximumVersion == null) {
1:                 version = minimumVersion.toString();
1:             } else {
1:                 version = (minimumExclusive ? "(" : "[") + minimumVersion + "," + maximumVersion
1:                           + (maximumExclusive ? ")" : "]");
1:             }
1:         }
1:         return this.version;
1:     }
1: 
1:     @Override
1:     public int hashCode() {
1:         int result = 17;
1:         result = 31 * result + minimumVersion.hashCode();
1:         result = 31 * result + (minimumExclusive ? 1 : 0);
1:         result = 31 * result + (maximumVersion != null ? maximumVersion.hashCode() : 0);
1:         result = 31 * result + (maximumExclusive ? 1 : 0);
1:         return result;
1:     }
1: 
1:     @Override
1:     public boolean equals(Object other) {
1:         boolean result = false;
1:         if (this == other) {
1:             result = true;
1:         } else if (other instanceof VersionRange) {
1:             VersionRange vr = (VersionRange) other;
1:             result = minimumVersion.equals(vr.minimumVersion)
1:                      && minimumExclusive == vr.minimumExclusive
1:                      && (maximumVersion == null ? vr.maximumVersion == null : maximumVersion
1:                              .equals(vr.maximumVersion)) && maximumExclusive == vr.maximumExclusive;
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#getExactVersion()
1:      */
1:     public Version getExactVersion() {
1:         Version v = null;
1:         if (isExactVersion()) {
1:             v = getMinimumVersion();
1:         }
1:         return v;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#getMaximumVersion()
1:      */
1:     public Version getMaximumVersion() {
1:         return maximumVersion;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#getMinimumVersion()
1:      */
1:     public Version getMinimumVersion() {
1:         return minimumVersion;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#isMaximumExclusive()
1:      */
1:     public boolean isMaximumExclusive() {
1:         return maximumExclusive;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#isMaximumUnbounded()
1:      */
1:     public boolean isMaximumUnbounded() {
1:         boolean unbounded = maximumVersion == null;
1:         return unbounded;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#isMinimumExclusive()
1:      */
1:     public boolean isMinimumExclusive() {
1:         return minimumExclusive;
1:     }
1: 
1:     /**
1:      * this is designed for deployed-version as that is the exact version.
1:      * 
1:      * @param version
1:      * @return
1:      * @throws IllegalArgumentException
1:      */
1:     private boolean processExactVersionAttribute(String version) throws IllegalArgumentException {
1:         boolean success = processVersionAttribute(version);
1: 
1:         if (maximumVersion == null) {
0:             maximumVersion = minimumVersion;
1:         }
1: 
1:         if (!minimumVersion.equals(maximumVersion)) {
1:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0011E", version));
1:         }
1: 
1:         if (!!!isExactVersion()) {
1:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version));
1:         }
1: 
1:         return success;
1:     }
1: 
1:     /**
1:      * process the version attribute,
1:      * 
1:      * @param version
1:      *            the value to be processed
1:      * @return
1:      * @throws IllegalArgumentException
1:      */
1:     private boolean processVersionAttribute(String version) throws IllegalArgumentException {
1:         boolean success = false;
1: 
1:         if (version == null) {
1:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0010E"));
1:         }
1: 
1:         Matcher matches = versionCapture.matcher(version);
1: 
1:         if (matches.matches()) {
1:             String versions = matches.group(1);
1: 
1:             if ((versions.startsWith("[") || versions.startsWith("("))
1:                 && (versions.endsWith("]") || versions.endsWith(")"))) {
1:                 if (versions.startsWith("["))
1:                     minimumExclusive = false;
1:                 else if (versions.startsWith("("))
1:                     minimumExclusive = true;
1: 
1:                 if (versions.endsWith("]"))
1:                     maximumExclusive = false;
1:                 else if (versions.endsWith(")"))
1:                     maximumExclusive = true;
1: 
1:                 int index = versions.indexOf(',');
1:                 String minVersion = versions.substring(1, index);
1:                 String maxVersion = versions.substring(index + 1, versions.length() - 1);
1: 
1:                 try {
1:                     minimumVersion = new Version(minVersion.trim());
1:                     maximumVersion = new Version(maxVersion.trim());
1:                     success = true;
1:                 } catch (NumberFormatException nfe) {
1:                     throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version), nfe);
1:                 }
1:             } else {
1:                 try {
1:                     if (versions.trim().length() == 0)
1:                         minimumVersion = new Version(0, 0, 0);
1:                     else
1:                         minimumVersion = new Version(versions.trim());
1:                     success = true;
1:                 } catch (NumberFormatException nfe) {
1:                     throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version), nfe);
1:                 }
1:             }
1:         } else {
1:             throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version));
1:         }
1: 
1:         return success;
1:     }
1: 
1:     /**
1:      * Assert object invariants. Called by constructors to verify that arguments
1:      * were valid.
1:      * 
1:      * @throws IllegalArgumentException
1:      *             if invariants are violated.
1:      */
1:     private void assertInvariants() {
1:         if (minimumVersion == null
1:             || !isRangeValid(minimumVersion, minimumExclusive, maximumVersion, maximumExclusive)) {
1:             IllegalArgumentException e = new IllegalArgumentException();
1:             throw e;
1:         }
1:     }
1: 
1:     /**
1:      * Check if the supplied parameters describe a valid version range.
1:      * 
1:      * @param min
1:      *            the minimum version.
1:      * @param minExclusive
1:      *            whether the minimum version is exclusive.
1:      * @param max
1:      *            the maximum version.
1:      * @param maxExclusive
1:      *            whether the maximum version is exclusive.
1:      * @return true is the range is valid; otherwise false.
1:      */
1:     private boolean isRangeValid(Version min,
1:                                  boolean minExclusive,
1:                                  Version max,
1:                                  boolean maxExclusive) {
1:         boolean result;
1: 
1:         // A null maximum version is unbounded so means that minimum is smaller
1:         // than
1:         // maximum.
1:         int minMaxCompare = (max == null ? -1 : min.compareTo(max));
1:         if (minMaxCompare > 0) {
1:             // Minimum larger than maximum is invalid.
1:             result = false;
1:         } else if (minMaxCompare == 0 && (minExclusive || maxExclusive)) {
1:             // If min and max are the same, and either are exclusive, no valid
1:             // range
1:             // exists.
1:             result = false;
1:         } else {
1:             // Range is valid.
1:             result = true;
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * This method checks that the provided version matches the desired version.
1:      * 
1:      * @param version
1:      *            the version.
1:      * @return true if the version matches, false otherwise.
1:      */
1:     public boolean matches(Version version) {
1:         boolean result;
1:         if (this.getMaximumVersion() == null) {
1:             result = this.getMinimumVersion().compareTo(version) <= 0;
1:         } else {
1:             int minN = this.isMinimumExclusive() ? 0 : 1;
1:             int maxN = this.isMaximumExclusive() ? 0 : 1;
1: 
1:             result = (this.getMinimumVersion().compareTo(version) < minN)
1:                      && (version.compareTo(this.getMaximumVersion()) < maxN);
1:         }
1:         return result;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see org.apache.aries.application.impl.VersionRange#isExactVersion()
1:      */
1:     public boolean isExactVersion() {
1:         return minimumVersion.equals(maximumVersion) && minimumExclusive == maximumExclusive
1:                && !!!minimumExclusive;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
0:      * @see
0:      * org.apache.aries.application.impl.VersionRange#intersect(VersionRange
0:      * range)
1:      */
1:     public VersionRange intersect(VersionRange r) {
1:         // Use the highest minimum version.
1:         final Version newMinimumVersion;
1:         final boolean newMinimumExclusive;
1:         int minCompare = minimumVersion.compareTo(r.getMinimumVersion());
1:         if (minCompare > 0) {
1:             newMinimumVersion = minimumVersion;
1:             newMinimumExclusive = minimumExclusive;
1:         } else if (minCompare < 0) {
1:             newMinimumVersion = r.getMinimumVersion();
1:             newMinimumExclusive = r.isMinimumExclusive();
1:         } else {
1:             newMinimumVersion = minimumVersion;
1:             newMinimumExclusive = (minimumExclusive || r.isMinimumExclusive());
1:         }
1: 
1:         // Use the lowest maximum version.
1:         final Version newMaximumVersion;
1:         final boolean newMaximumExclusive;
1:         // null maximum version means unbounded, so the highest possible value.
1:         if (maximumVersion == null) {
1:             newMaximumVersion = r.getMaximumVersion();
1:             newMaximumExclusive = r.isMaximumExclusive();
1:         } else if (r.getMaximumVersion() == null) {
1:             newMaximumVersion = maximumVersion;
1:             newMaximumExclusive = maximumExclusive;
1:         } else {
1:             int maxCompare = maximumVersion.compareTo(r.getMaximumVersion());
1:             if (maxCompare < 0) {
1:                 newMaximumVersion = maximumVersion;
1:                 newMaximumExclusive = maximumExclusive;
1:             } else if (maxCompare > 0) {
1:                 newMaximumVersion = r.getMaximumVersion();
1:                 newMaximumExclusive = r.isMaximumExclusive();
1:             } else {
1:                 newMaximumVersion = maximumVersion;
1:                 newMaximumExclusive = (maximumExclusive || r.isMaximumExclusive());
1:             }
1:         }
1: 
1:         VersionRange result;
1:         if (isRangeValid(newMinimumVersion, newMinimumExclusive, newMaximumVersion,
1:                 newMaximumExclusive)) {
1:             result = new VersionRange(newMaximumVersion, newMaximumExclusive, newMinimumVersion,
1:                     newMinimumExclusive);
1:         } else {
1:             result = null;
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Parse a version range..
1:      * 
1:      * @param s
1:      * @return VersionRange object.
1:      * @throws IllegalArgumentException
1:      *             if the String could not be parsed as a VersionRange
1:      */
1:     public static VersionRange parseVersionRange(String s) throws IllegalArgumentException {
1:         return new VersionRange(s);
1:     }
1: 
1:     /**
1:      * Parse a version range and indicate if the version is an exact version
1:      * 
1:      * @param s
1:      * @param exactVersion
1:      * @return VersionRange object.
1:      * @throws IllegalArgumentException
1:      *             if the String could not be parsed as a VersionRange
1:      */
1:     public static VersionRange parseVersionRange(String s, boolean exactVersion)
1:             throws IllegalArgumentException {
1:         return new VersionRange(s, exactVersion);
1:     }
1: }
============================================================================