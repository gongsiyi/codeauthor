13:6df3ad3: /*
1:6df3ad3:  * Licensed to the Apache Software Foundation (ASF) under one
1:6df3ad3:  * or more contributor license agreements.  See the NOTICE file
1:6df3ad3:  * distributed with this work for additional information
1:6df3ad3:  * regarding copyright ownership.  The ASF licenses this file
1:6df3ad3:  * to you under the Apache License, Version 2.0 (the
1:6df3ad3:  * "License"); you may not use this file except in compliance
1:6df3ad3:  * with the License.  You may obtain a copy of the License at
25:6df3ad3:  *
1:6df3ad3:  *  http://www.apache.org/licenses/LICENSE-2.0
1:6df3ad3:  *
1:6df3ad3:  * Unless required by applicable law or agreed to in writing,
1:6df3ad3:  * software distributed under the License is distributed on an
1:6df3ad3:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6df3ad3:  * KIND, either express or implied.  See the License for the
1:6df3ad3:  * specific language governing permissions and limitations
1:6df3ad3:  * under the License.
51:6df3ad3:  */
32:6df3ad3: 
1:6df3ad3: 
1:6df3ad3: package org.apache.aries.util.tracker.hook;
1:6df3ad3: 
1:6df3ad3: import org.osgi.framework.Bundle;
1:6df3ad3: import org.osgi.framework.BundleContext;
1:6df3ad3: import org.osgi.framework.BundleEvent;
1:6df3ad3: import org.osgi.framework.ServiceRegistration;
1:6df3ad3: import org.osgi.framework.SynchronousBundleListener;
1:6df3ad3: import org.osgi.framework.hooks.bundle.EventHook;
1:6df3ad3: import org.osgi.util.tracker.BundleTracker;
1:6df3ad3: import org.osgi.util.tracker.BundleTrackerCustomizer;
1:6df3ad3: 
1:6df3ad3: import java.util.ArrayList;
1:6df3ad3: import java.util.Collection;
1:6df3ad3: import java.util.HashMap;
1:6df3ad3: import java.util.LinkedList;
1:6df3ad3: import java.util.List;
1:6df3ad3: import java.util.Map;
1:6df3ad3: 
29:6df3ad3: /**
1:6df3ad3:  * The Tracked and AbstractTracked inner classes are copied from felix framework 4.0.1.
1:6df3ad3:  *
1:6df3ad3:  * @version $Rev$ $Date$
1:6df3ad3:  */
1:6df3ad3: public class BundleHookBundleTracker<T> extends BundleTracker {
1:6df3ad3: 
1:6df3ad3:     static {
1:6df3ad3:         Class c = EventHook.class;
64:6df3ad3:     }
1:6df3ad3: 
1:414dc66:     /* set this to true to compile in debug messages */
1:414dc66:     static final boolean				DEBUG	= false;
1:6df3ad3: 
1:414dc66:     /**
1:414dc66:      * The Bundle Context used by this {@code BundleTracker}.
1:414dc66:      */
1:414dc66:     protected final BundleContext context;
1:6df3ad3: 
1:414dc66:     /**
1:414dc66:      * The {@code BundleTrackerCustomizer} object for this tracker.
1:414dc66:      */
1:414dc66:     final BundleTrackerCustomizer customizer;
1:414dc66:     /**
1:414dc66:      * Tracked bundles: {@code Bundle} object -> customized Object and
1:414dc66:      * {@code BundleListener} object
1:414dc66:      */
1:414dc66:     private volatile Tracked tracked;
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Accessor method for the current Tracked object. This method is only
1:414dc66:      * intended to be used by the unsynchronized methods which do not modify the
1:414dc66:      * tracked field.
1:414dc66:      *
1:414dc66:      * @return The current Tracked object.
1:414dc66:      */
1:414dc66:     private Tracked tracked() {
1:414dc66:         return tracked;
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * State mask for bundles being tracked. This field contains the ORed values
1:414dc66:      * of the bundle states being tracked.
1:414dc66:      */
1:414dc66:     private final int mask;
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * BundleHook service registration
1:414dc66:      */
1:414dc66:     private ServiceRegistration sr;
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Create a {@code BundleTracker} for bundles whose state is present in the
1:414dc66:      * specified state mask.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * Bundles whose state is present on the specified state mask will be
1:414dc66:      * tracked by this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * @param context The {@code BundleContext} against which the tracking is
1:414dc66:      *        done.
1:414dc66:      * @param stateMask The bit mask of the {@code OR}ing of the bundle states
1:414dc66:      *        to be tracked.
1:414dc66:      * @param customizer The customizer object to call when bundles are added,
1:414dc66:      *        modified, or removed in this {@code BundleTracker}. If customizer
1:414dc66:      *        is {@code null}, then this {@code BundleTracker} will be used as
1:414dc66:      *        the {@code BundleTrackerCustomizer} and this {@code BundleTracker}
1:414dc66:      *        will call the {@code BundleTrackerCustomizer} methods on itself.
1:414dc66:      * @see Bundle#getState()
1:414dc66:      */
1:414dc66:     public BundleHookBundleTracker(BundleContext context, int stateMask, BundleTrackerCustomizer customizer) {
1:414dc66:         super(context, stateMask, customizer);
1:414dc66:         this.context = context;
1:414dc66:         this.mask = stateMask;
1:414dc66:         this.customizer = customizer == null ? this : customizer;
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Open this {@code BundleTracker} and begin tracking bundles.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * Bundle which match the state criteria specified when this
1:414dc66:      * {@code BundleTracker} was created are now tracked by this
1:414dc66:      * {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * @throws java.lang.IllegalStateException If the {@code BundleContext} with
1:414dc66:      *         which this {@code BundleTracker} was created is no longer valid.
1:414dc66:      * @throws java.lang.SecurityException If the caller and this class do not
1:414dc66:      *         have the appropriate
1:414dc66:      *         {@code AdminPermission[context bundle,LISTENER]}, and the Java
1:414dc66:      *         Runtime Environment supports permissions.
1:414dc66:      */
1:414dc66:     @Override
1:414dc66:     public void open() {
1:414dc66:         final Tracked t;
1:414dc66:         synchronized (this) {
1:414dc66:             if (tracked != null) {
1:414dc66:                 return;
1:414dc66:             }
1:414dc66:             t = new Tracked();
1:414dc66:             synchronized (t) {
1:414dc66:                 EventHook hook = new BundleEventHook(t);
1:414dc66:                 sr = context.registerService(EventHook.class.getName(), hook, null);
1:414dc66:                 Bundle[] bundles = context.getBundles();
1:414dc66:                 if (bundles != null) {
1:414dc66:                     int length = bundles.length;
1:414dc66:                     for (int i = 0; i < length; i++) {
1:414dc66:                         int state = bundles[i].getState();
1:414dc66:                         if ((state & mask) == 0) {
1:414dc66:                             /* null out bundles whose states are not interesting */
1:414dc66:                             bundles[i] = null;
1:414dc66:                         }
1:414dc66:                     }
1:414dc66:                     /* set tracked with the initial bundles */
1:414dc66:                     t.setInitial(bundles);
1:414dc66:                 }
1:414dc66:             }
1:414dc66:             tracked = t;
1:f128c13:         }
1:414dc66:         /* Call tracked outside of synchronized region */
1:414dc66:         tracked.trackInitial(); /* process the initial references */
1:f128c13:     }
1:6df3ad3: 
1:414dc66:     /**
1:414dc66:      * Close this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This method should be called when this {@code BundleTracker} should end
1:414dc66:      * the tracking of bundles.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This implementation calls {@link #getBundles()} to get the list of
1:414dc66:      * tracked bundles to remove.
1:414dc66:      */
3:6df3ad3:     @Override
1:414dc66:     public void close() {
1:414dc66:         final Bundle[] bundles;
1:414dc66:         final Tracked outgoing;
1:414dc66:         synchronized (this) {
1:414dc66:             outgoing = tracked;
1:414dc66:             if (outgoing == null) {
1:414dc66:                 return;
1:414dc66:             }
1:414dc66:             if (DEBUG) {
1:414dc66:                 System.out.println("BundleTracker.close"); //$NON-NLS-1$
1:414dc66:             }
1:414dc66:             tracked.close();
1:414dc66:             bundles = getBundles();
1:414dc66:             tracked = null;
1:414dc66:             try {
1:414dc66:                 sr.unregister();
1:414dc66:             } catch (IllegalStateException e) {
1:414dc66: 				/* In case the context was stopped. */
1:414dc66:             }
1:f128c13:         }
1:414dc66:         if (bundles != null) {
1:414dc66:             for (int i = 0; i < bundles.length; i++) {
1:414dc66:                 outgoing.untrack(bundles[i], null);
1:414dc66:             }
1:414dc66:         }
1:f128c13:     }
1:6df3ad3: 
1:414dc66:     /**
1:414dc66:      * Default implementation of the
1:414dc66:      * {@code BundleTrackerCustomizer.addingBundle} method.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This method is only called when this {@code BundleTracker} has been
1:414dc66:      * constructed with a {@code null BundleTrackerCustomizer} argument.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This implementation simply returns the specified {@code Bundle}.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This method can be overridden in a subclass to customize the object to be
1:414dc66:      * tracked for the bundle being added.
1:414dc66:      *
1:414dc66:      * @param bundle The {@code Bundle} being added to this
1:414dc66:      *        {@code BundleTracker} object.
1:414dc66:      * @param event The bundle event which caused this customizer method to be
1:414dc66:      *        called or {@code null} if there is no bundle event associated with
1:414dc66:      *        the call to this method.
1:414dc66:      * @return The specified bundle.
1:414dc66:      * @see BundleTrackerCustomizer#addingBundle(Bundle, BundleEvent)
1:414dc66:      */
1:6df3ad3:     @Override
1:414dc66:     public Object addingBundle(Bundle bundle, BundleEvent event) {
1:414dc66:         T result = (T) bundle;
1:414dc66:         return result;
1:6df3ad3:     }
1:6df3ad3: 
1:414dc66:     /**
1:414dc66:      * Default implementation of the
1:414dc66:      * {@code BundleTrackerCustomizer.modifiedBundle} method.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This method is only called when this {@code BundleTracker} has been
1:414dc66:      * constructed with a {@code null BundleTrackerCustomizer} argument.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This implementation does nothing.
1:414dc66:      *
1:414dc66:      * @param bundle The {@code Bundle} whose state has been modified.
1:414dc66:      * @param event The bundle event which caused this customizer method to be
1:414dc66:      *        called or {@code null} if there is no bundle event associated with
1:414dc66:      *        the call to this method.
1:414dc66:      * @param object The customized object for the specified Bundle.
1:414dc66:      * @see BundleTrackerCustomizer#modifiedBundle(Bundle, BundleEvent, Object)
1:414dc66:      */
1:6df3ad3:     @Override
1:414dc66:     public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) {
1:414dc66: 		/* do nothing */
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Default implementation of the
1:414dc66:      * {@code BundleTrackerCustomizer.removedBundle} method.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This method is only called when this {@code BundleTracker} has been
1:414dc66:      * constructed with a {@code null BundleTrackerCustomizer} argument.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * This implementation does nothing.
1:414dc66:      *
1:414dc66:      * @param bundle The {@code Bundle} being removed.
1:414dc66:      * @param event The bundle event which caused this customizer method to be
1:414dc66:      *        called or {@code null} if there is no bundle event associated with
1:414dc66:      *        the call to this method.
1:414dc66:      * @param object The customized object for the specified bundle.
1:414dc66:      * @see BundleTrackerCustomizer#removedBundle(Bundle, BundleEvent, Object)
1:414dc66:      */
1:414dc66:     @Override
1:414dc66:     public void removedBundle(Bundle bundle, BundleEvent event, Object object) {
1:414dc66:         /* do nothing */
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Return an array of {@code Bundle}s for all bundles being tracked by this
1:414dc66:      * {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * @return An array of {@code Bundle}s or {@code null} if no bundles are
1:414dc66:      *         being tracked.
1:414dc66:      */
1:414dc66:     public Bundle[] getBundles() {
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return null;
1:414dc66:         }
1:414dc66:         synchronized (t) {
1:414dc66:             int length = t.size();
1:414dc66:             if (length == 0) {
1:414dc66:                 return null;
1:414dc66:             }
1:414dc66:             return t.copyKeys(new Bundle[length]);
1:414dc66:         }
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Returns the customized object for the specified {@code Bundle} if the
1:414dc66:      * specified bundle is being tracked by this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * @param bundle The {@code Bundle} being tracked.
1:414dc66:      * @return The customized object for the specified {@code Bundle} or
1:414dc66:      *         {@code null} if the specified {@code Bundle} is not being
1:414dc66:      *         tracked.
1:414dc66:      */
1:414dc66:     public T getObject(Bundle bundle) {
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return null;
1:414dc66:         }
1:414dc66:         synchronized (t) {
1:414dc66:             return t.getCustomizedObject(bundle);
1:414dc66:         }
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Remove a bundle from this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * The specified bundle will be removed from this {@code BundleTracker} . If
1:414dc66:      * the specified bundle was being tracked then the
1:414dc66:      * {@code BundleTrackerCustomizer.removedBundle} method will be called for
1:414dc66:      * that bundle.
1:414dc66:      *
1:414dc66:      * @param bundle The {@code Bundle} to be removed.
1:414dc66:      */
1:414dc66:     public void remove(Bundle bundle) {
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return;
1:414dc66:         }
1:414dc66:         t.untrack(bundle, null);
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Return the number of bundles being tracked by this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * @return The number of bundles being tracked.
1:414dc66:      */
1:414dc66:     public int size() {
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return 0;
1:414dc66:         }
1:414dc66:         synchronized (t) {
1:414dc66:             return t.size();
1:414dc66:         }
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Returns the tracking count for this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * The tracking count is initialized to 0 when this {@code BundleTracker} is
1:414dc66:      * opened. Every time a bundle is added, modified or removed from this
1:414dc66:      * {@code BundleTracker} the tracking count is incremented.
1:414dc66:      *
1:414dc66:      * <p>
1:414dc66:      * The tracking count can be used to determine if this {@code BundleTracker}
1:414dc66:      * has added, modified or removed a bundle by comparing a tracking count
1:414dc66:      * value previously collected with the current tracking count value. If the
1:414dc66:      * value has not changed, then no bundle has been added, modified or removed
1:414dc66:      * from this {@code BundleTracker} since the previous tracking count was
1:414dc66:      * collected.
1:414dc66:      *
1:414dc66:      * @return The tracking count for this {@code BundleTracker} or -1 if this
1:414dc66:      *         {@code BundleTracker} is not open.
1:414dc66:      */
1:414dc66:     public int getTrackingCount() {
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return -1;
1:414dc66:         }
1:414dc66:         synchronized (t) {
1:414dc66:             return t.getTrackingCount();
1:414dc66:         }
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Return a {@code Map} with the {@code Bundle}s and customized objects for
1:414dc66:      * all bundles being tracked by this {@code BundleTracker}.
1:414dc66:      *
1:414dc66:      * @return A {@code Map} with the {@code Bundle}s and customized objects for
1:414dc66:      *         all services being tracked by this {@code BundleTracker}. If no
1:414dc66:      *         bundles are being tracked, then the returned map is empty.
1:414dc66:      * @since 1.5
1:414dc66:      */
1:414dc66:     public Map<Bundle, T> getTracked() {
1:414dc66:         Map<Bundle, T> map = new HashMap<Bundle, T>();
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return map;
1:414dc66:         }
1:414dc66:         synchronized (t) {
1:414dc66:             return t.copyEntries(map);
1:414dc66:         }
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Return if this {@code BundleTracker} is empty.
1:414dc66:      *
1:414dc66:      * @return {@code true} if this {@code BundleTracker} is not tracking any
1:414dc66:      *         bundles.
1:414dc66:      * @since 1.5
1:414dc66:      */
1:414dc66:     public boolean isEmpty() {
1:414dc66:         final Tracked t = tracked();
1:414dc66:         if (t == null) { /* if BundleTracker is not open */
1:414dc66:             return true;
1:414dc66:         }
1:414dc66:         synchronized (t) {
1:414dc66:             return t.isEmpty();
1:414dc66:         }
1:6df3ad3:     }
1:6df3ad3: 
1:6df3ad3:     private class BundleEventHook implements EventHook {
1:414dc66:         private final Tracked tracked;
1:6df3ad3: 
1:414dc66:         private BundleEventHook(Tracked tracked) {
1:414dc66:             this.tracked = tracked;
1:6df3ad3:         }
1:414dc66: 
1:414dc66:         public void event(BundleEvent bundleEvent, Collection bundleContexts) {
1:414dc66:             tracked.bundleChanged(bundleEvent);
1:6df3ad3:         }
1:6df3ad3:     }
1:6df3ad3: 
1:6df3ad3:     /**
1:414dc66:      * Inner class which subclasses AbstractTracked. This class is the
1:414dc66:      * {@code SynchronousBundleListener} object for the tracker.
1:414dc66:      *
1:414dc66:      * @ThreadSafe
1:414dc66:      * @since 1.4
1:6df3ad3:      */
1:414dc66:     private final class Tracked extends AbstractTracked<Bundle, T, BundleEvent> implements SynchronousBundleListener {
1:414dc66:         /**
1:414dc66:          * Tracked constructor.
1:414dc66:          */
1:414dc66:         Tracked() {
1:414dc66:             super();
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * {@code BundleListener} method for the {@code BundleTracker}
1:414dc66:          * class. This method must NOT be synchronized to avoid deadlock
1:414dc66:          * potential.
1:414dc66:          *
1:414dc66:          * @param event {@code BundleEvent} object from the framework.
1:414dc66:          */
1:414dc66:         public void bundleChanged(final BundleEvent event) {
1:6df3ad3:             /*
1:414dc66:              * Check if we had a delayed call (which could happen when we
1:414dc66:              * close).
1:414dc66:              */
1:414dc66:             if (closed) {
1:414dc66:                 return;
1:6df3ad3:             }
1:414dc66:             final Bundle bundle = event.getBundle();
1:414dc66:             final int state = bundle.getState();
1:414dc66:             if (DEBUG) {
1:414dc66:                 System.out.println("BundleTracker.Tracked.bundleChanged[" + state + "]: " + bundle); //$NON-NLS-1$ //$NON-NLS-2$
1:414dc66:             }
1:414dc66: 
1:414dc66:             if ((state & mask) != 0) {
1:414dc66:                 track(bundle, event);
1:414dc66:                 /*
1:414dc66:                  * If the customizer throws an unchecked exception, it is safe
1:414dc66:                  * to let it propagate
1:414dc66:                  */
1:414dc66:             } else {
1:414dc66:                 untrack(bundle, event);
1:414dc66:                 /*
1:414dc66:                  * If the customizer throws an unchecked exception, it is safe
1:414dc66:                  * to let it propagate
1:414dc66:                  */
1:414dc66:             }
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Call the specific customizer adding method. This method must not be
1:414dc66:          * called while synchronized on this object.
1:414dc66:          *
1:414dc66:          * @param item    Item to be tracked.
1:414dc66:          * @param related Action related object.
1:414dc66:          * @return Customized object for the tracked item or {@code null}
1:414dc66:          *         if the item is not to be tracked.
1:414dc66:          */
1:414dc66:         T customizerAdding(final Bundle item, final BundleEvent related) {
1:414dc66:             return (T) customizer.addingBundle(item, related);
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Call the specific customizer modified method. This method must not be
1:414dc66:          * called while synchronized on this object.
1:414dc66:          *
1:414dc66:          * @param item    Tracked item.
1:414dc66:          * @param related Action related object.
1:414dc66:          * @param object  Customized object for the tracked item.
1:414dc66:          */
1:414dc66:         void customizerModified(final Bundle item, final BundleEvent related,
1:414dc66:                                 final T object) {
1:414dc66:             customizer.modifiedBundle(item, related, object);
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Call the specific customizer removed method. This method must not be
1:414dc66:          * called while synchronized on this object.
1:414dc66:          *
1:414dc66:          * @param item    Tracked item.
1:414dc66:          * @param related Action related object.
1:414dc66:          * @param object  Customized object for the tracked item.
1:414dc66:          */
1:414dc66:         void customizerRemoved(final Bundle item, final BundleEvent related,
1:414dc66:                                final T object) {
1:414dc66:             customizer.removedBundle(item, related, object);
1:414dc66:         }
1:414dc66:     }
1:414dc66: 
1:414dc66:     /**
1:414dc66:      * Abstract class to track items. If a Tracker is reused (closed then reopened),
1:414dc66:      * then a new AbstractTracked object is used. This class acts a map of tracked
1:414dc66:      * item -> customized object. Subclasses of this class will act as the listener
1:414dc66:      * object for the tracker. This class is used to synchronize access to the
1:414dc66:      * tracked items. This is not a public class. It is only for use by the
1:414dc66:      * implementation of the Tracker class.
1:414dc66:      *
1:414dc66:      * @param <S> The tracked item. It is the key.
1:414dc66:      * @param <T> The value mapped to the tracked item.
1:414dc66:      * @param <R> The reason the tracked item is being tracked or untracked.
1:414dc66:      * @version $Id: 79452e6c28683021f2bcf11d3689ec75c6b5642f $
1:414dc66:      * @ThreadSafe
1:414dc66:      * @since 1.4
1:414dc66:      */
1:414dc66:     private static abstract class AbstractTracked<S, T, R> {
1:414dc66:         /* set this to true to compile in debug messages */
1:414dc66:         static final boolean DEBUG = false;
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Map of tracked items to customized objects.
1:414dc66:          *
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         private final Map<S, T> tracked;
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Modification count. This field is initialized to zero and incremented by
1:414dc66:          * modified.
1:414dc66:          *
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         private int trackingCount;
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * List of items in the process of being added. This is used to deal with
1:414dc66:          * nesting of events. Since events may be synchronously delivered, events
1:414dc66:          * can be nested. For example, when processing the adding of a service and
1:414dc66:          * the customizer causes the service to be unregistered, notification to the
1:414dc66:          * nested call to untrack that the service was unregistered can be made to
1:414dc66:          * the track method.
1:414dc66:          * <p/>
1:414dc66:          * Since the ArrayList implementation is not synchronized, all access to
1:414dc66:          * this list must be protected by the same synchronized object for
1:414dc66:          * thread-safety.
1:414dc66:          *
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         private final List<S> adding;
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * true if the tracked object is closed.
1:414dc66:          * <p/>
1:414dc66:          * This field is volatile because it is set by one thread and read by
1:414dc66:          * another.
1:414dc66:          */
1:414dc66:         volatile boolean closed;
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Initial list of items for the tracker. This is used to correctly process
1:414dc66:          * the initial items which could be modified before they are tracked. This
1:414dc66:          * is necessary since the initial set of tracked items are not "announced"
1:414dc66:          * by events and therefore the event which makes the item untracked could be
1:414dc66:          * delivered before we track the item.
1:414dc66:          * <p/>
1:414dc66:          * An item must not be in both the initial and adding lists at the same
1:414dc66:          * time. An item must be moved from the initial list to the adding list
1:414dc66:          * "atomically" before we begin tracking it.
1:414dc66:          * <p/>
1:414dc66:          * Since the LinkedList implementation is not synchronized, all access to
1:414dc66:          * this list must be protected by the same synchronized object for
1:414dc66:          * thread-safety.
1:414dc66:          *
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         private final LinkedList<S> initial;
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * AbstractTracked constructor.
1:414dc66:          */
1:414dc66:         AbstractTracked() {
1:414dc66:             tracked = new HashMap<S, T>();
1:414dc66:             trackingCount = 0;
1:414dc66:             adding = new ArrayList<S>(6);
1:414dc66:             initial = new LinkedList<S>();
1:414dc66:             closed = false;
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Set initial list of items into tracker before events begin to be
1:414dc66:          * received.
1:414dc66:          * <p/>
1:414dc66:          * This method must be called from Tracker's open method while synchronized
1:414dc66:          * on this object in the same synchronized block as the add listener call.
1:414dc66:          *
1:414dc66:          * @param list The initial list of items to be tracked. {@code null}
1:414dc66:          *             entries in the list are ignored.
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         void setInitial(S[] list) {
1:414dc66:             if (list == null) {
1:414dc66:                 return;
1:414dc66:             }
1:414dc66:             for (S item : list) {
1:414dc66:                 if (item == null) {
1:414dc66:                     continue;
1:414dc66:                 }
1:414dc66:                 if (DEBUG) {
1:414dc66:                     System.out.println("AbstractTracked.setInitial: " + item); //$NON-NLS-1$
1:414dc66:                 }
1:414dc66:                 initial.add(item);
1:414dc66:             }
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Track the initial list of items. This is called after events can begin to
1:414dc66:          * be received.
1:414dc66:          * <p/>
1:414dc66:          * This method must be called from Tracker's open method while not
1:414dc66:          * synchronized on this object after the add listener call.
1:414dc66:          */
1:414dc66:         void trackInitial() {
1:414dc66:             while (true) {
1:414dc66:                 S item;
1:414dc66:                 synchronized (this) {
1:414dc66:                     if (closed || (initial.size() == 0)) {
1:414dc66:                         /*
1:414dc66:                          * if there are no more initial items
1:414dc66:                          */
1:414dc66:                         return; /* we are done */
1:414dc66:                     }
1:414dc66:                     /*
1:414dc66:                     * move the first item from the initial list to the adding list
1:414dc66:                     * within this synchronized block.
1:414dc66:                     */
1:414dc66:                     item = initial.removeFirst();
1:414dc66:                     if (tracked.get(item) != null) {
1:414dc66:                         /* if we are already tracking this item */
1:414dc66:                         if (DEBUG) {
1:414dc66:                             System.out.println("AbstractTracked.trackInitial[already tracked]: " + item); //$NON-NLS-1$
1:414dc66:                         }
1:414dc66:                         continue; /* skip this item */
1:414dc66:                     }
1:414dc66:                     if (adding.contains(item)) {
1:414dc66:                         /*
1:414dc66:                          * if this item is already in the process of being added.
1:414dc66:                          */
1:414dc66:                         if (DEBUG) {
1:414dc66:                             System.out.println("AbstractTracked.trackInitial[already adding]: " + item); //$NON-NLS-1$
1:414dc66:                         }
1:414dc66:                         continue; /* skip this item */
1:414dc66:                     }
1:414dc66:                     adding.add(item);
1:414dc66:                 }
1:414dc66:                 if (DEBUG) {
1:414dc66:                     System.out.println("AbstractTracked.trackInitial: " + item); //$NON-NLS-1$
1:414dc66:                 }
1:414dc66:                 trackAdding(item, null); /*
1:414dc66:                                           * Begin tracking it. We call trackAdding
1:414dc66: 									      * since we have already put the item in the
1:414dc66: 									      * adding list.
1:414dc66: 									      */
1:414dc66:             }
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Called by the owning Tracker object when it is closed.
1:414dc66:          */
1:414dc66:         void close() {
1:414dc66:             closed = true;
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Begin to track an item.
1:414dc66:          *
1:414dc66:          * @param item    Item to be tracked.
1:414dc66:          * @param related Action related object.
1:414dc66:          */
1:414dc66:         void track(final S item, final R related) {
1:414dc66:             final T object;
1:414dc66:             synchronized (this) {
1:414dc66:                 if (closed) {
1:414dc66:                     return;
1:414dc66:                 }
1:414dc66:                 object = tracked.get(item);
1:414dc66:                 if (object == null) { /* we are not tracking the item */
1:414dc66:                     if (adding.contains(item)) {
1:414dc66:                         /* if this item is already in the process of being added. */
1:414dc66:                         if (DEBUG) {
1:414dc66:                             System.out
1:414dc66:                                     .println("AbstractTracked.track[already adding]: " + item); //$NON-NLS-1$
1:414dc66:                         }
1:414dc66:                         return;
1:414dc66:                     }
1:414dc66:                     adding.add(item); /* mark this item is being added */
1:414dc66:                 } else { /* we are currently tracking this item */
1:414dc66:                     if (DEBUG) {
1:414dc66:                         System.out
1:414dc66:                                 .println("AbstractTracked.track[modified]: " + item); //$NON-NLS-1$
1:414dc66:                     }
1:414dc66:                     modified(); /* increment modification count */
1:414dc66:                 }
1:414dc66:             }
1:414dc66: 
1:414dc66:             if (object == null) { /* we are not tracking the item */
1:414dc66:                 trackAdding(item, related);
1:414dc66:             } else {
1:414dc66:                 /* Call customizer outside of synchronized region */
1:414dc66:                 customizerModified(item, related, object);
1:414dc66:                 /*
1:414dc66:                  * If the customizer throws an unchecked exception, it is safe to
1:414dc66:                  * let it propagate
1:414dc66:                  */
1:414dc66:             }
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Common logic to add an item to the tracker used by track and
1:414dc66:          * trackInitial. The specified item must have been placed in the adding list
1:414dc66:          * before calling this method.
1:414dc66:          *
1:414dc66:          * @param item    Item to be tracked.
1:414dc66:          * @param related Action related object.
1:414dc66:          */
1:414dc66:         private void trackAdding(final S item, final R related) {
1:414dc66:             if (DEBUG) {
1:414dc66:                 System.out.println("AbstractTracked.trackAdding: " + item); //$NON-NLS-1$
1:414dc66:             }
1:414dc66:             T object = null;
1:414dc66:             boolean becameUntracked = false;
1:414dc66:             /* Call customizer outside of synchronized region */
1:414dc66:             try {
1:414dc66:                 object = customizerAdding(item, related);
1:414dc66:                 /*
1:414dc66:                  * If the customizer throws an unchecked exception, it will
1:414dc66:                  * propagate after the finally
1:414dc66:                  */
1:414dc66:             } finally {
1:414dc66:                 synchronized (this) {
1:414dc66:                     if (adding.remove(item) && !closed) {
1:414dc66:                         /*
1:414dc66:                          * if the item was not untracked during the customizer
1:414dc66:                          * callback
1:414dc66:                          */
1:414dc66:                         if (object != null) {
1:414dc66:                             tracked.put(item, object);
1:414dc66:                             modified(); /* increment modification count */
1:414dc66:                             notifyAll(); /* notify any waiters */
1:414dc66:                         }
1:414dc66:                     } else {
1:414dc66:                         becameUntracked = true;
1:414dc66:                     }
1:414dc66:                 }
1:414dc66:             }
1:6df3ad3:             /*
1:414dc66:              * The item became untracked during the customizer callback.
1:414dc66:              */
1:414dc66:             if (becameUntracked && (object != null)) {
1:414dc66:                 if (DEBUG) {
1:414dc66:                     System.out.println("AbstractTracked.trackAdding[removed]: " + item); //$NON-NLS-1$
1:414dc66:                 }
1:414dc66:                 /* Call customizer outside of synchronized region */
1:414dc66:                 customizerRemoved(item, related, object);
1:414dc66:                 /*
1:414dc66:                  * If the customizer throws an unchecked exception, it is safe to
1:414dc66:                  * let it propagate
1:414dc66:                  */
1:6df3ad3:             }
1:6df3ad3:         }
1:6df3ad3: 
1:414dc66:         /**
1:414dc66:          * Discontinue tracking the item.
1:414dc66:          *
1:414dc66:          * @param item    Item to be untracked.
1:414dc66:          * @param related Action related object.
1:414dc66:          */
1:414dc66:         void untrack(final S item, final R related) {
1:414dc66:             final T object;
1:414dc66:             synchronized (this) {
1:414dc66:                 if (initial.remove(item)) { /*
1:414dc66: 										     * if this item is already in the list
1:414dc66: 										     * of initial references to process
1:414dc66: 										     */
1:414dc66:                     if (DEBUG) {
1:414dc66:                         System.out.println("AbstractTracked.untrack[removed from initial]: " + item); //$NON-NLS-1$
1:414dc66:                     }
1:414dc66:                     return; /*
1:414dc66: 						     * we have removed it from the list and it will not be
1:414dc66: 						     * processed
1:414dc66: 						     */
1:414dc66:                 }
1:414dc66: 
1:414dc66:                 if (adding.remove(item)) { /*
1:414dc66: 										    * if the item is in the process of
1:414dc66: 										    * being added
1:414dc66: 										    */
1:414dc66:                     if (DEBUG) {
1:414dc66:                         System.out.println("AbstractTracked.untrack[being added]: " + item); //$NON-NLS-1$
1:414dc66:                     }
1:414dc66:                     return; /*
1:414dc66: 						     * in case the item is untracked while in the process of
1:414dc66: 						     * adding
1:414dc66: 						     */
1:414dc66:                 }
1:414dc66:                 object = tracked.remove(item); /*
1:414dc66: 											    * must remove from tracker before
1:414dc66: 											    * calling customizer callback
1:414dc66: 											    */
1:414dc66:                 if (object == null) { /* are we actually tracking the item */
1:414dc66:                     return;
1:414dc66:                 }
1:414dc66:                 modified(); /* increment modification count */
1:414dc66:             }
1:414dc66:             if (DEBUG) {
1:414dc66:                 System.out.println("AbstractTracked.untrack[removed]: " + item); //$NON-NLS-1$
1:414dc66:             }
1:414dc66:             /* Call customizer outside of synchronized region */
1:414dc66:             customizerRemoved(item, related, object);
1:6df3ad3:             /*
1:414dc66:              * If the customizer throws an unchecked exception, it is safe to let it
1:414dc66:              * propagate
1:414dc66:              */
1:6df3ad3:         }
1:6df3ad3: 
1:414dc66:         /**
1:414dc66:          * Returns the number of tracked items.
1:414dc66:          *
1:414dc66:          * @return The number of tracked items.
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         int size() {
1:414dc66:             return tracked.size();
1:6df3ad3:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Returns if the tracker is empty.
1:414dc66:          *
1:414dc66:          * @return Whether the tracker is empty.
1:414dc66:          * @GuardedBy this
1:414dc66:          * @since 1.5
1:414dc66:          */
1:414dc66:         boolean isEmpty() {
1:414dc66:             return tracked.isEmpty();
1:6df3ad3:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Return the customized object for the specified item
1:414dc66:          *
1:414dc66:          * @param item The item to lookup in the map
1:414dc66:          * @return The customized object for the specified item.
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         T getCustomizedObject(final S item) {
1:414dc66:             return tracked.get(item);
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Copy the tracked items into an array.
1:414dc66:          *
1:414dc66:          * @param list An array to contain the tracked items.
1:414dc66:          * @return The specified list if it is large enough to hold the tracked
1:414dc66:          *         items or a new array large enough to hold the tracked items.
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         S[] copyKeys(final S[] list) {
1:414dc66:             return tracked.keySet().toArray(list);
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Increment the modification count. If this method is overridden, the
1:414dc66:          * overriding method MUST call this method to increment the tracking count.
1:414dc66:          *
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         void modified() {
1:414dc66:             trackingCount++;
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Returns the tracking count for this {@code ServiceTracker} object.
1:414dc66:          * <p/>
1:414dc66:          * The tracking count is initialized to 0 when this object is opened. Every
1:414dc66:          * time an item is added, modified or removed from this object the tracking
1:414dc66:          * count is incremented.
1:414dc66:          *
1:414dc66:          * @return The tracking count for this object.
1:414dc66:          * @GuardedBy this
1:414dc66:          */
1:414dc66:         int getTrackingCount() {
1:414dc66:             return trackingCount;
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Copy the tracked items and associated values into the specified map.
1:414dc66:          *
1:414dc66:          * @param <M> Type of {@code Map} to hold the tracked items and
1:414dc66:          *            associated values.
1:414dc66:          * @param map The map into which to copy the tracked items and associated
1:414dc66:          *            values. This map must not be a user provided map so that user code
1:414dc66:          *            is not executed while synchronized on this.
1:414dc66:          * @return The specified map.
1:414dc66:          * @GuardedBy this
1:414dc66:          * @since 1.5
1:414dc66:          */
1:414dc66:         <M extends Map<? super S, ? super T>> M copyEntries(final M map) {
1:414dc66:             map.putAll(tracked);
1:414dc66:             return map;
1:414dc66:         }
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Call the specific customizer adding method. This method must not be
1:414dc66:          * called while synchronized on this object.
1:414dc66:          *
1:414dc66:          * @param item    Item to be tracked.
1:414dc66:          * @param related Action related object.
1:414dc66:          * @return Customized object for the tracked item or {@code null} if
1:414dc66:          *         the item is not to be tracked.
1:414dc66:          */
1:414dc66:         abstract T customizerAdding(final S item, final R related);
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Call the specific customizer modified method. This method must not be
1:414dc66:          * called while synchronized on this object.
1:414dc66:          *
1:414dc66:          * @param item    Tracked item.
1:414dc66:          * @param related Action related object.
1:414dc66:          * @param object  Customized object for the tracked item.
1:414dc66:          */
1:414dc66:         abstract void customizerModified(final S item, final R related,
1:414dc66:                                          final T object);
1:414dc66: 
1:414dc66:         /**
1:414dc66:          * Call the specific customizer removed method. This method must not be
1:414dc66:          * called while synchronized on this object.
1:414dc66:          *
1:414dc66:          * @param item    Tracked item.
1:414dc66:          * @param related Action related object.
1:414dc66:          * @param object  Customized object for the tracked item.
1:414dc66:          */
1:414dc66:         abstract void customizerRemoved(final S item, final R related,
1:414dc66:                                         final T object);
1:6df3ad3:     }
1:6df3ad3: 
1:6df3ad3: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:414dc66
/////////////////////////////////////////////////////////////////////////
1:     /* set this to true to compile in debug messages */
1:     static final boolean				DEBUG	= false;
1:     /**
1:      * The Bundle Context used by this {@code BundleTracker}.
1:      */
1:     protected final BundleContext context;
1:     /**
1:      * The {@code BundleTrackerCustomizer} object for this tracker.
1:      */
1:     final BundleTrackerCustomizer customizer;
1:     /**
1:      * Tracked bundles: {@code Bundle} object -> customized Object and
1:      * {@code BundleListener} object
1:      */
1:     private volatile Tracked tracked;
1: 
1:     /**
1:      * Accessor method for the current Tracked object. This method is only
1:      * intended to be used by the unsynchronized methods which do not modify the
1:      * tracked field.
1:      *
1:      * @return The current Tracked object.
1:      */
1:     private Tracked tracked() {
1:         return tracked;
1:     }
1: 
1:     /**
1:      * State mask for bundles being tracked. This field contains the ORed values
1:      * of the bundle states being tracked.
1:      */
1:     private final int mask;
1: 
1:     /**
1:      * BundleHook service registration
1:      */
1:     private ServiceRegistration sr;
1: 
1:     /**
1:      * Create a {@code BundleTracker} for bundles whose state is present in the
1:      * specified state mask.
1:      *
1:      * <p>
1:      * Bundles whose state is present on the specified state mask will be
1:      * tracked by this {@code BundleTracker}.
1:      *
1:      * @param context The {@code BundleContext} against which the tracking is
1:      *        done.
1:      * @param stateMask The bit mask of the {@code OR}ing of the bundle states
1:      *        to be tracked.
1:      * @param customizer The customizer object to call when bundles are added,
1:      *        modified, or removed in this {@code BundleTracker}. If customizer
1:      *        is {@code null}, then this {@code BundleTracker} will be used as
1:      *        the {@code BundleTrackerCustomizer} and this {@code BundleTracker}
1:      *        will call the {@code BundleTrackerCustomizer} methods on itself.
1:      * @see Bundle#getState()
1:      */
1:     public BundleHookBundleTracker(BundleContext context, int stateMask, BundleTrackerCustomizer customizer) {
1:         super(context, stateMask, customizer);
1:         this.context = context;
1:         this.mask = stateMask;
1:         this.customizer = customizer == null ? this : customizer;
1:     }
1: 
1:     /**
1:      * Open this {@code BundleTracker} and begin tracking bundles.
1:      *
1:      * <p>
1:      * Bundle which match the state criteria specified when this
1:      * {@code BundleTracker} was created are now tracked by this
1:      * {@code BundleTracker}.
1:      *
1:      * @throws java.lang.IllegalStateException If the {@code BundleContext} with
1:      *         which this {@code BundleTracker} was created is no longer valid.
1:      * @throws java.lang.SecurityException If the caller and this class do not
1:      *         have the appropriate
1:      *         {@code AdminPermission[context bundle,LISTENER]}, and the Java
1:      *         Runtime Environment supports permissions.
1:      */
1:     @Override
1:     public void open() {
1:         final Tracked t;
1:         synchronized (this) {
1:             if (tracked != null) {
1:                 return;
1:             }
1:             t = new Tracked();
1:             synchronized (t) {
1:                 EventHook hook = new BundleEventHook(t);
1:                 sr = context.registerService(EventHook.class.getName(), hook, null);
1:                 Bundle[] bundles = context.getBundles();
1:                 if (bundles != null) {
1:                     int length = bundles.length;
1:                     for (int i = 0; i < length; i++) {
1:                         int state = bundles[i].getState();
1:                         if ((state & mask) == 0) {
1:                             /* null out bundles whose states are not interesting */
1:                             bundles[i] = null;
1:                         }
1:                     }
1:                     /* set tracked with the initial bundles */
1:                     t.setInitial(bundles);
1:                 }
1:             }
1:             tracked = t;
1:         /* Call tracked outside of synchronized region */
1:         tracked.trackInitial(); /* process the initial references */
1:     /**
1:      * Close this {@code BundleTracker}.
1:      *
1:      * <p>
1:      * This method should be called when this {@code BundleTracker} should end
1:      * the tracking of bundles.
1:      *
1:      * <p>
1:      * This implementation calls {@link #getBundles()} to get the list of
1:      * tracked bundles to remove.
1:      */
1:     public void close() {
1:         final Bundle[] bundles;
1:         final Tracked outgoing;
1:         synchronized (this) {
1:             outgoing = tracked;
1:             if (outgoing == null) {
1:                 return;
1:             }
1:             if (DEBUG) {
1:                 System.out.println("BundleTracker.close"); //$NON-NLS-1$
1:             }
1:             tracked.close();
1:             bundles = getBundles();
1:             tracked = null;
1:             try {
1:                 sr.unregister();
1:             } catch (IllegalStateException e) {
1: 				/* In case the context was stopped. */
1:             }
1:         if (bundles != null) {
1:             for (int i = 0; i < bundles.length; i++) {
1:                 outgoing.untrack(bundles[i], null);
1:             }
1:         }
1:     /**
1:      * Default implementation of the
1:      * {@code BundleTrackerCustomizer.addingBundle} method.
1:      *
1:      * <p>
1:      * This method is only called when this {@code BundleTracker} has been
1:      * constructed with a {@code null BundleTrackerCustomizer} argument.
1:      *
1:      * <p>
1:      * This implementation simply returns the specified {@code Bundle}.
1:      *
1:      * <p>
1:      * This method can be overridden in a subclass to customize the object to be
1:      * tracked for the bundle being added.
1:      *
1:      * @param bundle The {@code Bundle} being added to this
1:      *        {@code BundleTracker} object.
1:      * @param event The bundle event which caused this customizer method to be
1:      *        called or {@code null} if there is no bundle event associated with
1:      *        the call to this method.
1:      * @return The specified bundle.
1:      * @see BundleTrackerCustomizer#addingBundle(Bundle, BundleEvent)
1:      */
1:     public Object addingBundle(Bundle bundle, BundleEvent event) {
1:         T result = (T) bundle;
1:         return result;
1:     /**
1:      * Default implementation of the
1:      * {@code BundleTrackerCustomizer.modifiedBundle} method.
1:      *
1:      * <p>
1:      * This method is only called when this {@code BundleTracker} has been
1:      * constructed with a {@code null BundleTrackerCustomizer} argument.
1:      *
1:      * <p>
1:      * This implementation does nothing.
1:      *
1:      * @param bundle The {@code Bundle} whose state has been modified.
1:      * @param event The bundle event which caused this customizer method to be
1:      *        called or {@code null} if there is no bundle event associated with
1:      *        the call to this method.
1:      * @param object The customized object for the specified Bundle.
1:      * @see BundleTrackerCustomizer#modifiedBundle(Bundle, BundleEvent, Object)
1:      */
1:     public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) {
1: 		/* do nothing */
1:     }
1: 
1:     /**
1:      * Default implementation of the
1:      * {@code BundleTrackerCustomizer.removedBundle} method.
1:      *
1:      * <p>
1:      * This method is only called when this {@code BundleTracker} has been
1:      * constructed with a {@code null BundleTrackerCustomizer} argument.
1:      *
1:      * <p>
1:      * This implementation does nothing.
1:      *
1:      * @param bundle The {@code Bundle} being removed.
1:      * @param event The bundle event which caused this customizer method to be
1:      *        called or {@code null} if there is no bundle event associated with
1:      *        the call to this method.
1:      * @param object The customized object for the specified bundle.
1:      * @see BundleTrackerCustomizer#removedBundle(Bundle, BundleEvent, Object)
1:      */
1:     @Override
1:     public void removedBundle(Bundle bundle, BundleEvent event, Object object) {
1:         /* do nothing */
1:     }
1: 
1:     /**
1:      * Return an array of {@code Bundle}s for all bundles being tracked by this
1:      * {@code BundleTracker}.
1:      *
1:      * @return An array of {@code Bundle}s or {@code null} if no bundles are
1:      *         being tracked.
1:      */
1:     public Bundle[] getBundles() {
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return null;
1:         }
1:         synchronized (t) {
1:             int length = t.size();
1:             if (length == 0) {
1:                 return null;
1:             }
1:             return t.copyKeys(new Bundle[length]);
1:         }
1:     }
1: 
1:     /**
1:      * Returns the customized object for the specified {@code Bundle} if the
1:      * specified bundle is being tracked by this {@code BundleTracker}.
1:      *
1:      * @param bundle The {@code Bundle} being tracked.
1:      * @return The customized object for the specified {@code Bundle} or
1:      *         {@code null} if the specified {@code Bundle} is not being
1:      *         tracked.
1:      */
1:     public T getObject(Bundle bundle) {
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return null;
1:         }
1:         synchronized (t) {
1:             return t.getCustomizedObject(bundle);
1:         }
1:     }
1: 
1:     /**
1:      * Remove a bundle from this {@code BundleTracker}.
1:      *
1:      * The specified bundle will be removed from this {@code BundleTracker} . If
1:      * the specified bundle was being tracked then the
1:      * {@code BundleTrackerCustomizer.removedBundle} method will be called for
1:      * that bundle.
1:      *
1:      * @param bundle The {@code Bundle} to be removed.
1:      */
1:     public void remove(Bundle bundle) {
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return;
1:         }
1:         t.untrack(bundle, null);
1:     }
1: 
1:     /**
1:      * Return the number of bundles being tracked by this {@code BundleTracker}.
1:      *
1:      * @return The number of bundles being tracked.
1:      */
1:     public int size() {
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return 0;
1:         }
1:         synchronized (t) {
1:             return t.size();
1:         }
1:     }
1: 
1:     /**
1:      * Returns the tracking count for this {@code BundleTracker}.
1:      *
1:      * The tracking count is initialized to 0 when this {@code BundleTracker} is
1:      * opened. Every time a bundle is added, modified or removed from this
1:      * {@code BundleTracker} the tracking count is incremented.
1:      *
1:      * <p>
1:      * The tracking count can be used to determine if this {@code BundleTracker}
1:      * has added, modified or removed a bundle by comparing a tracking count
1:      * value previously collected with the current tracking count value. If the
1:      * value has not changed, then no bundle has been added, modified or removed
1:      * from this {@code BundleTracker} since the previous tracking count was
1:      * collected.
1:      *
1:      * @return The tracking count for this {@code BundleTracker} or -1 if this
1:      *         {@code BundleTracker} is not open.
1:      */
1:     public int getTrackingCount() {
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return -1;
1:         }
1:         synchronized (t) {
1:             return t.getTrackingCount();
1:         }
1:     }
1: 
1:     /**
1:      * Return a {@code Map} with the {@code Bundle}s and customized objects for
1:      * all bundles being tracked by this {@code BundleTracker}.
1:      *
1:      * @return A {@code Map} with the {@code Bundle}s and customized objects for
1:      *         all services being tracked by this {@code BundleTracker}. If no
1:      *         bundles are being tracked, then the returned map is empty.
1:      * @since 1.5
1:      */
1:     public Map<Bundle, T> getTracked() {
1:         Map<Bundle, T> map = new HashMap<Bundle, T>();
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return map;
1:         }
1:         synchronized (t) {
1:             return t.copyEntries(map);
1:         }
1:     }
1: 
1:     /**
1:      * Return if this {@code BundleTracker} is empty.
1:      *
1:      * @return {@code true} if this {@code BundleTracker} is not tracking any
1:      *         bundles.
1:      * @since 1.5
1:      */
1:     public boolean isEmpty() {
1:         final Tracked t = tracked();
1:         if (t == null) { /* if BundleTracker is not open */
1:             return true;
1:         }
1:         synchronized (t) {
1:             return t.isEmpty();
1:         }
1:         private final Tracked tracked;
1:         private BundleEventHook(Tracked tracked) {
1:             this.tracked = tracked;
1: 
1:         public void event(BundleEvent bundleEvent, Collection bundleContexts) {
1:             tracked.bundleChanged(bundleEvent);
1:      * Inner class which subclasses AbstractTracked. This class is the
1:      * {@code SynchronousBundleListener} object for the tracker.
1:      *
1:      * @ThreadSafe
1:      * @since 1.4
1:     private final class Tracked extends AbstractTracked<Bundle, T, BundleEvent> implements SynchronousBundleListener {
1:         /**
1:          * Tracked constructor.
1:          */
1:         Tracked() {
1:             super();
1:         }
1: 
1:         /**
1:          * {@code BundleListener} method for the {@code BundleTracker}
1:          * class. This method must NOT be synchronized to avoid deadlock
1:          * potential.
1:          *
1:          * @param event {@code BundleEvent} object from the framework.
1:          */
1:         public void bundleChanged(final BundleEvent event) {
1:              * Check if we had a delayed call (which could happen when we
1:              * close).
1:              */
1:             if (closed) {
1:                 return;
1:             final Bundle bundle = event.getBundle();
1:             final int state = bundle.getState();
1:             if (DEBUG) {
1:                 System.out.println("BundleTracker.Tracked.bundleChanged[" + state + "]: " + bundle); //$NON-NLS-1$ //$NON-NLS-2$
1:             }
1: 
1:             if ((state & mask) != 0) {
1:                 track(bundle, event);
1:                 /*
1:                  * If the customizer throws an unchecked exception, it is safe
1:                  * to let it propagate
1:                  */
1:             } else {
1:                 untrack(bundle, event);
1:                 /*
1:                  * If the customizer throws an unchecked exception, it is safe
1:                  * to let it propagate
1:                  */
1:             }
1:         }
1: 
1:         /**
1:          * Call the specific customizer adding method. This method must not be
1:          * called while synchronized on this object.
1:          *
1:          * @param item    Item to be tracked.
1:          * @param related Action related object.
1:          * @return Customized object for the tracked item or {@code null}
1:          *         if the item is not to be tracked.
1:          */
1:         T customizerAdding(final Bundle item, final BundleEvent related) {
1:             return (T) customizer.addingBundle(item, related);
1:         }
1: 
1:         /**
1:          * Call the specific customizer modified method. This method must not be
1:          * called while synchronized on this object.
1:          *
1:          * @param item    Tracked item.
1:          * @param related Action related object.
1:          * @param object  Customized object for the tracked item.
1:          */
1:         void customizerModified(final Bundle item, final BundleEvent related,
1:                                 final T object) {
1:             customizer.modifiedBundle(item, related, object);
1:         }
1: 
1:         /**
1:          * Call the specific customizer removed method. This method must not be
1:          * called while synchronized on this object.
1:          *
1:          * @param item    Tracked item.
1:          * @param related Action related object.
1:          * @param object  Customized object for the tracked item.
1:          */
1:         void customizerRemoved(final Bundle item, final BundleEvent related,
1:                                final T object) {
1:             customizer.removedBundle(item, related, object);
1:         }
1:     }
1: 
1:     /**
1:      * Abstract class to track items. If a Tracker is reused (closed then reopened),
1:      * then a new AbstractTracked object is used. This class acts a map of tracked
1:      * item -> customized object. Subclasses of this class will act as the listener
1:      * object for the tracker. This class is used to synchronize access to the
1:      * tracked items. This is not a public class. It is only for use by the
1:      * implementation of the Tracker class.
1:      *
1:      * @param <S> The tracked item. It is the key.
1:      * @param <T> The value mapped to the tracked item.
1:      * @param <R> The reason the tracked item is being tracked or untracked.
1:      * @version $Id: 79452e6c28683021f2bcf11d3689ec75c6b5642f $
1:      * @ThreadSafe
1:      * @since 1.4
1:      */
1:     private static abstract class AbstractTracked<S, T, R> {
1:         /* set this to true to compile in debug messages */
1:         static final boolean DEBUG = false;
1: 
1:         /**
1:          * Map of tracked items to customized objects.
1:          *
1:          * @GuardedBy this
1:          */
1:         private final Map<S, T> tracked;
1: 
1:         /**
1:          * Modification count. This field is initialized to zero and incremented by
1:          * modified.
1:          *
1:          * @GuardedBy this
1:          */
1:         private int trackingCount;
1: 
1:         /**
1:          * List of items in the process of being added. This is used to deal with
1:          * nesting of events. Since events may be synchronously delivered, events
1:          * can be nested. For example, when processing the adding of a service and
1:          * the customizer causes the service to be unregistered, notification to the
1:          * nested call to untrack that the service was unregistered can be made to
1:          * the track method.
1:          * <p/>
1:          * Since the ArrayList implementation is not synchronized, all access to
1:          * this list must be protected by the same synchronized object for
1:          * thread-safety.
1:          *
1:          * @GuardedBy this
1:          */
1:         private final List<S> adding;
1: 
1:         /**
1:          * true if the tracked object is closed.
1:          * <p/>
1:          * This field is volatile because it is set by one thread and read by
1:          * another.
1:          */
1:         volatile boolean closed;
1: 
1:         /**
1:          * Initial list of items for the tracker. This is used to correctly process
1:          * the initial items which could be modified before they are tracked. This
1:          * is necessary since the initial set of tracked items are not "announced"
1:          * by events and therefore the event which makes the item untracked could be
1:          * delivered before we track the item.
1:          * <p/>
1:          * An item must not be in both the initial and adding lists at the same
1:          * time. An item must be moved from the initial list to the adding list
1:          * "atomically" before we begin tracking it.
1:          * <p/>
1:          * Since the LinkedList implementation is not synchronized, all access to
1:          * this list must be protected by the same synchronized object for
1:          * thread-safety.
1:          *
1:          * @GuardedBy this
1:          */
1:         private final LinkedList<S> initial;
1: 
1:         /**
1:          * AbstractTracked constructor.
1:          */
1:         AbstractTracked() {
1:             tracked = new HashMap<S, T>();
1:             trackingCount = 0;
1:             adding = new ArrayList<S>(6);
1:             initial = new LinkedList<S>();
1:             closed = false;
1:         }
1: 
1:         /**
1:          * Set initial list of items into tracker before events begin to be
1:          * received.
1:          * <p/>
1:          * This method must be called from Tracker's open method while synchronized
1:          * on this object in the same synchronized block as the add listener call.
1:          *
1:          * @param list The initial list of items to be tracked. {@code null}
1:          *             entries in the list are ignored.
1:          * @GuardedBy this
1:          */
1:         void setInitial(S[] list) {
1:             if (list == null) {
1:                 return;
1:             }
1:             for (S item : list) {
1:                 if (item == null) {
1:                     continue;
1:                 }
1:                 if (DEBUG) {
1:                     System.out.println("AbstractTracked.setInitial: " + item); //$NON-NLS-1$
1:                 }
1:                 initial.add(item);
1:             }
1:         }
1: 
1:         /**
1:          * Track the initial list of items. This is called after events can begin to
1:          * be received.
1:          * <p/>
1:          * This method must be called from Tracker's open method while not
1:          * synchronized on this object after the add listener call.
1:          */
1:         void trackInitial() {
1:             while (true) {
1:                 S item;
1:                 synchronized (this) {
1:                     if (closed || (initial.size() == 0)) {
1:                         /*
1:                          * if there are no more initial items
1:                          */
1:                         return; /* we are done */
1:                     }
1:                     /*
1:                     * move the first item from the initial list to the adding list
1:                     * within this synchronized block.
1:                     */
1:                     item = initial.removeFirst();
1:                     if (tracked.get(item) != null) {
1:                         /* if we are already tracking this item */
1:                         if (DEBUG) {
1:                             System.out.println("AbstractTracked.trackInitial[already tracked]: " + item); //$NON-NLS-1$
1:                         }
1:                         continue; /* skip this item */
1:                     }
1:                     if (adding.contains(item)) {
1:                         /*
1:                          * if this item is already in the process of being added.
1:                          */
1:                         if (DEBUG) {
1:                             System.out.println("AbstractTracked.trackInitial[already adding]: " + item); //$NON-NLS-1$
1:                         }
1:                         continue; /* skip this item */
1:                     }
1:                     adding.add(item);
1:                 }
1:                 if (DEBUG) {
1:                     System.out.println("AbstractTracked.trackInitial: " + item); //$NON-NLS-1$
1:                 }
1:                 trackAdding(item, null); /*
1:                                           * Begin tracking it. We call trackAdding
1: 									      * since we have already put the item in the
1: 									      * adding list.
1: 									      */
1:             }
1:         }
1: 
1:         /**
1:          * Called by the owning Tracker object when it is closed.
1:          */
1:         void close() {
1:             closed = true;
1:         }
1: 
1:         /**
1:          * Begin to track an item.
1:          *
1:          * @param item    Item to be tracked.
1:          * @param related Action related object.
1:          */
1:         void track(final S item, final R related) {
1:             final T object;
1:             synchronized (this) {
1:                 if (closed) {
1:                     return;
1:                 }
1:                 object = tracked.get(item);
1:                 if (object == null) { /* we are not tracking the item */
1:                     if (adding.contains(item)) {
1:                         /* if this item is already in the process of being added. */
1:                         if (DEBUG) {
1:                             System.out
1:                                     .println("AbstractTracked.track[already adding]: " + item); //$NON-NLS-1$
1:                         }
1:                         return;
1:                     }
1:                     adding.add(item); /* mark this item is being added */
1:                 } else { /* we are currently tracking this item */
1:                     if (DEBUG) {
1:                         System.out
1:                                 .println("AbstractTracked.track[modified]: " + item); //$NON-NLS-1$
1:                     }
1:                     modified(); /* increment modification count */
1:                 }
1:             }
1: 
1:             if (object == null) { /* we are not tracking the item */
1:                 trackAdding(item, related);
1:             } else {
1:                 /* Call customizer outside of synchronized region */
1:                 customizerModified(item, related, object);
1:                 /*
1:                  * If the customizer throws an unchecked exception, it is safe to
1:                  * let it propagate
1:                  */
1:             }
1:         }
1: 
1:         /**
1:          * Common logic to add an item to the tracker used by track and
1:          * trackInitial. The specified item must have been placed in the adding list
1:          * before calling this method.
1:          *
1:          * @param item    Item to be tracked.
1:          * @param related Action related object.
1:          */
1:         private void trackAdding(final S item, final R related) {
1:             if (DEBUG) {
1:                 System.out.println("AbstractTracked.trackAdding: " + item); //$NON-NLS-1$
1:             }
1:             T object = null;
1:             boolean becameUntracked = false;
1:             /* Call customizer outside of synchronized region */
1:             try {
1:                 object = customizerAdding(item, related);
1:                 /*
1:                  * If the customizer throws an unchecked exception, it will
1:                  * propagate after the finally
1:                  */
1:             } finally {
1:                 synchronized (this) {
1:                     if (adding.remove(item) && !closed) {
1:                         /*
1:                          * if the item was not untracked during the customizer
1:                          * callback
1:                          */
1:                         if (object != null) {
1:                             tracked.put(item, object);
1:                             modified(); /* increment modification count */
1:                             notifyAll(); /* notify any waiters */
1:                         }
1:                     } else {
1:                         becameUntracked = true;
1:                     }
1:                 }
1:             }
1:              * The item became untracked during the customizer callback.
1:              */
1:             if (becameUntracked && (object != null)) {
1:                 if (DEBUG) {
1:                     System.out.println("AbstractTracked.trackAdding[removed]: " + item); //$NON-NLS-1$
1:                 }
1:                 /* Call customizer outside of synchronized region */
1:                 customizerRemoved(item, related, object);
1:                 /*
1:                  * If the customizer throws an unchecked exception, it is safe to
1:                  * let it propagate
1:                  */
1:         /**
1:          * Discontinue tracking the item.
1:          *
1:          * @param item    Item to be untracked.
1:          * @param related Action related object.
1:          */
1:         void untrack(final S item, final R related) {
1:             final T object;
1:             synchronized (this) {
1:                 if (initial.remove(item)) { /*
1: 										     * if this item is already in the list
1: 										     * of initial references to process
1: 										     */
1:                     if (DEBUG) {
1:                         System.out.println("AbstractTracked.untrack[removed from initial]: " + item); //$NON-NLS-1$
1:                     }
1:                     return; /*
1: 						     * we have removed it from the list and it will not be
1: 						     * processed
1: 						     */
1:                 }
1: 
1:                 if (adding.remove(item)) { /*
1: 										    * if the item is in the process of
1: 										    * being added
1: 										    */
1:                     if (DEBUG) {
1:                         System.out.println("AbstractTracked.untrack[being added]: " + item); //$NON-NLS-1$
1:                     }
1:                     return; /*
1: 						     * in case the item is untracked while in the process of
1: 						     * adding
1: 						     */
1:                 }
1:                 object = tracked.remove(item); /*
1: 											    * must remove from tracker before
1: 											    * calling customizer callback
1: 											    */
1:                 if (object == null) { /* are we actually tracking the item */
1:                     return;
1:                 }
1:                 modified(); /* increment modification count */
1:             }
1:             if (DEBUG) {
1:                 System.out.println("AbstractTracked.untrack[removed]: " + item); //$NON-NLS-1$
1:             }
1:             /* Call customizer outside of synchronized region */
1:             customizerRemoved(item, related, object);
1:              * If the customizer throws an unchecked exception, it is safe to let it
1:              * propagate
1:              */
1:         /**
1:          * Returns the number of tracked items.
1:          *
1:          * @return The number of tracked items.
1:          * @GuardedBy this
1:          */
1:         int size() {
1:             return tracked.size();
1: 
1:         /**
1:          * Returns if the tracker is empty.
1:          *
1:          * @return Whether the tracker is empty.
1:          * @GuardedBy this
1:          * @since 1.5
1:          */
1:         boolean isEmpty() {
1:             return tracked.isEmpty();
1: 
1:         /**
1:          * Return the customized object for the specified item
1:          *
1:          * @param item The item to lookup in the map
1:          * @return The customized object for the specified item.
1:          * @GuardedBy this
1:          */
1:         T getCustomizedObject(final S item) {
1:             return tracked.get(item);
1:         }
1: 
1:         /**
1:          * Copy the tracked items into an array.
1:          *
1:          * @param list An array to contain the tracked items.
1:          * @return The specified list if it is large enough to hold the tracked
1:          *         items or a new array large enough to hold the tracked items.
1:          * @GuardedBy this
1:          */
1:         S[] copyKeys(final S[] list) {
1:             return tracked.keySet().toArray(list);
1:         }
1: 
1:         /**
1:          * Increment the modification count. If this method is overridden, the
1:          * overriding method MUST call this method to increment the tracking count.
1:          *
1:          * @GuardedBy this
1:          */
1:         void modified() {
1:             trackingCount++;
1:         }
1: 
1:         /**
1:          * Returns the tracking count for this {@code ServiceTracker} object.
1:          * <p/>
1:          * The tracking count is initialized to 0 when this object is opened. Every
1:          * time an item is added, modified or removed from this object the tracking
1:          * count is incremented.
1:          *
1:          * @return The tracking count for this object.
1:          * @GuardedBy this
1:          */
1:         int getTrackingCount() {
1:             return trackingCount;
1:         }
1: 
1:         /**
1:          * Copy the tracked items and associated values into the specified map.
1:          *
1:          * @param <M> Type of {@code Map} to hold the tracked items and
1:          *            associated values.
1:          * @param map The map into which to copy the tracked items and associated
1:          *            values. This map must not be a user provided map so that user code
1:          *            is not executed while synchronized on this.
1:          * @return The specified map.
1:          * @GuardedBy this
1:          * @since 1.5
1:          */
1:         <M extends Map<? super S, ? super T>> M copyEntries(final M map) {
1:             map.putAll(tracked);
1:             return map;
1:         }
1: 
1:         /**
1:          * Call the specific customizer adding method. This method must not be
1:          * called while synchronized on this object.
1:          *
1:          * @param item    Item to be tracked.
1:          * @param related Action related object.
1:          * @return Customized object for the tracked item or {@code null} if
1:          *         the item is not to be tracked.
1:          */
1:         abstract T customizerAdding(final S item, final R related);
1: 
1:         /**
1:          * Call the specific customizer modified method. This method must not be
1:          * called while synchronized on this object.
1:          *
1:          * @param item    Tracked item.
1:          * @param related Action related object.
1:          * @param object  Customized object for the tracked item.
1:          */
1:         abstract void customizerModified(final S item, final R related,
1:                                          final T object);
1: 
1:         /**
1:          * Call the specific customizer removed method. This method must not be
1:          * called while synchronized on this object.
1:          *
1:          * @param item    Tracked item.
1:          * @param related Action related object.
1:          * @param object  Customized object for the tracked item.
1:          */
1:         abstract void customizerRemoved(final S item, final R related,
1:                                         final T object);
commit:f128c13
/////////////////////////////////////////////////////////////////////////
0:     synchronized (this) {
0:       tracked = new Tracked();
0:       Bundle[] bundles = context.getBundles();
0:       if (bundles != null) {
0:         int length = bundles.length;
0:         for (int i = 0; i < length; i++) {
0:           int state = bundles[i].getState();
0:           if ((state & mask) == 0) {
0:             /* null out bundles whose states are not interesting */
0:             bundles[i] = null;
1:           }
1:         }
0:         /* set tracked with the initial bundles */
0:         tracked.setInitial(bundles);
1:       }
1:     }
0:     tracked.trackInitial();
commit:6cdfa8b
/////////////////////////////////////////////////////////////////////////
author:David Jencks
-------------------------------------------------------------------------------
commit:6df3ad3
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *  http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: 
1: package org.apache.aries.util.tracker.hook;
1: 
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleEvent;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.framework.SynchronousBundleListener;
1: import org.osgi.framework.hooks.bundle.EventHook;
1: import org.osgi.util.tracker.BundleTracker;
1: import org.osgi.util.tracker.BundleTrackerCustomizer;
1: 
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: 
1: /**
1:  * The Tracked and AbstractTracked inner classes are copied from felix framework 4.0.1.
1:  *
1:  * @version $Rev$ $Date$
1:  */
1: public class BundleHookBundleTracker<T> extends BundleTracker {
1: 
1:     static {
1:         Class c = EventHook.class;
1:     }
1: 
0:   private final BundleContext context;
0:   private final int mask;
0:   private final BundleTrackerCustomizer customizer;
0:   private Tracked tracked;
0:   private ServiceRegistration sr;
1: 
0:   public BundleHookBundleTracker(BundleContext context, int stateMask, BundleTrackerCustomizer customizer) {
0:     super(context, stateMask, customizer);
0:     this.context = context;
0:     this.mask = stateMask;
0:     this.customizer = customizer == null ? this : customizer;
1:   }
1: 
1:   @Override
0:   public void open() {
0:     tracked = new Tracked();
0:     EventHook hook = new BundleEventHook(tracked);
0:     sr = context.registerService(EventHook.class.getName(), hook, null);
0:       super.open();
1:   }
1: 
1:   @Override
0:   public void close() {
0:       super.close();
0:     sr.unregister();
0:     tracked.close();
0:     tracked = null;
1:   }
1: 
1:     @Override
0:     public Object addingBundle(Bundle bundle, BundleEvent bundleEvent) {
0:         if (bundleEvent == null) {
0:             tracked.trackInitial(bundle);
1:         }
0:         return null;
1:     }
1: 
1:     @Override
0:     public void modifiedBundle(Bundle bundle, BundleEvent bundleEvent, Object o) {
1:     }
1: 
1:     @Override
0:     public void removedBundle(Bundle bundle, BundleEvent bundleEvent, Object o) {
1:     }
1: 
1:     private class BundleEventHook implements EventHook {
0:     private Tracked tracked;
1: 
0:     private BundleEventHook(Tracked tracked) {
0:       this.tracked = tracked;
1:     }
1: 
0:     public void event(BundleEvent bundleEvent, Collection<BundleContext> bundleContexts) {
0:       tracked.bundleChanged(bundleEvent);
1:     }
1:   }
1: 
1:   /**
0:    * Inner class which subclasses AbstractTracked. This class is the
0:    * {@code SynchronousBundleListener} object for the tracker.
1:    *
0:    * @ThreadSafe
0:    * @since 1.4
1:    */
0:   private final class Tracked extends AbstractTracked<Bundle, T, BundleEvent>
0:       implements
0:       SynchronousBundleListener {
1:     /**
0:      * Tracked constructor.
1:      */
0:     Tracked() {
0:       super();
1:     }
1: 
1:     /**
0:      * {@code BundleListener} method for the {@code BundleTracker}
0:      * class. This method must NOT be synchronized to avoid deadlock
0:      * potential.
1:      *
0:      * @param event {@code BundleEvent} object from the framework.
1:      */
0:     public void bundleChanged(final BundleEvent event) {
1:       /*
0:       * Check if we had a delayed call (which could happen when we
0:       * close).
1:       */
0:       if (closed) {
0:         return;
1:       }
0:       final Bundle bundle = event.getBundle();
0:       final int state = bundle.getState();
0:       if (DEBUG) {
0:         System.out
0:             .println("BundleTracker.Tracked.bundleChanged[" + state + "]: " + bundle); //$NON-NLS-1$ //$NON-NLS-2$
1:       }
1: 
0:       if ((state & mask) != 0) {
0:         track(bundle, event);
1:         /*
0:         * If the customizer throws an unchecked exception, it is safe
0:         * to let it propagate
1:         */
0:       } else {
0:         untrack(bundle, event);
1:         /*
0:         * If the customizer throws an unchecked exception, it is safe
0:         * to let it propagate
1:         */
1:       }
1:     }
1: 
1:     /**
0:      * Call the specific customizer adding method. This method must not be
0:      * called while synchronized on this object.
1:      *
0:      * @param item    Item to be tracked.
0:      * @param related Action related object.
0:      * @return Customized object for the tracked item or {@code null}
0:      *         if the item is not to be tracked.
1:      */
0:     T customizerAdding(final Bundle item, final BundleEvent related) {
0:       return (T)customizer.addingBundle(item, related);
1:     }
1: 
1:     /**
0:      * Call the specific customizer modified method. This method must not be
0:      * called while synchronized on this object.
1:      *
0:      * @param item    Tracked item.
0:      * @param related Action related object.
0:      * @param object  Customized object for the tracked item.
1:      */
0:     void customizerModified(final Bundle item, final BundleEvent related,
0:                             final T object) {
0:       customizer.modifiedBundle(item, related, object);
1:     }
1: 
1:     /**
0:      * Call the specific customizer removed method. This method must not be
0:      * called while synchronized on this object.
1:      *
0:      * @param item    Tracked item.
0:      * @param related Action related object.
0:      * @param object  Customized object for the tracked item.
1:      */
0:     void customizerRemoved(final Bundle item, final BundleEvent related,
0:                            final T object) {
0:       customizer.removedBundle(item, related, object);
1:     }
1:   }
1: 
1:   /**
0:    * Abstract class to track items. If a Tracker is reused (closed then reopened),
0:    * then a new AbstractTracked object is used. This class acts a map of tracked
0:    * item -> customized object. Subclasses of this class will act as the listener
0:    * object for the tracker. This class is used to synchronize access to the
0:    * tracked items. This is not a public class. It is only for use by the
0:    * implementation of the Tracker class.
1:    *
0:    * @param <S> The tracked item. It is the key.
0:    * @param <T> The value mapped to the tracked item.
0:    * @param <R> The reason the tracked item is being tracked or untracked.
0:    * @version $Id: 79452e6c28683021f2bcf11d3689ec75c6b5642f $
0:    * @ThreadSafe
0:    * @since 1.4
1:    */
0:   private static abstract class AbstractTracked<S, T, R> {
0:     /* set this to true to compile in debug messages */
0:     static final boolean DEBUG = false;
1: 
1:     /**
0:      * Map of tracked items to customized objects.
1:      *
0:      * @GuardedBy this
1:      */
0:     private final Map<S, T> tracked;
1: 
1:     /**
0:      * Modification count. This field is initialized to zero and incremented by
0:      * modified.
1:      *
0:      * @GuardedBy this
1:      */
0:     private int trackingCount;
1: 
1:     /**
0:      * List of items in the process of being added. This is used to deal with
0:      * nesting of events. Since events may be synchronously delivered, events
0:      * can be nested. For example, when processing the adding of a service and
0:      * the customizer causes the service to be unregistered, notification to the
0:      * nested call to untrack that the service was unregistered can be made to
0:      * the track method.
0:      * <p/>
0:      * Since the ArrayList implementation is not synchronized, all access to
0:      * this list must be protected by the same synchronized object for
0:      * thread-safety.
1:      *
0:      * @GuardedBy this
1:      */
0:     private final List<S> adding;
1: 
1:     /**
0:      * true if the tracked object is closed.
0:      * <p/>
0:      * This field is volatile because it is set by one thread and read by
0:      * another.
1:      */
0:     volatile boolean closed;
1: 
1:     /**
0:      * Initial list of items for the tracker. This is used to correctly process
0:      * the initial items which could be modified before they are tracked. This
0:      * is necessary since the initial set of tracked items are not "announced"
0:      * by events and therefore the event which makes the item untracked could be
0:      * delivered before we track the item.
0:      * <p/>
0:      * An item must not be in both the initial and adding lists at the same
0:      * time. An item must be moved from the initial list to the adding list
0:      * "atomically" before we begin tracking it.
0:      * <p/>
0:      * Since the LinkedList implementation is not synchronized, all access to
0:      * this list must be protected by the same synchronized object for
0:      * thread-safety.
1:      *
0:      * @GuardedBy this
1:      */
0:     private final LinkedList<S> initial;
1: 
1:     /**
0:      * AbstractTracked constructor.
1:      */
0:     AbstractTracked() {
0:       tracked = new HashMap<S, T>();
0:       trackingCount = 0;
0:       adding = new ArrayList<S>(6);
0:       initial = new LinkedList<S>();
0:       closed = false;
1:     }
1: 
1:     /**
0:      * Set initial list of items into tracker before events begin to be
0:      * received.
0:      * <p/>
0:      * This method must be called from Tracker's open method while synchronized
0:      * on this object in the same synchronized block as the add listener call.
1:      *
0:      * @param list The initial list of items to be tracked. {@code null}
0:      *             entries in the list are ignored.
0:      * @GuardedBy this
1:      */
0:     void setInitial(S[] list) {
0:       if (list == null) {
0:         return;
1:       }
0:       for (S item : list) {
0:         if (item == null) {
0:           continue;
1:         }
0:         if (DEBUG) {
0:           System.out.println("AbstractTracked.setInitial: " + item); //$NON-NLS-1$
1:         }
0:         initial.add(item);
1:       }
1:     }
1: 
1:     /**
0:      * Track the initial list of items. This is called after events can begin to
0:      * be received.
0:      * <p/>
0:      * This method must be called from Tracker's open method while not
0:      * synchronized on this object after the add listener call.
1:      */
0:     void trackInitial() {
0:       while (true) {
0:         S item;
0:         synchronized (this) {
0:           if (closed || (initial.size() == 0)) {
1:             /*
0:                         * if there are no more initial items
1:                         */
0:             return; /* we are done */
1:           }
1:           /*
0:                    * move the first item from the initial list to the adding list
0:                    * within this synchronized block.
1:                    */
0:           item = initial.removeFirst();
0:           if (tracked.get(item) != null) {
0:             /* if we are already tracking this item */
0:             if (DEBUG) {
0:               System.out
0:                   .println("AbstractTracked.trackInitial[already tracked]: " + item); //$NON-NLS-1$
1:             }
0:             continue; /* skip this item */
1:           }
0:           if (adding.contains(item)) {
1:             /*
0:                         * if this item is already in the process of being added.
1:                         */
0:             if (DEBUG) {
0:               System.out
0:                   .println("AbstractTracked.trackInitial[already adding]: " + item); //$NON-NLS-1$
1:             }
0:             continue; /* skip this item */
1:           }
0:           adding.add(item);
1:         }
0:         if (DEBUG) {
0:           System.out.println("AbstractTracked.trackInitial: " + item); //$NON-NLS-1$
1:         }
0:         trackAdding(item, null); /*
0: 									 * Begin tracking it. We call trackAdding
0: 									 * since we have already put the item in the
0: 									 * adding list.
1: 									 */
1:       }
1:     }
1: 
0:       void trackInitial(S item) {
0:         synchronized (this) {
0:           if (closed) {
1:             /*
0:                         * if there are no more initial items
1:                         */
0:             return; /* we are done */
1:           }
1:           /*
0:                    * move the first item from the initial list to the adding list
0:                    * within this synchronized block.
1:                    */
0:           item = initial.removeFirst();
0:           if (tracked.get(item) != null) {
0:             /* if we are already tracking this item */
0:             if (DEBUG) {
0:               System.out
0:                   .println("AbstractTracked.trackInitial[already tracked]: " + item); //$NON-NLS-1$
1:             }
0:             return; /* skip this item */
1:           }
0:           if (adding.contains(item)) {
1:             /*
0:                         * if this item is already in the process of being added.
1:                         */
0:             if (DEBUG) {
0:               System.out
0:                   .println("AbstractTracked.trackInitial[already adding]: " + item); //$NON-NLS-1$
1:             }
0:             return; /* skip this item */
1:           }
0:           adding.add(item);
1:         }
0:         if (DEBUG) {
0:           System.out.println("AbstractTracked.trackInitial: " + item); //$NON-NLS-1$
1:         }
0:         trackAdding(item, null); /*
0: 									 * Begin tracking it. We call trackAdding
0: 									 * since we have already put the item in the
0: 									 * adding list.
1: 									 */
1:     }
1: 
1:     /**
0:      * Called by the owning Tracker object when it is closed.
1:      */
0:     void close() {
0:       closed = true;
1:     }
1: 
1:     /**
0:      * Begin to track an item.
1:      *
0:      * @param item    Item to be tracked.
0:      * @param related Action related object.
1:      */
0:     void track(final S item, final R related) {
0:       final T object;
0:       synchronized (this) {
0:         if (closed) {
0:           return;
1:         }
0:         object = tracked.get(item);
0:         if (object == null) { /* we are not tracking the item */
0:           if (adding.contains(item)) {
0:             /* if this item is already in the process of being added. */
0:             if (DEBUG) {
0:               System.out
0:                   .println("AbstractTracked.track[already adding]: " + item); //$NON-NLS-1$
1:             }
0:             return;
1:           }
0:           adding.add(item); /* mark this item is being added */
0:         } else { /* we are currently tracking this item */
0:           if (DEBUG) {
0:             System.out
0:                 .println("AbstractTracked.track[modified]: " + item); //$NON-NLS-1$
1:           }
0:           modified(); /* increment modification count */
1:         }
1:       }
1: 
0:       if (object == null) { /* we are not tracking the item */
0:         trackAdding(item, related);
0:       } else {
0:         /* Call customizer outside of synchronized region */
0:         customizerModified(item, related, object);
1:         /*
0:                * If the customizer throws an unchecked exception, it is safe to
0:                * let it propagate
1:                */
1:       }
1:     }
1: 
1:     /**
0:      * Common logic to add an item to the tracker used by track and
0:      * trackInitial. The specified item must have been placed in the adding list
0:      * before calling this method.
1:      *
0:      * @param item    Item to be tracked.
0:      * @param related Action related object.
1:      */
0:     private void trackAdding(final S item, final R related) {
0:       if (DEBUG) {
0:         System.out.println("AbstractTracked.trackAdding: " + item); //$NON-NLS-1$
1:       }
0:       T object = null;
0:       boolean becameUntracked = false;
0:       /* Call customizer outside of synchronized region */
0:       try {
0:         object = customizerAdding(item, related);
1:         /*
0:                * If the customizer throws an unchecked exception, it will
0:                * propagate after the finally
1:                */
0:       } finally {
0:         synchronized (this) {
0:           if (adding.remove(item) && !closed) {
1:             /*
0:                         * if the item was not untracked during the customizer
0:                         * callback
1:                         */
0:             if (object != null) {
0:               tracked.put(item, object);
0:               modified(); /* increment modification count */
0:               notifyAll(); /* notify any waiters */
1:             }
0:           } else {
0:             becameUntracked = true;
1:           }
1:         }
1:       }
1:       /*
0:           * The item became untracked during the customizer callback.
1:           */
0:       if (becameUntracked && (object != null)) {
0:         if (DEBUG) {
0:           System.out
0:               .println("AbstractTracked.trackAdding[removed]: " + item); //$NON-NLS-1$
1:         }
0:         /* Call customizer outside of synchronized region */
0:         customizerRemoved(item, related, object);
1:         /*
0:                * If the customizer throws an unchecked exception, it is safe to
0:                * let it propagate
1:                */
1:       }
1:     }
1: 
1:     /**
0:      * Discontinue tracking the item.
1:      *
0:      * @param item    Item to be untracked.
0:      * @param related Action related object.
1:      */
0:     void untrack(final S item, final R related) {
0:       final T object;
0:       synchronized (this) {
0:         if (initial.remove(item)) { /*
0: 										 * if this item is already in the list
0: 										 * of initial references to process
1: 										 */
0:           if (DEBUG) {
0:             System.out
0:                 .println("AbstractTracked.untrack[removed from initial]: " + item); //$NON-NLS-1$
1:           }
0:           return; /*
0: 						 * we have removed it from the list and it will not be
0: 						 * processed
1: 						 */
1:         }
1: 
0:         if (adding.remove(item)) { /*
0: 										 * if the item is in the process of
0: 										 * being added
1: 										 */
0:           if (DEBUG) {
0:             System.out
0:                 .println("AbstractTracked.untrack[being added]: " + item); //$NON-NLS-1$
1:           }
0:           return; /*
0: 						 * in case the item is untracked while in the process of
0: 						 * adding
1: 						 */
1:         }
0:         object = tracked.remove(item); /*
0: 											 * must remove from tracker before
0: 											 * calling customizer callback
1: 											 */
0:         if (object == null) { /* are we actually tracking the item */
0:           return;
1:         }
0:         modified(); /* increment modification count */
1:       }
0:       if (DEBUG) {
0:         System.out.println("AbstractTracked.untrack[removed]: " + item); //$NON-NLS-1$
1:       }
0:       /* Call customizer outside of synchronized region */
0:       customizerRemoved(item, related, object);
1:       /*
0:           * If the customizer throws an unchecked exception, it is safe to let it
0:           * propagate
1:           */
1:     }
1: 
1:     /**
0:      * Returns the number of tracked items.
1:      *
0:      * @return The number of tracked items.
0:      * @GuardedBy this
1:      */
0:     int size() {
0:       return tracked.size();
1:     }
1: 
1:     /**
0:      * Returns if the tracker is empty.
1:      *
0:      * @return Whether the tracker is empty.
0:      * @GuardedBy this
0:      * @since 1.5
1:      */
0:     boolean isEmpty() {
0:       return tracked.isEmpty();
1:     }
1: 
1:     /**
0:      * Return the customized object for the specified item
1:      *
0:      * @param item The item to lookup in the map
0:      * @return The customized object for the specified item.
0:      * @GuardedBy this
1:      */
0:     T getCustomizedObject(final S item) {
0:       return tracked.get(item);
1:     }
1: 
1:     /**
0:      * Copy the tracked items into an array.
1:      *
0:      * @param list An array to contain the tracked items.
0:      * @return The specified list if it is large enough to hold the tracked
0:      *         items or a new array large enough to hold the tracked items.
0:      * @GuardedBy this
1:      */
0:     S[] copyKeys(final S[] list) {
0:       return tracked.keySet().toArray(list);
1:     }
1: 
1:     /**
0:      * Increment the modification count. If this method is overridden, the
0:      * overriding method MUST call this method to increment the tracking count.
1:      *
0:      * @GuardedBy this
1:      */
0:     void modified() {
0:       trackingCount++;
1:     }
1: 
1:     /**
0:      * Returns the tracking count for this {@code ServiceTracker} object.
0:      * <p/>
0:      * The tracking count is initialized to 0 when this object is opened. Every
0:      * time an item is added, modified or removed from this object the tracking
0:      * count is incremented.
1:      *
0:      * @return The tracking count for this object.
0:      * @GuardedBy this
1:      */
0:     int getTrackingCount() {
0:       return trackingCount;
1:     }
1: 
1:     /**
0:      * Copy the tracked items and associated values into the specified map.
1:      *
0:      * @param <M> Type of {@code Map} to hold the tracked items and
0:      *            associated values.
0:      * @param map The map into which to copy the tracked items and associated
0:      *            values. This map must not be a user provided map so that user code
0:      *            is not executed while synchronized on this.
0:      * @return The specified map.
0:      * @GuardedBy this
0:      * @since 1.5
1:      */
0:     <M extends Map<? super S, ? super T>> M copyEntries(final M map) {
0:       map.putAll(tracked);
0:       return map;
1:     }
1: 
1:     /**
0:      * Call the specific customizer adding method. This method must not be
0:      * called while synchronized on this object.
1:      *
0:      * @param item    Item to be tracked.
0:      * @param related Action related object.
0:      * @return Customized object for the tracked item or {@code null} if
0:      *         the item is not to be tracked.
1:      */
0:     abstract T customizerAdding(final S item, final R related);
1: 
1:     /**
0:      * Call the specific customizer modified method. This method must not be
0:      * called while synchronized on this object.
1:      *
0:      * @param item    Tracked item.
0:      * @param related Action related object.
0:      * @param object  Customized object for the tracked item.
1:      */
0:     abstract void customizerModified(final S item, final R related,
0:                                      final T object);
1: 
1:     /**
0:      * Call the specific customizer removed method. This method must not be
0:      * called while synchronized on this object.
1:      *
0:      * @param item    Tracked item.
0:      * @param related Action related object.
0:      * @param object  Customized object for the tracked item.
1:      */
0:     abstract void customizerRemoved(final S item, final R related,
0:                                     final T object);
1:   }
1: 
1: }
============================================================================