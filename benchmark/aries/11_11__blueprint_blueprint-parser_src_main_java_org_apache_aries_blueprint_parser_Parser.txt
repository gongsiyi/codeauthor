1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:09a7647: package org.apache.aries.blueprint.parser;
1:f13c6ac: 
1:220c392: import javax.xml.XMLConstants;
1:220c392: import javax.xml.namespace.QName;
1:220c392: import javax.xml.parsers.DocumentBuilder;
1:220c392: import javax.xml.parsers.DocumentBuilderFactory;
1:220c392: import javax.xml.transform.dom.DOMSource;
1:220c392: import javax.xml.validation.Schema;
1:220c392: import javax.xml.validation.Validator;
1:f13c6ac: import java.io.InputStream;
1:f13c6ac: import java.net.URI;
1:f13c6ac: import java.net.URL;
1:f13c6ac: import java.util.ArrayList;
1:f117d81: import java.util.Arrays;
1:f13c6ac: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:f117d81: import java.util.HashMap;
1:f13c6ac: import java.util.HashSet;
1:f13c6ac: import java.util.LinkedHashSet;
1:f13c6ac: import java.util.List;
1:f117d81: import java.util.Map;
1:f13c6ac: import java.util.Set;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:6414875: import org.apache.aries.blueprint.NamespaceHandler;
1:3cfe3e2: import org.apache.aries.blueprint.ParserContext;
1:6414875: import org.apache.aries.blueprint.reflect.BeanArgumentImpl;
1:6414875: import org.apache.aries.blueprint.reflect.BeanMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.BeanPropertyImpl;
1:6414875: import org.apache.aries.blueprint.reflect.CollectionMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.IdRefMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.MapEntryImpl;
1:6414875: import org.apache.aries.blueprint.reflect.MapMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.MetadataUtil;
1:6414875: import org.apache.aries.blueprint.reflect.PropsMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.RefMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.ReferenceListMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.ReferenceListenerImpl;
1:6414875: import org.apache.aries.blueprint.reflect.ReferenceMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.RegistrationListenerImpl;
1:6414875: import org.apache.aries.blueprint.reflect.ServiceMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.ServiceReferenceMetadataImpl;
1:6414875: import org.apache.aries.blueprint.reflect.ValueMetadataImpl;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanArgument;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanProperty;
1:f13c6ac: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapEntry;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.NonNullMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.NullMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.PropsMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Target;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ValueMetadata;
1:f13c6ac: import org.w3c.dom.Attr;
1:f13c6ac: import org.w3c.dom.CharacterData;
1:f13c6ac: import org.w3c.dom.Comment;
1:f13c6ac: import org.w3c.dom.Document;
1:f13c6ac: import org.w3c.dom.Element;
1:f13c6ac: import org.w3c.dom.EntityReference;
1:f13c6ac: import org.w3c.dom.NamedNodeMap;
1:f13c6ac: import org.w3c.dom.Node;
1:f13c6ac: import org.w3c.dom.NodeList;
1:0871217: import org.xml.sax.ErrorHandler;
1:f13c6ac: import org.xml.sax.InputSource;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * TODO: javadoc
1:f13c6ac:  *
1:09a7647:  * @version $Rev: 1135256 $, $Date: 2011-06-13 21:09:27 +0100 (Mon, 13 Jun 2011) $
1:f13c6ac:  */
1:f13c6ac: public class Parser {
1:f13c6ac: 
1:f13c6ac:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:f13c6ac: 
1:f13c6ac:     public static final String BLUEPRINT_ELEMENT = "blueprint";
1:f13c6ac:     public static final String DESCRIPTION_ELEMENT = "description";
1:f13c6ac:     public static final String TYPE_CONVERTERS_ELEMENT = "type-converters";
1:f13c6ac:     public static final String BEAN_ELEMENT = "bean";
1:f13c6ac:     public static final String ARGUMENT_ELEMENT = "argument";
1:f13c6ac:     public static final String REF_ELEMENT = "ref";
1:f13c6ac:     public static final String IDREF_ELEMENT = "idref";
1:f13c6ac:     public static final String LIST_ELEMENT = "list";
1:f13c6ac:     public static final String SET_ELEMENT = "set";
1:f13c6ac:     public static final String MAP_ELEMENT = "map";
1:f13c6ac:     public static final String ARRAY_ELEMENT = "array";
1:f13c6ac:     public static final String PROPS_ELEMENT = "props";
1:f13c6ac:     public static final String PROP_ELEMENT = "prop";
1:f13c6ac:     public static final String PROPERTY_ELEMENT = "property";
1:f13c6ac:     public static final String NULL_ELEMENT = "null";
1:f13c6ac:     public static final String VALUE_ELEMENT = "value";
1:f13c6ac:     public static final String SERVICE_ELEMENT = "service";
1:f13c6ac:     public static final String REFERENCE_ELEMENT = "reference";
1:f13c6ac:     public static final String REFERENCE_LIST_ELEMENT = "reference-list";
1:f13c6ac:     public static final String INTERFACES_ELEMENT = "interfaces";
1:f13c6ac:     public static final String REFERENCE_LISTENER_ELEMENT = "reference-listener";
1:f13c6ac:     public static final String SERVICE_PROPERTIES_ELEMENT = "service-properties";
1:f13c6ac:     public static final String REGISTRATION_LISTENER_ELEMENT = "registration-listener";
1:f13c6ac:     public static final String ENTRY_ELEMENT = "entry";
1:f13c6ac:     public static final String KEY_ELEMENT = "key";
1:f13c6ac:     public static final String DEFAULT_ACTIVATION_ATTRIBUTE = "default-activation";
1:f13c6ac:     public static final String DEFAULT_TIMEOUT_ATTRIBUTE = "default-timeout";
1:f13c6ac:     public static final String DEFAULT_AVAILABILITY_ATTRIBUTE = "default-availability";
1:f13c6ac:     public static final String NAME_ATTRIBUTE = "name";
1:f13c6ac:     public static final String ID_ATTRIBUTE = "id";
1:f13c6ac:     public static final String CLASS_ATTRIBUTE = "class";
1:f13c6ac:     public static final String INDEX_ATTRIBUTE = "index";
1:f13c6ac:     public static final String TYPE_ATTRIBUTE = "type";
1:f13c6ac:     public static final String VALUE_ATTRIBUTE = "value";
1:f13c6ac:     public static final String VALUE_REF_ATTRIBUTE = "value-ref";
1:f13c6ac:     public static final String KEY_ATTRIBUTE = "key";
1:f13c6ac:     public static final String KEY_REF_ATTRIBUTE = "key-ref";
1:f13c6ac:     public static final String REF_ATTRIBUTE = "ref";
1:f13c6ac:     public static final String COMPONENT_ID_ATTRIBUTE = "component-id";
1:f13c6ac:     public static final String INTERFACE_ATTRIBUTE = "interface";
1:f13c6ac:     public static final String DEPENDS_ON_ATTRIBUTE = "depends-on";
1:f13c6ac:     public static final String AUTO_EXPORT_ATTRIBUTE = "auto-export";
1:f13c6ac:     public static final String RANKING_ATTRIBUTE = "ranking";
1:f13c6ac:     public static final String TIMEOUT_ATTRIBUTE = "timeout";
1:f13c6ac:     public static final String FILTER_ATTRIBUTE = "filter";
1:f13c6ac:     public static final String COMPONENT_NAME_ATTRIBUTE = "component-name";
1:f13c6ac:     public static final String AVAILABILITY_ATTRIBUTE = "availability";
1:f13c6ac:     public static final String REGISTRATION_METHOD_ATTRIBUTE = "registration-method";
1:f13c6ac:     public static final String UNREGISTRATION_METHOD_ATTRIBUTE = "unregistration-method";
1:f13c6ac:     public static final String BIND_METHOD_ATTRIBUTE = "bind-method";
1:f13c6ac:     public static final String UNBIND_METHOD_ATTRIBUTE = "unbind-method";
1:f13c6ac:     public static final String KEY_TYPE_ATTRIBUTE = "key-type";
1:f13c6ac:     public static final String VALUE_TYPE_ATTRIBUTE = "value-type";
1:f13c6ac:     public static final String MEMBER_TYPE_ATTRIBUTE = "member-type";
1:f13c6ac:     public static final String SCOPE_ATTRIBUTE = "scope";
1:f13c6ac:     public static final String INIT_METHOD_ATTRIBUTE = "init-method";
1:f13c6ac:     public static final String DESTROY_METHOD_ATTRIBUTE = "destroy-method";
1:f13c6ac:     public static final String ACTIVATION_ATTRIBUTE = "activation";
1:f13c6ac:     public static final String FACTORY_REF_ATTRIBUTE = "factory-ref";
1:f13c6ac:     public static final String FACTORY_METHOD_ATTRIBUTE = "factory-method";
1:f13c6ac: 
1:f13c6ac:     public static final String AUTO_EXPORT_DISABLED = "disabled";
1:f13c6ac:     public static final String AUTO_EXPORT_INTERFACES = "interfaces";
1:f13c6ac:     public static final String AUTO_EXPORT_CLASS_HIERARCHY = "class-hierarchy";
1:f13c6ac:     public static final String AUTO_EXPORT_ALL = "all-classes";
1:f13c6ac:     public static final String AUTO_EXPORT_DEFAULT = AUTO_EXPORT_DISABLED;
1:f13c6ac:     public static final String RANKING_DEFAULT = "0";
1:f13c6ac:     public static final String AVAILABILITY_MANDATORY = "mandatory";
1:f13c6ac:     public static final String AVAILABILITY_OPTIONAL = "optional";
1:f13c6ac:     public static final String AVAILABILITY_DEFAULT = AVAILABILITY_MANDATORY;
1:f13c6ac:     public static final String TIMEOUT_DEFAULT = "300000";
1:f13c6ac:     public static final String USE_SERVICE_OBJECT = "service-object";
1:f13c6ac:     public static final String USE_SERVICE_REFERENCE = "service-reference";
1:f13c6ac:     public static final String ACTIVATION_EAGER = "eager";
1:f13c6ac:     public static final String ACTIVATION_LAZY = "lazy";
1:f13c6ac:     public static final String ACTIVATION_DEFAULT = ACTIVATION_EAGER;
1:f13c6ac:     
1:f13c6ac:     private static DocumentBuilderFactory documentBuilderFactory;
1:3cfe3e2:     private static final NamespaceHandler missingNamespace = new NamespaceHandler() {
1:3cfe3e2:         @Override
1:3cfe3e2:         public Metadata parse(Element element, ParserContext context) {
1:3cfe3e2:             return null;
1:3cfe3e2:         }
1:3cfe3e2:         @Override
1:3cfe3e2:         public URL getSchemaLocation(String namespace) {
1:3cfe3e2:             return null;
1:0871217:         }
1:3cfe3e2:         @Override
1:3cfe3e2:         public Set<Class> getManagedClasses() {
1:3cfe3e2:             return null;
1:3cfe3e2:         }
1:3cfe3e2:         @Override
1:3cfe3e2:         public ComponentMetadata decorate(Node node, ComponentMetadata component,
1:3cfe3e2:                 ParserContext context) {
1:3cfe3e2:             return component;
1:3cfe3e2:         }
1:3cfe3e2:     };
1:f13c6ac: 
1:436dc3a:     private final List<Document> documents = new ArrayList<Document>();
1:f13c6ac:     private ComponentDefinitionRegistry registry;
1:09a7647:     private NamespaceHandlerSet handlers;
1:3cfe3e2:     private final String idPrefix;
1:3cfe3e2:     private final boolean ignoreUnknownNamespaces;
1:b6c4135:     private final Set<String> ids = new HashSet<String>();
1:f13c6ac:     private int idCounter;
1:f13c6ac:     private String defaultTimeout;
1:f13c6ac:     private String defaultAvailability;
1:f13c6ac:     private String defaultActivation;
1:f13c6ac:     private Set<URI> namespaces;
1:f117d81:     private Map<String, String> locations;
1:f13c6ac: 
1:f13c6ac:     public Parser() {
1:3cfe3e2:       this(null);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Parser(String idPrefix) {
1:3cfe3e2:       this(idPrefix, false);
1:f13c6ac:     }
1:f13c6ac: 
1:3cfe3e2:     public Parser(String idPrefix, boolean ignoreUnknownNamespaces) {
1:3cfe3e2:       this.idPrefix = idPrefix == null ? "component-" : idPrefix;
1:3cfe3e2:       this.ignoreUnknownNamespaces = ignoreUnknownNamespaces;
1:f13c6ac:     }
1:f13c6ac: 
1:9d16c7e:     /**
1:9d16c7e:      * Parse an input stream for blueprint xml. 
1:9d16c7e:      * @param inputStream The data to parse. The caller is responsible for closing the stream afterwards. 
1:436dc3a:      * @throws Exception on parse error
1:9d16c7e:      */
1:9d16c7e:     public void parse(InputStream inputStream) throws Exception { 
1:5a5f2a0:       parse(null, inputStream);
1:3cfe3e2:     }
1:5a5f2a0: 
1:5a5f2a0:     public void parse(String location, InputStream inputStream) throws Exception {
1:5a5f2a0:         InputSource inputSource = new InputSource(inputStream);
1:5a5f2a0:         inputSource.setSystemId(location);
1:5a5f2a0:         DocumentBuilder builder = getDocumentBuilderFactory().newDocumentBuilder();
1:5a5f2a0:         Document doc = builder.parse(inputSource);
1:5a5f2a0:         documents.add(doc);
1:5a5f2a0:     }
1:5a5f2a0: 
1:9d16c7e:     /**
1:9d16c7e:      * Parse blueprint xml referred to by a list of URLs
1:9d16c7e:      * @param urls URLs to blueprint xml to parse
1:436dc3a:      * @throws Exception on parse error
1:9d16c7e:      */
1:f13c6ac:     public void parse(List<URL> urls) throws Exception {
1:f13c6ac:         // Create document builder factory
1:f13c6ac:         // Load documents
1:f13c6ac:         for (URL url : urls) {
1:f13c6ac:             InputStream inputStream = url.openStream();
1:f13c6ac:             try {
1:5a5f2a0:                 parse (url.toString(), inputStream);
1:f13c6ac:             } finally {
1:f13c6ac:                 inputStream.close();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Set<URI> getNamespaces() {
1:f13c6ac:         if (this.namespaces == null) {
1:f13c6ac:             Set<URI> namespaces = new LinkedHashSet<URI>();
1:f117d81:             Map<String, String> locations = new HashMap<String, String>();
1:f13c6ac:             for (Document doc : documents) {
1:f117d81:                 findNamespaces(namespaces, locations, doc);
1:f13c6ac:             }
1:f13c6ac:             this.namespaces = namespaces;
1:f117d81:             this.locations = locations;
1:f13c6ac:         }
1:f13c6ac:         return this.namespaces;
1:f13c6ac:     }
1:f13c6ac: 
1:f117d81:     public Map<String, String> getSchemaLocations() {
1:f117d81:         getNamespaces();
1:f117d81:         return locations;
1:f117d81:     }
1:f117d81: 
1:f117d81:     private void findNamespaces(Set<URI> namespaces, Map<String, String> locations, Node node) {
1:f13c6ac:         if (node instanceof Element || node instanceof Attr) {
1:f13c6ac:             String ns = node.getNamespaceURI();
1:f117d81:             if ("http://www.w3.org/2001/XMLSchema-instance".equals(ns)
1:f117d81:                     && node instanceof Attr
1:f117d81:                     && "schemaLocation".equals(node.getLocalName())) {
1:f117d81:                 String val = ((Attr) node).getValue();
1:f117d81:                 List<String> locs = new ArrayList<String>(Arrays.asList(val.split("\\s+")));
1:f117d81:                 locs.remove("");
1:f117d81:                 for (int i = 0; i < locs.size() / 2; i++) {
1:f117d81:                     locations.put(locs.get(i * 2), locs.get(i * 2 + 1));
1:f117d81:                 }
1:f117d81:             } else if (ns != null && !isBlueprintNamespace(ns) && !isIgnorableAttributeNamespace(ns)) {
1:f13c6ac:                 namespaces.add(URI.create(ns));
1:f117d81:             } else if (ns == null && //attributes from blueprint are unqualified as per schema.
1:8ae47e0:                        node instanceof Attr &&
1:8ae47e0:                        SCOPE_ATTRIBUTE.equals(node.getNodeName()) &&
1:8ae47e0:                        ((Attr)node).getOwnerElement() != null && //should never occur from parsed doc.
1:8ae47e0:                        BLUEPRINT_NAMESPACE.equals(((Attr)node).getOwnerElement().getNamespaceURI()) &&
1:8ae47e0:                        BEAN_ELEMENT.equals(((Attr)node).getOwnerElement().getLocalName()) ){
1:8ae47e0:                 //Scope attribute is special case, as may contain namespace usage within its value.
1:f13c6ac:                 
1:8ae47e0:                 URI scopeNS = getNamespaceForAttributeValue(node);
1:8ae47e0:                 if(scopeNS!=null){
1:8ae47e0:                     namespaces.add(scopeNS);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:8ae47e0:         NamedNodeMap nnm = node.getAttributes();
1:8ae47e0:         if(nnm!=null){
1:8ae47e0:             for(int i = 0; i< nnm.getLength() ; i++){
1:f117d81:                 findNamespaces(namespaces, locations, nnm.item(i));
1:3cfe3e2:             }
1:3cfe3e2:         }
1:f13c6ac:         NodeList nl = node.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f117d81:             findNamespaces(namespaces, locations, nl.item(i));
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:09a7647:     public void populate(NamespaceHandlerSet handlers,
1:f13c6ac:                          ComponentDefinitionRegistry registry) {
1:3b2c33b:         this.handlers = handlers;
1:f13c6ac:         this.registry = registry;
1:f13c6ac:         if (this.documents == null) {
1:f13c6ac:             throw new IllegalStateException("Documents should be parsed before populating the registry");
1:f13c6ac:         }
1:f13c6ac:         // Parse components
1:f13c6ac:         for (Document doc : this.documents) {
1:f13c6ac:             loadComponents(doc);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:3b2c33b:     public void validate(Schema schema) {
1:0871217:         validate(schema, null);
1:f13c6ac:     }
1:f13c6ac: 
1:0871217:     public void validate(Schema schema, ErrorHandler errorHandler) {
1:f13c6ac:         try {
1:f13c6ac:             Validator validator = schema.newValidator();
1:0871217:             if (errorHandler != null) {
1:0871217:                 validator.setErrorHandler(errorHandler);
1:0871217:             }
1:f13c6ac:             for (Document doc : this.documents) {
1:f13c6ac:                 validator.validate(new DOMSource(doc));
1:f13c6ac:             }
1:f13c6ac:         } catch (Exception e) {
1:f13c6ac:             throw new ComponentDefinitionException("Unable to validate xml", e);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:220c392:     public void validatePsvi(Schema schema) {
1:220c392:         try {
1:220c392:             // In order to support validation with the built-in xml parser
1:220c392:             // from the JDK, we can't use Validator.validate(source, result)
1:220c392:             // as it fails with an exception, see
1:220c392:             //   https://issues.apache.org/jira/browse/XERCESJ-1212
1:220c392:             // This was fixed in xerces 2.9.0 years ago but still is not
1:220c392:             // included in my JDK.
1:220c392:             List<String> locations = new ArrayList<String>();
1:220c392:             for (Document doc : documents) {
1:220c392:                 locations.add(doc.getDocumentURI());
1:220c392:             }
1:220c392:             List<Document> validated = new ArrayList<Document>();
1:220c392:             for (String location : locations) {
1:220c392:                 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
1:220c392:                 factory.setNamespaceAware(true);
1:220c392:                 factory.setSchema(schema);
1:220c392:                 DocumentBuilder builder = factory.newDocumentBuilder();
1:220c392:                 InputSource inputSource = new InputSource(location);
1:220c392:                 Document doc = builder.parse(inputSource);
1:220c392:                 validated.add(doc);
1:220c392:             }
1:220c392:             this.documents.clear();
1:220c392:             this.documents.addAll(validated);
1:220c392:         } catch (Exception e) {
1:220c392:             throw new ComponentDefinitionException("Unable to validate xml", e);
1:220c392:         }
1:220c392:     }
1:220c392: 
1:f13c6ac:     private void loadComponents(Document doc) {
1:f13c6ac:         defaultTimeout = TIMEOUT_DEFAULT;
1:f13c6ac:         defaultAvailability = AVAILABILITY_DEFAULT;
1:f13c6ac:         defaultActivation = ACTIVATION_DEFAULT;
1:f13c6ac:         Element root = doc.getDocumentElement();
1:f13c6ac:         if (!isBlueprintNamespace(root.getNamespaceURI()) ||
1:f13c6ac:                 !nodeNameEquals(root, BLUEPRINT_ELEMENT)) {
1:f13c6ac:             throw new ComponentDefinitionException("Root element must be {" + BLUEPRINT_NAMESPACE + "}" + BLUEPRINT_ELEMENT + " element");
1:f13c6ac:         }
1:f13c6ac:         // Parse global attributes
1:f13c6ac:         if (root.hasAttribute(DEFAULT_ACTIVATION_ATTRIBUTE)) {
1:f13c6ac:             defaultActivation = root.getAttribute(DEFAULT_ACTIVATION_ATTRIBUTE);
1:f13c6ac:         }
1:f13c6ac:         if (root.hasAttribute(DEFAULT_TIMEOUT_ATTRIBUTE)) {
1:f13c6ac:             defaultTimeout = root.getAttribute(DEFAULT_TIMEOUT_ATTRIBUTE);
1:f13c6ac:         }
1:f13c6ac:         if (root.hasAttribute(DEFAULT_AVAILABILITY_ATTRIBUTE)) {
1:f13c6ac:             defaultAvailability = root.getAttribute(DEFAULT_AVAILABILITY_ATTRIBUTE);
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         // Parse custom attributes
1:ba088af:         handleCustomAttributes(root.getAttributes(), null);
1:f13c6ac: 
1:f13c6ac:         // Parse elements
1:e594ebc:         // Break into 2 loops to ensure we scan the blueprint elements before
1:e594ebc:         // This is needed so that when we process the custom element, we know
1:e594ebc:         // the component definition registry has populated all blueprint components.
1:f13c6ac:         NodeList nl = root.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element element = (Element) node;
1:f13c6ac:                 String namespaceUri = element.getNamespaceURI();
1:f13c6ac:                 if (isBlueprintNamespace(namespaceUri)) {
1:f13c6ac:                     parseBlueprintElement(element);
1:f13c6ac:                 } 
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         
1:e594ebc:         for (int i = 0; i < nl.getLength(); i++) {
1:e594ebc:             Node node = nl.item(i);
1:e594ebc:             if (node instanceof Element) {
1:e594ebc:                 Element element = (Element) node;
1:e594ebc:                 String namespaceUri = element.getNamespaceURI();
1:e594ebc:                 if (!isBlueprintNamespace(namespaceUri)) {
1:f13c6ac:                     Metadata component = parseCustomElement(element, null);
1:f13c6ac:                     if (component != null) {
1:f13c6ac:                         if (!(component instanceof ComponentMetadata)) {
1:f13c6ac:                             throw new ComponentDefinitionException("Expected a ComponentMetadata to be returned when parsing element " + element.getNodeName());
1:f13c6ac:                         }
1:f13c6ac:                         registry.registerComponentDefinition((ComponentMetadata) component);
1:f13c6ac:                     }
1:f13c6ac:                 } 
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public <T> T parseElement(Class<T> type, ComponentMetadata enclosingComponent, Element element) {
1:f13c6ac:         if (BeanArgument.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseBeanArgument(enclosingComponent, element));
1:f13c6ac:         } else if (BeanProperty.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseBeanProperty(enclosingComponent, element));
1:f13c6ac:         } else if (MapEntry.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseMapEntry(element, enclosingComponent, null, null));
1:f13c6ac:         } else if (MapMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseMap(element, enclosingComponent));
1:f13c6ac:         } else if (BeanMetadata.class.isAssignableFrom(type)) {
1:b267b13:             return type.cast(parseBeanMetadata(element, enclosingComponent == null));
1:f13c6ac:         } else if (NullMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(NullMetadata.NULL);
1:f13c6ac:         } else if (CollectionMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseCollection(Collection.class, element, enclosingComponent));
1:f13c6ac:         } else if (PropsMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseProps(element));
1:f13c6ac:         } else if (ReferenceMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseReference(element, enclosingComponent == null));
1:f13c6ac:         } else if (ReferenceListMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseRefList(element, enclosingComponent == null));
1:b267b13:         } else if (ServiceMetadata.class.isAssignableFrom(type)) {
1:b267b13:             return type.cast(parseService(element, enclosingComponent == null));
1:f13c6ac:         } else if (IdRefMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseIdRef(element));
1:f13c6ac:         } else if (RefMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseRef(element));
1:f13c6ac:         } else if (ValueMetadata.class.isAssignableFrom(type)) {
1:f13c6ac:             return type.cast(parseValue(element, null));
1:1cfd24a:         } else if (ReferenceListener.class.isAssignableFrom(type)) {
1:1cfd24a:             return type.cast(parseServiceListener(element, enclosingComponent));
1:22a0fbb:         } else if (Metadata.class.isAssignableFrom(type)) {
1:22a0fbb:             return type.cast(parseValueGroup(element, enclosingComponent, null, true));
2:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Unknown type to parse element: " + type.getName());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void parseBlueprintElement(Element element) {
1:f13c6ac:         if (nodeNameEquals(element, DESCRIPTION_ELEMENT)) {
1:f13c6ac:             // Ignore description
1:f13c6ac:         } else if (nodeNameEquals(element, TYPE_CONVERTERS_ELEMENT)) {
1:f13c6ac:             parseTypeConverters(element);
1:f13c6ac:         } else if (nodeNameEquals(element, BEAN_ELEMENT)) {
1:f13c6ac:             ComponentMetadata component = parseBeanMetadata(element, true);
1:f13c6ac:             registry.registerComponentDefinition(component);
1:f13c6ac:         } else if (nodeNameEquals(element, SERVICE_ELEMENT)) {
1:f13c6ac:             ComponentMetadata service = parseService(element, true);
1:f13c6ac:             registry.registerComponentDefinition(service);
1:f13c6ac:         } else if (nodeNameEquals(element, REFERENCE_ELEMENT)) {
1:f13c6ac:             ComponentMetadata reference = parseReference(element, true);
1:f13c6ac:             registry.registerComponentDefinition(reference);
1:f13c6ac:         } else if (nodeNameEquals(element, REFERENCE_LIST_ELEMENT) ) {
1:f13c6ac:             ComponentMetadata references = parseRefList(element, true);
1:f13c6ac:             registry.registerComponentDefinition(references);
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Unknown element " + element.getNodeName() + " in namespace " + BLUEPRINT_NAMESPACE);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void parseTypeConverters(Element element) {
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 Object target = null;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:f13c6ac:                         target = parseBeanMetadata(e, true);
1:f13c6ac:                     } else if (nodeNameEquals(e, REF_ELEMENT)) {
1:f13c6ac:                         String componentName = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:f13c6ac:                         target = new RefMetadataImpl(componentName);
1:f13c6ac:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:f13c6ac:                         target = parseReference(e, true);
1:f13c6ac:                     }
1:f13c6ac:                 } else {
1:f13c6ac:                     target = parseCustomElement(e, null);
1:f13c6ac:                 }
1:f13c6ac:                 if (!(target instanceof Target)) {
1:f13c6ac:                     throw new ComponentDefinitionException("Metadata parsed for element " + e.getNodeName() + " can not be used as a type converter");
1:f13c6ac:                 }
1:f13c6ac:                 registry.registerTypeConverter((Target) target);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:8ae47e0:     /**
1:8ae47e0:      * Takes an Attribute Node containing a namespace prefix qualified attribute value, and resolves the namespace using the DOM Node.<br> 
1:8ae47e0:      *  
1:436dc3a:      * @param attrNode The DOM Node with the qualified attribute value.
1:8ae47e0:      * @return The URI if one is resolvable, or null if the attr is null, or not namespace prefixed. (or not a DOM Attribute Node)
1:436dc3a:      * @throws ComponentDefinitionException if the namespace prefix in the attribute value cannot be resolved.
1:8ae47e0:      */
1:436dc3a:     private URI getNamespaceForAttributeValue(Node attrNode) throws ComponentDefinitionException {
1:8ae47e0:         URI uri = null;
1:8ae47e0:         if(attrNode!=null && (attrNode instanceof Attr)){
1:8ae47e0:             Attr attr = (Attr)attrNode;
1:8ae47e0:             String attrValue = attr.getValue();
1:8ae47e0:             if(attrValue!=null && attrValue.indexOf(":")!=-1){
1:8ae47e0:                 String parts[] = attrValue.split(":");
1:8ae47e0:                 String uriStr = attr.getOwnerElement().lookupNamespaceURI(parts[0]);
1:8ae47e0:                 if(uriStr!=null){
1:8ae47e0:                     uri = URI.create(uriStr);
1:8ae47e0:                 }else{
1:8ae47e0:                     throw new ComponentDefinitionException("Unsupported attribute namespace prefix "+parts[0]+" "+attr);
1:1cfd24a:                 }
1:e594ebc:             }
1:e594ebc:         }
1:8ae47e0:         return uri;
1:e594ebc:     }
1:0871217:     
1:8ae47e0:     /**
1:b4fc651:      * Takes an Attribute Node for the scope, and returns the value.<br> 
1:b4fc651:      *  
1:b4fc651:      * @param attrNode The DOM Node with the attribute value.
1:b4fc651:      * @return The scope as a stringified value. It should be either the value <code>prototype</code>,
1:b4fc651:      * <code>singleton</code>, or a namespace qualified value, e.g. {http://foo}bar
1:b4fc651:      * @throws ComponentDefinitionException if the namespace prefix in the attribute value cannot be resolved.
1:b4fc651:      */
1:b4fc651:     private String getScope(Node attrNode) throws ComponentDefinitionException {
1:b4fc651:         String scope = null;
1:b4fc651:         if(attrNode!=null && (attrNode instanceof Attr)){
1:b4fc651:             Attr attr = (Attr)attrNode;
1:b4fc651:             String attrValue = attr.getValue();
1:b4fc651:             if(attrValue!=null && attrValue.indexOf(":")!=-1){
1:b4fc651:                 String[] parts = attrValue.split(":");
1:b4fc651:                 String prefix = parts[0];
1:b4fc651:                 String localName = parts[1];
1:b4fc651:                 String namespaceURI = attr.getOwnerElement().lookupNamespaceURI(prefix);
1:b4fc651:                 if(namespaceURI!=null){
1:b4fc651:                     scope = new QName(namespaceURI, localName).toString();
1:b4fc651:                 }else{
1:b4fc651:                     throw new ComponentDefinitionException("Unable to determine namespace binding for prefix, " + prefix);
1:b4fc651:                 }
1:b4fc651:             }
1:b4fc651:             else {
1:b4fc651:                 scope = attrValue;
1:b4fc651:             }
1:b4fc651:         }
1:b4fc651:         return scope;
1:b4fc651:     }
1:3cfe3e2:     
1:b4fc651:     /**
1:8ae47e0:      * Tests if a scope attribute value is a custom scope, and if so invokes
1:8ae47e0:      * the appropriate namespace handler, passing the blueprint scope node. 
1:8ae47e0:      * <p> 
1:8ae47e0:      * Currently this tests for custom scope by looking for the presence of
1:8ae47e0:      * a ':' char within the scope attribute value. This is valid as long as
1:8ae47e0:      * the blueprint schema continues to restrict that custom scopes should
1:8ae47e0:      * require that characters presence.
1:8ae47e0:      * <p>
1:8ae47e0:      *  
1:8ae47e0:      * @param scope Value of scope attribute
1:8ae47e0:      * @param bean DOM element for bean associated to this scope 
1:8ae47e0:      * @return Metadata as processed by NS Handler.
1:8ae47e0:      * @throws ComponentDefinitionException if an undeclared prefix is used, 
1:8ae47e0:      *           if a namespace handler is unavailable for a resolved prefix, 
1:8ae47e0:      *           or if the resolved prefix results as the blueprint namespace.
1:8ae47e0:      */
1:8ae47e0:     private ComponentMetadata handleCustomScope(Node scope, Element bean, ComponentMetadata metadata){
1:8ae47e0:         URI scopeNS = getNamespaceForAttributeValue(scope);
1:436dc3a:         if(scopeNS!=null && !BLUEPRINT_NAMESPACE.equals(scopeNS.toString())){
1:8ae47e0:             NamespaceHandler nsHandler = getNamespaceHandler(scopeNS);
1:8ae47e0:             ParserContextImpl context = new ParserContextImpl(this, registry, metadata, scope);
1:8ae47e0:             metadata = nsHandler.decorate(scope, metadata, context);
1:8ae47e0:         }else if(scopeNS!=null){
1:8ae47e0:             throw new ComponentDefinitionException("Custom scopes cannot use the blueprint namespace "+scope);
1:e594ebc:         }
1:8ae47e0:         return metadata;
1:9d16c7e:     }
1:3cfe3e2: 
1:f13c6ac:     private ComponentMetadata parseBeanMetadata(Element element, boolean topElement) {
1:f13c6ac:         BeanMetadataImpl metadata = new BeanMetadataImpl();
1:f13c6ac:         if (topElement) {
1:f13c6ac:             metadata.setId(getId(element));
1:f13c6ac:             if (element.hasAttribute(SCOPE_ATTRIBUTE)) {
1:b4fc651:                 metadata.setScope(getScope(element.getAttributeNode(SCOPE_ATTRIBUTE)));
1:b4fc651:                 if (!metadata.getScope().equals(BeanMetadata.SCOPE_SINGLETON)) {
1:f13c6ac:                     if (element.hasAttribute(ACTIVATION_ATTRIBUTE)) {
1:f13c6ac:                         if (element.getAttribute(ACTIVATION_ATTRIBUTE).equals(ACTIVATION_EAGER)) {
1:b4fc651:                             throw new ComponentDefinitionException("A <bean> with a prototype or custom scope can not have an eager activation");
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                     metadata.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:f13c6ac:                 } else {
1:f13c6ac:                     metadata.setActivation(parseActivation(element));
1:f13c6ac:                 }
1:f13c6ac:             } else {
1:f13c6ac:                 metadata.setActivation(parseActivation(element));
1:f13c6ac:             }
1:f13c6ac:         } else {
1:f13c6ac:             metadata.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(CLASS_ATTRIBUTE)) {
1:f13c6ac:             metadata.setClassName(element.getAttribute(CLASS_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
1:f13c6ac:             metadata.setDependsOn(parseList(element.getAttribute(DEPENDS_ON_ATTRIBUTE)));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
1:f13c6ac:             metadata.setInitMethod(element.getAttribute(INIT_METHOD_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
1:f13c6ac:             metadata.setDestroyMethod(element.getAttribute(DESTROY_METHOD_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(FACTORY_REF_ATTRIBUTE)) {
1:f13c6ac:             metadata.setFactoryComponent(new RefMetadataImpl(element.getAttribute(FACTORY_REF_ATTRIBUTE)));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
1:f13c6ac:             String factoryMethod = element.getAttribute(FACTORY_METHOD_ATTRIBUTE);
1:f13c6ac:             metadata.setFactoryMethod(factoryMethod);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         // Do some validation
1:f13c6ac:         if (metadata.getClassName() == null && metadata.getFactoryComponent() == null) {
1:f13c6ac:             throw new ComponentDefinitionException("Bean class or factory-ref must be specified");
1:f13c6ac:         }
1:f13c6ac:         if (metadata.getFactoryComponent() != null && metadata.getFactoryMethod() == null) {
1:f13c6ac:             throw new ComponentDefinitionException("factory-method is required when factory-component is set");
1:f13c6ac:         }
1:f13c6ac:         if (MetadataUtil.isPrototypeScope(metadata) && metadata.getDestroyMethod() != null) {
1:f13c6ac:             throw new ComponentDefinitionException("destroy-method must not be set for a <bean> with a prototype scope");
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         // Parse elements
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(node.getNamespaceURI())) {                
1:f13c6ac:                     if (nodeNameEquals(node, ARGUMENT_ELEMENT)) {
1:f13c6ac:                         metadata.addArgument(parseBeanArgument(metadata, e));
1:f13c6ac:                     } else if (nodeNameEquals(node, PROPERTY_ELEMENT)) {
1:f13c6ac:                         metadata.addProperty(parseBeanProperty(metadata, e));
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         MetadataUtil.validateBeanArguments(metadata.getArguments());
1:f13c6ac:         
1:f13c6ac:         ComponentMetadata m = metadata;
1:f13c6ac:         
1:8ae47e0:         // Parse custom scopes
1:8ae47e0:         m = handleCustomScope(element.getAttributeNode(SCOPE_ATTRIBUTE), element, m);
1:b4fc651:         
1:f13c6ac:         // Parse custom attributes
1:f13c6ac:         m = handleCustomAttributes(element.getAttributes(), m);
1:f13c6ac:         
1:f13c6ac:         // Parse custom elements;
1:f13c6ac:         m = handleCustomElements(element, m);
1:f13c6ac:         
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public BeanProperty parseBeanProperty(ComponentMetadata enclosingComponent, Element element) {
1:f13c6ac:         String name = element.hasAttribute(NAME_ATTRIBUTE) ? element.getAttribute(NAME_ATTRIBUTE) : null;
1:f13c6ac:         Metadata value = parseArgumentOrPropertyValue(element, enclosingComponent);
1:f13c6ac:         return new BeanPropertyImpl(name, value);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private BeanArgument parseBeanArgument(ComponentMetadata enclosingComponent, Element element) {
1:f13c6ac:         int index = element.hasAttribute(INDEX_ATTRIBUTE) ? Integer.parseInt(element.getAttribute(INDEX_ATTRIBUTE)) : -1;
1:f13c6ac:         String type = element.hasAttribute(TYPE_ATTRIBUTE) ? element.getAttribute(TYPE_ATTRIBUTE) : null;
1:f13c6ac:         Metadata value = parseArgumentOrPropertyValue(element, enclosingComponent);
1:f13c6ac:         return new BeanArgumentImpl(value, type, index);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ComponentMetadata parseService(Element element, boolean topElement) {
1:f13c6ac:         ServiceMetadataImpl service = new ServiceMetadataImpl();
1:f13c6ac:         boolean hasInterfaceNameAttribute = false;
1:f13c6ac:         if (topElement) {
1:f13c6ac:             service.setId(getId(element));
1:f13c6ac:             service.setActivation(parseActivation(element));
1:f13c6ac:         } else {
1:f13c6ac:             service.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(INTERFACE_ATTRIBUTE)) {
1:f13c6ac:             service.setInterfaceNames(Collections.singletonList(element.getAttribute(INTERFACE_ATTRIBUTE)));
1:f13c6ac:             hasInterfaceNameAttribute = true;
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:f13c6ac:             service.setServiceComponent(new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE)));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
1:f13c6ac:             service.setDependsOn(parseList(element.getAttribute(DEPENDS_ON_ATTRIBUTE)));
1:f13c6ac:         }
1:f13c6ac:         String autoExport = element.hasAttribute(AUTO_EXPORT_ATTRIBUTE) ? element.getAttribute(AUTO_EXPORT_ATTRIBUTE) : AUTO_EXPORT_DEFAULT;
1:f13c6ac:         if (AUTO_EXPORT_DISABLED.equals(autoExport)) {
1:f13c6ac:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:f13c6ac:         } else if (AUTO_EXPORT_INTERFACES.equals(autoExport)) {
1:f13c6ac:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_INTERFACES);
1:f13c6ac:         } else if (AUTO_EXPORT_CLASS_HIERARCHY.equals(autoExport)) {
1:f13c6ac:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
1:f13c6ac:         } else if (AUTO_EXPORT_ALL.equals(autoExport)) {
1:f13c6ac:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Illegal value (" + autoExport + ") for " + AUTO_EXPORT_ATTRIBUTE + " attribute");
1:f13c6ac:         }
1:f13c6ac:         String ranking = element.hasAttribute(RANKING_ATTRIBUTE) ? element.getAttribute(RANKING_ATTRIBUTE) : RANKING_DEFAULT;
1:f13c6ac:         try {
1:f13c6ac:             service.setRanking(Integer.parseInt(ranking));
1:f13c6ac:         } catch (NumberFormatException e) {
1:f13c6ac:             throw new ComponentDefinitionException("Attribute " + RANKING_ATTRIBUTE + " must be a valid integer (was: " + ranking + ")");
1:f13c6ac:         }
1:f13c6ac:         // Parse elements
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, INTERFACES_ELEMENT)) {
1:f13c6ac:                         if (hasInterfaceNameAttribute) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be used");
1:f13c6ac:                         }
1:f13c6ac:                         service.setInterfaceNames(parseInterfaceNames(e));
1:f13c6ac:                     } else if (nodeNameEquals(e, SERVICE_PROPERTIES_ELEMENT)) {
1:f13c6ac:                         List<MapEntry> entries = parseServiceProperties(e, service).getEntries();
1:f13c6ac:                         service.setServiceProperties(entries); 
1:f13c6ac:                     } else if (nodeNameEquals(e, REGISTRATION_LISTENER_ELEMENT)) {
1:f13c6ac:                         service.addRegistrationListener(parseRegistrationListener(e, service));
1:f13c6ac:                     } else if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:f13c6ac:                         if (service.getServiceComponent() != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         service.setServiceComponent((Target) parseBeanMetadata(e, false));
1:f13c6ac:                     } else if (nodeNameEquals(e, REF_ELEMENT)) {
1:f13c6ac:                         if (service.getServiceComponent() != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         String component = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:f13c6ac:                         if (component == null || component.length() == 0) {
1:f13c6ac:                             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:f13c6ac:                         }
1:f13c6ac:                         service.setServiceComponent(new RefMetadataImpl(component));                   
1:f13c6ac:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:f13c6ac:                         if (service.getServiceComponent() != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         service.setServiceComponent((Target) parseReference(e, false));
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Check service
1:f13c6ac:         if (service.getServiceComponent() == null) {
1:f13c6ac:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element must be set");
1:f13c6ac:         }
1:f13c6ac:         // Check interface
1:f13c6ac:         if (service.getAutoExport() == ServiceMetadata.AUTO_EXPORT_DISABLED && service.getInterfaces().isEmpty()) {
1:f13c6ac:             throw new ComponentDefinitionException(INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be set when " + AUTO_EXPORT_ATTRIBUTE + " is set to " + AUTO_EXPORT_DISABLED);
1:f13c6ac:         }
1:f13c6ac:         // Check for non-disabled auto-exports and interfaces
1:f13c6ac:         if (service.getAutoExport() != ServiceMetadata.AUTO_EXPORT_DISABLED && !service.getInterfaces().isEmpty()) {
1:f13c6ac:             throw new ComponentDefinitionException(INTERFACE_ATTRIBUTE + " attribute or  " + INTERFACES_ELEMENT + " element must not be set when " + AUTO_EXPORT_ATTRIBUTE + " is set to anything else than " + AUTO_EXPORT_DISABLED);
1:f13c6ac:         }
1:f13c6ac:         ComponentMetadata s = service;
1:f13c6ac:         
1:f13c6ac:         // Parse custom attributes
1:f13c6ac:         s = handleCustomAttributes(element.getAttributes(), s);
1:f13c6ac: 
1:f13c6ac:         // Parse custom elements;
1:f13c6ac:         s = handleCustomElements(element, s);
1:f13c6ac:         
1:f13c6ac:         return s;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private CollectionMetadata parseArray(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         return parseCollection(Object[].class, element, enclosingComponent);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private CollectionMetadata parseList(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         return parseCollection(List.class, element, enclosingComponent);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private CollectionMetadata parseSet(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         return parseCollection(Set.class, element, enclosingComponent);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private CollectionMetadata parseCollection(Class collectionType, Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         // Parse attributes
1:f13c6ac:         String valueType = element.hasAttribute(VALUE_TYPE_ATTRIBUTE) ? element.getAttribute(VALUE_TYPE_ATTRIBUTE) : null;
1:f13c6ac:         // Parse elements
1:f13c6ac:         List<Metadata> list = new ArrayList<Metadata>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Metadata val = parseValueGroup((Element) node, enclosingComponent, null, true);
1:f13c6ac:                 list.add(val);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return new CollectionMetadataImpl(collectionType, valueType, list);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public PropsMetadata parseProps(Element element) {
1:f13c6ac:         // Parse elements
1:f13c6ac:         List<MapEntry> entries = new ArrayList<MapEntry>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI()) && nodeNameEquals(e, PROP_ELEMENT)) {
1:f13c6ac:                     entries.add(parseProperty(e));
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return new PropsMetadataImpl(entries);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private MapEntry parseProperty(Element element) {
1:f13c6ac:         // Parse attributes
1:f13c6ac:         if (!element.hasAttribute(KEY_ATTRIBUTE)) {
1:f13c6ac:             throw new ComponentDefinitionException(KEY_ATTRIBUTE + " attribute is required");
1:f13c6ac:         }
1:436dc3a:         String value;
1:f13c6ac:         if (element.hasAttribute(VALUE_ATTRIBUTE)) {
1:f13c6ac:             value = element.getAttribute(VALUE_ATTRIBUTE);
1:f13c6ac:         } else {
1:f13c6ac:             value = getTextValue(element);
1:f13c6ac:         }
1:f13c6ac:         String key = element.getAttribute(KEY_ATTRIBUTE);
1:f13c6ac:         return new MapEntryImpl(new ValueMetadataImpl(key), new ValueMetadataImpl(value));
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public MapMetadata parseMap(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         // Parse attributes
1:f13c6ac:         String keyType = element.hasAttribute(KEY_TYPE_ATTRIBUTE) ? element.getAttribute(KEY_TYPE_ATTRIBUTE) : null;
1:f13c6ac:         String valueType = element.hasAttribute(VALUE_TYPE_ATTRIBUTE) ? element.getAttribute(VALUE_TYPE_ATTRIBUTE) : null;
1:f13c6ac:         // Parse elements
1:f13c6ac:         List<MapEntry> entries = new ArrayList<MapEntry>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (nodeNameEquals(e, ENTRY_ELEMENT)) {
1:f13c6ac:                     entries.add(parseMapEntry(e, enclosingComponent, null, null));
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return new MapMetadataImpl(keyType, valueType, entries);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private MapEntry parseMapEntry(Element element, ComponentMetadata enclosingComponent, String keyType, String valueType) {
1:f13c6ac:         // Parse attributes
1:f13c6ac:         String key = element.hasAttribute(KEY_ATTRIBUTE) ? element.getAttribute(KEY_ATTRIBUTE) : null;
1:f13c6ac:         String keyRef = element.hasAttribute(KEY_REF_ATTRIBUTE) ? element.getAttribute(KEY_REF_ATTRIBUTE) : null;
1:f13c6ac:         String value = element.hasAttribute(VALUE_ATTRIBUTE) ? element.getAttribute(VALUE_ATTRIBUTE) : null;
1:f13c6ac:         String valueRef = element.hasAttribute(VALUE_REF_ATTRIBUTE) ? element.getAttribute(VALUE_REF_ATTRIBUTE) : null;
1:f13c6ac:         // Parse elements
1:f13c6ac:         NonNullMetadata keyValue = null;
1:f13c6ac:         Metadata valValue = null;
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (nodeNameEquals(e, KEY_ELEMENT)) {
1:f13c6ac:                     keyValue = parseMapKeyEntry(e, enclosingComponent, keyType);
1:f13c6ac:                 } else {
1:f13c6ac:                     valValue = parseValueGroup(e, enclosingComponent, valueType, true);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Check key
1:f13c6ac:         if (keyValue != null && (key != null || keyRef != null) || (keyValue == null && key == null && keyRef == null)) {
1:f13c6ac:             throw new ComponentDefinitionException("Only and only one of " + KEY_ATTRIBUTE + " attribute, " + KEY_REF_ATTRIBUTE + " attribute or " + KEY_ELEMENT + " element must be set");
1:f13c6ac:         } else if (keyValue == null && key != null) {
1:f13c6ac:             keyValue = new ValueMetadataImpl(key, keyType);
1:f13c6ac:         } else if (keyValue == null /*&& keyRef != null*/) {
1:f13c6ac:             keyValue = new RefMetadataImpl(keyRef);
1:f13c6ac:         }
1:f13c6ac:         // Check value
1:f13c6ac:         if (valValue != null && (value != null || valueRef != null) || (valValue == null && value == null && valueRef == null)) {
1:f13c6ac:             throw new ComponentDefinitionException("Only and only one of " + VALUE_ATTRIBUTE + " attribute, " + VALUE_REF_ATTRIBUTE + " attribute or sub element must be set");
1:f13c6ac:         } else if (valValue == null && value != null) {
1:f13c6ac:             valValue = new ValueMetadataImpl(value, valueType);
1:f13c6ac:         } else if (valValue == null /*&& valueRef != null*/) {
1:f13c6ac:             valValue = new RefMetadataImpl(valueRef);
1:f13c6ac:         }
1:f13c6ac:         return new MapEntryImpl(keyValue, valValue);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private NonNullMetadata parseMapKeyEntry(Element element, ComponentMetadata enclosingComponent, String keyType) {
1:f13c6ac:         NonNullMetadata keyValue = null;
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (keyValue != null) {
1:f13c6ac:                     // TODO: throw an exception
1:f13c6ac:                 }
1:f13c6ac:                 keyValue = (NonNullMetadata) parseValueGroup(e, enclosingComponent, keyType, false);
1:f13c6ac:                 break;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (keyValue == null) {
1:f13c6ac:             // TODO: throw an exception
1:f13c6ac:         }
1:f13c6ac:         return keyValue;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public MapMetadata parseServiceProperties(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         // TODO: need to handle this better
1:f13c6ac:         MapMetadata map = parseMap(element, enclosingComponent);
1:f13c6ac:         handleCustomElements(element, enclosingComponent);
1:f13c6ac:         return map;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public RegistrationListener parseRegistrationListener(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         RegistrationListenerImpl listener = new RegistrationListenerImpl();
1:f13c6ac:         Metadata listenerComponent = null;
1:f13c6ac:         // Parse attributes
1:f13c6ac:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:f13c6ac:             listenerComponent = new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         String registrationMethod = null;
1:f13c6ac:         if (element.hasAttribute(REGISTRATION_METHOD_ATTRIBUTE)) {
1:f13c6ac:             registrationMethod = element.getAttribute(REGISTRATION_METHOD_ATTRIBUTE);
1:f13c6ac:             listener.setRegistrationMethod(registrationMethod);
1:f13c6ac:         }
1:f13c6ac:         String unregistrationMethod = null;
1:f13c6ac:         if (element.hasAttribute(UNREGISTRATION_METHOD_ATTRIBUTE)) {
1:f13c6ac:             unregistrationMethod = element.getAttribute(UNREGISTRATION_METHOD_ATTRIBUTE);
1:f13c6ac:             listener.setUnregistrationMethod(unregistrationMethod);
1:f13c6ac:         }
1:f13c6ac:         if (registrationMethod == null && unregistrationMethod == null) {
1:f13c6ac:             throw new ComponentDefinitionException("One of " + REGISTRATION_METHOD_ATTRIBUTE + " or " + UNREGISTRATION_METHOD_ATTRIBUTE + " must be set");
1:f13c6ac:         }
1:f13c6ac:         // Parse elements
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, REF_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         String component = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:f13c6ac:                         if (component == null || component.length() == 0) {
1:f13c6ac:                             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = new RefMetadataImpl(component);
1:f13c6ac:                     } else if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = parseBeanMetadata(e, false);
1:f13c6ac:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = parseReference(e, false);
1:f13c6ac:                     } else if (nodeNameEquals(e, SERVICE_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = parseService(e, false);
1:f13c6ac:                     }
1:f13c6ac:                 } else {
1:f13c6ac:                     if (listenerComponent != null) {
1:f13c6ac:                         throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                     }
1:f13c6ac:                     listenerComponent = parseCustomElement(e, enclosingComponent);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (listenerComponent == null) {
1:f13c6ac:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element must be set");
1:f13c6ac:         }
1:f13c6ac:         listener.setListenerComponent((Target) listenerComponent);
1:f13c6ac:         return listener;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ComponentMetadata parseReference(Element element, boolean topElement) {       
1:f13c6ac:         ReferenceMetadataImpl reference = new ReferenceMetadataImpl();
1:f13c6ac:         if (topElement) {
1:f13c6ac:             reference.setId(getId(element));
1:f13c6ac:         }
1:f13c6ac:         parseReference(element, reference, topElement);
1:f13c6ac:         String timeout = element.hasAttribute(TIMEOUT_ATTRIBUTE) ? element.getAttribute(TIMEOUT_ATTRIBUTE) : this.defaultTimeout;
1:f13c6ac:         try {
1:f13c6ac:             reference.setTimeout(Long.parseLong(timeout));
1:f13c6ac:         } catch (NumberFormatException e) {
1:f13c6ac:             throw new ComponentDefinitionException("Attribute " + TIMEOUT_ATTRIBUTE + " must be a valid long (was: " + timeout + ")");
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         ComponentMetadata r = reference;
1:f13c6ac: 
1:f13c6ac:         // Parse custom attributes
1:f13c6ac:         r = handleCustomAttributes(element.getAttributes(), r);
1:f13c6ac: 
1:f13c6ac:         // Parse custom elements;
1:f13c6ac:         r = handleCustomElements(element, r);
1:f13c6ac:         
1:f13c6ac:         return r;
1:f13c6ac:     }
1:f13c6ac: 
1:1cfd24a:     public String getDefaultTimeout() {
1:1cfd24a:         return defaultTimeout;
1:f13c6ac:     }
1:1cfd24a: 
1:1cfd24a:     public String getDefaultAvailability() {
1:1cfd24a:         return defaultAvailability;
1:1cfd24a:     }
1:1cfd24a: 
1:1cfd24a:     public String getDefaultActivation() {
1:1cfd24a:         return defaultActivation;
1:1cfd24a:     }
1:1cfd24a: 
1:f13c6ac:     private ComponentMetadata parseRefList(Element element, boolean topElement) {
1:f13c6ac:         ReferenceListMetadataImpl references = new ReferenceListMetadataImpl();
1:f13c6ac:         if (topElement) {
1:f13c6ac:             references.setId(getId(element));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(MEMBER_TYPE_ATTRIBUTE)) {
1:f13c6ac:             String memberType = element.getAttribute(MEMBER_TYPE_ATTRIBUTE);
1:f13c6ac:             if (USE_SERVICE_OBJECT.equals(memberType)) {
1:f13c6ac:                 references.setMemberType(ReferenceListMetadata.USE_SERVICE_OBJECT);
1:f13c6ac:             } else if (USE_SERVICE_REFERENCE.equals(memberType)) {
1:f13c6ac:                 references.setMemberType(ReferenceListMetadata.USE_SERVICE_REFERENCE);
1:f13c6ac:             }
1:f13c6ac:         } else {
1:f13c6ac:             references.setMemberType(ReferenceListMetadata.USE_SERVICE_OBJECT);
1:f13c6ac:         }
1:f13c6ac:         parseReference(element, references, topElement);
1:f13c6ac: 
1:f13c6ac:         ComponentMetadata r = references;
1:f13c6ac:         
1:f13c6ac:         // Parse custom attributes
1:f13c6ac:         r = handleCustomAttributes(element.getAttributes(), r);
1:f13c6ac: 
1:f13c6ac:         // Parse custom elements;
1:f13c6ac:         r = handleCustomElements(element, r);
1:f13c6ac:         
1:f13c6ac:         return r;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void parseReference(Element element, ServiceReferenceMetadataImpl reference, boolean topElement) {
1:f13c6ac:         // Parse attributes
1:f13c6ac:         if (topElement) {
1:f13c6ac:             reference.setActivation(parseActivation(element));
1:f13c6ac:         } else {
1:f13c6ac:             reference.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
1:f13c6ac:             reference.setDependsOn(parseList(element.getAttribute(DEPENDS_ON_ATTRIBUTE)));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(INTERFACE_ATTRIBUTE)) {
1:f13c6ac:             reference.setInterface(element.getAttribute(INTERFACE_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(FILTER_ATTRIBUTE)) {
1:f13c6ac:             reference.setFilter(element.getAttribute(FILTER_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(COMPONENT_NAME_ATTRIBUTE)) {
1:f13c6ac:             reference.setComponentName(element.getAttribute(COMPONENT_NAME_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         String availability = element.hasAttribute(AVAILABILITY_ATTRIBUTE) ? element.getAttribute(AVAILABILITY_ATTRIBUTE) : defaultAvailability;
1:f13c6ac:         if (AVAILABILITY_MANDATORY.equals(availability)) {
1:f13c6ac:             reference.setAvailability(ServiceReferenceMetadata.AVAILABILITY_MANDATORY);
1:f13c6ac:         } else if (AVAILABILITY_OPTIONAL.equals(availability)) {
1:f13c6ac:             reference.setAvailability(ServiceReferenceMetadata.AVAILABILITY_OPTIONAL);
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Illegal value for " + AVAILABILITY_ATTRIBUTE + " attribute: " + availability);
1:f13c6ac:         }
1:f13c6ac:         // Parse elements
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, REFERENCE_LISTENER_ELEMENT)) {
1:f13c6ac:                         reference.addServiceListener(parseServiceListener(e, reference));
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ReferenceListener parseServiceListener(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         ReferenceListenerImpl listener = new ReferenceListenerImpl();
1:f13c6ac:         Metadata listenerComponent = null;
1:f13c6ac:         // Parse attributes
1:f13c6ac:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:f13c6ac:             listenerComponent = new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE));
1:f13c6ac:         }
1:f13c6ac:         String bindMethodName = null;
1:f13c6ac:         String unbindMethodName = null;
1:f13c6ac:         if (element.hasAttribute(BIND_METHOD_ATTRIBUTE)) {
1:f13c6ac:             bindMethodName = element.getAttribute(BIND_METHOD_ATTRIBUTE);
1:f13c6ac:             listener.setBindMethod(bindMethodName);
1:f13c6ac:         }
1:f13c6ac:         if (element.hasAttribute(UNBIND_METHOD_ATTRIBUTE)) {
1:f13c6ac:             unbindMethodName = element.getAttribute(UNBIND_METHOD_ATTRIBUTE);
1:f13c6ac:             listener.setUnbindMethod(unbindMethodName);
1:f13c6ac:         }
1:f13c6ac:         if (bindMethodName == null && unbindMethodName == null) {
1:f13c6ac:             throw new ComponentDefinitionException("One of " + BIND_METHOD_ATTRIBUTE + " or " + UNBIND_METHOD_ATTRIBUTE + " must be set");
1:f13c6ac:         }
1:f13c6ac:         // Parse elements
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, REF_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         String component = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:f13c6ac:                         if (component == null || component.length() == 0) {
1:f13c6ac:                             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = new RefMetadataImpl(component);
1:f13c6ac:                     } else if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = parseBeanMetadata(e, false);
1:f13c6ac:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = parseReference(e, false);
1:f13c6ac:                     } else if (nodeNameEquals(e, SERVICE_ELEMENT)) {
1:f13c6ac:                         if (listenerComponent != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                         }
1:f13c6ac:                         listenerComponent = parseService(e, false);
1:f13c6ac:                     }
1:f13c6ac:                 } else {
1:f13c6ac:                     if (listenerComponent != null) {
1:f13c6ac:                         throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:f13c6ac:                     }
1:f13c6ac:                     listenerComponent = parseCustomElement(e, enclosingComponent);
1:f13c6ac:                 }
1:f13c6ac:             }
2:8ae47e0:         }
1:f13c6ac:         if (listenerComponent == null) {
1:f13c6ac:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element must be set");
1:f13c6ac:         }
1:f13c6ac:         listener.setListenerComponent((Target) listenerComponent);
1:f13c6ac:         return listener;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public List<String> parseInterfaceNames(Element element) {
1:f13c6ac:         List<String> interfaceNames = new ArrayList<String>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (nodeNameEquals(e, VALUE_ELEMENT)) {
1:f13c6ac:                     String v = getTextValue(e).trim();
1:f13c6ac:                     if (interfaceNames.contains(v)) {
1:f13c6ac:                         throw new ComponentDefinitionException("The element " + INTERFACES_ELEMENT + " should not contain the same interface twice");
1:f13c6ac:                     }
1:f13c6ac:                     interfaceNames.add(getTextValue(e));
1:f13c6ac:                 } else {
1:f13c6ac:                     throw new ComponentDefinitionException("Unsupported element " + e.getNodeName() + " inside an " + INTERFACES_ELEMENT + " element");
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return interfaceNames;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Metadata parseArgumentOrPropertyValue(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         Metadata [] values = new Metadata[3];
1:f13c6ac:         
1:f13c6ac:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:f13c6ac:             values[0] = new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE));
1:f13c6ac:         } 
1:f13c6ac:         
1:f13c6ac:         if (element.hasAttribute(VALUE_ATTRIBUTE)) {
1:f13c6ac:             values[1] = new ValueMetadataImpl(element.getAttribute(VALUE_ATTRIBUTE));
1:f13c6ac:         } 
1:f13c6ac:         
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:f13c6ac:                 if (isBlueprintNamespace(node.getNamespaceURI()) && nodeNameEquals(node, DESCRIPTION_ELEMENT)) {
1:f13c6ac:                     // Ignore description elements
1:f13c6ac:                 } else {
1:f13c6ac:                     values[2] = parseValueGroup(e, enclosingComponent, null, true);                    
1:f13c6ac:                     break;
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         Metadata value = null;
1:f13c6ac:         for (Metadata v : values) {
1:f13c6ac:             if (v != null) {
1:f13c6ac:                 if (value == null) {
1:f13c6ac:                     value = v;
1:f13c6ac:                 } else {
1:f13c6ac:                     throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + VALUE_ATTRIBUTE + " attribute or sub element must be set");
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         if (value == null) {
1:f13c6ac:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + VALUE_ATTRIBUTE + " attribute or sub element must be set");
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         return value;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Metadata parseValueGroup(Element element, ComponentMetadata enclosingComponent, String collectionType, boolean allowNull) {
1:f13c6ac:         if (isBlueprintNamespace(element.getNamespaceURI())) {
1:f13c6ac:             if (nodeNameEquals(element, BEAN_ELEMENT)) {
1:f13c6ac:                 return parseBeanMetadata(element, false);
1:f13c6ac:             } else if (nodeNameEquals(element, REFERENCE_ELEMENT)) {
1:f13c6ac:                 return parseReference(element, false);
1:f13c6ac:             } else if (nodeNameEquals(element, SERVICE_ELEMENT)) {
1:f13c6ac:                 return parseService(element, false);
1:f13c6ac:             } else if (nodeNameEquals(element, REFERENCE_LIST_ELEMENT) ) {
1:f13c6ac:                 return parseRefList(element, false);
1:f13c6ac:             } else if (nodeNameEquals(element, NULL_ELEMENT) && allowNull) {
1:f13c6ac:                 return NullMetadata.NULL;
1:f13c6ac:             } else if (nodeNameEquals(element, VALUE_ELEMENT)) {
1:f13c6ac:                 return parseValue(element, collectionType);
1:f13c6ac:             } else if (nodeNameEquals(element, REF_ELEMENT)) {
1:f13c6ac:                 return parseRef(element);
1:f13c6ac:             } else if (nodeNameEquals(element, IDREF_ELEMENT)) {
1:f13c6ac:                 return parseIdRef(element);
1:f13c6ac:             } else if (nodeNameEquals(element, LIST_ELEMENT)) {
1:f13c6ac:                 return parseList(element, enclosingComponent);
1:f13c6ac:             } else if (nodeNameEquals(element, SET_ELEMENT)) {
1:f13c6ac:                 return parseSet(element, enclosingComponent);
1:f13c6ac:             } else if (nodeNameEquals(element, MAP_ELEMENT)) {
1:f13c6ac:                 return parseMap(element, enclosingComponent);
1:f13c6ac:             } else if (nodeNameEquals(element, PROPS_ELEMENT)) {
1:f13c6ac:                 return parseProps(element);
1:f13c6ac:             } else if (nodeNameEquals(element, ARRAY_ELEMENT)) {
1:f13c6ac:                 return parseArray(element, enclosingComponent);
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Unknown blueprint element " + element.getNodeName());
1:f13c6ac:             }
1:f13c6ac:         } else {
1:f13c6ac:             return parseCustomElement(element, enclosingComponent);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ValueMetadata parseValue(Element element, String collectionType) {
1:436dc3a:         String type;
1:f13c6ac:         if (element.hasAttribute(TYPE_ATTRIBUTE)) {
1:f13c6ac:             type = element.getAttribute(TYPE_ATTRIBUTE);
1:f13c6ac:         } else {
1:f13c6ac:             type = collectionType;
1:f13c6ac:         }
1:f13c6ac:         return new ValueMetadataImpl(getTextValue(element), type);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private RefMetadata parseRef(Element element) {
1:f13c6ac:         String component = element.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:f13c6ac:         if (component == null || component.length() == 0) {
1:f13c6ac:             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:f13c6ac:         }
1:f13c6ac:         return new RefMetadataImpl(component);
1:f13c6ac:     }
1:f13c6ac:     private Metadata parseIdRef(Element element) {
1:f13c6ac:         String component = element.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:f13c6ac:         if (component == null || component.length() == 0) {
1:f13c6ac:             throw new ComponentDefinitionException("Element " + IDREF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:f13c6ac:         }
1:f13c6ac:         return new IdRefMetadataImpl(component);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private int parseActivation(Element element) {
1:f13c6ac:         String initialization = element.hasAttribute(ACTIVATION_ATTRIBUTE) ? element.getAttribute(ACTIVATION_ATTRIBUTE) : defaultActivation;
1:f13c6ac:         if (ACTIVATION_EAGER.equals(initialization)) {
1:f13c6ac:             return ComponentMetadata.ACTIVATION_EAGER;
1:f13c6ac:         } else if (ACTIVATION_LAZY.equals(initialization)) {
1:f13c6ac:             return ComponentMetadata.ACTIVATION_LAZY;
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Attribute " + ACTIVATION_ATTRIBUTE + " must be equal to " + ACTIVATION_EAGER + " or " + ACTIVATION_LAZY);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private ComponentMetadata handleCustomAttributes(NamedNodeMap attributes, ComponentMetadata enclosingComponent) {
2:f13c6ac:         if (attributes != null) {
2:f13c6ac:             for (int i = 0; i < attributes.getLength(); i++) {
2:f13c6ac:                 Node node = attributes.item(i);
1:8ae47e0:                 //attr is custom if it has a namespace, and it isnt blueprint, or the xmlns ns. 
1:8ae47e0:                 //blueprint ns would be an error, as blueprint attrs are unqualified.
1:f13c6ac:                 if (node instanceof Attr && 
1:f13c6ac:                     node.getNamespaceURI() != null && 
1:8ae47e0:                     !isBlueprintNamespace(node.getNamespaceURI()) &&
1:53633a9:                     !isIgnorableAttributeNamespace(node.getNamespaceURI()) ) {
1:f13c6ac:                     enclosingComponent = decorateCustomNode(node, enclosingComponent);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return enclosingComponent;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private ComponentMetadata handleCustomElements(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 if (!isBlueprintNamespace(node.getNamespaceURI())) {
1:f13c6ac:                     enclosingComponent = decorateCustomNode(node, enclosingComponent);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return enclosingComponent;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private ComponentMetadata decorateCustomNode(Node node, ComponentMetadata enclosingComponent) {
1:f13c6ac:         NamespaceHandler handler = getNamespaceHandler(node);
1:f13c6ac:         ParserContextImpl context = new ParserContextImpl(this, registry, enclosingComponent, node);
1:f13c6ac:         return handler.decorate(node, enclosingComponent, context);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Metadata parseCustomElement(Element element, ComponentMetadata enclosingComponent) {
1:f13c6ac:         NamespaceHandler handler = getNamespaceHandler(element);
1:f13c6ac:         ParserContextImpl context = new ParserContextImpl(this, registry, enclosingComponent, element);
1:f13c6ac:         return handler.parse(element, context);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private NamespaceHandler getNamespaceHandler(Node node) {
1:f13c6ac:         URI ns = URI.create(node.getNamespaceURI());
1:436dc3a:         return getNamespaceHandler(ns);
1:f13c6ac:     }
1:e594ebc: 
1:47d3353:     public NamespaceHandler getNamespaceHandler(URI uri) {
1:3b2c33b:         if (handlers == null) {
1:8ae47e0:             throw new ComponentDefinitionException("Unsupported node (namespace handler registry is not set): " + uri);
1:8ae47e0:         }
1:8ae47e0:         NamespaceHandler handler = this.handlers.getNamespaceHandler(uri);
1:f13c6ac:         if (handler == null) {
1:3cfe3e2:             if (ignoreUnknownNamespaces) {
1:3cfe3e2:                 return missingNamespace;
1:f13c6ac:             }
1:8ae47e0:             throw new ComponentDefinitionException("Unsupported node namespace: " + uri);
1:3cfe3e2:         }
1:f13c6ac:         return handler;
1:f13c6ac:     }
1:f13c6ac: 
1:1cfd24a:     public String generateId() {
1:f13c6ac:         String id;
1:f13c6ac:         do {
1:f13c6ac:             id = "." + idPrefix + ++idCounter;
1:f13c6ac:         } while (ids.contains(id));
2:1cfd24a:         ids.add(id);
1:1cfd24a:         return id;        
1:1cfd24a:     }
1:1cfd24a:     
1:f13c6ac:     public String getId(Element element) {
1:1cfd24a:         String id;
1:f13c6ac:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:f13c6ac:             id = element.getAttribute(ID_ATTRIBUTE);
1:f13c6ac:             ids.add(id);
1:f13c6ac:         } else {
1:1cfd24a:             id = generateId();
1:f13c6ac:         }
1:f13c6ac:         return id;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static boolean isBlueprintNamespace(String ns) {
1:f13c6ac:         return BLUEPRINT_NAMESPACE.equals(ns);
1:f13c6ac:     }
1:f13c6ac: 
1:53633a9:     /**
1:53633a9:      * Test if this namespace uri does not require a Namespace Handler.<p>
1:baa10f5:      * 
1:53633a9:      * @param ns URI to be tested.
1:53633a9:      * @return true if the uri does not require a namespace handler.
1:53633a9:      */
1:53633a9:     public static boolean isIgnorableAttributeNamespace(String ns) {
1:53633a9:         return XMLConstants.RELAXNG_NS_URI.equals(ns) ||
1:53633a9:                XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI.equals(ns) || 
1:53633a9:                XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(ns) ||
1:53633a9:                XMLConstants.W3C_XPATH_DATATYPE_NS_URI.equals(ns) ||
1:53633a9:                XMLConstants.W3C_XPATH_DATATYPE_NS_URI.equals(ns) ||
1:53633a9:                XMLConstants.XML_DTD_NS_URI.equals(ns) ||
1:53633a9:                XMLConstants.XML_NS_URI.equals(ns) || 
1:53633a9:                XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(ns);
1:53633a9:     }
1:f13c6ac:     
1:f13c6ac:     private static boolean nodeNameEquals(Node node, String name) {
1:f13c6ac:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static List<String> parseList(String list) {
1:f13c6ac:         String[] items = list.split(" ");
1:f13c6ac:         List<String> set = new ArrayList<String>();
1:f13c6ac:         for (String item : items) {
1:f13c6ac:             item = item.trim();
1:f13c6ac:             if (item.length() > 0) {
1:f13c6ac:                 set.add(item);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return set;                   
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static String getTextValue(Element element) {
1:f13c6ac:         StringBuffer value = new StringBuffer();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node item = nl.item(i);
1:f13c6ac:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:f13c6ac:                 value.append(item.getNodeValue());
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return value.toString();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static DocumentBuilderFactory getDocumentBuilderFactory() {
1:f13c6ac:         if (documentBuilderFactory == null) {
1:f13c6ac:             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
1:f13c6ac:             dbf.setNamespaceAware(true);
1:f13c6ac:             documentBuilderFactory = dbf;
1:f13c6ac:         }
1:f13c6ac:         return documentBuilderFactory;
1:f13c6ac:     }
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:220c392
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.XMLConstants;
1: import javax.xml.namespace.QName;
1: import javax.xml.parsers.DocumentBuilder;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: import javax.xml.transform.dom.DOMSource;
1: import javax.xml.validation.Schema;
1: import javax.xml.validation.Validator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void validatePsvi(Schema schema) {
1:         try {
1:             // In order to support validation with the built-in xml parser
1:             // from the JDK, we can't use Validator.validate(source, result)
1:             // as it fails with an exception, see
1:             //   https://issues.apache.org/jira/browse/XERCESJ-1212
1:             // This was fixed in xerces 2.9.0 years ago but still is not
1:             // included in my JDK.
1:             List<String> locations = new ArrayList<String>();
1:             for (Document doc : documents) {
1:                 locations.add(doc.getDocumentURI());
1:             }
1:             List<Document> validated = new ArrayList<Document>();
1:             for (String location : locations) {
1:                 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
1:                 factory.setNamespaceAware(true);
1:                 factory.setSchema(schema);
1:                 DocumentBuilder builder = factory.newDocumentBuilder();
1:                 InputSource inputSource = new InputSource(location);
1:                 Document doc = builder.parse(inputSource);
1:                 validated.add(doc);
1:             }
1:             this.documents.clear();
1:             this.documents.addAll(validated);
1:         } catch (Exception e) {
1:             throw new ComponentDefinitionException("Unable to validate xml", e);
1:         }
1:     }
1: 
commit:5a5f2a0
/////////////////////////////////////////////////////////////////////////
1:       parse(null, inputStream);
1: 
1:     public void parse(String location, InputStream inputStream) throws Exception {
1:         InputSource inputSource = new InputSource(inputStream);
1:         inputSource.setSystemId(location);
1:         DocumentBuilder builder = getDocumentBuilderFactory().newDocumentBuilder();
1:         Document doc = builder.parse(inputSource);
1:         documents.add(doc);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 parse (url.toString(), inputStream);
commit:47d3353
/////////////////////////////////////////////////////////////////////////
1:     public NamespaceHandler getNamespaceHandler(URI uri) {
commit:f117d81
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     private Map<String, String> locations;
/////////////////////////////////////////////////////////////////////////
1:             Map<String, String> locations = new HashMap<String, String>();
1:                 findNamespaces(namespaces, locations, doc);
1:             this.locations = locations;
1:     public Map<String, String> getSchemaLocations() {
1:         getNamespaces();
1:         return locations;
1:     }
1: 
1:     private void findNamespaces(Set<URI> namespaces, Map<String, String> locations, Node node) {
1:             if ("http://www.w3.org/2001/XMLSchema-instance".equals(ns)
1:                     && node instanceof Attr
1:                     && "schemaLocation".equals(node.getLocalName())) {
1:                 String val = ((Attr) node).getValue();
1:                 List<String> locs = new ArrayList<String>(Arrays.asList(val.split("\\s+")));
1:                 locs.remove("");
1:                 for (int i = 0; i < locs.size() / 2; i++) {
1:                     locations.put(locs.get(i * 2), locs.get(i * 2 + 1));
1:                 }
1:             } else if (ns != null && !isBlueprintNamespace(ns) && !isIgnorableAttributeNamespace(ns)) {
1:             } else if (ns == null && //attributes from blueprint are unqualified as per schema.
/////////////////////////////////////////////////////////////////////////
1:                 findNamespaces(namespaces, locations, nnm.item(i));
1:             findNamespaces(namespaces, locations, nl.item(i));
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
0:     private NamespaceHandlerRegistry.NamespaceHandlerSet handlers;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void populate(NamespaceHandlerRegistry.NamespaceHandlerSet handlers,
1:         this.handlers = handlers;
1:     public void validate(Schema schema) {
/////////////////////////////////////////////////////////////////////////
1:         if (handlers == null) {
0:         NamespaceHandler handler = this.handlers.getNamespaceHandler(ns);
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.io.InputStream;
1: import java.net.URI;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import java.util.LinkedHashSet;
1: import java.util.List;
1: import java.util.Set;
1: 
0: import javax.xml.XMLConstants;
0: import javax.xml.parsers.DocumentBuilder;
0: import javax.xml.parsers.DocumentBuilderFactory;
0: import javax.xml.transform.dom.DOMSource;
0: import javax.xml.validation.Schema;
0: import javax.xml.validation.Validator;
1: 
1: import org.w3c.dom.Attr;
1: import org.w3c.dom.CharacterData;
1: import org.w3c.dom.Comment;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.EntityReference;
1: import org.w3c.dom.NamedNodeMap;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1: 
0: import org.apache.geronimo.blueprint.ComponentDefinitionRegistry;
0: import org.apache.geronimo.blueprint.NamespaceHandler;
0: import org.apache.geronimo.blueprint.reflect.BeanArgumentImpl;
0: import org.apache.geronimo.blueprint.reflect.BeanMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.BeanPropertyImpl;
0: import org.apache.geronimo.blueprint.reflect.CollectionMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.IdRefMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.MapEntryImpl;
0: import org.apache.geronimo.blueprint.reflect.MapMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.MetadataUtil;
0: import org.apache.geronimo.blueprint.reflect.PropsMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.RefMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.ReferenceListMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.ReferenceListenerImpl;
0: import org.apache.geronimo.blueprint.reflect.ReferenceMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.RegistrationListenerImpl;
0: import org.apache.geronimo.blueprint.reflect.ServiceMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.ServiceReferenceMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.ValueMetadataImpl;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.BeanArgument;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1: import org.osgi.service.blueprint.reflect.MapEntry;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.NonNullMetadata;
1: import org.osgi.service.blueprint.reflect.NullMetadata;
1: import org.osgi.service.blueprint.reflect.PropsMetadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.Target;
1: import org.osgi.service.blueprint.reflect.ValueMetadata;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: import org.xml.sax.InputSource;
1: 
1: /**
1:  * TODO: javadoc
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
1: public class Parser {
1: 
1:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1: 
1:     public static final String BLUEPRINT_ELEMENT = "blueprint";
1:     public static final String DESCRIPTION_ELEMENT = "description";
1:     public static final String TYPE_CONVERTERS_ELEMENT = "type-converters";
1:     public static final String BEAN_ELEMENT = "bean";
1:     public static final String ARGUMENT_ELEMENT = "argument";
1:     public static final String REF_ELEMENT = "ref";
1:     public static final String IDREF_ELEMENT = "idref";
1:     public static final String LIST_ELEMENT = "list";
1:     public static final String SET_ELEMENT = "set";
1:     public static final String MAP_ELEMENT = "map";
1:     public static final String ARRAY_ELEMENT = "array";
1:     public static final String PROPS_ELEMENT = "props";
1:     public static final String PROP_ELEMENT = "prop";
1:     public static final String PROPERTY_ELEMENT = "property";
1:     public static final String NULL_ELEMENT = "null";
1:     public static final String VALUE_ELEMENT = "value";
1:     public static final String SERVICE_ELEMENT = "service";
1:     public static final String REFERENCE_ELEMENT = "reference";
1:     public static final String REFERENCE_LIST_ELEMENT = "reference-list";
1:     public static final String INTERFACES_ELEMENT = "interfaces";
1:     public static final String REFERENCE_LISTENER_ELEMENT = "reference-listener";
1:     public static final String SERVICE_PROPERTIES_ELEMENT = "service-properties";
1:     public static final String REGISTRATION_LISTENER_ELEMENT = "registration-listener";
1:     public static final String ENTRY_ELEMENT = "entry";
1:     public static final String KEY_ELEMENT = "key";
1:     public static final String DEFAULT_ACTIVATION_ATTRIBUTE = "default-activation";
1:     public static final String DEFAULT_TIMEOUT_ATTRIBUTE = "default-timeout";
1:     public static final String DEFAULT_AVAILABILITY_ATTRIBUTE = "default-availability";
1:     public static final String NAME_ATTRIBUTE = "name";
1:     public static final String ID_ATTRIBUTE = "id";
1:     public static final String CLASS_ATTRIBUTE = "class";
1:     public static final String INDEX_ATTRIBUTE = "index";
1:     public static final String TYPE_ATTRIBUTE = "type";
1:     public static final String VALUE_ATTRIBUTE = "value";
1:     public static final String VALUE_REF_ATTRIBUTE = "value-ref";
1:     public static final String KEY_ATTRIBUTE = "key";
1:     public static final String KEY_REF_ATTRIBUTE = "key-ref";
1:     public static final String REF_ATTRIBUTE = "ref";
1:     public static final String COMPONENT_ID_ATTRIBUTE = "component-id";
1:     public static final String INTERFACE_ATTRIBUTE = "interface";
1:     public static final String DEPENDS_ON_ATTRIBUTE = "depends-on";
1:     public static final String AUTO_EXPORT_ATTRIBUTE = "auto-export";
1:     public static final String RANKING_ATTRIBUTE = "ranking";
1:     public static final String TIMEOUT_ATTRIBUTE = "timeout";
1:     public static final String FILTER_ATTRIBUTE = "filter";
1:     public static final String COMPONENT_NAME_ATTRIBUTE = "component-name";
1:     public static final String AVAILABILITY_ATTRIBUTE = "availability";
1:     public static final String REGISTRATION_METHOD_ATTRIBUTE = "registration-method";
1:     public static final String UNREGISTRATION_METHOD_ATTRIBUTE = "unregistration-method";
1:     public static final String BIND_METHOD_ATTRIBUTE = "bind-method";
1:     public static final String UNBIND_METHOD_ATTRIBUTE = "unbind-method";
1:     public static final String KEY_TYPE_ATTRIBUTE = "key-type";
1:     public static final String VALUE_TYPE_ATTRIBUTE = "value-type";
1:     public static final String MEMBER_TYPE_ATTRIBUTE = "member-type";
1:     public static final String SCOPE_ATTRIBUTE = "scope";
1:     public static final String INIT_METHOD_ATTRIBUTE = "init-method";
1:     public static final String DESTROY_METHOD_ATTRIBUTE = "destroy-method";
1:     public static final String ACTIVATION_ATTRIBUTE = "activation";
1:     public static final String FACTORY_REF_ATTRIBUTE = "factory-ref";
1:     public static final String FACTORY_METHOD_ATTRIBUTE = "factory-method";
1: 
1:     public static final String AUTO_EXPORT_DISABLED = "disabled";
1:     public static final String AUTO_EXPORT_INTERFACES = "interfaces";
1:     public static final String AUTO_EXPORT_CLASS_HIERARCHY = "class-hierarchy";
1:     public static final String AUTO_EXPORT_ALL = "all-classes";
1:     public static final String AUTO_EXPORT_DEFAULT = AUTO_EXPORT_DISABLED;
1:     public static final String RANKING_DEFAULT = "0";
1:     public static final String AVAILABILITY_MANDATORY = "mandatory";
1:     public static final String AVAILABILITY_OPTIONAL = "optional";
1:     public static final String AVAILABILITY_DEFAULT = AVAILABILITY_MANDATORY;
1:     public static final String TIMEOUT_DEFAULT = "300000";
1:     public static final String USE_SERVICE_OBJECT = "service-object";
1:     public static final String USE_SERVICE_REFERENCE = "service-reference";
1:     public static final String ACTIVATION_EAGER = "eager";
1:     public static final String ACTIVATION_LAZY = "lazy";
1:     public static final String ACTIVATION_DEFAULT = ACTIVATION_EAGER;
1:     
0:     private static final Logger LOGGER = LoggerFactory.getLogger(Parser.class);
1: 
1:     private static DocumentBuilderFactory documentBuilderFactory;
1: 
0:     private List<Document> documents;
1:     private ComponentDefinitionRegistry registry;
0:     private NamespaceHandlerRegistry namespaceHandlerRegistry;
0:     private String idPrefix = "component-";
0:     private Set<String> ids = new HashSet<String>();
1:     private int idCounter;
1:     private String defaultTimeout;
1:     private String defaultAvailability;
1:     private String defaultActivation;
1:     private Set<URI> namespaces;
0:     private boolean validation;
0:     private boolean validated;
1: 
1:     public Parser() {
1:     }
1: 
1:     public Parser(String idPrefix) {
0:         this.idPrefix = idPrefix;
1:     }
1: 
0:     public void setValidation(boolean validation) {
0:         this.validation = validation;
1:     }
1: 
1:     public void parse(List<URL> urls) throws Exception {
0:         List<Document> documents = new ArrayList<Document>();
1:         // Create document builder factory
1:         // Load documents
1:         for (URL url : urls) {
1:             InputStream inputStream = url.openStream();
1:             try {
0:                 InputSource inputSource = new InputSource(inputStream);
0:                 DocumentBuilder builder = getDocumentBuilderFactory().newDocumentBuilder();
0:                 Document doc = builder.parse(inputSource);
0:                 documents.add(doc);
1:             } finally {
1:                 inputStream.close();
1:             }
1:         }
0:         this.documents = documents;
1:     }
1: 
1:     public Set<URI> getNamespaces() {
1:         if (this.namespaces == null) {
0:             if (documents == null) {
0:                 throw new IllegalStateException("Documents should be parsed before retrieving required namespaces");
1:             }
1:             Set<URI> namespaces = new LinkedHashSet<URI>();
1:             for (Document doc : documents) {
0:                 findNamespaces(namespaces, doc);
1:             }
1:             this.namespaces = namespaces;
1:         }
1:         return this.namespaces;
1:     }
1: 
0:     private void findNamespaces(Set<URI> namespaces, Node node) {
1:         if (node instanceof Element || node instanceof Attr) {
1:             String ns = node.getNamespaceURI();
0:             if (ns != null && !isBlueprintNamespace(ns)) {
1:                 namespaces.add(URI.create(ns));
1:             }
1:         }
1:         NodeList nl = node.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
0:             findNamespaces(namespaces, nl.item(i));
1:         }
1:     }
1: 
0:     public void populate(NamespaceHandlerRegistry handlers,
1:                          ComponentDefinitionRegistry registry) {
0:         this.namespaceHandlerRegistry = handlers;
1:         this.registry = registry;
1:         if (this.documents == null) {
1:             throw new IllegalStateException("Documents should be parsed before populating the registry");
1:         }
0:         // Validate xmls
0:         if (!this.validated && validation) {
0:             validate();
0:             this.validated = true;
1:         }
1:         // Parse components
1:         for (Document doc : this.documents) {
1:             loadComponents(doc);
1:         }
1:     }
1: 
0:     private void validate() {
0:         // Use a LinkedHashSet to ensure that the blueprint schema is loaded first
1:         try {
0:             Schema schema = this.namespaceHandlerRegistry.getSchema(getNamespaces());
1:             Validator validator = schema.newValidator();
1:             for (Document doc : this.documents) {
1:                 validator.validate(new DOMSource(doc));
1:             }
1:         } catch (Exception e) {
1:             throw new ComponentDefinitionException("Unable to validate xml", e);
1:         }
1:     }
1: 
1:     private void loadComponents(Document doc) {
1:         defaultTimeout = TIMEOUT_DEFAULT;
1:         defaultAvailability = AVAILABILITY_DEFAULT;
1:         defaultActivation = ACTIVATION_DEFAULT;
1:         Element root = doc.getDocumentElement();
1:         if (!isBlueprintNamespace(root.getNamespaceURI()) ||
1:                 !nodeNameEquals(root, BLUEPRINT_ELEMENT)) {
1:             throw new ComponentDefinitionException("Root element must be {" + BLUEPRINT_NAMESPACE + "}" + BLUEPRINT_ELEMENT + " element");
1:         }
1:         // Parse global attributes
1:         if (root.hasAttribute(DEFAULT_ACTIVATION_ATTRIBUTE)) {
1:             defaultActivation = root.getAttribute(DEFAULT_ACTIVATION_ATTRIBUTE);
1:         }
1:         if (root.hasAttribute(DEFAULT_TIMEOUT_ATTRIBUTE)) {
1:             defaultTimeout = root.getAttribute(DEFAULT_TIMEOUT_ATTRIBUTE);
1:         }
1:         if (root.hasAttribute(DEFAULT_AVAILABILITY_ATTRIBUTE)) {
1:             defaultAvailability = root.getAttribute(DEFAULT_AVAILABILITY_ATTRIBUTE);
1:         }
1:         
1:         // Parse custom attributes
0:         NamedNodeMap attributes = root.getAttributes();
1:         if (attributes != null) {
1:             for (int i = 0; i < attributes.getLength(); i++) {
1:                 Node node = attributes.item(i);
0:                 if (node instanceof Attr
0:                         && node.getNamespaceURI() != null
0:                         && !isBlueprintNamespace(node.getNamespaceURI())
0:                         && !XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(node.getNamespaceURI())
0:                         && XMLConstants.XMLNS_ATTRIBUTE.equals(node.getNodeName())) {
0:                     decorateCustomNode(node, null);
1:                 }
1:             }
1:         }
1: 
1:         // Parse elements
1:         NodeList nl = root.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element element = (Element) node;
1:                 String namespaceUri = element.getNamespaceURI();
1:                 if (isBlueprintNamespace(namespaceUri)) {
1:                     parseBlueprintElement(element);
1:                 } else {
1:                     Metadata component = parseCustomElement(element, null);
1:                     if (component != null) {
1:                         if (!(component instanceof ComponentMetadata)) {
1:                             throw new ComponentDefinitionException("Expected a ComponentMetadata to be returned when parsing element " + element.getNodeName());
1:                         }
1:                         registry.registerComponentDefinition((ComponentMetadata) component);
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public <T> T parseElement(Class<T> type, ComponentMetadata enclosingComponent, Element element) {
1:         if (BeanArgument.class.isAssignableFrom(type)) {
1:             return type.cast(parseBeanArgument(enclosingComponent, element));
1:         } else if (BeanProperty.class.isAssignableFrom(type)) {
1:             return type.cast(parseBeanProperty(enclosingComponent, element));
1:         } else if (MapEntry.class.isAssignableFrom(type)) {
1:             return type.cast(parseMapEntry(element, enclosingComponent, null, null));
1:         } else if (MapMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseMap(element, enclosingComponent));
1:         } else if (BeanMetadata.class.isAssignableFrom(type)) {
0:             return type.cast(parseBeanMetadata(element, false));
1:         } else if (NullMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(NullMetadata.NULL);
1:         } else if (CollectionMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseCollection(Collection.class, element, enclosingComponent));
1:         } else if (PropsMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseProps(element));
1:         } else if (ReferenceMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseReference(element, enclosingComponent == null));
1:         } else if (ReferenceListMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseRefList(element, enclosingComponent == null));
1:         } else if (IdRefMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseIdRef(element));
1:         } else if (RefMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseRef(element));
1:         } else if (ValueMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseValue(element, null));
1:         } else {
1:             throw new ComponentDefinitionException("Unknown type to parse element: " + type.getName());
1:         }
1:     }
1: 
1:     private void parseBlueprintElement(Element element) {
1:         if (nodeNameEquals(element, DESCRIPTION_ELEMENT)) {
1:             // Ignore description
1:         } else if (nodeNameEquals(element, TYPE_CONVERTERS_ELEMENT)) {
1:             parseTypeConverters(element);
1:         } else if (nodeNameEquals(element, BEAN_ELEMENT)) {
1:             ComponentMetadata component = parseBeanMetadata(element, true);
1:             registry.registerComponentDefinition(component);
1:         } else if (nodeNameEquals(element, SERVICE_ELEMENT)) {
1:             ComponentMetadata service = parseService(element, true);
1:             registry.registerComponentDefinition(service);
1:         } else if (nodeNameEquals(element, REFERENCE_ELEMENT)) {
1:             ComponentMetadata reference = parseReference(element, true);
1:             registry.registerComponentDefinition(reference);
1:         } else if (nodeNameEquals(element, REFERENCE_LIST_ELEMENT) ) {
1:             ComponentMetadata references = parseRefList(element, true);
1:             registry.registerComponentDefinition(references);
1:         } else {
1:             throw new ComponentDefinitionException("Unknown element " + element.getNodeName() + " in namespace " + BLUEPRINT_NAMESPACE);
1:         }
1:     }
1: 
1:     private void parseTypeConverters(Element element) {
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 Object target = null;
1:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:                         target = parseBeanMetadata(e, true);
1:                     } else if (nodeNameEquals(e, REF_ELEMENT)) {
1:                         String componentName = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:                         target = new RefMetadataImpl(componentName);
1:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:                         target = parseReference(e, true);
1:                     }
1:                 } else {
1:                     target = parseCustomElement(e, null);
1:                 }
1:                 if (!(target instanceof Target)) {
1:                     throw new ComponentDefinitionException("Metadata parsed for element " + e.getNodeName() + " can not be used as a type converter");
1:                 }
1:                 registry.registerTypeConverter((Target) target);
1:             }
1:         }
1:     }
1: 
1:     private ComponentMetadata parseBeanMetadata(Element element, boolean topElement) {
1:         BeanMetadataImpl metadata = new BeanMetadataImpl();
1:         if (topElement) {
1:             metadata.setId(getId(element));
1:             if (element.hasAttribute(SCOPE_ATTRIBUTE)) {
0:                 metadata.setScope(element.getAttribute(SCOPE_ATTRIBUTE));
0:                 if (metadata.getScope().equals(BeanMetadata.SCOPE_PROTOTYPE)) {
1:                     if (element.hasAttribute(ACTIVATION_ATTRIBUTE)) {
1:                         if (element.getAttribute(ACTIVATION_ATTRIBUTE).equals(ACTIVATION_EAGER)) {
0:                             throw new ComponentDefinitionException("A <bean> with a prototype scope can not have an eager activation");
1:                         }
1:                     }
1:                     metadata.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:                 } else {
1:                     metadata.setActivation(parseActivation(element));
1:                 }
1:             } else {
1:                 metadata.setActivation(parseActivation(element));
1:             }
1:         } else {
1:             metadata.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:         }
1:         if (element.hasAttribute(CLASS_ATTRIBUTE)) {
1:             metadata.setClassName(element.getAttribute(CLASS_ATTRIBUTE));
1:         }
1:         if (element.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
1:             metadata.setDependsOn(parseList(element.getAttribute(DEPENDS_ON_ATTRIBUTE)));
1:         }
1:         if (element.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
1:             metadata.setInitMethod(element.getAttribute(INIT_METHOD_ATTRIBUTE));
1:         }
1:         if (element.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
1:             metadata.setDestroyMethod(element.getAttribute(DESTROY_METHOD_ATTRIBUTE));
1:         }
1:         if (element.hasAttribute(FACTORY_REF_ATTRIBUTE)) {
1:             metadata.setFactoryComponent(new RefMetadataImpl(element.getAttribute(FACTORY_REF_ATTRIBUTE)));
1:         }
1:         if (element.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
1:             String factoryMethod = element.getAttribute(FACTORY_METHOD_ATTRIBUTE);
1:             metadata.setFactoryMethod(factoryMethod);
1:         }
1: 
1:         // Do some validation
1:         if (metadata.getClassName() == null && metadata.getFactoryComponent() == null) {
1:             throw new ComponentDefinitionException("Bean class or factory-ref must be specified");
1:         }
1:         if (metadata.getFactoryComponent() != null && metadata.getFactoryMethod() == null) {
1:             throw new ComponentDefinitionException("factory-method is required when factory-component is set");
1:         }
1:         if (MetadataUtil.isPrototypeScope(metadata) && metadata.getDestroyMethod() != null) {
1:             throw new ComponentDefinitionException("destroy-method must not be set for a <bean> with a prototype scope");
1:         }
1: 
1:         // Parse elements
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(node.getNamespaceURI())) {                
1:                     if (nodeNameEquals(node, ARGUMENT_ELEMENT)) {
1:                         metadata.addArgument(parseBeanArgument(metadata, e));
1:                     } else if (nodeNameEquals(node, PROPERTY_ELEMENT)) {
1:                         metadata.addProperty(parseBeanProperty(metadata, e));
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         MetadataUtil.validateBeanArguments(metadata.getArguments());
1:         
1:         ComponentMetadata m = metadata;
1: 
1:         // Parse custom attributes
1:         m = handleCustomAttributes(element.getAttributes(), m);
1:         
1:         // Parse custom elements;
1:         m = handleCustomElements(element, m);
1:         
1:         return m;
1:     }
1: 
1:     public BeanProperty parseBeanProperty(ComponentMetadata enclosingComponent, Element element) {
1:         String name = element.hasAttribute(NAME_ATTRIBUTE) ? element.getAttribute(NAME_ATTRIBUTE) : null;
1:         Metadata value = parseArgumentOrPropertyValue(element, enclosingComponent);
1:         return new BeanPropertyImpl(name, value);
1:     }
1: 
1:     private BeanArgument parseBeanArgument(ComponentMetadata enclosingComponent, Element element) {
1:         int index = element.hasAttribute(INDEX_ATTRIBUTE) ? Integer.parseInt(element.getAttribute(INDEX_ATTRIBUTE)) : -1;
1:         String type = element.hasAttribute(TYPE_ATTRIBUTE) ? element.getAttribute(TYPE_ATTRIBUTE) : null;
1:         Metadata value = parseArgumentOrPropertyValue(element, enclosingComponent);
1:         return new BeanArgumentImpl(value, type, index);
1:     }
1: 
1:     private ComponentMetadata parseService(Element element, boolean topElement) {
1:         ServiceMetadataImpl service = new ServiceMetadataImpl();
1:         boolean hasInterfaceNameAttribute = false;
1:         if (topElement) {
1:             service.setId(getId(element));
1:             service.setActivation(parseActivation(element));
1:         } else {
1:             service.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:         }
1:         if (element.hasAttribute(INTERFACE_ATTRIBUTE)) {
1:             service.setInterfaceNames(Collections.singletonList(element.getAttribute(INTERFACE_ATTRIBUTE)));
1:             hasInterfaceNameAttribute = true;
1:         }
1:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:             service.setServiceComponent(new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE)));
1:         }
1:         if (element.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
1:             service.setDependsOn(parseList(element.getAttribute(DEPENDS_ON_ATTRIBUTE)));
1:         }
1:         String autoExport = element.hasAttribute(AUTO_EXPORT_ATTRIBUTE) ? element.getAttribute(AUTO_EXPORT_ATTRIBUTE) : AUTO_EXPORT_DEFAULT;
1:         if (AUTO_EXPORT_DISABLED.equals(autoExport)) {
1:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:         } else if (AUTO_EXPORT_INTERFACES.equals(autoExport)) {
1:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_INTERFACES);
1:         } else if (AUTO_EXPORT_CLASS_HIERARCHY.equals(autoExport)) {
1:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
1:         } else if (AUTO_EXPORT_ALL.equals(autoExport)) {
1:             service.setAutoExport(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
1:         } else {
1:             throw new ComponentDefinitionException("Illegal value (" + autoExport + ") for " + AUTO_EXPORT_ATTRIBUTE + " attribute");
1:         }
1:         String ranking = element.hasAttribute(RANKING_ATTRIBUTE) ? element.getAttribute(RANKING_ATTRIBUTE) : RANKING_DEFAULT;
1:         try {
1:             service.setRanking(Integer.parseInt(ranking));
1:         } catch (NumberFormatException e) {
1:             throw new ComponentDefinitionException("Attribute " + RANKING_ATTRIBUTE + " must be a valid integer (was: " + ranking + ")");
1:         }
1:         // Parse elements
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, INTERFACES_ELEMENT)) {
1:                         if (hasInterfaceNameAttribute) {
1:                             throw new ComponentDefinitionException("Only one of " + INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be used");
1:                         }
1:                         service.setInterfaceNames(parseInterfaceNames(e));
1:                     } else if (nodeNameEquals(e, SERVICE_PROPERTIES_ELEMENT)) {
1:                         List<MapEntry> entries = parseServiceProperties(e, service).getEntries();
1:                         service.setServiceProperties(entries); 
1:                     } else if (nodeNameEquals(e, REGISTRATION_LISTENER_ELEMENT)) {
1:                         service.addRegistrationListener(parseRegistrationListener(e, service));
1:                     } else if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:                         if (service.getServiceComponent() != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element can be set");
1:                         }
1:                         service.setServiceComponent((Target) parseBeanMetadata(e, false));
1:                     } else if (nodeNameEquals(e, REF_ELEMENT)) {
1:                         if (service.getServiceComponent() != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element can be set");
1:                         }
1:                         String component = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:                         if (component == null || component.length() == 0) {
1:                             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:                         }
1:                         service.setServiceComponent(new RefMetadataImpl(component));                   
1:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:                         if (service.getServiceComponent() != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element can be set");
1:                         }
1:                         service.setServiceComponent((Target) parseReference(e, false));
1:                     }
1:                 }
1:             }
1:         }
1:         // Check service
1:         if (service.getServiceComponent() == null) {
1:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + BEAN_ELEMENT + " element, " + REFERENCE_ELEMENT + " element or " + REF_ELEMENT + " element must be set");
1:         }
1:         // Check interface
1:         if (service.getAutoExport() == ServiceMetadata.AUTO_EXPORT_DISABLED && service.getInterfaces().isEmpty()) {
1:             throw new ComponentDefinitionException(INTERFACE_ATTRIBUTE + " attribute or " + INTERFACES_ELEMENT + " element must be set when " + AUTO_EXPORT_ATTRIBUTE + " is set to " + AUTO_EXPORT_DISABLED);
1:         }
1:         // Check for non-disabled auto-exports and interfaces
1:         if (service.getAutoExport() != ServiceMetadata.AUTO_EXPORT_DISABLED && !service.getInterfaces().isEmpty()) {
1:             throw new ComponentDefinitionException(INTERFACE_ATTRIBUTE + " attribute or  " + INTERFACES_ELEMENT + " element must not be set when " + AUTO_EXPORT_ATTRIBUTE + " is set to anything else than " + AUTO_EXPORT_DISABLED);
1:         }
1:         ComponentMetadata s = service;
1:         
1:         // Parse custom attributes
1:         s = handleCustomAttributes(element.getAttributes(), s);
1: 
1:         // Parse custom elements;
1:         s = handleCustomElements(element, s);
1:         
1:         return s;
1:     }
1: 
1:     private CollectionMetadata parseArray(Element element, ComponentMetadata enclosingComponent) {
1:         return parseCollection(Object[].class, element, enclosingComponent);
1:     }
1: 
1:     private CollectionMetadata parseList(Element element, ComponentMetadata enclosingComponent) {
1:         return parseCollection(List.class, element, enclosingComponent);
1:     }
1: 
1:     private CollectionMetadata parseSet(Element element, ComponentMetadata enclosingComponent) {
1:         return parseCollection(Set.class, element, enclosingComponent);
1:     }
1: 
1:     private CollectionMetadata parseCollection(Class collectionType, Element element, ComponentMetadata enclosingComponent) {
1:         // Parse attributes
1:         String valueType = element.hasAttribute(VALUE_TYPE_ATTRIBUTE) ? element.getAttribute(VALUE_TYPE_ATTRIBUTE) : null;
1:         // Parse elements
1:         List<Metadata> list = new ArrayList<Metadata>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Metadata val = parseValueGroup((Element) node, enclosingComponent, null, true);
1:                 list.add(val);
1:             }
1:         }
1:         return new CollectionMetadataImpl(collectionType, valueType, list);
1:     }
1: 
1:     public PropsMetadata parseProps(Element element) {
1:         // Parse elements
1:         List<MapEntry> entries = new ArrayList<MapEntry>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(e.getNamespaceURI()) && nodeNameEquals(e, PROP_ELEMENT)) {
1:                     entries.add(parseProperty(e));
1:                 }
1:             }
1:         }
1:         return new PropsMetadataImpl(entries);
1:     }
1: 
1:     private MapEntry parseProperty(Element element) {
1:         // Parse attributes
1:         if (!element.hasAttribute(KEY_ATTRIBUTE)) {
1:             throw new ComponentDefinitionException(KEY_ATTRIBUTE + " attribute is required");
1:         }
0:         String value = null;
1:         if (element.hasAttribute(VALUE_ATTRIBUTE)) {
1:             value = element.getAttribute(VALUE_ATTRIBUTE);
1:         } else {
1:             value = getTextValue(element);
1:         }
1:         String key = element.getAttribute(KEY_ATTRIBUTE);
1:         return new MapEntryImpl(new ValueMetadataImpl(key), new ValueMetadataImpl(value));
1:     }
1: 
1:     public MapMetadata parseMap(Element element, ComponentMetadata enclosingComponent) {
1:         // Parse attributes
1:         String keyType = element.hasAttribute(KEY_TYPE_ATTRIBUTE) ? element.getAttribute(KEY_TYPE_ATTRIBUTE) : null;
1:         String valueType = element.hasAttribute(VALUE_TYPE_ATTRIBUTE) ? element.getAttribute(VALUE_TYPE_ATTRIBUTE) : null;
1:         // Parse elements
1:         List<MapEntry> entries = new ArrayList<MapEntry>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (nodeNameEquals(e, ENTRY_ELEMENT)) {
1:                     entries.add(parseMapEntry(e, enclosingComponent, null, null));
1:                 }
1:             }
1:         }
1:         return new MapMetadataImpl(keyType, valueType, entries);
1:     }
1: 
1:     private MapEntry parseMapEntry(Element element, ComponentMetadata enclosingComponent, String keyType, String valueType) {
1:         // Parse attributes
1:         String key = element.hasAttribute(KEY_ATTRIBUTE) ? element.getAttribute(KEY_ATTRIBUTE) : null;
1:         String keyRef = element.hasAttribute(KEY_REF_ATTRIBUTE) ? element.getAttribute(KEY_REF_ATTRIBUTE) : null;
1:         String value = element.hasAttribute(VALUE_ATTRIBUTE) ? element.getAttribute(VALUE_ATTRIBUTE) : null;
1:         String valueRef = element.hasAttribute(VALUE_REF_ATTRIBUTE) ? element.getAttribute(VALUE_REF_ATTRIBUTE) : null;
1:         // Parse elements
1:         NonNullMetadata keyValue = null;
1:         Metadata valValue = null;
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (nodeNameEquals(e, KEY_ELEMENT)) {
1:                     keyValue = parseMapKeyEntry(e, enclosingComponent, keyType);
1:                 } else {
1:                     valValue = parseValueGroup(e, enclosingComponent, valueType, true);
1:                 }
1:             }
1:         }
1:         // Check key
1:         if (keyValue != null && (key != null || keyRef != null) || (keyValue == null && key == null && keyRef == null)) {
1:             throw new ComponentDefinitionException("Only and only one of " + KEY_ATTRIBUTE + " attribute, " + KEY_REF_ATTRIBUTE + " attribute or " + KEY_ELEMENT + " element must be set");
1:         } else if (keyValue == null && key != null) {
1:             keyValue = new ValueMetadataImpl(key, keyType);
1:         } else if (keyValue == null /*&& keyRef != null*/) {
1:             keyValue = new RefMetadataImpl(keyRef);
1:         }
1:         // Check value
1:         if (valValue != null && (value != null || valueRef != null) || (valValue == null && value == null && valueRef == null)) {
1:             throw new ComponentDefinitionException("Only and only one of " + VALUE_ATTRIBUTE + " attribute, " + VALUE_REF_ATTRIBUTE + " attribute or sub element must be set");
1:         } else if (valValue == null && value != null) {
1:             valValue = new ValueMetadataImpl(value, valueType);
1:         } else if (valValue == null /*&& valueRef != null*/) {
1:             valValue = new RefMetadataImpl(valueRef);
1:         }
1:         return new MapEntryImpl(keyValue, valValue);
1:     }
1: 
1:     private NonNullMetadata parseMapKeyEntry(Element element, ComponentMetadata enclosingComponent, String keyType) {
1:         NonNullMetadata keyValue = null;
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (keyValue != null) {
1:                     // TODO: throw an exception
1:                 }
1:                 keyValue = (NonNullMetadata) parseValueGroup(e, enclosingComponent, keyType, false);
1:                 break;
1:             }
1:         }
1:         if (keyValue == null) {
1:             // TODO: throw an exception
1:         }
1:         return keyValue;
1:     }
1:     
1:     public MapMetadata parseServiceProperties(Element element, ComponentMetadata enclosingComponent) {
1:         // TODO: need to handle this better
1:         MapMetadata map = parseMap(element, enclosingComponent);
1:         handleCustomElements(element, enclosingComponent);
1:         return map;
1:     }
1:     
1:     public RegistrationListener parseRegistrationListener(Element element, ComponentMetadata enclosingComponent) {
1:         RegistrationListenerImpl listener = new RegistrationListenerImpl();
1:         Metadata listenerComponent = null;
1:         // Parse attributes
1:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:             listenerComponent = new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE));
1:         }
1:         String registrationMethod = null;
1:         if (element.hasAttribute(REGISTRATION_METHOD_ATTRIBUTE)) {
1:             registrationMethod = element.getAttribute(REGISTRATION_METHOD_ATTRIBUTE);
1:             listener.setRegistrationMethod(registrationMethod);
1:         }
1:         String unregistrationMethod = null;
1:         if (element.hasAttribute(UNREGISTRATION_METHOD_ATTRIBUTE)) {
1:             unregistrationMethod = element.getAttribute(UNREGISTRATION_METHOD_ATTRIBUTE);
1:             listener.setUnregistrationMethod(unregistrationMethod);
1:         }
1:         if (registrationMethod == null && unregistrationMethod == null) {
1:             throw new ComponentDefinitionException("One of " + REGISTRATION_METHOD_ATTRIBUTE + " or " + UNREGISTRATION_METHOD_ATTRIBUTE + " must be set");
1:         }
1:         // Parse elements
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, REF_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         String component = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:                         if (component == null || component.length() == 0) {
1:                             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:                         }
1:                         listenerComponent = new RefMetadataImpl(component);
1:                     } else if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         listenerComponent = parseBeanMetadata(e, false);
1:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         listenerComponent = parseReference(e, false);
1:                     } else if (nodeNameEquals(e, SERVICE_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         listenerComponent = parseService(e, false);
1:                     }
1:                 } else {
1:                     if (listenerComponent != null) {
1:                         throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                     }
1:                     listenerComponent = parseCustomElement(e, enclosingComponent);
1:                 }
1:             }
1:         }
1:         if (listenerComponent == null) {
1:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BEAN_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element must be set");
1:         }
1:         listener.setListenerComponent((Target) listenerComponent);
1:         return listener;
1:     }
1: 
1:     private ComponentMetadata parseReference(Element element, boolean topElement) {       
1:         ReferenceMetadataImpl reference = new ReferenceMetadataImpl();
1:         if (topElement) {
1:             reference.setId(getId(element));
1:         }
1:         parseReference(element, reference, topElement);
1:         String timeout = element.hasAttribute(TIMEOUT_ATTRIBUTE) ? element.getAttribute(TIMEOUT_ATTRIBUTE) : this.defaultTimeout;
1:         try {
1:             reference.setTimeout(Long.parseLong(timeout));
1:         } catch (NumberFormatException e) {
1:             throw new ComponentDefinitionException("Attribute " + TIMEOUT_ATTRIBUTE + " must be a valid long (was: " + timeout + ")");
1:         }
1:         
1:         ComponentMetadata r = reference;
1: 
1:         // Parse custom attributes
1:         r = handleCustomAttributes(element.getAttributes(), r);
1: 
1:         // Parse custom elements;
1:         r = handleCustomElements(element, r);
1:         
1:         return r;
1:     }
1: 
1:     private ComponentMetadata parseRefList(Element element, boolean topElement) {
1:         ReferenceListMetadataImpl references = new ReferenceListMetadataImpl();
1:         if (topElement) {
1:             references.setId(getId(element));
1:         }
1:         if (element.hasAttribute(MEMBER_TYPE_ATTRIBUTE)) {
1:             String memberType = element.getAttribute(MEMBER_TYPE_ATTRIBUTE);
1:             if (USE_SERVICE_OBJECT.equals(memberType)) {
1:                 references.setMemberType(ReferenceListMetadata.USE_SERVICE_OBJECT);
1:             } else if (USE_SERVICE_REFERENCE.equals(memberType)) {
1:                 references.setMemberType(ReferenceListMetadata.USE_SERVICE_REFERENCE);
1:             }
1:         } else {
1:             references.setMemberType(ReferenceListMetadata.USE_SERVICE_OBJECT);
1:         }
1:         parseReference(element, references, topElement);
1: 
1:         ComponentMetadata r = references;
1:         
1:         // Parse custom attributes
1:         r = handleCustomAttributes(element.getAttributes(), r);
1: 
1:         // Parse custom elements;
1:         r = handleCustomElements(element, r);
1:         
1:         return r;
1:     }
1: 
1:     private void parseReference(Element element, ServiceReferenceMetadataImpl reference, boolean topElement) {
1:         // Parse attributes
1:         if (topElement) {
1:             reference.setActivation(parseActivation(element));
1:         } else {
1:             reference.setActivation(ComponentMetadata.ACTIVATION_LAZY);
1:         }
1:         if (element.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
1:             reference.setDependsOn(parseList(element.getAttribute(DEPENDS_ON_ATTRIBUTE)));
1:         }
1:         if (element.hasAttribute(INTERFACE_ATTRIBUTE)) {
1:             reference.setInterface(element.getAttribute(INTERFACE_ATTRIBUTE));
1:         }
1:         if (element.hasAttribute(FILTER_ATTRIBUTE)) {
1:             reference.setFilter(element.getAttribute(FILTER_ATTRIBUTE));
1:         }
1:         if (element.hasAttribute(COMPONENT_NAME_ATTRIBUTE)) {
1:             reference.setComponentName(element.getAttribute(COMPONENT_NAME_ATTRIBUTE));
1:         }
1:         String availability = element.hasAttribute(AVAILABILITY_ATTRIBUTE) ? element.getAttribute(AVAILABILITY_ATTRIBUTE) : defaultAvailability;
1:         if (AVAILABILITY_MANDATORY.equals(availability)) {
1:             reference.setAvailability(ServiceReferenceMetadata.AVAILABILITY_MANDATORY);
1:         } else if (AVAILABILITY_OPTIONAL.equals(availability)) {
1:             reference.setAvailability(ServiceReferenceMetadata.AVAILABILITY_OPTIONAL);
1:         } else {
1:             throw new ComponentDefinitionException("Illegal value for " + AVAILABILITY_ATTRIBUTE + " attribute: " + availability);
1:         }
1:         // Parse elements
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, REFERENCE_LISTENER_ELEMENT)) {
1:                         reference.addServiceListener(parseServiceListener(e, reference));
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private ReferenceListener parseServiceListener(Element element, ComponentMetadata enclosingComponent) {
1:         ReferenceListenerImpl listener = new ReferenceListenerImpl();
1:         Metadata listenerComponent = null;
1:         // Parse attributes
1:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:             listenerComponent = new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE));
1:         }
1:         String bindMethodName = null;
1:         String unbindMethodName = null;
1:         if (element.hasAttribute(BIND_METHOD_ATTRIBUTE)) {
1:             bindMethodName = element.getAttribute(BIND_METHOD_ATTRIBUTE);
1:             listener.setBindMethod(bindMethodName);
1:         }
1:         if (element.hasAttribute(UNBIND_METHOD_ATTRIBUTE)) {
1:             unbindMethodName = element.getAttribute(UNBIND_METHOD_ATTRIBUTE);
1:             listener.setUnbindMethod(unbindMethodName);
1:         }
1:         if (bindMethodName == null && unbindMethodName == null) {
1:             throw new ComponentDefinitionException("One of " + BIND_METHOD_ATTRIBUTE + " or " + UNBIND_METHOD_ATTRIBUTE + " must be set");
1:         }
1:         // Parse elements
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, REF_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         String component = e.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:                         if (component == null || component.length() == 0) {
1:                             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:                         }
1:                         listenerComponent = new RefMetadataImpl(component);
1:                     } else if (nodeNameEquals(e, BEAN_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         listenerComponent = parseBeanMetadata(e, false);
1:                     } else if (nodeNameEquals(e, REFERENCE_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         listenerComponent = parseReference(e, false);
1:                     } else if (nodeNameEquals(e, SERVICE_ELEMENT)) {
1:                         if (listenerComponent != null) {
1:                             throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                         }
1:                         listenerComponent = parseService(e, false);
1:                     }
1:                 } else {
1:                     if (listenerComponent != null) {
1:                         throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element can be set");
1:                     }
1:                     listenerComponent = parseCustomElement(e, enclosingComponent);
1:                 }
1:             }
1:         }
1:         if (listenerComponent == null) {
1:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + REF_ELEMENT + ", " + BLUEPRINT_ELEMENT + ", " + REFERENCE_ELEMENT + ", " + SERVICE_ELEMENT + " or custom element must be set");
1:         }
1:         listener.setListenerComponent((Target) listenerComponent);
1:         return listener;
1:     }
1: 
1:     public List<String> parseInterfaceNames(Element element) {
1:         List<String> interfaceNames = new ArrayList<String>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (nodeNameEquals(e, VALUE_ELEMENT)) {
1:                     String v = getTextValue(e).trim();
1:                     if (interfaceNames.contains(v)) {
1:                         throw new ComponentDefinitionException("The element " + INTERFACES_ELEMENT + " should not contain the same interface twice");
1:                     }
1:                     interfaceNames.add(getTextValue(e));
1:                 } else {
1:                     throw new ComponentDefinitionException("Unsupported element " + e.getNodeName() + " inside an " + INTERFACES_ELEMENT + " element");
1:                 }
1:             }
1:         }
1:         return interfaceNames;
1:     }
1: 
1:     private Metadata parseArgumentOrPropertyValue(Element element, ComponentMetadata enclosingComponent) {
1:         Metadata [] values = new Metadata[3];
1:         
1:         if (element.hasAttribute(REF_ATTRIBUTE)) {
1:             values[0] = new RefMetadataImpl(element.getAttribute(REF_ATTRIBUTE));
1:         } 
1:         
1:         if (element.hasAttribute(VALUE_ATTRIBUTE)) {
1:             values[1] = new ValueMetadataImpl(element.getAttribute(VALUE_ATTRIBUTE));
1:         } 
1:         
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
1:                 if (isBlueprintNamespace(node.getNamespaceURI()) && nodeNameEquals(node, DESCRIPTION_ELEMENT)) {
1:                     // Ignore description elements
1:                 } else {
1:                     values[2] = parseValueGroup(e, enclosingComponent, null, true);                    
1:                     break;
1:                 }
1:             }
1:         }
1:         
1:         Metadata value = null;
1:         for (Metadata v : values) {
1:             if (v != null) {
1:                 if (value == null) {
1:                     value = v;
1:                 } else {
1:                     throw new ComponentDefinitionException("Only one of " + REF_ATTRIBUTE + " attribute, " + VALUE_ATTRIBUTE + " attribute or sub element must be set");
1:                 }
1:             }
1:         }
1: 
1:         if (value == null) {
1:             throw new ComponentDefinitionException("One of " + REF_ATTRIBUTE + " attribute, " + VALUE_ATTRIBUTE + " attribute or sub element must be set");
1:         }
1:         
1:         return value;
1:     }
1: 
1:     private Metadata parseValueGroup(Element element, ComponentMetadata enclosingComponent, String collectionType, boolean allowNull) {
1:         if (isBlueprintNamespace(element.getNamespaceURI())) {
1:             if (nodeNameEquals(element, BEAN_ELEMENT)) {
1:                 return parseBeanMetadata(element, false);
1:             } else if (nodeNameEquals(element, REFERENCE_ELEMENT)) {
1:                 return parseReference(element, false);
1:             } else if (nodeNameEquals(element, SERVICE_ELEMENT)) {
1:                 return parseService(element, false);
1:             } else if (nodeNameEquals(element, REFERENCE_LIST_ELEMENT) ) {
1:                 return parseRefList(element, false);
1:             } else if (nodeNameEquals(element, NULL_ELEMENT) && allowNull) {
1:                 return NullMetadata.NULL;
1:             } else if (nodeNameEquals(element, VALUE_ELEMENT)) {
1:                 return parseValue(element, collectionType);
1:             } else if (nodeNameEquals(element, REF_ELEMENT)) {
1:                 return parseRef(element);
1:             } else if (nodeNameEquals(element, IDREF_ELEMENT)) {
1:                 return parseIdRef(element);
1:             } else if (nodeNameEquals(element, LIST_ELEMENT)) {
1:                 return parseList(element, enclosingComponent);
1:             } else if (nodeNameEquals(element, SET_ELEMENT)) {
1:                 return parseSet(element, enclosingComponent);
1:             } else if (nodeNameEquals(element, MAP_ELEMENT)) {
1:                 return parseMap(element, enclosingComponent);
1:             } else if (nodeNameEquals(element, PROPS_ELEMENT)) {
1:                 return parseProps(element);
1:             } else if (nodeNameEquals(element, ARRAY_ELEMENT)) {
1:                 return parseArray(element, enclosingComponent);
1:             } else {
1:                 throw new ComponentDefinitionException("Unknown blueprint element " + element.getNodeName());
1:             }
1:         } else {
1:             return parseCustomElement(element, enclosingComponent);
1:         }
1:     }
1: 
1:     private ValueMetadata parseValue(Element element, String collectionType) {
0:         String type = null;
1:         if (element.hasAttribute(TYPE_ATTRIBUTE)) {
1:             type = element.getAttribute(TYPE_ATTRIBUTE);
1:         } else {
1:             type = collectionType;
1:         }
1:         return new ValueMetadataImpl(getTextValue(element), type);
1:     }
1: 
1:     private RefMetadata parseRef(Element element) {
1:         String component = element.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:         if (component == null || component.length() == 0) {
1:             throw new ComponentDefinitionException("Element " + REF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:         }
1:         return new RefMetadataImpl(component);
1:     }
1:     private Metadata parseIdRef(Element element) {
1:         String component = element.getAttribute(COMPONENT_ID_ATTRIBUTE);
1:         if (component == null || component.length() == 0) {
1:             throw new ComponentDefinitionException("Element " + IDREF_ELEMENT + " must have a valid " + COMPONENT_ID_ATTRIBUTE + " attribute");
1:         }
1:         return new IdRefMetadataImpl(component);
1:     }
1: 
1:     private int parseActivation(Element element) {
1:         String initialization = element.hasAttribute(ACTIVATION_ATTRIBUTE) ? element.getAttribute(ACTIVATION_ATTRIBUTE) : defaultActivation;
1:         if (ACTIVATION_EAGER.equals(initialization)) {
1:             return ComponentMetadata.ACTIVATION_EAGER;
1:         } else if (ACTIVATION_LAZY.equals(initialization)) {
1:             return ComponentMetadata.ACTIVATION_LAZY;
1:         } else {
1:             throw new ComponentDefinitionException("Attribute " + ACTIVATION_ATTRIBUTE + " must be equal to " + ACTIVATION_EAGER + " or " + ACTIVATION_LAZY);
1:         }
1:     }
1:     
1:     private ComponentMetadata handleCustomAttributes(NamedNodeMap attributes, ComponentMetadata enclosingComponent) {
1:         if (attributes != null) {
1:             for (int i = 0; i < attributes.getLength(); i++) {
1:                 Node node = attributes.item(i);
1:                 if (node instanceof Attr && 
1:                     node.getNamespaceURI() != null && 
0:                     !isBlueprintNamespace(node.getNamespaceURI())) {
1:                     enclosingComponent = decorateCustomNode(node, enclosingComponent);
1:                 }
1:             }
1:         }
1:         return enclosingComponent;
1:     }
1:     
1:     private ComponentMetadata handleCustomElements(Element element, ComponentMetadata enclosingComponent) {
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 if (!isBlueprintNamespace(node.getNamespaceURI())) {
1:                     enclosingComponent = decorateCustomNode(node, enclosingComponent);
1:                 }
1:             }
1:         }
1:         return enclosingComponent;
1:     }
1:     
1:     private ComponentMetadata decorateCustomNode(Node node, ComponentMetadata enclosingComponent) {
1:         NamespaceHandler handler = getNamespaceHandler(node);
1:         ParserContextImpl context = new ParserContextImpl(this, registry, enclosingComponent, node);
1:         return handler.decorate(node, enclosingComponent, context);
1:     }
1: 
1:     private Metadata parseCustomElement(Element element, ComponentMetadata enclosingComponent) {
1:         NamespaceHandler handler = getNamespaceHandler(element);
1:         ParserContextImpl context = new ParserContextImpl(this, registry, enclosingComponent, element);
1:         return handler.parse(element, context);
1:     }
1: 
1:     private NamespaceHandler getNamespaceHandler(Node node) {
0:         if (namespaceHandlerRegistry == null) {
0:             throw new ComponentDefinitionException("Unsupported node (namespace handler registry is not set): " + node);
1:         }
1:         URI ns = URI.create(node.getNamespaceURI());
0:         NamespaceHandler handler = this.namespaceHandlerRegistry.getNamespaceHandler(ns);
1:         if (handler == null) {
0:             throw new ComponentDefinitionException("Unsupported node namespace: " + node.getNamespaceURI());
1:         }
1:         return handler;
1:     }
1:     
1:     public String getId(Element element) {
1:         String id;
1:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:             id = element.getAttribute(ID_ATTRIBUTE);
1:         } else {
1:             do {
1:                 id = "." + idPrefix + ++idCounter;
1:             } while (ids.contains(id));
1:         }
1:         ids.add(id);
1:         return id;
1:     }
1: 
1:     public static boolean isBlueprintNamespace(String ns) {
1:         return BLUEPRINT_NAMESPACE.equals(ns);
1:     }
1: 
1:     private static boolean nodeNameEquals(Node node, String name) {
1:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:     }
1: 
1:     private static List<String> parseList(String list) {
1:         String[] items = list.split(" ");
1:         List<String> set = new ArrayList<String>();
1:         for (String item : items) {
1:             item = item.trim();
1:             if (item.length() > 0) {
1:                 set.add(item);
1:             }
1:         }
1:         return set;                   
1:     }
1: 
1:     private static String getTextValue(Element element) {
1:         StringBuffer value = new StringBuffer();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node item = nl.item(i);
1:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:                 value.append(item.getNodeValue());
1:             }
1:         }
1:         return value.toString();
1:     }
1: 
1:     private static DocumentBuilderFactory getDocumentBuilderFactory() {
1:         if (documentBuilderFactory == null) {
1:             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
1:             dbf.setNamespaceAware(true);
1:             documentBuilderFactory = dbf;
1:         }
1:         return documentBuilderFactory;
1:     }
1: 
1: }
author:Christian Schneider
-------------------------------------------------------------------------------
commit:baa10f5
/////////////////////////////////////////////////////////////////////////
1:      * 
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:0871217
/////////////////////////////////////////////////////////////////////////
1: import org.xml.sax.ErrorHandler;
/////////////////////////////////////////////////////////////////////////
1:         validate(schema, null);
1:     }
1: 
1:     public void validate(Schema schema, ErrorHandler errorHandler) {
1:             if (errorHandler != null) {
1:                 validator.setErrorHandler(errorHandler);
1:             }
/////////////////////////////////////////////////////////////////////////
author:Tom Watson
-------------------------------------------------------------------------------
commit:3cfe3e2
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.aries.blueprint.ParserContext;
/////////////////////////////////////////////////////////////////////////
1:     private static final NamespaceHandler missingNamespace = new NamespaceHandler() {
1:         @Override
1:         public Metadata parse(Element element, ParserContext context) {
1:             return null;
1:         }
1:         @Override
1:         public URL getSchemaLocation(String namespace) {
1:             return null;
1:         }
1:         @Override
1:         public Set<Class> getManagedClasses() {
1:             return null;
1:         }
1:         @Override
1:         public ComponentMetadata decorate(Node node, ComponentMetadata component,
1:                 ParserContext context) {
1:             return component;
1:         }
1:     };
1:     private final String idPrefix;
1:     private final boolean ignoreUnknownNamespaces;
/////////////////////////////////////////////////////////////////////////
0:     public Parser() {
1:       this(null);
1:     }
1:       this(idPrefix, false);
1:     }
1: 
1:     public Parser(String idPrefix, boolean ignoreUnknownNamespaces) {
1:       this.idPrefix = idPrefix == null ? "component-" : idPrefix;
1:       this.ignoreUnknownNamespaces = ignoreUnknownNamespaces;
/////////////////////////////////////////////////////////////////////////
1:             if (ignoreUnknownNamespaces) {
1:                 return missingNamespace;
1:             }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:b4fc651
/////////////////////////////////////////////////////////////////////////
0: import javax.xml.namespace.QName;
/////////////////////////////////////////////////////////////////////////
1:      * Takes an Attribute Node for the scope, and returns the value.<br> 
1:      *  
1:      * @param attrNode The DOM Node with the attribute value.
1:      * @return The scope as a stringified value. It should be either the value <code>prototype</code>,
1:      * <code>singleton</code>, or a namespace qualified value, e.g. {http://foo}bar
1:      * @throws ComponentDefinitionException if the namespace prefix in the attribute value cannot be resolved.
1:      */
1:     private String getScope(Node attrNode) throws ComponentDefinitionException {
1:         String scope = null;
1:         if(attrNode!=null && (attrNode instanceof Attr)){
1:             Attr attr = (Attr)attrNode;
1:             String attrValue = attr.getValue();
1:             if(attrValue!=null && attrValue.indexOf(":")!=-1){
1:                 String[] parts = attrValue.split(":");
1:                 String prefix = parts[0];
1:                 String localName = parts[1];
1:                 String namespaceURI = attr.getOwnerElement().lookupNamespaceURI(prefix);
1:                 if(namespaceURI!=null){
1:                     scope = new QName(namespaceURI, localName).toString();
1:                 }else{
1:                     throw new ComponentDefinitionException("Unable to determine namespace binding for prefix, " + prefix);
1:                 }
1:             }
1:             else {
1:                 scope = attrValue;
1:             }
1:         }
1:         return scope;
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:                 metadata.setScope(getScope(element.getAttributeNode(SCOPE_ATTRIBUTE)));
1:                 if (!metadata.getScope().equals(BeanMetadata.SCOPE_SINGLETON)) {
1:                             throw new ComponentDefinitionException("A <bean> with a prototype or custom scope can not have an eager activation");
commit:ba088af
/////////////////////////////////////////////////////////////////////////
1:         handleCustomAttributes(root.getAttributes(), null);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.parser;
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev: 1135256 $, $Date: 2011-06-13 21:09:27 +0100 (Mon, 13 Jun 2011) $
/////////////////////////////////////////////////////////////////////////
1:     private NamespaceHandlerSet handlers;
/////////////////////////////////////////////////////////////////////////
1:     public void populate(NamespaceHandlerSet handlers,
commit:b6c4135
/////////////////////////////////////////////////////////////////////////
1:     private final Set<String> ids = new HashSet<String>();
0:     public Parser() {}
commit:1cfd24a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } else if (ReferenceListener.class.isAssignableFrom(type)) {
1:             return type.cast(parseServiceListener(element, enclosingComponent));
/////////////////////////////////////////////////////////////////////////
1:     public String getDefaultTimeout() {
1:         return defaultTimeout;
1:     }
1: 
1:     public String getDefaultAvailability() {
1:         return defaultAvailability;
1:     }
1: 
1:     public String getDefaultActivation() {
1:         return defaultActivation;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public String generateId() {
1:         String id;
0:         do {
0:             id = "." + idPrefix + ++idCounter;
0:         } while (ids.contains(id));
1:         ids.add(id);
1:         return id;        
1:     }
1:     
1:             ids.add(id);
1:             id = generateId();
author:Lin Sun
-------------------------------------------------------------------------------
commit:e594ebc
/////////////////////////////////////////////////////////////////////////
1:         // Break into 2 loops to ensure we scan the blueprint elements before
1:         // This is needed so that when we process the custom element, we know
1:         // the component definition registry has populated all blueprint components.
/////////////////////////////////////////////////////////////////////////
1:                 } 
1:             }
1:         }
1:         
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element element = (Element) node;
1:                 String namespaceUri = element.getNamespaceURI();
1:                 if (!isBlueprintNamespace(namespaceUri)) {
/////////////////////////////////////////////////////////////////////////
1:                 } 
commit:b267b13
/////////////////////////////////////////////////////////////////////////
1:             return type.cast(parseBeanMetadata(element, enclosingComponent == null));
/////////////////////////////////////////////////////////////////////////
1:         } else if (ServiceMetadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseService(element, enclosingComponent == null));
author:David Jencks
-------------------------------------------------------------------------------
commit:22a0fbb
/////////////////////////////////////////////////////////////////////////
1:         } else if (Metadata.class.isAssignableFrom(type)) {
1:             return type.cast(parseValueGroup(element, enclosingComponent, null, true));
commit:436dc3a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final List<Document> documents = new ArrayList<Document>();
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception on parse error
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception on parse error
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param attrNode The DOM Node with the qualified attribute value.
1:      * @throws ComponentDefinitionException if the namespace prefix in the attribute value cannot be resolved.
1:     private URI getNamespaceForAttributeValue(Node attrNode) throws ComponentDefinitionException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if(scopeNS!=null && !BLUEPRINT_NAMESPACE.equals(scopeNS.toString())){
/////////////////////////////////////////////////////////////////////////
1:         String value;
/////////////////////////////////////////////////////////////////////////
1:         String type;
/////////////////////////////////////////////////////////////////////////
1:         return getNamespaceHandler(ns);
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
0:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.NamespaceHandler;
1: import org.apache.aries.blueprint.reflect.BeanArgumentImpl;
1: import org.apache.aries.blueprint.reflect.BeanMetadataImpl;
1: import org.apache.aries.blueprint.reflect.BeanPropertyImpl;
1: import org.apache.aries.blueprint.reflect.CollectionMetadataImpl;
1: import org.apache.aries.blueprint.reflect.IdRefMetadataImpl;
1: import org.apache.aries.blueprint.reflect.MapEntryImpl;
1: import org.apache.aries.blueprint.reflect.MapMetadataImpl;
1: import org.apache.aries.blueprint.reflect.MetadataUtil;
1: import org.apache.aries.blueprint.reflect.PropsMetadataImpl;
1: import org.apache.aries.blueprint.reflect.RefMetadataImpl;
1: import org.apache.aries.blueprint.reflect.ReferenceListMetadataImpl;
1: import org.apache.aries.blueprint.reflect.ReferenceListenerImpl;
1: import org.apache.aries.blueprint.reflect.ReferenceMetadataImpl;
1: import org.apache.aries.blueprint.reflect.RegistrationListenerImpl;
1: import org.apache.aries.blueprint.reflect.ServiceMetadataImpl;
1: import org.apache.aries.blueprint.reflect.ServiceReferenceMetadataImpl;
1: import org.apache.aries.blueprint.reflect.ValueMetadataImpl;
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:9d16c7e
/////////////////////////////////////////////////////////////////////////
0:     private List<Document> documents = new ArrayList<Document>();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Parse an input stream for blueprint xml. 
1:      * @param inputStream The data to parse. The caller is responsible for closing the stream afterwards. 
0:      * @throws Exception
1:      */
1:     public void parse(InputStream inputStream) throws Exception { 
0:       InputSource inputSource = new InputSource(inputStream);
0:       DocumentBuilder builder = getDocumentBuilderFactory().newDocumentBuilder();
0:       Document doc = builder.parse(inputSource);
0:       documents.add(doc);
1:     }
0:     
1:     /**
1:      * Parse blueprint xml referred to by a list of URLs
1:      * @param urls URLs to blueprint xml to parse
0:      * @throws Exception
1:      */
0:                 parse (inputStream);
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:53633a9
/////////////////////////////////////////////////////////////////////////
0:             if (ns != null && !isBlueprintNamespace(ns) && !isIgnorableAttributeNamespace(ns)) {
/////////////////////////////////////////////////////////////////////////
1:                     !isIgnorableAttributeNamespace(node.getNamespaceURI()) ) {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test if this namespace uri does not require a Namespace Handler.<p>
0:      *      <li>    XMLConstants.RELAXNG_NS_URI
0:      *      <li>    XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI
0:      *      <li>    XMLConstants.W3C_XML_SCHEMA_NS_URI
0:      *      <li>    XMLConstants.W3C_XPATH_DATATYPE_NS_URI
0:      *      <li>    XMLConstants.W3C_XPATH_DATATYPE_NS_URI
0:      *      <li>    XMLConstants.XML_DTD_NS_URI
0:      *      <li>    XMLConstants.XML_NS_URI
0:      *      <li>    XMLConstants.XMLNS_ATTRIBUTE_NS_URI
1:      * @param ns URI to be tested.
1:      * @return true if the uri does not require a namespace handler.
1:      */
1:     public static boolean isIgnorableAttributeNamespace(String ns) {
1:         return XMLConstants.RELAXNG_NS_URI.equals(ns) ||
1:                XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI.equals(ns) || 
1:                XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(ns) ||
1:                XMLConstants.W3C_XPATH_DATATYPE_NS_URI.equals(ns) ||
1:                XMLConstants.W3C_XPATH_DATATYPE_NS_URI.equals(ns) ||
1:                XMLConstants.XML_DTD_NS_URI.equals(ns) ||
1:                XMLConstants.XML_NS_URI.equals(ns) || 
1:                XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(ns);
1:     }
0:     
commit:8ae47e0
/////////////////////////////////////////////////////////////////////////
0: import javax.xml.namespace.QName;
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.Attr;
0: import org.w3c.dom.CharacterData;
0: import org.w3c.dom.Comment;
0: import org.w3c.dom.Document;
0: import org.w3c.dom.Element;
0: import org.w3c.dom.EntityReference;
0: import org.w3c.dom.NamedNodeMap;
0: import org.w3c.dom.Node;
0: import org.w3c.dom.NodeList;
/////////////////////////////////////////////////////////////////////////
0:             if (ns != null && !isBlueprintNamespace(ns) && !XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(ns)) {
0:             }else if ( ns == null && //attributes from blueprint are unqualified as per schema.
1:                        node instanceof Attr &&
1:                        SCOPE_ATTRIBUTE.equals(node.getNodeName()) &&
1:                        ((Attr)node).getOwnerElement() != null && //should never occur from parsed doc.
1:                        BLUEPRINT_NAMESPACE.equals(((Attr)node).getOwnerElement().getNamespaceURI()) &&
1:                        BEAN_ELEMENT.equals(((Attr)node).getOwnerElement().getLocalName()) ){
1:                 //Scope attribute is special case, as may contain namespace usage within its value.
0:                 
1:                 URI scopeNS = getNamespaceForAttributeValue(node);
1:                 if(scopeNS!=null){
1:                     namespaces.add(scopeNS);
1:                 }
1:             }
1:         }
1:         NamedNodeMap nnm = node.getAttributes();
1:         if(nnm!=null){
1:             for(int i = 0; i< nnm.getLength() ; i++){
0:                 findNamespaces(namespaces, nnm.item(i));
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Takes an Attribute Node containing a namespace prefix qualified attribute value, and resolves the namespace using the DOM Node.<br> 
1:      *  
0:      * @param attr The DOM Node with the qualified attribute value.
1:      * @return The URI if one is resolvable, or null if the attr is null, or not namespace prefixed. (or not a DOM Attribute Node)
0:      * @throws ComponentDefinitonException if the namespace prefix in the attribute value cannot be resolved.
1:      */
0:     private URI getNamespaceForAttributeValue(Node attrNode){
1:         URI uri = null;
1:         if(attrNode!=null && (attrNode instanceof Attr)){
1:             Attr attr = (Attr)attrNode;
1:             String attrValue = attr.getValue();
1:             if(attrValue!=null && attrValue.indexOf(":")!=-1){
1:                 String parts[] = attrValue.split(":");
1:                 String uriStr = attr.getOwnerElement().lookupNamespaceURI(parts[0]);
1:                 if(uriStr!=null){
1:                     uri = URI.create(uriStr);
1:                 }else{
1:                     throw new ComponentDefinitionException("Unsupported attribute namespace prefix "+parts[0]+" "+attr);
0:                 }
0:             }
0:         }
1:         return uri;
0:     }
0:     
1:     /**
1:      * Tests if a scope attribute value is a custom scope, and if so invokes
1:      * the appropriate namespace handler, passing the blueprint scope node. 
1:      * <p> 
1:      * Currently this tests for custom scope by looking for the presence of
1:      * a ':' char within the scope attribute value. This is valid as long as
1:      * the blueprint schema continues to restrict that custom scopes should
1:      * require that characters presence.
1:      * <p>
1:      *  
1:      * @param scope Value of scope attribute
1:      * @param bean DOM element for bean associated to this scope 
0:      * @param cm Metadata for bean associated to this scope
1:      * @return Metadata as processed by NS Handler.
1:      * @throws ComponentDefinitionException if an undeclared prefix is used, 
1:      *           if a namespace handler is unavailable for a resolved prefix, 
1:      *           or if the resolved prefix results as the blueprint namespace.
1:      */
1:     private ComponentMetadata handleCustomScope(Node scope, Element bean, ComponentMetadata metadata){
1:         URI scopeNS = getNamespaceForAttributeValue(scope);
0:         if(scopeNS!=null && !BLUEPRINT_NAMESPACE.equals(scopeNS)){
1:             NamespaceHandler nsHandler = getNamespaceHandler(scopeNS);
1:             ParserContextImpl context = new ParserContextImpl(this, registry, metadata, scope);
1:             metadata = nsHandler.decorate(scope, metadata, context);
1:         }else if(scopeNS!=null){
1:             throw new ComponentDefinitionException("Custom scopes cannot use the blueprint namespace "+scope);
0:         }
1:         return metadata;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         
1:         // Parse custom scopes
1:         m = handleCustomScope(element.getAttributeNode(SCOPE_ATTRIBUTE), element, m);
0:         
/////////////////////////////////////////////////////////////////////////
1:                 //attr is custom if it has a namespace, and it isnt blueprint, or the xmlns ns. 
1:                 //blueprint ns would be an error, as blueprint attrs are unqualified.
1:                     !isBlueprintNamespace(node.getNamespaceURI()) &&
0:                     !XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(node.getNamespaceURI()) ) {
/////////////////////////////////////////////////////////////////////////
0:         NamespaceHandler handler = getNamespaceHandler(ns);
0:         return handler;
0:     }
0: 
0:     private NamespaceHandler getNamespaceHandler(URI uri) {
0:         if (handlers == null) {
1:             throw new ComponentDefinitionException("Unsupported node (namespace handler registry is not set): " + uri);
0:         }
1:         NamespaceHandler handler = this.handlers.getNamespaceHandler(uri);
1:             throw new ComponentDefinitionException("Unsupported node namespace: " + uri);
0: 
============================================================================