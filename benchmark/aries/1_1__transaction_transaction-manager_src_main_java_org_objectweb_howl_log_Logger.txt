1:ea1e959: /*
1:ea1e959:  * JOnAS: Java(TM) Open Application Server
1:ea1e959:  * Copyright (C) 2004 Bull S.A.
1:ea1e959:  * All rights reserved.
1:ea1e959:  * 
1:ea1e959:  * Contact: howl@objectweb.org
1:ea1e959:  * 
1:ea1e959:  * This software is licensed under the BSD license.
1:ea1e959:  * 
1:ea1e959:  * Redistribution and use in source and binary forms, with or without
1:ea1e959:  * modification, are permitted provided that the following conditions
1:ea1e959:  * are met:
1:ea1e959:  * 
1:ea1e959:  *   * Redistributions of source code must retain the above copyright
1:ea1e959:  *     notice, this list of conditions and the following disclaimer.
1:ea1e959:  *     
1:ea1e959:  *   * Redistributions in binary form must reproduce the above copyright
1:ea1e959:  *     notice, this list of conditions and the following disclaimer in the
1:ea1e959:  *     documentation and/or other materials provided with the distribution.
1:ea1e959:  *     
1:ea1e959:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
1:ea1e959:  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
1:ea1e959:  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
1:ea1e959:  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
1:ea1e959:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
1:ea1e959:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
1:ea1e959:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
1:ea1e959:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
1:ea1e959:  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
1:ea1e959:  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
1:ea1e959:  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1:ea1e959:  * 
1:ea1e959:  * ------------------------------------------------------------------------------
1:ea1e959:  * $Id: Logger.java,v 1.14 2006/04/21 15:03:36 girouxm Exp $
1:ea1e959:  * ------------------------------------------------------------------------------
1:ea1e959:  */
1:ea1e959: package org.objectweb.howl.log;
1:ea1e959: 
1:ea1e959: import java.io.IOException;
1:ea1e959: 
1:ea1e959: /**
1:ea1e959:  * Manage a configured set of two or more physical log files.
1:ea1e959:  * 
1:ea1e959:  * <p>Log files have a configured maximum size.  When a file has
1:ea1e959:  * reached the configured capacity, Logger switches to
1:ea1e959:  * the next available alternate file.  Normally, log files are created
1:ea1e959:  * in advance to guarantee that space is available during execution.
1:ea1e959:  * 
1:ea1e959:  * <p>Each log file has a file header containing information 
1:ea1e959:  * allowing Logger to reposition and replay the logs
1:ea1e959:  * during a recovery scenario.
1:ea1e959:  * 
1:ea1e959:  * <p>LogFile <i> marking </i>
1:ea1e959:  * <p>The LogFile's mark is the the position within the file
1:ea1e959:  * of the oldest active entry.
1:ea1e959:  * Initially the mark is set at the beginning of the file.
1:ea1e959:  * At some configured interval, the caller invokes <i> mark() </i>
1:ea1e959:  * with the key of the oldest active entry in the log.
1:ea1e959:  * 
1:ea1e959:  * <p>For XA the key would be for the oldest transaction still
1:ea1e959:  * in committing state.  In theory, XA could call <i> mark() </i> every
1:ea1e959:  * time a DONE record is logged.  In practice, it should only be
1:ea1e959:  * necessary to call <i> mark() </i> every minute or so depending on the
1:ea1e959:  * capacity of the log files.
1:ea1e959:  * 
1:ea1e959:  * <p>The Logger maintains an active mark within the set
1:ea1e959:  * of log files.  A file may be reused only if the mark does not
1:ea1e959:  * reside within the file.  The Logger will throw
1:ea1e959:  * LogFileOverflowException if an attempt is made to switch to a
1:ea1e959:  * file that contains a mark.
1:ea1e959:  * 
1:ea1e959:  * @author Michael Giroux
1:ea1e959:  *
1:ea1e959:  */
1:ea1e959: public class Logger extends LogObject
1:ea1e959: {
1:ea1e959:   /**
1:ea1e959:    * indicates whether the LogFile is open.
1:ea1e959:    * <p>Logger methods return LogClosedException when log is closed.
1:ea1e959:    */
1:ea1e959:   protected volatile boolean isClosed = true;
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Manages a pool of buffers used for log file IO.
1:ea1e959:    */
1:ea1e959:   LogBufferManager bmgr = null;
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Manages a pool of files used for log file IO.
1:ea1e959:    */
1:ea1e959:   LogFileManager lfmgr = null;
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * @return activeMark member of the associated LogFileManager.
1:ea1e959:    */
1:ea1e959:   public long getActiveMark()
1:ea1e959:   {
1:ea1e959:     return lfmgr.activeMark;
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Construct a Logger using default Configuration object.
1:ea1e959:    * @throws IOException
1:ea1e959:    */
1:ea1e959:   public Logger()
1:ea1e959:     throws IOException
1:ea1e959:   {
1:ea1e959:     this(new Configuration());
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Construct a Logger using a Configuration supplied
1:ea1e959:    * by the caller.
1:ea1e959:    * @param config Configuration object
1:ea1e959:    * @throws IOException
1:ea1e959:    */
1:ea1e959:   public Logger(Configuration config)
1:ea1e959:     throws IOException
1:ea1e959:   {
1:ea1e959:     super(config);
1:ea1e959: 
1:ea1e959:     lfmgr = new LogFileManager(config);
1:ea1e959:     
1:ea1e959:     bmgr = new LogBufferManager(config);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * add a USER record consisting of byte[][] to log. 
1:ea1e959:    * 
1:ea1e959:    * <p>if <i> sync </i> parameter is true, then the method will
1:ea1e959:    * block (in bmgr.put()) until the <i> data </i> buffer is forced to disk.
1:ea1e959:    * Otherwise, the method returns immediately.
1:ea1e959:    * 
1:ea1e959:    * @param data record data
1:ea1e959:    * @param sync true if call should block until force
1:ea1e959:    * 
1:ea1e959:    * @return a key that can be used to locate the record.
1:ea1e959:    * Some implementations may use the key as a correlation ID 
1:ea1e959:    * to associate related records.
1:ea1e959:    * 
1:ea1e959:    * When automark is disabled (false) the caller must
1:ea1e959:    * invoke mark() using this key to indicate the location
1:ea1e959:    * of the oldest active entry in the log.
1:ea1e959:    * 
1:ea1e959:    * @throws LogClosedException
1:ea1e959:    * @throws LogRecordSizeException
1:ea1e959:    * @throws LogFileOverflowException
1:ea1e959:    * @throws InterruptedException
1:ea1e959:    * @throws IOException
1:ea1e959:    * 
1:ea1e959:    * @see #mark(long)
1:ea1e959:    * @see #setAutoMark(boolean)
1:ea1e959:    */
1:ea1e959:   public long put(byte[][] data, boolean sync)
1:ea1e959:     throws LogClosedException, LogRecordSizeException, LogFileOverflowException,
1:ea1e959:                 InterruptedException, IOException
1:ea1e959:   {
1:ea1e959:     return put(LogRecordType.USER, data, sync);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * add a USER record consisting of byte[] to the log.
1:ea1e959:    * 
1:ea1e959:    * <p>wrap byte[] <i> data </i> in a new byte[][]
1:ea1e959:    * and delegates call to put(byte[][], boolean)
1:ea1e959:    *  
1:ea1e959:    * @param data byte[] to be written to log
1:ea1e959:    * @param sync true if caller wishes to block waiting for the
1:ea1e959:    * record to force to disk.
1:ea1e959:    * @return log key for the record
1:ea1e959:    * @throws LogClosedException
1:ea1e959:    * @throws LogRecordSizeException
1:ea1e959:    * @throws LogFileOverflowException
1:ea1e959:    * @throws InterruptedException
1:ea1e959:    * @throws IOException
1:ea1e959:    */
1:ea1e959:   public long put(byte[] data, boolean sync)
1:ea1e959:     throws LogClosedException, LogRecordSizeException, LogFileOverflowException,
1:ea1e959:       InterruptedException, IOException
1:ea1e959:   {
1:ea1e959:     return put(LogRecordType.USER, new byte[][]{data}, sync);
1:ea1e959:   }
1:ea1e959: 
1:ea1e959:   /**
1:ea1e959:    * Sub-classes call this method to write log records with
1:ea1e959:    * a specific record type.
1:ea1e959:    * 
1:ea1e959:    * @param type a record type defined in LogRecordType.
1:ea1e959:    * @param data record data to be logged.
1:ea1e959:    * @param sync boolean indicating whether call should
1:ea1e959:    * wait for data to be written to physical disk.
1:ea1e959:    * 
1:ea1e959:    * @return a log key that can be used to reference
1:ea1e959:    * the record.
1:ea1e959:    */
1:ea1e959:   protected long put(short type, byte[][] data, boolean sync)
1:ea1e959:   throws LogClosedException, LogRecordSizeException, LogFileOverflowException,
1:ea1e959:   InterruptedException, IOException
1:ea1e959:   {
1:ea1e959:     synchronized(this)
1:ea1e959:     {
1:ea1e959:       if (isClosed) throw new LogClosedException();
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     // QUESTION: should we deal with exceptions here?
1:ea1e959: 
1:ea1e959:     long key = bmgr.put(type, data, sync);
1:ea1e959:     lfmgr.setCurrentKey(key);
1:ea1e959:     
1:ea1e959:     return key;
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * sets the LogFile's mark.
1:ea1e959:    * 
1:ea1e959:    * <p><i> mark() </i> provides a generalized method for callers
1:ea1e959:    * to inform the Logger that log space can be released
1:ea1e959:    * for reuse.
1:ea1e959:    * 
1:ea1e959:    * <p>calls LogFileManager to process the request.
1:ea1e959:    * 
1:ea1e959:    * @param key is a log key returned by a previous call to put().
1:ea1e959:    * @param force a boolean that indicates whether the mark data
1:ea1e959:    * should be forced to disk.  When set to <b> true </b> the caller
1:ea1e959:    * is blocked until the mark record is forced to disk.
1:ea1e959:    * 
1:ea1e959:    * @throws InvalidLogKeyException
1:ea1e959:    * if <i> key </i> parameter is out of range.
1:ea1e959:    * <i> key </i> must be greater than current activeMark and less than the most recent
1:ea1e959:    * key returned by put().
1:ea1e959:    * @throws LogClosedException
1:ea1e959:    * if this logger instance has been closed.
1:ea1e959:    */
1:ea1e959:   public void mark(long key, boolean force)
1:ea1e959:     throws InvalidLogKeyException, LogClosedException, IOException, InterruptedException
1:ea1e959:   {
1:ea1e959:     synchronized(this)
1:ea1e959:     {
1:ea1e959:       if (isClosed)
1:ea1e959:         throw new LogClosedException("log is closed");
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     lfmgr.mark(key, force);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * calls Logger.mark(key, force) with <i> force </i> set to <b> true </b>.
1:ea1e959:    * <p>Caller is blocked until mark record is forced to disk.
1:ea1e959:    * @param key a log key returned by a previous call to put().
1:ea1e959:    * @throws InvalidLogKeyException
1:ea1e959:    * @throws LogClosedException
1:ea1e959:    * @throws IOException
1:ea1e959:    * @throws InterruptedException
1:ea1e959:    * @see #mark(long, boolean)
1:ea1e959:    */
1:ea1e959:   public void mark(long key)
1:ea1e959:     throws InvalidLogKeyException, LogClosedException, IOException, InterruptedException
1:ea1e959:   {
1:ea1e959:     mark(key, true);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Sets the LogFile marking mode.
1:ea1e959:    * 
1:ea1e959:    * <p>passes call to LogFileManager
1:ea1e959:    * 
1:ea1e959:    * @param autoMark true to indicate automatic marking.
1:ea1e959:    */
1:ea1e959:   public void setAutoMark(boolean autoMark)
1:ea1e959:     throws InvalidLogKeyException, LogClosedException, LogFileOverflowException, IOException, InterruptedException
1:ea1e959:   {
1:ea1e959:     synchronized(this)
1:ea1e959:     {
1:ea1e959:       if (this.isClosed) throw new LogClosedException();
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     lfmgr.setAutoMark(autoMark);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * close the Log files and perform necessary cleanup tasks.
1:ea1e959:    */
1:ea1e959:   public void close() throws IOException, InterruptedException
1:ea1e959:   {
1:ea1e959:     // prevent new threads from adding to the log
1:ea1e959:     synchronized(this) { isClosed = true; }
1:ea1e959:     
1:ea1e959:     lfmgr.close();
1:ea1e959:     bmgr.close();
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * open Log files and perform necessart initialization.
1:ea1e959:    * 
1:ea1e959:    * TODO: consider open(String name) to allow named configurations.
1:ea1e959:    *       this would allow utility to open two loggers and copy 
1:ea1e959:    *       old records to new files.
1:ea1e959:    *
1:ea1e959:    */
1:ea1e959:   public void open()
1:ea1e959:     throws InvalidFileSetException,
1:ea1e959:            IOException, LogConfigurationException, InvalidLogBufferException, InterruptedException
1:ea1e959:   {
1:ea1e959:     lfmgr.open();
1:ea1e959:     
1:ea1e959:     try {
1:ea1e959:       bmgr.open();
1:ea1e959:     } catch (ClassNotFoundException e) {
1:ea1e959:       String cnf = "LogBuffer Class not found: " + config.getBufferClassName();
1:ea1e959:       LogConfigurationException lce = new LogConfigurationException(cnf, e);
1:ea1e959:       throw lce;
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     // read header information from each file
1:ea1e959:     lfmgr.init(bmgr);
1:ea1e959:     
1:ea1e959:     // indicate that Log is ready for use.
1:ea1e959:     synchronized(this) { isClosed = false; }
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Registers a LogEventListener for log event notifications.
1:ea1e959:    * 
1:ea1e959:    * @param eventListener object to be notified of logger events.
1:ea1e959:    */
1:ea1e959:   public void setLogEventListener(LogEventListener eventListener)
1:ea1e959:   {
1:ea1e959:     lfmgr.setLogEventListener(eventListener);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Replays log from a specified mark forward to the current mark.
1:ea1e959:    * 
1:ea1e959:    * <p>Beginning with the record located at <i> mark </i>
1:ea1e959:    * the Logger reads log records forward to the end of the log.
1:ea1e959:    * USER records are passed to the <i> listener </i> onRecord()
1:ea1e959:    * method. When the end of log has been reached, replay returns
1:ea1e959:    * one final record with a type of END_OF_LOG to inform <i> listener </i>
1:ea1e959:    * that no further records will be returned.
1:ea1e959:    * 
1:ea1e959:    * <p>If an error is encountered while reading the log, the
1:ea1e959:    * <i> listener </i> onError method is called.  Replay terminates
1:ea1e959:    * when any error occurs and when END_OF_LOG is encountered.
1:ea1e959:    * 
1:ea1e959:    * @param listener an object that implements ReplayListener interface.
1:ea1e959:    * @param mark a log key to begin replay from.
1:ea1e959:    * <p>The <i> mark </i> should be a valid log key returned by the put()
1:ea1e959:    * method.  To replay the entire log beginning with the oldest available
1:ea1e959:    * record, <i> mark </i> should be set to zero (0L).
1:ea1e959:    * @throws LogConfigurationException
1:ea1e959:    * most likely because the configured LogBuffer class cannot be found.
1:ea1e959:    * @throws InvalidLogKeyException
1:ea1e959:    * if <i> mark </i> is not a valid log key.
1:ea1e959:    */
1:ea1e959:   public void replay(ReplayListener listener, long mark)
1:ea1e959:     throws InvalidLogKeyException, LogConfigurationException
1:ea1e959:   {
1:ea1e959:     // replay only the user records.
1:ea1e959:     bmgr.replay(listener, mark, false);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Replays log from the active mark forward to the current position.
1:ea1e959:    * 
1:ea1e959:    * @param listener an object that implements ReplayListener interface.
1:ea1e959:    * @throws LogConfigurationException
1:ea1e959:    * most likely because the configured LogBuffer class cannot be found.
1:ea1e959:    * @see #replay(ReplayListener, long)
1:ea1e959:    */
1:ea1e959:   public void replay(ReplayListener listener) throws LogConfigurationException
1:ea1e959:   {
1:ea1e959:     try {
1:ea1e959:       bmgr.replay(listener, lfmgr.activeMark, false);
1:ea1e959:     } catch (InvalidLogKeyException e) {
1:ea1e959:       // should not happen -- use assert to catch during development
1:ea1e959:       assert false : "Unhandled InvalidLogKeyException" + e.toString();
1:ea1e959:     }
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Allows sub-classes of Logger to replay control records.
1:ea1e959:    * 
1:ea1e959:    * @param listener ReplayListener to receive the records 
1:ea1e959:    * @param mark starting mark (log key) for the replay.
1:ea1e959:    * @param replayCtrlRecords boolean indicating whether to
1:ea1e959:    * return CTRL records.
1:ea1e959:    * @throws InvalidLogKeyException
1:ea1e959:    * If the <i> mark </i> parameter specifies an invalid log key
1:ea1e959:    * (one that does not exist in the current set of log files.)
1:ea1e959:    * @throws LogConfigurationException
1:ea1e959:    * 
1:ea1e959:    * @see org.objectweb.howl.log.LogBufferManager#replay(ReplayListener, long, boolean)
1:ea1e959:    */
1:ea1e959:   protected void replay(ReplayListener listener, long mark, boolean replayCtrlRecords)
1:ea1e959:   throws InvalidLogKeyException, LogConfigurationException
1:ea1e959:   {
1:ea1e959:     bmgr.replay(listener, mark, replayCtrlRecords);
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Read a specific record from the log.
1:ea1e959:    * <p>Control records are not filtered by this method.
1:ea1e959:    * If the requested mark is valid and identifies a control record,
1:ea1e959:    * the record will be returned.
1:ea1e959:    * @param lr LogRecord to be updated or null if caller wishes a new
1:ea1e959:    *           LogRecord to be allocated.
1:ea1e959:    * @param mark a log key identifying the location of the record
1:ea1e959:    *               within the journal
1:ea1e959:    * @return LogRecord containing requested record
1:ea1e959:    * @throws InvalidLogKeyException
1:ea1e959:    *         if logkey parameter is < 0L or if the requested key is not within the current range
1:ea1e959:    *         of keys in the log.
1:ea1e959:    * @throws LogConfigurationException
1:ea1e959:    * @throws LogException
1:ea1e959:    */  // FEATURE: 300792
1:ea1e959:   public LogRecord get(LogRecord lr, long mark) throws InvalidLogKeyException,
1:ea1e959:     LogConfigurationException,
1:ea1e959:     LogException, InvalidLogBufferException
1:ea1e959:   {
1:ea1e959:     /* this code is similar to LogBufferManager.replay() -- potential for refactor */
1:ea1e959:     int bsn = bmgr.bsnFromMark(mark);
1:ea1e959:     if (mark < 0 || (bsn == 0 && mark != 0))
1:ea1e959:       throw new InvalidLogKeyException(Long.toHexString(mark));
1:ea1e959:     
1:ea1e959:     if (lr == null)
1:ea1e959:       lr = new LogRecord((config.getBufferSize() * 1024)/4); // default to 1/4 buffer size
1:ea1e959:     
1:ea1e959:     // allocate a LogBuffer that we can use to read the journal
1:ea1e959:     try {
1:ea1e959:       if (lr.buffer == null)
1:ea1e959:         lr.buffer = bmgr.getLogBuffer(-1);
1:ea1e959:     } catch (ClassNotFoundException e) {
1:ea1e959:       throw new LogConfigurationException(e);
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     LogBuffer buffer = lr.buffer;
1:ea1e959:     
1:ea1e959:     // read block containing requested mark
1:ea1e959:     try {
1:ea1e959:       bmgr.forceCurrentBuffer();
1:ea1e959:       lfmgr.read(buffer, bsn);
1:ea1e959:     } catch (IOException e) {
1:ea1e959:       LogFile lf = buffer.lf;
1:ea1e959:       String msg = "Error reading " + lf.file + " @ position [" + lf.position + "]";
1:ea1e959:       throw new LogException(msg, e);
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     if (buffer.bsn == -1)
1:ea1e959:     {
1:ea1e959:       lr.type = LogRecordType.END_OF_LOG;
1:ea1e959:       return lr;
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     // verify we have the desired block
1:ea1e959:     // if requested mark == 0 then we start with the oldest block available
1:ea1e959:     int markBSN = (mark == 0) ? buffer.bsn : bmgr.bsnFromMark(mark);
1:ea1e959:     if (markBSN != buffer.bsn) {
1:ea1e959:       InvalidLogBufferException lbe = new InvalidLogBufferException(
1:ea1e959:           "block read [" + buffer.bsn + "] not block requested: " + markBSN);
1:ea1e959:       throw lbe;
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     /*
1:ea1e959:      * position buffer to requested mark.
1:ea1e959:      * 
1:ea1e959:      * Although the mark contains a buffer offset, we search forward
1:ea1e959:      * through the buffer to guarantee that we have the start
1:ea1e959:      * of a record.  This protects against using marks that were
1:ea1e959:      * not generated by the current Logger.
1:ea1e959:      */
1:ea1e959:     lr.get(buffer); // get first record in buffer
1:ea1e959:     if (mark > 0 && mark > bmgr.markFromBsn(markBSN,0)) {
1:ea1e959:       while(lr.key < mark) {
1:ea1e959:         lr.get(buffer);
1:ea1e959:       }
1:ea1e959:       if (lr.key != mark) {
1:ea1e959:         String msg = "The requested mark [" + Long.toHexString(mark) + 
1:ea1e959:           "] was not found in the log.";
1:ea1e959:         // BUG 300733 following line changed to throw an exception
1:ea1e959:         throw new InvalidLogKeyException(msg);
1:ea1e959:       }
1:ea1e959:     }
1:ea1e959:     
1:ea1e959:     return lr;
1:ea1e959:   }
1:ea1e959:   
1:ea1e959:   /**
1:ea1e959:    * Read the journal record that follows the record identified by lr.
1:ea1e959:    * @param lr LogRecord to be updated with the next journal record.
1:ea1e959:    * <p>The LogRecord <code> lr </code> must have been returned
1:ea1e959:    * by a previous call to Logger.get(LogRecord, long). 
1:ea1e959:    * <p>Effectively, the record identified by lr is located, and the record
1:ea1e959:    * immediately following it is returned.
1:ea1e959:    * @return LogRecord containing the requested record.
1:ea1e959:    * @throws IllegalArgumentException
1:ea1e959:    * if lr parameter is null or if the lr.buffer member is null.
1:ea1e959:    */  // FEATURE: 300792
1:ea1e959:   public LogRecord getNext(LogRecord lr)
1:ea1e959:     throws InvalidLogBufferException, LogException
1:ea1e959:   {
1:ea1e959:     if (lr == null || lr.buffer == null) throw new IllegalArgumentException();
1:ea1e959:     
1:ea1e959:     LogBuffer buffer = lr.buffer;
1:ea1e959:     
1:ea1e959:     // get next record
1:ea1e959:     lr.get(buffer);
1:ea1e959:     
1:ea1e959:     if (lr.isEOB())
1:ea1e959:     {
1:ea1e959:       long bsn = buffer.bsn;  // so we can test for wraparound
1:ea1e959:       try {
1:ea1e959:         lfmgr.read(buffer, buffer.bsn+1);
1:ea1e959:       } catch (IOException e) {
1:ea1e959:         LogFile lf = lr.buffer.lf;
1:ea1e959:         String msg = "Error reading " + lf.file + " @ position [" + lf.position + "]";
1:ea1e959:         throw new LogException(msg, e);
1:ea1e959:       }
1:ea1e959:       
1:ea1e959:       if (buffer.bsn == -1 || buffer.bsn < bsn) // BUG 304982
1:ea1e959:       {
1:ea1e959:         lr.type = LogRecordType.END_OF_LOG;
1:ea1e959:         return lr;
1:ea1e959:       }
1:ea1e959:       
1:ea1e959:       lr.get(buffer);
1:ea1e959:     }
1:ea1e959: 
1:ea1e959:     return lr;
1:ea1e959:   }
1:ea1e959: 
1:ea1e959:   /**
1:ea1e959:    * return an XML node containing statistics for the Logger,
1:ea1e959:    * the LogFile pool and the LogBuffer pool.
1:ea1e959:    * 
1:ea1e959:    * <p>The getStats method for the LogBufferManager and LogFileManager
1:ea1e959:    * are called to include statistics for these contained objects.
1:ea1e959:    * 
1:ea1e959:    * @return String contiining XML node.
1:ea1e959:    */
1:ea1e959:   public String getStats()
1:ea1e959:   {
1:ea1e959:     String name = this.getClass().getName();
1:ea1e959:     StringBuffer stats = new StringBuffer(
1:ea1e959:         "<Logger  class='" + name + "'>" 
1:ea1e959:     );
1:ea1e959:     
1:ea1e959:     // TODO: append Logger specific stats
1:ea1e959:     
1:ea1e959:     stats.append(bmgr.getStats());
1:ea1e959:     
1:ea1e959:     stats.append(lfmgr.getStats());
1:ea1e959:     
1:ea1e959:     stats.append("\n</Logger>" +
1:ea1e959:         "\n");
1:ea1e959:     
1:ea1e959:     return stats.toString();
1:ea1e959:   }
1:ea1e959:   
1:ea1e959: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:ea1e959
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * JOnAS: Java(TM) Open Application Server
1:  * Copyright (C) 2004 Bull S.A.
1:  * All rights reserved.
1:  * 
1:  * Contact: howl@objectweb.org
1:  * 
1:  * This software is licensed under the BSD license.
1:  * 
1:  * Redistribution and use in source and binary forms, with or without
1:  * modification, are permitted provided that the following conditions
1:  * are met:
1:  * 
1:  *   * Redistributions of source code must retain the above copyright
1:  *     notice, this list of conditions and the following disclaimer.
1:  *     
1:  *   * Redistributions in binary form must reproduce the above copyright
1:  *     notice, this list of conditions and the following disclaimer in the
1:  *     documentation and/or other materials provided with the distribution.
1:  *     
1:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
1:  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
1:  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
1:  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
1:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
1:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
1:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
1:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
1:  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
1:  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
1:  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
1:  * 
1:  * ------------------------------------------------------------------------------
1:  * $Id: Logger.java,v 1.14 2006/04/21 15:03:36 girouxm Exp $
1:  * ------------------------------------------------------------------------------
1:  */
1: package org.objectweb.howl.log;
1: 
1: import java.io.IOException;
1: 
1: /**
1:  * Manage a configured set of two or more physical log files.
1:  * 
1:  * <p>Log files have a configured maximum size.  When a file has
1:  * reached the configured capacity, Logger switches to
1:  * the next available alternate file.  Normally, log files are created
1:  * in advance to guarantee that space is available during execution.
1:  * 
1:  * <p>Each log file has a file header containing information 
1:  * allowing Logger to reposition and replay the logs
1:  * during a recovery scenario.
1:  * 
1:  * <p>LogFile <i> marking </i>
1:  * <p>The LogFile's mark is the the position within the file
1:  * of the oldest active entry.
1:  * Initially the mark is set at the beginning of the file.
1:  * At some configured interval, the caller invokes <i> mark() </i>
1:  * with the key of the oldest active entry in the log.
1:  * 
1:  * <p>For XA the key would be for the oldest transaction still
1:  * in committing state.  In theory, XA could call <i> mark() </i> every
1:  * time a DONE record is logged.  In practice, it should only be
1:  * necessary to call <i> mark() </i> every minute or so depending on the
1:  * capacity of the log files.
1:  * 
1:  * <p>The Logger maintains an active mark within the set
1:  * of log files.  A file may be reused only if the mark does not
1:  * reside within the file.  The Logger will throw
1:  * LogFileOverflowException if an attempt is made to switch to a
1:  * file that contains a mark.
1:  * 
1:  * @author Michael Giroux
1:  *
1:  */
1: public class Logger extends LogObject
1: {
1:   /**
1:    * indicates whether the LogFile is open.
1:    * <p>Logger methods return LogClosedException when log is closed.
1:    */
1:   protected volatile boolean isClosed = true;
1:   
1:   /**
1:    * Manages a pool of buffers used for log file IO.
1:    */
1:   LogBufferManager bmgr = null;
1:   
1:   /**
1:    * Manages a pool of files used for log file IO.
1:    */
1:   LogFileManager lfmgr = null;
1:   
1:   /**
1:    * @return activeMark member of the associated LogFileManager.
1:    */
1:   public long getActiveMark()
1:   {
1:     return lfmgr.activeMark;
1:   }
1:   
1:   /**
1:    * Construct a Logger using default Configuration object.
1:    * @throws IOException
1:    */
1:   public Logger()
1:     throws IOException
1:   {
1:     this(new Configuration());
1:   }
1:   
1:   /**
1:    * Construct a Logger using a Configuration supplied
1:    * by the caller.
1:    * @param config Configuration object
1:    * @throws IOException
1:    */
1:   public Logger(Configuration config)
1:     throws IOException
1:   {
1:     super(config);
1: 
1:     lfmgr = new LogFileManager(config);
1:     
1:     bmgr = new LogBufferManager(config);
1:   }
1:   
1:   /**
1:    * add a USER record consisting of byte[][] to log. 
1:    * 
1:    * <p>if <i> sync </i> parameter is true, then the method will
1:    * block (in bmgr.put()) until the <i> data </i> buffer is forced to disk.
1:    * Otherwise, the method returns immediately.
1:    * 
1:    * @param data record data
1:    * @param sync true if call should block until force
1:    * 
1:    * @return a key that can be used to locate the record.
1:    * Some implementations may use the key as a correlation ID 
1:    * to associate related records.
1:    * 
1:    * When automark is disabled (false) the caller must
1:    * invoke mark() using this key to indicate the location
1:    * of the oldest active entry in the log.
1:    * 
1:    * @throws LogClosedException
1:    * @throws LogRecordSizeException
1:    * @throws LogFileOverflowException
1:    * @throws InterruptedException
1:    * @throws IOException
1:    * 
1:    * @see #mark(long)
1:    * @see #setAutoMark(boolean)
1:    */
1:   public long put(byte[][] data, boolean sync)
1:     throws LogClosedException, LogRecordSizeException, LogFileOverflowException,
1:                 InterruptedException, IOException
1:   {
1:     return put(LogRecordType.USER, data, sync);
1:   }
1:   
1:   /**
1:    * add a USER record consisting of byte[] to the log.
1:    * 
1:    * <p>wrap byte[] <i> data </i> in a new byte[][]
1:    * and delegates call to put(byte[][], boolean)
1:    *  
1:    * @param data byte[] to be written to log
1:    * @param sync true if caller wishes to block waiting for the
1:    * record to force to disk.
1:    * @return log key for the record
1:    * @throws LogClosedException
1:    * @throws LogRecordSizeException
1:    * @throws LogFileOverflowException
1:    * @throws InterruptedException
1:    * @throws IOException
1:    */
1:   public long put(byte[] data, boolean sync)
1:     throws LogClosedException, LogRecordSizeException, LogFileOverflowException,
1:       InterruptedException, IOException
1:   {
1:     return put(LogRecordType.USER, new byte[][]{data}, sync);
1:   }
1: 
1:   /**
1:    * Sub-classes call this method to write log records with
1:    * a specific record type.
1:    * 
1:    * @param type a record type defined in LogRecordType.
1:    * @param data record data to be logged.
1:    * @param sync boolean indicating whether call should
1:    * wait for data to be written to physical disk.
1:    * 
1:    * @return a log key that can be used to reference
1:    * the record.
1:    */
1:   protected long put(short type, byte[][] data, boolean sync)
1:   throws LogClosedException, LogRecordSizeException, LogFileOverflowException,
1:   InterruptedException, IOException
1:   {
1:     synchronized(this)
1:     {
1:       if (isClosed) throw new LogClosedException();
1:     }
1:     
1:     // QUESTION: should we deal with exceptions here?
1: 
1:     long key = bmgr.put(type, data, sync);
1:     lfmgr.setCurrentKey(key);
1:     
1:     return key;
1:   }
1:   
1:   /**
1:    * sets the LogFile's mark.
1:    * 
1:    * <p><i> mark() </i> provides a generalized method for callers
1:    * to inform the Logger that log space can be released
1:    * for reuse.
1:    * 
1:    * <p>calls LogFileManager to process the request.
1:    * 
1:    * @param key is a log key returned by a previous call to put().
1:    * @param force a boolean that indicates whether the mark data
1:    * should be forced to disk.  When set to <b> true </b> the caller
1:    * is blocked until the mark record is forced to disk.
1:    * 
1:    * @throws InvalidLogKeyException
1:    * if <i> key </i> parameter is out of range.
1:    * <i> key </i> must be greater than current activeMark and less than the most recent
1:    * key returned by put().
1:    * @throws LogClosedException
1:    * if this logger instance has been closed.
1:    */
1:   public void mark(long key, boolean force)
1:     throws InvalidLogKeyException, LogClosedException, IOException, InterruptedException
1:   {
1:     synchronized(this)
1:     {
1:       if (isClosed)
1:         throw new LogClosedException("log is closed");
1:     }
1:     
1:     lfmgr.mark(key, force);
1:   }
1:   
1:   /**
1:    * calls Logger.mark(key, force) with <i> force </i> set to <b> true </b>.
1:    * <p>Caller is blocked until mark record is forced to disk.
1:    * @param key a log key returned by a previous call to put().
1:    * @throws InvalidLogKeyException
1:    * @throws LogClosedException
1:    * @throws IOException
1:    * @throws InterruptedException
1:    * @see #mark(long, boolean)
1:    */
1:   public void mark(long key)
1:     throws InvalidLogKeyException, LogClosedException, IOException, InterruptedException
1:   {
1:     mark(key, true);
1:   }
1:   
1:   /**
1:    * Sets the LogFile marking mode.
1:    * 
1:    * <p>passes call to LogFileManager
1:    * 
1:    * @param autoMark true to indicate automatic marking.
1:    */
1:   public void setAutoMark(boolean autoMark)
1:     throws InvalidLogKeyException, LogClosedException, LogFileOverflowException, IOException, InterruptedException
1:   {
1:     synchronized(this)
1:     {
1:       if (this.isClosed) throw new LogClosedException();
1:     }
1:     
1:     lfmgr.setAutoMark(autoMark);
1:   }
1:   
1:   /**
1:    * close the Log files and perform necessary cleanup tasks.
1:    */
1:   public void close() throws IOException, InterruptedException
1:   {
1:     // prevent new threads from adding to the log
1:     synchronized(this) { isClosed = true; }
1:     
1:     lfmgr.close();
1:     bmgr.close();
1:   }
1:   
1:   /**
1:    * open Log files and perform necessart initialization.
1:    * 
1:    * TODO: consider open(String name) to allow named configurations.
1:    *       this would allow utility to open two loggers and copy 
1:    *       old records to new files.
1:    *
1:    */
1:   public void open()
1:     throws InvalidFileSetException,
1:            IOException, LogConfigurationException, InvalidLogBufferException, InterruptedException
1:   {
1:     lfmgr.open();
1:     
1:     try {
1:       bmgr.open();
1:     } catch (ClassNotFoundException e) {
1:       String cnf = "LogBuffer Class not found: " + config.getBufferClassName();
1:       LogConfigurationException lce = new LogConfigurationException(cnf, e);
1:       throw lce;
1:     }
1:     
1:     // read header information from each file
1:     lfmgr.init(bmgr);
1:     
1:     // indicate that Log is ready for use.
1:     synchronized(this) { isClosed = false; }
1:   }
1:   
1:   /**
1:    * Registers a LogEventListener for log event notifications.
1:    * 
1:    * @param eventListener object to be notified of logger events.
1:    */
1:   public void setLogEventListener(LogEventListener eventListener)
1:   {
1:     lfmgr.setLogEventListener(eventListener);
1:   }
1:   
1:   /**
1:    * Replays log from a specified mark forward to the current mark.
1:    * 
1:    * <p>Beginning with the record located at <i> mark </i>
1:    * the Logger reads log records forward to the end of the log.
1:    * USER records are passed to the <i> listener </i> onRecord()
1:    * method. When the end of log has been reached, replay returns
1:    * one final record with a type of END_OF_LOG to inform <i> listener </i>
1:    * that no further records will be returned.
1:    * 
1:    * <p>If an error is encountered while reading the log, the
1:    * <i> listener </i> onError method is called.  Replay terminates
1:    * when any error occurs and when END_OF_LOG is encountered.
1:    * 
1:    * @param listener an object that implements ReplayListener interface.
1:    * @param mark a log key to begin replay from.
1:    * <p>The <i> mark </i> should be a valid log key returned by the put()
1:    * method.  To replay the entire log beginning with the oldest available
1:    * record, <i> mark </i> should be set to zero (0L).
1:    * @throws LogConfigurationException
1:    * most likely because the configured LogBuffer class cannot be found.
1:    * @throws InvalidLogKeyException
1:    * if <i> mark </i> is not a valid log key.
1:    */
1:   public void replay(ReplayListener listener, long mark)
1:     throws InvalidLogKeyException, LogConfigurationException
1:   {
1:     // replay only the user records.
1:     bmgr.replay(listener, mark, false);
1:   }
1:   
1:   /**
1:    * Replays log from the active mark forward to the current position.
1:    * 
1:    * @param listener an object that implements ReplayListener interface.
1:    * @throws LogConfigurationException
1:    * most likely because the configured LogBuffer class cannot be found.
1:    * @see #replay(ReplayListener, long)
1:    */
1:   public void replay(ReplayListener listener) throws LogConfigurationException
1:   {
1:     try {
1:       bmgr.replay(listener, lfmgr.activeMark, false);
1:     } catch (InvalidLogKeyException e) {
1:       // should not happen -- use assert to catch during development
1:       assert false : "Unhandled InvalidLogKeyException" + e.toString();
1:     }
1:   }
1:   
1:   /**
1:    * Allows sub-classes of Logger to replay control records.
1:    * 
1:    * @param listener ReplayListener to receive the records 
1:    * @param mark starting mark (log key) for the replay.
1:    * @param replayCtrlRecords boolean indicating whether to
1:    * return CTRL records.
1:    * @throws InvalidLogKeyException
1:    * If the <i> mark </i> parameter specifies an invalid log key
1:    * (one that does not exist in the current set of log files.)
1:    * @throws LogConfigurationException
1:    * 
1:    * @see org.objectweb.howl.log.LogBufferManager#replay(ReplayListener, long, boolean)
1:    */
1:   protected void replay(ReplayListener listener, long mark, boolean replayCtrlRecords)
1:   throws InvalidLogKeyException, LogConfigurationException
1:   {
1:     bmgr.replay(listener, mark, replayCtrlRecords);
1:   }
1:   
1:   /**
1:    * Read a specific record from the log.
1:    * <p>Control records are not filtered by this method.
1:    * If the requested mark is valid and identifies a control record,
1:    * the record will be returned.
1:    * @param lr LogRecord to be updated or null if caller wishes a new
1:    *           LogRecord to be allocated.
1:    * @param mark a log key identifying the location of the record
1:    *               within the journal
1:    * @return LogRecord containing requested record
1:    * @throws InvalidLogKeyException
1:    *         if logkey parameter is < 0L or if the requested key is not within the current range
1:    *         of keys in the log.
1:    * @throws LogConfigurationException
1:    * @throws LogException
1:    */  // FEATURE: 300792
1:   public LogRecord get(LogRecord lr, long mark) throws InvalidLogKeyException,
1:     LogConfigurationException,
1:     LogException, InvalidLogBufferException
1:   {
1:     /* this code is similar to LogBufferManager.replay() -- potential for refactor */
1:     int bsn = bmgr.bsnFromMark(mark);
1:     if (mark < 0 || (bsn == 0 && mark != 0))
1:       throw new InvalidLogKeyException(Long.toHexString(mark));
1:     
1:     if (lr == null)
1:       lr = new LogRecord((config.getBufferSize() * 1024)/4); // default to 1/4 buffer size
1:     
1:     // allocate a LogBuffer that we can use to read the journal
1:     try {
1:       if (lr.buffer == null)
1:         lr.buffer = bmgr.getLogBuffer(-1);
1:     } catch (ClassNotFoundException e) {
1:       throw new LogConfigurationException(e);
1:     }
1:     
1:     LogBuffer buffer = lr.buffer;
1:     
1:     // read block containing requested mark
1:     try {
1:       bmgr.forceCurrentBuffer();
1:       lfmgr.read(buffer, bsn);
1:     } catch (IOException e) {
1:       LogFile lf = buffer.lf;
1:       String msg = "Error reading " + lf.file + " @ position [" + lf.position + "]";
1:       throw new LogException(msg, e);
1:     }
1:     
1:     if (buffer.bsn == -1)
1:     {
1:       lr.type = LogRecordType.END_OF_LOG;
1:       return lr;
1:     }
1:     
1:     // verify we have the desired block
1:     // if requested mark == 0 then we start with the oldest block available
1:     int markBSN = (mark == 0) ? buffer.bsn : bmgr.bsnFromMark(mark);
1:     if (markBSN != buffer.bsn) {
1:       InvalidLogBufferException lbe = new InvalidLogBufferException(
1:           "block read [" + buffer.bsn + "] not block requested: " + markBSN);
1:       throw lbe;
1:     }
1:     
1:     /*
1:      * position buffer to requested mark.
1:      * 
1:      * Although the mark contains a buffer offset, we search forward
1:      * through the buffer to guarantee that we have the start
1:      * of a record.  This protects against using marks that were
1:      * not generated by the current Logger.
1:      */
1:     lr.get(buffer); // get first record in buffer
1:     if (mark > 0 && mark > bmgr.markFromBsn(markBSN,0)) {
1:       while(lr.key < mark) {
1:         lr.get(buffer);
1:       }
1:       if (lr.key != mark) {
1:         String msg = "The requested mark [" + Long.toHexString(mark) + 
1:           "] was not found in the log.";
1:         // BUG 300733 following line changed to throw an exception
1:         throw new InvalidLogKeyException(msg);
1:       }
1:     }
1:     
1:     return lr;
1:   }
1:   
1:   /**
1:    * Read the journal record that follows the record identified by lr.
1:    * @param lr LogRecord to be updated with the next journal record.
1:    * <p>The LogRecord <code> lr </code> must have been returned
1:    * by a previous call to Logger.get(LogRecord, long). 
1:    * <p>Effectively, the record identified by lr is located, and the record
1:    * immediately following it is returned.
1:    * @return LogRecord containing the requested record.
1:    * @throws IllegalArgumentException
1:    * if lr parameter is null or if the lr.buffer member is null.
1:    */  // FEATURE: 300792
1:   public LogRecord getNext(LogRecord lr)
1:     throws InvalidLogBufferException, LogException
1:   {
1:     if (lr == null || lr.buffer == null) throw new IllegalArgumentException();
1:     
1:     LogBuffer buffer = lr.buffer;
1:     
1:     // get next record
1:     lr.get(buffer);
1:     
1:     if (lr.isEOB())
1:     {
1:       long bsn = buffer.bsn;  // so we can test for wraparound
1:       try {
1:         lfmgr.read(buffer, buffer.bsn+1);
1:       } catch (IOException e) {
1:         LogFile lf = lr.buffer.lf;
1:         String msg = "Error reading " + lf.file + " @ position [" + lf.position + "]";
1:         throw new LogException(msg, e);
1:       }
1:       
1:       if (buffer.bsn == -1 || buffer.bsn < bsn) // BUG 304982
1:       {
1:         lr.type = LogRecordType.END_OF_LOG;
1:         return lr;
1:       }
1:       
1:       lr.get(buffer);
1:     }
1: 
1:     return lr;
1:   }
1: 
1:   /**
1:    * return an XML node containing statistics for the Logger,
1:    * the LogFile pool and the LogBuffer pool.
1:    * 
1:    * <p>The getStats method for the LogBufferManager and LogFileManager
1:    * are called to include statistics for these contained objects.
1:    * 
1:    * @return String contiining XML node.
1:    */
1:   public String getStats()
1:   {
1:     String name = this.getClass().getName();
1:     StringBuffer stats = new StringBuffer(
1:         "<Logger  class='" + name + "'>" 
1:     );
1:     
1:     // TODO: append Logger specific stats
1:     
1:     stats.append(bmgr.getStats());
1:     
1:     stats.append(lfmgr.getStats());
1:     
1:     stats.append("\n</Logger>" +
1:         "\n");
1:     
1:     return stats.toString();
1:   }
1:   
1: }
============================================================================