1:dc7365b: /**
1:dc7365b:  * Licensed to the Apache Software Foundation (ASF) under one
1:dc7365b:  * or more contributor license agreements.  See the NOTICE file
1:dc7365b:  * distributed with this work for additional information
1:dc7365b:  * regarding copyright ownership.  The ASF licenses this file
1:dc7365b:  * to you under the Apache License, Version 2.0 (the
1:dc7365b:  * "License"); you may not use this file except in compliance
1:dc7365b:  * with the License.  You may obtain a copy of the License at
1:dc7365b:  *
1:dc7365b:  *   http://www.apache.org/licenses/LICENSE-2.0
1:dc7365b:  *
1:dc7365b:  * Unless required by applicable law or agreed to in writing,
1:dc7365b:  * software distributed under the License is distributed on an
1:dc7365b:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:dc7365b:  * KIND, either express or implied.  See the License for the
1:dc7365b:  * specific language governing permissions and limitations
1:dc7365b:  * under the License.
1:dc7365b:  */
1:6bd0f94: package org.apache.aries.application.modelling.impl;
1:6bd0f94: 
1:6bd0f94: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1:6bd0f94: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1:6bd0f94: 
1:6bd0f94: import java.io.InputStream;
1:6bd0f94: import java.net.URL;
1:6bd0f94: import java.util.ArrayList;
1:6bd0f94: import java.util.Collection;
1:6bd0f94: import java.util.HashMap;
1:906d778: import java.util.HashSet;
1:5965be7: import java.util.LinkedHashSet;
1:4db0d92: import java.util.LinkedList;
1:6bd0f94: import java.util.List;
1:6bd0f94: import java.util.Map;
1:4db0d92: import java.util.Queue;
1:6bd0f94: import java.util.Set;
1:6bd0f94: 
1:6bd0f94: import org.apache.aries.application.InvalidAttributeException;
1:6bd0f94: import org.apache.aries.application.modelling.ExportedService;
1:6bd0f94: import org.apache.aries.application.modelling.ImportedService;
1:6bd0f94: import org.apache.aries.application.modelling.ModellingManager;
1:6bd0f94: import org.apache.aries.application.modelling.ParsedServiceElements;
1:6bd0f94: import org.apache.aries.application.modelling.ParserProxy;
1:6bd0f94: import org.apache.aries.application.modelling.WrappedServiceMetadata;
1:6bd0f94: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:6bd0f94: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1:906d778: import org.osgi.service.blueprint.reflect.BeanArgument;
1:6bd0f94: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:906d778: import org.osgi.service.blueprint.reflect.BeanProperty;
1:6bd0f94: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.MapEntry;
1:906d778: import org.osgi.service.blueprint.reflect.MapMetadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.Metadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.RefMetadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1:906d778: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:906d778: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:6bd0f94: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:6bd0f94: import org.osgi.service.blueprint.reflect.Target;
1:6bd0f94: import org.osgi.service.blueprint.reflect.ValueMetadata;
1:6bd0f94: import org.osgi.service.jndi.JNDIConstants;
1:6bd0f94: import org.slf4j.Logger;
1:6bd0f94: import org.slf4j.LoggerFactory;
1:6bd0f94: 
1:6bd0f94: abstract public class AbstractParserProxy implements ParserProxy {
1:6bd0f94: 	  private final Logger _logger = LoggerFactory.getLogger(AbstractParserProxy.class);
1:6bd0f94: 	  private ModellingManager _modellingManager;
1:6bd0f94: 
1:6bd0f94: 
1:6bd0f94:       protected abstract ComponentDefinitionRegistry parseCDR(List<URL> blueprintsToParse) throws Exception;
1:6bd0f94:       protected abstract ComponentDefinitionRegistry parseCDR(InputStream blueprintToParse) throws Exception;
1:6bd0f94: 	  
1:6bd0f94: 	  public void setModellingManager (ModellingManager m) { 
1:6bd0f94: 	    _modellingManager = m;
3:6bd0f94: 	  }
1:6bd0f94: 
1:6bd0f94: 	  public List<? extends WrappedServiceMetadata> parse(List<URL> blueprintsToParse) throws Exception {
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "parse", new Object[]{blueprintsToParse});
1:6bd0f94: 	    ComponentDefinitionRegistry cdr = parseCDR (blueprintsToParse);
1:6bd0f94: 	    List<? extends WrappedServiceMetadata> result = parseCDRForServices (cdr, true);
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "parse", new Object[]{result});
1:6bd0f94: 	    return result;
1:6bd0f94: 	  }
1:6bd0f94: 	   
1:6bd0f94: 	  public List<? extends WrappedServiceMetadata> parse(URL blueprintToParse) throws Exception {
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "parse", new Object[]{blueprintToParse});
1:6bd0f94: 	    List<URL> list = new ArrayList<URL>();
1:6bd0f94: 	    list.add(blueprintToParse);
1:6bd0f94: 	   
1:6bd0f94: 	    List<? extends WrappedServiceMetadata> result = parse (list);
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "parse", new Object[]{result});
1:6bd0f94: 	    return result;
1:6bd0f94: 	  }
1:6bd0f94: 
1:6bd0f94: 	  public List<? extends WrappedServiceMetadata> parse(InputStream blueprintToParse) throws Exception {
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "parse", new Object[]{blueprintToParse});
1:6bd0f94: 	    ComponentDefinitionRegistry cdr = parseCDR (blueprintToParse);
1:6bd0f94: 	    List<? extends WrappedServiceMetadata> result = parseCDRForServices (cdr, true);
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "parse", new Object[]{result});
1:6bd0f94: 	    return result;
1:6bd0f94: 	  }
1:6bd0f94: 	 
1:6bd0f94: 
1:6bd0f94: 	  public ParsedServiceElements parseAllServiceElements(InputStream blueprintToParse) throws Exception {
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "parseAllServiceElements", new Object[]{blueprintToParse});
1:6bd0f94: 	    ComponentDefinitionRegistry cdr = parseCDR (blueprintToParse);
1:6bd0f94: 	    Collection<ExportedService> services = parseCDRForServices(cdr, false);
1:6bd0f94: 	    Collection<ImportedService> references = parseCDRForReferences (cdr);
1:6bd0f94: 	    ParsedServiceElements result = _modellingManager.getParsedServiceElements(services, references);
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "parseAllServiceElements", new Object[]{result});
1:6bd0f94: 	    return result;
1:4db0d92: 	  }
1:6bd0f94: 	  
2:6bd0f94: 	  /**
1:6bd0f94: 	   * Extract Service metadata from a ComponentDefinitionRegistry. When doing SCA modelling, we
1:6bd0f94: 	   * need to suppress anonymous services. We don't want to do that when we're modelling for 
1:6bd0f94: 	   * provisioning dependencies. 
1:6bd0f94: 	   * @param cdr                       ComponentDefinitionRegistry
1:6bd0f94: 	   * @param suppressAnonymousServices Unnamed services will not be returned if this is true
1:6bd0f94: 	   * @return List<WrappedServiceMetadata>
1:6bd0f94: 	   */
1:6bd0f94: 	  private List<ExportedService> parseCDRForServices (ComponentDefinitionRegistry cdr, 
1:6bd0f94: 	      boolean suppressAnonymousServices) { 
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "parseCDRForServices", new Object[]{cdr, suppressAnonymousServices});
1:6bd0f94: 	    List<ExportedService> result = new ArrayList<ExportedService>();
1:906d778: 	    for (ComponentMetadata compMetadata : findAllComponents(cdr)) { 
1:6bd0f94: 	      if (compMetadata instanceof ServiceMetadata) { 
1:6bd0f94: 	        ServiceMetadata serviceMetadata = (ServiceMetadata)compMetadata;
1:6bd0f94: 	        String serviceName;
1:6bd0f94: 	        int ranking;
1:6bd0f94: 	        Collection<String> interfaces = new ArrayList<String>(); 
1:6bd0f94: 	        Map<String, Object> serviceProps = new HashMap<String, Object>();
1:6bd0f94: 
1:6bd0f94: 	        ranking = serviceMetadata.getRanking();
1:6bd0f94: 	        for (Object i : serviceMetadata.getInterfaces()) {
1:6bd0f94: 	          interfaces.add((String)i);
1:6bd0f94: 	        }
1:6bd0f94: 	        
1:6bd0f94: 	        // get the service properties
1:6bd0f94: 	        List<MapEntry> props = serviceMetadata.getServiceProperties();
1:6bd0f94: 	        for (MapEntry entry : props) { 
1:6bd0f94: 	          String key = ((ValueMetadata)entry.getKey()).getStringValue();
1:6bd0f94: 	          
1:6bd0f94: 	          Metadata value = entry.getValue();
1:6bd0f94: 	          if (value instanceof CollectionMetadata) { 
1:4db0d92: 	            processMultiValueProperty(serviceProps, key, value);
1:6bd0f94: 	          } else { 
1:6bd0f94: 	            serviceProps.put(key, ((ValueMetadata)entry.getValue()).getStringValue());
1:6bd0f94: 	          }
1:6bd0f94: 	        }
1:6bd0f94: 
1:6bd0f94: 	        // serviceName: use the service id unless that's not set, 
1:6bd0f94: 	        // in which case we use the bean id. 
1:6bd0f94: 	        serviceName = serviceMetadata.getId();
1:6bd0f94: 	        
1:6bd0f94: 	        // If the Service references a Bean, export the bean id as a service property
1:6bd0f94: 	        // as per 121.6.5 p669 of the blueprint 1.0 specification
1:6bd0f94: 	        Target t = serviceMetadata.getServiceComponent();
1:6bd0f94: 	        String targetId = null;
1:6bd0f94: 	        if (t instanceof RefMetadata) { 
1:6bd0f94: 	          targetId = ((RefMetadata)t).getComponentId();
1:6bd0f94: 	        } else if (t instanceof BeanMetadata) { 
1:6bd0f94: 	          targetId = ((BeanMetadata)t).getId();
1:6bd0f94: 	        }
1:6bd0f94: 	        
1:6bd0f94: 	        // Our OBR code MUST have access to targetId if it's available (i.e. not null 
1:6bd0f94: 	        // or auto-generated for an anonymous service. This must ALWAYS be set. 
1:6bd0f94: 	        if (targetId != null && !targetId.startsWith(".")) { // Don't set this for anonymous inner components
1:6bd0f94: 	            serviceProps.put("osgi.service.blueprint.compname", targetId);
1:6bd0f94: 	          if (serviceName == null || serviceName.equals("") || serviceName.startsWith(".")) { 
1:6bd0f94: 	            serviceName = targetId;
1:6bd0f94: 	          }
1:6bd0f94: 	        }
1:6bd0f94: 	        
1:6bd0f94: 	        if(serviceName != null && serviceName.startsWith("."))
1:6bd0f94: 	          serviceName = null;
1:6bd0f94: 	        
1:6bd0f94: 	        // If suppressAnonymous services, do not expose services that have no name
1:6bd0f94: 	        if (!suppressAnonymousServices || (serviceName != null)) { 
1:6bd0f94: 	          ExportedService wsm = _modellingManager.getExportedService(serviceName, ranking, interfaces, serviceProps);
1:6bd0f94: 	          result.add(wsm);
1:6bd0f94: 	        }
1:6bd0f94: 	      }
1:6bd0f94: 	    }
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "parseAllServiceElements", new Object[]{result});
1:6bd0f94: 	    return result; 
1:6bd0f94: 	  }
1:4db0d92:     private void processMultiValueProperty(Map<String, Object> serviceProps,
1:4db0d92:         String key, Metadata value) {
1:4db0d92:       List<Metadata> values = ((CollectionMetadata)value).getValues();
1:4db0d92:       Class<?> collectionClass = ((CollectionMetadata)value).getCollectionClass();
1:4db0d92:       Object collectionValue;
1:4db0d92:       
1:4db0d92:       if(Collection.class.isAssignableFrom(collectionClass)) {
1:4db0d92:         Collection<String> theseValues = getCollectionFromClass(collectionClass);
1:4db0d92:         for(Metadata m : values) {
1:4db0d92:           theseValues.add(((ValueMetadata)m).getStringValue());
1:4db0d92:         }
1:4db0d92:         collectionValue = theseValues;
1:4db0d92:       } else {
1:4db0d92:         String[] theseValues = new String[values.size()];
1:4db0d92:         for (int i=0; i < values.size(); i++) { 
1:4db0d92:           Metadata m = values.get(i); 
1:4db0d92:           theseValues[i] = ((ValueMetadata)m).getStringValue();
1:4db0d92:         }
1:4db0d92:         collectionValue = theseValues;
1:4db0d92:       }
1:4db0d92:       serviceProps.put(key, collectionValue);
1:4db0d92:     }	  
1:6bd0f94: 	  
1:4db0d92: 	  private Collection<String> getCollectionFromClass(Class<?> collectionClass) {
1:4db0d92: 	    
1:4db0d92: 	    if(List.class.isAssignableFrom(collectionClass)) {
1:4db0d92: 	      return new ArrayList<String>();
1:4db0d92: 	    } else if (Set.class.isAssignableFrom(collectionClass)) {
1:5965be7: 	      return new LinkedHashSet<String>();
1:4db0d92: 	    } else if (Queue.class.isAssignableFrom(collectionClass)) {
1:4db0d92: 	      //This covers Queue and Deque, which is caught by the isAssignableFrom check
1:4db0d92: 	      //as a sub-interface of Queue
1:4db0d92: 	      return new LinkedList<String>();
1:4db0d92: 	    } else {
1:4db0d92: 	      throw new IllegalArgumentException(collectionClass.getName());
1:4db0d92: 	    }
1:4db0d92: 	  }
1:4db0d92: 	  
1:4db0d92:     /**
1:6bd0f94: 	   * Extract References metadata from a ComponentDefinitionRegistry. 
1:6bd0f94: 	   * @param cdr                       ComponentDefinitionRegistry
1:6bd0f94: 	   * @return List<WrappedReferenceMetadata>
1:6bd0f94: 	   * @throws InvalidAttributeException 
1:6bd0f94: 	   */
1:6bd0f94: 	  private List<ImportedService> parseCDRForReferences (ComponentDefinitionRegistry cdr) throws InvalidAttributeException { 
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "parseCDRForReferences", new Object[]{cdr});
1:6bd0f94: 	    List<ImportedService> result = new ArrayList<ImportedService>();
1:906d778: 	    for (ComponentMetadata compMetadata : findAllComponents(cdr)) { 
1:6bd0f94: 	      if (compMetadata instanceof ServiceReferenceMetadata) { 
1:6bd0f94: 	        ServiceReferenceMetadata referenceMetadata = (ServiceReferenceMetadata)compMetadata;
1:6bd0f94: 
1:6bd0f94: 	        boolean optional = referenceMetadata.getAvailability() == ServiceReferenceMetadata.AVAILABILITY_OPTIONAL;
1:6bd0f94: 	        String iface = referenceMetadata.getInterface();
1:6bd0f94: 	        String compName = referenceMetadata.getComponentName();
1:6bd0f94: 	        String blueprintFilter = referenceMetadata.getFilter();
1:6bd0f94: 	        String id = referenceMetadata.getId();
1:6bd0f94: 	        boolean isMultiple = (referenceMetadata instanceof ReferenceListMetadata);
1:6bd0f94: 	        
1:6bd0f94: 	        //The blueprint parser teams up with JPA and blueprint resource ref
1:6bd0f94: 	        // namespace handlers to give us service imports of the form, 
1:6bd0f94: 	        // objectClass=javax.persistence.EntityManagerFactory, org.apache.aries.jpa.proxy.factory=*, osgi.unit.name=blabber
1:6bd0f94: 	        //
1:6bd0f94: 	        // There will be no matching service for this reference. 
1:6bd0f94: 	        // For now we blacklist certain objectClasses and filters - this is a pretty dreadful thing to do. 
1:6bd0f94: 	        if (!isBlacklisted (iface, blueprintFilter)) { 
1:6bd0f94: 	          ImportedService ref = _modellingManager.getImportedService (optional, iface, compName, blueprintFilter, 
1:6bd0f94: 	              id, isMultiple);
1:6bd0f94: 	          result.add (ref);  
1:6bd0f94: 	        }
1:6bd0f94: 	      }
1:6bd0f94: 	    }
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "parseCDRForReferences", new Object[]{result});
1:6bd0f94: 	    return result; 
1:6bd0f94: 	  }
1:906d778: 	  
1:906d778: 	  /**
1:906d778: 	   * Find all the components in a given {@link ComponentDefinitionRegistry} this finds top-level
1:906d778: 	   * components as well as their nested counter-parts. It may however not find components in custom namespacehandler 
1:906d778: 	   * {@link ComponentMetadata} instances.
1:906d778: 	   * 
1:906d778: 	   * @param cdr The {@link ComponentDefinitionRegistry} to scan
1:906d778: 	   * @return a {@link Set} of {@link ComponentMetadata}
1:906d778: 	   */
1:906d778: 	  private Set<ComponentMetadata> findAllComponents(ComponentDefinitionRegistry cdr) {
1:906d778: 	      Set<ComponentMetadata> components = new HashSet<ComponentMetadata>();
1:906d778: 	      
1:906d778: 	      for (String name : cdr.getComponentDefinitionNames()) {
1:906d778: 	          ComponentMetadata component = cdr.getComponentDefinition(name);
1:906d778: 	          traverseComponent(component, components);
1:906d778: 	      }
1:906d778: 	      
1:906d778: 	      return components;
1:906d778: 	  }
1:906d778: 	  
1:906d778: 	  /**
1:906d778: 	   * Traverse to find all nested {@link ComponentMetadata} instances
1:906d778: 	   * @param metadata
1:906d778: 	   * @param output
1:906d778: 	   */
1:906d778: 	  private void traverse(Metadata metadata, Set<ComponentMetadata> output) {
1:906d778: 	      if (metadata instanceof ComponentMetadata) {
1:906d778: 	          traverseComponent((ComponentMetadata) metadata, output);	          
1:906d778: 	      } else if (metadata instanceof CollectionMetadata) {
1:906d778: 	          CollectionMetadata collection = (CollectionMetadata) metadata;
1:906d778: 	          
1:906d778: 	          for (Metadata v : collection.getValues()) traverse(v, output);
1:906d778: 	      } else if (metadata instanceof MapMetadata) {
1:906d778: 	          MapMetadata map = (MapMetadata) metadata;
1:906d778: 	          
1:906d778: 	          for (MapEntry e : map.getEntries()) {
1:906d778: 	              traverse(e.getKey(), output);
1:906d778: 	              traverse(e.getValue(), output);
1:906d778: 	          }
1:906d778: 	      }
1:906d778: 	  }
1:906d778: 	  
1:906d778: 	  /**
1:906d778: 	   * Traverse {@link ComponentMetadata} instances to find all nested {@link ComponentMetadata} instances
1:906d778: 	   * @param component
1:906d778: 	   * @param output
1:906d778: 	   */
1:906d778: 	  private void traverseComponent(ComponentMetadata component, Set<ComponentMetadata> output) {
1:906d778: 	      if (!!!output.add(component)) return;
1:906d778: 	      
1:906d778: 	      if (component instanceof BeanMetadata) {
1:906d778: 	          BeanMetadata bean = (BeanMetadata) component;
1:906d778: 	          
1:906d778: 	          traverse(bean.getFactoryComponent(), output);
1:906d778: 
1:906d778: 	          for (BeanArgument argument : bean.getArguments()) {
1:906d778: 	              traverse(argument.getValue(), output);
1:906d778: 	          }
1:906d778: 	          
1:906d778: 	          for (BeanProperty property : bean.getProperties()) {
1:906d778: 	              traverse(property.getValue(), output);
1:906d778: 	          }
1:906d778: 	          
1:906d778: 	      } else if (component instanceof ServiceMetadata) {
1:906d778: 	          ServiceMetadata service = (ServiceMetadata) component;
1:906d778: 	          	          
1:906d778: 	          traverse(service.getServiceComponent(), output);
1:906d778: 	          
1:906d778: 	          for (RegistrationListener listener : service.getRegistrationListeners()) {
1:906d778: 	               traverse(listener.getListenerComponent(), output);
1:906d778: 	          }
1:906d778: 	          
1:906d778: 	          for (MapEntry e : service.getServiceProperties()) {
1:906d778: 	              traverse(e.getKey(), output);
1:906d778: 	              traverse(e.getValue(), output);
1:906d778: 	          }
1:906d778: 	          
1:906d778: 	      } else if (component instanceof ServiceReferenceMetadata) {
1:906d778: 	          ServiceReferenceMetadata reference = (ServiceReferenceMetadata) component;
1:906d778: 	          
1:906d778: 	          for (ReferenceListener listener : reference.getReferenceListeners()) {
1:906d778: 	              traverse(listener.getListenerComponent(), output);
1:906d778: 	          }
1:906d778: 	      }
1:906d778: 	  }
1:6bd0f94: 	
1:6bd0f94: 	  /**
1:6bd0f94: 	   * Some services are injected directly into isolated frameworks by default. We do 
1:6bd0f94: 	   * not need to model these services. They are not represented as ExportedServices 
1:6bd0f94: 	   * (Capabilities) in the various OBR registries, and so cannot be resolved against. 
1:6bd0f94: 	   * Since they are injected directly into each isolated framework, we do not need
1:6bd0f94: 	   * an entry in DEPLOYMENT.MF's Deployed-ImportService header for any of these 
1:6bd0f94: 	   * services. 
1:6bd0f94: 	   * 
1:6bd0f94: 	   * @param iface           The interface declared on a blueprint reference
1:6bd0f94: 	   * @param blueprintFilter The filter on the blueprint reference
1:6bd0f94: 	   * @return                True if the service is not 'blacklisted' and so may be exposed
1:6bd0f94: 	   *                        in the model being generated. 
1:6bd0f94: 	   */
1:6bd0f94: 	  protected boolean isBlacklisted (String iface, String blueprintFilter) { 
1:6bd0f94: 	    _logger.debug(LOG_ENTRY, "isBlacklisted", new Object[]{iface, blueprintFilter});
1:6bd0f94: 	    boolean blacklisted = false;
1:6bd0f94: 	    if (iface != null) {
1:6bd0f94: 	      // JPA - detect interface;
1:6bd0f94: 	      blacklisted |= iface.equals("javax.persistence.EntityManagerFactory");
1:6bd0f94: 	      blacklisted |= iface.equals("javax.persistence.EntityManager");
1:6bd0f94: 	    
1:6bd0f94: 	      // JTA - detect interface
1:6bd0f94: 	      blacklisted |= iface.equals("javax.transaction.UserTransaction");
1:6bd0f94: 	      blacklisted |= iface.equals("javax.transaction.TransactionSynchronizationRegistry");
1:6bd0f94: 	      
1:7a355b2: 	      // ConfigurationAdmin - detect interface
1:7a355b2: 	      blacklisted |= iface.equals("org.osgi.service.cm.ConfigurationAdmin");
1:7a355b2: 	               
1:6bd0f94: 	      // Don't provision against JNDI references
1:a0ebbc7: 	      if (blueprintFilter != null && blueprintFilter.trim().length() != 0) { 
1:6bd0f94: 	        Map<String, String> filter = ManifestHeaderProcessor.parseFilter(blueprintFilter);
1:6bd0f94: 	        blacklisted |= filter.containsKey(JNDIConstants.JNDI_SERVICENAME);
1:6bd0f94: 	      }
1:6bd0f94: 	    }
1:6bd0f94: 	    _logger.debug(LOG_EXIT, "isBlacklisted", new Object[]{!blacklisted});
1:6bd0f94: 	    return blacklisted;
1:6bd0f94: 	  }
1:6bd0f94: }
============================================================================
author:Holly Cummins
-------------------------------------------------------------------------------
commit:dc7365b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5965be7
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1: 	      return new LinkedHashSet<String>();
commit:4db0d92
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
1: import java.util.Queue;
/////////////////////////////////////////////////////////////////////////
1: 	            processMultiValueProperty(serviceProps, key, value);
/////////////////////////////////////////////////////////////////////////
1: 	  }
1:     private void processMultiValueProperty(Map<String, Object> serviceProps,
1:         String key, Metadata value) {
1:       List<Metadata> values = ((CollectionMetadata)value).getValues();
1:       Class<?> collectionClass = ((CollectionMetadata)value).getCollectionClass();
1:       Object collectionValue;
1:       
1:       if(Collection.class.isAssignableFrom(collectionClass)) {
1:         Collection<String> theseValues = getCollectionFromClass(collectionClass);
1:         for(Metadata m : values) {
1:           theseValues.add(((ValueMetadata)m).getStringValue());
1:         }
1:         collectionValue = theseValues;
1:       } else {
1:         String[] theseValues = new String[values.size()];
1:         for (int i=0; i < values.size(); i++) { 
1:           Metadata m = values.get(i); 
1:           theseValues[i] = ((ValueMetadata)m).getStringValue();
1:         }
1:         collectionValue = theseValues;
1:       }
1:       serviceProps.put(key, collectionValue);
1:     }	  
1: 	  private Collection<String> getCollectionFromClass(Class<?> collectionClass) {
1: 	    
1: 	    if(List.class.isAssignableFrom(collectionClass)) {
1: 	      return new ArrayList<String>();
1: 	    } else if (Set.class.isAssignableFrom(collectionClass)) {
0: 	      return new HashSet<String>();
1: 	    } else if (Queue.class.isAssignableFrom(collectionClass)) {
1: 	      //This covers Queue and Deque, which is caught by the isAssignableFrom check
1: 	      //as a sub-interface of Queue
1: 	      return new LinkedList<String>();
1: 	    } else {
1: 	      throw new IllegalArgumentException(collectionClass.getName());
1: 	    }
1: 	  }
1: 	  
1:     /**
commit:7a355b2
/////////////////////////////////////////////////////////////////////////
1: 	      // ConfigurationAdmin - detect interface
1: 	      blacklisted |= iface.equals("org.osgi.service.cm.ConfigurationAdmin");
1: 	               
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:3d7f5b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:906d778
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.BeanArgument;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
/////////////////////////////////////////////////////////////////////////
1: 	    for (ComponentMetadata compMetadata : findAllComponents(cdr)) { 
/////////////////////////////////////////////////////////////////////////
1: 	    for (ComponentMetadata compMetadata : findAllComponents(cdr)) { 
/////////////////////////////////////////////////////////////////////////
1: 	  
1: 	  /**
1: 	   * Find all the components in a given {@link ComponentDefinitionRegistry} this finds top-level
1: 	   * components as well as their nested counter-parts. It may however not find components in custom namespacehandler 
1: 	   * {@link ComponentMetadata} instances.
1: 	   * 
1: 	   * @param cdr The {@link ComponentDefinitionRegistry} to scan
1: 	   * @return a {@link Set} of {@link ComponentMetadata}
1: 	   */
1: 	  private Set<ComponentMetadata> findAllComponents(ComponentDefinitionRegistry cdr) {
1: 	      Set<ComponentMetadata> components = new HashSet<ComponentMetadata>();
1: 	      
1: 	      for (String name : cdr.getComponentDefinitionNames()) {
1: 	          ComponentMetadata component = cdr.getComponentDefinition(name);
1: 	          traverseComponent(component, components);
1: 	      }
1: 	      
1: 	      return components;
1: 	  }
1: 	  
1: 	  /**
1: 	   * Traverse to find all nested {@link ComponentMetadata} instances
1: 	   * @param metadata
1: 	   * @param output
1: 	   */
1: 	  private void traverse(Metadata metadata, Set<ComponentMetadata> output) {
1: 	      if (metadata instanceof ComponentMetadata) {
1: 	          traverseComponent((ComponentMetadata) metadata, output);	          
1: 	      } else if (metadata instanceof CollectionMetadata) {
1: 	          CollectionMetadata collection = (CollectionMetadata) metadata;
1: 	          
1: 	          for (Metadata v : collection.getValues()) traverse(v, output);
1: 	      } else if (metadata instanceof MapMetadata) {
1: 	          MapMetadata map = (MapMetadata) metadata;
1: 	          
1: 	          for (MapEntry e : map.getEntries()) {
1: 	              traverse(e.getKey(), output);
1: 	              traverse(e.getValue(), output);
1: 	          }
1: 	      }
1: 	  }
1: 	  
1: 	  /**
1: 	   * Traverse {@link ComponentMetadata} instances to find all nested {@link ComponentMetadata} instances
1: 	   * @param component
1: 	   * @param output
1: 	   */
1: 	  private void traverseComponent(ComponentMetadata component, Set<ComponentMetadata> output) {
1: 	      if (!!!output.add(component)) return;
1: 	      
1: 	      if (component instanceof BeanMetadata) {
1: 	          BeanMetadata bean = (BeanMetadata) component;
1: 	          
1: 	          traverse(bean.getFactoryComponent(), output);
1: 
1: 	          for (BeanArgument argument : bean.getArguments()) {
1: 	              traverse(argument.getValue(), output);
1: 	          }
1: 	          
1: 	          for (BeanProperty property : bean.getProperties()) {
1: 	              traverse(property.getValue(), output);
1: 	          }
1: 	          
1: 	      } else if (component instanceof ServiceMetadata) {
1: 	          ServiceMetadata service = (ServiceMetadata) component;
1: 	          	          
1: 	          traverse(service.getServiceComponent(), output);
1: 	          
1: 	          for (RegistrationListener listener : service.getRegistrationListeners()) {
1: 	               traverse(listener.getListenerComponent(), output);
1: 	          }
1: 	          
1: 	          for (MapEntry e : service.getServiceProperties()) {
1: 	              traverse(e.getKey(), output);
1: 	              traverse(e.getValue(), output);
1: 	          }
1: 	          
1: 	      } else if (component instanceof ServiceReferenceMetadata) {
1: 	          ServiceReferenceMetadata reference = (ServiceReferenceMetadata) component;
1: 	          
1: 	          for (ReferenceListener listener : reference.getReferenceListeners()) {
1: 	              traverse(listener.getListenerComponent(), output);
1: 	          }
1: 	      }
1: 	  }
commit:a0ebbc7
/////////////////////////////////////////////////////////////////////////
1: 	      if (blueprintFilter != null && blueprintFilter.trim().length() != 0) { 
commit:6bd0f94
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.application.modelling.impl;
1: 
1: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1: 
1: import java.io.InputStream;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import org.apache.aries.application.InvalidAttributeException;
1: import org.apache.aries.application.modelling.ExportedService;
1: import org.apache.aries.application.modelling.ImportedService;
1: import org.apache.aries.application.modelling.ModellingManager;
1: import org.apache.aries.application.modelling.ParsedServiceElements;
1: import org.apache.aries.application.modelling.ParserProxy;
1: import org.apache.aries.application.modelling.WrappedServiceMetadata;
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.MapEntry;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.Target;
1: import org.osgi.service.blueprint.reflect.ValueMetadata;
1: import org.osgi.service.jndi.JNDIConstants;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: abstract public class AbstractParserProxy implements ParserProxy {
1: 	  private final Logger _logger = LoggerFactory.getLogger(AbstractParserProxy.class);
1: 	  private ModellingManager _modellingManager;
1: 
1: 
1:       protected abstract ComponentDefinitionRegistry parseCDR(List<URL> blueprintsToParse) throws Exception;
1:       protected abstract ComponentDefinitionRegistry parseCDR(InputStream blueprintToParse) throws Exception;
1: 	  
1: 	  public void setModellingManager (ModellingManager m) { 
1: 	    _modellingManager = m;
1: 	  }
1: 
0: 	  @Override
1: 	  public List<? extends WrappedServiceMetadata> parse(List<URL> blueprintsToParse) throws Exception {
1: 	    _logger.debug(LOG_ENTRY, "parse", new Object[]{blueprintsToParse});
1: 	    ComponentDefinitionRegistry cdr = parseCDR (blueprintsToParse);
1: 	    List<? extends WrappedServiceMetadata> result = parseCDRForServices (cdr, true);
1: 	    _logger.debug(LOG_EXIT, "parse", new Object[]{result});
1: 	    return result;
1: 	  }
1: 	   
0: 	  @Override
1: 	  public List<? extends WrappedServiceMetadata> parse(URL blueprintToParse) throws Exception {
1: 	    _logger.debug(LOG_ENTRY, "parse", new Object[]{blueprintToParse});
1: 	    List<URL> list = new ArrayList<URL>();
1: 	    list.add(blueprintToParse);
1: 	   
1: 	    List<? extends WrappedServiceMetadata> result = parse (list);
1: 	    _logger.debug(LOG_EXIT, "parse", new Object[]{result});
1: 	    return result;
1: 	  }
1: 
0: 	  @Override
1: 	  public List<? extends WrappedServiceMetadata> parse(InputStream blueprintToParse) throws Exception {
1: 	    _logger.debug(LOG_ENTRY, "parse", new Object[]{blueprintToParse});
1: 	    ComponentDefinitionRegistry cdr = parseCDR (blueprintToParse);
1: 	    List<? extends WrappedServiceMetadata> result = parseCDRForServices (cdr, true);
1: 	    _logger.debug(LOG_EXIT, "parse", new Object[]{result});
1: 	    return result;
1: 	  }
1: 	 
1: 
0: 	  @Override
1: 	  public ParsedServiceElements parseAllServiceElements(InputStream blueprintToParse) throws Exception {
1: 	    _logger.debug(LOG_ENTRY, "parseAllServiceElements", new Object[]{blueprintToParse});
1: 	    ComponentDefinitionRegistry cdr = parseCDR (blueprintToParse);
1: 	    Collection<ExportedService> services = parseCDRForServices(cdr, false);
1: 	    Collection<ImportedService> references = parseCDRForReferences (cdr);
1: 	    ParsedServiceElements result = _modellingManager.getParsedServiceElements(services, references);
1: 	    _logger.debug(LOG_EXIT, "parseAllServiceElements", new Object[]{result});
1: 	    return result;
1: 	  }
1: 	  
1: 	  /**
1: 	   * Extract Service metadata from a ComponentDefinitionRegistry. When doing SCA modelling, we
1: 	   * need to suppress anonymous services. We don't want to do that when we're modelling for 
1: 	   * provisioning dependencies. 
1: 	   * @param cdr                       ComponentDefinitionRegistry
1: 	   * @param suppressAnonymousServices Unnamed services will not be returned if this is true
1: 	   * @return List<WrappedServiceMetadata>
1: 	   */
1: 	  private List<ExportedService> parseCDRForServices (ComponentDefinitionRegistry cdr, 
1: 	      boolean suppressAnonymousServices) { 
1: 	    _logger.debug(LOG_ENTRY, "parseCDRForServices", new Object[]{cdr, suppressAnonymousServices});
1: 	    List<ExportedService> result = new ArrayList<ExportedService>();
0: 	    Set<String> names = cdr.getComponentDefinitionNames();
0: 	    for (String name: names) { 
0: 	      ComponentMetadata compMetadata = cdr.getComponentDefinition(name);
1: 	      if (compMetadata instanceof ServiceMetadata) { 
1: 	        ServiceMetadata serviceMetadata = (ServiceMetadata)compMetadata;
1: 	        String serviceName;
1: 	        int ranking;
1: 	        Collection<String> interfaces = new ArrayList<String>(); 
1: 	        Map<String, Object> serviceProps = new HashMap<String, Object>();
1: 
1: 	        ranking = serviceMetadata.getRanking();
1: 	        for (Object i : serviceMetadata.getInterfaces()) {
1: 	          interfaces.add((String)i);
1: 	        }
1: 	        
1: 	        // get the service properties
1: 	        List<MapEntry> props = serviceMetadata.getServiceProperties();
1: 	        for (MapEntry entry : props) { 
1: 	          String key = ((ValueMetadata)entry.getKey()).getStringValue();
1: 	          
1: 	          Metadata value = entry.getValue();
1: 	          if (value instanceof CollectionMetadata) { 
0: 	            List<Metadata> values = ((CollectionMetadata)value).getValues();
0: 	            String[] theseValues = new String[values.size()];
0: 	            for (int i=0; i < values.size(); i++) { 
0: 	              Metadata m = values.get(i); 
0: 	              theseValues[i] = ((ValueMetadata)m).getStringValue();
1: 	            }
0: 	            serviceProps.put(key, theseValues);
1: 	          } else { 
1: 	            serviceProps.put(key, ((ValueMetadata)entry.getValue()).getStringValue());
1: 	          }
1: 	        }
1: 
1: 	        // serviceName: use the service id unless that's not set, 
1: 	        // in which case we use the bean id. 
1: 	        serviceName = serviceMetadata.getId();
1: 	        
1: 	        // If the Service references a Bean, export the bean id as a service property
1: 	        // as per 121.6.5 p669 of the blueprint 1.0 specification
1: 	        Target t = serviceMetadata.getServiceComponent();
1: 	        String targetId = null;
1: 	        if (t instanceof RefMetadata) { 
1: 	          targetId = ((RefMetadata)t).getComponentId();
1: 	        } else if (t instanceof BeanMetadata) { 
1: 	          targetId = ((BeanMetadata)t).getId();
1: 	        }
1: 	        
1: 	        // Our OBR code MUST have access to targetId if it's available (i.e. not null 
1: 	        // or auto-generated for an anonymous service. This must ALWAYS be set. 
1: 	        if (targetId != null && !targetId.startsWith(".")) { // Don't set this for anonymous inner components
1: 	            serviceProps.put("osgi.service.blueprint.compname", targetId);
1: 	          if (serviceName == null || serviceName.equals("") || serviceName.startsWith(".")) { 
1: 	            serviceName = targetId;
1: 	          }
1: 	        }
1: 	        
1: 	        if(serviceName != null && serviceName.startsWith("."))
1: 	          serviceName = null;
1: 	        
1: 	        // If suppressAnonymous services, do not expose services that have no name
1: 	        if (!suppressAnonymousServices || (serviceName != null)) { 
1: 	          ExportedService wsm = _modellingManager.getExportedService(serviceName, ranking, interfaces, serviceProps);
1: 	          result.add(wsm);
1: 	        }
1: 	      }
1: 	    }
1: 	    _logger.debug(LOG_EXIT, "parseAllServiceElements", new Object[]{result});
1: 	    return result; 
1: 	  }	  
1: 	  
1: 	  /**
1: 	   * Extract References metadata from a ComponentDefinitionRegistry. 
1: 	   * @param cdr                       ComponentDefinitionRegistry
1: 	   * @return List<WrappedReferenceMetadata>
1: 	   * @throws InvalidAttributeException 
1: 	   */
1: 	  private List<ImportedService> parseCDRForReferences (ComponentDefinitionRegistry cdr) throws InvalidAttributeException { 
1: 	    _logger.debug(LOG_ENTRY, "parseCDRForReferences", new Object[]{cdr});
1: 	    List<ImportedService> result = new ArrayList<ImportedService>();
0: 	    Set<String> names = cdr.getComponentDefinitionNames();
0: 	    for (String name: names) { 
0: 	      ComponentMetadata compMetadata = cdr.getComponentDefinition(name);
1: 	      if (compMetadata instanceof ServiceReferenceMetadata) { 
1: 	        ServiceReferenceMetadata referenceMetadata = (ServiceReferenceMetadata)compMetadata;
1: 
1: 	        boolean optional = referenceMetadata.getAvailability() == ServiceReferenceMetadata.AVAILABILITY_OPTIONAL;
1: 	        String iface = referenceMetadata.getInterface();
1: 	        String compName = referenceMetadata.getComponentName();
1: 	        String blueprintFilter = referenceMetadata.getFilter();
1: 	        String id = referenceMetadata.getId();
1: 	        boolean isMultiple = (referenceMetadata instanceof ReferenceListMetadata);
1: 	        
1: 	        //The blueprint parser teams up with JPA and blueprint resource ref
1: 	        // namespace handlers to give us service imports of the form, 
1: 	        // objectClass=javax.persistence.EntityManagerFactory, org.apache.aries.jpa.proxy.factory=*, osgi.unit.name=blabber
1: 	        //
1: 	        // There will be no matching service for this reference. 
1: 	        // For now we blacklist certain objectClasses and filters - this is a pretty dreadful thing to do. 
1: 	        if (!isBlacklisted (iface, blueprintFilter)) { 
1: 	          ImportedService ref = _modellingManager.getImportedService (optional, iface, compName, blueprintFilter, 
1: 	              id, isMultiple);
1: 	          result.add (ref);  
1: 	        }
1: 	      }
1: 	    }
1: 	    _logger.debug(LOG_EXIT, "parseCDRForReferences", new Object[]{result});
1: 	    return result; 
1: 	  }
1: 	
1: 	  /**
1: 	   * Some services are injected directly into isolated frameworks by default. We do 
1: 	   * not need to model these services. They are not represented as ExportedServices 
1: 	   * (Capabilities) in the various OBR registries, and so cannot be resolved against. 
1: 	   * Since they are injected directly into each isolated framework, we do not need
1: 	   * an entry in DEPLOYMENT.MF's Deployed-ImportService header for any of these 
1: 	   * services. 
1: 	   * 
1: 	   * @param iface           The interface declared on a blueprint reference
1: 	   * @param blueprintFilter The filter on the blueprint reference
1: 	   * @return                True if the service is not 'blacklisted' and so may be exposed
1: 	   *                        in the model being generated. 
1: 	   */
1: 	  protected boolean isBlacklisted (String iface, String blueprintFilter) { 
1: 	    _logger.debug(LOG_ENTRY, "isBlacklisted", new Object[]{iface, blueprintFilter});
1: 	    boolean blacklisted = false;
1: 	    if (iface != null) {
1: 	      // JPA - detect interface;
1: 	      blacklisted |= iface.equals("javax.persistence.EntityManagerFactory");
1: 	      blacklisted |= iface.equals("javax.persistence.EntityManager");
1: 	    
1: 	      // JTA - detect interface
1: 	      blacklisted |= iface.equals("javax.transaction.UserTransaction");
1: 	      blacklisted |= iface.equals("javax.transaction.TransactionSynchronizationRegistry");
1: 	      
1: 	      // Don't provision against JNDI references
0: 	      if (blueprintFilter != null && !blueprintFilter.trim().isEmpty()) { 
1: 	        Map<String, String> filter = ManifestHeaderProcessor.parseFilter(blueprintFilter);
1: 	        blacklisted |= filter.containsKey(JNDIConstants.JNDI_SERVICENAME);
1: 	      }
1: 	    }
1: 	    _logger.debug(LOG_EXIT, "isBlacklisted", new Object[]{!blacklisted});
1: 	    return blacklisted;
1: 	  }
1: }
============================================================================