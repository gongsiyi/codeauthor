1:f13c6ac: /**
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.utils;
1:f13c6ac: 
1:753fec1: import java.lang.ref.WeakReference;
1:f13c6ac: import java.lang.reflect.Constructor;
1:d08aba3: import java.lang.reflect.Field;
1:f13c6ac: import java.lang.reflect.InvocationTargetException;
1:f13c6ac: import java.lang.reflect.Method;
1:f13c6ac: import java.lang.reflect.Modifier;
1:c04a99b: import java.lang.reflect.ParameterizedType;
1:f13c6ac: import java.lang.reflect.Type;
1:c04a99b: import java.lang.reflect.TypeVariable;
1:f13c6ac: import java.security.AccessControlContext;
1:f13c6ac: import java.security.AccessController;
1:f13c6ac: import java.security.PrivilegedActionException;
1:f13c6ac: import java.security.PrivilegedExceptionAction;
1:f13c6ac: import java.util.ArrayList;
1:d08aba3: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:d08aba3: import java.util.HashMap;
1:cab8bfe: import java.util.HashSet;
1:d08aba3: import java.util.Iterator;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Map;
1:f13c6ac: import java.util.Set;
1:f13c6ac: import java.util.WeakHashMap;
1:f13c6ac: 
1:cab8bfe: import org.apache.aries.blueprint.container.GenericType;
1:cab8bfe: import org.apache.aries.blueprint.di.ExecutionContext;
1:c9e6b82: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:08c11fc: import org.osgi.framework.BundleReference;
1:cab8bfe: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:cab8bfe: 
1:f13c6ac: /**
1:f13c6ac:  * TODO: javadoc
1:f13c6ac:  *
1:f13c6ac:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public class ReflectionUtils {
1:f13c6ac: 
1:4d5683c:     private static Map<Class<?>, WeakReference<Method[]>> publicMethods = Collections.synchronizedMap(new WeakHashMap<Class<?>, WeakReference<Method[]>>());
1:d08aba3:     private static Map<Class<?>, PropertyDescriptor[][]> beanInfos = Collections.synchronizedMap(new WeakHashMap<Class<?>, PropertyDescriptor[][]>());
1:f13c6ac: 
1:f13c6ac:     public static boolean hasDefaultConstructor(Class type) {
1:f13c6ac:         if (!Modifier.isPublic(type.getModifiers())) {
1:f13c6ac:             return false;
1:f13c6ac:         }
1:f13c6ac:         if (Modifier.isAbstract(type.getModifiers())) {
1:f13c6ac:             return false;
1:f13c6ac:         }
1:f13c6ac:         Constructor[] constructors = type.getConstructors();
1:f13c6ac:         for (Constructor constructor : constructors) {
1:f13c6ac:             if (Modifier.isPublic(constructor.getModifiers()) &&
1:f13c6ac:                     constructor.getParameterTypes().length == 0) {
1:f13c6ac:                 return true;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return false;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public static Set<String> getImplementedInterfaces(Set<String> classes, Class clazz) {
1:f13c6ac:         if (clazz != null && clazz != Object.class) {
1:f13c6ac:             for (Class itf : clazz.getInterfaces()) {
1:f13c6ac:                 if (Modifier.isPublic(itf.getModifiers())) {
1:f13c6ac:                     classes.add(itf.getName());
1:f13c6ac:                 }
1:f13c6ac:                 getImplementedInterfaces(classes, itf);
1:f13c6ac:             }
1:f13c6ac:             getImplementedInterfaces(classes, clazz.getSuperclass());
1:f13c6ac:         }
1:f13c6ac:         return classes;
1:f13c6ac:     }
1:f13c6ac:     
1:6726c3e:     public static Set<Class<?>> getImplementedInterfacesAsClasses(Set<Class<?>> classes, Class<?> clazz) {
1:6726c3e:         if (clazz != null && clazz != Object.class) {
1:6726c3e:             for (Class<?> itf : clazz.getInterfaces()) {
1:6726c3e:                 if (Modifier.isPublic(itf.getModifiers())) {
1:6726c3e:                     classes.add(itf);
1:f13c6ac:                 }
1:6726c3e:                 getImplementedInterfacesAsClasses(classes, itf);
1:f13c6ac:             }
1:6726c3e:             getImplementedInterfacesAsClasses(classes, clazz.getSuperclass());
1:f13c6ac:         }
1:6726c3e:         return classes;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static Set<String> getSuperClasses(Set<String> classes, Class clazz) {
1:f13c6ac:         if (clazz != null && clazz != Object.class) {
1:f13c6ac:             if (Modifier.isPublic(clazz.getModifiers())) {
1:f13c6ac:                 classes.add(clazz.getName());
1:f13c6ac:             }
1:f13c6ac:             getSuperClasses(classes, clazz.getSuperclass());
1:f13c6ac:         }
1:f13c6ac:         return classes;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static Method getLifecycleMethod(Class clazz, String name) {
1:f13c6ac:         if (name != null) {
1:c9e6b82:             for (Method method : getPublicMethods(clazz)) {
1:c9e6b82:                 if (method.getName().equals(name)
1:c9e6b82:                         && method.getParameterTypes().length == 0
1:c9e6b82:                         && Void.TYPE.equals(method.getReturnType())) {
1:f13c6ac:                     return method;
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return null;
1:f13c6ac:     }
1:c9e6b82: 
1:4d5683c:     public static Method[] getPublicMethods(Class clazz) {
1:4d5683c:         WeakReference<Method[]> ref = publicMethods.get(clazz);
1:4d5683c:         Method[] methods = ref != null ? ref.get() : null;
1:4d5683c:         if (methods == null) {
1:4d5683c:             ArrayList<Method> array = new ArrayList<Method>();
1:4d5683c:             doGetPublicMethods(clazz, array);
1:4d5683c:             methods = array.toArray(new Method[array.size()]);
1:4d5683c:             publicMethods.put(clazz, new WeakReference<Method[]>(methods));
1:4d5683c:         }
1:c9e6b82:         return methods;
1:c9e6b82:     }
1:c9e6b82: 
1:c9e6b82:     private static void doGetPublicMethods(Class clazz, ArrayList<Method> methods) {
1:c9e6b82:         Class parent = clazz.getSuperclass();
1:c9e6b82:         if (parent != null) {
1:c9e6b82:             doGetPublicMethods(parent, methods);
1:c9e6b82:         }
1:c9e6b82:         for (Class interf : clazz.getInterfaces()) {
1:c9e6b82:             doGetPublicMethods(interf, methods);
1:c9e6b82:         }
1:c9e6b82:         if (Modifier.isPublic(clazz.getModifiers())) {
1:c9e6b82:             for (Method mth : clazz.getMethods()) {
1:c9e6b82:                 removeByNameAndSignature(methods, mth);
1:c9e6b82:                 methods.add(mth);
1:c9e6b82:             }
1:c9e6b82:         }
1:c9e6b82:     }
1:c9e6b82: 
1:c9e6b82:     private static void removeByNameAndSignature(ArrayList<Method> methods, Method toRemove) {
1:c9e6b82:         for (int i = 0; i < methods.size(); i++) {
1:c9e6b82:             Method m = methods.get(i);
1:c9e6b82:             if (m != null &&
1:c9e6b82:                     m.getReturnType() == toRemove.getReturnType() &&
1:c9e6b82:                     m.getName() == toRemove.getName() &&
1:c9e6b82:                     arrayContentsEq(m.getParameterTypes(),
1:c9e6b82:                             toRemove.getParameterTypes())) {
1:c9e6b82:                 methods.remove(i--);
1:c9e6b82:             }
1:c9e6b82:         }
1:c9e6b82:     }
1:c9e6b82: 
1:c9e6b82:     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
1:c9e6b82:         if (a1 == null) {
1:c9e6b82:             return a2 == null || a2.length == 0;
1:c9e6b82:         }
1:c9e6b82:         if (a2 == null) {
1:c9e6b82:             return a1.length == 0;
1:c9e6b82:         }
1:c9e6b82:         if (a1.length != a2.length) {
1:c9e6b82:             return false;
1:c9e6b82:         }
1:c9e6b82:         for (int i = 0; i < a1.length; i++) {
1:c9e6b82:             if (a1[i] != a2[i]) {
1:c9e6b82:                 return false;
1:c9e6b82:             }
1:c9e6b82:         }
1:c9e6b82:         return true;
1:c9e6b82:     }
1:c9e6b82: 
1:f13c6ac:     public static List<Method> findCompatibleMethods(Class clazz, String name, Class[] paramTypes) {
1:f13c6ac:         List<Method> methods = new ArrayList<Method>();
1:c9e6b82:         for (Method method : getPublicMethods(clazz)) {
1:f13c6ac:             Class[] methodParams = method.getParameterTypes();
1:7c549ab:             if (name.equals(method.getName()) && Void.TYPE.equals(method.getReturnType()) && methodParams.length == paramTypes.length && !method.isBridge()) {
1:f13c6ac:                 boolean assignable = true;
1:f13c6ac:                 for (int i = 0; i < paramTypes.length && assignable; i++) {
1:f13c6ac:                     assignable &= paramTypes[i] == null || methodParams[i].isAssignableFrom(paramTypes[i]);
1:f13c6ac:                 }
1:f13c6ac:                 if (assignable) {
1:f13c6ac:                     methods.add(method);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return methods;
1:f13c6ac:     }
1:f13c6ac: 
1:d08aba3:     public static PropertyDescriptor[] getPropertyDescriptors(Class clazz, boolean allowFieldInjection) {
1:d08aba3:         PropertyDescriptor[][] properties = beanInfos.get(clazz);
1:d08aba3:         int index = allowFieldInjection ? 0 : 1;
1:cab8bfe:         
1:f13c6ac:         if (properties == null) {
1:d08aba3:             properties = new PropertyDescriptor[2][];
1:f13c6ac:             beanInfos.put(clazz, properties);
1:f13c6ac:         }
1:d08aba3:         
1:d08aba3:         if (properties[index] == null) {
1:cab8bfe:             Set<String> propertyNames = new HashSet<String>();
1:cab8bfe:             Map<String,Method> getters = new HashMap<String, Method>();
1:cab8bfe:             Map<String,List<Method>> setters = new HashMap<String, List<Method>>();
1:cab8bfe:             Set<String> illegalProperties = new HashSet<String>();
1:cab8bfe:             
1:c9e6b82:             for (Method method : getPublicMethods(clazz)) {
1:cab8bfe:                 if (Modifier.isStatic(method.getModifiers()) || method.isBridge()) continue;
1:cab8bfe:                 
1:f13c6ac:                 String name = method.getName();
1:d08aba3:                 Class<?> argTypes[] = method.getParameterTypes();
1:d08aba3:                 Class<?> resultType = method.getReturnType();
1:d08aba3:                 
1:f13c6ac:                 if (name.length() > 3 && name.startsWith("set") && resultType == Void.TYPE && argTypes.length == 1) {
1:d08aba3:                     name = decapitalize(name.substring(3));
1:cab8bfe:                     if (!!!setters.containsKey(name)) setters.put(name, new ArrayList<Method>());
1:cab8bfe:                     setters.get(name).add(method);
1:cab8bfe:                     propertyNames.add(name);
1:cab8bfe:                 } else if (name.length() > 3 && name.startsWith("get") && resultType != Void.TYPE && argTypes.length == 0) {
1:d08aba3:                     name = decapitalize(name.substring(3));
1:f13c6ac: 
1:cab8bfe:                     if (getters.containsKey(name)) illegalProperties.add(name);
1:cab8bfe:                     else propertyNames.add(name);
1:cab8bfe:                     
1:cab8bfe:                     getters.put(name, method);                    
1:f13c6ac:                 } else if (name.length() > 2 && name.startsWith("is") && argTypes.length == 0 && resultType == boolean.class) {
1:d08aba3:                     name = decapitalize(name.substring(2));
1:cab8bfe: 
1:cab8bfe:                     if (getters.containsKey(name)) illegalProperties.add(name);
1:cab8bfe:                     else propertyNames.add(name);
1:cab8bfe:                     
1:cab8bfe:                     getters.put(name, method);                    
1:f13c6ac:                 }
1:cab8bfe:                 
1:f13c6ac:             }
1:cab8bfe: 
1:cab8bfe:             Map<String, PropertyDescriptor> props = new HashMap<String, PropertyDescriptor>();
1:cab8bfe:             for (String propName : propertyNames) {
1:cab8bfe:                 props.put(propName,
1:cab8bfe:                         new MethodPropertyDescriptor(propName, getters.get(propName), setters.get(propName)));
1:f13c6ac:             }            
1:d08aba3:             
1:d08aba3:             if (allowFieldInjection) {
1:62ba6d5:                 for (Class cl = clazz; cl != null && cl != Object.class; cl = cl.getSuperclass()) {
1:62ba6d5:                     for (Field field : cl.getDeclaredFields()) {
1:62ba6d5:                         if (!!!Modifier.isStatic(field.getModifiers())) {
1:62ba6d5:                             String name = decapitalize(field.getName());
1:62ba6d5:                             PropertyDescriptor desc = props.get(name);
1:62ba6d5:                             if (desc == null) {
1:62ba6d5:                                 props.put(name, new FieldPropertyDescriptor(name, field));
1:62ba6d5:                             } else if (desc instanceof MethodPropertyDescriptor) {
1:62ba6d5:                                 props.put(name,
1:62ba6d5:                                         new JointPropertyDescriptor((MethodPropertyDescriptor) desc,
1:62ba6d5:                                                 new FieldPropertyDescriptor(name, field)));
1:62ba6d5:                             } else {
1:62ba6d5:                                 illegalProperties.add(name);
1:62ba6d5:                             }
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             
1:cab8bfe:             List<PropertyDescriptor> result = new ArrayList<PropertyDescriptor>();
1:cab8bfe:             for (PropertyDescriptor prop : props.values()) {
1:cab8bfe:                 if (!!!illegalProperties.contains(prop.getName())) result.add(prop);
1:f13c6ac:             }
1:753fec1:             
1:cab8bfe:             properties[index] = result.toArray(new PropertyDescriptor[result.size()]); 
1:f13c6ac:         }
1:d08aba3:         return properties[index];
1:f13c6ac:     }
1:d08aba3: 
1:f13c6ac:     private static String decapitalize(String name) {
1:f13c6ac:         if (name == null || name.length() == 0) {
1:f13c6ac:             return name;
1:f13c6ac:         }
1:f13c6ac:         if (name.length() > 1 && Character.isUpperCase(name.charAt(1)) &&
1:f13c6ac:                 Character.isUpperCase(name.charAt(0))) {
1:f13c6ac:             return name;
1:f13c6ac:         }
1:f13c6ac:         char chars[] = name.toCharArray();
1:f13c6ac:         chars[0] = Character.toLowerCase(chars[0]);
1:f13c6ac:         return new String(chars);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static Object invoke(AccessControlContext acc, final Method method, final Object instance, final Object... args) throws Exception {
1:f13c6ac:         if (acc == null) {
1:f13c6ac:             return method.invoke(instance, args);
1:f13c6ac:         } else {
1:f13c6ac:             try {
1:f13c6ac:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:f13c6ac:                     public Object run() throws Exception {
1:f13c6ac:                         return method.invoke(instance, args);
1:f13c6ac:                     }            
1:f13c6ac:                 }, acc);
1:f13c6ac:             } catch (PrivilegedActionException e) {
1:f13c6ac:                 throw e.getException();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public static Object newInstance(AccessControlContext acc, final Class clazz) throws Exception {
1:f13c6ac:         if (acc == null) {
1:f13c6ac:             return clazz.newInstance();
1:f13c6ac:         } else {
1:f13c6ac:             try {
1:f13c6ac:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:f13c6ac:                     public Object run() throws Exception {
1:f13c6ac:                         return clazz.newInstance();
1:f13c6ac:                     }            
1:f13c6ac:                 }, acc);
1:f13c6ac:             } catch (PrivilegedActionException e) {
1:f13c6ac:                 throw e.getException();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public static Object newInstance(AccessControlContext acc, final Constructor constructor, final Object... args) throws Exception {
1:f13c6ac:         if (acc == null) {
1:f13c6ac:             return constructor.newInstance(args);
1:f13c6ac:         } else {
1:f13c6ac:             try {
1:f13c6ac:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:f13c6ac:                     public Object run() throws Exception {
1:f13c6ac:                         return constructor.newInstance(args);
1:f13c6ac:                     }            
1:f13c6ac:                 }, acc);
1:f13c6ac:             } catch (PrivilegedActionException e) {
1:f13c6ac:                 throw e.getException();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:cab8bfe:     public static abstract class PropertyDescriptor {
1:cab8bfe:         private final String name;
1:f13c6ac:         
1:cab8bfe:         public PropertyDescriptor(String name) {
1:f13c6ac:             this.name = name;
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         public String getName() {
1:f13c6ac:             return name;
1:f13c6ac:         }
1:f13c6ac:         
1:cab8bfe:         public abstract boolean allowsGet();
1:cab8bfe:         public abstract boolean allowsSet();
1:f13c6ac:         
1:08c11fc:         protected abstract Object internalGet(ExtendedBlueprintContainer container, Object instance) throws Exception;
1:08c11fc:         protected abstract void internalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception;        
1:f13c6ac:         
1:08c11fc:         public Object get(final Object instance, final ExtendedBlueprintContainer container) throws Exception {            
1:08c11fc:             if (container.getAccessControlContext() == null) {
1:08c11fc:                 return internalGet(container, instance);
1:f13c6ac:             } else {
1:f13c6ac:                 try {
1:08c11fc:                     return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:08c11fc:                         public Object run() throws Exception {
1:08c11fc:                             return internalGet(container, instance);
1:f13c6ac:                         }            
1:08c11fc:                     }, container.getAccessControlContext());
1:d08aba3:                 } catch (PrivilegedActionException e) {
1:d08aba3:                     throw e.getException();
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:d08aba3: 
1:08c11fc:         public void set(final Object instance, final Object value, final ExtendedBlueprintContainer container) throws Exception {
1:08c11fc:             if (container.getAccessControlContext() == null) {
1:08c11fc:                 internalSet(container, instance, value);
1:08c11fc:             } else {
1:08c11fc:                 try {
1:08c11fc:                     AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
2:d08aba3:                         public Object run() throws Exception {
1:08c11fc:                             internalSet(container, instance, value);
1:08c11fc:                             return null;
1:f13c6ac:                         }            
1:08c11fc:                     }, container.getAccessControlContext());
1:d08aba3:                 } catch (PrivilegedActionException e) {
1:d08aba3:                     throw e.getException();
1:f13c6ac:                 }
1:08c11fc:             }            
1:cab8bfe:         }
1:d08aba3:         
1:cab8bfe:         protected Object convert(Object obj, Type type) throws Exception {
1:cab8bfe:             return ExecutionContext.Holder.getContext().convert(obj, new GenericType(type));
1:cab8bfe:         }
1:cab8bfe:     }
1:cab8bfe:     
1:cab8bfe:     private static class JointPropertyDescriptor extends PropertyDescriptor {
1:cab8bfe:         private final MethodPropertyDescriptor mpd;
1:cab8bfe:         private final FieldPropertyDescriptor fpd;
1:cab8bfe:         
1:cab8bfe:         public JointPropertyDescriptor(MethodPropertyDescriptor mpd, FieldPropertyDescriptor fpd) {
1:cab8bfe:             super(mpd.getName());
1:cab8bfe:             this.mpd = mpd;
1:cab8bfe:             this.fpd = fpd;
1:cab8bfe:         }
1:cab8bfe: 
1:cab8bfe:         @Override
1:cab8bfe:         public boolean allowsGet() {
1:cab8bfe:             return mpd.allowsGet() || fpd.allowsGet();
1:cab8bfe:         }
1:cab8bfe: 
1:cab8bfe:         @Override
1:cab8bfe:         public boolean allowsSet() {
1:cab8bfe:             return mpd.allowsSet() || fpd.allowsSet();
1:cab8bfe:         }
1:753fec1: 
1:cab8bfe:         @Override
1:08c11fc:         protected Object internalGet(ExtendedBlueprintContainer container, Object instance) throws Exception {
1:08c11fc:             if (mpd.allowsGet()) return mpd.internalGet(container, instance);
1:08c11fc:             else if (fpd.allowsGet()) return fpd.internalGet(container, instance);
1:cab8bfe:             else throw new UnsupportedOperationException();
1:cab8bfe:         }
1:cab8bfe: 
1:cab8bfe:         @Override
1:08c11fc:         protected void internalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception {
1:08c11fc:             if (mpd.allowsSet()) mpd.internalSet(container, instance, value);
1:08c11fc:             else if (fpd.allowsSet()) fpd.internalSet(container, instance, value);
1:cab8bfe:             else throw new UnsupportedOperationException();
1:cab8bfe:         }
1:cab8bfe:     }
1:cab8bfe:     
1:cab8bfe:     private static class FieldPropertyDescriptor extends PropertyDescriptor {
1:753fec1:         // instead of holding on to the java.lang.reflect.Field objects we retrieve it every time. The reason is that PropertyDescriptors are 
1:753fec1:         // used as values in a WeakHashMap with the class corresponding to the field as the key
1:753fec1:         private final String fieldName;
1:753fec1:         private final WeakReference<Class<?>> declaringClass;
1:cab8bfe:         
1:cab8bfe:         public FieldPropertyDescriptor(String name, Field field) {
1:cab8bfe:             super(name);
1:753fec1:             this.fieldName = field.getName();
1:753fec1:             this.declaringClass = new WeakReference(field.getDeclaringClass());
1:cab8bfe:         }
1:cab8bfe: 
1:cab8bfe:         public boolean allowsGet() {
1:cab8bfe:             return true;
1:cab8bfe:         }
1:cab8bfe: 
1:cab8bfe:         public boolean allowsSet() {
1:cab8bfe:             return true;
1:cab8bfe:         }
1:cab8bfe:         
1:753fec1:         private Field getField(ExtendedBlueprintContainer container) throws ClassNotFoundException, NoSuchFieldException {
1:753fec1:             if (declaringClass.get() == null) throw new ClassNotFoundException("Declaring class was garbage collected");
1:753fec1:             
1:753fec1:             return declaringClass.get().getDeclaredField(fieldName);
1:753fec1:         }
1:cab8bfe: 
1:753fec1:         protected Object internalGet(final ExtendedBlueprintContainer container, final Object instance) throws Exception {
1:08c11fc:             if (useContainersPermission(container)) {
2:d08aba3:                 try {
1:d08aba3:                     return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:08c11fc:                         public Object run() throws Exception {
1:753fec1:                             return doInternalGet(container, instance);
1:d08aba3:                         }                        
2:08c11fc:                     });
1:08c11fc:                 } catch (PrivilegedActionException pae) {
1:08c11fc:                     Exception e = pae.getException();
1:08c11fc:                     if (e instanceof IllegalAccessException) throw (IllegalAccessException) e;
1:08c11fc:                     else throw (RuntimeException) e;
1:753fec1:                 }
1:08c11fc:             } else {
1:753fec1:                 return doInternalGet(container, instance);
1:753fec1:             }
1:08c11fc:         }
1:cab8bfe:         
1:753fec1:         private Object doInternalGet(ExtendedBlueprintContainer container, Object instance) throws Exception {
1:753fec1:             Field field = getField(container);
1:753fec1:             boolean isAccessible = field.isAccessible();
1:753fec1:             field.setAccessible(true);
1:753fec1:             try {
2:08c11fc:                 return field.get(instance);
1:753fec1:             } finally {
1:753fec1:                 field.setAccessible(isAccessible);
1:08c11fc:             }
1:08c11fc:         }
1:cab8bfe: 
1:753fec1:         protected void internalSet(final ExtendedBlueprintContainer container, final Object instance, final Object value) throws Exception {
1:08c11fc:             try {
1:fde5fef:                 Boolean wasSet = AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {
1:fde5fef:                     public Boolean run() throws Exception {
1:08c11fc:                       if (useContainersPermission(container)) {
1:753fec1:                         doInternalSet(container, instance, value);
1:fde5fef:                         return Boolean.TRUE;
1:08c11fc:                       }
1:fde5fef:                       return Boolean.FALSE;
1:cab8bfe:                     }                        
1:08c11fc:                 });
1:fde5fef:                 if(!!!wasSet) {
1:753fec1:                   doInternalSet(container, instance, value);
1:cab8bfe:                 }
1:08c11fc:             } catch (PrivilegedActionException pae) {
1:08c11fc:                 throw pae.getException();
1:753fec1:             }
1:753fec1:         }
1:753fec1:         
1:753fec1:         private void doInternalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception {
1:753fec1:             Field field = getField(container);
1:753fec1:             final Object convertedValue = convert(value, field.getGenericType());
1:753fec1:             boolean isAccessible = field.isAccessible();
1:753fec1:             field.setAccessible(true);
1:753fec1:             try {
2:08c11fc:                 field.set(instance, convertedValue);
1:753fec1:             } finally {
1:753fec1:                 field.setAccessible(isAccessible);
1:08c11fc:             }
1:08c11fc:         }
1:08c11fc:         
1:08c11fc:         /**
1:08c11fc:          * Determine whether the field access (in particular the call to {@link Field#setAccessible(boolean)} should be done with the Blueprint extender's
1:08c11fc:          * permissions, rather than the joint (more restrictive) permissions of the extender plus the Blueprint bundle.
1:08c11fc:          * 
1:08c11fc:          * We currently only allow this for classes that originate from inside the Blueprint bundle. Otherwise this would open a potential security hole.
1:08c11fc:          * @param container
1:08c11fc:          * @return
1:08c11fc:          */
1:753fec1:         private boolean useContainersPermission(ExtendedBlueprintContainer container) throws ClassNotFoundException {
1:753fec1:             if (declaringClass.get() == null) throw new ClassNotFoundException("Declaring class was garbage collected");
1:753fec1:             ClassLoader loader = declaringClass.get().getClassLoader();
1:08c11fc:             
1:08c11fc:             if (loader == null) return false;
1:08c11fc:             
1:08c11fc:             if (loader instanceof BundleReference) {
1:08c11fc:                 BundleReference ref = (BundleReference) loader;
1:08c11fc:                 return ref.getBundle().equals(container.getBundleContext().getBundle());                
1:08c11fc:             }
1:08c11fc:             
1:08c11fc:             return false;
1:08c11fc:         }
1:cab8bfe:     }
1:cab8bfe:     
1:753fec1:     private static class MethodDescriptor {
1:753fec1:         private final String methodName;
1:753fec1:         private final WeakReference<Class<?>> declaringClass;
1:753fec1:         private final List<WeakReference<Class<?>>> argClasses;
1:753fec1:         
1:753fec1:         public MethodDescriptor(Method method) {
1:753fec1:             methodName = method.getName();
1:753fec1:             declaringClass = new WeakReference<Class<?>>(method.getDeclaringClass());
1:753fec1:             
1:753fec1:             List<WeakReference<Class<?>>> accumulator = new ArrayList<WeakReference<Class<?>>>();
1:753fec1:             for (Class<?> c : method.getParameterTypes()) {
1:753fec1:                 accumulator.add(new WeakReference<Class<?>>(c));
1:753fec1:             }
1:753fec1:             argClasses = Collections.unmodifiableList(accumulator);
1:753fec1:         }
1:753fec1:         
1:753fec1:         public Method getMethod(ExtendedBlueprintContainer container) throws ClassNotFoundException, NoSuchMethodException {
1:753fec1:             Class<?>[] argumentClasses = new Class<?>[argClasses.size()];
1:753fec1:             for (int i=0; i<argClasses.size(); i++) {
1:753fec1:                 argumentClasses[i] = argClasses.get(i).get();
1:753fec1:                 if (argumentClasses[i] == null) throw new ClassNotFoundException("Argument class was garbage collected");
1:753fec1:             }
1:753fec1:             
1:753fec1:             if (declaringClass.get() == null) throw new ClassNotFoundException("Declaring class was garbage collected");
1:753fec1:             
1:753fec1:             return declaringClass.get().getMethod(methodName, argumentClasses);
1:753fec1:         }
1:753fec1:         
1:753fec1:         public String toString() {
1:753fec1:             StringBuilder builder = new StringBuilder();
1:753fec1:             builder.append(declaringClass.get()).append(".").append(methodName).append("(");
1:753fec1:             
1:753fec1:             boolean first = true;
1:753fec1:             for (WeakReference<Class<?>> wcl : argClasses) {
1:753fec1:                 if (!!!first) builder.append(",");
1:753fec1:                 else first = false;
1:753fec1:                 
1:753fec1:                 builder.append(wcl.get());
1:753fec1:             }
1:c9e6b82: 
1:c9e6b82:             builder.append(")");
1:753fec1:             return builder.toString();
1:753fec1:         }
1:753fec1:     }
1:753fec1:     
1:cab8bfe:     private static class MethodPropertyDescriptor extends PropertyDescriptor {
1:753fec1:         // instead of holding on to the java.lang.reflect.Method objects we retrieve it every time. The reason is that PropertyDescriptors are 
1:753fec1:         // used as values in a WeakHashMap with the class corresponding to the methods as the key
1:753fec1:         private final MethodDescriptor getter;
1:753fec1:         private final Collection<MethodDescriptor> setters;
1:753fec1: 
1:cab8bfe:         private MethodPropertyDescriptor(String name, Method getter, Collection<Method> setters) {
1:cab8bfe:             super(name);
1:753fec1:             this.getter = (getter != null) ? new MethodDescriptor(getter) : null;
1:753fec1:             
1:753fec1:             if (setters != null) {
1:753fec1:                 Collection<MethodDescriptor> accumulator = new ArrayList<MethodDescriptor>();
1:753fec1:                 for (Method s : setters) accumulator.add(new MethodDescriptor(s));
1:753fec1:                 this.setters = Collections.unmodifiableCollection(accumulator);
1:753fec1:             } else {
1:753fec1:                 this.setters = Collections.emptyList();
1:753fec1:             }
1:cab8bfe:         }
1:cab8bfe:         
1:cab8bfe:         public boolean allowsGet() {
1:cab8bfe:             return getter != null;
1:cab8bfe:         }
1:cab8bfe:         
1:cab8bfe:         public boolean allowsSet() {
1:cab8bfe:             return !!!setters.isEmpty();
1:cab8bfe:         }
1:cab8bfe:         
1:08c11fc:         protected Object internalGet(ExtendedBlueprintContainer container, Object instance) 
1:753fec1:                 throws Exception {
1:cab8bfe:             if (getter != null) {
1:753fec1:                 return getter.getMethod(container).invoke(instance);
1:cab8bfe:             } else {
2:d08aba3:                 throw new UnsupportedOperationException();
1:d08aba3:             }
1:d08aba3:         }
1:cab8bfe:         
1:08c11fc:         protected void internalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception {
1:cab8bfe:             
1:753fec1:             Method setterMethod = findSetter(container, value);
1:d08aba3: 
1:cab8bfe:             if (setterMethod != null) {
1:c04a99b:                 setterMethod.invoke(instance, convert(value, resolveParameterType(instance.getClass(), setterMethod)));
1:cab8bfe:             } else {
1:cab8bfe:                 throw new ComponentDefinitionException(
1:cab8bfe:                         "No converter available to convert value "+value+" into a form applicable for the " + 
1:cab8bfe:                         "setters of property "+getName());
1:cab8bfe:             }
1:cab8bfe:         }
1:c04a99b: 
1:c04a99b:         private Type resolveParameterType(Class<?> impl, Method setterMethod) {
1:c04a99b:             Type type = setterMethod.getGenericParameterTypes()[0];
1:c04a99b:             Class<?> declaringClass = setterMethod.getDeclaringClass();
1:c04a99b:             TypeVariable<?>[] declaredVariables = declaringClass.getTypeParameters();
1:c04a99b: 
1:c04a99b:             if (TypeVariable.class.isInstance(type)) {
1:c04a99b:                 // e.g.: "T extends Serializable"
1:c04a99b:                 TypeVariable variable = TypeVariable.class.cast(type);
1:c04a99b: 
1:c04a99b:                 int index = 0;
1:c04a99b:                 for (; index < declaredVariables.length; index++) {
1:c04a99b:                     // find the class declaration index...
1:c04a99b:                     if (variable == declaredVariables[index]) {
1:c04a99b:                         break;
1:c04a99b:                     }
1:c04a99b:                 }
1:c04a99b: 
1:c04a99b:                 if (index >= declaredVariables.length) {
1:c04a99b:                     // not found - now what...
1:c04a99b:                     return type;
1:c04a99b:                 }
1:c04a99b: 
1:c04a99b:                 // navigate from the implementation type up to the declaring super
1:c04a99b:                 // class to find the real generic type...
1:c04a99b:                 Class<?> c = impl;
1:c04a99b:                 while (c != null && c != declaringClass) {
1:c04a99b:                     Type sup = c.getGenericSuperclass();
1:c04a99b:                     if (sup != null && ParameterizedType.class.isInstance(sup)) {
1:c04a99b:                         ParameterizedType pt = ParameterizedType.class.cast(sup);
1:c04a99b:                         if (declaringClass == pt.getRawType()) {
1:c04a99b:                             Type t = pt.getActualTypeArguments()[index];
1:c04a99b:                             return t;
1:c04a99b:                         }
1:c04a99b:                     }
1:c04a99b:                     c = c.getSuperclass();
1:c04a99b:                 }
1:c04a99b:                 return type;
1:c04a99b:             } else {
1:c04a99b:                 // not a generic type...
1:c04a99b:                 return type;
1:c04a99b:             }
1:c04a99b:         }
1:c04a99b: 
1:753fec1:         private Method findSetter(ExtendedBlueprintContainer container, Object value) throws Exception {
1:cab8bfe:             Class<?> valueType = (value == null) ? null : value.getClass();
1:cab8bfe:             
1:753fec1:             Method getterMethod = (getter != null) ? getter.getMethod(container) : null;
1:753fec1:             Collection<Method> setterMethods = getSetters(container);
1:cab8bfe:             
1:753fec1:             Method result = findMethodByClass(getterMethod, setterMethods, valueType);
1:753fec1:             
1:753fec1:             if (result == null) result = findMethodWithConversion(setterMethods, value);
1:cab8bfe:                         
1:cab8bfe:             return result;
1:cab8bfe:         }
1:cab8bfe:         
1:753fec1:         private Collection<Method> getSetters(ExtendedBlueprintContainer container) throws Exception {
1:753fec1:             Collection<Method> result = new ArrayList<Method>();
1:753fec1:             for (MethodDescriptor md : setters) result.add(md.getMethod(container));
1:753fec1:             
1:753fec1:             return result;
1:753fec1:         }
1:753fec1:         
1:753fec1:         private Method findMethodByClass(Method getterMethod, Collection<Method> setterMethods, Class<?> arg)
1:43c68d1:                 throws ComponentDefinitionException {
1:cab8bfe:             Method result = null;
1:cab8bfe: 
1:753fec1:             if (!hasSameTypeSetter(getterMethod, setterMethods)) {
1:43c68d1:                 throw new ComponentDefinitionException(
1:43c68d1:                         "At least one Setter method has to match the type of the Getter method for property "
1:43c68d1:                                 + getName());
1:d08aba3:             }
1:cab8bfe: 
1:753fec1:             if (setterMethods.size() == 1) {
1:753fec1:                 return setterMethods.iterator().next();
1:d08aba3:             }
1:d08aba3:             
1:753fec1:             for (Method m : setterMethods) {
1:cab8bfe:                 Class<?> paramType = m.getParameterTypes()[0];
8:d08aba3: 
1:cab8bfe:                 if ((arg == null && Object.class.isAssignableFrom(paramType))
1:cab8bfe:                         || (arg != null && paramType.isAssignableFrom(arg))) {
1:cab8bfe: 
1:43c68d1:                     // pick the method that has the more specific parameter if
1:43c68d1:                     // any
1:cab8bfe:                     if (result != null) {
1:cab8bfe:                         Class<?> oldParamType = result.getParameterTypes()[0];
1:cab8bfe:                         if (paramType.isAssignableFrom(oldParamType)) {
1:cab8bfe:                             // do nothing, result is correct
1:cab8bfe:                         } else if (oldParamType.isAssignableFrom(paramType)) {
1:cab8bfe:                             result = m;
1:cab8bfe:                         } else {
1:cab8bfe:                             throw new ComponentDefinitionException(
1:43c68d1:                                     "Ambiguous setter method for property "
1:43c68d1:                                             + getName()
1:43c68d1:                                             + ". More than one method matches the  parameter type "
1:43c68d1:                                             + arg);
1:cab8bfe:                         }
1:cab8bfe:                     } else {
1:cab8bfe:                         result = m;
1:cab8bfe:                     }
1:cab8bfe:                 }
1:cab8bfe:             }
1:cab8bfe: 
1:cab8bfe:             return result;
1:cab8bfe:         }
1:cab8bfe:         
1:43c68d1:         // ensure there is a setter that matches the type of the getter
1:753fec1:         private boolean hasSameTypeSetter(Method getterMethod, Collection<Method> setterMethods) {
1:753fec1:             if (getterMethod == null) {
1:43c68d1:                 return true;
1:d08aba3:             }
1:753fec1: 
1:753fec1:             Iterator<Method> it = setterMethods.iterator();
1:d08aba3:             while (it.hasNext()) {
1:43c68d1:                 Method m = it.next();
1:753fec1:                 if (m.getParameterTypes()[0].equals(getterMethod.getReturnType())) {
1:43c68d1:                     return true;
9:d08aba3:                 }
1:d08aba3:             }
1:43c68d1:             return false;
1:d08aba3:         }
1:d08aba3: 
1:753fec1:         private Method findMethodWithConversion(Collection<Method> setterMethods, Object value) throws Exception {
1:cab8bfe:             ExecutionContext ctx = ExecutionContext.Holder.getContext();
1:cab8bfe:             List<Method> matchingMethods = new ArrayList<Method>();
1:753fec1:             for (Method m : setterMethods) {
1:cab8bfe:                 Type paramType = m.getGenericParameterTypes()[0];
1:cab8bfe:                 if (ctx.canConvert(value, new GenericType(paramType))) matchingMethods.add(m);
1:cab8bfe:             }
1:cab8bfe:             
1:cab8bfe:             if (matchingMethods.isEmpty()) return null;
1:cab8bfe:             else if (matchingMethods.size() == 1) return matchingMethods.get(0);
1:cab8bfe:             else throw new ComponentDefinitionException(
1:cab8bfe:                     "Ambiguous setter method for property "+ getName() + 
1:cab8bfe:                     ". More than one method matches the parameter "+value+" after applying conversion.");
1:d08aba3:         }
1:d08aba3:         
1:d08aba3:         public String toString() {
1:cab8bfe:             return "PropertyDescriptor <name: "+getName()+", getter: "+getter+", setter: "+setters;
1:d08aba3:         }
1:d08aba3:     }
1:d08aba3: 
1:f13c6ac:     public static Throwable getRealCause(Throwable t) {
1:f13c6ac:         if (t instanceof InvocationTargetException && t.getCause() != null) {
1:f13c6ac:             return t.getCause();
1:f13c6ac:         }
1:f13c6ac:         return t;
1:f13c6ac:     }
1:f13c6ac: 
1:d08aba3: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:c04a99b
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.ParameterizedType;
1: import java.lang.reflect.TypeVariable;
/////////////////////////////////////////////////////////////////////////
1:                 setterMethod.invoke(instance, convert(value, resolveParameterType(instance.getClass(), setterMethod)));
1: 
1:         private Type resolveParameterType(Class<?> impl, Method setterMethod) {
1:             Type type = setterMethod.getGenericParameterTypes()[0];
1:             Class<?> declaringClass = setterMethod.getDeclaringClass();
1:             TypeVariable<?>[] declaredVariables = declaringClass.getTypeParameters();
1: 
1:             if (TypeVariable.class.isInstance(type)) {
1:                 // e.g.: "T extends Serializable"
1:                 TypeVariable variable = TypeVariable.class.cast(type);
1: 
1:                 int index = 0;
1:                 for (; index < declaredVariables.length; index++) {
1:                     // find the class declaration index...
1:                     if (variable == declaredVariables[index]) {
1:                         break;
1:                     }
1:                 }
1: 
1:                 if (index >= declaredVariables.length) {
1:                     // not found - now what...
1:                     return type;
1:                 }
1: 
1:                 // navigate from the implementation type up to the declaring super
1:                 // class to find the real generic type...
1:                 Class<?> c = impl;
1:                 while (c != null && c != declaringClass) {
1:                     Type sup = c.getGenericSuperclass();
1:                     if (sup != null && ParameterizedType.class.isInstance(sup)) {
1:                         ParameterizedType pt = ParameterizedType.class.cast(sup);
1:                         if (declaringClass == pt.getRawType()) {
1:                             Type t = pt.getActualTypeArguments()[index];
1:                             return t;
1:                         }
1:                     }
1:                     c = c.getSuperclass();
1:                 }
1:                 return type;
1:             } else {
1:                 // not a generic type...
1:                 return type;
1:             }
1:         }
1: 
commit:4d5683c
/////////////////////////////////////////////////////////////////////////
1:     private static Map<Class<?>, WeakReference<Method[]>> publicMethods = Collections.synchronizedMap(new WeakHashMap<Class<?>, WeakReference<Method[]>>());
/////////////////////////////////////////////////////////////////////////
1:     public static Method[] getPublicMethods(Class clazz) {
1:         WeakReference<Method[]> ref = publicMethods.get(clazz);
1:         Method[] methods = ref != null ? ref.get() : null;
1:         if (methods == null) {
1:             ArrayList<Method> array = new ArrayList<Method>();
1:             doGetPublicMethods(clazz, array);
1:             methods = array.toArray(new Method[array.size()]);
1:             publicMethods.put(clazz, new WeakReference<Method[]>(methods));
1:         }
commit:c9e6b82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
/////////////////////////////////////////////////////////////////////////
1:             for (Method method : getPublicMethods(clazz)) {
1:                 if (method.getName().equals(name)
1:                         && method.getParameterTypes().length == 0
1:                         && Void.TYPE.equals(method.getReturnType())) {
1: 
0:     public static List<Method> getPublicMethods(Class clazz) {
0:         ArrayList<Method> methods = new ArrayList<Method>();
0:         doGetPublicMethods(clazz, methods);
1:         return methods;
1:     }
1: 
1:     private static void doGetPublicMethods(Class clazz, ArrayList<Method> methods) {
1:         Class parent = clazz.getSuperclass();
1:         if (parent != null) {
1:             doGetPublicMethods(parent, methods);
1:         }
1:         for (Class interf : clazz.getInterfaces()) {
1:             doGetPublicMethods(interf, methods);
1:         }
1:         if (Modifier.isPublic(clazz.getModifiers())) {
1:             for (Method mth : clazz.getMethods()) {
1:                 removeByNameAndSignature(methods, mth);
1:                 methods.add(mth);
1:             }
1:         }
1:     }
1: 
1:     private static void removeByNameAndSignature(ArrayList<Method> methods, Method toRemove) {
1:         for (int i = 0; i < methods.size(); i++) {
1:             Method m = methods.get(i);
1:             if (m != null &&
1:                     m.getReturnType() == toRemove.getReturnType() &&
1:                     m.getName() == toRemove.getName() &&
1:                     arrayContentsEq(m.getParameterTypes(),
1:                             toRemove.getParameterTypes())) {
1:                 methods.remove(i--);
1:             }
1:         }
1:     }
1: 
1:     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
1:         if (a1 == null) {
1:             return a2 == null || a2.length == 0;
1:         }
1:         if (a2 == null) {
1:             return a1.length == 0;
1:         }
1:         if (a1.length != a2.length) {
1:             return false;
1:         }
1:         for (int i = 0; i < a1.length; i++) {
1:             if (a1[i] != a2[i]) {
1:                 return false;
1:             }
1:         }
1:         return true;
1:     }
1: 
1:         for (Method method : getPublicMethods(clazz)) {
/////////////////////////////////////////////////////////////////////////
1:             for (Method method : getPublicMethods(clazz)) {
/////////////////////////////////////////////////////////////////////////
1: 
1:             builder.append(")");
commit:62ba6d5
/////////////////////////////////////////////////////////////////////////
1:                 for (Class cl = clazz; cl != null && cl != Object.class; cl = cl.getSuperclass()) {
1:                     for (Field field : cl.getDeclaredFields()) {
1:                         if (!!!Modifier.isStatic(field.getModifiers())) {
1:                             String name = decapitalize(field.getName());
1:                             PropertyDescriptor desc = props.get(name);
1:                             if (desc == null) {
1:                                 props.put(name, new FieldPropertyDescriptor(name, field));
1:                             } else if (desc instanceof MethodPropertyDescriptor) {
1:                                 props.put(name,
1:                                         new JointPropertyDescriptor((MethodPropertyDescriptor) desc,
1:                                                 new FieldPropertyDescriptor(name, field)));
1:                             } else {
1:                                 illegalProperties.add(name);
1:                             }
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.utils;
1: 
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.lang.reflect.Type;
0: import java.lang.ref.Reference;
0: import java.lang.ref.SoftReference;
1: import java.security.AccessControlContext;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.WeakHashMap;
1: 
1: /**
1:  * TODO: javadoc
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
1:  * @version $Rev$, $Date$
1:  */
1: public class ReflectionUtils {
1: 
0:     // TODO: MLK: PropertyDescriptor holds a reference to Method which holds a reference to the Class itself
0:     private static Map<Class, PropertyDescriptor[]> beanInfos = Collections.synchronizedMap(new WeakHashMap<Class, PropertyDescriptor[]>());
1: 
1:     public static boolean hasDefaultConstructor(Class type) {
1:         if (!Modifier.isPublic(type.getModifiers())) {
1:             return false;
1:         }
1:         if (Modifier.isAbstract(type.getModifiers())) {
1:             return false;
1:         }
1:         Constructor[] constructors = type.getConstructors();
1:         for (Constructor constructor : constructors) {
1:             if (Modifier.isPublic(constructor.getModifiers()) &&
1:                     constructor.getParameterTypes().length == 0) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1:     
1:     public static Set<String> getImplementedInterfaces(Set<String> classes, Class clazz) {
1:         if (clazz != null && clazz != Object.class) {
1:             for (Class itf : clazz.getInterfaces()) {
1:                 if (Modifier.isPublic(itf.getModifiers())) {
1:                     classes.add(itf.getName());
1:                 }
1:                 getImplementedInterfaces(classes, itf);
1:             }
1:             getImplementedInterfaces(classes, clazz.getSuperclass());
1:         }
1:         return classes;
1:     }
1: 
1:     public static Set<String> getSuperClasses(Set<String> classes, Class clazz) {
1:         if (clazz != null && clazz != Object.class) {
1:             if (Modifier.isPublic(clazz.getModifiers())) {
1:                 classes.add(clazz.getName());
1:             }
1:             getSuperClasses(classes, clazz.getSuperclass());
1:         }
1:         return classes;
1:     }
1: 
1:     public static Method getLifecycleMethod(Class clazz, String name) {
1:         if (name != null) {
1:             try {
0:                 Method method = clazz.getMethod(name);
0:                 if (Void.TYPE.equals(method.getReturnType())) {
1:                     return method;
1:                 }
0:             } catch (NoSuchMethodException e) {
0:                 // fall thru
1:             }
1:         }
1:         return null;
1:     }
1:     
1:     public static List<Method> findCompatibleMethods(Class clazz, String name, Class[] paramTypes) {
1:         List<Method> methods = new ArrayList<Method>();
0:         for (Method method : clazz.getMethods()) {
1:             Class[] methodParams = method.getParameterTypes();
0:             if (name.equals(method.getName()) && Void.TYPE.equals(method.getReturnType()) && methodParams.length == paramTypes.length) {
1:                 boolean assignable = true;
1:                 for (int i = 0; i < paramTypes.length && assignable; i++) {
1:                     assignable &= paramTypes[i] == null || methodParams[i].isAssignableFrom(paramTypes[i]);
1:                 }
1:                 if (assignable) {
1:                     methods.add(method);
1:                 }
1:             }
1:         }
1:         return methods;
1:     }
1: 
0:     public static PropertyDescriptor[] getPropertyDescriptors(Class clazz) {
0:         PropertyDescriptor[] properties = beanInfos.get(clazz);
1:         if (properties == null) {
0:             List<PropertyDescriptor> props = new ArrayList<PropertyDescriptor>();
0:             for (Method method : clazz.getMethods()) {
0:                 if (Modifier.isStatic(method.getModifiers())) {
0:                     continue;
1:                 }
1:                 String name = method.getName();
0:                 Class argTypes[] = method.getParameterTypes();
0:                 Class resultType = method.getReturnType();
1:                 if (name.length() > 3 && name.startsWith("set") && resultType == Void.TYPE && argTypes.length == 1) {
0:                     props.add(new PropertyDescriptor(decapitalize(name.substring(3)), argTypes[0], null, method));
1: 
0:                 } else if (name.length() > 3 && name.startsWith("get") && argTypes.length == 0) {
0:                     props.add(new PropertyDescriptor(decapitalize(name.substring(3)), resultType, method, null));
1:                 } else if (name.length() > 2 && name.startsWith("is") && argTypes.length == 0 && resultType == boolean.class) {
0:                     props.add(new PropertyDescriptor(decapitalize(name.substring(2)), resultType, method, null));
1:                 }
1:             }
0:             PropertyDescriptor[] pds = props.toArray(new PropertyDescriptor[props.size()]);
0:             for (int i = 0; i < pds.length - 1; i++) {
0:                 boolean remove = false;
0:                 for (int j = i + 1; j < pds.length; j++) {
0:                     if (pds[i] != null && pds[j] != null) {
0:                         if (pds[i].name.equals(pds[j].name)) {
0:                             if (remove || !pds[i].type.equals(pds[j].type)) {
0:                                 remove = true;
0:                                 pds[j] = null;
0:                                 continue;
1:                             } else {
0:                                 if (pds[j].getter != null) {
0:                                     if (pds[i].getter == null) {
0:                                         pds[i].getter = pds[j].getter;
0:                                     } else if (pds[i].getter != pds[j].getter) {
0:                                         remove = true;
0:                                         pds[j] = null;
0:                                         continue;
1:                                     }
1:                                 }
0:                                 if (pds[j].setter != null) {
0:                                     if (pds[i].setter == null) {
0:                                         pds[i].setter = pds[j].setter;
0:                                     } else if (pds[i].setter != pds[j].setter) {
0:                                         remove = true;
0:                                         pds[j] = null;
0:                                         continue;
1:                                     }
1:                                 }
1:                             }
1:                         }
1:                     }
1:                 }
0:                 if (remove) {
0:                     pds[i] = null;
1:                 }
1:             }
0:             props.clear();
0:             for (int i = 0; i < pds.length - 1; i++) {
0:                 if (pds[i] != null) {
0:                     pds[i].type = null;
0:                     props.add(pds[i]);
1:                 }
1:             }
0:             properties = props.toArray(new PropertyDescriptor[props.size()]);
1:             beanInfos.put(clazz, properties);
1:         }
0:         return properties;
1:     }
1: 
1:     private static String decapitalize(String name) {
1:         if (name == null || name.length() == 0) {
1:             return name;
1:         }
1:         if (name.length() > 1 && Character.isUpperCase(name.charAt(1)) &&
1:                 Character.isUpperCase(name.charAt(0))) {
1:             return name;
1:         }
1:         char chars[] = name.toCharArray();
1:         chars[0] = Character.toLowerCase(chars[0]);
1:         return new String(chars);
1:     }
1: 
1:     public static Object invoke(AccessControlContext acc, final Method method, final Object instance, final Object... args) throws Exception {
1:         if (acc == null) {
1:             return method.invoke(instance, args);
1:         } else {
1:             try {
1:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                     public Object run() throws Exception {
1:                         return method.invoke(instance, args);
1:                     }            
1:                 }, acc);
1:             } catch (PrivilegedActionException e) {
1:                 throw e.getException();
1:             }
1:         }
1:     }
1:     
1:     public static Object newInstance(AccessControlContext acc, final Class clazz) throws Exception {
1:         if (acc == null) {
1:             return clazz.newInstance();
1:         } else {
1:             try {
1:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                     public Object run() throws Exception {
1:                         return clazz.newInstance();
1:                     }            
1:                 }, acc);
1:             } catch (PrivilegedActionException e) {
1:                 throw e.getException();
1:             }
1:         }
1:     }
1:     
1:     public static Object newInstance(AccessControlContext acc, final Constructor constructor, final Object... args) throws Exception {
1:         if (acc == null) {
1:             return constructor.newInstance(args);
1:         } else {
1:             try {
1:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                     public Object run() throws Exception {
1:                         return constructor.newInstance(args);
1:                     }            
1:                 }, acc);
1:             } catch (PrivilegedActionException e) {
1:                 throw e.getException();
1:             }
1:         }
1:     }
1:     
0:     public static class PropertyDescriptor {
0:         private String name;
0:         private Class type;
0:         private Method getter;
0:         private Method setter;
1: 
0:         public PropertyDescriptor(String name, Class type, Method getter, Method setter) {
1:             this.name = name;
0:             this.type = type;
0:             this.getter = getter;
0:             this.setter = setter;
1:         }
1: 
1:         public String getName() {
1:             return name;
1:         }
1: 
0:         public Method getGetter() {
0:             return getter;
1:         }
1: 
0:         public Method getSetter() {
0:             return setter;
1:         }
1:     }
1: 
1:     public static Throwable getRealCause(Throwable t) {
1:         if (t instanceof InvocationTargetException && t.getCause() != null) {
1:             return t.getCause();
1:         }
1:         return t;
1:     }
1: 
1: }
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:753fec1
/////////////////////////////////////////////////////////////////////////
1: import java.lang.ref.WeakReference;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // instead of holding on to the java.lang.reflect.Field objects we retrieve it every time. The reason is that PropertyDescriptors are 
1:         // used as values in a WeakHashMap with the class corresponding to the field as the key
1:         private final String fieldName;
1:         private final WeakReference<Class<?>> declaringClass;
1:             this.fieldName = field.getName();
1:             this.declaringClass = new WeakReference(field.getDeclaringClass());
/////////////////////////////////////////////////////////////////////////
1:         
1:         private Field getField(ExtendedBlueprintContainer container) throws ClassNotFoundException, NoSuchFieldException {
1:             if (declaringClass.get() == null) throw new ClassNotFoundException("Declaring class was garbage collected");
1:             
1:             return declaringClass.get().getDeclaredField(fieldName);
1:         }
1:         protected Object internalGet(final ExtendedBlueprintContainer container, final Object instance) throws Exception {
1:                             return doInternalGet(container, instance);
/////////////////////////////////////////////////////////////////////////
1:                 return doInternalGet(container, instance);
1:             }
1:         }
1:         
1:         private Object doInternalGet(ExtendedBlueprintContainer container, Object instance) throws Exception {
1:             Field field = getField(container);
1:             boolean isAccessible = field.isAccessible();
1:             field.setAccessible(true);
1:             try {
1:             } finally {
1:                 field.setAccessible(isAccessible);
1:         protected void internalSet(final ExtendedBlueprintContainer container, final Object instance, final Object value) throws Exception {
1:                             doInternalSet(container, instance, value);
/////////////////////////////////////////////////////////////////////////
1:                 doInternalSet(container, instance, value);
1:             }
1:         }
1:         
1:         private void doInternalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception {
1:             Field field = getField(container);
1:             final Object convertedValue = convert(value, field.getGenericType());
1:             boolean isAccessible = field.isAccessible();
1:             field.setAccessible(true);
1:             try {
1:             } finally {
1:                 field.setAccessible(isAccessible);
/////////////////////////////////////////////////////////////////////////
1:         private boolean useContainersPermission(ExtendedBlueprintContainer container) throws ClassNotFoundException {
1:             if (declaringClass.get() == null) throw new ClassNotFoundException("Declaring class was garbage collected");
1:             ClassLoader loader = declaringClass.get().getClassLoader();
/////////////////////////////////////////////////////////////////////////
1:     private static class MethodDescriptor {
1:         private final String methodName;
1:         private final WeakReference<Class<?>> declaringClass;
1:         private final List<WeakReference<Class<?>>> argClasses;
1:         
1:         public MethodDescriptor(Method method) {
1:             methodName = method.getName();
1:             declaringClass = new WeakReference<Class<?>>(method.getDeclaringClass());
1:             
1:             List<WeakReference<Class<?>>> accumulator = new ArrayList<WeakReference<Class<?>>>();
1:             for (Class<?> c : method.getParameterTypes()) {
1:                 accumulator.add(new WeakReference<Class<?>>(c));
1:             }
1:             argClasses = Collections.unmodifiableList(accumulator);
1:         }
1:         
1:         public Method getMethod(ExtendedBlueprintContainer container) throws ClassNotFoundException, NoSuchMethodException {
1:             Class<?>[] argumentClasses = new Class<?>[argClasses.size()];
1:             for (int i=0; i<argClasses.size(); i++) {
1:                 argumentClasses[i] = argClasses.get(i).get();
1:                 if (argumentClasses[i] == null) throw new ClassNotFoundException("Argument class was garbage collected");
1:             }
1:             
1:             if (declaringClass.get() == null) throw new ClassNotFoundException("Declaring class was garbage collected");
1:             
1:             return declaringClass.get().getMethod(methodName, argumentClasses);
1:         }
1:         
1:         public String toString() {
1:             StringBuilder builder = new StringBuilder();
1:             builder.append(declaringClass.get()).append(".").append(methodName).append("(");
1:             
1:             boolean first = true;
1:             for (WeakReference<Class<?>> wcl : argClasses) {
1:                 if (!!!first) builder.append(",");
1:                 else first = false;
1:                 
1:                 builder.append(wcl.get());
1:             }
1:             
1:             return builder.toString();
1:         }
1:     }
1:     
1:         // instead of holding on to the java.lang.reflect.Method objects we retrieve it every time. The reason is that PropertyDescriptors are 
1:         // used as values in a WeakHashMap with the class corresponding to the methods as the key
1:         private final MethodDescriptor getter;
1:         private final Collection<MethodDescriptor> setters;
1:             this.getter = (getter != null) ? new MethodDescriptor(getter) : null;
1:             
1:             if (setters != null) {
1:                 Collection<MethodDescriptor> accumulator = new ArrayList<MethodDescriptor>();
1:                 for (Method s : setters) accumulator.add(new MethodDescriptor(s));
1:                 this.setters = Collections.unmodifiableCollection(accumulator);
1:             } else {
1:                 this.setters = Collections.emptyList();
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 throws Exception {
1:                 return getter.getMethod(container).invoke(instance);
/////////////////////////////////////////////////////////////////////////
1:             Method setterMethod = findSetter(container, value);
/////////////////////////////////////////////////////////////////////////
1:         private Method findSetter(ExtendedBlueprintContainer container, Object value) throws Exception {
1:             Method getterMethod = (getter != null) ? getter.getMethod(container) : null;
1:             Collection<Method> setterMethods = getSetters(container);
1:             Method result = findMethodByClass(getterMethod, setterMethods, valueType);
1:             
1:             if (result == null) result = findMethodWithConversion(setterMethods, value);
1:         private Collection<Method> getSetters(ExtendedBlueprintContainer container) throws Exception {
1:             Collection<Method> result = new ArrayList<Method>();
1:             for (MethodDescriptor md : setters) result.add(md.getMethod(container));
1:             
1:             return result;
1:         }
1:         
1:         private Method findMethodByClass(Method getterMethod, Collection<Method> setterMethods, Class<?> arg)
1:             if (!hasSameTypeSetter(getterMethod, setterMethods)) {
1:             if (setterMethods.size() == 1) {
1:                 return setterMethods.iterator().next();
1:             for (Method m : setterMethods) {
/////////////////////////////////////////////////////////////////////////
1:         private boolean hasSameTypeSetter(Method getterMethod, Collection<Method> setterMethods) {
1:             if (getterMethod == null) {
1: 
1:             Iterator<Method> it = setterMethods.iterator();
1:                 if (m.getParameterTypes()[0].equals(getterMethod.getReturnType())) {
1:         private Method findMethodWithConversion(Collection<Method> setterMethods, Object value) throws Exception {
1:             for (Method m : setterMethods) {
commit:08c11fc
/////////////////////////////////////////////////////////////////////////
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.osgi.framework.BundleReference;
/////////////////////////////////////////////////////////////////////////
1:         protected abstract Object internalGet(ExtendedBlueprintContainer container, Object instance) throws Exception;
1:         protected abstract void internalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception;        
1:         public Object get(final Object instance, final ExtendedBlueprintContainer container) throws Exception {            
1:             if (container.getAccessControlContext() == null) {
1:                 return internalGet(container, instance);
1:                             return internalGet(container, instance);
1:                     }, container.getAccessControlContext());
1:         public void set(final Object instance, final Object value, final ExtendedBlueprintContainer container) throws Exception {
1:             if (container.getAccessControlContext() == null) {
1:                 internalSet(container, instance, value);
1:                             internalSet(container, instance, value);
1:                     }, container.getAccessControlContext());
/////////////////////////////////////////////////////////////////////////
1:         protected Object internalGet(ExtendedBlueprintContainer container, Object instance) throws Exception {
1:             if (mpd.allowsGet()) return mpd.internalGet(container, instance);
1:             else if (fpd.allowsGet()) return fpd.internalGet(container, instance);
1:         protected void internalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception {
1:             if (mpd.allowsSet()) mpd.internalSet(container, instance, value);
1:             else if (fpd.allowsSet()) fpd.internalSet(container, instance, value);
/////////////////////////////////////////////////////////////////////////
0:         protected Object internalGet(ExtendedBlueprintContainer container, final Object instance) throws IllegalArgumentException, IllegalAccessException {
1:             if (useContainersPermission(container)) {
1:                 try {
1:                     return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                         public Object run() throws Exception {
0:                             field.setAccessible(true);
1:                             return field.get(instance);
1:                         }                        
1:                     });
1:                 } catch (PrivilegedActionException pae) {
1:                     Exception e = pae.getException();
1:                     if (e instanceof IllegalAccessException) throw (IllegalAccessException) e;
1:                     else throw (RuntimeException) e;
1:                 }
1:             } else {
0:                 field.setAccessible(true);
1:                 return field.get(instance);
1:             }
0:         protected void internalSet(ExtendedBlueprintContainer container, final Object instance, Object value) throws Exception {
0:             final Object convertedValue = convert(value, field.getGenericType());
1:             if (useContainersPermission(container)) {
1:                 try {
1:                     AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                         public Object run() throws Exception {
0:                             field.setAccessible(true);
1:                             field.set(instance, convertedValue);
1:                             return null;
1:                         }                        
1:                     });
1:                 } catch (PrivilegedActionException pae) {
1:                     throw pae.getException();
1:                 }
1:             } else {
0:                 field.setAccessible(true);
1:                 field.set(instance, convertedValue);
1:             }
1:         }
1:         
1:         /**
1:          * Determine whether the field access (in particular the call to {@link Field#setAccessible(boolean)} should be done with the Blueprint extender's
1:          * permissions, rather than the joint (more restrictive) permissions of the extender plus the Blueprint bundle.
1:          * 
1:          * We currently only allow this for classes that originate from inside the Blueprint bundle. Otherwise this would open a potential security hole.
1:          * @param container
1:          * @return
1:          */
0:         private boolean useContainersPermission(ExtendedBlueprintContainer container) {
0:             ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
0:                 public ClassLoader run() {
0:                     return field.getDeclaringClass().getClassLoader();
1:                 }
1:             });            
1:             
1:             if (loader == null) return false;
1:             
1:             if (loader instanceof BundleReference) {
1:                 BundleReference ref = (BundleReference) loader;
1:                 return ref.getBundle().equals(container.getBundleContext().getBundle());                
1:             }
1:             
1:             return false;
/////////////////////////////////////////////////////////////////////////
1:         protected Object internalGet(ExtendedBlueprintContainer container, Object instance) 
/////////////////////////////////////////////////////////////////////////
1:         protected void internalSet(ExtendedBlueprintContainer container, Object instance, Object value) throws Exception {
commit:cab8bfe
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import org.apache.aries.blueprint.container.GenericType;
1: import org.apache.aries.blueprint.di.ExecutionContext;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: 
/////////////////////////////////////////////////////////////////////////
1:             Set<String> propertyNames = new HashSet<String>();
1:             Map<String,Method> getters = new HashMap<String, Method>();
1:             Map<String,List<Method>> setters = new HashMap<String, List<Method>>();
1:             Set<String> illegalProperties = new HashSet<String>();
1:             
1:                 if (Modifier.isStatic(method.getModifiers()) || method.isBridge()) continue;
1:                 
1:                     if (!!!setters.containsKey(name)) setters.put(name, new ArrayList<Method>());
1:                     setters.get(name).add(method);
1:                     propertyNames.add(name);
1:                 } else if (name.length() > 3 && name.startsWith("get") && resultType != Void.TYPE && argTypes.length == 0) {
1: 
1:                     if (getters.containsKey(name)) illegalProperties.add(name);
1:                     else propertyNames.add(name);
1:                     
1:                     getters.put(name, method);                    
1: 
1:                     if (getters.containsKey(name)) illegalProperties.add(name);
1:                     else propertyNames.add(name);
1:                     
1:                     getters.put(name, method);                    
1: 
1:             Map<String, PropertyDescriptor> props = new HashMap<String, PropertyDescriptor>();
1:             for (String propName : propertyNames) {
1:                 props.put(propName,
1:                         new MethodPropertyDescriptor(propName, getters.get(propName), setters.get(propName)));
1:             }            
0:                     if (!!!Modifier.isStatic(field.getModifiers())) {
0:                         String name = decapitalize(field.getName());
0:                         PropertyDescriptor desc = props.get(name);
0:                         if (desc == null) {
0:                             props.put(name, new FieldPropertyDescriptor(name, field));
0:                         } else if (desc instanceof MethodPropertyDescriptor) {
0:                             props.put(name, 
0:                                     new JointPropertyDescriptor((MethodPropertyDescriptor) desc, 
0:                                             new FieldPropertyDescriptor(name, field)));
1:                         } else {
0:                             illegalProperties.add(name);
1:             List<PropertyDescriptor> result = new ArrayList<PropertyDescriptor>();
1:             for (PropertyDescriptor prop : props.values()) {
1:                 if (!!!illegalProperties.contains(prop.getName())) result.add(prop);
1:             properties[index] = result.toArray(new PropertyDescriptor[result.size()]); 
/////////////////////////////////////////////////////////////////////////
1:     public static abstract class PropertyDescriptor {
1:         private final String name;
1:         
1:         public PropertyDescriptor(String name) {
1:         public abstract boolean allowsGet();
1:         public abstract boolean allowsSet();
0:         protected abstract Object internalGet(Object instance) throws Exception;
0:         protected abstract void internalSet(Object instance, Object value) throws Exception;        
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         protected Object convert(Object obj, Type type) throws Exception {
1:             return ExecutionContext.Holder.getContext().convert(obj, new GenericType(type));
1:         }
1:     }
1:     
1:     private static class JointPropertyDescriptor extends PropertyDescriptor {
1:         private final MethodPropertyDescriptor mpd;
1:         private final FieldPropertyDescriptor fpd;
1:         
1:         public JointPropertyDescriptor(MethodPropertyDescriptor mpd, FieldPropertyDescriptor fpd) {
1:             super(mpd.getName());
1:             this.mpd = mpd;
1:             this.fpd = fpd;
1:         }
1: 
1:         @Override
1:         public boolean allowsGet() {
1:             return mpd.allowsGet() || fpd.allowsGet();
1:         }
1: 
1:         @Override
1:         public boolean allowsSet() {
1:             return mpd.allowsSet() || fpd.allowsSet();
1:         }
1: 
1:         @Override
0:         protected Object internalGet(Object instance) throws Exception {
0:             if (mpd.allowsGet()) return mpd.internalGet(instance);
0:             else if (fpd.allowsGet()) return fpd.internalGet(instance);
1:             else throw new UnsupportedOperationException();
1:         }
1: 
1:         @Override
0:         protected void internalSet(Object instance, Object value) throws Exception {
0:             if (mpd.allowsSet()) mpd.internalSet(instance, value);
0:             else if (fpd.allowsSet()) fpd.internalSet(instance, value);
1:             else throw new UnsupportedOperationException();
1:         }
1:     }
1:     
1:     private static class FieldPropertyDescriptor extends PropertyDescriptor {
0:         private final Field field;
1:         
1:         public FieldPropertyDescriptor(String name, Field field) {
1:             super(name);
0:             this.field = field;
1:         }
1: 
1:         public boolean allowsGet() {
1:             return true;
1:         }
1: 
1:         public boolean allowsSet() {
1:             return true;
1:         }
1: 
0:         protected Object internalGet(Object instance) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
0:             field.setAccessible(true);
0:             return field.get(instance);
1:         }
1: 
0:         protected void internalSet(Object instance, Object value) throws Exception {
0:             field.setAccessible(true);
0:             field.set(instance, convert(value, field.getGenericType()));
1:         }
1:     }
1:     
1:     private static class MethodPropertyDescriptor extends PropertyDescriptor {
0:         private final Method getter;
0:         private final Collection<Method> setters;
1: 
1:         private MethodPropertyDescriptor(String name, Method getter, Collection<Method> setters) {
1:             super(name);
0:             this.getter = getter;
0:             this.setters = (setters != null) ? setters : Collections.<Method>emptyList();
1:         }
1:         
1:         public boolean allowsGet() {
1:             return getter != null;
1:         }
1:         
1:         public boolean allowsSet() {
1:             return !!!setters.isEmpty();
1:         }
1:         
0:         protected Object internalGet(Object instance) 
1:             if (getter != null) {
0:                 return getter.invoke(instance);
0:         protected void internalSet(Object instance, Object value) throws Exception {
1:             
0:             Method setterMethod = findSetter(value);
1: 
1:             if (setterMethod != null) {
0:                 setterMethod.invoke(instance, convert(value, setterMethod.getGenericParameterTypes()[0]));
1:             } else {
1:                 throw new ComponentDefinitionException(
1:                         "No converter available to convert value "+value+" into a form applicable for the " + 
1:                         "setters of property "+getName());
1:             }
1:         }
1:         
0:         private Method findSetter(Object value) {
1:             Class<?> valueType = (value == null) ? null : value.getClass();
1:             
0:             Method result = findMethodByClass(valueType);
1:             
0:             if (result == null) result = findMethodWithConversion(value);
1:                         
1:             return result;
1:         }
1:         
0:         private Method findMethodByClass(Class<?> arg) throws ComponentDefinitionException {
1:             Method result = null;
1:             
0:             for (Method m : setters) {
1:                 Class<?> paramType = m.getParameterTypes()[0];
1:                 if ((arg == null && Object.class.isAssignableFrom(paramType)) 
1:                         || (arg != null && paramType.isAssignableFrom(arg))) {
1:                     
0:                     // pick the method that has the more specific parameter if any
1:                     if (result != null) {
1:                         Class<?> oldParamType = result.getParameterTypes()[0];
1:                         if (paramType.isAssignableFrom(oldParamType)) {
1:                             // do nothing, result is correct
1:                         } else if (oldParamType.isAssignableFrom(paramType)) {
1:                             result = m;
1:                         } else {
1:                             throw new ComponentDefinitionException(
0:                                     "Ambiguous setter method for property "+getName()+
0:                                     ". More than one method matches the  parameter type "+arg);
1:                         }
1:                     } else {
1:                         result = m;
1:                     }
1:                 }
1:             }            
1:             
1:             return result;
1:         }
1:         
0:         private Method findMethodWithConversion(Object value) throws ComponentDefinitionException {
1:             ExecutionContext ctx = ExecutionContext.Holder.getContext();
1:             List<Method> matchingMethods = new ArrayList<Method>();
0:             for (Method m : setters) {
1:                 Type paramType = m.getGenericParameterTypes()[0];
1:                 if (ctx.canConvert(value, new GenericType(paramType))) matchingMethods.add(m);
1:             }
1:             
1:             if (matchingMethods.isEmpty()) return null;
1:             else if (matchingMethods.size() == 1) return matchingMethods.get(0);
1:             else throw new ComponentDefinitionException(
1:                     "Ambiguous setter method for property "+ getName() + 
1:                     ". More than one method matches the parameter "+value+" after applying conversion.");
1:             return "PropertyDescriptor <name: "+getName()+", getter: "+getter+", setter: "+setters;
commit:d08aba3
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
0: import java.lang.reflect.Type;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     private static Map<Class<?>, PropertyDescriptor[][]> beanInfos = Collections.synchronizedMap(new WeakHashMap<Class<?>, PropertyDescriptor[][]>());
/////////////////////////////////////////////////////////////////////////
1:     public static PropertyDescriptor[] getPropertyDescriptors(Class clazz, boolean allowFieldInjection) {
1:         PropertyDescriptor[][] properties = beanInfos.get(clazz);
1:         int index = allowFieldInjection ? 0 : 1;
1:         
1:             properties = new PropertyDescriptor[2][];
0:             beanInfos.put(clazz, properties);
1:         }
1:         
1:         if (properties[index] == null) {
0:             Map<String,PropertyDescriptor> props = new HashMap<String, PropertyDescriptor>();
1:                 Class<?> argTypes[] = method.getParameterTypes();
1:                 Class<?> resultType = method.getReturnType();
1:                 
0:                 Class<?> argType = resultType;
0:                 Method getter = null;
0:                 Method setter = null;
1:                 
1:                     name = decapitalize(name.substring(3));
0:                     setter = method;
0:                     argType = argTypes[0];
1:                     name = decapitalize(name.substring(3));
0:                     getter = method;
1:                     name = decapitalize(name.substring(2));
0:                     getter = method;
0:                 } else {
0:                     continue;
1:                 }
1:                 
0:                 if (props.containsKey(name)) {
0:                     PropertyDescriptor pd = props.get(name);
0:                     if (pd != INVALID_PROPERTY) {
0:                         if (!argType.equals(pd.type)) {
0:                             props.put(name, INVALID_PROPERTY);
0:                         } else if (getter != null) {
0:                             if (pd.getter == null || pd.getter.equals(getter))
0:                                 pd.getter = getter;
0:                             else
0:                                 props.put(name, INVALID_PROPERTY);
0:                         } else if (setter != null) {
0:                             if (pd.setter == null || pd.setter.equals(setter)) 
0:                                 pd.setter = setter;
0:                             else
0:                                 props.put(name, INVALID_PROPERTY);
1:                         }
1:                     }
0:                 } else {
0:                     props.put(name, new PropertyDescriptor(name, argType, getter, setter));
1:             
1:             if (allowFieldInjection) {
0:                 for (Field field : clazz.getDeclaredFields()) {
0:                     if (Modifier.isStatic(field.getModifiers())) {
0:                         continue;
1:                     }
1:                     
0:                     String name = decapitalize(field.getName());
0:                     if (!props.containsKey(name)) {
0:                         props.put(name, new PropertyDescriptor(name, field.getType(), field));
0:                     } else {
0:                         PropertyDescriptor pd = props.get(name);
0:                         if (pd != INVALID_PROPERTY) {
0:                             if (pd.type.equals(field.getType())) {
0:                                 pd.field = field;
1:                             } 
0:                             // no else, we don't require field implementations to have the same
0:                             // type as the getter and setter
1:             
0:             Iterator<PropertyDescriptor> it = props.values().iterator();
1:             while (it.hasNext()) {
0:                 if (it.next() == INVALID_PROPERTY)
0:                     it.remove();
1:             
0:             Collection<PropertyDescriptor> tmp = props.values();
0:             properties[index] = tmp.toArray(new PropertyDescriptor[tmp.size()]); 
1:         return properties[index];
/////////////////////////////////////////////////////////////////////////
0:     private static final PropertyDescriptor INVALID_PROPERTY = new PropertyDescriptor(null, null, null, null);
1: 
0:         private Class<?> type;
0:         private Field field;
0:         public PropertyDescriptor(String name, Class<?> type, Method getter, Method setter) {
1:         
0:         public PropertyDescriptor(String name, Class<?> type, Field field) {
0:             this.name = name;
0:             this.type = type;
0:             this.field = field;
0:             this.getter = null;
0:             this.setter = null;
1:         }
1:         
0:         public boolean allowsGet() {
0:             return getter != null || field != null;
1:         }
1:         
0:         public boolean allowsSet() {
0:             return setter != null || field != null;
1:         }
1:         
0:         public Object get(final Object instance, AccessControlContext acc) throws Exception {            
0:             if (acc == null) {
0:                 return internalGet(instance);
0:             } else {
1:                 try {
1:                     return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                         public Object run() throws Exception {
0:                             return internalGet(instance);
1:                         }            
0:                     }, acc);
1:                 } catch (PrivilegedActionException e) {
1:                     throw e.getException();
1:                 }
1:             }
1:         }
1:             
0:         private Object internalGet(Object instance) 
0:                 throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
0:             if (getter != null) {
0:                 return getter.invoke(instance);
0:             } else if (field != null) {
0:                 field.setAccessible(true);
0:                 return field.get(instance);
0:             } else {
1:                 throw new UnsupportedOperationException();
1:             }
0:         public void set(final Object instance, final Object value, AccessControlContext acc) throws Exception {
0:             if (acc == null) {
0:                 internalSet(instance, value);
0:             } else {
1:                 try {
0:                     AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
1:                         public Object run() throws Exception {
0:                             internalSet(instance, value);
0:                             return null;
1:                         }            
0:                     }, acc);
1:                 } catch (PrivilegedActionException e) {
1:                     throw e.getException();
1:                 }
1:             }            
1:         }
1:         
0:         private void internalSet(Object instance, Object value) 
0:                 throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
0:             if (setter != null) {
0:                 setter.invoke(instance, value);
0:             } else if (field != null) {
0:                 field.setAccessible(true);
0:                 field.set(instance, value);
0:             } else {
1:                 throw new UnsupportedOperationException();
1:             }
1:         }
1:         
0:         public Type getGenericType() {
0:             if (setter != null)
0:                 return setter.getGenericParameterTypes()[0];
0:             else if (getter != null)
0:                 return getter.getGenericReturnType();
0:             else 
0:                 return field.getGenericType();
1:                 
1:         }
1:         
1:         public String toString() {
0:             return "PropertyDescriptor <name: "+name+", getter: "+getter+", setter: "+setter+
0:                 ", field: "+field+">";
commit:7c549ab
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (name.equals(method.getName()) && Void.TYPE.equals(method.getReturnType()) && methodParams.length == paramTypes.length && !method.isBridge()) {
/////////////////////////////////////////////////////////////////////////
0:                 if (Modifier.isStatic(method.getModifiers()) || method.isBridge()) {
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:6726c3e
/////////////////////////////////////////////////////////////////////////
0:     
1:     public static Set<Class<?>> getImplementedInterfacesAsClasses(Set<Class<?>> classes, Class<?> clazz) {
1:         if (clazz != null && clazz != Object.class) {
1:             for (Class<?> itf : clazz.getInterfaces()) {
1:                 if (Modifier.isPublic(itf.getModifiers())) {
1:                     classes.add(itf);
0:                 }
1:                 getImplementedInterfacesAsClasses(classes, itf);
0:             }
1:             getImplementedInterfacesAsClasses(classes, clazz.getSuperclass());
0:         }
1:         return classes;
0:     }
commit:fde5fef
/////////////////////////////////////////////////////////////////////////
0:             try {
1:                 Boolean wasSet = AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {
1:                     public Boolean run() throws Exception {
0:                       if (useContainersPermission(container)) {
0:                         doInternalSet(container, instance, value);
1:                         return Boolean.TRUE;
0:                       }
1:                       return Boolean.FALSE;
0:                     }                        
0:                 });
1:                 if(!!!wasSet) {
0:                   doInternalSet(container, instance, value);
0:             } catch (PrivilegedActionException pae) {
0:                 throw pae.getException();
author:Lin Sun
-------------------------------------------------------------------------------
commit:43c68d1
/////////////////////////////////////////////////////////////////////////
0:         private Method findMethodByClass(Class<?> arg)
1:                 throws ComponentDefinitionException {
0: 
0:             if (!hasSameTypeSetter()) {
1:                 throw new ComponentDefinitionException(
1:                         "At least one Setter method has to match the type of the Getter method for property "
1:                                 + getName());
0:             }
0: 
0:             if (setters.size() == 1) {
0:                 return setters.iterator().next();
0:             }
0: 
0:                 if ((arg == null && Object.class.isAssignableFrom(paramType))
0: 
1:                     // pick the method that has the more specific parameter if
1:                     // any
/////////////////////////////////////////////////////////////////////////
1:                                     "Ambiguous setter method for property "
1:                                             + getName()
1:                                             + ". More than one method matches the  parameter type "
1:                                             + arg);
0:             }
0: 
1:         // ensure there is a setter that matches the type of the getter
0:         private boolean hasSameTypeSetter() {
0:             if (getter == null) {
1:                 return true;
0:             }
0:             Iterator<Method> it = setters.iterator();
0:             while (it.hasNext()) {
1:                 Method m = it.next();
0:                 if (m.getParameterTypes()[0].equals(getter.getReturnType())) {
1:                     return true;
0:                 }
0:             }
1:             return false;
0:         }
0: 
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.utils;
============================================================================