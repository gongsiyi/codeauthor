1:f13c6ac: /**
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
2:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:4ae0bfc: import java.io.File;
1:4ae0bfc: import java.net.MalformedURLException;
1:c89ef70: import java.net.URI;
1:f13c6ac: import java.net.URL;
1:f13c6ac: import java.util.ArrayList;
1:c89ef70: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:f13c6ac: import java.util.Comparator;
1:f13c6ac: import java.util.Enumeration;
1:3fa788c: import java.util.Hashtable;
1:f13c6ac: import java.util.List;
1:3e11f4a: import java.util.concurrent.*;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.BlueprintConstants;
1:edc17ca: import org.apache.aries.blueprint.annotation.service.BlueprintAnnotationScanner;
1:6414875: import org.apache.aries.blueprint.namespace.NamespaceHandlerRegistryImpl;
1:c18101e: import org.apache.aries.blueprint.services.BlueprintExtenderService;
1:09a7647: import org.apache.aries.blueprint.services.ParserService;
1:6414875: import org.apache.aries.blueprint.utils.HeaderParser;
1:6414875: import org.apache.aries.blueprint.utils.HeaderParser.PathElement;
1:ef7b490: import org.apache.aries.blueprint.utils.threading.ScheduledExecutorServiceWrapper;
1:ef7b490: import org.apache.aries.blueprint.utils.threading.ScheduledExecutorServiceWrapper.ScheduledExecutorServiceFactory;
1:24455ce: import org.apache.aries.proxy.ProxyManager;
1:047a2ae: import org.apache.aries.util.AriesFrameworkUtil;
1:537d4ee: import org.apache.aries.util.tracker.RecursiveBundleTracker;
1:b6c4135: import org.apache.aries.util.tracker.SingleServiceTracker;
1:b6c4135: import org.apache.aries.util.tracker.SingleServiceTracker.SingleServiceListener;
1:f13c6ac: import org.osgi.framework.Bundle;
1:f13c6ac: import org.osgi.framework.BundleActivator;
1:f13c6ac: import org.osgi.framework.BundleContext;
1:f13c6ac: import org.osgi.framework.BundleEvent;
1:f13c6ac: import org.osgi.framework.Constants;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:3fa788c: import org.osgi.framework.ServiceRegistration;
1:6d7c26a: import org.osgi.framework.SynchronousBundleListener;
1:f13c6ac: import org.osgi.service.blueprint.container.BlueprintContainer;
1:f13c6ac: import org.osgi.service.blueprint.container.BlueprintEvent;
1:ecf9333: import org.osgi.util.tracker.BundleTracker;
1:7ffd760: import org.osgi.util.tracker.BundleTrackerCustomizer;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:f13c6ac: 
1:f13c6ac: /**
1:537d4ee:  * This is the blueprint extender that listens to blueprint bundles.  
1:8c4aa3a:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:6d7c26a: public class BlueprintExtender implements BundleActivator, BundleTrackerCustomizer, SynchronousBundleListener {
1:f13c6ac: 
1:7257be0:     /** The QuiesceParticipant implementation class name */
1:7257be0:     private static final String QUIESCE_PARTICIPANT_CLASS = "org.apache.aries.quiesce.participant.QuiesceParticipant";
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintExtender.class);
1:f13c6ac: 
1:f13c6ac:     private BundleContext context;
1:f13c6ac:     private ScheduledExecutorService executors;
1:3e11f4a:     private final ConcurrentMap<Bundle, BlueprintContainerImpl> containers = new ConcurrentHashMap<Bundle, BlueprintContainerImpl>();
1:3e11f4a:     private final ConcurrentMap<Bundle, FutureTask> destroying = new ConcurrentHashMap<Bundle, FutureTask>();
1:f13c6ac:     private BlueprintEventDispatcher eventDispatcher;
1:f13c6ac:     private NamespaceHandlerRegistry handlers;
1:ecf9333:     private Object bt;
1:3fa788c:     private ServiceRegistration parserServiceReg;
1:c18101e:     private ServiceRegistration blueprintServiceReg;
1:da163d0:     private ServiceRegistration quiesceParticipantReg;
1:4dfd2d8:     private SingleServiceTracker<ProxyManager> proxyManager;
1:3e11f4a:     private ExecutorServiceFinder executorServiceFinder;
1:3e11f4a:     private volatile boolean stopping;
1:3e11f4a: 
1:24455ce:     public void start(BundleContext ctx) {
1:f13c6ac:         LOGGER.debug("Starting blueprint extender...");
1:f13c6ac: 
1:24455ce:         this.context = ctx;
1:ecf9333:         boolean useSystemContext = Boolean.parseBoolean(ctx.getProperty("org.apache.aries.blueprint.use.system.context"));
1:ecf9333:         BundleContext trackingContext = useSystemContext ? ctx.getBundle(Constants.SYSTEM_BUNDLE_LOCATION).getBundleContext() : ctx;
1:f13c6ac: 
1:ecf9333:         handlers = new NamespaceHandlerRegistryImpl(trackingContext);
1:ef7b490:         executors = new ScheduledExecutorServiceWrapper(ctx, "Blueprint Extender", new ScheduledExecutorServiceFactory() {
1:ef7b490:           public ScheduledExecutorService create(String name)
1:ef7b490:           {
1:ef7b490:             return Executors.newScheduledThreadPool(3, new BlueprintThreadFactory(name));
1:f13c6ac:           }
1:ef7b490:         });
1:24455ce:         eventDispatcher = new BlueprintEventDispatcher(ctx, executors);
1:f13c6ac: 
1:6d7c26a:         // Ideally we'd want to only track STARTING and ACTIVE bundle, but this is not supported
1:6d7c26a:         // when using equinox composites.  This would ensure that no STOPPING event is lost while
1:6d7c26a:         // tracking the initial bundles. To work around this issue, we need to register
1:6d7c26a:         // a synchronous bundle listener that will ensure the stopping event will be correctly
1:6d7c26a:         // handled.
1:6d7c26a:         context.addBundleListener(this);
1:3e11f4a:         int mask = Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.STOPPING | Bundle.ACTIVE;
1:ecf9333:         bt = useSystemContext ? new BundleTracker(trackingContext, mask, this) : new  RecursiveBundleTracker(ctx, mask, this);
1:f13c6ac:         
1:24455ce:         proxyManager = new SingleServiceTracker<ProxyManager>(ctx, ProxyManager.class, new SingleServiceListener() {
1:24455ce:           public void serviceFound() {
1:24455ce:             LOGGER.debug("Found ProxyManager service, starting to process blueprint bundles");
1:ecf9333:             if (bt instanceof BundleTracker) {
1:ecf9333:             	((BundleTracker) bt).open();
1:ecf9333:             } else if (bt instanceof RecursiveBundleTracker) {
1:ecf9333:             	((RecursiveBundleTracker) bt).open();
1:f13c6ac:             }
1:f13c6ac:           }
1:24455ce:           public void serviceLost() {
1:6d7c26a:             while (!containers.isEmpty()) {
1:6d7c26a:               for (Bundle bundle : getBundlesToDestroy()) {
1:6d7c26a:                 destroyContainer(bundle);
1:6d7c26a:               }
1:6d7c26a:             }
1:ecf9333:             if (bt instanceof BundleTracker) {
1:ecf9333:             	((BundleTracker) bt).close();
1:ecf9333:             } else if (bt instanceof RecursiveBundleTracker) {
1:ecf9333:             	((RecursiveBundleTracker) bt).close();
1:f13c6ac:             }
1:f13c6ac:           }
1:24455ce:           public void serviceReplaced() {
1:f13c6ac:           }
1:f13c6ac:         });
1:24455ce:         proxyManager.open();
1:f13c6ac:         
1:3cfe3e2:         // Determine if the ParserService should ignore unknown namespace handlers
1:3cfe3e2:         boolean ignoreUnknownNamespaceHandlers = Boolean.parseBoolean(ctx.getProperty("org.apache.aries.blueprint.parser.service.ignore.unknown.namespace.handlers"));
1:3fa788c:         // Create and publish a ParserService
1:24455ce:         parserServiceReg = ctx.registerService(ParserService.class.getName(), 
1:3cfe3e2:             new ParserServiceImpl (handlers, ignoreUnknownNamespaceHandlers), 
1:3e11f4a:             new Hashtable<String, Object>());
1:f13c6ac: 
1:c18101e:         // Create and publish a BlueprintContainerService
1:c18101e:         blueprintServiceReg = ctx.registerService(
1:c18101e:                 BlueprintExtenderService.class.getName(),
1:c18101e:                 new BlueprintContainerServiceImpl(),
1:c18101e:                 new Hashtable<String, Object>());
1:ecf9333: 
1:da163d0:         try{
1:24455ce:             ctx.getBundle().loadClass(QUIESCE_PARTICIPANT_CLASS);
1:da163d0:             //Class was loaded, register
1:c18101e: 
1:24455ce:             quiesceParticipantReg = ctx.registerService(QUIESCE_PARTICIPANT_CLASS, 
1:24455ce:               new BlueprintQuiesceParticipant(ctx, this), 
1:3e11f4a:               new Hashtable<String, Object>());
1:f13c6ac:         } 
1:da163d0:         catch (ClassNotFoundException e) 
1:24455ce:         {
1:24455ce:             LOGGER.info("No quiesce support is available, so blueprint components will not participate in quiesce operations");
1:f13c6ac:         }
1:c18101e:         
1:f13c6ac:         LOGGER.debug("Blueprint extender started");
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void stop(BundleContext context) {
1:f13c6ac:         LOGGER.debug("Stopping blueprint extender...");
1:3e11f4a: 
1:3e11f4a:         stopping = true;
1:3e11f4a: 
1:047a2ae:         AriesFrameworkUtil.safeUnregisterService(parserServiceReg);
1:c18101e:         AriesFrameworkUtil.safeUnregisterService(blueprintServiceReg);
1:047a2ae:         AriesFrameworkUtil.safeUnregisterService(quiesceParticipantReg);
1:f13c6ac: 
1:f13c6ac:         // Orderly shutdown of containers
1:f13c6ac:         while (!containers.isEmpty()) {
1:f13c6ac:             for (Bundle bundle : getBundlesToDestroy()) {
3:3e11f4a:                 destroyContainer(bundle);
1:f13c6ac:             }
1:f13c6ac:         }
1:3e11f4a: 
1:ecf9333:         if (bt instanceof BundleTracker) {
1:ecf9333:         	((BundleTracker) bt).close();
1:ecf9333:         } else if (bt instanceof RecursiveBundleTracker) {
1:ecf9333:         	((RecursiveBundleTracker) bt).close();
1:f13c6ac:         }
1:3e11f4a:         proxyManager.close();
1:3e11f4a: 
1:f13c6ac:         this.eventDispatcher.destroy();
1:f13c6ac:         this.handlers.destroy();
1:f13c6ac:         executors.shutdown();
1:f13c6ac:         LOGGER.debug("Blueprint extender stopped");
1:f13c6ac:     }
1:3e11f4a: 
1:3e11f4a:     /*
1:6d7c26a:      * SynchronousBundleListener
1:6d7c26a:      */
1:6d7c26a: 
1:6d7c26a:     public void bundleChanged(BundleEvent event) {
1:6d7c26a:         Bundle bundle = event.getBundle();
1:6d7c26a:         if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
1:6d7c26a:             // The bundle is not in STARTING or ACTIVE state anymore
1:89cecf7:             // so destroy the context.  Ignore our own bundle since it
1:89cecf7:             // needs to kick the orderly shutdown and not unregister the namespaces.
1:89cecf7:             if (bundle != this.context.getBundle()) {
1:89cecf7:                 destroyContainer(bundle);
1:89cecf7:             }
1:89cecf7:         }
1:6d7c26a:     }
1:6d7c26a: 
1:6d7c26a:     /*
1:3e11f4a:      * BundleTrackerCustomizer
1:3e11f4a:      */
1:3e11f4a: 
1:3e11f4a:     public Object addingBundle(Bundle bundle, BundleEvent event) {
1:3e11f4a:         modifiedBundle(bundle, event, bundle);
1:3e11f4a:         return bundle;
1:3e11f4a:     }
1:3e11f4a: 
1:3e11f4a:     public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) {
1:ee634c7:         // If the bundle being stopped is the system bundle,
1:ee634c7:         // do an orderly shutdown of all blueprint contexts now
1:ee634c7:         // so that service usage can actually be useful
1:1c97579:         if (context.getBundle(0).equals(bundle) && bundle.getState() == Bundle.STOPPING) {
1:ee634c7:             String val = context.getProperty("org.apache.aries.blueprint.preemptiveShutdown");
1:ee634c7:             if (val == null || Boolean.parseBoolean(val)) {
1:ee634c7:                 stop(context);
1:ee634c7:                 return;
1:ee634c7:             }
1:ee634c7:         }
1:3e11f4a:         if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
1:3e11f4a:             // The bundle is not in STARTING or ACTIVE state anymore
1:89cecf7:             // so destroy the context.  Ignore our own bundle since it
1:89cecf7:             // needs to kick the orderly shutdown and not unregister the namespaces.
1:89cecf7:             if (bundle != this.context.getBundle()) {
1:89cecf7:                 destroyContainer(bundle);
1:6d7c26a:             }
1:6d7c26a:             return;
1:3e11f4a:         }
1:3e11f4a:         // Do not track bundles given we are stopping
1:3e11f4a:         if (stopping) {
2:3e11f4a:             return;
1:3e11f4a:         }
1:3e11f4a:         // For starting bundles, ensure, it's a lazy activation,
1:3e11f4a:         // else we'll wait for the bundle to become ACTIVE
1:3e11f4a:         if (bundle.getState() == Bundle.STARTING) {
1:3e11f4a:             String activationPolicyHeader = (String) bundle.getHeaders().get(Constants.BUNDLE_ACTIVATIONPOLICY);
1:3e11f4a:             if (activationPolicyHeader == null || !activationPolicyHeader.startsWith(Constants.ACTIVATION_LAZY)) {
1:3e11f4a:                 // Do not track this bundle yet
1:3e11f4a:                 return;
1:3e11f4a:             }
1:3e11f4a:         }
1:3e11f4a:         createContainer(bundle);
1:3e11f4a:     }
1:3e11f4a: 
1:3e11f4a:     public void removedBundle(Bundle bundle, BundleEvent event, Object object) {
1:3e11f4a:         // Nothing to do
1:6d7c26a:         destroyContainer(bundle);
1:3e11f4a:     }
1:3e11f4a: 
1:3e11f4a:     private boolean createContainer(Bundle bundle) {
1:3e11f4a:         List<Object> paths = getBlueprintPaths(bundle);
1:c18101e:         return createContainer(bundle, paths);
1:f13c6ac:     }
1:f13c6ac: 
1:c18101e:     private boolean createContainer(Bundle bundle, List<Object> paths) {
1:c89ef70:         return createContainer(bundle, paths, null);
1:c89ef70:     }
1:c89ef70: 
1:c89ef70:     private boolean createContainer(Bundle bundle, List<Object> paths, Collection<URI> namespaces) {
1:c89ef70:         try {
1:c18101e:             if (paths == null || paths.isEmpty()) {
1:3e11f4a:                 // This bundle is not a blueprint bundle, so ignore it
1:3e11f4a:                 return false;
1:3e11f4a:             }
1:6d7c26a:             ProxyManager pm = proxyManager.getService();
1:6d7c26a:             if (pm == null) {
1:6d7c26a:                 // The pm isn't available.  It may be because it is being untracked
1:6d7c26a:                 return false;
1:6d7c26a:             }
1:6d7c26a:             BundleContext bundleContext = bundle.getBundleContext();
1:6d7c26a:             if (bundleContext == null) {
1:6d7c26a:                 // The bundle has been stopped in the mean time
1:6d7c26a:                 return false;
1:6d7c26a:             }
1:6d7c26a:             BlueprintContainerImpl blueprintContainer = new BlueprintContainerImpl(bundle, bundleContext,
1:3e11f4a:                                                                 context.getBundle(), eventDispatcher,
1:3e11f4a:                                                                 handlers, getExecutorService(bundle),
1:c89ef70:                                                                 executors, paths, pm, namespaces);
1:3e11f4a:             synchronized (containers) {
1:3e11f4a:                 if (containers.putIfAbsent(bundle, blueprintContainer) != null) {
1:3e11f4a:                     return false;
1:3e11f4a:                 }
1:3e11f4a:             }
1:3e11f4a:             String val = context.getProperty("org.apache.aries.blueprint.synchronous");
1:3e11f4a:             if (Boolean.parseBoolean(val)) {
1:db4243b:                 LOGGER.debug("Starting creation of blueprint bundle {}/{} synchronously", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                 blueprintContainer.run();
1:3e11f4a:             } else {
1:db4243b:                 LOGGER.debug("Scheduling creation of blueprint bundle {}/{} asynchronously", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                 blueprintContainer.schedule();
1:3e11f4a:             }
1:3e11f4a:             return true;
1:3e11f4a:         } catch (Throwable t) {
1:db4243b:             LOGGER.warn("Error while creating blueprint container for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion(), t);
1:3e11f4a:             return false;
1:3e11f4a:         }
1:3e11f4a:     }
1:3e11f4a: 
1:3e11f4a:     private void destroyContainer(final Bundle bundle) {
1:3e11f4a:         FutureTask future;
1:3e11f4a:         synchronized (containers) {
1:db4243b:             LOGGER.debug("Starting BlueprintContainer destruction process for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:             future = destroying.get(bundle);
1:3e11f4a:             if (future == null) {
1:3e11f4a:                 final BlueprintContainerImpl blueprintContainer = containers.remove(bundle);
1:3e11f4a:                 if (blueprintContainer != null) {
1:db4243b:                     LOGGER.debug("Scheduling BlueprintContainer destruction for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                     future = new FutureTask<Void>(new Runnable() {
1:3e11f4a:                         public void run() {
1:db4243b:                             LOGGER.info("Destroying BlueprintContainer for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                             try {
1:3e11f4a:                                 blueprintContainer.destroy();
1:3e11f4a:                             } finally {
1:db4243b:                                 LOGGER.debug("Finished destroying BlueprintContainer for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                                 eventDispatcher.removeBlueprintBundle(bundle);
1:3e11f4a:                                 synchronized (containers) {
1:3e11f4a:                                     destroying.remove(bundle);
1:3e11f4a:                                 }
1:3e11f4a:                             }
1:3e11f4a:                         }
1:3e11f4a:                     }, null);
1:3e11f4a:                     destroying.put(bundle, future);
1:3e11f4a:                 } else {
1:db4243b:                     LOGGER.debug("Not a blueprint bundle or destruction of BlueprintContainer already finished for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                 }
1:3e11f4a:             } else {
1:db4243b:                 LOGGER.debug("Destruction already scheduled for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:             }
1:3e11f4a:         }
1:3e11f4a:         if (future != null) {
1:3e11f4a:             try {
1:db4243b:                 LOGGER.debug("Waiting for BlueprintContainer destruction for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                 future.run();
1:3e11f4a:                 future.get();
1:3e11f4a:             } catch (Throwable t) {
1:db4243b:                 LOGGER.warn("Error while destroying blueprint container for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion(), t);
1:3e11f4a:             }
1:3e11f4a:         }
1:3e11f4a:     }
1:3e11f4a: 
1:3e11f4a:     private List<Object> getBlueprintPaths(Bundle bundle) {
1:db4243b:         LOGGER.debug("Scanning bundle {}/{} for blueprint application", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:         try {
1:3e11f4a:             List<Object> pathList = new ArrayList<Object>();
1:3e11f4a:             String blueprintHeader = (String) bundle.getHeaders().get(BlueprintConstants.BUNDLE_BLUEPRINT_HEADER);
1:3e11f4a:             String blueprintHeaderAnnotation = (String) bundle.getHeaders().get(BlueprintConstants.BUNDLE_BLUEPRINT_ANNOTATION_HEADER);
1:3e11f4a:             if (blueprintHeader == null) {
1:3e11f4a:                 blueprintHeader = "OSGI-INF/blueprint/";
1:3e11f4a:             }
1:3e11f4a:             List<PathElement> paths = HeaderParser.parseHeader(blueprintHeader);
1:3e11f4a:             for (PathElement path : paths) {
1:3e11f4a:                 String name = path.getName();
1:3e11f4a:                 if (name.endsWith("/")) {
1:3e11f4a:                     addEntries(bundle, name, "*.xml", pathList);
1:3e11f4a:                 } else {
1:3e11f4a:                     String baseName;
1:3e11f4a:                     String filePattern;
1:3e11f4a:                     int pos = name.lastIndexOf('/');
1:3e11f4a:                     if (pos < 0) {
1:3e11f4a:                         baseName = "/";
1:3e11f4a:                         filePattern = name;
1:3e11f4a:                     } else {
1:3e11f4a:                         baseName = name.substring(0, pos + 1);
1:3e11f4a:                         filePattern = name.substring(pos + 1);
1:3e11f4a:                     }
1:3e11f4a:                     if (hasWildcards(filePattern)) {
1:3e11f4a:                         addEntries(bundle, baseName, filePattern, pathList);
1:3e11f4a:                     } else {
1:3e11f4a:                         addEntry(bundle, name, pathList);
1:3e11f4a:                     }
1:3e11f4a:                 }
1:3e11f4a:             }
1:3e11f4a:             // Check annotations
1:beb8062:             if (blueprintHeaderAnnotation != null && blueprintHeaderAnnotation.trim().equalsIgnoreCase("true")) {
1:db4243b:                 LOGGER.debug("Scanning bundle {}/{} for blueprint annotations", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                 ServiceReference sr = this.context.getServiceReference(BlueprintAnnotationScanner.class.getName());
1:3e11f4a:                 if (sr != null) {
1:3e11f4a:                     BlueprintAnnotationScanner bas = (BlueprintAnnotationScanner) this.context.getService(sr);
1:3e11f4a:                     try {
1:3e11f4a:                         // try to generate the blueprint definition XML
1:3e11f4a:                         URL url = bas.createBlueprintModel(bundle);
1:3e11f4a:                         if (url != null) {
1:3e11f4a:                             pathList.add(url);
1:3e11f4a:                         }
1:3e11f4a:                     } finally {
1:3e11f4a:                         this.context.ungetService(sr);
1:3e11f4a:                     }
1:3e11f4a:                 }
1:3e11f4a:             }
1:3e11f4a:             if (!pathList.isEmpty()) {
1:db4243b:                 LOGGER.debug("Found blueprint application in bundle {}/{} with paths: {}", bundle.getSymbolicName(), bundle.getVersion(), pathList);
1:3e11f4a:                 // Check compatibility
1:3e11f4a:                 // TODO: For lazy bundles, the class is either loaded from an imported package or not found, so it should
1:3e11f4a:                 // not trigger the activation.  If it does, we need to use something else like package admin or
1:3e11f4a:                 // ServiceReference, or just not do this check, which could be quite harmful.
1:3e11f4a:                 if (isCompatible(bundle)) {
1:3e11f4a:                     return pathList;
1:3e11f4a:                 } else {
1:db4243b:                     LOGGER.info("Bundle {}/{} is not compatible with this blueprint extender", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:                 }
1:3e11f4a:             } else {
1:db4243b:                 LOGGER.debug("No blueprint application found in bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:3e11f4a:             }
1:3e11f4a:         } catch (Throwable t) {
1:3e11f4a:             if (!stopping) {
1:db4243b:                 LOGGER.warn("Error creating blueprint container for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion(), t);
1:3e11f4a:                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, bundle, context.getBundle(), t));
1:3e11f4a:             }
1:3e11f4a:         }
1:3e11f4a:         return null;
1:3e11f4a:     }
1:3e11f4a: 
1:f13c6ac:     private List<Bundle> getBundlesToDestroy() {
1:f13c6ac:         List<Bundle> bundlesToDestroy = new ArrayList<Bundle>();
1:f13c6ac:         for (Bundle bundle : containers.keySet()) {
1:f13c6ac:             ServiceReference[] references = bundle.getRegisteredServices();
1:f13c6ac:             int usage = 0;
1:f13c6ac:             if (references != null) {
1:f13c6ac:                 for (ServiceReference reference : references) {
1:f13c6ac:                     usage += getServiceUsage(reference);
1:441c3a5:                 }
1:f13c6ac:             }
1:db4243b:             LOGGER.debug("Usage for bundle {}/{} is {}", bundle.getSymbolicName(), bundle.getVersion(), usage);
1:f13c6ac:             if (usage == 0) {
1:f13c6ac:                 bundlesToDestroy.add(bundle);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (!bundlesToDestroy.isEmpty()) {
1:f13c6ac:             Collections.sort(bundlesToDestroy, new Comparator<Bundle>() {
1:f13c6ac:                 public int compare(Bundle b1, Bundle b2) {
1:f13c6ac:                     return (int) (b2.getLastModified() - b1.getLastModified());
1:f13c6ac:                 }
1:24455ce:             });
1:db4243b:             if (LOGGER.isDebugEnabled()) {
1:db4243b:                 LOGGER.debug("Selected bundles {} for destroy (no services in use)", toString(bundlesToDestroy));
1:db4243b:             }
1:441c3a5:         } else {
1:f13c6ac:             ServiceReference ref = null;
1:f13c6ac:             for (Bundle bundle : containers.keySet()) {
1:f13c6ac:                 ServiceReference[] references = bundle.getRegisteredServices();
1:f13c6ac:                 for (ServiceReference reference : references) {
1:f13c6ac:                     if (getServiceUsage(reference) == 0) {
1:f13c6ac:                         continue;
1:f13c6ac:                     }
1:f13c6ac:                     if (ref == null || reference.compareTo(ref) < 0) {
1:db4243b:                         LOGGER.debug("Currently selecting bundle {}/{} for destroy (with reference {})", bundle.getSymbolicName(), bundle.getVersion(), reference);
1:f13c6ac:                         ref = reference;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:6d7c26a:             if (ref != null) {
1:6d7c26a:                 bundlesToDestroy.add(ref.getBundle());
1:6d7c26a:             }
1:db4243b:             if (LOGGER.isDebugEnabled()) {
1:db4243b:                 LOGGER.debug("Selected bundles {} for destroy (lowest ranking service)", toString(bundlesToDestroy));
1:db4243b:             }
1:f13c6ac:         }
1:f13c6ac:         return bundlesToDestroy;
1:f13c6ac:     }
1:f13c6ac: 
1:db4243b:     private static String toString(List<Bundle> bundles) {
1:db4243b:         StringBuilder sb = new StringBuilder();
1:db4243b:         sb.append("[");
1:db4243b:         for (int i = 0; i < bundles.size(); i++) {
1:db4243b:             if (i > 0) {
1:db4243b:                 sb.append(", ");
1:db4243b:             }
1:db4243b:             sb.append(bundles.get(i).getSymbolicName());
1:db4243b:             sb.append("/");
1:db4243b:             sb.append(bundles.get(i).getVersion());
1:db4243b:         }
1:db4243b:         sb.append("]");
1:db4243b:         return sb.toString();
1:db4243b:     }
1:db4243b: 
1:f13c6ac:     private static int getServiceUsage(ServiceReference ref) {
1:f13c6ac:         Bundle[] usingBundles = ref.getUsingBundles();
1:3e11f4a:         return (usingBundles != null) ? usingBundles.length : 0;
1:f13c6ac:     }
1:3e11f4a: 
1:3e11f4a:     private ExecutorService getExecutorService(Bundle bundle) {
1:3e11f4a:         if (executorServiceFinder != null) {
1:3e11f4a:             return executorServiceFinder.find(bundle);
1:3e11f4a:         } else {
1:3e11f4a:             return executors;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:3e11f4a:     interface ExecutorServiceFinder {
1:f13c6ac: 
1:3e11f4a:         public ExecutorService find( Bundle bundle );
1:3e11f4a: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private boolean isCompatible(Bundle bundle) {
2:f13c6ac:         // Check compatibility
1:f13c6ac:         boolean compatible;
1:f13c6ac:         if (bundle.getState() == Bundle.ACTIVE) {
1:3e11f4a:             try {
1:24455ce:                 Class<?> clazz = bundle.getBundleContext().getBundle().loadClass(BlueprintContainer.class.getName());
1:f13c6ac:                 compatible = (clazz == BlueprintContainer.class);
1:f13c6ac:             } catch (ClassNotFoundException e) {
1:f13c6ac:                 compatible = true;
1:f13c6ac:             }
3:f13c6ac:         } else {
1:f13c6ac:             // for lazy bundle, we can't load the class, so just assume it's ok
1:f13c6ac:             compatible = true;
1:f13c6ac:         }
1:f13c6ac:         return compatible;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private boolean hasWildcards(String path) {
1:f13c6ac:         return path.indexOf("*") >= 0; 
1:f13c6ac:     }
1:f13c6ac:     
1:4ae0bfc:     private String getFilePart(URL url) {
1:4ae0bfc:         String path = url.getPath();
1:4ae0bfc:         int index = path.lastIndexOf('/');
1:4ae0bfc:         return path.substring(index + 1);
1:f13c6ac:     }
1:ef7b490:     
1:4ae0bfc:     private String cachePath(Bundle bundle, String filePath)
1:da163d0:     {
1:97adf4b:       return Integer.toHexString(bundle.hashCode()) + "/" + filePath;
1:f13c6ac:     }    
1:24455ce:     
1:4ae0bfc:     private URL getOverrideURLForCachePath(String privatePath){
1:4ae0bfc:         URL override = null;
1:4ae0bfc:         File privateDataVersion = context.getDataFile(privatePath);
1:4ae0bfc:         if (privateDataVersion != null
1:4ae0bfc:                 && privateDataVersion.exists()) {
2:f13c6ac:             try {
1:8c4aa3a:                 override = privateDataVersion.toURI().toURL();
1:4ae0bfc:             } catch (MalformedURLException e) {
1:4ae0bfc:                 LOGGER.error("Unexpected URL Conversion Issue", e);
1:f13c6ac:             }
1:f13c6ac:         }
1:4ae0bfc:         return override;
1:f13c6ac:     }
1:24455ce:     
1:4ae0bfc:     private URL getOverrideURL(Bundle bundle, String path){
1:4ae0bfc:         String cachePath = cachePath(bundle, path);
1:4ae0bfc:         return getOverrideURLForCachePath(cachePath);
1:ecf9333:     }
1:24455ce:     
1:4ae0bfc:     private URL getOverrideURL(Bundle bundle, URL path, String basePath){
1:4ae0bfc:         String cachePath = cachePath(bundle, basePath + getFilePart(path));
1:4ae0bfc:         return getOverrideURLForCachePath(cachePath);
1:ecf9333:     }    
1:24455ce:     
1:f13c6ac:     private void addEntry(Bundle bundle, String path, List<Object> pathList) {
1:4ae0bfc:         URL override = getOverrideURL(bundle, path);
1:4ae0bfc:         if(override == null) {
1:f13c6ac:             pathList.add(path);
1:f13c6ac:         } else {
1:4ae0bfc:             pathList.add(override);
1:f13c6ac:         }
1:ecf9333:     }
1:f13c6ac:     
1:f13c6ac:     private void addEntries(Bundle bundle, String path, String filePattern, List<Object> pathList) {
1:24455ce:         Enumeration<?> e = bundle.findEntries(path, filePattern, false);
1:f13c6ac:         while (e != null && e.hasMoreElements()) {
1:f13c6ac:             URL u = (URL) e.nextElement();
1:4ae0bfc:             URL override = getOverrideURL(bundle, u, path);
1:4ae0bfc:             if(override == null) {
1:f13c6ac:                 pathList.add(u);
1:f13c6ac:             } else {
1:4ae0bfc:                 pathList.add(override);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:047a2ae:     
1:da163d0:     protected BlueprintContainerImpl getBlueprintContainerImpl(Bundle bundle)
1:da163d0:     {
1:8c4aa3a:         return containers.get(bundle);
1:c18101e:     }
1:c18101e: 
1:c18101e:     private class BlueprintContainerServiceImpl implements BlueprintExtenderService {
1:c18101e: 
1:c18101e:         public BlueprintContainer createContainer(Bundle bundle) {
1:c18101e:             if (BlueprintExtender.this.createContainer(bundle)) {
1:c18101e:                 return getContainer(bundle);
1:f13c6ac:             } else {
1:c18101e:                 return null;
1:c18101e:             }
1:c18101e:         }
1:c18101e: 
1:c18101e:         public BlueprintContainer createContainer(Bundle bundle, List<Object> blueprintPaths) {
1:c18101e:             if (BlueprintExtender.this.createContainer(bundle, blueprintPaths)) {
1:c18101e:                 return getContainer(bundle);
1:f13c6ac:             } else {
1:c18101e:                 return null;
1:c18101e:             }
1:c18101e:         }
1:c18101e: 
1:c89ef70:         public BlueprintContainer createContainer(Bundle bundle, List<Object> blueprintPaths, Collection<URI> namespaces) {
1:c89ef70:             if (BlueprintExtender.this.createContainer(bundle, blueprintPaths, namespaces)) {
1:c89ef70:                 return getContainer(bundle);
1:c89ef70:             } else {
1:c89ef70:                 return null;
1:c89ef70:             }
1:c89ef70:         }
1:c89ef70: 
1:c18101e:         public void destroyContainer(Bundle bundle, BlueprintContainer container) {
1:c18101e:             BlueprintContainer bundleContainer = getContainer(bundle);
1:c18101e:             if (bundleContainer != container) {
1:c18101e:                 String error = "Unexpected Blueprint Container";
1:c18101e:                 LOGGER.error(error);
1:c18101e:                 throw new IllegalArgumentException(error);
1:c18101e:             }
1:c18101e:             BlueprintExtender.this.destroyContainer(bundle);
1:c18101e:         }
1:c18101e: 
1:c18101e:         public BlueprintContainer getContainer(Bundle bundle) {
1:c18101e:             return BlueprintExtender.this.getBlueprintContainerImpl(bundle);
1:c18101e:         }
1:c18101e: 
1:c18101e:     }
2:da163d0:     
1:ef7b490: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:c89ef70
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:         return createContainer(bundle, paths, null);
1:     }
1: 
1:     private boolean createContainer(Bundle bundle, List<Object> paths, Collection<URI> namespaces) {
1:         try {
/////////////////////////////////////////////////////////////////////////
1:                                                                 executors, paths, pm, namespaces);
/////////////////////////////////////////////////////////////////////////
1:         public BlueprintContainer createContainer(Bundle bundle, List<Object> blueprintPaths, Collection<URI> namespaces) {
1:             if (BlueprintExtender.this.createContainer(bundle, blueprintPaths, namespaces)) {
1:                 return getContainer(bundle);
1:             } else {
1:                 return null;
1:             }
1:         }
1: 
commit:db4243b
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.debug("Starting creation of blueprint bundle {}/{} synchronously", bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.debug("Scheduling creation of blueprint bundle {}/{} asynchronously", bundle.getSymbolicName(), bundle.getVersion());
1:             LOGGER.warn("Error while creating blueprint container for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion(), t);
/////////////////////////////////////////////////////////////////////////
1:             LOGGER.debug("Starting BlueprintContainer destruction process for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:                     LOGGER.debug("Scheduling BlueprintContainer destruction for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:                             LOGGER.info("Destroying BlueprintContainer for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:                                 LOGGER.debug("Finished destroying BlueprintContainer for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
/////////////////////////////////////////////////////////////////////////
1:                     LOGGER.debug("Not a blueprint bundle or destruction of BlueprintContainer already finished for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.debug("Destruction already scheduled for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.debug("Waiting for BlueprintContainer destruction for {}/{}.", bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.warn("Error while destroying blueprint container for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion(), t);
1:         LOGGER.debug("Scanning bundle {}/{} for blueprint application", bundle.getSymbolicName(), bundle.getVersion());
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.debug("Scanning bundle {}/{} for blueprint annotations", bundle.getSymbolicName(), bundle.getVersion());
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.debug("Found blueprint application in bundle {}/{} with paths: {}", bundle.getSymbolicName(), bundle.getVersion(), pathList);
/////////////////////////////////////////////////////////////////////////
1:                     LOGGER.info("Bundle {}/{} is not compatible with this blueprint extender", bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.debug("No blueprint application found in bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion());
1:                 LOGGER.warn("Error creating blueprint container for bundle {}/{}", bundle.getSymbolicName(), bundle.getVersion(), t);
/////////////////////////////////////////////////////////////////////////
1:             LOGGER.debug("Usage for bundle {}/{} is {}", bundle.getSymbolicName(), bundle.getVersion(), usage);
/////////////////////////////////////////////////////////////////////////
1:             if (LOGGER.isDebugEnabled()) {
1:                 LOGGER.debug("Selected bundles {} for destroy (no services in use)", toString(bundlesToDestroy));
1:             }
/////////////////////////////////////////////////////////////////////////
1:                         LOGGER.debug("Currently selecting bundle {}/{} for destroy (with reference {})", bundle.getSymbolicName(), bundle.getVersion(), reference);
/////////////////////////////////////////////////////////////////////////
1:             if (LOGGER.isDebugEnabled()) {
1:                 LOGGER.debug("Selected bundles {} for destroy (lowest ranking service)", toString(bundlesToDestroy));
1:             }
1:     private static String toString(List<Bundle> bundles) {
1:         StringBuilder sb = new StringBuilder();
1:         sb.append("[");
1:         for (int i = 0; i < bundles.size(); i++) {
1:             if (i > 0) {
1:                 sb.append(", ");
1:             }
1:             sb.append(bundles.get(i).getSymbolicName());
1:             sb.append("/");
1:             sb.append(bundles.get(i).getVersion());
1:         }
1:         sb.append("]");
1:         return sb.toString();
1:     }
1: 
commit:beb8062
/////////////////////////////////////////////////////////////////////////
1:             if (blueprintHeaderAnnotation != null && blueprintHeaderAnnotation.trim().equalsIgnoreCase("true")) {
commit:89cecf7
/////////////////////////////////////////////////////////////////////////
1:             // so destroy the context.  Ignore our own bundle since it
1:             // needs to kick the orderly shutdown and not unregister the namespaces.
1:             if (bundle != this.context.getBundle()) {
1:                 destroyContainer(bundle);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             // so destroy the context.  Ignore our own bundle since it
1:             // needs to kick the orderly shutdown and not unregister the namespaces.
1:             if (bundle != this.context.getBundle()) {
1:                 destroyContainer(bundle);
1:             }
commit:ee634c7
/////////////////////////////////////////////////////////////////////////
1:         // If the bundle being stopped is the system bundle,
1:         // do an orderly shutdown of all blueprint contexts now
1:         // so that service usage can actually be useful
0:         if (bundle.getBundleId() == 0 && bundle.getState() == Bundle.STOPPING) {
1:             String val = context.getProperty("org.apache.aries.blueprint.preemptiveShutdown");
1:             if (val == null || Boolean.parseBoolean(val)) {
1:                 stop(context);
1:                 return;
1:             }
1:         }
commit:6d7c26a
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.SynchronousBundleListener;
/////////////////////////////////////////////////////////////////////////
1: public class BlueprintExtender implements BundleActivator, BundleTrackerCustomizer, SynchronousBundleListener {
/////////////////////////////////////////////////////////////////////////
1:         // Ideally we'd want to only track STARTING and ACTIVE bundle, but this is not supported
1:         // when using equinox composites.  This would ensure that no STOPPING event is lost while
1:         // tracking the initial bundles. To work around this issue, we need to register
1:         // a synchronous bundle listener that will ensure the stopping event will be correctly
1:         // handled.
1:         context.addBundleListener(this);
/////////////////////////////////////////////////////////////////////////
1:             while (!containers.isEmpty()) {
1:               for (Bundle bundle : getBundlesToDestroy()) {
1:                 destroyContainer(bundle);
1:               }
1:             }
0:             bt.close();
/////////////////////////////////////////////////////////////////////////
1:      * SynchronousBundleListener
1:      */
1: 
1:     public void bundleChanged(BundleEvent event) {
1:         Bundle bundle = event.getBundle();
1:         if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
1:             // The bundle is not in STARTING or ACTIVE state anymore
0:             // so destroy the context
1:             destroyContainer(bundle);
1:             return;
1:         }
1:     }
1: 
1:     /*
/////////////////////////////////////////////////////////////////////////
1:             ProxyManager pm = proxyManager.getService();
1:             if (pm == null) {
1:                 // The pm isn't available.  It may be because it is being untracked
1:                 return false;
1:             }
1:             BundleContext bundleContext = bundle.getBundleContext();
1:             if (bundleContext == null) {
1:                 // The bundle has been stopped in the mean time
1:                 return false;
1:             }
1:             BlueprintContainerImpl blueprintContainer = new BlueprintContainerImpl(bundle, bundleContext,
0:                                                                 executors, paths, pm);
/////////////////////////////////////////////////////////////////////////
1:             if (ref != null) {
1:                 bundlesToDestroy.add(ref.getBundle());
1:             }
commit:3e11f4a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class BlueprintExtender implements BundleActivator, BundleTrackerCustomizer {
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<Bundle, BlueprintContainerImpl> containers = new ConcurrentHashMap<Bundle, BlueprintContainerImpl>();
1:     private final ConcurrentMap<Bundle, FutureTask> destroying = new ConcurrentHashMap<Bundle, FutureTask>();
1:     private ExecutorServiceFinder executorServiceFinder;
1:     private volatile boolean stopping;
1: 
/////////////////////////////////////////////////////////////////////////
1:         int mask = Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.STOPPING | Bundle.ACTIVE;
0:         bt = new RecursiveBundleTracker(ctx, mask, this);
/////////////////////////////////////////////////////////////////////////
1:             new Hashtable<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:               new Hashtable<String, Object>());
/////////////////////////////////////////////////////////////////////////
1: 
1:         stopping = true;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 destroyContainer(bundle);
1: 
0:         bt.close();
1:         proxyManager.close();
1: 
1: 
1:     /*
1:      * BundleTrackerCustomizer
1:      */
1: 
1:     public Object addingBundle(Bundle bundle, BundleEvent event) {
1:         modifiedBundle(bundle, event, bundle);
1:         return bundle;
1:     }
1: 
1:     public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) {
1:         if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
1:             // The bundle is not in STARTING or ACTIVE state anymore
0:             // so destroy the context
1:             destroyContainer(bundle);
1:             return;
1:         }
1:         // Do not track bundles given we are stopping
1:         if (stopping) {
1:             return;
1:         }
1:         // For starting bundles, ensure, it's a lazy activation,
1:         // else we'll wait for the bundle to become ACTIVE
1:         if (bundle.getState() == Bundle.STARTING) {
1:             String activationPolicyHeader = (String) bundle.getHeaders().get(Constants.BUNDLE_ACTIVATIONPOLICY);
1:             if (activationPolicyHeader == null || !activationPolicyHeader.startsWith(Constants.ACTIVATION_LAZY)) {
1:                 // Do not track this bundle yet
1:                 return;
1:             }
1:         }
1:         createContainer(bundle);
1:     }
1: 
1:     public void removedBundle(Bundle bundle, BundleEvent event, Object object) {
1:         // Nothing to do
1:         destroyContainer(bundle);
1:     }
1: 
1:     private boolean createContainer(Bundle bundle) {
1:         try {
1:             List<Object> paths = getBlueprintPaths(bundle);
0:             if (paths == null) {
1:                 // This bundle is not a blueprint bundle, so ignore it
1:                 return false;
1:             }
0:             BlueprintContainerImpl blueprintContainer = new BlueprintContainerImpl(bundle.getBundleContext(),
1:                                                                 context.getBundle(), eventDispatcher,
1:                                                                 handlers, getExecutorService(bundle),
0:                                                                 executors, paths,
0:                                                                 proxyManager.getService());
1:             synchronized (containers) {
1:                 if (containers.putIfAbsent(bundle, blueprintContainer) != null) {
1:                     return false;
1:                 }
1:             }
1:             String val = context.getProperty("org.apache.aries.blueprint.synchronous");
1:             if (Boolean.parseBoolean(val)) {
0:                 LOGGER.debug("Starting creation of blueprint bundle {} synchronously", bundle.getSymbolicName());
1:                 blueprintContainer.run();
1:             } else {
0:                 LOGGER.debug("Scheduling creation of blueprint bundle {} asynchronously", bundle.getSymbolicName());
1:                 blueprintContainer.schedule();
1:             }
1:             return true;
1:         } catch (Throwable t) {
0:             LOGGER.warn("Error while creating blueprint container for bundle " + bundle, t);
1:             return false;
1:         }
1:     }
1: 
1:     private void destroyContainer(final Bundle bundle) {
1:         FutureTask future;
1:         synchronized (containers) {
0:             LOGGER.debug("Starting BlueprintContainer destruction process for bundle {}", bundle.getSymbolicName());
1:             future = destroying.get(bundle);
1:             if (future == null) {
1:                 final BlueprintContainerImpl blueprintContainer = containers.remove(bundle);
1:                 if (blueprintContainer != null) {
0:                     LOGGER.debug("Scheduling BlueprintContainer destruction for {}.", bundle.getSymbolicName());
1:                     future = new FutureTask<Void>(new Runnable() {
1:                         public void run() {
0:                             LOGGER.info("Destroying BlueprintContainer for bundle {}", bundle.getSymbolicName());
1:                             try {
1:                                 blueprintContainer.destroy();
1:                             } finally {
0:                                 LOGGER.debug("Finished destroying BlueprintContainer for bundle {}", bundle.getSymbolicName());
1:                                 eventDispatcher.removeBlueprintBundle(bundle);
1:                                 synchronized (containers) {
1:                                     destroying.remove(bundle);
1:                                 }
1:                             }
1:                         }
1:                     }, null);
1:                     destroying.put(bundle, future);
1:                 } else {
0:                     LOGGER.debug("Not a blueprint bundle or destruction of BlueprintContainer already finished for {}.", bundle.getSymbolicName());
1:                 }
1:             } else {
0:                 LOGGER.debug("Destruction already scheduled for {}.", bundle.getSymbolicName());
1:             }
1:         }
1:         if (future != null) {
1:             try {
0:                 LOGGER.debug("Waiting for BlueprintContainer destruction for {}.", bundle.getSymbolicName());
1:                 future.run();
1:                 future.get();
1:             } catch (Throwable t) {
0:                 LOGGER.warn("Error while destroying blueprint container for bundle " + bundle, t);
1:             }
1:         }
1:     }
1: 
1:     private List<Object> getBlueprintPaths(Bundle bundle) {
0:         LOGGER.debug("Scanning bundle {} for blueprint application", bundle.getSymbolicName());
1:         try {
1:             List<Object> pathList = new ArrayList<Object>();
1:             String blueprintHeader = (String) bundle.getHeaders().get(BlueprintConstants.BUNDLE_BLUEPRINT_HEADER);
1:             String blueprintHeaderAnnotation = (String) bundle.getHeaders().get(BlueprintConstants.BUNDLE_BLUEPRINT_ANNOTATION_HEADER);
1:             if (blueprintHeader == null) {
1:                 blueprintHeader = "OSGI-INF/blueprint/";
1:             }
1:             List<PathElement> paths = HeaderParser.parseHeader(blueprintHeader);
1:             for (PathElement path : paths) {
1:                 String name = path.getName();
1:                 if (name.endsWith("/")) {
1:                     addEntries(bundle, name, "*.xml", pathList);
1:                 } else {
1:                     String baseName;
1:                     String filePattern;
1:                     int pos = name.lastIndexOf('/');
1:                     if (pos < 0) {
1:                         baseName = "/";
1:                         filePattern = name;
1:                     } else {
1:                         baseName = name.substring(0, pos + 1);
1:                         filePattern = name.substring(pos + 1);
1:                     }
1:                     if (hasWildcards(filePattern)) {
1:                         addEntries(bundle, baseName, filePattern, pathList);
1:                     } else {
1:                         addEntry(bundle, name, pathList);
1:                     }
1:                 }
1:             }
1:             // Check annotations
0:             if (pathList.isEmpty() && blueprintHeaderAnnotation != null && blueprintHeaderAnnotation.trim().equalsIgnoreCase("true")) {
0:                 LOGGER.debug("Scanning bundle {} for blueprint annotations", bundle.getSymbolicName());
1:                 ServiceReference sr = this.context.getServiceReference(BlueprintAnnotationScanner.class.getName());
1:                 if (sr != null) {
1:                     BlueprintAnnotationScanner bas = (BlueprintAnnotationScanner) this.context.getService(sr);
1:                     try {
1:                         // try to generate the blueprint definition XML
1:                         URL url = bas.createBlueprintModel(bundle);
1:                         if (url != null) {
1:                             pathList.add(url);
1:                         }
1:                     } finally {
1:                         this.context.ungetService(sr);
1:                     }
1:                 }
1:             }
1:             if (!pathList.isEmpty()) {
0:                 LOGGER.debug("Found blueprint application in bundle {} with paths: {}", bundle.getSymbolicName(), pathList);
1:                 // Check compatibility
1:                 // TODO: For lazy bundles, the class is either loaded from an imported package or not found, so it should
1:                 // not trigger the activation.  If it does, we need to use something else like package admin or
1:                 // ServiceReference, or just not do this check, which could be quite harmful.
1:                 if (isCompatible(bundle)) {
1:                     return pathList;
1:                 } else {
0:                     LOGGER.info("Bundle {} is not compatible with this blueprint extender", bundle.getSymbolicName());
1:                 }
1:             } else {
0:                 LOGGER.debug("No blueprint application found in bundle {}", bundle.getSymbolicName());
1:             }
1:         } catch (Throwable t) {
1:             if (!stopping) {
0:                 LOGGER.warn("Error creating blueprint container for bundle " + bundle.getSymbolicName(), t);
1:                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, bundle, context.getBundle(), t));
1:             }
1:         }
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return (usingBundles != null) ? usingBundles.length : 0;
1: 
1:     private ExecutorService getExecutorService(Bundle bundle) {
1:         if (executorServiceFinder != null) {
1:             return executorServiceFinder.find(bundle);
1:         } else {
1:             return executors;
1:     interface ExecutorServiceFinder {
1:         public ExecutorService find( Bundle bundle );
1: 
/////////////////////////////////////////////////////////////////////////
commit:e424950
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:         containers = new ConcurrentHashMap<Bundle, BlueprintContainerImpl>();
commit:4dfd2d8
/////////////////////////////////////////////////////////////////////////
1:     private SingleServiceTracker<ProxyManager> proxyManager;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     final BlueprintContainerImpl blueprintContainer = new BlueprintContainerImpl(bundle.getBundleContext(), context.getBundle(), eventDispatcher, handlers, executors, pathList, proxyManager.getService());
commit:441c3a5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     String val = context.getProperty("org.apache.aries.blueprint.synchronous");
0:                     if (Boolean.parseBoolean(val)) {
0:                         LOGGER.debug("Starting creation of blueprint bundle {} synchronously", bundle.getSymbolicName());
0:                         blueprintContainer.run();
1:                     } else {
0:                         LOGGER.debug("Scheduling creation of blueprint bundle {} asynchronously", bundle.getSymbolicName());
0:                         blueprintContainer.schedule();
1:                     }
commit:8c4aa3a
/////////////////////////////////////////////////////////////////////////
0:      * bundle tracker is opened.
1:      *
0:      * @param b the bundle to check
/////////////////////////////////////////////////////////////////////////
1:                 override = privateDataVersion.toURI().toURL();
/////////////////////////////////////////////////////////////////////////
1:     	return containers.get(bundle);
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.Comparator;
1: import java.util.Enumeration;
0: import java.util.HashMap;
1: import java.util.List;
0: import java.util.Map;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.ScheduledExecutorService;
1: 
0: import org.apache.geronimo.blueprint.BlueprintConstants;
0: import org.apache.geronimo.blueprint.namespace.NamespaceHandlerRegistryImpl;
0: import org.apache.geronimo.blueprint.utils.HeaderParser;
0: import org.apache.geronimo.blueprint.utils.HeaderParser.PathElement;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleActivator;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleEvent;
1: import org.osgi.framework.Constants;
0: import org.osgi.framework.SynchronousBundleListener;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.blueprint.container.BlueprintContainer;
1: import org.osgi.service.blueprint.container.BlueprintEvent;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
0:  * TODO: javadoc
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
0: public class BlueprintExtender implements BundleActivator, SynchronousBundleListener {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintExtender.class);
1: 
1:     private BundleContext context;
1:     private ScheduledExecutorService executors;
0:     private Map<Bundle, BlueprintContainerImpl> containers;
1:     private BlueprintEventDispatcher eventDispatcher;
1:     private NamespaceHandlerRegistry handlers;
1: 
0:     public void start(BundleContext context) {
1:         LOGGER.debug("Starting blueprint extender...");
1: 
0:         this.context = context;
0:         eventDispatcher = new BlueprintEventDispatcher(context);
0:         handlers = new NamespaceHandlerRegistryImpl(context);
0:         executors = Executors.newScheduledThreadPool(3);
0:         containers = new HashMap<Bundle, BlueprintContainerImpl>();
1: 
0:         context.addBundleListener(this);
1: 
0:         Bundle[] bundles = context.getBundles();
0:         for (Bundle b : bundles) {
0:             // If the bundle is active, check it
0:             if (b.getState() == Bundle.ACTIVE) {
0:                 checkBundle(b);
0:             // Also check bundles in the starting state with a lazy activation policy
0:             } else if (b.getState() == Bundle.STARTING) {
0:                 String activationPolicyHeader = (String) b.getHeaders().get(Constants.BUNDLE_ACTIVATIONPOLICY);
0:                 if (activationPolicyHeader != null && activationPolicyHeader.startsWith(Constants.ACTIVATION_LAZY)) {
0:                     checkBundle(b);
1:                 }
1:             }
1:         }
1:         LOGGER.debug("Blueprint extender started");
1:     }
1: 
1: 
1:     public void stop(BundleContext context) {
1:         LOGGER.debug("Stopping blueprint extender...");
0:         context.removeBundleListener(this);
1:         // Orderly shutdown of containers
1:         while (!containers.isEmpty()) {
1:             for (Bundle bundle : getBundlesToDestroy()) {
0:                 destroyContext(bundle);
1:             }
1:         }
1:         this.eventDispatcher.destroy();
1:         this.handlers.destroy();
1:         executors.shutdown();
1:         LOGGER.debug("Blueprint extender stopped");
1:     }
1: 
1:     private List<Bundle> getBundlesToDestroy() {
1:         List<Bundle> bundlesToDestroy = new ArrayList<Bundle>();
1:         for (Bundle bundle : containers.keySet()) {
1:             ServiceReference[] references = bundle.getRegisteredServices();
1:             int usage = 0;
1:             if (references != null) {
1:                 for (ServiceReference reference : references) {
1:                     usage += getServiceUsage(reference);
1:                 }
1:             }
0:             LOGGER.debug("Usage for bundle {} is {}", bundle, usage);
1:             if (usage == 0) {
1:                 bundlesToDestroy.add(bundle);
1:             }
1:         }
1:         if (!bundlesToDestroy.isEmpty()) {
1:             Collections.sort(bundlesToDestroy, new Comparator<Bundle>() {
1:                 public int compare(Bundle b1, Bundle b2) {
1:                     return (int) (b2.getLastModified() - b1.getLastModified());
1:                 }
1:             });
0:             LOGGER.debug("Selected bundles {} for destroy (no services in use)", bundlesToDestroy);
1:         } else {
1:             ServiceReference ref = null;
1:             for (Bundle bundle : containers.keySet()) {
1:                 ServiceReference[] references = bundle.getRegisteredServices();
1:                 for (ServiceReference reference : references) {
1:                     if (getServiceUsage(reference) == 0) {
1:                         continue;
1:                     }
1:                     if (ref == null || reference.compareTo(ref) < 0) {
0:                         LOGGER.debug("Currently selecting bundle {} for destroy (with reference {})", bundle, reference);
1:                         ref = reference;
1:                     }
1:                 }
1:             }
0:             bundlesToDestroy.add(ref.getBundle());
0:             LOGGER.debug("Selected bundle {} for destroy (lowest ranking service)", bundlesToDestroy);
1:         }
1:         return bundlesToDestroy;
1:     }
1: 
1:     private static int getServiceUsage(ServiceReference ref) {
1:         Bundle[] usingBundles = ref.getUsingBundles();
0:         return (usingBundles != null) ? usingBundles.length : 0;        
1:     }
1:     
0:     public void bundleChanged(BundleEvent event) {
0:         Bundle bundle = event.getBundle();
0:         if (event.getType() == BundleEvent.LAZY_ACTIVATION) {
0:             checkBundle(bundle);
0:         } else if (event.getType() == BundleEvent.STARTED) {
0:             BlueprintContainerImpl blueprintContainer = containers.get(bundle);
0:             if (blueprintContainer == null) {
0:                 checkBundle(bundle);
1:             }
0:         } else if (event.getType() == BundleEvent.STOPPING) {
0:             destroyContext(bundle);
1:         }
1:     }
1: 
0:     private void destroyContext(Bundle bundle) {
0:         BlueprintContainerImpl blueprintContainer = containers.remove(bundle);
0:         if (blueprintContainer != null) {
0:             LOGGER.debug("Destroying BlueprintContainer for bundle {}", bundle.getSymbolicName());
0:             blueprintContainer.destroy();
0:             eventDispatcher.contextDestroyed(bundle);
1:         }
1:     }
1:     
0:     private void checkBundle(Bundle bundle) {
0:         LOGGER.debug("Scanning bundle {} for blueprint application", bundle.getSymbolicName());
1:         try {
0:             List<Object> pathList = new ArrayList<Object>();
0:             String blueprintHeader = (String) bundle.getHeaders().get(BlueprintConstants.BUNDLE_BLUEPRINT_HEADER);
0:             if (blueprintHeader == null) {
0:                 blueprintHeader = "OSGI-INF/blueprint/";
1:             } 
0:             List<PathElement> paths = HeaderParser.parseHeader(blueprintHeader);
0:             for (PathElement path : paths) {
0:                 String name = path.getName();
0:                 if (name.endsWith("/")) {
0:                     addEntries(bundle, name, "*.xml", pathList);
1:                 } else {
0:                     String baseName;
0:                     String filePattern;
0:                     int pos = name.lastIndexOf('/');
0:                     if (pos < 0) {
0:                         baseName = "/";
0:                         filePattern = name;
1:                     } else {
0:                         baseName = name.substring(0, pos + 1);
0:                         filePattern = name.substring(pos + 1);
1:                     }
0:                     if (hasWildcards(filePattern)) {
0:                         addEntries(bundle, baseName, filePattern, pathList);
1:                     } else {
0:                         addEntry(bundle, name, pathList);
1:                     }                    
1:                 }
1:             }            
0:             if (!pathList.isEmpty()) {
0:                 LOGGER.debug("Found blueprint application in bundle {} with paths: {}", bundle.getSymbolicName(), pathList);
1:                 // Check compatibility
0:                 // TODO: For lazy bundles, the class is either loaded from an imported package or not found, so it should
0:                 // not trigger the activation.  If it does, we need to use something else like package admin or
0:                 // ServiceReference, or just not do this check, which could be quite harmful.
0:                 boolean compatible = isCompatible(bundle);
0:                 if (compatible) {
0:                     final BlueprintContainerImpl blueprintContainer = new BlueprintContainerImpl(bundle.getBundleContext(), context.getBundle(), eventDispatcher, handlers, executors, pathList);
0:                     containers.put(bundle, blueprintContainer);
0:                     blueprintContainer.schedule();
1:                 } else {
0:                     LOGGER.info("Bundle {} is not compatible with this blueprint extender", bundle.getSymbolicName());
1:                 }
1: 
1:             } else {
0:                 LOGGER.debug("No blueprint application found in bundle {}", bundle.getSymbolicName());
1:             }
0:         } catch (Throwable t) {
0:             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, bundle, context.getBundle(), t));
1:         }
1:     }
1:     
1:     private boolean isCompatible(Bundle bundle) {
1:         // Check compatibility
1:         boolean compatible;
1:         if (bundle.getState() == Bundle.ACTIVE) {
1:             try {
0:                 Class clazz = bundle.getBundleContext().getBundle().loadClass(BlueprintContainer.class.getName());
1:                 compatible = (clazz == BlueprintContainer.class);
1:             } catch (ClassNotFoundException e) {
1:                 compatible = true;
1:             }
1:         } else {
1:             // for lazy bundle, we can't load the class, so just assume it's ok
1:             compatible = true;
1:         }
1:         return compatible;
1:     }
1:     
1:     private boolean hasWildcards(String path) {
1:         return path.indexOf("*") >= 0; 
1:     }
1:     
1:     private void addEntry(Bundle bundle, String path, List<Object> pathList) {
1:         pathList.add(path);
1:     }
1:     
1:     private void addEntries(Bundle bundle, String path, String filePattern, List<Object> pathList) {
0:         Enumeration e = bundle.findEntries(path, filePattern, false);
1:         while (e != null && e.hasMoreElements()) {
1:             URL u = (URL) e.nextElement();
1:             pathList.add(u);
1:         }
1:     }
1: }
author:Tom Watson
-------------------------------------------------------------------------------
commit:3cfe3e2
/////////////////////////////////////////////////////////////////////////
1:         // Determine if the ParserService should ignore unknown namespace handlers
1:         boolean ignoreUnknownNamespaceHandlers = Boolean.parseBoolean(ctx.getProperty("org.apache.aries.blueprint.parser.service.ignore.unknown.namespace.handlers"));
1:             new ParserServiceImpl (handlers, ignoreUnknownNamespaceHandlers), 
commit:ecf9333
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.util.tracker.BundleTracker;
/////////////////////////////////////////////////////////////////////////
1:     private Object bt;
/////////////////////////////////////////////////////////////////////////
1:         boolean useSystemContext = Boolean.parseBoolean(ctx.getProperty("org.apache.aries.blueprint.use.system.context"));
1:         BundleContext trackingContext = useSystemContext ? ctx.getBundle(Constants.SYSTEM_BUNDLE_LOCATION).getBundleContext() : ctx;
1: 
1:         handlers = new NamespaceHandlerRegistryImpl(trackingContext);
/////////////////////////////////////////////////////////////////////////
1:         bt = useSystemContext ? new BundleTracker(trackingContext, mask, this) : new  RecursiveBundleTracker(ctx, mask, this);
1:             if (bt instanceof BundleTracker) {
1:             	((BundleTracker) bt).open();
1:             } else if (bt instanceof RecursiveBundleTracker) {
1:             	((RecursiveBundleTracker) bt).open();
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (bt instanceof BundleTracker) {
1:             	((BundleTracker) bt).close();
1:             } else if (bt instanceof RecursiveBundleTracker) {
1:             	((RecursiveBundleTracker) bt).close();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (bt instanceof BundleTracker) {
1:         	((BundleTracker) bt).close();
1:         } else if (bt instanceof RecursiveBundleTracker) {
1:         	((RecursiveBundleTracker) bt).close();
1:         }
author:Sergey Beryozkin
-------------------------------------------------------------------------------
commit:c18101e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.BlueprintExtenderService;
/////////////////////////////////////////////////////////////////////////
1:     private ServiceRegistration blueprintServiceReg;
/////////////////////////////////////////////////////////////////////////
1:         // Create and publish a BlueprintContainerService
1:         blueprintServiceReg = ctx.registerService(
1:                 BlueprintExtenderService.class.getName(),
1:                 new BlueprintContainerServiceImpl(),
1:                 new Hashtable<String, Object>());
1: 
/////////////////////////////////////////////////////////////////////////
1:         AriesFrameworkUtil.safeUnregisterService(blueprintServiceReg);
/////////////////////////////////////////////////////////////////////////
0:         List<Object> paths = getBlueprintPaths(bundle);
1:         return createContainer(bundle, paths);
1:     }
1: 
1:     private boolean createContainer(Bundle bundle, List<Object> paths) {
0:     try {
1:             if (paths == null || paths.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     private class BlueprintContainerServiceImpl implements BlueprintExtenderService {
1: 
1:         public BlueprintContainer createContainer(Bundle bundle) {
1:             if (BlueprintExtender.this.createContainer(bundle)) {
1:                 return getContainer(bundle);
0:             } else {
1:                 return null;
1:             }
1:         }
1: 
1:         public BlueprintContainer createContainer(Bundle bundle, List<Object> blueprintPaths) {
1:             if (BlueprintExtender.this.createContainer(bundle, blueprintPaths)) {
1:                 return getContainer(bundle);
0:             } else {
1:                 return null;
1:             }
1:         }
1: 
1:         public void destroyContainer(Bundle bundle, BlueprintContainer container) {
1:             BlueprintContainer bundleContainer = getContainer(bundle);
1:             if (bundleContainer != container) {
1:                 String error = "Unexpected Blueprint Container";
1:                 LOGGER.error(error);
1:                 throw new IllegalArgumentException(error);
1:             }
1:             BlueprintExtender.this.destroyContainer(bundle);
1:         }
1: 
1:         public BlueprintContainer getContainer(Bundle bundle) {
1:             return BlueprintExtender.this.getBlueprintContainerImpl(bundle);
1:         }
1: 
1:     }
author:Chris Wilkinson
-------------------------------------------------------------------------------
commit:1c97579
/////////////////////////////////////////////////////////////////////////
1:         if (context.getBundle(0).equals(bundle) && bundle.getState() == Bundle.STOPPING) {
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:ef7b490
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ScheduledExecutorService;
1: 
1: import org.apache.aries.blueprint.utils.threading.ScheduledExecutorServiceWrapper;
1: import org.apache.aries.blueprint.utils.threading.ScheduledExecutorServiceWrapper.ScheduledExecutorServiceFactory;
/////////////////////////////////////////////////////////////////////////
0:     private ScheduledExecutorService executors;
/////////////////////////////////////////////////////////////////////////
1:         executors = new ScheduledExecutorServiceWrapper(ctx, "Blueprint Extender", new ScheduledExecutorServiceFactory() {
1:           public ScheduledExecutorService create(String name)
1:           {
1:             return Executors.newScheduledThreadPool(3, new BlueprintThreadFactory(name));
1:           }
1:         });
commit:c827e88
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.util.SingleServiceTracker;
0: import org.apache.aries.util.SingleServiceTracker.SingleServiceListener;
commit:24455ce
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.ProxyManager;
0: import org.apache.aries.util.SingleServiceTracker;
0: import org.apache.aries.util.SingleServiceTracker.SingleServiceListener;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.util.tracker.ServiceTracker;
0: import org.osgi.util.tracker.ServiceTrackerCustomizer;
/////////////////////////////////////////////////////////////////////////
0:     private static SingleServiceTracker<ProxyManager> proxyManager;
1:     
1:     public void start(BundleContext ctx) {
1:         this.context = ctx;
0:         handlers = new NamespaceHandlerRegistryImpl(ctx);
1:         eventDispatcher = new BlueprintEventDispatcher(ctx, executors);
0:         bt = new RecursiveBundleTracker(ctx, stateMask, new BlueprintBundleTrackerCustomizer());
1:         
1:         proxyManager = new SingleServiceTracker<ProxyManager>(ctx, ProxyManager.class, new SingleServiceListener() {
1:           public void serviceFound() {
1:             LOGGER.debug("Found ProxyManager service, starting to process blueprint bundles");
0:             bt.open();
0:           }
1:           public void serviceLost() {
0:             // TODO we should probably close here, not sure.
0:           }
1:           public void serviceReplaced() {
0:           }
1:         });
1:         proxyManager.open();
1:         
1:         parserServiceReg = ctx.registerService(ParserService.class.getName(), 
1:             ctx.getBundle().loadClass(QUIESCE_PARTICIPANT_CLASS);
1:             quiesceParticipantReg = ctx.registerService(QUIESCE_PARTICIPANT_CLASS, 
1:               new BlueprintQuiesceParticipant(ctx, this), 
1:             LOGGER.info("No quiesce support is available, so blueprint components will not participate in quiesce operations");
/////////////////////////////////////////////////////////////////////////
1:     
0:     /**
0:      * @return the proxy manager. This will return null if the blueprint is not yet managing bundles.
0:      */
0:     public static ProxyManager getProxyManager()
1:     {
0:       return proxyManager.getService();
0:     }
/////////////////////////////////////////////////////////////////////////
1:                 Class<?> clazz = bundle.getBundleContext().getBundle().loadClass(BlueprintContainer.class.getName());
/////////////////////////////////////////////////////////////////////////
1:         Enumeration<?> e = bundle.findEntries(path, filePattern, false);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:7257be0
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ScheduledThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
1:     /** The QuiesceParticipant implementation class name */
1:     private static final String QUIESCE_PARTICIPANT_CLASS = "org.apache.aries.quiesce.participant.QuiesceParticipant";
0:     private ScheduledThreadPoolExecutor executors;
/////////////////////////////////////////////////////////////////////////
0:         executors = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(3, new BlueprintThreadFactory("Blueprint Extender"));
/////////////////////////////////////////////////////////////////////////
0:             bt.close();
/////////////////////////////////////////////////////////////////////////
0:         return containers.get(bundle);
commit:09a7647
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ParserService;
commit:b6c4135
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.tracker.SingleServiceTracker;
1: import org.apache.aries.util.tracker.SingleServiceTracker.SingleServiceListener;
commit:1d8c3ec
/////////////////////////////////////////////////////////////////////////
0:         eventDispatcher.removeBlueprintBundle(bundle);
commit:48dd690
/////////////////////////////////////////////////////////////////////////
0:         executors = Executors.newScheduledThreadPool(3, new BlueprintThreadFactory("Blueprint Extender"));
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:047a2ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.AriesFrameworkUtil;
0: import org.apache.aries.util.tracker.SingleServiceTracker;
0: import org.apache.aries.util.tracker.SingleServiceTracker.SingleServiceListener;
/////////////////////////////////////////////////////////////////////////
1:         AriesFrameworkUtil.safeUnregisterService(parserServiceReg);
1: 
1:         AriesFrameworkUtil.safeUnregisterService(quiesceParticipantReg);
author:Holly Cummins
-------------------------------------------------------------------------------
commit:da163d0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	/** The QuiesceParticipant implementation class name */
0: 	private static final String QUIESCE_PARTICIPANT_CLASS = "org.apache.aries.quiesce.participant.QuiesceParticipant";
/////////////////////////////////////////////////////////////////////////
1:     private ServiceRegistration quiesceParticipantReg;
/////////////////////////////////////////////////////////////////////////
1: 
1:         try{
0:             context.getBundle().loadClass(QUIESCE_PARTICIPANT_CLASS);
1:             //Class was loaded, register
1: 
0:             quiesceParticipantReg = context.registerService(QUIESCE_PARTICIPANT_CLASS, 
0:               new BlueprintQuiesceParticipant(context, this), 
0:               new Hashtable<Object, Object>()); 
0:         } 
1:         catch (ClassNotFoundException e) 
1:         {
0:             LOGGER.info("No quiesce support is available, so blueprint components will not participate in quiesce operations", e);
0:         }
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (quiesceParticipantReg != null) 
0:           	quiesceParticipantReg.unregister();
/////////////////////////////////////////////////////////////////////////
1:     protected BlueprintContainerImpl getBlueprintContainerImpl(Bundle bundle)
1:     {
0:     	return (BlueprintContainerImpl) containers.get(bundle);
0:     }
0:     
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:97adf4b
/////////////////////////////////////////////////////////////////////////
1:       return Integer.toHexString(bundle.hashCode()) + "/" + filePath;
commit:e14de25
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3fa788c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
0: import org.apache.aries.blueprint.ParserService;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.ServiceRegistration;
/////////////////////////////////////////////////////////////////////////
0:     
0:     // MN adding new bits
1:     private ServiceRegistration parserServiceReg;
/////////////////////////////////////////////////////////////////////////
0:         
1:         // Create and publish a ParserService
0:         parserServiceReg = context.registerService(ParserService.class.getName(), 
0:             new ParserServiceImpl (handlers), 
0:             new Hashtable<Object, Object>()); 
0:         
0:         LOGGER.debug("Blueprint extender started");
0: 
0: 
0:         
0:         parserServiceReg.unregister();
0: 
/////////////////////////////////////////////////////////////////////////
0:             
author:Lin Sun
-------------------------------------------------------------------------------
commit:f582694
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (pathList.isEmpty() && blueprintHeaderAnnotation != null && blueprintHeaderAnnotation.trim().equalsIgnoreCase("true")) {
commit:edc17ca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.annotation.service.BlueprintAnnotationScanner;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.util.tracker.ServiceTracker;
/////////////////////////////////////////////////////////////////////////
0:     private ServiceTracker st;
/////////////////////////////////////////////////////////////////////////
0:             String blueprintHeaderAnnotation = (String) bundle.getHeaders().get(BlueprintConstants.BUNDLE_BLUEPRINT_ANNOTATION_HEADER);
/////////////////////////////////////////////////////////////////////////
0:             }
0:             
0:             if (pathList.isEmpty() && blueprintHeaderAnnotation.trim().equalsIgnoreCase("true")) {
0:                 LOGGER.debug("Scanning bundle {} for blueprint annotations", bundle.getSymbolicName());
0:                 ServiceReference sr = this.context.getServiceReference("org.apache.aries.blueprint.annotation.service.BlueprintAnnotationScanner");
0:                            
0:                 if (sr != null) {
0:                     BlueprintAnnotationScanner bas = (BlueprintAnnotationScanner)this.context.getService(sr);
0:                     // try to generate the blueprint definition XML
0:                     URL url = bas.createBlueprintModel(bundle);
0:                         
0:                     if (url != null) {
0:                         pathList.add(url);
0:                     }
0:                     
0:                     this.context.ungetService(sr);
0:                 }
0:              
0:             }
0:             
/////////////////////////////////////////////////////////////////////////
0:                 LOGGER.debug("No blueprint application found in bundle {}", bundle.getSymbolicName());   
0: 
commit:537d4ee
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.tracker.RecursiveBundleTracker;
/////////////////////////////////////////////////////////////////////////
1:  * This is the blueprint extender that listens to blueprint bundles.  
/////////////////////////////////////////////////////////////////////////
0:     private RecursiveBundleTracker bt;
/////////////////////////////////////////////////////////////////////////
0:         int stateMask = Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.ACTIVE
0:         | Bundle.STOPPING;
0:         bt = new RecursiveBundleTracker(context, stateMask, new BlueprintBundleTrackerCustomizer());
/////////////////////////////////////////////////////////////////////////
commit:9fa6706
/////////////////////////////////////////////////////////////////////////
0:      * this method checks the initial bundle that are installed/active before
0:      * bundle tracker is opened.  
0:     private void checkInitialBundle(Bundle b) {
0:         // If the bundle is active, check it
0:         if (b.getState() == Bundle.ACTIVE) {
0:             checkBundle(b);
0:             // Also check bundles in the starting state with a lazy activation
0:             // policy
0:         } else if (b.getState() == Bundle.STARTING) {
0:             String activationPolicyHeader = (String) b.getHeaders().get(
0:                     Constants.BUNDLE_ACTIVATIONPOLICY);
0:             if (activationPolicyHeader != null
0:                     && activationPolicyHeader
0:                             .startsWith(Constants.ACTIVATION_LAZY)) {
0:                 checkBundle(b);
0: 
/////////////////////////////////////////////////////////////////////////
0:                 // existing bundles first added to the tracker with no event change
0:                 checkInitialBundle(b);
0:             } else {
0:                 bundleChanged(event);
0:                 // cannot think of why we would be interested in a modified bundle with no bundle event
/////////////////////////////////////////////////////////////////////////
0:                 // existing bundles first added to the tracker with no event change
0:                 checkInitialBundle(b);
0:             } else {        
0:                 bundleChanged(event);
0:             
0:             if (event == null) {
0:                 // cannot think of why we would be interested in a modified bundle with no bundle event
0:                 return;
0:             } else {
0:                 bundleChanged(event);
0:             }
commit:2d9e4c5
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.framework.CompositeBundle;
/////////////////////////////////////////////////////////////////////////
0:         checkAllBundles(bundles, sr);
0: 
0:     /**
0:      *  this method check all bundles. if the sr is null, then we only check
0:      *  bundles within the current bundle context where this bundle resides.  
0:      *  if sr is not null, then we also check the bundles inside the child frameworks
0:      *  that are associated with composite bundles 
0:      * @param bundles  bundles to be checked
0:      * @param sr       Service reference for the composite bundle factory service
0:      */
0:     private void checkAllBundles(Bundle[] bundles, ServiceReference sr) {
0:         for (Bundle b : bundles) {
0:             if (sr != null && (b instanceof CompositeBundle)) {
0:                 // let's check bundles associated with the composite bundle
0:                 CompositeBundle cb = (CompositeBundle)b;
0:                 Bundle[] buns = cb.getCompositeFramework().getBundleContext().getBundles();
0:                 checkAllBundles(buns, sr);
0:             } else {
0:                 // If the bundle is active, check it
0:                 if (b.getState() == Bundle.ACTIVE) {
0:                     checkBundle(b);
0:                 // Also check bundles in the starting state with a lazy activation policy
0:                 } else if (b.getState() == Bundle.STARTING) {
0:                     String activationPolicyHeader = (String) b.getHeaders().get(Constants.BUNDLE_ACTIVATIONPOLICY);
0:                     if (activationPolicyHeader != null && activationPolicyHeader.startsWith(Constants.ACTIVATION_LAZY)) {
0:                         checkBundle(b);
0:                     }
0:                 }
0:             }
0:         }
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0: 
0:             super.addingBundle(b, event);
0:             
commit:2b87d24
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.util.tracker.AriesBundleTrackerCustomizer;
/////////////////////////////////////////////////////////////////////////
0:         ServiceReference sr = this.context.getServiceReference("org.osgi.service.framework.CompositeBundleFactory");
0:         if (sr == null) {
0:             bt = new BundleTracker(context, Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING, new BlueprintBundleTrackerCustomizer()); 
0:         } else {
0:             // composite bundle factory service is active, let's track blueprint bundles installed in the child frameworks too.
0:             bt = new BundleTracker(context, Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING, new BlueprintMutilBundleTrackerCustomizer());   
0:         }
/////////////////////////////////////////////////////////////////////////
0:     
0:     // blueprint bundle tracker calls bundleChanged to minimize changes.
0:     // this bundle tracker customizer handles bundles installed in the child framework as well
0:     private class BlueprintMutilBundleTrackerCustomizer extends
0:             AriesBundleTrackerCustomizer {
0: 
0:         public BlueprintMutilBundleTrackerCustomizer() {
0:         }
0: 
0:         public Object addingBundle(Bundle b, BundleEvent event) {
0:             
0:             if (event == null) {
0:                 return null;
0:             }
0: 
0:             super.addingBundle(b, event);
0:             bundleChanged(event);
0: 
0:             return b;
0:         }
0: 
0:         public void modifiedBundle(Bundle b, BundleEvent event, Object arg2) {
0:             if (event == null) {
0:                 return;
0:             }
0: 
0:             super.modifiedBundle(b, event, arg2);
0:             bundleChanged(event);
0: 
0:         }
0: 
0:         // don't think we would be interested in removedBundle, as that is
0:         // called when bundle is removed from the tracker
0:         public void removedBundle(Bundle b, BundleEvent event, Object arg2) {
0:         }
0:     }
commit:6cb5785
/////////////////////////////////////////////////////////////////////////
0:     private class BlueprintBundleTrackerCustomizer implements
0:             BundleTrackerCustomizer {
0: 
0:         public Object addingBundle(Bundle b, BundleEvent event) {
0:             if (event == null) {
0:                 return null;
0:             }
0: 
0:             bundleChanged(event);
0: 
0:             return b;
0:         public void modifiedBundle(Bundle b, BundleEvent event, Object arg2) {
0: 
0: 
0:         public void removedBundle(Bundle b, BundleEvent event, Object arg2) {
0:     }
commit:7ffd760
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.util.tracker.BundleTracker;
1: import org.osgi.util.tracker.BundleTrackerCustomizer;
0:  * This is the blueprint extender that listens to blueprint bundles.  it implements the sync
0:  * bundle listener but it doesn't register the listener and uses the bundle tracker instead.
/////////////////////////////////////////////////////////////////////////
0:     private BundleTracker bt;
/////////////////////////////////////////////////////////////////////////
0:         // TODO: allow aries consumer to plugin their own bundletracker customizer.
0:         bt = new BundleTracker(context, Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING, new BlueprintBundleTrackerCustomizer());
0:         bt.open();
0:         
/////////////////////////////////////////////////////////////////////////
0:         if (bt != null) {
0:         	bt.close();
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     // blueprint bundle tracker calls bundleChanged to minimize changes.
0:     private class BlueprintBundleTrackerCustomizer implements BundleTrackerCustomizer {
0: 
0:         public BlueprintBundleTrackerCustomizer() {
0:         }
0:         
0:         public Object addingBundle(Bundle b, BundleEvent event)
0:         {
0:           if (event == null) {
0:             return null;
0:           }
0:           
0:           bundleChanged(event);
0:           
0:           return b;
0:         }
0: 
0:         public void modifiedBundle(Bundle b, BundleEvent event, Object arg2)
0:         {          
0:             if (event == null) {
0:                 return;
0:             }
0:         
0:             bundleChanged(event);
0:           
0:         }
0: 
0:         // don't think we would be interested in removedBundle, as that is
0:         // called when bundle is removed from the tracker
0:         public void removedBundle(Bundle b, BundleEvent event, Object arg2)
0:         {      
0:         }
0:       }
author:Alan T Keane
-------------------------------------------------------------------------------
commit:ac84882
/////////////////////////////////////////////////////////////////////////
0:         // Create and publish a ParserService
0:         parserServiceReg = context.registerService(ParserService.class.getName(), 
0:             new ParserServiceImpl (handlers), 
0:             new Hashtable<Object, Object>()); 
0:         
/////////////////////////////////////////////////////////////////////////
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.BlueprintConstants;
1: import org.apache.aries.blueprint.namespace.NamespaceHandlerRegistryImpl;
1: import org.apache.aries.blueprint.utils.HeaderParser;
1: import org.apache.aries.blueprint.utils.HeaderParser.PathElement;
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:4ae0bfc
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.net.MalformedURLException;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.SynchronousBundleListener;
/////////////////////////////////////////////////////////////////////////
1:     private String getFilePart(URL url) {
1:         String path = url.getPath();
1:         int index = path.lastIndexOf('/');
1:         return path.substring(index + 1);
0:     }
0:     
1:     private String cachePath(Bundle bundle, String filePath)
0:     {
0:       return bundle.getSymbolicName() + "/" + bundle.getVersion() + "/" + filePath;
0:     }    
0:     
1:     private URL getOverrideURLForCachePath(String privatePath){
1:         URL override = null;
1:         File privateDataVersion = context.getDataFile(privatePath);
1:         if (privateDataVersion != null
1:                 && privateDataVersion.exists()) {
0:             try {
0:                 override = privateDataVersion.toURL();
1:             } catch (MalformedURLException e) {
1:                 LOGGER.error("Unexpected URL Conversion Issue", e);
0:             }
0:         }
1:         return override;
0:     }
0:     
1:     private URL getOverrideURL(Bundle bundle, String path){
1:         String cachePath = cachePath(bundle, path);
1:         return getOverrideURLForCachePath(cachePath);
0:     }
0:     
1:     private URL getOverrideURL(Bundle bundle, URL path, String basePath){
1:         String cachePath = cachePath(bundle, basePath + getFilePart(path));
1:         return getOverrideURLForCachePath(cachePath);
0:     }    
0:     
1:         URL override = getOverrideURL(bundle, path);
1:         if(override == null) {
0:             pathList.add(path);
0:         } else {
1:             pathList.add(override);
0:         }
1:             URL override = getOverrideURL(bundle, u, path);
1:             if(override == null) {
0:                 pathList.add(u);
0:             } else {
1:                 pathList.add(override);
0:             }
commit:86df11e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.ServiceReference;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             }            
commit:d4dd720
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.net.MalformedURLException;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.SynchronousBundleListener;
/////////////////////////////////////////////////////////////////////////
0:     private String getFilePart(URL url)
0:     {
0:       String path = url.getPath();
0:       int index = path.lastIndexOf('/');
0:       return path.substring(index+1);
0:     }
0:     
0:     private String cachePath(Bundle bundle, String filePath)
0:     {
0:       return bundle.getSymbolicName() + "/" + bundle.getVersion() + "/" + filePath;
0:     }     
0:     
/////////////////////////////////////////////////////////////////////////
0:             }
0:             
0:             //Override bundle specified blueprint XML with 
0:             //XML already in the private storage.
0: 			Iterator<Object> pathIter = pathList.iterator();
0: 			List<Object> overridden = new ArrayList<Object>();
0: 			while (pathIter.hasNext()) {
0: 				Object path = pathIter.next();
0: 				if (path instanceof URL) {
0: 					URL url = (URL) path;
0: 					File privateDataVersion = context.getDataFile(cachePath(
0: 							bundle, "OSGI-INF/blueprint/" + getFilePart(url)));
0: 					if (privateDataVersion != null && privateDataVersion.exists()) {
0: 						try {
0: 							overridden.add(privateDataVersion.toURL());
0: 							pathIter.remove();
0: 						} catch (MalformedURLException e) {
0: 							LOGGER.error("Unexpected URL Conversion Issue", e);
0: 						}
0: 					}
0: 				} else if (path instanceof String) {
0: 					String s = (String) path;
0: 					File privateDataVersion = context.getDataFile(cachePath(
0: 							bundle, s));
0: 					if (privateDataVersion != null 	&& privateDataVersion.exists()) {
0: 						try {
0: 							overridden.add(privateDataVersion.toURL());
0: 							pathIter.remove();
0: 						} catch (MalformedURLException e) {
0: 							LOGGER.error("Unexpected URL Conversion Issue", e);
0: 						}
0: 					}
0: 				} else {
0: 					throw new IllegalArgumentException("Unexpected path type: "
0: 							+ path.getClass());
0: 				}
0: 			}
0: 			pathList.addAll(overridden);          
0:             
author:Alan Cabrera
-------------------------------------------------------------------------------
commit:7aa7756
/////////////////////////////////////////////////////////////////////////
0:         eventDispatcher = new BlueprintEventDispatcher(context, executors);
commit:5cff64a
/////////////////////////////////////////////////////////////////////////
0:         eventDispatcher = new BlueprintEventDispatcher(context, executors);
commit:4d7701c
/////////////////////////////////////////////////////////////////////////
============================================================================