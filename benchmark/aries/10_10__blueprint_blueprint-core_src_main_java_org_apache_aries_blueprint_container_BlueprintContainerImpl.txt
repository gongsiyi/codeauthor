1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:4dfd2d8: 
1:f13c6ac: import java.io.FileNotFoundException;
1:f13c6ac: import java.net.URI;
1:f13c6ac: import java.net.URL;
1:f13c6ac: import java.security.AccessControlContext;
1:f13c6ac: import java.security.AccessController;
1:f13c6ac: import java.security.PrivilegedAction;
1:f13c6ac: import java.security.PrivilegedActionException;
1:f13c6ac: import java.security.PrivilegedExceptionAction;
1:f13c6ac: import java.util.ArrayList;
1:ba10b30: import java.util.Arrays;
1:f13c6ac: import java.util.Collection;
1:f13c6ac: import java.util.Collections;
1:f13c6ac: import java.util.Dictionary;
1:f13c6ac: import java.util.HashMap;
1:f13c6ac: import java.util.HashSet;
1:f13c6ac: import java.util.LinkedHashSet;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Map;
1:f13c6ac: import java.util.Properties;
1:f13c6ac: import java.util.Set;
1:8351107: import java.util.concurrent.ExecutorService;
1:f13c6ac: import java.util.concurrent.ScheduledExecutorService;
1:f13c6ac: import java.util.concurrent.ScheduledFuture;
1:f13c6ac: import java.util.concurrent.TimeUnit;
1:f13c6ac: import java.util.concurrent.TimeoutException;
1:f13c6ac: import java.util.concurrent.atomic.AtomicBoolean;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.BlueprintConstants;
1:6414875: import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
1:6414875: import org.apache.aries.blueprint.ExtendedBeanMetadata;
1:6414875: import org.apache.aries.blueprint.NamespaceHandler;
1:220c392: import org.apache.aries.blueprint.NamespaceHandler2;
1:6414875: import org.apache.aries.blueprint.Processor;
1:7959fcd: import org.apache.aries.blueprint.di.ExecutionContext;
1:6414875: import org.apache.aries.blueprint.di.Recipe;
1:6414875: import org.apache.aries.blueprint.di.Repository;
1:94f26b1: import org.apache.aries.blueprint.namespace.MissingNamespaceException;
1:6414875: import org.apache.aries.blueprint.namespace.NamespaceHandlerRegistryImpl;
1:6bd0f94: import org.apache.aries.blueprint.parser.ComponentDefinitionRegistryImpl;
1:09a7647: import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
1:8351107: import org.apache.aries.blueprint.parser.Parser;
1:5e2bd49: import org.apache.aries.blueprint.proxy.ProxyUtils;
1:79e9d13: import org.apache.aries.blueprint.reflect.MetadataUtil;
1:2f55d71: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
1:8351107: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:6414875: import org.apache.aries.blueprint.utils.HeaderParser;
1:6414875: import org.apache.aries.blueprint.utils.HeaderParser.PathElement;
1:8351107: import org.apache.aries.blueprint.utils.JavaUtils;
1:4dfd2d8: import org.apache.aries.proxy.ProxyManager;
1:047a2ae: import org.apache.aries.util.AriesFrameworkUtil;
1:f13c6ac: import org.osgi.framework.Bundle;
1:f13c6ac: import org.osgi.framework.BundleContext;
1:f13c6ac: import org.osgi.framework.Constants;
1:f13c6ac: import org.osgi.framework.ServiceReference;
1:f13c6ac: import org.osgi.framework.ServiceRegistration;
1:55084bf: import org.osgi.framework.wiring.BundleWiring;
1:f13c6ac: import org.osgi.service.blueprint.container.BlueprintContainer;
1:f13c6ac: import org.osgi.service.blueprint.container.BlueprintEvent;
1:f13c6ac: import org.osgi.service.blueprint.container.BlueprintListener;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.container.Converter;
1:f13c6ac: import org.osgi.service.blueprint.container.NoSuchComponentException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanArgument;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanProperty;
1:f13c6ac: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapEntry;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.PropsMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Target;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:0871217: import org.xml.sax.ErrorHandler;
1:0871217: import org.xml.sax.SAXException;
1:0871217: import org.xml.sax.SAXParseException;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * TODO: javadoc
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:1e0e25d: @SuppressWarnings("deprecation") // due to the deprecated org.apache.aries.blueprint.ExtendedBlueprintContainer
1:1e0e25d: public class BlueprintContainerImpl 
1:1e0e25d:     implements ExtendedBlueprintContainer, NamespaceHandlerSet.Listener, 
1:1e0e25d:     Runnable, SatisfiableRecipe.SatisfactionListener,
1:1e0e25d:     org.apache.aries.blueprint.ExtendedBlueprintContainer {
1:f13c6ac: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintContainerImpl.class);
1:f13c6ac: 
1:d92e123:     private static final Class[] SECURITY_BUGFIX = {
1:d92e123:             BlueprintDomainCombiner.class,
1:d92e123:             BlueprintProtectionDomain.class,
1:d92e123:     };
1:d92e123:     
1:d46274e:     public enum State {
1:f13c6ac:         Unknown,
1:f13c6ac:         WaitForNamespaceHandlers,
1:f13c6ac:         Populated,
1:f13c6ac:         WaitForInitialReferences,
1:f13c6ac:         InitialReferencesSatisfied,
1:f13c6ac:         WaitForInitialReferences2,
1:f13c6ac:         Create,
1:f13c6ac:         Created,
1:f13c6ac:         Failed,
1:e21ec8f:     }
1:55084bf: 
1:f13c6ac:     private final BundleContext bundleContext;
1:3e11f4a:     private final Bundle bundle;
1:f13c6ac:     private final Bundle extenderBundle;
1:f13c6ac:     private final BlueprintListener eventDispatcher;
1:f13c6ac:     private final NamespaceHandlerRegistry handlers;
1:f13c6ac:     private final List<Object> pathList;
1:f13c6ac:     private final ComponentDefinitionRegistryImpl componentDefinitionRegistry;
1:f13c6ac:     private final AggregateConverter converter;
1:3e11f4a:     private final ExecutorService executors;
1:3e11f4a:     private final ScheduledExecutorService timer;
1:c89ef70:     private final Collection<URI> additionalNamespaces;
1:f13c6ac:     private Set<URI> namespaces;
1:f13c6ac:     private State state = State.Unknown;
1:09a7647:     private NamespaceHandlerSet handlerSet;
1:6d7c26a:     private final AtomicBoolean destroyed = new AtomicBoolean(false);
1:f13c6ac:     private Parser parser;
1:f13c6ac:     private BlueprintRepository repository;
1:f13c6ac:     private ServiceRegistration registration;
1:f13c6ac:     private List<Processor> processors;
1:f13c6ac:     private final Object satisfiablesLock = new Object();
1:f13c6ac:     private Map<String, List<SatisfiableRecipe>> satisfiables;
1:f13c6ac:     private long timeout = 5 * 60 * 1000;
1:f13c6ac:     private boolean waitForDependencies = true;
1:0871217:     private String xmlValidation;
1:f13c6ac:     private ScheduledFuture timeoutFuture;
1:f13c6ac:     private final AtomicBoolean scheduled = new AtomicBoolean();
1:f13c6ac:     private List<ServiceRecipe> services;
1:6d7c26a:     private final AccessControlContext accessControlContext;
1:9f9d944:     private final IdSpace tempRecipeIdSpace = new IdSpace();
1:6d7c26a:     private final ProxyManager proxyManager;
1:3e11f4a: 
1:6d7c26a:     public BlueprintContainerImpl(Bundle bundle, BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher,
1:3e11f4a:                                   NamespaceHandlerRegistry handlers, ExecutorService executor, ScheduledExecutorService timer,
1:c89ef70:                                   List<Object> pathList, ProxyManager proxyManager, Collection<URI> namespaces) {
1:6d7c26a:         this.bundle = bundle;
1:f13c6ac:         this.bundleContext = bundleContext;
1:f13c6ac:         this.extenderBundle = extenderBundle;
1:f13c6ac:         this.eventDispatcher = eventDispatcher;
1:f13c6ac:         this.handlers = handlers;
1:f13c6ac:         this.pathList = pathList;
1:f13c6ac:         this.converter = new AggregateConverter(this);
1:f13c6ac:         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl();
1:fe68bf1:         this.executors = executor != null ? new ExecutorServiceWrapper(executor) : null;
1:3e11f4a:         this.timer = timer;
1:f492016:         this.processors = new ArrayList<Processor>();
1:f13c6ac:         if (System.getSecurityManager() != null) {
1:d92e123:             this.accessControlContext = BlueprintDomainCombiner.createAccessControlContext(bundleContext);
1:6d7c26a:         } else {
1:6d7c26a:             this.accessControlContext = null;
1:f13c6ac:         }
1:4dfd2d8:         this.proxyManager = proxyManager;
1:c89ef70:         this.additionalNamespaces = namespaces;
1:f13c6ac:     }
1:f13c6ac: 
1:8351107:     public ExecutorService getExecutors() {
1:8351107:         return executors;
1:8351107:     }
1:8351107: 
1:f13c6ac:     public Bundle getExtenderBundle() {
1:f13c6ac:         return extenderBundle;
1:f13c6ac:     }
1:f13c6ac: 
1:4dfd2d8:     public ProxyManager getProxyManager() {
1:4dfd2d8:         return proxyManager;
1:4dfd2d8:     }
1:4dfd2d8: 
1:f13c6ac:     public <T extends Processor> List<T> getProcessors(Class<T> clazz) {
1:f13c6ac:         List<T> p = new ArrayList<T>();
1:f13c6ac:         for (Processor processor : processors) {
1:f13c6ac:             if (clazz.isInstance(processor)) {
1:f13c6ac:                 p.add(clazz.cast(processor));
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return p;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public BlueprintListener getEventDispatcher() {
1:f13c6ac:         return eventDispatcher;
1:f13c6ac:     }
1:f13c6ac: 
1:ef7b490:     private void readDirectives() {
1:f13c6ac:         Dictionary headers = bundle.getHeaders();
1:f13c6ac:         String symbolicName = (String)headers.get(Constants.BUNDLE_SYMBOLICNAME);
1:f13c6ac:         List<PathElement> paths = HeaderParser.parseHeader(symbolicName);
1:f13c6ac: 
1:f13c6ac:         String timeoutDirective = paths.get(0).getDirective(BlueprintConstants.TIMEOUT_DIRECTIVE);
1:f13c6ac:         if (timeoutDirective != null) {
1:f13c6ac:             LOGGER.debug("Timeout directive: {}", timeoutDirective);
1:f13c6ac:             timeout = Integer.parseInt(timeoutDirective);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         String graceperiod = paths.get(0).getDirective(BlueprintConstants.GRACE_PERIOD);
1:f13c6ac:         if (graceperiod != null) {
1:f13c6ac:             LOGGER.debug("Grace-period directive: {}", graceperiod);
1:f13c6ac:             waitForDependencies = Boolean.parseBoolean(graceperiod);
1:f13c6ac:         }
1:f13c6ac: 
1:0871217:         xmlValidation = paths.get(0).getDirective(BlueprintConstants.XML_VALIDATION);
1:0871217:         // enabled if null or "true"; structure-only if "structure"; disabled otherwise
1:0871217:         LOGGER.debug("Xml-validation directive: {}", xmlValidation);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void schedule() {
1:f13c6ac:         if (scheduled.compareAndSet(false, true)) {
1:f13c6ac:             executors.submit(this);
1:f13c6ac:         }
1:f13c6ac:     }
1:f492016: 
1:f492016:     public void reload() {
1:3e11f4a:         synchronized (scheduled) {
1:6d7c26a:             if (destroyed.get()) {
1:6d7c26a:                 return;
1:6d7c26a:             }
1:3e11f4a:             tidyupComponents();
1:e76da08:             resetComponentDefinitionRegistry();
1:c3f255b:             cancelFutureIfPresent();
1:3e11f4a:             this.repository = null;
1:3e11f4a:             this.processors = new ArrayList<Processor>();
1:3e11f4a:             timeout = 5 * 60 * 1000;
1:3e11f4a:             waitForDependencies = true;
1:0871217:             xmlValidation = null;
1:3e11f4a:             if (handlerSet != null) {
1:9a1ff22:                 handlerSet.removeListener(this);
1:9a1ff22:                 handlerSet.destroy();
1:3e11f4a:                 handlerSet = null;
1:6d7c26a:             }
1:3e11f4a:             state = State.Unknown;
1:3e11f4a:             schedule();
1:3e11f4a:         }
1:e21ec8f:     }
1:f13c6ac:     
1:55084bf:     protected void resetComponentDefinitionRegistry() {
1:3e11f4a:         this.componentDefinitionRegistry.reset();
1:2f55d71:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
1:3e11f4a:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundle));
1:2f55d71:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundleContext", bundleContext));
1:2f55d71:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintConverter", converter));
1:3e11f4a:     }
1:f492016: 
1:f13c6ac:     public void run() {
1:f13c6ac:         scheduled.set(false);
1:f13c6ac:         synchronized (scheduled) {
1:3e11f4a:             doRun();
1:e21ec8f:         }
1:3b2c33b:     }
1:f13c6ac: 
1:d46274e:     public State getState() {
1:d46274e:         return state;
1:d46274e:     }
1:d46274e: 
1:f13c6ac:     /**
1:f13c6ac:      * This method must be called inside a synchronized block to ensure this method is not run concurrently
1:f13c6ac:      */
1:f13c6ac:     private void doRun() {
1:94f26b1:         try {
1:f13c6ac:             for (;;) {
1:6d7c26a:                 if (destroyed.get()) {
1:f13c6ac:                     return;
1:3b2c33b:                 }
1:3e11f4a:                 if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
1:3e11f4a:                     return;
1:3e11f4a:                 }
1:3e11f4a:                 if (bundle.getBundleContext() != bundleContext) {
1:3e11f4a:                     return;
1:3e11f4a:                 }
1:db4243b:                 LOGGER.debug("Running blueprint container for bundle {}/{} in state {}", getBundle().getSymbolicName(), getBundle().getVersion(), state);
1:f13c6ac:                 switch (state) {
1:f13c6ac:                     case Unknown:
1:ef7b490:                         readDirectives();
1:3e11f4a:                         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATING, getBundle(), getExtenderBundle()));
1:f13c6ac:                         parser = new Parser();
1:f13c6ac:                         parser.parse(getResources());
1:f13c6ac:                         namespaces = parser.getNamespaces();
1:c89ef70:                         if (additionalNamespaces != null) {
1:c89ef70:                             namespaces.addAll(additionalNamespaces);
1:c89ef70:                         }
1:9a1ff22:                         handlerSet = handlers.getNamespaceHandlers(namespaces, getBundle());
1:9a1ff22:                         handlerSet.addListener(this);
2:f13c6ac:                         state = State.WaitForNamespaceHandlers;
1:3e11f4a:                         break;
1:f13c6ac:                     case WaitForNamespaceHandlers:
1:f13c6ac:                     {
1:f13c6ac:                         List<String> missing = new ArrayList<String>();
1:a37e3d4:                         List<URI> missingURIs = new ArrayList<URI>();
1:9a1ff22:                         for (URI ns : handlerSet.getNamespaces()) {
1:3b2c33b:                             if (handlerSet.getNamespaceHandler(ns) == null) {
1:f13c6ac:                                 missing.add("(&(" + Constants.OBJECTCLASS + "=" + NamespaceHandler.class.getName() + ")(" + NamespaceHandlerRegistryImpl.NAMESPACE + "=" + ns + "))");
1:a37e3d4:                                 missingURIs.add(ns);
1:f13c6ac:                             }
1:f13c6ac:                         }
1:f13c6ac:                         if (missing.size() > 0) {
1:db4243b:                             LOGGER.info("Bundle {}/{} is waiting for namespace handlers {}", getBundle().getSymbolicName(), getBundle().getVersion(), missingURIs);
1:3e11f4a:                             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missing.toArray(new String[missing.size()])));
1:f13c6ac:                             return;
1:f13c6ac:                         }
1:e76da08:                         resetComponentDefinitionRegistry();
1:94f26b1:                         if (xmlValidation == null || "true".equals(xmlValidation)) {
1:220c392:                             for (URI ns : handlerSet.getNamespaces()) {
1:220c392:                                 NamespaceHandler handler = handlerSet.getNamespaceHandler(ns);
1:220c392:                                 if (handler instanceof NamespaceHandler2) {
1:220c392:                                     if (((NamespaceHandler2) handler).usePsvi()) {
1:220c392:                                         xmlValidation = "psvi";
1:220c392:                                         break;
1:220c392:                                     }
1:220c392:                                 }
1:220c392:                             }
1:220c392:                         }
1:e21ec8f:                         try {
1:220c392:                             if (xmlValidation == null || "true".equals(xmlValidation)) {
1:94f26b1:                                 parser.validate(handlerSet.getSchema(parser.getSchemaLocations()));
1:94f26b1:                             } else if ("structure".equals(xmlValidation)) {
1:94f26b1:                                 parser.validate(handlerSet.getSchema(parser.getSchemaLocations()), new ValidationHandler());
1:94f26b1:                             } else if ("psvi".equals(xmlValidation)) {
1:94f26b1:                                 parser.validatePsvi(handlerSet.getSchema(parser.getSchemaLocations()));
1:94f26b1:                             }
1:94f26b1:                             parser.populate(handlerSet, componentDefinitionRegistry);
1:94f26b1:                             state = State.Populated;
1:94f26b1:                         } catch (MissingNamespaceException e) {
1:94f26b1:                             // If we found a missing namespace when parsing the schema,
1:94f26b1:                             // we remain in the current state
1:9a1ff22:                             handlerSet.getNamespaces().add(e.getNamespace());
1:f13c6ac:                         }
1:3e11f4a:                         break;
1:f13c6ac:                     }
1:f13c6ac:                     case Populated:
1:f13c6ac:                         getRepository();
1:f13c6ac:                         trackServiceReferences();
1:f13c6ac:                         Runnable r = new Runnable() {
1:f13c6ac:                             public void run() {
1:f13c6ac:                                 synchronized (scheduled) {
1:6d7c26a:                                     if (destroyed.get()) {
1:6d7c26a:                                         return;
1:6d7c26a:                                     }
1:0231f6a:                                     String[] missingDependecies = getMissingDependencies();
1:0231f6a:                                     if (missingDependecies.length == 0) {
1:0231f6a:                                         return;
1:f13c6ac:                                     }
1:f13c6ac:                                     Throwable t = new TimeoutException();
1:f13c6ac:                                     state = State.Failed;
1:f25cf7c:                                     tidyupComponents();
1:db4243b:                                     LOGGER.error("Unable to start blueprint container for bundle {}/{} due to unresolved dependencies {}", getBundle().getSymbolicName(), getBundle().getVersion(), Arrays.asList(missingDependecies), t);
1:3e11f4a:                                     eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), missingDependecies, t));
1:f13c6ac:                                 }
1:f13c6ac:                             }
2:f13c6ac:                         };
1:3e11f4a:                         timeoutFuture = timer.schedule(r, timeout, TimeUnit.MILLISECONDS);
1:f13c6ac:                         state = State.WaitForInitialReferences;
1:3e11f4a:                         break;
1:f13c6ac:                     case WaitForInitialReferences:
1:f13c6ac:                         if (waitForDependencies) {
1:f13c6ac:                             String[] missingDependencies = getMissingDependencies();
1:f13c6ac:                             if (missingDependencies.length > 0) {
1:db4243b:                                 LOGGER.info("Bundle {}/{} is waiting for dependencies {}", getBundle().getSymbolicName(), getBundle().getVersion(), Arrays.asList(missingDependencies));
1:3e11f4a:                                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missingDependencies));
1:f13c6ac:                                 return;
1:f13c6ac:                             }
1:f13c6ac:                         }
1:f13c6ac:                         state = State.InitialReferencesSatisfied;
1:3e11f4a:                         break;
1:f13c6ac:                     case InitialReferencesSatisfied:
1:f13c6ac:                         processTypeConverters();
1:f13c6ac:                         processProcessors();
1:f13c6ac:                         state = State.WaitForInitialReferences2;
1:3e11f4a:                         break;
1:f13c6ac:                     case WaitForInitialReferences2:
1:f13c6ac:                         if (waitForDependencies) {
1:f13c6ac:                             String[] missingDependencies = getMissingDependencies();
1:f13c6ac:                             if (missingDependencies.length > 0) {
1:db4243b:                                 LOGGER.info("Bundle {}/{} is waiting for dependencies {}", getBundle().getSymbolicName(), getBundle().getVersion(), Arrays.asList(missingDependencies));
1:3e11f4a:                                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missingDependencies));
1:f13c6ac:                                 return;
1:f13c6ac:                             }
1:f13c6ac:                         }                       
1:f13c6ac:                         state = State.Create;
1:3e11f4a:                         break;
1:f13c6ac:                     case Create:
1:c3f255b:                         cancelFutureIfPresent();
1:f13c6ac:                         instantiateEagerComponents();
1:e0cac5e: 			//Register the services after the eager components are ready, as per 121.6
1:f13c6ac: 			registerServices();
1:f13c6ac:                         // Register the BlueprintContainer in the OSGi registry
1:3e11f4a:                         int bs = bundle.getState();
1:571928e:                         if (registration == null && (bs == Bundle.ACTIVE || bs == Bundle.STARTING)) {
1:f13c6ac:                             Properties props = new Properties();
1:f13c6ac:                             props.put(BlueprintConstants.CONTAINER_SYMBOLIC_NAME_PROPERTY,
1:3e11f4a:                                       bundle.getSymbolicName());
1:f13c6ac:                             props.put(BlueprintConstants.CONTAINER_VERSION_PROPERTY,
1:3e11f4a:                                       JavaUtils.getBundleVersion(bundle));
1:f13c6ac:                             registration = registerService(new String [] { BlueprintContainer.class.getName() }, this, props);
1:f13c6ac:                         }
1:3e11f4a:                         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATED, getBundle(), getExtenderBundle()));
1:f492016:                         state = State.Created;
1:3e11f4a:                         break;
1:f13c6ac:                     case Created:
1:f13c6ac:                     case Failed:
1:f13c6ac:                         return;
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         } catch (Throwable t) {
3:f13c6ac:             try {
1:f13c6ac:                 state = State.Failed;
1:135b9a1:                 cancelFutureIfPresent();
1:ca42e8d:                 tidyupComponents();
1:db4243b:                 LOGGER.error("Unable to start blueprint container for bundle {}/{}", getBundle().getSymbolicName(), getBundle().getVersion(), t);
1:3e11f4a:                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), t));
1:ca42e8d:             } catch (RuntimeException re) {
1:ca42e8d:                 LOGGER.debug("Tidying up components failed. ", re);
1:ca42e8d:                 throw re;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private List<URL> getResources() throws FileNotFoundException {
1:f13c6ac:         List<URL> resources = new ArrayList<URL>();
1:f13c6ac:         for (Object path : pathList) {
1:f13c6ac:             if (path instanceof URL) {
1:f13c6ac:                 resources.add((URL) path);                
1:f13c6ac:             } else if (path instanceof String) {
1:3e11f4a:                 URL url = bundle.getEntry((String) path);
1:f13c6ac:                 if (url == null) {
1:f13c6ac:                     throw new FileNotFoundException("Unable to find configuration file for " + path);
1:f13c6ac:                 } else {
1:f13c6ac:                     resources.add(url);
1:f13c6ac:                 }
1:f13c6ac:             } else {
1:f13c6ac:                 throw new IllegalArgumentException("Unexpected path type: " + path.getClass());
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return resources;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Class loadClass(final String name) throws ClassNotFoundException {
1:f13c6ac:         if (accessControlContext == null) {
1:3e11f4a:             return bundle.loadClass(name);
1:f13c6ac:         } else {
1:f13c6ac:             try {
1:f13c6ac:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Class>() {
1:f13c6ac:                     public Class run() throws Exception {
1:3e11f4a:                         return bundle.loadClass(name);
1:f13c6ac:                     }            
1:f13c6ac:                 }, accessControlContext);
1:f13c6ac:             } catch (PrivilegedActionException e) {
1:f13c6ac:                 Exception cause = e.getException();
1:f13c6ac:                 if (cause instanceof ClassNotFoundException) {
1:f13c6ac:                     throw (ClassNotFoundException) cause;
1:f13c6ac:                 }
1:f13c6ac:                 throw new IllegalStateException("Unexpected checked exception", cause);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:55084bf:     @Override
1:55084bf:     public ClassLoader getClassLoader() {
1:55084bf:         return getBundle().adapt(BundleWiring.class).getClassLoader();
1:55084bf:     }
1:55084bf: 
1:f13c6ac:     public ServiceRegistration registerService(final String[] classes, final Object service, final Dictionary properties) {
1:f13c6ac:         if (accessControlContext == null) {
1:f13c6ac:             return bundleContext.registerService(classes, service, properties);
1:f13c6ac:         } else {
1:f13c6ac:             return AccessController.doPrivileged(new PrivilegedAction<ServiceRegistration>() {
1:f13c6ac:                 public ServiceRegistration run() {
1:f13c6ac:                     return bundleContext.registerService(classes, service, properties);
1:f13c6ac:                 }            
1:f13c6ac:             }, accessControlContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Object getService(final ServiceReference reference) {
1:f13c6ac:         if (accessControlContext == null) {
1:f13c6ac:             return bundleContext.getService(reference);
1:f13c6ac:         } else {
1:f13c6ac:             return AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:f13c6ac:                 public Object run() {
1:f13c6ac:                     return bundleContext.getService(reference);
1:f13c6ac:                 }            
1:f13c6ac:             }, accessControlContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public AccessControlContext getAccessControlContext() {
1:f13c6ac:         return accessControlContext;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public BlueprintRepository getRepository() {
2:f13c6ac:         if (repository == null) {
1:9f9d944:             repository = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
1:f13c6ac:         }
1:f13c6ac:         return repository;
1:f13c6ac:     }
1:f13c6ac: 
1:55084bf:     protected void processTypeConverters() throws Exception {
1:f13c6ac:         List<String> typeConverters = new ArrayList<String>();
1:f13c6ac:         for (Target target : componentDefinitionRegistry.getTypeConverters()) {
1:f13c6ac:             if (target instanceof ComponentMetadata) {
1:f13c6ac:                 typeConverters.add(((ComponentMetadata) target).getId());
1:f13c6ac:             } else if (target instanceof RefMetadata) {
1:f13c6ac:                 typeConverters.add(((RefMetadata) target).getComponentId());
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Unexpected metadata for type converter: " + target);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:55084bf:         Map<String, Object> objects = getRepository().createAll(typeConverters, ProxyUtils.asList(Converter.class));
1:f13c6ac:         for (String name : typeConverters) {
1:f13c6ac:             Object obj = objects.get(name);
1:f13c6ac:             if (obj instanceof Converter) {
1:f13c6ac:                 converter.registerConverter((Converter) obj);
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Type converter " + obj + " does not implement the " + Converter.class.getName() + " interface");
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:55084bf:     protected void processProcessors() throws Exception {
1:3e11f4a:         // Instantiate ComponentDefinitionRegistryProcessor and BeanProcessor
1:f13c6ac:         for (BeanMetadata bean : getMetadata(BeanMetadata.class)) {
1:f13c6ac:             if (bean instanceof ExtendedBeanMetadata && !((ExtendedBeanMetadata) bean).isProcessor()) {
1:f13c6ac:                 continue;
1:f13c6ac:             }     
1:f13c6ac:             
1:f13c6ac:             Class clazz = null;
1:f13c6ac:             if (bean instanceof ExtendedBeanMetadata) {
1:f13c6ac:                 clazz = ((ExtendedBeanMetadata) bean).getRuntimeClass();
1:f13c6ac:             }            
1:f13c6ac:             if (clazz == null && bean.getClassName() != null) {
1:f13c6ac:                 clazz = loadClass(bean.getClassName());
1:f13c6ac:             }
1:f13c6ac:             if (clazz == null) {
1:f13c6ac:                 continue;
1:f13c6ac:             }
1:f13c6ac: 
1:cf22c81:             Object obj = null;
1:f13c6ac:             if (ComponentDefinitionRegistryProcessor.class.isAssignableFrom(clazz)) {
1:cf22c81:                 obj = repository.create(bean.getId(), ProxyUtils.asList(ComponentDefinitionRegistryProcessor.class));
1:f13c6ac:                 ((ComponentDefinitionRegistryProcessor) obj).process(componentDefinitionRegistry);
1:cf22c81:             }
1:cf22c81:             if (Processor.class.isAssignableFrom(clazz)) {
1:cf22c81:                 obj = repository.create(bean.getId(), ProxyUtils.asList(Processor.class));
1:f13c6ac:                 this.processors.add((Processor) obj);
1:cf22c81:             }
1:cf22c81:             if (obj == null) {
1:f13c6ac:                 continue;
1:f13c6ac:             }
1:6d7c26a:             untrackServiceReferences();
1:18ee583:             updateUninstantiatedRecipes();
1:f13c6ac:             getSatisfiableDependenciesMap(true);
1:f13c6ac:             trackServiceReferences();        
1:f13c6ac:         }
1:f13c6ac:     }
1:18ee583:     private void updateUninstantiatedRecipes() {
1:18ee583:         Repository tmpRepo = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
1:f13c6ac:         
1:18ee583:         LOGGER.debug("Updating blueprint repository");
1:f13c6ac:         
1:18ee583:         for (String name : repository.getNames()) {
2:18ee583:             if (repository.getInstance(name) == null) {
1:18ee583:                 LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
1:18ee583:                 repository.removeRecipe(name);
1:f13c6ac:             } else {
1:18ee583:                 LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         for (String name : tmpRepo.getNames()) {
1:f13c6ac:             if (repository.getInstance(name) == null) {
1:18ee583:                 LOGGER.debug("Adding new recipe {}", new Object[] { name });
1:f13c6ac:                 Recipe r = tmpRepo.getRecipe(name);
1:f13c6ac:                 if (r != null) {
1:f13c6ac:                     repository.putRecipe(name, r);
1:f13c6ac:                 }
2:18ee583:             } else {
1:18ee583:                 LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Map<String, List<SatisfiableRecipe>> getSatisfiableDependenciesMap() {
1:f13c6ac:         return getSatisfiableDependenciesMap(false);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Map<String, List<SatisfiableRecipe>> getSatisfiableDependenciesMap(boolean recompute) {
1:f13c6ac:         synchronized (satisfiablesLock) {
1:f13c6ac:             if ((recompute || satisfiables == null) && repository != null) {
1:f13c6ac:                 satisfiables = new HashMap<String, List<SatisfiableRecipe>>();
1:f13c6ac:                 for (Recipe r : repository.getAllRecipes()) {
1:f13c6ac:                     List<SatisfiableRecipe> recipes = repository.getAllRecipes(SatisfiableRecipe.class, r.getName());
1:f13c6ac:                     if (!recipes.isEmpty()) {
1:f13c6ac:                         satisfiables.put(r.getName(), recipes);
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             return satisfiables;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void trackServiceReferences() {
1:f13c6ac:         Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:f13c6ac:         Set<String> satisfiables = new HashSet<String>();
1:f13c6ac:         for (List<SatisfiableRecipe> recipes : dependencies.values()) {
1:f13c6ac:             for (SatisfiableRecipe satisfiable : recipes) {
1:f13c6ac:                 if (satisfiables.add(satisfiable.getName())) {
1:f13c6ac:                     satisfiable.start(this);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         LOGGER.debug("Tracking service references: {}", satisfiables);
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private void untrackServiceReferences() {
1:f13c6ac:         Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:f13c6ac:         if (dependencies != null) {
1:f13c6ac:             Set<String> stopped = new HashSet<String>();
1:f13c6ac:             for (List<SatisfiableRecipe> recipes : dependencies.values()) {
1:f13c6ac:                 for (SatisfiableRecipe satisfiable : recipes) {
1:f13c6ac:                     untrackServiceReference(satisfiable, stopped, dependencies);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac: 
1:370ce47:         synchronized (satisfiablesLock) {
1:370ce47:             satisfiables = null;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void untrackServiceReference(SatisfiableRecipe recipe, Set<String> stopped, Map<String, List<SatisfiableRecipe>> dependencies) {
1:f13c6ac:         if (stopped.add(recipe.getName())) {
1:f13c6ac:             for (Map.Entry<String, List<SatisfiableRecipe>> entry : dependencies.entrySet()) {
1:f13c6ac:                 if (entry.getValue().contains(recipe)) {
1:f13c6ac:                     Recipe r = getRepository().getRecipe(entry.getKey());
1:f13c6ac:                     if (r instanceof SatisfiableRecipe) {
1:f13c6ac:                         untrackServiceReference((SatisfiableRecipe) r, stopped, dependencies);
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             recipe.stop();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void notifySatisfaction(SatisfiableRecipe satisfiable) {
1:6d7c26a:         if (destroyed.get()) {
1:6d7c26a:             return;
1:6d7c26a:         }
1:db4243b:         LOGGER.debug("Notified satisfaction {} in bundle {}/{}: {}",
1:db4243b:                 satisfiable.getName(), bundle.getSymbolicName(), getBundle().getVersion(), satisfiable.isSatisfied());
1:f13c6ac:         if (state == State.Create || state == State.Created ) {
1:f13c6ac:             Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:f13c6ac:             for (Map.Entry<String, List<SatisfiableRecipe>> entry : dependencies.entrySet()) {
1:f13c6ac:                 String name = entry.getKey();
1:f13c6ac:                 ComponentMetadata metadata = componentDefinitionRegistry.getComponentDefinition(name);
1:f13c6ac:                 if (metadata instanceof ServiceMetadata) {
1:f13c6ac:                     ServiceRecipe reg = (ServiceRecipe) repository.getRecipe(name);
1:f13c6ac:                     synchronized (reg) {
1:f13c6ac:                         boolean satisfied = true;
1:f13c6ac:                         for (SatisfiableRecipe recipe : entry.getValue()) {
1:f13c6ac:                             if (!recipe.isSatisfied()) {
1:f13c6ac:                                 satisfied = false;
8:f13c6ac:                                 break;
1:f13c6ac:                             }
1:f13c6ac:                         }
1:f13c6ac:                         if (satisfied && !reg.isRegistered()) {
1:f13c6ac:                             LOGGER.debug("Registering service {} due to satisfied references", name);
1:f13c6ac:                             reg.register();
1:f13c6ac:                         } else if (!satisfied && reg.isRegistered()) {
1:f13c6ac:                             LOGGER.debug("Unregistering service {} due to unsatisfied references", name);
1:f13c6ac:                             reg.unregister();
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         } else {
1:f492016:             schedule();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void instantiateEagerComponents() {
1:f13c6ac:         List<String> components = new ArrayList<String>();
1:f13c6ac:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:f13c6ac:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:f13c6ac:             boolean eager = component.getActivation() == ComponentMetadata.ACTIVATION_EAGER;
1:f13c6ac:             if (component instanceof BeanMetadata) {
1:f13c6ac:                 BeanMetadata local = (BeanMetadata) component;
1:f13c6ac:                 eager &= MetadataUtil.isSingletonScope(local);
1:f13c6ac:             }
1:f13c6ac:             if (eager) {
1:f13c6ac:                 components.add(name);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         LOGGER.debug("Instantiating components: {}", components);
1:f13c6ac:         try {
1:f13c6ac:             repository.createAll(components);
1:f13c6ac:         } catch (ComponentDefinitionException e) {
1:f13c6ac:             throw e;
1:f13c6ac:         } catch (Throwable t) {
1:f13c6ac:             throw new ComponentDefinitionException("Unable to instantiate components", t);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void registerServices() {
1:f13c6ac:         services = repository.getAllRecipes(ServiceRecipe.class);
1:f13c6ac:         for (ServiceRecipe r : services) {
1:f13c6ac:             List<SatisfiableRecipe> dependencies = getSatisfiableDependenciesMap().get(r.getName());
1:f13c6ac:             boolean enabled = true;
1:f13c6ac:             if (dependencies != null) {
1:f13c6ac:                 for (SatisfiableRecipe recipe : dependencies) {
1:f13c6ac:                     if (!recipe.isSatisfied()) {
1:f13c6ac:                         enabled = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (enabled) {
1:f13c6ac:                 r.register();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:da163d0:     protected void unregisterServices() {
1:f13c6ac:         if (repository != null) {
1:f13c6ac:             List<ServiceRecipe> recipes = this.services;
1:f13c6ac:             this.services = null;
1:f13c6ac:             if (recipes != null) {
1:f13c6ac:                 for (ServiceRecipe r : recipes) {
1:f13c6ac:                     r.unregister();
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void destroyComponents() {
1:f13c6ac:         if (repository != null) {
1:f13c6ac:             repository.destroy();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private String[] getMissingDependencies() {
1:f13c6ac:         List<String> missing = new ArrayList<String>();
1:f13c6ac:         Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:f13c6ac:         Set<SatisfiableRecipe> recipes = new HashSet<SatisfiableRecipe>();
1:f13c6ac:         for (List<SatisfiableRecipe> deps : dependencies.values()) {
1:f13c6ac:             for (SatisfiableRecipe recipe : deps) {
1:f13c6ac:                 if (!recipe.isSatisfied()) {
1:f13c6ac:                     recipes.add(recipe);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         for (SatisfiableRecipe recipe : recipes) {
1:f13c6ac:             missing.add(recipe.getOsgiFilter());
1:f13c6ac:         }
1:f13c6ac:         return missing.toArray(new String[missing.size()]);
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Set<String> getComponentIds() {
1:e76da08:         return new LinkedHashSet<String>(componentDefinitionRegistry.getComponentDefinitionNames());
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public Object getComponentInstance(String id) throws NoSuchComponentException {
1:6d7c26a:         if (repository == null || destroyed.get()) {
1:f13c6ac:             throw new NoSuchComponentException(id);
1:f13c6ac:         }
1:f13c6ac:         try {
1:f13c6ac:             LOGGER.debug("Instantiating component {}", id);
1:f13c6ac:             return repository.create(id);
1:f13c6ac:         } catch (NoSuchComponentException e) {
1:f13c6ac:             throw e;
1:f13c6ac:         } catch (ComponentDefinitionException e) {
1:f13c6ac:             throw e;
1:f13c6ac:         } catch (Throwable t) {
1:f13c6ac:             throw new ComponentDefinitionException("Cound not create component instance for " + id, t);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public ComponentMetadata getComponentMetadata(String id) {
1:f13c6ac:         ComponentMetadata metadata = componentDefinitionRegistry.getComponentDefinition(id);
1:f13c6ac:         if (metadata == null) {
1:f13c6ac:             throw new NoSuchComponentException(id);
1:f13c6ac:         }
1:f13c6ac:         return metadata;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public <T extends ComponentMetadata> Collection<T> getMetadata(Class<T> clazz) {
1:f13c6ac:         Collection<T> metadatas = new ArrayList<T>();
1:f13c6ac:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:f13c6ac:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:f13c6ac:             getMetadata(clazz, component, metadatas);
1:f13c6ac:         }
1:f13c6ac:         metadatas = Collections.unmodifiableCollection(metadatas);
1:f13c6ac:         return metadatas;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private <T extends ComponentMetadata> void getMetadata(Class<T> clazz, Metadata component, Collection<T> metadatas) {
1:f13c6ac:         if (component == null) {
1:f13c6ac:             return;
1:f13c6ac:         }
1:f13c6ac:         if (clazz.isInstance(component)) {
1:f13c6ac:             metadatas.add(clazz.cast(component));
1:f13c6ac:         }
1:f13c6ac:         if (component instanceof BeanMetadata) {
1:f13c6ac:             getMetadata(clazz, ((BeanMetadata) component).getFactoryComponent(), metadatas);
1:f13c6ac:             for (BeanArgument arg : ((BeanMetadata) component).getArguments()) {
1:f13c6ac:                 getMetadata(clazz, arg.getValue(), metadatas);
1:f13c6ac:             }
1:f13c6ac:             for (BeanProperty prop : ((BeanMetadata) component).getProperties()) {
1:f13c6ac:                 getMetadata(clazz, prop.getValue(), metadatas);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (component instanceof CollectionMetadata) {
1:f13c6ac:             for (Metadata m : ((CollectionMetadata) component).getValues()) {
1:f13c6ac:                 getMetadata(clazz, m, metadatas);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (component instanceof MapMetadata) {
1:f13c6ac:             for (MapEntry m : ((MapMetadata) component).getEntries()) {
1:f13c6ac:                 getMetadata(clazz, m.getKey(), metadatas);
1:f13c6ac:                 getMetadata(clazz, m.getValue(), metadatas);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (component instanceof PropsMetadata) {
1:f13c6ac:             for (MapEntry m : ((PropsMetadata) component).getEntries()) {
1:f13c6ac:                 getMetadata(clazz, m.getKey(), metadatas);
1:f13c6ac:                 getMetadata(clazz, m.getValue(), metadatas);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (component instanceof ServiceReferenceMetadata) {
1:f13c6ac:             for (ReferenceListener l : ((ServiceReferenceMetadata) component).getReferenceListeners()) {
1:f13c6ac:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (component instanceof ServiceMetadata) {
1:f13c6ac:             getMetadata(clazz, ((ServiceMetadata) component).getServiceComponent(), metadatas);
1:f13c6ac:             for (MapEntry m : ((ServiceMetadata) component).getServiceProperties()) {
1:f13c6ac:                 getMetadata(clazz, m.getKey(), metadatas);
1:f13c6ac:                 getMetadata(clazz, m.getValue(), metadatas);
1:f13c6ac:             }
1:f13c6ac:             for (RegistrationListener l : ((ServiceMetadata) component).getRegistrationListeners()) {
1:f13c6ac:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Converter getConverter() {
1:f13c6ac:         return converter;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public ComponentDefinitionRegistryImpl getComponentDefinitionRegistry() {
1:f13c6ac:         return componentDefinitionRegistry;
1:f13c6ac:     }
1:f13c6ac:         
1:f13c6ac:     public BundleContext getBundleContext() {
1:f13c6ac:         return bundleContext;
1:f13c6ac:     }
1:3e11f4a: 
1:3e11f4a:     public Bundle getBundle() {
1:3e11f4a:         return bundle;
1:3e11f4a:     }
1:3e11f4a: 
1:f13c6ac:     public void destroy() {
1:6d7c26a:         synchronized (scheduled) {
1:6d7c26a:             destroyed.set(true);
1:6d7c26a:         }
1:3e11f4a:         cancelFutureIfPresent();
1:3e11f4a: 
1:6d7c26a:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
1:6d7c26a:         executors.shutdownNow();
1:6d7c26a:         if (handlerSet != null) {
1:6d7c26a:             handlerSet.removeListener(this);
1:6d7c26a:             handlerSet.destroy();
1:6d7c26a:         }
1:3e11f4a: 
1:6d7c26a:         try {
1:6d7c26a:             executors.awaitTermination(5 * 60, TimeUnit.SECONDS);
1:6d7c26a:         } catch (InterruptedException e) {
1:6d7c26a:             LOGGER.debug("Interrupted waiting for executor to shut down");
1:6d7c26a:         }
1:3e11f4a: 
1:6d7c26a:         tidyupComponents();
1:f13c6ac: 
1:6d7c26a:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYED, getBundle(), getExtenderBundle()));
1:db4243b:         LOGGER.debug("Blueprint container {} destroyed", getBundle().getSymbolicName(), getBundle().getVersion());
1:3e11f4a:     }
1:f13c6ac:     
1:da163d0:     protected void quiesce() {
1:6d7c26a:         destroyed.set(true);
2:3e11f4a:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
1:f13c6ac: 
1:ca42e8d:         cancelFutureIfPresent();
1:3e11f4a:         AriesFrameworkUtil.safeUnregisterService(registration);
1:3e11f4a:         if (handlerSet != null) {
1:3e11f4a:             handlerSet.removeListener(this);
1:3e11f4a:             handlerSet.destroy();
1:f13c6ac:         }
1:db4243b:         LOGGER.debug("Blueprint container {} quiesced", getBundle().getSymbolicName(), getBundle().getVersion());
1:f13c6ac:     }
1:f13c6ac: 
1:ef7b490:     private void cancelFutureIfPresent()
1:ef7b490:     {
2:f13c6ac:       if (timeoutFuture != null) {
3:f13c6ac:           timeoutFuture.cancel(false);
1:f13c6ac:       }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void namespaceHandlerRegistered(URI uri) {
1:9a1ff22:         if (handlerSet != null && handlerSet.getNamespaces().contains(uri)) {
3:f13c6ac:             schedule();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void namespaceHandlerUnregistered(URI uri) {
1:9a1ff22:         if (handlerSet != null && handlerSet.getNamespaces().contains(uri)) {
1:3e11f4a:             synchronized (scheduled) {
1:6d7c26a:                 if (destroyed.get()) {
1:6d7c26a:                     return;
1:3e11f4a:                 }
1:3e11f4a:                 tidyupComponents();
1:e76da08:                 resetComponentDefinitionRegistry();
1:ef7b490:                 cancelFutureIfPresent();
1:3e11f4a:                 this.repository = null;
1:3e11f4a:                 handlerSet.removeListener(this);
1:3e11f4a:                 handlerSet.destroy();
1:3e11f4a:                 handlerSet = handlers.getNamespaceHandlers(namespaces, getBundle());
1:3b2c33b:                 handlerSet.addListener(this);
1:3e11f4a:                 state = State.WaitForNamespaceHandlers;
1:3e11f4a:                 schedule();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f25cf7c:     private void tidyupComponents()
1:f25cf7c:     {
1:3e11f4a:       unregisterServices();
1:3e11f4a:       destroyComponents();
1:b42121e:       untrackServiceReferences();
1:f492016:     }
1:f13c6ac: 
1:7959fcd:     public void injectBeanInstance(BeanMetadata bmd, Object o) 
1:7959fcd:         throws IllegalArgumentException, ComponentDefinitionException {
1:7959fcd:         ExecutionContext origContext 
1:7959fcd:             = ExecutionContext.Holder.setContext((ExecutionContext)getRepository());
1:3e11f4a:         try {
1:7959fcd:             ComponentMetadata cmd = componentDefinitionRegistry.getComponentDefinition(bmd.getId());
1:7959fcd:             if (cmd == null || cmd != bmd) {
1:7959fcd:                 throw new IllegalArgumentException(bmd.getId() + " not found in blueprint container");
1:f13c6ac:             }
1:7959fcd:             Recipe r = this.getRepository().getRecipe(bmd.getId());
1:7959fcd:             if (r instanceof BeanRecipe) {
1:7959fcd:                 BeanRecipe br = (BeanRecipe)r;
1:7959fcd:                 if (!br.getType().isInstance(o)) {
1:7959fcd:                     throw new IllegalArgumentException("Instance class " + o.getClass().getName() 
1:7959fcd:                                                        + " is not an instance of " + br.getClass());
1:f13c6ac:                 }
1:7959fcd:                 br.setProperties(o);
1:18ee583:             } else {
1:7959fcd:                 throw new IllegalArgumentException(bmd.getId() + " does not refer to a BeanRecipe");
1:f13c6ac:             }
1:e21ec8f:         } finally {
1:7959fcd:             ExecutionContext.Holder.setContext(origContext);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:0871217:     // this could be parameterized/customized, but for now, hard-coded for ignoring datatype validation
1:0871217:     private static class ValidationHandler implements ErrorHandler {
1:0871217:         @Override
1:0871217:         public void warning(SAXParseException exception) throws SAXException {
1:0871217:             // ignore
1:f13c6ac:         }
1:0871217:         @Override
1:0871217:         public void error(SAXParseException exception) throws SAXException {
1:0871217:             final String cvctext = exception.getMessage(); 
1:0871217:             if (cvctext != null && 
1:0871217:                 (cvctext.startsWith("cvc-datatype-valid.1") || cvctext.startsWith("cvc-attribute.3"))) {
1:0871217:                 return;
1:f13c6ac:             }
1:0871217:             throw exception;
1:f13c6ac:         }
1:f13c6ac: 
1:0871217:         @Override
1:0871217:         public void fatalError(SAXParseException exception) throws SAXException {
1:0871217:             throw exception;
1:0231f6a:         }
4:0871217:     }
1:0871217: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:9a1ff22
/////////////////////////////////////////////////////////////////////////
1:                         for (URI ns : handlerSet.getNamespaces()) {
/////////////////////////////////////////////////////////////////////////
1:                             handlerSet.getNamespaces().add(e.getNamespace());
/////////////////////////////////////////////////////////////////////////
1:         if (handlerSet != null && handlerSet.getNamespaces().contains(uri)) {
1:         if (handlerSet != null && handlerSet.getNamespaces().contains(uri)) {
/////////////////////////////////////////////////////////////////////////
1:                 handlerSet.removeListener(this);
1:                 handlerSet.destroy();
1:                 handlerSet = handlers.getNamespaceHandlers(namespaces, getBundle());
1:                 handlerSet.addListener(this);
commit:94f26b1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.namespace.MissingNamespaceException;
/////////////////////////////////////////////////////////////////////////
1:                         try {
1:                             if (xmlValidation == null || "true".equals(xmlValidation)) {
1:                                 parser.validate(handlerSet.getSchema(parser.getSchemaLocations()));
1:                             } else if ("structure".equals(xmlValidation)) {
1:                                 parser.validate(handlerSet.getSchema(parser.getSchemaLocations()), new ValidationHandler());
1:                             } else if ("psvi".equals(xmlValidation)) {
1:                                 parser.validatePsvi(handlerSet.getSchema(parser.getSchemaLocations()));
1:                             }
1:                             parser.populate(handlerSet, componentDefinitionRegistry);
1:                             state = State.Populated;
1:                         } catch (MissingNamespaceException e) {
1:                             // If we found a missing namespace when parsing the schema,
1:                             // we remain in the current state
0:                             namespaces.add(e.getNamespace());
commit:c89ef70
/////////////////////////////////////////////////////////////////////////
1:     private final Collection<URI> additionalNamespaces;
/////////////////////////////////////////////////////////////////////////
1:                                   List<Object> pathList, ProxyManager proxyManager, Collection<URI> namespaces) {
/////////////////////////////////////////////////////////////////////////
1:         this.additionalNamespaces = namespaces;
/////////////////////////////////////////////////////////////////////////
1:                         if (additionalNamespaces != null) {
1:                             namespaces.addAll(additionalNamespaces);
1:                         }
commit:220c392
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.NamespaceHandler2;
/////////////////////////////////////////////////////////////////////////
1:                             for (URI ns : handlerSet.getNamespaces()) {
1:                                 NamespaceHandler handler = handlerSet.getNamespaceHandler(ns);
1:                                 if (handler instanceof NamespaceHandler2) {
1:                                     if (((NamespaceHandler2) handler).usePsvi()) {
1:                                         xmlValidation = "psvi";
1:                                         break;
1:                                     }
1:                                 }
1:                             }
1:                         }
1:                         if (xmlValidation == null || "true".equals(xmlValidation)) {
0:                         } else if ("psvi".equals(xmlValidation)) {
0:                             parser.validatePsvi(handlerSet.getSchema(parser.getSchemaLocations()));
commit:55084bf
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
1:     protected void resetComponentDefinitionRegistry() {
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public ClassLoader getClassLoader() {
1:         return getBundle().adapt(BundleWiring.class).getClassLoader();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected void processTypeConverters() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         Map<String, Object> objects = getRepository().createAll(typeConverters, ProxyUtils.asList(Converter.class));
/////////////////////////////////////////////////////////////////////////
1:     protected void processProcessors() throws Exception {
commit:cf22c81
/////////////////////////////////////////////////////////////////////////
1:             Object obj = null;
1:                 obj = repository.create(bean.getId(), ProxyUtils.asList(ComponentDefinitionRegistryProcessor.class));
1:             }
1:             if (Processor.class.isAssignableFrom(clazz)) {
1:                 obj = repository.create(bean.getId(), ProxyUtils.asList(Processor.class));
1:             }
1:             if (obj == null) {
commit:f117d81
/////////////////////////////////////////////////////////////////////////
0:                             parser.validate(handlerSet.getSchema(parser.getSchemaLocations()));
0:                             parser.validate(handlerSet.getSchema(parser.getSchemaLocations()), new ValidationHandler());
commit:c3f255b
/////////////////////////////////////////////////////////////////////////
1:             cancelFutureIfPresent();
/////////////////////////////////////////////////////////////////////////
1:                 cancelFutureIfPresent();
commit:db4243b
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.debug("Running blueprint container for bundle {}/{} in state {}", getBundle().getSymbolicName(), getBundle().getVersion(), state);
/////////////////////////////////////////////////////////////////////////
1:                             LOGGER.info("Bundle {}/{} is waiting for namespace handlers {}", getBundle().getSymbolicName(), getBundle().getVersion(), missingURIs);
/////////////////////////////////////////////////////////////////////////
1:                                     LOGGER.error("Unable to start blueprint container for bundle {}/{} due to unresolved dependencies {}", getBundle().getSymbolicName(), getBundle().getVersion(), Arrays.asList(missingDependecies), t);
/////////////////////////////////////////////////////////////////////////
1:                                 LOGGER.info("Bundle {}/{} is waiting for dependencies {}", getBundle().getSymbolicName(), getBundle().getVersion(), Arrays.asList(missingDependencies));
/////////////////////////////////////////////////////////////////////////
1:                                 LOGGER.info("Bundle {}/{} is waiting for dependencies {}", getBundle().getSymbolicName(), getBundle().getVersion(), Arrays.asList(missingDependencies));
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.error("Unable to start blueprint container for bundle {}/{}", getBundle().getSymbolicName(), getBundle().getVersion(), t);
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.debug("Notified satisfaction {} in bundle {}/{}: {}",
1:                 satisfiable.getName(), bundle.getSymbolicName(), getBundle().getVersion(), satisfiable.isSatisfied());
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.debug("Blueprint container {} destroyed", getBundle().getSymbolicName(), getBundle().getVersion());
/////////////////////////////////////////////////////////////////////////
1:         LOGGER.debug("Blueprint container {} quiesced", getBundle().getSymbolicName(), getBundle().getVersion());
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1:     public enum State {
/////////////////////////////////////////////////////////////////////////
1:     public State getState() {
1:         return state;
1:     }
1: 
commit:b42121e
/////////////////////////////////////////////////////////////////////////
1:       untrackServiceReferences();
commit:6d7c26a
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean destroyed = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:     private final AccessControlContext accessControlContext;
1:     private final ProxyManager proxyManager;
1:     public BlueprintContainerImpl(Bundle bundle, BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher,
1:         this.bundle = bundle;
/////////////////////////////////////////////////////////////////////////
1:         } else {
1:             this.accessControlContext = null;
/////////////////////////////////////////////////////////////////////////
1:             if (destroyed.get()) {
1:                 return;
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 if (destroyed.get()) {
/////////////////////////////////////////////////////////////////////////
1:                                     if (destroyed.get()) {
1:                                         return;
1:                                     }
/////////////////////////////////////////////////////////////////////////
1:         if (destroyed.get()) {
1:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (repository == null || destroyed.get()) {
/////////////////////////////////////////////////////////////////////////
1:         synchronized (scheduled) {
1:             destroyed.set(true);
1:         }
1:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
1:         executors.shutdownNow();
1:         if (handlerSet != null) {
1:             handlerSet.removeListener(this);
1:             handlerSet.destroy();
1:         }
1:         try {
1:             executors.awaitTermination(5 * 60, TimeUnit.SECONDS);
1:         } catch (InterruptedException e) {
1:             LOGGER.debug("Interrupted waiting for executor to shut down");
1:         }
1:         tidyupComponents();
1:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYED, getBundle(), getExtenderBundle()));
0:         LOGGER.debug("Blueprint container destroyed: {}", this.bundleContext);
1:         destroyed.set(true);
/////////////////////////////////////////////////////////////////////////
1:                 if (destroyed.get()) {
1:                     return;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:       untrackServiceReferences();
commit:fe68bf1
/////////////////////////////////////////////////////////////////////////
0:         this.bundle = bundleContext != null ? bundleContext.getBundle() : null;
1:         this.executors = executor != null ? new ExecutorServiceWrapper(executor) : null;
commit:3e11f4a
/////////////////////////////////////////////////////////////////////////
1:     private final Bundle bundle;
1:     private final ExecutorService executors;
1:     private final ScheduledExecutorService timer;
/////////////////////////////////////////////////////////////////////////
1:                                   NamespaceHandlerRegistry handlers, ExecutorService executor, ScheduledExecutorService timer,
0:                                   List<Object> pathList, ProxyManager proxyManager) {
0:         this.bundle = bundleContext.getBundle();
0:         this.executors = new ExecutorServiceWrapper(executor);
1:         this.timer = timer;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         synchronized (scheduled) {
1:             tidyupComponents();
1:             this.componentDefinitionRegistry.reset();
1:             this.repository = null;
1:             this.processors = new ArrayList<Processor>();
1:             timeout = 5 * 60 * 1000;
1:             waitForDependencies = true;
0:             xmlValidation = true;
1:             if (handlerSet != null) {
1:                 handlerSet.removeListener(this);
1:                 handlerSet.destroy();
1:                 handlerSet = null;
1:             }
1:             state = State.Unknown;
1:             schedule();
1:         }
1:             doRun();
/////////////////////////////////////////////////////////////////////////
1:                 if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
1:                     return;
1:                 }
1:                 if (bundle.getBundleContext() != bundleContext) {
1:                     return;
1:                 }
0:                 LOGGER.debug("Running blueprint container for bundle {} in state {}", bundle.getSymbolicName(), state);
1:                         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATING, getBundle(), getExtenderBundle()));
1:                         handlerSet = handlers.getNamespaceHandlers(namespaces, getBundle());
1:                         break;
/////////////////////////////////////////////////////////////////////////
0:                             LOGGER.info("Bundle {} is waiting for namespace handlers {}", getBundle().getSymbolicName(), missingURIs);
1:                             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missing.toArray(new String[missing.size()])));
1:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundle));
/////////////////////////////////////////////////////////////////////////
1:                         break;
/////////////////////////////////////////////////////////////////////////
0:                                     LOGGER.error("Unable to start blueprint container for bundle " + getBundle().getSymbolicName() + " due to unresolved dependencies " + Arrays.asList(missingDependecies), t);
1:                                     eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), missingDependecies, t));
1:                         timeoutFuture = timer.schedule(r, timeout, TimeUnit.MILLISECONDS);
1:                         break;
0:                                 LOGGER.info("Bundle {} is waiting for dependencies {}", getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
1:                                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missingDependencies));
1:                         break;
1:                         break;
0:                                 LOGGER.info("Bundle {} is waiting for dependencies {}", getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
1:                                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missingDependencies));
1:                         break;
1:                         int bs = bundle.getState();
1:                                       bundle.getSymbolicName());
1:                                       JavaUtils.getBundleVersion(bundle));
1:                         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATED, getBundle(), getExtenderBundle()));
1:                         break;
/////////////////////////////////////////////////////////////////////////
0:             LOGGER.error("Unable to start blueprint container for bundle " + getBundle().getSymbolicName(), t);
1:             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), t));
/////////////////////////////////////////////////////////////////////////
1:                 URL url = bundle.getEntry((String) path);
/////////////////////////////////////////////////////////////////////////
1:             return bundle.loadClass(name);
1:                         return bundle.loadClass(name);
/////////////////////////////////////////////////////////////////////////
1:         // Instantiate ComponentDefinitionRegistryProcessor and BeanProcessor
/////////////////////////////////////////////////////////////////////////
0:                 new Object[] { satisfiable.getName(), bundle.getSymbolicName(), satisfiable.isSatisfied() });
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Bundle getBundle() {
1:         return bundle;
1:     }
1: 
0: //        synchronized (scheduled) {
0:             destroyed = true;
1:             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
0:             executors.shutdownNow();
1:             cancelFutureIfPresent();
1:             AriesFrameworkUtil.safeUnregisterService(registration);
1:             unregisterServices();
1: 
1:             if (handlerSet != null) {
1:                 handlerSet.removeListener(this);
1:                 handlerSet.destroy();
1:             destroyComponents();
0:             untrackServiceReferences();
1: 
1:             try {
0:                 executors.awaitTermination(5 * 60, TimeUnit.SECONDS);
0:             } catch (InterruptedException e) {
0:                 LOGGER.debug("Interrupted waiting for executor to shut down");
1:             }
1: 
0:             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYED, getBundle(), getExtenderBundle()));
0:             LOGGER.debug("Blueprint container destroyed: {}", this.bundleContext);
0: //        }
1:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
/////////////////////////////////////////////////////////////////////////
0:         LOGGER.debug("Blueprint container quiesced: {}", getBundleContext());
/////////////////////////////////////////////////////////////////////////
1:             synchronized (scheduled) {
1:                 tidyupComponents();
0:                 this.componentDefinitionRegistry.reset();
1:                 this.repository = null;
1:                 state = State.WaitForNamespaceHandlers;
1:                 schedule();
1:             }
commit:e57c8bb
/////////////////////////////////////////////////////////////////////////
0:             this.componentDefinitionRegistry.reset();
0:             this.repository = null;
commit:8351107
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ExecutorService;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.parser.Parser;
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.utils.JavaUtils;
/////////////////////////////////////////////////////////////////////////
1:     public ExecutorService getExecutors() {
1:         return executors;
1:     }
1: 
commit:78312c9
/////////////////////////////////////////////////////////////////////////
0:                         componentDefinitionRegistry.reset();
commit:d92e123
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final Class[] SECURITY_BUGFIX = {
1:             BlueprintDomainCombiner.class,
1:             BlueprintProtectionDomain.class,
1:     };
1:     
/////////////////////////////////////////////////////////////////////////
1:             this.accessControlContext = BlueprintDomainCombiner.createAccessControlContext(bundleContext);
/////////////////////////////////////////////////////////////////////////
commit:e21ec8f
/////////////////////////////////////////////////////////////////////////
0:     private Thread runningThread;
/////////////////////////////////////////////////////////////////////////
0:                 runningThread = Thread.currentThread();
1:             }
1:             try {
0:                 doRun();
1:             } finally {
0:                 synchronized (running) {
0:                     runningThread = null;
/////////////////////////////////////////////////////////////////////////
0:                 if (runningThread != null) {
0:                     runningThread.interrupt();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         if (handlerSet != null) {
0:             handlerSet.removeListener(this);
0:             handlerSet.destroy();
1:         }
commit:4dfd2d8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.ProxyManager;
/////////////////////////////////////////////////////////////////////////
0:     private ProxyManager proxyManager;
1: 
0:     public BlueprintContainerImpl(BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher,
0:                                   NamespaceHandlerRegistry handlers, ScheduledExecutorService executors, List<Object> pathList, ProxyManager proxyManager) {
/////////////////////////////////////////////////////////////////////////
1:         this.proxyManager = proxyManager;
1:     public ProxyManager getProxyManager() {
1:         return proxyManager;
1:     }
1: 
commit:549996c
/////////////////////////////////////////////////////////////////////////
0:                             LOGGER.info("Bundle {} is waiting for namespace handlers ", bundleContext.getBundle().getSymbolicName(), missing);
/////////////////////////////////////////////////////////////////////////
0:                                 LOGGER.info("Bundle {} is waiting for dependencies {}", bundleContext.getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
/////////////////////////////////////////////////////////////////////////
0:                                 LOGGER.info("Bundle {} is waiting for dependencies {}", bundleContext.getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
commit:571928e
/////////////////////////////////////////////////////////////////////////
0:                         int bs = bundleContext.getBundle().getState();
1:                         if (registration == null && (bs == Bundle.ACTIVE || bs == Bundle.STARTING)) {
commit:f492016
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void reload() {
0:         unregisterServices();
0:         untrackServiceReferences();
0:         destroyComponents();
0:         this.componentDefinitionRegistry.reset();
0:         this.repository = null;
1:         this.processors = new ArrayList<Processor>();
0:         timeout = 5 * 60 * 1000;
0:         waitForDependencies = true;
0:         xmlValidation = true;
0:         state = State.Unknown;
1:         schedule();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATED, getBundleContext().getBundle(), getExtenderBundle()));
1:                         state = State.Created;
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
0:     private NamespaceHandlerRegistry.NamespaceHandlerSet handlerSet;
/////////////////////////////////////////////////////////////////////////
0:                         handlerSet = handlers.getNamespaceHandlers(namespaces, getBundleContext().getBundle());
1:                         handlerSet.addListener(this);
1:                             if (handlerSet.getNamespaceHandler(ns) == null) {
/////////////////////////////////////////////////////////////////////////
0:                         if (xmlValidation) {
0:                             parser.validate(handlerSet.getSchema());
1:                         }
0:                         parser.populate(handlerSet, componentDefinitionRegistry);
/////////////////////////////////////////////////////////////////////////
0:         if (handlerSet != null) {
0:             handlerSet.removeListener(this);
0:             handlerSet.destroy();
1:         }
commit:2f55d71
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
/////////////////////////////////////////////////////////////////////////
1:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
0:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundleContext.getBundle()));
1:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundleContext", bundleContext));
1:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintConverter", converter));
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.io.FileNotFoundException;
1: import java.net.URI;
1: import java.net.URL;
1: import java.security.AccessControlContext;
1: import java.security.AccessController;
0: import java.security.DomainCombiner;
0: import java.security.Permission;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
0: import java.security.ProtectionDomain;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Dictionary;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Properties;
1: import java.util.Set;
1: import java.util.LinkedHashSet;
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.ScheduledFuture;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.TimeoutException;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
0: import org.apache.geronimo.blueprint.BlueprintConstants;
0: import org.apache.geronimo.blueprint.ComponentDefinitionRegistryProcessor;
0: import org.apache.geronimo.blueprint.ExtendedBeanMetadata;
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.NamespaceHandler;
0: import org.apache.geronimo.blueprint.Processor;
0: import org.apache.geronimo.blueprint.reflect.EnvironmentMetadataImpl;
0: import org.apache.geronimo.blueprint.reflect.MetadataUtil;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.di.Repository;
0: import org.apache.geronimo.blueprint.namespace.ComponentDefinitionRegistryImpl;
0: import org.apache.geronimo.blueprint.namespace.NamespaceHandlerRegistryImpl;
0: import org.apache.geronimo.blueprint.utils.HeaderParser;
0: import org.apache.geronimo.blueprint.utils.JavaUtils;
0: import org.apache.geronimo.blueprint.utils.HeaderParser.PathElement;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.service.blueprint.container.BlueprintContainer;
1: import org.osgi.service.blueprint.container.BlueprintEvent;
1: import org.osgi.service.blueprint.container.BlueprintListener;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.container.Converter;
1: import org.osgi.service.blueprint.container.NoSuchComponentException;
1: import org.osgi.service.blueprint.reflect.BeanArgument;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.MapEntry;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.PropsMetadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.Target;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * TODO: javadoc
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 760378 $, $Date: 2009-03-31 11:31:38 +0200 (Tue, 31 Mar 2009) $
1:  */
0: public class BlueprintContainerImpl implements ExtendedBlueprintContainer, NamespaceHandlerRegistry.Listener, Runnable, SatisfiableRecipe.SatisfactionListener {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintContainerImpl.class);
1: 
0:     private enum State {
1:         Unknown,
1:         WaitForNamespaceHandlers,
1:         Populated,
1:         WaitForInitialReferences,
1:         InitialReferencesSatisfied,
1:         WaitForInitialReferences2,
1:         Create,
1:         Created,
1:         Failed,
1:     }
1: 
1:     private final BundleContext bundleContext;
1:     private final Bundle extenderBundle;
1:     private final BlueprintListener eventDispatcher;
1:     private final NamespaceHandlerRegistry handlers;
1:     private final List<Object> pathList;
1:     private final ComponentDefinitionRegistryImpl componentDefinitionRegistry;
1:     private final AggregateConverter converter;
0:     private final ScheduledExecutorService executors;
1:     private Set<URI> namespaces;
1:     private State state = State.Unknown;
0:     private boolean destroyed;
1:     private Parser parser;
1:     private BlueprintRepository repository;
1:     private ServiceRegistration registration;
1:     private List<Processor> processors;
1:     private final Object satisfiablesLock = new Object();
1:     private Map<String, List<SatisfiableRecipe>> satisfiables;
1:     private long timeout = 5 * 60 * 1000;
1:     private boolean waitForDependencies = true;
0:     private boolean xmlValidation = true;
1:     private ScheduledFuture timeoutFuture;
1:     private final AtomicBoolean scheduled = new AtomicBoolean();
0:     private final AtomicBoolean running = new AtomicBoolean();
1:     private List<ServiceRecipe> services;
0:     private AccessControlContext accessControlContext;
1: 
0:     public BlueprintContainerImpl(BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher, NamespaceHandlerRegistry handlers, ScheduledExecutorService executors, List<Object> pathList) {
1:         this.bundleContext = bundleContext;
1:         this.extenderBundle = extenderBundle;
1:         this.eventDispatcher = eventDispatcher;
1:         this.handlers = handlers;
1:         this.pathList = pathList;
1:         this.converter = new AggregateConverter(this);
1:         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl();
0:         this.executors = executors;
0:         this.processors = new ArrayList<Processor>();
1:         if (System.getSecurityManager() != null) {
0:             this.accessControlContext = createAccessControlContext();
1:         }
1:     }
1: 
1:     public Bundle getExtenderBundle() {
1:         return extenderBundle;
1:     }
1: 
1:     public <T extends Processor> List<T> getProcessors(Class<T> clazz) {
1:         List<T> p = new ArrayList<T>();
1:         for (Processor processor : processors) {
1:             if (clazz.isInstance(processor)) {
1:                 p.add(clazz.cast(processor));
1:             }
1:         }
1:         return p;
1:     }
1: 
1:     public BlueprintListener getEventDispatcher() {
1:         return eventDispatcher;
1:     }
1: 
0:     private void checkDirectives() {
0:         Bundle bundle = bundleContext.getBundle();
1:         Dictionary headers = bundle.getHeaders();
1:         String symbolicName = (String)headers.get(Constants.BUNDLE_SYMBOLICNAME);
1:         List<PathElement> paths = HeaderParser.parseHeader(symbolicName);
1: 
1:         String timeoutDirective = paths.get(0).getDirective(BlueprintConstants.TIMEOUT_DIRECTIVE);
1:         if (timeoutDirective != null) {
1:             LOGGER.debug("Timeout directive: {}", timeoutDirective);
1:             timeout = Integer.parseInt(timeoutDirective);
1:         }
1: 
1:         String graceperiod = paths.get(0).getDirective(BlueprintConstants.GRACE_PERIOD);
1:         if (graceperiod != null) {
1:             LOGGER.debug("Grace-period directive: {}", graceperiod);
1:             waitForDependencies = Boolean.parseBoolean(graceperiod);
1:         }
1: 
0:         String xmlValidationDirective = paths.get(0).getDirective(BlueprintConstants.XML_VALIDATION);
0:         if (xmlValidationDirective != null) {
0:             LOGGER.debug("Xml-validation directive: {}", xmlValidationDirective);
0:             xmlValidation = Boolean.parseBoolean(xmlValidationDirective);
1:         }
1:     }
1:     
1:     public void schedule() {
1:         if (scheduled.compareAndSet(false, true)) {
1:             executors.submit(this);
1:         }
1:     }
1:     
1:     public void run() {
1:         scheduled.set(false);
1:         synchronized (scheduled) {
0:             synchronized (running) {
0:                 running.set(true);
1:                 try {
0:                     doRun();
0:                 } finally {
0:                     running.set(false);
0:                     running.notifyAll();
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * This method must be called inside a synchronized block to ensure this method is not run concurrently
1:      */
1:     private void doRun() {
1:         try {
1:             for (;;) {
0:                 if (destroyed) {
1:                     return;
1:                 }
0:                 LOGGER.debug("Running blueprint container for bundle {} in state {}", bundleContext.getBundle().getSymbolicName(), state);
1:                 switch (state) {
1:                     case Unknown:
0:                         checkDirectives();
0:                         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATING, getBundleContext().getBundle(), getExtenderBundle()));
1:                         parser = new Parser();
0:                         parser.setValidation(xmlValidation);
1:                         parser.parse(getResources());
1:                         namespaces = parser.getNamespaces();
0:                         if (namespaces.size() > 0) {
0:                             handlers.addListener(this);
1:                         }
1:                         state = State.WaitForNamespaceHandlers;
1:                         break;
1:                     case WaitForNamespaceHandlers:
1:                     {
1:                         List<String> missing = new ArrayList<String>();
0:                         for (URI ns : namespaces) {
0:                             if (handlers.getNamespaceHandler(ns) == null) {
1:                                 missing.add("(&(" + Constants.OBJECTCLASS + "=" + NamespaceHandler.class.getName() + ")(" + NamespaceHandlerRegistryImpl.NAMESPACE + "=" + ns + "))");
1:                             }
1:                         }
1:                         if (missing.size() > 0) {
0:                             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundleContext().getBundle(), getExtenderBundle(), missing.toArray(new String[missing.size()])));
1:                             return;
1:                         }
0:                         componentDefinitionRegistry.registerComponentDefinition(new EnvironmentMetadataImpl("blueprintContainer", this));
0:                         componentDefinitionRegistry.registerComponentDefinition(new EnvironmentMetadataImpl("blueprintBundle", bundleContext.getBundle()));
0:                         componentDefinitionRegistry.registerComponentDefinition(new EnvironmentMetadataImpl("blueprintBundleContext", bundleContext));
0:                         componentDefinitionRegistry.registerComponentDefinition(new EnvironmentMetadataImpl("blueprintConverter", converter));
0:                         parser.populate(handlers, componentDefinitionRegistry);
0:                         state = State.Populated;
1:                         break;
1:                     }
1:                     case Populated:
1:                         getRepository();
1:                         trackServiceReferences();
1:                         Runnable r = new Runnable() {
1:                             public void run() {
1:                                 synchronized (scheduled) {
1:                                     Throwable t = new TimeoutException();
1:                                     state = State.Failed;
0:                                     unregisterServices();
0:                                     untrackServiceReferences();
0:                                     destroyComponents();
0:                                     LOGGER.error("Unable to start blueprint container for bundle " + bundleContext.getBundle().getSymbolicName(), t);
0:                                     eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundleContext().getBundle(), getExtenderBundle(), getMissingDependencies(), t));
1:                                 }
1:                             }
1:                         };
0:                         timeoutFuture = executors.schedule(r, timeout, TimeUnit.MILLISECONDS);
1:                         state = State.WaitForInitialReferences;
1:                         break;
1:                     case WaitForInitialReferences:
1:                         if (waitForDependencies) {
1:                             String[] missingDependencies = getMissingDependencies();
1:                             if (missingDependencies.length > 0) {
0:                                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundleContext().getBundle(), getExtenderBundle(), missingDependencies));
1:                                 return;
1:                             }
1:                         }
1:                         state = State.InitialReferencesSatisfied;
1:                         break;
1:                     case InitialReferencesSatisfied:
1:                         processTypeConverters();
1:                         processProcessors();
1:                         state = State.WaitForInitialReferences2;
1:                         break;
1:                     case WaitForInitialReferences2:
1:                         if (waitForDependencies) {
1:                             String[] missingDependencies = getMissingDependencies();
1:                             if (missingDependencies.length > 0) {
0:                                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundleContext().getBundle(), getExtenderBundle(), missingDependencies));
1:                                 return;
1:                             }
1:                         }                       
1:                         state = State.Create;
1:                         break;
1:                     case Create:
1:                         timeoutFuture.cancel(false);
1:                         registerServices();
1:                         instantiateEagerComponents();
1: 
1:                         // Register the BlueprintContainer in the OSGi registry
0:                         if (registration == null) {
1:                             Properties props = new Properties();
1:                             props.put(BlueprintConstants.CONTAINER_SYMBOLIC_NAME_PROPERTY,
0:                                       bundleContext.getBundle().getSymbolicName());
1:                             props.put(BlueprintConstants.CONTAINER_VERSION_PROPERTY,
0:                                       JavaUtils.getBundleVersion(bundleContext.getBundle()));
1:                             registration = registerService(new String [] { BlueprintContainer.class.getName() }, this, props);
0:                             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATED, getBundleContext().getBundle(), getExtenderBundle()));
0:                             state = State.Created;
1:                         }
1:                         break;
1:                     case Created:
1:                     case Failed:
1:                         return;
1:                 }
1:             }
1:         } catch (Throwable t) {
1:             state = State.Failed;
1:             if (timeoutFuture != null) {
1:                 timeoutFuture.cancel(false);
1:             }
0:             unregisterServices();
0:             untrackServiceReferences();
0:             destroyComponents();
0:             LOGGER.error("Unable to start blueprint container for bundle " + bundleContext.getBundle().getSymbolicName(), t);
0:             eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundleContext().getBundle(), getExtenderBundle(), t));
1:         }
1:     }
1: 
1:     private List<URL> getResources() throws FileNotFoundException {
1:         List<URL> resources = new ArrayList<URL>();
1:         for (Object path : pathList) {
1:             if (path instanceof URL) {
1:                 resources.add((URL) path);                
1:             } else if (path instanceof String) {
0:                 URL url = bundleContext.getBundle().getEntry((String) path);
1:                 if (url == null) {
1:                     throw new FileNotFoundException("Unable to find configuration file for " + path);
1:                 } else {
1:                     resources.add(url);
1:                 }
1:             } else {
1:                 throw new IllegalArgumentException("Unexpected path type: " + path.getClass());
1:             }
1:         }
1:         return resources;
1:     }
1:     
1:     public Class loadClass(final String name) throws ClassNotFoundException {
1:         if (accessControlContext == null) {
0:             return bundleContext.getBundle().loadClass(name);
1:         } else {
1:             try {
1:                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Class>() {
1:                     public Class run() throws Exception {
0:                         return bundleContext.getBundle().loadClass(name);
1:                     }            
1:                 }, accessControlContext);
1:             } catch (PrivilegedActionException e) {
1:                 Exception cause = e.getException();
1:                 if (cause instanceof ClassNotFoundException) {
1:                     throw (ClassNotFoundException) cause;
1:                 }
1:                 throw new IllegalStateException("Unexpected checked exception", cause);
1:             }
1:         }
1:     }
1:     
1:     public ServiceRegistration registerService(final String[] classes, final Object service, final Dictionary properties) {
1:         if (accessControlContext == null) {
1:             return bundleContext.registerService(classes, service, properties);
1:         } else {
1:             return AccessController.doPrivileged(new PrivilegedAction<ServiceRegistration>() {
1:                 public ServiceRegistration run() {
1:                     return bundleContext.registerService(classes, service, properties);
1:                 }            
1:             }, accessControlContext);
1:         }
1:     }
1:     
1:     public Object getService(final ServiceReference reference) {
1:         if (accessControlContext == null) {
1:             return bundleContext.getService(reference);
1:         } else {
1:             return AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:                 public Object run() {
1:                     return bundleContext.getService(reference);
1:                 }            
1:             }, accessControlContext);
1:         }
1:     }
1:     
0:     private AccessControlContext createAccessControlContext() {
0:         return new AccessControlContext(AccessController.getContext(),
0:                 new DomainCombiner() {               
0:                     public ProtectionDomain[] combine(ProtectionDomain[] arg0,
0:                                                       ProtectionDomain[] arg1) {                    
0:                         return new ProtectionDomain[] { new ProtectionDomain(null, null) {                        
0:                             public boolean implies(Permission permission) {                                                           
0:                                 return bundleContext.getBundle().hasPermission(permission);
1:                             }
1:                         } 
1:                     };
1:                 }
0:         });
1:     }
1:     
1:     public AccessControlContext getAccessControlContext() {
1:         return accessControlContext;
1:     }
1:     
1:     public BlueprintRepository getRepository() {
1:         if (repository == null) {
0:             repository = new RecipeBuilder(this).createRepository();
1:         }
1:         return repository;
1:     }
1: 
0:     private void processTypeConverters() throws Exception {
1:         List<String> typeConverters = new ArrayList<String>();
1:         for (Target target : componentDefinitionRegistry.getTypeConverters()) {
1:             if (target instanceof ComponentMetadata) {
1:                 typeConverters.add(((ComponentMetadata) target).getId());
1:             } else if (target instanceof RefMetadata) {
1:                 typeConverters.add(((RefMetadata) target).getComponentId());
1:             } else {
1:                 throw new ComponentDefinitionException("Unexpected metadata for type converter: " + target);
1:             }
1:         }
1: 
0:         Map<String, Object> objects = repository.createAll(typeConverters);
1:         for (String name : typeConverters) {
1:             Object obj = objects.get(name);
1:             if (obj instanceof Converter) {
1:                 converter.registerConverter((Converter) obj);
1:             } else {
1:                 throw new ComponentDefinitionException("Type converter " + obj + " does not implement the " + Converter.class.getName() + " interface");
1:             }
1:         }
1:     }
1: 
0:     private void processProcessors() throws Exception {
0:         // Instanciate ComponentDefinitionRegistryProcessor and BeanProcessor
1:         for (BeanMetadata bean : getMetadata(BeanMetadata.class)) {
1:             if (bean instanceof ExtendedBeanMetadata && !((ExtendedBeanMetadata) bean).isProcessor()) {
1:                 continue;
1:             }     
1:             
1:             Class clazz = null;
1:             if (bean instanceof ExtendedBeanMetadata) {
1:                 clazz = ((ExtendedBeanMetadata) bean).getRuntimeClass();
1:             }            
1:             if (clazz == null && bean.getClassName() != null) {
1:                 clazz = loadClass(bean.getClassName());
1:             }
1:             if (clazz == null) {
1:                 continue;
1:             }
1: 
1:             if (ComponentDefinitionRegistryProcessor.class.isAssignableFrom(clazz)) {
0:                 Object obj = repository.create(bean.getId());
1:                 ((ComponentDefinitionRegistryProcessor) obj).process(componentDefinitionRegistry);
0:             } else if (Processor.class.isAssignableFrom(clazz)) {
0:                 Object obj = repository.create(bean.getId());
1:                 this.processors.add((Processor) obj);
1:             } else {
1:                 continue;
1:             }
0:             // Update repository with recipes processed by the processors
0:             untrackServiceReferences();
0:             Repository tmpRepo = new RecipeBuilder(this).createRepository();
1:             for (String name : tmpRepo.getNames()) {
1:                 if (repository.getInstance(name) == null) {
1:                     Recipe r = tmpRepo.getRecipe(name);
1:                     if (r != null) {
1:                         repository.putRecipe(name, r);
1:                     }
1:                 }
1:             }
1:             getSatisfiableDependenciesMap(true);
1:             trackServiceReferences();
1:         }
1:     }
1: 
1:     private Map<String, List<SatisfiableRecipe>> getSatisfiableDependenciesMap() {
1:         return getSatisfiableDependenciesMap(false);
1:     }
1: 
1:     private Map<String, List<SatisfiableRecipe>> getSatisfiableDependenciesMap(boolean recompute) {
1:         synchronized (satisfiablesLock) {
1:             if ((recompute || satisfiables == null) && repository != null) {
1:                 satisfiables = new HashMap<String, List<SatisfiableRecipe>>();
1:                 for (Recipe r : repository.getAllRecipes()) {
1:                     List<SatisfiableRecipe> recipes = repository.getAllRecipes(SatisfiableRecipe.class, r.getName());
1:                     if (!recipes.isEmpty()) {
1:                         satisfiables.put(r.getName(), recipes);
1:                     }
1:                 }
1:             }
1:             return satisfiables;
1:         }
1:     }
1: 
1:     private void trackServiceReferences() {
1:         Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:         Set<String> satisfiables = new HashSet<String>();
1:         for (List<SatisfiableRecipe> recipes : dependencies.values()) {
1:             for (SatisfiableRecipe satisfiable : recipes) {
1:                 if (satisfiables.add(satisfiable.getName())) {
1:                     satisfiable.start(this);
1:                 }
1:             }
1:         }
1:         LOGGER.debug("Tracking service references: {}", satisfiables);
1:     }
1:     
1:     private void untrackServiceReferences() {
1:         Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:         if (dependencies != null) {
1:             Set<String> stopped = new HashSet<String>();
1:             for (List<SatisfiableRecipe> recipes : dependencies.values()) {
1:                 for (SatisfiableRecipe satisfiable : recipes) {
1:                     untrackServiceReference(satisfiable, stopped, dependencies);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private void untrackServiceReference(SatisfiableRecipe recipe, Set<String> stopped, Map<String, List<SatisfiableRecipe>> dependencies) {
1:         if (stopped.add(recipe.getName())) {
1:             for (Map.Entry<String, List<SatisfiableRecipe>> entry : dependencies.entrySet()) {
1:                 if (entry.getValue().contains(recipe)) {
1:                     Recipe r = getRepository().getRecipe(entry.getKey());
1:                     if (r instanceof SatisfiableRecipe) {
1:                         untrackServiceReference((SatisfiableRecipe) r, stopped, dependencies);
1:                     }
1:                 }
1:             }
1:             recipe.stop();
1:         }
1:     }
1: 
1:     public void notifySatisfaction(SatisfiableRecipe satisfiable) {
0:         LOGGER.debug("Notified satisfaction {} in bundle {}: {}",
0:                 new Object[] { satisfiable.getName(), bundleContext.getBundle().getSymbolicName(), satisfiable.isSatisfied() });
1:         if (state == State.Create || state == State.Created ) {
1:             Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:             for (Map.Entry<String, List<SatisfiableRecipe>> entry : dependencies.entrySet()) {
1:                 String name = entry.getKey();
1:                 ComponentMetadata metadata = componentDefinitionRegistry.getComponentDefinition(name);
1:                 if (metadata instanceof ServiceMetadata) {
1:                     ServiceRecipe reg = (ServiceRecipe) repository.getRecipe(name);
1:                     synchronized (reg) {
1:                         boolean satisfied = true;
1:                         for (SatisfiableRecipe recipe : entry.getValue()) {
1:                             if (!recipe.isSatisfied()) {
1:                                 satisfied = false;
1:                                 break;
1:                             }
1:                         }
1:                         if (satisfied && !reg.isRegistered()) {
1:                             LOGGER.debug("Registering service {} due to satisfied references", name);
1:                             reg.register();
1:                         } else if (!satisfied && reg.isRegistered()) {
1:                             LOGGER.debug("Unregistering service {} due to unsatisfied references", name);
1:                             reg.unregister();
1:                         }
1:                     }
1:                 }
1:             }
1:         } else {
1:             schedule();
1:         }
1:     }
1: 
1:     private void instantiateEagerComponents() {
1:         List<String> components = new ArrayList<String>();
1:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:             boolean eager = component.getActivation() == ComponentMetadata.ACTIVATION_EAGER;
1:             if (component instanceof BeanMetadata) {
1:                 BeanMetadata local = (BeanMetadata) component;
1:                 eager &= MetadataUtil.isSingletonScope(local);
1:             }
1:             if (eager) {
1:                 components.add(name);
1:             }
1:         }
1:         LOGGER.debug("Instantiating components: {}", components);
1:         try {
1:             repository.createAll(components);
1:         } catch (ComponentDefinitionException e) {
1:             throw e;
1:         } catch (Throwable t) {
1:             throw new ComponentDefinitionException("Unable to instantiate components", t);
1:         }
1:     }
1: 
1:     private void registerServices() {
1:         services = repository.getAllRecipes(ServiceRecipe.class);
1:         for (ServiceRecipe r : services) {
1:             List<SatisfiableRecipe> dependencies = getSatisfiableDependenciesMap().get(r.getName());
1:             boolean enabled = true;
1:             if (dependencies != null) {
1:                 for (SatisfiableRecipe recipe : dependencies) {
1:                     if (!recipe.isSatisfied()) {
1:                         enabled = false;
1:                         break;
1:                     }
1:                 }
1:             }
1:             if (enabled) {
1:                 r.register();
1:             }
1:         }
1:     }
1: 
0:     private void unregisterServices() {
1:         if (repository != null) {
1:             List<ServiceRecipe> recipes = this.services;
1:             this.services = null;
1:             if (recipes != null) {
1:                 for (ServiceRecipe r : recipes) {
1:                     r.unregister();
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private void destroyComponents() {
1:         if (repository != null) {
1:             repository.destroy();
1:         }
1:     }
1: 
1:     private String[] getMissingDependencies() {
1:         List<String> missing = new ArrayList<String>();
1:         Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
1:         Set<SatisfiableRecipe> recipes = new HashSet<SatisfiableRecipe>();
1:         for (List<SatisfiableRecipe> deps : dependencies.values()) {
1:             for (SatisfiableRecipe recipe : deps) {
1:                 if (!recipe.isSatisfied()) {
1:                     recipes.add(recipe);
1:                 }
1:             }
1:         }
1:         for (SatisfiableRecipe recipe : recipes) {
1:             missing.add(recipe.getOsgiFilter());
1:         }
1:         return missing.toArray(new String[missing.size()]);
1:     }
1:     
1:     public Set<String> getComponentIds() {
0:         Set<String> set = new LinkedHashSet<String>();
0:         set.addAll(componentDefinitionRegistry.getComponentDefinitionNames());
0:         set.add("blueprintContainer");
0:         set.add("blueprintBundle");
0:         set.add("blueprintBundleContext");
0:         set.add("blueprintConverter");
0:         return set;
1:     }
1:     
1:     public Object getComponentInstance(String id) throws NoSuchComponentException {
1:         if (repository == null) {
1:             throw new NoSuchComponentException(id);
1:         }
1:         try {
1:             LOGGER.debug("Instantiating component {}", id);
1:             return repository.create(id);
1:         } catch (NoSuchComponentException e) {
1:             throw e;
1:         } catch (ComponentDefinitionException e) {
1:             throw e;
1:         } catch (Throwable t) {
1:             throw new ComponentDefinitionException("Cound not create component instance for " + id, t);
1:         }
1:     }
1: 
1:     public ComponentMetadata getComponentMetadata(String id) {
1:         ComponentMetadata metadata = componentDefinitionRegistry.getComponentDefinition(id);
1:         if (metadata == null) {
1:             throw new NoSuchComponentException(id);
1:         }
1:         return metadata;
1:     }
1: 
1:     public <T extends ComponentMetadata> Collection<T> getMetadata(Class<T> clazz) {
1:         Collection<T> metadatas = new ArrayList<T>();
1:         for (String name : componentDefinitionRegistry.getComponentDefinitionNames()) {
1:             ComponentMetadata component = componentDefinitionRegistry.getComponentDefinition(name);
1:             getMetadata(clazz, component, metadatas);
1:         }
1:         metadatas = Collections.unmodifiableCollection(metadatas);
1:         return metadatas;
1:     }
1: 
1:     private <T extends ComponentMetadata> void getMetadata(Class<T> clazz, Metadata component, Collection<T> metadatas) {
1:         if (component == null) {
1:             return;
1:         }
1:         if (clazz.isInstance(component)) {
1:             metadatas.add(clazz.cast(component));
1:         }
1:         if (component instanceof BeanMetadata) {
1:             getMetadata(clazz, ((BeanMetadata) component).getFactoryComponent(), metadatas);
1:             for (BeanArgument arg : ((BeanMetadata) component).getArguments()) {
1:                 getMetadata(clazz, arg.getValue(), metadatas);
1:             }
1:             for (BeanProperty prop : ((BeanMetadata) component).getProperties()) {
1:                 getMetadata(clazz, prop.getValue(), metadatas);
1:             }
1:         }
1:         if (component instanceof CollectionMetadata) {
1:             for (Metadata m : ((CollectionMetadata) component).getValues()) {
1:                 getMetadata(clazz, m, metadatas);
1:             }
1:         }
1:         if (component instanceof MapMetadata) {
1:             for (MapEntry m : ((MapMetadata) component).getEntries()) {
1:                 getMetadata(clazz, m.getKey(), metadatas);
1:                 getMetadata(clazz, m.getValue(), metadatas);
1:             }
1:         }
1:         if (component instanceof PropsMetadata) {
1:             for (MapEntry m : ((PropsMetadata) component).getEntries()) {
1:                 getMetadata(clazz, m.getKey(), metadatas);
1:                 getMetadata(clazz, m.getValue(), metadatas);
1:             }
1:         }
1:         if (component instanceof ServiceReferenceMetadata) {
1:             for (ReferenceListener l : ((ServiceReferenceMetadata) component).getReferenceListeners()) {
1:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:             }
1:         }
1:         if (component instanceof ServiceMetadata) {
1:             getMetadata(clazz, ((ServiceMetadata) component).getServiceComponent(), metadatas);
1:             for (MapEntry m : ((ServiceMetadata) component).getServiceProperties()) {
1:                 getMetadata(clazz, m.getKey(), metadatas);
1:                 getMetadata(clazz, m.getValue(), metadatas);
1:             }
1:             for (RegistrationListener l : ((ServiceMetadata) component).getRegistrationListeners()) {
1:                 getMetadata(clazz, l.getListenerComponent(), metadatas);
1:             }
1:         }
1:     }
1: 
1:     public Converter getConverter() {
1:         return converter;
1:     }
1:     
1:     public ComponentDefinitionRegistryImpl getComponentDefinitionRegistry() {
1:         return componentDefinitionRegistry;
1:     }
1:         
1:     public BundleContext getBundleContext() {
1:         return bundleContext;
1:     }
1:     
1:     public void destroy() {
0:         destroyed = true;
0:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundleContext().getBundle(), getExtenderBundle()));
1: 
1:         if (timeoutFuture != null) {
1:             timeoutFuture.cancel(false);
1:         }
0:         if (registration != null) {
0:             registration.unregister();
1:         }
0:         handlers.removeListener(this);
0:         unregisterServices();
0:         untrackServiceReferences();
1: 
0:         synchronized (running) {
0:             while (running.get()) {
1:                 try {
0:                     running.wait();
0:                 } catch (InterruptedException e) {
0:                     // Ignore
1:                 }
1:             }
1:         }
1: 
0:         destroyComponents();
1:         
0:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYED, getBundleContext().getBundle(), getExtenderBundle()));
0:         LOGGER.debug("Blueprint container destroyed: {}", this.bundleContext);
1:     }
1: 
1:     public void namespaceHandlerRegistered(URI uri) {
0:         if (namespaces != null && namespaces.contains(uri)) {
1:             schedule();
1:         }
1:     }
1: 
1:     public void namespaceHandlerUnregistered(URI uri) {
0:         if (namespaces != null && namespaces.contains(uri)) {
0:             unregisterServices();
0:             untrackServiceReferences();
0:             destroyComponents();
1:             state = State.WaitForNamespaceHandlers;
1:             schedule();
1:         }
1:     }
1: 
1: }
1: 
author:Christian Schneider
-------------------------------------------------------------------------------
commit:0231f6a
/////////////////////////////////////////////////////////////////////////
1:                                     String[] missingDependecies = getMissingDependencies();
1:                                     if (missingDependecies.length == 0) {
1:                                         return;
1:                                     }
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:0871217
/////////////////////////////////////////////////////////////////////////
1: import org.xml.sax.ErrorHandler;
1: import org.xml.sax.SAXException;
1: import org.xml.sax.SAXParseException;
/////////////////////////////////////////////////////////////////////////
1:     private String xmlValidation;
/////////////////////////////////////////////////////////////////////////
1:         xmlValidation = paths.get(0).getDirective(BlueprintConstants.XML_VALIDATION);
1:         // enabled if null or "true"; structure-only if "structure"; disabled otherwise
1:         LOGGER.debug("Xml-validation directive: {}", xmlValidation);
/////////////////////////////////////////////////////////////////////////
1:             xmlValidation = null;
/////////////////////////////////////////////////////////////////////////
0:                         if (xmlValidation == null || "true".equals(xmlValidation)) {
0:                         } else if ("structure".equals(xmlValidation)) {
0:                             parser.validate(handlerSet.getSchema(), new ValidationHandler());
/////////////////////////////////////////////////////////////////////////
0: 
1:     // this could be parameterized/customized, but for now, hard-coded for ignoring datatype validation
1:     private static class ValidationHandler implements ErrorHandler {
1:         @Override
1:         public void warning(SAXParseException exception) throws SAXException {
1:             // ignore
1:         }
1:         @Override
1:         public void error(SAXParseException exception) throws SAXException {
1:             final String cvctext = exception.getMessage(); 
1:             if (cvctext != null && 
1:                 (cvctext.startsWith("cvc-datatype-valid.1") || cvctext.startsWith("cvc-attribute.3"))) {
1:                 return;
1:             }
1:             throw exception;
1:         }
0: 
1:         @Override
1:         public void fatalError(SAXParseException exception) throws SAXException {
1:             throw exception;
1:         }
1:     }
commit:135b9a1
/////////////////////////////////////////////////////////////////////////
1:         cancelFutureIfPresent();
0: 
commit:e76da08
/////////////////////////////////////////////////////////////////////////
1:             resetComponentDefinitionRegistry();
/////////////////////////////////////////////////////////////////////////
0:     
0:     private void resetComponentDefinitionRegistry() {
0:         this.componentDefinitionRegistry.reset();
0:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
0:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundle));
0:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundleContext", bundleContext));
0:         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintConverter", converter));
0:     }
/////////////////////////////////////////////////////////////////////////
1:                         resetComponentDefinitionRegistry();
/////////////////////////////////////////////////////////////////////////
1:         return new LinkedHashSet<String>(componentDefinitionRegistry.getComponentDefinitionNames());
/////////////////////////////////////////////////////////////////////////
1:                 resetComponentDefinitionRegistry();
commit:18ee583
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             } else { 
1:             updateUninstantiatedRecipes();
0:             trackServiceReferences();        
0:         }
0:     }
1:     private void updateUninstantiatedRecipes() {
1:         Repository tmpRepo = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
0:         
1:         LOGGER.debug("Updating blueprint repository");
0:         
1:         for (String name : repository.getNames()) {
1:             if (repository.getInstance(name) == null) {
1:                 LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
1:                 repository.removeRecipe(name);
1:             } else {
1:                 LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
0:             }
0:         }
0:         
0:         for (String name : tmpRepo.getNames()) {
1:             if (repository.getInstance(name) == null) {
1:                 LOGGER.debug("Adding new recipe {}", new Object[] { name });
0:                 Recipe r = tmpRepo.getRecipe(name);
0:                 if (r != null) {
0:                     repository.putRecipe(name, r);
0:                 }
1:             } else {
1:                 LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
0:             }
commit:27e02c9
/////////////////////////////////////////////////////////////////////////
0:         boolean changed = false;
/////////////////////////////////////////////////////////////////////////
0:                 changed = true;
0:                 changed = true;
0:         }
0:         if (changed) {
/////////////////////////////////////////////////////////////////////////
author:Jeremy Hughes
-------------------------------------------------------------------------------
commit:e0cac5e
/////////////////////////////////////////////////////////////////////////
1: 			//Register the services after the eager components are ready, as per 121.6
0: 			registerServices();
commit:ca42e8d
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 state = State.Failed;
1:                 cancelFutureIfPresent();
1:                 tidyupComponents();
0:                 LOGGER.error("Unable to start blueprint container for bundle " + getBundle().getSymbolicName(), t);
0:                 eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), t));
1:             } catch (RuntimeException re) {
1:                 LOGGER.debug("Tidying up components failed. ", re);
1:                 throw re;
0:             }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5e2bd49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.proxy.ProxyUtils;
/////////////////////////////////////////////////////////////////////////
0:         Map<String, Object> objects = repository.createAll(typeConverters, ProxyUtils.asList(Converter.class));
/////////////////////////////////////////////////////////////////////////
0:                 Object obj = repository.create(bean.getId(), ProxyUtils.asList(ComponentDefinitionRegistryProcessor.class));
0:                 Object obj = repository.create(bean.getId(), ProxyUtils.asList(Processor.class));
commit:370ce47
/////////////////////////////////////////////////////////////////////////
0: 
1:         synchronized (satisfiablesLock) {
1:             satisfiables = null;
0:         }
commit:047a2ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.AriesFrameworkUtil;
/////////////////////////////////////////////////////////////////////////
0:         AriesFrameworkUtil.safeUnregisterService(registration);
/////////////////////////////////////////////////////////////////////////
0:         AriesFrameworkUtil.safeUnregisterService(registration);
commit:ba10b30
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:                                     String[] missingDependecies = getMissingDependencies();
0:                                     LOGGER.error("Unable to start blueprint container for bundle " + bundleContext.getBundle().getSymbolicName() + " due to unresolved dependencies " + Arrays.asList(missingDependecies), t);
0:                                     eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundleContext().getBundle(), getExtenderBundle(), missingDependecies, t));
author:J. Daniel Kulp
-------------------------------------------------------------------------------
commit:7959fcd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.di.ExecutionContext;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void injectBeanInstance(BeanMetadata bmd, Object o) 
1:         throws IllegalArgumentException, ComponentDefinitionException {
1:         ExecutionContext origContext 
1:             = ExecutionContext.Holder.setContext((ExecutionContext)getRepository());
0:         try {
1:             ComponentMetadata cmd = componentDefinitionRegistry.getComponentDefinition(bmd.getId());
1:             if (cmd == null || cmd != bmd) {
1:                 throw new IllegalArgumentException(bmd.getId() + " not found in blueprint container");
0:             }
1:             Recipe r = this.getRepository().getRecipe(bmd.getId());
1:             if (r instanceof BeanRecipe) {
1:                 BeanRecipe br = (BeanRecipe)r;
1:                 if (!br.getType().isInstance(o)) {
1:                     throw new IllegalArgumentException("Instance class " + o.getClass().getName() 
1:                                                        + " is not an instance of " + br.getClass());
0:                 }
1:                 br.setProperties(o);
0:             } else {
1:                 throw new IllegalArgumentException(bmd.getId() + " does not refer to a BeanRecipe");
0:             }
0:         } finally {
1:             ExecutionContext.Holder.setContext(origContext);
0:         }
0:     }
commit:1e0e25d
/////////////////////////////////////////////////////////////////////////
1: @SuppressWarnings("deprecation") // due to the deprecated org.apache.aries.blueprint.ExtendedBlueprintContainer
1: public class BlueprintContainerImpl 
1:     implements ExtendedBlueprintContainer, NamespaceHandlerSet.Listener, 
1:     Runnable, SatisfiableRecipe.SatisfactionListener,
1:     org.apache.aries.blueprint.ExtendedBlueprintContainer {
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:a37e3d4
/////////////////////////////////////////////////////////////////////////
1:                         List<URI> missingURIs = new ArrayList<URI>();
1:                                 missingURIs.add(ns);
0:                             LOGGER.info("Bundle {} is waiting for namespace handlers {}", bundleContext.getBundle().getSymbolicName(), missingURIs);
commit:ef7b490
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ScheduledExecutorService;
/////////////////////////////////////////////////////////////////////////
0:     private final ScheduledExecutorService executors;
/////////////////////////////////////////////////////////////////////////
0:     public BlueprintContainerImpl(BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher, NamespaceHandlerRegistry handlers, ScheduledExecutorService executors, List<Object> pathList) {
/////////////////////////////////////////////////////////////////////////
1:     private void readDirectives() {
/////////////////////////////////////////////////////////////////////////
1:                         readDirectives();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         cancelFutureIfPresent();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             cancelFutureIfPresent();
/////////////////////////////////////////////////////////////////////////
0:         cancelFutureIfPresent();
/////////////////////////////////////////////////////////////////////////
0:         cancelFutureIfPresent();
/////////////////////////////////////////////////////////////////////////
1:     private void cancelFutureIfPresent()
1:     {
0:       if (timeoutFuture != null) {
0:           timeoutFuture.cancel(false);
0:       }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:f25cf7c
/////////////////////////////////////////////////////////////////////////
1:         tidyupComponents();
/////////////////////////////////////////////////////////////////////////
0:                                     tidyupComponents();
/////////////////////////////////////////////////////////////////////////
0:             tidyupComponents();
/////////////////////////////////////////////////////////////////////////
0:             tidyupComponents();
1:     private void tidyupComponents()
1:     {
0:       unregisterServices();
0:       destroyComponents();
0:       untrackServiceReferences();
0:     }
0: 
commit:c2087a3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         untrackServiceReferences();
0: 
commit:0631713
/////////////////////////////////////////////////////////////////////////
0:                         timeoutFuture = executors.schedule(r, timeout, TimeUnit.MILLISECONDS);
commit:4b749be
/////////////////////////////////////////////////////////////////////////
0:                                     String[] missingDependecies = getMissingDependencies();
0:                         timeoutFuture = executors.schedule(r, 10, TimeUnit.SECONDS);
commit:3c4350c
/////////////////////////////////////////////////////////////////////////
0:                             LOGGER.warn("Bundle " + bundleContext.getBundle().getSymbolicName() + " is waiting for namespace handlers " + missing);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:7257be0
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ScheduledThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
0:     private final ScheduledThreadPoolExecutor executors;
/////////////////////////////////////////////////////////////////////////
0:     public BlueprintContainerImpl(BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher, NamespaceHandlerRegistry handlers, ScheduledThreadPoolExecutor executors, List<Object> pathList) {
/////////////////////////////////////////////////////////////////////////
0:                         executors.purge();
/////////////////////////////////////////////////////////////////////////
0:             executors.purge();
0:         
0:             if (handlerSet != null) {
0:                 handlerSet.removeListener(this);
0:                 handlerSet.destroy();
0:             }
0:             
/////////////////////////////////////////////////////////////////////////
0:             executors.purge();
commit:6bd0f94
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.parser.ComponentDefinitionRegistryImpl;
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
0: import org.apache.aries.blueprint.parser.Parser;
1: import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
/////////////////////////////////////////////////////////////////////////
0: public class BlueprintContainerImpl implements ExtendedBlueprintContainer, NamespaceHandlerSet.Listener, Runnable, SatisfiableRecipe.SatisfactionListener {
/////////////////////////////////////////////////////////////////////////
1:     private NamespaceHandlerSet handlerSet;
commit:9f9d944
/////////////////////////////////////////////////////////////////////////
1:     private final IdSpace tempRecipeIdSpace = new IdSpace();
0:     
/////////////////////////////////////////////////////////////////////////
1:             repository = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
/////////////////////////////////////////////////////////////////////////
0:             Repository tmpRepo = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
0:             
0:             LOGGER.debug("Updating blueprint repository");
0:             
0:             for (String name : repository.getNames()) {
0:                 if (repository.getInstance(name) == null) {
0:                     LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
0:                     repository.removeRecipe(name);
0:                 } else {
0:                     LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
0:                 }
0:             }
0:             
0:                     LOGGER.debug("Adding new recipe {}", new Object[] { name });
0:                 } else {
0:                     LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
0:             
commit:c1dc516
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
/////////////////////////////////////////////////////////////////////////
0:         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl();
/////////////////////////////////////////////////////////////////////////
0:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
0:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundleContext.getBundle()));
0:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundleContext", bundleContext));
0:                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintConverter", converter));
commit:79e9d13
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.reflect.MetadataUtil;
/////////////////////////////////////////////////////////////////////////
0:         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl(this, bundleContext, converter);
/////////////////////////////////////////////////////////////////////////
author:Holly Cummins
-------------------------------------------------------------------------------
commit:da163d0
/////////////////////////////////////////////////////////////////////////
1:     protected void unregisterServices() {
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected void quiesce() {
0:         destroyed = true;
0:         eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundleContext().getBundle(), getExtenderBundle()));
0: 
0:         if (timeoutFuture != null) {
0:             timeoutFuture.cancel(false);
0:         }
0:         if (registration != null) {
0:             registration.unregister();
0:         }
0:         if (handlerSet != null) {
0:             handlerSet.removeListener(this);
0:             handlerSet.destroy();
0:         }
0:         LOGGER.debug("Blueprint container quiesced: {}", this.bundleContext);
0:     }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.BlueprintConstants;
1: import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
1: import org.apache.aries.blueprint.ExtendedBeanMetadata;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.NamespaceHandler;
1: import org.apache.aries.blueprint.Processor;
0: import org.apache.aries.blueprint.reflect.EnvironmentMetadataImpl;
0: import org.apache.aries.blueprint.reflect.MetadataUtil;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.di.Repository;
0: import org.apache.aries.blueprint.namespace.ComponentDefinitionRegistryImpl;
1: import org.apache.aries.blueprint.namespace.NamespaceHandlerRegistryImpl;
1: import org.apache.aries.blueprint.utils.HeaderParser;
0: import org.apache.aries.blueprint.utils.JavaUtils;
1: import org.apache.aries.blueprint.utils.HeaderParser.PathElement;
============================================================================