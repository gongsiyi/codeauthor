1:fdf3952: /*
1:fdf3952:  * Licensed to the Apache Software Foundation (ASF) under one
1:fdf3952:  * or more contributor license agreements.  See the NOTICE file
1:fdf3952:  * distributed with this work for additional information
1:fdf3952:  * regarding copyright ownership.  The ASF licenses this file
1:fdf3952:  * to you under the Apache License, Version 2.0 (the
1:fdf3952:  * "License"); you may not use this file except in compliance
1:fdf3952:  * with the License.  You may obtain a copy of the License at
1:fdf3952:  *
1:fdf3952:  *   http://www.apache.org/licenses/LICENSE-2.0
1:fdf3952:  *
1:fdf3952:  * Unless required by applicable law or agreed to in writing,
1:fdf3952:  * software distributed under the License is distributed on an
1:fdf3952:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:fdf3952:  * KIND, either express or implied.  See the License for the
1:fdf3952:  * specific language governing permissions and limitations
1:fdf3952:  * under the License.
1:fdf3952:  */
1:fdf3952: package org.apache.aries.jmx.core.whiteboard;
33:fdf3952: 
1:fdf3952: import java.util.Hashtable;
1:fdf3952: import java.util.concurrent.ConcurrentHashMap;
1:fdf3952: import java.util.concurrent.ConcurrentMap;
1:fdf3952: import java.util.concurrent.atomic.AtomicReference;
1:fdf3952: 
1:fdf3952: import org.apache.aries.jmx.Logger;
1:fdf3952: import org.apache.aries.jmx.framework.BundleState;
1:fdf3952: import org.apache.aries.jmx.framework.Framework;
1:fdf3952: import org.apache.aries.jmx.framework.PackageState;
1:fdf3952: import org.apache.aries.jmx.framework.ServiceState;
1:a0df2a3: import org.apache.aries.jmx.framework.StateConfig;
1:7186eab: import org.apache.aries.jmx.util.ObjectNameUtils;
1:fdf3952: import org.osgi.framework.Bundle;
1:fdf3952: import org.osgi.framework.BundleActivator;
1:fdf3952: import org.osgi.framework.BundleContext;
1:fdf3952: import org.osgi.framework.Constants;
1:fdf3952: import org.osgi.framework.Filter;
1:fdf3952: import org.osgi.framework.InvalidSyntaxException;
1:fdf3952: import org.osgi.framework.ServiceFactory;
1:fdf3952: import org.osgi.framework.ServiceReference;
1:fdf3952: import org.osgi.framework.ServiceRegistration;
1:fdf3952: import org.osgi.jmx.framework.BundleStateMBean;
1:fdf3952: import org.osgi.jmx.framework.FrameworkMBean;
1:fdf3952: import org.osgi.jmx.framework.PackageStateMBean;
1:fdf3952: import org.osgi.jmx.framework.ServiceStateMBean;
1:fdf3952: import org.osgi.jmx.service.cm.ConfigurationAdminMBean;
1:fdf3952: import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
1:fdf3952: import org.osgi.jmx.service.provisioning.ProvisioningServiceMBean;
1:fdf3952: import org.osgi.jmx.service.useradmin.UserAdminMBean;
1:fdf3952: import org.osgi.service.cm.ConfigurationAdmin;
1:fdf3952: import org.osgi.service.packageadmin.PackageAdmin;
1:fdf3952: import org.osgi.service.permissionadmin.PermissionAdmin;
1:fdf3952: import org.osgi.service.provisioning.ProvisioningService;
1:fdf3952: import org.osgi.service.startlevel.StartLevel;
1:fdf3952: import org.osgi.service.useradmin.UserAdmin;
1:fdf3952: import org.osgi.util.tracker.ServiceTracker;
1:fdf3952: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1:fdf3952: 
1:fdf3952: public class Activator implements BundleActivator, ServiceTrackerCustomizer
1:fdf3952: {
1:fdf3952:   private ServiceTracker tracker;
1:fdf3952:   private BundleContext ctx;
1:fdf3952:   private ConcurrentMap<Long, ServiceRegistration> _provisioningMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
1:fdf3952:   private ConcurrentMap<Long, ServiceRegistration> _userAdminMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
1:fdf3952:   private ConcurrentMap<Long, ServiceRegistration> _configAdminMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
1:fdf3952: 
1:fdf3952:   private AtomicReference<ServiceRegistration> _serviceStateMbean = new AtomicReference<ServiceRegistration>();
1:fdf3952:   private AtomicReference<ServiceRegistration> _permissionAdminMbean = new AtomicReference<ServiceRegistration>();
1:fdf3952:   private AtomicReference<ServiceRegistration> _packageStateMbean = new AtomicReference<ServiceRegistration>();
1:fdf3952:   private AtomicReference<ServiceRegistration> _bundleState = new AtomicReference<ServiceRegistration>();
1:fdf3952:   private AtomicReference<ServiceRegistration> _framework = new AtomicReference<ServiceRegistration>();
1:fdf3952: 
1:fdf3952:   private AtomicReference<ServiceReference> _startLevel = new AtomicReference<ServiceReference>();
1:fdf3952:   private AtomicReference<ServiceReference> _packageAdmin = new AtomicReference<ServiceReference>();
1:fdf3952: 
1:fdf3952:   private static final String PACKAGE_ADMIN = "org.osgi.service.packageadmin.PackageAdmin";
1:fdf3952:   private static final String START_LEVEL = "org.osgi.service.startlevel.StartLevel";
1:fdf3952:   private static final String PERMISSION_ADMIN = "org.osgi.service.permissionadmin.PermissionAdmin";
1:fdf3952:   private static final String CONFIG_ADMIN = "org.osgi.service.cm.ConfigurationAdmin";
1:fdf3952:   private static final String USER_ADMIN = "org.osgi.service.useradmin.UserAdmin";
1:fdf3952:   private static final String PROVISIONING_SERVICE = "org.osgi.service.provisioning.ProvisioningService";
1:fdf3952: 
1:fdf3952:   private Logger logger;
1:a0df2a3:   private StateConfig stateConfig;
1:7186eab: 
1:fdf3952:   private class MBeanServiceProxy<T> implements ServiceFactory
1:fdf3952:   {
1:fdf3952:     private Factory<T> objectFactory;
1:fdf3952:     private AtomicReference<T> result = new AtomicReference<T>();
1:7186eab: 
1:fdf3952:     private MBeanServiceProxy(Factory<T> factory) {
1:fdf3952:       objectFactory = factory;
1:fdf3952:     }
1:7186eab: 
1:fdf3952:     public Object getService(Bundle bundle, ServiceRegistration registration)
1:fdf3952:     {
1:fdf3952:       if (result.get() == null) {
1:fdf3952:         result.compareAndSet(null, objectFactory.create());
1:fdf3952:       }
1:fdf3952:       return result.get();
1:fdf3952:     }
1:7186eab: 
1:fdf3952:     public void ungetService(Bundle bundle, ServiceRegistration registration, Object service)
1:fdf3952:     {
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private interface Factory<T>
1:fdf3952:   {
1:fdf3952:     public abstract T create();
1:fdf3952:   }
1:7186eab: 
1:fdf3952:   private abstract class BaseFactory<T> implements Factory<T>
1:fdf3952:   {
1:fdf3952:     public abstract T create(PackageAdmin pa, StartLevel sl);
1:fdf3952:     public final T create()
1:fdf3952:     {
1:fdf3952:       StartLevel sl = null;
1:fdf3952:       PackageAdmin pa = null;
1:7186eab: 
1:fdf3952:       ServiceReference slRef = _startLevel.get();
1:fdf3952:       if (slRef != null) {
1:fdf3952:         sl = (StartLevel) ctx.getService(slRef);
1:fdf3952:       }
1:fdf3952:       ServiceReference paRef = _packageAdmin.get();
1:7186eab: 
1:fdf3952:       if (paRef != null) {
1:fdf3952:         pa = (PackageAdmin) ctx.getService(paRef);
1:fdf3952:       }
1:7186eab: 
1:fdf3952:       if (pa == null) {
1:fdf3952:         ctx.ungetService(slRef);
1:fdf3952:       }
1:7186eab: 
1:fdf3952:       if (sl != null && pa != null) {
1:fdf3952:         return create(pa, sl);
1:fdf3952:       } else {
1:fdf3952:         return null;
1:fdf3952:       }
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   public void start(BundleContext context) throws Exception
1:fdf3952:   {
1:fdf3952:     ctx = context;
1:fdf3952:     logger = new Logger(ctx);
1:7186eab: 
1:fdf3952:     Filter filter = getFilter(context, PACKAGE_ADMIN, START_LEVEL,
1:fdf3952:         PERMISSION_ADMIN, CONFIG_ADMIN, USER_ADMIN,
1:fdf3952:         PROVISIONING_SERVICE);
1:fdf3952: 
1:fdf3952:     tracker = new ServiceTracker(context, filter, this);
1:fdf3952:     tracker.open();
1:7186eab: 
1:a0df2a3:     stateConfig = StateConfig.register(context);
1:a0df2a3: 
1:fdf3952:     registerMBean(ServiceStateMBean.class.getName(), new Factory<ServiceStateMBean>() {
1:fdf3952:       public ServiceStateMBean create()
1:fdf3952:       {
1:a0df2a3:         return new ServiceState(ctx, stateConfig, logger);
1:fdf3952:       }
1:fdf3952:     }, ServiceStateMBean.OBJECTNAME, _serviceStateMbean );
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private Filter getFilter(BundleContext ctx, String ... services) throws InvalidSyntaxException
1:fdf3952:   {
1:fdf3952:     StringBuilder builder = new StringBuilder("(|");
1:7186eab: 
1:fdf3952:     for (String type : services) {
1:fdf3952:       builder.append('(');
1:fdf3952:       builder.append(Constants.OBJECTCLASS);
1:fdf3952:       builder.append('=');
1:fdf3952:       builder.append(type);
1:fdf3952:       builder.append(')');
1:fdf3952:     }
1:7186eab: 
1:fdf3952:     builder.append(')');
1:fdf3952:     return ctx.createFilter(builder.toString());
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   public void stop(BundleContext context) throws Exception
1:fdf3952:   {
1:a0df2a3:     stateConfig = null;
1:fdf3952:     tracker.close();
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   public Object addingService(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     Object tracked = null;
1:7186eab: 
1:fdf3952:     String[] types = (String[]) reference.getProperty(Constants.OBJECTCLASS);
1:7186eab: 
1:fdf3952:     for (String t : types) {
1:fdf3952:       if (PACKAGE_ADMIN.equals(t)) {
1:fdf3952:         foundPackageAdmin(reference);
1:fdf3952:         tracked = reference;
1:fdf3952:       } else if (START_LEVEL.equals(t)) {
1:fdf3952:         foundStartLevel(reference);
1:fdf3952:         tracked = reference;
1:fdf3952:       } else if (PERMISSION_ADMIN.equals(t)) {
1:fdf3952:         foundPermissionAdmin(reference);
1:fdf3952:         tracked = reference;
1:fdf3952:       } else if (CONFIG_ADMIN.equals(t)) {
1:fdf3952:         foundConfigAdmin(reference);
1:fdf3952:         tracked = reference;
1:fdf3952:       } else if (USER_ADMIN.equals(t)) {
1:fdf3952:         foundUserAdmin(reference);
1:fdf3952:         tracked = reference;
1:fdf3952:       } else if (PROVISIONING_SERVICE.equals(t)) {
1:fdf3952:         foundProvisioningService(reference);
1:fdf3952:         tracked = reference;
1:fdf3952:       }
1:fdf3952:     }
1:7186eab: 
1:fdf3952:     return tracked;
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private <T> void registerMBean(String type, Factory<T> factory, String objectName, AtomicReference<ServiceRegistration> result)
1:fdf3952:   {
1:fdf3952:     synchronized (result) {
1:fdf3952:       ServiceRegistration reg = registerAnMbean(type, factory, objectName);
1:7186eab: 
1:fdf3952:       if (!!!result.compareAndSet(null, reg)) {
1:fdf3952:         reg.unregister();
1:fdf3952:       }
1:fdf3952:     }
1:fdf3952:   }
1:7186eab: 
1:fdf3952:   private <T> void registerMBean(String type, Factory<T> factory, String objectName, ConcurrentMap<Long, ServiceRegistration> mbeans,
1:fdf3952:       ServiceReference referencedServices, String underlyingType)
1:fdf3952:   {
1:fdf3952:     try {
1:fdf3952:       Class.forName(underlyingType);
1:fdf3952:       if (referencedServices.isAssignableTo(ctx.getBundle(), underlyingType)) {
1:fdf3952:         ServiceRegistration reg = registerAnMbean(type, factory, objectName);
1:7186eab: 
1:fdf3952:         Long id = (Long) reg.getReference().getProperty(Constants.SERVICE_ID);
1:fdf3952:         mbeans.put(id, reg);
1:fdf3952:       }
1:fdf3952:     } catch (ClassNotFoundException e) {
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private <T> ServiceRegistration registerAnMbean(String type, Factory<T> factory, String objectName)
1:fdf3952:   {
1:fdf3952:     Hashtable<String, Object> properties = new Hashtable<String, Object>();
1:7186eab:     properties.put("jmx.objectname", ObjectNameUtils.createFullObjectName(ctx, objectName));
1:7186eab: 
1:fdf3952:     Object service = new MBeanServiceProxy<T>(factory);
1:7186eab: 
1:fdf3952:     ServiceRegistration reg = ctx.registerService(type, service, properties);
1:fdf3952:     return reg;
1:fdf3952:   }
1:7186eab: 
1:fdf3952:   private void foundPermissionAdmin(final ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     registerMBean(PermissionAdminMBean.class.getName(), new Factory<PermissionAdminMBean>() {
1:fdf3952:       public PermissionAdminMBean create()
1:fdf3952:       {
1:fdf3952:         PermissionAdmin service = (PermissionAdmin) ctx.getService(reference);
1:7186eab: 
1:fdf3952:         if (service == null) return null;
1:fdf3952:         else return new org.apache.aries.jmx.permissionadmin.PermissionAdmin(service);
1:fdf3952:       }
1:fdf3952:     }, PermissionAdminMBean.OBJECTNAME, _permissionAdminMbean);
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void foundProvisioningService(final ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     registerMBean(ProvisioningServiceMBean.class.getName(), new Factory<ProvisioningServiceMBean>() {
1:fdf3952:         public ProvisioningServiceMBean create()
1:fdf3952:         {
1:fdf3952:           ProvisioningService service = (ProvisioningService) ctx.getService(reference);
1:7186eab: 
1:fdf3952:           if (service == null) return null;
1:fdf3952:           else return new org.apache.aries.jmx.provisioning.ProvisioningService(service);
1:fdf3952:         }
1:fdf3952:       }, ProvisioningServiceMBean.OBJECTNAME, _provisioningMBeans, reference, PROVISIONING_SERVICE);
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void foundUserAdmin(final ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     try {
1:fdf3952:       Class.forName(USER_ADMIN);
1:fdf3952:       if (reference.isAssignableTo(ctx.getBundle(), USER_ADMIN)) {
1:fdf3952:         registerMBean(UserAdminMBean.class.getName(), new Factory<UserAdminMBean>() {
1:fdf3952:           public UserAdminMBean create()
1:fdf3952:           {
1:fdf3952:             UserAdmin service = (UserAdmin) ctx.getService(reference);
1:7186eab: 
1:fdf3952:             if (service == null) return null;
1:fdf3952:             else return new org.apache.aries.jmx.useradmin.UserAdmin(service);
1:fdf3952:           }
1:fdf3952:         }, UserAdminMBean.OBJECTNAME, _userAdminMBeans, reference, USER_ADMIN);
1:fdf3952:       }
1:fdf3952:     } catch (ClassNotFoundException e) {
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void foundConfigAdmin(final ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     registerMBean(ConfigurationAdminMBean.class.getName(), new Factory<ConfigurationAdminMBean>() {
1:fdf3952:       public ConfigurationAdminMBean create()
1:fdf3952:       {
1:fdf3952:         ConfigurationAdmin service = (ConfigurationAdmin) ctx.getService(reference);
1:7186eab: 
1:fdf3952:         if (service == null) return null;
1:fdf3952:         else return new org.apache.aries.jmx.cm.ConfigurationAdmin(service);
1:fdf3952:       }
1:fdf3952:     }, ConfigurationAdminMBean.OBJECTNAME, _configAdminMBeans, reference, CONFIG_ADMIN);
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void foundStartLevel(final ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     if (_startLevel.compareAndSet(null, reference)) {
1:fdf3952:       registerBundleStateAndFrameworkIfPossible();
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void foundPackageAdmin(final ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     registerMBean(PackageStateMBean.class.getName(), new Factory<PackageStateMBean>() {
1:fdf3952:       public PackageStateMBean create()
1:fdf3952:       {
1:fdf3952:         PackageAdmin service = (PackageAdmin) ctx.getService(reference);
1:7186eab: 
1:fdf3952:         if (service == null) return null;
1:fdf3952:         else return new PackageState(ctx, service);
1:fdf3952:       }
1:fdf3952:     }, PackageStateMBean.OBJECTNAME, _packageStateMbean);
1:7186eab: 
1:fdf3952:     if (_packageAdmin.compareAndSet(null, reference)) {
1:fdf3952:       registerBundleStateAndFrameworkIfPossible();
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   // This method is synchronized to ensure that notification of StartLevel and PackageAdmin
1:fdf3952:   // on different threads at the same time doesn't cause problems. It only affects these services
1:fdf3952:   // so it shouldn't be too expensive.
1:fdf3952:   private synchronized void registerBundleStateAndFrameworkIfPossible()
1:fdf3952:   {
1:fdf3952:       if (_bundleState.get() == null && _startLevel.get() != null && _packageAdmin.get() != null) {
1:fdf3952:         registerMBean(BundleStateMBean.class.getName(), new BaseFactory<BundleStateMBean>() {
1:fdf3952:           @Override
1:fdf3952:           public BundleStateMBean create(PackageAdmin pa, StartLevel sl)
1:fdf3952:           {
1:a0df2a3:             return new BundleState(ctx, pa, sl, stateConfig, logger);
1:fdf3952:           }
1:fdf3952:         }, BundleStateMBean.OBJECTNAME, _bundleState);
1:fdf3952:       }
1:fdf3952:       if (_framework.get() == null && _startLevel.get() != null && _packageAdmin.get() != null) {
1:fdf3952:         registerMBean(FrameworkMBean.class.getName(), new BaseFactory<FrameworkMBean>() {
1:fdf3952:           @Override
1:fdf3952:           public FrameworkMBean create(PackageAdmin pa, StartLevel sl)
1:fdf3952:           {
1:fdf3952:             return new Framework(ctx, sl, pa);
1:fdf3952:           }
1:fdf3952:         }, FrameworkMBean.OBJECTNAME, _framework);
1:fdf3952:       }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   public void modifiedService(ServiceReference reference, Object service)
1:fdf3952:   {
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   public void removedService(ServiceReference reference, Object service)
1:fdf3952:   {
1:fdf3952:     String[] types = (String[]) reference.getProperty(Constants.OBJECTCLASS);
1:7186eab: 
1:fdf3952:     for (String t : types) {
1:fdf3952:       if (PACKAGE_ADMIN.equals(t)) {
1:fdf3952:         lostPackageAdmin(reference);
1:fdf3952:       } else if (START_LEVEL.equals(t)) {
1:fdf3952:         lostStartLevel(reference);
1:fdf3952:       } else if (PERMISSION_ADMIN.equals(t)) {
1:fdf3952:         lostPermissionAdmin(reference);
1:fdf3952:       } else if (CONFIG_ADMIN.equals(t)) {
1:fdf3952:         lostConfigAdmin(reference);
1:fdf3952:       } else if (USER_ADMIN.equals(t)) {
1:fdf3952:         lostUserAdmin(reference);
1:fdf3952:       } else if (PROVISIONING_SERVICE.equals(t)) {
1:fdf3952:         lostProvisioningService(reference);
1:fdf3952:       }
1:fdf3952:     }
1:7186eab: 
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void lostProvisioningService(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     unregister(reference, _provisioningMBeans);
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void lostUserAdmin(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     unregister(reference, _userAdminMBeans);
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void lostConfigAdmin(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     unregister(reference, _configAdminMBeans);
1:fdf3952:   }
1:7186eab: 
1:fdf3952:   private void unregister(ServiceReference reference, ConcurrentMap<Long, ServiceRegistration> mbeans)
1:fdf3952:   {
1:fdf3952:     Long id = (Long) reference.getProperty(Constants.SERVICE_ID);
1:fdf3952:     ServiceRegistration reg = mbeans.remove(id);
1:fdf3952:     if (reg != null) reg.unregister();
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void lostPermissionAdmin(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     safeUnregister(_permissionAdminMbean);
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void lostStartLevel(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     if (_startLevel.compareAndSet(reference, null)) {
1:fdf3952:       safeUnregister(_bundleState);
1:fdf3952:       safeUnregister(_framework);
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void lostPackageAdmin(ServiceReference reference)
1:fdf3952:   {
1:fdf3952:     if (_packageAdmin.compareAndSet(reference, null)) {
1:fdf3952:       safeUnregister(_bundleState);
1:fdf3952:       safeUnregister(_framework);
1:7186eab: 
1:fdf3952:       safeUnregister(_packageStateMbean);
1:fdf3952:     }
1:fdf3952:   }
1:fdf3952: 
1:fdf3952:   private void safeUnregister(AtomicReference<ServiceRegistration> atomicRegistration)
1:fdf3952:   {
1:fdf3952:     ServiceRegistration reg = atomicRegistration.getAndSet(null);
1:fdf3952:     if (reg != null) reg.unregister();
1:fdf3952:   }
1:fdf3952: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:a0df2a3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.jmx.framework.StateConfig;
/////////////////////////////////////////////////////////////////////////
1:   private StateConfig stateConfig;
/////////////////////////////////////////////////////////////////////////
1:     stateConfig = StateConfig.register(context);
1: 
1:         return new ServiceState(ctx, stateConfig, logger);
/////////////////////////////////////////////////////////////////////////
1:     stateConfig = null;
/////////////////////////////////////////////////////////////////////////
1:             return new BundleState(ctx, pa, sl, stateConfig, logger);
commit:0273964
commit:7186eab
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.jmx.util.ObjectNameUtils;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     properties.put("jmx.objectname", ObjectNameUtils.createFullObjectName(ctx, objectName));
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:fdf3952
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.jmx.core.whiteboard;
1: 
1: import java.util.Hashtable;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import org.apache.aries.jmx.Logger;
1: import org.apache.aries.jmx.framework.BundleState;
1: import org.apache.aries.jmx.framework.Framework;
1: import org.apache.aries.jmx.framework.PackageState;
1: import org.apache.aries.jmx.framework.ServiceState;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleActivator;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceFactory;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.jmx.framework.BundleStateMBean;
1: import org.osgi.jmx.framework.FrameworkMBean;
1: import org.osgi.jmx.framework.PackageStateMBean;
1: import org.osgi.jmx.framework.ServiceStateMBean;
1: import org.osgi.jmx.service.cm.ConfigurationAdminMBean;
1: import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
1: import org.osgi.jmx.service.provisioning.ProvisioningServiceMBean;
1: import org.osgi.jmx.service.useradmin.UserAdminMBean;
1: import org.osgi.service.cm.ConfigurationAdmin;
1: import org.osgi.service.packageadmin.PackageAdmin;
1: import org.osgi.service.permissionadmin.PermissionAdmin;
1: import org.osgi.service.provisioning.ProvisioningService;
1: import org.osgi.service.startlevel.StartLevel;
1: import org.osgi.service.useradmin.UserAdmin;
1: import org.osgi.util.tracker.ServiceTracker;
1: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1: 
1: public class Activator implements BundleActivator, ServiceTrackerCustomizer
1: {
1:   private ServiceTracker tracker;
1:   private BundleContext ctx;
1:   private ConcurrentMap<Long, ServiceRegistration> _provisioningMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
1:   private ConcurrentMap<Long, ServiceRegistration> _userAdminMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
1:   private ConcurrentMap<Long, ServiceRegistration> _configAdminMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
1: 
1:   private AtomicReference<ServiceRegistration> _serviceStateMbean = new AtomicReference<ServiceRegistration>();
1:   private AtomicReference<ServiceRegistration> _permissionAdminMbean = new AtomicReference<ServiceRegistration>();
1:   private AtomicReference<ServiceRegistration> _packageStateMbean = new AtomicReference<ServiceRegistration>();
1:   private AtomicReference<ServiceRegistration> _bundleState = new AtomicReference<ServiceRegistration>();
1:   private AtomicReference<ServiceRegistration> _framework = new AtomicReference<ServiceRegistration>();
1: 
1:   private AtomicReference<ServiceReference> _startLevel = new AtomicReference<ServiceReference>();
1:   private AtomicReference<ServiceReference> _packageAdmin = new AtomicReference<ServiceReference>();
1: 
1:   private static final String PACKAGE_ADMIN = "org.osgi.service.packageadmin.PackageAdmin";
1:   private static final String START_LEVEL = "org.osgi.service.startlevel.StartLevel";
1:   private static final String PERMISSION_ADMIN = "org.osgi.service.permissionadmin.PermissionAdmin";
1:   private static final String CONFIG_ADMIN = "org.osgi.service.cm.ConfigurationAdmin";
1:   private static final String USER_ADMIN = "org.osgi.service.useradmin.UserAdmin";
1:   private static final String PROVISIONING_SERVICE = "org.osgi.service.provisioning.ProvisioningService";
1: 
1:   private Logger logger;
1:   
1:   private class MBeanServiceProxy<T> implements ServiceFactory
1:   {
1:     private Factory<T> objectFactory;
1:     private AtomicReference<T> result = new AtomicReference<T>();
1:     
1:     private MBeanServiceProxy(Factory<T> factory) {
1:       objectFactory = factory;
1:     }
1:     
1:     public Object getService(Bundle bundle, ServiceRegistration registration)
1:     {
1:       if (result.get() == null) {
1:         result.compareAndSet(null, objectFactory.create());
1:       }
1:       return result.get();
1:     }
1:     
1:     public void ungetService(Bundle bundle, ServiceRegistration registration, Object service)
1:     {
1:     }
1:   }
1: 
1:   private interface Factory<T>
1:   {
1:     public abstract T create();
1:   }
1:   
1:   private abstract class BaseFactory<T> implements Factory<T>
1:   {
1:     public abstract T create(PackageAdmin pa, StartLevel sl);
1:     public final T create()
1:     {
1:       StartLevel sl = null;
1:       PackageAdmin pa = null;
1:       
1:       ServiceReference slRef = _startLevel.get();
1:       if (slRef != null) {
1:         sl = (StartLevel) ctx.getService(slRef);
1:       }
1:       ServiceReference paRef = _packageAdmin.get();
1:       
1:       if (paRef != null) {
1:         pa = (PackageAdmin) ctx.getService(paRef);
1:       }
1:       
1:       if (pa == null) {
1:         ctx.ungetService(slRef);
1:       }
1:       
1:       if (sl != null && pa != null) {
1:         return create(pa, sl);
1:       } else {
1:         return null;
1:       }
1:     }
1:   }
1: 
1:   public void start(BundleContext context) throws Exception
1:   {
1:     ctx = context;
1:     logger = new Logger(ctx);
1:     
1:     Filter filter = getFilter(context, PACKAGE_ADMIN, START_LEVEL,
1:         PERMISSION_ADMIN, CONFIG_ADMIN, USER_ADMIN,
1:         PROVISIONING_SERVICE);
1: 
1:     tracker = new ServiceTracker(context, filter, this);
1:     tracker.open();
1:     
1:     registerMBean(ServiceStateMBean.class.getName(), new Factory<ServiceStateMBean>() {
1:       public ServiceStateMBean create()
1:       {
0:         return new ServiceState(ctx, logger);
1:       }
1:     }, ServiceStateMBean.OBJECTNAME, _serviceStateMbean );
1:   }
1: 
1:   private Filter getFilter(BundleContext ctx, String ... services) throws InvalidSyntaxException
1:   {
1:     StringBuilder builder = new StringBuilder("(|");
1:     
1:     for (String type : services) {
1:       builder.append('(');
1:       builder.append(Constants.OBJECTCLASS);
1:       builder.append('=');
1:       builder.append(type);
1:       builder.append(')');
1:     }
1:     
1:     builder.append(')');
1:     return ctx.createFilter(builder.toString());
1:   }
1: 
1:   public void stop(BundleContext context) throws Exception
1:   {
1:     tracker.close();
1:   }
1: 
1:   public Object addingService(ServiceReference reference)
1:   {
1:     Object tracked = null;
1:     
1:     String[] types = (String[]) reference.getProperty(Constants.OBJECTCLASS);
1:     
1:     for (String t : types) {
1:       if (PACKAGE_ADMIN.equals(t)) {
1:         foundPackageAdmin(reference);
1:         tracked = reference;
1:       } else if (START_LEVEL.equals(t)) {
1:         foundStartLevel(reference);
1:         tracked = reference;
1:       } else if (PERMISSION_ADMIN.equals(t)) {
1:         foundPermissionAdmin(reference);
1:         tracked = reference;
1:       } else if (CONFIG_ADMIN.equals(t)) {
1:         foundConfigAdmin(reference);
1:         tracked = reference;
1:       } else if (USER_ADMIN.equals(t)) {
1:         foundUserAdmin(reference);
1:         tracked = reference;
1:       } else if (PROVISIONING_SERVICE.equals(t)) {
1:         foundProvisioningService(reference);
1:         tracked = reference;
1:       }
1:     }
1:     
1:     return tracked;
1:   }
1: 
1:   private <T> void registerMBean(String type, Factory<T> factory, String objectName, AtomicReference<ServiceRegistration> result)
1:   {
1:     synchronized (result) {
1:       ServiceRegistration reg = registerAnMbean(type, factory, objectName);
1:       
1:       if (!!!result.compareAndSet(null, reg)) {
1:         reg.unregister();
1:       }
1:     }
1:   }
1:   
1:   private <T> void registerMBean(String type, Factory<T> factory, String objectName, ConcurrentMap<Long, ServiceRegistration> mbeans,
1:       ServiceReference referencedServices, String underlyingType)
1:   {
1:     try {
1:       Class.forName(underlyingType);
1:       if (referencedServices.isAssignableTo(ctx.getBundle(), underlyingType)) {
1:         ServiceRegistration reg = registerAnMbean(type, factory, objectName);
1:   
1:         Long id = (Long) reg.getReference().getProperty(Constants.SERVICE_ID);
1:         mbeans.put(id, reg);
1:       }
1:     } catch (ClassNotFoundException e) {
1:     }
1:   }
1: 
1:   private <T> ServiceRegistration registerAnMbean(String type, Factory<T> factory, String objectName)
1:   {
1:     Hashtable<String, Object> properties = new Hashtable<String, Object>();
0:     properties.put("jmx.objectname", objectName);
1:     
1:     Object service = new MBeanServiceProxy<T>(factory);
1:     
1:     ServiceRegistration reg = ctx.registerService(type, service, properties);
1:     return reg;
1:   }
1:   
1:   private void foundPermissionAdmin(final ServiceReference reference)
1:   {
1:     registerMBean(PermissionAdminMBean.class.getName(), new Factory<PermissionAdminMBean>() {
1:       public PermissionAdminMBean create()
1:       {
1:         PermissionAdmin service = (PermissionAdmin) ctx.getService(reference);
1:         
1:         if (service == null) return null;
1:         else return new org.apache.aries.jmx.permissionadmin.PermissionAdmin(service);
1:       }
1:     }, PermissionAdminMBean.OBJECTNAME, _permissionAdminMbean);
1:   }
1: 
1:   private void foundProvisioningService(final ServiceReference reference)
1:   {
1:     registerMBean(ProvisioningServiceMBean.class.getName(), new Factory<ProvisioningServiceMBean>() {
1:         public ProvisioningServiceMBean create()
1:         {
1:           ProvisioningService service = (ProvisioningService) ctx.getService(reference);
1:           
1:           if (service == null) return null;
1:           else return new org.apache.aries.jmx.provisioning.ProvisioningService(service);
1:         }
1:       }, ProvisioningServiceMBean.OBJECTNAME, _provisioningMBeans, reference, PROVISIONING_SERVICE);
1:   }
1: 
1:   private void foundUserAdmin(final ServiceReference reference)
1:   {
1:     try {
1:       Class.forName(USER_ADMIN);
1:       if (reference.isAssignableTo(ctx.getBundle(), USER_ADMIN)) {
1:         registerMBean(UserAdminMBean.class.getName(), new Factory<UserAdminMBean>() {
1:           public UserAdminMBean create()
1:           {
1:             UserAdmin service = (UserAdmin) ctx.getService(reference);
1:             
1:             if (service == null) return null;
1:             else return new org.apache.aries.jmx.useradmin.UserAdmin(service);
1:           }
1:         }, UserAdminMBean.OBJECTNAME, _userAdminMBeans, reference, USER_ADMIN);
1:       }
1:     } catch (ClassNotFoundException e) {
1:     }
1:   }
1: 
1:   private void foundConfigAdmin(final ServiceReference reference)
1:   {
1:     registerMBean(ConfigurationAdminMBean.class.getName(), new Factory<ConfigurationAdminMBean>() {
1:       public ConfigurationAdminMBean create()
1:       {
1:         ConfigurationAdmin service = (ConfigurationAdmin) ctx.getService(reference);
1:         
1:         if (service == null) return null;
1:         else return new org.apache.aries.jmx.cm.ConfigurationAdmin(service);
1:       }
1:     }, ConfigurationAdminMBean.OBJECTNAME, _configAdminMBeans, reference, CONFIG_ADMIN);
1:   }
1: 
1:   private void foundStartLevel(final ServiceReference reference)
1:   {
1:     if (_startLevel.compareAndSet(null, reference)) {
1:       registerBundleStateAndFrameworkIfPossible();
1:     }
1:   }
1: 
1:   private void foundPackageAdmin(final ServiceReference reference)
1:   {
1:     registerMBean(PackageStateMBean.class.getName(), new Factory<PackageStateMBean>() {
1:       public PackageStateMBean create()
1:       {
1:         PackageAdmin service = (PackageAdmin) ctx.getService(reference);
1:         
1:         if (service == null) return null;
1:         else return new PackageState(ctx, service);
1:       }
1:     }, PackageStateMBean.OBJECTNAME, _packageStateMbean);
1:     
1:     if (_packageAdmin.compareAndSet(null, reference)) {
1:       registerBundleStateAndFrameworkIfPossible();
1:     }
1:   }
1: 
1:   // This method is synchronized to ensure that notification of StartLevel and PackageAdmin
1:   // on different threads at the same time doesn't cause problems. It only affects these services
1:   // so it shouldn't be too expensive.
1:   private synchronized void registerBundleStateAndFrameworkIfPossible()
1:   {
1:       if (_bundleState.get() == null && _startLevel.get() != null && _packageAdmin.get() != null) {
1:         registerMBean(BundleStateMBean.class.getName(), new BaseFactory<BundleStateMBean>() {
1:           @Override
1:           public BundleStateMBean create(PackageAdmin pa, StartLevel sl)
1:           {
0:             return new BundleState(ctx, pa, sl, logger);
1:           }
1:         }, BundleStateMBean.OBJECTNAME, _bundleState);
1:       }
1:       if (_framework.get() == null && _startLevel.get() != null && _packageAdmin.get() != null) {
1:         registerMBean(FrameworkMBean.class.getName(), new BaseFactory<FrameworkMBean>() {
1:           @Override
1:           public FrameworkMBean create(PackageAdmin pa, StartLevel sl)
1:           {
1:             return new Framework(ctx, sl, pa);
1:           }
1:         }, FrameworkMBean.OBJECTNAME, _framework);
1:       }
1:   }
1: 
1:   public void modifiedService(ServiceReference reference, Object service)
1:   {
1:   }
1: 
1:   public void removedService(ServiceReference reference, Object service)
1:   {
1:     String[] types = (String[]) reference.getProperty(Constants.OBJECTCLASS);
1:     
1:     for (String t : types) {
1:       if (PACKAGE_ADMIN.equals(t)) {
1:         lostPackageAdmin(reference);
1:       } else if (START_LEVEL.equals(t)) {
1:         lostStartLevel(reference);
1:       } else if (PERMISSION_ADMIN.equals(t)) {
1:         lostPermissionAdmin(reference);
1:       } else if (CONFIG_ADMIN.equals(t)) {
1:         lostConfigAdmin(reference);
1:       } else if (USER_ADMIN.equals(t)) {
1:         lostUserAdmin(reference);
1:       } else if (PROVISIONING_SERVICE.equals(t)) {
1:         lostProvisioningService(reference);
1:       }
1:     }
1:     
1:   }
1: 
1:   private void lostProvisioningService(ServiceReference reference)
1:   {
1:     unregister(reference, _provisioningMBeans);
1:   }
1: 
1:   private void lostUserAdmin(ServiceReference reference)
1:   {
1:     unregister(reference, _userAdminMBeans);
1:   }
1: 
1:   private void lostConfigAdmin(ServiceReference reference)
1:   {
1:     unregister(reference, _configAdminMBeans);
1:   }
1:   
1:   private void unregister(ServiceReference reference, ConcurrentMap<Long, ServiceRegistration> mbeans)
1:   {
1:     Long id = (Long) reference.getProperty(Constants.SERVICE_ID);
1:     ServiceRegistration reg = mbeans.remove(id);
1:     if (reg != null) reg.unregister();
1:   }
1: 
1:   private void lostPermissionAdmin(ServiceReference reference)
1:   {
1:     safeUnregister(_permissionAdminMbean);
1:   }
1: 
1:   private void lostStartLevel(ServiceReference reference)
1:   {
1:     if (_startLevel.compareAndSet(reference, null)) {
1:       safeUnregister(_bundleState);
1:       safeUnregister(_framework);
1:     }
1:   }
1: 
1:   private void lostPackageAdmin(ServiceReference reference)
1:   {
1:     if (_packageAdmin.compareAndSet(reference, null)) {
1:       safeUnregister(_bundleState);
1:       safeUnregister(_framework);
1:       
1:       safeUnregister(_packageStateMbean);
1:     }
1:   }
1: 
1:   private void safeUnregister(AtomicReference<ServiceRegistration> atomicRegistration)
1:   {
1:     ServiceRegistration reg = atomicRegistration.getAndSet(null);
1:     if (reg != null) reg.unregister();
1:   }
1: }
============================================================================