1:3c38842: /*
1:3c38842:  * Licensed to the Apache Software Foundation (ASF) under one
1:3c38842:  * or more contributor license agreements.  See the NOTICE file
1:3c38842:  * distributed with this work for additional information
1:3c38842:  * regarding copyright ownership.  The ASF licenses this file
1:3c38842:  * to you under the Apache License, Version 2.0 (the
1:3c38842:  * "License"); you may not use this file except in compliance
1:3c38842:  * with the License.  You may obtain a copy of the License at
1:109ef40:  *
1:3c38842:  *   http://www.apache.org/licenses/LICENSE-2.0
19:3c38842:  *
1:3c38842:  * Unless required by applicable law or agreed to in writing,
1:3c38842:  * software distributed under the License is distributed on an
1:3c38842:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:3c38842:  * KIND, either express or implied.  See the License for the
1:3c38842:  * specific language governing permissions and limitations
1:3c38842:  * under the License.
14:3c38842:  */
1:de5b346: 
1:910fec0: package org.apache.aries.util.manifest;
1:de5b346: 
1:3c38842: import java.util.ArrayList;
1:3c38842: import java.util.HashMap;
1:3c38842: import java.util.HashSet;
1:3c38842: import java.util.List;
1:3c38842: import java.util.Map;
1:3c38842: import java.util.Set;
1:3c38842: import java.util.regex.Matcher;
1:3c38842: import java.util.regex.Pattern;
1:de5b346: 
1:8d4d949: import org.apache.aries.util.ManifestHeaderUtils;
1:910fec0: import org.apache.aries.util.VersionRange;
1:3c38842: import org.osgi.framework.Constants;
1:109ef40: import org.osgi.framework.Version;
1:de5b346: 
1:449792b: 
1:3c38842: public class ManifestHeaderProcessor
9:3c38842: {
1:e1c60f4:   public static final String NESTED_FILTER_ATTRIBUTE = "org.apache.aries.application.filter.attribute";
1:3c38842:   private static final Pattern FILTER_ATTR = Pattern.compile("(\\(!)?\\((.*?)([<>]?=)(.*?)\\)\\)?");
1:3c38842:   private static final String LESS_EQ_OP = "<=";
1:3c38842:   private static final String GREATER_EQ_OP = ">=";
1:449792b: 
13:3c38842:   /**
1:109ef40:    * A GenericMetadata is either a Generic Capability or a Generic Requirement
1:109ef40:    */
1:109ef40:   public static class GenericMetadata {
1:109ef40:     private final String namespace;
1:109ef40:     private final Map<String, Object> attributes = new HashMap<String, Object>();
1:109ef40:     private final Map<String, String> directives = new HashMap<String, String>();
1:109ef40: 
1:109ef40:     public GenericMetadata(String namespace) {
1:109ef40:       this.namespace = namespace;
1:109ef40:     }
1:109ef40: 
1:109ef40:     public String getNamespace() {
1:109ef40:       return namespace;
1:109ef40:     }
1:109ef40: 
1:109ef40:     public Map<String, Object> getAttributes() {
1:109ef40:       return attributes;
1:109ef40:     }
1:109ef40: 
1:109ef40:     public Map<String, String> getDirectives() {
1:109ef40:       return directives;
1:109ef40:     }
1:109ef40:   }
1:109ef40: 
1:109ef40:   /**
1:3c38842:    * A simple class to associate two types.
1:3c38842:    */
1:de5b346:   public static class NameValuePair {
1:de5b346:     private String name;
1:de5b346:     private Map<String,String> attributes;
1:109ef40: 
1:de5b346:     public NameValuePair(String name, Map<String,String> value)
1:3c38842:     {
1:3c38842:       this.name = name;
1:de5b346:       this.attributes = value;
26:3c38842:     }
1:de5b346:     public String getName()
1:3c38842:     {
1:3c38842:       return name;
1:3c38842:     }
1:de5b346:     public void setName(String name)
1:3c38842:     {
1:3c38842:       this.name = name;
1:3c38842:     }
1:109ef40: 
1:de5b346:     public Map<String,String> getAttributes()
1:3c38842:     {
1:de5b346:       return attributes;
1:3c38842:     }
1:de5b346:     public void setAttributes(Map<String,String> value)
1:3c38842:     {
1:de5b346:       this.attributes = value;
1:3c38842:     }
1:109ef40: 
1:e1c60f4:     @Override
1:e1c60f4:     public String toString(){
1:de5b346:       return "{"+name.toString()+"::"+attributes.toString()+"}";
1:3c38842:     }
1:e1c60f4:     @Override
1:3c38842:     public int hashCode()
1:3c38842:     {
1:3c38842:       final int prime = 31;
1:3c38842:       int result = 1;
1:3c38842:       result = prime * result + ((name == null) ? 0 : name.hashCode());
1:de5b346:       result = prime * result + ((attributes == null) ? 0 : attributes.hashCode());
2:3c38842:       return result;
1:9c133a0:     }
1:e1c60f4:     @Override
1:3c38842:     public boolean equals(Object obj)
1:3c38842:     {
1:3c38842:       if (this == obj) return true;
1:3c38842:       if (obj == null) return false;
1:3c38842:       if (getClass() != obj.getClass()) return false;
1:de5b346:       final NameValuePair other = (NameValuePair) obj;
1:3c38842:       if (name == null) {
1:3c38842:         if (other.name != null) return false;
1:3c38842:       } else if (!name.equals(other.name)) return false;
1:de5b346:       if (attributes == null) {
1:de5b346:     	  if (other.attributes != null) return false;
1:de5b346:       } else if (!attributes.equals(other.attributes)) return false;
1:3c38842:       return true;
1:9c133a0:     }
1:3c38842:   }
1:109ef40: 
1:9c133a0:   /**
1:109ef40:    * Intended to provide a standard way to add Name/Value's to
1:3c38842:    * aggregations of Name/Value's.
1:9c133a0:    */
1:de5b346:   public static interface NameValueCollection {
1:9c133a0:     /**
1:3c38842:      * Add this Name & Value to the collection.
1:3c38842:      * @param n
1:3c38842:      * @param v
1:9c133a0:      */
1:de5b346:     public void addToCollection(String n, Map<String,String> v);
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * Map of Name -> Value.
1:3c38842:    */
1:de5b346:   public static class NameValueMap extends HashMap<String, Map<String,String>> implements NameValueCollection, Map<String, Map<String,String>>{
1:de5b346: 	private static final long serialVersionUID = -6446338858542599141L;
1:109ef40: 
1:de5b346: 	public void addToCollection(String n, Map<String,String> v){
1:3c38842:       this.put(n,v);
1:3c38842:     }
1:109ef40: 
1:de5b346: 	@Override
1:de5b346: 	public String toString(){
1:f9c9743:       StringBuilder sb = new StringBuilder();
1:3c38842:       sb.append("{");
1:3c38842:       boolean first=true;
1:de5b346:       for(Map.Entry<String, Map<String,String>> entry : this.entrySet()){
1:3c38842:         if(!first)sb.append(",");
1:3c38842:         first=false;
1:3c38842:         sb.append(entry.getKey()+"->"+entry.getValue());
1:3c38842:       }
1:3c38842:       sb.append("}");
1:3c38842:       return sb.toString();
1:3c38842:     }
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * List of Name/Value
1:3c38842:    */
1:109ef40:   public static class NameValueList extends ArrayList<NameValuePair> implements NameValueCollection, List<NameValuePair> {
1:de5b346: 	private static final long serialVersionUID = 1808636823825029983L;
1:109ef40: 
1:de5b346: 	public void addToCollection(String n, Map<String,String> v){
1:de5b346:       this.add(new NameValuePair(n,v));
1:109ef40:     }
2:3c38842: 	@Override
3:3c38842:     public String toString(){
2:3c38842:       StringBuffer sb = new StringBuffer();
1:3c38842:       sb.append("{");
1:3c38842:       boolean first = true;
1:de5b346:       for(NameValuePair nvp : this){
1:3c38842:         if(!first)sb.append(",");
1:3c38842:         first=false;
1:109ef40:         sb.append(nvp.toString());
1:3c38842:       }
1:3c38842:       sb.append("}");
1:3c38842:       return sb.toString();
1:3c38842:     }
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:109ef40:    *
1:3c38842:    * Splits a delimiter separated string, tolerating presence of non separator commas
1:3c38842:    * within double quoted segments.
1:109ef40:    *
1:3c38842:    * Eg.
1:3c38842:    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
1:3c38842:    * com.ibm.ws.eba.helloWorldService;version="1.0.0"
1:3c38842:    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
1:3c38842:    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
1:3c38842:    *  @param value          the value to be split
1:3c38842:    *  @param delimiter      the delimiter string such as ',' etc.
1:3c38842:    *  @return List<String>  the components of the split String in a list
1:3c38842:    */
1:3c38842:   public static List<String> split(String value, String delimiter)
1:3c38842:   {
1:8d4d949:     return ManifestHeaderUtils.split(value, delimiter);
1:109ef40:   }
1:109ef40: 
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * Internal method to parse headers with the format<p>
1:109ef40:    *   [Name](;[Name])*(;[attribute-name]=[attribute-value])*<br>
1:3c38842:    * Eg.<br>
1:3c38842:    *   rumplestiltskin;thing=value;other=something<br>
1:3c38842:    *   littleredridinghood
1:3c38842:    *   bundle1;bundle2;other=things
1:3c38842:    *   bundle1;bundle2
1:109ef40:    *
1:3c38842:    * @param s data to parse
1:109ef40:    * @return a list of NameValuePair, with the Name being the name component,
1:109ef40:    *         and the Value being a NameValueMap of key->value mappings.
1:3c38842:    */
1:109ef40:   private static List<NameValuePair> genericNameWithNameValuePairProcess(String s){
1:3c38842:     String name;
1:de5b346:     Map<String,String> params = null;
1:de5b346:     List<NameValuePair> nameValues = new ArrayList<NameValuePair>();
1:3c38842:     List<String> pkgs = new ArrayList<String>();
1:3c38842:     int index = s.indexOf(";");
1:3c38842:     if(index==-1){
1:3c38842:       name = s;
1:de5b346:       params = new HashMap<String, String>();
1:3c38842:       pkgs.add(name);
1:109ef40:     }else{
1:3c38842:       name = s.substring(0,index).trim();
1:3c38842:       String tail = s.substring(index+1).trim();
1:109ef40: 
1:3c38842:       pkgs.add(name); // add the first package
1:3c38842:       StringBuilder parameters = new StringBuilder();
1:109ef40: 
1:109ef40: 
1:3c38842:       // take into consideration of multiple packages separated by ';'
1:3c38842:       // while they share the same attributes or directives
1:3c38842:       List<String> tailParts = split(tail, ";");
1:3c38842:       boolean firstParameter =false;
1:109ef40: 
1:3c38842:       for (String part : tailParts) {
1:3c38842:         // if it is not a parameter and no parameter appears in front of it, it must a package
1:3c38842:         if (!!!(part.contains("=")))  {
1:3c38842:           // Need to make sure no parameter appears before the package, otherwise ignore this string
1:3c38842:           // as this syntax is invalid
2:3c38842:           if (!!!(firstParameter))
1:3c38842:             pkgs.add(part);
1:3c38842:         } else {
1:109ef40:           if (!!!(firstParameter))
1:3c38842:             firstParameter = true;
1:de5b346: 
1:3c38842:           parameters.append(part + ";");
1:109ef40:         }
1:3c38842:       }
1:109ef40: 
1:3c38842:       if (parameters.length() != 0) {
1:3c38842:         //remove the final ';' if there is one
1:3c38842:         if (parameters.toString().endsWith(";")) {
1:109ef40: 
1:3c38842:           parameters = parameters.deleteCharAt(parameters.length() -1);
1:109ef40:         }
1:109ef40: 
1:3c38842:         params = genericNameValueProcess(parameters.toString());
1:3c38842:       }
1:109ef40: 
1:3c38842:     }
1:3c38842:     for (String pkg : pkgs) {
1:de5b346:       nameValues.add(new NameValuePair(pkg,params));
1:109ef40:     }
1:109ef40: 
1:3c38842:     return nameValues;
1:109ef40: 
1:3c38842:   }
1:de5b346: 
1:3c38842:   /**
1:3c38842:    * Internal method to parse headers with the format<p>
1:3c38842:    *   [attribute-name]=[attribute-value](;[attribute-name]=[attribute-value])*<br>
1:3c38842:    * Eg.<br>
1:3c38842:    *   thing=value;other=something<br>
1:3c38842:    * <p>
1:3c38842:    * Note. Directives (name:=value) are represented in the map with name suffixed by ':'
1:109ef40:    *
1:3c38842:    * @param s data to parse
1:3c38842:    * @return a NameValueMap, with attribute-name -> attribute-value.
1:3c38842:    */
1:de5b346:   private static Map<String,String> genericNameValueProcess(String s){
1:109ef40:     Map<String,String> params = new HashMap<String,String>();
1:3c38842:     List<String> parameters = split(s, ";");
1:3c38842:     for(String parameter : parameters) {
1:3c38842:       List<String> parts = split(parameter,"=");
1:109ef40:       // do a check, otherwise we might get NPE
1:3c38842:       if (parts.size() ==2) {
1:3c38842:         String second = parts.get(1).trim();
1:3c38842:         if (second.startsWith("\"") && second.endsWith("\""))
1:3c38842:           second = second.substring(1,second.length()-1);
1:109ef40: 
1:449792b:         String first = parts.get(0).trim();
1:109ef40: 
1:109ef40:         // make sure for directives we clear out any space as in "directive  :=value"
1:449792b:         if (first.endsWith(":")) {
1:449792b:             first = first.substring(0, first.length()-1).trim()+":";
1:449792b:         }
1:109ef40: 
1:449792b:         params.put(first, second);
1:3c38842:       }
1:3c38842:     }
1:449792b: 
1:3c38842:     return params;
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:109ef40:    * Processes an import/export style header.. <p>
1:3c38842:    *  pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
1:109ef40:    *
1:3c38842:    * @param out The collection to add each package name + attrib map to.
1:3c38842:    * @param s The data to parse
1:3c38842:    */
1:de5b346:   private static void genericImportExportProcess(NameValueCollection out, String s){
1:3c38842:     List<String> packages = split(s, ",");
1:109ef40:     for(String pkg : packages){
1:de5b346:       List<NameValuePair> ps = genericNameWithNameValuePairProcess(pkg);
1:de5b346:       for (NameValuePair p : ps) {
1:de5b346:         out.addToCollection(p.getName(), p.getAttributes());
1:109ef40:       }
1:3c38842:     }
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * Parse an export style header.<p>
1:3c38842:    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value2
1:3c38842:    * <p>
1:3c38842:    * Result is returned as a list, as export does allow duplicate package exports.
1:109ef40:    *
1:7937e00:    * @param s The data to parse.
1:109ef40:    * @return List of NameValuePairs, where each Name in the list is an exported package,
1:109ef40:    *         with its associated Value being a NameValueMap of any attributes declared.
1:3c38842:    */
1:de5b346:   public static List<NameValuePair> parseExportString(String s){
1:de5b346:     NameValueList retval = new NameValueList();
1:3c38842:     genericImportExportProcess(retval, s);
2:3c38842:     return retval;
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * Parse an export style header in a list.<p>
1:3c38842:    *   pkg1;attrib=value;attrib=value
1:3c38842:    *   pkg2;attrib=value
1:3c38842:    *   pkg3;attrib=value2
1:3c38842:    * <p>
1:3c38842:    * Result is returned as a list, as export does allow duplicate package exports.
1:109ef40:    *
1:0aad0ca:    * @param list The data to parse.
1:109ef40:    * @return List of NameValuePairs, where each Name in the list is an exported package,
1:109ef40:    *         with its associated Value being a NameValueMap of any attributes declared.
1:3c38842:    */
1:de5b346:   public static List<NameValuePair> parseExportList(List<String> list){
1:de5b346:     NameValueList retval = new NameValueList();
1:109ef40:     for(String pkg : list){
1:de5b346:       List<NameValuePair> ps = genericNameWithNameValuePairProcess(pkg);
1:de5b346:       for (NameValuePair p : ps) {
1:de5b346:         retval.addToCollection(p.getName(), p.getAttributes());
1:109ef40:       }
1:3c38842:     }
1:3c38842:     return retval;
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * Parse an import style header.<p>
1:3c38842:    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
1:3c38842:    * <p>
1:3c38842:    * Result is returned as a set, as import does not allow duplicate package imports.
1:109ef40:    *
3:3c38842:    * @param s The data to parse.
1:109ef40:    * @return Map of NameValuePairs, where each Key in the Map is an imported package,
1:109ef40:    *         with its associated Value being a NameValueMap of any attributes declared.
1:109ef40:    */
1:de5b346:   public static Map<String, Map<String, String>> parseImportString(String s){
1:de5b346:     NameValueMap retval = new NameValueMap();
1:3c38842:     genericImportExportProcess(retval, s);
1:109ef40:     return retval;
1:3c38842:   }
1:109ef40: 
1:109ef40:   /**
1:109ef40:    * Parse a generic capability header. For example<br/>
1:109ef40:    *   com.acme.myns;mylist:List<String>="nl,be,fr,uk";myver:Version=1.3;long:Long="1234";d:Double="3.14";myattr=xyz,
1:109ef40:    *   com.acme.myns;myattr=abc
1:109ef40:    * @param s The header to be parsed
1:109ef40:    * @return A list of GenericMetadata objects each representing an individual capability. The values in the attribute map
1:109ef40:    *   are of the specified datatype.
1:109ef40:    */
1:109ef40:   public static List<GenericMetadata> parseCapabilityString(String s) {
1:109ef40:     return parseGenericMetadata(s);
1:109ef40:   }
1:109ef40: 
1:109ef40:   /**
1:109ef40:    * Parse a generic capability header. For example<br/>
1:109ef40:    *   com.acme.myns;mylist:List<String>="nl,be,fr,uk";myver:Version=1.3;long:Long="1234";d:Double="3.14";myattr=xyz,
1:109ef40:    *   com.acme.myns;myattr=abc
1:109ef40:    * @param s The header to be parsed
1:109ef40:    * @return A list of GenericMetadata objects each representing an individual capability. The values in the attribute map
1:109ef40:    *   are of the specified datatype.
1:109ef40:    */
1:109ef40:   public static List<GenericMetadata> parseRequirementString(String s) {
1:109ef40:     return parseGenericMetadata(s);
1:109ef40:   }
1:109ef40: 
1:109ef40:   private static List<GenericMetadata> parseGenericMetadata(String s) {
1:109ef40:     List<GenericMetadata> capabilities = new ArrayList<GenericMetadata>();
1:109ef40: 
1:109ef40:     List<String> entries = split(s, ",");
1:109ef40:     for(String e : entries){
1:109ef40:       List<NameValuePair> nvpList = genericNameWithNameValuePairProcess(e);
1:109ef40: 
1:109ef40:       for(NameValuePair nvp : nvpList) {
1:109ef40:         String namespace = nvp.getName();
1:109ef40:         GenericMetadata cap = new GenericMetadata(namespace);
1:109ef40:         capabilities.add(cap);
1:109ef40: 
1:109ef40:         Map<String, String> attrMap = nvp.getAttributes();
1:109ef40:         for (Map.Entry<String, String> entry : attrMap.entrySet()) {
1:109ef40:           String k = entry.getKey();
1:109ef40:           String v = entry.getValue();
1:109ef40:           if (k.contains(":")) {
1:109ef40:             if (k.endsWith(":")) {
1:109ef40:               // a directive
1:109ef40:               cap.getDirectives().put(k.substring(0, k.length() - 1), v);
1:109ef40:             } else {
1:109ef40:               // an attribute with its datatype specified
1:109ef40:               parseTypedAttribute(k, v, cap);
1:109ef40:             }
1:109ef40:           } else {
1:109ef40:             // ordinary (String) attribute
1:109ef40:             cap.getAttributes().put(k, v);
1:109ef40:           }
1:109ef40:         }
1:109ef40:       }
1:109ef40:     }
1:109ef40: 
1:109ef40:     return capabilities;
1:109ef40:   }
1:109ef40: 
1:109ef40:   private static void parseTypedAttribute(String k, String v, GenericMetadata cap) {
1:109ef40:     int idx = k.indexOf(':');
1:109ef40:     String name = k.substring(0, idx);
1:109ef40:     String type = k.substring(idx + 1);
1:109ef40: 
1:109ef40:     if (type.startsWith("List<") && type.endsWith(">")) {
1:109ef40:       String subtype = type.substring("List<".length(), type.length() - 1).trim();
1:109ef40:       List<Object> l = new ArrayList<Object>();
1:109ef40:       for (String s : v.split(",")) {
1:109ef40:         l.add(getTypedValue(k, subtype, s));
1:109ef40:       }
1:109ef40:       cap.getAttributes().put(name, l);
1:109ef40:     } else {
1:109ef40:       cap.getAttributes().put(name, getTypedValue(k, type.trim(), v));
1:109ef40:     }
1:109ef40:   }
1:109ef40: 
1:109ef40:   private static Object getTypedValue(String k, String type, String v) {
1:109ef40:     if ("String".equals(type)) {
1:109ef40:       return v;
1:109ef40:     } else if ("Long".equals(type)) {
1:109ef40:       return Long.parseLong(v);
1:109ef40:     } else if ("Double".equals(type)) {
1:109ef40:       return Double.parseDouble(v);
1:109ef40:     } else if ("Version".equals(type)) {
1:109ef40:       return Version.parseVersion(v);
1:109ef40:     }
1:109ef40:     throw new IllegalArgumentException(k + "=" + v);
1:109ef40:   }
1:109ef40: 
1:109ef40: 
1:3c38842:   /**
1:3c38842:    * Parse a bundle symbolic name.<p>
1:3c38842:    *   bundlesymbolicname;attrib=value;attrib=value
1:3c38842:    * <p>
1:109ef40:    *
1:3c38842:    * @param s The data to parse.
1:109ef40:    * @return NameValuePair with Name being the BundleSymbolicName,
1:109ef40:    *         and Value being any attribs declared for the name.
1:109ef40:    */
1:de5b346:   public static NameValuePair parseBundleSymbolicName(String s){
1:3c38842:     return genericNameWithNameValuePairProcess(s).get(0); // should just return the first one
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:109ef40:    * Parse a version range..
1:109ef40:    *
1:3c38842:    * @param s
1:3c38842:    * @return VersionRange object.
1:3c38842:    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
1:3c38842:    */
1:3c38842:   public static VersionRange parseVersionRange(String s) throws IllegalArgumentException{
1:910fec0:     return new VersionRange(s);
1:3c38842:   }
1:109ef40: 
1:3c38842:   /**
1:109ef40:    * Parse a version range and indicate if the version is an exact version
1:109ef40:    *
1:3c38842:    * @param s
1:3c38842:    * @param exactVersion
1:3c38842:    * @return VersionRange object.
1:3c38842:    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
1:3c38842:    */
1:3c38842:   public static VersionRange parseVersionRange(String s, boolean exactVersion) throws IllegalArgumentException{
1:910fec0:     return new VersionRange(s, exactVersion);
1:3c38842:   }
1:e1c60f4: 
1:3c38842:   /**
1:0fddb9f: 	 * Generate a filter from a set of attributes. This filter will be suitable
1:0fddb9f: 	 * for presentation to OBR This means that, due to the way OBR works, it
1:0fddb9f: 	 * will include a stanza of the form, (mandatory:<*mandatoryAttribute)
1:0fddb9f: 	 * Filter strings generated by this method will therefore tend to break the
1:0fddb9f: 	 * standard OSGi Filter class. The OBR stanza can be stripped out later if
1:0fddb9f: 	 * required.
1:109ef40: 	 *
1:3c38842: 	 * @param attribs
1:0fddb9f: 	 * @return filter string
1:3c38842: 	 */
1:0fddb9f: 	public static String generateFilter(Map<String, String> attribs) {
1:0fddb9f: 		StringBuilder filter = new StringBuilder("(&");
1:3c38842: 		boolean realAttrib = false;
1:3c38842: 		StringBuffer realAttribs = new StringBuffer();
1:e1c60f4: 
1:0fddb9f: 		if (attribs == null) {
1:0fddb9f: 			attribs = new HashMap<String, String>();
1:3c38842: 		}
1:e1c60f4: 
1:0fddb9f: 		for (Map.Entry<String, String> attrib : attribs.entrySet()) {
1:3c38842: 			String attribName = attrib.getKey();
1:8d4d949: 
1:0fddb9f: 			if (attribName.endsWith(":")) {
1:0fddb9f: 				// skip all directives. It is used to affect the attribs on the
1:0fddb9f: 				// filter xml.
1:0fddb9f: 			} else if ((Constants.VERSION_ATTRIBUTE.equals(attribName))
1:0fddb9f: 					|| (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attribName))) {
1:0fddb9f: 				// version and bundle-version attrib requires special
1:0fddb9f: 				// conversion.
1:3c38842: 				realAttrib = true;
1:9c133a0: 
1:0fddb9f: 				VersionRange vr = ManifestHeaderProcessor
1:0fddb9f: 						.parseVersionRange(attrib.getValue());
1:9c133a0: 
1:0fddb9f: 				filter.append("(" + attribName + ">=" + vr.getMinimumVersion());
1:9c133a0: 
1:0fddb9f: 				if (vr.getMaximumVersion() != null) {
1:3c38842: 					filter.append(")(" + attribName + "<=");
1:3c38842: 					filter.append(vr.getMaximumVersion());
1:3c38842: 				}
1:59e7b8b: 
1:0fddb9f: 				if (vr.getMaximumVersion() != null && vr.isMinimumExclusive()) {
1:3c38842: 					filter.append(")(!(" + attribName + "=");
1:3c38842: 					filter.append(vr.getMinimumVersion());
1:3c38842: 					filter.append(")");
1:3c38842: 				}
49:3c38842: 
1:0fddb9f: 				if (vr.getMaximumVersion() != null && vr.isMaximumExclusive()) {
1:3c38842: 					filter.append(")(!(" + attribName + "=");
1:3c38842: 					filter.append(vr.getMaximumVersion());
1:3c38842: 					filter.append(")");
1:3c38842: 				}
1:3c38842: 				filter.append(")");
1:3c38842: 
1:e1c60f4: 			} else if (NESTED_FILTER_ATTRIBUTE.equals(attribName)) {
1:e1c60f4: 				// Filters go in whole, no formatting needed
1:e1c60f4: 				realAttrib = true;
1:e1c60f4: 				filter.append(attrib.getValue());
1:e1c60f4: 
1:e1c60f4: 			} else if (Constants.OBJECTCLASS.equals(attribName)) {
1:e1c60f4: 				realAttrib = true;
1:e1c60f4: 				// objectClass has a "," separated list of interfaces
1:e1c60f4: 				String[] values = attrib.getValue().split(",");
1:e1c60f4: 				for (String s : values)
1:e1c60f4: 					filter.append("(" + Constants.OBJECTCLASS + "=" + s + ")");
1:e1c60f4: 
1:3c38842: 			} else {
1:0fddb9f: 				// attribName was not version..
1:3c38842: 				realAttrib = true;
1:3c38842: 
1:0fddb9f: 				filter.append("(" + attribName + "=" + attrib.getValue() + ")");
1:0fddb9f: 				// store all attributes in order to build up the mandatory
1:0fddb9f: 				// filter and separate them with ", "
1:3c38842: 				// skip bundle-symbolic-name in the mandatory directive query
1:0fddb9f: 				if (!!!Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE
1:0fddb9f: 						.equals(attribName)) {
1:3c38842: 					realAttribs.append(attribName);
1:3c38842: 					realAttribs.append(", ");
1:e1c60f4: 				}
1:3c38842: 			}
1:3c38842: 		}
1:0fddb9f: 		/*
1:0fddb9f: 		 * The following is how OBR makes mandatory attributes work, we require
1:0fddb9f: 		 * that the set of mandatory attributes on the export is a subset of (or
1:0fddb9f: 		 * equal to) the set of the attributes we supply.
1:3c38842: 		 */
1:3c38842: 
1:3c38842: 		if (realAttribs.length() > 0) {
1:3c38842: 			String attribStr = (realAttribs.toString()).trim();
1:3c38842: 			// remove the final ,
1:3c38842: 			if ((attribStr.length() > 0) && (attribStr.endsWith(","))) {
1:3c38842: 				attribStr = attribStr.substring(0, attribStr.length() - 1);
1:3c38842: 			}
1:3c38842: 			// build the mandatory filter, e.g.(mandatory:&lt;*company, local)
1:0fddb9f: 			filter.append("(" + Constants.MANDATORY_DIRECTIVE + ":" + "<*"
1:0fddb9f: 					+ attribStr + ")");
1:3c38842: 		}
1:3c38842: 
1:0fddb9f: 		// Prune (& off the front and ) off end
1:0fddb9f: 		String filterString = filter.toString();
1:0fddb9f: 		int openBraces = 0;
1:0fddb9f: 		for (int i = 0; openBraces < 3; i++) {
1:0fddb9f: 			i = filterString.indexOf('(', i);
1:0fddb9f: 			if (i == -1) {
1:0fddb9f: 				break;
1:3c38842: 			} else {
1:0fddb9f: 				openBraces++;
1:3c38842: 			}
1:3c38842: 		}
1:0fddb9f: 		if (openBraces < 3 && filterString.length() > 2) {
1:0fddb9f: 			filter.delete(0, 2);
3:0fddb9f: 		} else {
5:0fddb9f: 			filter.append(")");
1:3c38842: 		}
1:3c38842: 
1:0fddb9f: 		String result = "";
1:0fddb9f: 		if (realAttrib != false) {
2:0fddb9f: 			result = filter.toString();
1:3c38842: 		}
1:3c38842: 		return result;
1:3c38842: 	}
1:3c38842: 
1:3c38842: 	/**
1:0fddb9f:    * Generate a filter from a set of attributes. This filter will be suitable
1:0fddb9f:    * for presentation to OBR. This means that, due to the way OBR works, it will
1:0fddb9f:    * include a stanza of the form, (mandatory:<*mandatoryAttribute) Filter
1:0fddb9f:    * strings generated by this method will therefore tend to break the standard
1:0fddb9f:    * OSGi Filter class. The OBR stanza can be stripped out later if required.
1:109ef40:    *
1:0fddb9f:    * We may wish to consider relocating this method since VersionRange has its
1:0fddb9f:    * own top level class.
1:109ef40:    *
1:3c38842:    * @param type
1:3c38842:    * @param name
1:0fddb9f:    * @param attribs
1:0fddb9f:    * @return filter string
1:3c38842:    */
1:0fddb9f:   public static String generateFilter(String type, String name,
1:0fddb9f:       Map<String, String> attribs) {
1:3c38842:     StringBuffer filter = new StringBuffer();
1:3c38842:     String result;
1:0fddb9f:     // shortcut for the simple case with no attribs.
1:3c38842: 
1:0fddb9f:     if (attribs == null || attribs.isEmpty())
1:0fddb9f:       filter.append("(" + type + "=" + name + ")");
1:0fddb9f:     else {
1:0fddb9f:       // process all the attribs passed.
1:0fddb9f:       // find out whether there are attributes on the filter
1:3c38842: 
1:0fddb9f:       filter.append("(&(" + type + "=" + name + ")");
1:3c38842: 
1:0fddb9f:       String filterString = generateFilter(attribs);
1:3c38842: 
1:0fddb9f:       int start = 0;
1:0fddb9f:       int end = filterString.length();
1:0fddb9f:       if (filterString.startsWith("(&")) {
1:0fddb9f:         start = 2;
1:0fddb9f:         end--;
1:3c38842:       }
1:3c38842: 
1:0fddb9f:       if ("".equals(filterString)) {
1:0fddb9f:         filter.delete(0, 2);
1:3c38842:       } else {
1:0fddb9f:         filter.append(filterString, start, end);
1:3c38842:         filter.append(")");
1:3c38842:       }
1:3c38842:     }
1:3c38842: 
1:3c38842:     result = filter.toString();
1:3c38842: 
1:3c38842:     return result;
1:3c38842:   }
1:3c38842: 
1:0fddb9f:   private static Map<String, String> parseFilterList(String filter) {
1:3c38842: 
1:3c38842:     Map<String, String> result = new HashMap<String, String>();
1:3c38842:     Set<String> negatedVersions = new HashSet<String>();
1:0fddb9f:     Set<String> negatedBundleVersions = new HashSet<String>();
1:3c38842: 
1:3c38842:     String lowerVersion = null;
1:3c38842:     String upperVersion = null;
1:0fddb9f:     String lowerBundleVersion = null;
1:0fddb9f:     String upperBundleVersion = null;
1:3c38842: 
1:3c38842:     Matcher m = FILTER_ATTR.matcher(filter);
1:3c38842:     while (m.find()) {
1:3c38842:       boolean negation = m.group(1) != null;
1:3c38842:       String attr = m.group(2);
1:3c38842:       String op = m.group(3);
1:3c38842:       String value = m.group(4);
1:3c38842: 
1:3c38842:       if (Constants.VERSION_ATTRIBUTE.equals(attr)) {
1:3c38842:         if (negation) {
1:3c38842:           negatedVersions.add(value);
1:3c38842:         } else {
1:3c38842:           if (GREATER_EQ_OP.equals(op))
1:3c38842:             lowerVersion = value;
1:3c38842:           else if (LESS_EQ_OP.equals(op))
1:3c38842:             upperVersion = value;
1:3c38842:           else
1:3c38842:             throw new IllegalArgumentException();
1:3c38842:         }
1:0fddb9f:       } else if (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attr)) {
1:0fddb9f:         // bundle-version is like version, but may be specified at the
1:0fddb9f:         // same time
1:0fddb9f:         // therefore we have similar code with separate variables
1:0fddb9f:         if (negation) {
1:0fddb9f:           negatedBundleVersions.add(value);
1:3c38842:         } else {
1:0fddb9f:           if (GREATER_EQ_OP.equals(op))
1:0fddb9f:             lowerBundleVersion = value;
1:0fddb9f:           else if (LESS_EQ_OP.equals(op))
1:0fddb9f:             upperBundleVersion = value;
1:3c38842:           else
1:0fddb9f:             throw new IllegalArgumentException();
1:3c38842:         }
1:0fddb9f:       } else {
1:3c38842:         result.put(attr, value);
1:3c38842:       }
1:3c38842:     }
1:3c38842: 
1:3c38842:     if (lowerVersion != null) {
1:3c38842:       StringBuilder versionAttr = new StringBuilder(lowerVersion);
1:3c38842:       if (upperVersion != null) {
1:0fddb9f:         versionAttr.append(",").append(upperVersion).insert(0,
1:0fddb9f:             negatedVersions.contains(lowerVersion) ? '(' : '[').append(
1:0fddb9f:             negatedVersions.contains(upperVersion) ? ')' : ']');
1:3c38842:       }
1:3c38842: 
1:3c38842:       result.put(Constants.VERSION_ATTRIBUTE, versionAttr.toString());
1:3c38842:     }
1:0fddb9f:     // Do it again for bundle-version
1:0fddb9f:     if (lowerBundleVersion != null) {
1:0fddb9f:       StringBuilder versionAttr = new StringBuilder(lowerBundleVersion);
1:0fddb9f:       if (upperBundleVersion != null) {
1:0fddb9f:         versionAttr.append(",").append(upperBundleVersion).insert(0,
1:0fddb9f:             negatedBundleVersions.contains(lowerBundleVersion) ? '(' : '[')
1:0fddb9f:             .append(
1:0fddb9f:                 negatedBundleVersions.contains(upperBundleVersion) ? ')' : ']');
1:3c38842:       }
1:3c38842: 
1:0fddb9f:       result.put(Constants.BUNDLE_VERSION_ATTRIBUTE, versionAttr.toString());
1:3c38842:     }
1:3c38842: 
1:3c38842:     return result;
1:3c38842:   }
1:3c38842: 
1:109ef40:   public static Map<String,String> parseFilter(String filter)
1:3c38842:   {
1:3c38842:     Map<String,String> result;
1:3c38842:     if (filter.startsWith("(&")) {
1:3c38842:       result = parseFilterList(filter.substring(2, filter.length()-1));
1:3c38842:     } else {
1:3c38842:       result = parseFilterList(filter);
1:3c38842:     }
1:3c38842:     return result;
1:3c38842:   }
1:3c38842: }
1:3c38842: 
============================================================================
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:7937e00
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    * @param s The data to parse.
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:109ef40
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Version;
/////////////////////////////////////////////////////////////////////////
1:    * A GenericMetadata is either a Generic Capability or a Generic Requirement
1:    */
1:   public static class GenericMetadata {
1:     private final String namespace;
1:     private final Map<String, Object> attributes = new HashMap<String, Object>();
1:     private final Map<String, String> directives = new HashMap<String, String>();
1: 
1:     public GenericMetadata(String namespace) {
1:       this.namespace = namespace;
1:     }
1: 
1:     public String getNamespace() {
1:       return namespace;
1:     }
1: 
1:     public Map<String, Object> getAttributes() {
1:       return attributes;
1:     }
1: 
1:     public Map<String, String> getDirectives() {
1:       return directives;
1:     }
1:   }
1: 
1:   /**
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:    * Intended to provide a standard way to add Name/Value's to
/////////////////////////////////////////////////////////////////////////
1:    *
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   public static class NameValueList extends ArrayList<NameValuePair> implements NameValueCollection, List<NameValuePair> {
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1:         sb.append(nvp.toString());
1: 
1:    *
1:    *
/////////////////////////////////////////////////////////////////////////
1:   }
1: 
1: 
1:    *   [Name](;[Name])*(;[attribute-name]=[attribute-value])*<br>
1:    *
1:    * @return a list of NameValuePair, with the Name being the name component,
1:    *         and the Value being a NameValueMap of key->value mappings.
1:   private static List<NameValuePair> genericNameWithNameValuePairProcess(String s){
/////////////////////////////////////////////////////////////////////////
1:     }else{
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:           if (!!!(firstParameter))
1:       }
1: 
1: 
1:         }
1: 
1: 
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:    *
1:     Map<String,String> params = new HashMap<String,String>();
1:       // do a check, otherwise we might get NPE
1: 
1: 
1:         // make sure for directives we clear out any space as in "directive  :=value"
1: 
1: 
1:    * Processes an import/export style header.. <p>
1:    *
1:     for(String pkg : packages){
1:     }
1: 
1:    *
1:    * @return List of NameValuePairs, where each Name in the list is an exported package,
1:    *         with its associated Value being a NameValueMap of any attributes declared.
1: 
/////////////////////////////////////////////////////////////////////////
1:    *
1:    * @return List of NameValuePairs, where each Name in the list is an exported package,
1:    *         with its associated Value being a NameValueMap of any attributes declared.
1:     for(String pkg : list){
1:     }
1: 
1:    *
1:    * @return Map of NameValuePairs, where each Key in the Map is an imported package,
1:    *         with its associated Value being a NameValueMap of any attributes declared.
1:    */
1:     return retval;
1: 
1:   /**
1:    * Parse a generic capability header. For example<br/>
1:    *   com.acme.myns;mylist:List<String>="nl,be,fr,uk";myver:Version=1.3;long:Long="1234";d:Double="3.14";myattr=xyz,
1:    *   com.acme.myns;myattr=abc
1:    * @param s The header to be parsed
1:    * @return A list of GenericMetadata objects each representing an individual capability. The values in the attribute map
1:    *   are of the specified datatype.
1:    */
1:   public static List<GenericMetadata> parseCapabilityString(String s) {
1:     return parseGenericMetadata(s);
1:   }
1: 
1:   /**
1:    * Parse a generic capability header. For example<br/>
1:    *   com.acme.myns;mylist:List<String>="nl,be,fr,uk";myver:Version=1.3;long:Long="1234";d:Double="3.14";myattr=xyz,
1:    *   com.acme.myns;myattr=abc
1:    * @param s The header to be parsed
1:    * @return A list of GenericMetadata objects each representing an individual capability. The values in the attribute map
1:    *   are of the specified datatype.
1:    */
1:   public static List<GenericMetadata> parseRequirementString(String s) {
1:     return parseGenericMetadata(s);
1:   }
1: 
1:   private static List<GenericMetadata> parseGenericMetadata(String s) {
1:     List<GenericMetadata> capabilities = new ArrayList<GenericMetadata>();
1: 
1:     List<String> entries = split(s, ",");
1:     for(String e : entries){
1:       List<NameValuePair> nvpList = genericNameWithNameValuePairProcess(e);
1: 
1:       for(NameValuePair nvp : nvpList) {
1:         String namespace = nvp.getName();
1:         GenericMetadata cap = new GenericMetadata(namespace);
1:         capabilities.add(cap);
1: 
1:         Map<String, String> attrMap = nvp.getAttributes();
1:         for (Map.Entry<String, String> entry : attrMap.entrySet()) {
1:           String k = entry.getKey();
1:           String v = entry.getValue();
1:           if (k.contains(":")) {
1:             if (k.endsWith(":")) {
1:               // a directive
1:               cap.getDirectives().put(k.substring(0, k.length() - 1), v);
1:             } else {
1:               // an attribute with its datatype specified
1:               parseTypedAttribute(k, v, cap);
1:             }
1:           } else {
1:             // ordinary (String) attribute
1:             cap.getAttributes().put(k, v);
1:           }
1:         }
1:       }
1:     }
1: 
1:     return capabilities;
1:   }
1: 
1:   private static void parseTypedAttribute(String k, String v, GenericMetadata cap) {
1:     int idx = k.indexOf(':');
1:     String name = k.substring(0, idx);
1:     String type = k.substring(idx + 1);
1: 
1:     if (type.startsWith("List<") && type.endsWith(">")) {
1:       String subtype = type.substring("List<".length(), type.length() - 1).trim();
1:       List<Object> l = new ArrayList<Object>();
1:       for (String s : v.split(",")) {
1:         l.add(getTypedValue(k, subtype, s));
1:       }
1:       cap.getAttributes().put(name, l);
1:     } else {
1:       cap.getAttributes().put(name, getTypedValue(k, type.trim(), v));
1:     }
1:   }
1: 
1:   private static Object getTypedValue(String k, String type, String v) {
1:     if ("String".equals(type)) {
1:       return v;
1:     } else if ("Long".equals(type)) {
1:       return Long.parseLong(v);
1:     } else if ("Double".equals(type)) {
1:       return Double.parseDouble(v);
1:     } else if ("Version".equals(type)) {
1:       return Version.parseVersion(v);
1:     }
1:     throw new IllegalArgumentException(k + "=" + v);
1:   }
1: 
1: 
1:    *
1:    * @return NameValuePair with Name being the BundleSymbolicName,
1:    *         and Value being any attribs declared for the name.
1:    */
1: 
1:    * Parse a version range..
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1:    * Parse a version range and indicate if the version is an exact version
1:    *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1:    *
1:    *
/////////////////////////////////////////////////////////////////////////
1: 
1:   public static Map<String,String> parseFilter(String filter)
/////////////////////////////////////////////////////////////////////////
author:David Jencks
-------------------------------------------------------------------------------
commit:6df3ad3
commit:0aad0ca
/////////////////////////////////////////////////////////////////////////
1:    * @param list The data to parse.
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:de5b346
/////////////////////////////////////////////////////////////////////////
1:   public static class NameValuePair {
1:     private String name;
1:     private Map<String,String> attributes;
1:     
1:     public NameValuePair(String name, Map<String,String> value)
1:       this.attributes = value;
1:     public String getName()
1:     public void setName(String name)
1:     
1:     public Map<String,String> getAttributes()
1:       return attributes;
1:     public void setAttributes(Map<String,String> value)
1:       this.attributes = value;
1:     
1:       return "{"+name.toString()+"::"+attributes.toString()+"}";
/////////////////////////////////////////////////////////////////////////
1:       result = prime * result + ((attributes == null) ? 0 : attributes.hashCode());
/////////////////////////////////////////////////////////////////////////
1:       final NameValuePair other = (NameValuePair) obj;
1:       if (attributes == null) {
1:     	  if (other.attributes != null) return false;
1:       } else if (!attributes.equals(other.attributes)) return false;
/////////////////////////////////////////////////////////////////////////
1:   public static interface NameValueCollection {
1:     public void addToCollection(String n, Map<String,String> v);
/////////////////////////////////////////////////////////////////////////
1:   public static class NameValueMap extends HashMap<String, Map<String,String>> implements NameValueCollection, Map<String, Map<String,String>>{
1: 	private static final long serialVersionUID = -6446338858542599141L;
1: 	
1: 	public void addToCollection(String n, Map<String,String> v){
1: 	
1: 	@Override
1: 	public String toString(){
1:       for(Map.Entry<String, Map<String,String>> entry : this.entrySet()){
/////////////////////////////////////////////////////////////////////////
0:   public static class NameValueList extends ArrayList<NameValuePair> implements NameValueCollection, List<NameValuePair> {    
1: 	private static final long serialVersionUID = 1808636823825029983L;
1: 	
1: 	public void addToCollection(String n, Map<String,String> v){
1:       this.add(new NameValuePair(n,v));
1:       for(NameValuePair nvp : this){
/////////////////////////////////////////////////////////////////////////
0:   private static List<NameValuePair> genericNameWithNameValuePairProcess(String s){    
1:     Map<String,String> params = null;
1:     List<NameValuePair> nameValues = new ArrayList<NameValuePair>();
1:       params = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
1:       nameValues.add(new NameValuePair(pkg,params));
/////////////////////////////////////////////////////////////////////////
1:   private static Map<String,String> genericNameValueProcess(String s){
0:     Map<String,String> params = new HashMap<String,String>();  
/////////////////////////////////////////////////////////////////////////
1:   private static void genericImportExportProcess(NameValueCollection out, String s){
1:       List<NameValuePair> ps = genericNameWithNameValuePairProcess(pkg);
1:       for (NameValuePair p : ps) {
1:         out.addToCollection(p.getName(), p.getAttributes());
/////////////////////////////////////////////////////////////////////////
1:   public static List<NameValuePair> parseExportString(String s){
1:     NameValueList retval = new NameValueList();
/////////////////////////////////////////////////////////////////////////
1:   public static List<NameValuePair> parseExportList(List<String> list){
1:     NameValueList retval = new NameValueList();
1:       List<NameValuePair> ps = genericNameWithNameValuePairProcess(pkg);
1:       for (NameValuePair p : ps) {
1:         retval.addToCollection(p.getName(), p.getAttributes());
/////////////////////////////////////////////////////////////////////////
1:   public static Map<String, Map<String, String>> parseImportString(String s){
1:     NameValueMap retval = new NameValueMap();
/////////////////////////////////////////////////////////////////////////
1:   public static NameValuePair parseBundleSymbolicName(String s){
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.util.manifest;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.VersionRange;
/////////////////////////////////////////////////////////////////////////
1:     return new VersionRange(s);
/////////////////////////////////////////////////////////////////////////
1:     return new VersionRange(s, exactVersion);
/////////////////////////////////////////////////////////////////////////
commit:449792b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1:         String first = parts.get(0).trim();
1:         
0:         // make sure for directives we clear out any space as in "directive  :=value"        
1:         if (first.endsWith(":")) {
1:             first = first.substring(0, first.length()-1).trim()+":";
1:         }
1:         
1:         params.put(first, second);
commit:e1c60f4
/////////////////////////////////////////////////////////////////////////
1:   public static final String NESTED_FILTER_ATTRIBUTE = "org.apache.aries.application.filter.attribute";
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:       final NameValuePair<?, ?> other = (NameValuePair<?, ?>) obj;
/////////////////////////////////////////////////////////////////////////
1: 	    
0:    public void addToCollection(N n,V v){
1:    @Override
1:    public String toString(){
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public void addToCollection(N n,V v){
1: 	@Override
/////////////////////////////////////////////////////////////////////////
0:    * @param list The data to parse.
/////////////////////////////////////////////////////////////////////////
0:    * We may wish to consider moving this method to VersionRange.
/////////////////////////////////////////////////////////////////////////
1:        } else if (NESTED_FILTER_ATTRIBUTE.equals(attribName)) {
1:           // Filters go in whole, no formatting needed
1:           realAttrib = true;
1:           filter.append(attrib.getValue());
1: 
1:        } else if (Constants.OBJECTCLASS.equals(attribName)) {
1:           realAttrib = true;
1:           // objectClass has a "," separated list of interfaces
1:           String[] values = attrib.getValue().split(",");
1:           for (String s : values)
1:             filter.append("(" + Constants.OBJECTCLASS + "=" + s + ")");
1:           
0:       }else{
/////////////////////////////////////////////////////////////////////////
1:       }      
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:f9c9743
/////////////////////////////////////////////////////////////////////////
1:       StringBuilder sb = new StringBuilder();
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:8d4d949
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.ManifestHeaderUtils;
/////////////////////////////////////////////////////////////////////////
1:     return ManifestHeaderUtils.split(value, delimiter);
1:  
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:9c133a0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.Content;
0: import org.apache.aries.application.impl.ContentImpl;
/////////////////////////////////////////////////////////////////////////
1:   
1:   /**
0:    * Parse a content object
0:    * @param bundleSymbolicName bundle symbolic name
0:    * @param versionRange version range in the String format
0:    * @return Content object
1:    */
0:   public static Content parseContent(String bundleSymbolicName, String versionRange) {
0:     return new ContentImpl(bundleSymbolicName, parseVersionRange(versionRange));
1:   }
1:   
1:   /**
0:    * Parse a content
0:    * @param contentName The content name
0:    * @param nameValueMap The map containing the content attributes/directives
0:    * @return a content object
1:    */
0:   public static Content parseContent(String contentName, NameValueMap<String, String> nameValueMap) {
0:     return new ContentImpl(contentName, nameValueMap);
1:   }
1: 
commit:59e7b8b
/////////////////////////////////////////////////////////////////////////
1:   
commit:2227f26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.VersionRange;
0: import org.apache.aries.application.impl.VersionRangeImpl;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     return new VersionRangeImpl(s);
/////////////////////////////////////////////////////////////////////////
0:     return new VersionRangeImpl(s, exactVersion);
commit:3c38842
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
0: package org.apache.aries.application.utils.manifest;
1: 
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: 
0: import org.apache.aries.application.utils.internal.MessageUtil;
1: import org.osgi.framework.Constants;
0: import org.osgi.framework.Version;
1: 
1: 
1: public class ManifestHeaderProcessor
1: {
1:   /**
1:    * A simple class to associate two types.
1:    *
0:    * @param <N> The type for the 'Name'
0:    * @param <V> The type for the 'Value'
1:    */
0:   public static class NameValuePair<N,V>{
0:     private N name;
0:     private V value;
0:     public NameValuePair(N name, V value)
1:     {
1:       this.name = name;
0:       this.value = value;
1:     }
0:     public N getName()
1:     {
1:       return name;
1:     }
0:     public void setName(N name)
1:     {
1:       this.name = name;
1:     }
0:     public V getValue()
1:     {
0:       return value;
1:     }
0:     public void setValue(V value)
1:     {
0:       this.value = value;
1:     }
1:     public String toString(){
0:       return "{"+name.toString()+"::"+value.toString()+"}";
1:     }
1:     @Override
1:     public int hashCode()
1:     {
1:       final int prime = 31;
1:       int result = 1;
1:       result = prime * result + ((name == null) ? 0 : name.hashCode());
0:       result = prime * result + ((value == null) ? 0 : value.hashCode());
1:       return result;
1:     }
1:     @Override
1:     public boolean equals(Object obj)
1:     {
1:       if (this == obj) return true;
1:       if (obj == null) return false;
1:       if (getClass() != obj.getClass()) return false;
0:       final NameValuePair other = (NameValuePair) obj;
1:       if (name == null) {
1:         if (other.name != null) return false;
1:       } else if (!name.equals(other.name)) return false;
0:       if (value == null) {
0:         if (other.value != null) return false;
0:       } else if (!value.equals(other.value)) return false;
1:       return true;
1:     }
1:   }
1:   
1:   /**
0:    * Intended to provide a standard way to add Name/Value's to 
1:    * aggregations of Name/Value's.
1:    *
0:    * @param <N> Type of 'Name'
0:    * @param <V> Type of 'Value'
1:    */
0:   public static interface NameValueCollection<N,V>{
1:     /**
1:      * Add this Name & Value to the collection.
1:      * @param n
1:      * @param v
1:      */
0:     public void addToCollection(N n,V v);
1:   }
1: 
1:   /**
1:    * Map of Name -> Value.
1:    * 
0:    * @param <N> Type of 'Name'
0:    * @param <V> Type of 'Value'
1:    */
0:   public static class NameValueMap<N,V> extends HashMap<N,V> implements NameValueCollection<N,V>, Map<N,V>{
0:     public void addToCollection(N n,V v){
1:       this.put(n,v);
1:     }
1:     public String toString(){
1:       StringBuffer sb = new StringBuffer();
1:       sb.append("{");
1:       boolean first=true;
0:       for(Map.Entry<N, V> entry : this.entrySet()){
1:         if(!first)sb.append(",");
1:         first=false;
1:         sb.append(entry.getKey()+"->"+entry.getValue());
1:       }
1:       sb.append("}");
1:       return sb.toString();
1:     }
1:   }
1:   
1:   /**
1:    * List of Name/Value
1:    *
0:    * @param <N> Type of 'Name'
0:    * @param <V> Type of 'Value'
1:    */
0:   public static class NameValueList<N,V> extends ArrayList<NameValuePair<N,V>> implements NameValueCollection<N,V>, List<NameValuePair<N,V>>{    
0:     public void addToCollection(N n,V v){
0:       this.add(new NameValuePair<N,V>(n,v));
1:     } 
1:     public String toString(){
1:       StringBuffer sb = new StringBuffer();
1:       sb.append("{");
1:       boolean first = true;
0:       for(NameValuePair<N, V> nvp : this){
1:         if(!first)sb.append(",");
1:         first=false;
0:         sb.append(nvp.toString());        
1:       }
1:       sb.append("}");
1:       return sb.toString();
1:     }
1:   }
1:   
1:   /**
1:    * 
1:    * Splits a delimiter separated string, tolerating presence of non separator commas
1:    * within double quoted segments.
1:    * 
1:    * Eg.
1:    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
1:    * com.ibm.ws.eba.helloWorldService;version="1.0.0"
1:    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
1:    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
1:    *  @param value          the value to be split
1:    *  @param delimiter      the delimiter string such as ',' etc.
1:    *  @return List<String>  the components of the split String in a list
1:    */
1:   public static List<String> split(String value, String delimiter)
1:   {
0:     List<String> result = new ArrayList<String>();
0:     if (value != null) {
0:       String[] packages = value.split(delimiter);
1:       
0:       for (int i = 0; i < packages.length; ) {
0:         String tmp = packages[i++].trim();
0:         // if there is a odd number of " in a string, we need to append
0:         while (count(tmp, "\"") % 2 != 0) {
0:           // check to see if we need to append the next package[i++]          
0:             if (i<packages.length)
0:               tmp = tmp + delimiter + packages[i++].trim();
1:             else 
0:               // oops. The double quotes are not paired up. We have reached to the end of the string.
0:               throw new IllegalArgumentException(MessageUtil.getMessage("APPUTILS0008E",tmp));        
1:         }
1:         
0:         result.add(tmp);
1:         
1:       }
1:     }
1:     return result;
1:   }  
1:   
1:  /**
0:   * count the number of characters in a string
0:   * @param parent The string to be searched
0:   * @param subString The substring to be found
0:   * @return the number of occurrence of the subString
1:   */
0:   private static int count(String parent, String subString) {
1:     
0:     int count = 0 ;
0:     int i = parent.indexOf(subString);
0:     while (i > -1) {
0:       if (parent.length() >= i+1)
0:         parent = parent.substring(i+1);
0:       count ++;
0:       i = parent.indexOf(subString);
1:     }
0:     return count;
1:   }
1:   /**
1:    * Internal method to parse headers with the format<p>
0:    *   [Name](;[Name])*(;[attribute-name]=[attribute-value])*<br> 
1:    * Eg.<br>
1:    *   rumplestiltskin;thing=value;other=something<br>
1:    *   littleredridinghood
1:    *   bundle1;bundle2;other=things
1:    *   bundle1;bundle2
1:    *   
1:    * @param s data to parse
0:    * @return a list of NameValuePair, with the Name being the name component, 
0:    *         and the Value being a NameValueMap of key->value mappings.   
1:    */
0:   private static List<NameValuePair<String, NameValueMap<String, String>>> genericNameWithNameValuePairProcess(String s){    
1:     String name;
0:     NameValueMap<String,String> params = null;
0:     List<NameValuePair<String, NameValueMap<String, String>>> nameValues = new ArrayList<NameValuePair<String, NameValueMap<String, String>>>();
1:     List<String> pkgs = new ArrayList<String>();
1:     int index = s.indexOf(";");
1:     if(index==-1){
1:       name = s;
0:       params = new NameValueMap<String, String>();
1:       pkgs.add(name);
0:     }else{       
1:       name = s.substring(0,index).trim();
1:       String tail = s.substring(index+1).trim();
1:       
1:       pkgs.add(name); // add the first package
1:       StringBuilder parameters = new StringBuilder();
1:           
1:       
1:       // take into consideration of multiple packages separated by ';'
1:       // while they share the same attributes or directives
1:       List<String> tailParts = split(tail, ";");
1:       boolean firstParameter =false;
1:       
1:       for (String part : tailParts) {
1:         // if it is not a parameter and no parameter appears in front of it, it must a package
1:         if (!!!(part.contains("=")))  {
1:           // Need to make sure no parameter appears before the package, otherwise ignore this string
1:           // as this syntax is invalid
1:           if (!!!(firstParameter))
1:             pkgs.add(part);
1:         } else {
1:           if (!!!(firstParameter)) 
1:             firstParameter = true;
1: 
1:           parameters.append(part + ";");
1:         }
1:       }          
1:       
1:       if (parameters.length() != 0) {
1:         //remove the final ';' if there is one
1:         if (parameters.toString().endsWith(";")) {
1:          
1:           parameters = parameters.deleteCharAt(parameters.length() -1);
1:         }       
1:         
1:         params = genericNameValueProcess(parameters.toString());
1:       }
1:       
1:     }
1:     for (String pkg : pkgs) {
0:       nameValues.add(new NameValuePair<String, NameValueMap<String, String>>(pkg,params));
1:     }  
1:     
1:     return nameValues;
1:    
1:   }
1: 
1:   /**
1:    * Internal method to parse headers with the format<p>
1:    *   [attribute-name]=[attribute-value](;[attribute-name]=[attribute-value])*<br>
1:    * Eg.<br>
1:    *   thing=value;other=something<br>
1:    * <p>
1:    * Note. Directives (name:=value) are represented in the map with name suffixed by ':'
1:    *   
1:    * @param s data to parse
1:    * @return a NameValueMap, with attribute-name -> attribute-value.
1:    */
0:   private static NameValueMap<String,String> genericNameValueProcess(String s){
0:     NameValueMap<String,String> params = new NameValueMap<String,String>();  
1:     List<String> parameters = split(s, ";");
1:     for(String parameter : parameters) {
1:       List<String> parts = split(parameter,"=");
0:       // do a check, otherwise we might get NPE   
1:       if (parts.size() ==2) {
1:         String second = parts.get(1).trim();
1:         if (second.startsWith("\"") && second.endsWith("\""))
1:           second = second.substring(1,second.length()-1);
0:         params.put(parts.get(0).trim(), second);
1:       }
1:     }
1: 
1:     return params;
1:   }
1:   
1:   /**
0:    * Processes an import/export style header.. <p> 
1:    *  pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
1:    * 
1:    * @param out The collection to add each package name + attrib map to.
1:    * @param s The data to parse
1:    */
0:   private static void genericImportExportProcess(NameValueCollection<String, NameValueMap<String,String>>out, String s){
1:     List<String> packages = split(s, ",");
0:     for(String pkg : packages){   
0:       List<NameValuePair<String, NameValueMap<String, String>>> ps = genericNameWithNameValuePairProcess(pkg);
0:       for (NameValuePair<String, NameValueMap<String, String>> p : ps) {
0:         out.addToCollection(p.getName(), p.getValue());
1:       }
1:     }    
1:   }
1:   
1:   /**
1:    * Parse an export style header.<p>
1:    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value2
1:    * <p>
1:    * Result is returned as a list, as export does allow duplicate package exports.
1:    * 
1:    * @param s The data to parse.
0:    * @return List of NameValuePairs, where each Name in the list is an exported package, 
0:    *         with its associated Value being a NameValueMap of any attributes declared. 
1:    */
0:   public static List<NameValuePair<String, NameValueMap<String, String>>> parseExportString(String s){
0:     NameValueList<String, NameValueMap<String, String>> retval = new NameValueList<String, NameValueMap<String, String>>();
1:     genericImportExportProcess(retval, s);
1:     return retval;
1:   }
1:   
1:   /**
1:    * Parse an export style header in a list.<p>
1:    *   pkg1;attrib=value;attrib=value
1:    *   pkg2;attrib=value
1:    *   pkg3;attrib=value2
1:    * <p>
1:    * Result is returned as a list, as export does allow duplicate package exports.
1:    * 
1:    * @param s The data to parse.
0:    * @return List of NameValuePairs, where each Name in the list is an exported package, 
0:    *         with its associated Value being a NameValueMap of any attributes declared. 
1:    */
0:   public static List<NameValuePair<String, NameValueMap<String, String>>> parseExportList(List<String> list){
0:     NameValueList<String, NameValueMap<String, String>> retval = new NameValueList<String, NameValueMap<String, String>>();
0:     for(String pkg : list){   
0:       List<NameValuePair<String, NameValueMap<String, String>>> ps = genericNameWithNameValuePairProcess(pkg);
0:       for (NameValuePair<String, NameValueMap<String, String>> p : ps) {
0:         retval.addToCollection(p.getName(), p.getValue());
1:       }
1:     } 
1:     return retval;
1:   }
1:   
1:   /**
1:    * Parse an import style header.<p>
1:    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
1:    * <p>
1:    * Result is returned as a set, as import does not allow duplicate package imports.
1:    * 
1:    * @param s The data to parse.
0:    * @return Map of NameValuePairs, where each Key in the Map is an imported package, 
0:    *         with its associated Value being a NameValueMap of any attributes declared. 
1:    */  
0:   public static Map<String, NameValueMap<String, String>> parseImportString(String s){
0:     NameValueMap<String, NameValueMap<String, String>> retval = new NameValueMap<String, NameValueMap<String, String>>();
1:     genericImportExportProcess(retval, s);
1:     return retval;    
1:   }
1:   
1:   /**
1:    * Parse a bundle symbolic name.<p>
1:    *   bundlesymbolicname;attrib=value;attrib=value
1:    * <p>
1:    * 
1:    * @param s The data to parse.
0:    * @return NameValuePair with Name being the BundleSymbolicName, 
0:    *         and Value being any attribs declared for the name. 
1:    */   
0:   public static NameValuePair<String, NameValueMap<String, String>> parseBundleSymbolicName(String s){
1:     return genericNameWithNameValuePairProcess(s).get(0); // should just return the first one
1:   }
1: 
1:   
1:   /**
0:    * A simple class to represent Version Range information.<br>
0:    * Intended to provide version range parsing for callers.
1:    */
0:   public static class VersionRange
1:   {
0:     private boolean minimumExclusive = false;
0:     private boolean maximumExclusive = false;
0:     private Version minimumVersion = null;
0:     private Version maximumVersion = null;
0:     /** exact version */
0:     private boolean exactVersion = false;
1: 
1:     /**
0:      * Private, constructed via ManifestHeaderProcessor.parseVersionRange
0:      * @param version The string data to parse.
1:      */
0:     private VersionRange(String version) throws IllegalArgumentException
1:     {
0:       if (version != null) {
0:         version = version.trim();
0:         if(version.startsWith("\"") && version.endsWith("\"")){
0:           version = version.substring(1,version.length()-1).trim();
1:         }
1:         
0:         if ((version.startsWith("[") || version.startsWith("("))
0:             && (version.endsWith("]") || version.endsWith(")"))) {
0:           if (version.startsWith("[")) minimumExclusive = false;
0:           else if (version.startsWith("(")) minimumExclusive = true;
1: 
0:           if (version.endsWith("]")) maximumExclusive = false;
0:           else if (version.endsWith(")")) maximumExclusive = true;
1: 
0:           int index = version.indexOf(',');
0:           String minVersion = version.substring(1, index);
0:           String maxVersion = version.substring(index + 1, version.length() - 1);
1: 
0:           try {
0:             minimumVersion = Version.parseVersion(minVersion);
0:             maximumVersion = Version.parseVersion(maxVersion);
1:             
0:             if ((minimumVersion.compareTo(maximumVersion) == 0) 
0:                 && !!!maximumExclusive && !!!minimumExclusive){
0:               exactVersion = true;             
1:             }
0:           } catch (NumberFormatException nfe) {
0:             throw new IllegalArgumentException(MessageUtil.getMessage("APPUTILS0009E", version), nfe);
1:           }
1:         } else {
0:           minimumExclusive = false;
0:           maximumExclusive = false;
1:           
0:           try {
0:             minimumVersion = Version.parseVersion(version);
0:           } catch (NumberFormatException nfe) {
0:             throw new IllegalArgumentException(MessageUtil.getMessage("APPUTILS0009E", version), nfe);
1:           }
1:         }
0:       }else{
0:         throw new IllegalArgumentException(MessageUtil.getMessage("APPUTILS0010E"));        
1:       }
1:     }
1:     
1:     /**
0:      * Private, constructed via ManifestHeaderProcessor.parseVersionRange
0:      * @param version The string data to parse.
0:      * @param exactVersion whether this is an exact version
1:      */
0:     private VersionRange(String version, boolean exactVersion) throws IllegalArgumentException {
0:       this(version);
0:       this.exactVersion = exactVersion;
1:       
0:       if (this.maximumVersion == null) {
0:         this.maximumVersion = this.minimumVersion;
1:       }
0:       if (exactVersion) {
0:         if (!!!minimumVersion.equals(maximumVersion) || minimumExclusive || maximumExclusive) {
0:           throw new IllegalArgumentException(MessageUtil.getMessage("APPUTILS0011E", version));
1:         }
1:       }
1:     }
1: 
1:     /**
0:      * This method checks that the provided version matches the desired version.
1:      * 
0:      * @param version the version.
0:      * @return        true if the version matches, false otherwise.
1:      */
0:     public boolean matches(Version version)
1:     {
0:       boolean result;
0:       if (this.getMaximumVersion() == null) {
0:         result = this.getMinimumVersion().compareTo(version) <= 0;
1:       } else {
0:         int minN = this.isMinimumExclusive() ? 0 : 1;
0:         int maxN = this.isMaximumExclusive() ? 0 : 1;
1:         
0:         result = (this.getMinimumVersion().compareTo(version) < minN) &&
0:                  (version.compareTo(this.getMaximumVersion()) < maxN);
1:       }
1:       return result;
1:     }
1:     
1:     /**
0:      * Returns true if the Minimum is considered Exclusive<br> 
0:      * The Range was defined starting with '('
0:      * @return true if exclusive, false otherwise.
1:      */
0:     public boolean isMinimumExclusive()
1:     {
0:       return minimumExclusive;
1:     }
1:     /**
0:      * Returns true if the Maximum is considered Exclusive<br> 
0:      * The Range was defined ending with ')'<p>
0:      * This has no meaning if getMaximumVersion returns null.<br>
0:      * @return true if exclusive, false otherwise.
1:      */
0:     public boolean isMaximumExclusive()
1:     {
0:       return maximumExclusive;
1:     }
1:     /**
0:      * Returns the parsed Minimum Version
0:      * @return Minimum Version
1:      */
0:     public Version getMinimumVersion()
1:     {
0:       return minimumVersion;
1:     }
1:     /**
0:      * Returns the parsed Maximum Version. 
0:      * May return null if none was set, interpretable as Max Unbounded.
0:      * @return Maximum Version, or null if none was set.
1:      */
0:     public Version getMaximumVersion()
1:     {
0:       return maximumVersion;
1:     }
1:     
1:     /**
0:      * check if the versioninfo is the exact version
0:      * @return
1:      */
0:     public boolean isExactVersion() {
0:       return this.exactVersion;
1:     }
1:     
1:     /**
0:      * this method returns the exact version from the versionInfo obj.
0:      * this is used for DeploymentContent only to return a valid exact version
0:      * otherwise, null is returned.
0:      * @return
1:      */
0:     public Version getExactVersion() {
0:       return this.exactVersion ? getMinimumVersion() : null;
1:     }
1:   }
1:   
1:   /**
0:    * Parse a version range.. 
1:    * 
1:    * @param s
1:    * @return VersionRange object.
1:    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
1:    */
1:   public static VersionRange parseVersionRange(String s) throws IllegalArgumentException{
0:     return new VersionRange(s);
1:   }
1:   
1:   /**
0:    * Parse a version range and indicate if the version is an exact version 
1:    * 
1:    * @param s
1:    * @param exactVersion
1:    * @return VersionRange object.
1:    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
1:    */
1:   public static VersionRange parseVersionRange(String s, boolean exactVersion) throws IllegalArgumentException{
0:     return new VersionRange(s, exactVersion);
1:   }
1: 
1:   /**
0:    * This method is temporary here, until VersionRange becomes it's own top level class.
1:    * 
1:    * @param type
1:    * @param name
1:    * @param attribs
0:    * @return
1:    */
0:   public static String generateFilter(String type, String name, Map<String, String> attribs){
1:     StringBuffer filter = new StringBuffer();
1:     StringBuffer realAttribs = new StringBuffer();
1:     String result;
0:     //shortcut for the simple case with no attribs.
1:     boolean realAttrib = false;
0:     if(attribs.isEmpty())
0:       filter.append("("+type+"="+name+")");
0:     else{    
0:       //process all the attribs passed. 
0:       //find out whether there are attributes on the filter
1:       
0:       filter.append("(&("+type+"="+name+")");      
0:       for(Map.Entry<String,String> attrib : attribs.entrySet()){
1:         String attribName = attrib.getKey();
1:         
0:         if(attribName.endsWith(":")){
0:           //skip all directives. It is used to affect the attribs on the filter xml.
0:         }else if((Constants.VERSION_ATTRIBUTE.equals(attribName)) || (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attribName))){
0:           //version and bundle-version attrib requires special conversion.
1:           realAttrib = true;
1:           
0:           VersionRange vr = ManifestHeaderProcessor.parseVersionRange(attrib.getValue());
1: 
0:           filter.append("(" + attribName + ">="+vr.getMinimumVersion());
1:     
0:           if(vr.getMaximumVersion()!=null) {
1:             filter.append(")(" + attribName + "<=");
1:             filter.append(vr.getMaximumVersion());
1:           }
1:     
0:           if(vr.getMaximumVersion()!=null && vr.isMinimumExclusive()) {
1:             filter.append(")(!(" + attribName + "=");
1:             filter.append(vr.getMinimumVersion());
1:             filter.append(")");
1:           }
1:     
0:           if(vr.getMaximumVersion()!=null && vr.isMaximumExclusive()) {
1:             filter.append(")(!(" + attribName + "=");
1:             filter.append(vr.getMaximumVersion());
1:             filter.append(")");
1:           }
1:           filter.append(")"); 
1:           
0:         }else{
0:           //attribName was not version.. 
1:           realAttrib = true;
1:           
0:           filter.append("("+attribName+"="+attrib.getValue()+")");
0:           // store all attributes in order to build up the mandatory filter and separate them with ", "
1:           // skip bundle-symbolic-name in the mandatory directive query
0:           if (!!!Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE.equals(attribName)) {
1:             realAttribs.append(attribName);
1:             realAttribs.append(", ");
1:           }
1:         }     
1:       }
0:       // tidy up realAttribs - remove the final ,
1:       
1:       if (realAttribs.length() > 0) {
1:         String attribStr = (realAttribs.toString()).trim();
1:         // remove the final ,
1:         if ((attribStr.length() > 0) && (attribStr.endsWith(","))) {
1:           attribStr = attribStr.substring(0, attribStr.length() - 1);
1:         }
1:         // build the mandatory filter, e.g.(mandatory:&lt;*company, local)
0:         filter.append("(" + Constants.MANDATORY_DIRECTIVE + ":" + "<*"+attribStr + ")");
1:       }
1:       filter.append(")"); 
1:     }
1: 
1:     
0:     if (!!!(realAttrib)) {
0:       result = "("+type+"="+name+")";
1:     } else {
1:       result = filter.toString();
1:     }
1:     
1:     return result;
1:   }
1: 
1:   private static final Pattern FILTER_ATTR = Pattern.compile("(\\(!)?\\((.*?)([<>]?=)(.*?)\\)\\)?");
1:   private static final String LESS_EQ_OP = "<=";
1:   private static final String GREATER_EQ_OP = ">=";
1:   
0:   private static Map<String,String> parseFilterList(String filter)
1:   {
1:     Map<String, String> result = new HashMap<String, String>();
1:     Set<String> negatedVersions = new HashSet<String>();
1:     
1:     String lowerVersion = null;
1:     String upperVersion = null;
1:     
1:     Matcher m = FILTER_ATTR.matcher(filter);
1:     while (m.find()) {
1:       boolean negation = m.group(1) != null;
1:       String attr = m.group(2);
1:       String op = m.group(3);
1:       String value = m.group(4);
1:       
1:       if (Constants.VERSION_ATTRIBUTE.equals(attr)) {
1:         if (negation) {
1:           negatedVersions.add(value);
1:         } else {
1:           if (GREATER_EQ_OP.equals(op))
1:             lowerVersion = value;
1:           else if (LESS_EQ_OP.equals(op))
1:             upperVersion = value;
1:           else
1:             throw new IllegalArgumentException();
1:         }
1:       } else {
1:         result.put(attr, value);
1:       }
1:     }
1: 
1:     if (lowerVersion != null) {
1:       StringBuilder versionAttr = new StringBuilder(lowerVersion);
1:       if (upperVersion != null) {
0:         versionAttr.append(",")
0:           .append(upperVersion)
0:           .insert(0, negatedVersions.contains(lowerVersion) ? '(' : '[')
0:           .append(negatedVersions.contains(upperVersion) ? ')' : ']');
1:       }
1:       
1:       result.put(Constants.VERSION_ATTRIBUTE, versionAttr.toString());
1:     }
1:     return result;
1:   }
1:   
0:   public static Map<String,String> parseFilter(String filter) 
1:   {
1:     Map<String,String> result;
1:     if (filter.startsWith("(&")) {
1:       result = parseFilterList(filter.substring(2, filter.length()-1));
1:     } else {
1:       result = parseFilterList(filter);
1:     }
1:     return result;
1:   }
1: }
1: 
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:0fddb9f
/////////////////////////////////////////////////////////////////////////
0:   private static final Pattern FILTER_ATTR = Pattern.compile("(\\(!)?\\((.*?)([<>]?=)(.*?)\\)\\)?");
0:   private static final String LESS_EQ_OP = "<=";
0:   private static final String GREATER_EQ_OP = ">=";
/////////////////////////////////////////////////////////////////////////
1: 	 * Generate a filter from a set of attributes. This filter will be suitable
1: 	 * for presentation to OBR This means that, due to the way OBR works, it
1: 	 * will include a stanza of the form, (mandatory:<*mandatoryAttribute)
1: 	 * Filter strings generated by this method will therefore tend to break the
1: 	 * standard OSGi Filter class. The OBR stanza can be stripped out later if
1: 	 * required.
0: 	 * 
1: 	 * @param attribs
1: 	 * @return filter string
0: 	 */
1: 	public static String generateFilter(Map<String, String> attribs) {
1: 		StringBuilder filter = new StringBuilder("(&");
0: 		boolean realAttrib = false;
0: 		StringBuffer realAttribs = new StringBuffer();
0: 
1: 		if (attribs == null) {
1: 			attribs = new HashMap<String, String>();
0: 		}
0: 
1: 		for (Map.Entry<String, String> attrib : attribs.entrySet()) {
0: 			String attribName = attrib.getKey();
0: 
1: 			if (attribName.endsWith(":")) {
1: 				// skip all directives. It is used to affect the attribs on the
1: 				// filter xml.
1: 			} else if ((Constants.VERSION_ATTRIBUTE.equals(attribName))
1: 					|| (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attribName))) {
1: 				// version and bundle-version attrib requires special
1: 				// conversion.
0: 				realAttrib = true;
0: 
1: 				VersionRange vr = ManifestHeaderProcessor
1: 						.parseVersionRange(attrib.getValue());
0: 
1: 				filter.append("(" + attribName + ">=" + vr.getMinimumVersion());
0: 
1: 				if (vr.getMaximumVersion() != null) {
0: 					filter.append(")(" + attribName + "<=");
0: 					filter.append(vr.getMaximumVersion());
0: 				}
0: 
1: 				if (vr.getMaximumVersion() != null && vr.isMinimumExclusive()) {
0: 					filter.append(")(!(" + attribName + "=");
0: 					filter.append(vr.getMinimumVersion());
1: 					filter.append(")");
0: 				}
0: 
1: 				if (vr.getMaximumVersion() != null && vr.isMaximumExclusive()) {
0: 					filter.append(")(!(" + attribName + "=");
0: 					filter.append(vr.getMaximumVersion());
1: 					filter.append(")");
0: 				}
1: 				filter.append(")");
0: 
0: 			} else if (NESTED_FILTER_ATTRIBUTE.equals(attribName)) {
0: 				// Filters go in whole, no formatting needed
0: 				realAttrib = true;
0: 				filter.append(attrib.getValue());
0: 
0: 			} else if (Constants.OBJECTCLASS.equals(attribName)) {
0: 				realAttrib = true;
0: 				// objectClass has a "," separated list of interfaces
0: 				String[] values = attrib.getValue().split(",");
0: 				for (String s : values)
0: 					filter.append("(" + Constants.OBJECTCLASS + "=" + s + ")");
0: 
1: 			} else {
1: 				// attribName was not version..
0: 				realAttrib = true;
0: 
1: 				filter.append("(" + attribName + "=" + attrib.getValue() + ")");
1: 				// store all attributes in order to build up the mandatory
1: 				// filter and separate them with ", "
0: 				// skip bundle-symbolic-name in the mandatory directive query
1: 				if (!!!Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE
1: 						.equals(attribName)) {
0: 					realAttribs.append(attribName);
0: 					realAttribs.append(", ");
0: 				}
0: 			}
0: 		}
1: 		/*
1: 		 * The following is how OBR makes mandatory attributes work, we require
1: 		 * that the set of mandatory attributes on the export is a subset of (or
1: 		 * equal to) the set of the attributes we supply.
0: 		 */
0: 
0: 		if (realAttribs.length() > 0) {
0: 			String attribStr = (realAttribs.toString()).trim();
0: 			// remove the final ,
0: 			if ((attribStr.length() > 0) && (attribStr.endsWith(","))) {
0: 				attribStr = attribStr.substring(0, attribStr.length() - 1);
0: 			}
0: 			// build the mandatory filter, e.g.(mandatory:&lt;*company, local)
1: 			filter.append("(" + Constants.MANDATORY_DIRECTIVE + ":" + "<*"
1: 					+ attribStr + ")");
0: 		}
0: 
1: 		// Prune (& off the front and ) off end
1: 		String filterString = filter.toString();
1: 		int openBraces = 0;
1: 		for (int i = 0; openBraces < 3; i++) {
1: 			i = filterString.indexOf('(', i);
1: 			if (i == -1) {
1: 				break;
1: 			} else {
1: 				openBraces++;
0: 			}
0: 		}
1: 		if (openBraces < 3 && filterString.length() > 2) {
1: 			filter.delete(0, 2);
1: 		} else {
1: 			filter.append(")");
0: 		}
0: 
1: 		String result = "";
1: 		if (realAttrib != false) {
1: 			result = filter.toString();
0: 		}
0: 		return result;
0: 	}
0: 
0: 	/**
1:    * Generate a filter from a set of attributes. This filter will be suitable
1:    * for presentation to OBR. This means that, due to the way OBR works, it will
1:    * include a stanza of the form, (mandatory:<*mandatoryAttribute) Filter
1:    * strings generated by this method will therefore tend to break the standard
1:    * OSGi Filter class. The OBR stanza can be stripped out later if required.
0:    * 
1:    * We may wish to consider relocating this method since VersionRange has its
1:    * own top level class.
1:    * @return filter string
1:   public static String generateFilter(String type, String name,
1:       Map<String, String> attribs) {
1:     // shortcut for the simple case with no attribs.
1:     if (attribs == null || attribs.isEmpty())
1:       filter.append("(" + type + "=" + name + ")");
1:     else {
1:       // process all the attribs passed.
1:       // find out whether there are attributes on the filter
1:       filter.append("(&(" + type + "=" + name + ")");
0: 
1:       String filterString = generateFilter(attribs);
0: 
1:       int start = 0;
1:       int end = filterString.length();
1:       if (filterString.startsWith("(&")) {
1:         start = 2;
1:         end--;
0: 
1:       if ("".equals(filterString)) {
1:         filter.delete(0, 2);
1:       } else {
1:         filter.append(filterString, start, end);
1:         filter.append(")");
0:       }
1:     result = filter.toString();
0: 
1:   private static Map<String, String> parseFilterList(String filter) {
0: 
1:     Set<String> negatedBundleVersions = new HashSet<String>();
0: 
1:     String lowerBundleVersion = null;
1:     String upperBundleVersion = null;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:       } else if (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attr)) {
1:         // bundle-version is like version, but may be specified at the
1:         // same time
1:         // therefore we have similar code with separate variables
1:         if (negation) {
1:           negatedBundleVersions.add(value);
0:         } else {
1:           if (GREATER_EQ_OP.equals(op))
1:             lowerBundleVersion = value;
1:           else if (LESS_EQ_OP.equals(op))
1:             upperBundleVersion = value;
0:           else
1:             throw new IllegalArgumentException();
0:         }
/////////////////////////////////////////////////////////////////////////
1:         versionAttr.append(",").append(upperVersion).insert(0,
1:             negatedVersions.contains(lowerVersion) ? '(' : '[').append(
1:             negatedVersions.contains(upperVersion) ? ')' : ']');
0: 
1:     // Do it again for bundle-version
1:     if (lowerBundleVersion != null) {
1:       StringBuilder versionAttr = new StringBuilder(lowerBundleVersion);
1:       if (upperBundleVersion != null) {
1:         versionAttr.append(",").append(upperBundleVersion).insert(0,
1:             negatedBundleVersions.contains(lowerBundleVersion) ? '(' : '[')
1:             .append(
1:                 negatedBundleVersions.contains(upperBundleVersion) ? ')' : ']');
0:       }
0: 
1:       result.put(Constants.BUNDLE_VERSION_ATTRIBUTE, versionAttr.toString());
0:     }
0: 
0: 	  
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:8914925
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.aries.application.utils.manifest;
0: 
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.regex.Matcher;
0: import java.util.regex.Pattern;
0: 
0: import org.apache.aries.application.VersionRange;
0: import org.apache.aries.application.impl.VersionRangeImpl;
0: import org.apache.aries.application.utils.internal.MessageUtil;
0: import org.osgi.framework.Constants;
0: 
0: 
0: public class ManifestHeaderProcessor
0: {
0:   /**
0:    * A simple class to associate two types.
0:    *
0:    * @param <N> The type for the 'Name'
0:    * @param <V> The type for the 'Value'
0:    */
0:   public static class NameValuePair<N,V>{
0:     private N name;
0:     private V value;
0:     public NameValuePair(N name, V value)
0:     {
0:       this.name = name;
0:       this.value = value;
0:     }
0:     public N getName()
0:     {
0:       return name;
0:     }
0:     public void setName(N name)
0:     {
0:       this.name = name;
0:     }
0:     public V getValue()
0:     {
0:       return value;
0:     }
0:     public void setValue(V value)
0:     {
0:       this.value = value;
0:     }
0:     public String toString(){
0:       return "{"+name.toString()+"::"+value.toString()+"}";
0:     }
0:     @Override
0:     public int hashCode()
0:     {
0:       final int prime = 31;
0:       int result = 1;
0:       result = prime * result + ((name == null) ? 0 : name.hashCode());
0:       result = prime * result + ((value == null) ? 0 : value.hashCode());
0:       return result;
0:     }
0:     @Override
0:     public boolean equals(Object obj)
0:     {
0:       if (this == obj) return true;
0:       if (obj == null) return false;
0:       if (getClass() != obj.getClass()) return false;
0:       final NameValuePair other = (NameValuePair) obj;
0:       if (name == null) {
0:         if (other.name != null) return false;
0:       } else if (!name.equals(other.name)) return false;
0:       if (value == null) {
0:         if (other.value != null) return false;
0:       } else if (!value.equals(other.value)) return false;
0:       return true;
0:     }
0:   }
0:   
0:   /**
0:    * Intended to provide a standard way to add Name/Value's to 
0:    * aggregations of Name/Value's.
0:    *
0:    * @param <N> Type of 'Name'
0:    * @param <V> Type of 'Value'
0:    */
0:   public static interface NameValueCollection<N,V>{
0:     /**
0:      * Add this Name & Value to the collection.
0:      * @param n
0:      * @param v
0:      */
0:     public void addToCollection(N n,V v);
0:   }
0: 
0:   /**
0:    * Map of Name -> Value.
0:    * 
0:    * @param <N> Type of 'Name'
0:    * @param <V> Type of 'Value'
0:    */
0:   public static class NameValueMap<N,V> extends HashMap<N,V> implements NameValueCollection<N,V>, Map<N,V>{
0:     public void addToCollection(N n,V v){
0:       this.put(n,v);
0:     }
0:     public String toString(){
0:       StringBuffer sb = new StringBuffer();
0:       sb.append("{");
0:       boolean first=true;
0:       for(Map.Entry<N, V> entry : this.entrySet()){
0:         if(!first)sb.append(",");
0:         first=false;
0:         sb.append(entry.getKey()+"->"+entry.getValue());
0:       }
0:       sb.append("}");
0:       return sb.toString();
0:     }
0:   }
0:   
0:   /**
0:    * List of Name/Value
0:    *
0:    * @param <N> Type of 'Name'
0:    * @param <V> Type of 'Value'
0:    */
0:   public static class NameValueList<N,V> extends ArrayList<NameValuePair<N,V>> implements NameValueCollection<N,V>, List<NameValuePair<N,V>>{    
0:     public void addToCollection(N n,V v){
0:       this.add(new NameValuePair<N,V>(n,v));
0:     } 
0:     public String toString(){
0:       StringBuffer sb = new StringBuffer();
0:       sb.append("{");
0:       boolean first = true;
0:       for(NameValuePair<N, V> nvp : this){
0:         if(!first)sb.append(",");
0:         first=false;
0:         sb.append(nvp.toString());        
0:       }
0:       sb.append("}");
0:       return sb.toString();
0:     }
0:   }
0:   
0:   /**
0:    * 
0:    * Splits a delimiter separated string, tolerating presence of non separator commas
0:    * within double quoted segments.
0:    * 
0:    * Eg.
0:    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
0:    * com.ibm.ws.eba.helloWorldService;version="1.0.0"
0:    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
0:    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
0:    *  @param value          the value to be split
0:    *  @param delimiter      the delimiter string such as ',' etc.
0:    *  @return List<String>  the components of the split String in a list
0:    */
0:   public static List<String> split(String value, String delimiter)
0:   {
0:     List<String> result = new ArrayList<String>();
0:     if (value != null) {
0:       String[] packages = value.split(delimiter);
0:       
0:       for (int i = 0; i < packages.length; ) {
0:         String tmp = packages[i++].trim();
0:         // if there is a odd number of " in a string, we need to append
0:         while (count(tmp, "\"") % 2 != 0) {
0:           // check to see if we need to append the next package[i++]          
0:             if (i<packages.length)
0:               tmp = tmp + delimiter + packages[i++].trim();
0:             else 
0:               // oops. The double quotes are not paired up. We have reached to the end of the string.
0:               throw new IllegalArgumentException(MessageUtil.getMessage("APPUTILS0008E",tmp));        
0:         }
0:         
0:         result.add(tmp);
0:         
0:       }
0:     }
0:     return result;
0:   }  
0:   
0:  /**
0:   * count the number of characters in a string
0:   * @param parent The string to be searched
0:   * @param subString The substring to be found
0:   * @return the number of occurrence of the subString
0:   */
0:   private static int count(String parent, String subString) {
0:     
0:     int count = 0 ;
0:     int i = parent.indexOf(subString);
0:     while (i > -1) {
0:       if (parent.length() >= i+1)
0:         parent = parent.substring(i+1);
0:       count ++;
0:       i = parent.indexOf(subString);
0:     }
0:     return count;
0:   }
0:   /**
0:    * Internal method to parse headers with the format<p>
0:    *   [Name](;[Name])*(;[attribute-name]=[attribute-value])*<br> 
0:    * Eg.<br>
0:    *   rumplestiltskin;thing=value;other=something<br>
0:    *   littleredridinghood
0:    *   bundle1;bundle2;other=things
0:    *   bundle1;bundle2
0:    *   
0:    * @param s data to parse
0:    * @return a list of NameValuePair, with the Name being the name component, 
0:    *         and the Value being a NameValueMap of key->value mappings.   
0:    */
0:   private static List<NameValuePair<String, NameValueMap<String, String>>> genericNameWithNameValuePairProcess(String s){    
0:     String name;
0:     NameValueMap<String,String> params = null;
0:     List<NameValuePair<String, NameValueMap<String, String>>> nameValues = new ArrayList<NameValuePair<String, NameValueMap<String, String>>>();
0:     List<String> pkgs = new ArrayList<String>();
0:     int index = s.indexOf(";");
0:     if(index==-1){
0:       name = s;
0:       params = new NameValueMap<String, String>();
0:       pkgs.add(name);
0:     }else{       
0:       name = s.substring(0,index).trim();
0:       String tail = s.substring(index+1).trim();
0:       
0:       pkgs.add(name); // add the first package
0:       StringBuilder parameters = new StringBuilder();
0:           
0:       
0:       // take into consideration of multiple packages separated by ';'
0:       // while they share the same attributes or directives
0:       List<String> tailParts = split(tail, ";");
0:       boolean firstParameter =false;
0:       
0:       for (String part : tailParts) {
0:         // if it is not a parameter and no parameter appears in front of it, it must a package
0:         if (!!!(part.contains("=")))  {
0:           // Need to make sure no parameter appears before the package, otherwise ignore this string
0:           // as this syntax is invalid
0:           if (!!!(firstParameter))
0:             pkgs.add(part);
0:         } else {
0:           if (!!!(firstParameter)) 
0:             firstParameter = true;
0: 
0:           parameters.append(part + ";");
0:         }
0:       }          
0:       
0:       if (parameters.length() != 0) {
0:         //remove the final ';' if there is one
0:         if (parameters.toString().endsWith(";")) {
0:          
0:           parameters = parameters.deleteCharAt(parameters.length() -1);
0:         }       
0:         
0:         params = genericNameValueProcess(parameters.toString());
0:       }
0:       
0:     }
0:     for (String pkg : pkgs) {
0:       nameValues.add(new NameValuePair<String, NameValueMap<String, String>>(pkg,params));
0:     }  
0:     
0:     return nameValues;
0:    
0:   }
0: 
0:   /**
0:    * Internal method to parse headers with the format<p>
0:    *   [attribute-name]=[attribute-value](;[attribute-name]=[attribute-value])*<br>
0:    * Eg.<br>
0:    *   thing=value;other=something<br>
0:    * <p>
0:    * Note. Directives (name:=value) are represented in the map with name suffixed by ':'
0:    *   
0:    * @param s data to parse
0:    * @return a NameValueMap, with attribute-name -> attribute-value.
0:    */
0:   private static NameValueMap<String,String> genericNameValueProcess(String s){
0:     NameValueMap<String,String> params = new NameValueMap<String,String>();  
0:     List<String> parameters = split(s, ";");
0:     for(String parameter : parameters) {
0:       List<String> parts = split(parameter,"=");
0:       // do a check, otherwise we might get NPE   
0:       if (parts.size() ==2) {
0:         String second = parts.get(1).trim();
0:         if (second.startsWith("\"") && second.endsWith("\""))
0:           second = second.substring(1,second.length()-1);
0:         params.put(parts.get(0).trim(), second);
0:       }
0:     }
0: 
0:     return params;
0:   }
0:   
0:   /**
0:    * Processes an import/export style header.. <p> 
0:    *  pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
0:    * 
0:    * @param out The collection to add each package name + attrib map to.
0:    * @param s The data to parse
0:    */
0:   private static void genericImportExportProcess(NameValueCollection<String, NameValueMap<String,String>>out, String s){
0:     List<String> packages = split(s, ",");
0:     for(String pkg : packages){   
0:       List<NameValuePair<String, NameValueMap<String, String>>> ps = genericNameWithNameValuePairProcess(pkg);
0:       for (NameValuePair<String, NameValueMap<String, String>> p : ps) {
0:         out.addToCollection(p.getName(), p.getValue());
0:       }
0:     }    
0:   }
0:   
0:   /**
0:    * Parse an export style header.<p>
0:    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value2
0:    * <p>
0:    * Result is returned as a list, as export does allow duplicate package exports.
0:    * 
0:    * @param s The data to parse.
0:    * @return List of NameValuePairs, where each Name in the list is an exported package, 
0:    *         with its associated Value being a NameValueMap of any attributes declared. 
0:    */
0:   public static List<NameValuePair<String, NameValueMap<String, String>>> parseExportString(String s){
0:     NameValueList<String, NameValueMap<String, String>> retval = new NameValueList<String, NameValueMap<String, String>>();
0:     genericImportExportProcess(retval, s);
0:     return retval;
0:   }
0:   
0:   /**
0:    * Parse an export style header in a list.<p>
0:    *   pkg1;attrib=value;attrib=value
0:    *   pkg2;attrib=value
0:    *   pkg3;attrib=value2
0:    * <p>
0:    * Result is returned as a list, as export does allow duplicate package exports.
0:    * 
0:    * @param s The data to parse.
0:    * @return List of NameValuePairs, where each Name in the list is an exported package, 
0:    *         with its associated Value being a NameValueMap of any attributes declared. 
0:    */
0:   public static List<NameValuePair<String, NameValueMap<String, String>>> parseExportList(List<String> list){
0:     NameValueList<String, NameValueMap<String, String>> retval = new NameValueList<String, NameValueMap<String, String>>();
0:     for(String pkg : list){   
0:       List<NameValuePair<String, NameValueMap<String, String>>> ps = genericNameWithNameValuePairProcess(pkg);
0:       for (NameValuePair<String, NameValueMap<String, String>> p : ps) {
0:         retval.addToCollection(p.getName(), p.getValue());
0:       }
0:     } 
0:     return retval;
0:   }
0:   
0:   /**
0:    * Parse an import style header.<p>
0:    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
0:    * <p>
0:    * Result is returned as a set, as import does not allow duplicate package imports.
0:    * 
0:    * @param s The data to parse.
0:    * @return Map of NameValuePairs, where each Key in the Map is an imported package, 
0:    *         with its associated Value being a NameValueMap of any attributes declared. 
0:    */  
0:   public static Map<String, NameValueMap<String, String>> parseImportString(String s){
0:     NameValueMap<String, NameValueMap<String, String>> retval = new NameValueMap<String, NameValueMap<String, String>>();
0:     genericImportExportProcess(retval, s);
0:     return retval;    
0:   }
0:   
0:   /**
0:    * Parse a bundle symbolic name.<p>
0:    *   bundlesymbolicname;attrib=value;attrib=value
0:    * <p>
0:    * 
0:    * @param s The data to parse.
0:    * @return NameValuePair with Name being the BundleSymbolicName, 
0:    *         and Value being any attribs declared for the name. 
0:    */   
0:   public static NameValuePair<String, NameValueMap<String, String>> parseBundleSymbolicName(String s){
0:     return genericNameWithNameValuePairProcess(s).get(0); // should just return the first one
0:   }
0: 
0:   /**
0:    * Parse a version range.. 
0:    * 
0:    * @param s
0:    * @return VersionRange object.
0:    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
0:    */
0:   public static VersionRange parseVersionRange(String s) throws IllegalArgumentException{
0:     return new VersionRangeImpl(s);
0:   }
0:   
0:   /**
0:    * Parse a version range and indicate if the version is an exact version 
0:    * 
0:    * @param s
0:    * @param exactVersion
0:    * @return VersionRange object.
0:    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
0:    */
0:   public static VersionRange parseVersionRange(String s, boolean exactVersion) throws IllegalArgumentException{
0:     return new VersionRangeImpl(s, exactVersion);
0:   }
0: 
0:   /**
0:    * This method is temporary here, until VersionRange becomes it's own top level class.
0:    * 
0:    * @param type
0:    * @param name
0:    * @param attribs
0:    * @return
0:    */
0:   public static String generateFilter(String type, String name, Map<String, String> attribs){
0:     StringBuffer filter = new StringBuffer();
0:     StringBuffer realAttribs = new StringBuffer();
0:     String result;
0:     //shortcut for the simple case with no attribs.
0:     boolean realAttrib = false;
0:     if(attribs.isEmpty())
0:       filter.append("("+type+"="+name+")");
0:     else{    
0:       //process all the attribs passed. 
0:       //find out whether there are attributes on the filter
0:       
0:       filter.append("(&("+type+"="+name+")");      
0:       for(Map.Entry<String,String> attrib : attribs.entrySet()){
0:         String attribName = attrib.getKey();
0:         
0:         if(attribName.endsWith(":")){
0:           //skip all directives. It is used to affect the attribs on the filter xml.
0:         }else if((Constants.VERSION_ATTRIBUTE.equals(attribName)) || (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attribName))){
0:           //version and bundle-version attrib requires special conversion.
0:           realAttrib = true;
0:           
0:           VersionRange vr = ManifestHeaderProcessor.parseVersionRange(attrib.getValue());
0: 
0:           filter.append("(" + attribName + ">="+vr.getMinimumVersion());
0:     
0:           if(vr.getMaximumVersion()!=null) {
0:             filter.append(")(" + attribName + "<=");
0:             filter.append(vr.getMaximumVersion());
0:           }
0:     
0:           if(vr.getMaximumVersion()!=null && vr.isMinimumExclusive()) {
0:             filter.append(")(!(" + attribName + "=");
0:             filter.append(vr.getMinimumVersion());
0:             filter.append(")");
0:           }
0:     
0:           if(vr.getMaximumVersion()!=null && vr.isMaximumExclusive()) {
0:             filter.append(")(!(" + attribName + "=");
0:             filter.append(vr.getMaximumVersion());
0:             filter.append(")");
0:           }
0:           filter.append(")"); 
0:           
0:         }else{
0:           //attribName was not version.. 
0:           realAttrib = true;
0:           
0:           filter.append("("+attribName+"="+attrib.getValue()+")");
0:           // store all attributes in order to build up the mandatory filter and separate them with ", "
0:           // skip bundle-symbolic-name in the mandatory directive query
0:           if (!!!Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE.equals(attribName)) {
0:             realAttribs.append(attribName);
0:             realAttribs.append(", ");
0:           }
0:         }     
0:       }
0:       // tidy up realAttribs - remove the final ,
0:       
0:       if (realAttribs.length() > 0) {
0:         String attribStr = (realAttribs.toString()).trim();
0:         // remove the final ,
0:         if ((attribStr.length() > 0) && (attribStr.endsWith(","))) {
0:           attribStr = attribStr.substring(0, attribStr.length() - 1);
0:         }
0:         // build the mandatory filter, e.g.(mandatory:&lt;*company, local)
0:         filter.append("(" + Constants.MANDATORY_DIRECTIVE + ":" + "<*"+attribStr + ")");
0:       }
0:       filter.append(")"); 
0:     }
0: 
0:     
0:     if (!!!(realAttrib)) {
0:       result = "("+type+"="+name+")";
0:     } else {
0:       result = filter.toString();
0:     }
0:     
0:     return result;
0:   }
0: 
0:   private static final Pattern FILTER_ATTR = Pattern.compile("(\\(!)?\\((.*?)([<>]?=)(.*?)\\)\\)?");
0:   private static final String LESS_EQ_OP = "<=";
0:   private static final String GREATER_EQ_OP = ">=";
0:   
0:   private static Map<String,String> parseFilterList(String filter)
0:   {
0:     Map<String, String> result = new HashMap<String, String>();
0:     Set<String> negatedVersions = new HashSet<String>();
0:     
0:     String lowerVersion = null;
0:     String upperVersion = null;
0:     
0:     Matcher m = FILTER_ATTR.matcher(filter);
0:     while (m.find()) {
0:       boolean negation = m.group(1) != null;
0:       String attr = m.group(2);
0:       String op = m.group(3);
0:       String value = m.group(4);
0:       
0:       if (Constants.VERSION_ATTRIBUTE.equals(attr)) {
0:         if (negation) {
0:           negatedVersions.add(value);
0:         } else {
0:           if (GREATER_EQ_OP.equals(op))
0:             lowerVersion = value;
0:           else if (LESS_EQ_OP.equals(op))
0:             upperVersion = value;
0:           else
0:             throw new IllegalArgumentException();
0:         }
0:       } else {
0:         result.put(attr, value);
0:       }
0:     }
0: 
0:     if (lowerVersion != null) {
0:       StringBuilder versionAttr = new StringBuilder(lowerVersion);
0:       if (upperVersion != null) {
0:         versionAttr.append(",")
0:           .append(upperVersion)
0:           .insert(0, negatedVersions.contains(lowerVersion) ? '(' : '[')
0:           .append(negatedVersions.contains(upperVersion) ? ')' : ']');
0:       }
0:       
0:       result.put(Constants.VERSION_ATTRIBUTE, versionAttr.toString());
0:     }
0:     return result;
0:   }
0:   
0:   public static Map<String,String> parseFilter(String filter) 
0:   {
0:     Map<String,String> result;
0:     if (filter.startsWith("(&")) {
0:       result = parseFilterList(filter.substring(2, filter.length()-1));
0:     } else {
0:       result = parseFilterList(filter);
0:     }
0:     return result;
0:   }
0: }
0: 
============================================================================