1:1362378: /**
1:1362378:  * Licensed to the Apache Software Foundation (ASF) under one
1:1362378:  * or more contributor license agreements.  See the NOTICE file
1:1362378:  * distributed with this work for additional information
1:1362378:  * regarding copyright ownership.  The ASF licenses this file
1:1362378:  * to you under the Apache License, Version 2.0 (the
1:1362378:  * "License"); you may not use this file except in compliance
1:1362378:  * with the License.  You may obtain a copy of the License at
1:1362378:  *
1:1362378:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1362378:  *
1:1362378:  * Unless required by applicable law or agreed to in writing,
1:1362378:  * software distributed under the License is distributed on an
1:1362378:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:1362378:  * KIND, either express or implied.  See the License for the
1:1362378:  * specific language governing permissions and limitations
1:1362378:  * under the License.
1:1362378:  */
1:1362378: package org.apache.aries.spifly.dynamic;
1:1362378: 
1:1362378: import java.io.BufferedReader;
1:1362378: import java.io.File;
1:1362378: import java.io.FileReader;
1:1362378: import java.io.IOException;
1:1362378: import java.lang.reflect.Field;
1:1362378: import java.lang.reflect.Method;
1:1362378: import java.net.URL;
1:1362378: import java.net.URLClassLoader;
1:1362378: import java.security.ProtectionDomain;
1:1362378: import java.util.ArrayList;
1:1362378: import java.util.Arrays;
1:1362378: import java.util.Collection;
1:11803af: import java.util.Collections;
1:1362378: import java.util.Dictionary;
1:1362378: import java.util.Enumeration;
1:1362378: import java.util.HashMap;
1:1362378: import java.util.Hashtable;
1:1362378: import java.util.List;
1:1362378: import java.util.Map;
1:1362378: import java.util.concurrent.ConcurrentHashMap;
1:1362378: 
1:1362378: import org.apache.aries.spifly.BaseActivator;
1:e9a5257: import org.apache.aries.spifly.SpiFlyConstants;
1:1362378: import org.apache.aries.spifly.Streams;
1:1362378: import org.easymock.EasyMock;
1:1362378: import org.easymock.IAnswer;
1:1362378: import org.junit.After;
1:1362378: import org.junit.Assert;
1:1362378: import org.junit.Before;
1:1362378: import org.junit.Test;
1:1362378: import org.osgi.framework.Bundle;
1:1362378: import org.osgi.framework.BundleContext;
1:1362378: import org.osgi.framework.BundleReference;
1:1362378: import org.osgi.framework.Version;
1:1362378: import org.osgi.framework.hooks.weaving.WeavingHook;
1:1362378: import org.osgi.framework.hooks.weaving.WovenClass;
1:1362378: import org.osgi.framework.wiring.BundleRevision;
1:1362378: import org.osgi.framework.wiring.BundleWiring;
1:1362378: 
1:1362378: public class ClientWeavingHookOSGi43Test  {
1:1362378:     DynamicWeavingActivator activator;
1:1362378: 
1:1362378:     @Before
1:1362378:     public void setUp() {
1:1362378:         activator = new DynamicWeavingActivator();
1:1362378:         BaseActivator.activator = activator;
1:1362378:     }
1:1362378: 
1:1362378:     @After
1:1362378:     public void tearDown() {
1:1362378:         BaseActivator.activator = null;
1:1362378:         activator = null;
1:1362378:     }
1:1362378: 
1:1362378:     @Test
1:1362378:     public void testBasicServiceLoaderUsageWithClassLoaderFromBundleRevision() throws Exception {
1:1362378:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:1362378:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1:1362378: 
1:1362378:         // Register the bundle that provides the SPI implementation.
1:1362378:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:1362378:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:1362378: 
1:1362378:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:1362378:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:1362378: 
1:1362378:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:1362378:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:1362378: 
1:1362378:         // Weave the TestClient class.
1:1362378:         URL clsUrl = getClass().getResource("TestClient.class");
1:1362378:         Assert.assertNotNull("Precondition", clsUrl);
1:1362378: 
1:1362378:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:1362378:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:1362378:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:1362378:         wh.weave(wc);
1:1362378:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:1362378:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:1362378:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:1362378:         String di = wc.getDynamicImports().get(0);
1:1362378:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1:1362378: 
1:1362378:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:1362378:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:1362378:         Class<?> cls = wc.getDefinedClass();
1:1362378:         Method method = cls.getMethod("test", new Class [] {String.class});
1:1362378:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Assert.assertEquals(Collections.singleton("olleh"), result);
1:1362378:     }
1:1362378: 
1:1362378:     private Bundle mockSpiFlyBundle(String bsn, Version version, Bundle ... bundles) throws Exception {
1:1362378:         Bundle spiFlyBundle = EasyMock.createMock(Bundle.class);
1:1362378: 
1:1362378:         BundleContext spiFlyBundleContext = EasyMock.createMock(BundleContext.class);
1:1362378:         EasyMock.expect(spiFlyBundleContext.getBundle()).andReturn(spiFlyBundle).anyTimes();
1:1362378:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(bundles));
1:1362378:         allBundles.add(spiFlyBundle);
1:1362378:         EasyMock.expect(spiFlyBundleContext.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:1362378:         EasyMock.replay(spiFlyBundleContext);
1:1362378: 
1:1362378:         EasyMock.expect(spiFlyBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:1362378:         EasyMock.expect(spiFlyBundle.getVersion()).andReturn(version).anyTimes();
1:1362378:         EasyMock.expect(spiFlyBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:1362378:         EasyMock.expect(spiFlyBundle.getBundleContext()).andReturn(spiFlyBundleContext).anyTimes();
1:1362378:         EasyMock.replay(spiFlyBundle);
1:1362378: 
1:1362378:         // Set the bundle context for testing purposes
1:1362378:         Field bcField = BaseActivator.class.getDeclaredField("bundleContext");
1:1362378:         bcField.setAccessible(true);
1:1362378:         bcField.set(activator, spiFlyBundle.getBundleContext());
1:1362378: 
1:1362378:         return spiFlyBundle;
1:1362378:     }
1:1362378: 
1:1362378:     private Bundle mockProviderBundle(String subdir, long id) throws Exception {
1:1362378:         return mockProviderBundle(subdir, id, Version.emptyVersion);
1:1362378:     }
1:1362378: 
1:1362378:     private Bundle mockProviderBundle(String subdir, long id, Version version) throws Exception {
1:1362378:         URL url = getClass().getResource("/" + getClass().getName().replace('.', '/') + ".class");
1:1362378:         File classFile = new File(url.getFile());
1:1362378:         File baseDir = new File(classFile.getParentFile(), subdir);
1:1362378:         File directory = new File(baseDir, "/META-INF/services");
1:1362378:         final List<String> classNames = new ArrayList<String>();
1:1362378: 
1:1362378:         // Do a directory listing of the applicable META-INF/services directory
1:1362378:         List<String> resources = new ArrayList<String>();
1:1362378:         for (File f : directory.listFiles()) {
1:1362378:             String fileName = f.getName();
1:1362378:             if (fileName.startsWith(".") || fileName.endsWith("."))
1:1362378:                 continue;
1:1362378: 
1:1362378:             classNames.addAll(getClassNames(f));
1:1362378: 
1:1362378:             // Needs to be something like: META-INF/services/org.apache.aries.mytest.MySPI
1:1362378:             String path = f.getAbsolutePath().substring(baseDir.getAbsolutePath().length());
1:1362378:             path = path.replace('\\', '/');
1:1362378:             if (path.startsWith("/")) {
1:1362378:                 path = path.substring(1);
1:1362378:             }
1:1362378:             resources.add(path);
1:1362378:         }
1:1362378: 
1:1362378:         // Set up the classloader that will be used by the ASM-generated code as the TCCL.
1:1362378:         // It can load a META-INF/services file
1:1362378:         final ClassLoader cl = new TestProviderBundleClassLoader(subdir, resources.toArray(new String [] {}));
1:1362378: 
1:1362378:         final List<String> classResources = new ArrayList<String>();
1:1362378:         for(String className : classNames) {
1:1362378:             classResources.add("/" + className.replace('.', '/') + ".class");
1:1362378:         }
1:1362378: 
1:1362378:         Bundle systemBundle = EasyMock.createMock(Bundle.class);
1:1362378:         EasyMock.<Class<?>>expect(systemBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:1362378:             @Override
1:1362378:             public Class<?> answer() throws Throwable {
1:1362378:                 String name = (String) EasyMock.getCurrentArguments()[0];
1:1362378:                 return ClientWeavingHookOSGi43Test.class.getClassLoader().loadClass(name);
1:1362378:             }
1:1362378:         }).anyTimes();
1:1362378:         EasyMock.replay(systemBundle);
1:1362378: 
1:1362378:         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);
1:1362378:         EasyMock.expect(bc.getBundle(0)).andReturn(systemBundle).anyTimes();
1:1362378:         EasyMock.replay(bc);
1:1362378: 
1:1362378:         BundleWiring bundleWiring = EasyMock.createMock(BundleWiring.class);
1:1362378:         EasyMock.expect(bundleWiring.getClassLoader()).andReturn(cl).anyTimes();
1:1362378:         EasyMock.replay(bundleWiring);
1:1362378: 
1:1362378:         BundleRevision bundleRevision = EasyMock.createMock(BundleRevision.class);
1:1362378:         EasyMock.expect(bundleRevision.getWiring()).andReturn(bundleWiring).anyTimes();
1:1362378:         EasyMock.replay(bundleRevision);
1:1362378: 
1:1362378:         Bundle providerBundle = EasyMock.createMock(Bundle.class);
1:1362378:         String bsn = subdir;
1:1362378:         int idx = bsn.indexOf('_');
1:1362378:         if (idx > 0) {
1:1362378:             bsn = bsn.substring(0, idx);
1:1362378:         }
1:1362378:         EasyMock.expect(providerBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:1362378:         EasyMock.expect(providerBundle.getBundleId()).andReturn(id).anyTimes();
1:1362378:         EasyMock.expect(providerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:1362378:         EasyMock.expect(providerBundle.getVersion()).andReturn(version).anyTimes();
1:1362378:         EasyMock.expect(providerBundle.adapt(BundleRevision.class)).andReturn(bundleRevision).anyTimes();
1:1362378:         EasyMock.<Class<?>>expect(providerBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:1362378:             @Override
1:1362378:             public Class<?> answer() throws Throwable {
1:1362378:                 String name = (String) EasyMock.getCurrentArguments()[0];
1:1362378:                 if (!classNames.contains(name)) {
1:1362378:                     throw new ClassCastException(name);
1:1362378:                 }
1:1362378:                 return cl.loadClass(name);
1:1362378:             }
1:1362378:         }).anyTimes();
1:1362378:         EasyMock.replay(providerBundle);
1:1362378:         return providerBundle;
1:1362378:     }
1:1362378: 
1:1362378:     private Collection<String> getClassNames(File f) throws IOException {
1:1362378:         List<String> names = new ArrayList<String>();
1:1362378: 
1:1362378:         BufferedReader br = new BufferedReader(new FileReader(f));
1:1362378:         try {
1:1362378:             String line = null;
1:1362378:             while((line = br.readLine()) != null) {
1:1362378:                 names.add(line.trim());
1:1362378:             }
1:1362378:         } finally {
1:1362378:             br.close();
1:1362378:         }
1:1362378:         return names;
1:1362378:     }
1:1362378: 
1:1362378:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, Bundle ... otherBundles) {
1:1362378:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load()
1:1362378:         // or another SPI invocation.
1:1362378:         BundleContext bc = EasyMock.createMock(BundleContext.class);
1:1362378: 
1:1362378:         Bundle consumerBundle = EasyMock.createMock(Bundle.class);
1:1362378:         EasyMock.expect(consumerBundle.getSymbolicName()).andReturn("testConsumer").anyTimes();
1:1362378:         EasyMock.expect(consumerBundle.getHeaders()).andReturn(headers).anyTimes();
1:1362378:         EasyMock.expect(consumerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:1362378:         EasyMock.expect(consumerBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:7dabe8c:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(null).anyTimes();
1:1362378:         EasyMock.replay(consumerBundle);
1:1362378: 
1:1362378:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(otherBundles));
1:1362378:         allBundles.add(consumerBundle);
1:1362378:         EasyMock.expect(bc.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:1362378:         EasyMock.replay(bc);
1:1362378: 
1:1362378:         return consumerBundle;
1:1362378:     }
1:1362378: 
1:1362378:     // A classloader that loads anything starting with org.apache.aries.spifly.dynamic.impl1 from it
1:1362378:     // and the rest from the parent. This is to mimic a bundle that holds a specific SPI implementation.
1:1362378:     public static class TestProviderBundleClassLoader extends URLClassLoader {
1:1362378:         private final List<String> resources;
1:1362378:         private final String prefix;
1:1362378:         private final String classPrefix;
1:1362378:         private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<String, Class<?>>();
1:1362378: 
1:1362378:         public TestProviderBundleClassLoader(String subdir, String ... resources) {
1:1362378:             super(new URL [] {}, TestProviderBundleClassLoader.class.getClassLoader());
1:1362378: 
1:1362378:             this.prefix = TestProviderBundleClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:1362378:             this.classPrefix = prefix.replace('/', '.');
1:1362378:             this.resources = Arrays.asList(resources);
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:1362378:             if (name.startsWith(classPrefix))
1:1362378:                 return loadClassLocal(name);
1:1362378: 
1:1362378:             return super.loadClass(name);
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:1362378:             if (name.startsWith(classPrefix)) {
1:1362378:                 Class<?> cls = loadClassLocal(name);
1:1362378:                 if (resolve)
1:1362378:                     resolveClass(cls);
1:1362378: 
1:1362378:                 return cls;
1:1362378:             }
1:1362378: 
1:1362378:             return super.loadClass(name, resolve);
1:1362378:         }
1:1362378: 
1:1362378:         protected Class<?> loadClassLocal(String name) throws ClassNotFoundException {
1:1362378:             Class<?> prevLoaded = loadedClasses.get(name);
1:1362378:             if (prevLoaded != null)
1:1362378:                 return prevLoaded;
1:1362378: 
1:1362378:             URL res = TestProviderBundleClassLoader.class.getClassLoader().getResource(name.replace('.', '/') + ".class");
1:1362378:             try {
1:1362378:                 byte[] bytes = Streams.suck(res.openStream());
1:1362378:                 Class<?> cls = defineClass(name, bytes, 0, bytes.length);
1:1362378:                 loadedClasses.put(name, cls);
1:1362378:                 return cls;
1:1362378:             } catch (Exception e) {
1:1362378:                 throw new ClassNotFoundException(name, e);
1:1362378:             }
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public URL findResource(String name) {
1:1362378:             if (resources.contains(name)) {
1:1362378:                 return getClass().getClassLoader().getResource(prefix + name);
1:1362378:             } else {
1:1362378:                 return super.findResource(name);
1:1362378:             }
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public Enumeration<URL> findResources(String name) throws IOException {
1:1362378:             if (resources.contains(name)) {
1:1362378:                 return getClass().getClassLoader().getResources(prefix + name);
1:1362378:             } else {
1:1362378:                 return super.findResources(name);
1:1362378:             }
1:1362378:         }
1:1362378:     }
1:1362378: 
1:1362378:     private static class MyWovenClass implements WovenClass {
1:1362378:         byte [] bytes;
1:1362378:         final String className;
1:1362378:         final Bundle bundleContainingOriginalClass;
1:1362378:         List<String> dynamicImports = new ArrayList<String>();
1:1362378:         boolean weavingComplete = false;
1:1362378: 
1:1362378:         private MyWovenClass(URL clazz, String name, Bundle bundle) throws Exception {
1:1362378:             bytes = Streams.suck(clazz.openStream());
1:1362378:             className = name;
1:1362378:             bundleContainingOriginalClass = bundle;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public byte[] getBytes() {
1:1362378:             return bytes;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public void setBytes(byte[] newBytes) {
1:1362378:             bytes = newBytes;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public List<String> getDynamicImports() {
1:1362378:             return dynamicImports;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public boolean isWeavingComplete() {
1:1362378:             return weavingComplete;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public String getClassName() {
1:1362378:             return className;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public ProtectionDomain getProtectionDomain() {
1:1362378:             return null;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public Class<?> getDefinedClass() {
1:1362378:             try {
1:1362378:                 weavingComplete = true;
1:1362378:                 return new MyWovenClassClassLoader(className, getBytes(), getClass().getClassLoader(), bundleContainingOriginalClass).loadClass(className);
1:1362378:             } catch (ClassNotFoundException e) {
1:1362378:                 e.printStackTrace();
1:1362378:                 return null;
1:1362378:             }
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public BundleWiring getBundleWiring() {
1:1362378:             BundleWiring bw = EasyMock.createMock(BundleWiring.class);
1:1362378:             EasyMock.expect(bw.getBundle()).andReturn(bundleContainingOriginalClass);
1:1362378:             EasyMock.expect(bw.getClassLoader()).andReturn(getClass().getClassLoader());
1:1362378:             EasyMock.replay(bw);
1:1362378:             return bw;
1:1362378:         }
1:1362378:     }
1:1362378: 
1:1362378:     private static class MyWovenClassClassLoader extends ClassLoader implements BundleReference {
1:1362378:         private final String className;
1:1362378:         private final Bundle bundle;
1:1362378:         private final byte [] bytes;
1:1362378:         private Class<?> wovenClass;
1:1362378: 
1:1362378:         public MyWovenClassClassLoader(String className, byte[] bytes, ClassLoader parent, Bundle bundle) {
1:1362378:             super(parent);
1:1362378: 
1:1362378:             this.className = className;
1:1362378:             this.bundle = bundle;
1:1362378:             this.bytes = bytes;
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         protected synchronized Class<?> loadClass(String name, boolean resolve)
1:1362378:                 throws ClassNotFoundException {
1:1362378:             if (name.equals(className)) {
1:1362378:                 if (wovenClass == null)
1:1362378:                     wovenClass = defineClass(className, bytes, 0, bytes.length);
1:1362378: 
1:1362378:                 return wovenClass;
1:1362378:             } else {
1:1362378:                 return super.loadClass(name, resolve);
1:1362378:             }
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:1362378:             return loadClass(name, false);
1:1362378:         }
1:1362378: 
1:1362378:         @Override
1:1362378:         public Bundle getBundle() {
1:1362378:             return bundle;
1:1362378:         }
1:1362378:     }
1:1362378: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:7dabe8c
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(null).anyTimes();
commit:11803af
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals(Collections.singleton("olleh"), result);
commit:e9a5257
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.spifly.SpiFlyConstants;
commit:1362378
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.spifly.dynamic;
1: 
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.FileReader;
1: import java.io.IOException;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Method;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.security.ProtectionDomain;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Hashtable;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: 
1: import org.apache.aries.spifly.BaseActivator;
1: import org.apache.aries.spifly.Streams;
0: import org.apache.aries.spifly.api.SpiFlyConstants;
1: import org.easymock.EasyMock;
1: import org.easymock.IAnswer;
1: import org.junit.After;
1: import org.junit.Assert;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleReference;
1: import org.osgi.framework.Version;
1: import org.osgi.framework.hooks.weaving.WeavingHook;
1: import org.osgi.framework.hooks.weaving.WovenClass;
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.framework.wiring.BundleWiring;
1: 
1: public class ClientWeavingHookOSGi43Test  {
1:     DynamicWeavingActivator activator;
1: 
1:     @Before
1:     public void setUp() {
1:         activator = new DynamicWeavingActivator();
1:         BaseActivator.activator = activator;
1:     }
1: 
1:     @After
1:     public void tearDown() {
1:         BaseActivator.activator = null;
1:         activator = null;
1:     }
1: 
1:     @Test
1:     public void testBasicServiceLoaderUsageWithClassLoaderFromBundleRevision() throws Exception {
1:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1: 
1:         // Register the bundle that provides the SPI implementation.
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1: 
1:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
1: 
1:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:         String di = wc.getDynamicImports().get(0);
1:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1: 
1:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("olleh", result);
1:     }
1: 
1:     private Bundle mockSpiFlyBundle(String bsn, Version version, Bundle ... bundles) throws Exception {
1:         Bundle spiFlyBundle = EasyMock.createMock(Bundle.class);
1: 
1:         BundleContext spiFlyBundleContext = EasyMock.createMock(BundleContext.class);
1:         EasyMock.expect(spiFlyBundleContext.getBundle()).andReturn(spiFlyBundle).anyTimes();
1:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(bundles));
1:         allBundles.add(spiFlyBundle);
1:         EasyMock.expect(spiFlyBundleContext.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:         EasyMock.replay(spiFlyBundleContext);
1: 
1:         EasyMock.expect(spiFlyBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getVersion()).andReturn(version).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getBundleContext()).andReturn(spiFlyBundleContext).anyTimes();
1:         EasyMock.replay(spiFlyBundle);
1: 
1:         // Set the bundle context for testing purposes
1:         Field bcField = BaseActivator.class.getDeclaredField("bundleContext");
1:         bcField.setAccessible(true);
1:         bcField.set(activator, spiFlyBundle.getBundleContext());
1: 
1:         return spiFlyBundle;
1:     }
1: 
1:     private Bundle mockProviderBundle(String subdir, long id) throws Exception {
1:         return mockProviderBundle(subdir, id, Version.emptyVersion);
1:     }
1: 
1:     private Bundle mockProviderBundle(String subdir, long id, Version version) throws Exception {
1:         URL url = getClass().getResource("/" + getClass().getName().replace('.', '/') + ".class");
1:         File classFile = new File(url.getFile());
1:         File baseDir = new File(classFile.getParentFile(), subdir);
1:         File directory = new File(baseDir, "/META-INF/services");
1:         final List<String> classNames = new ArrayList<String>();
1: 
1:         // Do a directory listing of the applicable META-INF/services directory
1:         List<String> resources = new ArrayList<String>();
1:         for (File f : directory.listFiles()) {
1:             String fileName = f.getName();
1:             if (fileName.startsWith(".") || fileName.endsWith("."))
1:                 continue;
1: 
1:             classNames.addAll(getClassNames(f));
1: 
1:             // Needs to be something like: META-INF/services/org.apache.aries.mytest.MySPI
1:             String path = f.getAbsolutePath().substring(baseDir.getAbsolutePath().length());
1:             path = path.replace('\\', '/');
1:             if (path.startsWith("/")) {
1:                 path = path.substring(1);
1:             }
1:             resources.add(path);
1:         }
1: 
1:         // Set up the classloader that will be used by the ASM-generated code as the TCCL.
1:         // It can load a META-INF/services file
1:         final ClassLoader cl = new TestProviderBundleClassLoader(subdir, resources.toArray(new String [] {}));
1: 
1:         final List<String> classResources = new ArrayList<String>();
1:         for(String className : classNames) {
1:             classResources.add("/" + className.replace('.', '/') + ".class");
1:         }
1: 
1:         Bundle systemBundle = EasyMock.createMock(Bundle.class);
1:         EasyMock.<Class<?>>expect(systemBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:             @Override
1:             public Class<?> answer() throws Throwable {
1:                 String name = (String) EasyMock.getCurrentArguments()[0];
1:                 return ClientWeavingHookOSGi43Test.class.getClassLoader().loadClass(name);
1:             }
1:         }).anyTimes();
1:         EasyMock.replay(systemBundle);
1: 
1:         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);
1:         EasyMock.expect(bc.getBundle(0)).andReturn(systemBundle).anyTimes();
1:         EasyMock.replay(bc);
1: 
1:         BundleWiring bundleWiring = EasyMock.createMock(BundleWiring.class);
1:         EasyMock.expect(bundleWiring.getClassLoader()).andReturn(cl).anyTimes();
1:         EasyMock.replay(bundleWiring);
1: 
1:         BundleRevision bundleRevision = EasyMock.createMock(BundleRevision.class);
1:         EasyMock.expect(bundleRevision.getWiring()).andReturn(bundleWiring).anyTimes();
1:         EasyMock.replay(bundleRevision);
1: 
1:         Bundle providerBundle = EasyMock.createMock(Bundle.class);
1:         String bsn = subdir;
1:         int idx = bsn.indexOf('_');
1:         if (idx > 0) {
1:             bsn = bsn.substring(0, idx);
1:         }
1:         EasyMock.expect(providerBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:         EasyMock.expect(providerBundle.getBundleId()).andReturn(id).anyTimes();
1:         EasyMock.expect(providerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:         EasyMock.expect(providerBundle.getVersion()).andReturn(version).anyTimes();
1:         EasyMock.expect(providerBundle.adapt(BundleRevision.class)).andReturn(bundleRevision).anyTimes();
1:         EasyMock.<Class<?>>expect(providerBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:             @Override
1:             public Class<?> answer() throws Throwable {
1:                 String name = (String) EasyMock.getCurrentArguments()[0];
1:                 if (!classNames.contains(name)) {
1:                     throw new ClassCastException(name);
1:                 }
1:                 return cl.loadClass(name);
1:             }
1:         }).anyTimes();
1:         EasyMock.replay(providerBundle);
1:         return providerBundle;
1:     }
1: 
1:     private Collection<String> getClassNames(File f) throws IOException {
1:         List<String> names = new ArrayList<String>();
1: 
1:         BufferedReader br = new BufferedReader(new FileReader(f));
1:         try {
1:             String line = null;
1:             while((line = br.readLine()) != null) {
1:                 names.add(line.trim());
1:             }
1:         } finally {
1:             br.close();
1:         }
1:         return names;
1:     }
1: 
1:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, Bundle ... otherBundles) {
1:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load()
1:         // or another SPI invocation.
1:         BundleContext bc = EasyMock.createMock(BundleContext.class);
1: 
1:         Bundle consumerBundle = EasyMock.createMock(Bundle.class);
1:         EasyMock.expect(consumerBundle.getSymbolicName()).andReturn("testConsumer").anyTimes();
1:         EasyMock.expect(consumerBundle.getHeaders()).andReturn(headers).anyTimes();
1:         EasyMock.expect(consumerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:         EasyMock.expect(consumerBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:         EasyMock.replay(consumerBundle);
1: 
1:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(otherBundles));
1:         allBundles.add(consumerBundle);
1:         EasyMock.expect(bc.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:         EasyMock.replay(bc);
1: 
1:         return consumerBundle;
1:     }
1: 
1:     // A classloader that loads anything starting with org.apache.aries.spifly.dynamic.impl1 from it
1:     // and the rest from the parent. This is to mimic a bundle that holds a specific SPI implementation.
1:     public static class TestProviderBundleClassLoader extends URLClassLoader {
1:         private final List<String> resources;
1:         private final String prefix;
1:         private final String classPrefix;
1:         private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<String, Class<?>>();
1: 
1:         public TestProviderBundleClassLoader(String subdir, String ... resources) {
1:             super(new URL [] {}, TestProviderBundleClassLoader.class.getClassLoader());
1: 
1:             this.prefix = TestProviderBundleClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:             this.classPrefix = prefix.replace('/', '.');
1:             this.resources = Arrays.asList(resources);
1:         }
1: 
1:         @Override
1:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:             if (name.startsWith(classPrefix))
1:                 return loadClassLocal(name);
1: 
1:             return super.loadClass(name);
1:         }
1: 
1:         @Override
1:         protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:             if (name.startsWith(classPrefix)) {
1:                 Class<?> cls = loadClassLocal(name);
1:                 if (resolve)
1:                     resolveClass(cls);
1: 
1:                 return cls;
1:             }
1: 
1:             return super.loadClass(name, resolve);
1:         }
1: 
1:         protected Class<?> loadClassLocal(String name) throws ClassNotFoundException {
1:             Class<?> prevLoaded = loadedClasses.get(name);
1:             if (prevLoaded != null)
1:                 return prevLoaded;
1: 
1:             URL res = TestProviderBundleClassLoader.class.getClassLoader().getResource(name.replace('.', '/') + ".class");
1:             try {
1:                 byte[] bytes = Streams.suck(res.openStream());
1:                 Class<?> cls = defineClass(name, bytes, 0, bytes.length);
1:                 loadedClasses.put(name, cls);
1:                 return cls;
1:             } catch (Exception e) {
1:                 throw new ClassNotFoundException(name, e);
1:             }
1:         }
1: 
1:         @Override
1:         public URL findResource(String name) {
1:             if (resources.contains(name)) {
1:                 return getClass().getClassLoader().getResource(prefix + name);
1:             } else {
1:                 return super.findResource(name);
1:             }
1:         }
1: 
1:         @Override
1:         public Enumeration<URL> findResources(String name) throws IOException {
1:             if (resources.contains(name)) {
1:                 return getClass().getClassLoader().getResources(prefix + name);
1:             } else {
1:                 return super.findResources(name);
1:             }
1:         }
1:     }
1: 
1:     private static class MyWovenClass implements WovenClass {
1:         byte [] bytes;
1:         final String className;
1:         final Bundle bundleContainingOriginalClass;
1:         List<String> dynamicImports = new ArrayList<String>();
1:         boolean weavingComplete = false;
1: 
1:         private MyWovenClass(URL clazz, String name, Bundle bundle) throws Exception {
1:             bytes = Streams.suck(clazz.openStream());
1:             className = name;
1:             bundleContainingOriginalClass = bundle;
1:         }
1: 
1:         @Override
1:         public byte[] getBytes() {
1:             return bytes;
1:         }
1: 
1:         @Override
1:         public void setBytes(byte[] newBytes) {
1:             bytes = newBytes;
1:         }
1: 
1:         @Override
1:         public List<String> getDynamicImports() {
1:             return dynamicImports;
1:         }
1: 
1:         @Override
1:         public boolean isWeavingComplete() {
1:             return weavingComplete;
1:         }
1: 
1:         @Override
1:         public String getClassName() {
1:             return className;
1:         }
1: 
1:         @Override
1:         public ProtectionDomain getProtectionDomain() {
1:             return null;
1:         }
1: 
1:         @Override
1:         public Class<?> getDefinedClass() {
1:             try {
1:                 weavingComplete = true;
1:                 return new MyWovenClassClassLoader(className, getBytes(), getClass().getClassLoader(), bundleContainingOriginalClass).loadClass(className);
1:             } catch (ClassNotFoundException e) {
1:                 e.printStackTrace();
1:                 return null;
1:             }
1:         }
1: 
1:         @Override
1:         public BundleWiring getBundleWiring() {
1:             BundleWiring bw = EasyMock.createMock(BundleWiring.class);
1:             EasyMock.expect(bw.getBundle()).andReturn(bundleContainingOriginalClass);
1:             EasyMock.expect(bw.getClassLoader()).andReturn(getClass().getClassLoader());
1:             EasyMock.replay(bw);
1:             return bw;
1:         }
1:     }
1: 
1:     private static class MyWovenClassClassLoader extends ClassLoader implements BundleReference {
1:         private final String className;
1:         private final Bundle bundle;
1:         private final byte [] bytes;
1:         private Class<?> wovenClass;
1: 
1:         public MyWovenClassClassLoader(String className, byte[] bytes, ClassLoader parent, Bundle bundle) {
1:             super(parent);
1: 
1:             this.className = className;
1:             this.bundle = bundle;
1:             this.bytes = bytes;
1:         }
1: 
1:         @Override
1:         protected synchronized Class<?> loadClass(String name, boolean resolve)
1:                 throws ClassNotFoundException {
1:             if (name.equals(className)) {
1:                 if (wovenClass == null)
1:                     wovenClass = defineClass(className, bytes, 0, bytes.length);
1: 
1:                 return wovenClass;
1:             } else {
1:                 return super.loadClass(name, resolve);
1:             }
1:         }
1: 
1:         @Override
1:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:             return loadClass(name, false);
1:         }
1: 
1:         @Override
1:         public Bundle getBundle() {
1:             return bundle;
1:         }
1:     }
1: }
============================================================================