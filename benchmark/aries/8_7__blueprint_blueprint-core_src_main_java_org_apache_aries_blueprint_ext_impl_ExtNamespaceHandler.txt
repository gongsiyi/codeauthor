1:f13c6ac: /**
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:be8e9c5: package org.apache.aries.blueprint.ext.impl;
1:f13c6ac: 
1:f13c6ac: import java.net.URL;
1:f13c6ac: import java.util.ArrayList;
1:3b2c33b: import java.util.Arrays;
1:3b2c33b: import java.util.HashSet;
1:f13c6ac: import java.util.List;
1:3b2c33b: import java.util.Set;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
1:6414875: import org.apache.aries.blueprint.ParserContext;
1:be8e9c5: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
1:be8e9c5: import org.apache.aries.blueprint.ext.PropertyPlaceholder;
1:f520fd5: import org.apache.aries.blueprint.ext.evaluator.PropertyEvaluator;
1:6414875: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableCollectionMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableComponentMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableIdRefMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableRefMetadata;
1:e104a3b: import org.apache.aries.blueprint.mutable.MutableReferenceMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableServiceReferenceMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableValueMetadata;
1:b13e703: import org.osgi.framework.BundleContext;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanProperty;
1:f13c6ac: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RefMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1:e104a3b: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ValueMetadata;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:f13c6ac: import org.w3c.dom.Attr;
1:f13c6ac: import org.w3c.dom.CharacterData;
1:f13c6ac: import org.w3c.dom.Comment;
1:f13c6ac: import org.w3c.dom.Element;
1:f13c6ac: import org.w3c.dom.EntityReference;
1:f13c6ac: import org.w3c.dom.Node;
1:f13c6ac: import org.w3c.dom.NodeList;
1:f13c6ac: 
1:f13c6ac: /**
1:6414875:  * A namespace handler for Aries blueprint extensions
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:6414875: public class ExtNamespaceHandler implements org.apache.aries.blueprint.NamespaceHandler {
1:f13c6ac: 
1:f13c6ac:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:e104a3b:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1:e104a3b:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.1.0";
1:b13e703:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.2.0";
1:d46274e:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_3 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.3.0";
1:ae7707a:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_4 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.4.0";
1:5d334d7:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_5 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.5.0";
1:d46274e: 
1:f13c6ac:     public static final String PROPERTY_PLACEHOLDER_ELEMENT = "property-placeholder";
1:f13c6ac:     public static final String DEFAULT_PROPERTIES_ELEMENT = "default-properties";
1:f13c6ac:     public static final String PROPERTY_ELEMENT = "property";
1:f13c6ac:     public static final String VALUE_ELEMENT = "value";
1:f13c6ac:     public static final String LOCATION_ELEMENT = "location";
1:f13c6ac: 
1:f13c6ac:     public static final String ID_ATTRIBUTE = "id";
1:f13c6ac:     public static final String PLACEHOLDER_PREFIX_ATTRIBUTE = "placeholder-prefix";
1:f13c6ac:     public static final String PLACEHOLDER_SUFFIX_ATTRIBUTE = "placeholder-suffix";
1:f13c6ac:     public static final String DEFAULTS_REF_ATTRIBUTE = "defaults-ref";
1:f13c6ac:     public static final String IGNORE_MISSING_LOCATIONS_ATTRIBUTE = "ignore-missing-locations";
1:b13e703:     public static final String EVALUATOR_ATTRIBUTE = "evaluator";
1:f13c6ac: 
1:f13c6ac:     public static final String SYSTEM_PROPERTIES_ATTRIBUTE = "system-properties";
1:f13c6ac:     public static final String SYSTEM_PROPERTIES_NEVER = "never";
1:f13c6ac:     public static final String SYSTEM_PROPERTIES_FALLBACK = "fallback";
1:f13c6ac:     public static final String SYSTEM_PROPERTIES_OVERRIDE = "override";
1:f13c6ac: 
1:f13c6ac:     public static final String PROXY_METHOD_ATTRIBUTE = "proxy-method";
1:f13c6ac:     public static final String PROXY_METHOD_DEFAULT = "default";
1:f13c6ac:     public static final String PROXY_METHOD_CLASSES = "classes";
1:f13c6ac:     public static final String PROXY_METHOD_GREEDY = "greedy";
1:f13c6ac: 
1:f13c6ac:     public static final String ROLE_ATTRIBUTE = "role";
1:f13c6ac:     public static final String ROLE_PROCESSOR = "processor";
1:f13c6ac:     
1:d08aba3:     public static final String FIELD_INJECTION_ATTRIBUTE = "field-injection";
1:f13c6ac:     
1:e104a3b:     public static final String DEFAULT_REFERENCE_BEAN = "default";
1:f13c6ac: 
1:d46274e:     public static final String FILTER_ATTRIBUTE = "filter";
1:ae7707a:     
1:ae7707a:     public static final String ADDITIONAL_INTERFACES = "additional-interfaces";
1:ae8562c:     public static final String INTERFACE_VALUE = "value";
1:5d334d7:     
1:5d334d7:     public static final String BEAN = "bean";
1:5d334d7:     public static final String REFERENCE = "reference";
1:5d334d7:     
1:d46274e: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(ExtNamespaceHandler.class);
1:f13c6ac: 
1:f13c6ac:     private int idCounter;
1:f13c6ac:     
1:b13e703:     private BundleContext ctx;
1:b13e703: 
1:b13e703:     public void setBundleContext(BundleContext bc) {
1:b13e703:       this.ctx = bc;
1:b13e703:     }
1:b13e703:     
1:f13c6ac:     public URL getSchemaLocation(String namespace) {
1:e104a3b:         if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(namespace)) {
1:f13c6ac:           return getClass().getResource("blueprint-ext.xsd");
1:e104a3b:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_1.equals(namespace)) {
1:e104a3b:           return getClass().getResource("blueprint-ext-1.1.xsd");
1:b13e703:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_2.equals(namespace)) {
1:b13e703:           return getClass().getResource("blueprint-ext-1.2.xsd");
1:d46274e:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_3.equals(namespace)) {
1:d46274e:             return getClass().getResource("blueprint-ext-1.3.xsd");
1:ae7707a:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_4.equals(namespace)) {
1:ae7707a:             return getClass().getResource("blueprint-ext-1.4.xsd");
1:5d334d7:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_5.equals(namespace)) {
1:5d334d7:             return getClass().getResource("blueprint-ext-1.5.xsd");
1:e62407d:         } else if ("http://www.w3.org/XML/1998/namespace".equals(namespace)) {
1:e62407d:             return getClass().getResource("xml.xsd");
1:f13c6ac:         }
1:e62407d:         return null;
1:e104a3b:     }
1:ae7707a:     public boolean isExtNamespace(String e) {
1:ae7707a:         return BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e)
1:ae7707a:             || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e)
1:ae7707a:             || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e)
1:ae7707a:             || BLUEPRINT_EXT_NAMESPACE_V1_3.equals(e)
1:5d334d7:             || BLUEPRINT_EXT_NAMESPACE_V1_4.equals(e)
1:5d334d7:             || BLUEPRINT_EXT_NAMESPACE_V1_5.equals(e);            
1:ae7707a:     }
1:f13c6ac: 
1:3b2c33b:     public Set<Class> getManagedClasses() {
1:3b2c33b:         return new HashSet<Class>(Arrays.asList(
1:3b2c33b:                 PropertyPlaceholder.class
1:3b2c33b:         ));
1:3b2c33b:     }
1:3b2c33b: 
1:f13c6ac:     public Metadata parse(Element element, ParserContext context) {
1:f13c6ac:         LOGGER.debug("Parsing element {{}}{}", element.getNamespaceURI(), element.getLocalName());
1:f13c6ac:         if (nodeNameEquals(element, PROPERTY_PLACEHOLDER_ELEMENT)) {
1:f13c6ac:             return parsePropertyPlaceholder(context, element);
1:5d334d7:         } else if (nodeNameEquals(element, BEAN)) {
1:5d334d7:             return context.parseElement(BeanMetadata.class, context.getEnclosingComponent(), element);
1:5d334d7:         } else if (nodeNameEquals(element, REFERENCE)) {
1:5d334d7:             RefMetadata rd = context.parseElement(RefMetadata.class, context.getEnclosingComponent(), element);
1:5d334d7:             return createReference(context, rd.getComponentId());
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Unsupported element: " + element.getNodeName());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:f13c6ac:         if (node instanceof Attr && nodeNameEquals(node, PROXY_METHOD_ATTRIBUTE)) {
1:f13c6ac:             return decorateProxyMethod(node, component, context);
1:f13c6ac:         } else if (node instanceof Attr && nodeNameEquals(node, ROLE_ATTRIBUTE)) {
1:f13c6ac:             return decorateRole(node, component, context);
1:d08aba3:         } else if (node instanceof Attr && nodeNameEquals(node, FIELD_INJECTION_ATTRIBUTE)) {
1:d08aba3:             return decorateFieldInjection(node, component, context);
1:e104a3b:         } else if (node instanceof Attr && nodeNameEquals(node, DEFAULT_REFERENCE_BEAN)) {
1:e104a3b:             return decorateDefaultBean(node, component, context);
1:d46274e:         } else if (node instanceof Attr && nodeNameEquals(node, FILTER_ATTRIBUTE)) {
1:d46274e:             return decorateFilter(node, component, context);
1:ae7707a:         } else if (node instanceof Element && nodeNameEquals(node, ADDITIONAL_INTERFACES)) {
1:ae7707a:             return decorateAdditionalInterfaces(node, component, context);
1:5d334d7:         } else if (node instanceof Element && nodeNameEquals(node, BEAN)) {
1:5d334d7:             return context.parseElement(BeanMetadata.class, component, (Element)node);
1:5d334d7:         } else if (node instanceof Element && nodeNameEquals(node, REFERENCE)) {
1:5d334d7:             RefMetadata rd = context.parseElement(RefMetadata.class, component, (Element)node);
1:5d334d7:             return createReference(context, rd.getComponentId());
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("Unsupported node: " + node.getNodeName());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac:     
1:ae7707a:     private ComponentMetadata decorateAdditionalInterfaces(Node node, ComponentMetadata component,
1:ae7707a:                                                            ParserContext context) {
1:ae7707a:         if (!(component instanceof MutableReferenceMetadata)) {
1:ae7707a:             throw new ComponentDefinitionException("Expected an instanceof MutableReferenceMetadata");
1:ae7707a:         }
1:ae7707a:         MutableReferenceMetadata mrm = (MutableReferenceMetadata)component;
1:ae7707a:         List<String> list = new ArrayList<String>();
1:ae7707a:         Node nd = node.getFirstChild();
1:ae7707a:         while (nd != null) {
1:ada9585:             if (nd instanceof Element && nodeNameEquals(nd, INTERFACE_VALUE)) {
1:ada9585:                 list.add(((Element)nd).getTextContent());
1:ae7707a:             }
1:ae7707a:             nd = nd.getNextSibling();
1:ae7707a:         }
1:ae7707a:         mrm.setExtraInterfaces(list);
1:ae7707a:         return component;
1:ae7707a:     }
1:ae7707a: 
1:e104a3b:     private ComponentMetadata decorateDefaultBean(Node node,
1:e104a3b:         ComponentMetadata component, ParserContext context) 
1:e104a3b:     {
1:e104a3b:         if (!(component instanceof ReferenceMetadata)) {
1:e104a3b:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> element");
1:e104a3b:         }
1:b13e703:       
1:e104a3b:         if (!(component instanceof MutableReferenceMetadata)) {
1:e104a3b:             throw new ComponentDefinitionException("Expected an instanceof MutableReferenceMetadata");
1:e104a3b:         }
1:b13e703:         
1:e104a3b:         String value = ((Attr) node).getValue();
1:e104a3b:         ((MutableReferenceMetadata) component).setDefaultBean(value);
1:e104a3b:         return component;
1:e104a3b:     }
1:e104a3b: 
1:d08aba3:     private ComponentMetadata decorateFieldInjection(Node node, ComponentMetadata component, ParserContext context) {
1:d08aba3:         if (!(component instanceof BeanMetadata)) {
1:d08aba3:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:d08aba3:         }
1:e104a3b:         
1:d08aba3:         if (!(component instanceof MutableBeanMetadata)) {
1:d08aba3:             throw new ComponentDefinitionException("Expected an instanceof MutableBeanMetadata");
1:d08aba3:         }
1:e104a3b:         
1:d08aba3:         String value = ((Attr) node).getValue();
1:d08aba3:         ((MutableBeanMetadata) component).setFieldInjection("true".equals(value) || "1".equals(value));
1:d08aba3:         return component;
1:d08aba3:     }
1:e104a3b: 
1:f13c6ac:     private ComponentMetadata decorateRole(Node node, ComponentMetadata component, ParserContext context) {
1:f13c6ac:         if (!(component instanceof BeanMetadata)) {
1:f13c6ac:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:f13c6ac:         }
1:f13c6ac:         if (!(component instanceof MutableBeanMetadata)) {
1:f13c6ac:             throw new ComponentDefinitionException("Expected an instance of MutableBeanMetadata");
1:f13c6ac:         }
1:f13c6ac:         boolean processor = false;
1:f13c6ac:         String value = ((Attr) node).getValue();
1:f13c6ac:         String[] flags = value.trim().split(" ");
1:f13c6ac:         for (String flag : flags) {
1:f13c6ac:             if (ROLE_PROCESSOR.equals(flag)) {
1:f13c6ac:                 processor = true;
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         ((MutableBeanMetadata) component).setProcessor(processor);
1:f13c6ac:         return component;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private ComponentMetadata decorateProxyMethod(Node node, ComponentMetadata component, ParserContext context) {
1:f13c6ac:         if (!(component instanceof ServiceReferenceMetadata)) {
1:29a5ea1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> or <reference-list> element");
1:f13c6ac:         }
1:f13c6ac:         if (!(component instanceof MutableServiceReferenceMetadata)) {
1:f13c6ac:             throw new ComponentDefinitionException("Expected an instance of MutableServiceReferenceMetadata");
1:f13c6ac:         }
1:f13c6ac:         int method = 0;
1:f13c6ac:         String value = ((Attr) node).getValue();
1:f13c6ac:         String[] flags = value.trim().split(" ");
1:f13c6ac:         for (String flag : flags) {
1:f13c6ac:             if (PROXY_METHOD_DEFAULT.equals(flag)) {
1:f13c6ac:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_DEFAULT;
1:f13c6ac:             } else if (PROXY_METHOD_CLASSES.equals(flag)) {
1:f13c6ac:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_CLASSES;
1:f13c6ac:             } else if (PROXY_METHOD_GREEDY.equals(flag)) {
1:f13c6ac:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY;
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if ((method & ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY) != 0 && !(component instanceof ReferenceListMetadata)) {
1:29a5ea1:             throw new ComponentDefinitionException("Greedy proxying is only available for <reference-list> element");
1:f13c6ac:         }
1:f13c6ac:         ((MutableServiceReferenceMetadata) component).setProxyMethod(method);
1:f13c6ac:         return component;
1:f13c6ac:     }
1:f13c6ac: 
1:d46274e:     private ComponentMetadata decorateFilter(Node node,
1:d46274e:                                              ComponentMetadata component, ParserContext context)
1:d46274e:     {
1:d46274e:         if (!(component instanceof ServiceReferenceMetadata)) {
1:d46274e:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> or <reference-list> element");
1:d46274e:         }
1:d46274e: 
1:d46274e:         if (!(component instanceof MutableServiceReferenceMetadata)) {
1:d46274e:             throw new ComponentDefinitionException("Expected an instanceof MutableServiceReferenceMetadata");
1:d46274e:         }
1:d46274e: 
1:d46274e:         String value = ((Attr) node).getValue();
1:d46274e:         ((MutableServiceReferenceMetadata) component).setExtendedFilter(createValue(context, value));
1:d46274e:         return component;
1:d46274e:     }
1:d46274e: 
1:f13c6ac:     private Metadata parsePropertyPlaceholder(ParserContext context, Element element) {
1:f13c6ac:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:f13c6ac:         metadata.setProcessor(true);
1:f13c6ac:         metadata.setId(getId(context, element));
1:f13c6ac:         metadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:f13c6ac:         metadata.setRuntimeClass(PropertyPlaceholder.class);
1:f13c6ac:         metadata.setInitMethod("init");
1:f13c6ac:         String prefix = element.hasAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:f13c6ac:                                     ? element.getAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:f13c6ac:                                     : "${";
1:f13c6ac:         metadata.addProperty("placeholderPrefix", createValue(context, prefix));
1:f13c6ac:         String suffix = element.hasAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:f13c6ac:                                     ? element.getAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:f13c6ac:                                     : "}";
1:f13c6ac:         metadata.addProperty("placeholderSuffix", createValue(context, suffix));
1:f13c6ac:         String defaultsRef = element.hasAttribute(DEFAULTS_REF_ATTRIBUTE) ? element.getAttribute(DEFAULTS_REF_ATTRIBUTE) : null;
1:f13c6ac:         if (defaultsRef != null) {
1:f13c6ac:             metadata.addProperty("defaultProperties", createRef(context, defaultsRef));
1:f13c6ac:         }
1:f13c6ac:         String ignoreMissingLocations = element.hasAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) ? element.getAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) : null;
1:f13c6ac:         if (ignoreMissingLocations != null) {
1:f13c6ac:             metadata.addProperty("ignoreMissingLocations", createValue(context, ignoreMissingLocations));
1:f13c6ac:         }
1:f13c6ac:         String systemProperties = element.hasAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) ? element.getAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) : null;
1:f13c6ac:         if (systemProperties != null) {
1:f13c6ac:             metadata.addProperty("systemProperties", createValue(context, systemProperties));
1:f13c6ac:         }
1:b13e703:         String evaluator = element.hasAttribute(EVALUATOR_ATTRIBUTE) ? element.getAttribute(EVALUATOR_ATTRIBUTE) : null;
1:b13e703:         if (evaluator != null) {
1:b13e703:             metadata.addProperty("evaluator", createReference(context, evaluator));
1:b13e703:         }
1:f13c6ac:         // Parse elements
1:f13c6ac:         List<String> locations = new ArrayList<String>();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:ae7707a:                 if (isExtNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, DEFAULT_PROPERTIES_ELEMENT)) {
1:f13c6ac:                         if (defaultsRef != null) {
1:f13c6ac:                             throw new ComponentDefinitionException("Only one of " + DEFAULTS_REF_ATTRIBUTE + " attribute or " + DEFAULT_PROPERTIES_ELEMENT + " element is allowed");
1:f13c6ac:                         }
1:f13c6ac:                         Metadata props = parseDefaultProperties(context, metadata, e);
1:f13c6ac:                         metadata.addProperty("defaultProperties", props);
1:f13c6ac:                     } else if (nodeNameEquals(e, LOCATION_ELEMENT)) {
1:f13c6ac:                         locations.add(getTextValue(e));
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         if (!locations.isEmpty()) {
1:f13c6ac:             metadata.addProperty("locations", createList(context, locations));
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         PlaceholdersUtils.validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1:f13c6ac: 
1:f13c6ac:         return metadata;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Metadata parseDefaultProperties(ParserContext context, MutableBeanMetadata enclosingComponent, Element element) {
1:f13c6ac:         MutableMapMetadata props = context.createMetadata(MutableMapMetadata.class);
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node node = nl.item(i);
1:f13c6ac:             if (node instanceof Element) {
1:f13c6ac:                 Element e = (Element) node;
1:ae7707a:                 if (isExtNamespace(e.getNamespaceURI())) {
1:f13c6ac:                     if (nodeNameEquals(e, PROPERTY_ELEMENT)) {
1:f13c6ac:                         BeanProperty prop = context.parseElement(BeanProperty.class, enclosingComponent, e);
1:f13c6ac:                         props.addEntry(createValue(context, prop.getName(), String.class.getName()), prop.getValue());
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return props;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public String getId(ParserContext context, Element element) {
1:f13c6ac:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:f13c6ac:             return element.getAttribute(ID_ATTRIBUTE);
1:f13c6ac:         } else {
1:f13c6ac:             return generateId(context);
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void generateIdIfNeeded(ParserContext context, MutableComponentMetadata metadata) {
1:f13c6ac:         if (metadata.getId() == null) {
1:f13c6ac:             metadata.setId(generateId(context));
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private String generateId(ParserContext context) {
1:f13c6ac:         String id;
1:f13c6ac:         do {
1:f13c6ac:             id = ".ext-" + ++idCounter;
1:f13c6ac:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:f13c6ac:         return id;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static ValueMetadata createValue(ParserContext context, String value) {
1:f13c6ac:         return createValue(context, value, null);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static ValueMetadata createValue(ParserContext context, String value, String type) {
1:f13c6ac:         MutableValueMetadata m = context.createMetadata(MutableValueMetadata.class);
1:f13c6ac:         m.setStringValue(value);
1:f13c6ac:         m.setType(type);
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static RefMetadata createRef(ParserContext context, String value) {
1:f13c6ac:         MutableRefMetadata m = context.createMetadata(MutableRefMetadata.class);
1:f13c6ac:         m.setComponentId(value);
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static IdRefMetadata createIdRef(ParserContext context, String value) {
1:f13c6ac:         MutableIdRefMetadata m = context.createMetadata(MutableIdRefMetadata.class);
1:f13c6ac:         m.setComponentId(value);
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac:     
1:b13e703:     private MutableReferenceMetadata createReference(ParserContext context, String value) {
1:b13e703:         MutableReferenceMetadata m = context.createMetadata(MutableReferenceMetadata.class);
1:b13e703:         // use the class instance directly rather than loading the class from the specified the interface name.
1:b13e703:         m.setRuntimeInterface(PropertyEvaluator.class);
1:b13e703:         m.setFilter("(org.apache.aries.blueprint.ext.evaluator.name=" + value + ")");
1:b13e703:         m.setBundleContext(ctx);
1:b13e703:         return m;
1:b13e703:     }
1:d08aba3: 
1:f13c6ac:     private static CollectionMetadata createList(ParserContext context, List<String> list) {
1:f13c6ac:         MutableCollectionMetadata m = context.createMetadata(MutableCollectionMetadata.class);
1:f13c6ac:         m.setCollectionClass(List.class);
1:f13c6ac:         m.setValueType(String.class.getName());
1:f13c6ac:         for (String v : list) {
1:f13c6ac:             m.addValue(createValue(context, v, String.class.getName()));
1:f13c6ac:         }
1:f13c6ac:         return m;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static String getTextValue(Element element) {
1:f13c6ac:         StringBuffer value = new StringBuffer();
1:f13c6ac:         NodeList nl = element.getChildNodes();
1:f13c6ac:         for (int i = 0; i < nl.getLength(); i++) {
1:f13c6ac:             Node item = nl.item(i);
1:f13c6ac:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:f13c6ac:                 value.append(item.getNodeValue());
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return value.toString();
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static boolean nodeNameEquals(Node node, String name) {
1:f13c6ac:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public static boolean isBlueprintNamespace(String ns) {
1:f13c6ac:         return BLUEPRINT_NAMESPACE.equals(ns);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: }
============================================================================
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:5d334d7
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_5 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.5.0";
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static final String BEAN = "bean";
1:     public static final String REFERENCE = "reference";
1:     
/////////////////////////////////////////////////////////////////////////
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_5.equals(namespace)) {
1:             return getClass().getResource("blueprint-ext-1.5.xsd");
/////////////////////////////////////////////////////////////////////////
1:             || BLUEPRINT_EXT_NAMESPACE_V1_4.equals(e)
1:             || BLUEPRINT_EXT_NAMESPACE_V1_5.equals(e);            
/////////////////////////////////////////////////////////////////////////
1:         } else if (nodeNameEquals(element, BEAN)) {
1:             return context.parseElement(BeanMetadata.class, context.getEnclosingComponent(), element);
1:         } else if (nodeNameEquals(element, REFERENCE)) {
1:             RefMetadata rd = context.parseElement(RefMetadata.class, context.getEnclosingComponent(), element);
1:             return createReference(context, rd.getComponentId());
/////////////////////////////////////////////////////////////////////////
1:         } else if (node instanceof Element && nodeNameEquals(node, BEAN)) {
1:             return context.parseElement(BeanMetadata.class, component, (Element)node);
1:         } else if (node instanceof Element && nodeNameEquals(node, REFERENCE)) {
1:             RefMetadata rd = context.parseElement(RefMetadata.class, component, (Element)node);
1:             return createReference(context, rd.getComponentId());
commit:ada9585
/////////////////////////////////////////////////////////////////////////
1:             if (nd instanceof Element && nodeNameEquals(nd, INTERFACE_VALUE)) {
1:                 list.add(((Element)nd).getTextContent());
commit:ae8562c
/////////////////////////////////////////////////////////////////////////
1:     public static final String INTERFACE_VALUE = "value";
/////////////////////////////////////////////////////////////////////////
0:             if (node instanceof Element && nodeNameEquals(node, INTERFACE_VALUE)) {
commit:ae7707a
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_4 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.4.0";
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static final String ADDITIONAL_INTERFACES = "additional-interfaces";
0:     public static final String INTERFACE = "interface";
/////////////////////////////////////////////////////////////////////////
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_4.equals(namespace)) {
1:             return getClass().getResource("blueprint-ext-1.4.xsd");
1:     public boolean isExtNamespace(String e) {
1:         return BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e)
1:             || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e)
1:             || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e)
1:             || BLUEPRINT_EXT_NAMESPACE_V1_3.equals(e)
0:             || BLUEPRINT_EXT_NAMESPACE_V1_4.equals(e);            
1:     }
/////////////////////////////////////////////////////////////////////////
1:         } else if (node instanceof Element && nodeNameEquals(node, ADDITIONAL_INTERFACES)) {
1:             return decorateAdditionalInterfaces(node, component, context);
1:     private ComponentMetadata decorateAdditionalInterfaces(Node node, ComponentMetadata component,
1:                                                            ParserContext context) {
1:         if (!(component instanceof MutableReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instanceof MutableReferenceMetadata");
1:         }
1:         MutableReferenceMetadata mrm = (MutableReferenceMetadata)component;
1:         List<String> list = new ArrayList<String>();
1:         Node nd = node.getFirstChild();
1:         while (nd != null) {
0:             if (node instanceof Element && nodeNameEquals(node, INTERFACE)) {
0:                 list.add(((Element)nd).getNodeValue());
1:             }
1:             nd = nd.getNextSibling();
1:         }
1:         mrm.setExtraInterfaces(list);
1:         return component;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (isExtNamespace(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:                 if (isExtNamespace(e.getNamespaceURI())) {
commit:e62407d
/////////////////////////////////////////////////////////////////////////
1:         } else if ("http://www.w3.org/XML/1998/namespace".equals(namespace)) {
1:             return getClass().getResource("xml.xsd");
1:         return null;
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_3 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.3.0";
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static final String FILTER_ATTRIBUTE = "filter";
1: 
/////////////////////////////////////////////////////////////////////////
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_3.equals(namespace)) {
1:             return getClass().getResource("blueprint-ext-1.3.xsd");
/////////////////////////////////////////////////////////////////////////
1:         } else if (node instanceof Attr && nodeNameEquals(node, FILTER_ATTRIBUTE)) {
1:             return decorateFilter(node, component, context);
/////////////////////////////////////////////////////////////////////////
1:     private ComponentMetadata decorateFilter(Node node,
1:                                              ComponentMetadata component, ParserContext context)
1:     {
1:         if (!(component instanceof ServiceReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> or <reference-list> element");
1:         }
1: 
1:         if (!(component instanceof MutableServiceReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instanceof MutableServiceReferenceMetadata");
1:         }
1: 
1:         String value = ((Attr) node).getValue();
1:         ((MutableServiceReferenceMetadata) component).setExtendedFilter(createValue(context, value));
1:         return component;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_3.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_3.equals(e.getNamespaceURI())) {
commit:be8e9c5
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.ext.impl;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ext.PlaceholdersUtils;
1: import org.apache.aries.blueprint.ext.PropertyPlaceholder;
/////////////////////////////////////////////////////////////////////////
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     public Set<Class> getManagedClasses() {
1:         return new HashSet<Class>(Arrays.asList(
1:                 PropertyPlaceholder.class
1:         ));
1:     }
1: 
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.ext;
1: 
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: import org.w3c.dom.Attr;
1: import org.w3c.dom.CharacterData;
1: import org.w3c.dom.Comment;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.EntityReference;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1: 
0: import org.apache.geronimo.blueprint.ExtendedReferenceListMetadata;
0: import org.apache.geronimo.blueprint.ParserContext;
0: import org.apache.geronimo.blueprint.mutable.MutableBeanMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableCollectionMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableComponentMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableIdRefMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableMapMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableRefMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableServiceReferenceMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableValueMetadata;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.IdRefMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1: import org.osgi.service.blueprint.reflect.RefMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.ValueMetadata;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
0:  * A namespace handler for geronimo blueprint extensions
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 766508 $, $Date: 2009-04-19 22:09:27 +0200 (Sun, 19 Apr 2009) $
1:  */
0: public class ExtNamespaceHandler implements org.apache.geronimo.blueprint.NamespaceHandler {
1: 
1:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
0:     public static final String BLUEPRINT_EXT_NAMESPACE = "http://geronimo.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1: 
1:     public static final String PROPERTY_PLACEHOLDER_ELEMENT = "property-placeholder";
1:     public static final String DEFAULT_PROPERTIES_ELEMENT = "default-properties";
1:     public static final String PROPERTY_ELEMENT = "property";
1:     public static final String VALUE_ELEMENT = "value";
1:     public static final String LOCATION_ELEMENT = "location";
1: 
1:     public static final String ID_ATTRIBUTE = "id";
1:     public static final String PLACEHOLDER_PREFIX_ATTRIBUTE = "placeholder-prefix";
1:     public static final String PLACEHOLDER_SUFFIX_ATTRIBUTE = "placeholder-suffix";
1:     public static final String DEFAULTS_REF_ATTRIBUTE = "defaults-ref";
1:     public static final String IGNORE_MISSING_LOCATIONS_ATTRIBUTE = "ignore-missing-locations";
1: 
1:     public static final String SYSTEM_PROPERTIES_ATTRIBUTE = "system-properties";
1:     public static final String SYSTEM_PROPERTIES_NEVER = "never";
1:     public static final String SYSTEM_PROPERTIES_FALLBACK = "fallback";
1:     public static final String SYSTEM_PROPERTIES_OVERRIDE = "override";
1: 
1:     public static final String PROXY_METHOD_ATTRIBUTE = "proxy-method";
1:     public static final String PROXY_METHOD_DEFAULT = "default";
1:     public static final String PROXY_METHOD_CLASSES = "classes";
1:     public static final String PROXY_METHOD_GREEDY = "greedy";
1: 
1:     public static final String ROLE_ATTRIBUTE = "role";
1:     public static final String ROLE_PROCESSOR = "processor";
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(ExtNamespaceHandler.class);
1: 
1:     private int idCounter;
1: 
1:     public URL getSchemaLocation(String namespace) {
1:         return getClass().getResource("blueprint-ext.xsd");
1:     }
1: 
1:     public Metadata parse(Element element, ParserContext context) {
1:         LOGGER.debug("Parsing element {{}}{}", element.getNamespaceURI(), element.getLocalName());
1:         if (nodeNameEquals(element, PROPERTY_PLACEHOLDER_ELEMENT)) {
1:             return parsePropertyPlaceholder(context, element);
1:         } else {
1:             throw new ComponentDefinitionException("Unsupported element: " + element.getNodeName());
1:         }
1:     }
1: 
1:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:         if (node instanceof Attr && nodeNameEquals(node, PROXY_METHOD_ATTRIBUTE)) {
1:             return decorateProxyMethod(node, component, context);
1:         } else if (node instanceof Attr && nodeNameEquals(node, ROLE_ATTRIBUTE)) {
1:             return decorateRole(node, component, context);
1:         } else {
1:             throw new ComponentDefinitionException("Unsupported node: " + node.getNodeName());
1:         }
1:     }
1: 
1:     private ComponentMetadata decorateRole(Node node, ComponentMetadata component, ParserContext context) {
1:         if (!(component instanceof BeanMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:         }
1:         if (!(component instanceof MutableBeanMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instance of MutableBeanMetadata");
1:         }
1:         boolean processor = false;
1:         String value = ((Attr) node).getValue();
1:         String[] flags = value.trim().split(" ");
1:         for (String flag : flags) {
1:             if (ROLE_PROCESSOR.equals(flag)) {
1:                 processor = true;
1:             } else {
1:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:             }
1:         }
1:         ((MutableBeanMetadata) component).setProcessor(processor);
1:         return component;
1:     }
1: 
1:     private ComponentMetadata decorateProxyMethod(Node node, ComponentMetadata component, ParserContext context) {
1:         if (!(component instanceof ServiceReferenceMetadata)) {
0:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference>, <ref-list> or <ref-set> element");
1:         }
1:         if (!(component instanceof MutableServiceReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instance of MutableServiceReferenceMetadata");
1:         }
1:         int method = 0;
1:         String value = ((Attr) node).getValue();
1:         String[] flags = value.trim().split(" ");
1:         for (String flag : flags) {
1:             if (PROXY_METHOD_DEFAULT.equals(flag)) {
1:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_DEFAULT;
1:             } else if (PROXY_METHOD_CLASSES.equals(flag)) {
1:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_CLASSES;
1:             } else if (PROXY_METHOD_GREEDY.equals(flag)) {
1:                 method += ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY;
1:             } else {
1:                 throw new ComponentDefinitionException("Unknown proxy method: " + flag);
1:             }
1:         }
1:         if ((method & ExtendedReferenceListMetadata.PROXY_METHOD_GREEDY) != 0 && !(component instanceof ReferenceListMetadata)) {
0:             throw new ComponentDefinitionException("Greedy proxying is only available for <ref-list> and <ref-set> elements");
1:         }
1:         ((MutableServiceReferenceMetadata) component).setProxyMethod(method);
1:         return component;
1:     }
1: 
1:     private Metadata parsePropertyPlaceholder(ParserContext context, Element element) {
1:         MutableBeanMetadata metadata = context.createMetadata(MutableBeanMetadata.class);
1:         metadata.setProcessor(true);
1:         metadata.setId(getId(context, element));
1:         metadata.setScope(BeanMetadata.SCOPE_SINGLETON);
1:         metadata.setRuntimeClass(PropertyPlaceholder.class);
1:         metadata.setInitMethod("init");
1:         String prefix = element.hasAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:                                     ? element.getAttribute(PLACEHOLDER_PREFIX_ATTRIBUTE)
1:                                     : "${";
1:         metadata.addProperty("placeholderPrefix", createValue(context, prefix));
1:         String suffix = element.hasAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:                                     ? element.getAttribute(PLACEHOLDER_SUFFIX_ATTRIBUTE)
1:                                     : "}";
1:         metadata.addProperty("placeholderSuffix", createValue(context, suffix));
1:         String defaultsRef = element.hasAttribute(DEFAULTS_REF_ATTRIBUTE) ? element.getAttribute(DEFAULTS_REF_ATTRIBUTE) : null;
1:         if (defaultsRef != null) {
1:             metadata.addProperty("defaultProperties", createRef(context, defaultsRef));
1:         }
1:         String ignoreMissingLocations = element.hasAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) ? element.getAttribute(IGNORE_MISSING_LOCATIONS_ATTRIBUTE) : null;
1:         if (ignoreMissingLocations != null) {
1:             metadata.addProperty("ignoreMissingLocations", createValue(context, ignoreMissingLocations));
1:         }
1:         String systemProperties = element.hasAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) ? element.getAttribute(SYSTEM_PROPERTIES_ATTRIBUTE) : null;
1:         if (systemProperties != null) {
1:             metadata.addProperty("systemProperties", createValue(context, systemProperties));
1:         }
1:         // Parse elements
1:         List<String> locations = new ArrayList<String>();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
0:                 if (BLUEPRINT_EXT_NAMESPACE.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, DEFAULT_PROPERTIES_ELEMENT)) {
1:                         if (defaultsRef != null) {
1:                             throw new ComponentDefinitionException("Only one of " + DEFAULTS_REF_ATTRIBUTE + " attribute or " + DEFAULT_PROPERTIES_ELEMENT + " element is allowed");
1:                         }
1:                         Metadata props = parseDefaultProperties(context, metadata, e);
1:                         metadata.addProperty("defaultProperties", props);
1:                     } else if (nodeNameEquals(e, LOCATION_ELEMENT)) {
1:                         locations.add(getTextValue(e));
1:                     }
1:                 }
1:             }
1:         }
1:         if (!locations.isEmpty()) {
1:             metadata.addProperty("locations", createList(context, locations));
1:         }
1: 
1:         PlaceholdersUtils.validatePlaceholder(metadata, context.getComponentDefinitionRegistry());
1: 
1:         return metadata;
1:     }
1: 
1:     private Metadata parseDefaultProperties(ParserContext context, MutableBeanMetadata enclosingComponent, Element element) {
1:         MutableMapMetadata props = context.createMetadata(MutableMapMetadata.class);
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node node = nl.item(i);
1:             if (node instanceof Element) {
1:                 Element e = (Element) node;
0:                 if (BLUEPRINT_EXT_NAMESPACE.equals(e.getNamespaceURI())) {
1:                     if (nodeNameEquals(e, PROPERTY_ELEMENT)) {
1:                         BeanProperty prop = context.parseElement(BeanProperty.class, enclosingComponent, e);
1:                         props.addEntry(createValue(context, prop.getName(), String.class.getName()), prop.getValue());
1:                     }
1:                 }
1:             }
1:         }
1:         return props;
1:     }
1: 
1:     public String getId(ParserContext context, Element element) {
1:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:             return element.getAttribute(ID_ATTRIBUTE);
1:         } else {
1:             return generateId(context);
1:         }
1:     }
1: 
1:     public void generateIdIfNeeded(ParserContext context, MutableComponentMetadata metadata) {
1:         if (metadata.getId() == null) {
1:             metadata.setId(generateId(context));
1:         }
1:     }
1: 
1:     private String generateId(ParserContext context) {
1:         String id;
1:         do {
1:             id = ".ext-" + ++idCounter;
1:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:         return id;
1:     }
1: 
1:     private static ValueMetadata createValue(ParserContext context, String value) {
1:         return createValue(context, value, null);
1:     }
1: 
1:     private static ValueMetadata createValue(ParserContext context, String value, String type) {
1:         MutableValueMetadata m = context.createMetadata(MutableValueMetadata.class);
1:         m.setStringValue(value);
1:         m.setType(type);
1:         return m;
1:     }
1: 
1:     private static RefMetadata createRef(ParserContext context, String value) {
1:         MutableRefMetadata m = context.createMetadata(MutableRefMetadata.class);
1:         m.setComponentId(value);
1:         return m;
1:     }
1: 
1:     private static IdRefMetadata createIdRef(ParserContext context, String value) {
1:         MutableIdRefMetadata m = context.createMetadata(MutableIdRefMetadata.class);
1:         m.setComponentId(value);
1:         return m;
1:     }
1: 
1:     private static CollectionMetadata createList(ParserContext context, List<String> list) {
1:         MutableCollectionMetadata m = context.createMetadata(MutableCollectionMetadata.class);
1:         m.setCollectionClass(List.class);
1:         m.setValueType(String.class.getName());
1:         for (String v : list) {
1:             m.addValue(createValue(context, v, String.class.getName()));
1:         }
1:         return m;
1:     }
1: 
1:     private static String getTextValue(Element element) {
1:         StringBuffer value = new StringBuffer();
1:         NodeList nl = element.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node item = nl.item(i);
1:             if ((item instanceof CharacterData && !(item instanceof Comment)) || item instanceof EntityReference) {
1:                 value.append(item.getNodeValue());
1:             }
1:         }
1:         return value.toString();
1:     }
1: 
1:     private static boolean nodeNameEquals(Node node, String name) {
1:         return (name.equals(node.getNodeName()) || name.equals(node.getLocalName()));
1:     }
1: 
1:     public static boolean isBlueprintNamespace(String ns) {
1:         return BLUEPRINT_NAMESPACE.equals(ns);
1:     }
1: 
1: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:e2445d0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.utils.PlaceholdersUtils;
0: import org.apache.aries.blueprint.utils.PropertyPlaceholder;
commit:f520fd5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ext.evaluator.PropertyEvaluator;
commit:b13e703
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_2 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.2.0";
1:     
/////////////////////////////////////////////////////////////////////////
1:     public static final String EVALUATOR_ATTRIBUTE = "evaluator";
/////////////////////////////////////////////////////////////////////////
1:     
1:     private BundleContext ctx;
1:     public void setBundleContext(BundleContext bc) {
1:       this.ctx = bc;
1:     }
1:     
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_2.equals(namespace)) {
1:           return getClass().getResource("blueprint-ext-1.2.xsd");
/////////////////////////////////////////////////////////////////////////
1:         String evaluator = element.hasAttribute(EVALUATOR_ATTRIBUTE) ? element.getAttribute(EVALUATOR_ATTRIBUTE) : null;
1:         if (evaluator != null) {
1:             metadata.addProperty("evaluator", createReference(context, evaluator));
1:         }
/////////////////////////////////////////////////////////////////////////
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_2.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     private MutableReferenceMetadata createReference(ParserContext context, String value) {
1:         MutableReferenceMetadata m = context.createMetadata(MutableReferenceMetadata.class);
1:         // use the class instance directly rather than loading the class from the specified the interface name.
1:         m.setRuntimeInterface(PropertyEvaluator.class);
1:         m.setFilter("(org.apache.aries.blueprint.ext.evaluator.name=" + value + ")");
1:         m.setBundleContext(ctx);
1:         return m;
1:     }
author:Lei Wang
-------------------------------------------------------------------------------
commit:80af17c
/////////////////////////////////////////////////////////////////////////
0:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
0:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())
0:                         || BLUEPRINT_EXT_NAMESPACE_V1_1.equals(e.getNamespaceURI())) {
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:e104a3b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.mutable.MutableReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_0 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
1:     public static final String BLUEPRINT_EXT_NAMESPACE_V1_1 = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.1.0";
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static final String DEFAULT_REFERENCE_BEAN = "default";
1:         if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(namespace)) {
0:           return getClass().getResource("blueprint-ext.xsd");
1:         } else if (BLUEPRINT_EXT_NAMESPACE_V1_1.equals(namespace)) {
1:           return getClass().getResource("blueprint-ext-1.1.xsd");
0:         } else {
0:           return null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         } else if (node instanceof Attr && nodeNameEquals(node, DEFAULT_REFERENCE_BEAN)) {
1:             return decorateDefaultBean(node, component, context);
1:     private ComponentMetadata decorateDefaultBean(Node node,
1:         ComponentMetadata component, ParserContext context) 
1:     {
1:         if (!(component instanceof ReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> element");
1:         }
1:       
1:         if (!(component instanceof MutableReferenceMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instanceof MutableReferenceMetadata");
1:         }
1:         
1:         String value = ((Attr) node).getValue();
1:         ((MutableReferenceMetadata) component).setDefaultBean(value);
1:         return component;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())) {
/////////////////////////////////////////////////////////////////////////
0:                 if (BLUEPRINT_EXT_NAMESPACE_V1_0.equals(e.getNamespaceURI())) {
author:Lin Sun
-------------------------------------------------------------------------------
commit:29a5ea1
/////////////////////////////////////////////////////////////////////////
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <reference> or <reference-list> element");
/////////////////////////////////////////////////////////////////////////
1:             throw new ComponentDefinitionException("Greedy proxying is only available for <reference-list> element");
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:d08aba3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
0: import org.w3c.dom.Attr;
0: import org.w3c.dom.CharacterData;
0: import org.w3c.dom.Comment;
0: import org.w3c.dom.Element;
0: import org.w3c.dom.EntityReference;
0: import org.w3c.dom.Node;
0: import org.w3c.dom.NodeList;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static final String FIELD_INJECTION_ATTRIBUTE = "field-injection";
/////////////////////////////////////////////////////////////////////////
1:         } else if (node instanceof Attr && nodeNameEquals(node, FIELD_INJECTION_ATTRIBUTE)) {
1:             return decorateFieldInjection(node, component, context);
0:     
1:     private ComponentMetadata decorateFieldInjection(Node node, ComponentMetadata component, ParserContext context) {
1:         if (!(component instanceof BeanMetadata)) {
1:             throw new ComponentDefinitionException("Attribute " + node.getNodeName() + " can only be used on a <bean> element");
1:         }
0:         
1:         if (!(component instanceof MutableBeanMetadata)) {
1:             throw new ComponentDefinitionException("Expected an instanceof MutableBeanMetadata");
1:         }
0:         
1:         String value = ((Attr) node).getValue();
1:         ((MutableBeanMetadata) component).setFieldInjection("true".equals(value) || "1".equals(value));
1:         return component;
1:     }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.blueprint.ext;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ExtendedReferenceListMetadata;
1: import org.apache.aries.blueprint.ParserContext;
1: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1: import org.apache.aries.blueprint.mutable.MutableCollectionMetadata;
1: import org.apache.aries.blueprint.mutable.MutableComponentMetadata;
1: import org.apache.aries.blueprint.mutable.MutableIdRefMetadata;
1: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1: import org.apache.aries.blueprint.mutable.MutableRefMetadata;
1: import org.apache.aries.blueprint.mutable.MutableServiceReferenceMetadata;
1: import org.apache.aries.blueprint.mutable.MutableValueMetadata;
/////////////////////////////////////////////////////////////////////////
1:  * A namespace handler for Aries blueprint extensions
1: public class ExtNamespaceHandler implements org.apache.aries.blueprint.NamespaceHandler {
0:     public static final String BLUEPRINT_EXT_NAMESPACE = "http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0";
============================================================================