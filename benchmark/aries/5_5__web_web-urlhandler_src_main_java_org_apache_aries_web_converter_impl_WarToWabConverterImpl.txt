1:0adda31: /*
1:0adda31:  * Licensed to the Apache Software Foundation (ASF) under one
1:0adda31:  * or more contributor license agreements.  See the NOTICE file
1:0adda31:  * distributed with this work for additional information
1:0adda31:  * regarding copyright ownership.  The ASF licenses this file
1:0adda31:  * to you under the Apache License, Version 2.0 (the
1:0adda31:  * "License"); you may not use this file except in compliance
1:0adda31:  * with the License.  You may obtain a copy of the License at
1:0adda31:  *
1:0adda31:  *   http://www.apache.org/licenses/LICENSE-2.0
1:0adda31:  *
1:0adda31:  * Unless required by applicable law or agreed to in writing,
1:0adda31:  * software distributed under the License is distributed on an
1:0adda31:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:0adda31:  * KIND, either express or implied.  See the License for the
1:0adda31:  * specific language governing permissions and limitations
1:0adda31:  * under the License.
1:0adda31:  */
1:d80741a: package org.apache.aries.web.converter.impl;
23:0adda31: 
1:1e6dfc7: import static org.apache.aries.web.converter.WarToWabConverter.WEB_CONTEXT_PATH;
1:1e6dfc7: 
1:0adda31: import java.io.IOException;
1:0adda31: import java.io.InputStream;
1:0adda31: import java.util.ArrayList;
1:0adda31: import java.util.Collection;
1:0adda31: import java.util.HashMap;
1:eff3f5e: import java.util.TreeSet;
1:8d145ca: import java.util.List;
1:0adda31: import java.util.Map;
1:0adda31: import java.util.Properties;
1:0adda31: import java.util.Set;
1:0adda31: import java.util.jar.Attributes;
1:0adda31: import java.util.jar.JarInputStream;
1:0adda31: import java.util.jar.JarOutputStream;
1:0adda31: import java.util.jar.Manifest;
1:0adda31: import java.util.regex.Matcher;
1:0adda31: import java.util.regex.Pattern;
1:0adda31: import java.util.zip.ZipEntry;
1:0adda31: 
1:3af6ab7: import org.apache.aries.web.converter.WabConversion;
1:d80741a: import org.apache.aries.web.converter.WarToWabConverter.InputStreamProvider;
1:0adda31: import org.objectweb.asm.ClassReader;
1:0adda31: import org.osgi.framework.Constants;
1:0adda31: 
1:3af6ab7: public class WarToWabConverterImpl implements WabConversion {
1:0adda31:   private static final String DEFAULT_BUNDLE_VERSION = "1.0";
1:0adda31:   private static final String DEFAULT_BUNDLE_MANIFESTVERSION = "2";
1:9701730:   private static final String INITIAL_CLASSPATH_ENTRY = "WEB-INF/classes";
1:0adda31:   private static final String CLASSPATH_LIB_PREFIX = "WEB-INF/lib/";
1:9af03a3:   
1:9af03a3:   private static final String SERVLET_IMPORTS = 
1:9af03a3:       "javax.servlet;version=2.5," +
1:9af03a3:       "javax.servlet.http;version=2.5";
1:9af03a3:   
1:9af03a3:   private static final String JSP_IMPORTS =
1:9af03a3:       "javax.servlet.jsp;version=2.1," +
1:9af03a3:       "javax.servlet.jsp.el;version=2.1," +
1:9af03a3:       "javax.servlet.jsp.tagext;version=2.1," +
1:9af03a3:       "javax.servlet.jsp.resources;version=2.1";
1:9af03a3:     
1:9af03a3:   private static final String DEFAULT_IMPORT_PACKAGE_LIST = 
1:9af03a3:       SERVLET_IMPORTS + "," + JSP_IMPORTS;
1:0adda31: 
1:50ca3da:   private CaseInsensitiveMap properties;
1:0adda31: 
1:0adda31:   // InputStream for the new WAB file
1:5b39862:   private CachedOutputStream wab;
1:90e52fd:   private Manifest wabManifest;
1:0adda31:   private String warName;
1:d80741a:   private InputStreamProvider input;
1:0adda31:   
1:0adda31:   // State used for updating the manifest
1:0adda31:   private Set<String> importPackages;
1:0adda31:   private Set<String> exemptPackages;
1:0adda31:   private Map<String, Manifest> manifests; 
1:0adda31:   private ArrayList<String> classPath;
1:a0169df:   private boolean signed;
1:0adda31: 
1:d80741a:   public WarToWabConverterImpl(InputStreamProvider warFile, String name, Properties properties) throws IOException {
1:50ca3da:       this(warFile, name, new CaseInsensitiveMap(properties));
1:50ca3da:   }
1:50ca3da:   
1:50ca3da:   public WarToWabConverterImpl(InputStreamProvider warFile, String name, CaseInsensitiveMap properties) throws IOException {
1:0adda31:     this.properties = properties;
1:0adda31:     classPath = new ArrayList<String>();
1:eff3f5e:     importPackages = new TreeSet<String>();
1:eff3f5e:     exemptPackages = new TreeSet<String>();
1:d80741a:     input = warFile;
1:d80741a:     this.warName = name;
11:0adda31:   }
1:50ca3da:     
1:5b39862:   private void generateManifest() throws IOException {
1:5b39862:     if (wabManifest != null) {
1:5b39862:         // WAB manifest is already generated
1:5b39862:         return;
1:5b39862:     }
1:5b39862:     
1:0adda31:     JarInputStream jarInput = null;
1:0adda31:     try {
1:d80741a:       jarInput = new JarInputStream(input.getInputStream());
1:5fca10e:       Manifest manifest = jarInput.getManifest();
1:043e0a4:       if (isBundle(manifest)) {
1:043e0a4:           wabManifest = updateBundleManifest(manifest);
1:043e0a4:       } else {
1:043e0a4:           scanForDependencies(jarInput);
1:043e0a4:           // Add the new properties to the manifest byte stream
1:043e0a4:           wabManifest = updateManifest(manifest);
1:043e0a4:       }
1:0adda31:     } 
1:0adda31:     finally {
1:0adda31:       try { if (jarInput != null) jarInput.close(); } catch (IOException e) { e.printStackTrace(); }
1:5b39862:     }
1:0adda31:   }
1:0adda31: 
1:5b39862:   private void convert() throws IOException {
1:5b39862:     if (wab != null) {
1:5b39862:         // WAB is already converted
1:5b39862:         return;
1:5b39862:     }
1:5b39862:     
1:5b39862:     generateManifest();
1:5b39862:     
1:5b39862:     CachedOutputStream output = new CachedOutputStream();
1:0adda31:     JarOutputStream jarOutput = null;
1:5b39862:     JarInputStream jarInput = null;
1:5b39862:     ZipEntry entry = null;
1:0adda31: 
1:0adda31:     // Copy across all entries from the original jar
1:0adda31:     int val;
1:0adda31:     try {
1:90e52fd:       jarOutput = new JarOutputStream(output, wabManifest);
1:d80741a:       jarInput = new JarInputStream(input.getInputStream());
1:9af03a3:       byte[] buffer = new byte[2048];
1:0adda31:       while ((entry = jarInput.getNextEntry()) != null) {
1:a0169df:         // skip signature files if war is signed
1:a0169df:         if (signed && isSignatureFile(entry.getName())) {
1:a0169df:             continue;
1:a0169df:         }
1:9af03a3:         jarOutput.putNextEntry(entry);        
1:5b39862:         while ((val = jarInput.read(buffer)) > 0) {
1:9af03a3:           jarOutput.write(buffer, 0, val);
1:5b39862:         }
1:0adda31:       }
1:0adda31:     }
1:0adda31:     finally {
1:5b39862:       if (jarOutput != null) {
1:0adda31:         jarOutput.close();
1:5b39862:       }
1:5b39862:       if (jarInput != null) {
1:0adda31:         jarInput.close();
1:5b39862:       }
1:0adda31:     }
1:5b39862:     
1:5b39862:     wab = output;
1:0adda31:   }
1:0adda31: 
1:043e0a4:   private boolean isBundle(Manifest manifest)  {
1:043e0a4:       if (manifest == null) {
1:043e0a4:           return false;          
1:043e0a4:       }
1:9af03a3:       // Presence of _any_ of these headers indicates a bundle...
1:043e0a4:       Attributes attributes = manifest.getMainAttributes();
1:9af03a3:       if (attributes.getValue(Constants.BUNDLE_SYMBOLICNAME) != null ||
1:9af03a3:           attributes.getValue(Constants.BUNDLE_VERSION) != null ||
1:9af03a3:           attributes.getValue(Constants.BUNDLE_MANIFESTVERSION) != null ||
1:9af03a3:           attributes.getValue(Constants.IMPORT_PACKAGE) != null ||
1:9af03a3:           attributes.getValue(WEB_CONTEXT_PATH) != null) {
1:043e0a4:           return true;
1:043e0a4:       }
1:043e0a4:       return false;
1:043e0a4:   }
1:043e0a4:   
1:0adda31:   private void scanRecursive(final JarInputStream jarInput, boolean topLevel) throws IOException 
3:0adda31:   {
2:0adda31:     ZipEntry entry;
1:0adda31:     
1:0adda31:     while ((entry = jarInput.getNextEntry()) != null) {
1:0adda31:       if (entry.getName().endsWith(".class")) {
1:0adda31:         PackageFinder pkgFinder = new PackageFinder();
1:0adda31:         new ClassReader(jarInput).accept(pkgFinder, ClassReader.SKIP_DEBUG);
1:0adda31: 
1:0adda31:         importPackages.addAll(pkgFinder.getImportPackages());
1:0adda31:         exemptPackages.addAll(pkgFinder.getExemptPackages());
1:0adda31:       } else if (entry.getName().endsWith(".jsp")) { 
1:0adda31:         Collection<String> thisJSPsImports = JSPImportParser.getImports(jarInput);
1:0adda31:         importPackages.addAll(thisJSPsImports);
1:0adda31:       } else if (entry.getName().endsWith(".jar")) {
1:0adda31:         
1:0adda31:         JarInputStream newJar = new JarInputStream(new InputStream() {
1:0adda31:           @Override
1:0adda31:           public int read() throws IOException
1:0adda31:           {
1:0adda31:             return jarInput.read();
1:0adda31:           }
1:0adda31:         });
1:0adda31:         
1:0adda31:         // discard return, we only care about the top level jars
1:0adda31:         scanRecursive(newJar,false);
1:0adda31:         
1:0adda31:         // do not add jar embedded in already embedded jars
1:0adda31:         if (topLevel) {
1:0adda31:           manifests.put(entry.getName(), newJar.getManifest());
1:0adda31:         }
1:0adda31:       }
1:0adda31:     }
1:0adda31:   }
1:0adda31:   
1:0adda31:   /**
1:0adda31:    * 
1:0adda31:    * Read in the filenames inside the war (used for manifest update) Also
1:0adda31:    * analyse the bytecode of any .class files in order to find any required
1:0adda31:    * imports
1:0adda31:    */
1:0adda31:   private void scanForDependencies(final JarInputStream jarInput) throws IOException 
1:0adda31:   {
1:0adda31:     manifests = new HashMap<String, Manifest>();
1:0adda31:     
1:0adda31:     scanRecursive(jarInput, true);
1:0adda31: 
1:0adda31:     // Process manifests from jars in order to work out classpath dependencies
1:0adda31:     ClassPathBuilder classPathBuilder = new ClassPathBuilder(manifests);
1:0adda31:     for (String fileName : manifests.keySet())
1:5fca10e:       if (fileName.startsWith(CLASSPATH_LIB_PREFIX)) {
1:0adda31:         classPath.add(fileName);
1:0adda31:         classPath = classPathBuilder.updatePath(fileName, classPath);
1:0adda31:       }
1:0adda31:         
1:0adda31:     // Remove packages that are part of the classes we searched through
1:0adda31:     for (String s : exemptPackages)
1:0adda31:       if (importPackages.contains(s))
1:0adda31:         importPackages.remove(s);
1:0adda31:   }
1:0adda31: 
1:043e0a4:   protected Manifest updateBundleManifest(Manifest manifest) throws IOException {
1:50ca3da:       String webCPath = properties.get(WEB_CONTEXT_PATH);
1:043e0a4:       if (webCPath == null) {
1:043e0a4:           webCPath = manifest.getMainAttributes().getValue(WEB_CONTEXT_PATH);
1:043e0a4:       }
1:043e0a4:       if (webCPath == null) {
1:043e0a4:           throw new IOException("Must specify " + WEB_CONTEXT_PATH + " parameter. The " + 
1:043e0a4:                                 WEB_CONTEXT_PATH + " header is not defined in the source bundle.");
1:043e0a4:       } else {
1:043e0a4:           webCPath = addSlash(webCPath);
1:043e0a4:           manifest.getMainAttributes().put(new Attributes.Name(WEB_CONTEXT_PATH), webCPath);
1:043e0a4:       }
1:043e0a4:       
1:043e0a4:       // converter is not allowed to specify and override the following properties
1:043e0a4:       // when source is already a bundle
1:043e0a4:       checkParameter(Constants.BUNDLE_VERSION);
1:043e0a4:       checkParameter(Constants.BUNDLE_MANIFESTVERSION);
1:043e0a4:       checkParameter(Constants.BUNDLE_SYMBOLICNAME);
1:043e0a4:       checkParameter(Constants.IMPORT_PACKAGE);
1:043e0a4:       checkParameter(Constants.BUNDLE_CLASSPATH);
1:043e0a4:               
1:043e0a4:       return manifest;
1:043e0a4:   }
1:043e0a4:   
1:043e0a4:   private void checkParameter(String parameter) throws IOException {
1:043e0a4:       if (properties.containsKey(parameter)) {
1:50ca3da:           throw new IOException("Cannot override " + parameter + " header when converting a bundle");
1:043e0a4:       }
1:043e0a4:   }
1:043e0a4:   
1:0adda31:   protected Manifest updateManifest(Manifest manifest) throws IOException
1:0adda31:   {
1:0adda31:     // If for some reason no manifest was generated, we start our own so that we don't null pointer later on
1:0adda31:     if (manifest == null) {
1:0adda31:       manifest = new Manifest();
1:0adda31:       manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1");
1:a0169df:     } else {
1:a0169df:       // remove digest attributes if was is signed
1:a0169df:       signed = removeDigestAttributes(manifest);
1:0adda31:     }
1:0adda31:     
1:0adda31:     // Compare the manifest and the supplied properties
1:043e0a4:     
1:043e0a4:     //
1:043e0a4:     // Web-ContextPath
1:043e0a4:     //
1:043e0a4: 
1:50ca3da:     String webCPath = properties.get(WEB_CONTEXT_PATH);
1:043e0a4:     if (webCPath == null) {
1:50ca3da:         throw new IOException(WEB_CONTEXT_PATH + " parameter is missing.");
1:043e0a4:     }
1:043e0a4:     properties.put(WEB_CONTEXT_PATH, addSlash(webCPath));  
1:0adda31: 
7:0adda31:     //
1:0adda31:     // Bundle-Version
1:0adda31:     //
1:0adda31: 
1:0adda31:     if (manifest.getMainAttributes().getValue(Constants.BUNDLE_VERSION) == null
1:0adda31:         && !properties.containsKey(Constants.BUNDLE_VERSION)) {
1:0adda31:       properties.put(Constants.BUNDLE_VERSION, DEFAULT_BUNDLE_VERSION);
1:668dcc6:     }
1:0adda31: 
1:0adda31:     //
1:0adda31:     // Bundle-ManifestVersion
1:0adda31:     //
1:0adda31: 
1:50ca3da:     String manifestVersion = properties.get(Constants.BUNDLE_MANIFESTVERSION);
1:9af03a3:     if (manifestVersion == null) {
1:9af03a3:         manifestVersion = manifest.getMainAttributes().getValue(Constants.BUNDLE_MANIFESTVERSION);
1:9af03a3:         if (manifestVersion == null) {
1:9af03a3:             manifestVersion = DEFAULT_BUNDLE_MANIFESTVERSION;
1:9af03a3:         }
1:9af03a3:     } else if (!manifestVersion.equals("2")) {
1:9af03a3:         throw new IOException("Unsupported bundle manifest version " + manifestVersion);
1:0adda31:     }
1:9af03a3:     properties.put(Constants.BUNDLE_MANIFESTVERSION, manifestVersion);
1:0adda31: 
1:0adda31:     // 
1:0adda31:     // Bundle-ClassPath
1:0adda31:     //
1:0adda31: 
1:0adda31:     ArrayList<String> classpath = new ArrayList<String>();
1:0adda31: 
1:0adda31:     // Set initial entry into classpath
1:9701730:     classpath.add(INITIAL_CLASSPATH_ENTRY);
1:0adda31: 
1:0adda31:     // Add any files from the WEB-INF/lib directory + their dependencies
1:0adda31:     classpath.addAll(classPath);
1:0adda31:     
1:0adda31:     // Get the list from the URL and add to classpath (removing duplicates)
1:50ca3da:     mergePathList(properties.get(Constants.BUNDLE_CLASSPATH), classpath, ",");
1:0adda31: 
1:0adda31:     // Get the existing list from the manifest file and add to classpath
1:0adda31:     // (removing duplicates)
1:8d145ca:     mergePathList(manifest.getMainAttributes().getValue(Constants.BUNDLE_CLASSPATH), classpath, ",");
1:0adda31: 
1:0adda31:     // Construct the classpath string and set it into the properties
1:0adda31:     StringBuffer classPathValue = new StringBuffer();
1:0adda31:     for (String entry : classpath) {
1:90e52fd:       classPathValue.append(",");
1:0adda31:       classPathValue.append(entry);
1:0adda31:     }
1:0adda31: 
1:8d145ca:     if (!classpath.isEmpty()) {
1:8d145ca:       properties.put(Constants.BUNDLE_CLASSPATH, classPathValue.toString().substring(1));
1:8d145ca:     }
1:0adda31: 
1:9e668db:     @SuppressWarnings("serial")
1:0adda31:     ArrayList<String> packages = new ArrayList<String>() {
1:0adda31:       @Override
1:0adda31:       public boolean contains(Object elem) {
1:0adda31:         // Check for exact match of export list
1:0adda31:         if (super.contains(elem))
1:0adda31:           return true;
1:0adda31: 
1:0adda31:         if (!!!(elem instanceof String))
1:0adda31:           return false;
1:0adda31: 
1:0adda31:         String expPackageStmt = (String) elem;
1:0adda31:         String expPackage = expPackageStmt.split("\\s*;\\s*")[0];
1:0adda31:         
1:0adda31:         Pattern p = Pattern.compile("^\\s*"+Pattern.quote(expPackage)+"((;|\\s).*)?\\s*$");
1:0adda31:         for (String s : this) {
1:0adda31:           Matcher m = p.matcher(s);
1:0adda31:           if (m.matches()) {
1:0adda31:             return true;
1:0adda31:           }
1:0adda31:         }
1:0adda31: 
1:0adda31:         return false;
1:0adda31:       }
1:0adda31: 
1:0adda31:     };
1:0adda31:     
1:0adda31:     //
1:0adda31:     // Import-Package
1:0adda31:     //
1:0adda31:     packages.clear();
1:9701730:     
1:0adda31:     // Get the list from the URL and add to classpath (removing duplicates)
1:50ca3da:     mergePathList(properties.get(Constants.IMPORT_PACKAGE), packages, ",");
1:0adda31: 
1:0adda31:     // Get the existing list from the manifest file and add to classpath
1:0adda31:     // (removing duplicates)
1:8d145ca:     mergePathList(manifest.getMainAttributes().getValue(Constants.IMPORT_PACKAGE), packages, ",");
1:0adda31: 
1:0adda31:     // Add the default set of packages
1:0adda31:     mergePathList(DEFAULT_IMPORT_PACKAGE_LIST, packages, ",");
1:0adda31: 
1:0adda31:     // Analyse the bytecode of any .class files in the jar to find any other
1:0adda31:     // required imports
1:0adda31:     if (!!!importPackages.isEmpty()) {
1:0adda31:       StringBuffer generatedImports = new StringBuffer();
1:0adda31:       for (String entry : importPackages) {
1:0adda31:         generatedImports.append(',');
1:0adda31:         generatedImports.append(entry);
1:0adda31:         generatedImports.append(";resolution:=optional");
1:0adda31:       }      
1:0adda31:       
1:0adda31:       mergePathList(generatedImports.substring(1), packages, ",");
1:0adda31:     }
1:0adda31: 
1:0adda31:     // Construct the string and set it into the properties
1:0adda31:     StringBuffer importValues = new StringBuffer();
1:0adda31:     for (String entry : packages) {
1:0adda31:       importValues.append(",");
1:0adda31:       importValues.append(entry);
1:0adda31:     }
1:8d145ca:     if (!packages.isEmpty()) {
1:8d145ca:       properties.put(Constants.IMPORT_PACKAGE, importValues.toString().substring(1));
1:8d145ca:     }
1:043e0a4:      
1:0adda31:     // Take the properties map and add them to the manifest file
1:50ca3da:     for (Map.Entry<String, String> entry : properties.entrySet()) {
1:50ca3da:         String key = entry.getKey();
1:50ca3da:         String value = entry.getValue();
1:7748419:         manifest.getMainAttributes().putValue(key, value);
1:7748419:     }
1:7748419:     
1:7748419:     //
1:7748419:     // Bundle-SymbolicName
1:7748419:     //
1:7748419: 
1:7748419:     if (manifest.getMainAttributes().getValue(Constants.BUNDLE_SYMBOLICNAME) == null) {
1:7748419:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, warName + "_" + manifest.hashCode());
1:043e0a4:     }
1:8d145ca:     
1:0adda31:     return manifest;
1:0adda31:   }
1:0adda31: 
1:043e0a4:   private static String addSlash(String contextPath) {
1:043e0a4:       if (!contextPath.startsWith("/")) {
1:043e0a4:           contextPath = "/" + contextPath;
1:043e0a4:       }
1:043e0a4:       return contextPath;
1:043e0a4:   }
1:043e0a4:   
1:0adda31:   // pathlist = A "delim" delimitted list of path entries
1:8d145ca:   private static void mergePathList(String pathlist, ArrayList<String> paths, String delim) {
1:8d145ca:       if (pathlist != null) {
1:8d145ca:           List<String> tokens = parseDelimitedString(pathlist, delim, true);
1:8d145ca:           for (String token : tokens) {
1:8d145ca:               if (!paths.contains(token)) {
1:8d145ca:                   paths.add(token);
1:8d145ca:               }
1:8d145ca:           }
1:0adda31:       }
1:0adda31:   }
1:8d145ca:   
1:8d145ca:   private static List<String> parseDelimitedString(String value, String delim, boolean includeQuotes) {   
1:8d145ca:       if (value == null) {       
1:8d145ca:           value = "";
1:8d145ca:       }
1:0adda31: 
1:8d145ca:       List<String> list = new ArrayList<String>();
1:8d145ca: 
1:8d145ca:       int CHAR = 1;
1:8d145ca:       int DELIMITER = 2;
1:8d145ca:       int STARTQUOTE = 4;
1:8d145ca:       int ENDQUOTE = 8;
1:8d145ca: 
1:8d145ca:       StringBuffer sb = new StringBuffer();
1:8d145ca: 
1:8d145ca:       int expecting = (CHAR | DELIMITER | STARTQUOTE);
1:8d145ca: 
1:8d145ca:       for (int i = 0; i < value.length(); i++) {        
1:8d145ca:           char c = value.charAt(i);
1:8d145ca: 
1:8d145ca:           boolean isDelimiter = (delim.indexOf(c) >= 0);
1:8d145ca:           boolean isQuote = (c == '"');
1:8d145ca: 
1:8d145ca:           if (isDelimiter && ((expecting & DELIMITER) > 0)) {            
1:8d145ca:               list.add(sb.toString().trim());
1:8d145ca:               sb.delete(0, sb.length());
1:8d145ca:               expecting = (CHAR | DELIMITER | STARTQUOTE);
1:8d145ca:           } else if (isQuote && ((expecting & STARTQUOTE) > 0)) { 
1:8d145ca:               if (includeQuotes) {
1:8d145ca:                   sb.append(c);
1:8d145ca:               }
1:8d145ca:               expecting = CHAR | ENDQUOTE;
1:8d145ca:           } else if (isQuote && ((expecting & ENDQUOTE) > 0)) {    
1:8d145ca:               if (includeQuotes) {
1:8d145ca:                   sb.append(c);
1:8d145ca:               }
1:8d145ca:               expecting = (CHAR | STARTQUOTE | DELIMITER);
1:8d145ca:           } else if ((expecting & CHAR) > 0) {            
1:8d145ca:               sb.append(c);
1:8d145ca:           } else {
1:8d145ca:               throw new IllegalArgumentException("Invalid delimited string: " + value);
1:8d145ca:           }
1:8d145ca:       }
1:8d145ca: 
1:8d145ca:       if (sb.length() > 0) {        
1:8d145ca:           list.add(sb.toString().trim());
1:8d145ca:       }
1:8d145ca: 
1:8d145ca:       return list;
1:8d145ca:   }
1:8d145ca:   
1:a0169df:   private static boolean removeDigestAttributes(Manifest manifest) {
1:a0169df:       boolean foundDigestAttribute = false;
1:a0169df:       for (Map.Entry<String, Attributes> entry : manifest.getEntries().entrySet()) {
1:a0169df:           Attributes attributes = entry.getValue();
1:a0169df:           for (Object attributeName : attributes.keySet()) {    
1:a0169df:               String name = ((Attributes.Name) attributeName).toString();
1:a0169df:               name = name.toLowerCase();
1:a0169df:               if (name.endsWith("-digest") || name.contains("-digest-")) {
1:a0169df:                   attributes.remove(attributeName);
1:a0169df:                   foundDigestAttribute = true;
1:a0169df:               }
1:a0169df:           }
1:a0169df:       }
1:a0169df:       return foundDigestAttribute;
1:a0169df:   }
1:a0169df:   
1:a0169df:   private static boolean isSignatureFile(String entryName) {
1:a0169df:       String[] parts = entryName.split("/");
1:a0169df:       if (parts.length == 2) {
1:a0169df:           String name = parts[1].toLowerCase();
1:a0169df:           return (parts[0].equals("META-INF") &&
1:a0169df:                   (name.endsWith(".sf") || 
1:a0169df:                    name.endsWith(".dsa") || 
1:a0169df:                    name.endsWith(".rsa") || 
1:a0169df:                    name.startsWith("sig-")));
1:a0169df:       } else {
1:a0169df:           return false;
1:a0169df:       }
1:a0169df:   }
1:a0169df:   
1:0adda31:   public InputStream getWAB() throws IOException {
1:5b39862:     convert();
1:5b39862:     return wab.getInputStream();
1:90e52fd:   }
1:90e52fd:   
1:90e52fd:   public Manifest getWABManifest() throws IOException {
1:5b39862:     generateManifest();
1:90e52fd:     return wabManifest;
1:90e52fd:   }
1:90e52fd: 
1:0adda31:   public int getWabLength() throws IOException {
1:5b39862:     convert();
1:5b39862:     return wab.size();
1:0adda31:   }
1:0adda31:   
1:0adda31: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:9e668db
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("serial")
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:eff3f5e
/////////////////////////////////////////////////////////////////////////
1: import java.util.TreeSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     importPackages = new TreeSet<String>();
1:     exemptPackages = new TreeSet<String>();
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:3af6ab7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.web.converter.WabConversion;
0: import org.apache.aries.web.converter.WarToWabConverter;
1: public class WarToWabConverterImpl implements WabConversion {
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:a0169df
/////////////////////////////////////////////////////////////////////////
1:   private boolean signed;
/////////////////////////////////////////////////////////////////////////
1:         // skip signature files if war is signed
1:         if (signed && isSignatureFile(entry.getName())) {
1:             continue;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     } else {
1:       // remove digest attributes if was is signed
1:       signed = removeDigestAttributes(manifest);
/////////////////////////////////////////////////////////////////////////
1:   private static boolean removeDigestAttributes(Manifest manifest) {
1:       boolean foundDigestAttribute = false;
1:       for (Map.Entry<String, Attributes> entry : manifest.getEntries().entrySet()) {
1:           Attributes attributes = entry.getValue();
1:           for (Object attributeName : attributes.keySet()) {    
1:               String name = ((Attributes.Name) attributeName).toString();
1:               name = name.toLowerCase();
1:               if (name.endsWith("-digest") || name.contains("-digest-")) {
1:                   attributes.remove(attributeName);
1:                   foundDigestAttribute = true;
1:               }
1:           }
1:       }
1:       return foundDigestAttribute;
1:   }
1:   
1:   private static boolean isSignatureFile(String entryName) {
1:       String[] parts = entryName.split("/");
1:       if (parts.length == 2) {
1:           String name = parts[1].toLowerCase();
1:           return (parts[0].equals("META-INF") &&
1:                   (name.endsWith(".sf") || 
1:                    name.endsWith(".dsa") || 
1:                    name.endsWith(".rsa") || 
1:                    name.startsWith("sig-")));
1:       } else {
1:           return false;
1:       }
1:   }
1:   
commit:7748419
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         manifest.getMainAttributes().putValue(key, value);
1:     }
1:     
1:     //
1:     // Bundle-SymbolicName
1:     //
1: 
1:     if (manifest.getMainAttributes().getValue(Constants.BUNDLE_SYMBOLICNAME) == null) {
1:         manifest.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, warName + "_" + manifest.hashCode());
commit:5b39862
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private CachedOutputStream wab;
/////////////////////////////////////////////////////////////////////////
1:   private void generateManifest() throws IOException {
1:     if (wabManifest != null) {
1:         // WAB manifest is already generated
1:         return;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:   }
1:   private void convert() throws IOException {
1:     if (wab != null) {
1:         // WAB is already converted
1:         return;
1:     }
1:     
1:     generateManifest();
1:     
1:     CachedOutputStream output = new CachedOutputStream();
1:     JarInputStream jarInput = null;
1:     ZipEntry entry = null;
/////////////////////////////////////////////////////////////////////////
1:         while ((val = jarInput.read(buffer)) > 0) {
1:         }
1:       if (jarOutput != null) {
1:       }
1:       if (jarInput != null) {
1:       }
1:     
1:     wab = output;
/////////////////////////////////////////////////////////////////////////
1:     convert();
1:     return wab.getInputStream();
1:     generateManifest();
1:     convert();
1:     return wab.size();
commit:50ca3da
/////////////////////////////////////////////////////////////////////////
1:   private CaseInsensitiveMap properties;
/////////////////////////////////////////////////////////////////////////
1:       this(warFile, name, new CaseInsensitiveMap(properties));
1:   }
1:   
1:   public WarToWabConverterImpl(InputStreamProvider warFile, String name, CaseInsensitiveMap properties) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:       String webCPath = properties.get(WEB_CONTEXT_PATH);
/////////////////////////////////////////////////////////////////////////
1:           throw new IOException("Cannot override " + parameter + " header when converting a bundle");
/////////////////////////////////////////////////////////////////////////
1:     String webCPath = properties.get(WEB_CONTEXT_PATH);
1:         throw new IOException(WEB_CONTEXT_PATH + " parameter is missing.");
/////////////////////////////////////////////////////////////////////////
1:     String manifestVersion = properties.get(Constants.BUNDLE_MANIFESTVERSION);
/////////////////////////////////////////////////////////////////////////
1:     mergePathList(properties.get(Constants.BUNDLE_CLASSPATH), classpath, ",");
/////////////////////////////////////////////////////////////////////////
1:     mergePathList(properties.get(Constants.IMPORT_PACKAGE), packages, ",");
/////////////////////////////////////////////////////////////////////////
1:     for (Map.Entry<String, String> entry : properties.entrySet()) {
1:         String key = entry.getKey();
1:         String value = entry.getValue();
commit:9af03a3
/////////////////////////////////////////////////////////////////////////
1:   
1:   private static final String SERVLET_IMPORTS = 
1:       "javax.servlet;version=2.5," +
1:       "javax.servlet.http;version=2.5";
1:   
1:   private static final String JSP_IMPORTS =
1:       "javax.servlet.jsp;version=2.1," +
1:       "javax.servlet.jsp.el;version=2.1," +
1:       "javax.servlet.jsp.tagext;version=2.1," +
1:       "javax.servlet.jsp.resources;version=2.1";
1:     
1:   private static final String DEFAULT_IMPORT_PACKAGE_LIST = 
1:       SERVLET_IMPORTS + "," + JSP_IMPORTS;
/////////////////////////////////////////////////////////////////////////
1:       byte[] buffer = new byte[2048];
1:         jarOutput.putNextEntry(entry);        
0:         while ((val = jarInput.read(buffer)) > 0)
1:           jarOutput.write(buffer, 0, val);
/////////////////////////////////////////////////////////////////////////
1:       // Presence of _any_ of these headers indicates a bundle...
1:       if (attributes.getValue(Constants.BUNDLE_SYMBOLICNAME) != null ||
1:           attributes.getValue(Constants.BUNDLE_VERSION) != null ||
1:           attributes.getValue(Constants.BUNDLE_MANIFESTVERSION) != null ||
1:           attributes.getValue(Constants.IMPORT_PACKAGE) != null ||
1:           attributes.getValue(WEB_CONTEXT_PATH) != null) {
/////////////////////////////////////////////////////////////////////////
0:     String manifestVersion = properties.getProperty(Constants.BUNDLE_MANIFESTVERSION);
1:     if (manifestVersion == null) {
1:         manifestVersion = manifest.getMainAttributes().getValue(Constants.BUNDLE_MANIFESTVERSION);
1:         if (manifestVersion == null) {
1:             manifestVersion = DEFAULT_BUNDLE_MANIFESTVERSION;
1:         }
1:     } else if (!manifestVersion.equals("2")) {
1:         throw new IOException("Unsupported bundle manifest version " + manifestVersion);
1:     properties.put(Constants.BUNDLE_MANIFESTVERSION, manifestVersion);
commit:043e0a4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       if (isBundle(manifest)) {
1:           wabManifest = updateBundleManifest(manifest);
1:       } else {
1:           scanForDependencies(jarInput);
1:           // Add the new properties to the manifest byte stream
1:           wabManifest = updateManifest(manifest);
1:       }
/////////////////////////////////////////////////////////////////////////
1:   private boolean isBundle(Manifest manifest)  {
1:       if (manifest == null) {
1:           return false;          
1:       }
1:       Attributes attributes = manifest.getMainAttributes();
0:       // TODO: need to check for other headers too
0:       if (attributes.getValue(Constants.BUNDLE_SYMBOLICNAME) != null) {
1:           return true;
1:       }
1:       return false;
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:   protected Manifest updateBundleManifest(Manifest manifest) throws IOException {
0:       String webCPath = properties.getProperty(WEB_CONTEXT_PATH);
1:       if (webCPath == null) {
1:           webCPath = manifest.getMainAttributes().getValue(WEB_CONTEXT_PATH);
1:       }
1:       if (webCPath == null) {
1:           throw new IOException("Must specify " + WEB_CONTEXT_PATH + " parameter. The " + 
1:                                 WEB_CONTEXT_PATH + " header is not defined in the source bundle.");
1:       } else {
1:           webCPath = addSlash(webCPath);
1:           manifest.getMainAttributes().put(new Attributes.Name(WEB_CONTEXT_PATH), webCPath);
1:       }
1:       
1:       // converter is not allowed to specify and override the following properties
1:       // when source is already a bundle
1:       checkParameter(Constants.BUNDLE_VERSION);
1:       checkParameter(Constants.BUNDLE_MANIFESTVERSION);
1:       checkParameter(Constants.BUNDLE_SYMBOLICNAME);
1:       checkParameter(Constants.IMPORT_PACKAGE);
1:       checkParameter(Constants.BUNDLE_CLASSPATH);
1:               
1:       return manifest;
1:   }
1:   
1:   private void checkParameter(String parameter) throws IOException {
1:       if (properties.containsKey(parameter)) {
0:           throw new IOException("Cannot override " + parameter + " parameter when converting a bundle");
1:       }
1:   }
1:   
/////////////////////////////////////////////////////////////////////////
1:     
1:     //
1:     // Web-ContextPath
1:     //
1: 
0:     String webCPath = properties.getProperty(WEB_CONTEXT_PATH);
1:     if (webCPath == null) {
0:         throw new IOException(WEB_CONTEXT_PATH + " parameter is required.");
1:     }
1:     properties.put(WEB_CONTEXT_PATH, addSlash(webCPath));  
/////////////////////////////////////////////////////////////////////////
0:       properties.put(Constants.BUNDLE_MANIFESTVERSION, DEFAULT_BUNDLE_MANIFESTVERSION);
/////////////////////////////////////////////////////////////////////////
0:       properties.put(Constants.BUNDLE_SYMBOLICNAME, warName + "_" + manifest.hashCode());
/////////////////////////////////////////////////////////////////////////
1:      
0:     for (Map.Entry<Object, Object> entry : properties.entrySet()) {
0:         String key = entry.getKey().toString();
0:         String value = entry.getValue().toString();
0:         manifest.getMainAttributes().put(new Attributes.Name(key), value);
1:     }
1:   private static String addSlash(String contextPath) {
1:       if (!contextPath.startsWith("/")) {
1:           contextPath = "/" + contextPath;
1:       }
1:       return contextPath;
1:   }
1:   
commit:b6e25a4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:8d145ca
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     mergePathList(properties.getProperty(Constants.BUNDLE_CLASSPATH), classpath, ",");
1:     mergePathList(manifest.getMainAttributes().getValue(Constants.BUNDLE_CLASSPATH), classpath, ",");
/////////////////////////////////////////////////////////////////////////
1:     if (!classpath.isEmpty()) {
1:       properties.put(Constants.BUNDLE_CLASSPATH, classPathValue.toString().substring(1));
1:     }
/////////////////////////////////////////////////////////////////////////
0:     mergePathList(properties.getProperty(Constants.IMPORT_PACKAGE), packages, ",");
1:     mergePathList(manifest.getMainAttributes().getValue(Constants.IMPORT_PACKAGE), packages, ",");
/////////////////////////////////////////////////////////////////////////
1:     if (!packages.isEmpty()) {
1:       properties.put(Constants.IMPORT_PACKAGE, importValues.toString().substring(1));
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:   private static void mergePathList(String pathlist, ArrayList<String> paths, String delim) {
1:       if (pathlist != null) {
1:           List<String> tokens = parseDelimitedString(pathlist, delim, true);
1:           for (String token : tokens) {
1:               if (!paths.contains(token)) {
1:                   paths.add(token);
1:               }
1:           }
1:   
1:   private static List<String> parseDelimitedString(String value, String delim, boolean includeQuotes) {   
1:       if (value == null) {       
1:           value = "";
1:       }
1:       List<String> list = new ArrayList<String>();
1: 
1:       int CHAR = 1;
1:       int DELIMITER = 2;
1:       int STARTQUOTE = 4;
1:       int ENDQUOTE = 8;
1: 
1:       StringBuffer sb = new StringBuffer();
1: 
1:       int expecting = (CHAR | DELIMITER | STARTQUOTE);
1: 
1:       for (int i = 0; i < value.length(); i++) {        
1:           char c = value.charAt(i);
1: 
1:           boolean isDelimiter = (delim.indexOf(c) >= 0);
1:           boolean isQuote = (c == '"');
1: 
1:           if (isDelimiter && ((expecting & DELIMITER) > 0)) {            
1:               list.add(sb.toString().trim());
1:               sb.delete(0, sb.length());
1:               expecting = (CHAR | DELIMITER | STARTQUOTE);
1:           } else if (isQuote && ((expecting & STARTQUOTE) > 0)) { 
1:               if (includeQuotes) {
1:                   sb.append(c);
1:               }
1:               expecting = CHAR | ENDQUOTE;
1:           } else if (isQuote && ((expecting & ENDQUOTE) > 0)) {    
1:               if (includeQuotes) {
1:                   sb.append(c);
1:               }
1:               expecting = (CHAR | STARTQUOTE | DELIMITER);
1:           } else if ((expecting & CHAR) > 0) {            
1:               sb.append(c);
1:           } else {
1:               throw new IllegalArgumentException("Invalid delimited string: " + value);
1:           }
1:       }
1: 
1:       if (sb.length() > 0) {        
1:           list.add(sb.toString().trim());
1:       }
1: 
1:       return list;
1:   }
1:   
commit:9701730
/////////////////////////////////////////////////////////////////////////
1:   private static final String INITIAL_CLASSPATH_ENTRY = "WEB-INF/classes";
/////////////////////////////////////////////////////////////////////////
1:     classpath.add(INITIAL_CLASSPATH_ENTRY);
/////////////////////////////////////////////////////////////////////////
1:     
commit:5fca10e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       Manifest manifest = jarInput.getManifest();
0:       wabManifest = updateManifest(manifest);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       if (fileName.startsWith(CLASSPATH_LIB_PREFIX)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     String webCPath = properties.getProperty(WEB_CONTEXT_PATH);
0:         webCPath = manifest.getMainAttributes().getValue(WEB_CONTEXT_PATH);
commit:668dcc6
/////////////////////////////////////////////////////////////////////////
0:     if (webCPath == null) {
0:         webCPath = properties.getProperty(WEB_CONTEXT_PATH);
0:     if (webCPath == null) {
0:         properties.put(WEB_CONTEXT_PATH, DEFAULT_WEB_CONTEXT_PATH);
0:     } else {
0:         // always ensure context path starts with slash
0:         if (!webCPath.startsWith("/")) {
0:             webCPath = "/" + webCPath;
1:         }
0:         properties.put(WEB_CONTEXT_PATH, webCPath);
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:1e6dfc7
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.web.converter.WarToWabConverter.WEB_CONTEXT_PATH;
0: import static org.apache.aries.web.converter.WarToWabConverter.WEB_JSP_EXTRACT_LOCATION;
1: 
/////////////////////////////////////////////////////////////////////////
commit:d80741a
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.web.converter.impl;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.web.converter.WarToWabConverter.InputStreamProvider;
0: public class WarToWabConverterImpl {
/////////////////////////////////////////////////////////////////////////
1:   private InputStreamProvider input;
/////////////////////////////////////////////////////////////////////////
1:   public WarToWabConverterImpl(InputStreamProvider warFile, String name, Properties properties) throws IOException {
1:     input = warFile;
1:     this.warName = name;
/////////////////////////////////////////////////////////////////////////
1:       jarInput = new JarInputStream(input.getInputStream());
/////////////////////////////////////////////////////////////////////////
1:       jarInput = new JarInputStream(input.getInputStream());
commit:90e52fd
/////////////////////////////////////////////////////////////////////////
1:   private Manifest wabManifest;
/////////////////////////////////////////////////////////////////////////
0:       wabManifest = jarInput.getManifest();
0:       wabManifest = updateManifest(wabManifest);
/////////////////////////////////////////////////////////////////////////
1:       jarOutput = new JarOutputStream(output, wabManifest);
/////////////////////////////////////////////////////////////////////////
0:         classpath, ",");
0:         Constants.BUNDLE_CLASSPATH), classpath, ",");
1:       classPathValue.append(",");
/////////////////////////////////////////////////////////////////////////
0:     ensureConverted();
1:   
1:   public Manifest getWABManifest() throws IOException {
0:     ensureConverted();
1:     return wabManifest;
1:   }
0:     ensureConverted();
0:     return wabFile.length;
1:   }
1:   
0:   private void ensureConverted() throws IOException {
commit:0adda31
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.aries.application.converters;
1: 
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.HashMap;
0: import java.util.HashSet;
1: import java.util.Map;
1: import java.util.Properties;
1: import java.util.Set;
0: import java.util.StringTokenizer;
1: import java.util.jar.Attributes;
1: import java.util.jar.JarInputStream;
1: import java.util.jar.JarOutputStream;
1: import java.util.jar.Manifest;
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: import java.util.zip.ZipEntry;
1: 
0: import org.apache.aries.application.filesystem.IFile;
1: import org.objectweb.asm.ClassReader;
1: import org.osgi.framework.Constants;
1: 
0: public class WarToWabConverter {
1:   private static final String DEFAULT_BUNDLE_VERSION = "1.0";
1:   private static final String DEFAULT_BUNDLE_MANIFESTVERSION = "2";
0:   private static final String INITIAL_CLASSPATH_ENTRY = "WEB-INF/classes/";
1:   private static final String CLASSPATH_LIB_PREFIX = "WEB-INF/lib/";
0:   private static final String DEFAULT_IMPORT_PACKAGE_LIST = "javax.servlet;version=2.5,"
0:       + "javax.servlet.http;version=2.5,"
0:       + "javax.el;version=2.1,"
0:       + "javax.servlet.jsp;version=2.1,"
0:       + "javax.servlet.jsp.el;version=2.1,"
0:       + "javax.servlet.jsp.tagext;version=2.1";
1: 
0:   private static final String DEFAULT_WEB_CONTEXT_PATH = "/";
0:   private static final String DEFAULT_WEB_JSP_EXTRACT_LOCATION = "/";
1: 
0:   // TODO: These constants should be in the framework but at the time of write
0:   // they
0:   // do not exist. When they do we need to point at their values instead.
0:   public static final String WEB_CONTEXT_PATH = "Web-ContextPath";
0:   public static final String WEB_JSP_EXTRACT_LOCATION = "Web-JSPExtractLocation";
1: 
0:   private Properties properties;
1: 
1:   // InputStream for the new WAB file
0:   private byte[] wabFile;
1:   private String warName;
1:   
0:   private boolean converted = false;
1: 
1:   // State used for updating the manifest
0:   private ArrayList<String> fileNames;
1:   private Set<String> importPackages;
1:   private Set<String> exemptPackages;
1:   private Map<String, Manifest> manifests; 
1:   private ArrayList<String> classPath;
1:   
0:   private IFile warFile;
1: 
0:   public WarToWabConverter(IFile warFile, Properties properties) throws IOException {
1:     this.properties = properties;
0:     fileNames = new ArrayList<String>();
1:     classPath = new ArrayList<String>();
0:     importPackages = new HashSet<String>();
0:     exemptPackages = new HashSet<String>();
0:     this.warFile = warFile;
0:     this.warName = warFile.getName();
1:   }
1:   
0:   private void convert() throws IOException {
1: 
1:     ZipEntry entry;
1:     JarInputStream jarInput = null;
1: 
0:     Manifest manifest;
1:     try {
0:       jarInput = new JarInputStream(warFile.open());
0:       scanForDependencies(jarInput);
1: 
0:       // Add the new properties to the manifest byte stream
0:       manifest = jarInput.getManifest();
0:       manifest = updateManifest(manifest);
1:     } 
1:     finally {
1:       try { if (jarInput != null) jarInput.close(); } catch (IOException e) { e.printStackTrace(); }
1:     }
1: 
0:     // Create a new jar file in memory with the new manifest and the old data
0:     ByteArrayOutputStream output = new ByteArrayOutputStream();
1:     JarOutputStream jarOutput = null;
0:     jarInput = null;
1: 
1:     // Copy across all entries from the original jar
1:     int val;
1:     try {
0:       jarOutput = new JarOutputStream(output, manifest);
0:       jarInput = new JarInputStream(warFile.open());
1:       while ((entry = jarInput.getNextEntry()) != null) {
0:         jarOutput.putNextEntry(entry);
0:         while ((val = jarInput.read()) != -1)
0:           jarOutput.write(val);
1:       }
1:     }
1:     finally {
0:       if (jarOutput != null)
1:         jarOutput.close();
0:       if (jarInput != null)
1:         jarInput.close();
1:     }
1: 
0:     // Create a stream to the in-memory jar
0:     wabFile = output.toByteArray();
1:   }
1: 
1:   private void scanRecursive(final JarInputStream jarInput, boolean topLevel) throws IOException 
1:   {
1:     ZipEntry entry;
1:     
1:     while ((entry = jarInput.getNextEntry()) != null) {
0:       fileNames.add(entry.getName());
1:       if (entry.getName().endsWith(".class")) {
1:         PackageFinder pkgFinder = new PackageFinder();
1:         new ClassReader(jarInput).accept(pkgFinder, ClassReader.SKIP_DEBUG);
1: 
1:         importPackages.addAll(pkgFinder.getImportPackages());
1:         exemptPackages.addAll(pkgFinder.getExemptPackages());
1:       } else if (entry.getName().endsWith(".jsp")) { 
1:         Collection<String> thisJSPsImports = JSPImportParser.getImports(jarInput);
1:         importPackages.addAll(thisJSPsImports);
1:       } else if (entry.getName().endsWith(".jar")) {
1:         
1:         JarInputStream newJar = new JarInputStream(new InputStream() {
1:           @Override
1:           public int read() throws IOException
1:           {
1:             return jarInput.read();
1:           }
1:         });
1:         
1:         // discard return, we only care about the top level jars
1:         scanRecursive(newJar,false);
1:         
1:         // do not add jar embedded in already embedded jars
1:         if (topLevel) {
1:           manifests.put(entry.getName(), newJar.getManifest());
1:         }
1:       }
1:     }
1:   }
1:   
1:   /**
1:    * 
1:    * Read in the filenames inside the war (used for manifest update) Also
1:    * analyse the bytecode of any .class files in order to find any required
1:    * imports
1:    */
1:   private void scanForDependencies(final JarInputStream jarInput) throws IOException 
1:   {
1:     manifests = new HashMap<String, Manifest>();
1:     
1:     scanRecursive(jarInput, true);
1: 
1:     // Process manifests from jars in order to work out classpath dependencies
1:     ClassPathBuilder classPathBuilder = new ClassPathBuilder(manifests);
1:     for (String fileName : manifests.keySet())
0:       if (fileName.startsWith("WEB-INF/lib")) {
1:         classPath.add(fileName);
1:         classPath = classPathBuilder.updatePath(fileName, classPath);
1:       }
1:         
1:     // Remove packages that are part of the classes we searched through
1:     for (String s : exemptPackages)
1:       if (importPackages.contains(s))
1:         importPackages.remove(s);
1:   }
1: 
1:   protected Manifest updateManifest(Manifest manifest) throws IOException
1:   {
1:     // If for some reason no manifest was generated, we start our own so that we don't null pointer later on
1:     if (manifest == null) {
1:       manifest = new Manifest();
1:       manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1");
1:     }
1:     
1:     // Compare the manifest and the supplied properties
1: 
1:     //
1:     // Bundle-Version
1:     //
1: 
1:     if (manifest.getMainAttributes().getValue(Constants.BUNDLE_VERSION) == null
1:         && !properties.containsKey(Constants.BUNDLE_VERSION)) {
1:       properties.put(Constants.BUNDLE_VERSION, DEFAULT_BUNDLE_VERSION);
1:     }
1: 
1:     //
1:     // Bundle-ManifestVersion
1:     //
1: 
0:     if (manifest.getMainAttributes().getValue(Constants.BUNDLE_MANIFESTVERSION) == null
0:         && !properties.containsKey(Constants.BUNDLE_MANIFESTVERSION)) {
0:       properties.put(Constants.BUNDLE_MANIFESTVERSION,
0:           DEFAULT_BUNDLE_MANIFESTVERSION);
1:     }
1: 
1:     //
0:     // Bundle-SymbolicName
1:     //
1: 
0:     if (manifest.getMainAttributes().getValue(Constants.BUNDLE_SYMBOLICNAME) == null
0:         && !properties.containsKey(Constants.BUNDLE_SYMBOLICNAME)) {
0:       properties.put(Constants.BUNDLE_SYMBOLICNAME, warName + "_"
0:           + manifest.hashCode());
1:     }
1: 
1:     // 
1:     // Bundle-ClassPath
1:     //
1: 
1:     ArrayList<String> classpath = new ArrayList<String>();
1: 
1:     // Set initial entry into classpath
0:     classpath.add(0, INITIAL_CLASSPATH_ENTRY);
1: 
1:     // Add any files from the WEB-INF/lib directory + their dependencies
1:     classpath.addAll(classPath);
1:     
0:     for (String s : fileNames)
0:       if (s.startsWith(CLASSPATH_LIB_PREFIX) && !classpath.contains(s))
0:         classpath.add(s);
1: 
1:     // Get the list from the URL and add to classpath (removing duplicates)
0:     mergePathList(properties.getProperty(Constants.BUNDLE_CLASSPATH),
0:         classpath, ";");
1: 
1:     // Get the existing list from the manifest file and add to classpath
1:     // (removing duplicates)
0:     mergePathList(manifest.getMainAttributes().getValue(
0:         Constants.BUNDLE_CLASSPATH), classpath, ";");
1: 
1:     // Construct the classpath string and set it into the properties
1:     StringBuffer classPathValue = new StringBuffer();
1:     for (String entry : classpath) {
0:       classPathValue.append(";");
1:       classPathValue.append(entry);
1:     }
1: 
0:     if (!classpath.isEmpty())
0:       properties.put(Constants.BUNDLE_CLASSPATH, classPathValue.toString()
0:           .substring(1));
1: 
1:     ArrayList<String> packages = new ArrayList<String>() {
1:       @Override
1:       public boolean contains(Object elem) {
1:         // Check for exact match of export list
1:         if (super.contains(elem))
1:           return true;
1: 
1:         if (!!!(elem instanceof String))
1:           return false;
1: 
1:         String expPackageStmt = (String) elem;
1:         String expPackage = expPackageStmt.split("\\s*;\\s*")[0];
1:         
1:         Pattern p = Pattern.compile("^\\s*"+Pattern.quote(expPackage)+"((;|\\s).*)?\\s*$");
1:         for (String s : this) {
1:           Matcher m = p.matcher(s);
1:           if (m.matches()) {
1:             return true;
1:           }
1:         }
1: 
1:         return false;
1:       }
1: 
1:     };
1:     
1:     //
1:     // Import-Package
1:     //
1:     packages.clear();
1: 
1:     // Get the list from the URL and add to classpath (removing duplicates)
0:     mergePathList(properties.getProperty(Constants.IMPORT_PACKAGE), packages,
0:         ",");
1: 
1:     // Get the existing list from the manifest file and add to classpath
1:     // (removing duplicates)
0:     mergePathList(manifest.getMainAttributes().getValue(
0:         Constants.IMPORT_PACKAGE), packages, ",");
1: 
1:     // Add the default set of packages
1:     mergePathList(DEFAULT_IMPORT_PACKAGE_LIST, packages, ",");
1: 
1:     // Analyse the bytecode of any .class files in the jar to find any other
1:     // required imports
1:     if (!!!importPackages.isEmpty()) {
1:       StringBuffer generatedImports = new StringBuffer();
1:       for (String entry : importPackages) {
1:         generatedImports.append(',');
1:         generatedImports.append(entry);
1:         generatedImports.append(";resolution:=optional");
1:       }      
1:       
1:       mergePathList(generatedImports.substring(1), packages, ",");
1:     }
1: 
1:     // Construct the string and set it into the properties
1:     StringBuffer importValues = new StringBuffer();
1:     for (String entry : packages) {
1:       importValues.append(",");
1:       importValues.append(entry);
1:     }
0:     if (!packages.isEmpty())
0:       properties.put(Constants.IMPORT_PACKAGE, importValues.toString()
0:           .substring(1));
1: 
1:     //
0:     // Web-ContextPath
1:     //
1: 
0:     String webCPath = manifest.getMainAttributes().getValue(WEB_CONTEXT_PATH);
0:     if (webCPath != null)
1:     {
0:       if (!webCPath.startsWith(DEFAULT_WEB_CONTEXT_PATH))
1:       {
0:           webCPath = DEFAULT_WEB_CONTEXT_PATH + webCPath;
0:           properties.put(WEB_CONTEXT_PATH, webCPath);
1:       }
1:     }
0:     else if ( !properties.containsKey(WEB_CONTEXT_PATH)) {
0:       properties.put(WEB_CONTEXT_PATH, DEFAULT_WEB_CONTEXT_PATH);
1:     }
1: 
1:     //
0:     // Web-JSPExtractLocation
1:     //
1: 
0:     if (manifest.getMainAttributes().getValue(WEB_JSP_EXTRACT_LOCATION) == null
0:         && !properties.containsKey(WEB_JSP_EXTRACT_LOCATION)) {
0:       properties
0:           .put(WEB_JSP_EXTRACT_LOCATION, DEFAULT_WEB_JSP_EXTRACT_LOCATION);
1:     }
1: 
1:     // Take the properties map and add them to the manifest file
0:     for (Object s : properties.keySet())
0:       manifest.getMainAttributes().put(new Attributes.Name((String) s), properties.get(s));
1:     
1:     return manifest;
1:   }
1: 
1:   // pathlist = A "delim" delimitted list of path entries
0:   public static void mergePathList(String pathlist, ArrayList<String> classpath,
0:       String delim) {
0:     if (pathlist != null) {
0:       StringTokenizer tok = new StringTokenizer(pathlist, delim);
0:       while (tok.hasMoreTokens()) {
0:         String token = tok.nextToken().trim();
0:         if (!classpath.contains(token))
0:           classpath.add(token);
1:       }
1:     }
1:   }
1: 
1:   public InputStream getWAB() throws IOException {
0:     if (!!!converted) {
0:       convert();
0:       converted = true;
1:     }
1:     
0:     return new ByteArrayInputStream(wabFile);
1:   }
1: 
1:   public int getWabLength() throws IOException {
0:     if (!!!converted) {
0:       convert();
0:       converted = true;
1:     }
1: 
0:     return wabFile.length;
1:   }
1: 
1: }
============================================================================