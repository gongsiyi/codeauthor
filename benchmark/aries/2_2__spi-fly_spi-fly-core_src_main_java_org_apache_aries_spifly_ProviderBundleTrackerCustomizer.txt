1:1c43780: /**
1:1c43780:  * Licensed to the Apache Software Foundation (ASF) under one
1:1c43780:  * or more contributor license agreements.  See the NOTICE file
1:1c43780:  * distributed with this work for additional information
1:1c43780:  * regarding copyright ownership.  The ASF licenses this file
1:1c43780:  * to you under the Apache License, Version 2.0 (the
1:1c43780:  * "License"); you may not use this file except in compliance
1:1c43780:  * with the License.  You may obtain a copy of the License at
1:1c43780:  *
1:1c43780:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1c43780:  *
1:1c43780:  * Unless required by applicable law or agreed to in writing,
1:1c43780:  * software distributed under the License is distributed on an
1:1c43780:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:1c43780:  * KIND, either express or implied.  See the License for the
1:1c43780:  * specific language governing permissions and limitations
1:1c43780:  * under the License.
1:a166d95:  */
1:1c43780: package org.apache.aries.spifly;
1:b1578c3: 
1:1c43780: import java.io.BufferedReader;
1:3f2be6b: import java.io.IOException;
1:1c43780: import java.io.InputStreamReader;
1:1c43780: import java.net.URL;
1:1c43780: import java.util.ArrayList;
1:708d00a: import java.util.Arrays;
1:a166d95: import java.util.Collection;
1:3f2be6b: import java.util.Collections;
1:3e50f86: import java.util.Dictionary;
1:1c43780: import java.util.Enumeration;
1:708d00a: import java.util.HashMap;
1:1c43780: import java.util.Hashtable;
1:1c43780: import java.util.List;
1:708d00a: import java.util.Map;
1:3f2be6b: import java.util.jar.JarEntry;
1:3f2be6b: import java.util.jar.JarInputStream;
1:b1578c3: 
1:708d00a: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1:708d00a: import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
1:1c43780: import org.osgi.framework.Bundle;
1:1c43780: import org.osgi.framework.BundleEvent;
1:3f2be6b: import org.osgi.framework.Constants;
1:a166d95: import org.osgi.framework.Filter;
1:a166d95: import org.osgi.framework.FrameworkUtil;
1:a166d95: import org.osgi.framework.InvalidSyntaxException;
1:6826a3a: import org.osgi.framework.ServicePermission;
1:1c43780: import org.osgi.framework.ServiceRegistration;
1:7dabe8c: import org.osgi.framework.wiring.BundleRevision;
1:7dabe8c: import org.osgi.framework.wiring.BundleWire;
1:7dabe8c: import org.osgi.framework.wiring.BundleWiring;
1:1c43780: import org.osgi.service.log.LogService;
1:1c43780: import org.osgi.util.tracker.BundleTrackerCustomizer;
1:b1578c3: 
1:1c43780: /**
1:1c43780:  * Listens for new bundles being installed and registers them as service providers if applicable.
2:1c43780:  */
1:4b6c670: public class ProviderBundleTrackerCustomizer implements BundleTrackerCustomizer {
1:3f2be6b:     private static final String METAINF_SERVICES = "META-INF/services";
1:b1578c3: 
1:b1379cb:     final BaseActivator activator;
1:1c43780:     final Bundle spiBundle;
1:b1578c3: 
1:b1578c3:     public ProviderBundleTrackerCustomizer(BaseActivator activator, Bundle spiBundle) {
1:b1578c3:         this.activator = activator;
1:b1578c3:         this.spiBundle = spiBundle;
1:2276d43:     }
1:a166d95: 
1:6826a3a:     public List<ServiceRegistration> addingBundle(final Bundle bundle, BundleEvent event) {
1:c38b26e:         log(LogService.LOG_DEBUG, "Bundle Considered for SPI providers: "
1:1c43780:                 + bundle.getSymbolicName());
1:a34a6c6: 
1:a34a6c6:         if (bundle.equals(spiBundle))
1:a34a6c6:             return null; // don't process the SPI bundle itself
1:a166d95: 
1:3e50f86:         List<String> providedServices = null;
1:708d00a:         Map<String, Object> customAttributes = new HashMap<String, Object>();
1:5e6f679:         if (bundle.getHeaders().get(SpiFlyConstants.REQUIRE_CAPABILITY) != null) {
1:a166d95:             try {
1:7dabe8c:                 providedServices = readServiceLoaderMediatorCapabilityMetadata(bundle, customAttributes);
1:a166d95:             } catch (InvalidSyntaxException e) {
1:a166d95:                 log(LogService.LOG_ERROR, "Unable to read capabilities from bundle " + bundle, e);
1:a166d95:             }
1:a166d95:         }
1:76c890d: 
1:a166d95:         boolean fromSPIProviderHeader = false;
1:7dabe8c:         String spiProviderHeader = getHeaderFromBundleOrFragment(bundle, SpiFlyConstants.SPI_PROVIDER_HEADER);
1:7dabe8c:         if (providedServices == null && spiProviderHeader != null) {
1:7dabe8c:             String header = spiProviderHeader.trim();
1:7158c23:             if ("*".equals(header)) {
1:7158c23:                 providedServices = new ArrayList<String>();
1:7158c23:             } else {
1:7158c23:                 providedServices = Arrays.asList(header.split(","));
1:7158c23:             }
1:a166d95:             fromSPIProviderHeader = true;
1:3e50f86:         }
1:76c890d: 
1:3e50f86:         if (providedServices == null) {
1:c38b26e:             log(LogService.LOG_DEBUG, "No '"
1:1c43780:                     + SpiFlyConstants.SPI_PROVIDER_HEADER
1:1c43780:                     + "' Manifest header. Skipping bundle: "
1:1c43780:                     + bundle.getSymbolicName());
1:a166d95:             return null;
1:708d00a:         } else {
1:1c43780:             log(LogService.LOG_INFO, "Examining bundle for SPI provider: "
1:1c43780:                     + bundle.getSymbolicName());
1:a166d95:         }
1:a166d95: 
1:7158c23:         for (String svc : providedServices) {
1:7158c23:             // Eagerly register any services that are explicitly listed, as they may not be found in META-INF/services
1:7158c23:             activator.registerProviderBundle(svc, bundle, customAttributes);
1:7158c23:         }
1:a166d95: 
1:a166d95:         List<URL> serviceFileURLs = new ArrayList<URL>();
1:7158c23: 
1:708d00a:         @SuppressWarnings("unchecked")
1:3f2be6b:         Enumeration<URL> entries = bundle.findEntries(METAINF_SERVICES, "*", false);
1:3f2be6b:         if (entries != null) {
1:a166d95:             serviceFileURLs.addAll(Collections.list(entries));
1:76c890d:         }
1:76c890d: 
1:3f2be6b:         Object bcp = bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);
1:3f2be6b:         if (bcp instanceof String) {
1:3f2be6b:             for (String entry : ((String) bcp).split(",")) {
1:3f2be6b:                 entry = entry.trim();
1:b1578c3:                 if (entry.equals("."))
2:5e6f679:                     continue;
1:3e50f86: 
1:3f2be6b:                 URL url = bundle.getResource(entry);
1:3f2be6b:                 if (url != null) {
1:a166d95:                     serviceFileURLs.addAll(getMetaInfServiceURLsFromJar(url));
1:3e50f86:                 }
1:b1578c3:             }
1:3f2be6b:         }
1:b1578c3: 
1:6826a3a:         final List<ServiceRegistration> registrations = new ArrayList<ServiceRegistration>();
1:a166d95:         for (URL serviceFileURL : serviceFileURLs) {
1:a166d95:             log(LogService.LOG_INFO, "Found SPI resource: " + serviceFileURL);
1:b1578c3: 
1:1c43780:             try {
1:1c43780:                 BufferedReader reader = new BufferedReader(
1:a166d95:                         new InputStreamReader(serviceFileURL.openStream()));
1:b1578c3:                 String className = null;
1:b1578c3:                 while((className = reader.readLine()) != null) {
1:3e50f86:                     try {
1:c69c410:                         className = className.trim();
1:c69c410: 
1:c69c410:                         if (className.length() == 0)
1:c69c410:                             continue; // empty line
1:c69c410: 
1:3e50f86:                         if (className.startsWith("#"))
1:3e50f86:                             continue; // a comment
1:3e50f86: 
1:a166d95:                         String serviceFile = serviceFileURL.toExternalForm();
1:a166d95:                         int idx = serviceFile.lastIndexOf('/');
1:708d00a:                         String registrationClassName = className;
1:a166d95:                         if (serviceFile.length() > idx) {
1:a166d95:                             registrationClassName = serviceFile.substring(idx + 1);
1:708d00a:                         }
1:6826a3a: 
1:708d00a:                         if (providedServices.size() > 0 && !providedServices.contains(registrationClassName))
1:5e6f679:                             continue;
1:708d00a: 
1:6826a3a:                         final Class<?> cls = bundle.loadClass(className);
1:c69c410:                         log(LogService.LOG_INFO, "Loaded SPI provider: " + cls);
1:3e50f86: 
1:6826a3a:                         final Hashtable<String, Object> properties;
1:a166d95:                         if (fromSPIProviderHeader)
1:a166d95:                             properties = new Hashtable<String, Object>();
1:a166d95:                         else
1:a166d95:                             properties = findServiceRegistrationProperties(bundle.getHeaders(), registrationClassName, className);
1:3e50f86: 
1:a166d95:                         if (properties != null) {
1:82e8b21:                             properties.put(SpiFlyConstants.SERVICELOADER_MEDIATOR_PROPERTY, spiBundle.getBundleId());
1:c69c410:                             properties.put(SpiFlyConstants.PROVIDER_IMPLCLASS_PROPERTY, cls.getName());
1:6826a3a: 
1:6826a3a:                             ServiceRegistration reg = null;
1:6826a3a:                             SecurityManager sm = System.getSecurityManager();
1:6826a3a:                             if (sm != null) {
1:6826a3a:                                 if (bundle.hasPermission(new ServicePermission(registrationClassName, ServicePermission.REGISTER))) {
1:6826a3a:                                     reg = bundle.getBundleContext().registerService(
1:6826a3a:                                             registrationClassName, new ProviderServiceFactory(cls), properties);
1:6826a3a:                                 } else {
1:6826a3a:                                     log(LogService.LOG_INFO, "Bundle " + bundle + " does not have the permission to register services of type: " + registrationClassName);
1:6826a3a:                                 }
1:6826a3a:                             } else {
1:6826a3a:                                 reg = bundle.getBundleContext().registerService(
1:6826a3a:                                         registrationClassName, new ProviderServiceFactory(cls), properties);
1:6826a3a:                             }
1:6826a3a: 
1:6826a3a:                             if (reg != null) {
1:6826a3a:                                 registrations.add(reg);
1:6826a3a:                                 log(LogService.LOG_INFO, "Registered service: " + reg);
1:6826a3a:                             }
1:76c890d:                         }
1:b1578c3: 
1:708d00a:                         activator.registerProviderBundle(registrationClassName, bundle, customAttributes);
1:76c890d:                         log(LogService.LOG_INFO, "Registered provider: " + registrationClassName + " in bundle " + bundle.getSymbolicName());
1:3e50f86:                     } catch (Exception e) {
1:3e50f86:                         log(LogService.LOG_WARNING,
1:a166d95:                                 "Could not load SPI implementation referred from " + serviceFileURL, e);
1:3e50f86:                     }
1:3f2be6b:                 }
1:3e50f86:             } catch (IOException e) {
1:a166d95:                 log(LogService.LOG_WARNING, "Could not read SPI metadata from " + serviceFileURL, e);
1:3f2be6b:             }
3:3f2be6b:         }
1:3e50f86: 
1:1c43780:         return registrations;
1:3e50f86:     }
1:3e50f86: 
1:7dabe8c:     private String getHeaderFromBundleOrFragment(Bundle bundle, String headerName) {
1:7dabe8c:         return getHeaderFromBundleOrFragment(bundle, headerName, null);
1:7dabe8c:     }
1:7dabe8c: 
1:7dabe8c:     private String getHeaderFromBundleOrFragment(Bundle bundle, String headerName, String matchString) {
1:7dabe8c:         String val = bundle.getHeaders().get(headerName);
1:7dabe8c:         if (matches(val, matchString))
1:7dabe8c:             return val;
1:7dabe8c: 
1:7dabe8c:         BundleRevision rev = bundle.adapt(BundleRevision.class);
1:7dabe8c:         if (rev != null) {
1:7dabe8c:             BundleWiring wiring = rev.getWiring();
1:7dabe8c:             if (wiring != null) {
1:7dabe8c:                 for (BundleWire wire : wiring.getProvidedWires("osgi.wiring.host")) {
1:7dabe8c:                     Bundle fragment = wire.getRequirement().getRevision().getBundle();
1:7dabe8c:                     val = fragment.getHeaders().get(headerName);
1:7dabe8c:                     if (matches(val, matchString)) {
1:7dabe8c:                         return val;
1:7dabe8c:                     }
1:7dabe8c:                 }
1:7dabe8c:             }
1:7dabe8c:         }
1:7dabe8c: 
1:7dabe8c:         return null;
1:7dabe8c:     }
1:7dabe8c: 
1:7dabe8c:     private boolean matches(String val, String matchString) {
1:7dabe8c:         if (val == null)
1:7dabe8c:             return false;
1:7dabe8c: 
1:7dabe8c:         if (matchString == null)
1:7dabe8c:             return true;
1:7dabe8c: 
1:7dabe8c:         int idx = val.indexOf(matchString);
1:7dabe8c:         return idx >= 0;
1:7dabe8c:     }
1:7dabe8c: 
1:3e50f86:     // An empty list returned means 'all SPIs'
1:3e50f86:     // A return value of null means no SPIs
1:3e50f86:     // A populated list means: only these SPIs
1:7dabe8c:     private List<String> readServiceLoaderMediatorCapabilityMetadata(Bundle bundle, Map<String, Object> customAttributes) throws InvalidSyntaxException {
1:7dabe8c:         String requirementHeader = getHeaderFromBundleOrFragment(bundle, SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE);
1:a166d95:         if (requirementHeader == null)
1:a166d95:             return null;
1:a166d95: 
1:7dabe8c:         List<GenericMetadata> requirements = ManifestHeaderProcessor.parseRequirementString(requirementHeader);
1:8d934f9:         GenericMetadata extenderRequirement = findRequirement(requirements, SpiFlyConstants.EXTENDER_CAPABILITY_NAMESPACE, SpiFlyConstants.REGISTRAR_EXTENDER_NAME);
1:a166d95:         if (extenderRequirement == null)
1:a166d95:             return null;
1:a166d95: 
1:a166d95:         List<GenericMetadata> capabilities;
1:7dabe8c:         String capabilityHeader = getHeaderFromBundleOrFragment(bundle, SpiFlyConstants.PROVIDE_CAPABILITY, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE);
1:a166d95:         if (capabilityHeader == null) {
1:a166d95:             capabilities = Collections.emptyList();
1:a166d95:         } else {
1:7dabe8c:             capabilities = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader);
1:a166d95:         }
1:a166d95: 
1:a166d95:         List<String> serviceNames = new ArrayList<String>();
1:a166d95:         for (GenericMetadata serviceLoaderCapability : findAllMetadata(capabilities, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE)) {
1:a166d95:             for (Map.Entry<String, Object> entry : serviceLoaderCapability.getAttributes().entrySet()) {
1:a166d95:                 if (SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE.equals(entry.getKey())) {
1:a166d95:                     serviceNames.add(entry.getValue().toString());
1:a166d95:                     continue;
1:a166d95:                 }
1:a166d95: 
1:a166d95:                 customAttributes.put(entry.getKey(), entry.getValue());
1:a166d95:             }
1:a166d95:         }
1:a166d95:         return serviceNames;
1:a166d95:     }
1:a166d95: 
1:a166d95:     // null means don't register,
1:a166d95:     // otherwise the return value should be taken as the service registration properties
1:a166d95:     private Hashtable<String, Object> findServiceRegistrationProperties(Dictionary<?,?> headers, String spiName, String implName) {
1:a166d95:         Object capabilityHeader = headers.get(SpiFlyConstants.PROVIDE_CAPABILITY);
1:a166d95:         if (capabilityHeader == null)
1:a166d95:             return null;
1:a166d95: 
1:a166d95:         List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader.toString());
1:a166d95:         GenericMetadata cap = findCapability(capabilities, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE, spiName);
1:a166d95: 
1:a166d95:         Hashtable<String, Object> properties = new Hashtable<String, Object>();
1:a166d95:         if (cap != null) {
1:a166d95:             for (Map.Entry<String, Object> entry : cap.getAttributes().entrySet()) {
1:a166d95:                 if (SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE.equals(entry.getKey()))
1:a166d95:                     continue;
1:a166d95: 
1:489cf73:                 if (!entry.getKey().startsWith("."))
1:489cf73:                     properties.put(entry.getKey(), entry.getValue());
1:a166d95:             }
1:a166d95:         }
1:a166d95: 
1:a166d95:         String registerDirective = cap.getDirectives().get(SpiFlyConstants.REGISTER_DIRECTIVE);
1:a166d95:         if (registerDirective == null) {
2:a166d95:             return properties;
1:a166d95:         } else {
1:a166d95:             if ("".equals(registerDirective.trim()))
1:a166d95:                 return null;
1:a166d95: 
1:a166d95:             if (implName.equals(registerDirective.trim()))
1:a166d95:                 return properties;
1:a166d95:         }
1:a166d95:         return null;
1:3e50f86:     }
1:a166d95: 
1:3f2be6b:     private List<URL> getMetaInfServiceURLsFromJar(URL url) {
1:3f2be6b:         List<URL> urls = new ArrayList<URL>();
1:3f2be6b:         try {
1:3f2be6b:             JarInputStream jis = null;
1:3f2be6b:             try {
1:3f2be6b:                 jis = new JarInputStream(url.openStream());
1:3e50f86: 
1:3f2be6b:                 JarEntry je = null;
1:3f2be6b:                 while((je = jis.getNextJarEntry()) != null) {
1:3f2be6b:                     if (je.getName().startsWith(METAINF_SERVICES) &&
1:b1578c3:                         je.getName().length() > (METAINF_SERVICES.length() + 1)) {
1:3f2be6b:                         urls.add(new URL("jar:" + url + "!/" + je.getName()));
1:3e50f86:                     }
1:3e50f86:                 }
1:3f2be6b:             } finally {
1:3f2be6b:                 if (jis != null) {
1:3f2be6b:                     jis.close();
1:3e50f86:                 }
1:3f2be6b:             }
1:3f2be6b:         } catch (IOException e) {
1:5e890d0:             log(LogService.LOG_ERROR, "Problem opening embedded jar file: " + url, e);
1:3f2be6b:         }
1:3f2be6b:         return urls;
1:3f2be6b:     }
1:3e50f86: 
1:782066c:     private GenericMetadata findCapability(List<GenericMetadata> capabilities, String namespace, String spiName) {
1:782066c:         for (GenericMetadata cap : capabilities) {
1:782066c:             if (namespace.equals(cap.getNamespace())) {
1:782066c:                 if (spiName.equals(cap.getAttributes().get(namespace))) {
1:782066c:                     return cap;
1:782066c:                 }
1:782066c:             }
1:782066c:         }
1:782066c:         return null;
1:782066c:     }
1:782066c: 
1:744fda1:     private static Collection<GenericMetadata> findAllMetadata(List<GenericMetadata> requirementsOrCapabilities, String namespace) {
1:744fda1:         List<GenericMetadata> reqsCaps = new ArrayList<ManifestHeaderProcessor.GenericMetadata>();
1:744fda1:         for (GenericMetadata reqCap : requirementsOrCapabilities) {
1:744fda1:             if (namespace.equals(reqCap.getNamespace())) {
1:744fda1:                 reqsCaps.add(reqCap);
1:782066c:             }
1:782066c:         }
1:744fda1:         return reqsCaps;
1:782066c:     }
1:782066c: 
1:4b6c670:     public void modifiedBundle(Bundle bundle, BundleEvent event, Object registrations) {
1:1c43780:         // should really be doing something here...
1:a166d95:     }
1:5e6f679: 
1:3f2be6b:     @SuppressWarnings("unchecked")
1:4b6c670:     public void removedBundle(Bundle bundle, BundleEvent event, Object registrations) {
1:9644284:         activator.unregisterProviderBundle(bundle);
1:9644284: 
1:1c43780:         if (registrations == null)
1:1c43780:             return;
1:5e6f679: 
1:4b6c670:         for (ServiceRegistration reg : (List<ServiceRegistration>) registrations) {
1:1c43780:             reg.unregister();
1:b1578c3:             log(LogService.LOG_INFO, "Unregistered: " + reg);
1:a166d95:         }
1:a166d95:     }
1:5e6f679: 
1:1c43780:     private void log(int level, String message) {
1:1c43780:         activator.log(level, message);
1:5e6f679:     }
1:b1578c3: 
1:1c43780:     private void log(int level, String message, Throwable th) {
1:1c43780:         activator.log(level, message, th);
1:a166d95:     }
1:b1578c3: 
1:a166d95:     private static GenericMetadata findRequirement(List<GenericMetadata> requirements, String namespace, String type) throws InvalidSyntaxException {
1:a166d95:         Dictionary<String, String> nsAttr = new Hashtable<String, String>();
1:a166d95:         nsAttr.put(namespace, type);
1:a166d95: 
1:782066c:         for (GenericMetadata req : requirements) {
1:782066c:             if (namespace.equals(req.getNamespace())) {
1:a166d95:                 String filterString = req.getDirectives().get(SpiFlyConstants.FILTER_DIRECTIVE);
1:a166d95:                 if (filterString != null) {
1:a166d95:                     Filter filter = FrameworkUtil.createFilter(filterString);
1:a166d95:                     if (filter.match(nsAttr)) {
1:a166d95:                         return req;
1:a166d95:                     }
1:a166d95:                 }
1:a166d95:             }
1:a166d95:         }
1:a166d95:         return null;
1:a166d95:     }
1:a166d95: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:c38b26e
/////////////////////////////////////////////////////////////////////////
1:         log(LogService.LOG_DEBUG, "Bundle Considered for SPI providers: "
/////////////////////////////////////////////////////////////////////////
1:             log(LogService.LOG_DEBUG, "No '"
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:7dabe8c
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.framework.wiring.BundleWire;
1: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
1:                 providedServices = readServiceLoaderMediatorCapabilityMetadata(bundle, customAttributes);
1:         String spiProviderHeader = getHeaderFromBundleOrFragment(bundle, SpiFlyConstants.SPI_PROVIDER_HEADER);
1:         if (providedServices == null && spiProviderHeader != null) {
1:             String header = spiProviderHeader.trim();
/////////////////////////////////////////////////////////////////////////
1:     private String getHeaderFromBundleOrFragment(Bundle bundle, String headerName) {
1:         return getHeaderFromBundleOrFragment(bundle, headerName, null);
1:     }
1: 
1:     private String getHeaderFromBundleOrFragment(Bundle bundle, String headerName, String matchString) {
1:         String val = bundle.getHeaders().get(headerName);
1:         if (matches(val, matchString))
1:             return val;
1: 
1:         BundleRevision rev = bundle.adapt(BundleRevision.class);
1:         if (rev != null) {
1:             BundleWiring wiring = rev.getWiring();
1:             if (wiring != null) {
1:                 for (BundleWire wire : wiring.getProvidedWires("osgi.wiring.host")) {
1:                     Bundle fragment = wire.getRequirement().getRevision().getBundle();
1:                     val = fragment.getHeaders().get(headerName);
1:                     if (matches(val, matchString)) {
1:                         return val;
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         return null;
1:     }
1: 
1:     private boolean matches(String val, String matchString) {
1:         if (val == null)
1:             return false;
1: 
1:         if (matchString == null)
1:             return true;
1: 
1:         int idx = val.indexOf(matchString);
1:         return idx >= 0;
1:     }
1: 
1:     private List<String> readServiceLoaderMediatorCapabilityMetadata(Bundle bundle, Map<String, Object> customAttributes) throws InvalidSyntaxException {
1:         String requirementHeader = getHeaderFromBundleOrFragment(bundle, SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE);
1:         List<GenericMetadata> requirements = ManifestHeaderProcessor.parseRequirementString(requirementHeader);
1:         String capabilityHeader = getHeaderFromBundleOrFragment(bundle, SpiFlyConstants.PROVIDE_CAPABILITY, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE);
1:             capabilities = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader);
commit:aaba413
/////////////////////////////////////////////////////////////////////////
commit:7904fa4
/////////////////////////////////////////////////////////////////////////
commit:6826a3a
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.ServicePermission;
/////////////////////////////////////////////////////////////////////////
1:     public List<ServiceRegistration> addingBundle(final Bundle bundle, BundleEvent event) {
/////////////////////////////////////////////////////////////////////////
1:         final List<ServiceRegistration> registrations = new ArrayList<ServiceRegistration>();
/////////////////////////////////////////////////////////////////////////
1: 
1:                         final Class<?> cls = bundle.loadClass(className);
1:                         final Hashtable<String, Object> properties;
/////////////////////////////////////////////////////////////////////////
1: 
1:                             ServiceRegistration reg = null;
1:                             SecurityManager sm = System.getSecurityManager();
1:                             if (sm != null) {
1:                                 if (bundle.hasPermission(new ServicePermission(registrationClassName, ServicePermission.REGISTER))) {
0:                                     System.err.println("*** Found security manager and bundle has permission to register: " + bundle);
1:                                     reg = bundle.getBundleContext().registerService(
1:                                             registrationClassName, new ProviderServiceFactory(cls), properties);
1:                                 } else {
0:                                     System.err.println("*** Found security manager and bundle has NO permission to register: " + bundle);
1:                                     log(LogService.LOG_INFO, "Bundle " + bundle + " does not have the permission to register services of type: " + registrationClassName);
1:                                 }
1:                             } else {
1:                                 reg = bundle.getBundleContext().registerService(
1:                                         registrationClassName, new ProviderServiceFactory(cls), properties);
1:                             }
1: 
1:                             if (reg != null) {
1:                                 registrations.add(reg);
1:                                 log(LogService.LOG_INFO, "Registered service: " + reg);
1:                             }
commit:e9a5257
/////////////////////////////////////////////////////////////////////////
commit:9644284
/////////////////////////////////////////////////////////////////////////
1:         activator.unregisterProviderBundle(bundle);
1: 
commit:c69c410
/////////////////////////////////////////////////////////////////////////
1:                         className = className.trim();
1: 
1:                         if (className.length() == 0)
1:                             continue; // empty line
1: 
/////////////////////////////////////////////////////////////////////////
1:                         log(LogService.LOG_INFO, "Loaded SPI provider: " + cls);
/////////////////////////////////////////////////////////////////////////
1:                             properties.put(SpiFlyConstants.PROVIDER_IMPLCLASS_PROPERTY, cls.getName());
0:                             ServiceRegistration reg = bundle.getBundleContext().registerService(
0:                                 registrationClassName, new ProviderServiceFactory(cls), properties);
commit:489cf73
/////////////////////////////////////////////////////////////////////////
1:                 if (!entry.getKey().startsWith("."))
1:                     properties.put(entry.getKey(), entry.getValue());
commit:744fda1
/////////////////////////////////////////////////////////////////////////
0:                 providedServices = readServiceLoaderMediatorCapabilityMetadata(bundle.getHeaders(), customAttributes);
/////////////////////////////////////////////////////////////////////////
0:     private List<String> readServiceLoaderMediatorCapabilityMetadata(Dictionary<?,?> headers, Map<String, Object> customAttributes) throws InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static Collection<GenericMetadata> findAllMetadata(List<GenericMetadata> requirementsOrCapabilities, String namespace) {
1:         List<GenericMetadata> reqsCaps = new ArrayList<ManifestHeaderProcessor.GenericMetadata>();
1:         for (GenericMetadata reqCap : requirementsOrCapabilities) {
1:             if (namespace.equals(reqCap.getNamespace())) {
1:                 reqsCaps.add(reqCap);
1:         return reqsCaps;
commit:82e8b21
/////////////////////////////////////////////////////////////////////////
1:                             properties.put(SpiFlyConstants.SERVICELOADER_MEDIATOR_PROPERTY, spiBundle.getBundleId());
commit:44456b0
/////////////////////////////////////////////////////////////////////////
commit:a34a6c6
/////////////////////////////////////////////////////////////////////////
0:         if (bundle.getBundleId() == 0)
0:             return null; // don't process the system bundle
1: 
1:         if (bundle.equals(spiBundle))
1:             return null; // don't process the SPI bundle itself
commit:782066c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private GenericMetadata findCapability(List<GenericMetadata> capabilities, String namespace, String spiName) {
1:         for (GenericMetadata cap : capabilities) {
1:             if (namespace.equals(cap.getNamespace())) {
1:                 if (spiName.equals(cap.getAttributes().get(namespace))) {
1:                     return cap;
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
0:     private static Collection<GenericMetadata> findAllMetadata(List<GenericMetadata> requirements, String namespace) {
0:         List<GenericMetadata> reqs = new ArrayList<ManifestHeaderProcessor.GenericMetadata>();
1:         for (GenericMetadata req : requirements) {
1:             if (namespace.equals(req.getNamespace())) {
0:                 reqs.add(req);
1:             }
1:         }
0:         return reqs;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:8d934f9
/////////////////////////////////////////////////////////////////////////
1:         GenericMetadata extenderRequirement = findRequirement(requirements, SpiFlyConstants.EXTENDER_CAPABILITY_NAMESPACE, SpiFlyConstants.REGISTRAR_EXTENDER_NAME);
commit:a166d95
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.FrameworkUtil;
1: import org.osgi.framework.InvalidSyntaxException;
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 providedServices = readRequireCapability(bundle.getHeaders(), customAttributes);
1:             } catch (InvalidSyntaxException e) {
1:                 log(LogService.LOG_ERROR, "Unable to read capabilities from bundle " + bundle, e);
1:             }
1:         boolean fromSPIProviderHeader = false;
/////////////////////////////////////////////////////////////////////////
1:             fromSPIProviderHeader = true;
/////////////////////////////////////////////////////////////////////////
1:         List<URL> serviceFileURLs = new ArrayList<URL>();
1:             serviceFileURLs.addAll(Collections.list(entries));
/////////////////////////////////////////////////////////////////////////
1:                     serviceFileURLs.addAll(getMetaInfServiceURLsFromJar(url));
1:         for (URL serviceFileURL : serviceFileURLs) {
1:             log(LogService.LOG_INFO, "Found SPI resource: " + serviceFileURL);
1:                         new InputStreamReader(serviceFileURL.openStream()));
1:                         String serviceFile = serviceFileURL.toExternalForm();
1:                         int idx = serviceFile.lastIndexOf('/');
1:                         if (serviceFile.length() > idx) {
1:                             registrationClassName = serviceFile.substring(idx + 1);
/////////////////////////////////////////////////////////////////////////
0:                         Hashtable<String, Object> properties;
1:                         if (fromSPIProviderHeader)
1:                             properties = new Hashtable<String, Object>();
1:                         else
1:                             properties = findServiceRegistrationProperties(bundle.getHeaders(), registrationClassName, className);
1:                         if (properties != null) {
0:                             properties.put(SpiFlyConstants.SERVICELOADER_URL_PROPERTY, serviceFile);
0:                                     .registerService(registrationClassName, o, properties);
/////////////////////////////////////////////////////////////////////////
1:                                 "Could not load SPI implementation referred from " + serviceFileURL, e);
1:                 log(LogService.LOG_WARNING, "Could not read SPI metadata from " + serviceFileURL, e);
/////////////////////////////////////////////////////////////////////////
0:     private List<String> readRequireCapability(Dictionary<?,?> headers, Map<String, Object> customAttributes) throws InvalidSyntaxException {
0:         Object requirementHeader = headers.get(SpiFlyConstants.REQUIRE_CAPABILITY);
1:         if (requirementHeader == null)
1:             return null;
1: 
0:         List<GenericMetadata> requirements = ManifestHeaderProcessor.parseRequirementString(requirementHeader.toString());
0:         GenericMetadata extenderRequirement = findRequirement(requirements, SpiFlyConstants.EXTENDER_CAPABILITY_NAMESPACE, SpiFlyConstants.PROVIDER_EXTENDER_NAME);
1:         if (extenderRequirement == null)
1:             return null;
1: 
1:         List<GenericMetadata> capabilities;
1:         Object capabilityHeader = headers.get(SpiFlyConstants.PROVIDE_CAPABILITY);
1:         if (capabilityHeader == null) {
1:             capabilities = Collections.emptyList();
1:         } else {
0:             capabilities = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader.toString());
1:         }
1: 
1:         List<String> serviceNames = new ArrayList<String>();
1:         for (GenericMetadata serviceLoaderCapability : findAllMetadata(capabilities, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE)) {
1:             for (Map.Entry<String, Object> entry : serviceLoaderCapability.getAttributes().entrySet()) {
1:                 if (SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE.equals(entry.getKey())) {
1:                     serviceNames.add(entry.getValue().toString());
1:                     continue;
1:                 }
1: 
1:                 customAttributes.put(entry.getKey(), entry.getValue());
1:             }
1:         }
1:         return serviceNames;
1: 
0: /*
0:         //******************
0:         Object capabilityHeaderxx = headers.get(SpiFlyConstants.REQUIRE_CAPABILITY);
0:         // Find the extender namespace and check that its filter matches serviceloader.registrar
0:         // if so, find all capabilties in osgi.serviceloader namespace,
0:         List<GenericMetadata> capabilitiesxx = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader.toString());
/////////////////////////////////////////////////////////////////////////
1:         */
1:     }
1: 
1:     // null means don't register,
1:     // otherwise the return value should be taken as the service registration properties
1:     private Hashtable<String, Object> findServiceRegistrationProperties(Dictionary<?,?> headers, String spiName, String implName) {
0:         Object capabilityHeader = headers.get(SpiFlyConstants.PROVIDE_CAPABILITY);
1:         if (capabilityHeader == null)
1:             return null;
1: 
1:         List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader.toString());
1:         GenericMetadata cap = findCapability(capabilities, SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE, spiName);
1: 
1:         Hashtable<String, Object> properties = new Hashtable<String, Object>();
1:         if (cap != null) {
1:             for (Map.Entry<String, Object> entry : cap.getAttributes().entrySet()) {
1:                 if (SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE.equals(entry.getKey()))
1:                     continue;
1: 
0:                 properties.put(entry.getKey(), entry.getValue());
1:             }
1:         }
1: 
1:         String registerDirective = cap.getDirectives().get(SpiFlyConstants.REGISTER_DIRECTIVE);
1:         if (registerDirective == null) {
1:             return properties;
1:         } else {
1:             if ("".equals(registerDirective.trim()))
1:                 return null;
1: 
0:             if ("*".equals(registerDirective.trim()))
1:                 return properties;
1: 
1:             if (implName.equals(registerDirective.trim()))
1:                 return properties;
1:         }
1:         return null;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static GenericMetadata findRequirement(List<GenericMetadata> requirements, String namespace, String type) throws InvalidSyntaxException {
1:         Dictionary<String, String> nsAttr = new Hashtable<String, String>();
1:         nsAttr.put(namespace, type);
1: 
0:         for (GenericMetadata req : requirements) {
0:             if (namespace.equals(req.getNamespace())) {
1:                 String filterString = req.getDirectives().get(SpiFlyConstants.FILTER_DIRECTIVE);
1:                 if (filterString != null) {
1:                     Filter filter = FrameworkUtil.createFilter(filterString);
1:                     if (filter.match(nsAttr)) {
1:                         return req;
1:                     }
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
0:     private GenericMetadata findCapability(List<GenericMetadata> capabilities, String namespace, String spiName) {
0:         for (GenericMetadata cap : capabilities) {
0:             if (namespace.equals(cap.getNamespace())) {
0:                 if (spiName.equals(cap.getAttributes().get(namespace))) {
0:                     return cap;
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
0:     private static Collection<GenericMetadata> findAllMetadata(List<GenericMetadata> requirements, String namespace) {
0:         List<GenericMetadata> reqs = new ArrayList<ManifestHeaderProcessor.GenericMetadata>();
0:         for (GenericMetadata req : requirements) {
0:             if (namespace.equals(req.getNamespace())) {
0:                 reqs.add(req);
1:             }
1:         }
0:         return reqs;
1:     }
commit:2276d43
/////////////////////////////////////////////////////////////////////////
0:                         for (String s : entry.getValue().split(",")) {
0:                             serviceNames.add(s.trim());
1:                         }
commit:5e6f679
/////////////////////////////////////////////////////////////////////////
1:         if (bundle.getHeaders().get(SpiFlyConstants.REQUIRE_CAPABILITY) != null) {
0:             providedServices = readRequireCapability(bundle.getHeaders(), directives, customAttributes);
/////////////////////////////////////////////////////////////////////////
0:                         props.put(SpiFlyConstants.SPI_PROVIDER_URL_PROPERTY, serviceFile);
/////////////////////////////////////////////////////////////////////////
0:     private List<String> readRequireCapability(Dictionary<?,?> headers, Map<String, String> directives, Map<String, Object> customAttributes) {
0:         Object capabilityHeader = headers.get(SpiFlyConstants.REQUIRE_CAPABILITY);
0:             if (!SpiFlyConstants.EXTENDER_CAPABILITY_NAMESPACE.equals(cap.getNamespace()))
0:                 if (SpiFlyConstants.EXTENDER_CAPABILITY_NAMESPACE.equals(entry.getKey()))
1:                     continue;
1: 
0:                 customAttributes.put(entry.getKey(), entry.getValue());
1:             }
1: 
0:             List<String> serviceNames = new ArrayList<String>();
0:             for (Map.Entry<String, String> entry : cap.getDirectives().entrySet()) {
0:                 if ("filter".equals(entry.getKey()))
1:                     continue;
0:                 if ("resolution".equals(entry.getKey()))
1:                     continue;
1: 
0:                 if (SpiFlyConstants.PROVIDED_SPI_DIRECTIVE.equals(entry.getKey())) {
0:                     if (entry.getValue() != null) {
0:                         serviceNames.add(entry.getValue());
0:                         // TODO split string
0:                     directives.put(entry.getKey(), entry.getValue());
0:             // directives.putAll(cap.getDirectives());
commit:7158c23
/////////////////////////////////////////////////////////////////////////
0:             String header = bundle.getHeaders().get(SpiFlyConstants.SPI_PROVIDER_HEADER).toString().trim();
1:             if ("*".equals(header)) {
1:                 providedServices = new ArrayList<String>();
1:             } else {
1:                 providedServices = Arrays.asList(header.split(","));
1:             }
/////////////////////////////////////////////////////////////////////////
1:         for (String svc : providedServices) {
1:             // Eagerly register any services that are explicitly listed, as they may not be found in META-INF/services
1:             activator.registerProviderBundle(svc, bundle, customAttributes);
1:         }
1: 
commit:76c890d
/////////////////////////////////////////////////////////////////////////
0:         Map<String, String> directives = new HashMap<String, String>();
0:             providedServices = readProvideCapability(bundle.getHeaders(), directives, customAttributes);
1: 
0:             if (!"active".equals(directives.get(SpiFlyConstants.EFFECTIVE_DIRECTIVE))) {
0:                 log(LogService.LOG_INFO, "Effective is not equal to 'active'. Not processing bundle " + bundle.getSymbolicName());
0:                 return null;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         if (!"false".equalsIgnoreCase(directives.get(SpiFlyConstants.SERVICE_REGISTRY_DIRECTIVE))) {
0:                             ServiceRegistration reg = bundle.getBundleContext()
0:                                     .registerService(registrationClassName, o, props);
0:                             registrations.add(reg);
0:                             log(LogService.LOG_INFO, "Registered service: " + reg);
1:                         }
1:                         log(LogService.LOG_INFO, "Registered provider: " + registrationClassName + " in bundle " + bundle.getSymbolicName());
/////////////////////////////////////////////////////////////////////////
0:     private List<String> readProvideCapability(Dictionary<?,?> headers, Map<String, String> directives, Map<String, Object> customAttributes) {
/////////////////////////////////////////////////////////////////////////
1: 
0:             directives.putAll(cap.getDirectives());
commit:22e0ef1
/////////////////////////////////////////////////////////////////////////
0:                         props.putAll(customAttributes);
commit:708d00a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashMap;
1: import java.util.Map;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
/////////////////////////////////////////////////////////////////////////
1:         Map<String, Object> customAttributes = new HashMap<String, Object>();
0:             providedServices = readProvideCapability(bundle.getHeaders(), customAttributes);
/////////////////////////////////////////////////////////////////////////
0:                         String s = serviceFile.toExternalForm();
0:                         int idx = s.lastIndexOf('/');
1:                         String registrationClassName = className;
0:                         if (s.length() > idx) {
0:                             registrationClassName = s.substring(idx + 1);
1:                         }
1:                         if (providedServices.size() > 0 && !providedServices.contains(registrationClassName))
0:                             continue;
1: 
/////////////////////////////////////////////////////////////////////////
1:                         activator.registerProviderBundle(registrationClassName, bundle, customAttributes);
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
0:     private List<String> readProvideCapability(Dictionary<?,?> headers, Map<String, Object> customAttributes) {
0:         Object capabilityHeader = headers.get(SpiFlyConstants.PROVIDE_CAPABILITY);
0:         if (capabilityHeader == null)
0:         List<GenericMetadata> capabilities = ManifestHeaderProcessor.parseCapabilityString(capabilityHeader.toString());
0:         for (GenericMetadata cap : capabilities) {
0:             if (!SpiFlyConstants.SPI_CAPABILITY_NAMESPACE.equals(cap.getNamespace()))
0:             List<String> serviceNames = new ArrayList<String>();
0:             for (Map.Entry<String, Object> entry : cap.getAttributes().entrySet()) {
0:                 if (SpiFlyConstants.SERVICE_ATTRIBUTE.equals(entry.getKey())) {
0:                     if (entry.getValue() instanceof String) {
0:                         serviceNames.add((String) entry.getValue());
0:                     } else if (entry.getValue() instanceof String []) {
0:                         serviceNames.addAll(Arrays.asList((String []) entry.getValue()));
0:                     } else if (entry.getValue() instanceof List) {
0:                         serviceNames.addAll((List<String>) entry.getValue());
1:                 } else {
0:                     customAttributes.put(entry.getKey(), entry.getValue());
0:             return serviceNames;
commit:3e50f86
/////////////////////////////////////////////////////////////////////////
1: import java.util.Dictionary;
/////////////////////////////////////////////////////////////////////////
1:         List<String> providedServices = null;
0:         if (bundle.getHeaders().get("Provide-Capability") != null) {
0:             providedServices = readProvideCapability(bundle.getHeaders());
1:         }
0:         if (providedServices == null && bundle.getHeaders().get(SpiFlyConstants.SPI_PROVIDER_HEADER) != null) {
0:             providedServices = new ArrayList<String>();
1:         }
1: 
1:         if (providedServices == null) {
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         if (className.startsWith("#"))
1:                             continue; // a comment
0:                         Class<?> cls = bundle.loadClass(className);
0:                         Object o = cls.newInstance();
0:                         log(LogService.LOG_INFO, "Instantiated SPI provider: " + o);
0:                         Hashtable<String, Object> props = new Hashtable<String, Object>();
0:                         props.put(SpiFlyConstants.SPI_PROVIDER_URL, serviceFile);
1: 
0:                         String s = serviceFile.toExternalForm();
0:                         int idx = s.lastIndexOf('/');
0:                         String registrationClassName = className;
0:                         if (s.length() > idx) {
0:                             registrationClassName = s.substring(idx + 1);
1:                         }
1: 
0:                         ServiceRegistration reg = bundle.getBundleContext()
0:                                 .registerService(registrationClassName, o, props);
0:                         registrations.add(reg);
1: 
0:                         activator.registerProviderBundle(registrationClassName, bundle);
0:                         log(LogService.LOG_INFO, "Registered service: " + reg);
1:                     } catch (Exception e) {
1:                         log(LogService.LOG_WARNING,
0:                                 "Could not load SPI implementation referred from " + serviceFile, e);
1:             } catch (IOException e) {
0:                 log(LogService.LOG_WARNING, "Could not read SPI metadata from " + serviceFile, e);
1:     // An empty list returned means 'all SPIs'
1:     // A return value of null means no SPIs
1:     // A populated list means: only these SPIs
0:     private List<String> readProvideCapability(Dictionary<?,?> headers) {
0:         if (headers.get(SpiFlyConstants.PROVIDE_CAPABILITY) == null)
0:             return null;
1: 
0:         String pc = headers.get(SpiFlyConstants.PROVIDE_CAPABILITY).toString();
0:         for (String c : pc.split(",")) { // TODO cover situation where ',' is inside a string (e.g. service:List<String>).
0:             c = c.trim();
0:             int idx = c.indexOf(';');
0:             if (idx < 0)
0:                 continue;
1: 
0:             String ns = c.substring(0, idx);
0:             if (!SpiFlyConstants.SPI_CAPABILITY_NAMESPACE.equals(ns))
0:                 continue;
1: 
0:             List<String> providedServices = new ArrayList<String>();
0:             String attrs = c.substring(idx);
0:             for (String attr : attrs.split(";")) {
0:                 attr = attr.trim();
0:                 if (attr.startsWith("service=")) {
0:                     String val = attr.substring("service=".length());
0:                     providedServices.add(val);
0:                 } else if (attr.startsWith("service:String=")) {
0:                     String val = attr.substring("service:String=".length());
0:                     providedServices.add(val);
0:                 } else if (attr.startsWith("service:List<String>=")) {
0:                     String val = attr.substring("service:List<String>=".length());
0:                     for (String v : val.split(",")) {
0:                         providedServices.add(v.trim());
1:                     }
1:                 }
1:             }
0:             return providedServices; // An empty array means all SPIs
1:         }
0:         return null;
1:     }
1: 
commit:b1578c3
/////////////////////////////////////////////////////////////////////////
1: 
1:     public ProviderBundleTrackerCustomizer(BaseActivator activator, Bundle spiBundle) {
1:         this.activator = activator;
1:         this.spiBundle = spiBundle;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:                 if (entry.equals("."))
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                 String className = null;
1:                 while((className = reader.readLine()) != null) {
0:                     Class<?> cls = bundle.loadClass(className);
0:                     Object o = cls.newInstance();
0:                     log(LogService.LOG_INFO, "Instantiated SPI provider: " + o);
0:                     Hashtable<String, Object> props = new Hashtable<String, Object>();
0:                     props.put(SpiFlyConstants.SPI_PROVIDER_URL, serviceFile);
0:                     String s = serviceFile.toExternalForm();
0:                     int idx = s.lastIndexOf('/');
0:                     String registrationClassName = className;
0:                     if (s.length() > idx) {
0:                         registrationClassName = s.substring(idx + 1);
1:                     }
0:                     ServiceRegistration reg = bundle.getBundleContext()
0:                             .registerService(registrationClassName, o, props);
0:                     registrations.add(reg);
1: 
0:                     activator.registerProviderBundle(registrationClassName, bundle);
0:                     log(LogService.LOG_INFO, "Registered service: " + reg);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                         je.getName().length() > (METAINF_SERVICES.length() + 1)) {
/////////////////////////////////////////////////////////////////////////
1: 
1:             log(LogService.LOG_INFO, "Unregistered: " + reg);
commit:5e890d0
/////////////////////////////////////////////////////////////////////////
1:             log(LogService.LOG_ERROR, "Problem opening embedded jar file: " + url, e);
commit:3f2be6b
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.Collections;
1: import java.util.jar.JarEntry;
1: import java.util.jar.JarInputStream;
1: import org.osgi.framework.Constants;
/////////////////////////////////////////////////////////////////////////
1:     private static final String METAINF_SERVICES = "META-INF/services";
0:     
/////////////////////////////////////////////////////////////////////////
0:         URL servicesDir = bundle.getResource("/" + METAINF_SERVICES);
0:         if (servicesDir == null)
0:         
0:         List<URL> serviceFiles = new ArrayList<URL>();
0:         
1:         @SuppressWarnings("unchecked")
1:         Enumeration<URL> entries = bundle.findEntries(METAINF_SERVICES, "*", false);
1:         if (entries != null) {
0:             serviceFiles.addAll(Collections.list(entries));
0:         
1:         Object bcp = bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);
1:         if (bcp instanceof String) {
1:             for (String entry : ((String) bcp).split(",")) {
1:                 entry = entry.trim();
0:                 if (entry.equals(".")) 
0:                     continue;
0:                 
1:                 URL url = bundle.getResource(entry);
1:                 if (url != null) {
0:                     serviceFiles.addAll(getMetaInfServiceURLsFromJar(url));
1:                 }
1:             }
1:         }
0:         
0:         for (URL serviceFile : serviceFiles) {
0:             log(LogService.LOG_INFO, "Found SPI resource: " + serviceFile);
0:                         new InputStreamReader(serviceFile.openStream()));
/////////////////////////////////////////////////////////////////////////
0:                 props.put(SpiFlyConstants.SPI_PROVIDER_URL, serviceFile);
0:                 String s = serviceFile.toExternalForm();
/////////////////////////////////////////////////////////////////////////
0:                         "Could not load SPI implementation referred from " + serviceFile, e);
1:     private List<URL> getMetaInfServiceURLsFromJar(URL url) {
1:         List<URL> urls = new ArrayList<URL>();
1:         try {
1:             JarInputStream jis = null;
1:             try {
1:                 jis = new JarInputStream(url.openStream());
0:                 
1:                 JarEntry je = null;
1:                 while((je = jis.getNextJarEntry()) != null) {
1:                     if (je.getName().startsWith(METAINF_SERVICES) &&
0:                         je.getName().length() > (METAINF_SERVICES.length() + 1)) {                       
1:                         urls.add(new URL("jar:" + url + "!/" + je.getName()));
1:                     }
1:                 }
1:             } finally {
1:                 if (jis != null) {
1:                     jis.close();
1:                 }
1:             }
1:         } catch (IOException e) {
0:             log(LogService.LOG_ERROR, "Problem opening embedded jar file: " + url);
1:         }
1:         return urls;
1:     }
0: 
commit:4b6c670
/////////////////////////////////////////////////////////////////////////
1: public class ProviderBundleTrackerCustomizer implements BundleTrackerCustomizer {
/////////////////////////////////////////////////////////////////////////
0:     public List<ServiceRegistration> addingBundle(Bundle bundle, BundleEvent event) {
/////////////////////////////////////////////////////////////////////////
0:         @SuppressWarnings("unchecked")
0:         List<ServiceRegistration> registrations = new ArrayList<ServiceRegistration>();
/////////////////////////////////////////////////////////////////////////
0:                 ServiceRegistration reg = bundle.getBundleContext()
/////////////////////////////////////////////////////////////////////////
1:     public void modifiedBundle(Bundle bundle, BundleEvent event, Object registrations) {
0:     @SuppressWarnings("unchecked")
1:     public void removedBundle(Bundle bundle, BundleEvent event, Object registrations) {
1:         for (ServiceRegistration reg : (List<ServiceRegistration>) registrations) {
commit:b1379cb
/////////////////////////////////////////////////////////////////////////
1:     final BaseActivator activator;
0:     public ProviderBundleTrackerCustomizer(BaseActivator a, Bundle b) {
commit:1c43780
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.spifly;
0: 
1: import java.io.BufferedReader;
1: import java.io.InputStreamReader;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import java.util.List;
0: 
0: import org.apache.aries.spifly.api.SpiFlyConstants;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleEvent;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.service.log.LogService;
1: import org.osgi.util.tracker.BundleTrackerCustomizer;
0: 
1: /**
1:  * Listens for new bundles being installed and registers them as service providers if applicable.
1:  */
0: public class ProviderBundleTrackerCustomizer implements BundleTrackerCustomizer<List<ServiceRegistration<?>>> {
0:     final Activator activator;
1:     final Bundle spiBundle;
0: 
0:     public ProviderBundleTrackerCustomizer(Activator a, Bundle b) {
0:         activator = a;
0:         spiBundle = b;
0:                 
0:         // TODO handle pre-existing bundles.
0:     }
0: 
0:     public List<ServiceRegistration<?>> addingBundle(Bundle bundle, BundleEvent event) {
0:         log(LogService.LOG_INFO, "Bundle Considered for SPI providers: "
1:                 + bundle.getSymbolicName());
0: 
0:         if (bundle.equals(spiBundle)) {
0:             return null;
0:         }
0: 
0:         if (bundle.getHeaders().get(SpiFlyConstants.SPI_PROVIDER_HEADER) == null) {
0:             log(LogService.LOG_INFO, "No '"
1:                     + SpiFlyConstants.SPI_PROVIDER_HEADER
1:                     + "' Manifest header. Skipping bundle: "
1:                     + bundle.getSymbolicName());
0:             return null;
0:         } else {
1:             log(LogService.LOG_INFO, "Examining bundle for SPI provider: "
1:                     + bundle.getSymbolicName());
0:         }
0: 
0:         Enumeration<URL> entries = bundle.findEntries("META-INF/services", "*", false);
0:         if (entries == null) {
0:             return null;
0:         }
0: 
0:         List<ServiceRegistration<?>> registrations = new ArrayList<ServiceRegistration<?>>();
0:         while (entries.hasMoreElements()) {
0:             URL url = entries.nextElement();
0:             log(LogService.LOG_INFO, "Found SPI resource: " + url);
0: 
1:             try {
1:                 BufferedReader reader = new BufferedReader(
0:                         new InputStreamReader(url.openStream()));
0:                 String className = reader.readLine();
0:                 // TODO need to read more than one class name!
0: 
0:                 Class<?> cls = bundle.loadClass(className);
0:                 Object o = cls.newInstance();
0:                 log(LogService.LOG_INFO, "Instantiated SPI provider: " + o);
0: 
0:                 Hashtable<String, Object> props = new Hashtable<String, Object>();
0:                 props.put(SpiFlyConstants.SPI_PROVIDER_URL, url);
0: 
0:                 String s = url.toExternalForm();
0:                 int idx = s.lastIndexOf('/');
0:                 String registrationClassName = className;
0:                 if (s.length() > idx) {
0:                     registrationClassName = s.substring(idx + 1);
0:                 }
0: 
0:                 ServiceRegistration<?> reg = bundle.getBundleContext()
0:                         .registerService(registrationClassName, o, props);
0:                 registrations.add(reg);
0: 
0:                 activator.registerProviderBundle(registrationClassName, bundle);
0:                 log(LogService.LOG_INFO, "Registered service: " + reg);                
0:             } catch (Exception e) {
0:                 log(LogService.LOG_WARNING,
0:                         "Could not load SPI implementation referred from " + url, e);
0:             }
0:         }
0:         
1:         return registrations;
0:     }
0: 
0:     public void modifiedBundle(Bundle bundle, BundleEvent event, List<ServiceRegistration<?>> registrations) {
1:         // should really be doing something here...
0:     }
0: 
0:     public void removedBundle(Bundle bundle, BundleEvent event, List<ServiceRegistration<?>> registrations) {
1:         if (registrations == null)
1:             return;
0:         
0:         for (ServiceRegistration<?> reg : registrations) {
1:             reg.unregister();
0:             log(LogService.LOG_INFO, "Unregistered: " + reg);            
0:         }
0:     }
0: 
1:     private void log(int level, String message) {
1:         activator.log(level, message);
0:     }
0: 
1:     private void log(int level, String message, Throwable th) {
1:         activator.log(level, message, th);
0:     }
0: }
============================================================================