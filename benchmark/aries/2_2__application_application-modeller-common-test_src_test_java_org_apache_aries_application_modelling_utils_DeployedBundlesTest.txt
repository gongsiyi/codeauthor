1:4fec049: /*
1:4fec049:  * Licensed to the Apache Software Foundation (ASF) under one
1:4fec049:  * or more contributor license agreements.  See the NOTICE file
1:4fec049:  * distributed with this work for additional information
1:4fec049:  * regarding copyright ownership.  The ASF licenses this file
1:4fec049:  * to you under the Apache License, Version 2.0 (the
1:4fec049:  * "License"); you may not use this file except in compliance
1:4fec049:  * with the License.  You may obtain a copy of the License at
1:4fec049:  *
1:4fec049:  *   http://www.apache.org/licenses/LICENSE-2.0
1:4fec049:  *
1:4fec049:  * Unless required by applicable law or agreed to in writing,
1:4fec049:  * software distributed under the License is distributed on an
1:4fec049:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:4fec049:  * KIND, either express or implied.  See the License for the
1:4fec049:  * specific language governing permissions and limitations
1:4fec049:  * under the License.
1:4fec049:  */
1:4fec049: package org.apache.aries.application.modelling.utils;
1:4fec049: 
1:4fec049: 
1:4fec049: import static org.junit.Assert.assertEquals;
1:4fec049: 
1:4fec049: import java.util.ArrayList;
1:4fec049: import java.util.Arrays;
1:4fec049: import java.util.Collection;
1:4fec049: import java.util.Collections;
1:4fec049: import java.util.HashMap;
1:4fec049: import java.util.List;
1:4fec049: import java.util.Map;
1:4fec049: import java.util.jar.Attributes;
1:4fec049: 
1:89f804e: import org.apache.aries.application.InvalidAttributeException;
1:4fec049: import org.apache.aries.application.management.ResolverException;
1:58f55bd: import org.apache.aries.application.modelling.DeployedBundles;
1:4fec049: import org.apache.aries.application.modelling.ExportedService;
1:4fec049: import org.apache.aries.application.modelling.ImportedBundle;
1:4fec049: import org.apache.aries.application.modelling.ImportedService;
1:4fec049: import org.apache.aries.application.modelling.ModelledResource;
1:4fec049: import org.apache.aries.application.modelling.impl.ExportedServiceImpl;
1:4fec049: import org.apache.aries.application.modelling.impl.ImportedBundleImpl;
1:4fec049: import org.apache.aries.application.modelling.impl.ImportedServiceImpl;
1:4fec049: import org.apache.aries.application.modelling.impl.ModelledResourceImpl;
1:58f55bd: import org.apache.aries.application.modelling.utils.impl.ModellingHelperImpl;
1:910fec0: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
1:910fec0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
1:4fec049: import org.junit.Assert;
1:4fec049: import org.junit.Test;
1:4fec049: import org.osgi.framework.Constants;
1:4fec049: 
1:4fec049: 
1:4fec049: public final class DeployedBundlesTest
1:4fec049: {
1:4fec049:   
1:4fec049:   private DeployedBundles validDeployedBundles() throws Exception {
1:4fec049: 
1:4fec049:     Collection<ImportedBundle> content = new ArrayList<ImportedBundle>();
1:4fec049:     Collection<ImportedBundle> uses = new ArrayList<ImportedBundle>();
1:4fec049: 
1:4fec049:     content.add(new ImportedBundleImpl("bundle.a", "1.0.0"));
1:4fec049:     content.add(new ImportedBundleImpl("bundle.b", "1.0.0"));
1:4fec049:     
1:4fec049:     uses.add(new ImportedBundleImpl("bundle.c", "1.0.0"));
1:4fec049:     uses.add(new ImportedBundleImpl("bundle.d", "1.0.0"));
1:4fec049:     
1:58f55bd:     return new ModellingHelperImpl().createDeployedBundles("test",content, uses, null);
1:4fec049:   }
1:4fec049:   
1:4fec049:   private void basicResolve(DeployedBundles db, boolean cPersistent) throws InvalidAttributeException {
1:4fec049:     db.addBundle(createModelledResource("bundle.a", "1.0.0", 
1:4fec049:         Arrays.asList("package.b", "package.c"), Arrays.asList("package.a;version=1.0.0")));
1:4fec049:     db.addBundle(createModelledResource("bundle.b", "1.0.0", 
1:4fec049:         Arrays.asList("package.d;version=1.0.0", "package.e;version=\"[1.0.0,2.0.0)\"", "package.g"),
1:4fec049:         Arrays.asList("package.b;version=1.0.0")));
1:4fec049:     
1:4fec049:     db.addBundle(createModelledResource("bundle.c", "1.0.0", 
1:4fec049:         (cPersistent) ? Arrays.asList("package.d;version=\"[1.0.0,2.0.0)\"", "javax.persistence;version=1.1.0") : 
1:4fec049:           Arrays.asList("package.d;version=\"[1.0.0,2.0.0)\""), Arrays.asList("package.c;version=1.0.0")));
1:4fec049:     db.addBundle(createModelledResource("bundle.d", "1.0.0", 
1:4fec049:         Arrays.asList("package.e;version=\"[1.0.0,1.0.0]\""), Arrays.asList("package.d;version=1.0.0")));
1:4fec049: 
1:4fec049:   }
1:4fec049:   
1:4fec049:   private void packagesResolve(DeployedBundles db) throws InvalidAttributeException {
1:4fec049:     basicResolve(db, false);
1:4fec049:     
1:4fec049:     db.addBundle(createModelledResource("bundle.e", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.e;version=1.0.0")));
1:4fec049:   }
1:4fec049:   
1:4fec049:   public static ModelledResource createModelledResource(String bundleName, String bundleVersion, 
1:4fec049:       Collection<String> importedPackages, Collection<String> exportedPackages) throws InvalidAttributeException {
1:4fec049:     Attributes att = new Attributes();
1:4fec049:     att.put(new Attributes.Name(Constants.BUNDLE_SYMBOLICNAME), bundleName);
1:4fec049:     att.put(new Attributes.Name(Constants.BUNDLE_VERSION), bundleVersion);
1:4fec049:     att.put(new Attributes.Name(Constants.BUNDLE_MANIFESTVERSION), "2");
1:4fec049:     
1:4fec049:     StringBuilder builder = new StringBuilder();
1:4fec049:     for(String iPackage : importedPackages) {
1:4fec049:       builder.append(iPackage).append(",");
1:4fec049:     }
1:4fec049:     if(builder.length() > 0) {
1:4fec049:       builder.deleteCharAt(builder.length() - 1);
1:4fec049:       att.put(new Attributes.Name(Constants.IMPORT_PACKAGE), builder.toString());
1:4fec049:     }
1:4fec049:     
1:4fec049:     builder = new StringBuilder();
1:4fec049:     for(String ePackage : exportedPackages) {
1:4fec049:       builder.append(ePackage).append(",");
1:4fec049:     }
1:4fec049:     if(builder.length() > 0) {
1:4fec049:       builder.deleteCharAt(builder.length() - 1);
1:4fec049:       att.put(new Attributes.Name(Constants.EXPORT_PACKAGE), builder.toString());
1:4fec049:     }
1:4fec049:     return new ModelledResourceImpl(null, att, null, null);
1:4fec049:   }
1:4fec049:   
1:4fec049:   public static ModelledResource createModelledServiceBundle(String bundleName, String bundleVersion,
1:4fec049:       Collection<String> importService, Collection<String> exportService) throws InvalidAttributeException 
1:4fec049:   {
1:4fec049:     Attributes att = new Attributes();
1:4fec049:     att.put(new Attributes.Name(Constants.BUNDLE_SYMBOLICNAME), bundleName);
1:4fec049:     att.put(new Attributes.Name(Constants.BUNDLE_VERSION), bundleVersion);
1:4fec049:     att.put(new Attributes.Name(Constants.BUNDLE_MANIFESTVERSION), "2");
1:4fec049:     
1:4fec049:     List<ImportedService> importedServices = new ArrayList<ImportedService>();
1:4fec049:     for (String s : importService) {
1:4fec049:       importedServices.add(new ImportedServiceImpl(false, s, null, null, null, false));
1:4fec049:     }
1:4fec049:     
1:4fec049:     List<ExportedService> exportedServices = new ArrayList<ExportedService>();
1:4fec049:     for (String s : exportService) {
1:4fec049:       exportedServices.add(new ExportedServiceImpl(null, 0, Collections.singleton(s), Collections.<String,Object>emptyMap()));
1:4fec049:     }
1:4fec049:     
1:4fec049:     return new ModelledResourceImpl(null, att, importedServices, exportedServices);
1:4fec049:   }
1:4fec049:   
1:4fec049:   /**
1:4fec049:    * Check the actual results match the expected values, regardless of order of the parts.
1:4fec049:    * @param entry the actual manifest entry.
1:4fec049:    * @param expected the expected manifest entry.
1:4fec049:    * @return true if they match; false otherwise.
1:4fec049:    */
1:4fec049:   private static boolean isEqual(String actual, String expected)
1:4fec049:   {
1:de5b346:     Map<NameValuePair, Integer> actualEntries = parseEntries(actual);
1:de5b346:     Map<NameValuePair, Integer> expectedEntries = parseEntries(expected);
1:4fec049:     return actualEntries.equals(expectedEntries);
1:4fec049:   }
1:4fec049: 
1:4fec049:   /**
1:4fec049:    * Parse manifest entries into a set of values and associated attributes, which can
1:4fec049:    * be directly compared for equality regardless of ordering.
1:4fec049:    * <p>
1:4fec049:    * Example manifest entry format: value1;attrName1=attrValue1;attrName2=attrValue2,value2;attrName1=attrValue1
1:4fec049:    * @param entries a manifest header entry.
1:4fec049:    * @return a set of parsed entries.
1:4fec049:    */
1:de5b346:   private static Map<NameValuePair, Integer> parseEntries(String entries)
1:4fec049:   {
1:de5b346:     Map<NameValuePair, Integer> result = new HashMap<NameValuePair, Integer>();
1:de5b346:     for (NameValuePair entry : ManifestHeaderProcessor.parseExportString(entries))
1:4fec049:     {
1:4fec049:       Integer count = result.get(entry);
1:4fec049:       if (count != null)
1:4fec049:       {
1:4fec049:         // This entry already exists to increment the count.
1:4fec049:         count++;
1:4fec049:       }
1:4fec049:       else
1:4fec049:       {
1:4fec049:         count = 1;
1:4fec049:       }
1:4fec049:       result.put(entry, count);
1:4fec049:     }
1:4fec049:     
1:4fec049:     return result;
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetContent_Valid() throws Exception
1:4fec049:   {
1:4fec049:     // Get a valid set of deployment information.
1:4fec049:     DeployedBundles deployedBundles = validDeployedBundles();
1:4fec049:     packagesResolve(deployedBundles);
1:4fec049:     
1:4fec049:     // Check the deployed content entry is correct.
1:4fec049:     String contentEntry = deployedBundles.getContent();
1:4fec049:     String expectedResult = "bundle.a;deployed-version=1.0.0,bundle.b;deployed-version=1.0.0";
1:4fec049:     Assert.assertTrue("Content=" + contentEntry, isEqual(contentEntry, expectedResult));
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetUseBundle_Valid() throws Exception
1:4fec049:   {
1:4fec049:     // Get a valid set of deployment information.
1:4fec049:     DeployedBundles deployedBundles = validDeployedBundles();
1:4fec049:     packagesResolve(deployedBundles);
1:4fec049:     
1:4fec049:     // Check the deployed use bundle entry is correct.
1:4fec049:     String useBundleEntry = deployedBundles.getUseBundle();
1:4fec049:     String expectedResult = "bundle.c;deployed-version=1.0.0,bundle.d;deployed-version=1.0.0";
1:4fec049:     Assert.assertTrue("UseBundle=" + useBundleEntry, isEqual(useBundleEntry, expectedResult));
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetProvisionBundle_Valid() throws Exception
1:4fec049:   {
1:4fec049:     // Check the provision bundle entry is correct.
1:4fec049:     DeployedBundles deployedBundles = validDeployedBundles();
1:4fec049:     packagesResolve(deployedBundles);
1:4fec049:     String provisionBundleEntry = deployedBundles.getProvisionBundle();
1:4fec049:     String expectedResult = "bundle.e;deployed-version=1.0.0";
1:4fec049:     Assert.assertTrue("ProvisionBundle=" + provisionBundleEntry, isEqual(provisionBundleEntry, expectedResult));
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_Valid() throws Exception
1:4fec049:   {
1:4fec049:     // Check the import package entry is correct.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       DeployedBundles deployedBundles = validDeployedBundles();
1:4fec049:       packagesResolve(deployedBundles);
1:4fec049:       
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     
1:4fec049:     String expectedResult = "package.c;version=\"1.0.0\";bundle-symbolic-name=\"bundle.c\";bundle-version=\"[1.0.0,1.0.0]\","
1:4fec049:       + "package.d;version=\"1.0.0\";bundle-symbolic-name=\"bundle.d\";bundle-version=\"[1.0.0,1.0.0]\"," 
1:4fec049:       + "package.e;version=\"[1.0.0,2.0.0)\","
1:4fec049:       + "package.g;version=\"0.0.0\"";
1:4fec049:     
1:4fec049:     
1:4fec049:     /*
1:4fec049:      * String expectedResult = "package.c;bundle-symbolic-name=bundle.c;bundle-version=\"[1.0.0,1.0.0]\""
1:4fec049:      
1:4fec049:         + ",package.d;version=\"1.0.0\";bundle-symbolic-name=bundle.d;bundle-version=\"[1.0.0,1.0.0]\""
1:4fec049:         + ",package.e;version=\"[1.0.0,2.0.0)\""
1:4fec049:         + ",package.g";
1:4fec049:      */
1:4fec049:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:4fec049:   }
1:4fec049:   
1:4fec049:   
1:4fec049:   
1:4fec049: 
1:4fec049:   private enum ternary { CONTENT,USES,NONE }
1:4fec049:   
1:4fec049:   private DeployedBundles getSimpleDeployedBundles(ternary a, ternary b, ternary c) throws InvalidAttributeException
1:4fec049:   {
1:4fec049:     Collection<ImportedBundle> content = new ArrayList<ImportedBundle>();
1:4fec049:     Collection<ImportedBundle> uses = new ArrayList<ImportedBundle>();
1:4fec049: 
1:4fec049:     if(a == ternary.CONTENT)
1:4fec049:       content.add(new ImportedBundleImpl("bundle.a", "1.0.0"));
1:4fec049:     else if (a == ternary.USES)
1:4fec049:       uses.add(new ImportedBundleImpl("bundle.a", "1.0.0"));
1:4fec049:     if (b == ternary.CONTENT)
1:4fec049:       content.add(new ImportedBundleImpl("bundle.b", "1.0.0"));
1:4fec049:     else if (b == ternary.USES)
1:4fec049:       uses.add(new ImportedBundleImpl("bundle.b", "1.0.0"));
1:4fec049:     if (c == ternary.CONTENT)
1:4fec049:       content.add(new ImportedBundleImpl("bundle.c", "1.0.0"));
1:4fec049:     else if (c == ternary.USES)
1:4fec049:       uses.add(new ImportedBundleImpl("bundle.c", "1.0.0"));
1:4fec049:     
1:58f55bd:     // In a unit test we could go straight to the static method; choosing not to in this case. 
1:58f55bd:     return new ModellingHelperImpl().createDeployedBundles("test",content, uses, null);
1:4fec049:   }
1:4fec049:   
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_ValidDuplicates() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.CONTENT);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.d;version=\"[1.0.0,3.0.0)\""), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         Arrays.asList("package.d;version=\"2.0.0\""), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:4fec049:         Arrays.asList("package.d;version=\"1.0.0\""), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.d", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.d;version=2.0.1")));
1:4fec049:     
1:4fec049:     // Check that package D is not duplicated in Import-Package, and that the version range
1:4fec049:     // has been narrowed to the intersection of the original requirements.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     String expectedResult = "package.d;version=\"[2.0.0,3.0.0)\"";
1:4fec049:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_ValidDuplicatesWithAttributes() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=1.0.0;was_internal=true"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=2.0.0;was_internal=true"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.c;version=2.0.0;was_internal=true")));
1:4fec049: 
1:4fec049:     // Check that package C is not duplicated in Import-Package, and that the version range
1:4fec049:     // has been narrowed to the intersection of the original requirements.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     String expectedResult = "package.c;was_internal=\"true\";version=\"2.0.0\"";
1:4fec049:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_InvalidDuplicates() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=\"[1.0.0,2.0.0)\""), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=2.0.0"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.c;version=2.0.0;was_internal=true")));
1:4fec049:     
1:4fec049:     // Check that the incompatible version requirements cannot be resolved.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       // We expect to reach this point if the test passes.
1:4fec049:     }
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_InvalidDuplicatesWithAttributes() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=1.0.0;was_internal=true"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=2.0.0"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.c;version=2.0.0;was_internal=true")));
1:4fec049: 
1:4fec049:     // Check that the incompatible package requirement attributes cause an exception.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       // We expect to reach this point if the test passes.
1:4fec049:     }
1:4fec049:   }
1:4fec049: 
1:4fec049:   
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_bundleSymbolicNameOK() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.b;version=1.0.0;bundle-symbolic-name=bundle.b;bundle-version=\"[1.0.0,2.0.0)\""), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.b;version=2.0.0")));
1:4fec049:     
1:4fec049:     // Check that the bundle-symbolic-name attribute for a bundle within deployed-content is ok. 
1:4fec049:     String importPackageEntry = null; 
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();      
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     String expectedResult = "";  // All packages are satisfied internally 
1:4fec049:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:4fec049: 
1:4fec049:   }
1:4fec049:   
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_rfc138PreventsBundleSymbolicNameWorking() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.USES, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.b;version=1.0.0;bundle-symbolic-name=bundle.b"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.b;version=2.0.0")));
1:4fec049: 
1:4fec049:     
1:4fec049:     // Check that the bundle-symbolic-name attribute for a bundle outside use-bundle causes an exception.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       // We expect to reach this point if the test passes.
1:4fec049:     }
1:4fec049:   }
1:4fec049:   
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_rfc138PreventsBundleVersionWorking() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.NONE, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.b;version=1.0.0;bundle-version=1.0.0"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.b;version=2.0.0")));
1:4fec049: 
1:4fec049:     
1:4fec049:     // Check that the bundle-symbolic-name attribute for a bundle outside use-bundle causes an exception.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       // We expect to reach this point if the test passes.
1:4fec049:     }
1:4fec049:   }
1:4fec049:   
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_ValidResolutionAttribute() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.c;version=1.0.0;resolution:=optional"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:          Arrays.asList("package.c;version=1.0.0"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:4fec049:         new ArrayList<String>(), Arrays.asList("package.c;version=1.0.0")));
1:4fec049:     
1:4fec049:     // Check that the resulting resolution directive is not optional.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     String expectedResult = "package.c;version=1.0.0";
1:4fec049:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetRequiredUseBundle_RedundantEntry() throws Exception
1:4fec049:   {
1:4fec049:     // Bundle A requires package B from bundle B with no version requirement.
1:4fec049:     // Bundle B requires package C from bundle C with no version requirement.
1:4fec049:     // Bundle C requires package B from bundle B with explicit version requirement.
1:4fec049:     
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.USES, ternary.USES);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.b"), new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:          Arrays.asList("package.c"), Arrays.asList("package.b;version=1.0.0")));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:4fec049:         Arrays.asList("package.b;version=1.0.0"), Arrays.asList("package.c;version=1.0.0")));
1:4fec049:       
1:4fec049:     // Check the redundant use-bundle entry is identified.
1:4fec049:     // Bundle C is not required by app content, although it is specified in use-bundle.
1:4fec049:     Collection<ModelledResource> requiredUseBundle = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       requiredUseBundle = deployedBundles.getRequiredUseBundle();
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     Assert.assertTrue("RequiredUseBundle=" + requiredUseBundle, requiredUseBundle.size() == 1);
1:4fec049:   }
1:4fec049: 
1:4fec049:   @Test
1:4fec049:   public void testGetRequiredUseBundle_Valid() throws Exception
1:4fec049:   {
1:4fec049:     // Get a valid set of deployment information.
1:4fec049:     DeployedBundles deployedBundles = validDeployedBundles();
1:4fec049:     packagesResolve(deployedBundles);
1:4fec049:     
1:4fec049:     // Check all the use-bundle entries are required.
1:4fec049:     Collection<ModelledResource> requiredUseBundle = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       requiredUseBundle = deployedBundles.getRequiredUseBundle();
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       e.printStackTrace();
1:4fec049:       Assert.fail(e.toString());
1:4fec049:     }
1:4fec049:     Assert.assertTrue("RequiredUseBundle=" + requiredUseBundle, requiredUseBundle.size() == 2);
1:4fec049:   }
1:4fec049:   
1:4fec049:   //Inside cannot bundle-symbolic-name an outside bundle until the new RFC 138!
1:4fec049:   @Test
1:4fec049:   public void testGetImportPackage_InvalidBundleVersion() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.USES, ternary.NONE);
1:4fec049:     
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:4fec049:         Arrays.asList("package.b;version=\"[1.0.0,1.0.0]\";bundle-symbolic-name=bundle.b;bundle-version=\"[0.0.0,1.0.0)\"")
1:4fec049:         , new ArrayList<String>()));
1:4fec049:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:4fec049:          new ArrayList<String>(), Arrays.asList("package.b;version=1.0.0")));
1:4fec049: 
1:4fec049:     // Check that the bundle version requirement generates an error because it doesn't match the a bundle in use-bundle.
1:4fec049:     String importPackageEntry = null;
1:4fec049:     try
1:4fec049:     {
1:4fec049:       importPackageEntry = deployedBundles.getImportPackage();
1:4fec049:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:4fec049:     }
1:4fec049:     catch (ResolverException e)
1:4fec049:     {
1:4fec049:       // We expect to reach this point if the test passes.
1:4fec049:     }
1:4fec049:   }
1:4fec049:   
1:4fec049:   
1:4fec049:   @Test
1:4fec049:   public void testImportedService() throws Exception
1:4fec049:   {
1:4fec049:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.NONE, ternary.NONE);
1:4fec049: 
1:4fec049:     deployedBundles.addBundle(createModelledServiceBundle("bundle.a", "1.0.0", 
1:4fec049:         Collections.singleton("java.util.List"), Collections.<String>emptyList()));
1:4fec049: 
1:4fec049:     deployedBundles.addBundle(createModelledServiceBundle("bundle.b", "1.0.0", 
1:4fec049:         Collections.singleton("java.util.Set"), Collections.singleton("java.util.List")));
1:4fec049: 
1:4fec049:     deployedBundles.addBundle(createModelledServiceBundle("bundle.c", "1.0.0", 
1:4fec049:         Collections.<String>emptyList(), Collections.singleton("java.util.Set")));
1:4fec049:     
1:4fec049:     assertEquals("(objectClass=java.util.List)", deployedBundles.getDeployedImportService());
1:4fec049:   }
1:4fec049: 
1:4fec049: }
============================================================================
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:26ae47b
commit:de5b346
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Map<NameValuePair, Integer> actualEntries = parseEntries(actual);
1:     Map<NameValuePair, Integer> expectedEntries = parseEntries(expected);
/////////////////////////////////////////////////////////////////////////
1:   private static Map<NameValuePair, Integer> parseEntries(String entries)
1:     Map<NameValuePair, Integer> result = new HashMap<NameValuePair, Integer>();
1:     for (NameValuePair entry : ManifestHeaderProcessor.parseExportString(entries))
commit:910fec0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
1: import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
commit:89f804e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.InvalidAttributeException;
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:58f55bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.DeployedBundles;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.modelling.utils.impl.ModellingHelperImpl;
/////////////////////////////////////////////////////////////////////////
1:     return new ModellingHelperImpl().createDeployedBundles("test",content, uses, null);
/////////////////////////////////////////////////////////////////////////
1:     // In a unit test we could go straight to the static method; choosing not to in this case. 
1:     return new ModellingHelperImpl().createDeployedBundles("test",content, uses, null);
commit:4fec049
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.application.modelling.utils;
1: 
1: 
1: import static org.junit.Assert.assertEquals;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.jar.Attributes;
1: 
0: import org.apache.aries.application.management.InvalidAttributeException;
1: import org.apache.aries.application.management.ResolverException;
1: import org.apache.aries.application.modelling.ExportedService;
1: import org.apache.aries.application.modelling.ImportedBundle;
1: import org.apache.aries.application.modelling.ImportedService;
1: import org.apache.aries.application.modelling.ModelledResource;
1: import org.apache.aries.application.modelling.impl.ExportedServiceImpl;
1: import org.apache.aries.application.modelling.impl.ImportedBundleImpl;
1: import org.apache.aries.application.modelling.impl.ImportedServiceImpl;
1: import org.apache.aries.application.modelling.impl.ModelledResourceImpl;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValueMap;
0: import org.apache.aries.application.utils.manifest.ManifestHeaderProcessor.NameValuePair;
1: import org.junit.Assert;
1: import org.junit.Test;
1: import org.osgi.framework.Constants;
1: 
1: 
1: public final class DeployedBundlesTest
1: {
1:   
1:   private DeployedBundles validDeployedBundles() throws Exception {
1: 
1:     Collection<ImportedBundle> content = new ArrayList<ImportedBundle>();
1:     Collection<ImportedBundle> uses = new ArrayList<ImportedBundle>();
1: 
1:     content.add(new ImportedBundleImpl("bundle.a", "1.0.0"));
1:     content.add(new ImportedBundleImpl("bundle.b", "1.0.0"));
1:     
1:     uses.add(new ImportedBundleImpl("bundle.c", "1.0.0"));
1:     uses.add(new ImportedBundleImpl("bundle.d", "1.0.0"));
1:     
0:     return new DeployedBundles("test",content, uses, null);
1:   }
1:   
1:   private void basicResolve(DeployedBundles db, boolean cPersistent) throws InvalidAttributeException {
1:     db.addBundle(createModelledResource("bundle.a", "1.0.0", 
1:         Arrays.asList("package.b", "package.c"), Arrays.asList("package.a;version=1.0.0")));
1:     db.addBundle(createModelledResource("bundle.b", "1.0.0", 
1:         Arrays.asList("package.d;version=1.0.0", "package.e;version=\"[1.0.0,2.0.0)\"", "package.g"),
1:         Arrays.asList("package.b;version=1.0.0")));
1:     
1:     db.addBundle(createModelledResource("bundle.c", "1.0.0", 
1:         (cPersistent) ? Arrays.asList("package.d;version=\"[1.0.0,2.0.0)\"", "javax.persistence;version=1.1.0") : 
1:           Arrays.asList("package.d;version=\"[1.0.0,2.0.0)\""), Arrays.asList("package.c;version=1.0.0")));
1:     db.addBundle(createModelledResource("bundle.d", "1.0.0", 
1:         Arrays.asList("package.e;version=\"[1.0.0,1.0.0]\""), Arrays.asList("package.d;version=1.0.0")));
1: 
1:   }
1:   
1:   private void packagesResolve(DeployedBundles db) throws InvalidAttributeException {
1:     basicResolve(db, false);
1:     
1:     db.addBundle(createModelledResource("bundle.e", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.e;version=1.0.0")));
1:   }
1:   
1:   public static ModelledResource createModelledResource(String bundleName, String bundleVersion, 
1:       Collection<String> importedPackages, Collection<String> exportedPackages) throws InvalidAttributeException {
1:     Attributes att = new Attributes();
1:     att.put(new Attributes.Name(Constants.BUNDLE_SYMBOLICNAME), bundleName);
1:     att.put(new Attributes.Name(Constants.BUNDLE_VERSION), bundleVersion);
1:     att.put(new Attributes.Name(Constants.BUNDLE_MANIFESTVERSION), "2");
1:     
1:     StringBuilder builder = new StringBuilder();
1:     for(String iPackage : importedPackages) {
1:       builder.append(iPackage).append(",");
1:     }
1:     if(builder.length() > 0) {
1:       builder.deleteCharAt(builder.length() - 1);
1:       att.put(new Attributes.Name(Constants.IMPORT_PACKAGE), builder.toString());
1:     }
1:     
1:     builder = new StringBuilder();
1:     for(String ePackage : exportedPackages) {
1:       builder.append(ePackage).append(",");
1:     }
1:     if(builder.length() > 0) {
1:       builder.deleteCharAt(builder.length() - 1);
1:       att.put(new Attributes.Name(Constants.EXPORT_PACKAGE), builder.toString());
1:     }
1:     return new ModelledResourceImpl(null, att, null, null);
1:   }
1:   
1:   public static ModelledResource createModelledServiceBundle(String bundleName, String bundleVersion,
1:       Collection<String> importService, Collection<String> exportService) throws InvalidAttributeException 
1:   {
1:     Attributes att = new Attributes();
1:     att.put(new Attributes.Name(Constants.BUNDLE_SYMBOLICNAME), bundleName);
1:     att.put(new Attributes.Name(Constants.BUNDLE_VERSION), bundleVersion);
1:     att.put(new Attributes.Name(Constants.BUNDLE_MANIFESTVERSION), "2");
1:     
1:     List<ImportedService> importedServices = new ArrayList<ImportedService>();
1:     for (String s : importService) {
1:       importedServices.add(new ImportedServiceImpl(false, s, null, null, null, false));
1:     }
1:     
1:     List<ExportedService> exportedServices = new ArrayList<ExportedService>();
1:     for (String s : exportService) {
1:       exportedServices.add(new ExportedServiceImpl(null, 0, Collections.singleton(s), Collections.<String,Object>emptyMap()));
1:     }
1:     
1:     return new ModelledResourceImpl(null, att, importedServices, exportedServices);
1:   }
1:   
1:   /**
1:    * Check the actual results match the expected values, regardless of order of the parts.
1:    * @param entry the actual manifest entry.
1:    * @param expected the expected manifest entry.
1:    * @return true if they match; false otherwise.
1:    */
1:   private static boolean isEqual(String actual, String expected)
1:   {
0:     Map<NameValuePair<String, NameValueMap<String, String>>, Integer> actualEntries = parseEntries(actual);
0:     Map<NameValuePair<String, NameValueMap<String, String>>, Integer> expectedEntries = parseEntries(expected);
1:     return actualEntries.equals(expectedEntries);
1:   }
1: 
1:   /**
1:    * Parse manifest entries into a set of values and associated attributes, which can
1:    * be directly compared for equality regardless of ordering.
1:    * <p>
1:    * Example manifest entry format: value1;attrName1=attrValue1;attrName2=attrValue2,value2;attrName1=attrValue1
1:    * @param entries a manifest header entry.
1:    * @return a set of parsed entries.
1:    */
0:   private static Map<NameValuePair<String, NameValueMap<String, String>>, Integer> parseEntries(String entries)
1:   {
0:     Map<NameValuePair<String, NameValueMap<String, String>>, Integer> result = new HashMap<NameValuePair<String, NameValueMap<String, String>>, Integer>();
0:     for (NameValuePair<String, NameValueMap<String, String>> entry : ManifestHeaderProcessor.parseExportString(entries))
1:     {
1:       Integer count = result.get(entry);
1:       if (count != null)
1:       {
1:         // This entry already exists to increment the count.
1:         count++;
1:       }
1:       else
1:       {
1:         count = 1;
1:       }
1:       result.put(entry, count);
1:     }
1:     
1:     return result;
1:   }
1: 
1:   @Test
1:   public void testGetContent_Valid() throws Exception
1:   {
1:     // Get a valid set of deployment information.
1:     DeployedBundles deployedBundles = validDeployedBundles();
1:     packagesResolve(deployedBundles);
1:     
1:     // Check the deployed content entry is correct.
1:     String contentEntry = deployedBundles.getContent();
1:     String expectedResult = "bundle.a;deployed-version=1.0.0,bundle.b;deployed-version=1.0.0";
1:     Assert.assertTrue("Content=" + contentEntry, isEqual(contentEntry, expectedResult));
1:   }
1: 
1:   @Test
1:   public void testGetUseBundle_Valid() throws Exception
1:   {
1:     // Get a valid set of deployment information.
1:     DeployedBundles deployedBundles = validDeployedBundles();
1:     packagesResolve(deployedBundles);
1:     
1:     // Check the deployed use bundle entry is correct.
1:     String useBundleEntry = deployedBundles.getUseBundle();
1:     String expectedResult = "bundle.c;deployed-version=1.0.0,bundle.d;deployed-version=1.0.0";
1:     Assert.assertTrue("UseBundle=" + useBundleEntry, isEqual(useBundleEntry, expectedResult));
1:   }
1: 
1:   @Test
1:   public void testGetProvisionBundle_Valid() throws Exception
1:   {
1:     // Check the provision bundle entry is correct.
1:     DeployedBundles deployedBundles = validDeployedBundles();
1:     packagesResolve(deployedBundles);
1:     String provisionBundleEntry = deployedBundles.getProvisionBundle();
1:     String expectedResult = "bundle.e;deployed-version=1.0.0";
1:     Assert.assertTrue("ProvisionBundle=" + provisionBundleEntry, isEqual(provisionBundleEntry, expectedResult));
1:   }
1: 
1:   @Test
1:   public void testGetImportPackage_Valid() throws Exception
1:   {
1:     // Check the import package entry is correct.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       DeployedBundles deployedBundles = validDeployedBundles();
1:       packagesResolve(deployedBundles);
1:       
1:       importPackageEntry = deployedBundles.getImportPackage();
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     
1:     String expectedResult = "package.c;version=\"1.0.0\";bundle-symbolic-name=\"bundle.c\";bundle-version=\"[1.0.0,1.0.0]\","
1:       + "package.d;version=\"1.0.0\";bundle-symbolic-name=\"bundle.d\";bundle-version=\"[1.0.0,1.0.0]\"," 
1:       + "package.e;version=\"[1.0.0,2.0.0)\","
1:       + "package.g;version=\"0.0.0\"";
1:     
1:     
1:     /*
1:      * String expectedResult = "package.c;bundle-symbolic-name=bundle.c;bundle-version=\"[1.0.0,1.0.0]\""
1:      
1:         + ",package.d;version=\"1.0.0\";bundle-symbolic-name=bundle.d;bundle-version=\"[1.0.0,1.0.0]\""
1:         + ",package.e;version=\"[1.0.0,2.0.0)\""
1:         + ",package.g";
1:      */
1:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:   }
1:   
1:   
1:   
1: 
1:   private enum ternary { CONTENT,USES,NONE }
1:   
1:   private DeployedBundles getSimpleDeployedBundles(ternary a, ternary b, ternary c) throws InvalidAttributeException
1:   {
1:     Collection<ImportedBundle> content = new ArrayList<ImportedBundle>();
1:     Collection<ImportedBundle> uses = new ArrayList<ImportedBundle>();
1: 
1:     if(a == ternary.CONTENT)
1:       content.add(new ImportedBundleImpl("bundle.a", "1.0.0"));
1:     else if (a == ternary.USES)
1:       uses.add(new ImportedBundleImpl("bundle.a", "1.0.0"));
1:     if (b == ternary.CONTENT)
1:       content.add(new ImportedBundleImpl("bundle.b", "1.0.0"));
1:     else if (b == ternary.USES)
1:       uses.add(new ImportedBundleImpl("bundle.b", "1.0.0"));
1:     if (c == ternary.CONTENT)
1:       content.add(new ImportedBundleImpl("bundle.c", "1.0.0"));
1:     else if (c == ternary.USES)
1:       uses.add(new ImportedBundleImpl("bundle.c", "1.0.0"));
1:     
0:     return new DeployedBundles("test",content, uses, null);
1:   }
1:   
1:   @Test
1:   public void testGetImportPackage_ValidDuplicates() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.CONTENT);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.d;version=\"[1.0.0,3.0.0)\""), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         Arrays.asList("package.d;version=\"2.0.0\""), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:         Arrays.asList("package.d;version=\"1.0.0\""), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.d", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.d;version=2.0.1")));
1:     
1:     // Check that package D is not duplicated in Import-Package, and that the version range
1:     // has been narrowed to the intersection of the original requirements.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     String expectedResult = "package.d;version=\"[2.0.0,3.0.0)\"";
1:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:   }
1: 
1:   @Test
1:   public void testGetImportPackage_ValidDuplicatesWithAttributes() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.c;version=1.0.0;was_internal=true"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         Arrays.asList("package.c;version=2.0.0;was_internal=true"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.c;version=2.0.0;was_internal=true")));
1: 
1:     // Check that package C is not duplicated in Import-Package, and that the version range
1:     // has been narrowed to the intersection of the original requirements.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     String expectedResult = "package.c;was_internal=\"true\";version=\"2.0.0\"";
1:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:   }
1: 
1:   @Test
1:   public void testGetImportPackage_InvalidDuplicates() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.c;version=\"[1.0.0,2.0.0)\""), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         Arrays.asList("package.c;version=2.0.0"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.c;version=2.0.0;was_internal=true")));
1:     
1:     // Check that the incompatible version requirements cannot be resolved.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:     }
1:     catch (ResolverException e)
1:     {
1:       // We expect to reach this point if the test passes.
1:     }
1:   }
1: 
1:   @Test
1:   public void testGetImportPackage_InvalidDuplicatesWithAttributes() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.c;version=1.0.0;was_internal=true"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         Arrays.asList("package.c;version=2.0.0"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.c;version=2.0.0;was_internal=true")));
1: 
1:     // Check that the incompatible package requirement attributes cause an exception.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:     }
1:     catch (ResolverException e)
1:     {
1:       // We expect to reach this point if the test passes.
1:     }
1:   }
1: 
1:   
1:   @Test
1:   public void testGetImportPackage_bundleSymbolicNameOK() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.b;version=1.0.0;bundle-symbolic-name=bundle.b;bundle-version=\"[1.0.0,2.0.0)\""), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.b;version=2.0.0")));
1:     
1:     // Check that the bundle-symbolic-name attribute for a bundle within deployed-content is ok. 
1:     String importPackageEntry = null; 
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();      
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     String expectedResult = "";  // All packages are satisfied internally 
1:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1: 
1:   }
1:   
1:   @Test
1:   public void testGetImportPackage_rfc138PreventsBundleSymbolicNameWorking() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.USES, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.b;version=1.0.0;bundle-symbolic-name=bundle.b"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.b;version=2.0.0")));
1: 
1:     
1:     // Check that the bundle-symbolic-name attribute for a bundle outside use-bundle causes an exception.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:     }
1:     catch (ResolverException e)
1:     {
1:       // We expect to reach this point if the test passes.
1:     }
1:   }
1:   
1:   @Test
1:   public void testGetImportPackage_rfc138PreventsBundleVersionWorking() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.NONE, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.b;version=1.0.0;bundle-version=1.0.0"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.b;version=2.0.0")));
1: 
1:     
1:     // Check that the bundle-symbolic-name attribute for a bundle outside use-bundle causes an exception.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:     }
1:     catch (ResolverException e)
1:     {
1:       // We expect to reach this point if the test passes.
1:     }
1:   }
1:   
1:   @Test
1:   public void testGetImportPackage_ValidResolutionAttribute() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.CONTENT, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.c;version=1.0.0;resolution:=optional"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:          Arrays.asList("package.c;version=1.0.0"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:         new ArrayList<String>(), Arrays.asList("package.c;version=1.0.0")));
1:     
1:     // Check that the resulting resolution directive is not optional.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     String expectedResult = "package.c;version=1.0.0";
1:     Assert.assertTrue("ImportPackage=" + importPackageEntry, isEqual(importPackageEntry, expectedResult));
1:   }
1: 
1:   @Test
1:   public void testGetRequiredUseBundle_RedundantEntry() throws Exception
1:   {
1:     // Bundle A requires package B from bundle B with no version requirement.
1:     // Bundle B requires package C from bundle C with no version requirement.
1:     // Bundle C requires package B from bundle B with explicit version requirement.
1:     
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.USES, ternary.USES);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.b"), new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:          Arrays.asList("package.c"), Arrays.asList("package.b;version=1.0.0")));
1:     deployedBundles.addBundle(createModelledResource("bundle.c", "1.0.0",
1:         Arrays.asList("package.b;version=1.0.0"), Arrays.asList("package.c;version=1.0.0")));
1:       
1:     // Check the redundant use-bundle entry is identified.
1:     // Bundle C is not required by app content, although it is specified in use-bundle.
1:     Collection<ModelledResource> requiredUseBundle = null;
1:     try
1:     {
1:       requiredUseBundle = deployedBundles.getRequiredUseBundle();
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     Assert.assertTrue("RequiredUseBundle=" + requiredUseBundle, requiredUseBundle.size() == 1);
1:   }
1: 
1:   @Test
1:   public void testGetRequiredUseBundle_Valid() throws Exception
1:   {
1:     // Get a valid set of deployment information.
1:     DeployedBundles deployedBundles = validDeployedBundles();
1:     packagesResolve(deployedBundles);
1:     
1:     // Check all the use-bundle entries are required.
1:     Collection<ModelledResource> requiredUseBundle = null;
1:     try
1:     {
1:       requiredUseBundle = deployedBundles.getRequiredUseBundle();
1:     }
1:     catch (ResolverException e)
1:     {
1:       e.printStackTrace();
1:       Assert.fail(e.toString());
1:     }
1:     Assert.assertTrue("RequiredUseBundle=" + requiredUseBundle, requiredUseBundle.size() == 2);
1:   }
1:   
1:   //Inside cannot bundle-symbolic-name an outside bundle until the new RFC 138!
1:   @Test
1:   public void testGetImportPackage_InvalidBundleVersion() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.USES, ternary.NONE);
1:     
1:     deployedBundles.addBundle(createModelledResource("bundle.a", "1.0.0",
1:         Arrays.asList("package.b;version=\"[1.0.0,1.0.0]\";bundle-symbolic-name=bundle.b;bundle-version=\"[0.0.0,1.0.0)\"")
1:         , new ArrayList<String>()));
1:     deployedBundles.addBundle(createModelledResource("bundle.b", "1.0.0",
1:          new ArrayList<String>(), Arrays.asList("package.b;version=1.0.0")));
1: 
1:     // Check that the bundle version requirement generates an error because it doesn't match the a bundle in use-bundle.
1:     String importPackageEntry = null;
1:     try
1:     {
1:       importPackageEntry = deployedBundles.getImportPackage();
1:       Assert.fail("Expected exception. ImportPackage=" + importPackageEntry);
1:     }
1:     catch (ResolverException e)
1:     {
1:       // We expect to reach this point if the test passes.
1:     }
1:   }
1:   
1:   
1:   @Test
1:   public void testImportedService() throws Exception
1:   {
1:     DeployedBundles deployedBundles = getSimpleDeployedBundles(ternary.CONTENT, ternary.NONE, ternary.NONE);
1: 
1:     deployedBundles.addBundle(createModelledServiceBundle("bundle.a", "1.0.0", 
1:         Collections.singleton("java.util.List"), Collections.<String>emptyList()));
1: 
1:     deployedBundles.addBundle(createModelledServiceBundle("bundle.b", "1.0.0", 
1:         Collections.singleton("java.util.Set"), Collections.singleton("java.util.List")));
1: 
1:     deployedBundles.addBundle(createModelledServiceBundle("bundle.c", "1.0.0", 
1:         Collections.<String>emptyList(), Collections.singleton("java.util.Set")));
1:     
1:     assertEquals("(objectClass=java.util.List)", deployedBundles.getDeployedImportService());
1:   }
1: 
1: }
============================================================================