1:6591ac7: /**
1:6591ac7:  * Licensed to the Apache Software Foundation (ASF) under one
1:6591ac7:  * or more contributor license agreements.  See the NOTICE file
1:6591ac7:  * distributed with this work for additional information
1:6591ac7:  * regarding copyright ownership.  The ASF licenses this file
1:6591ac7:  * to you under the Apache License, Version 2.0 (the
1:6591ac7:  * "License"); you may not use this file except in compliance
1:6591ac7:  * with the License.  You may obtain a copy of the License at
1:6591ac7:  *
1:6591ac7:  *   http://www.apache.org/licenses/LICENSE-2.0
1:6591ac7:  *
1:6591ac7:  * Unless required by applicable law or agreed to in writing,
1:6591ac7:  * software distributed under the License is distributed on an
1:6591ac7:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6591ac7:  * KIND, either express or implied.  See the License for the
1:6591ac7:  * specific language governing permissions and limitations
1:6591ac7:  * under the License.
1:e126d45:  */
1:6591ac7: package org.apache.aries.spifly.dynamic;
28:6591ac7: 
1:6591ac7: import java.io.BufferedReader;
1:6591ac7: import java.io.File;
1:6591ac7: import java.io.FileReader;
1:6591ac7: import java.io.IOException;
1:6591ac7: import java.lang.reflect.Field;
1:14bb556: import java.lang.reflect.InvocationTargetException;
1:6591ac7: import java.lang.reflect.Method;
1:6591ac7: import java.net.URL;
1:6591ac7: import java.net.URLClassLoader;
1:6591ac7: import java.security.ProtectionDomain;
1:6591ac7: import java.util.ArrayList;
1:6591ac7: import java.util.Arrays;
1:6591ac7: import java.util.Collection;
1:6591ac7: import java.util.Collections;
1:6591ac7: import java.util.Dictionary;
1:6591ac7: import java.util.Enumeration;
1:35cb846: import java.util.HashMap;
1:11803af: import java.util.HashSet;
1:6591ac7: import java.util.Hashtable;
1:6591ac7: import java.util.List;
1:6591ac7: import java.util.Map;
1:11803af: import java.util.Set;
1:6591ac7: import java.util.concurrent.ConcurrentHashMap;
1:6591ac7: 
1:6591ac7: import org.apache.aries.spifly.BaseActivator;
1:e9a5257: import org.apache.aries.spifly.SpiFlyConstants;
1:6591ac7: import org.apache.aries.spifly.Streams;
1:6591ac7: import org.easymock.EasyMock;
1:6591ac7: import org.easymock.IAnswer;
1:6591ac7: import org.junit.After;
1:6591ac7: import org.junit.Assert;
1:6591ac7: import org.junit.Before;
1:6591ac7: import org.junit.Test;
1:6591ac7: import org.osgi.framework.Bundle;
1:6591ac7: import org.osgi.framework.BundleContext;
1:6591ac7: import org.osgi.framework.BundleReference;
1:6591ac7: import org.osgi.framework.Version;
1:6591ac7: import org.osgi.framework.hooks.weaving.WeavingHook;
1:6591ac7: import org.osgi.framework.hooks.weaving.WovenClass;
1:fb75ccc: import org.osgi.framework.wiring.BundleRequirement;
1:7dabe8c: import org.osgi.framework.wiring.BundleRevision;
1:fb75ccc: import org.osgi.framework.wiring.BundleWire;
1:6591ac7: import org.osgi.framework.wiring.BundleWiring;
1:6591ac7: 
1:6591ac7: public class ClientWeavingHookGenericCapabilityTest {
1:6591ac7:     DynamicWeavingActivator activator;
1:6591ac7: 
1:6591ac7:     @Before
1:6591ac7:     public void setUp() {
1:6591ac7:         activator = new DynamicWeavingActivator();
1:6591ac7:         BaseActivator.activator = activator;
6:6591ac7:     }
1:e126d45: 
1:6591ac7:     @After
1:6591ac7:     public void tearDown() {
1:6591ac7:         BaseActivator.activator = null;
1:6591ac7:         activator = null;
1:6591ac7:     }
1:6591ac7: 
4:6591ac7:     @Test
1:c7183ef:     public void testBasicServiceLoaderUsage() throws Exception {
1:6591ac7:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:5e6f679:         consumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1:6591ac7: 
1:6591ac7:         // Register the bundle that provides the SPI implementation.
1:6591ac7:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:6591ac7: 
1:6591ac7:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:6591ac7:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
1:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
2:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
2:6591ac7:         // Weave the TestClient class.
2:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:6591ac7:         Assert.assertNotNull("Precondition", clsUrl);
1:6591ac7: 
1:6591ac7:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:6591ac7:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
5:6591ac7:         wh.weave(wc);
1:6591ac7:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:6591ac7:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:6591ac7:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:6591ac7:         String di = wc.getDynamicImports().get(0);
1:6591ac7:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
5:6591ac7:         Class<?> cls = wc.getDefinedClass();
2:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
2:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Assert.assertEquals(Collections.singleton("olleh"), result);
1:6591ac7:     }
1:6591ac7: 
1:fb75ccc:     @Test
1:fb75ccc:     public void testHeadersFromFragment() throws Exception {
1:fb75ccc:         // Register the bundle that provides the SPI implementation.
1:fb75ccc:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:fb75ccc:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:fb75ccc: 
1:fb75ccc:         Dictionary<String, String> fragmentConsumerHeaders = new Hashtable<String, String>();
1:fb75ccc:         fragmentConsumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1:fb75ccc: 
1:fb75ccc:         Bundle fragment = EasyMock.createMock(Bundle.class);
1:fb75ccc:         EasyMock.expect(fragment.getHeaders()).andReturn(fragmentConsumerHeaders).anyTimes();
1:fb75ccc:         EasyMock.replay(fragment);
1:fb75ccc:         BundleRevision frev = EasyMock.createMock(BundleRevision.class);
1:fb75ccc:         EasyMock.expect(frev.getBundle()).andReturn(fragment).anyTimes();
1:fb75ccc:         EasyMock.replay(frev);
1:fb75ccc:         BundleRequirement req = EasyMock.createMock(BundleRequirement.class);
1:fb75ccc:         EasyMock.expect(req.getRevision()).andReturn(frev).anyTimes();
1:fb75ccc:         EasyMock.replay(req);
1:fb75ccc:         BundleWire wire = EasyMock.createMock(BundleWire.class);
1:fb75ccc:         EasyMock.expect(wire.getRequirement()).andReturn(req).anyTimes();
1:fb75ccc:         EasyMock.replay(wire);
1:fb75ccc:         List<BundleWire> wires = Collections.singletonList(wire);
1:fb75ccc:         BundleWiring wiring = EasyMock.createMock(BundleWiring.class);
1:fb75ccc:         EasyMock.expect(wiring.getProvidedWires("osgi.wiring.host")).andReturn(wires).anyTimes();
1:fb75ccc:         EasyMock.replay(wiring);
1:fb75ccc:         BundleRevision rev = EasyMock.createMock(BundleRevision.class);
1:fb75ccc:         EasyMock.expect(rev.getWiring()).andReturn(wiring).anyTimes();
1:fb75ccc:         EasyMock.replay(rev);
1:fb75ccc: 
1:fb75ccc:         Bundle consumerBundle = mockConsumerBundle(new Hashtable<String, String>(), rev, providerBundle);
1:fb75ccc:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:fb75ccc: 
1:fb75ccc:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:fb75ccc:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:fb75ccc: 
1:fb75ccc:         // Weave the TestClient class.
1:fb75ccc:         URL clsUrl = getClass().getResource("TestClient.class");
1:fb75ccc:         Assert.assertNotNull("Precondition", clsUrl);
1:fb75ccc: 
1:fb75ccc:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:fb75ccc:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:fb75ccc:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:fb75ccc:         wh.weave(wc);
1:fb75ccc:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:fb75ccc:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:fb75ccc:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:fb75ccc:         String di = wc.getDynamicImports().get(0);
1:fb75ccc:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1:fb75ccc: 
1:fb75ccc:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:fb75ccc:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:fb75ccc:         Class<?> cls = wc.getDefinedClass();
1:fb75ccc:         Method method = cls.getMethod("test", new Class [] {String.class});
1:fb75ccc:         Object result = method.invoke(cls.newInstance(), "hello");
1:fb75ccc:         Assert.assertEquals(Collections.singleton("olleh"), result);
1:fb75ccc: 
1:fb75ccc:     }
1:fb75ccc: 
1:6591ac7: 
1:6591ac7:     @Test
1:6591ac7:     public void testTCCLResetting() throws Exception {
1:6591ac7:         ClassLoader cl = new URLClassLoader(new URL [] {});
1:6591ac7:         Thread.currentThread().setContextClassLoader(cl);
1:6591ac7:         Assert.assertSame("Precondition", cl, Thread.currentThread().getContextClassLoader());
1:6591ac7: 
1:6591ac7:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
1:5e6f679:         consumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1:6591ac7: 
1:6591ac7:         // Register the bundle that provides the SPI implementation.
1:6591ac7:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:6591ac7: 
1:6591ac7:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:e126d45:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
1:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:6591ac7:         Assert.assertNotNull("Precondition", clsUrl);
1:6591ac7: 
1:6591ac7:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:6591ac7:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:6591ac7:         wh.weave(wc);
1:6591ac7:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:6591ac7:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:6591ac7:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:6591ac7:         String di = wc.getDynamicImports().get(0);
1:6591ac7:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         method.invoke(cls.newInstance(), "hi there");
1:6591ac7: 
1:6591ac7:         Assert.assertSame(cl, Thread.currentThread().getContextClassLoader());
1:6591ac7:     }
1:e126d45: 
1:6591ac7: 
1:6591ac7:     @Test
1:14bb556:     public void testTCCLResettingOnException() throws Exception {
1:14bb556:         ClassLoader cl = new URLClassLoader(new URL [] {});
1:14bb556:         Thread.currentThread().setContextClassLoader(cl);
1:14bb556:         Assert.assertSame("Precondition", cl, Thread.currentThread().getContextClassLoader());
1:14bb556: 
1:14bb556:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:8d934f9:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1:14bb556: 
1:14bb556:         Bundle providerBundle5 = mockProviderBundle("impl5", 1);
1:14bb556:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle5, new HashMap<String, Object>());
1:14bb556: 
1:14bb556:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle5);
1:14bb556:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:14bb556: 
1:14bb556:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle,providerBundle5);
1:14bb556:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:14bb556: 
1:14bb556:         // Weave the TestClient class.
1:14bb556:         URL clsUrl = getClass().getResource("TestClient.class");
1:14bb556:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:14bb556:         wh.weave(wc);
1:14bb556: 
1:14bb556:         Class<?> cls = wc.getDefinedClass();
1:14bb556:         Method method = cls.getMethod("test", new Class [] {String.class});
1:14bb556: 
1:14bb556:         // Invoke the woven class, check that it properly set the TCCL so that the implementation of impl5 is called.
1:14bb556:         // That implementation throws an exception, after which we are making sure that the TCCL is set back appropriately.
1:14bb556:         try {
1:14bb556:             method.invoke(cls.newInstance(), "hello");
1:14bb556:             Assert.fail("Invocation should have thrown an exception");
1:14bb556:         } catch (InvocationTargetException ite) {
1:14bb556:             RuntimeException re = (RuntimeException) ite.getCause();
1:14bb556:             String msg = re.getMessage();
1:14bb556:             Assert.assertEquals("Uh-oh: hello", msg);
1:14bb556: 
1:14bb556:             // The TCCL should have been reset correctly
1:14bb556:             Assert.assertSame(cl, Thread.currentThread().getContextClassLoader());
1:6591ac7:         }
1:6591ac7:     }
1:35cb846: 
1:6591ac7:     @Test
1:6591ac7:     public void testAltServiceLoaderLoadUnprocessed() throws Exception {
1:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle();
1:6591ac7: 
1:35cb846:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:5e6f679:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1:6591ac7:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1:6591ac7: 
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("UnaffectedTestClient.class");
1:6591ac7:         Assert.assertNotNull("Precondition", clsUrl);
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.UnaffectedTestClient", consumerBundle);
1:6591ac7:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:6591ac7:         Assert.assertEquals("The client is not affected so no additional imports should have been added",
1:6591ac7:             0, wc.getDynamicImports().size());
1:6591ac7: 
1:6591ac7:         // ok the weaving is done, now prepare the registry for the call
1:6591ac7:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1:6591ac7: 
3:6591ac7:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:6591ac7:         Assert.assertEquals("impl4", result);
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     @Test
1:6591ac7:     public void testMultipleProviders() throws Exception {
1:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle();
1:6591ac7: 
1:021618a:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:5e6f679:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1:6591ac7: 
1:6591ac7:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1:e126d45:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
2:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:35cb846:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:35cb846:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:6591ac7: 
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:11803af:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI files from impl1 and impl2 are visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "HELLO", "5"));
1:11803af:         Assert.assertEquals("All three services should be invoked", expected, result);
1:6591ac7:     }
1:6591ac7: 
1:a166d95:     /* This is currently not supported in the generic model
1:6591ac7:     @Test
1:6591ac7:     public void testClientSpecifyingProvider() throws Exception {
5:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:14bb556:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
1:5e6f679:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(bundle-symbolic-name=impl2)\"");
1:6591ac7: 
3:6591ac7:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
2:6591ac7:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:6591ac7: 
1:6591ac7:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2);
1:0028427:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
1:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it propertly sets the TCCL so that the
3:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:35cb846:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "HELLO5", result);
1:14bb556:     }
1:6591ac7: 
1:6591ac7:     @Test
1:6591ac7:     public void testClientSpecifyingProviderVersion() throws Exception {
1:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:5e6f679:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
1:5e6f679:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(&(bundle-symbolic-name=impl2)(bundle-version=1.2.3))\"");
1:6591ac7: 
1:6591ac7:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:6591ac7:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:6591ac7:         Bundle providerBundle3 = mockProviderBundle("impl2_123", 3, new Version(1, 2, 3));
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3, new HashMap<String, Object>());
1:6591ac7: 
1:6591ac7:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle3);
1:be5d5b1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle3);
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:6591ac7:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "Updated!hello!Updated", result);
1:6591ac7:     }
1:be5d5b1: 
1:6591ac7:     @Test
1:6591ac7:     public void testClientMultipleTargetBundles() throws Exception {
1:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:5e6f679:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
1:5e6f679:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(|(bundle-symbolic-name=impl1)(bundle-symbolic-name=impl4))\"");
1:6591ac7: 
1:6591ac7:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:6591ac7:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
2:6591ac7:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
1:6591ac7: 
1:021618a:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:021618a:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:021618a:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:021618a: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:021618a:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
2:6591ac7:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);
1:6591ac7:     }
1:a166d95:     */
1:6591ac7: 
1:6591ac7:     @Test
1:35cb846:     public void testServiceFiltering() throws Exception {
1:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a166d95:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + "," +
1:a166d95:             SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE +
1:a166d95:                 "; filter:=\"(osgi.serviceloader=org.apache.aries.mytest.AltSPI)\";");
1:6591ac7: 
1:6591ac7:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:6591ac7:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
1:6591ac7: 
1:a166d95:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle2, providerBundle4);
1:021618a:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
1:a166d95:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle2, providerBundle4);
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:a166d95:         // Invoke the woven class. Since MySPI wasn't selected nothing should be returned
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Assert.assertEquals("No providers should be selected for this one", Collections.emptySet(), result);
1:6591ac7: 
1:021618a:         // Weave the AltTestClient class.
1:021618a:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:021618a:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:6591ac7:         wh.weave(wc2);
1:6591ac7: 
1:021618a:         // Invoke the AltTestClient
1:6591ac7:         Class<?> cls2 = wc2.getDefinedClass();
1:021618a:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:021618a:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
1:a166d95:         Assert.assertEquals("All Providers should be selected", (4096L*4096L)-4096L, result2);
1:a166d95: 
1:6591ac7:     }
1:021618a: 
1:6591ac7:     @Test
1:35cb846:     public void testServiceFilteringAlternative() throws Exception {
1:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a166d95:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + "," +
1:a166d95:                 SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE +
1:a166d95:                 "; filter:=\"(|(!(osgi.serviceloader=org.apache.aries.mytest.AltSPI))" +
1:a166d95:                             "(&(osgi.serviceloader=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4)))\"");
1:021618a: 
1:021618a:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:021618a:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:021618a:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:a166d95:         HashMap<String, Object> attrs2 = new HashMap<String, Object>();
1:a166d95:         attrs2.put("bundle-symbolic-name", "impl2");
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, attrs2);
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, attrs2);
1:a166d95:         HashMap<String, Object> attrs4 = new HashMap<String, Object>();
1:a166d95:         attrs4.put("bundle-symbolic-name", "impl4");
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, attrs4);
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, attrs4);
1:6591ac7: 
1:021618a:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:021618a:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
1:021618a:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:021618a:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:021618a:         // Weave the TestClient class.
1:021618a:         URL clsUrl = getClass().getResource("TestClient.class");
1:021618a:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:021618a:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:021618a:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:021618a:         Method method = cls.getMethod("test", new Class [] {String.class});
1:021618a:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "HELLO", "5", "impl4"));
1:11803af:         Assert.assertEquals("All providers should be selected for this one", expected, result);
1:6591ac7: 
1:021618a:         // Weave the AltTestClient class.
1:021618a:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:021618a:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:021618a:         wh.weave(wc2);
1:6591ac7: 
1:021618a:         // Invoke the AltTestClient
1:021618a:         Class<?> cls2 = wc2.getDefinedClass();
1:021618a:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:021618a:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
1:a166d95:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L, result2);
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     @Test
1:35cb846:     public void testServiceFilteringNarrow() throws Exception {
1:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a166d95:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + "," +
1:a166d95:                 SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE +
1:a166d95:                 "; filter:=\"(&(osgi.serviceloader=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4))\"");
1:6591ac7: 
1:6591ac7:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:6591ac7:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:6591ac7:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
1:7158c23:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:a166d95:         HashMap<String, Object> attrs2 = new HashMap<String, Object>();
1:a166d95:         attrs2.put("bundle-symbolic-name", "impl2");
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, attrs2);
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, attrs2);
1:a166d95:         HashMap<String, Object> attrs4 = new HashMap<String, Object>();
1:a166d95:         attrs4.put("bundle-symbolic-name", "impl4");
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, attrs4);
1:a166d95:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, attrs4);
1:6591ac7: 
3:6591ac7:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:021618a:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:6591ac7: 
3:6591ac7:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:6591ac7:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:6591ac7: 
1:6591ac7:         // Weave the TestClient class.
1:6591ac7:         URL clsUrl = getClass().getResource("TestClient.class");
1:6591ac7:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:6591ac7:         wh.weave(wc);
1:6591ac7: 
1:6591ac7:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:6591ac7:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:6591ac7:         Class<?> cls = wc.getDefinedClass();
1:6591ac7:         Method method = cls.getMethod("test", new Class [] {String.class});
1:6591ac7:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Assert.assertEquals("No providers should be selected here", Collections.emptySet(), result);
1:6591ac7: 
1:6591ac7:         // Weave the AltTestClient class.
1:6591ac7:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:6591ac7:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:6591ac7:         wh.weave(wc2);
1:6591ac7: 
1:6591ac7:         // Invoke the AltTestClient
1:6591ac7:         Class<?> cls2 = wc2.getDefinedClass();
1:6591ac7:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:6591ac7:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
1:a166d95:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L, result2);
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     @Test
1:35cb846:     public void testFilteringCustomAttribute() throws Exception {
1:6591ac7:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:a166d95:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + ", " +
1:a166d95:             SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE + "; filter:=\"(approval=global)\"");
1:35cb846: 
1:6591ac7:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:6591ac7:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:35cb846:         Map<String, Object> attrs1 = new HashMap<String, Object>();
1:35cb846:         attrs1.put("approval", "local");
1:35cb846:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, attrs1);
1:35cb846: 
1:35cb846:         Map<String, Object> attrs2 = new HashMap<String, Object>();
1:35cb846:         attrs2.put("approval", "global");
1:35cb846:         attrs2.put("other", "attribute");
1:35cb846:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, attrs2);
1:35cb846: 
1:35cb846:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2);
1:35cb846:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1:35cb846: 
1:35cb846:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);
1:35cb846:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1:35cb846: 
1:35cb846:         // Weave the TestClient class.
1:35cb846:         URL clsUrl = getClass().getResource("TestClient.class");
1:35cb846:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:35cb846:         wh.weave(wc);
1:6591ac7: 
1:35cb846:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:35cb846:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:35cb846:         Class<?> cls = wc.getDefinedClass();
1:35cb846:         Method method = cls.getMethod("test", new Class [] {String.class});
1:35cb846:         Object result = method.invoke(cls.newInstance(), "hello");
1:11803af:         Set<String> expected = new HashSet<String>(Arrays.asList("HELLO", "5"));
1:11803af:         Assert.assertEquals("Only the services from bundle impl2 should be selected", expected, result);
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private Bundle mockSpiFlyBundle(Bundle ... bundles) throws Exception {
1:6591ac7:         return mockSpiFlyBundle("spifly", new Version(1, 0, 0), bundles);
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private Bundle mockSpiFlyBundle(String bsn, Version version, Bundle ... bundles) throws Exception {
1:6591ac7:         Bundle spiFlyBundle = EasyMock.createMock(Bundle.class);
1:6591ac7: 
1:6591ac7:         BundleContext spiFlyBundleContext = EasyMock.createMock(BundleContext.class);
1:6591ac7:         EasyMock.expect(spiFlyBundleContext.getBundle()).andReturn(spiFlyBundle).anyTimes();
1:6591ac7:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(bundles));
1:6591ac7:         allBundles.add(spiFlyBundle);
1:6591ac7:         EasyMock.expect(spiFlyBundleContext.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:6591ac7:         EasyMock.replay(spiFlyBundleContext);
1:6591ac7: 
1:6591ac7:         EasyMock.expect(spiFlyBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:6591ac7:         EasyMock.expect(spiFlyBundle.getVersion()).andReturn(version).anyTimes();
1:6591ac7:         EasyMock.expect(spiFlyBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:6591ac7:         EasyMock.expect(spiFlyBundle.getBundleContext()).andReturn(spiFlyBundleContext).anyTimes();
1:6591ac7:         EasyMock.replay(spiFlyBundle);
1:6591ac7: 
1:6591ac7:         // Set the bundle context for testing purposes
1:6591ac7:         Field bcField = BaseActivator.class.getDeclaredField("bundleContext");
1:6591ac7:         bcField.setAccessible(true);
1:6591ac7:         bcField.set(activator, spiFlyBundle.getBundleContext());
1:6591ac7: 
1:6591ac7:         return spiFlyBundle;
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private Bundle mockProviderBundle(String subdir, long id) throws Exception {
1:6591ac7:         return mockProviderBundle(subdir, id, Version.emptyVersion);
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private Bundle mockProviderBundle(String subdir, long id, Version version) throws Exception {
1:6591ac7:         URL url = getClass().getResource("/" + getClass().getName().replace('.', '/') + ".class");
1:6591ac7:         File classFile = new File(url.getFile());
1:6591ac7:         File baseDir = new File(classFile.getParentFile(), subdir);
1:6591ac7:         File directory = new File(baseDir, "/META-INF/services");
1:6591ac7:         final List<String> classNames = new ArrayList<String>();
1:6591ac7: 
1:6591ac7:         // Do a directory listing of the applicable META-INF/services directory
1:6591ac7:         List<String> resources = new ArrayList<String>();
1:6591ac7:         for (File f : directory.listFiles()) {
1:6591ac7:             String fileName = f.getName();
1:6591ac7:             if (fileName.startsWith(".") || fileName.endsWith("."))
1:6591ac7:                 continue;
1:6591ac7: 
1:6591ac7:             classNames.addAll(getClassNames(f));
1:6591ac7: 
1:6591ac7:             // Needs to be something like: META-INF/services/org.apache.aries.mytest.MySPI
1:6591ac7:             String path = f.getAbsolutePath().substring(baseDir.getAbsolutePath().length());
1:6591ac7:             path = path.replace('\\', '/');
1:6591ac7:             if (path.startsWith("/")) {
1:6591ac7:                 path = path.substring(1);
1:6591ac7:             }
1:6591ac7:             resources.add(path);
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         // Set up the classloader that will be used by the ASM-generated code as the TCCL.
1:6591ac7:         // It can load a META-INF/services file
1:6591ac7:         final ClassLoader cl = new TestProviderBundleClassLoader(subdir, resources.toArray(new String [] {}));
1:6591ac7: 
1:6591ac7:         final List<String> classResources = new ArrayList<String>();
1:6591ac7:         for(String className : classNames) {
1:6591ac7:             classResources.add("/" + className.replace('.', '/') + ".class");
1:6591ac7:         }
1:0a02617: 
1:0a02617:         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);
1:0a02617:         EasyMock.replay(bc);
1:0a02617: 
1:6591ac7:         Bundle providerBundle = EasyMock.createMock(Bundle.class);
1:6591ac7:         String bsn = subdir;
1:6591ac7:         int idx = bsn.indexOf('_');
1:6591ac7:         if (idx > 0) {
1:6591ac7:             bsn = bsn.substring(0, idx);
1:6591ac7:         }
1:6591ac7:         EasyMock.expect(providerBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:6591ac7:         EasyMock.expect(providerBundle.getBundleId()).andReturn(id).anyTimes();
1:0a02617:         EasyMock.expect(providerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:6591ac7:         EasyMock.expect(providerBundle.getVersion()).andReturn(version).anyTimes();
1:6591ac7:         EasyMock.expect(providerBundle.getEntryPaths("/")).andAnswer(new IAnswer<Enumeration<String>>() {
1:6591ac7:             @Override
1:6591ac7:             public Enumeration<String> answer() throws Throwable {
1:6591ac7:                 return Collections.enumeration(classResources);
1:6591ac7:             }
1:6591ac7:         }).anyTimes();
1:6591ac7:         EasyMock.<Class<?>>expect(providerBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:6591ac7:             @Override
1:6591ac7:             public Class<?> answer() throws Throwable {
1:6591ac7:                 String  name = (String) EasyMock.getCurrentArguments()[0];
1:6591ac7:                 if (!classNames.contains(name)) {
1:6591ac7:                     throw new ClassCastException(name);
1:6591ac7:                 }
1:6591ac7:                 return cl.loadClass(name);
1:6591ac7:             }
1:6591ac7:         }).anyTimes();
1:6591ac7:         EasyMock.replay(providerBundle);
1:6591ac7:         return providerBundle;
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private Collection<String> getClassNames(File f) throws IOException {
1:6591ac7:         List<String> names = new ArrayList<String>();
1:6591ac7: 
1:6591ac7:         BufferedReader br = new BufferedReader(new FileReader(f));
1:6591ac7:         try {
1:6591ac7:             String line = null;
1:6591ac7:             while((line = br.readLine()) != null) {
1:6591ac7:                 names.add(line.trim());
1:6591ac7:             }
1:6591ac7:         } finally {
1:6591ac7:             br.close();
1:6591ac7:         }
1:6591ac7:         return names;
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, Bundle ... otherBundles) {
1:fb75ccc:         return mockConsumerBundle(headers, null, otherBundles);
1:fb75ccc:     }
1:fb75ccc: 
1:fb75ccc:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, BundleRevision rev,
1:fb75ccc:             Bundle ... otherBundles) {
1:6591ac7:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load()
1:6591ac7:         // or another SPI invocation.
1:6591ac7:         BundleContext bc = EasyMock.createMock(BundleContext.class);
1:6591ac7: 
1:6591ac7:         Bundle consumerBundle = EasyMock.createMock(Bundle.class);
1:6591ac7:         EasyMock.expect(consumerBundle.getSymbolicName()).andReturn("testConsumer").anyTimes();
1:0028427:         EasyMock.expect(consumerBundle.getVersion()).andReturn(new Version(1, 2, 3)).anyTimes();
1:6591ac7:         EasyMock.expect(consumerBundle.getHeaders()).andReturn(headers).anyTimes();
1:6591ac7:         EasyMock.expect(consumerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:6591ac7:         EasyMock.expect(consumerBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:fb75ccc:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(rev).anyTimes();
1:fb75ccc: 
1:6591ac7:         EasyMock.replay(consumerBundle);
1:6591ac7: 
1:6591ac7:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(otherBundles));
1:6591ac7:         allBundles.add(consumerBundle);
1:6591ac7:         EasyMock.expect(bc.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:6591ac7:         EasyMock.replay(bc);
1:6591ac7: 
1:6591ac7:         return consumerBundle;
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     // A classloader that loads anything starting with org.apache.aries.spifly.dynamic.impl1 from it
1:6591ac7:     // and the rest from the parent. This is to mimic a bundle that holds a specific SPI implementation.
1:6591ac7:     public static class TestProviderBundleClassLoader extends URLClassLoader {
1:6591ac7:         private final List<String> resources;
1:6591ac7:         private final String prefix;
1:6591ac7:         private final String classPrefix;
1:6591ac7:         private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<String, Class<?>>();
1:6591ac7: 
1:6591ac7:         public TestProviderBundleClassLoader(String subdir, String ... resources) {
1:6591ac7:             super(new URL [] {}, TestProviderBundleClassLoader.class.getClassLoader());
1:6591ac7: 
1:6591ac7:             this.prefix = TestProviderBundleClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:6591ac7:             this.classPrefix = prefix.replace('/', '.');
1:6591ac7:             this.resources = Arrays.asList(resources);
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:6591ac7:             if (name.startsWith(classPrefix))
1:6591ac7:                 return loadClassLocal(name);
1:6591ac7: 
1:6591ac7:             return super.loadClass(name);
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:6591ac7:             if (name.startsWith(classPrefix)) {
1:6591ac7:                 Class<?> cls = loadClassLocal(name);
1:6591ac7:                 if (resolve)
1:6591ac7:                     resolveClass(cls);
1:6591ac7: 
1:6591ac7:                 return cls;
1:6591ac7:             }
1:6591ac7: 
1:6591ac7:             return super.loadClass(name, resolve);
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         protected Class<?> loadClassLocal(String name) throws ClassNotFoundException {
1:6591ac7:             Class<?> prevLoaded = loadedClasses.get(name);
1:6591ac7:             if (prevLoaded != null)
1:6591ac7:                 return prevLoaded;
1:6591ac7: 
1:6591ac7:             URL res = TestProviderBundleClassLoader.class.getClassLoader().getResource(name.replace('.', '/') + ".class");
1:6591ac7:             try {
1:6591ac7:                 byte[] bytes = Streams.suck(res.openStream());
1:6591ac7:                 Class<?> cls = defineClass(name, bytes, 0, bytes.length);
1:6591ac7:                 loadedClasses.put(name, cls);
1:6591ac7:                 return cls;
1:6591ac7:             } catch (Exception e) {
1:6591ac7:                 throw new ClassNotFoundException(name, e);
1:6591ac7:             }
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public URL findResource(String name) {
1:6591ac7:             if (resources.contains(name)) {
1:6591ac7:                 return getClass().getClassLoader().getResource(prefix + name);
1:6591ac7:             } else {
1:6591ac7:                 return super.findResource(name);
1:6591ac7:             }
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public Enumeration<URL> findResources(String name) throws IOException {
1:6591ac7:             if (resources.contains(name)) {
1:6591ac7:                 return getClass().getClassLoader().getResources(prefix + name);
1:6591ac7:             } else {
1:6591ac7:                 return super.findResources(name);
1:6591ac7:             }
1:6591ac7:         }
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private static class MyWovenClass implements WovenClass {
1:6591ac7:         byte [] bytes;
1:6591ac7:         final String className;
1:6591ac7:         final Bundle bundleContainingOriginalClass;
1:6591ac7:         List<String> dynamicImports = new ArrayList<String>();
1:6591ac7:         boolean weavingComplete = false;
1:6591ac7: 
1:6591ac7:         private MyWovenClass(URL clazz, String name, Bundle bundle) throws Exception {
1:6591ac7:             bytes = Streams.suck(clazz.openStream());
1:6591ac7:             className = name;
1:6591ac7:             bundleContainingOriginalClass = bundle;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public byte[] getBytes() {
1:6591ac7:             return bytes;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public void setBytes(byte[] newBytes) {
1:6591ac7:             bytes = newBytes;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public List<String> getDynamicImports() {
1:6591ac7:             return dynamicImports;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public boolean isWeavingComplete() {
1:6591ac7:             return weavingComplete;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public String getClassName() {
1:6591ac7:             return className;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public ProtectionDomain getProtectionDomain() {
1:6591ac7:             return null;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public Class<?> getDefinedClass() {
1:6591ac7:             try {
1:6591ac7:                 weavingComplete = true;
1:6591ac7:                 return new MyWovenClassClassLoader(className, getBytes(), getClass().getClassLoader(), bundleContainingOriginalClass).loadClass(className);
1:6591ac7:             } catch (ClassNotFoundException e) {
1:6591ac7:                 e.printStackTrace();
1:6591ac7:                 return null;
1:6591ac7:             }
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public BundleWiring getBundleWiring() {
1:6591ac7:             BundleWiring bw = EasyMock.createMock(BundleWiring.class);
1:6591ac7:             EasyMock.expect(bw.getBundle()).andReturn(bundleContainingOriginalClass);
1:c7183ef:             EasyMock.expect(bw.getClassLoader()).andReturn(getClass().getClassLoader());
1:6591ac7:             EasyMock.replay(bw);
1:6591ac7:             return bw;
1:6591ac7:         }
1:6591ac7:     }
1:6591ac7: 
1:6591ac7:     private static class MyWovenClassClassLoader extends ClassLoader implements BundleReference {
1:6591ac7:         private final String className;
1:6591ac7:         private final Bundle bundle;
1:6591ac7:         private final byte [] bytes;
1:6591ac7:         private Class<?> wovenClass;
1:6591ac7: 
1:6591ac7:         public MyWovenClassClassLoader(String className, byte[] bytes, ClassLoader parent, Bundle bundle) {
1:6591ac7:             super(parent);
1:6591ac7: 
1:6591ac7:             this.className = className;
1:6591ac7:             this.bundle = bundle;
1:6591ac7:             this.bytes = bytes;
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         protected synchronized Class<?> loadClass(String name, boolean resolve)
1:6591ac7:                 throws ClassNotFoundException {
1:6591ac7:             if (name.equals(className)) {
1:6591ac7:                 if (wovenClass == null)
1:6591ac7:                     wovenClass = defineClass(className, bytes, 0, bytes.length);
1:6591ac7: 
1:6591ac7:                 return wovenClass;
1:6591ac7:             } else {
1:6591ac7:                 return super.loadClass(name, resolve);
1:6591ac7:             }
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:6591ac7:             return loadClass(name, false);
1:6591ac7:         }
1:6591ac7: 
1:6591ac7:         @Override
1:6591ac7:         public Bundle getBundle() {
1:6591ac7:             return bundle;
1:6591ac7:         }
1:6591ac7:     }
1:6591ac7: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:fb75ccc
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleRequirement;
1: import org.osgi.framework.wiring.BundleWire;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testHeadersFromFragment() throws Exception {
1:         // Register the bundle that provides the SPI implementation.
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
1: 
1:         Dictionary<String, String> fragmentConsumerHeaders = new Hashtable<String, String>();
1:         fragmentConsumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
1: 
1:         Bundle fragment = EasyMock.createMock(Bundle.class);
1:         EasyMock.expect(fragment.getHeaders()).andReturn(fragmentConsumerHeaders).anyTimes();
1:         EasyMock.replay(fragment);
1:         BundleRevision frev = EasyMock.createMock(BundleRevision.class);
1:         EasyMock.expect(frev.getBundle()).andReturn(fragment).anyTimes();
1:         EasyMock.replay(frev);
1:         BundleRequirement req = EasyMock.createMock(BundleRequirement.class);
1:         EasyMock.expect(req.getRevision()).andReturn(frev).anyTimes();
1:         EasyMock.replay(req);
1:         BundleWire wire = EasyMock.createMock(BundleWire.class);
1:         EasyMock.expect(wire.getRequirement()).andReturn(req).anyTimes();
1:         EasyMock.replay(wire);
1:         List<BundleWire> wires = Collections.singletonList(wire);
1:         BundleWiring wiring = EasyMock.createMock(BundleWiring.class);
1:         EasyMock.expect(wiring.getProvidedWires("osgi.wiring.host")).andReturn(wires).anyTimes();
1:         EasyMock.replay(wiring);
1:         BundleRevision rev = EasyMock.createMock(BundleRevision.class);
1:         EasyMock.expect(rev.getWiring()).andReturn(wiring).anyTimes();
1:         EasyMock.replay(rev);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(new Hashtable<String, String>(), rev, providerBundle);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
1: 
1:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:         String di = wc.getDynamicImports().get(0);
1:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1: 
1:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals(Collections.singleton("olleh"), result);
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return mockConsumerBundle(headers, null, otherBundles);
1:     }
1: 
1:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, BundleRevision rev,
1:             Bundle ... otherBundles) {
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(rev).anyTimes();
1: 
commit:7dabe8c
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleRevision;
/////////////////////////////////////////////////////////////////////////
0:         EasyMock.expect(consumerBundle.adapt(BundleRevision.class)).andReturn(null).anyTimes();
commit:11803af
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals(Collections.singleton("olleh"), result);
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "HELLO", "5"));
1:         Assert.assertEquals("All three services should be invoked", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("No providers should be selected for this one", Collections.emptySet(), result);
/////////////////////////////////////////////////////////////////////////
1:         Set<String> expected = new HashSet<String>(Arrays.asList("olleh", "HELLO", "5", "impl4"));
1:         Assert.assertEquals("All providers should be selected for this one", expected, result);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("No providers should be selected here", Collections.emptySet(), result);
/////////////////////////////////////////////////////////////////////////
1:         Set<String> expected = new HashSet<String>(Arrays.asList("HELLO", "5"));
1:         Assert.assertEquals("Only the services from bundle impl2 should be selected", expected, result);
commit:e9a5257
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.spifly.SpiFlyConstants;
commit:8d934f9
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
commit:a166d95
/////////////////////////////////////////////////////////////////////////
1:     /* This is currently not supported in the generic model
/////////////////////////////////////////////////////////////////////////
1:     */
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + "," +
1:             SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE +
1:                 "; filter:=\"(osgi.serviceloader=org.apache.aries.mytest.AltSPI)\";");
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle2, providerBundle4);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle2, providerBundle4);
/////////////////////////////////////////////////////////////////////////
1:         // Invoke the woven class. Since MySPI wasn't selected nothing should be returned
0:         Assert.assertEquals("No providers should be selected for this one", "", result);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("All Providers should be selected", (4096L*4096L)-4096L, result2);
1: 
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + "," +
1:                 SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE +
1:                 "; filter:=\"(|(!(osgi.serviceloader=org.apache.aries.mytest.AltSPI))" +
1:                             "(&(osgi.serviceloader=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4)))\"");
1:         HashMap<String, Object> attrs2 = new HashMap<String, Object>();
1:         attrs2.put("bundle-symbolic-name", "impl2");
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, attrs2);
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, attrs2);
1:         HashMap<String, Object> attrs4 = new HashMap<String, Object>();
1:         attrs4.put("bundle-symbolic-name", "impl4");
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, attrs4);
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, attrs4);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L, result2);
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + "," +
1:                 SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE +
1:                 "; filter:=\"(&(osgi.serviceloader=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4))\"");
1:         HashMap<String, Object> attrs2 = new HashMap<String, Object>();
1:         attrs2.put("bundle-symbolic-name", "impl2");
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, attrs2);
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, attrs2);
1:         HashMap<String, Object> attrs4 = new HashMap<String, Object>();
1:         attrs4.put("bundle-symbolic-name", "impl4");
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, attrs4);
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, attrs4);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L, result2);
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT + ", " +
1:             SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE + "; filter:=\"(approval=global)\"");
commit:14bb556
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1:     public void testTCCLResettingOnException() throws Exception {
1:         ClassLoader cl = new URLClassLoader(new URL [] {});
1:         Thread.currentThread().setContextClassLoader(cl);
1:         Assert.assertSame("Precondition", cl, Thread.currentThread().getContextClassLoader());
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
0:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(bundle-symbolic-name=impl5)\"");
1: 
1:         Bundle providerBundle5 = mockProviderBundle("impl5", 1);
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle5, new HashMap<String, Object>());
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle5);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle,providerBundle5);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1: 
1:         // Invoke the woven class, check that it properly set the TCCL so that the implementation of impl5 is called.
1:         // That implementation throws an exception, after which we are making sure that the TCCL is set back appropriately.
1:         try {
1:             method.invoke(cls.newInstance(), "hello");
1:             Assert.fail("Invocation should have thrown an exception");
1:         } catch (InvocationTargetException ite) {
1:             RuntimeException re = (RuntimeException) ite.getCause();
1:             String msg = re.getMessage();
1:             Assert.assertEquals("Uh-oh: hello", msg);
1: 
1:             // The TCCL should have been reset correctly
1:             Assert.assertSame(cl, Thread.currentThread().getContextClassLoader());
1:         }
/////////////////////////////////////////////////////////////////////////
commit:5e6f679
/////////////////////////////////////////////////////////////////////////
1:         consumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
/////////////////////////////////////////////////////////////////////////
1:         consumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT);
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
1:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(bundle-symbolic-name=impl2)\"");
/////////////////////////////////////////////////////////////////////////
1:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
1:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(&(bundle-symbolic-name=impl2)(bundle-version=1.2.3))\"");
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
1:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(|(bundle-symbolic-name=impl1)(bundle-symbolic-name=impl4))\"");
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
0:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(|(" + SpiFlyConstants.CONSUMED_SPI_CONDITION + "=org.apache.aries.mytest.MySPI)" +
0:                 "(&(" + SpiFlyConstants.CONSUMED_SPI_CONDITION + "=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4)))\"");
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
0:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(|(!(" + SpiFlyConstants.CONSUMED_SPI_CONDITION + "=org.apache.aries.mytest.AltSPI))" +
0:                 "(&(" + SpiFlyConstants.CONSUMED_SPI_CONDITION + "=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4)))\"");
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
0:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(&(" + SpiFlyConstants.CONSUMED_SPI_CONDITION + "=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4))\"");
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, SpiFlyConstants.CLIENT_REQUIREMENT +
0:                 "; " + SpiFlyConstants.PROVIDER_FILTER_DIRECTIVE + ":=\"(approval=global)\"");
commit:c7183ef
/////////////////////////////////////////////////////////////////////////
1:     public void testBasicServiceLoaderUsage() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             EasyMock.expect(bw.getClassLoader()).andReturn(getClass().getClassLoader());
commit:0a02617
/////////////////////////////////////////////////////////////////////////
1: 
1:         BundleContext bc = EasyMock.createNiceMock(BundleContext.class);
1:         EasyMock.replay(bc);
1: 
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(providerBundle.getBundleContext()).andReturn(bc).anyTimes();
commit:7158c23
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
1:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
/////////////////////////////////////////////////////////////////////////
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4, new HashMap<String, Object>());
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4, new HashMap<String, Object>());
commit:35cb846
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     public void testServiceFiltering() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testServiceFilteringAlternative() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testServiceFilteringNarrow() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testFilteringCustomAttribute() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active; filter:=\"(approval=global)\"");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Map<String, Object> attrs1 = new HashMap<String, Object>();
1:         attrs1.put("approval", "local");
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1, attrs1);
1: 
1:         Map<String, Object> attrs2 = new HashMap<String, Object>();
1:         attrs2.put("approval", "global");
1:         attrs2.put("other", "attribute");
1:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2, attrs2);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "HELLO5", result);
commit:021618a
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY,
0:                 "osgi.spi.provider; effective:=active; filter:=\"(|(bundle-symbolic-name=impl1)(bundle-symbolic-name=impl4))\"");
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY,
0:                 "osgi.spi.provider; effective:=active; filter:=\"(|(service=org.apache.aries.mytest.MySPI)" +
0:                 "(&(service=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4)))\"");
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
/////////////////////////////////////////////////////////////////////////
0:     public void testClientSpecificProviderLoadArgument2() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY,
0:                 "osgi.spi.provider; effective:=active; filter:=\"(|(!(service=org.apache.aries.mytest.AltSPI))" +
0:                 "(&(service=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4)))\"");
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
/////////////////////////////////////////////////////////////////////////
0:         Assert.assertEquals("All providers should be selected for this one", "ollehHELLO5impl4", result);
1:         // Weave the AltTestClient class.
1:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:         // Invoke the AltTestClient
1:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
0:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L*4096L, result2);
0:     public void testClientSpecificProviderLoadArgument3() throws Exception {
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY,
0:                 "osgi.spi.provider; effective:=active; filter:=\"" +
0:                 "(&(service=org.apache.aries.mytest.AltSPI)(bundle-symbolic-name=impl4))\"");
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("No providers should be selected here", "", result);
1:         // Weave the AltTestClient class.
1:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:         wh.weave(wc2);
1:         // Invoke the AltTestClient
1:         Class<?> cls2 = wc2.getDefinedClass();
1:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
0:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L*4096L, result2);
0:     public void testCustomAttributeMatching() {
0:         // TODO
commit:be5d5b1
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active; filter:=\"(&(bundle-symbolic-name=impl2)(bundle-version=1.2.3))\"");
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
/////////////////////////////////////////////////////////////////////////
1: 
commit:0028427
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active; filter:=\"(bundle-symbolic-name=impl2)\"");
/////////////////////////////////////////////////////////////////////////
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
/////////////////////////////////////////////////////////////////////////
0:     /* Not yet supported in the generic capability model
/////////////////////////////////////////////////////////////////////////
1:         EasyMock.expect(consumerBundle.getVersion()).andReturn(new Version(1, 2, 3)).anyTimes();
commit:e126d45
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         consumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active");
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active");
/////////////////////////////////////////////////////////////////////////
0:         headers.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active");
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
/////////////////////////////////////////////////////////////////////////
0:     /* Not yet supported in the generic capability model
/////////////////////////////////////////////////////////////////////////
1:     */
/////////////////////////////////////////////////////////////////////////
0:     /* Not yet supported in the generic capability model
/////////////////////////////////////////////////////////////////////////
0:     */
/////////////////////////////////////////////////////////////////////////
0:     /*
/////////////////////////////////////////////////////////////////////////
0:     */
commit:6591ac7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  */
1: package org.apache.aries.spifly.dynamic;
1: 
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.FileReader;
1: import java.io.IOException;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Method;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.security.ProtectionDomain;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: 
1: import org.apache.aries.spifly.BaseActivator;
1: import org.apache.aries.spifly.Streams;
0: import org.apache.aries.spifly.api.SpiFlyConstants;
1: import org.easymock.EasyMock;
1: import org.easymock.IAnswer;
1: import org.junit.After;
1: import org.junit.Assert;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleReference;
1: import org.osgi.framework.Version;
1: import org.osgi.framework.hooks.weaving.WeavingHook;
1: import org.osgi.framework.hooks.weaving.WovenClass;
1: import org.osgi.framework.wiring.BundleWiring;
1: 
1: public class ClientWeavingHookGenericCapabilityTest {
1:     DynamicWeavingActivator activator;
1: 
1:     @Before
1:     public void setUp() {
1:         activator = new DynamicWeavingActivator();
1:         BaseActivator.activator = activator;
1:     }
1: 
1:     @After
1:     public void tearDown() {
1:         BaseActivator.activator = null;
1:         activator = null;
1:     }
1: 
1:     @Test
0:     public void testBasicServiveLoaderUsage() throws Exception {
1:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
0:         consumerHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, "osgi.spi.provider; effective:=active");
1: 
1:         // Register the bundle that provides the SPI implementation.
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
1:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.REQUIRE_CAPABILITY);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
1: 
1:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:         String di = wc.getDynamicImports().get(0);
1:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1: 
1:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("olleh", result);
1:     }
1: 
0: /*
1:     @Test
1:     public void testTCCLResetting() throws Exception {
1:         ClassLoader cl = new URLClassLoader(new URL [] {});
1:         Thread.currentThread().setContextClassLoader(cl);
1:         Assert.assertSame("Precondition", cl, Thread.currentThread().getContextClassLoader());
1: 
1:         Dictionary<String, String> consumerHeaders = new Hashtable<String, String>();
0:         consumerHeaders.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1: 
1:         // Register the bundle that provides the SPI implementation.
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(consumerHeaders, providerBundle);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle("spifly", Version.parseVersion("1.9.4"), consumerBundle, providerBundle);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
1: 
1:         String clientClassName = "org.apache.aries.spifly.dynamic.TestClient";
1:         WovenClass wc = new MyWovenClass(clsUrl, clientClassName, consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1:         Assert.assertEquals(1, wc.getDynamicImports().size());
1:         String di1 = "org.apache.aries.spifly;bundle-symbolic-name=spifly;bundle-version=1.9.4";
1:         String di2 = "org.apache.aries.spifly;bundle-version=1.9.4;bundle-symbolic-name=spifly";
1:         String di = wc.getDynamicImports().get(0);
1:         Assert.assertTrue("Weaving should have added a dynamic import", di1.equals(di) || di2.equals(di));
1: 
1:         // Invoke the woven class and check that it properly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         method.invoke(cls.newInstance(), "hi there");
1: 
1:         Assert.assertSame(cl, Thread.currentThread().getContextClassLoader());
1:     }
1: 
1:     @Test
0:     public void testTCCLResettingOnException() {
0:         // TODO
1:     }
1: 
1:     @Test
1:     public void testAltServiceLoaderLoadUnprocessed() throws Exception {
1:         Bundle spiFlyBundle = mockSpiFlyBundle();
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
1: 
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("UnaffectedTestClient.class");
1:         Assert.assertNotNull("Precondition", clsUrl);
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.UnaffectedTestClient", consumerBundle);
1:         Assert.assertEquals("Precondition", 0, wc.getDynamicImports().size());
1:         wh.weave(wc);
1: 
1:         Assert.assertEquals("The client is not affected so no additional imports should have been added",
1:             0, wc.getDynamicImports().size());
1: 
1:         // ok the weaving is done, now prepare the registry for the call
1:         Bundle providerBundle = mockProviderBundle("impl1", 1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl1 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals("impl4", result);
1:     }
1: 
1:     @Test
1:     public void testMultipleProviders() throws Exception {
1:         Bundle spiFlyBundle = mockSpiFlyBundle();
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "*");
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, spiFlyBundle);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1: 
0:         // Register in reverse order to make sure the order in which bundles are sorted is correct
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI files from impl1 and impl2 are visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("All three services should be invoked in the correct order", "ollehHELLO5", result);
1:     }
1: 
1:     @Test
1:     public void testClientSpecifyingProvider() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "java.util.ServiceLoader#load(java.lang.Class);bundle=impl2");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "HELLO5", result);
1:     }
1: 
1:     @Test
1:     public void testClientSpecifyingProviderVersion() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "java.util.ServiceLoader#load(java.lang.Class);bundle=impl2:version=1.2.3");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle3 = mockProviderBundle("impl2_123", 3, new Version(1, 2, 3));
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle3);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle3);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle3);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals("Only the services from bundle impl2 should be selected", "Updated!hello!Updated", result);
1:     }
1: 
1:     @Test
1:     public void testClientMultipleTargetBundles() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:                 "java.util.ServiceLoader#load(java.lang.Class);bundle=impl1|impl4");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);
1:     }
1: 
1:     @Test
0:     public void testClientMultipleTargetBundles2() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:                 "java.util.ServiceLoader#load(java.lang.Class);bundleId=1|4");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
1:         Assert.assertEquals("All providers should be selected for this one", "ollehimpl4", result);
1:     }
1: 
1:     @Test
0:     public void testClientSpecificProviderLoadArgument() throws Exception {
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI])," +
0:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.AltSPI]);bundle=impl4");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1: 
1:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle1, providerBundle2, providerBundle4);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
1:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle, providerBundle1, providerBundle2, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
1:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.TestClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals("All providers should be selected for this one", "ollehHELLO5impl4", result);
1: 
1:         // Weave the AltTestClient class.
1:         URL cls2Url = getClass().getResource("AltTestClient.class");
1:         WovenClass wc2 = new MyWovenClass(cls2Url, "org.apache.aries.spifly.dynamic.AltTestClient", consumerBundle);
1:         wh.weave(wc2);
1: 
1:         // Invoke the AltTestClient
1:         Class<?> cls2 = wc2.getDefinedClass();
1:         Method method2 = cls2.getMethod("test", new Class [] {long.class});
1:         Object result2 = method2.invoke(cls2.newInstance(), 4096);
0:         Assert.assertEquals("Only the services from bundle impl4 should be selected", -4096L*4096L, result2);
1:     }
1: 
1:     @Test
0:     public void testClientSpecifyingDifferentMethodsLimitedToDifferentProviders() throws Exception {
0:         Dictionary<String, String> headers1 = new Hashtable<String, String>();
0:         headers1.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:                 "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=impl3," +
0:                 "java.util.ServiceLoader#load(java.lang.Class[org.apache.aries.mytest.MySPI]);bundle=impl4");
1: 
0:         Dictionary<String, String> headers2 = new Hashtable<String, String>();
0:         headers2.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:                 "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=system.bundle," +
0:                 "java.util.ServiceLoader#load;bundle=impl1");
1: 
0:         Dictionary<String, String> headers3 = new Hashtable<String, String>();
0:         headers3.put(SpiFlyConstants.SPI_CONSUMER_HEADER,
0:                 "org.acme.blah#someMethod();bundle=mybundle");
1: 
1:         Bundle providerBundle1 = mockProviderBundle("impl1", 1);
1:         Bundle providerBundle2 = mockProviderBundle("impl2", 2);
0:         Bundle providerBundle3 = mockProviderBundle("impl3", 3);
1:         Bundle providerBundle4 = mockProviderBundle("impl4", 4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle1);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle2);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle2);
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle3);
0:         activator.registerProviderBundle("org.apache.aries.mytest.MySPI", providerBundle4);
0:         activator.registerProviderBundle("org.apache.aries.mytest.AltSPI", providerBundle4);
1: 
0:         Bundle consumerBundle1 = mockConsumerBundle(headers1, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
0:         activator.addConsumerWeavingData(consumerBundle1, SpiFlyConstants.SPI_CONSUMER_HEADER);
0:         Bundle consumerBundle2 = mockConsumerBundle(headers2, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
0:         activator.addConsumerWeavingData(consumerBundle2, SpiFlyConstants.SPI_CONSUMER_HEADER);
0:         Bundle consumerBundle3 = mockConsumerBundle(headers3, providerBundle1, providerBundle2, providerBundle3, providerBundle4);
0:         activator.addConsumerWeavingData(consumerBundle3, SpiFlyConstants.SPI_CONSUMER_HEADER);
0:         Bundle spiFlyBundle = mockSpiFlyBundle(consumerBundle1, consumerBundle2, consumerBundle3,
0:                 providerBundle1, providerBundle2, providerBundle3, providerBundle4);
1:         WeavingHook wh = new ClientWeavingHook(spiFlyBundle.getBundleContext(), activator);
1: 
0:         testConsumerBundleWeaving(consumerBundle1, wh, "impl4", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory");
0:         testConsumerBundleWeaving(consumerBundle2, wh, "olleh", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
0:         testConsumerBundleWeaving(consumerBundle3, wh, "", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
1:     }
1: 
0:     private void testConsumerBundleWeaving(Bundle consumerBundle, WeavingHook wh, String testClientResult, String jaxpClientResult) throws Exception {
1:         // Weave the TestClient class.
1:         URL clsUrl = getClass().getResource("TestClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, TestClient.class.getName(), consumerBundle);
1:         wh.weave(wc);
1: 
1:         // Invoke the woven class and check that it propertly sets the TCCL so that the
1:         // META-INF/services/org.apache.aries.mytest.MySPI file from impl2 is visible.
1:         Class<?> cls = wc.getDefinedClass();
1:         Method method = cls.getMethod("test", new Class [] {String.class});
1:         Object result = method.invoke(cls.newInstance(), "hello");
0:         Assert.assertEquals(testClientResult, result);
1: 
0:         URL clsUrl2 = getClass().getResource("JaxpClient.class");
0:         WovenClass wc2 = new MyWovenClass(clsUrl2, JaxpClient.class.getName(), consumerBundle);
1:         wh.weave(wc2);
1: 
1:         Class<?> cls2 = wc2.getDefinedClass();
0:         Method method2 = cls2.getMethod("test", new Class [] {});
0:         Class<?> result2 = (Class<?>) method2.invoke(cls2.newInstance());
0:         Assert.assertEquals(jaxpClientResult, result2.getName());
1:     }
1: 
1:     @Test
0:     public void testJAXPClientWantsJREImplementation1() throws Exception {
0:         Bundle systembundle = mockSystemBundle();
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance()");
0:         Bundle consumerBundle = mockConsumerBundle(headers, systembundle);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, systembundle).getBundleContext(), activator);
1: 
0:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Class<?> cls = wc.getDefinedClass();
0:         Method method = cls.getMethod("test", new Class [] {});
0:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from JRE", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl", result.getName());
1:     }
1: 
0:     // If there is an alternate implementation it should always be favoured over the JRE one
1:     @Test
0:     public void testJAXPClientWantsAltImplementation1() throws Exception {
0:         Bundle systembundle = mockSystemBundle();
1: 
0:         Bundle providerBundle = mockProviderBundle("impl3", 1);
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance()");
0:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1: 
0:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Class<?> cls = wc.getDefinedClass();
0:         Method method = cls.getMethod("test", new Class [] {});
0:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from JRE", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory", result.getName());
1:     }
1: 
1:     @Test
0:     public void testJAXPClientWantsJREImplementation2() throws Exception {
0:         Bundle systembundle = mockSystemBundle();
1: 
0:         Bundle providerBundle = mockProviderBundle("impl3", 1);
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundleId=0");
0:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1: 
0:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Class<?> cls = wc.getDefinedClass();
0:         Method method = cls.getMethod("test", new Class [] {});
0:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from JRE", "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl", result.getName());
1:     }
1: 
1:     @Test
0:     public void testJAXPClientWantsAltImplementation2() throws Exception {
0:         Bundle systembundle = mockSystemBundle();
1: 
0:         Bundle providerBundle = mockProviderBundle("impl3", 1);
0:         activator.registerProviderBundle("javax.xml.parsers.DocumentBuilderFactory", providerBundle);
1: 
1:         Dictionary<String, String> headers = new Hashtable<String, String>();
0:         headers.put(SpiFlyConstants.SPI_CONSUMER_HEADER, "javax.xml.parsers.DocumentBuilderFactory#newInstance();bundle=impl3");
0:         Bundle consumerBundle = mockConsumerBundle(headers, providerBundle, systembundle);
0:         activator.addConsumerWeavingData(consumerBundle, SpiFlyConstants.SPI_CONSUMER_HEADER);
1: 
0:         WeavingHook wh = new ClientWeavingHook(mockSpiFlyBundle(consumerBundle, providerBundle, systembundle).getBundleContext(), activator);
1: 
0:         URL clsUrl = getClass().getResource("JaxpClient.class");
0:         WovenClass wc = new MyWovenClass(clsUrl, "org.apache.aries.spifly.dynamic.JaxpClient", consumerBundle);
1:         wh.weave(wc);
1: 
1:         Class<?> cls = wc.getDefinedClass();
0:         Method method = cls.getMethod("test", new Class [] {});
0:         Class<?> result = (Class<?>) method.invoke(cls.newInstance());
0:         Assert.assertEquals("JAXP implementation from alternative bundle", "org.apache.aries.spifly.dynamic.impl3.MyAltDocumentBuilderFactory", result.getName());
1:     }
1: 
1:     private Bundle mockSpiFlyBundle(Bundle ... bundles) throws Exception {
1:         return mockSpiFlyBundle("spifly", new Version(1, 0, 0), bundles);
1:     }
0: */
1: 
1:     private Bundle mockSpiFlyBundle(String bsn, Version version, Bundle ... bundles) throws Exception {
1:         Bundle spiFlyBundle = EasyMock.createMock(Bundle.class);
1: 
1:         BundleContext spiFlyBundleContext = EasyMock.createMock(BundleContext.class);
1:         EasyMock.expect(spiFlyBundleContext.getBundle()).andReturn(spiFlyBundle).anyTimes();
1:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(bundles));
1:         allBundles.add(spiFlyBundle);
1:         EasyMock.expect(spiFlyBundleContext.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:         EasyMock.replay(spiFlyBundleContext);
1: 
1:         EasyMock.expect(spiFlyBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getVersion()).andReturn(version).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:         EasyMock.expect(spiFlyBundle.getBundleContext()).andReturn(spiFlyBundleContext).anyTimes();
1:         EasyMock.replay(spiFlyBundle);
1: 
1:         // Set the bundle context for testing purposes
1:         Field bcField = BaseActivator.class.getDeclaredField("bundleContext");
1:         bcField.setAccessible(true);
1:         bcField.set(activator, spiFlyBundle.getBundleContext());
1: 
1:         return spiFlyBundle;
1:     }
1: 
1:     private Bundle mockProviderBundle(String subdir, long id) throws Exception {
1:         return mockProviderBundle(subdir, id, Version.emptyVersion);
1:     }
1: 
1:     private Bundle mockProviderBundle(String subdir, long id, Version version) throws Exception {
1:         URL url = getClass().getResource("/" + getClass().getName().replace('.', '/') + ".class");
1:         File classFile = new File(url.getFile());
1:         File baseDir = new File(classFile.getParentFile(), subdir);
1:         File directory = new File(baseDir, "/META-INF/services");
1:         final List<String> classNames = new ArrayList<String>();
1: 
1:         // Do a directory listing of the applicable META-INF/services directory
1:         List<String> resources = new ArrayList<String>();
1:         for (File f : directory.listFiles()) {
1:             String fileName = f.getName();
1:             if (fileName.startsWith(".") || fileName.endsWith("."))
1:                 continue;
1: 
1:             classNames.addAll(getClassNames(f));
1: 
1:             // Needs to be something like: META-INF/services/org.apache.aries.mytest.MySPI
1:             String path = f.getAbsolutePath().substring(baseDir.getAbsolutePath().length());
1:             path = path.replace('\\', '/');
1:             if (path.startsWith("/")) {
1:                 path = path.substring(1);
1:             }
1:             resources.add(path);
1:         }
1: 
1:         // Set up the classloader that will be used by the ASM-generated code as the TCCL.
1:         // It can load a META-INF/services file
1:         final ClassLoader cl = new TestProviderBundleClassLoader(subdir, resources.toArray(new String [] {}));
1: 
1:         final List<String> classResources = new ArrayList<String>();
1:         for(String className : classNames) {
1:             classResources.add("/" + className.replace('.', '/') + ".class");
1:         }
1:         Bundle providerBundle = EasyMock.createMock(Bundle.class);
1:         String bsn = subdir;
1:         int idx = bsn.indexOf('_');
1:         if (idx > 0) {
1:             bsn = bsn.substring(0, idx);
1:         }
1:         EasyMock.expect(providerBundle.getSymbolicName()).andReturn(bsn).anyTimes();
1:         EasyMock.expect(providerBundle.getBundleId()).andReturn(id).anyTimes();
1:         EasyMock.expect(providerBundle.getVersion()).andReturn(version).anyTimes();
1:         EasyMock.expect(providerBundle.getEntryPaths("/")).andAnswer(new IAnswer<Enumeration<String>>() {
1:             @Override
1:             public Enumeration<String> answer() throws Throwable {
1:                 return Collections.enumeration(classResources);
1:             }
1:         }).anyTimes();
1:         EasyMock.<Class<?>>expect(providerBundle.loadClass(EasyMock.anyObject(String.class))).andAnswer(new IAnswer<Class<?>>() {
1:             @Override
1:             public Class<?> answer() throws Throwable {
1:                 String  name = (String) EasyMock.getCurrentArguments()[0];
1:                 if (!classNames.contains(name)) {
1:                     throw new ClassCastException(name);
1:                 }
1:                 return cl.loadClass(name);
1:             }
1:         }).anyTimes();
1:         EasyMock.replay(providerBundle);
1:         return providerBundle;
1:     }
1: 
1:     private Collection<String> getClassNames(File f) throws IOException {
1:         List<String> names = new ArrayList<String>();
1: 
1:         BufferedReader br = new BufferedReader(new FileReader(f));
1:         try {
1:             String line = null;
1:             while((line = br.readLine()) != null) {
1:                 names.add(line.trim());
1:             }
1:         } finally {
1:             br.close();
1:         }
1:         return names;
1:     }
1: 
1:     private Bundle mockConsumerBundle(Dictionary<String, String> headers, Bundle ... otherBundles) {
1:         // Create a mock object for the client bundle which holds the code that uses ServiceLoader.load()
1:         // or another SPI invocation.
1:         BundleContext bc = EasyMock.createMock(BundleContext.class);
1: 
1:         Bundle consumerBundle = EasyMock.createMock(Bundle.class);
1:         EasyMock.expect(consumerBundle.getSymbolicName()).andReturn("testConsumer").anyTimes();
1:         EasyMock.expect(consumerBundle.getHeaders()).andReturn(headers).anyTimes();
1:         EasyMock.expect(consumerBundle.getBundleContext()).andReturn(bc).anyTimes();
1:         EasyMock.expect(consumerBundle.getBundleId()).andReturn(Long.MAX_VALUE).anyTimes();
1:         EasyMock.replay(consumerBundle);
1: 
1:         List<Bundle> allBundles = new ArrayList<Bundle>(Arrays.asList(otherBundles));
1:         allBundles.add(consumerBundle);
1:         EasyMock.expect(bc.getBundles()).andReturn(allBundles.toArray(new Bundle [] {})).anyTimes();
1:         EasyMock.replay(bc);
1: 
1:         return consumerBundle;
1:     }
1: 
0:     private Bundle mockSystemBundle() {
0:         Bundle systemBundle = EasyMock.createMock(Bundle.class);
0:         EasyMock.expect(systemBundle.getBundleId()).andReturn(0L).anyTimes();
0:         EasyMock.expect(systemBundle.getSymbolicName()).andReturn("system.bundle").anyTimes();
0:         EasyMock.replay(systemBundle);
1: 
0:         return systemBundle;
1:     }
1: 
1:     // A classloader that loads anything starting with org.apache.aries.spifly.dynamic.impl1 from it
1:     // and the rest from the parent. This is to mimic a bundle that holds a specific SPI implementation.
1:     public static class TestProviderBundleClassLoader extends URLClassLoader {
1:         private final List<String> resources;
1:         private final String prefix;
1:         private final String classPrefix;
1:         private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<String, Class<?>>();
1: 
1:         public TestProviderBundleClassLoader(String subdir, String ... resources) {
1:             super(new URL [] {}, TestProviderBundleClassLoader.class.getClassLoader());
1: 
1:             this.prefix = TestProviderBundleClassLoader.class.getPackage().getName().replace('.', '/') + "/" + subdir + "/";
1:             this.classPrefix = prefix.replace('/', '.');
1:             this.resources = Arrays.asList(resources);
1:         }
1: 
1:         @Override
1:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:             if (name.startsWith(classPrefix))
1:                 return loadClassLocal(name);
1: 
1:             return super.loadClass(name);
1:         }
1: 
1:         @Override
1:         protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
1:             if (name.startsWith(classPrefix)) {
1:                 Class<?> cls = loadClassLocal(name);
1:                 if (resolve)
1:                     resolveClass(cls);
1: 
1:                 return cls;
1:             }
1: 
1:             return super.loadClass(name, resolve);
1:         }
1: 
1:         protected Class<?> loadClassLocal(String name) throws ClassNotFoundException {
1:             Class<?> prevLoaded = loadedClasses.get(name);
1:             if (prevLoaded != null)
1:                 return prevLoaded;
1: 
1:             URL res = TestProviderBundleClassLoader.class.getClassLoader().getResource(name.replace('.', '/') + ".class");
1:             try {
1:                 byte[] bytes = Streams.suck(res.openStream());
1:                 Class<?> cls = defineClass(name, bytes, 0, bytes.length);
1:                 loadedClasses.put(name, cls);
1:                 return cls;
1:             } catch (Exception e) {
1:                 throw new ClassNotFoundException(name, e);
1:             }
1:         }
1: 
1:         @Override
1:         public URL findResource(String name) {
1:             if (resources.contains(name)) {
1:                 return getClass().getClassLoader().getResource(prefix + name);
1:             } else {
1:                 return super.findResource(name);
1:             }
1:         }
1: 
1:         @Override
1:         public Enumeration<URL> findResources(String name) throws IOException {
1:             if (resources.contains(name)) {
1:                 return getClass().getClassLoader().getResources(prefix + name);
1:             } else {
1:                 return super.findResources(name);
1:             }
1:         }
1:     }
1: 
1:     private static class MyWovenClass implements WovenClass {
1:         byte [] bytes;
1:         final String className;
1:         final Bundle bundleContainingOriginalClass;
1:         List<String> dynamicImports = new ArrayList<String>();
1:         boolean weavingComplete = false;
1: 
1:         private MyWovenClass(URL clazz, String name, Bundle bundle) throws Exception {
1:             bytes = Streams.suck(clazz.openStream());
1:             className = name;
1:             bundleContainingOriginalClass = bundle;
1:         }
1: 
1:         @Override
1:         public byte[] getBytes() {
1:             return bytes;
1:         }
1: 
1:         @Override
1:         public void setBytes(byte[] newBytes) {
1:             bytes = newBytes;
1:         }
1: 
1:         @Override
1:         public List<String> getDynamicImports() {
1:             return dynamicImports;
1:         }
1: 
1:         @Override
1:         public boolean isWeavingComplete() {
1:             return weavingComplete;
1:         }
1: 
1:         @Override
1:         public String getClassName() {
1:             return className;
1:         }
1: 
1:         @Override
1:         public ProtectionDomain getProtectionDomain() {
1:             return null;
1:         }
1: 
1:         @Override
1:         public Class<?> getDefinedClass() {
1:             try {
1:                 weavingComplete = true;
1:                 return new MyWovenClassClassLoader(className, getBytes(), getClass().getClassLoader(), bundleContainingOriginalClass).loadClass(className);
1:             } catch (ClassNotFoundException e) {
1:                 e.printStackTrace();
1:                 return null;
1:             }
1:         }
1: 
1:         @Override
1:         public BundleWiring getBundleWiring() {
1:             BundleWiring bw = EasyMock.createMock(BundleWiring.class);
1:             EasyMock.expect(bw.getBundle()).andReturn(bundleContainingOriginalClass);
1:             EasyMock.replay(bw);
1:             return bw;
1:         }
1:     }
1: 
1:     private static class MyWovenClassClassLoader extends ClassLoader implements BundleReference {
1:         private final String className;
1:         private final Bundle bundle;
1:         private final byte [] bytes;
1:         private Class<?> wovenClass;
1: 
1:         public MyWovenClassClassLoader(String className, byte[] bytes, ClassLoader parent, Bundle bundle) {
1:             super(parent);
1: 
1:             this.className = className;
1:             this.bundle = bundle;
1:             this.bytes = bytes;
1:         }
1: 
1:         @Override
1:         protected synchronized Class<?> loadClass(String name, boolean resolve)
1:                 throws ClassNotFoundException {
1:             if (name.equals(className)) {
1:                 if (wovenClass == null)
1:                     wovenClass = defineClass(className, bytes, 0, bytes.length);
1: 
1:                 return wovenClass;
1:             } else {
1:                 return super.loadClass(name, resolve);
1:             }
1:         }
1: 
1:         @Override
1:         public Class<?> loadClass(String name) throws ClassNotFoundException {
1:             return loadClass(name, false);
1:         }
1: 
1:         @Override
1:         public Bundle getBundle() {
1:             return bundle;
1:         }
1:     }
1: }
============================================================================