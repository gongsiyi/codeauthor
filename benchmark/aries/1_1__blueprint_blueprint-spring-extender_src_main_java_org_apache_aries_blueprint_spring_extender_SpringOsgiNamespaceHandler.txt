1:1388916: /**
1:1388916:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:1388916:  *  contributor license agreements.  See the NOTICE file distributed with
1:1388916:  *  this work for additional information regarding copyright ownership.
1:1388916:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:1388916:  *  (the "License"); you may not use this file except in compliance with
1:1388916:  *  the License.  You may obtain a copy of the License at
1:1388916:  *
1:1388916:  *     http://www.apache.org/licenses/LICENSE-2.0
1:1388916:  *
1:1388916:  *  Unless required by applicable law or agreed to in writing, software
1:1388916:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:1388916:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1388916:  *  See the License for the specific language governing permissions and
1:1388916:  *  limitations under the License.
1:1388916:  */
1:09b7171: package org.apache.aries.blueprint.spring.extender;
5:09b7171: 
1:2e9d097: import java.net.URI;
1:09b7171: import java.net.URL;
1:09b7171: import java.util.ArrayList;
1:09b7171: import java.util.Arrays;
1:09b7171: import java.util.List;
1:09b7171: import java.util.Set;
1:09b7171: 
1:09b7171: import org.apache.aries.blueprint.NamespaceHandler;
1:09b7171: import org.apache.aries.blueprint.ParserContext;
1:09b7171: import org.apache.aries.blueprint.mutable.MutableRefMetadata;
1:09b7171: import org.apache.aries.blueprint.mutable.MutableReferenceMetadata;
1:09b7171: import org.apache.aries.blueprint.mutable.MutableServiceMetadata;
1:09b7171: import org.apache.aries.blueprint.mutable.MutableValueMetadata;
1:2e9d097: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:09b7171: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:09b7171: import org.osgi.service.blueprint.reflect.Metadata;
1:09b7171: import org.osgi.service.blueprint.reflect.NonNullMetadata;
1:09b7171: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:09b7171: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:2e9d097: import org.osgi.service.blueprint.reflect.Target;
1:09b7171: import org.springframework.util.Assert;
1:09b7171: import org.springframework.util.StringUtils;
1:5688330: import org.w3c.dom.CharacterData;
1:5688330: import org.w3c.dom.Comment;
1:5688330: import org.w3c.dom.Element;
1:5688330: import org.w3c.dom.EntityReference;
1:5688330: import org.w3c.dom.Node;
1:5688330: import org.w3c.dom.NodeList;
1:09b7171: 
1:09b7171: public class SpringOsgiNamespaceHandler implements NamespaceHandler {
1:09b7171: 
1:2e9d097:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:2e9d097:     public static final String SPRING_NAMESPACE = "http://www.springframework.org/schema/beans";
1:5688330: 
1:2e9d097:     public static final String BEAN_ELEMENT = "bean";
1:5688330:     public static final String BEAN_NAME_ELEMENT = "bean-name";
1:5688330:     public static final String FILTER_ATTRIBUTE = "filter";
1:5688330:     public static final String INTERFACE_ATTRIBUTE = "interface";
1:5688330:     public static final String TIMEOUT_ATTRIBUTE = "timeout";
1:5688330:     public static final String DEPENDS_ON_ATTRIBUTE = "depends-on";
1:5688330:     public static final String CARDINALITY_ATTRIBUTE = "cardinality";
1:5688330:     public static final String LISTENER_ELEMENT = "listener";
1:5688330:     public static final String REF_ATTRIBUTE = "ref";
1:5688330:     public static final String BIND_METHOD_ATTRIBUTE = "bind-method";
1:5688330:     public static final String UNBIND_METHOD_ATTRIBUTE = "unbind-method";
1:5688330:     public static final String ID_ATTRIBUTE = "id";
1:5688330:     public static final String CARDINALITY_0_1 = "0..1";
1:5688330:     public static final String VALUE_ATTRIBUTE = "value";
1:5688330:     public static final String VALUE_REF_ATTRIBUTE = "value-ref";
1:5688330:     public static final String KEY_ATTRIBUTE = "key";
1:5688330:     public static final String KEY_REF_ATTRIBUTE = "key-ref";
1:5688330:     public static final String ENTRY_ELEMENT = "entry";
1:5688330:     public static final String SERVICE_PROPERTIES_ELEMENT = "service-properties";
1:5688330:     public static final String REGISTRATION_LISTENER_ELEMENT = "registration-listener";
1:5688330:     public static final String INTERFACES_ELEMENT = "interfaces";
1:5688330:     public static final String VALUE_ELEMENT = "value";
1:5688330:     public static final String AUTO_EXPORT_ATTRIBUTE = "auto-export";
1:5688330:     public static final String AUTO_EXPORT_INTERFACES = "interfaces";
1:5688330:     public static final String AUTO_EXPORT_CLASS_HIERARCHY = "class-hierarchy";
1:5688330:     public static final String AUTO_EXPORT_ALL_CLASSES = "all-classes";
1:5688330:     public static final String RANKING_ATTRIBUTE = "ranking";
1:5688330:     public static final String REFERENCE_ELEMENT = "reference";
1:5688330:     public static final String SERVICE_ELEMENT = "service";
1:5688330:     public static final String BUNDLE_ELEMENT = "bundle";
1:5688330:     public static final String SET_ELEMENT = "set";
1:5688330:     public static final String LIST_ELEMENT = "list";
1:5688330:     public static final int DEFAULT_TIMEOUT = 300000;
1:5688330:     public static final String REGISTRATION_METHOD_ATTRIBUTE = "registration-method";
1:5688330:     public static final String UNREGISTRATION_METHOD_ATTRIBUTE = "unregistration-method";
1:2e9d097: 
1:2e9d097:     private int idCounter;
1:2e9d097: 
1:09b7171:     @Override
1:09b7171:     public URL getSchemaLocation(String namespace) {
1:09b7171:         if (namespace.startsWith("http://www.springframework.org/schema/osgi/spring-osgi")) {
1:09b7171:             String sub = namespace.substring("http://www.springframework.org/schema/osgi/".length());
1:09b7171:             if ("spring-osgi.xsd".equals(sub)) {
1:09b7171:                 sub = "spring-osgi-1.2.xsd";
1:2e9d097:             }
1:09b7171:             return getClass().getResource(sub);
1:2e9d097:         }
1:09b7171:         return null;
1:2e9d097:     }
1:09b7171: 
1:09b7171:     @Override
1:09b7171:     public Set<Class> getManagedClasses() {
1:09b7171:         return null;
1:2e9d097:     }
1:09b7171: 
1:09b7171:     @Override
1:09b7171:     public Metadata parse(Element element, ParserContext context) {
1:5688330:         if (REFERENCE_ELEMENT.equals(element.getLocalName())) {
1:5688330:             return parseReference(element, context);
41:09b7171:         }
1:5688330:         else if (SERVICE_ELEMENT.equals(element.getLocalName())) {
1:5688330:             return parseService(element, context);
1:5688330:         }
1:5688330:         else if (BUNDLE_ELEMENT.equals(element.getLocalName())) {
1:5688330:             return parseBundle(element, context);
1:5688330:         }
1:5688330:         else if (SET_ELEMENT.equals(element.getLocalName())) {
1:5688330:             return parseSet(element, context);
1:5688330:         }
1:5688330:         else if (LIST_ELEMENT.equals(element.getLocalName())) {
1:5688330:             return parseList(element, context);
1:5688330:         }
1:5688330:         else {
1:5688330:             throw new UnsupportedOperationException();
1:5688330:         }
1:5688330:     }
1:09b7171: 
1:5688330:     private Metadata parseBundle(Element element, ParserContext context) {
1:09b7171:         throw new UnsupportedOperationException();
1:2e9d097:     }
1:09b7171: 
1:5688330:     private Metadata parseList(Element element, ParserContext context) {
1:5688330:         // TODO: support list
1:5688330:         throw new UnsupportedOperationException();
1:5688330:     }
1:5688330: 
1:5688330:     private Metadata parseSet(Element element, ParserContext context) {
1:5688330:         // TODO: support set
1:5688330:         throw new UnsupportedOperationException();
1:5688330:     }
1:5688330: 
1:5688330:     private Metadata parseService(Element element, ParserContext context) {
1:5688330:         MutableServiceMetadata metadata = context.createMetadata(MutableServiceMetadata.class);
1:5688330:         // Parse attributes
1:5688330:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:5688330:             metadata.setId(element.getAttribute(ID_ATTRIBUTE));
1:5688330:         } else {
1:5688330:             metadata.setId(generateId(context));
1:5688330:         }
1:5688330:         if (nonEmpty(element.getAttribute(REF_ATTRIBUTE)) != null) {
1:5688330:             MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
1:5688330:             ref.setComponentId(element.getAttribute(REF_ATTRIBUTE));
1:5688330:             metadata.setServiceComponent(ref);
1:5688330:         }
1:5688330:         metadata.setRanking(nonEmpty(element.getAttribute(RANKING_ATTRIBUTE)) != null
1:5688330:                 ? Integer.parseInt(element.getAttribute(RANKING_ATTRIBUTE))
1:5688330:                 : 0);
1:5688330:         String itf = nonEmpty(element.getAttribute(INTERFACE_ATTRIBUTE));
1:5688330:         if (itf != null) {
1:5688330:             metadata.addInterface(itf);
1:5688330:         }
1:5688330:         String[] dependsOn = StringUtils.tokenizeToStringArray(nonEmpty(element.getAttribute(DEPENDS_ON_ATTRIBUTE)), ",; ");
1:5688330:         metadata.setDependsOn(dependsOn != null ? Arrays.asList(dependsOn) : null);
1:5688330:         String autoExp = nonEmpty(element.getAttribute(AUTO_EXPORT_ATTRIBUTE));
1:5688330:         if (AUTO_EXPORT_INTERFACES.equals(autoExp)) {
1:5688330:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_INTERFACES);
1:5688330:         } else if (AUTO_EXPORT_CLASS_HIERARCHY.equals(autoExp)) {
1:5688330:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
1:5688330:         } else if (AUTO_EXPORT_ALL_CLASSES.equals(autoExp)) {
1:5688330:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
1:5688330:         } else {
1:5688330:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:5688330:         }
1:5688330:         // TODO: @context-class-loader
1:5688330:         // Parse child elements
1:5688330:         for (Element child : getChildren(element)) {
1:5688330:             if (element.getNamespaceURI().equals(child.getNamespaceURI())) {
1:5688330:                 if (INTERFACES_ELEMENT.equals(child.getLocalName())) {
1:5688330:                     List<String> itfs = parseInterfaces(child);
1:5688330:                     for (String intf : itfs) {
1:5688330:                         metadata.addInterface(intf);
1:5688330:                     }
1:5688330:                 }
1:5688330:                 else if (REGISTRATION_LISTENER_ELEMENT.equals(child.getLocalName())) {
1:5688330:                     String regMethod = nonEmpty(child.getAttribute(REGISTRATION_METHOD_ATTRIBUTE));
1:5688330:                     String unregMethod = nonEmpty(child.getAttribute(UNREGISTRATION_METHOD_ATTRIBUTE));
1:5688330:                     String refStr = nonEmpty(child.getAttribute(REF_ATTRIBUTE));
1:5688330:                     Target listenerComponent = null;
1:5688330:                     if (refStr != null) {
1:5688330:                         MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
1:5688330:                         ref.setComponentId(refStr);
1:5688330:                         listenerComponent = ref;
1:5688330:                     }
1:5688330:                     for (Element cchild : getChildren(child)) {
1:5688330:                         if (listenerComponent != null) {
1:5688330:                             throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:5688330:                         }
1:5688330:                         listenerComponent = parseInlinedTarget(context, metadata, cchild);
1:5688330:                     }
1:5688330:                     if (listenerComponent == null) {
1:5688330:                         throw new IllegalArgumentException("Missing @ref attribute or inlined bean definition element");
1:5688330:                     }
1:5688330:                     metadata.addRegistrationListener(listenerComponent, regMethod, unregMethod);
1:5688330:                 }
1:5688330:                 else if (SERVICE_PROPERTIES_ELEMENT.equals(child.getLocalName())) {
1:5688330:                     // TODO: @key-type
1:5688330:                     for (Element e : getChildren(child)) {
1:5688330:                         if (ENTRY_ELEMENT.equals(e.getLocalName())) {
1:5688330:                             NonNullMetadata key;
1:5688330:                             Metadata val;
1:5688330:                             boolean hasKeyAttribute = e.hasAttribute(KEY_ATTRIBUTE);
1:5688330:                             boolean hasKeyRefAttribute = e.hasAttribute(KEY_REF_ATTRIBUTE);
1:5688330:                             if (hasKeyRefAttribute && !hasKeyAttribute) {
1:5688330:                                 MutableRefMetadata r = context.createMetadata(MutableRefMetadata.class);
1:5688330:                                 r.setComponentId(e.getAttribute(KEY_REF_ATTRIBUTE));
1:5688330:                                 key = r;
1:5688330:                             } else if (hasKeyAttribute && !hasKeyRefAttribute) {
1:5688330:                                 MutableValueMetadata v = context.createMetadata(MutableValueMetadata.class);
1:5688330:                                 v.setStringValue(e.getAttribute(KEY_ATTRIBUTE));
1:5688330:                                 key = v;
1:5688330:                             } else {
1:5688330:                                 throw new IllegalStateException("Either key or key-ref must be specified");
1:5688330:                             }
1:5688330:                             // TODO: support key
1:5688330:                             boolean hasValAttribute = e.hasAttribute(VALUE_ATTRIBUTE);
1:5688330:                             boolean hasValRefAttribute = e.hasAttribute(VALUE_REF_ATTRIBUTE);
1:5688330:                             if (hasValRefAttribute && !hasValAttribute) {
1:5688330:                                 MutableRefMetadata r = context.createMetadata(MutableRefMetadata.class);
1:5688330:                                 r.setComponentId(e.getAttribute(VALUE_REF_ATTRIBUTE));
1:5688330:                                 val = r;
1:5688330:                             } else if (hasValAttribute && !hasValRefAttribute) {
1:5688330:                                 MutableValueMetadata v = context.createMetadata(MutableValueMetadata.class);
1:5688330:                                 v.setStringValue(e.getAttribute(VALUE_ATTRIBUTE));
1:5688330:                                 val = v;
1:5688330:                             } else {
1:5688330:                                 throw new IllegalStateException("Either val or val-ref must be specified");
1:5688330:                             }
1:5688330:                             // TODO: support children elements ?
1:5688330:                             metadata.addServiceProperty(key, val);
1:5688330:                         }
1:5688330:                     }
1:5688330:                 }
1:5688330:             }
1:5688330:             else if (BLUEPRINT_NAMESPACE.equals(child.getNamespaceURI())
1:5688330:                     && BEAN_ELEMENT.equals(child.getLocalName())) {
1:5688330:                 if (metadata.getServiceComponent() != null) {
1:5688330:                     throw new IllegalArgumentException("Only one of @ref attribute and bean element is allowed");
1:5688330:                 }
1:5688330:                 Target bean = context.parseElement(BeanMetadata.class, metadata, child);
1:5688330:                 metadata.setServiceComponent(bean);
1:5688330:             }
1:5688330:             else {
1:5688330:                 if (metadata.getServiceComponent() != null) {
1:5688330:                     throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:5688330:                 }
1:5688330:                 NamespaceHandler handler = context.getNamespaceHandler(URI.create(child.getNamespaceURI()));
1:5688330:                 if (handler == null) {
1:5688330:                     throw new IllegalStateException("No NamespaceHandler found for " + child.getNamespaceURI());
1:5688330:                 }
1:5688330:                 Metadata md = handler.parse(child, context);
1:5688330:                 if (!(md instanceof Target)) {
1:5688330:                     throw new IllegalStateException("NamespaceHandler did not return a Target instance but " + md);
1:5688330:                 }
1:5688330:                 metadata.setServiceComponent((Target) md);
1:5688330:             }
1:5688330:         }
1:5688330:         return metadata;
1:5688330:     }
1:5688330: 
1:5688330:     private Metadata parseReference(Element element, ParserContext context) {
1:5688330:         MutableReferenceMetadata metadata = context.createMetadata(MutableReferenceMetadata.class);
1:5688330:         // Parse attributes
1:5688330:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:5688330:             metadata.setId(element.getAttribute(ID_ATTRIBUTE));
1:5688330:         } else {
1:5688330:             metadata.setId(generateId(context));
1:5688330:         }
1:5688330:         metadata.setAvailability(CARDINALITY_0_1.equals(element.getAttribute(CARDINALITY_ATTRIBUTE))
1:5688330:                 ? ReferenceMetadata.AVAILABILITY_OPTIONAL
1:5688330:                 : ReferenceMetadata.AVAILABILITY_MANDATORY);
1:5688330:         metadata.setTimeout(getLong(element.getAttribute(TIMEOUT_ATTRIBUTE), DEFAULT_TIMEOUT));
1:5688330:         metadata.setInterface(element.getAttribute(INTERFACE_ATTRIBUTE));
1:5688330:         metadata.setFilter(element.getAttribute(FILTER_ATTRIBUTE));
1:5688330:         String[] dependsOn = StringUtils.tokenizeToStringArray(element.getAttribute(DEPENDS_ON_ATTRIBUTE), ",; ");
1:5688330:         metadata.setDependsOn(dependsOn != null ? Arrays.asList(dependsOn) : null);
1:5688330:         metadata.setComponentName(element.getAttribute(BEAN_NAME_ELEMENT));
1:5688330:         // TODO: @context-class-loader
1:5688330:         // Parse child elements
1:5688330:         for (Element child : getChildren(element)) {
1:5688330:             if (element.getNamespaceURI().equals(child.getNamespaceURI())) {
1:5688330:                 if (INTERFACES_ELEMENT.equals(child.getLocalName())) {
1:5688330:                     List<String> itfs = parseInterfaces(child);
1:5688330:                     metadata.setExtraInterfaces(itfs);
1:5688330:                 }
1:5688330:                 else if (LISTENER_ELEMENT.equals(child.getLocalName())) {
1:5688330:                     String bindMethod = nonEmpty(child.getAttribute(BIND_METHOD_ATTRIBUTE));
1:5688330:                     String unbindMethod = nonEmpty(child.getAttribute(UNBIND_METHOD_ATTRIBUTE));
1:5688330:                     String refStr = nonEmpty(child.getAttribute(REF_ATTRIBUTE));
1:5688330:                     Target listenerComponent = null;
1:5688330:                     if (refStr != null) {
1:5688330:                         MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
1:5688330:                         ref.setComponentId(refStr);
1:5688330:                         listenerComponent = ref;
1:5688330:                     }
1:5688330:                     for (Element cchild : getChildren(child)) {
1:5688330:                         if (listenerComponent != null) {
1:5688330:                             throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:5688330:                         }
1:5688330:                         listenerComponent = parseInlinedTarget(context, metadata, cchild);
1:5688330:                     }
1:5688330:                     if (listenerComponent == null) {
1:5688330:                         throw new IllegalArgumentException("Missing @ref attribute or inlined bean definition element");
1:5688330:                     }
1:5688330:                     metadata.addServiceListener(listenerComponent, bindMethod, unbindMethod);
1:5688330:                 }
1:5688330:             }
1:5688330:             else {
1:5688330:                 throw new UnsupportedOperationException("Custom namespaces not supported");
1:5688330:             }
1:5688330:         }
1:5688330:         return metadata;
1:5688330:     }
1:5688330: 
1:5688330:     private Target parseInlinedTarget(ParserContext context, ComponentMetadata metadata, Element element) {
1:5688330:         Target listenerComponent;
1:5688330:         if (BLUEPRINT_NAMESPACE.equals(element.getNamespaceURI())
1:5688330:                 && BEAN_ELEMENT.equals(element.getLocalName())) {
1:5688330:             listenerComponent = context.parseElement(BeanMetadata.class, metadata, element);
1:5688330:         }
1:5688330:         else {
1:5688330:             NamespaceHandler handler = context.getNamespaceHandler(URI.create(element.getNamespaceURI()));
1:5688330:             if (handler == null) {
1:5688330:                 throw new IllegalStateException("No NamespaceHandler found for " + element.getNamespaceURI());
1:5688330:             }
1:5688330:             Metadata md = handler.parse(element, context);
1:5688330:             if (!(md instanceof Target)) {
1:5688330:                 throw new IllegalStateException("NamespaceHandler did not return a Target instance but " + md);
1:5688330:             }
1:5688330:             listenerComponent = (Target) md;
1:5688330:         }
1:5688330:         return listenerComponent;
1:5688330:     }
1:5688330: 
1:5688330:     private List<String> parseInterfaces(Element element) {
1:5688330:         List<String> extra = new ArrayList<String>();
1:5688330:         for (Element e : getChildren(element)) {
1:5688330:             if (VALUE_ELEMENT.equals(e.getLocalName())) {
1:5688330:                 extra.add(getTextValue(e));
1:5688330:             } else {
1:5688330:                 // The schema support all kind of children for a list type
1:5688330:                 // The type for the spring property is converted to a Class[] array
1:5688330:                 // TODO: support other elements ?
1:5688330:                 throw new UnsupportedOperationException("Unsupported child: " + element.getLocalName());
1:5688330:             }
1:5688330:         }
1:5688330:         return extra;
1:5688330:     }
1:5688330: 
1:2e9d097:     private String nonEmpty(String ref) {
1:2e9d097:         return ref != null && ref.isEmpty() ? null : ref;
1:2e9d097:     }
1:2e9d097: 
1:2e9d097:     private String generateId(ParserContext context) {
1:2e9d097:         String id;
1:2e9d097:         do {
1:2e9d097:             id = ".spring-osgi-" + ++idCounter;
1:2e9d097:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:2e9d097:         return id;
1:2e9d097:     }
1:2e9d097: 
1:09b7171:     @Override
1:09b7171:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:09b7171:         return component;
1:2e9d097:     }
1:09b7171: 
1:09b7171:     private List<Element> getChildren(Element element) {
1:09b7171:         List<Element> children = new ArrayList<Element>();
1:09b7171:         for (Node child = element.getFirstChild(); child != null; child = child.getNextSibling()) {
1:09b7171:             if (child instanceof Element) {
1:09b7171:                 children.add((Element) child);
1:2e9d097:             }
1:2e9d097:         }
1:09b7171:         return children;
1:2e9d097:     }
1:09b7171: 
1:09b7171:     private long getLong(String str, long def) {
1:09b7171:         if (str == null || str.isEmpty()) {
1:09b7171:             return def;
1:2e9d097:         } else {
1:09b7171:             return Long.parseLong(str);
1:2e9d097:         }
1:2e9d097:     }
1:09b7171: 
1:09b7171:     public static String getTextValue(Element valueEle) {
1:09b7171:         Assert.notNull(valueEle, "Element must not be null");
1:09b7171:         StringBuilder sb = new StringBuilder();
1:09b7171:         NodeList nl = valueEle.getChildNodes();
1:5688330:         for(int i = 0, l = nl.getLength(); i < l; ++i) {
1:09b7171:             Node item = nl.item(i);
1:09b7171:             if(item instanceof CharacterData && !(item instanceof Comment) || item instanceof EntityReference) {
1:09b7171:                 sb.append(item.getNodeValue());
1:2e9d097:             }
1:2e9d097:         }
1:09b7171:         return sb.toString();
1:2e9d097:     }
1:09b7171: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:5688330
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.CharacterData;
1: import org.w3c.dom.Comment;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.EntityReference;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1: 
1:     public static final String BEAN_NAME_ELEMENT = "bean-name";
1:     public static final String FILTER_ATTRIBUTE = "filter";
1:     public static final String INTERFACE_ATTRIBUTE = "interface";
1:     public static final String TIMEOUT_ATTRIBUTE = "timeout";
1:     public static final String DEPENDS_ON_ATTRIBUTE = "depends-on";
1:     public static final String CARDINALITY_ATTRIBUTE = "cardinality";
1:     public static final String LISTENER_ELEMENT = "listener";
1:     public static final String REF_ATTRIBUTE = "ref";
1:     public static final String BIND_METHOD_ATTRIBUTE = "bind-method";
1:     public static final String UNBIND_METHOD_ATTRIBUTE = "unbind-method";
1:     public static final String ID_ATTRIBUTE = "id";
1:     public static final String CARDINALITY_0_1 = "0..1";
1:     public static final String VALUE_ATTRIBUTE = "value";
1:     public static final String VALUE_REF_ATTRIBUTE = "value-ref";
1:     public static final String KEY_ATTRIBUTE = "key";
1:     public static final String KEY_REF_ATTRIBUTE = "key-ref";
1:     public static final String ENTRY_ELEMENT = "entry";
1:     public static final String SERVICE_PROPERTIES_ELEMENT = "service-properties";
1:     public static final String REGISTRATION_LISTENER_ELEMENT = "registration-listener";
1:     public static final String INTERFACES_ELEMENT = "interfaces";
1:     public static final String VALUE_ELEMENT = "value";
1:     public static final String AUTO_EXPORT_ATTRIBUTE = "auto-export";
1:     public static final String AUTO_EXPORT_INTERFACES = "interfaces";
1:     public static final String AUTO_EXPORT_CLASS_HIERARCHY = "class-hierarchy";
1:     public static final String AUTO_EXPORT_ALL_CLASSES = "all-classes";
1:     public static final String RANKING_ATTRIBUTE = "ranking";
1:     public static final String REFERENCE_ELEMENT = "reference";
1:     public static final String SERVICE_ELEMENT = "service";
1:     public static final String BUNDLE_ELEMENT = "bundle";
1:     public static final String SET_ELEMENT = "set";
1:     public static final String LIST_ELEMENT = "list";
1:     public static final int DEFAULT_TIMEOUT = 300000;
1:     public static final String REGISTRATION_METHOD_ATTRIBUTE = "registration-method";
1:     public static final String UNREGISTRATION_METHOD_ATTRIBUTE = "unregistration-method";
/////////////////////////////////////////////////////////////////////////
1:         if (REFERENCE_ELEMENT.equals(element.getLocalName())) {
1:             return parseReference(element, context);
1:         else if (SERVICE_ELEMENT.equals(element.getLocalName())) {
1:             return parseService(element, context);
1:         }
1:         else if (BUNDLE_ELEMENT.equals(element.getLocalName())) {
1:             return parseBundle(element, context);
1:         }
1:         else if (SET_ELEMENT.equals(element.getLocalName())) {
1:             return parseSet(element, context);
1:         }
1:         else if (LIST_ELEMENT.equals(element.getLocalName())) {
1:             return parseList(element, context);
1:         }
1:         else {
1:             throw new UnsupportedOperationException();
1:         }
1:     }
1:     private Metadata parseBundle(Element element, ParserContext context) {
1:     private Metadata parseList(Element element, ParserContext context) {
1:         // TODO: support list
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     private Metadata parseSet(Element element, ParserContext context) {
1:         // TODO: support set
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     private Metadata parseService(Element element, ParserContext context) {
1:         MutableServiceMetadata metadata = context.createMetadata(MutableServiceMetadata.class);
1:         // Parse attributes
1:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:             metadata.setId(element.getAttribute(ID_ATTRIBUTE));
1:         } else {
1:             metadata.setId(generateId(context));
1:         }
1:         if (nonEmpty(element.getAttribute(REF_ATTRIBUTE)) != null) {
1:             MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
1:             ref.setComponentId(element.getAttribute(REF_ATTRIBUTE));
1:             metadata.setServiceComponent(ref);
1:         }
1:         metadata.setRanking(nonEmpty(element.getAttribute(RANKING_ATTRIBUTE)) != null
1:                 ? Integer.parseInt(element.getAttribute(RANKING_ATTRIBUTE))
1:                 : 0);
1:         String itf = nonEmpty(element.getAttribute(INTERFACE_ATTRIBUTE));
1:         if (itf != null) {
1:             metadata.addInterface(itf);
1:         }
1:         String[] dependsOn = StringUtils.tokenizeToStringArray(nonEmpty(element.getAttribute(DEPENDS_ON_ATTRIBUTE)), ",; ");
1:         metadata.setDependsOn(dependsOn != null ? Arrays.asList(dependsOn) : null);
1:         String autoExp = nonEmpty(element.getAttribute(AUTO_EXPORT_ATTRIBUTE));
1:         if (AUTO_EXPORT_INTERFACES.equals(autoExp)) {
1:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_INTERFACES);
1:         } else if (AUTO_EXPORT_CLASS_HIERARCHY.equals(autoExp)) {
1:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
1:         } else if (AUTO_EXPORT_ALL_CLASSES.equals(autoExp)) {
1:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
1:         } else {
1:             metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:         }
1:         // TODO: @context-class-loader
1:         // Parse child elements
1:         for (Element child : getChildren(element)) {
1:             if (element.getNamespaceURI().equals(child.getNamespaceURI())) {
1:                 if (INTERFACES_ELEMENT.equals(child.getLocalName())) {
1:                     List<String> itfs = parseInterfaces(child);
1:                     for (String intf : itfs) {
1:                         metadata.addInterface(intf);
1:                     }
1:                 }
1:                 else if (REGISTRATION_LISTENER_ELEMENT.equals(child.getLocalName())) {
1:                     String regMethod = nonEmpty(child.getAttribute(REGISTRATION_METHOD_ATTRIBUTE));
1:                     String unregMethod = nonEmpty(child.getAttribute(UNREGISTRATION_METHOD_ATTRIBUTE));
1:                     String refStr = nonEmpty(child.getAttribute(REF_ATTRIBUTE));
1:                     Target listenerComponent = null;
1:                     if (refStr != null) {
1:                         MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
1:                         ref.setComponentId(refStr);
1:                         listenerComponent = ref;
1:                     }
1:                     for (Element cchild : getChildren(child)) {
1:                         if (listenerComponent != null) {
1:                             throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:                         }
1:                         listenerComponent = parseInlinedTarget(context, metadata, cchild);
1:                     }
1:                     if (listenerComponent == null) {
1:                         throw new IllegalArgumentException("Missing @ref attribute or inlined bean definition element");
1:                     }
1:                     metadata.addRegistrationListener(listenerComponent, regMethod, unregMethod);
1:                 }
1:                 else if (SERVICE_PROPERTIES_ELEMENT.equals(child.getLocalName())) {
1:                     // TODO: @key-type
1:                     for (Element e : getChildren(child)) {
1:                         if (ENTRY_ELEMENT.equals(e.getLocalName())) {
1:                             NonNullMetadata key;
1:                             Metadata val;
1:                             boolean hasKeyAttribute = e.hasAttribute(KEY_ATTRIBUTE);
1:                             boolean hasKeyRefAttribute = e.hasAttribute(KEY_REF_ATTRIBUTE);
1:                             if (hasKeyRefAttribute && !hasKeyAttribute) {
1:                                 MutableRefMetadata r = context.createMetadata(MutableRefMetadata.class);
1:                                 r.setComponentId(e.getAttribute(KEY_REF_ATTRIBUTE));
1:                                 key = r;
1:                             } else if (hasKeyAttribute && !hasKeyRefAttribute) {
1:                                 MutableValueMetadata v = context.createMetadata(MutableValueMetadata.class);
1:                                 v.setStringValue(e.getAttribute(KEY_ATTRIBUTE));
1:                                 key = v;
1:                             } else {
1:                                 throw new IllegalStateException("Either key or key-ref must be specified");
1:                             }
1:                             // TODO: support key
1:                             boolean hasValAttribute = e.hasAttribute(VALUE_ATTRIBUTE);
1:                             boolean hasValRefAttribute = e.hasAttribute(VALUE_REF_ATTRIBUTE);
1:                             if (hasValRefAttribute && !hasValAttribute) {
1:                                 MutableRefMetadata r = context.createMetadata(MutableRefMetadata.class);
1:                                 r.setComponentId(e.getAttribute(VALUE_REF_ATTRIBUTE));
1:                                 val = r;
1:                             } else if (hasValAttribute && !hasValRefAttribute) {
1:                                 MutableValueMetadata v = context.createMetadata(MutableValueMetadata.class);
1:                                 v.setStringValue(e.getAttribute(VALUE_ATTRIBUTE));
1:                                 val = v;
1:                             } else {
1:                                 throw new IllegalStateException("Either val or val-ref must be specified");
1:                             }
1:                             // TODO: support children elements ?
1:                             metadata.addServiceProperty(key, val);
1:                         }
1:                     }
1:                 }
1:             }
1:             else if (BLUEPRINT_NAMESPACE.equals(child.getNamespaceURI())
1:                     && BEAN_ELEMENT.equals(child.getLocalName())) {
1:                 if (metadata.getServiceComponent() != null) {
1:                     throw new IllegalArgumentException("Only one of @ref attribute and bean element is allowed");
1:                 }
1:                 Target bean = context.parseElement(BeanMetadata.class, metadata, child);
1:                 metadata.setServiceComponent(bean);
1:             }
1:             else {
1:                 if (metadata.getServiceComponent() != null) {
1:                     throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:                 }
1:                 NamespaceHandler handler = context.getNamespaceHandler(URI.create(child.getNamespaceURI()));
1:                 if (handler == null) {
1:                     throw new IllegalStateException("No NamespaceHandler found for " + child.getNamespaceURI());
1:                 }
1:                 Metadata md = handler.parse(child, context);
1:                 if (!(md instanceof Target)) {
1:                     throw new IllegalStateException("NamespaceHandler did not return a Target instance but " + md);
1:                 }
1:                 metadata.setServiceComponent((Target) md);
1:             }
1:         }
1:         return metadata;
1:     }
1: 
1:     private Metadata parseReference(Element element, ParserContext context) {
1:         MutableReferenceMetadata metadata = context.createMetadata(MutableReferenceMetadata.class);
1:         // Parse attributes
1:         if (element.hasAttribute(ID_ATTRIBUTE)) {
1:             metadata.setId(element.getAttribute(ID_ATTRIBUTE));
1:         } else {
1:             metadata.setId(generateId(context));
1:         }
1:         metadata.setAvailability(CARDINALITY_0_1.equals(element.getAttribute(CARDINALITY_ATTRIBUTE))
1:                 ? ReferenceMetadata.AVAILABILITY_OPTIONAL
1:                 : ReferenceMetadata.AVAILABILITY_MANDATORY);
1:         metadata.setTimeout(getLong(element.getAttribute(TIMEOUT_ATTRIBUTE), DEFAULT_TIMEOUT));
1:         metadata.setInterface(element.getAttribute(INTERFACE_ATTRIBUTE));
1:         metadata.setFilter(element.getAttribute(FILTER_ATTRIBUTE));
1:         String[] dependsOn = StringUtils.tokenizeToStringArray(element.getAttribute(DEPENDS_ON_ATTRIBUTE), ",; ");
1:         metadata.setDependsOn(dependsOn != null ? Arrays.asList(dependsOn) : null);
1:         metadata.setComponentName(element.getAttribute(BEAN_NAME_ELEMENT));
1:         // TODO: @context-class-loader
1:         // Parse child elements
1:         for (Element child : getChildren(element)) {
1:             if (element.getNamespaceURI().equals(child.getNamespaceURI())) {
1:                 if (INTERFACES_ELEMENT.equals(child.getLocalName())) {
1:                     List<String> itfs = parseInterfaces(child);
1:                     metadata.setExtraInterfaces(itfs);
1:                 }
1:                 else if (LISTENER_ELEMENT.equals(child.getLocalName())) {
1:                     String bindMethod = nonEmpty(child.getAttribute(BIND_METHOD_ATTRIBUTE));
1:                     String unbindMethod = nonEmpty(child.getAttribute(UNBIND_METHOD_ATTRIBUTE));
1:                     String refStr = nonEmpty(child.getAttribute(REF_ATTRIBUTE));
1:                     Target listenerComponent = null;
1:                     if (refStr != null) {
1:                         MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
1:                         ref.setComponentId(refStr);
1:                         listenerComponent = ref;
1:                     }
1:                     for (Element cchild : getChildren(child)) {
1:                         if (listenerComponent != null) {
1:                             throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:                         }
1:                         listenerComponent = parseInlinedTarget(context, metadata, cchild);
1:                     }
1:                     if (listenerComponent == null) {
1:                         throw new IllegalArgumentException("Missing @ref attribute or inlined bean definition element");
1:                     }
1:                     metadata.addServiceListener(listenerComponent, bindMethod, unbindMethod);
1:                 }
1:             }
1:             else {
1:                 throw new UnsupportedOperationException("Custom namespaces not supported");
1:             }
1:         }
1:         return metadata;
1:     }
1: 
1:     private Target parseInlinedTarget(ParserContext context, ComponentMetadata metadata, Element element) {
1:         Target listenerComponent;
1:         if (BLUEPRINT_NAMESPACE.equals(element.getNamespaceURI())
1:                 && BEAN_ELEMENT.equals(element.getLocalName())) {
1:             listenerComponent = context.parseElement(BeanMetadata.class, metadata, element);
1:         }
1:         else {
1:             NamespaceHandler handler = context.getNamespaceHandler(URI.create(element.getNamespaceURI()));
1:             if (handler == null) {
1:                 throw new IllegalStateException("No NamespaceHandler found for " + element.getNamespaceURI());
1:             }
1:             Metadata md = handler.parse(element, context);
1:             if (!(md instanceof Target)) {
1:                 throw new IllegalStateException("NamespaceHandler did not return a Target instance but " + md);
1:             }
1:             listenerComponent = (Target) md;
1:         }
1:         return listenerComponent;
1:     }
1: 
1:     private List<String> parseInterfaces(Element element) {
1:         List<String> extra = new ArrayList<String>();
1:         for (Element e : getChildren(element)) {
1:             if (VALUE_ELEMENT.equals(e.getLocalName())) {
1:                 extra.add(getTextValue(e));
1:             } else {
1:                 // The schema support all kind of children for a list type
1:                 // The type for the spring property is converted to a Class[] array
1:                 // TODO: support other elements ?
1:                 throw new UnsupportedOperationException("Unsupported child: " + element.getLocalName());
1:             }
1:         }
1:         return extra;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         for(int i = 0, l = nl.getLength(); i < l; ++i) {
commit:2e9d097
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.Target;
1:     public static final String BLUEPRINT_NAMESPACE = "http://www.osgi.org/xmlns/blueprint/v1.0.0";
1:     public static final String SPRING_NAMESPACE = "http://www.springframework.org/schema/beans";
1:     public static final String BEAN_ELEMENT = "bean";
1: 
1:     private int idCounter;
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (element.hasAttribute("id")) {
0:                 metadata.setId(element.getAttribute("id"));
1:             } else {
0:                 metadata.setId(generateId(context));
1:             }
/////////////////////////////////////////////////////////////////////////
0:                         String bindMethod = nonEmpty(child.getAttribute("bind-method"));
0:                         String unbindMethod = nonEmpty(child.getAttribute("unbind-method"));
0:                         String refStr = nonEmpty(child.getAttribute("ref"));
0:                         Target listenerComponent = null;
0:                         if (refStr != null) {
0:                             MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
0:                             ref.setComponentId(refStr);
0:                             listenerComponent = ref;
1:                         }
0:                         for (Element cchild : getChildren(child)) {
0:                             if (BLUEPRINT_NAMESPACE.equals(cchild.getNamespaceURI())
0:                                     && BEAN_ELEMENT.equals(cchild.getLocalName())) {
0:                                 if (listenerComponent != null) {
0:                                     throw new IllegalArgumentException("Only one of @ref attribute and bean element is allowed");
1:                                 }
0:                                 listenerComponent = context.parseElement(BeanMetadata.class, metadata, cchild);
1:                             }
0:                             else if (SPRING_NAMESPACE.equals(cchild.getNamespaceURI())
0:                                     && BEAN_ELEMENT.equals(cchild.getLocalName())) {
0:                                 if (listenerComponent != null) {
0:                                     throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:                                 }
0:                                 listenerComponent = (Target) context.getNamespaceHandler(URI.create(SPRING_NAMESPACE))
0:                                         .parse(cchild, context);
1:                             }
0:                             else {
0:                                 throw new IllegalArgumentException("Unsupported element " + cchild.getLocalName());
1:                             }
1:                         }
0:                         if (listenerComponent == null) {
0:                             throw new IllegalArgumentException("Missing @ref attribute or inlined bean definition element");
1:                         }
0:                         metadata.addServiceListener(listenerComponent, bindMethod, unbindMethod);
/////////////////////////////////////////////////////////////////////////
0:             if (element.hasAttribute("id")) {
0:                 metadata.setId(element.getAttribute("id"));
0:             } else {
0:                 metadata.setId(generateId(context));
1:             }
0:             if (nonEmpty(element.getAttribute("ref")) != null) {
0:             metadata.setRanking(nonEmpty(element.getAttribute("ranking")) != null
0:             String itf = nonEmpty(element.getAttribute("interface"));
0:             String[] dependsOn = StringUtils.tokenizeToStringArray(nonEmpty(element.getAttribute("depends-on")), ",; ");
0:             String autoExp = nonEmpty(element.getAttribute("auto-export"));
/////////////////////////////////////////////////////////////////////////
0:                 else if (BLUEPRINT_NAMESPACE.equals(child.getNamespaceURI())
0:                         && BEAN_ELEMENT.equals(child.getLocalName())) {
0:                     if (metadata.getServiceComponent() != null) {
0:                         throw new IllegalArgumentException("Only one of @ref attribute and bean element is allowed");
1:                     }
0:                     Target bean = context.parseElement(BeanMetadata.class, metadata, child);
0:                     metadata.setServiceComponent(bean);
1:                 }
0:                 else if (SPRING_NAMESPACE.equals(child.getNamespaceURI())
0:                         && BEAN_ELEMENT.equals(child.getLocalName())) {
0:                     if (metadata.getServiceComponent() != null) {
0:                         throw new IllegalArgumentException("Only one of @ref attribute or inlined bean definition element is allowed");
1:                     }
0:                     Target bean = (Target) context.getNamespaceHandler(URI.create(SPRING_NAMESPACE))
0:                             .parse(child, context);
0:                     metadata.setServiceComponent(bean);
1:                 }
0:                     throw new IllegalArgumentException("Unsupported element " + child.getLocalName());
/////////////////////////////////////////////////////////////////////////
1:     private String nonEmpty(String ref) {
1:         return ref != null && ref.isEmpty() ? null : ref;
1:     }
1: 
1:     private String generateId(ParserContext context) {
1:         String id;
1:         do {
1:             id = ".spring-osgi-" + ++idCounter;
1:         } while (context.getComponentDefinitionRegistry().containsComponentDefinition(id));
1:         return id;
1:     }
1: 
commit:1388916
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
commit:09b7171
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.spring.extender;
1: 
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.List;
1: import java.util.Set;
1: 
1: import org.apache.aries.blueprint.NamespaceHandler;
1: import org.apache.aries.blueprint.ParserContext;
1: import org.apache.aries.blueprint.mutable.MutableRefMetadata;
1: import org.apache.aries.blueprint.mutable.MutableReferenceMetadata;
1: import org.apache.aries.blueprint.mutable.MutableServiceMetadata;
1: import org.apache.aries.blueprint.mutable.MutableValueMetadata;
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.NonNullMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.springframework.util.Assert;
1: import org.springframework.util.StringUtils;
0: import org.w3c.dom.*;
1: 
1: public class SpringOsgiNamespaceHandler implements NamespaceHandler {
1: 
1:     @Override
1:     public URL getSchemaLocation(String namespace) {
1:         if (namespace.startsWith("http://www.springframework.org/schema/osgi/spring-osgi")) {
1:             String sub = namespace.substring("http://www.springframework.org/schema/osgi/".length());
1:             if ("spring-osgi.xsd".equals(sub)) {
1:                 sub = "spring-osgi-1.2.xsd";
1:             }
1:             return getClass().getResource(sub);
1:         }
1:         return null;
1:     }
1: 
1:     @Override
1:     public Set<Class> getManagedClasses() {
1:         return null;
1:     }
1: 
1:     @Override
1:     public Metadata parse(Element element, ParserContext context) {
0:         if ("reference".equals(element.getLocalName())) {
0:             MutableReferenceMetadata metadata = context.createMetadata(MutableReferenceMetadata.class);
0:             // Parse attributes
0:             // TODO: auto generate id ?
0:             metadata.setId(element.getAttribute("id"));
0:             metadata.setAvailability("0..1".equals(element.getAttribute("cardinality"))
0:                     ? ReferenceMetadata.AVAILABILITY_OPTIONAL
0:                     : ReferenceMetadata.AVAILABILITY_MANDATORY);
0:             metadata.setTimeout(getLong(element.getAttribute("timeout"), 300000));
0:             metadata.setInterface(element.getAttribute("interface"));
0:             metadata.setFilter(element.getAttribute("filter"));
0:             String[] dependsOn = StringUtils.tokenizeToStringArray(element.getAttribute("depends-on"), ",; ");
0:             metadata.setDependsOn(dependsOn != null ? Arrays.asList(dependsOn) : null);
0:             metadata.setComponentName(element.getAttribute("bean-name"));
0:             // TODO: @context-class-loader
0:             // Parse child elements
0:             for (Element child : getChildren(element)) {
0:                 if (element.getNamespaceURI().equals(child.getNamespaceURI())) {
0:                     if ("interfaces".equals(child.getLocalName())) {
0:                         List<String> extra = new ArrayList<String>();
0:                         for (Element e : getChildren(child)) {
0:                             if ("value".equals(e.getLocalName())) {
0:                                 extra.add(getTextValue(e));
0:                             } else {
0:                                 // TODO: support other elements ?
0:                                 throw new UnsupportedOperationException("Unsupported child: " + element.getLocalName());
1:                             }
1:                         }
0:                         metadata.setExtraInterfaces(extra);
1:                     }
0:                     else if ("listener".equals(child.getLocalName())) {
0:                         // TODO: listener
1: 
1:                     }
1:                 }
0:                 else {
0:                     throw new UnsupportedOperationException("Custom namespaces not supported");
1:                 }
1:             }
0:             return metadata;
1:         }
0:         else if ("service".equals(element.getLocalName())) {
0:             MutableServiceMetadata metadata = context.createMetadata(MutableServiceMetadata.class);
0:             // Parse attributes
0:             // TODO: auto generate id ?
0:             metadata.setId(element.getAttribute("id"));
0:             if (element.getAttribute("ref") != null) {
0:                 MutableRefMetadata ref = context.createMetadata(MutableRefMetadata.class);
0:                 ref.setComponentId(element.getAttribute("ref"));
0:                 metadata.setServiceComponent(ref);
1:             }
0:             metadata.setRanking(element.getAttribute("ranking") != null
0:                     ? Integer.parseInt(element.getAttribute("ranking"))
0:                     : 0);
0:             String itf = element.getAttribute("interface");
0:             if (itf != null) {
0:                 metadata.addInterface(itf);
1:             }
0:             String[] dependsOn = StringUtils.tokenizeToStringArray(element.getAttribute("depends-on"), ",; ");
0:             metadata.setDependsOn(dependsOn != null ? Arrays.asList(dependsOn) : null);
0:             String autoExp = element.getAttribute("auto-export");
0:             if ("interfaces".equals(autoExp)) {
0:                 metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_INTERFACES);
0:             } else if ("class-hierarchy".equals(autoExp)) {
0:                 metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY);
0:             } else if ("all-classes".equals(autoExp)) {
0:                 metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_ALL_CLASSES);
0:             } else {
0:                 metadata.setAutoExport(ServiceMetadata.AUTO_EXPORT_DISABLED);
1:             }
0:             // TODO: @context-class-loader
0:             // Parse child elements
0:             for (Element child : getChildren(element)) {
0:                 if (element.getNamespaceURI().equals(child.getNamespaceURI())) {
0:                     if ("interfaces".equals(child.getLocalName())) {
0:                         for (Element e : getChildren(child)) {
0:                             if ("value".equals(e.getLocalName())) {
0:                                 metadata.addInterface(getTextValue(e));
0:                             } else {
0:                                 // TODO: support other elements ?
0:                                 throw new UnsupportedOperationException("Unsupported child: " + element.getLocalName());
1:                             }
1:                         }
1:                     }
0:                     else if ("registration-listener".equals(child.getLocalName())) {
0:                         // TODO: registration-listener
1: 
1:                     }
0:                     else if ("service-properties".equals(child.getLocalName())) {
0:                         // TODO: @key-type
0:                         for (Element e : getChildren(child)) {
0:                             if ("entry".equals(e.getLocalName())) {
0:                                 NonNullMetadata key;
0:                                 Metadata val;
0:                                 boolean hasKeyAttribute = e.hasAttribute("key");
0:                                 boolean hasKeyRefAttribute = e.hasAttribute("key-ref");
0:                                 if (hasKeyRefAttribute && !hasKeyAttribute) {
0:                                     MutableRefMetadata r = context.createMetadata(MutableRefMetadata.class);
0:                                     r.setComponentId(e.getAttribute("key-ref"));
0:                                     key = r;
0:                                 } else if (hasKeyAttribute && !hasKeyRefAttribute) {
0:                                     MutableValueMetadata v = context.createMetadata(MutableValueMetadata.class);
0:                                     v.setStringValue(e.getAttribute("key"));
0:                                     key = v;
0:                                 } else {
0:                                     throw new IllegalStateException("Either key or key-ref must be specified");
1:                                 }
0:                                 // TODO: support children elements ?
0:                                 boolean hasValAttribute = e.hasAttribute("value");
0:                                 boolean hasValRefAttribute = e.hasAttribute("value-ref");
0:                                 if (hasValRefAttribute && !hasValAttribute) {
0:                                     MutableRefMetadata r = context.createMetadata(MutableRefMetadata.class);
0:                                     r.setComponentId(e.getAttribute("value-ref"));
0:                                     val = r;
0:                                 } else if (hasValAttribute && !hasValRefAttribute) {
0:                                     MutableValueMetadata v = context.createMetadata(MutableValueMetadata.class);
0:                                     v.setStringValue(e.getAttribute("value"));
0:                                     val = v;
0:                                 } else {
0:                                     throw new IllegalStateException("Either val or val-ref must be specified");
1:                                 }
0:                                 // TODO: support children elements ?
0:                                 metadata.addServiceProperty(key, val);
1:                             }
1:                         }
1:                     }
1:                 }
0:                 else {
0:                     throw new UnsupportedOperationException("Custom namespaces not supported");
1:                 }
1:             }
0:             return metadata;
1:         }
0:         else if ("bundle".equals(element.getLocalName())) {
1: 
1:         }
0:         else if ("set".equals(element.getLocalName())) {
1: 
1:         }
0:         else if ("list".equals(element.getLocalName())) {
1: 
1:         }
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context) {
1:         return component;
1:     }
1: 
1:     private List<Element> getChildren(Element element) {
1:         List<Element> children = new ArrayList<Element>();
1:         for (Node child = element.getFirstChild(); child != null; child = child.getNextSibling()) {
1:             if (child instanceof Element) {
1:                 children.add((Element) child);
1:             }
1:         }
1:         return children;
1:     }
1: 
1:     private long getLong(String str, long def) {
1:         if (str == null || str.isEmpty()) {
1:             return def;
0:         } else {
1:             return Long.parseLong(str);
1:         }
1:     }
1: 
1:     public static String getTextValue(Element valueEle) {
1:         Assert.notNull(valueEle, "Element must not be null");
1:         StringBuilder sb = new StringBuilder();
1:         NodeList nl = valueEle.getChildNodes();
0:         for(int i = 0; i < nl.getLength(); ++i) {
1:             Node item = nl.item(i);
1:             if(item instanceof CharacterData && !(item instanceof Comment) || item instanceof EntityReference) {
1:                 sb.append(item.getNodeValue());
1:             }
1:         }
1:         return sb.toString();
1:     }
1: }
============================================================================