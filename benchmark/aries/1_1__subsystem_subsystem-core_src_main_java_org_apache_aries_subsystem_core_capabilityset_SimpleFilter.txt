1:9df8274: /*
1:9df8274:  * Licensed to the Apache Software Foundation (ASF) under one
1:9df8274:  * or more contributor license agreements.  See the NOTICE file
1:9df8274:  * distributed with this work for additional information
1:9df8274:  * regarding copyright ownership.  The ASF licenses this file
1:9df8274:  * to you under the Apache License, Version 2.0 (the
1:9df8274:  * "License"); you may not use this file except in compliance
1:9df8274:  * with the License.  You may obtain a copy of the License at
1:2ffcfb9:  *
1:9df8274:  *   http://www.apache.org/licenses/LICENSE-2.0
2:9df8274:  *
1:9df8274:  * Unless required by applicable law or agreed to in writing,
1:9df8274:  * software distributed under the License is distributed on an
1:9df8274:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9df8274:  * KIND, either express or implied.  See the License for the
1:9df8274:  * specific language governing permissions and limitations
1:9df8274:  * under the License.
2:9df8274:  */
1:9df8274: package org.apache.aries.subsystem.core.capabilityset;
1:9df8274: 
1:9df8274: import java.util.ArrayList;
1:2ffcfb9: import java.util.Collection;
1:2ffcfb9: import java.util.HashMap;
1:2ffcfb9: import java.util.Iterator;
1:9df8274: import java.util.List;
1:9df8274: import java.util.Map;
1:9df8274: import java.util.Map.Entry;
1:9df8274: 
1:c5864b3: import org.apache.aries.subsystem.core.archive.AttributeFactory;
1:c5864b3: import org.apache.aries.subsystem.core.archive.Parameter;
1:c5864b3: import org.apache.aries.subsystem.core.archive.VersionRangeAttribute;
1:9df8274: import org.osgi.framework.VersionRange;
1:9df8274: 
1:9df8274: public class SimpleFilter
1:9df8274: {
1:9df8274:     public static final int MATCH_ALL = 0;
1:9df8274:     public static final int AND = 1;
1:9df8274:     public static final int OR = 2;
1:9df8274:     public static final int NOT = 3;
1:9df8274:     public static final int EQ = 4;
1:9df8274:     public static final int LTE = 5;
1:9df8274:     public static final int GTE = 6;
1:9df8274:     public static final int SUBSTRING = 7;
1:9df8274:     public static final int PRESENT = 8;
1:9df8274:     public static final int APPROX = 9;
1:9df8274: 
1:9df8274:     private final String m_name;
1:9df8274:     private final Object m_value;
1:9df8274:     private final int m_op;
1:9df8274: 
1:9df8274:     public SimpleFilter(String attr, Object value, int op)
1:9df8274:     {
1:9df8274:         m_name = attr;
1:9df8274:         m_value = value;
1:9df8274:         m_op = op;
1:9df8274:     }
1:9df8274: 
1:9df8274:     public String getName()
1:9df8274:     {
1:9df8274:         return m_name;
1:9df8274:     }
1:9df8274: 
1:9df8274:     public Object getValue()
1:9df8274:     {
1:9df8274:         return m_value;
1:9df8274:     }
1:9df8274: 
1:9df8274:     public int getOperation()
1:9df8274:     {
1:9df8274:         return m_op;
1:9df8274:     }
1:9df8274: 
1:9df8274:     public String toString()
1:9df8274:     {
1:9df8274:         String s = null;
1:9df8274:         switch (m_op)
1:9df8274:         {
1:9df8274:             case AND:
1:9df8274:                 s = "(&" + toString((List) m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case OR:
1:9df8274:                 s = "(|" + toString((List) m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case NOT:
1:9df8274:                 s = "(!" + toString((List) m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case EQ:
1:9df8274:                 s = "(" + m_name + "=" + toEncodedString(m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case LTE:
1:9df8274:                 s = "(" + m_name + "<=" + toEncodedString(m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case GTE:
1:9df8274:                 s = "(" + m_name + ">=" + toEncodedString(m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case SUBSTRING:
1:9df8274:                 s = "(" + m_name + "=" + unparseSubstring((List<String>) m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case PRESENT:
1:9df8274:                 s = "(" + m_name + "=*)";
1:9df8274:                 break;
1:9df8274:             case APPROX:
1:9df8274:                 s = "(" + m_name + "~=" + toEncodedString(m_value) + ")";
1:9df8274:                 break;
1:9df8274:             case MATCH_ALL:
1:9df8274:                 s = "(*)";
1:9df8274:                 break;
1:9df8274:         }
1:9df8274:         return s;
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static String toString(List list)
1:9df8274:     {
1:9df8274:         StringBuffer sb = new StringBuffer();
1:9df8274:         for (int i = 0; i < list.size(); i++)
1:9df8274:         {
1:9df8274:             sb.append(list.get(i).toString());
1:9df8274:         }
1:9df8274:         return sb.toString();
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static String toDecodedString(String s, int startIdx, int endIdx)
1:9df8274:     {
1:9df8274:         StringBuffer sb = new StringBuffer(endIdx - startIdx);
1:9df8274:         boolean escaped = false;
1:9df8274:         for (int i = 0; i < (endIdx - startIdx); i++)
1:9df8274:         {
1:9df8274:             char c = s.charAt(startIdx + i);
1:9df8274:             if (!escaped && (c == '\\'))
1:9df8274:             {
1:9df8274:                 escaped = true;
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 escaped = false;
1:9df8274:                 sb.append(c);
1:9df8274:             }
1:9df8274:         }
1:9df8274: 
1:9df8274:         return sb.toString();
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static String toEncodedString(Object o)
1:9df8274:     {
1:9df8274:         if (o instanceof String)
1:9df8274:         {
1:9df8274:             String s = (String) o;
1:9df8274:             StringBuffer sb = new StringBuffer();
1:9df8274:             for (int i = 0; i < s.length(); i++)
1:9df8274:             {
1:9df8274:                 char c = s.charAt(i);
1:9df8274:                 if ((c == '\\') || (c == '(') || (c == ')') || (c == '*'))
1:9df8274:                 {
1:9df8274:                     sb.append('\\');
1:9df8274:                 }
1:9df8274:                 sb.append(c);
1:9df8274:             }
1:9df8274: 
1:9df8274:             o = sb.toString();
1:9df8274:         }
1:9df8274: 
1:9df8274:         return o.toString();
1:9df8274:     }
1:9df8274: 
1:9df8274:     public static SimpleFilter parse(String filter)
1:9df8274:     {
1:9df8274:         int idx = skipWhitespace(filter, 0);
1:9df8274: 
1:9df8274:         if ((filter == null) || (filter.length() == 0) || (idx >= filter.length()))
1:9df8274:         {
1:9df8274:             throw new IllegalArgumentException("Null or empty filter.");
1:9df8274:         }
1:9df8274:         else if (filter.charAt(idx) != '(')
1:9df8274:         {
1:9df8274:             throw new IllegalArgumentException("Missing opening parenthesis: " + filter);
1:9df8274:         }
1:9df8274: 
1:9df8274:         SimpleFilter sf = null;
1:9df8274:         List stack = new ArrayList();
1:9df8274:         boolean isEscaped = false;
1:9df8274:         while (idx < filter.length())
1:9df8274:         {
1:9df8274:             if (sf != null)
1:9df8274:             {
1:9df8274:                 throw new IllegalArgumentException(
1:9df8274:                     "Only one top-level operation allowed: " + filter);
1:9df8274:             }
1:9df8274: 
1:9df8274:             if (!isEscaped && (filter.charAt(idx) == '('))
1:9df8274:             {
1:9df8274:                 // Skip paren and following whitespace.
1:9df8274:                 idx = skipWhitespace(filter, idx + 1);
1:9df8274: 
1:9df8274:                 if (filter.charAt(idx) == '&')
1:9df8274:                 {
1:9df8274:                     int peek = skipWhitespace(filter, idx + 1);
1:9df8274:                     if (filter.charAt(peek) == '(')
1:9df8274:                     {
1:9df8274:                         idx = peek - 1;
1:9df8274:                         stack.add(0, new SimpleFilter(null, new ArrayList(), SimpleFilter.AND));
1:9df8274:                     }
1:9df8274:                     else
1:9df8274:                     {
1:9df8274:                         stack.add(0, new Integer(idx));
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:                 else if (filter.charAt(idx) == '|')
1:9df8274:                 {
1:9df8274:                     int peek = skipWhitespace(filter, idx + 1);
1:9df8274:                     if (filter.charAt(peek) == '(')
1:9df8274:                     {
1:9df8274:                         idx = peek - 1;
1:9df8274:                         stack.add(0, new SimpleFilter(null, new ArrayList(), SimpleFilter.OR));
1:9df8274:                     }
1:9df8274:                     else
1:9df8274:                     {
1:9df8274:                         stack.add(0, new Integer(idx));
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:                 else if (filter.charAt(idx) == '!')
1:9df8274:                 {
1:9df8274:                     int peek = skipWhitespace(filter, idx + 1);
1:9df8274:                     if (filter.charAt(peek) == '(')
1:9df8274:                     {
1:9df8274:                         idx = peek - 1;
1:9df8274:                         stack.add(0, new SimpleFilter(null, new ArrayList(), SimpleFilter.NOT));
1:9df8274:                     }
1:9df8274:                     else
1:9df8274:                     {
1:9df8274:                         stack.add(0, new Integer(idx));
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     stack.add(0, new Integer(idx));
1:9df8274:                 }
1:9df8274:             }
1:9df8274:             else if (!isEscaped && (filter.charAt(idx) == ')'))
1:9df8274:             {
1:9df8274:                 Object top = stack.remove(0);
1:9df8274:                 if (top instanceof SimpleFilter)
1:9df8274:                 {
1:9df8274:                     if (!stack.isEmpty() && (stack.get(0) instanceof SimpleFilter))
1:9df8274:                     {
1:9df8274:                         ((List) ((SimpleFilter) stack.get(0)).m_value).add(top);
1:9df8274:                     }
1:9df8274:                     else
1:9df8274:                     {
1:9df8274:                         sf = (SimpleFilter) top;
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:                 else if (!stack.isEmpty() && (stack.get(0) instanceof SimpleFilter))
1:9df8274:                 {
1:9df8274:                     ((List) ((SimpleFilter) stack.get(0)).m_value).add(
1:9df8274:                         SimpleFilter.subfilter(filter, ((Integer) top).intValue(), idx));
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     sf = SimpleFilter.subfilter(filter, ((Integer) top).intValue(), idx);
1:9df8274:                 }
1:9df8274:             }
1:9df8274:             else if (!isEscaped && (filter.charAt(idx) == '\\'))
1:9df8274:             {
1:9df8274:                 isEscaped = true;
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 isEscaped = false;
1:9df8274:             }
1:9df8274: 
1:9df8274:             idx = skipWhitespace(filter, idx + 1);
1:9df8274:         }
1:9df8274: 
1:9df8274:         if (sf == null)
1:9df8274:         {
1:9df8274:             throw new IllegalArgumentException("Missing closing parenthesis: " + filter);
1:9df8274:         }
1:9df8274: 
1:9df8274:         return sf;
1:9df8274:     }
1:2ffcfb9: 
1:9df8274:     private static SimpleFilter subfilter(String filter, int startIdx, int endIdx)
1:9df8274:     {
1:9df8274:         final String opChars = "=<>~";
1:9df8274: 
1:9df8274:         // Determine the ending index of the attribute name.
1:9df8274:         int attrEndIdx = startIdx;
1:9df8274:         for (int i = 0; i < (endIdx - startIdx); i++)
1:9df8274:         {
1:9df8274:             char c = filter.charAt(startIdx + i);
1:9df8274:             if (opChars.indexOf(c) >= 0)
1:9df8274:             {
1:9df8274:                 break;
1:9df8274:             }
1:9df8274:             else if (!Character.isWhitespace(c))
1:9df8274:             {
1:9df8274:                 attrEndIdx = startIdx + i + 1;
1:9df8274:             }
1:9df8274:         }
1:9df8274:         if (attrEndIdx == startIdx)
1:9df8274:         {
1:9df8274:             throw new IllegalArgumentException(
1:9df8274:                 "Missing attribute name: " + filter.substring(startIdx, endIdx));
1:9df8274:         }
1:9df8274:         String attr = filter.substring(startIdx, attrEndIdx);
1:9df8274: 
1:9df8274:         // Skip the attribute name and any following whitespace.
1:9df8274:         startIdx = skipWhitespace(filter, attrEndIdx);
1:9df8274: 
1:9df8274:         // Determine the operator type.
1:9df8274:         int op = -1;
1:9df8274:         switch (filter.charAt(startIdx))
1:9df8274:         {
1:9df8274:             case '=':
1:9df8274:                 op = EQ;
1:9df8274:                 startIdx++;
1:9df8274:                 break;
1:9df8274:             case '<':
1:9df8274:                 if (filter.charAt(startIdx + 1) != '=')
1:9df8274:                 {
1:9df8274:                     throw new IllegalArgumentException(
1:9df8274:                         "Unknown operator: " + filter.substring(startIdx, endIdx));
1:9df8274:                 }
1:9df8274:                 op = LTE;
1:9df8274:                 startIdx += 2;
1:9df8274:                 break;
1:9df8274:             case '>':
1:9df8274:                 if (filter.charAt(startIdx + 1) != '=')
1:9df8274:                 {
1:9df8274:                     throw new IllegalArgumentException(
1:9df8274:                         "Unknown operator: " + filter.substring(startIdx, endIdx));
1:9df8274:                 }
1:9df8274:                 op = GTE;
1:9df8274:                 startIdx += 2;
1:9df8274:                 break;
1:9df8274:             case '~':
1:9df8274:                 if (filter.charAt(startIdx + 1) != '=')
1:9df8274:                 {
1:9df8274:                     throw new IllegalArgumentException(
1:9df8274:                         "Unknown operator: " + filter.substring(startIdx, endIdx));
1:9df8274:                 }
1:9df8274:                 op = APPROX;
1:9df8274:                 startIdx += 2;
1:9df8274:                 break;
1:9df8274:             default:
1:9df8274:                 throw new IllegalArgumentException(
1:9df8274:                     "Unknown operator: " + filter.substring(startIdx, endIdx));
1:9df8274:         }
1:9df8274: 
1:9df8274:         // Parse value.
1:9df8274:         Object value = toDecodedString(filter, startIdx, endIdx);
1:9df8274: 
1:9df8274:         // Check if the equality comparison is actually a substring
1:9df8274:         // or present operation.
1:9df8274:         if (op == EQ)
1:9df8274:         {
1:9df8274:             String valueStr = filter.substring(startIdx, endIdx);
1:9df8274:             List<String> values = parseSubstring(valueStr);
1:9df8274:             if ((values.size() == 2)
1:9df8274:                 && (values.get(0).length() == 0)
1:9df8274:                 && (values.get(1).length() == 0))
1:9df8274:             {
1:9df8274:                 op = PRESENT;
1:9df8274:             }
1:9df8274:             else if (values.size() > 1)
1:9df8274:             {
1:9df8274:                 op = SUBSTRING;
1:9df8274:                 value = values;
1:9df8274:             }
1:9df8274:         }
1:9df8274: 
1:9df8274:         return new SimpleFilter(attr, value, op);
1:9df8274:     }
1:9df8274: 
1:9df8274:     public static List<String> parseSubstring(String value)
1:9df8274:     {
1:9df8274:         List<String> pieces = new ArrayList();
1:9df8274:         StringBuffer ss = new StringBuffer();
1:9df8274:         // int kind = SIMPLE; // assume until proven otherwise
1:9df8274:         boolean wasStar = false; // indicates last piece was a star
1:9df8274:         boolean leftstar = false; // track if the initial piece is a star
1:9df8274:         boolean rightstar = false; // track if the final piece is a star
1:9df8274: 
1:9df8274:         int idx = 0;
1:9df8274: 
1:9df8274:         // We assume (sub)strings can contain leading and trailing blanks
1:9df8274:         boolean escaped = false;
1:9df8274: loop:   for (;;)
1:9df8274:         {
1:9df8274:             if (idx >= value.length())
1:9df8274:             {
1:9df8274:                 if (wasStar)
1:9df8274:                 {
1:9df8274:                     // insert last piece as "" to handle trailing star
1:9df8274:                     rightstar = true;
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     pieces.add(ss.toString());
1:9df8274:                     // accumulate the last piece
1:9df8274:                     // note that in the case of
1:9df8274:                     // (cn=); this might be
1:9df8274:                     // the string "" (!=null)
1:9df8274:                 }
1:9df8274:                 ss.setLength(0);
1:9df8274:                 break loop;
1:9df8274:             }
1:9df8274: 
1:9df8274:             // Read the next character and account for escapes.
1:9df8274:             char c = value.charAt(idx++);
1:9df8274:             if (!escaped && (c == '*'))
1:9df8274:             {
1:9df8274:                 // If we have successive '*' characters, then we can
1:9df8274:                 // effectively collapse them by ignoring succeeding ones.
1:9df8274:                 if (!wasStar)
1:9df8274:                 {
1:9df8274:                     if (ss.length() > 0)
1:9df8274:                     {
1:9df8274:                         pieces.add(ss.toString()); // accumulate the pieces
1:9df8274:                         // between '*' occurrences
1:9df8274:                     }
1:9df8274:                     ss.setLength(0);
1:9df8274:                     // if this is a leading star, then track it
1:9df8274:                     if (pieces.isEmpty())
1:9df8274:                     {
1:9df8274:                         leftstar = true;
1:9df8274:                     }
1:9df8274:                     wasStar = true;
1:9df8274:                 }
1:9df8274:             }
1:9df8274:             else if (!escaped && (c == '\\'))
1:9df8274:             {
1:9df8274:                 escaped = true;
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 escaped = false;
1:9df8274:                 wasStar = false;
1:9df8274:                 ss.append(c);
1:9df8274:             }
1:9df8274:         }
1:9df8274:         if (leftstar || rightstar || pieces.size() > 1)
1:9df8274:         {
1:9df8274:             // insert leading and/or trailing "" to anchor ends
1:9df8274:             if (rightstar)
1:9df8274:             {
1:9df8274:                 pieces.add("");
1:9df8274:             }
1:9df8274:             if (leftstar)
1:9df8274:             {
1:9df8274:                 pieces.add(0, "");
1:9df8274:             }
1:9df8274:         }
1:9df8274:         return pieces;
1:9df8274:     }
1:9df8274: 
1:9df8274:     public static String unparseSubstring(List<String> pieces)
1:9df8274:     {
1:9df8274:         StringBuffer sb = new StringBuffer();
1:9df8274:         for (int i = 0; i < pieces.size(); i++)
1:9df8274:         {
1:9df8274:             if (i > 0)
1:9df8274:             {
1:9df8274:                 sb.append("*");
1:9df8274:             }
1:9df8274:             sb.append(toEncodedString(pieces.get(i)));
1:9df8274:         }
1:9df8274:         return sb.toString();
1:9df8274:     }
1:9df8274: 
1:9df8274:     public static boolean compareSubstring(List<String> pieces, String s)
1:9df8274:     {
1:9df8274:         // Walk the pieces to match the string
1:9df8274:         // There are implicit stars between each piece,
1:9df8274:         // and the first and last pieces might be "" to anchor the match.
1:9df8274:         // assert (pieces.length > 1)
1:9df8274:         // minimal case is <string>*<string>
1:9df8274: 
1:9df8274:         boolean result = true;
1:9df8274:         int len = pieces.size();
1:9df8274: 
1:9df8274:         // Special case, if there is only one piece, then
1:9df8274:         // we must perform an equality test.
1:9df8274:         if (len == 1)
1:9df8274:         {
1:9df8274:             return s.equals(pieces.get(0));
1:9df8274:         }
1:9df8274: 
1:9df8274:         // Otherwise, check whether the pieces match
1:9df8274:         // the specified string.
1:9df8274: 
1:9df8274:         int index = 0;
1:9df8274: 
1:9df8274: loop:   for (int i = 0; i < len; i++)
1:9df8274:         {
1:9df8274:             String piece = pieces.get(i);
1:9df8274: 
1:9df8274:             // If this is the first piece, then make sure the
1:9df8274:             // string starts with it.
1:9df8274:             if (i == 0)
1:9df8274:             {
1:9df8274:                 if (!s.startsWith(piece))
1:9df8274:                 {
1:9df8274:                     result = false;
1:9df8274:                     break loop;
1:9df8274:                 }
1:9df8274:             }
1:9df8274: 
1:9df8274:             // If this is the last piece, then make sure the
1:9df8274:             // string ends with it.
1:9df8274:             if (i == (len - 1))
1:9df8274:             {
1:9df8274:                 if (s.endsWith(piece) && (s.length() >= (index + piece.length())))
1:9df8274:                 {
1:9df8274:                     result = true;
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     result = false;
1:9df8274:                 }
1:9df8274:                 break loop;
1:9df8274:             }
1:9df8274: 
1:9df8274:             // If this is neither the first or last piece, then
1:9df8274:             // make sure the string contains it.
1:9df8274:             if ((i > 0) && (i < (len - 1)))
1:9df8274:             {
1:9df8274:                 index = s.indexOf(piece, index);
1:9df8274:                 if (index < 0)
1:9df8274:                 {
1:9df8274:                     result = false;
1:9df8274:                     break loop;
1:9df8274:                 }
1:9df8274:             }
1:9df8274: 
1:9df8274:             // Move string index beyond the matching piece.
1:9df8274:             index += piece.length();
1:9df8274:         }
1:9df8274: 
1:9df8274:         return result;
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static int skipWhitespace(String s, int startIdx)
1:9df8274:     {
1:9df8274:         int len = s.length();
1:9df8274:         while ((startIdx < len) && Character.isWhitespace(s.charAt(startIdx)))
1:9df8274:         {
1:9df8274:             startIdx++;
1:9df8274:         }
1:9df8274:         return startIdx;
1:9df8274:     }
1:9df8274: 
1:2ffcfb9:     /**
1:9df8274:      * Converts a attribute map to a filter. The filter is created by iterating
1:9df8274:      * over the map's entry set. If ordering of attributes is important (e.g.,
1:9df8274:      * for hitting attribute indices), then the map's entry set should iterate
1:9df8274:      * in the desired order. Equality testing is assumed for all attribute types
1:9df8274:      * other than version ranges, which are handled appropriated. If the attribute
1:9df8274:      * map is empty, then a filter that matches anything is returned.
1:9df8274:      * @param attrs Map of attributes to convert to a filter.
1:9df8274:      * @return A filter corresponding to the attributes.
1:2ffcfb9:      */
1:9df8274:     public static SimpleFilter convert(Map<String, Object> attrs)
1:9df8274:     {
1:9df8274:         // Rather than building a filter string to be parsed into a SimpleFilter,
1:9df8274:         // we will just create the parsed SimpleFilter directly.
1:9df8274: 
1:9df8274:         List<SimpleFilter> filters = new ArrayList<SimpleFilter>();
1:9df8274: 
1:9df8274:         for (Entry<String, Object> entry : attrs.entrySet())
1:9df8274:         {
1:9df8274:             if (entry.getValue() instanceof VersionRange)
1:9df8274:             {
1:9df8274:                 VersionRange vr = (VersionRange) entry.getValue();
1:9df8274:                 if (vr.getLeftType() == VersionRange.RIGHT_OPEN)
1:9df8274:                 {
1:9df8274:                     filters.add(
1:9df8274:                         new SimpleFilter(
1:9df8274:                             entry.getKey(),
1:9df8274:                             vr.getLeft().toString(),
1:9df8274:                             SimpleFilter.GTE));
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     SimpleFilter not =
1:9df8274:                         new SimpleFilter(null, new ArrayList(), SimpleFilter.NOT);
1:9df8274:                     ((List) not.getValue()).add(
1:9df8274:                         new SimpleFilter(
1:9df8274:                             entry.getKey(),
1:9df8274:                             vr.getLeft().toString(),
1:9df8274:                             SimpleFilter.LTE));
1:9df8274:                     filters.add(not);
1:9df8274:                 }
1:9df8274: 
1:9df8274:                 if (vr.getRight() != null)
1:9df8274:                 {
1:9df8274:                     if (vr.getRightType() == VersionRange.RIGHT_OPEN)
1:9df8274:                     {
1:9df8274:                         filters.add(
1:9df8274:                             new SimpleFilter(
1:9df8274:                                 entry.getKey(),
1:9df8274:                                 vr.getRight().toString(),
1:9df8274:                                 SimpleFilter.LTE));
1:9df8274:                     }
1:9df8274:                     else
1:9df8274:                     {
1:9df8274:                         SimpleFilter not =
1:9df8274:                             new SimpleFilter(null, new ArrayList(), SimpleFilter.NOT);
1:9df8274:                         ((List) not.getValue()).add(
1:9df8274:                             new SimpleFilter(
1:9df8274:                                 entry.getKey(),
1:9df8274:                                 vr.getRight().toString(),
1:9df8274:                                 SimpleFilter.GTE));
1:9df8274:                         filters.add(not);
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 List<String> values = SimpleFilter.parseSubstring(entry.getValue().toString());
1:9df8274:                 if (values.size() > 1)
1:9df8274:                 {
1:9df8274:                     filters.add(
1:9df8274:                         new SimpleFilter(
1:9df8274:                             entry.getKey(),
1:9df8274:                             values,
1:9df8274:                             SimpleFilter.SUBSTRING));
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     filters.add(
1:9df8274:                         new SimpleFilter(
1:9df8274:                             entry.getKey(),
1:9df8274:                             values.get(0),
1:9df8274:                             SimpleFilter.EQ));
1:9df8274:                 }
1:9df8274:             }
1:9df8274:         }
1:9df8274: 
1:9df8274:         SimpleFilter sf = null;
1:9df8274: 
1:9df8274:         if (filters.size() == 1)
1:9df8274:         {
1:9df8274:             sf = filters.get(0);
1:9df8274:         }
1:9df8274:         else if (attrs.size() > 1)
1:9df8274:         {
1:9df8274:             sf = new SimpleFilter(null, filters, SimpleFilter.AND);
1:9df8274:         }
1:9df8274:         else if (filters.isEmpty())
1:9df8274:         {
1:9df8274:             sf = new SimpleFilter(null, null, SimpleFilter.MATCH_ALL);
1:9df8274:         }
1:9df8274: 
1:9df8274:         return sf;
1:9df8274:     }
1:9df8274:     
1:2ffcfb9:     @Override
1:2ffcfb9:     public int hashCode() {
1:2ffcfb9:         int result = 17;
1:2ffcfb9:         result = 31 * result + (m_name == null ? 0 : m_name.hashCode());
1:2ffcfb9:         result = 31 * result + m_op;
1:2ffcfb9:         if (m_value == null) {
1:2ffcfb9:         	result = 31 * result + 0;
1:2ffcfb9:         }
1:2ffcfb9:         else if (m_name == null && m_value instanceof Collection) {
1:2ffcfb9:         	Iterator iterator = ((Collection)m_value).iterator();
1:2ffcfb9:         	int sum = 0;
1:2ffcfb9:         	while (iterator.hasNext()) {
1:2ffcfb9:         		sum += iterator.next().hashCode();
1:2ffcfb9:         	}
1:2ffcfb9:         	result = 31 * result + sum;
1:2ffcfb9:         }
1:2ffcfb9:         else {
1:2ffcfb9:         	result = 31 * result + m_value.hashCode();
1:2ffcfb9:         }
1:2ffcfb9:         return result;
1:2ffcfb9:     }
1:2ffcfb9:     
1:2ffcfb9:     @Override
1:2ffcfb9:     public boolean equals(Object o) {
1:2ffcfb9:     	if (o == this) {
1:2ffcfb9:     		return true;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (!(o instanceof SimpleFilter)) {
1:2ffcfb9:     		return false;
1:2ffcfb9:     	}
1:2ffcfb9:     	SimpleFilter that = (SimpleFilter)o;
1:2ffcfb9:     	if (!(that.m_name == null ? this.m_name == null : that.m_name.equals(this.m_name))) {
1:2ffcfb9:     		return false;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (that.m_op != this.m_op) {
1:2ffcfb9:     		return false;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (that.m_value == null) {
1:2ffcfb9:     		return this.m_value == null;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (this.m_value == null) {
1:2ffcfb9:     		return false;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (that.m_name == null && that.m_value instanceof Collection) {
1:2ffcfb9:     		if (!(this.m_name == null && this.m_value instanceof Collection)) {
1:2ffcfb9:     			return false;
1:2ffcfb9:     		}
1:2ffcfb9:     		return ((Collection)that.m_value).containsAll((Collection)this.m_value);
1:2ffcfb9:     	}
1:2ffcfb9:     	return that.m_value.equals(this.m_value);
1:2ffcfb9:     }
1:2ffcfb9:     
1:c5864b3:     public static Map<String, List<SimpleFilter>> attributes(String filter) {
1:c5864b3:     	Map<String, List<SimpleFilter>> attributes = new HashMap<String, List<SimpleFilter>>();
1:2ffcfb9:     	attributes(parse(filter), attributes);
1:2ffcfb9:     	return attributes;
1:2ffcfb9:     }
1:2ffcfb9:     
1:c5864b3:     private static void attributes(SimpleFilter filter, Map<String, List<SimpleFilter>> attributes) {
1:c5864b3:     	if (filter.m_op == NOT && ((List<SimpleFilter>)filter.m_value).size() == 1) {
1:c5864b3:     		SimpleFilter sf = ((List<SimpleFilter>)filter.m_value).get(0);
1:c5864b3:     		List<SimpleFilter> sfs = attributes.get(sf.m_name);
1:c5864b3:     		if (sfs == null) {
1:c5864b3:     			sfs = new ArrayList<SimpleFilter>();
1:c5864b3:     			attributes.put(sf.m_name, sfs);
1:c5864b3:     		}
1:c5864b3:     		sfs.add(filter);
1:c5864b3:     	}
1:c5864b3:     	else if (filter.m_value instanceof Collection) {
1:c5864b3:     		Collection<SimpleFilter> filters = (Collection<SimpleFilter>)filter.m_value;
1:2ffcfb9:     		for (SimpleFilter f : filters) {
1:2ffcfb9:         		attributes(f, attributes);
1:2ffcfb9:         	}
1:2ffcfb9:     	}
1:2ffcfb9:     	else {
1:c5864b3:     		List<SimpleFilter> sfs = attributes.get(filter.m_name);
1:c5864b3:     		if (sfs == null) {
1:c5864b3:     			sfs = new ArrayList<SimpleFilter>();
1:c5864b3:     			attributes.put(filter.m_name, sfs);
1:c5864b3:     		}
1:c5864b3:     		sfs.add(filter);
1:2ffcfb9:     	}
1:2ffcfb9:     }
1:9df8274: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:c5864b3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.AttributeFactory;
1: import org.apache.aries.subsystem.core.archive.Parameter;
1: import org.apache.aries.subsystem.core.archive.VersionRangeAttribute;
/////////////////////////////////////////////////////////////////////////
1:     public static Map<String, List<SimpleFilter>> attributes(String filter) {
1:     	Map<String, List<SimpleFilter>> attributes = new HashMap<String, List<SimpleFilter>>();
1:     private static void attributes(SimpleFilter filter, Map<String, List<SimpleFilter>> attributes) {
1:     	if (filter.m_op == NOT && ((List<SimpleFilter>)filter.m_value).size() == 1) {
1:     		SimpleFilter sf = ((List<SimpleFilter>)filter.m_value).get(0);
1:     		List<SimpleFilter> sfs = attributes.get(sf.m_name);
1:     		if (sfs == null) {
1:     			sfs = new ArrayList<SimpleFilter>();
1:     			attributes.put(sf.m_name, sfs);
1:     		}
1:     		sfs.add(filter);
1:     	}
1:     	else if (filter.m_value instanceof Collection) {
1:     		Collection<SimpleFilter> filters = (Collection<SimpleFilter>)filter.m_value;
1:     		List<SimpleFilter> sfs = attributes.get(filter.m_name);
1:     		if (sfs == null) {
1:     			sfs = new ArrayList<SimpleFilter>();
1:     			attributes.put(filter.m_name, sfs);
1:     		}
1:     		sfs.add(filter);
commit:2ffcfb9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Override
1:     public int hashCode() {
1:         int result = 17;
1:         result = 31 * result + (m_name == null ? 0 : m_name.hashCode());
1:         result = 31 * result + m_op;
1:         if (m_value == null) {
1:         	result = 31 * result + 0;
1:         }
1:         else if (m_name == null && m_value instanceof Collection) {
1:         	Iterator iterator = ((Collection)m_value).iterator();
1:         	int sum = 0;
1:         	while (iterator.hasNext()) {
1:         		sum += iterator.next().hashCode();
1:         	}
1:         	result = 31 * result + sum;
1:         }
1:         else {
1:         	result = 31 * result + m_value.hashCode();
1:         }
1:         return result;
1:     }
1:     
1:     @Override
1:     public boolean equals(Object o) {
1:     	if (o == this) {
1:     		return true;
1:     	}
1:     	if (!(o instanceof SimpleFilter)) {
1:     		return false;
1:     	}
1:     	SimpleFilter that = (SimpleFilter)o;
1:     	if (!(that.m_name == null ? this.m_name == null : that.m_name.equals(this.m_name))) {
1:     		return false;
1:     	}
1:     	if (that.m_op != this.m_op) {
1:     		return false;
1:     	}
1:     	if (that.m_value == null) {
1:     		return this.m_value == null;
1:     	}
1:     	if (this.m_value == null) {
1:     		return false;
1:     	}
1:     	if (that.m_name == null && that.m_value instanceof Collection) {
1:     		if (!(this.m_name == null && this.m_value instanceof Collection)) {
1:     			return false;
1:     		}
1:     		return ((Collection)that.m_value).containsAll((Collection)this.m_value);
1:     	}
1:     	return that.m_value.equals(this.m_value);
1:     }
1:     
1:     /**
0:      * Extracts attributes from the provided filter. If an attribute appears 
0:      * more than once, the last value seen will be the value in the map. The 
0:      * returned map is the property of the caller.
1:      * 
0:      * @param filter The filter containing attributes to extract.
0:      * @return The map of extracted attributes. The key is the attribute name, 
0:      *         and the value is the attribute value.
0:      * @throws NullPointerException If the filter is <code>null</code>.
0:      * @throws IllegalArgumentException If the filter contains invalid syntax.
1:      */
0:     public static Map<String, Object> attributes(String filter) {
0:     	Map<String, Object> attributes = new HashMap<String, Object>();
1:     	attributes(parse(filter), attributes);
1:     	return attributes;
1:     }
1:     
0:     private static void attributes(SimpleFilter filter, Map<String, Object> attributes) {
0:     	Object value = filter.m_value;
0:     	if (value instanceof Collection) {
0:     		Collection<SimpleFilter> filters = (Collection<SimpleFilter>)value;
1:     		for (SimpleFilter f : filters) {
1:         		attributes(f, attributes);
1:         	}
1:     	}
1:     	else {
0:     		attributes.put(filter.m_name, value);
1:     	}
1:     }
commit:9df8274
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.subsystem.core.capabilityset;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: 
1: import org.osgi.framework.VersionRange;
1: 
1: public class SimpleFilter
1: {
1:     public static final int MATCH_ALL = 0;
1:     public static final int AND = 1;
1:     public static final int OR = 2;
1:     public static final int NOT = 3;
1:     public static final int EQ = 4;
1:     public static final int LTE = 5;
1:     public static final int GTE = 6;
1:     public static final int SUBSTRING = 7;
1:     public static final int PRESENT = 8;
1:     public static final int APPROX = 9;
1: 
1:     private final String m_name;
1:     private final Object m_value;
1:     private final int m_op;
1: 
1:     public SimpleFilter(String attr, Object value, int op)
1:     {
1:         m_name = attr;
1:         m_value = value;
1:         m_op = op;
1:     }
1: 
1:     public String getName()
1:     {
1:         return m_name;
1:     }
1: 
1:     public Object getValue()
1:     {
1:         return m_value;
1:     }
1: 
1:     public int getOperation()
1:     {
1:         return m_op;
1:     }
1: 
1:     public String toString()
1:     {
1:         String s = null;
1:         switch (m_op)
1:         {
1:             case AND:
1:                 s = "(&" + toString((List) m_value) + ")";
1:                 break;
1:             case OR:
1:                 s = "(|" + toString((List) m_value) + ")";
1:                 break;
1:             case NOT:
1:                 s = "(!" + toString((List) m_value) + ")";
1:                 break;
1:             case EQ:
1:                 s = "(" + m_name + "=" + toEncodedString(m_value) + ")";
1:                 break;
1:             case LTE:
1:                 s = "(" + m_name + "<=" + toEncodedString(m_value) + ")";
1:                 break;
1:             case GTE:
1:                 s = "(" + m_name + ">=" + toEncodedString(m_value) + ")";
1:                 break;
1:             case SUBSTRING:
1:                 s = "(" + m_name + "=" + unparseSubstring((List<String>) m_value) + ")";
1:                 break;
1:             case PRESENT:
1:                 s = "(" + m_name + "=*)";
1:                 break;
1:             case APPROX:
1:                 s = "(" + m_name + "~=" + toEncodedString(m_value) + ")";
1:                 break;
1:             case MATCH_ALL:
1:                 s = "(*)";
1:                 break;
1:         }
1:         return s;
1:     }
1: 
1:     private static String toString(List list)
1:     {
1:         StringBuffer sb = new StringBuffer();
1:         for (int i = 0; i < list.size(); i++)
1:         {
1:             sb.append(list.get(i).toString());
1:         }
1:         return sb.toString();
1:     }
1: 
1:     private static String toDecodedString(String s, int startIdx, int endIdx)
1:     {
1:         StringBuffer sb = new StringBuffer(endIdx - startIdx);
1:         boolean escaped = false;
1:         for (int i = 0; i < (endIdx - startIdx); i++)
1:         {
1:             char c = s.charAt(startIdx + i);
1:             if (!escaped && (c == '\\'))
1:             {
1:                 escaped = true;
1:             }
1:             else
1:             {
1:                 escaped = false;
1:                 sb.append(c);
1:             }
1:         }
1: 
1:         return sb.toString();
1:     }
1: 
1:     private static String toEncodedString(Object o)
1:     {
1:         if (o instanceof String)
1:         {
1:             String s = (String) o;
1:             StringBuffer sb = new StringBuffer();
1:             for (int i = 0; i < s.length(); i++)
1:             {
1:                 char c = s.charAt(i);
1:                 if ((c == '\\') || (c == '(') || (c == ')') || (c == '*'))
1:                 {
1:                     sb.append('\\');
1:                 }
1:                 sb.append(c);
1:             }
1: 
1:             o = sb.toString();
1:         }
1: 
1:         return o.toString();
1:     }
1: 
1:     public static SimpleFilter parse(String filter)
1:     {
1:         int idx = skipWhitespace(filter, 0);
1: 
1:         if ((filter == null) || (filter.length() == 0) || (idx >= filter.length()))
1:         {
1:             throw new IllegalArgumentException("Null or empty filter.");
1:         }
1:         else if (filter.charAt(idx) != '(')
1:         {
1:             throw new IllegalArgumentException("Missing opening parenthesis: " + filter);
1:         }
1: 
1:         SimpleFilter sf = null;
1:         List stack = new ArrayList();
1:         boolean isEscaped = false;
1:         while (idx < filter.length())
1:         {
1:             if (sf != null)
1:             {
1:                 throw new IllegalArgumentException(
1:                     "Only one top-level operation allowed: " + filter);
1:             }
1: 
1:             if (!isEscaped && (filter.charAt(idx) == '('))
1:             {
1:                 // Skip paren and following whitespace.
1:                 idx = skipWhitespace(filter, idx + 1);
1: 
1:                 if (filter.charAt(idx) == '&')
1:                 {
1:                     int peek = skipWhitespace(filter, idx + 1);
1:                     if (filter.charAt(peek) == '(')
1:                     {
1:                         idx = peek - 1;
1:                         stack.add(0, new SimpleFilter(null, new ArrayList(), SimpleFilter.AND));
1:                     }
1:                     else
1:                     {
1:                         stack.add(0, new Integer(idx));
1:                     }
1:                 }
1:                 else if (filter.charAt(idx) == '|')
1:                 {
1:                     int peek = skipWhitespace(filter, idx + 1);
1:                     if (filter.charAt(peek) == '(')
1:                     {
1:                         idx = peek - 1;
1:                         stack.add(0, new SimpleFilter(null, new ArrayList(), SimpleFilter.OR));
1:                     }
1:                     else
1:                     {
1:                         stack.add(0, new Integer(idx));
1:                     }
1:                 }
1:                 else if (filter.charAt(idx) == '!')
1:                 {
1:                     int peek = skipWhitespace(filter, idx + 1);
1:                     if (filter.charAt(peek) == '(')
1:                     {
1:                         idx = peek - 1;
1:                         stack.add(0, new SimpleFilter(null, new ArrayList(), SimpleFilter.NOT));
1:                     }
1:                     else
1:                     {
1:                         stack.add(0, new Integer(idx));
1:                     }
1:                 }
1:                 else
1:                 {
1:                     stack.add(0, new Integer(idx));
1:                 }
1:             }
1:             else if (!isEscaped && (filter.charAt(idx) == ')'))
1:             {
1:                 Object top = stack.remove(0);
1:                 if (top instanceof SimpleFilter)
1:                 {
1:                     if (!stack.isEmpty() && (stack.get(0) instanceof SimpleFilter))
1:                     {
1:                         ((List) ((SimpleFilter) stack.get(0)).m_value).add(top);
1:                     }
1:                     else
1:                     {
1:                         sf = (SimpleFilter) top;
1:                     }
1:                 }
1:                 else if (!stack.isEmpty() && (stack.get(0) instanceof SimpleFilter))
1:                 {
1:                     ((List) ((SimpleFilter) stack.get(0)).m_value).add(
1:                         SimpleFilter.subfilter(filter, ((Integer) top).intValue(), idx));
1:                 }
1:                 else
1:                 {
1:                     sf = SimpleFilter.subfilter(filter, ((Integer) top).intValue(), idx);
1:                 }
1:             }
1:             else if (!isEscaped && (filter.charAt(idx) == '\\'))
1:             {
1:                 isEscaped = true;
1:             }
1:             else
1:             {
1:                 isEscaped = false;
1:             }
1: 
1:             idx = skipWhitespace(filter, idx + 1);
1:         }
1: 
1:         if (sf == null)
1:         {
1:             throw new IllegalArgumentException("Missing closing parenthesis: " + filter);
1:         }
1: 
1:         return sf;
1:     }
1: 
1:     private static SimpleFilter subfilter(String filter, int startIdx, int endIdx)
1:     {
1:         final String opChars = "=<>~";
1: 
1:         // Determine the ending index of the attribute name.
1:         int attrEndIdx = startIdx;
1:         for (int i = 0; i < (endIdx - startIdx); i++)
1:         {
1:             char c = filter.charAt(startIdx + i);
1:             if (opChars.indexOf(c) >= 0)
1:             {
1:                 break;
1:             }
1:             else if (!Character.isWhitespace(c))
1:             {
1:                 attrEndIdx = startIdx + i + 1;
1:             }
1:         }
1:         if (attrEndIdx == startIdx)
1:         {
1:             throw new IllegalArgumentException(
1:                 "Missing attribute name: " + filter.substring(startIdx, endIdx));
1:         }
1:         String attr = filter.substring(startIdx, attrEndIdx);
1: 
1:         // Skip the attribute name and any following whitespace.
1:         startIdx = skipWhitespace(filter, attrEndIdx);
1: 
1:         // Determine the operator type.
1:         int op = -1;
1:         switch (filter.charAt(startIdx))
1:         {
1:             case '=':
1:                 op = EQ;
1:                 startIdx++;
1:                 break;
1:             case '<':
1:                 if (filter.charAt(startIdx + 1) != '=')
1:                 {
1:                     throw new IllegalArgumentException(
1:                         "Unknown operator: " + filter.substring(startIdx, endIdx));
1:                 }
1:                 op = LTE;
1:                 startIdx += 2;
1:                 break;
1:             case '>':
1:                 if (filter.charAt(startIdx + 1) != '=')
1:                 {
1:                     throw new IllegalArgumentException(
1:                         "Unknown operator: " + filter.substring(startIdx, endIdx));
1:                 }
1:                 op = GTE;
1:                 startIdx += 2;
1:                 break;
1:             case '~':
1:                 if (filter.charAt(startIdx + 1) != '=')
1:                 {
1:                     throw new IllegalArgumentException(
1:                         "Unknown operator: " + filter.substring(startIdx, endIdx));
1:                 }
1:                 op = APPROX;
1:                 startIdx += 2;
1:                 break;
1:             default:
1:                 throw new IllegalArgumentException(
1:                     "Unknown operator: " + filter.substring(startIdx, endIdx));
1:         }
1: 
1:         // Parse value.
1:         Object value = toDecodedString(filter, startIdx, endIdx);
1: 
1:         // Check if the equality comparison is actually a substring
1:         // or present operation.
1:         if (op == EQ)
1:         {
1:             String valueStr = filter.substring(startIdx, endIdx);
1:             List<String> values = parseSubstring(valueStr);
1:             if ((values.size() == 2)
1:                 && (values.get(0).length() == 0)
1:                 && (values.get(1).length() == 0))
1:             {
1:                 op = PRESENT;
1:             }
1:             else if (values.size() > 1)
1:             {
1:                 op = SUBSTRING;
1:                 value = values;
1:             }
1:         }
1: 
1:         return new SimpleFilter(attr, value, op);
1:     }
1: 
1:     public static List<String> parseSubstring(String value)
1:     {
1:         List<String> pieces = new ArrayList();
1:         StringBuffer ss = new StringBuffer();
1:         // int kind = SIMPLE; // assume until proven otherwise
1:         boolean wasStar = false; // indicates last piece was a star
1:         boolean leftstar = false; // track if the initial piece is a star
1:         boolean rightstar = false; // track if the final piece is a star
1: 
1:         int idx = 0;
1: 
1:         // We assume (sub)strings can contain leading and trailing blanks
1:         boolean escaped = false;
1: loop:   for (;;)
1:         {
1:             if (idx >= value.length())
1:             {
1:                 if (wasStar)
1:                 {
1:                     // insert last piece as "" to handle trailing star
1:                     rightstar = true;
1:                 }
1:                 else
1:                 {
1:                     pieces.add(ss.toString());
1:                     // accumulate the last piece
1:                     // note that in the case of
1:                     // (cn=); this might be
1:                     // the string "" (!=null)
1:                 }
1:                 ss.setLength(0);
1:                 break loop;
1:             }
1: 
1:             // Read the next character and account for escapes.
1:             char c = value.charAt(idx++);
1:             if (!escaped && (c == '*'))
1:             {
1:                 // If we have successive '*' characters, then we can
1:                 // effectively collapse them by ignoring succeeding ones.
1:                 if (!wasStar)
1:                 {
1:                     if (ss.length() > 0)
1:                     {
1:                         pieces.add(ss.toString()); // accumulate the pieces
1:                         // between '*' occurrences
1:                     }
1:                     ss.setLength(0);
1:                     // if this is a leading star, then track it
1:                     if (pieces.isEmpty())
1:                     {
1:                         leftstar = true;
1:                     }
1:                     wasStar = true;
1:                 }
1:             }
1:             else if (!escaped && (c == '\\'))
1:             {
1:                 escaped = true;
1:             }
1:             else
1:             {
1:                 escaped = false;
1:                 wasStar = false;
1:                 ss.append(c);
1:             }
1:         }
1:         if (leftstar || rightstar || pieces.size() > 1)
1:         {
1:             // insert leading and/or trailing "" to anchor ends
1:             if (rightstar)
1:             {
1:                 pieces.add("");
1:             }
1:             if (leftstar)
1:             {
1:                 pieces.add(0, "");
1:             }
1:         }
1:         return pieces;
1:     }
1: 
1:     public static String unparseSubstring(List<String> pieces)
1:     {
1:         StringBuffer sb = new StringBuffer();
1:         for (int i = 0; i < pieces.size(); i++)
1:         {
1:             if (i > 0)
1:             {
1:                 sb.append("*");
1:             }
1:             sb.append(toEncodedString(pieces.get(i)));
1:         }
1:         return sb.toString();
1:     }
1: 
1:     public static boolean compareSubstring(List<String> pieces, String s)
1:     {
1:         // Walk the pieces to match the string
1:         // There are implicit stars between each piece,
1:         // and the first and last pieces might be "" to anchor the match.
1:         // assert (pieces.length > 1)
1:         // minimal case is <string>*<string>
1: 
1:         boolean result = true;
1:         int len = pieces.size();
1: 
1:         // Special case, if there is only one piece, then
1:         // we must perform an equality test.
1:         if (len == 1)
1:         {
1:             return s.equals(pieces.get(0));
1:         }
1: 
1:         // Otherwise, check whether the pieces match
1:         // the specified string.
1: 
1:         int index = 0;
1: 
1: loop:   for (int i = 0; i < len; i++)
1:         {
1:             String piece = pieces.get(i);
1: 
1:             // If this is the first piece, then make sure the
1:             // string starts with it.
1:             if (i == 0)
1:             {
1:                 if (!s.startsWith(piece))
1:                 {
1:                     result = false;
1:                     break loop;
1:                 }
1:             }
1: 
1:             // If this is the last piece, then make sure the
1:             // string ends with it.
1:             if (i == (len - 1))
1:             {
1:                 if (s.endsWith(piece) && (s.length() >= (index + piece.length())))
1:                 {
1:                     result = true;
1:                 }
1:                 else
1:                 {
1:                     result = false;
1:                 }
1:                 break loop;
1:             }
1: 
1:             // If this is neither the first or last piece, then
1:             // make sure the string contains it.
1:             if ((i > 0) && (i < (len - 1)))
1:             {
1:                 index = s.indexOf(piece, index);
1:                 if (index < 0)
1:                 {
1:                     result = false;
1:                     break loop;
1:                 }
1:             }
1: 
1:             // Move string index beyond the matching piece.
1:             index += piece.length();
1:         }
1: 
1:         return result;
1:     }
1: 
1:     private static int skipWhitespace(String s, int startIdx)
1:     {
1:         int len = s.length();
1:         while ((startIdx < len) && Character.isWhitespace(s.charAt(startIdx)))
1:         {
1:             startIdx++;
1:         }
1:         return startIdx;
1:     }
1: 
0:     /**
1:      * Converts a attribute map to a filter. The filter is created by iterating
1:      * over the map's entry set. If ordering of attributes is important (e.g.,
1:      * for hitting attribute indices), then the map's entry set should iterate
1:      * in the desired order. Equality testing is assumed for all attribute types
1:      * other than version ranges, which are handled appropriated. If the attribute
1:      * map is empty, then a filter that matches anything is returned.
1:      * @param attrs Map of attributes to convert to a filter.
1:      * @return A filter corresponding to the attributes.
1:      */
1:     public static SimpleFilter convert(Map<String, Object> attrs)
1:     {
1:         // Rather than building a filter string to be parsed into a SimpleFilter,
1:         // we will just create the parsed SimpleFilter directly.
1: 
1:         List<SimpleFilter> filters = new ArrayList<SimpleFilter>();
1: 
1:         for (Entry<String, Object> entry : attrs.entrySet())
1:         {
1:             if (entry.getValue() instanceof VersionRange)
1:             {
1:                 VersionRange vr = (VersionRange) entry.getValue();
1:                 if (vr.getLeftType() == VersionRange.RIGHT_OPEN)
1:                 {
1:                     filters.add(
1:                         new SimpleFilter(
1:                             entry.getKey(),
1:                             vr.getLeft().toString(),
1:                             SimpleFilter.GTE));
1:                 }
1:                 else
1:                 {
1:                     SimpleFilter not =
1:                         new SimpleFilter(null, new ArrayList(), SimpleFilter.NOT);
1:                     ((List) not.getValue()).add(
1:                         new SimpleFilter(
1:                             entry.getKey(),
1:                             vr.getLeft().toString(),
1:                             SimpleFilter.LTE));
1:                     filters.add(not);
1:                 }
1: 
1:                 if (vr.getRight() != null)
1:                 {
1:                     if (vr.getRightType() == VersionRange.RIGHT_OPEN)
1:                     {
1:                         filters.add(
1:                             new SimpleFilter(
1:                                 entry.getKey(),
1:                                 vr.getRight().toString(),
1:                                 SimpleFilter.LTE));
1:                     }
1:                     else
1:                     {
1:                         SimpleFilter not =
1:                             new SimpleFilter(null, new ArrayList(), SimpleFilter.NOT);
1:                         ((List) not.getValue()).add(
1:                             new SimpleFilter(
1:                                 entry.getKey(),
1:                                 vr.getRight().toString(),
1:                                 SimpleFilter.GTE));
1:                         filters.add(not);
1:                     }
1:                 }
1:             }
1:             else
1:             {
1:                 List<String> values = SimpleFilter.parseSubstring(entry.getValue().toString());
1:                 if (values.size() > 1)
1:                 {
1:                     filters.add(
1:                         new SimpleFilter(
1:                             entry.getKey(),
1:                             values,
1:                             SimpleFilter.SUBSTRING));
1:                 }
1:                 else
1:                 {
1:                     filters.add(
1:                         new SimpleFilter(
1:                             entry.getKey(),
1:                             values.get(0),
1:                             SimpleFilter.EQ));
1:                 }
1:             }
1:         }
1: 
1:         SimpleFilter sf = null;
1: 
1:         if (filters.size() == 1)
1:         {
1:             sf = filters.get(0);
1:         }
1:         else if (attrs.size() > 1)
1:         {
1:             sf = new SimpleFilter(null, filters, SimpleFilter.AND);
1:         }
1:         else if (filters.isEmpty())
1:         {
1:             sf = new SimpleFilter(null, null, SimpleFilter.MATCH_ALL);
1:         }
1: 
1:         return sf;
1:     }
1: }
============================================================================