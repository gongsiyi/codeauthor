2:1129914: /*
1:8ad6b99:  * Licensed to the Apache Software Foundation (ASF) under one
1:8ad6b99:  * or more contributor license agreements.  See the NOTICE file
1:8ad6b99:  * distributed with this work for additional information
1:8ad6b99:  * regarding copyright ownership.  The ASF licenses this file
1:8ad6b99:  * to you under the Apache License, Version 2.0 (the
1:8ad6b99:  * "License"); you may not use this file except in compliance
1:8ad6b99:  * with the License.  You may obtain a copy of the License at
1:1129914:  *
1:8ad6b99:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1129914:  *
1:8ad6b99:  * Unless required by applicable law or agreed to in writing,
1:8ad6b99:  * software distributed under the License is distributed on an
1:8ad6b99:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:8ad6b99:  * KIND, either express or implied.  See the License for the
1:8ad6b99:  * specific language governing permissions and limitations
1:8ad6b99:  * under the License.
3:1129914:  */
1:67ef08f: package org.apache.aries.subsystem.core.internal;
1:bc9f4bc: 
1:47cea41: import java.io.ByteArrayInputStream;
1:47cea41: import java.io.ByteArrayOutputStream;
1:1129914: import java.io.IOException;
1:1129914: import java.io.InputStream;
1:47cea41: import java.net.MalformedURLException;
1:1129914: import java.util.ArrayList;
1:b75f264: import java.util.Collections;
1:1129914: import java.util.List;
1:47cea41: import java.util.jar.JarEntry;
1:47cea41: import java.util.jar.JarOutputStream;
1:f615d56: 
1:4717af0: import org.apache.aries.subsystem.core.archive.BundleManifest;
1:f46e7d5: import org.apache.aries.subsystem.core.archive.BundleRequiredExecutionEnvironmentHeader;
1:12260c5: import org.apache.aries.subsystem.core.archive.BundleSymbolicNameHeader;
1:12260c5: import org.apache.aries.subsystem.core.archive.BundleVersionHeader;
1:4717af0: import org.apache.aries.subsystem.core.archive.ExportPackageHeader;
1:8ad6b99: import org.apache.aries.subsystem.core.archive.FragmentHostCapability;
1:8ad6b99: import org.apache.aries.subsystem.core.archive.FragmentHostHeader;
1:8ad6b99: import org.apache.aries.subsystem.core.archive.FragmentHostRequirement;
1:1129914: import org.apache.aries.subsystem.core.archive.ImportPackageHeader;
1:12260c5: import org.apache.aries.subsystem.core.archive.ProvideBundleCapability;
1:12260c5: import org.apache.aries.subsystem.core.archive.ProvideCapabilityCapability;
1:12260c5: import org.apache.aries.subsystem.core.archive.ProvideCapabilityHeader;
1:574fba9: import org.apache.aries.subsystem.core.archive.RequireBundleHeader;
1:574fba9: import org.apache.aries.subsystem.core.archive.RequireBundleRequirement;
1:7e004f1: import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
1:7e004f1: import org.apache.aries.subsystem.core.archive.RequireCapabilityRequirement;
1:f46e7d5: import org.apache.aries.subsystem.core.archive.RequirementHeader;
1:f615d56: import org.apache.aries.util.filesystem.IDirectory;
1:47cea41: import org.apache.aries.util.filesystem.IFile;
1:f615d56: import org.apache.aries.util.io.IOUtils;
1:b75f264: import org.osgi.namespace.service.ServiceNamespace;
1:71fe81a: import org.osgi.resource.Capability;
1:71fe81a: import org.osgi.resource.Requirement;
1:71fe81a: import org.osgi.resource.Resource;
1:b75f264: import org.osgi.service.subsystem.SubsystemException;
1:1c9c28b: 
1:d6eb080: public class BundleResource implements Resource, org.apache.aries.subsystem.core.repository.RepositoryContent {
1:f615d56: 	private static BundleManifest computeManifest(IDirectory directory) {
1:f615d56: 		return new BundleManifest(org.apache.aries.util.manifest.BundleManifest
1:f615d56: 				.fromBundle(directory)
1:f615d56: 				.getRawManifest());
1:f615d56: 	}
1:f615d56: 	
1:1129914: 	private final List<Capability> capabilities = new ArrayList<Capability>();
1:47cea41: 	private final IFile content;
1:4717af0: 	private final BundleManifest manifest;
1:4717af0: 	private final List<Requirement> requirements = new ArrayList<Requirement>();
1:f615d56: 	
1:9bba779: 	public BundleResource(IFile content) {
1:1c9c28b: 		this.content = content;
1:47cea41: 		IDirectory dir = content.isDirectory() ? content.convert() : content.convertNested();
1:47cea41: 		manifest = computeManifest(dir);
1:e7af8b6: 		computeRequirementsAndCapabilities(dir);
1:f615d56: 	}
1:f615d56: 
1:1129914: 	public List<Capability> getCapabilities(String namespace) {
1:b75f264: 		if (namespace == null)
1:b75f264: 			return Collections.unmodifiableList(capabilities);
1:1129914: 		ArrayList<Capability> result = new ArrayList<Capability>(capabilities.size());
1:f615d56: 		for (Capability capability : capabilities)
1:b75f264: 			if (namespace.equals(capability.getNamespace()))
1:1129914: 				result.add(capability);
1:b75f264: 		result.trimToSize();
1:b75f264: 		return Collections.unmodifiableList(result);
1:f615d56: 	}
1:f615d56: 	
1:47cea41: 	public String getLocation() {
1:47cea41: 		return getFileName(content);
1:47cea41: 	}
1:47cea41: 	
1:bc9f4bc: 	@Override
1:aac6a2a: 	public InputStream getContent() {
2:f615d56: 		try {
1:47cea41: 			if (content.isFile())
1:47cea41: 				return content.open();
1:47cea41: 			try {
1:47cea41: 				// Give the IDirectory a shot at opening in case it supports it.
1:47cea41: 				return content.open();
1:47cea41: 			}
1:47cea41: 			catch (UnsupportedOperationException e) {
1:47cea41: 				// As a last ditch effort, try to jar up the contents.
1:47cea41: 				ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:47cea41: 				JarOutputStream out = new JarOutputStream(baos, manifest.getManifest());
1:47cea41: 				try {
1:47cea41: 					jar(out, "", content.convert());
1:47cea41: 				}
1:47cea41: 				finally {
1:47cea41: 					IOUtils.close(out);
1:47cea41: 				}
1:47cea41: 				return new ByteArrayInputStream(baos.toByteArray());
1:47cea41: 			}
2:f615d56: 		}
1:47cea41: 		catch (Exception e) {
1:b75f264: 			throw new SubsystemException(e);
1:f615d56: 		}
1:f615d56: 	}
1:f615d56: 
1:1129914: 	public List<Requirement> getRequirements(String namespace) {
1:b75f264: 		if (namespace == null)
1:b75f264: 			return Collections.unmodifiableList(requirements);
1:b75f264: 		ArrayList<Requirement> result = new ArrayList<Requirement>(requirements.size());
1:f615d56: 		for (Requirement requirement : requirements)
1:b75f264: 			if (namespace.equals(requirement.getNamespace()))
1:4717af0: 				result.add(requirement);
1:b75f264: 		result.trimToSize();
1:b75f264: 		return Collections.unmodifiableList(result);
1:f615d56: 	}
1:f615d56: 	
1:1c9c28b: 	@Override
1:bc9f4bc: 	public String toString() {
1:47cea41:         return content.toString();
1:f615d56:     }
1:f615d56: 	
1:e7af8b6: 	private void computeCapabilitiesOtherThanService() {
1:b75f264: 		computeOsgiIdentityCapability();
1:b75f264: 		computeOsgiWiringPackageCapabilities();
1:b75f264: 		computeOsgiWiringBundleCapability();
1:b75f264: 		computeGenericCapabilities();
1:b75f264: 	}
1:f615d56: 	
1:b75f264: 	private void computeGenericCapabilities() {
1:f615d56: 		ProvideCapabilityHeader pch = (ProvideCapabilityHeader)manifest.getHeader(ProvideCapabilityHeader.NAME);
1:f615d56: 		if (pch != null)
1:f615d56: 			for (ProvideCapabilityHeader.Clause clause : pch.getClauses())
1:f615d56: 				capabilities.add(new ProvideCapabilityCapability(clause, this));
1:b75f264: 	}
1:b75f264: 	
1:b75f264: 	private void computeGenericRequirements() {
1:f615d56: 		RequireCapabilityHeader rch = (RequireCapabilityHeader)manifest.getHeader(RequireCapabilityHeader.NAME);
1:f615d56: 		if (rch != null)
1:f615d56: 			for (RequireCapabilityHeader.Clause clause : rch.getClauses())
1:f615d56: 				requirements.add(new RequireCapabilityRequirement(clause, this));
1:b75f264: 	}
1:b75f264: 	
1:f46e7d5: 	private void computeOsgiExecutionEnvironmentRequirement() {
1:f46e7d5: 		RequirementHeader<?> header = (RequirementHeader<?>)manifest.getHeader(BundleRequiredExecutionEnvironmentHeader.NAME);
1:f46e7d5: 		if (header == null)
1:f46e7d5: 			return;
1:f46e7d5: 		requirements.addAll(header.toRequirements(this));
1:f46e7d5: 	}
1:f46e7d5: 	
1:b75f264: 	private void computeOsgiIdentityCapability() {
1:b75f264: 		capabilities.add(new OsgiIdentityCapability(this, manifest));
1:b75f264: 	}
1:b75f264: 	
1:b75f264: 	private void computeOsgiWiringBundleCapability() {
1:8ad6b99: 		if (manifest.getHeader(org.osgi.framework.Constants.FRAGMENT_HOST) != null) {
1:8ad6b99: 	        // The osgi.wiring.bundle capability is not provided by fragments.
1:8ad6b99: 	        return;
1:8ad6b99: 	    }
1:b75f264: 		BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
1:b75f264: 		BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
1:b75f264: 		capabilities.add(new ProvideBundleCapability(bsnh, bvh, this));
1:b75f264: 	}
1:b75f264: 	
1:b75f264: 	private void computeOsgiWiringBundleRequirements() {
1:b75f264: 		RequireBundleHeader rbh = (RequireBundleHeader)manifest.getHeader(RequireBundleHeader.NAME);
1:b75f264: 		if (rbh != null)
1:b75f264: 			for (RequireBundleHeader.Clause clause : rbh.getClauses())
1:b75f264: 				requirements.add(new RequireBundleRequirement(clause, this));
1:b75f264: 	}
1:b75f264: 	
1:8ad6b99: 	private void computeOsgiWiringHostCapability() {
1:8ad6b99: 	    if (manifest.getHeader(org.osgi.framework.Constants.FRAGMENT_HOST) != null) {
1:8ad6b99:             // The osgi.wiring.host capability is not provided by fragments.
1:8ad6b99:             return;
1:8ad6b99:         }
1:8ad6b99:         BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
1:8ad6b99:         BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
1:8ad6b99:         capabilities.add(new FragmentHostCapability(bsnh, bvh, this));
1:8ad6b99:     }
1:8ad6b99: 	
1:8ad6b99: 	private void computeOsgiWiringHostRequirement() {
1:8ad6b99:         FragmentHostHeader fhh = (FragmentHostHeader)manifest.getHeader(FragmentHostHeader.NAME);
1:8ad6b99:         if (fhh != null) {
1:8ad6b99:             requirements.add(new FragmentHostRequirement(fhh.getClauses().iterator().next(), this));
1:8ad6b99:         }
1:8ad6b99:     }
1:8ad6b99: 	
1:b75f264: 	private void computeOsgiWiringPackageCapabilities() {
1:b75f264: 		ExportPackageHeader eph = (ExportPackageHeader)manifest.getHeader(ExportPackageHeader.NAME);
1:b75f264: 		if (eph != null)
1:b75f264: 			capabilities.addAll(eph.toCapabilities(this));
1:b75f264: 	}
1:b75f264: 	
1:b75f264: 	private void computeOsgiWiringPackageRequirements() {
1:b75f264: 		ImportPackageHeader iph = (ImportPackageHeader)manifest.getHeader(ImportPackageHeader.NAME);
1:b75f264: 		if (iph != null)
1:b75f264: 			requirements.addAll(iph.toRequirements(this));
1:b75f264: 	}
1:e7af8b6: 	
1:9bba779: 	private void computeRequirementsAndCapabilities(IDirectory directory) {
1:28b6fc1: 		// Compute all requirements and capabilities other than those related
1:28b6fc1: 		// to services.
1:e7af8b6: 		computeRequirementsOtherThanService();
1:e7af8b6: 		computeCapabilitiesOtherThanService();
1:d6eb080: 		// OSGi RFC 201 for R6: The presence of any Require/Provide-Capability
1:d6eb080: 		// clauses in the osgi.service namespace overrides any service related
1:d6eb080: 		// requirements or capabilities that might have been found by other
1:d6eb080: 		// means.
1:d6eb080: 		boolean computeServiceRequirements = getRequirements(ServiceNamespace.SERVICE_NAMESPACE).isEmpty();
1:d6eb080: 		boolean computeServiceCapabilities = getCapabilities(ServiceNamespace.SERVICE_NAMESPACE).isEmpty();
1:d6eb080: 		if (!(computeServiceCapabilities || computeServiceRequirements))
1:e7af8b6: 			return;
1:28b6fc1: 		// Compute service requirements and capabilities if the optional
1:28b6fc1: 		// ModelledResourceManager service is present.
1:9bba779: 		ServiceModeller modeller = getServiceModeller();
1:9bba779: 		if (modeller == null)
1:d6eb080: 			return;
1:e7af8b6: 
1:d6eb080: 		ServiceModeller.ServiceModel model = modeller.computeRequirementsAndCapabilities(this, directory);
1:d6eb080: 		if (computeServiceCapabilities)
1:d6eb080: 			capabilities.addAll(model.getServiceCapabilities());
1:d6eb080: 		if (computeServiceRequirements)
1:d6eb080: 			requirements.addAll(model.getServiceRequirements());
1:e7af8b6: 	}
1:b75f264: 	
1:e7af8b6: 	private void computeRequirementsOtherThanService() {
1:b75f264: 		computeOsgiWiringPackageRequirements();
1:b75f264: 		computeGenericRequirements();
1:b75f264: 		computeOsgiWiringBundleRequirements();
1:f46e7d5: 		computeOsgiExecutionEnvironmentRequirement();
1:8ad6b99: 		computeOsgiWiringHostRequirement();
1:8ad6b99: 		computeOsgiWiringHostCapability();
1:b75f264: 	}
1:b75f264: 	
1:47cea41: 	private String getFileName(IFile file) {
1:47cea41: 		String name = file.getName();
1:47cea41: 		if ("".equals(name)) {
1:47cea41: 			// The file is the root directory of an archive. Use the URL
1:47cea41: 			// instead. Using the empty string will likely result in duplicate
1:47cea41: 			// locations during installation.
1:47cea41: 			try {
1:47cea41: 				name = file.toURL().toString();
1:47cea41: 			}
1:47cea41: 			catch (MalformedURLException e) {
1:47cea41: 				throw new SubsystemException(e);
1:47cea41: 			}
1:47cea41: 		}
1:47cea41: 		int index = name.lastIndexOf('/');
1:47cea41: 		if (index == -1 || index == name.length() - 1)
1:47cea41: 			return name;
1:47cea41: 		return name.substring(index + 1);
1:47cea41: 	}
1:47cea41: 
1:9bba779: 	private ServiceModeller getServiceModeller() {
1:9bba779: 		return Activator.getInstance().getServiceModeller();
1:f615d56: 	}
1:47cea41: 
1:47cea41: 	private void jar(JarOutputStream out, String prefix, IDirectory directory) throws IOException {
1:47cea41: 		List<IFile> files = directory.listFiles();
1:47cea41: 		for (IFile f : files) {        
1:47cea41: 			String fileName; 
1:47cea41: 			if (f.isDirectory())
1:47cea41: 				fileName = prefix + getFileName(f) + "/";
1:47cea41: 			else
1:47cea41: 				fileName = prefix + getFileName(f);
1:47cea41: 			if ("META-INF/".equalsIgnoreCase(fileName) || "META-INF/MANIFEST.MF".equalsIgnoreCase(fileName))
1:47cea41: 				continue;
1:47cea41: 			JarEntry entry = new JarEntry(fileName);
1:47cea41: 			entry.setSize(f.getSize());
1:47cea41: 			entry.setTime(f.getLastModified());
1:47cea41: 			out.putNextEntry(entry);
1:47cea41: 			if (f.isDirectory()) 
1:47cea41: 				jar(out, fileName, f.convert());
1:47cea41: 			else
1:47cea41: 				IOUtils.copy(f.open(), out);
1:47cea41: 		}
1:47cea41: 	}
1:f615d56: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:8ad6b99
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.FragmentHostCapability;
1: import org.apache.aries.subsystem.core.archive.FragmentHostHeader;
1: import org.apache.aries.subsystem.core.archive.FragmentHostRequirement;
/////////////////////////////////////////////////////////////////////////
1: 		if (manifest.getHeader(org.osgi.framework.Constants.FRAGMENT_HOST) != null) {
1: 	        // The osgi.wiring.bundle capability is not provided by fragments.
1: 	        return;
1: 	    }
/////////////////////////////////////////////////////////////////////////
1: 	private void computeOsgiWiringHostCapability() {
1: 	    if (manifest.getHeader(org.osgi.framework.Constants.FRAGMENT_HOST) != null) {
1:             // The osgi.wiring.host capability is not provided by fragments.
1:             return;
1:         }
1:         BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
1:         BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
1:         capabilities.add(new FragmentHostCapability(bsnh, bvh, this));
1:     }
1: 	
1: 	private void computeOsgiWiringHostRequirement() {
1:         FragmentHostHeader fhh = (FragmentHostHeader)manifest.getHeader(FragmentHostHeader.NAME);
1:         if (fhh != null) {
1:             requirements.add(new FragmentHostRequirement(fhh.getClauses().iterator().next(), this));
1:         }
1:     }
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		computeOsgiWiringHostRequirement();
1: 		computeOsgiWiringHostCapability();
commit:28b6fc1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.modelling.ParsedServiceElements;
/////////////////////////////////////////////////////////////////////////
0: 	private void computeOsgiServiceCapabilities(Collection<ExportedService> services) {
/////////////////////////////////////////////////////////////////////////
0: 	private void computeOsgiServiceRequirements(Collection<ImportedService> services) {
/////////////////////////////////////////////////////////////////////////
1: 		// Compute all requirements and capabilities other than those related
1: 		// to services.
1: 		// Compute service requirements and capabilities if the optional
1: 		// ModelledResourceManager service is present.
0: 		ParsedServiceElements elements = manager.getServiceElements(directory);
0: 		computeOsgiServiceRequirements(elements.getReferences());
0: 		computeOsgiServiceCapabilities(elements.getServices());
commit:e7af8b6
/////////////////////////////////////////////////////////////////////////
1: 		computeRequirementsAndCapabilities(dir);
/////////////////////////////////////////////////////////////////////////
1: 	private void computeCapabilitiesOtherThanService() {
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private void computeRequirementsAndCapabilities(IDirectory directory) throws ModellerException {
1: 		computeRequirementsOtherThanService();
1: 		computeCapabilitiesOtherThanService();
0: 		ModelledResourceManager manager = getModelledResourceManager();
0: 		if (manager == null)
1: 			return;
0: 		// TODO Could use ModelledResourceManager.getServiceElements instead. 
0: 		// Only the service dependency info is being used right now.
0: 		ModelledResource resource = manager.getModelledResource(directory);
0: 		computeOsgiServiceRequirements(resource);
0: 		computeOsgiServiceCapabilities(resource);
1: 	}
1: 	
1: 	private void computeRequirementsOtherThanService() {
commit:f46e7d5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.BundleRequiredExecutionEnvironmentHeader;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.RequirementHeader;
/////////////////////////////////////////////////////////////////////////
1: 	private void computeOsgiExecutionEnvironmentRequirement() {
1: 		RequirementHeader<?> header = (RequirementHeader<?>)manifest.getHeader(BundleRequiredExecutionEnvironmentHeader.NAME);
1: 		if (header == null)
1: 			return;
1: 		requirements.addAll(header.toRequirements(this));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		computeOsgiExecutionEnvironmentRequirement();
commit:1853801
/////////////////////////////////////////////////////////////////////////
0: 				builder.append(filter);
commit:6740c72
/////////////////////////////////////////////////////////////////////////
0: 					.directive(
0: 							Namespace.REQUIREMENT_CARDINALITY_DIRECTIVE, 
0: 							service.isMultiple() ? Namespace.CARDINALITY_MULTIPLE : Namespace.CARDINALITY_SINGLE)
commit:47cea41
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.net.MalformedURLException;
1: import java.util.jar.JarEntry;
1: import java.util.jar.JarOutputStream;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.filesystem.IFile;
/////////////////////////////////////////////////////////////////////////
1: 	private final IFile content;
0: 	public BundleResource(IFile content) throws ModellerException {
1: 		IDirectory dir = content.isDirectory() ? content.convert() : content.convertNested();
1: 		manifest = computeManifest(dir);
0: 		// TODO Could use ModelledResourceManager.getServiceElements instead. 
0: 		// Only the service dependency info is being used right now.
0: 		ModelledResource resource = getModelledResourceManager().getModelledResource(dir);
0: 		computeRequirements(resource);
0: 		computeCapabilities(resource);
/////////////////////////////////////////////////////////////////////////
1: 	public String getLocation() {
1: 		return getFileName(content);
1: 	}
1: 	
1: 			if (content.isFile())
1: 				return content.open();
1: 			try {
1: 				// Give the IDirectory a shot at opening in case it supports it.
1: 				return content.open();
1: 			}
1: 			catch (UnsupportedOperationException e) {
1: 				// As a last ditch effort, try to jar up the contents.
1: 				ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 				JarOutputStream out = new JarOutputStream(baos, manifest.getManifest());
1: 				try {
1: 					jar(out, "", content.convert());
1: 				}
1: 				finally {
1: 					IOUtils.close(out);
1: 				}
1: 				return new ByteArrayInputStream(baos.toByteArray());
1: 			}
1: 		catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:         return content.toString();
/////////////////////////////////////////////////////////////////////////
1: 	private String getFileName(IFile file) {
1: 		String name = file.getName();
1: 		if ("".equals(name)) {
1: 			// The file is the root directory of an archive. Use the URL
1: 			// instead. Using the empty string will likely result in duplicate
1: 			// locations during installation.
1: 			try {
1: 				name = file.toURL().toString();
1: 			}
1: 			catch (MalformedURLException e) {
1: 				throw new SubsystemException(e);
1: 			}
1: 		}
1: 		int index = name.lastIndexOf('/');
1: 		if (index == -1 || index == name.length() - 1)
1: 			return name;
1: 		return name.substring(index + 1);
1: 	}
1: 
1: 
1: 	private void jar(JarOutputStream out, String prefix, IDirectory directory) throws IOException {
1: 		List<IFile> files = directory.listFiles();
1: 		for (IFile f : files) {        
1: 			String fileName; 
1: 			if (f.isDirectory())
1: 				fileName = prefix + getFileName(f) + "/";
1: 			else
1: 				fileName = prefix + getFileName(f);
1: 			if ("META-INF/".equalsIgnoreCase(fileName) || "META-INF/MANIFEST.MF".equalsIgnoreCase(fileName))
1: 				continue;
1: 			JarEntry entry = new JarEntry(fileName);
1: 			entry.setSize(f.getSize());
1: 			entry.setTime(f.getLastModified());
1: 			out.putNextEntry(entry);
1: 			if (f.isDirectory()) 
1: 				jar(out, fileName, f.convert());
1: 			else
1: 				IOUtils.copy(f.open(), out);
1: 		}
1: 	}
commit:b75f264
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
1: import java.util.Collections;
0: import org.apache.aries.application.modelling.ExportedService;
0: import org.apache.aries.application.modelling.ImportedService;
0: import org.apache.aries.application.modelling.ModelledResource;
0: import org.apache.aries.application.modelling.ModelledResourceManager;
0: import org.apache.aries.application.modelling.ModellerException;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.namespace.service.ServiceNamespace;
0: import org.osgi.resource.Namespace;
1: import org.osgi.service.subsystem.SubsystemException;
/////////////////////////////////////////////////////////////////////////
0: 	public BundleResource(URL content) throws IOException, ModellerException {
0: 				// TODO Could use ModelledResourceManager.getServiceElements
0: 				// instead. Only the service dependency info is being used
0: 				// right now.
0: 				ModelledResource resource = getModelledResourceManager().getModelledResource(directory);
0: 				computeRequirements(resource);
0: 				computeCapabilities(resource);
/////////////////////////////////////////////////////////////////////////
0: 	public BundleResource(String content) throws IOException, ModellerException {
1: 		if (namespace == null)
1: 			return Collections.unmodifiableList(capabilities);
1: 			if (namespace.equals(capability.getNamespace()))
1: 		result.trimToSize();
1: 		return Collections.unmodifiableList(result);
/////////////////////////////////////////////////////////////////////////
0: 		catch (IOException e) {
1: 			throw new SubsystemException(e);
1: 		if (namespace == null)
1: 			return Collections.unmodifiableList(requirements);
1: 		ArrayList<Requirement> result = new ArrayList<Requirement>(requirements.size());
1: 			if (namespace.equals(requirement.getNamespace()))
1: 		result.trimToSize();
1: 		return Collections.unmodifiableList(result);
/////////////////////////////////////////////////////////////////////////
0: 	private void computeCapabilities(ModelledResource resource) {
1: 		computeOsgiIdentityCapability();
1: 		computeOsgiWiringPackageCapabilities();
1: 		computeOsgiWiringBundleCapability();
1: 		computeGenericCapabilities();
0: 		computeOsgiServiceCapabilities(resource);
1: 	private void computeGenericCapabilities() {
1: 	private void computeGenericRequirements() {
1: 	private void computeOsgiIdentityCapability() {
1: 		capabilities.add(new OsgiIdentityCapability(this, manifest));
1: 	}
1: 	
0: 	private void computeOsgiServiceCapabilities(ModelledResource resource) {
0: 		Collection<? extends ExportedService> services = resource.getExportedServices();
0: 		for (ExportedService service : services)
0: 			capabilities.add(new BasicCapability.Builder()
0: 					.namespace(ServiceNamespace.SERVICE_NAMESPACE)
0: 					.attribute(ServiceNamespace.CAPABILITY_OBJECTCLASS_ATTRIBUTE, new ArrayList<String>(service.getInterfaces()))
0: 					.attributes(service.getServiceProperties())
0: 					.resource(this)
0: 					.build());
1: 	}
1: 	
0: 	private void computeOsgiServiceRequirements(ModelledResource resource) {
0: 		Collection<? extends ImportedService> services = resource.getImportedServices();
0: 		for (ImportedService service : services) {
0: 			StringBuilder builder = new StringBuilder("(&(")
0: 					.append(ServiceNamespace.CAPABILITY_OBJECTCLASS_ATTRIBUTE)
0: 					.append('=')
0: 					.append(service.getInterface())
0: 					.append(')');
0: 			String filter = service.getFilter();
0: 			if (filter != null)
0: 				builder.append('(').append(filter).append(')');
0: 			builder.append(')');
0: 			requirements.add(new BasicRequirement.Builder()
0: 					.namespace(ServiceNamespace.SERVICE_NAMESPACE)
0: 					.directive(Namespace.REQUIREMENT_FILTER_DIRECTIVE, builder.toString())
0: 					.directive(
0: 							Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE, 
0: 							service.isOptional() ? Namespace.RESOLUTION_OPTIONAL : Namespace.RESOLUTION_MANDATORY)
0: 					.resource(this)
0: 					.build());
1: 		}
1: 	}
1: 	
1: 	private void computeOsgiWiringBundleCapability() {
0: 		// TODO The osgi.wiring.bundle capability should not be provided for fragments. Nor should the host capability.
1: 		BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
1: 		BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
1: 		capabilities.add(new ProvideBundleCapability(bsnh, bvh, this));
1: 	}
1: 	
1: 	private void computeOsgiWiringBundleRequirements() {
1: 		RequireBundleHeader rbh = (RequireBundleHeader)manifest.getHeader(RequireBundleHeader.NAME);
1: 		if (rbh != null)
1: 			for (RequireBundleHeader.Clause clause : rbh.getClauses())
1: 				requirements.add(new RequireBundleRequirement(clause, this));
1: 	}
1: 	
1: 	private void computeOsgiWiringPackageCapabilities() {
1: 		ExportPackageHeader eph = (ExportPackageHeader)manifest.getHeader(ExportPackageHeader.NAME);
1: 		if (eph != null)
1: 			capabilities.addAll(eph.toCapabilities(this));
1: 	}
1: 	
1: 	private void computeOsgiWiringPackageRequirements() {
1: 		ImportPackageHeader iph = (ImportPackageHeader)manifest.getHeader(ImportPackageHeader.NAME);
1: 		if (iph != null)
1: 			requirements.addAll(iph.toRequirements(this));
1: 	}
1: 
0: 	private void computeRequirements(ModelledResource resource) {
1: 		computeOsgiWiringPackageRequirements();
1: 		computeGenericRequirements();
1: 		computeOsgiWiringBundleRequirements();
0: 		computeOsgiServiceRequirements(resource);
1: 	
0: 	private ModelledResourceManager getModelledResourceManager() {
0: 		return Activator.getInstance().getModelledResourceManager();
1: 	}
commit:f615d56
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.util.filesystem.FileSystem;
0: import org.apache.aries.util.filesystem.ICloseableDirectory;
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.apache.aries.util.io.IOUtils;
/////////////////////////////////////////////////////////////////////////
1: 	private static BundleManifest computeManifest(IDirectory directory) {
1: 		return new BundleManifest(org.apache.aries.util.manifest.BundleManifest
1: 				.fromBundle(directory)
1: 				.getRawManifest());
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		InputStream is = content.openStream();
1: 		try {
0: 			ICloseableDirectory directory = FileSystem.getFSRoot(is);
1: 			try {
0: 				manifest = computeManifest(directory);
0: 				computeRequirements(directory);
0: 				computeCapabilities();
1: 			}
0: 			finally {
0: 				IOUtils.close(directory);
0: 		finally {
0: 			// Although FileSystem.getFSRoot ultimately tries to close the
0: 			// provided input stream, it is possible an exception will be thrown
0: 			// before that happens.
0: 			IOUtils.close(is);
1: 		}
1: 		for (Capability capability : capabilities)
/////////////////////////////////////////////////////////////////////////
1: 		for (Requirement requirement : requirements)
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private void computeCapabilities() {
0: 		computeExportPackageCapabilities();
0: 		computeProvideBundleCapability();
0: 		computeProvideCapabilityCapabilities();
1: 	}
1: 	
0: 	private void computeExportPackageCapabilities() {
0: 		ExportPackageHeader eph = (ExportPackageHeader)manifest.getHeader(ExportPackageHeader.NAME);
0: 		if (eph != null)
0: 			capabilities.addAll(eph.toCapabilities(this));
1: 	}
1: 	
0: 	private void computeImportPackageRequirements() {
0: 		ImportPackageHeader iph = (ImportPackageHeader)manifest.getHeader(ImportPackageHeader.NAME);
0: 		if (iph != null)
0: 			requirements.addAll(iph.toRequirements(this));
1: 	}
1: 	
0: 	private void computeProvideBundleCapability() {
0: 		// TODO The osgi.wiring.bundle capability should not be provided for fragments. Nor should the host capability.
0: 		BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
0: 		BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
0: 		capabilities.add(new ProvideBundleCapability(bsnh, bvh, this));
1: 	}
1: 	
0: 	private void computeProvideCapabilityCapabilities() {
1: 		ProvideCapabilityHeader pch = (ProvideCapabilityHeader)manifest.getHeader(ProvideCapabilityHeader.NAME);
1: 		if (pch != null)
1: 			for (ProvideCapabilityHeader.Clause clause : pch.getClauses())
1: 				capabilities.add(new ProvideCapabilityCapability(clause, this));
1: 	}
1: 	
0: 	private void computeRequireBundleRequirements() {
0: 		RequireBundleHeader rbh = (RequireBundleHeader)manifest.getHeader(RequireBundleHeader.NAME);
0: 		if (rbh != null)
0: 			for (RequireBundleHeader.Clause clause : rbh.getClauses())
0: 				requirements.add(new RequireBundleRequirement(clause, this));
1: 	}
1: 	
0: 	private void computeRequireCapabilityRequirements() {
1: 		RequireCapabilityHeader rch = (RequireCapabilityHeader)manifest.getHeader(RequireCapabilityHeader.NAME);
1: 		if (rch != null)
1: 			for (RequireCapabilityHeader.Clause clause : rch.getClauses())
1: 				requirements.add(new RequireCapabilityRequirement(clause, this));
1: 	}
1: 	
0: 	private void computeRequirements(IDirectory directory) {
0: 		computeImportPackageRequirements();
0: 		computeRequireCapabilityRequirements();
0: 		computeRequireBundleRequirements();
0: 		// TODO Bundle-RequiredExecutionEnvironment
1: 	}
commit:5896d6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		manifest = new BundleManifest(org.apache.aries.util.manifest.BundleManifest.fromBundle(content.openStream()).getRawManifest());
commit:bc9f4bc
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Override
1: 	public String toString() {
0:         return content.toExternalForm();
0:     }
commit:67ef08f
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.subsystem.core.internal;
/////////////////////////////////////////////////////////////////////////
commit:35094c6
/////////////////////////////////////////////////////////////////////////
0: 				requirements.add(new RequireCapabilityRequirement(clause, this));
0: 				requirements.add(new RequireBundleRequirement(clause, this));
commit:df175a6
/////////////////////////////////////////////////////////////////////////
0: 			requirements.addAll(iph.toRequirements(this));
commit:12260c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.BundleSymbolicNameHeader;
1: import org.apache.aries.subsystem.core.archive.BundleVersionHeader;
1: import org.apache.aries.subsystem.core.archive.ProvideBundleCapability;
1: import org.apache.aries.subsystem.core.archive.ProvideCapabilityCapability;
1: import org.apache.aries.subsystem.core.archive.ProvideCapabilityHeader;
/////////////////////////////////////////////////////////////////////////
0: 		// TODO The osgi.wiring.bundle capability should not be provided for fragments. Nor should the host capability.
0: 		BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
0: 		BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
0: 		capabilities.add(new ProvideBundleCapability(bsnh, bvh, this));
0: 		ProvideCapabilityHeader pch = (ProvideCapabilityHeader)manifest.getHeader(ProvideCapabilityHeader.NAME);
0: 		if (pch != null) {
0: 			for (ProvideCapabilityHeader.Clause clause : pch.getClauses()) {
0: 				capabilities.add(new ProvideCapabilityCapability(clause, this));
0: 			}
0: 		}
0: 		// TODO Bundle-RequiredExecutionEnvironment
commit:aac6a2a
/////////////////////////////////////////////////////////////////////////
1: 	public InputStream getContent() {
0: 		try {
0: 			return content.openStream();
0: 		}
0: 		catch (Exception e) {
0: 			throw new RuntimeException(e);
0: 		}
commit:574fba9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.RequireBundleHeader;
1: import org.apache.aries.subsystem.core.archive.RequireBundleRequirement;
/////////////////////////////////////////////////////////////////////////
0: 		RequireBundleHeader rbh = (RequireBundleHeader)manifest.getHeader(RequireBundleHeader.NAME);
0: 		if (rbh != null)
0: 			for (RequireBundleHeader.Clause clause : rbh.getClauses())
0: 				requirements.add(new RequireBundleRequirement(clause));
commit:7e004f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
1: import org.apache.aries.subsystem.core.archive.RequireCapabilityRequirement;
/////////////////////////////////////////////////////////////////////////
0: 		if (eph != null)
0: 		if (iph != null)
0: 		RequireCapabilityHeader rch = (RequireCapabilityHeader)manifest.getHeader(RequireCapabilityHeader.NAME);
0: 		if (rch != null)
0: 			for (RequireCapabilityHeader.Clause clause : rch.getClauses())
0: 				requirements.add(new RequireCapabilityRequirement(clause));
commit:7837a59
/////////////////////////////////////////////////////////////////////////
0: 			capabilities.addAll(eph.toCapabilities(this));
commit:8ee8aac
/////////////////////////////////////////////////////////////////////////
0: 	public InputStream getContent(String osgiContent) throws IOException {
commit:71fe81a
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.resource.Capability;
1: import org.osgi.resource.Requirement;
1: import org.osgi.resource.Resource;
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.repository.RepositoryContent;
0: public class BundleResource implements Resource, RepositoryContent {
/////////////////////////////////////////////////////////////////////////
0: 	private final URL content;
0: 	private BundleResource(URL content) throws IOException {
1: 		this.content = content;
0: 		JarInputStream jis = new JarInputStream(content.openStream());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Override
0: 	public InputStream getContent() throws IOException {
0: 		return content.openStream();
0: 	}
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.resource.Capability;
0: import org.osgi.framework.resource.Requirement;
0: import org.osgi.framework.resource.Resource;
commit:4717af0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.BundleManifest;
1: import org.apache.aries.subsystem.core.archive.ExportPackageHeader;
/////////////////////////////////////////////////////////////////////////
1: 	private final BundleManifest manifest;
1: 	private final List<Requirement> requirements = new ArrayList<Requirement>();
/////////////////////////////////////////////////////////////////////////
0: 			this.manifest = new BundleManifest(manifest);
/////////////////////////////////////////////////////////////////////////
0: 		ExportPackageHeader eph = (ExportPackageHeader)manifest.getHeader(ExportPackageHeader.NAME);
0: 		if (eph != null) {
0: 			capabilities.addAll(eph.getCapabilities(this));
0: 		}
0: 		ImportPackageHeader iph = (ImportPackageHeader)manifest.getHeader(ImportPackageHeader.NAME);
0: 		if (iph != null) {
0: 			requirements.addAll(iph.getRequirements(this));
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 			if (namespace == null || namespace.equals(capability.getNamespace()))
/////////////////////////////////////////////////////////////////////////
0: 		for (Requirement requirement : requirements) {
0: 			if (namespace == null || namespace.equals(requirement.getNamespace()))
1: 				result.add(requirement);
commit:1129914
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
0: package org.apache.aries.subsystem.core.resource;
0: 
1: import java.io.IOException;
1: import java.io.InputStream;
0: import java.net.URL;
1: import java.util.ArrayList;
0: import java.util.Collections;
1: import java.util.List;
0: import java.util.jar.JarInputStream;
0: import java.util.jar.Manifest;
0: 
1: import org.apache.aries.subsystem.core.archive.ImportPackageHeader;
0: import org.apache.aries.subsystem.core.internal.OsgiContentCapability;
0: import org.apache.aries.subsystem.core.internal.OsgiIdentityCapability;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.wiring.Capability;
0: import org.osgi.framework.wiring.Requirement;
0: import org.osgi.framework.wiring.Resource;
0: 
0: public class BundleResource implements Resource {
0: 	public static BundleResource newInstance(URL content) throws IOException {
0: 		BundleResource result = new BundleResource(content);
0: 		result.capabilities.add(new OsgiIdentityCapability(result, result.manifest));
0: 		result.capabilities.add(new OsgiContentCapability(result, content));
0: 		return result;
0: 	}
0: 	
1: 	private final List<Capability> capabilities = new ArrayList<Capability>();
0: 	private final Manifest manifest;
0: 	
0: 	private BundleResource(InputStream content) throws IOException {
0: 		JarInputStream jis = new JarInputStream(content);
0: 		try {
0: 			Manifest manifest = jis.getManifest();
0: 			if (manifest == null)
0: 				throw new IllegalArgumentException("The jar file contained no manifest");
0: 			this.manifest = manifest;
0: 		}
0: 		finally {
0: 			try {
0: 				jis.close();
0: 			}
0: 			catch (IOException e) {}
0: 		}
0: 	}
0: 	
0: 	private BundleResource(URL content) throws IOException {
0: 		this(content.openStream());
0: 	}
0: 	
0: 	private BundleResource(String content) throws IOException {
1: 		/*
0: 		 * TODO
0: 		 * Capabilities
0: 		 * 		Export-Package
0: 		 * 		Provide-Capability
0: 		 * 		BSN + Version (host)
0: 		 * 		osgi.identity
0: 		 * Requirements
0: 		 * 		Import-Package
0: 		 * 		Require-Bundle
0: 		 * 		Require-Capability
0: 		 * 		Fragment-Host
1: 		 */
0: 		this(new URL(content));
0: 	}
0: 
1: 	public List<Capability> getCapabilities(String namespace) {
0: 		if (namespace == null) {
0: 			return Collections.unmodifiableList(capabilities);
0: 		}
1: 		ArrayList<Capability> result = new ArrayList<Capability>(capabilities.size());
0: 		for (Capability capability : capabilities) {
0: 			if (namespace.equals(capability.getNamespace())) {
1: 				result.add(capability);
0: 			}
0: 		}
0: 		result.trimToSize();
0: 		return result;
0: 	}
0: 
1: 	public List<Requirement> getRequirements(String namespace) {
0: 		/* Requirements
0: 		 * 		Import-Package
0: 		 * 		Require-Bundle
0: 		 * 		Require-Capability
0: 		 * 		Fragment-Host
1: 		 */
0: 		ArrayList<Requirement> result = new ArrayList<Requirement>();
0: 		String importPackageHeaderStr = manifest.getMainAttributes().getValue(Constants.IMPORT_PACKAGE);
0: 		if (importPackageHeaderStr != null) {
0: 			ImportPackageHeader header = new ImportPackageHeader(importPackageHeaderStr);
0: 			result.addAll(header.getRequirements(this));
0: 		}
0: 		return result;
0: 	}
0: }
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.namespace.service.ServiceNamespace;
1: public class BundleResource implements Resource, org.apache.aries.subsystem.core.repository.RepositoryContent {
/////////////////////////////////////////////////////////////////////////
1: 		// OSGi RFC 201 for R6: The presence of any Require/Provide-Capability
1: 		// clauses in the osgi.service namespace overrides any service related
1: 		// requirements or capabilities that might have been found by other
1: 		// means.
1: 		boolean computeServiceRequirements = getRequirements(ServiceNamespace.SERVICE_NAMESPACE).isEmpty();
1: 		boolean computeServiceCapabilities = getCapabilities(ServiceNamespace.SERVICE_NAMESPACE).isEmpty();
1: 		if (!(computeServiceCapabilities || computeServiceRequirements))
1: 			return;
0: 
1: 		ServiceModeller.ServiceModel model = modeller.computeRequirementsAndCapabilities(this, directory);
1: 		if (computeServiceCapabilities)
1: 			capabilities.addAll(model.getServiceCapabilities());
1: 		if (computeServiceRequirements)
1: 			requirements.addAll(model.getServiceRequirements());
author:Christian Schneider
-------------------------------------------------------------------------------
commit:57b6627
/////////////////////////////////////////////////////////////////////////
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:9bba779
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public BundleResource(IFile content) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private void computeRequirementsAndCapabilities(IDirectory directory) {
1: 		ServiceModeller modeller = getServiceModeller();
1: 		if (modeller == null)
0:         ServiceModeller.ServiceModel model = modeller.computeRequirementsAndCapabilities(this, directory);
0:         capabilities.addAll(model.getServiceCapabilities());
0:         requirements.addAll(model.getServiceRequirements());
/////////////////////////////////////////////////////////////////////////
1: 	private ServiceModeller getServiceModeller() {
1: 		return Activator.getInstance().getServiceModeller();
============================================================================