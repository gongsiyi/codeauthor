1:2aab796: /*
1:2aab796:  * Licensed to the Apache Software Foundation (ASF) under one
1:2aab796:  * or more contributor license agreements.  See the NOTICE file
1:2aab796:  * distributed with this work for additional information
1:2aab796:  * regarding copyright ownership.  The ASF licenses this file
1:2aab796:  * to you under the Apache License, Version 2.0 (the
1:2aab796:  * "License"); you may not use this file except in compliance
1:2aab796:  * with the License.  You may obtain a copy of the License at
1:2aab796:  *
1:2aab796:  *   http://www.apache.org/licenses/LICENSE-2.0
1:2aab796:  *
1:2aab796:  * Unless required by applicable law or agreed to in writing,
1:2aab796:  * software distributed under the License is distributed on an
1:2aab796:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:2aab796:  * KIND, either express or implied.  See the License for the
1:2aab796:  * specific language governing permissions and limitations
1:2aab796:  * under the License.
1:2aab796:  */
1:2aab796: package org.apache.aries.subsystem.itests.defect;
1:2aab796: 
1:14d0ff1: import static org.junit.Assert.assertEquals;
1:2aab796: import static org.junit.Assert.assertFalse;
1:14d0ff1: import static org.junit.Assert.assertNotNull;
1:2aab796: import static org.junit.Assert.assertTrue;
1:2aab796: import static org.junit.Assert.fail;
1:2aab796: 
1:2aab796: import java.io.ByteArrayInputStream;
1:2aab796: import java.io.ByteArrayOutputStream;
1:14d0ff1: import java.io.File;
1:2aab796: import java.io.IOException;
1:2aab796: import java.io.InputStream;
1:2aab796: import java.util.Arrays;
1:14d0ff1: import java.util.Collection;
1:2aab796: import java.util.HashMap;
1:2aab796: import java.util.List;
1:2aab796: import java.util.Map;
1:2aab796: import java.util.Set;
1:2aab796: import java.util.concurrent.atomic.AtomicBoolean;
1:2aab796: 
1:2aab796: import org.apache.aries.subsystem.itests.SubsystemTest;
1:2aab796: import org.apache.aries.subsystem.itests.util.TestCapability;
1:2aab796: import org.apache.aries.subsystem.itests.util.TestRepository;
1:2aab796: import org.apache.aries.subsystem.itests.util.TestRepositoryContent;
1:2aab796: import org.eclipse.equinox.region.Region;
1:1c027e7: import org.eclipse.equinox.region.RegionDigraph;
1:2aab796: import org.eclipse.equinox.region.RegionDigraph.FilteredRegion;
1:2aab796: import org.eclipse.equinox.region.RegionFilter;
1:2aab796: import org.junit.Before;
1:2aab796: import org.junit.Test;
1:2aab796: import org.ops4j.pax.tinybundles.core.InnerClassStrategy;
1:2aab796: import org.ops4j.pax.tinybundles.core.TinyBundles;
1:2aab796: import org.osgi.framework.Bundle;
1:14d0ff1: import org.osgi.framework.BundleContext;
1:2aab796: import org.osgi.framework.Constants;
1:2aab796: import org.osgi.framework.Version;
1:2aab796: import org.osgi.framework.hooks.weaving.WeavingHook;
1:2aab796: import org.osgi.framework.hooks.weaving.WovenClass;
1:2aab796: import org.osgi.framework.namespace.IdentityNamespace;
1:2aab796: import org.osgi.framework.namespace.PackageNamespace;
1:2aab796: import org.osgi.resource.Resource;
1:2aab796: import org.osgi.service.repository.Repository;
1:2aab796: import org.osgi.service.subsystem.Subsystem;
1:2aab796: import org.osgi.service.subsystem.SubsystemConstants;
1:2aab796: 
1:2aab796: /*
1:2aab796:  * https://issues.apache.org/jira/browse/ARIES-1435
1:2aab796:  * 
1:2aab796:  * Sharing policy updates for dynamic imports, if necessary, should proceed up 
1:2aab796:  * the subsystem region tree.
1:2aab796:  */
1:2aab796: public class Aries1435Test extends SubsystemTest {
1:2aab796: 	private static final String APPLICATION_A = "application.a.esa";
1:2aab796: 	private static final String APPLICATION_B = "application.b.esa";
1:2aab796: 	private static final String APPLICATION_C = "application.c.esa";
1:2aab796: 	private static final String APPLICATION_D = "application.d.esa";
1:2aab796: 	private static final String APPLICATION_E = "application.e.esa";
1:2aab796: 	private static final String BUNDLE_A = "bundle.a.jar";
1:2aab796: 	private static final String BUNDLE_B = "bundle.b.jar";
1:2aab796: 	private static final String COMPOSITE_A = "composite.a.esa";
1:2aab796: 	private static final String COMPOSITE_B = "composite.b.esa";
1:2aab796: 	private static final String COMPOSITE_C = "composite.c.esa";
1:2aab796: 	private static final String COMPOSITE_D = "composite.d.esa";
1:2aab796: 	private static final String COMPOSITE_E = "composite.e.esa";
1:14d0ff1: 	private static final String COMPOSITE_F = "composite.f.esa";
1:2aab796: 	private static final String FEATURE_A = "feature.a.esa";
1:2aab796: 	private static final String FEATURE_B = "feature.b.esa";
1:2aab796: 	private static final String FEATURE_C = "feature.c.esa";
1:2aab796: 	private static final String FEATURE_D = "feature.d.esa";
1:2aab796: 	
1:2aab796: 	private static boolean createdTestFiles;
1:2aab796: 	@Before
1:2aab796: 	public void createTestFiles() throws Exception {
1:2aab796: 		if (createdTestFiles)
1:2aab796: 			return;
1:2aab796: 		createApplicationB();
1:2aab796: 		createApplicationA();	
1:2aab796: 		createCompositeA();
1:2aab796: 		createCompositeB();
1:2aab796: 		createApplicationC();
1:2aab796: 		createFeatureA();
1:2aab796: 		createFeatureB();
1:2aab796: 		createApplicationD();
1:2aab796: 		createCompositeC();
1:2aab796: 		createFeatureC();
1:2aab796: 		createCompositeD();
1:2aab796: 		createFeatureD();
1:2aab796: 		createApplicationE();
1:2aab796: 		createCompositeE();
1:14d0ff1: 		createCompositeF();
1:2aab796: 		createdTestFiles = true;
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private AtomicBoolean weavingHookCalled;
1:2aab796: 	@Override
1:2aab796:     public void setUp() throws Exception {
1:2aab796:         super.setUp();
1:2aab796:         try {
1:2aab796:             serviceRegistrations.add(
1:2aab796:                     bundleContext.registerService(
1:2aab796:                             Repository.class, 
1:2aab796:                             createTestRepository(), 
1:2aab796:                             null));
1:2aab796:         }
1:2aab796:         catch (IOException e) {
1:2aab796:             throw new RuntimeException(e);
1:2aab796:         }
1:2aab796:         weavingHookCalled = new AtomicBoolean();
1:2aab796:     }
1:2aab796: 	
1:14d0ff1: 	@Test
1:2aab796:     public void testApplicationWithParentApplication() throws Exception {
1:2aab796: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, APPLICATION_A);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testApplicationWithParentComposite() throws Exception {
1:2aab796: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, COMPOSITE_A);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testApplicationWithParentFeature() throws Exception {
1:2aab796: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, FEATURE_A);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testApplicationWithParentRoot() throws Exception {
1:2aab796: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, null);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testChildExportsPackage() throws Exception {
1:2aab796: 		registerWeavingHook("b");
1:2aab796: 		Subsystem applicationB = installSubsystemFromFile(APPLICATION_B);
1:2aab796: 		try {
1:2aab796: 			Subsystem compositeE = installSubsystemFromFile(applicationB, COMPOSITE_E);
1:2aab796: 			try {
1:2aab796: 				startSubsystem(compositeE);
1:2aab796: 				try {
1:2aab796: 					testSharingPolicy(applicationB, "b", true);
1:2aab796: 					testDynamicImport(applicationB, "b.B");
1:2aab796: 					testSharingPolicy(applicationB, "b", true);
1:2aab796: 					testSharingPolicy(compositeE, "b", false);
1:2aab796: 					testSharingPolicy(getRootSubsystem(), "b", false);
1:2aab796: 				}
1:2aab796: 				finally {
1:2aab796: 					stopSubsystemSilently(compositeE);
1:2aab796: 				}
1:2aab796: 			}
1:2aab796: 			finally {
1:2aab796: 				uninstallSubsystemSilently(compositeE);
1:2aab796: 			}
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(applicationB);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testCompositeWithParentApplication() throws Exception {
1:2aab796: 		testDynamicImport(COMPOSITE_B, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE, APPLICATION_C);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testCompositeWithParentComposite() throws Exception {
1:2aab796: 		testDynamicImport(COMPOSITE_B, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE, COMPOSITE_C);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testCompositeWithParentFeature() throws Exception {
1:2aab796: 		testDynamicImport(COMPOSITE_B, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE, FEATURE_C);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testDisconnectedEdgeWithParent() throws Exception {
1:2aab796: 		registerWeavingHook("b");
1:2aab796: 		Bundle bundleB = getRootSubsystem().getBundleContext().installBundle(
1:2aab796: 				BUNDLE_B, new ByteArrayInputStream(createBundleBContent()));
1:2aab796: 		try {
1:2aab796: 			Subsystem applicationA = installSubsystemFromFile(APPLICATION_A);
1:2aab796: 			try {
1:2aab796: 				Subsystem applicationB = getChild(applicationA, APPLICATION_B);
1:2aab796: 				uninstallSubsystem(applicationB);
1:2aab796: 				removeConnectionWithParent(applicationA);
1:2aab796: 				applicationB = installSubsystemFromFile(applicationA, APPLICATION_B);
1:2aab796: 				try {
1:2aab796: 					try {
1:2aab796: 						testDynamicImport(applicationB, "b.B");
1:2aab796: 						fail("Dynamic import should have failed");
1:2aab796: 					}
1:2aab796: 					catch (AssertionError e) {
1:2aab796: 						// Okay.
1:2aab796: 					}
1:2aab796: 					testSharingPolicy(applicationB, "b", true);
1:2aab796: 					testSharingPolicy(applicationA, "b", false);
1:2aab796: 					testSharingPolicy(getRootSubsystem(), "b", false);
1:2aab796: 				}
1:2aab796: 				finally {
1:2aab796: 					uninstallSubsystemSilently(applicationB);
1:2aab796: 				}
1:2aab796: 			}
1:2aab796: 			finally {
1:2aab796: 				uninstallSubsystemSilently(applicationA);
1:2aab796: 			}
1:2aab796: 		}
1:2aab796: 		finally {
1:1c027e7: 			uninstallSilently(bundleB);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testFeatureWithParentApplication() throws Exception {
1:2aab796: 		testDynamicImport(FEATURE_B, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE, APPLICATION_D);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testFeatureWithParentComposite() throws Exception {
1:2aab796: 		testDynamicImport(FEATURE_B, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE, COMPOSITE_D);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796:     public void testFeatureWithParentFeature() throws Exception {
1:2aab796: 		testDynamicImport(FEATURE_B, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE, FEATURE_D);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testNoProviders() throws Exception {
1:2aab796: 		registerWeavingHook("b");
1:2aab796: 		Subsystem applicationB = installSubsystemFromFile(APPLICATION_B);
1:2aab796: 		try {
1:2aab796: 			Bundle bundleA = getConstituentAsBundle(applicationB, BUNDLE_A, null, null);
1:2aab796: 			bundleA.loadClass("a.A");
1:2aab796: 			try {
1:2aab796: 				bundleA.loadClass("b.B");
1:2aab796: 				fail("Class should not have loaded");
1:2aab796: 			}
1:2aab796: 			catch (ClassNotFoundException e) {
1:2aab796: 				// Okay.
1:2aab796: 			}
1:2aab796: 			testSharingPolicy(applicationB, "b", false);
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(applicationB);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testWildcardEverything() throws Exception {
1:2aab796: 		registerWeavingHook("b", "*");
1:2aab796: 		Subsystem compositeB = installSubsystemFromFile(COMPOSITE_B);
1:2aab796: 		try {
1:2aab796: 			Bundle bundleB = compositeB.getBundleContext().installBundle(
1:2aab796: 					BUNDLE_B, 
1:2aab796: 					new ByteArrayInputStream(createBundleBContent()));
1:2aab796: 			try {
1:2aab796: 				Subsystem applicationB = installSubsystemFromFile(compositeB, APPLICATION_B);
1:2aab796: 				Subsystem featureB = installSubsystemFromFile(applicationB, FEATURE_B);
1:2aab796: 				Subsystem applicationE = installSubsystemFromFile(featureB, APPLICATION_E);
1:2aab796: 				
1:2aab796: 				testSharingPolicy(applicationE, "b", false);
1:2aab796: 				testSharingPolicy(applicationE, "org.osgi.framework.Constants", false);
1:2aab796: 				testSharingPolicy(applicationB, "b", false);
1:2aab796: 				testSharingPolicy(applicationB, "org.osgi.framework.Constants", false);
1:2aab796: 				testSharingPolicy(compositeB, "b", false);
1:2aab796: 				testSharingPolicy(compositeB, "org.osgi.framework.Constants", false);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "b", false);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "org.osgi.framework.Constants", false);
1:2aab796: 				
1:2aab796: 				testDynamicImport(applicationE, "b.B");
1:2aab796: 				testDynamicImport(applicationE, "org.osgi.framework.Constants");
1:2aab796: 				testDynamicImport(featureB, "b.B");
1:2aab796: 				testDynamicImport(featureB, "org.osgi.framework.Constants");
1:2aab796: 				testDynamicImport(applicationB, "b.B");
1:2aab796: 				testDynamicImport(applicationB, "org.osgi.framework.Constants");
1:2aab796: 				testDynamicImport(compositeB, "b.B");
1:2aab796: 				testDynamicImport(compositeB, "org.osgi.framework.Constants");
1:2aab796: 				
1:2aab796: 				testSharingPolicy(applicationE, "b", true);
1:2aab796: 				testSharingPolicy(applicationE, "org.osgi.framework.Constants", true);
1:2aab796: 				testSharingPolicy(applicationB, "b", true);
1:2aab796: 				testSharingPolicy(applicationB, "org.osgi.framework.Constants", true);
1:2aab796: 				testSharingPolicy(compositeB, "b", true);
1:2aab796: 				testSharingPolicy(compositeB, "org.osgi.framework.Constants", true);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "b", false);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "org.osgi.framework.Constants", false);
1:2aab796: 				
1:2aab796: 				uninstallSubsystemSilently(applicationE);
1:2aab796: 				uninstallSubsystemSilently(featureB);
1:2aab796: 				uninstallSubsystemSilently(applicationB);
1:2aab796: 			}
1:2aab796: 			finally {
1:1c027e7: 				uninstallSilently(bundleB);
1:2aab796: 			}
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(compositeB);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testWildcardEverythingInPackage() throws Exception {
1:2aab796: 		registerWeavingHook("b.*");
1:2aab796: 		Subsystem applicationA = installSubsystemFromFile(APPLICATION_A);
1:2aab796: 		try {
1:2aab796: 			Bundle bundleB = applicationA.getBundleContext().installBundle(
1:2aab796: 					BUNDLE_B, 
1:2aab796: 					new ByteArrayInputStream(createBundleBContent()));
1:2aab796: 			try {
1:2aab796: 				Subsystem applicationB = getChild(applicationA, APPLICATION_B);
1:2aab796: 				
1:2aab796: 				testSharingPolicy(applicationB, "b", false);
1:2aab796: 				testSharingPolicy(applicationB, "b.a", false);
1:2aab796: 				testSharingPolicy(applicationA, "b", false);
1:2aab796: 				testSharingPolicy(applicationA, "b.a", false);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "b", false);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "b.a", false);
1:2aab796: 				
1:2aab796: 				testDynamicImport(applicationB, "b.a.A");
1:2aab796: 				
1:2aab796: 				testSharingPolicy(applicationB, "b", false);
1:2aab796: 				testSharingPolicy(applicationB, "b.a", true);
1:2aab796: 				testSharingPolicy(applicationA, "b", false);
1:2aab796: 				testSharingPolicy(applicationA, "b.a", true);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "b", false);
1:2aab796: 				testSharingPolicy(getRootSubsystem(), "b.a", false);
1:2aab796: 			}
1:2aab796: 			finally {
1:1c027e7: 				uninstallSilently(bundleB);
1:2aab796: 			}
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(applicationA);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testWovenSubsystemContainsProvider() throws Exception {
1:2aab796: 		registerWeavingHook("b");
1:2aab796: 		Subsystem applicationE = installSubsystemFromFile(APPLICATION_E);
1:2aab796: 		try {
1:2aab796: 			assertConstituent(applicationE, BUNDLE_B);
1:2aab796: 			testDynamicImport(applicationE, "b.B");
1:2aab796: 			testSharingPolicy(applicationE, "b", false);
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(applicationE);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:2aab796: 	public void testWovenSubsystemParentContainsProvider() throws Exception {
1:2aab796: 		registerWeavingHook("b");
1:2aab796: 		Subsystem compositeE = installSubsystemFromFile(COMPOSITE_E);
1:2aab796: 		try {
1:2aab796: 			assertNotConstituent(getRootSubsystem(), BUNDLE_B);
1:2aab796: 			assertConstituent(compositeE, BUNDLE_B);
1:2aab796: 			Subsystem applicationB = getChild(compositeE, APPLICATION_B);
1:2aab796: 			assertNotConstituent(applicationB, BUNDLE_B);
1:2aab796: 			testDynamicImport(applicationB, "b.B");
1:2aab796: 			testSharingPolicy(compositeE, "b", false);
1:2aab796: 			testSharingPolicy(applicationB, "b", true);
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(compositeE);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	@Test
1:14d0ff1: 	public void testWovenSubsystemParentPolicyAllowsProvider() throws Exception {
1:14d0ff1: 		registerWeavingHook("b");
1:14d0ff1: 		Subsystem root = getRootSubsystem();
1:14d0ff1: 		BundleContext context = root.getBundleContext();
1:14d0ff1: 		Bundle bundleB = context.installBundle(BUNDLE_B, new ByteArrayInputStream(createBundleBContent()));
1:14d0ff1: 		try {
1:14d0ff1: 			Subsystem applicationB1 = installSubsystemFromFile(root, new File(APPLICATION_B), APPLICATION_B + "1");
1:14d0ff1: 			try {
1:14d0ff1: 				Subsystem compositeF = installSubsystemFromFile(applicationB1, COMPOSITE_F);
1:14d0ff1: 				try {
1:14d0ff1: 					assertPackageFiltersInParentConnection(compositeF, applicationB1, 2, 1);
1:14d0ff1: 					Subsystem applicationB2 = installSubsystemFromFile(compositeF, new File(APPLICATION_B), APPLICATION_B + "2");
1:14d0ff1: 					try {
1:14d0ff1: 						testDynamicImport(applicationB2, "b.B");
1:14d0ff1: 						testSharingPolicy(applicationB2, "b", true);
1:14d0ff1: 						testSharingPolicy(compositeF, "b", true);
1:14d0ff1: 						assertPackageFiltersInParentConnection(compositeF, applicationB1, 2, 1);
1:14d0ff1: 						testSharingPolicy(applicationB1, "b", true);
1:14d0ff1: 						testSharingPolicy(root, "b", false);
1:14d0ff1: 					}
1:14d0ff1: 					finally {
1:14d0ff1: 						uninstallSubsystemSilently(applicationB2);
1:14d0ff1: 					}
1:14d0ff1: 				}
1:14d0ff1: 				finally {
1:14d0ff1: 					uninstallSubsystemSilently(compositeF);
1:14d0ff1: 				}
1:14d0ff1: 			}
1:14d0ff1: 			finally {
1:14d0ff1: 				uninstallSubsystemSilently(applicationB1);
1:14d0ff1: 			}
1:14d0ff1: 		}
1:14d0ff1: 		finally {
1:14d0ff1: 			uninstallSilently(bundleB);
1:14d0ff1: 		}
1:14d0ff1: 	}
1:14d0ff1: 	
1:14d0ff1: 	private void assertPackageFiltersInParentConnection(Subsystem subsystem, Subsystem parent, int expectedEdges, int expectedFilters) {
1:14d0ff1: 		Region parentRegion = getRegion(parent);
1:14d0ff1: 		Region region = getRegion(subsystem);
1:14d0ff1: 		Set<FilteredRegion> edges = region.getEdges();
1:14d0ff1: 		assertEquals("Wrong number of edges", expectedEdges, edges.size());
1:14d0ff1: 		for (FilteredRegion edge : region.getEdges()) {
1:14d0ff1: 			if (!edge.getRegion().equals(parentRegion)) {
1:14d0ff1: 				continue;
1:14d0ff1: 			}
1:14d0ff1: 			RegionFilter filter = edge.getFilter();
1:14d0ff1: 			Map<String, Collection<String>> policy = filter.getSharingPolicy();
1:14d0ff1: 			Collection<String> packages = policy.get(PackageNamespace.PACKAGE_NAMESPACE);
1:14d0ff1: 			assertNotNull("Wrong number of packages", packages);
1:14d0ff1: 			assertEquals("Wrong number of packages", expectedFilters, packages.size());
1:14d0ff1: 			return;
1:14d0ff1: 		}
1:14d0ff1: 		fail("No connection to parent found");
1:14d0ff1: 	}
1:14d0ff1: 	
1:2aab796: 	private void createApplicationA() throws IOException {
1:2aab796: 		createApplicationAManifest();
1:2aab796: 		createSubsystem(APPLICATION_A, APPLICATION_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationAManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_A);
1:2aab796: 		createManifest(APPLICATION_A + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationB() throws IOException {
1:2aab796: 		createApplicationBManifest();
1:2aab796: 		createSubsystem(APPLICATION_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationBManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_B);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1:2aab796: 		createManifest(APPLICATION_B + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationC() throws IOException {
1:2aab796: 		createApplicationCManifest();
1:2aab796: 		createSubsystem(APPLICATION_C, COMPOSITE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationCManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_C);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, COMPOSITE_B + ";type=osgi.subsystem.composite");
1:2aab796: 		createManifest(APPLICATION_C + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationD() throws IOException {
1:2aab796: 		createApplicationDManifest();
1:2aab796: 		createSubsystem(APPLICATION_D, FEATURE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationDManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_D);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, FEATURE_B + ";type=osgi.subsystem.feature");
1:2aab796: 		createManifest(APPLICATION_D + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationE() throws IOException {
1:2aab796: 		createApplicationEManifest();
1:2aab796: 		createSubsystem(APPLICATION_E);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createApplicationEManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_E);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ',' + BUNDLE_B);
1:2aab796: 		createManifest(APPLICATION_E + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private byte[] createBundleAContent() throws Exception {
1:2aab796:         InputStream is = TinyBundles
1:2aab796:         		.bundle()
1:2aab796:         		.add(getClass().getClassLoader().loadClass("a.A"), InnerClassStrategy.NONE)
1:2aab796: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_A)
1:2aab796: 				.build(TinyBundles.withBnd());
1:2aab796:         return createBundleContent(is);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	private Resource createBundleAResource() throws Exception {
1:2aab796:         return new TestRepositoryContent.Builder()
1:2aab796:         .capability(
1:2aab796:                 new TestCapability.Builder()
1:2aab796:                     .namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:2aab796:                     .attribute(IdentityNamespace.IDENTITY_NAMESPACE, BUNDLE_A)
1:2aab796:                     .attribute(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE, IdentityNamespace.TYPE_BUNDLE)
1:2aab796:                     .attribute(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:2aab796:         .content(createBundleAContent())
1:2aab796:         .build();
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	private byte[] createBundleBContent() throws Exception {
1:2aab796:         InputStream is = TinyBundles
1:2aab796:         		.bundle()
1:2aab796:         		.add(getClass().getClassLoader().loadClass("b.B"), InnerClassStrategy.NONE)
1:2aab796:         		.add(getClass().getClassLoader().loadClass("b.a.A"), InnerClassStrategy.NONE)
1:2aab796: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_B)
1:2aab796: 				.set(Constants.EXPORT_PACKAGE, "b,b.a")
1:2aab796: 				.build(TinyBundles.withBnd());
1:2aab796:         return createBundleContent(is);
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	private byte[] createBundleContent(InputStream is) throws Exception {
1:2aab796: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:2aab796: 		byte[] bytes = new byte[1024];
1:2aab796:         int length;
1:2aab796:         while ((length = is.read(bytes)) != -1) {
1:2aab796:         	baos.write(bytes, 0, length);
1:2aab796:         }
1:2aab796:         is.close();
1:2aab796:         baos.close();
1:2aab796:         return baos.toByteArray();
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private Resource createBundleBResource() throws Exception {
1:2aab796:         return new TestRepositoryContent.Builder()
1:2aab796:         .capability(
1:2aab796:                 new TestCapability.Builder()
1:2aab796:                     .namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:2aab796:                     .attribute(IdentityNamespace.IDENTITY_NAMESPACE, BUNDLE_B)
1:2aab796:                     .attribute(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE, IdentityNamespace.TYPE_BUNDLE)
1:2aab796:                     .attribute(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:2aab796:         .capability(
1:2aab796:         		new TestCapability.Builder()
1:2aab796:         			.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:2aab796:         			.attribute(PackageNamespace.PACKAGE_NAMESPACE, "b")
1:2aab796:         			.attribute(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:2aab796:         .capability(
1:2aab796:         		new TestCapability.Builder()
1:2aab796:         			.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:2aab796:         			.attribute(PackageNamespace.PACKAGE_NAMESPACE, "b.a")
1:2aab796:         			.attribute(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:2aab796:         .content(createBundleBContent())
1:2aab796:         .build();
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	private void createCompositeA() throws IOException {
1:2aab796: 		createCompositeAManifest();
1:2aab796: 		createSubsystem(COMPOSITE_A, APPLICATION_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeAManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_A);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, APPLICATION_B + 
1:2aab796: 				";type=osgi.subsystem.application;version=\"[0,0]\"");
1:2aab796: 		createManifest(COMPOSITE_A + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeB() throws IOException {
1:2aab796: 		createCompositeBManifest();
1:2aab796: 		createSubsystem(COMPOSITE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeBManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_B);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ";version=\"[0,0]\"");
1:2aab796: 		createManifest(COMPOSITE_B + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeC() throws IOException {
1:2aab796: 		createCompositeCManifest();
1:2aab796: 		createSubsystem(COMPOSITE_C, COMPOSITE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeCManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_C);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, COMPOSITE_B + ";type=osgi.subsystem.composite;version=\"[0,0]\"");
1:2aab796: 		createManifest(COMPOSITE_C + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeD() throws IOException {
1:2aab796: 		createCompositeDManifest();
1:2aab796: 		createSubsystem(COMPOSITE_D, FEATURE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeDManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_D);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, FEATURE_B + ";type=osgi.subsystem.feature;version=\"[0,0]\"");
1:2aab796: 		createManifest(COMPOSITE_D + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeE() throws IOException {
1:2aab796: 		createCompositeEManifest();
1:2aab796: 		createSubsystem(COMPOSITE_E, APPLICATION_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createCompositeEManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_E);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, APPLICATION_B + 
1:2aab796: 				";type=osgi.subsystem.application;version=\"[0,0]\"," +
1:2aab796: 				BUNDLE_B + ";version=\"[0,0]\"");
1:2aab796: 		attributes.put(Constants.EXPORT_PACKAGE, "b");
1:2aab796: 		createManifest(COMPOSITE_E + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:14d0ff1: 	private void createCompositeF() throws IOException {
1:14d0ff1: 		createCompositeFManifest();
1:14d0ff1: 		createSubsystem(COMPOSITE_F);
1:14d0ff1: 	}
1:14d0ff1: 	
1:14d0ff1: 	private void createCompositeFManifest() throws IOException {
1:14d0ff1: 		Map<String, String> attributes = new HashMap<String, String>();
1:14d0ff1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_F);
1:14d0ff1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:14d0ff1: 		attributes.put(Constants.IMPORT_PACKAGE, "b;resolution:=optional");
1:14d0ff1: 		createManifest(COMPOSITE_F + ".mf", attributes);
1:14d0ff1: 	}
1:14d0ff1: 	
1:2aab796: 	private void createFeatureA() throws IOException {
1:2aab796: 		createFeatureAManifest();
1:2aab796: 		createSubsystem(FEATURE_A, APPLICATION_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureAManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_A);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:2aab796: 		createManifest(FEATURE_A + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureB() throws IOException {
1:2aab796: 		createFeatureBManifest();
1:2aab796: 		createSubsystem(FEATURE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureBManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_B);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1:2aab796: 		createManifest(FEATURE_B + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureC() throws IOException {
1:2aab796: 		createFeatureCManifest();
1:2aab796: 		createSubsystem(FEATURE_C, COMPOSITE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureCManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_C);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:2aab796: 		createManifest(FEATURE_C + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureD() throws IOException {
1:2aab796: 		createFeatureDManifest();
1:2aab796: 		createSubsystem(FEATURE_D, FEATURE_B);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void createFeatureDManifest() throws IOException {
1:2aab796: 		Map<String, String> attributes = new HashMap<String, String>();
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_D);
1:2aab796: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:2aab796: 		createManifest(FEATURE_D + ".mf", attributes);
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private Repository createTestRepository() throws Exception {
1:2aab796:         return new TestRepository.Builder()
1:2aab796:         .resource(createBundleAResource())
1:2aab796:         .resource(createBundleBResource())
1:2aab796:         .build();
1:2aab796:     }
1:2aab796: 	
1:2aab796: 	private void registerWeavingHook(final String...dynamicImport) {
1:2aab796: 		serviceRegistrations.add(bundleContext.registerService(
1:2aab796:     			WeavingHook.class, 
1:2aab796:     			new WeavingHook() {
1:2aab796:     				@Override
1:2aab796:     				public void weave(WovenClass wovenClass) {
1:2aab796:     					Bundle bundle = wovenClass.getBundleWiring().getBundle();
1:2aab796:     					String symbolicName = bundle.getSymbolicName();
1:2aab796:     					if (BUNDLE_A.equals(symbolicName)) {
1:2aab796:     						weavingHookCalled.set(true);
1:2aab796:     						List<String> dynamicImports = wovenClass.getDynamicImports();
1:2aab796:     						dynamicImports.addAll(Arrays.asList(dynamicImport));
1:2aab796:     					}
1:2aab796:     				}
1:2aab796:     			}, 
1:2aab796:     			null));
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void testDynamicImport(String child, String type, String parent) throws Exception {
1:2aab796: 		testDynamicImport(child, type, parent, "org.osgi.framework");
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void testDynamicImport(String child, String type, String parent, String dynamicImport) throws Exception {
1:2aab796: 		registerWeavingHook(dynamicImport);
1:2aab796: 		Subsystem p = installSubsystemFromFile(parent == null ? child : parent);
1:2aab796: 		try {	
1:2aab796: 			if (parent != null) {
1:2aab796: 				assertChild(p, child, null, type);
1:2aab796: 				final Subsystem s = getConstituentAsSubsystem(p, child, null, type);
1:2aab796: 				testDynamicImport(s);
1:2aab796: 			}
1:2aab796: 			else {
1:2aab796: 				testDynamicImport(p);
1:2aab796: 			}
1:2aab796: 		}
1:2aab796: 		finally {
1:2aab796: 			uninstallSubsystemSilently(p);
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void testDynamicImport(Subsystem subsystem) throws Exception {
1:2aab796: 		testDynamicImport(subsystem, "org.osgi.framework.Constants");
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void testDynamicImport(Subsystem subsystem, String clazz) throws Exception {
1:2aab796: 		assertConstituent(subsystem, BUNDLE_A);
1:2aab796: 		Bundle bundleA = getConstituentAsBundle(subsystem, BUNDLE_A, null, null);
1:2aab796: 		bundleA.loadClass("a.A");
1:2aab796: 		assertTrue("Weaving hook not called", weavingHookCalled.get());
1:2aab796: 		try {
1:2aab796: 			bundleA.loadClass(clazz);
1:2aab796: 		}
1:2aab796: 		catch (ClassNotFoundException e) {
1:2aab796: 			e.printStackTrace();
1:2aab796: 			fail("Dynamic import not visible");
1:2aab796: 		}
1:2aab796: 	}
1:2aab796: 	
1:2aab796: 	private void testSharingPolicy(Subsystem subsystem, String dynamicImport, boolean allowed) {
1:2aab796: 		Region region = getRegion(subsystem);
1:2aab796: 		Set<FilteredRegion> filteredRegions = region.getEdges();
1:2aab796: 		Map<String, Object> map = new HashMap<String, Object>();
1:2aab796: 		map.put(PackageNamespace.PACKAGE_NAMESPACE, dynamicImport);
1:2aab796: 		map.put(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion);
1:2aab796: 		boolean wasAllowed = false;
1:2aab796: 		for (FilteredRegion filteredRegion : filteredRegions) {
1:2aab796: 			RegionFilter filter = filteredRegion.getFilter();
1:2aab796: 			if (allowed) {
1:2aab796: 				if (filter.isAllowed(PackageNamespace.PACKAGE_NAMESPACE, map)) {
1:2aab796: 					wasAllowed = true;
1:2aab796: 					break;
1:2aab796: 				}
1:2aab796: 			}
1:2aab796: 			else {
1:2aab796: 				assertFalse("Sharing policy should not have been updated", 
1:2aab796: 						filter.isAllowed(PackageNamespace.PACKAGE_NAMESPACE, map));
1:2aab796: 			}
1:2aab796: 		}
1:2aab796: 		if (allowed && !wasAllowed) {
1:2aab796: 			fail("Sharing policy should have been updated");
1:2aab796: 		}
1:2aab796: 	}
1:1c027e7: 	
1:1c027e7: 	@Test
1:1c027e7: 	public void testConnectedNonSubsystemRegions() throws Exception {
1:1c027e7: 		registerWeavingHook("b");
1:1c027e7: 		Bundle bundleB = getRootSubsystem().getBundleContext().installBundle(
1:1c027e7: 				BUNDLE_B, new ByteArrayInputStream(createBundleBContent()));
1:1c027e7: 		uninstallableBundles.add(bundleB);
1:1c027e7: 		Subsystem applicationA = installSubsystemFromFile(APPLICATION_A);
1:1c027e7: 		uninstallableSubsystems.add(applicationA);
1:1c027e7: 		Subsystem applicationB = getChild(applicationA, APPLICATION_B);
1:1c027e7: 		uninstallSubsystem(applicationB);
1:1c027e7: 		removeConnectionWithParent(applicationA);
1:1c027e7: 		Region region = getRegion(applicationA);
1:1c027e7: 		RegionDigraph digraph = region.getRegionDigraph();
1:1c027e7: 		Region r1 = digraph.createRegion("R1");
1:1c027e7: 		deletableRegions.add(r1);
1:1c027e7: 		region.connectRegion(r1, digraph.createRegionFilterBuilder().allow("y", "(y=x)").build());
1:1c027e7: 		Region r2a = digraph.createRegion("R2A");
1:1c027e7: 		deletableRegions.add(r2a);
1:1c027e7: 		Bundle bundleB1 = r2a.installBundleAtLocation(BUNDLE_B + '1', new ByteArrayInputStream(createBundleBContent()));
1:1c027e7: 		uninstallableBundles.add(bundleB1);
1:1c027e7: 		Region r2b = digraph.createRegion("R2B");
1:1c027e7: 		deletableRegions.add(r2b);
1:1c027e7: 		r2b.connectRegion(r2a, digraph.createRegionFilterBuilder().allow("osgi.wiring.package", "(&(osgi.wiring.package=b)(version=0))").build());
1:1c027e7: 		region.connectRegion(r2b, digraph.createRegionFilterBuilder().allow("osgi.wiring.package", "(&(osgi.wiring.package=b)(version=0))").build());
1:1c027e7: 		applicationB = installSubsystemFromFile(applicationA, APPLICATION_B);
1:1c027e7: 		uninstallableSubsystems.add(applicationB);
1:1c027e7: 		try {
1:1c027e7: 			testDynamicImport(applicationB, "b.B");
1:1c027e7: 		}
1:1c027e7: 		catch (AssertionError e) {
1:1c027e7: 			fail("Dynamic import should have succeeded");
1:1c027e7: 		}
1:1c027e7: 		testSharingPolicy(applicationB, "b", true);
1:1c027e7: 		testSharingPolicy(applicationA, "b", true);
1:1c027e7: 		testSharingPolicy(getRootSubsystem(), "b", false);
1:1c027e7: 	}
1:2aab796: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:1c027e7
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.equinox.region.RegionDigraph;
/////////////////////////////////////////////////////////////////////////
1: 			uninstallSilently(bundleB);
/////////////////////////////////////////////////////////////////////////
1: 				uninstallSilently(bundleB);
/////////////////////////////////////////////////////////////////////////
1: 				uninstallSilently(bundleB);
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Test
1: 	public void testConnectedNonSubsystemRegions() throws Exception {
1: 		registerWeavingHook("b");
1: 		Bundle bundleB = getRootSubsystem().getBundleContext().installBundle(
1: 				BUNDLE_B, new ByteArrayInputStream(createBundleBContent()));
1: 		uninstallableBundles.add(bundleB);
1: 		Subsystem applicationA = installSubsystemFromFile(APPLICATION_A);
1: 		uninstallableSubsystems.add(applicationA);
1: 		Subsystem applicationB = getChild(applicationA, APPLICATION_B);
1: 		uninstallSubsystem(applicationB);
1: 		removeConnectionWithParent(applicationA);
1: 		Region region = getRegion(applicationA);
1: 		RegionDigraph digraph = region.getRegionDigraph();
1: 		Region r1 = digraph.createRegion("R1");
1: 		deletableRegions.add(r1);
1: 		region.connectRegion(r1, digraph.createRegionFilterBuilder().allow("y", "(y=x)").build());
1: 		Region r2a = digraph.createRegion("R2A");
1: 		deletableRegions.add(r2a);
1: 		Bundle bundleB1 = r2a.installBundleAtLocation(BUNDLE_B + '1', new ByteArrayInputStream(createBundleBContent()));
1: 		uninstallableBundles.add(bundleB1);
1: 		Region r2b = digraph.createRegion("R2B");
1: 		deletableRegions.add(r2b);
1: 		r2b.connectRegion(r2a, digraph.createRegionFilterBuilder().allow("osgi.wiring.package", "(&(osgi.wiring.package=b)(version=0))").build());
1: 		region.connectRegion(r2b, digraph.createRegionFilterBuilder().allow("osgi.wiring.package", "(&(osgi.wiring.package=b)(version=0))").build());
1: 		applicationB = installSubsystemFromFile(applicationA, APPLICATION_B);
1: 		uninstallableSubsystems.add(applicationB);
1: 		try {
1: 			testDynamicImport(applicationB, "b.B");
1: 		}
1: 		catch (AssertionError e) {
1: 			fail("Dynamic import should have succeeded");
1: 		}
1: 		testSharingPolicy(applicationB, "b", true);
1: 		testSharingPolicy(applicationA, "b", true);
1: 		testSharingPolicy(getRootSubsystem(), "b", false);
1: 	}
commit:14d0ff1
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import java.io.File;
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
1: 	private static final String COMPOSITE_F = "composite.f.esa";
/////////////////////////////////////////////////////////////////////////
1: 		createCompositeF();
/////////////////////////////////////////////////////////////////////////
1: 	@Test
1: 	public void testWovenSubsystemParentPolicyAllowsProvider() throws Exception {
1: 		registerWeavingHook("b");
1: 		Subsystem root = getRootSubsystem();
1: 		BundleContext context = root.getBundleContext();
1: 		Bundle bundleB = context.installBundle(BUNDLE_B, new ByteArrayInputStream(createBundleBContent()));
1: 		try {
1: 			Subsystem applicationB1 = installSubsystemFromFile(root, new File(APPLICATION_B), APPLICATION_B + "1");
1: 			try {
1: 				Subsystem compositeF = installSubsystemFromFile(applicationB1, COMPOSITE_F);
1: 				try {
1: 					assertPackageFiltersInParentConnection(compositeF, applicationB1, 2, 1);
1: 					Subsystem applicationB2 = installSubsystemFromFile(compositeF, new File(APPLICATION_B), APPLICATION_B + "2");
1: 					try {
1: 						testDynamicImport(applicationB2, "b.B");
1: 						testSharingPolicy(applicationB2, "b", true);
1: 						testSharingPolicy(compositeF, "b", true);
1: 						assertPackageFiltersInParentConnection(compositeF, applicationB1, 2, 1);
1: 						testSharingPolicy(applicationB1, "b", true);
1: 						testSharingPolicy(root, "b", false);
1: 					}
1: 					finally {
1: 						uninstallSubsystemSilently(applicationB2);
1: 					}
1: 				}
1: 				finally {
1: 					uninstallSubsystemSilently(compositeF);
1: 				}
1: 			}
1: 			finally {
1: 				uninstallSubsystemSilently(applicationB1);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSilently(bundleB);
1: 		}
1: 	}
1: 	
1: 	private void assertPackageFiltersInParentConnection(Subsystem subsystem, Subsystem parent, int expectedEdges, int expectedFilters) {
1: 		Region parentRegion = getRegion(parent);
1: 		Region region = getRegion(subsystem);
1: 		Set<FilteredRegion> edges = region.getEdges();
1: 		assertEquals("Wrong number of edges", expectedEdges, edges.size());
1: 		for (FilteredRegion edge : region.getEdges()) {
1: 			if (!edge.getRegion().equals(parentRegion)) {
1: 				continue;
1: 			}
1: 			RegionFilter filter = edge.getFilter();
1: 			Map<String, Collection<String>> policy = filter.getSharingPolicy();
1: 			Collection<String> packages = policy.get(PackageNamespace.PACKAGE_NAMESPACE);
1: 			assertNotNull("Wrong number of packages", packages);
1: 			assertEquals("Wrong number of packages", expectedFilters, packages.size());
1: 			return;
1: 		}
1: 		fail("No connection to parent found");
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	private void createCompositeF() throws IOException {
1: 		createCompositeFManifest();
1: 		createSubsystem(COMPOSITE_F);
1: 	}
1: 	
1: 	private void createCompositeFManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_F);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		attributes.put(Constants.IMPORT_PACKAGE, "b;resolution:=optional");
1: 		createManifest(COMPOSITE_F + ".mf", attributes);
1: 	}
1: 	
commit:2aab796
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.subsystem.itests.defect;
1: 
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.util.Arrays;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import org.apache.aries.subsystem.itests.SubsystemTest;
1: import org.apache.aries.subsystem.itests.util.TestCapability;
1: import org.apache.aries.subsystem.itests.util.TestRepository;
1: import org.apache.aries.subsystem.itests.util.TestRepositoryContent;
1: import org.eclipse.equinox.region.Region;
1: import org.eclipse.equinox.region.RegionDigraph.FilteredRegion;
1: import org.eclipse.equinox.region.RegionFilter;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.ops4j.pax.tinybundles.core.InnerClassStrategy;
1: import org.ops4j.pax.tinybundles.core.TinyBundles;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Version;
1: import org.osgi.framework.hooks.weaving.WeavingHook;
1: import org.osgi.framework.hooks.weaving.WovenClass;
1: import org.osgi.framework.namespace.IdentityNamespace;
1: import org.osgi.framework.namespace.PackageNamespace;
1: import org.osgi.resource.Resource;
1: import org.osgi.service.repository.Repository;
1: import org.osgi.service.subsystem.Subsystem;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: 
1: /*
1:  * https://issues.apache.org/jira/browse/ARIES-1435
1:  * 
1:  * Sharing policy updates for dynamic imports, if necessary, should proceed up 
1:  * the subsystem region tree.
1:  */
1: public class Aries1435Test extends SubsystemTest {
1: 	private static final String APPLICATION_A = "application.a.esa";
1: 	private static final String APPLICATION_B = "application.b.esa";
1: 	private static final String APPLICATION_C = "application.c.esa";
1: 	private static final String APPLICATION_D = "application.d.esa";
1: 	private static final String APPLICATION_E = "application.e.esa";
1: 	private static final String BUNDLE_A = "bundle.a.jar";
1: 	private static final String BUNDLE_B = "bundle.b.jar";
1: 	private static final String COMPOSITE_A = "composite.a.esa";
1: 	private static final String COMPOSITE_B = "composite.b.esa";
1: 	private static final String COMPOSITE_C = "composite.c.esa";
1: 	private static final String COMPOSITE_D = "composite.d.esa";
1: 	private static final String COMPOSITE_E = "composite.e.esa";
1: 	private static final String FEATURE_A = "feature.a.esa";
1: 	private static final String FEATURE_B = "feature.b.esa";
1: 	private static final String FEATURE_C = "feature.c.esa";
1: 	private static final String FEATURE_D = "feature.d.esa";
1: 	
1: 	private static boolean createdTestFiles;
1: 	@Before
1: 	public void createTestFiles() throws Exception {
1: 		if (createdTestFiles)
1: 			return;
1: 		createApplicationB();
1: 		createApplicationA();	
1: 		createCompositeA();
1: 		createCompositeB();
1: 		createApplicationC();
1: 		createFeatureA();
1: 		createFeatureB();
1: 		createApplicationD();
1: 		createCompositeC();
1: 		createFeatureC();
1: 		createCompositeD();
1: 		createFeatureD();
1: 		createApplicationE();
1: 		createCompositeE();
1: 		createdTestFiles = true;
1: 	}
1: 	
1: 	private AtomicBoolean weavingHookCalled;
1: 	@Override
1:     public void setUp() throws Exception {
1:         super.setUp();
1:         try {
1:             serviceRegistrations.add(
1:                     bundleContext.registerService(
1:                             Repository.class, 
1:                             createTestRepository(), 
1:                             null));
1:         }
1:         catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:         weavingHookCalled = new AtomicBoolean();
1:     }
1: 	
1: 	@Test
1:     public void testApplicationWithParentApplication() throws Exception {
1: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, APPLICATION_A);
1:     }
1: 	
1: 	@Test
1:     public void testApplicationWithParentComposite() throws Exception {
1: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, COMPOSITE_A);
1:     }
1: 	
1: 	@Test
1:     public void testApplicationWithParentFeature() throws Exception {
1: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, FEATURE_A);
1:     }
1: 	
1: 	@Test
1:     public void testApplicationWithParentRoot() throws Exception {
1: 		testDynamicImport(APPLICATION_B, SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, null);
1:     }
1: 	
1: 	@Test
1: 	public void testChildExportsPackage() throws Exception {
1: 		registerWeavingHook("b");
1: 		Subsystem applicationB = installSubsystemFromFile(APPLICATION_B);
1: 		try {
1: 			Subsystem compositeE = installSubsystemFromFile(applicationB, COMPOSITE_E);
1: 			try {
1: 				startSubsystem(compositeE);
1: 				try {
1: 					testSharingPolicy(applicationB, "b", true);
1: 					testDynamicImport(applicationB, "b.B");
1: 					testSharingPolicy(applicationB, "b", true);
1: 					testSharingPolicy(compositeE, "b", false);
1: 					testSharingPolicy(getRootSubsystem(), "b", false);
1: 				}
1: 				finally {
1: 					stopSubsystemSilently(compositeE);
1: 				}
1: 			}
1: 			finally {
1: 				uninstallSubsystemSilently(compositeE);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(applicationB);
1: 		}
1: 	}
1: 	
1: 	@Test
1:     public void testCompositeWithParentApplication() throws Exception {
1: 		testDynamicImport(COMPOSITE_B, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE, APPLICATION_C);
1:     }
1: 	
1: 	@Test
1:     public void testCompositeWithParentComposite() throws Exception {
1: 		testDynamicImport(COMPOSITE_B, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE, COMPOSITE_C);
1:     }
1: 	
1: 	@Test
1:     public void testCompositeWithParentFeature() throws Exception {
1: 		testDynamicImport(COMPOSITE_B, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE, FEATURE_C);
1:     }
1: 	
1: 	@Test
1: 	public void testDisconnectedEdgeWithParent() throws Exception {
1: 		registerWeavingHook("b");
1: 		Bundle bundleB = getRootSubsystem().getBundleContext().installBundle(
1: 				BUNDLE_B, new ByteArrayInputStream(createBundleBContent()));
1: 		try {
1: 			Subsystem applicationA = installSubsystemFromFile(APPLICATION_A);
1: 			try {
1: 				Subsystem applicationB = getChild(applicationA, APPLICATION_B);
1: 				uninstallSubsystem(applicationB);
1: 				removeConnectionWithParent(applicationA);
1: 				applicationB = installSubsystemFromFile(applicationA, APPLICATION_B);
1: 				try {
1: 					try {
1: 						testDynamicImport(applicationB, "b.B");
1: 						fail("Dynamic import should have failed");
1: 					}
1: 					catch (AssertionError e) {
1: 						// Okay.
1: 					}
1: 					testSharingPolicy(applicationB, "b", true);
1: 					testSharingPolicy(applicationA, "b", false);
1: 					testSharingPolicy(getRootSubsystem(), "b", false);
1: 				}
1: 				finally {
1: 					uninstallSubsystemSilently(applicationB);
1: 				}
1: 			}
1: 			finally {
1: 				uninstallSubsystemSilently(applicationA);
1: 			}
1: 		}
1: 		finally {
0: 			bundleB.uninstall();
1: 		}
1: 	}
1: 	
1: 	@Test
1:     public void testFeatureWithParentApplication() throws Exception {
1: 		testDynamicImport(FEATURE_B, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE, APPLICATION_D);
1:     }
1: 	
1: 	@Test
1:     public void testFeatureWithParentComposite() throws Exception {
1: 		testDynamicImport(FEATURE_B, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE, COMPOSITE_D);
1:     }
1: 	
1: 	@Test
1:     public void testFeatureWithParentFeature() throws Exception {
1: 		testDynamicImport(FEATURE_B, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE, FEATURE_D);
1:     }
1: 	
1: 	@Test
1: 	public void testNoProviders() throws Exception {
1: 		registerWeavingHook("b");
1: 		Subsystem applicationB = installSubsystemFromFile(APPLICATION_B);
1: 		try {
1: 			Bundle bundleA = getConstituentAsBundle(applicationB, BUNDLE_A, null, null);
1: 			bundleA.loadClass("a.A");
1: 			try {
1: 				bundleA.loadClass("b.B");
1: 				fail("Class should not have loaded");
1: 			}
1: 			catch (ClassNotFoundException e) {
1: 				// Okay.
1: 			}
1: 			testSharingPolicy(applicationB, "b", false);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(applicationB);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testWildcardEverything() throws Exception {
1: 		registerWeavingHook("b", "*");
1: 		Subsystem compositeB = installSubsystemFromFile(COMPOSITE_B);
1: 		try {
1: 			Bundle bundleB = compositeB.getBundleContext().installBundle(
1: 					BUNDLE_B, 
1: 					new ByteArrayInputStream(createBundleBContent()));
1: 			try {
1: 				Subsystem applicationB = installSubsystemFromFile(compositeB, APPLICATION_B);
1: 				Subsystem featureB = installSubsystemFromFile(applicationB, FEATURE_B);
1: 				Subsystem applicationE = installSubsystemFromFile(featureB, APPLICATION_E);
1: 				
1: 				testSharingPolicy(applicationE, "b", false);
1: 				testSharingPolicy(applicationE, "org.osgi.framework.Constants", false);
1: 				testSharingPolicy(applicationB, "b", false);
1: 				testSharingPolicy(applicationB, "org.osgi.framework.Constants", false);
1: 				testSharingPolicy(compositeB, "b", false);
1: 				testSharingPolicy(compositeB, "org.osgi.framework.Constants", false);
1: 				testSharingPolicy(getRootSubsystem(), "b", false);
1: 				testSharingPolicy(getRootSubsystem(), "org.osgi.framework.Constants", false);
1: 				
1: 				testDynamicImport(applicationE, "b.B");
1: 				testDynamicImport(applicationE, "org.osgi.framework.Constants");
1: 				testDynamicImport(featureB, "b.B");
1: 				testDynamicImport(featureB, "org.osgi.framework.Constants");
1: 				testDynamicImport(applicationB, "b.B");
1: 				testDynamicImport(applicationB, "org.osgi.framework.Constants");
1: 				testDynamicImport(compositeB, "b.B");
1: 				testDynamicImport(compositeB, "org.osgi.framework.Constants");
1: 				
1: 				testSharingPolicy(applicationE, "b", true);
1: 				testSharingPolicy(applicationE, "org.osgi.framework.Constants", true);
1: 				testSharingPolicy(applicationB, "b", true);
1: 				testSharingPolicy(applicationB, "org.osgi.framework.Constants", true);
1: 				testSharingPolicy(compositeB, "b", true);
1: 				testSharingPolicy(compositeB, "org.osgi.framework.Constants", true);
1: 				testSharingPolicy(getRootSubsystem(), "b", false);
1: 				testSharingPolicy(getRootSubsystem(), "org.osgi.framework.Constants", false);
1: 				
1: 				uninstallSubsystemSilently(applicationE);
1: 				uninstallSubsystemSilently(featureB);
1: 				uninstallSubsystemSilently(applicationB);
1: 			}
1: 			finally {
0: 				bundleB.uninstall();
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(compositeB);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testWildcardEverythingInPackage() throws Exception {
1: 		registerWeavingHook("b.*");
1: 		Subsystem applicationA = installSubsystemFromFile(APPLICATION_A);
1: 		try {
1: 			Bundle bundleB = applicationA.getBundleContext().installBundle(
1: 					BUNDLE_B, 
1: 					new ByteArrayInputStream(createBundleBContent()));
1: 			try {
1: 				Subsystem applicationB = getChild(applicationA, APPLICATION_B);
1: 				
1: 				testSharingPolicy(applicationB, "b", false);
1: 				testSharingPolicy(applicationB, "b.a", false);
1: 				testSharingPolicy(applicationA, "b", false);
1: 				testSharingPolicy(applicationA, "b.a", false);
1: 				testSharingPolicy(getRootSubsystem(), "b", false);
1: 				testSharingPolicy(getRootSubsystem(), "b.a", false);
1: 				
1: 				testDynamicImport(applicationB, "b.a.A");
1: 				
1: 				testSharingPolicy(applicationB, "b", false);
1: 				testSharingPolicy(applicationB, "b.a", true);
1: 				testSharingPolicy(applicationA, "b", false);
1: 				testSharingPolicy(applicationA, "b.a", true);
1: 				testSharingPolicy(getRootSubsystem(), "b", false);
1: 				testSharingPolicy(getRootSubsystem(), "b.a", false);
1: 			}
1: 			finally {
0: 				bundleB.uninstall();
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(applicationA);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testWovenSubsystemContainsProvider() throws Exception {
1: 		registerWeavingHook("b");
1: 		Subsystem applicationE = installSubsystemFromFile(APPLICATION_E);
1: 		try {
1: 			assertConstituent(applicationE, BUNDLE_B);
1: 			testDynamicImport(applicationE, "b.B");
1: 			testSharingPolicy(applicationE, "b", false);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(applicationE);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testWovenSubsystemParentContainsProvider() throws Exception {
1: 		registerWeavingHook("b");
1: 		Subsystem compositeE = installSubsystemFromFile(COMPOSITE_E);
1: 		try {
1: 			assertNotConstituent(getRootSubsystem(), BUNDLE_B);
1: 			assertConstituent(compositeE, BUNDLE_B);
1: 			Subsystem applicationB = getChild(compositeE, APPLICATION_B);
1: 			assertNotConstituent(applicationB, BUNDLE_B);
1: 			testDynamicImport(applicationB, "b.B");
1: 			testSharingPolicy(compositeE, "b", false);
1: 			testSharingPolicy(applicationB, "b", true);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(compositeE);
1: 		}
1: 	}
1: 	
1: 	private void createApplicationA() throws IOException {
1: 		createApplicationAManifest();
1: 		createSubsystem(APPLICATION_A, APPLICATION_B);
1: 	}
1: 	
1: 	private void createApplicationAManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_A);
1: 		createManifest(APPLICATION_A + ".mf", attributes);
1: 	}
1: 	
1: 	private void createApplicationB() throws IOException {
1: 		createApplicationBManifest();
1: 		createSubsystem(APPLICATION_B);
1: 	}
1: 	
1: 	private void createApplicationBManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_B);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1: 		createManifest(APPLICATION_B + ".mf", attributes);
1: 	}
1: 	
1: 	private void createApplicationC() throws IOException {
1: 		createApplicationCManifest();
1: 		createSubsystem(APPLICATION_C, COMPOSITE_B);
1: 	}
1: 	
1: 	private void createApplicationCManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_C);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, COMPOSITE_B + ";type=osgi.subsystem.composite");
1: 		createManifest(APPLICATION_C + ".mf", attributes);
1: 	}
1: 	
1: 	private void createApplicationD() throws IOException {
1: 		createApplicationDManifest();
1: 		createSubsystem(APPLICATION_D, FEATURE_B);
1: 	}
1: 	
1: 	private void createApplicationDManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_D);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, FEATURE_B + ";type=osgi.subsystem.feature");
1: 		createManifest(APPLICATION_D + ".mf", attributes);
1: 	}
1: 	
1: 	private void createApplicationE() throws IOException {
1: 		createApplicationEManifest();
1: 		createSubsystem(APPLICATION_E);
1: 	}
1: 	
1: 	private void createApplicationEManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_E);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ',' + BUNDLE_B);
1: 		createManifest(APPLICATION_E + ".mf", attributes);
1: 	}
1: 	
1: 	private byte[] createBundleAContent() throws Exception {
1:         InputStream is = TinyBundles
1:         		.bundle()
1:         		.add(getClass().getClassLoader().loadClass("a.A"), InnerClassStrategy.NONE)
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_A)
1: 				.build(TinyBundles.withBnd());
1:         return createBundleContent(is);
1:     }
1: 	
1: 	private Resource createBundleAResource() throws Exception {
1:         return new TestRepositoryContent.Builder()
1:         .capability(
1:                 new TestCapability.Builder()
1:                     .namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:                     .attribute(IdentityNamespace.IDENTITY_NAMESPACE, BUNDLE_A)
1:                     .attribute(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE, IdentityNamespace.TYPE_BUNDLE)
1:                     .attribute(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:         .content(createBundleAContent())
1:         .build();
1:     }
1: 	
1: 	private byte[] createBundleBContent() throws Exception {
1:         InputStream is = TinyBundles
1:         		.bundle()
1:         		.add(getClass().getClassLoader().loadClass("b.B"), InnerClassStrategy.NONE)
1:         		.add(getClass().getClassLoader().loadClass("b.a.A"), InnerClassStrategy.NONE)
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_B)
1: 				.set(Constants.EXPORT_PACKAGE, "b,b.a")
1: 				.build(TinyBundles.withBnd());
1:         return createBundleContent(is);
1:     }
1: 	
1: 	private byte[] createBundleContent(InputStream is) throws Exception {
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		byte[] bytes = new byte[1024];
1:         int length;
1:         while ((length = is.read(bytes)) != -1) {
1:         	baos.write(bytes, 0, length);
1:         }
1:         is.close();
1:         baos.close();
1:         return baos.toByteArray();
1: 	}
1: 	
1: 	private Resource createBundleBResource() throws Exception {
1:         return new TestRepositoryContent.Builder()
1:         .capability(
1:                 new TestCapability.Builder()
1:                     .namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:                     .attribute(IdentityNamespace.IDENTITY_NAMESPACE, BUNDLE_B)
1:                     .attribute(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE, IdentityNamespace.TYPE_BUNDLE)
1:                     .attribute(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:         .capability(
1:         		new TestCapability.Builder()
1:         			.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:         			.attribute(PackageNamespace.PACKAGE_NAMESPACE, "b")
1:         			.attribute(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:         .capability(
1:         		new TestCapability.Builder()
1:         			.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:         			.attribute(PackageNamespace.PACKAGE_NAMESPACE, "b.a")
1:         			.attribute(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion))
1:         .content(createBundleBContent())
1:         .build();
1:     }
1: 	
1: 	private void createCompositeA() throws IOException {
1: 		createCompositeAManifest();
1: 		createSubsystem(COMPOSITE_A, APPLICATION_B);
1: 	}
1: 	
1: 	private void createCompositeAManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_A);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, APPLICATION_B + 
1: 				";type=osgi.subsystem.application;version=\"[0,0]\"");
1: 		createManifest(COMPOSITE_A + ".mf", attributes);
1: 	}
1: 	
1: 	private void createCompositeB() throws IOException {
1: 		createCompositeBManifest();
1: 		createSubsystem(COMPOSITE_B);
1: 	}
1: 	
1: 	private void createCompositeBManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_B);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ";version=\"[0,0]\"");
1: 		createManifest(COMPOSITE_B + ".mf", attributes);
1: 	}
1: 	
1: 	private void createCompositeC() throws IOException {
1: 		createCompositeCManifest();
1: 		createSubsystem(COMPOSITE_C, COMPOSITE_B);
1: 	}
1: 	
1: 	private void createCompositeCManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_C);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, COMPOSITE_B + ";type=osgi.subsystem.composite;version=\"[0,0]\"");
1: 		createManifest(COMPOSITE_C + ".mf", attributes);
1: 	}
1: 	
1: 	private void createCompositeD() throws IOException {
1: 		createCompositeDManifest();
1: 		createSubsystem(COMPOSITE_D, FEATURE_B);
1: 	}
1: 	
1: 	private void createCompositeDManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_D);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, FEATURE_B + ";type=osgi.subsystem.feature;version=\"[0,0]\"");
1: 		createManifest(COMPOSITE_D + ".mf", attributes);
1: 	}
1: 	
1: 	private void createCompositeE() throws IOException {
1: 		createCompositeEManifest();
1: 		createSubsystem(COMPOSITE_E, APPLICATION_B);
1: 	}
1: 	
1: 	private void createCompositeEManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_E);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, APPLICATION_B + 
1: 				";type=osgi.subsystem.application;version=\"[0,0]\"," +
1: 				BUNDLE_B + ";version=\"[0,0]\"");
1: 		attributes.put(Constants.EXPORT_PACKAGE, "b");
1: 		createManifest(COMPOSITE_E + ".mf", attributes);
1: 	}
1: 	
1: 	private void createFeatureA() throws IOException {
1: 		createFeatureAManifest();
1: 		createSubsystem(FEATURE_A, APPLICATION_B);
1: 	}
1: 	
1: 	private void createFeatureAManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_A);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		createManifest(FEATURE_A + ".mf", attributes);
1: 	}
1: 	
1: 	private void createFeatureB() throws IOException {
1: 		createFeatureBManifest();
1: 		createSubsystem(FEATURE_B);
1: 	}
1: 	
1: 	private void createFeatureBManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_B);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1: 		createManifest(FEATURE_B + ".mf", attributes);
1: 	}
1: 	
1: 	private void createFeatureC() throws IOException {
1: 		createFeatureCManifest();
1: 		createSubsystem(FEATURE_C, COMPOSITE_B);
1: 	}
1: 	
1: 	private void createFeatureCManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_C);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		createManifest(FEATURE_C + ".mf", attributes);
1: 	}
1: 	
1: 	private void createFeatureD() throws IOException {
1: 		createFeatureDManifest();
1: 		createSubsystem(FEATURE_D, FEATURE_B);
1: 	}
1: 	
1: 	private void createFeatureDManifest() throws IOException {
1: 		Map<String, String> attributes = new HashMap<String, String>();
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_D);
1: 		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		createManifest(FEATURE_D + ".mf", attributes);
1: 	}
1: 	
1: 	private Repository createTestRepository() throws Exception {
1:         return new TestRepository.Builder()
1:         .resource(createBundleAResource())
1:         .resource(createBundleBResource())
1:         .build();
1:     }
1: 	
1: 	private void registerWeavingHook(final String...dynamicImport) {
1: 		serviceRegistrations.add(bundleContext.registerService(
1:     			WeavingHook.class, 
1:     			new WeavingHook() {
1:     				@Override
1:     				public void weave(WovenClass wovenClass) {
1:     					Bundle bundle = wovenClass.getBundleWiring().getBundle();
1:     					String symbolicName = bundle.getSymbolicName();
1:     					if (BUNDLE_A.equals(symbolicName)) {
1:     						weavingHookCalled.set(true);
1:     						List<String> dynamicImports = wovenClass.getDynamicImports();
1:     						dynamicImports.addAll(Arrays.asList(dynamicImport));
1:     					}
1:     				}
1:     			}, 
1:     			null));
1: 	}
1: 	
1: 	private void testDynamicImport(String child, String type, String parent) throws Exception {
1: 		testDynamicImport(child, type, parent, "org.osgi.framework");
1: 	}
1: 	
1: 	private void testDynamicImport(String child, String type, String parent, String dynamicImport) throws Exception {
1: 		registerWeavingHook(dynamicImport);
1: 		Subsystem p = installSubsystemFromFile(parent == null ? child : parent);
1: 		try {	
1: 			if (parent != null) {
1: 				assertChild(p, child, null, type);
1: 				final Subsystem s = getConstituentAsSubsystem(p, child, null, type);
1: 				testDynamicImport(s);
1: 			}
1: 			else {
1: 				testDynamicImport(p);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(p);
1: 		}
1: 	}
1: 	
1: 	private void testDynamicImport(Subsystem subsystem) throws Exception {
1: 		testDynamicImport(subsystem, "org.osgi.framework.Constants");
1: 	}
1: 	
1: 	private void testDynamicImport(Subsystem subsystem, String clazz) throws Exception {
1: 		assertConstituent(subsystem, BUNDLE_A);
1: 		Bundle bundleA = getConstituentAsBundle(subsystem, BUNDLE_A, null, null);
1: 		bundleA.loadClass("a.A");
1: 		assertTrue("Weaving hook not called", weavingHookCalled.get());
1: 		try {
1: 			bundleA.loadClass(clazz);
1: 		}
1: 		catch (ClassNotFoundException e) {
1: 			e.printStackTrace();
1: 			fail("Dynamic import not visible");
1: 		}
1: 	}
1: 	
1: 	private void testSharingPolicy(Subsystem subsystem, String dynamicImport, boolean allowed) {
1: 		Region region = getRegion(subsystem);
1: 		Set<FilteredRegion> filteredRegions = region.getEdges();
1: 		Map<String, Object> map = new HashMap<String, Object>();
1: 		map.put(PackageNamespace.PACKAGE_NAMESPACE, dynamicImport);
1: 		map.put(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion);
1: 		boolean wasAllowed = false;
1: 		for (FilteredRegion filteredRegion : filteredRegions) {
1: 			RegionFilter filter = filteredRegion.getFilter();
1: 			if (allowed) {
1: 				if (filter.isAllowed(PackageNamespace.PACKAGE_NAMESPACE, map)) {
1: 					wasAllowed = true;
1: 					break;
1: 				}
1: 			}
1: 			else {
1: 				assertFalse("Sharing policy should not have been updated", 
1: 						filter.isAllowed(PackageNamespace.PACKAGE_NAMESPACE, map));
1: 			}
1: 		}
1: 		if (allowed && !wasAllowed) {
1: 			fail("Sharing policy should have been updated");
1: 		}
1: 	}
1: }
============================================================================