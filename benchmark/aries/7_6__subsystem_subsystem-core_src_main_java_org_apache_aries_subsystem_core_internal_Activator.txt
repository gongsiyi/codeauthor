1:e6bf465: /*
1:c84d925:  * Licensed under the Apache License, Version 2.0 (the "License");
1:c84d925:  * you may not use this file except in compliance with the License.
1:c84d925:  * You may obtain a copy of the License at
1:c84d925:  *
1:c84d925:  *      http://www.apache.org/licenses/LICENSE-2.0
1:c84d925:  *
1:c84d925:  * Unless required by applicable law or agreed to in writing, software
1:c84d925:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c84d925:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c84d925:  * See the License for the specific language governing permissions and
1:c84d925:  * limitations under the License.
1:e6bf465:  */
1:c84d925: package org.apache.aries.subsystem.core.internal;
1:d299aa1: 
1:3e4b2d5: import java.util.Collection;
1:3e4b2d5: import java.util.Collections;
1:28c3eb7: import java.util.Dictionary;
1:3e4b2d5: import java.util.HashSet;
1:28c3eb7: import java.util.Hashtable;
1:1c9c28b: 
1:79b20bc: import org.apache.aries.subsystem.ContentHandler;
1:79b20bc: import org.apache.aries.subsystem.core.content.ConfigAdminContentHandler;
1:69d4847: import org.apache.aries.util.filesystem.IDirectoryFinder;
1:3e4b2d5: import org.eclipse.equinox.region.RegionDigraph;
1:c84d925: import org.osgi.framework.BundleActivator;
1:c84d925: import org.osgi.framework.BundleContext;
1:3e4b2d5: import org.osgi.framework.Filter;
1:3e4b2d5: import org.osgi.framework.FrameworkUtil;
1:3e4b2d5: import org.osgi.framework.InvalidSyntaxException;
1:3e4b2d5: import org.osgi.framework.ServiceReference;
1:c84d925: import org.osgi.framework.ServiceRegistration;
1:28c3eb7: import org.osgi.framework.hooks.bundle.EventHook;
1:b2314ac: import org.osgi.framework.hooks.resolver.ResolverHookFactory;
1:3e4b2d5: import org.osgi.service.coordinator.Coordinator;
1:23d86e6: import org.osgi.service.resolver.Resolver;
1:3e4b2d5: import org.osgi.util.tracker.ServiceTracker;
1:3e4b2d5: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1:6490c01: import org.slf4j.Logger;
1:6490c01: import org.slf4j.LoggerFactory;
1:1c9c28b: 
1:c84d925: /**
1:b2314ac:  * The bundle activator for the this bundle. When the bundle is starting, this
1:b2314ac:  * activator will create and register the SubsystemAdmin service.
1:3a1dcd7:  */
1:3e4b2d5: public class Activator implements BundleActivator, ServiceTrackerCustomizer<Object, Object> {
1:1c9c28b:     private static final Logger logger = LoggerFactory.getLogger(Activator.class);
1:9bba779:     public static final String MODELLED_RESOURCE_MANAGER = "org.apache.aries.application.modelling.ModelledResourceManager";
1:279dba5:     private static final String LOCK_TIMEOUT = "org.apache.aries.subsystem.lock.timeout";
1:1c9c28b: 
1:9bba779:     public static final String LOG_ENTRY = "Method entry: {}, args {}";
1:9bba779:     public static final String LOG_EXIT = "Method exit: {}, returning {}";
1:1c9c28b: 
1:3aebecb:     private static volatile Activator instance;
1:3aebecb: 	public static Activator getInstance() {
1:3aebecb: 	    Activator result = instance;
1:3aebecb: 	    if (result == null)
1:3aebecb:             throw new IllegalStateException("The activator has not been initialized or has been shutdown");
1:3aebecb: 		return result;
1:d299aa1: 	}
1:9df8274: 	
1:7b50945: 	private volatile BundleContext bundleContext;
1:279dba5: 	private volatile LockingStrategy lockingStrategy;
1:79b20bc:     private volatile ConfigAdminContentHandler configAdminHandler;
1:3e4b2d5: 	private volatile Coordinator coordinator;
1:9bba779:     private volatile Object modelledResourceManager;
1:9df8274:     private volatile RegionDigraph regionDigraph;
1:3e4b2d5: 	private volatile SubsystemServiceRegistrar registrar;
1:3e4b2d5: 	private volatile Resolver resolver;
1:9df8274: 	private volatile ServiceModeller serviceModeller;
1:9df8274: 	private volatile Subsystems subsystems;
1:9df8274: 	private volatile SystemRepositoryManager systemRepositoryManager;
1:9df8274: 	
1:9df8274: 	private BundleEventHook bundleEventHook;
1:3e4b2d5: 	private ServiceTracker<?,?> serviceTracker;
1:74ef56e: 
1:69d4847: 	private final Collection<IDirectoryFinder> finders = Collections.synchronizedSet(new HashSet<IDirectoryFinder>());
1:9df8274: 	private final Collection<ServiceRegistration<?>> registrations = new HashSet<ServiceRegistration<?>>();
1:9df8274: 	
1:3e4b2d5: 	public BundleContext getBundleContext() {
1:3e4b2d5: 		return bundleContext;
1:3e4b2d5: 	}
1:3e4b2d5: 
1:279dba5: 	public LockingStrategy getLockingStrategy() {
1:279dba5: 		return lockingStrategy;
1:279dba5: 	}
1:279dba5: 
1:3e4b2d5: 	public Coordinator getCoordinator() {
1:3e4b2d5: 		return coordinator;
1:b75f264: 	}
1:b75f264: 
1:9bba779:     public ServiceModeller getServiceModeller() {
1:9bba779:         return serviceModeller;
1:3e4b2d5:     }
1:3e4b2d5: 
1:3e4b2d5:     public RegionDigraph getRegionDigraph() {
1:3e4b2d5: 		return regionDigraph;
1:3e4b2d5: 	}
1:3e4b2d5: 
1:69d4847: 	public Collection<IDirectoryFinder> getIDirectoryFinders() {
1:69d4847: 		return Collections.unmodifiableCollection(finders);
1:3e4b2d5: 	}
1:3e4b2d5: 
1:9272a39: 	public Resolver getResolver() {
1:3e4b2d5: 		return resolver;
1:3e4b2d5: 	}
1:3e4b2d5: 
1:74ef56e: 	public Subsystems getSubsystems() {
1:225bcae: 		return subsystems;
1:225bcae: 	}
1:225bcae: 
1:3e4b2d5: 	public SubsystemServiceRegistrar getSubsystemServiceRegistrar() {
1:d299aa1: 		logger.debug(LOG_ENTRY, "getSubsystemServiceRegistrar");
1:d299aa1: 		SubsystemServiceRegistrar result = registrar;
1:d299aa1: 		logger.debug(LOG_EXIT, "getSubsystemServiceRegistrar", result);
1:f59e428: 		return result;
1:67ef08f: 	}
1:67ef08f: 
1:9df8274: 	public SystemRepository getSystemRepository() {
1:9df8274: 		return systemRepositoryManager.getSystemRepository();
1:3e4b2d5: 	}
1:9272a39: 
1:1c9c28b: 	@Override
1:3e4b2d5: 	public synchronized void start(BundleContext context) throws Exception {
1:1c9c28b: 		logger.debug(LOG_ENTRY, "start", context);
1:1c9c28b: 		bundleContext = context;
1:279dba5: 		lockingStrategy = new LockingStrategy(bundleContext.getProperty(LOCK_TIMEOUT));
1:3e4b2d5: 		serviceTracker = new ServiceTracker<Object, Object>(bundleContext, generateServiceFilter(), this);
1:3e4b2d5: 		serviceTracker.open();
1:1c9c28b: 		logger.debug(LOG_EXIT, "start");
1:3e4b2d5: 	}
1:1c9c28b: 
1:1c9c28b: 	@Override
1:3e4b2d5: 	public synchronized void stop(BundleContext context) {
1:1c9c28b: 		logger.debug(LOG_ENTRY, "stop", context);
1:3e4b2d5: 		serviceTracker.close();
1:3e4b2d5: 		serviceTracker = null;
1:3e4b2d5: 		bundleContext = null;
1:3e4b2d5: 		logger.debug(LOG_EXIT, "stop");
1:3e4b2d5: 	}
1:3e4b2d5: 
1:3e4b2d5: 	private void activate() {
1:3e4b2d5: 		if (isActive() || !hasRequiredServices())
1:3e4b2d5: 			return;
1:3e4b2d5: 		synchronized (Activator.class) {
1:3e4b2d5: 			instance = Activator.this;
1:3e4b2d5: 		}
1:cf81a79: 		subsystems = new Subsystems();
1:74ef56e: 		registerBundleEventHook();
1:6abbe8d: 		registrations.add(bundleContext.registerService(ResolverHookFactory.class, new SubsystemResolverHookFactory(subsystems), null));
1:79b20bc:         Dictionary<String, Object> handlerProps = new Hashtable<String, Object>();
1:79b20bc:         handlerProps.put(ContentHandler.CONTENT_TYPE_PROPERTY, ConfigAdminContentHandler.CONTENT_TYPES);
1:79b20bc:         configAdminHandler = new ConfigAdminContentHandler(bundleContext);
1:79b20bc:         registrations.add(bundleContext.registerService(ContentHandler.class, configAdminHandler, handlerProps));
1:6abbe8d: 		registrar = new SubsystemServiceRegistrar(bundleContext);
1:9df8274: 		systemRepositoryManager = new SystemRepositoryManager(bundleContext.getBundle(0).getBundleContext());
1:9df8274:         systemRepositoryManager.open();
1:5bd3bf6: 		BasicSubsystem root = subsystems.getRootSubsystem();
1:7b50945: 		bundleEventHook.activate();
1:74ef56e: 		root.start();
1:d6eb080: 		registerWovenClassListener();
1:3e4b2d5: 	}
1:3e4b2d5: 
1:3e4b2d5: 	private void deactivate() {
1:777b216: 		if (!isActive())
1:3e4b2d5: 			return;
1:7b50945: 		bundleEventHook.deactivate();
1:9df8274: 		systemRepositoryManager.close();
1:391a1aa: 		new StopAction(subsystems.getRootSubsystem(), subsystems.getRootSubsystem(), true).run();
1:3e4b2d5: 		for (ServiceRegistration<?> registration : registrations) {
1:3e4b2d5: 			try {
1:3e4b2d5: 				registration.unregister();
1:3e4b2d5: 			}
1:1c9c28b: 			catch (IllegalStateException e) {
1:1c9c28b: 				logger.debug("Service had already been unregistered", e);
1:3e4b2d5: 			}
1:3e4b2d5: 		}
1:79b20bc:         configAdminHandler.shutDown();
1:7b50945: 		bundleEventHook.processPendingEvents();
2:1c9c28b: 		synchronized (Activator.class) {
1:1c9c28b: 			instance = null;
1:3e4b2d5: 		}
1:3e4b2d5: 	}
1:3e4b2d5: 
1:9bba779: 	private <T> T findAlternateServiceFor(Class<T> service) {
1:3e4b2d5: 		Object[] services = serviceTracker.getServices();
1:3e4b2d5: 		if (services == null)
1:3e4b2d5: 			return null;
1:3e4b2d5: 		for (Object alternate : services)
1:9bba779: 			if (service.isInstance(alternate))
1:9bba779: 					return service.cast(alternate);
1:3e4b2d5: 		return null;
1:3e4b2d5: 	}
1:3e4b2d5: 
1:3e4b2d5: 	private Filter generateServiceFilter() throws InvalidSyntaxException {
1:3e4b2d5: 		return FrameworkUtil.createFilter(generateServiceFilterString());
1:3e4b2d5: 	}
1:3e4b2d5: 
1:3e4b2d5: 	private String generateServiceFilterString() {
1:3e4b2d5: 		return new StringBuilder("(|(")
1:3e4b2d5: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1:3e4b2d5: 				.append(Coordinator.class.getName()).append(")(")
1:3e4b2d5: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1:3e4b2d5: 				.append(RegionDigraph.class.getName()).append(")(")
1:3e4b2d5: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1:3e4b2d5: 				.append(Resolver.class.getName()).append(")(")
1:74ef56e: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1:d6eb080: 				.append("org.osgi.service.repository.Repository").append(")(")
1:b75f264: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1:9bba779: 				.append(MODELLED_RESOURCE_MANAGER).append(")(")
1:3e4b2d5: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1:74ef56e: 				.append(IDirectoryFinder.class.getName()).append("))").toString();
1:3e4b2d5: 	}
1:3e4b2d5: 
1:3e4b2d5: 	private boolean hasRequiredServices() {
1:3e4b2d5: 		return coordinator != null &&
1:3e4b2d5: 				regionDigraph != null &&
1:e7af8b6: 				resolver != null;
1:3e4b2d5: 	}
1:3e4b2d5: 
1:3e4b2d5: 	private boolean isActive() {
1:3e4b2d5: 		synchronized (Activator.class) {
1:3a1dcd7: 			return instance != null && getSubsystems() != null;
1:3e4b2d5: 		}
1:3e4b2d5: 	}
1:28c3eb7: 
1:7b50945: 	private void registerBundleEventHook() {
1:28c3eb7: 		Dictionary<String, Object> properties = new Hashtable<String, Object>(1);
1:f59e428: 		properties.put(org.osgi.framework.Constants.SERVICE_RANKING, Integer.MAX_VALUE);
1:7b50945: 		bundleEventHook = new BundleEventHook();
1:7b50945: 		registrations.add(bundleContext.registerService(EventHook.class, bundleEventHook, properties));
1:3e4b2d5: 	}
13:b2314ac: 
1:d6eb080: 	private void registerWovenClassListener() {
1:d6eb080: 		registrations.add(
1:d6eb080: 				bundleContext.registerService(
1:d6eb080: 						org.osgi.framework.hooks.weaving.WovenClassListener.class,
1:d6eb080: 						new WovenClassListener(bundleContext, subsystems),
1:d6eb080: 						null));
1:d6eb080: 	}
1:d6eb080: 	
1:3e4b2d5: 	/* Begin ServiceTrackerCustomizer methods */
1:3e4b2d5: 
1:3e4b2d5: 	@Override
1:3e4b2d5: 	public synchronized Object addingService(ServiceReference<Object> reference) {
1:3e4b2d5: 		Object service = bundleContext.getService(reference);
1:139a1ce: 		// Use all of each type of the following services.
1:139a1ce: 		if (service instanceof IDirectoryFinder)
1:139a1ce: 			finders.add((IDirectoryFinder) service);
1:139a1ce: 		// Use only one of each type of the following services.
1:139a1ce: 		else if (service instanceof Coordinator && coordinator == null)
1:139a1ce: 			coordinator = (Coordinator) service;
1:139a1ce: 		else if (service instanceof RegionDigraph && regionDigraph == null)
1:139a1ce: 			regionDigraph = (RegionDigraph) service;
1:139a1ce: 		else if (service instanceof Resolver && resolver == null)
1:139a1ce: 			resolver = (Resolver) service;
1:b2314ac: 		else {
1:d6eb080: 			try {
1:d6eb080: 				Class clazz = getClass().getClassLoader().loadClass(MODELLED_RESOURCE_MANAGER);
1:d6eb080: 				if (clazz.isInstance(service) && serviceModeller == null) {
1:d6eb080: 					modelledResourceManager = service;
1:d6eb080: 					serviceModeller = new ApplicationServiceModeller(service);
1:d6eb080: 				} else {
1:d6eb080: 					service = null;
1:d6eb080: 				}
1:d6eb080: 			} catch (ClassNotFoundException e) {
1:d6eb080: 				service = null;
1:d6eb080: 			} catch (NoClassDefFoundError e) {
1:d6eb080: 				service = null;
1:d6eb080: 			}
1:d6eb080: 		}
1:139a1ce: 		// Activation is harmless if already active or all required services
1:139a1ce: 		// have not yet been found.
1:139a1ce: 		activate();
1:139a1ce: 		// Filter guarantees we want to track all services received.
1:3e4b2d5: 		return service;
1:b75f264: 	}
1:3e4b2d5: 
1:3e4b2d5: 	@Override
1:3e4b2d5: 	public void modifiedService(ServiceReference<Object> reference, Object service) {
1:3e4b2d5: 		// Nothing
1:b75f264: 	}
1:3e4b2d5: 
1:3e4b2d5: 	@Override
1:3e4b2d5: 	public synchronized void removedService(ServiceReference<Object> reference, Object service) {
2:3e4b2d5: 		if (service instanceof Coordinator) {
1:3e4b2d5: 			if (service.equals(coordinator)) {
1:9bba779: 				Coordinator coordinator = findAlternateServiceFor(Coordinator.class);
1:777b216: 				if (coordinator == null)
2:777b216: 					deactivate();
1:777b216: 				this.coordinator = coordinator;
1:3e4b2d5: 			}
1:3e4b2d5: 		}
2:3e4b2d5: 		else if (service instanceof RegionDigraph) {
1:3e4b2d5: 			if (service.equals(regionDigraph)) {
1:9bba779: 				RegionDigraph regionDigraph = findAlternateServiceFor(RegionDigraph.class);
1:777b216: 				if (regionDigraph == null)
1:777b216: 					deactivate();
1:777b216: 				this.regionDigraph = regionDigraph;
1:3e4b2d5: 			}
1:3e4b2d5: 		}
2:3e4b2d5: 		else if (service instanceof Resolver) {
1:3e4b2d5: 			if (service.equals(resolver)) {
1:9bba779: 				Resolver resolver = findAlternateServiceFor(Resolver.class);
1:b75f264: 				if (resolver == null)
1:b75f264: 					deactivate();
1:777b216: 				this.resolver = resolver;
1:3e4b2d5: 			}
1:3e4b2d5: 		}
1:6abbe8d: 		else if (service instanceof IDirectoryFinder)
1:6abbe8d: 			finders.remove(service);
1:9bba779:         else {
1:b75f264:             if (service.equals(modelledResourceManager)) {
1:1c9c28b:                 try {
1:9bba779:                     Class clazz = getClass().getClassLoader().loadClass(MODELLED_RESOURCE_MANAGER);
1:9bba779:                     Object manager = findAlternateServiceFor(clazz);
1:9bba779:                     if (manager == null) {
1:9bba779:                         modelledResourceManager = null;
1:9bba779:                         serviceModeller = null;
1:9bba779:                     } else {
1:9bba779:                         modelledResourceManager = service;
1:9bba779:                         serviceModeller = new ApplicationServiceModeller(service);
1:b75f264:                     }
1:9bba779:                 } catch (ClassNotFoundException e) {
1:9bba779:                     // ignore
1:9bba779:                 } catch (NoClassDefFoundError e) {
1:9bba779:                     // ignore
1:b75f264:                 }
1:3e4b2d5:             }
1:3e4b2d5:         }
1:28c3eb7: 	}
1:3e4b2d5: 
1:3e4b2d5: 	/* End ServiceTrackerCustomizer methods */
1:9272a39: }
============================================================================
author:Tom Watson
-------------------------------------------------------------------------------
commit:279dba5
/////////////////////////////////////////////////////////////////////////
1:     private static final String LOCK_TIMEOUT = "org.apache.aries.subsystem.lock.timeout";
/////////////////////////////////////////////////////////////////////////
1: 	private volatile LockingStrategy lockingStrategy;
/////////////////////////////////////////////////////////////////////////
1: 	public LockingStrategy getLockingStrategy() {
1: 		return lockingStrategy;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		lockingStrategy = new LockingStrategy(bundleContext.getProperty(LOCK_TIMEOUT));
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public org.apache.aries.subsystem.core.repository.Repository getSystemRepository() {
/////////////////////////////////////////////////////////////////////////
1: 		registerWovenClassListener();
/////////////////////////////////////////////////////////////////////////
1: 				.append("org.osgi.service.repository.Repository").append(")(")
/////////////////////////////////////////////////////////////////////////
1: 	private void registerWovenClassListener() {
1: 		registrations.add(
1: 				bundleContext.registerService(
1: 						org.osgi.framework.hooks.weaving.WovenClassListener.class,
1: 						new WovenClassListener(bundleContext, subsystems),
1: 						null));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			try {
1: 				Class clazz = getClass().getClassLoader().loadClass(MODELLED_RESOURCE_MANAGER);
1: 				if (clazz.isInstance(service) && serviceModeller == null) {
1: 					modelledResourceManager = service;
1: 					serviceModeller = new ApplicationServiceModeller(service);
1: 				} else {
1: 					service = null;
1: 				}
1: 			} catch (ClassNotFoundException e) {
1: 				service = null;
1: 			} catch (NoClassDefFoundError e) {
1: 				service = null;
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
author:John Ross
-------------------------------------------------------------------------------
commit:9df8274
/////////////////////////////////////////////////////////////////////////
1: 	
1:     private volatile RegionDigraph regionDigraph;
1: 	private volatile ServiceModeller serviceModeller;
1: 	private volatile Subsystems subsystems;
1: 	private volatile SystemRepositoryManager systemRepositoryManager;
1: 	
1: 	private BundleEventHook bundleEventHook;
1: 	private final Collection<ServiceRegistration<?>> registrations = new HashSet<ServiceRegistration<?>>();
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	public SystemRepository getSystemRepository() {
1: 		return systemRepositoryManager.getSystemRepository();
/////////////////////////////////////////////////////////////////////////
1: 		systemRepositoryManager = new SystemRepositoryManager(bundleContext.getBundle(0).getBundleContext());
1:         systemRepositoryManager.open();
/////////////////////////////////////////////////////////////////////////
1: 		systemRepositoryManager.close();
commit:3aebecb
/////////////////////////////////////////////////////////////////////////
1:     private static volatile Activator instance;
1: 	public static Activator getInstance() {
1: 	    Activator result = instance;
1: 	    if (result == null)
1:             throw new IllegalStateException("The activator has not been initialized or has been shutdown");
1: 		return result;
commit:e7af8b6
/////////////////////////////////////////////////////////////////////////
1: 				resolver != null;
commit:4911111
/////////////////////////////////////////////////////////////////////////
commit:cf81a79
/////////////////////////////////////////////////////////////////////////
1: 		subsystems = new Subsystems();
commit:139a1ce
/////////////////////////////////////////////////////////////////////////
1: 		// Use all of each type of the following services.
1: 		if (service instanceof IDirectoryFinder)
1: 			finders.add((IDirectoryFinder) service);
0: 		else if (service instanceof Repository)
0: 			repositories.add((Repository) service);
1: 		// Use only one of each type of the following services.
1: 		else if (service instanceof Coordinator && coordinator == null)
1: 			coordinator = (Coordinator) service;
1: 		else if (service instanceof RegionDigraph && regionDigraph == null)
1: 			regionDigraph = (RegionDigraph) service;
1: 		else if (service instanceof Resolver && resolver == null)
1: 			resolver = (Resolver) service;
0: 		else if (service instanceof ModelledResourceManager && modelledResourceManager == null)
0: 			modelledResourceManager = (ModelledResourceManager) service;
1: 		// Activation is harmless if already active or all required services
1: 		// have not yet been found.
1: 		activate();
1: 		// Filter guarantees we want to track all services received.
commit:74ef56e
/////////////////////////////////////////////////////////////////////////
1: 
0: 	private volatile Subsystems subsystems;
/////////////////////////////////////////////////////////////////////////
1: 	public Subsystems getSubsystems() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		registerBundleEventHook();
1: 		root.start();
/////////////////////////////////////////////////////////////////////////
0: 				.append(Repository.class.getName()).append(")(")
0: 				.append(ModelledResourceManager.class.getName()).append(")(")
1: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1: 				.append(IDirectoryFinder.class.getName()).append("))").toString();
commit:7b50945
/////////////////////////////////////////////////////////////////////////
0: 	// @GuardedBy("this")
0: 	private BundleEventHook bundleEventHook;
1: 	private volatile BundleContext bundleContext;
/////////////////////////////////////////////////////////////////////////
0: 		registerBundleEventHook();
/////////////////////////////////////////////////////////////////////////
1: 		bundleEventHook.activate();
1: 		bundleEventHook.deactivate();
/////////////////////////////////////////////////////////////////////////
1: 		bundleEventHook.processPendingEvents();
/////////////////////////////////////////////////////////////////////////
1: 	private void registerBundleEventHook() {
1: 		bundleEventHook = new BundleEventHook();
1: 		registrations.add(bundleContext.registerService(EventHook.class, bundleEventHook, properties));
commit:f59e428
/////////////////////////////////////////////////////////////////////////
0: 		BundleEventHook hook = registerBundleEventHook();
/////////////////////////////////////////////////////////////////////////
0: 		hook.activate();
/////////////////////////////////////////////////////////////////////////
0: 	private BundleEventHook registerBundleEventHook() {
1: 		properties.put(org.osgi.framework.Constants.SERVICE_RANKING, Integer.MAX_VALUE);
0: 		BundleEventHook result = new BundleEventHook();
0: 		registrations.add(bundleContext.registerService(EventHook.class, result, properties));
1: 		return result;
commit:5bd3bf6
/////////////////////////////////////////////////////////////////////////
1: 		BasicSubsystem root = subsystems.getRootSubsystem();
commit:6abbe8d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		registrations.add(bundleContext.registerService(ResolverHookFactory.class, new SubsystemResolverHookFactory(subsystems), null));
1: 		registrar = new SubsystemServiceRegistrar(bundleContext);
/////////////////////////////////////////////////////////////////////////
1: 		else if (service instanceof IDirectoryFinder)
0: 			finders.add((IDirectoryFinder)service);
/////////////////////////////////////////////////////////////////////////
0: 				if (modelledResourceManager == null)
0: 		else if (service instanceof IDirectoryFinder)
1: 			finders.remove(service);
commit:b75f264
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.application.modelling.ModelledResourceManager;
/////////////////////////////////////////////////////////////////////////
0: 	private volatile ModelledResourceManager modelledResourceManager;
/////////////////////////////////////////////////////////////////////////
0: 	public ModelledResourceManager getModelledResourceManager() {
0: 		return modelledResourceManager;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 				.append(Repository.class.getName()).append(")(")
1: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
0: 				.append(ModelledResourceManager.class.getName()).append("))").toString();
0: 				resolver != null &&
0: 				modelledResourceManager != null;
/////////////////////////////////////////////////////////////////////////
0: 		else if (service instanceof ModelledResourceManager) {
0: 			if (modelledResourceManager == null) {
0: 				modelledResourceManager = (ModelledResourceManager)service;
0: 				activate();
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		else if (service instanceof ModelledResourceManager) {
1: 			if (service.equals(modelledResourceManager)) {
0: 				ModelledResourceManager modelledResourceManager = (ModelledResourceManager)findAlternateServiceFor(this.modelledResourceManager);
1: 				if (resolver == null)
1: 					deactivate();
0: 				this.modelledResourceManager = modelledResourceManager;
1: 			}
1: 		}
commit:3a1dcd7
/////////////////////////////////////////////////////////////////////////
0: 	// @GuardedBy("this")
0: 	private Subsystems subsystems;
/////////////////////////////////////////////////////////////////////////
0: 	/* Synchronization was introduced here to prevent conflicts between the
0: 	 * BundleEventHook and the activation process. The activation process
0: 	 * must complete the initialization of the root subsystem in order to
0: 	 * fully initialize the Subsystems object.
1: 	 */
0: 	public synchronized Subsystems getSubsystems() {
/////////////////////////////////////////////////////////////////////////
0: 		return new SystemRepository(getSubsystems().getRootSubsystem());
/////////////////////////////////////////////////////////////////////////
1: 			return instance != null && getSubsystems() != null;
commit:391a1aa
/////////////////////////////////////////////////////////////////////////
1: 		new StopAction(subsystems.getRootSubsystem(), subsystems.getRootSubsystem(), true).run();
commit:2b13b05
/////////////////////////////////////////////////////////////////////////
0: 		new StopAction(subsystems.getRootSubsystem(), true, false).run();
commit:5896d6f
/////////////////////////////////////////////////////////////////////////
0: 			return instance != null && subsystems != null;
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: 		if (!isActive())
0: 		new StopAction(subsystems.getRootSubsystem(), true).run();
0: //		subsystems.getRootSubsystem().stop();
/////////////////////////////////////////////////////////////////////////
0: 				Coordinator coordinator = (Coordinator)findAlternateServiceFor(this.coordinator);
1: 				if (coordinator == null)
1: 					deactivate();
1: 				this.coordinator = coordinator;
0: 				RegionDigraph regionDigraph = (RegionDigraph)findAlternateServiceFor(this.regionDigraph);
1: 				if (regionDigraph == null)
1: 					deactivate();
1: 				this.regionDigraph = regionDigraph;
0: 				Resolver resolver = (Resolver)findAlternateServiceFor(this.resolver);
0: 				if (resolver == null)
1: 					deactivate();
1: 				this.resolver = resolver;
commit:225bcae
/////////////////////////////////////////////////////////////////////////
0: 	private volatile Subsystems subsystems;
/////////////////////////////////////////////////////////////////////////
0: 	public Subsystems getSubsystems() {
1: 		return subsystems;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		return new SystemRepository(subsystems.getRootSubsystem());
/////////////////////////////////////////////////////////////////////////
0: 			subsystems = new Subsystems();
/////////////////////////////////////////////////////////////////////////
0: 		AriesSubsystem root = subsystems.getRootSubsystem();
/////////////////////////////////////////////////////////////////////////
0: 		subsystems.getRootSubsystem().stop0();
commit:67ef08f
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	public Repository getSystemRepository() {
0: 		return new SystemRepository(root);
1: 	}
commit:3e4b2d5
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import org.eclipse.equinox.region.RegionDigraph;
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.FrameworkUtil;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.coordinator.Coordinator;
0: import org.osgi.service.repository.Repository;
0: import org.osgi.service.subsystem.SubsystemException;
1: import org.osgi.util.tracker.ServiceTracker;
1: import org.osgi.util.tracker.ServiceTrackerCustomizer;
/////////////////////////////////////////////////////////////////////////
1: public class Activator implements BundleActivator, ServiceTrackerCustomizer<Object, Object> {
/////////////////////////////////////////////////////////////////////////
1: 	private volatile Coordinator coordinator;
1: 	private volatile SubsystemServiceRegistrar registrar;
0: 	private volatile RegionDigraph regionDigraph;
1: 	private volatile Resolver resolver;
1: 	private ServiceTracker<?,?> serviceTracker;
0: 	private final Collection<ServiceRegistration<?>> registrations = new HashSet<ServiceRegistration<?>>();
0: 	private final Collection<Repository> repositories = Collections.synchronizedSet(new HashSet<Repository>());
1: 	
1: 	public BundleContext getBundleContext() {
1: 		return bundleContext;
1: 	}
1: 	
1: 	public Coordinator getCoordinator() {
1: 		return coordinator;
1: 	}
1: 	
1: 	public RegionDigraph getRegionDigraph() {
1: 		return regionDigraph;
1: 	}
1: 	
0: 	public Collection<Repository> getRepositories() {
0: 		return Collections.unmodifiableCollection(repositories);
1: 		return resolver;
1: 	public SubsystemServiceRegistrar getSubsystemServiceRegistrar() {
/////////////////////////////////////////////////////////////////////////
1: 	public synchronized void start(BundleContext context) throws Exception {
1: 		serviceTracker = new ServiceTracker<Object, Object>(bundleContext, generateServiceFilter(), this);
1: 		serviceTracker.open();
1: 	public synchronized void stop(BundleContext context) {
1: 		serviceTracker.close();
1: 		serviceTracker = null;
1: 		bundleContext = null;
1: 		logger.debug(LOG_EXIT, "stop");
1: 	}
1: 	
1: 	private void activate() {
1: 		if (isActive() || !hasRequiredServices())
1: 			return;
1: 		synchronized (Activator.class) {
1: 			instance = Activator.this;
1: 		}
0: 		registerBundleEventHook();
0: 		registrations.add(bundleContext.registerService(ResolverHookFactory.class, new SubsystemResolverHookFactory(), null));
0: 		registrar = new SubsystemServiceRegistrar(bundleContext);
1: 		try {
0: 			root = new AriesSubsystem();
1: 		}
0: 		catch (SubsystemException e) {
0: 			throw e;
1: 		}
0: 		catch (Exception e) {
0: 			throw new SubsystemException(e);
1: 		}
0: 		root.install();
0: 		root.start();
1: 	}
1: 	
1: 	private void deactivate() {
0: 		if (!isActive() || hasRequiredServices())
1: 			return;
1: 		for (ServiceRegistration<?> registration : registrations) {
1: 				registration.unregister();
1: 	}
1: 	
0: 	private Object findAlternateServiceFor(Object service) {
1: 		Object[] services = serviceTracker.getServices();
1: 		if (services == null)
1: 			return null;
1: 		for (Object alternate : services)
0: 			if (alternate.getClass().equals(service.getClass()))
0: 					return alternate;
1: 		return null;
1: 	}
1: 	
1: 	private Filter generateServiceFilter() throws InvalidSyntaxException {
1: 		return FrameworkUtil.createFilter(generateServiceFilterString());
1: 	}
1: 	
1: 	private String generateServiceFilterString() {
1: 		return new StringBuilder("(|(")
1: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1: 				.append(Coordinator.class.getName()).append(")(")
1: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1: 				.append(RegionDigraph.class.getName()).append(")(")
1: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
1: 				.append(Resolver.class.getName()).append(")(")
1: 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
0: 				.append(Repository.class.getName()).append("))").toString();
1: 	}
1: 	
1: 	private boolean hasRequiredServices() {
1: 		return coordinator != null &&
1: 				regionDigraph != null &&
0: 				resolver != null;
1: 	}
1: 	
1: 	private boolean isActive() {
1: 		synchronized (Activator.class) {
0: 			return instance != null;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/* Begin ServiceTrackerCustomizer methods */
1: 
1: 	@Override
1: 	public synchronized Object addingService(ServiceReference<Object> reference) {
1: 		Object service = bundleContext.getService(reference);
1: 		if (service instanceof Coordinator) {
0: 			if (coordinator == null) {
0: 				coordinator = (Coordinator)service;
0: 				activate();
1: 			}
1: 		}
1: 		else if (service instanceof RegionDigraph) {
0: 			if (regionDigraph == null) {
0: 				regionDigraph = (RegionDigraph)service;
0: 				activate();
1: 			}
1: 		}
1: 		else if (service instanceof Resolver) {
0: 			if (resolver == null) {
0: 				resolver = (Resolver)service;
0: 				activate();
1: 			}
1: 		}
0: 		else
0: 			repositories.add((Repository)service);
1: 		return service;
1: 	}
1: 
1: 	@Override
1: 	public void modifiedService(ServiceReference<Object> reference, Object service) {
1: 		// Nothing
1: 	}
1: 
1: 	@Override
1: 	public synchronized void removedService(ServiceReference<Object> reference, Object service) {
1: 		if (service instanceof Coordinator) {
1: 			if (service.equals(coordinator)) {
0: 				coordinator = (Coordinator)findAlternateServiceFor(coordinator);
0: 				deactivate();
1: 			}
1: 		}
1: 		else if (service instanceof RegionDigraph) {
1: 			if (service.equals(regionDigraph)) {
0: 				regionDigraph = (RegionDigraph)findAlternateServiceFor(regionDigraph);
0: 				deactivate();
1: 			}
1: 		}
1: 		else if (service instanceof Resolver) {
1: 			if (service.equals(resolver)) {
0: 				resolver = (Resolver)findAlternateServiceFor(regionDigraph);
0: 				deactivate();
1: 			}
1: 		}
0: 		else
0: 			repositories.remove(service);
1: 	}
1: 	
1: 	/* End ServiceTrackerCustomizer methods */
commit:23d86e6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.felix.resolver.ResolverImpl;
1: import org.osgi.service.resolver.Resolver;
commit:28c3eb7
/////////////////////////////////////////////////////////////////////////
1: import java.util.Dictionary;
1: import java.util.Hashtable;
1: import org.osgi.framework.hooks.bundle.EventHook;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		registerBundleEventHook();
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private void registerBundleEventHook() {
1: 		Dictionary<String, Object> properties = new Hashtable<String, Object>(1);
0: 		properties.put(org.osgi.framework.Constants.SERVICE_RANKING, Integer.MIN_VALUE);
0: 		registrations.add(bundleContext.registerService(EventHook.class, new BundleEventHook(), properties));
1: 	}
commit:7e004f1
/////////////////////////////////////////////////////////////////////////
0: //		registrations.add(bundleContext.registerService(Resolver.class, new ResolverImpl(null), null));
commit:9272a39
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.Resolver;
/////////////////////////////////////////////////////////////////////////
1: 	public Resolver getResolver() {
0: 		return new ResolverImpl(null);
1: 	}
1: 	
commit:f1ff8f8
/////////////////////////////////////////////////////////////////////////
0: 		root.stop0();
commit:d299aa1
/////////////////////////////////////////////////////////////////////////
0: 	private SubsystemServiceRegistrar registrar;
0: 	private AriesSubsystem root;
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	public synchronized SubsystemServiceRegistrar getSubsystemServiceRegistrar() {
1: 		logger.debug(LOG_ENTRY, "getSubsystemServiceRegistrar");
1: 		SubsystemServiceRegistrar result = registrar;
1: 		logger.debug(LOG_EXIT, "getSubsystemServiceRegistrar", result);
0: 		return result;
1: 	}
/////////////////////////////////////////////////////////////////////////
0: 		registrar = new SubsystemServiceRegistrar(bundleContext);
0: 		root = new AriesSubsystem();
0: 		root.start();
0: 		root.stop();
0: 		registrar.unregisterAll();
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
0: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
0: import java.util.ArrayList;
0: import java.util.List;
1: 
0: import org.apache.felix.resolver.impl.ResolverImpl;
0: import org.osgi.framework.BundleListener;
/////////////////////////////////////////////////////////////////////////
1: 	private static final Logger logger = LoggerFactory.getLogger(Activator.class);
0: 	private static Activator instance;
1: 	
0: 	public static synchronized Activator getInstance() {
0: 		logger.debug(LOG_ENTRY, "getInstance");
0: 		checkInstance();
0: 		logger.debug(LOG_EXIT, "getInstance", instance);
0: 		return instance;
0: 	private static synchronized void checkInstance() {
0: 		logger.debug(LOG_ENTRY, "checkInstance");
0: 		if (instance == null)
0: 			throw new IllegalStateException("The activator has not been initialized or has been shutdown");
0: 		logger.debug(LOG_EXIT, "checkInstance");
0: 	private final BundleListener bundleListener = new SubsystemSynchronousBundleListener();
0: 	private BundleContext bundleContext;
0: 	private ServiceProviderImpl serviceProvider;
1: 	
0: 	public synchronized BundleContext getBundleContext() {
0: 		logger.debug(LOG_ENTRY, "getBundleContext");
0: 		BundleContext result = bundleContext;
0: 		logger.debug(LOG_EXIT, "getBundleContext", result);
0: 		return result;
0: 	public synchronized ServiceProvider getServiceProvider() {
0: 		logger.debug(LOG_ENTRY, "getServiceProvider");
0: 		ServiceProvider result = serviceProvider;
0: 		logger.debug(LOG_EXIT, "getServiceProvider", result);
0: 		return result;
0: 	}
1: 
1: 	@Override
0: 	public synchronized void start(final BundleContext context) throws Exception {
1: 		logger.debug(LOG_ENTRY, "start", context);
1: 		synchronized (Activator.class) {
0: 			instance = this;
0: 		}
1: 		bundleContext = context;
0: 		serviceProvider = new ServiceProviderImpl(bundleContext);
0: 		context.getBundle(0).getBundleContext().addBundleListener(bundleListener);
0: 		registrations.add(bundleContext.registerService(ResolverHookFactory.class, new SubsystemResolverHookFactory(), null));
0: 		// TODO The registration of the Resolver service should be temporary, unless Felix 
0: 		// does not have an official release at the time.
0: 		registrations.add(bundleContext.registerService(Resolver.class, new ResolverImpl(null), null));
0: 		AriesSubsystem root = new AriesSubsystem();
0: 		registrations.add(bundleContext.registerService(Subsystem.class.getName(), root, null));
0: 		root.install();
1: 		logger.debug(LOG_EXIT, "start");
0: 	}
1: 
1: 	@Override
0: 	public synchronized void stop(BundleContext context) /*throws Exception*/ {
1: 		logger.debug(LOG_ENTRY, "stop", context);
0: 		for (int i = registrations.size() - 1; i >= 0; i--) {
1: 			try {
0: 				registrations.get(i).unregister();
0: 			}
1: 			catch (IllegalStateException e) {
1: 				logger.debug("Service had already been unregistered", e);
0: 			}
0: 		}
0: 		context.getBundle(0).getBundleContext().removeBundleListener(bundleListener);
0: 		serviceProvider.shutdown();
1: 		synchronized (Activator.class) {
1: 			instance = null;
0: 		}
0: 		logger.debug(LOG_EXIT, "stop");
commit:0c3bb10
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: //	private final BundleListener bundleListener = new SubsystemSynchronousBundleListener();
/////////////////////////////////////////////////////////////////////////
0: //		context.getBundle(0).getBundleContext().addBundleListener(bundleListener);
/////////////////////////////////////////////////////////////////////////
0: //		context.getBundle(0).getBundleContext().removeBundleListener(bundleListener);
commit:046b8ec
/////////////////////////////////////////////////////////////////////////
0: //		return new SubsystemResolver();
0: 		ServiceTracker st = new ServiceTracker(context, Resolver.class.getName(), null);
0: 		try {
0: 			st.open();
0: 			return (Resolver)st.waitForService(5000);
0: 		}
0: 		catch (InterruptedException e) {
0: 			Thread.currentThread().interrupt();
0: 			return null;
0: 		}
0: 		finally {
0: 			st.close();
0: 		}
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
commit:4717af0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.obr.SubsystemResolver;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		return new SubsystemResolver();
0: //		return new Resolver() {
0: //			@Override
0: //			public Map<Resource, List<Wire>> resolve(Environment environment, Requirement... requirements) throws ResolutionException {
0: //				Collection<Capability> capabilities = new ArrayList<Capability>();
0: //				for (Requirement requirement : requirements)
0: //					capabilities.addAll(environment.findProviders(requirement));
0: //				List<Resource> resources = new ArrayList<Resource>(capabilities.size());
0: //				for (Capability capability : capabilities)
0: //					resources.add(capability.getResource());
0: //				org.apache.felix.bundlerepository.Resolver resolver = getRepositoryAdmin().resolver();
0: //		        for (Resource resource : resources)
0: //		            resolver.add(new OsgiResourceAdapter(resource));
0: //		        if (resolver.resolve()) {
0: //		        	/* 
0: //		        	 * TODO For now, these need to go back through the environment in order to be sure the URL is available.
0: //		        	 * This is because RepositoryAdmin is not going through the environment as part of pulling in transitive
0: //		        	 * dependencies. Once a "real" Resolver is available, this will no longer be necessary.
0: //		        	 */
0: //		        	for (org.apache.felix.bundlerepository.Resource resource : resolver.getRequiredResources()) {
0: //		        		Resource r = new FelixResourceAdapter(resource);
0: //		        		// Make the environment aware of the resource and its URL.
0: //		        		environment.findProviders(new OsgiIdentityRequirement(r, true));
0: //		            	resources.add(r);
0: //		        	}
0: //		        	for (org.apache.felix.bundlerepository.Resource resource : resolver.getOptionalResources()) {
0: //		        		Resource r = new FelixResourceAdapter(resource);
0: //		        		// Make the environment aware of the resource and its URL.
0: //		        		environment.findProviders(new OsgiIdentityRequirement(r, true));
0: //		            	resources.add(r);
0: //		        	}
0: //		        }
0: //		        else {
0: //		            Reason[] reasons = resolver.getUnsatisfiedRequirements();
0: //		            StringBuilder builder = new StringBuilder("Failed to resolve subsystem").append(System.getProperty("line.separator"));
0: //		            for (Reason reason : reasons)
0: //		                builder
0: //		                	.append("resource = ")
0: //		                	.append(reason.getResource().getSymbolicName())
0: //		                	.append(", requirement = ")
0: //		                	.append(reason.getRequirement().getName())
0: //		                	.append(System.getProperty("line.separator"));
0: //		            throw new SubsystemException(builder.toString());
0: //		        }
0: //		        Map<Resource, List<Wire>> result = new HashMap<Resource, List<Wire>>(resources.size());
0: //				for (Resource resource : resources)
0: //					result.put(resource, Collections.EMPTY_LIST);
0: //				return result;
0: //			}
0: //		};
commit:226c63f
/////////////////////////////////////////////////////////////////////////
0: 		        		environment.findProviders(new OsgiIdentityRequirement(r, true));
0: 		        		environment.findProviders(new OsgiIdentityRequirement(r, true));
commit:e6bf465
/////////////////////////////////////////////////////////////////////////
1: 		        	/* 
0: 		        	 * TODO For now, these need to go back through the environment in order to be sure the URL is available.
0: 		        	 * This is because RepositoryAdmin is not going through the environment as part of pulling in transitive
0: 		        	 * dependencies. Once a "real" Resolver is available, this will no longer be necessary.
1: 		        	 */
0: 		        	for (org.apache.felix.bundlerepository.Resource resource : resolver.getRequiredResources()) {
0: 		        		Resource r = new FelixResourceAdapter(resource);
0: 		        		// Make the environment aware of the resource and its URL.
0: 		        		environment.findProviders(new OsgiIdentityRequirement(r, resource.getSymbolicName(), resource.getVersion()));
0: 		            	resources.add(r);
0: 		        	}
0: 		        	for (org.apache.felix.bundlerepository.Resource resource : resolver.getOptionalResources()) {
0: 		        		Resource r = new FelixResourceAdapter(resource);
0: 		        		// Make the environment aware of the resource and its URL.
0: 		        		environment.findProviders(new OsgiIdentityRequirement(r, resource.getSymbolicName(), resource.getVersion()));
0: 		            	resources.add(r);
0: 		        	}
commit:b2314ac
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Map;
0: import java.util.concurrent.Executor;
0: import org.apache.aries.subsystem.core.obr.felix.FelixResourceAdapter;
0: import org.apache.aries.subsystem.core.obr.felix.OsgiResourceAdapter;
0: import org.apache.felix.bundlerepository.Reason;
0: import org.apache.felix.bundlerepository.RepositoryAdmin;
0: import org.osgi.framework.BundleListener;
0: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.hooks.resolver.ResolverHookFactory;
0: import org.osgi.framework.wiring.Capability;
0: import org.osgi.framework.wiring.FrameworkWiring;
0: import org.osgi.framework.wiring.Requirement;
0: import org.osgi.framework.wiring.Resource;
0: import org.osgi.framework.wiring.Wire;
0: import org.osgi.service.event.EventAdmin;
0: import org.osgi.service.event.EventConstants;
0: import org.osgi.service.event.EventHandler;
0: import org.osgi.service.repository.Repository;
0: import org.osgi.service.resolver.Environment;
0: import org.osgi.service.resolver.ResolutionException;
0: import org.osgi.service.resolver.Resolver;
0: import org.osgi.service.subsystem.Subsystem;
0: import org.osgi.service.subsystem.SubsystemException;
1:  * The bundle activator for the this bundle. When the bundle is starting, this
1:  * activator will create and register the SubsystemAdmin service.
0: 	private static final Logger LOGGER = LoggerFactory.getLogger(Activator.class);
0: 	private static BundleContext context;
0: 	private static SubsystemManager subsystemManager = new SubsystemManager();
1: 	
0: 	public static BundleContext getBundleContext() {
0: 		return context;
0: 	}
1: 	
0: 	public static Coordinator getCoordinator() {
0: 		return context.getService(context.getServiceReference(Coordinator.class));
0: 	}
1: 	
0: 	public static EventAdmin getEventAdmin() {
0: 		ServiceReference<EventAdmin> ref = context.getServiceReference(EventAdmin.class);
0: 		if (ref == null) return null;
0: 		return context.getService(ref);
0: 	}
1: 	
0: 	public static Executor getExecutor() {
0: 		return context.getService(context.getServiceReference(Executor.class));
0: 	}
1: 	
0: 	public static FrameworkWiring getFrameworkWiring() {
0: 		return context.getBundle(0).adapt(FrameworkWiring.class);
0: 	}
1: 	
0: 	public static RegionDigraph getRegionDigraph() {
0: 		return context.getService(context.getServiceReference(RegionDigraph.class));
0: 	}
1: 	
0: 	public static Collection<Repository> getRepositories() {
0: 		Collection<ServiceReference<Repository>> references;
0: 		try {
0: 			references = context.getServiceReferences(Repository.class, null);
0: 		}
0: 		catch (InvalidSyntaxException e) {
0: 			// This should never happen, but I don't want to cover it up. Nor do I want to force clients to handle it.
0: 			throw new RuntimeException(e);
0: 		}
0: 		ArrayList<Repository> repositories = new ArrayList<Repository>(references.size());
0: 		for (ServiceReference<Repository> reference : references) {
0: 			Repository repository = context.getService(reference);
0: 			if (repository != null)
0: 				repositories.add(repository);
0: 		}
0: 		repositories.trimToSize();
0: 		return repositories;
0: 	}
1: 	
0: 	public static RepositoryAdmin getRepositoryAdmin() {
0: 		ServiceTracker st = new ServiceTracker(context, RepositoryAdmin.class.getName(), null);
0: 		try {
0: 			st.open();
0: 			return (RepositoryAdmin)st.waitForService(5000);
0: 		}
0: 		catch (InterruptedException e) {
0: 			Thread.currentThread().interrupt();
0: 			return null;
0: 		}
0: 		finally {
0: 			st.close();
0: 		}
0: 	}
1: 	
0: 	/*
0: 	 * TODO
0: 	 * A naive implementation serving as a placeholder until a real Resolver comes along.
0: 	 */
0: 	public static Resolver getResolver() {
0: 		return new Resolver() {
0: 			@Override
0: 			public Map<Resource, List<Wire>> resolve(Environment environment, Requirement... requirements) throws ResolutionException {
0: 				Collection<Capability> capabilities = new ArrayList<Capability>();
0: 				for (Requirement requirement : requirements)
0: 					capabilities.addAll(environment.findProviders(requirement));
0: 				List<Resource> resources = new ArrayList<Resource>(capabilities.size());
0: 				for (Capability capability : capabilities)
0: 					resources.add(capability.getResource());
0: 				org.apache.felix.bundlerepository.Resolver resolver = getRepositoryAdmin().resolver();
0: 		        for (Resource resource : resources)
0: 		            resolver.add(new OsgiResourceAdapter(resource));
0: 		        if (resolver.resolve()) {
0: 		        	for (org.apache.felix.bundlerepository.Resource resource : resolver.getRequiredResources())
0: 		            	resources.add(new FelixResourceAdapter(resource));
0: 		        	for (org.apache.felix.bundlerepository.Resource resource : resolver.getOptionalResources())
0: 		        		resources.add(new FelixResourceAdapter(resource));
0: 		        }
1: 		        else {
0: 		            Reason[] reasons = resolver.getUnsatisfiedRequirements();
0: 		            StringBuilder builder = new StringBuilder("Failed to resolve subsystem").append(System.getProperty("line.separator"));
0: 		            for (Reason reason : reasons)
0: 		                builder
0: 		                	.append("resource = ")
0: 		                	.append(reason.getResource().getSymbolicName())
0: 		                	.append(", requirement = ")
0: 		                	.append(reason.getRequirement().getName())
0: 		                	.append(System.getProperty("line.separator"));
0: 		            throw new SubsystemException(builder.toString());
0: 		        }
0: 		        Map<Resource, List<Wire>> result = new HashMap<Resource, List<Wire>>(resources.size());
0: 				for (Resource resource : resources)
0: 					result.put(resource, Collections.EMPTY_LIST);
0: 				return result;
0: 			}
0: 		};
0: 	}
1: 	
0: 	public static SubsystemManager getSubsystemManager() {
0: 		return subsystemManager;
0: 	}
1: 	
0: 	private final BundleListener bundleListener = new SubsystemSynchronousBundleListener();
0: 	private final List<ServiceRegistration<?>> registrations = new ArrayList<ServiceRegistration<?>>();
1: 	
0: 	public void start(final BundleContext context) throws Exception {
0: 		if (LOGGER.isDebugEnabled()) {
0: 			LOGGER.debug("subsystem activator starting");
0: 		}
0: 		Activator.context = context;
0: 		register(Subsystem.class.getName(), new SubsystemServiceFactory(), null);
0: 		register(ResolverHookFactory.class, new SubsystemResolverHookFactory(), null);
0: 		context.getBundle(0).getBundleContext().addBundleListener(bundleListener);
0: 		Dictionary<String, Object> properties = new Hashtable<String, Object>();
0: 		properties.put(EventConstants.EVENT_TOPIC, new String[]{"org/osgi/framework/BundleEvent/*"});
0: 		register(EventHandler.class, new BundleEventHandler(), properties);
0: 	}
0: 	public void stop(BundleContext context) throws Exception {
0: 		if (LOGGER.isDebugEnabled()) {
0: 			LOGGER.debug("subsystem activator stopping");
0: 		}
0: 		context.getBundle(0).getBundleContext().removeBundleListener(bundleListener);
0: 		for (ServiceRegistration<?> r : registrations) {
0: 			try {
0: 				r.unregister();
0: 			} catch (Exception e) {
0: 				LOGGER.warn("Subsystem Activator shut down", e);
0: 			}
0: 		}
0: 	}
0: 	private <T> void register(Class<T> clazz, T service, Dictionary<String, ?> props) {
0: 		registrations.add(context.registerService(clazz.getName(), service, props));
0: 	}
1: 	
0: 	private <T> void register(String clazz, T service, Dictionary<String, ?> props) {
0: 		registrations.add(context.registerService(clazz, service, props));
0: 	}
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:79b20bc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.ContentHandler;
1: import org.apache.aries.subsystem.core.content.ConfigAdminContentHandler;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
1:     private volatile ConfigAdminContentHandler configAdminHandler;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:         Dictionary<String, Object> handlerProps = new Hashtable<String, Object>();
1:         handlerProps.put(ContentHandler.CONTENT_TYPE_PROPERTY, ConfigAdminContentHandler.CONTENT_TYPES);
1:         configAdminHandler = new ConfigAdminContentHandler(bundleContext);
1:         registrations.add(bundleContext.registerService(ContentHandler.class, configAdminHandler, handlerProps));
0: 
/////////////////////////////////////////////////////////////////////////
1:         configAdminHandler.shutDown();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:9bba779
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(Activator.class);
1:     public static final String MODELLED_RESOURCE_MANAGER = "org.apache.aries.application.modelling.ModelledResourceManager";
0: 
1:     public static final String LOG_ENTRY = "Method entry: {}, args {}";
1:     public static final String LOG_EXIT = "Method exit: {}, returning {}";
0: 
0:     private static Activator instance;
/////////////////////////////////////////////////////////////////////////
1:     private volatile Object modelledResourceManager;
0:     private volatile ServiceModeller serviceModeller;
/////////////////////////////////////////////////////////////////////////
1:     public ServiceModeller getServiceModeller() {
1:         return serviceModeller;
0:     }
0: 
0:     public RegionDigraph getRegionDigraph() {
/////////////////////////////////////////////////////////////////////////
1: 	private <T> T findAlternateServiceFor(Class<T> service) {
1: 			if (service.isInstance(alternate))
1: 					return service.cast(alternate);
/////////////////////////////////////////////////////////////////////////
1: 				.append(MODELLED_RESOURCE_MANAGER).append(")(")
/////////////////////////////////////////////////////////////////////////
1: 		else {
0:             try {
1:                 Class clazz = getClass().getClassLoader().loadClass(MODELLED_RESOURCE_MANAGER);
0:                 if (clazz.isInstance(service) && serviceModeller == null) {
1:                     modelledResourceManager = service;
1:                     serviceModeller = new ApplicationServiceModeller(service);
0:                 }
1:             } catch (ClassNotFoundException e) {
1:                 // ignore
1:             } catch (NoClassDefFoundError e) {
1:                 // ignore
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
1: 				Coordinator coordinator = findAlternateServiceFor(Coordinator.class);
/////////////////////////////////////////////////////////////////////////
1: 				RegionDigraph regionDigraph = findAlternateServiceFor(RegionDigraph.class);
/////////////////////////////////////////////////////////////////////////
1: 				Resolver resolver = findAlternateServiceFor(Resolver.class);
0: 		else if (service instanceof Repository)
0:         else {
0:             if (service.equals(modelledResourceManager)) {
0:                 try {
0:                     Class clazz = getClass().getClassLoader().loadClass(MODELLED_RESOURCE_MANAGER);
1:                     Object manager = findAlternateServiceFor(clazz);
1:                     if (manager == null) {
1:                         modelledResourceManager = null;
1:                         serviceModeller = null;
1:                     } else {
0:                         modelledResourceManager = service;
0:                         serviceModeller = new ApplicationServiceModeller(service);
0:                     }
0:                 } catch (ClassNotFoundException e) {
0:                     // ignore
0:                 } catch (NoClassDefFoundError e) {
0:                     // ignore
0:                 }
0:             }
0:         }
commit:c84d925
/////////////////////////////////////////////////////////////////////////
0: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.aries.subsystem.core.internal;
0: 
0: import java.util.ArrayList;
0: import java.util.Dictionary;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import org.apache.aries.subsystem.SubsystemAdmin;
0: import org.apache.aries.subsystem.SubsystemConstants;
0: import org.apache.aries.subsystem.spi.ResourceProcessor;
0: import org.apache.aries.subsystem.spi.ResourceResolver;
0: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleActivator;
1: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.ServiceFactory;
1: import org.osgi.framework.ServiceRegistration;
0: 
1: /**
0:  * The bundle activator for the this bundle.
0:  * When the bundle is starting, this activator will create
0:  * and register the SubsystemAdmin service.
0:  */
0: public class Activator implements BundleActivator {
0: 
0:     private BundleContext context;
0:     private List<ServiceRegistration> registrations = new ArrayList<ServiceRegistration>();
0: 
0:     public void start(BundleContext context) throws Exception {
0:         this.context = context;
0:         register(SubsystemAdmin.class, new SubsystemAdminFactory(), null);
0:         register(ResourceResolver.class,
0:                  new NoOpResolver(),
0:                  DictionaryBuilder.build(Constants.SERVICE_RANKING, Integer.MIN_VALUE));
0:         register(ResourceProcessor.class,
0:                 new BundleResourceProcessor(),
0:                 DictionaryBuilder.build(SubsystemConstants.SERVICE_RESOURCE_TYPE, SubsystemConstants.RESOURCE_TYPE_BUNDLE));
0:         register(ResourceProcessor.class,
0:                 new SubsystemResourceProcessor(),
0:                 DictionaryBuilder.build(SubsystemConstants.SERVICE_RESOURCE_TYPE, SubsystemConstants.RESOURCE_TYPE_SUBSYSTEM));
0:     }
0: 
0:     protected <T> void register(Class<T> clazz, T service, Dictionary props) {
0:          registrations.add(context.registerService(clazz.getName(), service, props));
0:     }
0: 
0:     protected <T> void register(Class<T> clazz, ServiceFactory factory, Dictionary props) {
0:          registrations.add(context.registerService(clazz.getName(), factory, props));
0:     }
0: 
0:     public void stop(BundleContext context) throws Exception {
0:         for (ServiceRegistration r : registrations) {
0:             try {
0:                 r.unregister();
0:             } catch (Exception e) {
0:                 // Ignore
0:             }
0:         }
0:     }
0: 
0: 
0:     public static class SubsystemAdminFactory implements ServiceFactory {
0: 
0:         private final Map<BundleContext, SubsystemAdminImpl> admins = new HashMap<BundleContext, SubsystemAdminImpl>();
0:         private final Map<SubsystemAdminImpl, Long> references = new HashMap<SubsystemAdminImpl, Long>();
0: 
0:         public synchronized Object getService(Bundle bundle, ServiceRegistration registration) {
0:             BundleContext systemBundleContext = bundle.getBundleContext().getBundle(0).getBundleContext();
0:             SubsystemAdminImpl admin = admins.get(systemBundleContext);
0:             long ref = 0;
0:             if (admin == null) {
0:                 admin = new SubsystemAdminImpl(systemBundleContext);
0:                 admins.put(systemBundleContext, admin);
0:             } else {
0:                 ref = references.get(admin);
0:             }
0:             references.put(admin, ref + 1);
0:             return admin;
0:         }
0: 
0:         public synchronized void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
0:             SubsystemAdminImpl admin = (SubsystemAdminImpl) service;
0:             long ref = references.get(admin) - 1;
0:             if (ref == 0) {
0:                 admin.dispose();
0:                 admins.remove(admin.context);
0:                 references.remove(admin);
0:             } else {
0:                 references.put(admin, ref);
0:             }
0:         }
0: 
0:     }
0: 
0: }
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:69d4847
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.filesystem.IDirectoryFinder;
/////////////////////////////////////////////////////////////////////////
1: 	private final Collection<IDirectoryFinder> finders = Collections.synchronizedSet(new HashSet<IDirectoryFinder>());
/////////////////////////////////////////////////////////////////////////
1: 	public Collection<IDirectoryFinder> getIDirectoryFinders() {
1: 		return Collections.unmodifiableCollection(finders);
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0:         .append(Repository.class.getName()).append(")(")
0:         .append(ModelledResourceManager.class.getName()).append(")(")
0:         .append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
0:         .append(IDirectoryFinder.class.getName()).append("))").toString();
/////////////////////////////////////////////////////////////////////////
0:     else if (service instanceof IDirectoryFinder)
0:       finders.add((IDirectoryFinder)service);
/////////////////////////////////////////////////////////////////////////
0:     else if (service instanceof IDirectoryFinder)
0:       finders.remove(service);
author:Graham Charters
-------------------------------------------------------------------------------
commit:6f4b079
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.ResourceResolver;
0: import org.eclipse.equinox.region.RegionDigraph;
0: import org.osgi.service.coordinator.Coordinator;
/////////////////////////////////////////////////////////////////////////
0:     static Coordinator getCoordinator() {
0:     	return context.getService(context.getServiceReference(Coordinator.class));
0:     }
0:     
0:     private ServiceTracker scopeServiceTracker;
0:     
0:     public void start(final BundleContext context) throws Exception {
0:         Activator.eventDispatcher = new SubsystemEventDispatcher(context);   
0:                 new ResourceResolverImpl(context),
0:                 new BundleResourceProcessor(context),
0:                 new SubsystemResourceProcessor(context),
0:         scopeServiceTracker = new ServiceTracker(
0:         		context,
0:         		RegionDigraph.class.getName(),
0:         		new ServiceTrackerCustomizer() {
0:         			private ServiceReference<?> scopeRef;
0:         			private ServiceRegistration<?> subsystemReg;
0:         			
0: 					public synchronized Object addingService(ServiceReference reference) {
0: 						if (subsystemReg != null) return null;
0: 						RegionDigraph digraph = (RegionDigraph)context.getService(reference);
0: 						if (digraph == null) return null;
0: 						subsystemReg = context.registerService(Subsystem.class.getName(), new SubsystemServiceFactory(digraph.getRegion(context.getBundle())), null);
0: 						return digraph;
0: 					}
0: 
0: 					public void modifiedService(ServiceReference reference, Object service) {
0: 						// Do nothing.
0: 					}
0: 
0: 					public synchronized void removedService(ServiceReference reference, Object service) {
0: 						if (reference != scopeRef) return;
0: 						subsystemReg.unregister();
0: 						subsystemReg = null;
0: 						// TODO Look for another service?
0: 					}
0:         		});
0:         scopeServiceTracker.open();
/////////////////////////////////////////////////////////////////////////
0:         scopeServiceTracker.close();
0:         for (ServiceRegistration<?> r : registrations) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e9f9bca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.scope.Scope;
/////////////////////////////////////////////////////////////////////////
0:         private Scope scopeAdmin; // scope admin for the root scope.
/////////////////////////////////////////////////////////////////////////
0:             ServiceReference reference = Activator.getBundleContext().getServiceReference(Scope.class.getName());
0:             if (reference != null) {
0:                 Scope scopeAdmin = (Scope)Activator.getBundleContext().getService(reference);
0:                 Subsystem subsystem = new SubsystemImpl(scopeAdmin, new HashMap<String, String>());
author:Lin Sun
-------------------------------------------------------------------------------
commit:a5b502b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
0: import org.apache.aries.subsystem.Subsystem;
0: import org.apache.aries.subsystem.SubsystemException;
0: import org.apache.aries.subsystem.scope.ScopeAdmin;
0: import org.osgi.framework.Filter;
0: import org.osgi.framework.FrameworkUtil;
0: import org.osgi.framework.InvalidSyntaxException;
0: import org.osgi.framework.ServiceReference;
0: import org.osgi.util.tracker.ServiceTracker;
0: import org.osgi.util.tracker.ServiceTrackerCustomizer;
/////////////////////////////////////////////////////////////////////////
0:     private static BundleContext context;
0:     private static SubsystemAdminFactory adminFactory;
0:     
0:         Activator.context = context;
0:         Activator.eventDispatcher = new SubsystemEventDispatcher(context);
0:         adminFactory = new SubsystemAdminFactory();
0:         register(SubsystemAdmin.class, adminFactory, null);
/////////////////////////////////////////////////////////////////////////
0:         if (adminFactory!= null) {
0:             adminFactory.destroy();
0:         }
0:         
0:     }
0:     
0:     public static BundleContext getBundleContext() {
0:         return context;
0:     }
0:     
0:     public static SubsystemEventDispatcher getEventDispatcher() {
0:         return eventDispatcher;
0:         //private final List<ScopeAdmin> scopeAdmins = new ArrayList<ScopeAdmin>();
0:         private final List<SubsystemAdmin> admins = new ArrayList<SubsystemAdmin>();
0:         private final Map<SubsystemAdmin, Long> references = new HashMap<SubsystemAdmin, Long>();
0:         private ScopeAdmin scopeAdmin; // scope admin for the root scope.
0:         private static ServiceTracker serviceTracker;
0:         private SubsystemAdmin defaultAdmin;
0:         private ServiceRegistration rootAdminReg;
0:         
0:         public SubsystemAdminFactory() throws InvalidSyntaxException  {
0:             context = Activator.getBundleContext();
0:             
0:             ServiceReference[] reference = Activator.getBundleContext().getServiceReferences(ScopeAdmin.class.getName(), 
0:             "(&(ScopeName=root))");
0:             if (reference != null && reference.length == 1) {
0:                 ScopeAdmin scopeAdmin = (ScopeAdmin)Activator.getBundleContext().getService(reference[0]);
0:                 Subsystem subsystem = new SubsystemImpl(scopeAdmin.getScope(), new HashMap<String, String>());
0:                 defaultAdmin = new SubsystemAdminImpl(scopeAdmin, subsystem, null);
0:                 rootAdminReg = context.registerService(SubsystemAdmin.class.getName(), 
0:                         defaultAdmin, 
0:                         DictionaryBuilder.build("Subsystem", subsystem.getSubsystemId(), "SubsystemParentId", 0));
0:                 admins.add(defaultAdmin);
0:             } else {
0:                 throw new RuntimeException("Unable to locate service reference for the root scope admin");
0:             }
0:             
0:             Filter filter = FrameworkUtil.createFilter("(&("
0:                     + Constants.OBJECTCLASS + "=" + SubsystemAdmin.class.getName() + "))");
0:             serviceTracker = new ServiceTracker(context, filter,
0:                     new ServiceTrackerCustomizer() {
0:                         public Object addingService(ServiceReference reference) {
0:                             // adding new service, update admins map
0:                             SubsystemAdmin sa = (SubsystemAdmin) context
0:                                     .getService(reference);
0:                             admins.add(sa);
0:                             return sa;
0:                         }
0: 
0:                         public void modifiedService(ServiceReference reference,
0:                                 Object service) {
0:                             // TODO Auto-generated method stub
0: 
0:                         }
0: 
0:                         public void removedService(ServiceReference reference,
0:                                 Object service) {
0:                             SubsystemAdmin sa = (SubsystemAdmin) service;
0:                             admins.remove(sa);
0:                         }
0: 
0:                     });
0:         }
0:         
0:         public void destroy() {
0:             serviceTracker.close();
0:         }
0:         
0:         private SubsystemAdmin getSubsystemAdmin(Bundle bundle) {
0:             // first check if it is in root framework
0:             Bundle[] bundles = Activator.getBundleContext().getBundles();
0:             for (Bundle b : bundles) {
0:                 if (b == bundle) {
0:                     return defaultAdmin;
0:                 }
0:             }
0:             // check if they are bundles in the 
0:             for (SubsystemAdmin admin : admins) {
0:                 Collection<Subsystem> subsystems = admin.getSubsystems();
0:                 for (Subsystem subsystem : subsystems) {
0:                     Collection<Bundle> subsystemBundles = subsystem.getBundles();
0:                     for (Bundle b : subsystemBundles) {
0:                         if (b == bundle) {
0:                             return admin;
0:                         }
0:                     }
0:                 }
0:             }
0:             
0:             return null;
0:         }
0:             
0:             
0:             // figure out the subsystemAdmin for the bundle           
0:             SubsystemAdmin admin = getSubsystemAdmin(bundle);
0:             
0:                 throw new SubsystemException("Unable to locate the Subsystem admin for the bundle " + bundle.toString());
0: 
0:             if (references.get(admin) == null) {
0:                 ref = 0;
0:             }
0:             
commit:207177a
/////////////////////////////////////////////////////////////////////////
0:         register(ResourceResolver.class,
0:                 new ResourceResolverImpl(this.context),
0:                 DictionaryBuilder.build(Constants.SERVICE_RANKING, 0));
commit:6490c01
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOGGER = LoggerFactory.getLogger(Activator.class);
0:     
0:         if (LOGGER.isDebugEnabled()) {
0:             LOGGER.debug("subsystem activator starting");
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (LOGGER.isDebugEnabled()) {
0:             LOGGER.debug("subsystem activator stopping");
0:         }
0:                 LOGGER.warn("Subsystem Activator shut down", e);
0:         eventDispatcher.destroy();
/////////////////////////////////////////////////////////////////////////
0:             if (LOGGER.isDebugEnabled()) {
0:                 LOGGER.debug("Get SubsystemAdmin service from bundle symbolic name {} version {}", bundle.getSymbolicName(), bundle.getVersion());
0:             }
/////////////////////////////////////////////////////////////////////////
0:             if (LOGGER.isDebugEnabled()) {
0:                 LOGGER.debug("Unget SubsystemAdmin service {} from bundle symbolic name {} version {}", new Object[] {service, bundle.getSymbolicName(), bundle.getVersion()});
0:             }
commit:071013f
/////////////////////////////////////////////////////////////////////////
0:     private static SubsystemEventDispatcher eventDispatcher;
0:         eventDispatcher = new SubsystemEventDispatcher(context);
0:         
/////////////////////////////////////////////////////////////////////////
0:                 admin = new SubsystemAdminImpl(systemBundleContext, eventDispatcher);
============================================================================