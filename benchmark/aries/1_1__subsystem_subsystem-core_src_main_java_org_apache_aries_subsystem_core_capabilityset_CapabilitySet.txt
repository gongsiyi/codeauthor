1:9df8274: /*
1:9df8274:  * Licensed to the Apache Software Foundation (ASF) under one
1:9df8274:  * or more contributor license agreements.  See the NOTICE file
1:9df8274:  * distributed with this work for additional information
1:9df8274:  * regarding copyright ownership.  The ASF licenses this file
1:9df8274:  * to you under the Apache License, Version 2.0 (the
1:9df8274:  * "License"); you may not use this file except in compliance
1:9df8274:  * with the License.  You may obtain a copy of the License at
1:9df8274:  *
1:9df8274:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9df8274:  *
1:9df8274:  * Unless required by applicable law or agreed to in writing,
1:9df8274:  * software distributed under the License is distributed on an
1:9df8274:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9df8274:  * KIND, either express or implied.  See the License for the
1:9df8274:  * specific language governing permissions and limitations
1:9df8274:  * under the License.
1:9df8274:  */
1:9df8274: package org.apache.aries.subsystem.core.capabilityset;
1:9df8274: 
1:9df8274: import java.lang.reflect.Array;
1:9df8274: import java.lang.reflect.Constructor;
1:9df8274: import java.lang.reflect.Method;
1:9df8274: import java.lang.reflect.Modifier;
1:9df8274: import java.util.ArrayList;
1:9df8274: import java.util.Arrays;
1:9df8274: import java.util.Collection;
1:9df8274: import java.util.Collections;
1:9df8274: import java.util.Iterator;
1:9df8274: import java.util.List;
1:9df8274: import java.util.Map;
1:9df8274: import java.util.Map.Entry;
1:9df8274: import java.util.Set;
1:9df8274: import java.util.SortedMap;
1:9df8274: import java.util.concurrent.ConcurrentHashMap;
1:9df8274: import java.util.concurrent.ConcurrentMap;
1:9df8274: import java.util.concurrent.ConcurrentSkipListMap;
1:9df8274: 
1:9df8274: import org.osgi.framework.Version;
1:9df8274: import org.osgi.framework.VersionRange;
1:9df8274: import org.osgi.framework.namespace.AbstractWiringNamespace;
1:9df8274: import org.osgi.resource.Capability;
1:9df8274: 
1:9df8274: public class CapabilitySet
1:9df8274: {
1:9df8274:     private final SortedMap<String, Map<Object, Set<Capability>>> m_indices; // Should also be concurrent!
1:9df8274:     private final Set<Capability> m_capSet = Collections.newSetFromMap(new ConcurrentHashMap<Capability, Boolean>());
1:9df8274:     private final static SecureAction m_secureAction = new SecureAction();
1:9df8274: 
1:9df8274: //    public void dump()
1:9df8274: //    {
1:9df8274: //        for (Entry<String, Map<Object, Set<Capability>>> entry : m_indices.entrySet())
1:9df8274: //        {
1:9df8274: //            boolean header1 = false;
1:9df8274: //            for (Entry<Object, Set<Capability>> entry2 : entry.getValue().entrySet())
1:9df8274: //            {
1:9df8274: //                boolean header2 = false;
1:9df8274: //                for (Capability cap : entry2.getValue())
1:9df8274: //                {
1:9df8274: //                    if (cap.getRevision().getBundle().getBundleId() != 0)
1:9df8274: //                    {
1:9df8274: //                        if (!header1)
1:9df8274: //                        {
1:9df8274: //                            System.out.println(entry.getKey() + ":");
1:9df8274: //                            header1 = true;
1:9df8274: //                        }
1:9df8274: //                        if (!header2)
1:9df8274: //                        {
1:9df8274: //                            System.out.println("   " + entry2.getKey());
1:9df8274: //                            header2 = true;
1:9df8274: //                        }
1:9df8274: //                        System.out.println("      " + cap);
1:9df8274: //                    }
1:9df8274: //                }
1:9df8274: //            }
1:9df8274: //        }
1:9df8274: //    }
1:9df8274: 
1:9df8274:     public CapabilitySet(final List<String> indexProps, final boolean caseSensitive)
1:9df8274:     {
1:9df8274:         m_indices = (caseSensitive)
1:9df8274:             ? new ConcurrentSkipListMap<String, Map<Object, Set<Capability>>>()
1:9df8274:             : new ConcurrentSkipListMap<String, Map<Object, Set<Capability>>>(
1:9df8274:                 StringComparator.COMPARATOR);
1:9df8274:         for (int i = 0; (indexProps != null) && (i < indexProps.size()); i++)
1:9df8274:         {
1:9df8274:             m_indices.put(
1:9df8274:                 indexProps.get(i), new ConcurrentHashMap<Object, Set<Capability>>());
1:9df8274:         }
1:9df8274:     }
1:9df8274: 
1:9df8274:     public void addCapability(final Capability cap)
1:9df8274:     {
1:9df8274:         m_capSet.add(cap);
1:9df8274: 
1:9df8274:         // Index capability.
1:9df8274:         for (Entry<String, Map<Object, Set<Capability>>> entry : m_indices.entrySet())
1:9df8274:         {
1:9df8274:             Object value = cap.getAttributes().get(entry.getKey());
1:9df8274:             if (value != null)
1:9df8274:             {
1:9df8274:                 if (value.getClass().isArray())
1:9df8274:                 {
1:9df8274:                     value = convertArrayToList(value);
1:9df8274:                 }
1:9df8274: 
1:9df8274:                 ConcurrentMap<Object, Set<Capability>> index =
1:9df8274:                         (ConcurrentMap<Object, Set<Capability>>) entry.getValue();
1:9df8274: 
1:9df8274:                 if (value instanceof Collection)
1:9df8274:                 {
1:9df8274:                     Collection c = (Collection) value;
1:9df8274:                     for (Object o : c)
1:9df8274:                     {
1:9df8274:                         indexCapability(index, cap, o);
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:                 else
1:9df8274:                 {
1:9df8274:                     indexCapability(index, cap, value);
1:9df8274:                 }
1:9df8274:             }
1:9df8274:         }
1:9df8274:     }
1:9df8274: 
1:9df8274:     private void indexCapability(
1:9df8274:         ConcurrentMap<Object, Set<Capability>> index, Capability cap, Object capValue)
1:9df8274:     {
1:9df8274:         Set<Capability> caps = Collections.newSetFromMap(new ConcurrentHashMap<Capability, Boolean>());
1:9df8274:         Set<Capability> prevval = index.putIfAbsent(capValue, caps);
1:9df8274:         if (prevval != null)
1:9df8274:             caps = prevval;
1:9df8274:         caps.add(cap);
1:9df8274:     }
1:9df8274: 
1:9df8274:     public void removeCapability(final Capability cap)
1:9df8274:     {
1:9df8274:         if (m_capSet.remove(cap))
1:9df8274:         {
1:9df8274:             for (Entry<String, Map<Object, Set<Capability>>> entry : m_indices.entrySet())
1:9df8274:             {
1:9df8274:                 Object value = cap.getAttributes().get(entry.getKey());
1:9df8274:                 if (value != null)
1:9df8274:                 {
1:9df8274:                     if (value.getClass().isArray())
1:9df8274:                     {
1:9df8274:                         value = convertArrayToList(value);
1:9df8274:                     }
1:9df8274: 
1:9df8274:                     Map<Object, Set<Capability>> index = entry.getValue();
1:9df8274: 
1:9df8274:                     if (value instanceof Collection)
1:9df8274:                     {
1:9df8274:                         Collection c = (Collection) value;
1:9df8274:                         for (Object o : c)
1:9df8274:                         {
1:9df8274:                             deindexCapability(index, cap, o);
1:9df8274:                         }
1:9df8274:                     }
1:9df8274:                     else
1:9df8274:                     {
1:9df8274:                         deindexCapability(index, cap, value);
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:             }
1:9df8274:         }
1:9df8274:     }
1:9df8274: 
1:9df8274:     private void deindexCapability(
1:9df8274:         Map<Object, Set<Capability>> index, Capability cap, Object value)
1:9df8274:     {
1:9df8274:         Set<Capability> caps = index.get(value);
1:9df8274:         if (caps != null)
1:9df8274:         {
1:9df8274:             caps.remove(cap);
1:9df8274:             if (caps.isEmpty())
1:9df8274:             {
1:9df8274:                 index.remove(value);
1:9df8274:             }
1:9df8274:         }
1:9df8274:     }
1:9df8274: 
1:9df8274:     public Set<Capability> match(final SimpleFilter sf, final boolean obeyMandatory)
1:9df8274:     {
1:9df8274:         final Set<Capability> matches = match(m_capSet, sf);
1:9df8274:         return (obeyMandatory)
1:9df8274:             ? matchMandatory(matches, sf)
1:9df8274:             : matches;
1:9df8274:     }
1:9df8274: 
1:9df8274:     private Set<Capability> match(Set<Capability> caps, final SimpleFilter sf)
1:9df8274:     {
1:9df8274:         Set<Capability> matches = Collections.newSetFromMap(new ConcurrentHashMap<Capability, Boolean>());
1:9df8274: 
1:9df8274:         if (sf.getOperation() == SimpleFilter.MATCH_ALL)
1:9df8274:         {
1:9df8274:             matches.addAll(caps);
1:9df8274:         }
1:9df8274:         else if (sf.getOperation() == SimpleFilter.AND)
1:9df8274:         {
1:9df8274:             // Evaluate each subfilter against the remaining capabilities.
1:9df8274:             // For AND we calculate the intersection of each subfilter.
1:9df8274:             // We can short-circuit the AND operation if there are no
1:9df8274:             // remaining capabilities.
1:9df8274:             final List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:9df8274:             for (int i = 0; (caps.size() > 0) && (i < sfs.size()); i++)
1:9df8274:             {
1:9df8274:                 matches = match(caps, sfs.get(i));
1:9df8274:                 caps = matches;
1:9df8274:             }
1:9df8274:         }
1:9df8274:         else if (sf.getOperation() == SimpleFilter.OR)
1:9df8274:         {
1:9df8274:             // Evaluate each subfilter against the remaining capabilities.
1:9df8274:             // For OR we calculate the union of each subfilter.
1:9df8274:             List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:9df8274:             for (int i = 0; i < sfs.size(); i++)
1:9df8274:             {
1:9df8274:                 matches.addAll(match(caps, sfs.get(i)));
1:9df8274:             }
1:9df8274:         }
1:9df8274:         else if (sf.getOperation() == SimpleFilter.NOT)
1:9df8274:         {
1:9df8274:             // Evaluate each subfilter against the remaining capabilities.
1:9df8274:             // For OR we calculate the union of each subfilter.
1:9df8274:             matches.addAll(caps);
1:9df8274:             List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:9df8274:             for (int i = 0; i < sfs.size(); i++)
1:9df8274:             {
1:9df8274:                 matches.removeAll(match(caps, sfs.get(i)));
1:9df8274:             }
1:9df8274:         }
1:9df8274:         else
1:9df8274:         {
1:9df8274:             Map<Object, Set<Capability>> index = m_indices.get(sf.getName());
1:9df8274:             if ((sf.getOperation() == SimpleFilter.EQ) && (index != null))
1:9df8274:             {
1:9df8274:                 Set<Capability> existingCaps = index.get(sf.getValue());
1:9df8274:                 if (existingCaps != null)
1:9df8274:                 {
1:9df8274:                     matches.addAll(existingCaps);
1:9df8274:                     if (caps != m_capSet)
1:9df8274:                     {
1:9df8274:                         matches.retainAll(caps);
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 for (Iterator<Capability> it = caps.iterator(); it.hasNext(); )
1:9df8274:                 {
1:9df8274:                     Capability cap = it.next();
1:9df8274:                     Object lhs = cap.getAttributes().get(sf.getName());
1:9df8274:                     if (lhs != null)
1:9df8274:                     {
1:9df8274:                         if (compare(lhs, sf.getValue(), sf.getOperation()))
1:9df8274:                         {
1:9df8274:                             matches.add(cap);
1:9df8274:                         }
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:             }
1:9df8274:         }
1:9df8274: 
1:9df8274:         return matches;
1:9df8274:     }
1:9df8274: 
1:9df8274: //    public static boolean matches(Capability cap, SimpleFilter sf)
1:9df8274: //    {
1:9df8274: //        return matchesInternal(cap, sf) && matchMandatory(cap, sf);
1:9df8274: //    }
1:9df8274: 
1:9df8274: //    private static boolean matchesInternal(Capability cap, SimpleFilter sf)
1:9df8274: //    {
1:9df8274: //        boolean matched = true;
1:9df8274: //
1:9df8274: //        if (sf.getOperation() == SimpleFilter.MATCH_ALL)
1:9df8274: //        {
1:9df8274: //            matched = true;
1:9df8274: //        }
1:9df8274: //        else if (sf.getOperation() == SimpleFilter.AND)
1:9df8274: //        {
1:9df8274: //            // Evaluate each subfilter against the remaining capabilities.
1:9df8274: //            // For AND we calculate the intersection of each subfilter.
1:9df8274: //            // We can short-circuit the AND operation if there are no
1:9df8274: //            // remaining capabilities.
1:9df8274: //            List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:9df8274: //            for (int i = 0; matched && (i < sfs.size()); i++)
1:9df8274: //            {
1:9df8274: //                matched = matchesInternal(cap, sfs.get(i));
1:9df8274: //            }
1:9df8274: //        }
1:9df8274: //        else if (sf.getOperation() == SimpleFilter.OR)
1:9df8274: //        {
1:9df8274: //            // Evaluate each subfilter against the remaining capabilities.
1:9df8274: //            // For OR we calculate the union of each subfilter.
1:9df8274: //            matched = false;
1:9df8274: //            List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:9df8274: //            for (int i = 0; !matched && (i < sfs.size()); i++)
1:9df8274: //            {
1:9df8274: //                matched = matchesInternal(cap, sfs.get(i));
1:9df8274: //            }
1:9df8274: //        }
1:9df8274: //        else if (sf.getOperation() == SimpleFilter.NOT)
1:9df8274: //        {
1:9df8274: //            // Evaluate each subfilter against the remaining capabilities.
1:9df8274: //            // For OR we calculate the union of each subfilter.
1:9df8274: //            List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:9df8274: //            for (int i = 0; i < sfs.size(); i++)
1:9df8274: //            {
1:9df8274: //                matched = !(matchesInternal(cap, sfs.get(i)));
1:9df8274: //            }
1:9df8274: //        }
1:9df8274: //        else
1:9df8274: //        {
1:9df8274: //            matched = false;
1:9df8274: //            Object lhs = cap.getAttributes().get(sf.getName());
1:9df8274: //            if (lhs != null)
1:9df8274: //            {
1:9df8274: //                matched = compare(lhs, sf.getValue(), sf.getOperation());
1:9df8274: //            }
1:9df8274: //        }
1:9df8274: //
1:9df8274: //        return matched;
1:9df8274: //    }
1:9df8274: 
1:9df8274:     private static Set<Capability> matchMandatory(
1:9df8274:         Set<Capability> caps, SimpleFilter sf)
1:9df8274:     {
1:9df8274:         for (Iterator<Capability> it = caps.iterator(); it.hasNext(); )
1:9df8274:         {
1:9df8274:             Capability cap = it.next();
1:9df8274:             if (!matchMandatory(cap, sf))
1:9df8274:             {
1:9df8274:                 it.remove();
1:9df8274:             }
1:9df8274:         }
1:9df8274:         return caps;
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static boolean matchMandatory(Capability cap, SimpleFilter sf)
1:9df8274:     {
1:9df8274:         String mandatoryDirective = cap.getDirectives().get(AbstractWiringNamespace.CAPABILITY_MANDATORY_DIRECTIVE);
1:9df8274:         if (mandatoryDirective == null) {
1:9df8274:             // There are no mandatory attributes to check.
1:9df8274:             return true;
1:9df8274:         }
1:9df8274:         List<String> mandatoryAttributes = Arrays.asList(mandatoryDirective.split(","));
1:9df8274:         
1:9df8274:         Map<String, Object> attrs = cap.getAttributes();
1:9df8274:         for (Entry<String, Object> entry : attrs.entrySet())
1:9df8274:         {
1:9df8274:             if (mandatoryAttributes.contains(entry.getKey())
1:9df8274:                 && !matchMandatoryAttrbute(entry.getKey(), sf))
1:9df8274:             {
1:9df8274:                 return false;
1:9df8274:             }
1:9df8274:         }
1:9df8274:         return true;
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static boolean matchMandatoryAttrbute(String attrName, SimpleFilter sf)
1:9df8274:     {
1:9df8274:         if ((sf.getName() != null) && sf.getName().equals(attrName))
1:9df8274:         {
1:9df8274:             return true;
1:9df8274:         }
1:9df8274:         else if (sf.getOperation() == SimpleFilter.AND)
1:9df8274:         {
1:9df8274:             List list = (List) sf.getValue();
1:9df8274:             for (int i = 0; i < list.size(); i++)
1:9df8274:             {
1:9df8274:                 SimpleFilter sf2 = (SimpleFilter) list.get(i);
1:9df8274:                 if ((sf2.getName() != null)
1:9df8274:                     && sf2.getName().equals(attrName))
1:9df8274:                 {
1:9df8274:                     return true;
1:9df8274:                 }
1:9df8274:             }
1:9df8274:         }
1:9df8274:         return false;
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static final Class<?>[] STRING_CLASS = new Class[] { String.class };
1:9df8274:     private static final String VALUE_OF_METHOD_NAME = "valueOf";
1:9df8274: 
1:9df8274:     private static boolean compare(Object lhs, Object rhsUnknown, int op)
1:9df8274:     {
1:9df8274:         if (lhs == null)
1:9df8274:         {
1:9df8274:             return false;
1:9df8274:         }
1:9df8274: 
1:9df8274:         // If this is a PRESENT operation, then just return true immediately
1:9df8274:         // since we wouldn't be here if the attribute wasn't present.
1:9df8274:         if (op == SimpleFilter.PRESENT)
1:9df8274:         {
1:9df8274:             return true;
1:9df8274:         }
1:9df8274: 
1:9df8274:         //Need a special case here when lhs is a Version and rhs is a VersionRange
1:9df8274:         //Version is comparable so we need to check this first
1:9df8274:         if(lhs instanceof Version && op == SimpleFilter.EQ)
1:9df8274:         {
1:9df8274:             Object rhs = null;
1:9df8274:             try
1:9df8274:             {
1:9df8274:                 rhs = coerceType(lhs, (String) rhsUnknown);
1:9df8274:             }
1:9df8274:             catch (Exception ex)
1:9df8274:             {
1:9df8274:                 //Do nothing will check later if rhs is null
1:9df8274:             }
1:9df8274: 
1:9df8274:             if(rhs != null && rhs instanceof VersionRange)
1:9df8274:             {
1:9df8274:                 return ((VersionRange)rhs).includes((Version)lhs);
1:9df8274:             }
1:9df8274:         }
1:9df8274: 
1:9df8274:         // If the type is comparable, then we can just return the
1:9df8274:         // result immediately.
1:9df8274:         if (lhs instanceof Comparable)
1:9df8274:         {
1:9df8274:             // Spec says SUBSTRING is false for all types other than string.
1:9df8274:             if ((op == SimpleFilter.SUBSTRING) && !(lhs instanceof String))
1:9df8274:             {
1:9df8274:                 return false;
1:9df8274:             }
1:9df8274: 
1:9df8274:             Object rhs;
1:9df8274:             if (op == SimpleFilter.SUBSTRING)
1:9df8274:             {
1:9df8274:                 rhs = rhsUnknown;
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 try
1:9df8274:                 {
1:9df8274:                     rhs = coerceType(lhs, (String) rhsUnknown);
1:9df8274:                 }
1:9df8274:                 catch (Exception ex)
1:9df8274:                 {
1:9df8274:                     return false;
1:9df8274:                 }
1:9df8274:             }
1:9df8274: 
1:9df8274:             switch (op)
1:9df8274:             {
1:9df8274:                 case SimpleFilter.EQ :
1:9df8274:                     try
1:9df8274:                     {
1:9df8274:                         return (((Comparable) lhs).compareTo(rhs) == 0);
1:9df8274:                     }
1:9df8274:                     catch (Exception ex)
1:9df8274:                     {
1:9df8274:                         return false;
1:9df8274:                     }
1:9df8274:                 case SimpleFilter.GTE :
1:9df8274:                     try
1:9df8274:                     {
1:9df8274:                         return (((Comparable) lhs).compareTo(rhs) >= 0);
1:9df8274:                     }
1:9df8274:                     catch (Exception ex)
1:9df8274:                     {
1:9df8274:                         return false;
1:9df8274:                     }
1:9df8274:                 case SimpleFilter.LTE :
1:9df8274:                     try
1:9df8274:                     {
1:9df8274:                         return (((Comparable) lhs).compareTo(rhs) <= 0);
1:9df8274:                     }
1:9df8274:                     catch (Exception ex)
1:9df8274:                     {
1:9df8274:                         return false;
1:9df8274:                     }
1:9df8274:                 case SimpleFilter.APPROX :
1:9df8274:                     return compareApproximate(lhs, rhs);
1:9df8274:                 case SimpleFilter.SUBSTRING :
1:9df8274:                     return SimpleFilter.compareSubstring((List<String>) rhs, (String) lhs);
1:9df8274:                 default:
1:9df8274:                     throw new RuntimeException(
1:9df8274:                         "Unknown comparison operator: " + op);
1:9df8274:             }
1:9df8274:         }
1:9df8274:         // Booleans do not implement comparable, so special case them.
1:9df8274:         else if (lhs instanceof Boolean)
1:9df8274:         {
1:9df8274:             Object rhs;
1:9df8274:             try
1:9df8274:             {
1:9df8274:                 rhs = coerceType(lhs, (String) rhsUnknown);
1:9df8274:             }
1:9df8274:             catch (Exception ex)
1:9df8274:             {
1:9df8274:                 return false;
1:9df8274:             }
1:9df8274: 
1:9df8274:             switch (op)
1:9df8274:             {
1:9df8274:                 case SimpleFilter.EQ :
1:9df8274:                 case SimpleFilter.GTE :
1:9df8274:                 case SimpleFilter.LTE :
1:9df8274:                 case SimpleFilter.APPROX :
1:9df8274:                     return (lhs.equals(rhs));
1:9df8274:                 default:
1:9df8274:                     throw new RuntimeException(
1:9df8274:                         "Unknown comparison operator: " + op);
1:9df8274:             }
1:9df8274:         }
1:9df8274: 
1:9df8274:         // If the LHS is not a comparable or boolean, check if it is an
1:9df8274:         // array. If so, convert it to a list so we can treat it as a
1:9df8274:         // collection.
1:9df8274:         if (lhs.getClass().isArray())
1:9df8274:         {
1:9df8274:             lhs = convertArrayToList(lhs);
1:9df8274:         }
1:9df8274: 
1:9df8274:         // If LHS is a collection, then call compare() on each element
1:9df8274:         // of the collection until a match is found.
1:9df8274:         if (lhs instanceof Collection)
1:9df8274:         {
1:9df8274:             for (Iterator iter = ((Collection) lhs).iterator(); iter.hasNext(); )
1:9df8274:             {
1:9df8274:                 if (compare(iter.next(), rhsUnknown, op))
1:9df8274:                 {
1:9df8274:                     return true;
1:9df8274:                 }
1:9df8274:             }
1:9df8274: 
1:9df8274:             return false;
1:9df8274:         }
1:9df8274: 
1:9df8274:         // Spec says SUBSTRING is false for all types other than string.
1:9df8274:         if ((op == SimpleFilter.SUBSTRING) && !(lhs instanceof String))
1:9df8274:         {
1:9df8274:             return false;
1:9df8274:         }
1:9df8274: 
1:9df8274:         // Since we cannot identify the LHS type, then we can only perform
1:9df8274:         // equality comparison.
1:9df8274:         try
1:9df8274:         {
1:9df8274:             return lhs.equals(coerceType(lhs, (String) rhsUnknown));
1:9df8274:         }
1:9df8274:         catch (Exception ex)
1:9df8274:         {
1:9df8274:             return false;
1:9df8274:         }
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static boolean compareApproximate(Object lhs, Object rhs)
1:9df8274:     {
1:9df8274:         if (rhs instanceof String)
1:9df8274:         {
1:9df8274:             return removeWhitespace((String) lhs)
1:9df8274:                 .equalsIgnoreCase(removeWhitespace((String) rhs));
1:9df8274:         }
1:9df8274:         else if (rhs instanceof Character)
1:9df8274:         {
1:9df8274:             return Character.toLowerCase(((Character) lhs))
1:9df8274:                 == Character.toLowerCase(((Character) rhs));
1:9df8274:         }
1:9df8274:         return lhs.equals(rhs);
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static String removeWhitespace(String s)
1:9df8274:     {
1:9df8274:         StringBuffer sb = new StringBuffer(s.length());
1:9df8274:         for (int i = 0; i < s.length(); i++)
1:9df8274:         {
1:9df8274:             if (!Character.isWhitespace(s.charAt(i)))
1:9df8274:             {
1:9df8274:                 sb.append(s.charAt(i));
1:9df8274:             }
1:9df8274:         }
1:9df8274:         return sb.toString();
1:9df8274:     }
1:9df8274: 
1:9df8274:     private static Object coerceType(Object lhs, String rhsString) throws Exception
1:9df8274:     {
1:9df8274:         // If the LHS expects a string, then we can just return
1:9df8274:         // the RHS since it is a string.
1:9df8274:         if (lhs.getClass() == rhsString.getClass())
1:9df8274:         {
1:9df8274:             return rhsString;
1:9df8274:         }
1:9df8274: 
1:9df8274:         // Try to convert the RHS type to the LHS type by using
1:9df8274:         // the string constructor of the LHS class, if it has one.
1:9df8274:         Object rhs = null;
1:9df8274:         try
1:9df8274:         {
1:9df8274:             // The Character class is a special case, since its constructor
1:9df8274:             // does not take a string, so handle it separately.
1:9df8274:             if (lhs instanceof Character)
1:9df8274:             {
1:9df8274:                 rhs = new Character(rhsString.charAt(0));
1:9df8274:             }
1:9df8274:             else if(lhs instanceof Version && rhsString.indexOf(',') >= 0)
1:9df8274:             {
1:9df8274:                 rhs = VersionRange.valueOf(rhsString);
1:9df8274:             }
1:9df8274:             else
1:9df8274:             {
1:9df8274:                 // Spec says we should trim number types.
1:9df8274:                 if ((lhs instanceof Number) || (lhs instanceof Boolean))
1:9df8274:                 {
1:9df8274:                     rhsString = rhsString.trim();
1:9df8274:                 }
1:9df8274: 
1:9df8274:                 try
1:9df8274:                 {
1:9df8274:                     // Try to find a suitable static valueOf method
1:9df8274:                     Method valueOfMethod = m_secureAction.getDeclaredMethod(
1:9df8274:                         lhs.getClass(), VALUE_OF_METHOD_NAME, STRING_CLASS);
1:9df8274:                     if (valueOfMethod.getReturnType().isAssignableFrom(lhs.getClass())
1:9df8274:                         && ((valueOfMethod.getModifiers() & Modifier.STATIC) > 0))
1:9df8274:                     {
1:9df8274:                         m_secureAction.setAccesssible(valueOfMethod);
1:9df8274:                         rhs = valueOfMethod.invoke(null, new Object[] { rhsString });
1:9df8274:                     }
1:9df8274:                 }
1:9df8274:                 catch (Exception ex)
1:9df8274:                 {
1:9df8274:                     // Static valueOf fails, try the next conversion mechanism
1:9df8274:                 }
1:9df8274: 
1:9df8274:                 if (rhs == null)
1:9df8274:                 {
1:9df8274:                     Constructor ctor = m_secureAction.getConstructor(lhs.getClass(), STRING_CLASS);
1:9df8274:                     m_secureAction.setAccesssible(ctor);
1:9df8274:                     rhs = ctor.newInstance(new Object[] { rhsString });
1:9df8274:                 }
1:9df8274:             }
1:9df8274:         }
1:9df8274:         catch (Exception ex)
1:9df8274:         {
1:9df8274:             throw new Exception(
1:9df8274:                 "Could not instantiate class "
1:9df8274:                     + lhs.getClass().getName()
1:9df8274:                     + " from string constructor with argument '"
1:9df8274:                     + rhsString + "' because " + ex);
1:9df8274:         }
1:9df8274: 
1:9df8274:         return rhs;
1:9df8274:     }
1:9df8274: 
1:9df8274:     /**
1:9df8274:      * This is an ugly utility method to convert an array of primitives
1:9df8274:      * to an array of primitive wrapper objects. This method simplifies
1:9df8274:      * processing LDAP filters since the special case of primitive arrays
1:9df8274:      * can be ignored.
1:9df8274:      * @param array An array of primitive types.
1:9df8274:      * @return An corresponding array using pritive wrapper objects.
1:9df8274:     **/
1:9df8274:     private static List convertArrayToList(Object array)
1:9df8274:     {
1:9df8274:         int len = Array.getLength(array);
1:9df8274:         List list = new ArrayList(len);
1:9df8274:         for (int i = 0; i < len; i++)
1:9df8274:         {
1:9df8274:             list.add(Array.get(array, i));
1:9df8274:         }
1:9df8274:         return list;
1:9df8274:     }
1:9df8274: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:9df8274
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.subsystem.core.capabilityset;
1: 
1: import java.lang.reflect.Array;
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.Set;
1: import java.util.SortedMap;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: import java.util.concurrent.ConcurrentSkipListMap;
1: 
1: import org.osgi.framework.Version;
1: import org.osgi.framework.VersionRange;
1: import org.osgi.framework.namespace.AbstractWiringNamespace;
1: import org.osgi.resource.Capability;
1: 
1: public class CapabilitySet
1: {
1:     private final SortedMap<String, Map<Object, Set<Capability>>> m_indices; // Should also be concurrent!
1:     private final Set<Capability> m_capSet = Collections.newSetFromMap(new ConcurrentHashMap<Capability, Boolean>());
1:     private final static SecureAction m_secureAction = new SecureAction();
1: 
1: //    public void dump()
1: //    {
1: //        for (Entry<String, Map<Object, Set<Capability>>> entry : m_indices.entrySet())
1: //        {
1: //            boolean header1 = false;
1: //            for (Entry<Object, Set<Capability>> entry2 : entry.getValue().entrySet())
1: //            {
1: //                boolean header2 = false;
1: //                for (Capability cap : entry2.getValue())
1: //                {
1: //                    if (cap.getRevision().getBundle().getBundleId() != 0)
1: //                    {
1: //                        if (!header1)
1: //                        {
1: //                            System.out.println(entry.getKey() + ":");
1: //                            header1 = true;
1: //                        }
1: //                        if (!header2)
1: //                        {
1: //                            System.out.println("   " + entry2.getKey());
1: //                            header2 = true;
1: //                        }
1: //                        System.out.println("      " + cap);
1: //                    }
1: //                }
1: //            }
1: //        }
1: //    }
1: 
1:     public CapabilitySet(final List<String> indexProps, final boolean caseSensitive)
1:     {
1:         m_indices = (caseSensitive)
1:             ? new ConcurrentSkipListMap<String, Map<Object, Set<Capability>>>()
1:             : new ConcurrentSkipListMap<String, Map<Object, Set<Capability>>>(
1:                 StringComparator.COMPARATOR);
1:         for (int i = 0; (indexProps != null) && (i < indexProps.size()); i++)
1:         {
1:             m_indices.put(
1:                 indexProps.get(i), new ConcurrentHashMap<Object, Set<Capability>>());
1:         }
1:     }
1: 
1:     public void addCapability(final Capability cap)
1:     {
1:         m_capSet.add(cap);
1: 
1:         // Index capability.
1:         for (Entry<String, Map<Object, Set<Capability>>> entry : m_indices.entrySet())
1:         {
1:             Object value = cap.getAttributes().get(entry.getKey());
1:             if (value != null)
1:             {
1:                 if (value.getClass().isArray())
1:                 {
1:                     value = convertArrayToList(value);
1:                 }
1: 
1:                 ConcurrentMap<Object, Set<Capability>> index =
1:                         (ConcurrentMap<Object, Set<Capability>>) entry.getValue();
1: 
1:                 if (value instanceof Collection)
1:                 {
1:                     Collection c = (Collection) value;
1:                     for (Object o : c)
1:                     {
1:                         indexCapability(index, cap, o);
1:                     }
1:                 }
1:                 else
1:                 {
1:                     indexCapability(index, cap, value);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private void indexCapability(
1:         ConcurrentMap<Object, Set<Capability>> index, Capability cap, Object capValue)
1:     {
1:         Set<Capability> caps = Collections.newSetFromMap(new ConcurrentHashMap<Capability, Boolean>());
1:         Set<Capability> prevval = index.putIfAbsent(capValue, caps);
1:         if (prevval != null)
1:             caps = prevval;
1:         caps.add(cap);
1:     }
1: 
1:     public void removeCapability(final Capability cap)
1:     {
1:         if (m_capSet.remove(cap))
1:         {
1:             for (Entry<String, Map<Object, Set<Capability>>> entry : m_indices.entrySet())
1:             {
1:                 Object value = cap.getAttributes().get(entry.getKey());
1:                 if (value != null)
1:                 {
1:                     if (value.getClass().isArray())
1:                     {
1:                         value = convertArrayToList(value);
1:                     }
1: 
1:                     Map<Object, Set<Capability>> index = entry.getValue();
1: 
1:                     if (value instanceof Collection)
1:                     {
1:                         Collection c = (Collection) value;
1:                         for (Object o : c)
1:                         {
1:                             deindexCapability(index, cap, o);
1:                         }
1:                     }
1:                     else
1:                     {
1:                         deindexCapability(index, cap, value);
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private void deindexCapability(
1:         Map<Object, Set<Capability>> index, Capability cap, Object value)
1:     {
1:         Set<Capability> caps = index.get(value);
1:         if (caps != null)
1:         {
1:             caps.remove(cap);
1:             if (caps.isEmpty())
1:             {
1:                 index.remove(value);
1:             }
1:         }
1:     }
1: 
1:     public Set<Capability> match(final SimpleFilter sf, final boolean obeyMandatory)
1:     {
1:         final Set<Capability> matches = match(m_capSet, sf);
1:         return (obeyMandatory)
1:             ? matchMandatory(matches, sf)
1:             : matches;
1:     }
1: 
1:     private Set<Capability> match(Set<Capability> caps, final SimpleFilter sf)
1:     {
1:         Set<Capability> matches = Collections.newSetFromMap(new ConcurrentHashMap<Capability, Boolean>());
1: 
1:         if (sf.getOperation() == SimpleFilter.MATCH_ALL)
1:         {
1:             matches.addAll(caps);
1:         }
1:         else if (sf.getOperation() == SimpleFilter.AND)
1:         {
1:             // Evaluate each subfilter against the remaining capabilities.
1:             // For AND we calculate the intersection of each subfilter.
1:             // We can short-circuit the AND operation if there are no
1:             // remaining capabilities.
1:             final List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:             for (int i = 0; (caps.size() > 0) && (i < sfs.size()); i++)
1:             {
1:                 matches = match(caps, sfs.get(i));
1:                 caps = matches;
1:             }
1:         }
1:         else if (sf.getOperation() == SimpleFilter.OR)
1:         {
1:             // Evaluate each subfilter against the remaining capabilities.
1:             // For OR we calculate the union of each subfilter.
1:             List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:             for (int i = 0; i < sfs.size(); i++)
1:             {
1:                 matches.addAll(match(caps, sfs.get(i)));
1:             }
1:         }
1:         else if (sf.getOperation() == SimpleFilter.NOT)
1:         {
1:             // Evaluate each subfilter against the remaining capabilities.
1:             // For OR we calculate the union of each subfilter.
1:             matches.addAll(caps);
1:             List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1:             for (int i = 0; i < sfs.size(); i++)
1:             {
1:                 matches.removeAll(match(caps, sfs.get(i)));
1:             }
1:         }
1:         else
1:         {
1:             Map<Object, Set<Capability>> index = m_indices.get(sf.getName());
1:             if ((sf.getOperation() == SimpleFilter.EQ) && (index != null))
1:             {
1:                 Set<Capability> existingCaps = index.get(sf.getValue());
1:                 if (existingCaps != null)
1:                 {
1:                     matches.addAll(existingCaps);
1:                     if (caps != m_capSet)
1:                     {
1:                         matches.retainAll(caps);
1:                     }
1:                 }
1:             }
1:             else
1:             {
1:                 for (Iterator<Capability> it = caps.iterator(); it.hasNext(); )
1:                 {
1:                     Capability cap = it.next();
1:                     Object lhs = cap.getAttributes().get(sf.getName());
1:                     if (lhs != null)
1:                     {
1:                         if (compare(lhs, sf.getValue(), sf.getOperation()))
1:                         {
1:                             matches.add(cap);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         return matches;
1:     }
1: 
1: //    public static boolean matches(Capability cap, SimpleFilter sf)
1: //    {
1: //        return matchesInternal(cap, sf) && matchMandatory(cap, sf);
1: //    }
1: 
1: //    private static boolean matchesInternal(Capability cap, SimpleFilter sf)
1: //    {
1: //        boolean matched = true;
1: //
1: //        if (sf.getOperation() == SimpleFilter.MATCH_ALL)
1: //        {
1: //            matched = true;
1: //        }
1: //        else if (sf.getOperation() == SimpleFilter.AND)
1: //        {
1: //            // Evaluate each subfilter against the remaining capabilities.
1: //            // For AND we calculate the intersection of each subfilter.
1: //            // We can short-circuit the AND operation if there are no
1: //            // remaining capabilities.
1: //            List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1: //            for (int i = 0; matched && (i < sfs.size()); i++)
1: //            {
1: //                matched = matchesInternal(cap, sfs.get(i));
1: //            }
1: //        }
1: //        else if (sf.getOperation() == SimpleFilter.OR)
1: //        {
1: //            // Evaluate each subfilter against the remaining capabilities.
1: //            // For OR we calculate the union of each subfilter.
1: //            matched = false;
1: //            List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1: //            for (int i = 0; !matched && (i < sfs.size()); i++)
1: //            {
1: //                matched = matchesInternal(cap, sfs.get(i));
1: //            }
1: //        }
1: //        else if (sf.getOperation() == SimpleFilter.NOT)
1: //        {
1: //            // Evaluate each subfilter against the remaining capabilities.
1: //            // For OR we calculate the union of each subfilter.
1: //            List<SimpleFilter> sfs = (List<SimpleFilter>) sf.getValue();
1: //            for (int i = 0; i < sfs.size(); i++)
1: //            {
1: //                matched = !(matchesInternal(cap, sfs.get(i)));
1: //            }
1: //        }
1: //        else
1: //        {
1: //            matched = false;
1: //            Object lhs = cap.getAttributes().get(sf.getName());
1: //            if (lhs != null)
1: //            {
1: //                matched = compare(lhs, sf.getValue(), sf.getOperation());
1: //            }
1: //        }
1: //
1: //        return matched;
1: //    }
1: 
1:     private static Set<Capability> matchMandatory(
1:         Set<Capability> caps, SimpleFilter sf)
1:     {
1:         for (Iterator<Capability> it = caps.iterator(); it.hasNext(); )
1:         {
1:             Capability cap = it.next();
1:             if (!matchMandatory(cap, sf))
1:             {
1:                 it.remove();
1:             }
1:         }
1:         return caps;
1:     }
1: 
1:     private static boolean matchMandatory(Capability cap, SimpleFilter sf)
1:     {
1:         String mandatoryDirective = cap.getDirectives().get(AbstractWiringNamespace.CAPABILITY_MANDATORY_DIRECTIVE);
1:         if (mandatoryDirective == null) {
1:             // There are no mandatory attributes to check.
1:             return true;
1:         }
1:         List<String> mandatoryAttributes = Arrays.asList(mandatoryDirective.split(","));
1:         
1:         Map<String, Object> attrs = cap.getAttributes();
1:         for (Entry<String, Object> entry : attrs.entrySet())
1:         {
1:             if (mandatoryAttributes.contains(entry.getKey())
1:                 && !matchMandatoryAttrbute(entry.getKey(), sf))
1:             {
1:                 return false;
1:             }
1:         }
1:         return true;
1:     }
1: 
1:     private static boolean matchMandatoryAttrbute(String attrName, SimpleFilter sf)
1:     {
1:         if ((sf.getName() != null) && sf.getName().equals(attrName))
1:         {
1:             return true;
1:         }
1:         else if (sf.getOperation() == SimpleFilter.AND)
1:         {
1:             List list = (List) sf.getValue();
1:             for (int i = 0; i < list.size(); i++)
1:             {
1:                 SimpleFilter sf2 = (SimpleFilter) list.get(i);
1:                 if ((sf2.getName() != null)
1:                     && sf2.getName().equals(attrName))
1:                 {
1:                     return true;
1:                 }
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     private static final Class<?>[] STRING_CLASS = new Class[] { String.class };
1:     private static final String VALUE_OF_METHOD_NAME = "valueOf";
1: 
1:     private static boolean compare(Object lhs, Object rhsUnknown, int op)
1:     {
1:         if (lhs == null)
1:         {
1:             return false;
1:         }
1: 
1:         // If this is a PRESENT operation, then just return true immediately
1:         // since we wouldn't be here if the attribute wasn't present.
1:         if (op == SimpleFilter.PRESENT)
1:         {
1:             return true;
1:         }
1: 
1:         //Need a special case here when lhs is a Version and rhs is a VersionRange
1:         //Version is comparable so we need to check this first
1:         if(lhs instanceof Version && op == SimpleFilter.EQ)
1:         {
1:             Object rhs = null;
1:             try
1:             {
1:                 rhs = coerceType(lhs, (String) rhsUnknown);
1:             }
1:             catch (Exception ex)
1:             {
1:                 //Do nothing will check later if rhs is null
1:             }
1: 
1:             if(rhs != null && rhs instanceof VersionRange)
1:             {
1:                 return ((VersionRange)rhs).includes((Version)lhs);
1:             }
1:         }
1: 
1:         // If the type is comparable, then we can just return the
1:         // result immediately.
1:         if (lhs instanceof Comparable)
1:         {
1:             // Spec says SUBSTRING is false for all types other than string.
1:             if ((op == SimpleFilter.SUBSTRING) && !(lhs instanceof String))
1:             {
1:                 return false;
1:             }
1: 
1:             Object rhs;
1:             if (op == SimpleFilter.SUBSTRING)
1:             {
1:                 rhs = rhsUnknown;
1:             }
1:             else
1:             {
1:                 try
1:                 {
1:                     rhs = coerceType(lhs, (String) rhsUnknown);
1:                 }
1:                 catch (Exception ex)
1:                 {
1:                     return false;
1:                 }
1:             }
1: 
1:             switch (op)
1:             {
1:                 case SimpleFilter.EQ :
1:                     try
1:                     {
1:                         return (((Comparable) lhs).compareTo(rhs) == 0);
1:                     }
1:                     catch (Exception ex)
1:                     {
1:                         return false;
1:                     }
1:                 case SimpleFilter.GTE :
1:                     try
1:                     {
1:                         return (((Comparable) lhs).compareTo(rhs) >= 0);
1:                     }
1:                     catch (Exception ex)
1:                     {
1:                         return false;
1:                     }
1:                 case SimpleFilter.LTE :
1:                     try
1:                     {
1:                         return (((Comparable) lhs).compareTo(rhs) <= 0);
1:                     }
1:                     catch (Exception ex)
1:                     {
1:                         return false;
1:                     }
1:                 case SimpleFilter.APPROX :
1:                     return compareApproximate(lhs, rhs);
1:                 case SimpleFilter.SUBSTRING :
1:                     return SimpleFilter.compareSubstring((List<String>) rhs, (String) lhs);
1:                 default:
1:                     throw new RuntimeException(
1:                         "Unknown comparison operator: " + op);
1:             }
1:         }
1:         // Booleans do not implement comparable, so special case them.
1:         else if (lhs instanceof Boolean)
1:         {
1:             Object rhs;
1:             try
1:             {
1:                 rhs = coerceType(lhs, (String) rhsUnknown);
1:             }
1:             catch (Exception ex)
1:             {
1:                 return false;
1:             }
1: 
1:             switch (op)
1:             {
1:                 case SimpleFilter.EQ :
1:                 case SimpleFilter.GTE :
1:                 case SimpleFilter.LTE :
1:                 case SimpleFilter.APPROX :
1:                     return (lhs.equals(rhs));
1:                 default:
1:                     throw new RuntimeException(
1:                         "Unknown comparison operator: " + op);
1:             }
1:         }
1: 
1:         // If the LHS is not a comparable or boolean, check if it is an
1:         // array. If so, convert it to a list so we can treat it as a
1:         // collection.
1:         if (lhs.getClass().isArray())
1:         {
1:             lhs = convertArrayToList(lhs);
1:         }
1: 
1:         // If LHS is a collection, then call compare() on each element
1:         // of the collection until a match is found.
1:         if (lhs instanceof Collection)
1:         {
1:             for (Iterator iter = ((Collection) lhs).iterator(); iter.hasNext(); )
1:             {
1:                 if (compare(iter.next(), rhsUnknown, op))
1:                 {
1:                     return true;
1:                 }
1:             }
1: 
1:             return false;
1:         }
1: 
1:         // Spec says SUBSTRING is false for all types other than string.
1:         if ((op == SimpleFilter.SUBSTRING) && !(lhs instanceof String))
1:         {
1:             return false;
1:         }
1: 
1:         // Since we cannot identify the LHS type, then we can only perform
1:         // equality comparison.
1:         try
1:         {
1:             return lhs.equals(coerceType(lhs, (String) rhsUnknown));
1:         }
1:         catch (Exception ex)
1:         {
1:             return false;
1:         }
1:     }
1: 
1:     private static boolean compareApproximate(Object lhs, Object rhs)
1:     {
1:         if (rhs instanceof String)
1:         {
1:             return removeWhitespace((String) lhs)
1:                 .equalsIgnoreCase(removeWhitespace((String) rhs));
1:         }
1:         else if (rhs instanceof Character)
1:         {
1:             return Character.toLowerCase(((Character) lhs))
1:                 == Character.toLowerCase(((Character) rhs));
1:         }
1:         return lhs.equals(rhs);
1:     }
1: 
1:     private static String removeWhitespace(String s)
1:     {
1:         StringBuffer sb = new StringBuffer(s.length());
1:         for (int i = 0; i < s.length(); i++)
1:         {
1:             if (!Character.isWhitespace(s.charAt(i)))
1:             {
1:                 sb.append(s.charAt(i));
1:             }
1:         }
1:         return sb.toString();
1:     }
1: 
1:     private static Object coerceType(Object lhs, String rhsString) throws Exception
1:     {
1:         // If the LHS expects a string, then we can just return
1:         // the RHS since it is a string.
1:         if (lhs.getClass() == rhsString.getClass())
1:         {
1:             return rhsString;
1:         }
1: 
1:         // Try to convert the RHS type to the LHS type by using
1:         // the string constructor of the LHS class, if it has one.
1:         Object rhs = null;
1:         try
1:         {
1:             // The Character class is a special case, since its constructor
1:             // does not take a string, so handle it separately.
1:             if (lhs instanceof Character)
1:             {
1:                 rhs = new Character(rhsString.charAt(0));
1:             }
1:             else if(lhs instanceof Version && rhsString.indexOf(',') >= 0)
1:             {
1:                 rhs = VersionRange.valueOf(rhsString);
1:             }
1:             else
1:             {
1:                 // Spec says we should trim number types.
1:                 if ((lhs instanceof Number) || (lhs instanceof Boolean))
1:                 {
1:                     rhsString = rhsString.trim();
1:                 }
1: 
1:                 try
1:                 {
1:                     // Try to find a suitable static valueOf method
1:                     Method valueOfMethod = m_secureAction.getDeclaredMethod(
1:                         lhs.getClass(), VALUE_OF_METHOD_NAME, STRING_CLASS);
1:                     if (valueOfMethod.getReturnType().isAssignableFrom(lhs.getClass())
1:                         && ((valueOfMethod.getModifiers() & Modifier.STATIC) > 0))
1:                     {
1:                         m_secureAction.setAccesssible(valueOfMethod);
1:                         rhs = valueOfMethod.invoke(null, new Object[] { rhsString });
1:                     }
1:                 }
1:                 catch (Exception ex)
1:                 {
1:                     // Static valueOf fails, try the next conversion mechanism
1:                 }
1: 
1:                 if (rhs == null)
1:                 {
1:                     Constructor ctor = m_secureAction.getConstructor(lhs.getClass(), STRING_CLASS);
1:                     m_secureAction.setAccesssible(ctor);
1:                     rhs = ctor.newInstance(new Object[] { rhsString });
1:                 }
1:             }
1:         }
1:         catch (Exception ex)
1:         {
1:             throw new Exception(
1:                 "Could not instantiate class "
1:                     + lhs.getClass().getName()
1:                     + " from string constructor with argument '"
1:                     + rhsString + "' because " + ex);
1:         }
1: 
1:         return rhs;
1:     }
1: 
1:     /**
1:      * This is an ugly utility method to convert an array of primitives
1:      * to an array of primitive wrapper objects. This method simplifies
1:      * processing LDAP filters since the special case of primitive arrays
1:      * can be ignored.
1:      * @param array An array of primitive types.
1:      * @return An corresponding array using pritive wrapper objects.
1:     **/
1:     private static List convertArrayToList(Object array)
1:     {
1:         int len = Array.getLength(array);
1:         List list = new ArrayList(len);
1:         for (int i = 0; i < len; i++)
1:         {
1:             list.add(Array.get(array, i));
1:         }
1:         return list;
1:     }
1: }
============================================================================