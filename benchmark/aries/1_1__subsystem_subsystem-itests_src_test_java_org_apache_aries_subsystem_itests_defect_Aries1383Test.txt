1:a990e32: package org.apache.aries.subsystem.itests.defect;
4:a990e32: 
1:a990e32: import static org.junit.Assert.assertEquals;
1:a990e32: import static org.junit.Assert.assertNotNull;
1:a990e32: import static org.junit.Assert.assertNull;
1:a990e32: import static org.junit.Assert.assertSame;
1:a990e32: import static org.junit.Assert.fail;
1:a990e32: 
1:a990e32: import java.io.ByteArrayInputStream;
1:a990e32: import java.io.ByteArrayOutputStream;
1:a990e32: import java.io.InputStream;
1:a990e32: import java.util.Arrays;
1:a990e32: import java.util.Collection;
1:a990e32: import java.util.EnumSet;
1:a990e32: import java.util.Iterator;
1:a990e32: import java.util.List;
1:a990e32: import java.util.Map;
1:a990e32: import java.util.concurrent.Callable;
1:a990e32: import java.util.concurrent.ExecutorService;
1:a990e32: import java.util.concurrent.Executors;
1:a990e32: import java.util.concurrent.Future;
1:a990e32: import java.util.jar.Attributes;
1:a990e32: import java.util.jar.Manifest;
1:a990e32: 
1:a990e32: import org.apache.aries.subsystem.AriesSubsystem;
1:a990e32: import org.apache.aries.subsystem.core.archive.AriesProvisionDependenciesDirective;
1:a990e32: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
1:a990e32: import org.apache.aries.subsystem.itests.SubsystemTest;
1:a990e32: import org.apache.aries.subsystem.itests.util.BundleArchiveBuilder;
1:a990e32: import org.apache.aries.subsystem.itests.util.SubsystemArchiveBuilder;
1:a990e32: import org.apache.aries.subsystem.itests.util.TestCapability;
1:a990e32: import org.apache.aries.subsystem.itests.util.TestRepository;
1:a990e32: import org.apache.aries.subsystem.itests.util.TestRepositoryContent;
1:a990e32: import org.apache.aries.subsystem.itests.util.TestRequirement;
1:a990e32: import org.easymock.internal.matchers.Null;
1:a990e32: import org.junit.Test;
1:a990e32: import org.ops4j.pax.tinybundles.core.InnerClassStrategy;
1:a990e32: import org.ops4j.pax.tinybundles.core.TinyBundles;
1:9ea9cc5: import org.osgi.framework.Bundle;
1:a990e32: import org.osgi.framework.BundleActivator;
1:a990e32: import org.osgi.framework.BundleContext;
1:a990e32: import org.osgi.framework.Constants;
1:a990e32: import org.osgi.framework.ServiceEvent;
1:a990e32: import org.osgi.framework.ServiceReference;
1:a990e32: import org.osgi.framework.ServiceRegistration;
1:a990e32: import org.osgi.framework.Version;
1:a990e32: import org.osgi.framework.hooks.resolver.ResolverHook;
1:a990e32: import org.osgi.framework.hooks.resolver.ResolverHookFactory;
1:a990e32: import org.osgi.framework.namespace.BundleNamespace;
1:a990e32: import org.osgi.framework.namespace.IdentityNamespace;
1:a990e32: import org.osgi.framework.namespace.PackageNamespace;
1:a990e32: import org.osgi.framework.wiring.BundleCapability;
1:a990e32: import org.osgi.framework.wiring.BundleRequirement;
1:a990e32: import org.osgi.framework.wiring.BundleRevision;
1:a990e32: import org.osgi.service.repository.Repository;
1:a990e32: import org.osgi.service.subsystem.Subsystem;
1:a990e32: import org.osgi.service.subsystem.Subsystem.State;
1:a990e32: import org.osgi.service.subsystem.SubsystemConstants;
1:a990e32: import org.osgi.service.subsystem.SubsystemException;
1:a990e32: 
1:a990e32: /*
1:a990e32:  * https://issues.apache.org/jira/browse/ARIES-1383
1:a990e32:  * 
1:a990e32:  * Provide option to disable the provisioning of dependencies at install time.
1:a990e32:  * 
1:a990e32:  * For tests containing a numerical value in the name, see the description of
1:a990e32:  * ARIES-1383 for an explanation.
1:a990e32:  */
1:a990e32: public class Aries1383Test extends SubsystemTest {
1:a990e32: 	private static final String SYMBOLICNAME_PREFIX = Aries1383Test.class.getSimpleName() + '.';
1:a990e32: 	
1:a990e32: 	private static final String APPLICATION_A = SYMBOLICNAME_PREFIX + "application.a";
1:a990e32: 	private static final String APPLICATION_B = SYMBOLICNAME_PREFIX + "application.b";
1:a990e32: 	private static final String APPLICATION_DEPENDENCY_IN_ARCHIVE = SYMBOLICNAME_PREFIX + "application.dependency.in.archive";
1:a990e32: 	private static final String APPLICATION_EMPTY = SYMBOLICNAME_PREFIX + "application.empty";
1:a990e32: 	private static final String APPLICATION_INSTALL_FAILED = SYMBOLICNAME_PREFIX + "application.install.failed";
1:a990e32: 	private static final String APPLICATION_INVALID_PROVISION_DEPENDENCIES = SYMBOLICNAME_PREFIX + "application.invalid.provision.dependency";
1:a990e32: 	private static final String APPLICATION_MISSING_DEPENDENCY = SYMBOLICNAME_PREFIX + "application.missing.dependency";
1:a990e32: 	private static final String APPLICATION_PROVISION_DEPENDENCIES_INSTALL = SYMBOLICNAME_PREFIX + "application.provision.dependencies.install";
1:a990e32: 	private static final String APPLICATION_START_FAILURE = SYMBOLICNAME_PREFIX + "application.start.failure";
1:a990e32: 	private static final String BUNDLE_A = SYMBOLICNAME_PREFIX + "bundle.a";
1:a990e32: 	private static final String BUNDLE_B = SYMBOLICNAME_PREFIX + "bundle.b";
1:a990e32: 	private static final String BUNDLE_C = SYMBOLICNAME_PREFIX + "bundle.c";
1:a990e32: 	private static final String BUNDLE_D = SYMBOLICNAME_PREFIX + "bundle.d";
1:a990e32: 	private static final String BUNDLE_INVALID_MANIFEST = SYMBOLICNAME_PREFIX + "bundle.invalid.manifest";
1:a990e32: 	private static final String BUNDLE_START_FAILURE = SYMBOLICNAME_PREFIX + "bundle.start.failure";
1:a990e32: 	private static final String ESA_EXTENSION = ".esa";
1:a990e32: 	private static final String FEATURE_PROVISION_DEPENDENCIES_INSTALL = "feature.provision.dependencies.install";
1:a990e32: 	private static final String FEATURE_PROVISION_DEPENDENCIES_RESOLVE = "feature.provision.dependencies.resolve";
1:a990e32: 	private static final String JAR_EXTENSION = ".jar";
1:a990e32: 	private static final String MANIFEST_VERSION = "1.0";
1:a990e32: 	private static final String PACKAGE_A = SYMBOLICNAME_PREFIX + "a";
1:a990e32: 	private static final String PACKAGE_B = SYMBOLICNAME_PREFIX + "b";
1:a990e32: 	private static final String PACKAGE_C = SYMBOLICNAME_PREFIX + "c";
1:a990e32: 	private static final String PACKAGE_D = SYMBOLICNAME_PREFIX + "d";
1:a990e32: 	private static final String SUBSYSTEM_MANIFEST_FILE = "OSGI-INF/SUBSYSTEM.MF";
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (1) A set of subsystems with interleaving content dependencies are able 
1:a990e32: 	 * to be independently, simultaneously, and successfully installed and 
1:a990e32: 	 * started.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test1() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		final Subsystem c1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"c1", 
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("c1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE + ';' 
1:a990e32: 										+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
1:afe81b7: 		uninstallableSubsystems.add(c1);
1:a990e32: 		c1.start();
1:a990e32: 		stoppableSubsystems.add(c1);
1:a990e32: 		@SuppressWarnings("unchecked")
1:a990e32: 		Callable<Subsystem>[] installCallables = new Callable[] {
1:a990e32: 				new Callable<Subsystem>() {
3:a990e32: 					@Override
1:a990e32: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:a990e32: 								c1,
1:a990e32: 								"a1", 
1:a990e32: 								new SubsystemArchiveBuilder()
1:a990e32: 										.symbolicName("a1")
1:a990e32: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 										.content("b1")
1:a990e32: 										.bundle(
1:a990e32: 												"b1", 
1:a990e32: 												new BundleArchiveBuilder()
1:a990e32: 														.symbolicName("b1")
1:a990e32: 														.importPackage("b2")
1:a990e32: 														.build())
1:a990e32: 										.build(),
1:a990e32: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:afe81b7: 						return result;
5:a990e32: 					}
1:a990e32: 					
1:a990e32: 				},
1:a990e32: 				new Callable<Subsystem>() {
1:a990e32: 					@Override
1:a990e32: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:a990e32: 								c1,
1:a990e32: 								"f1", 
1:a990e32: 								new SubsystemArchiveBuilder()
1:a990e32: 										.symbolicName("f1")
1:a990e32: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1:a990e32: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 										.content("b2")
1:a990e32: 										.bundle(
1:a990e32: 												"b2", 
1:a990e32: 												new BundleArchiveBuilder()
1:a990e32: 														.symbolicName("b2")
1:a990e32: 														.exportPackage("b2")
1:a990e32: 														.importPackage("b3")
1:a990e32: 														.build())
1:a990e32: 										.build(),
1:a990e32: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:afe81b7: 						return result;
1:a990e32: 					}
1:a990e32: 					
1:a990e32: 				},
1:a990e32: 				new Callable<Subsystem>() {
1:a990e32: 					@Override
1:a990e32: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:a990e32: 								c1,
1:a990e32: 								"f2", 
1:a990e32: 								new SubsystemArchiveBuilder()
1:a990e32: 										.symbolicName("f2")
1:a990e32: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1:a990e32: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 										.content("b4")
1:a990e32: 										.bundle(
1:a990e32: 												"b4", 
1:a990e32: 												new BundleArchiveBuilder()
1:a990e32: 														.symbolicName("b4")
1:a990e32: 														.exportPackage("b4")
1:a990e32: 														.importPackage("b2")
1:a990e32: 														.importPackage("b3")
1:a990e32: 														.build())
1:a990e32: 										.build(),
1:a990e32: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:afe81b7: 						return result;
1:a990e32: 					}
1:a990e32: 					
1:a990e32: 				},
1:a990e32: 				new Callable<Subsystem>() {
1:a990e32: 					@Override
1:a990e32: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:a990e32: 								c1,
1:a990e32: 								"c2", 
1:a990e32: 								new SubsystemArchiveBuilder()
1:a990e32: 										.symbolicName("c2")
1:a990e32: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE + ';' 
1:a990e32: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 										.content("b3;version=\"[0,0]\"")
1:a990e32: 										.exportPackage("b3")
1:a990e32: 										.importPackage("b4")
1:a990e32: 										.bundle(
1:a990e32: 												"b3", 
1:a990e32: 												new BundleArchiveBuilder()
1:a990e32: 														.symbolicName("b3")
1:a990e32: 														.exportPackage("b3")
1:a990e32: 														.importPackage("b4")
1:a990e32: 														.build())
1:a990e32: 										.build(),
1:a990e32: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:afe81b7: 						return result;
1:a990e32: 					}
1:a990e32: 					
1:a990e32: 				}
1:a990e32: 		};
1:a990e32: 		ExecutorService executor = Executors.newFixedThreadPool(4);
1:a990e32: 		List<Future<Subsystem>> installFutures = executor.invokeAll(Arrays.asList(installCallables));
1:a990e32: 		final Subsystem a1 = installFutures.get(0).get();
1:a990e32: 		assertConstituent(a1, "b1");
1:a990e32: 		final Subsystem f1 = installFutures.get(1).get();
1:a990e32: 		assertConstituent(f1, "b2");
1:a990e32: 		final Subsystem f2 = installFutures.get(2).get();
1:a990e32: 		assertConstituent(f2, "b4");
1:a990e32: 		final Subsystem c2 = installFutures.get(3).get();
1:a990e32: 		assertConstituent(c2, "b3");
1:a990e32: 		@SuppressWarnings("unchecked")
1:a990e32: 		Callable<Null>[] startCallables = new Callable[] {
1:a990e32: 			new Callable<Null>() {
1:a990e32: 				@Override
1:a990e32: 				public Null call() throws Exception {
1:a990e32: 					a1.start();
1:a990e32: 					assertEvent(a1, State.INSTALLED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(a1, State.RESOLVING, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(a1, State.RESOLVED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:afe81b7: 					stoppableSubsystems.add(a1);
1:a990e32: 					return null;
1:a990e32: 				}
1:a990e32: 			},
1:a990e32: 			new Callable<Null>() {
1:a990e32: 				@Override
1:a990e32: 				public Null call() throws Exception {
1:a990e32: 					f1.start();
1:a990e32: 					assertEvent(f1, State.INSTALLED, subsystemEvents.poll(f1.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(f1, State.RESOLVING, subsystemEvents.poll(f1.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(f1, State.RESOLVED, subsystemEvents.poll(f1.getSubsystemId(), 5000));
1:afe81b7: 					stoppableSubsystems.add(f1);
1:a990e32: 					return null;
1:a990e32: 				}
1:a990e32: 			},
1:a990e32: 			new Callable<Null>() {
1:a990e32: 				@Override
1:a990e32: 				public Null call() throws Exception {
1:a990e32: 					f2.start();
1:a990e32: 					assertEvent(f2, State.INSTALLED, subsystemEvents.poll(f2.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(f2, State.RESOLVING, subsystemEvents.poll(f2.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(f2, State.RESOLVED, subsystemEvents.poll(f2.getSubsystemId(), 5000));
1:afe81b7: 					stoppableSubsystems.add(f2);
1:a990e32: 					return null;
1:a990e32: 				}
1:a990e32: 			},
1:a990e32: 			new Callable<Null>() {
1:a990e32: 				@Override
1:a990e32: 				public Null call() throws Exception {
1:a990e32: 					c2.start();
1:a990e32: 					assertEvent(c2, State.INSTALLED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(c2, State.RESOLVING, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:a990e32: 					assertEvent(c2, State.RESOLVED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:afe81b7: 					stoppableSubsystems.add(c2);
1:a990e32: 					return null;
1:a990e32: 				}
1:a990e32: 			}
1:a990e32: 		};
1:a990e32: 		List<Future<Null>> startFutures = executor.invokeAll(Arrays.asList(startCallables));
1:a990e32: 		startFutures.get(0).get();
1:a990e32: 		startFutures.get(1).get();
1:a990e32: 		startFutures.get(2).get();
1:a990e32: 		startFutures.get(3).get();
1:a990e32: 	}
1:b66ad7c: 	
1:a990e32: 	/*
1:a990e32: 	 * (2) Subsystem with apache-aries-provision-dependencies:=resolve is in the 
1:a990e32: 	 * INSTALLING state after a successful installation.
1:a990e32: 	 */
1:b66ad7c: 	@Test
1:a990e32: 	public void test2() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 		try {
1:a990e32: 			assertState(State.INSTALLING, subsystem);
1:a990e32: 		}
1:a990e32: 		finally {
2:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (3) Subsystem with apache-aries-provision-dependencies:=resolve is available 
1:a990e32: 	 * as a service after a successful installation.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test3() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 		try {
1:a990e32: 			assertReferences(
1:a990e32: 					Subsystem.class, 
1:a990e32: 					"(&(subsystem.symbolicName=" 
1:a990e32: 							+ APPLICATION_EMPTY 
1:a990e32: 							+ ")(subsystem.version=0.0.0)(subsystem.type=" 
1:a990e32: 							+ SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION 
1:a990e32: 							+ ")(subsystem.state=" 
1:a990e32: 							+ State.INSTALLING 
1:a990e32: 							+ "))",
1:a990e32: 					1);
1:a990e32: 			assertReferences(
1:a990e32: 					AriesSubsystem.class, 
1:a990e32: 					"(&(subsystem.symbolicName=" 
1:a990e32: 							+ APPLICATION_EMPTY 
1:a990e32: 							+ ")(subsystem.version=0.0.0)(subsystem.type=" 
1:a990e32: 							+ SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION 
1:a990e32: 							+ ")(subsystem.state=" 
1:a990e32: 							+ State.INSTALLING 
1:a990e32: 							+ "))",
1:a990e32: 					1);
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (4) Subsystem with apache-aries-provision-dependencies:=resolve does not 
1:a990e32: 	 * have its dependencies installed after a successful installation.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test4() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_DEPENDENCY_IN_ARCHIVE, applicationDependencyInArchive(), false);
1:a990e32: 		try {
1:a990e32: 			assertConstituent(subsystem, BUNDLE_A);
1:a990e32: 			assertNotConstituent(subsystem, BUNDLE_B);
1:a990e32: 			assertNotConstituent(root, BUNDLE_B);
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (5) Subsystem with apache-aries-provision-dependencies:=resolve undergoes 
1:a990e32: 	 * the following state transitions when starting: INSTALLING -> INSTALLED 
1:a990e32: 	 * -> RESOLVING -> RESOLVED -> STARTING -> ACTIVE.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test5() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		Subsystem subsystem = root.install(
1:a990e32: 				"application", 
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.header(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, "application")
1:a990e32: 						.header(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 								SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 										+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.build()
1:a990e32: 		);
1:a990e32: 		try {
1:a990e32: 			long id = subsystem.getSubsystemId();
1:a990e32: 			assertEvent(subsystem, State.INSTALLING, subsystemEvents.poll(id, 5000));
1:a990e32: 			assertNull(subsystemEvents.poll(id, 1));
1:a990e32: 			subsystem.start();
1:a990e32: 			try {
1:a990e32: 				assertEvent(subsystem, State.INSTALLED, subsystemEvents.poll(id, 5000));
1:a990e32: 				assertEvent(subsystem, State.RESOLVING, subsystemEvents.poll(id, 5000));
1:a990e32: 				assertEvent(subsystem, State.RESOLVED, subsystemEvents.poll(id, 5000));
1:a990e32: 				assertEvent(subsystem, State.STARTING, subsystemEvents.poll(id, 5000));
1:a990e32: 				assertEvent(subsystem, State.ACTIVE, subsystemEvents.poll(id, 5000));
1:a990e32: 				assertNull(subsystemEvents.poll(id, 1));
1:a990e32: 			}
1:a990e32: 			finally {
2:a990e32: 				stopSubsystemSilently(subsystem);
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (6) Subsystem with apache-aries-provision-dependencies:=resolve has its 
1:a990e32: 	 * dependencies installed after a successful start.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test6() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = root.install(
1:a990e32: 				"application", 
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("application")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 										+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.content("bundle1")
1:a990e32: 						.bundle(
1:a990e32: 								"bundle1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("bundle1")
1:a990e32: 										.exportPackage("a")
1:a990e32: 										.importPackage("b")
1:a990e32: 										.build())
1:a990e32: 						.bundle(
1:a990e32: 								"bundle2", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("bundle2")
1:a990e32: 										.exportPackage("b")
1:a990e32: 										.build())
1:a990e32: 						.build()
1:a990e32: 		);
1:a990e32: 		try {
1:a990e32: 			assertNotConstituent(root, "bundle2");
1:a990e32: 			startSubsystem(subsystem, false);
1:a990e32: 			try {
1:a990e32: 				assertConstituent(root, "bundle2");
1:a990e32: 			}
1:a990e32: 			finally {
1:a990e32: 				stopSubsystemSilently(subsystem);
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (7) Subsystem with apache-aries-provision-dependencies:=resolve is in the 
1:a990e32: 	 * INSTALL_FAILED state after an unsuccessful installation.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test7() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = root.install(APPLICATION_INSTALL_FAILED, applicationInstallFailed());
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			long id = lastSubsystemId();
1:a990e32: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALL_FAILED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.UNINSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.UNINSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 		}
1:a990e32: 	}
1:9ea9cc5: 	
1:a990e32: 	/*
1:a990e32: 	 * (8) Subsystem with apache-aries-provision-dependencies:=resolve is not 
1:a990e32: 	 * available as a service after an unsuccessful installation.
1:a990e32: 	 */
1:9ea9cc5: 	@Test
1:a990e32: 	public void test8() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = installSubsystem(root, APPLICATION_INSTALL_FAILED, applicationInstallFailed(), false);
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			assertEquals("Subsystem service should not exist", 0,
1:a990e32: 					bundleContext.getServiceReferences(
1:a990e32: 							Subsystem.class, 
1:a990e32: 							"(" + SubsystemConstants.SUBSYSTEM_ID_PROPERTY + "=" + lastSubsystemId() + ")"
1:a990e32: 					).size());
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (9) Subsystem with apache-aries-provision-dependencies:=resolve is in the 
1:a990e32: 	 * INSTALLING state when dependencies cannot be provisioned after invoking 
1:a990e32: 	 * the start method.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test9() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_MISSING_DEPENDENCY, applicationMissingDependency(), false);
1:a990e32: 		try {
1:a990e32: 			startSubsystem(subsystem, false);
1:a990e32: 			stopSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have started");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			assertState(State.INSTALLING, subsystem);
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (10) Subsystem fails installation if the apache-aries-provision-dependencies 
1:a990e32: 	 * directive has a value other than "install" or "resolve".
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test10() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = installSubsystem(
1:a990e32: 					root, 
1:a990e32: 					APPLICATION_INVALID_PROVISION_DEPENDENCIES, 
1:a990e32: 					applicationInvalidProvisionDependencies(), 
1:a990e32: 					false);
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (11) Subsystem with apache-aries-provision-dependencies:=resolve undergoes 
1:a990e32: 	 * the following state transitions when starting fails due to a runtime 
1:a990e32: 	 * resolution failure: INSTALLING -> INSTALLED -> RESOLVING -> INSTALLED.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test11() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		Subsystem subsystem = root.install(APPLICATION_DEPENDENCY_IN_ARCHIVE, applicationDependencyInArchive());
1:a990e32: 		ServiceRegistration<ResolverHookFactory> registration = bundleContext.registerService(
1:a990e32: 				ResolverHookFactory.class, 
1:a990e32: 				new ResolverHookFactory() {
1:a990e32: 					@Override
1:a990e32: 					public ResolverHook begin(Collection<BundleRevision> triggers) {
1:a990e32: 						return new ResolverHook() {
1:a990e32: 							@Override
1:a990e32: 							public void filterResolvable(Collection<BundleRevision> candidates) {
1:a990e32: 								for (Iterator<BundleRevision> i = candidates.iterator(); i.hasNext();) {
1:a990e32: 									BundleRevision revision = i.next();
1:a990e32: 									if (revision.getSymbolicName().equals(BUNDLE_B)) {
1:a990e32: 										i.remove();
1:a990e32: 									}
1:a990e32: 								}
1:a990e32: 							}
1:a990e32: 
1:a990e32: 							@Override
1:a990e32: 							public void filterSingletonCollisions(
1:a990e32: 									BundleCapability singleton,
1:a990e32: 									Collection<BundleCapability> collisionCandidates) {
1:a990e32: 								// Nothing.
1:a990e32: 							}
1:a990e32: 
1:a990e32: 							@Override
1:a990e32: 							public void filterMatches(
1:a990e32: 									BundleRequirement requirement,
1:a990e32: 									Collection<BundleCapability> candidates) {
1:a990e32: 								// Nothing.
1:a990e32: 							}
1:a990e32: 
1:a990e32: 							@Override
1:a990e32: 							public void end() {
1:a990e32: 								// Nothing.
1:a990e32: 							}
1:a990e32: 						};
1:a990e32: 					}
1:a990e32: 				}, 
1:a990e32: 				null
1:a990e32: 		);
1:a990e32: 		try {
1:a990e32: 			subsystem.start();
1:a990e32: 			stopSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have started");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			long id = lastSubsystemId();
1:a990e32: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.RESOLVING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			registration.unregister();
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (12) Subsystem with apache-aries-provision-dependencies:=resolve undergoes 
1:a990e32: 	 * the following state transitions when starting fails due to a start 
1:a990e32: 	 * failure: INSTALLING -> INSTALLED -> RESOLVING -> RESOLVED -> STARTING -> 
1:a990e32: 	 * RESOLVED.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test12() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		Subsystem subsystem = root.install(APPLICATION_START_FAILURE, applicationStartFailure());
1:a990e32: 		try {
1:a990e32: 			subsystem.start();
1:a990e32: 			stopSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have started");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			long id = lastSubsystemId();
1:a990e32: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.RESOLVING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.RESOLVED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.STARTING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.RESOLVED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (13) The root subsystem has apache-aries-provision-dependencies:=install.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test13() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Map<String, String> headers = root.getSubsystemHeaders(null);
1:a990e32: 		String headerStr = headers.get(SubsystemConstants.SUBSYSTEM_TYPE);
1:a990e32: 		SubsystemTypeHeader header = new SubsystemTypeHeader(headerStr);
1:a990e32: 		AriesProvisionDependenciesDirective directive = header.getAriesProvisionDependenciesDirective();
1:a990e32: 		assertEquals(
1:a990e32: 				"Wrong directive", 
1:a990e32: 				AriesProvisionDependenciesDirective.INSTALL,
1:a990e32: 				directive);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (14) Subsystem with explicit apache-aries-provision-dependencies:=install 
1:a990e32: 	 * works as before.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test14() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_PROVISION_DEPENDENCIES_INSTALL,
1:a990e32: 				applicationProvisionDependenciesInstall(), true);
1:a990e32: 		try {
1:a990e32: 			assertConstituent(subsystem, BUNDLE_A);
1:a990e32: 			assertConstituent(root, BUNDLE_B);
1:a990e32: 			startSubsystem(subsystem, true);
1:a990e32: 			stopSubsystem(subsystem);
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystem(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (15) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that is different than the scoped parent fails installation.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test15a() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = installSubsystem(root, FEATURE_PROVISION_DEPENDENCIES_RESOLVE,
1:a990e32: 					featureProvisionDependenciesResolve(), false);
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (15) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that is different than the scoped parent fails installation.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test15b() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem application = installSubsystem(root, APPLICATION_PROVISION_DEPENDENCIES_INSTALL,
1:a990e32: 				applicationProvisionDependenciesInstall(), true);
1:a990e32: 		try {
1:a990e32: 			Subsystem feature = installSubsystem(application, FEATURE_PROVISION_DEPENDENCIES_RESOLVE,
1:a990e32: 					featureProvisionDependenciesResolve(), false);
1:a990e32: 			uninstallSubsystemSilently(feature);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(application);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (16) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that is the same as the scoped parent installs successfully.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test16a() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = installSubsystem(
1:a990e32: 					root, 
1:a990e32: 					FEATURE_PROVISION_DEPENDENCIES_INSTALL,
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("application")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1:a990e32: 							.build(), 
1:a990e32: 					true);
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			fail("Subsystem should have installed");
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (16) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that is the same as the scoped parent installs successfully.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test16b() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem application = installSubsystem(
1:a990e32: 				root, 
1:a990e32: 				"application",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("application")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 								+ AriesProvisionDependenciesDirective.INSTALL.toString())
1:a990e32: 						.build(), 
1:a990e32: 				true);
1:a990e32: 		try {
1:a990e32: 			Subsystem feature = installSubsystem(
1:a990e32: 					application, 
1:a990e32: 					"feature",
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("feature")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1:a990e32: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1:a990e32: 							.build(),  
1:a990e32: 					true);
1:a990e32: 			uninstallSubsystemSilently(feature);
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			fail("Subsystem should have installed");
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(application);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (16) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that is the same as the scoped parent installs successfully.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test16c() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = installSubsystem(
1:a990e32: 					root, 
1:a990e32: 					"application",
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("application")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 									+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 							.subsystem(
1:a990e32: 									"feature", 
1:a990e32: 									new SubsystemArchiveBuilder()
1:a990e32: 											.symbolicName("feature")
1:a990e32: 											.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1:a990e32: 													+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 											.build())
1:a990e32: 							.build(), 
1:a990e32: 					false);
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			fail("Subsystem should have installed");
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (17) Scoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that is the same as the scoped parent behaves accordingly.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test17() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		Subsystem parent = root.install(APPLICATION_B, applicationB());
1:a990e32: 		try {
1:a990e32: 			long id = parent.getSubsystemId();
1:a990e32: 			assertEvent(id, APPLICATION_B, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 			assertNotConstituent(root, BUNDLE_B);
1:a990e32: 			assertConstituent(parent, BUNDLE_A);
1:a990e32: 			Subsystem child = getChild(parent, APPLICATION_A);
1:a990e32: 			assertNotNull("Missing child", child);
1:a990e32: 			id = child.getSubsystemId();
1:a990e32: 			assertEvent(id, APPLICATION_A, Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 			assertNotConstituent(root, BUNDLE_D);
1:a990e32: 			assertConstituent(child, BUNDLE_A);
1:a990e32: 			assertConstituent(child, BUNDLE_C);
1:a990e32: 			parent.start();
1:a990e32: 			try {
1:a990e32: 				id = parent.getSubsystemId();
1:a990e32: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.STARTING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 				assertConstituent(root, BUNDLE_B);
1:a990e32: 				id = child.getSubsystemId();
1:a990e32: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.STARTING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 				assertConstituent(root, BUNDLE_D);
1:a990e32: 			}
1:a990e32: 			finally {
1:a990e32: 				stopSubsystemSilently(parent);
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(parent);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (18) Scoped subsystem with a value of apache-aries-provision-dependencies 
1:a990e32: 	 * that overrides the scoped parent behaves accordingly.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test18() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		Subsystem parent = root.install(
1:a990e32: 				"parent", 
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("parent")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION 
1:a990e32: 								+ ';' 
1:a990e32: 								+ AriesProvisionDependenciesDirective.INSTALL.toString()
1:a990e32: 								+ ';'
1:a990e32: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:a990e32: 								+ ":="
1:a990e32: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:a990e32: 						.content("bundle1")
1:a990e32: 						.bundle(
1:a990e32: 								"bundle1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("bundle1")
1:a990e32: 										.importPackage("a")
1:a990e32: 										.build())
1:a990e32: 						.bundle(
1:a990e32: 								"bundle2", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("bundle2")
1:a990e32: 										.exportPackage("a")
1:a990e32: 										.build())
1:a990e32: 				.build()
1:a990e32: 		);
1:a990e32: 		try {
1:a990e32: 			long id = parent.getSubsystemId();
1:a990e32: 			assertEvent(id, "parent", Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertEvent(id, "parent", Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.MODIFIED);
1:a990e32: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 			assertConstituent(parent, "bundle2");
1:a990e32: 			assertConstituent(parent, "bundle1");
1:a990e32: 			parent.start();
1:a990e32: 			Subsystem child = parent.install(
1:a990e32: 					"child", 
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("child")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 									+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 							.content("bundle3")
1:a990e32: 							.bundle(
1:a990e32: 									"bundle3", 
1:a990e32: 									new BundleArchiveBuilder()
1:a990e32: 											.symbolicName("bundle3")
1:a990e32: 											.importPackage("b")
1:a990e32: 											.build())
1:a990e32: 							.bundle(
1:a990e32: 									"bundle4", 
1:a990e32: 									new BundleArchiveBuilder()
1:a990e32: 											.symbolicName("bundle4")
1:a990e32: 											.exportPackage("b")
1:a990e32: 											.build())
1:a990e32: 							.build()
1:a990e32: 			);
1:a990e32: 			id = child.getSubsystemId();
1:a990e32: 			assertEvent(id, "child", Version.emptyVersion,
1:a990e32: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1:a990e32: 					ServiceEvent.REGISTERED);
1:a990e32: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 			assertNotConstituent(parent, "bundle4");
1:a990e32: 			assertConstituent(child, "bundle3");
1:a990e32: 			child.start();
1:a990e32: 			try {
1:a990e32: 				id = parent.getSubsystemId();
1:a990e32: 				assertEvent(id, "parent", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "parent", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "parent", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.STARTING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "parent", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 				id = child.getSubsystemId();
1:a990e32: 				assertEvent(id, "child", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.INSTALLED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "child", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "child", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "child", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.STARTING, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertEvent(id, "child", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1:a990e32: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1:a990e32: 						ServiceEvent.MODIFIED);
1:a990e32: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 				assertConstituent(parent, "bundle4");
1:a990e32: 			}
1:a990e32: 			finally {
1:a990e32: 				stopSubsystemSilently(parent);
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(parent);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (19) Scoped subsystem with only features as parents is able to override 
1:a990e32: 	 * the value of apache-aries-provision-dependencies.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test19() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		Subsystem feature1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"feature1", 
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("feature1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1:a990e32: 						.build()
1:a990e32: 		);
1:a990e32: 		try {
1:a990e32: 			Subsystem feature2 = installSubsystem(
1:a990e32: 					root,
1:a990e32: 					"feature2", 
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("feature2")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE
1:a990e32: 									+ ';'
1:a990e32: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1:a990e32: 							.build()
1:a990e32: 			);
1:a990e32: 			try {
1:a990e32: 				SubsystemArchiveBuilder applicationArchive = new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("application")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1:a990e32: 								+ ';'
1:a990e32: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:a990e32: 								+ ":="
1:a990e32: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:a990e32: 						.content("bundle1")
1:a990e32: 						.bundle(
1:a990e32: 								"bundle1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("bundle1")
1:a990e32: 										.importPackage("a")
1:a990e32: 										.build())
1:a990e32: 						.bundle(
1:a990e32: 								"bundle2",
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("bundle2")
1:a990e32: 										.exportPackage("a")
1:a990e32: 										.build());
1:a990e32: 				Subsystem application1 = feature1.install("application", applicationArchive.build());
1:a990e32: 				Subsystem application2 = feature2.install("application", applicationArchive.build());
1:a990e32: 				assertSame("Wrong subsystem", application1, application2);
1:a990e32: 				assertEquals("Wrong subsystem", application1, application2);
1:a990e32: 				assertChild(feature1, "application");
1:a990e32: 				assertChild(feature2, "application");
1:a990e32: 				long id = application1.getSubsystemId();
1:a990e32: 				assertEvent(id, "application", Version.emptyVersion,
1:a990e32: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.INSTALLING, 
1:a990e32: 						subsystemEvents.poll(id, 5000), ServiceEvent.REGISTERED);
1:a990e32: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 				assertConstituent(application1, "bundle1");
1:a990e32: 				assertNotConstituent(application1, "bundle2");
1:a990e32: 				application1.start();
1:a990e32: 				try {
1:a990e32: 					assertEvent(id, "application", Version.emptyVersion,
1:a990e32: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.INSTALLED, 
1:a990e32: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1:a990e32: 					assertEvent(id, "application", Version.emptyVersion,
1:a990e32: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.RESOLVING, 
1:a990e32: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1:a990e32: 					assertEvent(id, "application", Version.emptyVersion,
1:a990e32: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.RESOLVED, 
1:a990e32: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1:a990e32: 					assertEvent(id, "application", Version.emptyVersion,
1:a990e32: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.STARTING, 
1:a990e32: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1:a990e32: 					assertEvent(id, "application", Version.emptyVersion,
1:a990e32: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.ACTIVE, 
1:a990e32: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1:a990e32: 					assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1:a990e32: 					assertConstituent(application1, "bundle2");
1:a990e32: 				}
1:a990e32: 				finally {
1:a990e32: 					stopSubsystemSilently(application1);
1:a990e32: 				}
1:a990e32: 			}
1:a990e32: 			finally {
1:a990e32: 				uninstallSubsystemSilently(feature2);
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(feature1);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (20) Install a scoped subsystem, S1, with 
1:a990e32: 	 * apache-aries-provision-dependencies:=resolve. Install two features, F1 and 
1:a990e32: 	 * F2, independently as children of S1. F1 has bundle B1 as content. F2 has 
1:a990e32: 	 * bundle B2 as content. B2 has B1 as a dependency. B1 should be a 
1:a990e32: 	 * constituent of F1 but not of the root subsystem.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test20() throws Exception {
1:a990e32: 		serviceRegistrations.add(bundleContext.registerService(
1:a990e32: 				Repository.class,
1:a990e32: 				new TestRepository.Builder()
1:a990e32: 		        		.resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b1")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b1")
1:a990e32: 		                        		.exportPackage("a")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b2")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b2")
1:a990e32: 		                        		.importPackage("a")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		        		.build(),
1:a990e32:                 null));
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem s1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"s1",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("s1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
1:a990e32: 		uninstallableSubsystems.add(s1);
1:a990e32: 		startSubsystem(s1, false);
1:a990e32: 		stoppableSubsystems.add(s1);
1:a990e32: 		Subsystem f2 = installSubsystem(
1:a990e32: 				s1,
1:a990e32: 				"f2",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("f2")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1:a990e32: 						.content("b2")
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
2:a990e32: 		uninstallableSubsystems.add(f2);
1:a990e32: 		assertChild(s1, "f2", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:a990e32: 		assertConstituent(f2, "b2");
1:a990e32: 		Subsystem f1 = installSubsystem(
1:a990e32: 				s1,
1:a990e32: 				"f1",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("f1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1:a990e32: 						.content("b1")
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
2:a990e32: 		uninstallableSubsystems.add(f1);
1:a990e32: 		assertChild(s1, "f1", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:a990e32: 		assertConstituent(f1, "b1");
1:a990e32: 		assertNotConstituent(root, "b1");
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	/*
1:a990e32: 	 * (21) Install a scoped subsystem, S1, with 
1:a990e32: 	 * apache-aries-provision-dependencies:=resolve. Install two features, F1 and 
1:a990e32: 	 * F2, independently as children of S1. F1 has bundle B1 and B2 as content. 
1:a990e32: 	 * F2 has bundle B2 and B3 as content. B2 is shared content. B1 has a 
1:a990e32: 	 * dependency on bundle B4, B2 has a dependency on bundle B5. B3 has a 
1:a990e32: 	 * dependency on bundle B6. Start F1. Dependency bundles B4 and B5 should be 
1:a990e32: 	 * provisioned but not B6.
1:a990e32: 	 */
1:a990e32: 	@Test
1:a990e32: 	public void test21() throws Exception {
1:a990e32: 		serviceRegistrations.add(bundleContext.registerService(
1:a990e32: 				Repository.class,
1:a990e32: 				new TestRepository.Builder()
1:a990e32: 		        		.resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b1")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .requirement(new TestRequirement.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.directive(
1:a990e32: 		                        				PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE,
1:a990e32: 		                        				"(osgi.wiring.package=b4)"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b1")
1:a990e32: 		                        		.importPackage("b4")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b2")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .requirement(new TestRequirement.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.directive(
1:a990e32: 		                        				PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE,
1:a990e32: 		                        				"(osgi.wiring.package=b5)"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b2")
1:a990e32: 		                        		.importPackage("b5")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b3")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .requirement(new TestRequirement.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.directive(
1:a990e32: 		                        				PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE,
1:a990e32: 		                        				"(osgi.wiring.package=b6)"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b3")
1:a990e32: 		                        		.importPackage("b6")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b4")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				PackageNamespace.PACKAGE_NAMESPACE,
1:a990e32: 		                        				"b4"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b4")
1:a990e32: 		                        		.exportPackage("b4")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b5")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				PackageNamespace.PACKAGE_NAMESPACE,
1:a990e32: 		                        				"b5"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b5")
1:a990e32: 		                        		.exportPackage("b5")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b6")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				PackageNamespace.PACKAGE_NAMESPACE,
1:a990e32: 		                        				"b6"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b6")
1:a990e32: 		                        		.exportPackage("b6")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		        		.build(),
1:a990e32:                 null));
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem s1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"s1",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("s1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1:a990e32: 								+ ';'
1:a990e32: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:a990e32: 								+ ":="
1:a990e32: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
1:a990e32: 		uninstallableSubsystems.add(s1);
1:a990e32: 		startSubsystem(s1, false);
1:a990e32: 		stoppableSubsystems.add(s1);
1:a990e32: 		Subsystem f2 = installSubsystem(
1:a990e32: 				s1,
1:a990e32: 				"f2",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 				.symbolicName("f2")
1:a990e32: 				.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1:a990e32: 				.content("b2,b3")
1:a990e32: 				.build(),
1:a990e32: 				false
1:a990e32: 				);
1:a990e32: 		uninstallableSubsystems.add(f2);
1:a990e32: 		assertChild(s1, "f2", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:a990e32: 		assertConstituent(s1, "f2", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:a990e32: 		assertConstituent(f2, "b2");
1:a990e32: 		assertConstituent(f2, "b3");
1:a990e32: 		Subsystem f1 = installSubsystem(
1:a990e32: 				s1,
1:a990e32: 				"f1",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 				.symbolicName("f1")
1:a990e32: 				.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1:a990e32: 				.content("b1,b2")
1:a990e32: 				.build(),
1:a990e32: 				false
1:a990e32: 				);
1:a990e32: 		uninstallableSubsystems.add(f1);
1:a990e32: 		assertChild(s1, "f1", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:a990e32: 		assertConstituent(s1, "f1", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1:a990e32: 		assertConstituent(f1, "b1");
1:a990e32: 		assertConstituent(f1, "b2");
1:a990e32: 		startSubsystem(f1, false);
2:a990e32: 		stoppableSubsystems.add(f1);
1:b66ad7c: 		assertState(EnumSet.of(State.RESOLVED, State.ACTIVE), f2);
1:a990e32: 		assertConstituent(s1, "b4");
1:a990e32: 		assertConstituent(s1, "b5");
1:a990e32: 		assertConstituent(s1, "b6");
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testFullLifeCycle() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 		startSubsystem(subsystem, false);
1:a990e32: 		stopSubsystem(subsystem);
1:a990e32: 		uninstallSubsystem(subsystem);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testImplicitlyInstalledChildOverridesProvisionDependencies() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		subsystemEvents.clear();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = root.install(
1:a990e32: 					"parent", 
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("parent")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 									AriesProvisionDependenciesDirective.INSTALL.toString())
1:a990e32: 							.subsystem(
1:a990e32: 									"child", 
1:a990e32: 									new SubsystemArchiveBuilder()
1:a990e32: 											.symbolicName("child")
1:a990e32: 											.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 													AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 											.build())
1:a990e32: 							.build());
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testInstall() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 		catch (Exception e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			fail("Subsystem should have installed");
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testInstallChildIntoInstallingParent() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_DEPENDENCY_IN_ARCHIVE, applicationDependencyInArchive(), false);
1:a990e32: 		try {
1:a990e32: 			assertState(State.INSTALLING, subsystem);
1:a990e32: 			installSubsystem(subsystem, APPLICATION_A, applicationA(), false);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testStart() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 		try {
1:a990e32: 			startSubsystem(subsystem, false);
1:a990e32: 			stopSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 		catch (Exception e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			fail("Subsystem should have started");
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testStop() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 		try {
1:a990e32: 			startSubsystem(subsystem, false);
1:a990e32: 			try {
1:a990e32: 				stopSubsystem(subsystem);
1:a990e32: 			}
1:a990e32: 			catch (Exception e) {
1:a990e32: 				e.printStackTrace();
1:a990e32: 				fail("Subsystem should have stopped");
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		finally {
1:a990e32: 			uninstallSubsystemSilently(subsystem);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testUninstall() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1:a990e32: 		try {
1:a990e32: 			uninstallSubsystem(subsystem);
1:a990e32: 		}
1:a990e32: 		catch (Exception e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 			fail("Subsystem should have uninstalled");
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationA() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_A);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ',' + BUNDLE_C);
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1:a990e32: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1:a990e32: 				.add(BUNDLE_C + JAR_EXTENSION, bundleC())
1:a990e32: 				.add(BUNDLE_D + JAR_EXTENSION, bundleD())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationB() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_B);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ',' + APPLICATION_A + ";type=osgi.subsystem.application");
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1:a990e32: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1:a990e32: 				.add(APPLICATION_A + ESA_EXTENSION, applicationA())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationDependencyInArchive() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_DEPENDENCY_IN_ARCHIVE);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1:a990e32: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationEmpty() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), MANIFEST_VERSION);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_EMPTY);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationInstallFailed() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), MANIFEST_VERSION);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_INSTALL_FAILED);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_INVALID_MANIFEST + JAR_EXTENSION, bundleInvalidManifest())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationInvalidProvisionDependencies() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_INVALID_PROVISION_DEPENDENCIES);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.NAME + ":=foo");
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationMissingDependency() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_MISSING_DEPENDENCY);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationProvisionDependenciesInstall() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_PROVISION_DEPENDENCIES_INSTALL);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.INSTALL.toString());
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1:a990e32: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream applicationStartFailure() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_START_FAILURE);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_START_FAILURE);
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.add(BUNDLE_START_FAILURE + JAR_EXTENSION, bundleStartFailure())
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private void assertReferences(Class<?> clazz, String filter, int expected) throws Exception {
1:a990e32: 		ServiceReference<?>[] references = bundleContext.getAllServiceReferences(clazz.getName(), filter);
1:a990e32: 		if (expected < 1) {
1:a990e32: 			assertNull("References exist", references);
1:a990e32: 		}
1:a990e32: 		else {
1:a990e32: 			assertNotNull("No references", references);
1:a990e32: 			assertEquals("No references or more than one", expected, references.length);
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 
1:a990e32: 	private InputStream bundleA() {
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_A)
1:a990e32: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_A)
1:a990e32: 				.set(Constants.IMPORT_PACKAGE, PACKAGE_B)
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream bundleB() {
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_B)
1:a990e32: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_B)
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream bundleC() {
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_C)
1:a990e32: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_C)
1:a990e32: 				.set(Constants.IMPORT_PACKAGE, PACKAGE_B)
1:a990e32: 				.set(Constants.IMPORT_PACKAGE, PACKAGE_D)
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream bundleD() {
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_D)
1:a990e32: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_D)
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream bundleInvalidManifest() {
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_INVALID_MANIFEST)
1:a990e32: 				.set(Constants.PROVIDE_CAPABILITY, "osgi.ee;osgi.ee=J2SE-1.4")
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream bundleStartFailure() {
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_START_FAILURE)
1:a990e32: 				.set(Constants.BUNDLE_ACTIVATOR, BundleStartFailureActivator.class.getName())
1:a990e32: 				.add(BundleStartFailureActivator.class, InnerClassStrategy.NONE)
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private InputStream featureProvisionDependenciesResolve() throws Exception {
1:a990e32: 		Manifest manifest = new Manifest();
1:a990e32: 		Attributes attributes = manifest.getMainAttributes();
1:a990e32: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_PROVISION_DEPENDENCIES_RESOLVE);
1:a990e32: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1:a990e32: 				SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' +
1:a990e32: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1:a990e32: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:a990e32: 		manifest.write(baos);
1:a990e32: 		baos.close();
1:a990e32: 		return TinyBundles
1:a990e32: 				.bundle()
1:a990e32: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1:a990e32: 				.build();
1:a990e32: 	}
1:a990e32: 	
1:afe81b7: 	public static interface TestService {}
1:afe81b7: 	
1:afe81b7: 	public static class TestServiceImpl implements TestService {}
1:afe81b7: 	
1:b66ad7c: 	public static class TestServiceClientActivator implements BundleActivator {
1:b66ad7c: 		@Override
1:b66ad7c: 		public void start(BundleContext context) throws Exception {
1:b66ad7c: 			ServiceReference<TestService> ref = null;
1:b66ad7c: 			for (int i = 0; i < 80; i++) { // 20 seconds with 250ms sleep.
1:b66ad7c: 				ref = context.getServiceReference(TestService.class);
1:b66ad7c: 				if (ref == null) {
1:b66ad7c: 					Thread.sleep(250);
1:b66ad7c: 					continue;
1:b66ad7c: 				}
1:b66ad7c: 				break;
1:b66ad7c: 			}
1:b66ad7c: 			try {
1:b66ad7c: 				TestService service = context.getService(ref);
1:b66ad7c: 				service.getClass();
1:b66ad7c: 			}
1:b66ad7c: 			finally {
1:b66ad7c: 				context.ungetService(ref);
1:b66ad7c: 			}
1:b66ad7c: 		}
1:b66ad7c: 
1:b66ad7c: 		@Override
1:b66ad7c: 		public void stop(BundleContext context) throws Exception {
1:b66ad7c: 		}
1:b66ad7c: 	}
1:b66ad7c: 	
1:b66ad7c: 	public static class TestServiceImplActivator implements BundleActivator {
1:afe81b7: 		private ServiceRegistration<TestService> reg;
1:afe81b7: 		
1:afe81b7: 		@Override
1:afe81b7: 		public void start(BundleContext context) throws Exception {
1:afe81b7: 			reg = context.registerService(
1:afe81b7: 					TestService.class, 
1:afe81b7: 					new TestServiceImpl(), 
1:afe81b7: 					null);
1:afe81b7: 		}
1:afe81b7: 
1:afe81b7: 		@Override
1:afe81b7: 		public void stop(BundleContext context) throws Exception {
1:afe81b7: 			reg.unregister();
1:afe81b7: 		}
1:afe81b7: 	}
1:afe81b7: 	
1:a990e32: 	private static class BundleStartFailureActivator implements BundleActivator {
1:a990e32: 		@Override
1:a990e32: 		public void start(BundleContext context) throws Exception {
1:a990e32: 			throw new IllegalStateException();
1:a990e32: 		}
1:a990e32: 
1:a990e32: 		@Override
1:a990e32: 		public void stop(BundleContext context) throws Exception {
1:a990e32: 			// Nothing.
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testInterleavingContentDependencies() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem c1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"c1",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("c1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.content("c1b1;version=\"[0,0]\"")
1:a990e32: 						.exportPackage("c1b1")
1:a990e32: 						.importPackage("c2b1")
1:a990e32: 						.bundle(
1:a990e32: 								"c1b1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("c1b1")
1:a990e32: 										.exportPackage("c1b1")
1:a990e32: 										.importPackage("c2b1")
1:a990e32: 										.build())
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
1:a990e32: 		uninstallableSubsystems.add(c1);
1:a990e32: 		Subsystem c2 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"c2",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("c2")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.content("c2b1;version=\"[0,0]\"")
1:a990e32: 						.exportPackage("c2b1")
1:a990e32: 						.importPackage("c1b1")
1:a990e32: 						.bundle(
1:a990e32: 								"c2b1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("c2b1")
1:a990e32: 										.exportPackage("c2b1")
1:a990e32: 										.importPackage("c1b1")
1:a990e32: 										.build())
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
1:afe81b7: 		uninstallableSubsystems.add(c2);
1:a990e32: 		startSubsystem(c1, false);
1:a990e32: 		stoppableSubsystems.add(c1);
1:a990e32: 		assertState(EnumSet.of(State.RESOLVED, State.ACTIVE), c2);
1:afe81b7: 		stoppableSubsystems.add(c2);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testRestart2() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem c1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"c1",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("c1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.content("c1b1;version=\"[0,0]\"")
1:a990e32: 						.exportPackage("c1b1")
1:a990e32: 						.importPackage("c2b1")
1:a990e32: 						.bundle(
1:a990e32: 								"c1b1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("c1b1")
1:a990e32: 										.exportPackage("c1b1")
1:a990e32: 										.importPackage("c2b1")
1:a990e32: 										.build())
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
1:a990e32: 		uninstallableSubsystems.add(c1);
1:a990e32: 		Subsystem c2 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"c2",
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("c2")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1:a990e32: 								+ ';'
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.content("c2b1;version=\"[0,0]\"")
1:a990e32: 						.exportPackage("c2b1")
1:a990e32: 						.importPackage("c1b1")
1:a990e32: 						.bundle(
1:a990e32: 								"c2b1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("c2b1")
1:a990e32: 										.exportPackage("c2b1")
1:a990e32: 										.importPackage("c1b1")
1:a990e32: 										.build())
1:a990e32: 						.build(),
1:a990e32: 				false
1:a990e32: 		);
2:a990e32: 		uninstallableSubsystems.add(c2);
1:a990e32: 		assertChild(root, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:a990e32: 		assertChild(root, "c2", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:a990e32: 		restartSubsystemsImplBundle();
1:a990e32: 		root = getRootSubsystem();
1:a990e32: 		c1 = getChild(root, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:a990e32: 		assertNotNull("Missing child", c1);
1:a990e32: 		uninstallableSubsystems.add(c1);
1:a990e32: 		c2 = getChild(root, "c2", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:a990e32: 		assertNotNull("Missing child", c2);
1:a990e32: 		uninstallableSubsystems.add(c2);
1:a990e32: 		startSubsystem(c1, false);
1:a990e32: 		stoppableSubsystems.add(c1);
1:a990e32: 		try {
1:a990e32: 			assertState(EnumSet.of(State.RESOLVED, State.ACTIVE), c2);
1:a990e32: 		}
1:a990e32: 		catch (AssertionError e) {
1:a990e32: 			System.out.println(c2.getState());
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void testRestart() throws Exception {
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		Subsystem a1 = installSubsystem(
1:a990e32: 				root,
1:a990e32: 				"a1", 
1:a990e32: 				new SubsystemArchiveBuilder()
1:a990e32: 						.symbolicName("a1")
1:a990e32: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1:a990e32: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 						.content("b1,c1;type=osgi.subsystem.composite")
1:a990e32: 						.bundle(
1:a990e32: 								"b1", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("b1")
1:a990e32: 										.importPackage("b2")
1:a990e32: 										.build())
1:a990e32: 						.bundle(
1:a990e32: 								"b2", 
1:a990e32: 								new BundleArchiveBuilder()
1:a990e32: 										.symbolicName("b2")
1:a990e32: 										.exportPackage("b2")
1:a990e32: 										.build())
1:a990e32: 						.subsystem(
1:a990e32: 								"c1", 
1:a990e32: 								new SubsystemArchiveBuilder()
1:a990e32: 										.symbolicName("c1")
1:a990e32: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1:a990e32: 												+ ';'
1:a990e32: 												+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:a990e32: 										.content("b1;version=\"[0,0]\"")
1:a990e32: 										.importPackage("b2")
1:a990e32: 										.bundle(
1:a990e32: 												"b1", 
1:a990e32: 												new BundleArchiveBuilder()
1:a990e32: 														.symbolicName("b1")
1:a990e32: 														.importPackage("b2")
1:a990e32: 														.build())
1:a990e32: 								.build())
1:a990e32: 						.build(),
1:a990e32: 				false);
2:a990e32: 		uninstallableSubsystems.add(a1);
1:a990e32: 		assertChild(root, "a1");
1:a990e32: 		assertState(State.INSTALLING, a1);
1:a990e32: 		Subsystem c1 = getChild(a1, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:a990e32: 		assertNotNull("Missing child", c1);
1:a990e32: 		assertState(State.INSTALLING, c1);
1:a990e32: 
1:a990e32: 		restartSubsystemsImplBundle();
1:a990e32: 		root = getRootSubsystem();
1:a990e32: 		
1:a990e32: 		a1 = getChild(root, "a1");
1:a990e32: 		assertNotNull("Missing child", a1);
1:a990e32: 		uninstallableSubsystems.add(a1);
1:a990e32: 		assertState(State.INSTALLING, a1);
1:a990e32: 		assertConstituent(a1, "b1");
1:a990e32: 		assertNotConstituent(root, "b2");
1:a990e32: 		
1:a990e32: 		c1 = getChild(a1, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1:a990e32: 		assertNotNull("Missing child", c1);
1:a990e32: 		uninstallableSubsystems.add(c1);
1:a990e32: 		assertConstituent(c1, "b1");
1:a990e32: 		
1:a990e32: 		startSubsystem(c1, false);
1:a990e32: 		stoppableSubsystems.add(c1);
1:a990e32: 		
1:a990e32: 		assertState(State.INSTALLED, a1);
2:a990e32: 		stoppableSubsystems.add(a1);
1:a990e32: 		
1:a990e32: 		assertConstituent(root, "b2");
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:a990e32: 	public void test4e3bCompliance() throws Exception {
1:a990e32: 		serviceRegistrations.add(bundleContext.registerService(
1:a990e32: 				Repository.class,
1:a990e32: 				new TestRepository.Builder()
1:a990e32: 		        		.resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"a")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				PackageNamespace.PACKAGE_NAMESPACE, 
1:a990e32: 		                        				"x")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion))
1:a990e32: 		                        .capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(BundleNamespace.BUNDLE_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				BundleNamespace.BUNDLE_NAMESPACE, 
1:a990e32: 		                        				"a")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				BundleNamespace.CAPABILITY_BUNDLE_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("a")
1:a990e32: 		                        		.exportPackage("x")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		                .resource(new TestRepositoryContent.Builder()
1:a990e32: 		                		.capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1:a990e32: 		                        				"b")
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1:a990e32: 		                        				Version.emptyVersion)
1:a990e32: 		                        		.attribute(
1:a990e32: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1:a990e32: 		                        				IdentityNamespace.TYPE_BUNDLE))
1:a990e32: 		                        .capability(new TestCapability.Builder()
1:a990e32: 		                        		.namespace("y"))
1:a990e32: 		                        .content(new BundleArchiveBuilder()
1:a990e32: 		                        		.symbolicName("b")
1:a990e32: 		                        		.header("Provide-Capability", "y")
1:a990e32: 		                        		.buildAsBytes())
1:a990e32: 		                        .build())
1:a990e32: 		        		.build(),
1:a990e32:                 null));
1:a990e32: 		Subsystem root = getRootSubsystem();
1:a990e32: 		try {
1:a990e32: 			Subsystem s1 = installSubsystem(
1:a990e32: 					root,
1:a990e32: 					"s1",
1:a990e32: 					new SubsystemArchiveBuilder()
1:a990e32: 							.symbolicName("s1")
1:a990e32: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:a990e32: 							.subsystem(
1:a990e32: 									"s3",
1:a990e32: 									new SubsystemArchiveBuilder()
1:a990e32: 											.symbolicName("s3")
1:a990e32: 											.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:a990e32: 											.subsystem(
1:a990e32: 													"s2", 
1:a990e32: 													new SubsystemArchiveBuilder()
1:a990e32: 															.symbolicName("s2")
1:a990e32: 															.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1:a990e32: 															.bundle(
1:a990e32: 																	"c", 
1:a990e32: 																	new BundleArchiveBuilder()
1:a990e32: 																			.symbolicName("c")
1:a990e32: 																			.importPackage("x")
1:a990e32: 																			.build())
1:a990e32: 															.bundle(
1:a990e32: 																	"d", 
1:a990e32: 																	new BundleArchiveBuilder()
1:a990e32: 																			.symbolicName("d")
1:a990e32: 																			.header("Require-Bundle", "a")
1:a990e32: 																			.build())
1:a990e32: 															.bundle(
1:a990e32: 																	"e", 
1:a990e32: 																	new BundleArchiveBuilder()
1:a990e32: 																			.symbolicName("e")
1:a990e32: 																			.header("Require-Capability", "y")
1:a990e32: 																			.build())
1:a990e32: 															.build())
1:a990e32: 											.build())
1:afe81b7: 							.build(),
1:a990e32: 					true);
1:a990e32: 			uninstallableSubsystems.add(s1);
1:a990e32: 			fail("Subsystem should not have installed");
1:a990e32: 		}
1:a990e32: 		catch (SubsystemException e) {
1:a990e32: 			e.printStackTrace();
1:a990e32: 		}
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	@Test
1:9ea9cc5: 	public void testMatchingCapabilityInDisconnectedRegion() throws Exception {
1:9ea9cc5: 		Subsystem root = getRootSubsystem();
1:9ea9cc5: 		BundleArchiveBuilder b1Builder = new BundleArchiveBuilder()
1:9ea9cc5: 				.symbolicName("b1")
1:9ea9cc5: 				.exportPackage("b1");
1:9ea9cc5: 		Bundle b1 = root.getBundleContext().installBundle("b1", b1Builder.build());
1:9ea9cc5: 		try {
1:9ea9cc5: 			Subsystem a1 = installSubsystem(
1:9ea9cc5: 					root,
1:9ea9cc5: 					"a1",
1:9ea9cc5: 					new SubsystemArchiveBuilder()
1:9ea9cc5: 							.symbolicName("a1")
1:9ea9cc5: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1:9ea9cc5: 									+ ';'
1:9ea9cc5: 									+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1:9ea9cc5: 									+ ';'
1:9ea9cc5: 									+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:9ea9cc5: 									+ ":="
1:9ea9cc5: 									+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:9ea9cc5: 							.build(),
1:9ea9cc5: 					false
1:9ea9cc5: 			);
1:9ea9cc5: 			uninstallableSubsystems.add(a1);
1:9ea9cc5: 			startSubsystem(a1, false);
1:9ea9cc5: 			stoppableSubsystems.add(a1);
1:9ea9cc5: 			removeConnectionWithParent(a1);
1:9ea9cc5: 			Subsystem a2 = installSubsystem(
1:9ea9cc5: 					a1,
1:9ea9cc5: 					"a2",
1:9ea9cc5: 					new SubsystemArchiveBuilder()
1:9ea9cc5: 							.symbolicName("a2")
1:9ea9cc5: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1:9ea9cc5: 							.content("b2")
1:9ea9cc5: 							.bundle(
1:9ea9cc5: 									"b2", 
1:9ea9cc5: 									new BundleArchiveBuilder()
1:9ea9cc5: 											.symbolicName("b2")
1:9ea9cc5: 											.importPackage("b1")
1:9ea9cc5: 											.build())
1:9ea9cc5: 							.bundle(
1:9ea9cc5: 									"b1",
1:9ea9cc5: 									b1Builder.build())
1:9ea9cc5: 							.build(),
1:9ea9cc5: 					false
1:9ea9cc5: 			);
1:9ea9cc5: 			uninstallableSubsystems.add(a2);
1:9ea9cc5: 			assertState(State.INSTALLING, a2);
1:9ea9cc5: 			assertNotConstituent(a1, "b1");
1:9ea9cc5: 			try {
1:9ea9cc5: 				startSubsystem(a2, false);
1:9ea9cc5: 				stoppableSubsystems.add(a2);
1:9ea9cc5: 				assertConstituent(a1, "b1");
1:9ea9cc5: 			}
1:9ea9cc5: 			catch (SubsystemException e) {
1:9ea9cc5: 				e.printStackTrace();
1:9ea9cc5: 				fail("Subsystem should have started");
1:9ea9cc5: 			}
1:9ea9cc5: 		}
1:9ea9cc5: 		finally {
1:9ea9cc5: 			uninstallSilently(b1);
1:9ea9cc5: 		}
1:9ea9cc5: 	}
1:645a92b: 	
1:645a92b: 	@Test
1:645a92b: 	public void testProvideCapabilityNamespaceOnly() throws Exception {
1:645a92b: 		Subsystem root = getRootSubsystem();
1:645a92b: 		Subsystem c1 = installSubsystem(
1:645a92b: 				root,
1:645a92b: 				"c1", 
1:645a92b: 				new SubsystemArchiveBuilder()
1:645a92b: 						.symbolicName("c1")
1:645a92b: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:645a92b: 						.provideCapability("y")
1:645a92b: 						.build());
1:afe81b7: 		uninstallableSubsystems.add(c1);
1:645a92b: 		try {
1:645a92b: 			startSubsystem(c1);
1:afe81b7: 			stoppableSubsystems.add(c1);
1:afe81b7: 		}
1:645a92b: 		catch (SubsystemException e) {
1:645a92b: 			e.printStackTrace();
1:645a92b: 			fail("Subsystem should have started");
1:645a92b: 		}
1:645a92b: 	}
1:afe81b7: 	
1:afe81b7: 	@Test
1:afe81b7: 	public void testComApiComImplAppClient() throws Exception {
1:afe81b7: 		Subsystem root = getRootSubsystem();
1:afe81b7: 		final Subsystem shared = installSubsystem(
1:afe81b7: 				root,
1:afe81b7: 				"shared", 
1:afe81b7: 				new SubsystemArchiveBuilder()
1:afe81b7: 						.symbolicName("shared")
1:afe81b7: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1:afe81b7: 								+ ';' 
1:afe81b7: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1:afe81b7: 								+ ';'
1:afe81b7: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:afe81b7: 								+ ":="
1:afe81b7: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:afe81b7: 						.importPackage("org.osgi.framework")
1:afe81b7: 						.build(),
1:afe81b7: 				false
1:afe81b7: 		);
1:afe81b7: 		uninstallableSubsystems.add(shared);
1:afe81b7: 		shared.start();
1:afe81b7: 		stoppableSubsystems.add(shared);
1:afe81b7: 		@SuppressWarnings("unchecked")
1:afe81b7: 		Callable<Subsystem>[] installCallables = new Callable[] {
1:afe81b7: 				new Callable<Subsystem>() {
1:afe81b7: 					@Override
1:afe81b7: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:afe81b7: 								shared,
1:afe81b7: 								"client", 
1:afe81b7: 								new SubsystemArchiveBuilder()
1:afe81b7: 										.symbolicName("client")
1:afe81b7: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1:afe81b7: 										.bundle(
1:afe81b7: 												"client", 
1:afe81b7: 												new BundleArchiveBuilder()
1:afe81b7: 														.symbolicName("client")
1:afe81b7: 														.importPackage("org.apache.aries.subsystem.itests.defect")
1:afe81b7: 														.requireCapability("osgi.service;filter:=\"(objectClass="
1:afe81b7: 																+ TestService.class.getName()
1:afe81b7: 																+ ")\";effective:=active")
1:afe81b7: 														.build())
1:afe81b7: 										.build(),
1:afe81b7: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:afe81b7: 						return result;
1:afe81b7: 					}
1:b66ad7c: 					
1:afe81b7: 				},
1:afe81b7: 				new Callable<Subsystem>() {
1:afe81b7: 					@Override
1:afe81b7: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:afe81b7: 								shared,
1:afe81b7: 								"impl", 
1:afe81b7: 								new SubsystemArchiveBuilder()
1:afe81b7: 										.symbolicName("impl")
1:afe81b7: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:afe81b7: 										.content("impl;version=\"[0,0]\"")
1:afe81b7: 										.provideCapability("osgi.service;objectClass:List<String>=\"" 
1:afe81b7: 												+ TestService.class.getName() 
1:afe81b7: 												+ "\"")
1:afe81b7: 										.importPackage("org.osgi.framework")
1:afe81b7: 										.requireBundle("api")
1:afe81b7: 										.bundle(
1:afe81b7: 												"impl", 
1:b66ad7c: 												new BundleArchiveBuilder()
1:afe81b7: 														.symbolicName("impl")
1:afe81b7: 														.provideCapability("osgi.service;objectClass:List<String>=\"" 
1:afe81b7: 																+ TestService.class.getName() 
1:afe81b7: 																+ "\"")
1:afe81b7: 														.importPackage("org.osgi.framework")
1:afe81b7: 														.requireBundle("api")
1:afe81b7: 														.clazz(TestServiceImpl.class)
1:b66ad7c: 														.activator(TestServiceImplActivator.class)
1:afe81b7: 														.build())
1:b66ad7c: 										.build(),
1:b66ad7c: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:b66ad7c: 						return result;
1:b66ad7c: 					}
1:afe81b7: 					
1:afe81b7: 				},
1:afe81b7: 				new Callable<Subsystem>() {
1:afe81b7: 					@Override
1:afe81b7: 					public Subsystem call() throws Exception {
1:afe81b7: 						Subsystem result = installSubsystem(
1:afe81b7: 								shared,
1:afe81b7: 								"api", 
1:afe81b7: 								new SubsystemArchiveBuilder()
1:afe81b7: 										.symbolicName("api")
1:afe81b7: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:afe81b7: 										.content("api;version=\"[0,0]\"")
1:afe81b7: 										.exportPackage("org.apache.aries.subsystem.itests.defect")
1:afe81b7: 										.provideCapability("osgi.wiring.bundle;osgi.wiring.bundle=api;bundle-version=0")
1:afe81b7: 										.bundle(
1:afe81b7: 												"api", 
1:afe81b7: 												new BundleArchiveBuilder()
1:afe81b7: 														.symbolicName("api")
1:afe81b7: 														.exportPackage("org.apache.aries.subsystem.itests.defect")
1:afe81b7: 														.clazz(TestService.class)
1:afe81b7: 														.build())
1:afe81b7: 										.build(),
1:afe81b7: 								false);
1:afe81b7: 						uninstallableSubsystems.add(result);
1:afe81b7: 						return result;
1:afe81b7: 					}
1:afe81b7: 					
1:afe81b7: 				}
1:afe81b7: 		};
1:afe81b7: 		ExecutorService executor = Executors.newFixedThreadPool(3);
1:afe81b7: 		List<Future<Subsystem>> installFutures = executor.invokeAll(Arrays.asList(installCallables));
1:afe81b7: 		final Subsystem a1 = installFutures.get(0).get();
1:afe81b7: 		final Subsystem c1 = installFutures.get(1).get();
1:afe81b7: 		final Subsystem c2 = installFutures.get(2).get();
1:afe81b7: 		@SuppressWarnings("unchecked")
1:afe81b7: 		Callable<Void>[] startCallables = new Callable[] {
1:afe81b7: 			new Callable<Void>() {
1:afe81b7: 				@Override
1:afe81b7: 				public Void call() throws Exception {
1:afe81b7: 					a1.start();
1:afe81b7: 					stoppableSubsystems.add(a1);
1:afe81b7: 					assertEvent(a1, State.INSTALLED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(a1, State.RESOLVING, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(a1, State.RESOLVED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(a1, State.STARTING, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(a1, State.ACTIVE, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1:afe81b7: 					return null;
1:afe81b7: 				}
1:afe81b7: 			},
1:afe81b7: 			new Callable<Void>() {
1:afe81b7: 				@Override
1:afe81b7: 				public Void call() throws Exception {
1:afe81b7: 					c1.start();
1:afe81b7: 					stoppableSubsystems.add(c1);
1:afe81b7: 					assertEvent(c1, State.INSTALLED, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c1, State.RESOLVING, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c1, State.RESOLVED, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c1, State.STARTING, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c1, State.ACTIVE, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1:afe81b7: 					return null;
1:afe81b7: 				}
1:afe81b7: 			},
1:afe81b7: 			new Callable<Void>() {
1:afe81b7: 				@Override
1:afe81b7: 				public Void call() throws Exception {
1:afe81b7: 					c2.start();
1:afe81b7: 					stoppableSubsystems.add(c2);
1:afe81b7: 					assertEvent(c2, State.INSTALLED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c2, State.RESOLVING, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c2, State.RESOLVED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c2, State.STARTING, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:afe81b7: 					assertEvent(c2, State.ACTIVE, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1:afe81b7: 					return null;
1:afe81b7: 				}
1:afe81b7: 			}
1:afe81b7: 		};
1:afe81b7: 		List<Future<Void>> startFutures = executor.invokeAll(Arrays.asList(startCallables));
1:afe81b7: 		startFutures.get(0).get();
1:afe81b7: 		startFutures.get(1).get();
1:afe81b7: 		startFutures.get(2).get();
1:afe81b7: 	}
1:afe81b7: 	
1:a990e32: 	@Test
1:b66ad7c: 	public void testComApiComImplComClient() throws Exception {
1:b66ad7c: 		Subsystem root = getRootSubsystem();
1:b66ad7c: 		final Subsystem shared = installSubsystem(
1:b66ad7c: 				root,
1:b66ad7c: 				"shared", 
1:b66ad7c: 				new SubsystemArchiveBuilder()
1:b66ad7c: 						.symbolicName("shared")
1:b66ad7c: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1:b66ad7c: 								+ ';' 
1:b66ad7c: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1:b66ad7c: 								+ ';'
1:b66ad7c: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:b66ad7c: 								+ ":="
1:b66ad7c: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:b66ad7c: 						.importPackage("org.osgi.framework")
1:b66ad7c: 						.build(),
1:b66ad7c: 				false
1:b66ad7c: 		);
1:b66ad7c: 		uninstallableSubsystems.add(shared);
1:b66ad7c: 		shared.start();
1:b66ad7c: 		stoppableSubsystems.add(shared);
1:b66ad7c: 		@SuppressWarnings("unchecked")
1:b66ad7c: 		Callable<Subsystem>[] installCallables = new Callable[] {
1:b66ad7c: 				new Callable<Subsystem>() {
1:b66ad7c: 					@Override
1:b66ad7c: 					public Subsystem call() throws Exception {
1:b66ad7c: 						Subsystem result = installSubsystem(
1:b66ad7c: 								shared,
1:b66ad7c: 								"client", 
1:b66ad7c: 								new SubsystemArchiveBuilder()
1:b66ad7c: 										.symbolicName("client")
1:b66ad7c: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:b66ad7c: 										.content("client;version=\"[0,0]\"")
1:b66ad7c: 										.importPackage("org.osgi.framework")
1:b66ad7c: 										.requireCapability("osgi.service;filter:=\"(objectClass="
1:b66ad7c: 												+ TestService.class.getName()
1:b66ad7c: 												+ ")\";effective:=active")
1:b66ad7c: 										.importService(TestService.class.getName())
1:b66ad7c: 										.requireBundle("api,impl")
1:b66ad7c: 										.bundle(
1:b66ad7c: 												"client", 
1:b66ad7c: 												new BundleArchiveBuilder()
1:b66ad7c: 														.symbolicName("client")
1:b66ad7c: 														.importPackage("org.osgi.framework")
1:b66ad7c: 														.requireCapability("osgi.service;filter:=\"(objectClass="
1:b66ad7c: 																+ TestService.class.getName()
1:b66ad7c: 																+ ")\";effective:=active")
1:b66ad7c: 														.requireBundle("api,impl")
1:b66ad7c: 														.activator(TestServiceClientActivator.class)
1:b66ad7c: 														.build())
1:b66ad7c: 										.build(),
1:b66ad7c: 								false);
1:b66ad7c: 						return result;
1:b66ad7c: 					}
1:b66ad7c: 					
1:b66ad7c: 				},
1:b66ad7c: 				new Callable<Subsystem>() {
1:b66ad7c: 					@Override
1:b66ad7c: 					public Subsystem call() throws Exception {
1:b66ad7c: 						Subsystem result = installSubsystem(
1:b66ad7c: 								shared,
1:b66ad7c: 								"impl", 
1:b66ad7c: 								new SubsystemArchiveBuilder()
1:b66ad7c: 										.symbolicName("impl")
1:b66ad7c: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:b66ad7c: 										.content("impl;version=\"[0,0]\"")
1:b66ad7c: 										.provideCapability("osgi.service;objectClass:List<String>=\"" 
1:b66ad7c: 												+ TestService.class.getName() 
1:b66ad7c: 												+ "\"")
1:b66ad7c: 										.exportService(TestService.class.getName())
1:b66ad7c: 										.importPackage("org.osgi.framework")
1:b66ad7c: 										.requireBundle("api")
1:b66ad7c: 										.provideCapability("osgi.wiring.bundle;osgi.wiring.bundle=impl;bundle-version=0")
1:b66ad7c: 										.bundle(
1:b66ad7c: 												"impl", 
1:b66ad7c: 												new BundleArchiveBuilder()
1:b66ad7c: 														.symbolicName("impl")
1:b66ad7c: 														.provideCapability("osgi.service;objectClass:List<String>=\"" 
1:b66ad7c: 																+ TestService.class.getName() 
1:b66ad7c: 																+ "\"")
1:b66ad7c: 														.importPackage("org.osgi.framework")
1:b66ad7c: 														.requireBundle("api")
1:b66ad7c: 														.clazz(TestServiceImpl.class)
1:b66ad7c: 														.activator(TestServiceImplActivator.class)
1:b66ad7c: 														.build())
1:b66ad7c: 										.build(),
1:b66ad7c: 								false);
1:b66ad7c: 						return result;
1:b66ad7c: 					}
1:b66ad7c: 					
1:b66ad7c: 				},
1:b66ad7c: 				new Callable<Subsystem>() {
1:b66ad7c: 					@Override
1:b66ad7c: 					public Subsystem call() throws Exception {
1:b66ad7c: 						Subsystem result = installSubsystem(
1:b66ad7c: 								shared,
1:b66ad7c: 								"api", 
1:b66ad7c: 								new SubsystemArchiveBuilder()
1:b66ad7c: 										.symbolicName("api")
1:b66ad7c: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1:b66ad7c: 										.content("api;version=\"[0,0]\"")
1:b66ad7c: 										.exportPackage("org.apache.aries.subsystem.itests.defect")
1:b66ad7c: 										.provideCapability("osgi.wiring.bundle;osgi.wiring.bundle=api;bundle-version=0")
1:b66ad7c: 										.bundle(
1:b66ad7c: 												"api", 
1:afe81b7: 												new BundleArchiveBuilder()
1:b66ad7c: 														.symbolicName("api")
1:b66ad7c: 														.exportPackage("org.apache.aries.subsystem.itests.defect")
1:b66ad7c: 														.clazz(TestService.class)
1:b66ad7c: 														.build())
1:a990e32: 										.build(),
1:afe81b7: 								false);
1:afe81b7: 						return result;
1:b66ad7c: 					}
1:a990e32: 					
1:645a92b: 				}
1:b66ad7c: 		};
1:b66ad7c: 		ExecutorService executor = Executors.newFixedThreadPool(3);
1:b66ad7c: 		List<Future<Subsystem>> installFutures = executor.invokeAll(Arrays.asList(installCallables));
1:b66ad7c: 		final Subsystem client = installFutures.get(0).get();
1:b66ad7c: 		final Subsystem impl = installFutures.get(1).get();
1:b66ad7c: 		final Subsystem api = installFutures.get(2).get();
1:b66ad7c: 		@SuppressWarnings("unchecked")
1:b66ad7c: 		Callable<Void>[] startCallables = new Callable[] {
1:b66ad7c: 			new Callable<Void>() {
1:b66ad7c: 				@Override
1:b66ad7c: 				public Void call() throws Exception {
1:b66ad7c: 					client.start();
1:b66ad7c: 					assertEvent(client, State.INSTALLED, subsystemEvents.poll(client.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(client, State.RESOLVING, subsystemEvents.poll(client.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(client, State.RESOLVED, subsystemEvents.poll(client.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(client, State.STARTING, subsystemEvents.poll(client.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(client, State.ACTIVE, subsystemEvents.poll(client.getSubsystemId(), 5000));
1:b66ad7c: 					return null;
1:b66ad7c: 				}
1:b66ad7c: 			},
1:b66ad7c: 			new Callable<Void>() {
1:b66ad7c: 				@Override
1:b66ad7c: 				public Void call() throws Exception {
1:b66ad7c: 					impl.start();
1:b66ad7c: 					assertEvent(impl, State.INSTALLED, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(impl, State.RESOLVING, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(impl, State.RESOLVED, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(impl, State.STARTING, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(impl, State.ACTIVE, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1:b66ad7c: 					return null;
1:b66ad7c: 				}
1:b66ad7c: 			},
1:b66ad7c: 			new Callable<Void>() {
1:b66ad7c: 				@Override
1:b66ad7c: 				public Void call() throws Exception {
1:b66ad7c: 					api.start();
1:b66ad7c: 					assertEvent(api, State.INSTALLED, subsystemEvents.poll(api.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(api, State.RESOLVING, subsystemEvents.poll(api.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(api, State.RESOLVED, subsystemEvents.poll(api.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(api, State.STARTING, subsystemEvents.poll(api.getSubsystemId(), 5000));
1:b66ad7c: 					assertEvent(api, State.ACTIVE, subsystemEvents.poll(api.getSubsystemId(), 5000));
1:b66ad7c: 					return null;
1:b66ad7c: 				}
1:b66ad7c: 			}
1:b66ad7c: 		};
1:b66ad7c: 		List<Future<Void>> startFutures = executor.invokeAll(Arrays.asList(startCallables));
1:b66ad7c: 		startFutures.get(0).get();
1:b66ad7c: 		startFutures.get(1).get();
1:b66ad7c: 		startFutures.get(2).get();
1:b66ad7c: 	}
1:b66ad7c: 	
1:b66ad7c: 	@Test
1:b66ad7c: 	public void testAutoInstallDependenciesComposite() throws Exception {
1:b66ad7c: 		Subsystem root = getRootSubsystem();
1:b66ad7c: 		Subsystem b = installSubsystem(
1:b66ad7c: 				root,
1:b66ad7c: 				"b", 
1:b66ad7c: 				new SubsystemArchiveBuilder()
1:b66ad7c: 						.symbolicName("b")
1:b66ad7c: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1:b66ad7c: 								+ ';' 
1:b66ad7c: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1:b66ad7c: 						.content("a;version=\"[0,0]\"")
1:b66ad7c: 						.exportPackage("a")
1:b66ad7c: 						.importPackage("b")
1:b66ad7c: 						.bundle(
1:b66ad7c: 								"a", 
1:b66ad7c: 								new BundleArchiveBuilder()
1:b66ad7c: 								.symbolicName("a")
1:b66ad7c: 								.importPackage("b")
1:b66ad7c: 								.exportPackage("a")
1:b66ad7c: 								.build())
1:b66ad7c: 						.bundle(
1:b66ad7c: 								"b", 
1:b66ad7c: 								new BundleArchiveBuilder()
1:b66ad7c: 								.symbolicName("b")
1:b66ad7c: 								.exportPackage("b")
1:b66ad7c: 								.build())
1:b66ad7c: 						.build(),
1:b66ad7c: 				false
1:b66ad7c: 		);
1:b66ad7c: 		uninstallableSubsystems.add(b);
1:b66ad7c: 		try {
1:b66ad7c: 			Subsystem a = installSubsystem(
1:b66ad7c: 					root,
1:b66ad7c: 					"a", 
1:b66ad7c: 					new SubsystemArchiveBuilder()
1:b66ad7c: 							.symbolicName("a")
1:b66ad7c: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1:b66ad7c: 							.bundle(
1:b66ad7c: 									"a", 
1:b66ad7c: 									new BundleArchiveBuilder()
1:b66ad7c: 									.symbolicName("a")
1:b66ad7c: 									.importPackage("a")
1:b66ad7c: 									.build())
1:b66ad7c: 							.build(),
1:b66ad7c: 					true
1:b66ad7c: 			);
1:b66ad7c: 			uninstallableSubsystems.add(a);
1:b66ad7c: 			assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), b);
1:b66ad7c: 		}
1:b66ad7c: 		catch (Exception e) {
1:b66ad7c: 			e.printStackTrace();
1:b66ad7c: 			fail("Subsystem should have installed");
1:b66ad7c: 		}
1:b66ad7c: 	}
1:b66ad7c: 	
1:b66ad7c: 	@Test
1:b66ad7c: 	public void testAutoInstallDependenciesFeature() throws Exception {
1:b66ad7c: 		Subsystem root = getRootSubsystem();
1:b66ad7c: 		Subsystem shared = installSubsystem(
1:b66ad7c: 				root,
1:b66ad7c: 				"shared", 
1:b66ad7c: 				new SubsystemArchiveBuilder()
1:b66ad7c: 						.symbolicName("shared")
1:b66ad7c: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1:b66ad7c: 								+ ';' 
1:b66ad7c: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1:b66ad7c: 								+ ';'
1:b66ad7c: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1:b66ad7c: 								+ ":="
1:b66ad7c: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1:b66ad7c: 						.build(),
1:b66ad7c: 				false
1:b66ad7c: 		);
1:b66ad7c: 		uninstallableSubsystems.add(shared);
1:b66ad7c: 		startSubsystem(shared, false);
1:b66ad7c: 		Subsystem b = installSubsystem(
1:b66ad7c: 				shared,
1:b66ad7c: 				"b", 
1:b66ad7c: 				new SubsystemArchiveBuilder()
1:b66ad7c: 						.symbolicName("b")
1:b66ad7c: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1:b66ad7c: 						.content("a")
1:b66ad7c: 						.bundle(
1:b66ad7c: 								"a", 
1:b66ad7c: 								new BundleArchiveBuilder()
1:b66ad7c: 								.symbolicName("a")
1:b66ad7c: 								.importPackage("b")
1:b66ad7c: 								.exportPackage("a")
1:b66ad7c: 								.build())
1:b66ad7c: 						.bundle(
1:b66ad7c: 								"b", 
1:b66ad7c: 								new BundleArchiveBuilder()
1:b66ad7c: 								.symbolicName("b")
1:b66ad7c: 								.exportPackage("b")
1:b66ad7c: 								.build())
1:b66ad7c: 						.build(),
1:b66ad7c: 				false
1:b66ad7c: 		);
1:b66ad7c: 		try {
1:b66ad7c: 			installSubsystem(
1:b66ad7c: 					shared,
1:b66ad7c: 					"a", 
1:b66ad7c: 					new SubsystemArchiveBuilder()
1:b66ad7c: 							.symbolicName("a")
1:b66ad7c: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1:b66ad7c: 									+ ';' 
1:b66ad7c: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1:b66ad7c: 							.bundle(
1:b66ad7c: 									"a", 
1:b66ad7c: 									new BundleArchiveBuilder()
1:b66ad7c: 									.symbolicName("a")
1:b66ad7c: 									.importPackage("a")
1:b66ad7c: 									.build())
1:b66ad7c: 							.build(),
1:b66ad7c: 					true
1:b66ad7c: 			);
1:b66ad7c: 			assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), b);
1:b66ad7c: 		}
1:b66ad7c: 		catch (Exception e) {
1:b66ad7c: 			e.printStackTrace();
1:b66ad7c: 			fail("Subsystem should have installed");
1:b66ad7c: 		}
1:b66ad7c: 	}
1:a990e32: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:b66ad7c
/////////////////////////////////////////////////////////////////////////
1: 		assertState(EnumSet.of(State.RESOLVED, State.ACTIVE), f2);
/////////////////////////////////////////////////////////////////////////
1: 	public static class TestServiceClientActivator implements BundleActivator {
1: 		@Override
1: 		public void start(BundleContext context) throws Exception {
1: 			ServiceReference<TestService> ref = null;
1: 			for (int i = 0; i < 80; i++) { // 20 seconds with 250ms sleep.
1: 				ref = context.getServiceReference(TestService.class);
1: 				if (ref == null) {
1: 					Thread.sleep(250);
1: 					continue;
1: 				}
1: 				break;
1: 			}
1: 			try {
1: 				TestService service = context.getService(ref);
1: 				service.getClass();
1: 			}
1: 			finally {
1: 				context.ungetService(ref);
1: 			}
1: 		}
1: 
1: 		@Override
1: 		public void stop(BundleContext context) throws Exception {
1: 		}
1: 	}
1: 	
1: 	public static class TestServiceImplActivator implements BundleActivator {
/////////////////////////////////////////////////////////////////////////
1: 														.activator(TestServiceImplActivator.class)
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Test
1: 	public void testComApiComImplComClient() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		final Subsystem shared = installSubsystem(
1: 				root,
1: 				"shared", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("shared")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1: 								+ ';' 
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1: 								+ ';'
1: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 								+ ":="
1: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 						.importPackage("org.osgi.framework")
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(shared);
1: 		shared.start();
1: 		stoppableSubsystems.add(shared);
1: 		@SuppressWarnings("unchecked")
1: 		Callable<Subsystem>[] installCallables = new Callable[] {
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
1: 						Subsystem result = installSubsystem(
1: 								shared,
1: 								"client", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("client")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 										.content("client;version=\"[0,0]\"")
1: 										.importPackage("org.osgi.framework")
1: 										.requireCapability("osgi.service;filter:=\"(objectClass="
1: 												+ TestService.class.getName()
1: 												+ ")\";effective:=active")
1: 										.importService(TestService.class.getName())
1: 										.requireBundle("api,impl")
1: 										.bundle(
1: 												"client", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("client")
1: 														.importPackage("org.osgi.framework")
1: 														.requireCapability("osgi.service;filter:=\"(objectClass="
1: 																+ TestService.class.getName()
1: 																+ ")\";effective:=active")
1: 														.requireBundle("api,impl")
1: 														.activator(TestServiceClientActivator.class)
1: 														.build())
1: 										.build(),
1: 								false);
1: 						return result;
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
1: 						Subsystem result = installSubsystem(
1: 								shared,
1: 								"impl", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("impl")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 										.content("impl;version=\"[0,0]\"")
1: 										.provideCapability("osgi.service;objectClass:List<String>=\"" 
1: 												+ TestService.class.getName() 
1: 												+ "\"")
1: 										.exportService(TestService.class.getName())
1: 										.importPackage("org.osgi.framework")
1: 										.requireBundle("api")
1: 										.provideCapability("osgi.wiring.bundle;osgi.wiring.bundle=impl;bundle-version=0")
1: 										.bundle(
1: 												"impl", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("impl")
1: 														.provideCapability("osgi.service;objectClass:List<String>=\"" 
1: 																+ TestService.class.getName() 
1: 																+ "\"")
1: 														.importPackage("org.osgi.framework")
1: 														.requireBundle("api")
1: 														.clazz(TestServiceImpl.class)
1: 														.activator(TestServiceImplActivator.class)
1: 														.build())
1: 										.build(),
1: 								false);
1: 						return result;
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
1: 						Subsystem result = installSubsystem(
1: 								shared,
1: 								"api", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("api")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 										.content("api;version=\"[0,0]\"")
1: 										.exportPackage("org.apache.aries.subsystem.itests.defect")
1: 										.provideCapability("osgi.wiring.bundle;osgi.wiring.bundle=api;bundle-version=0")
1: 										.bundle(
1: 												"api", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("api")
1: 														.exportPackage("org.apache.aries.subsystem.itests.defect")
1: 														.clazz(TestService.class)
1: 														.build())
1: 										.build(),
1: 								false);
1: 						return result;
1: 					}
1: 					
1: 				}
1: 		};
1: 		ExecutorService executor = Executors.newFixedThreadPool(3);
1: 		List<Future<Subsystem>> installFutures = executor.invokeAll(Arrays.asList(installCallables));
1: 		final Subsystem client = installFutures.get(0).get();
1: 		final Subsystem impl = installFutures.get(1).get();
1: 		final Subsystem api = installFutures.get(2).get();
1: 		@SuppressWarnings("unchecked")
1: 		Callable<Void>[] startCallables = new Callable[] {
1: 			new Callable<Void>() {
1: 				@Override
1: 				public Void call() throws Exception {
1: 					client.start();
1: 					assertEvent(client, State.INSTALLED, subsystemEvents.poll(client.getSubsystemId(), 5000));
1: 					assertEvent(client, State.RESOLVING, subsystemEvents.poll(client.getSubsystemId(), 5000));
1: 					assertEvent(client, State.RESOLVED, subsystemEvents.poll(client.getSubsystemId(), 5000));
1: 					assertEvent(client, State.STARTING, subsystemEvents.poll(client.getSubsystemId(), 5000));
1: 					assertEvent(client, State.ACTIVE, subsystemEvents.poll(client.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Void>() {
1: 				@Override
1: 				public Void call() throws Exception {
1: 					impl.start();
1: 					assertEvent(impl, State.INSTALLED, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1: 					assertEvent(impl, State.RESOLVING, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1: 					assertEvent(impl, State.RESOLVED, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1: 					assertEvent(impl, State.STARTING, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1: 					assertEvent(impl, State.ACTIVE, subsystemEvents.poll(impl.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Void>() {
1: 				@Override
1: 				public Void call() throws Exception {
1: 					api.start();
1: 					assertEvent(api, State.INSTALLED, subsystemEvents.poll(api.getSubsystemId(), 5000));
1: 					assertEvent(api, State.RESOLVING, subsystemEvents.poll(api.getSubsystemId(), 5000));
1: 					assertEvent(api, State.RESOLVED, subsystemEvents.poll(api.getSubsystemId(), 5000));
1: 					assertEvent(api, State.STARTING, subsystemEvents.poll(api.getSubsystemId(), 5000));
1: 					assertEvent(api, State.ACTIVE, subsystemEvents.poll(api.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			}
1: 		};
1: 		List<Future<Void>> startFutures = executor.invokeAll(Arrays.asList(startCallables));
1: 		startFutures.get(0).get();
1: 		startFutures.get(1).get();
1: 		startFutures.get(2).get();
1: 	}
1: 	
1: 	@Test
1: 	public void testAutoInstallDependenciesComposite() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem b = installSubsystem(
1: 				root,
1: 				"b", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("b")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1: 								+ ';' 
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("a;version=\"[0,0]\"")
1: 						.exportPackage("a")
1: 						.importPackage("b")
1: 						.bundle(
1: 								"a", 
1: 								new BundleArchiveBuilder()
1: 								.symbolicName("a")
1: 								.importPackage("b")
1: 								.exportPackage("a")
1: 								.build())
1: 						.bundle(
1: 								"b", 
1: 								new BundleArchiveBuilder()
1: 								.symbolicName("b")
1: 								.exportPackage("b")
1: 								.build())
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(b);
1: 		try {
1: 			Subsystem a = installSubsystem(
1: 					root,
1: 					"a", 
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("a")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1: 							.bundle(
1: 									"a", 
1: 									new BundleArchiveBuilder()
1: 									.symbolicName("a")
1: 									.importPackage("a")
1: 									.build())
1: 							.build(),
1: 					true
1: 			);
1: 			uninstallableSubsystems.add(a);
1: 			assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), b);
1: 		}
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have installed");
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testAutoInstallDependenciesFeature() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem shared = installSubsystem(
1: 				root,
1: 				"shared", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("shared")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1: 								+ ';' 
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1: 								+ ';'
1: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 								+ ":="
1: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(shared);
1: 		startSubsystem(shared, false);
1: 		Subsystem b = installSubsystem(
1: 				shared,
1: 				"b", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("b")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1: 						.content("a")
1: 						.bundle(
1: 								"a", 
1: 								new BundleArchiveBuilder()
1: 								.symbolicName("a")
1: 								.importPackage("b")
1: 								.exportPackage("a")
1: 								.build())
1: 						.bundle(
1: 								"b", 
1: 								new BundleArchiveBuilder()
1: 								.symbolicName("b")
1: 								.exportPackage("b")
1: 								.build())
1: 						.build(),
1: 				false
1: 		);
1: 		try {
1: 			installSubsystem(
1: 					shared,
1: 					"a", 
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("a")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1: 									+ ';' 
1: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1: 							.bundle(
1: 									"a", 
1: 									new BundleArchiveBuilder()
1: 									.symbolicName("a")
1: 									.importPackage("a")
1: 									.build())
1: 							.build(),
1: 					true
1: 			);
1: 			assertState(EnumSet.of(State.INSTALLED, State.RESOLVED), b);
1: 		}
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have installed");
1: 		}
1: 	}
commit:afe81b7
/////////////////////////////////////////////////////////////////////////
1: 						Subsystem result = installSubsystem(
/////////////////////////////////////////////////////////////////////////
1: 						uninstallableSubsystems.add(result);
1: 						return result;
1: 						Subsystem result = installSubsystem(
/////////////////////////////////////////////////////////////////////////
1: 						uninstallableSubsystems.add(result);
1: 						return result;
1: 						Subsystem result = installSubsystem(
/////////////////////////////////////////////////////////////////////////
1: 						uninstallableSubsystems.add(result);
1: 						return result;
1: 						Subsystem result = installSubsystem(
/////////////////////////////////////////////////////////////////////////
1: 						uninstallableSubsystems.add(result);
1: 						return result;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					stoppableSubsystems.add(a1);
/////////////////////////////////////////////////////////////////////////
1: 					stoppableSubsystems.add(f1);
/////////////////////////////////////////////////////////////////////////
1: 					stoppableSubsystems.add(f2);
/////////////////////////////////////////////////////////////////////////
1: 					stoppableSubsystems.add(c2);
/////////////////////////////////////////////////////////////////////////
1: 	public static interface TestService {}
1: 	
1: 	public static class TestServiceImpl implements TestService {}
1: 	
0: 	public static class TestServiceActivator implements BundleActivator {
1: 		private ServiceRegistration<TestService> reg;
1: 		
1: 		@Override
1: 		public void start(BundleContext context) throws Exception {
1: 			reg = context.registerService(
1: 					TestService.class, 
1: 					new TestServiceImpl(), 
1: 					null);
1: 		}
1: 
1: 		@Override
1: 		public void stop(BundleContext context) throws Exception {
1: 			reg.unregister();
1: 		}
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		stoppableSubsystems.add(c2);
/////////////////////////////////////////////////////////////////////////
1: 		uninstallableSubsystems.add(c1);
/////////////////////////////////////////////////////////////////////////
1: 		uninstallableSubsystems.add(c2);
/////////////////////////////////////////////////////////////////////////
1: 		uninstallableSubsystems.add(c1);
1: 			stoppableSubsystems.add(c1);
1: 	
1: 	@Test
1: 	public void testComApiComImplAppClient() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		final Subsystem shared = installSubsystem(
1: 				root,
1: 				"shared", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("shared")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE 
1: 								+ ';' 
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1: 								+ ';'
1: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 								+ ":="
1: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 						.importPackage("org.osgi.framework")
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(shared);
1: 		shared.start();
1: 		stoppableSubsystems.add(shared);
1: 		@SuppressWarnings("unchecked")
1: 		Callable<Subsystem>[] installCallables = new Callable[] {
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
1: 						Subsystem result = installSubsystem(
1: 								shared,
1: 								"client", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("client")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1: 										.bundle(
1: 												"client", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("client")
1: 														.importPackage("org.apache.aries.subsystem.itests.defect")
1: 														.requireCapability("osgi.service;filter:=\"(objectClass="
1: 																+ TestService.class.getName()
1: 																+ ")\";effective:=active")
1: 														.build())
1: 										.build(),
1: 								false);
1: 						uninstallableSubsystems.add(result);
1: 						return result;
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
1: 						Subsystem result = installSubsystem(
1: 								shared,
1: 								"impl", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("impl")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 										.content("impl;version=\"[0,0]\"")
1: 										.provideCapability("osgi.service;objectClass:List<String>=\"" 
1: 												+ TestService.class.getName() 
1: 												+ "\"")
1: 										.importPackage("org.osgi.framework")
1: 										.requireBundle("api")
1: 										.bundle(
1: 												"impl", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("impl")
1: 														.provideCapability("osgi.service;objectClass:List<String>=\"" 
1: 																+ TestService.class.getName() 
1: 																+ "\"")
1: 														.importPackage("org.osgi.framework")
1: 														.requireBundle("api")
1: 														.clazz(TestServiceImpl.class)
0: 														.activator(TestServiceActivator.class)
1: 														.build())
1: 										.build(),
1: 								false);
1: 						uninstallableSubsystems.add(result);
1: 						return result;
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
1: 						Subsystem result = installSubsystem(
1: 								shared,
1: 								"api", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("api")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 										.content("api;version=\"[0,0]\"")
1: 										.exportPackage("org.apache.aries.subsystem.itests.defect")
1: 										.provideCapability("osgi.wiring.bundle;osgi.wiring.bundle=api;bundle-version=0")
1: 										.bundle(
1: 												"api", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("api")
1: 														.exportPackage("org.apache.aries.subsystem.itests.defect")
1: 														.clazz(TestService.class)
1: 														.build())
1: 										.build(),
1: 								false);
1: 						uninstallableSubsystems.add(result);
1: 						return result;
1: 					}
1: 					
1: 				}
1: 		};
1: 		ExecutorService executor = Executors.newFixedThreadPool(3);
1: 		List<Future<Subsystem>> installFutures = executor.invokeAll(Arrays.asList(installCallables));
1: 		final Subsystem a1 = installFutures.get(0).get();
1: 		final Subsystem c1 = installFutures.get(1).get();
1: 		final Subsystem c2 = installFutures.get(2).get();
1: 		@SuppressWarnings("unchecked")
1: 		Callable<Void>[] startCallables = new Callable[] {
1: 			new Callable<Void>() {
1: 				@Override
1: 				public Void call() throws Exception {
1: 					a1.start();
1: 					stoppableSubsystems.add(a1);
1: 					assertEvent(a1, State.INSTALLED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					assertEvent(a1, State.RESOLVING, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					assertEvent(a1, State.RESOLVED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					assertEvent(a1, State.STARTING, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					assertEvent(a1, State.ACTIVE, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Void>() {
1: 				@Override
1: 				public Void call() throws Exception {
1: 					c1.start();
1: 					stoppableSubsystems.add(c1);
1: 					assertEvent(c1, State.INSTALLED, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1: 					assertEvent(c1, State.RESOLVING, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1: 					assertEvent(c1, State.RESOLVED, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1: 					assertEvent(c1, State.STARTING, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1: 					assertEvent(c1, State.ACTIVE, subsystemEvents.poll(c1.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Void>() {
1: 				@Override
1: 				public Void call() throws Exception {
1: 					c2.start();
1: 					stoppableSubsystems.add(c2);
1: 					assertEvent(c2, State.INSTALLED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					assertEvent(c2, State.RESOLVING, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					assertEvent(c2, State.RESOLVED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					assertEvent(c2, State.STARTING, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					assertEvent(c2, State.ACTIVE, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			}
1: 		};
1: 		List<Future<Void>> startFutures = executor.invokeAll(Arrays.asList(startCallables));
1: 		startFutures.get(0).get();
1: 		startFutures.get(1).get();
1: 		startFutures.get(2).get();
1: 	}
commit:645a92b
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Test
1: 	public void testProvideCapabilityNamespaceOnly() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem c1 = installSubsystem(
1: 				root,
1: 				"c1", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("c1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 						.provideCapability("y")
1: 						.build());
1: 		try {
1: 			startSubsystem(c1);
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have started");
1: 		}
1: 	}
commit:1c027e7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9ea9cc5
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Test
1: 	public void testMatchingCapabilityInDisconnectedRegion() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		BundleArchiveBuilder b1Builder = new BundleArchiveBuilder()
1: 				.symbolicName("b1")
1: 				.exportPackage("b1");
1: 		Bundle b1 = root.getBundleContext().installBundle("b1", b1Builder.build());
1: 		try {
1: 			Subsystem a1 = installSubsystem(
1: 					root,
1: 					"a1",
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("a1")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1: 									+ ';'
1: 									+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1: 									+ ';'
1: 									+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 									+ ":="
1: 									+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 							.build(),
1: 					false
1: 			);
1: 			uninstallableSubsystems.add(a1);
1: 			startSubsystem(a1, false);
1: 			stoppableSubsystems.add(a1);
1: 			removeConnectionWithParent(a1);
1: 			Subsystem a2 = installSubsystem(
1: 					a1,
1: 					"a2",
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("a2")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1: 							.content("b2")
1: 							.bundle(
1: 									"b2", 
1: 									new BundleArchiveBuilder()
1: 											.symbolicName("b2")
1: 											.importPackage("b1")
1: 											.build())
1: 							.bundle(
1: 									"b1",
1: 									b1Builder.build())
1: 							.build(),
1: 					false
1: 			);
1: 			uninstallableSubsystems.add(a2);
1: 			assertState(State.INSTALLING, a2);
1: 			assertNotConstituent(a1, "b1");
1: 			try {
1: 				startSubsystem(a2, false);
1: 				stoppableSubsystems.add(a2);
1: 				assertConstituent(a1, "b1");
1: 			}
1: 			catch (SubsystemException e) {
1: 				e.printStackTrace();
1: 				fail("Subsystem should have started");
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSilently(b1);
1: 		}
1: 	}
commit:4821cbe
/////////////////////////////////////////////////////////////////////////
commit:a990e32
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.subsystem.itests.defect;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertSame;
1: import static org.junit.Assert.fail;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.InputStream;
0: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.EnumSet;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.jar.Attributes;
1: import java.util.jar.Manifest;
1: 
1: import org.apache.aries.subsystem.AriesSubsystem;
1: import org.apache.aries.subsystem.core.archive.AriesProvisionDependenciesDirective;
1: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
1: import org.apache.aries.subsystem.itests.SubsystemTest;
1: import org.apache.aries.subsystem.itests.util.BundleArchiveBuilder;
1: import org.apache.aries.subsystem.itests.util.SubsystemArchiveBuilder;
1: import org.apache.aries.subsystem.itests.util.TestCapability;
1: import org.apache.aries.subsystem.itests.util.TestRepository;
1: import org.apache.aries.subsystem.itests.util.TestRepositoryContent;
1: import org.apache.aries.subsystem.itests.util.TestRequirement;
1: import org.easymock.internal.matchers.Null;
1: import org.junit.Test;
1: import org.ops4j.pax.tinybundles.core.InnerClassStrategy;
1: import org.ops4j.pax.tinybundles.core.TinyBundles;
1: import org.osgi.framework.BundleActivator;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.ServiceEvent;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.ServiceRegistration;
1: import org.osgi.framework.Version;
1: import org.osgi.framework.hooks.resolver.ResolverHook;
1: import org.osgi.framework.hooks.resolver.ResolverHookFactory;
1: import org.osgi.framework.namespace.BundleNamespace;
0: import org.osgi.framework.namespace.HostNamespace;
1: import org.osgi.framework.namespace.IdentityNamespace;
1: import org.osgi.framework.namespace.PackageNamespace;
1: import org.osgi.framework.wiring.BundleCapability;
1: import org.osgi.framework.wiring.BundleRequirement;
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.service.repository.Repository;
1: import org.osgi.service.subsystem.Subsystem;
1: import org.osgi.service.subsystem.Subsystem.State;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: import org.osgi.service.subsystem.SubsystemException;
1: 
1: /*
1:  * https://issues.apache.org/jira/browse/ARIES-1383
1:  * 
1:  * Provide option to disable the provisioning of dependencies at install time.
1:  * 
1:  * For tests containing a numerical value in the name, see the description of
1:  * ARIES-1383 for an explanation.
1:  */
1: public class Aries1383Test extends SubsystemTest {
1: 	private static final String SYMBOLICNAME_PREFIX = Aries1383Test.class.getSimpleName() + '.';
1: 	
1: 	private static final String APPLICATION_A = SYMBOLICNAME_PREFIX + "application.a";
1: 	private static final String APPLICATION_B = SYMBOLICNAME_PREFIX + "application.b";
1: 	private static final String APPLICATION_DEPENDENCY_IN_ARCHIVE = SYMBOLICNAME_PREFIX + "application.dependency.in.archive";
1: 	private static final String APPLICATION_EMPTY = SYMBOLICNAME_PREFIX + "application.empty";
1: 	private static final String APPLICATION_INSTALL_FAILED = SYMBOLICNAME_PREFIX + "application.install.failed";
1: 	private static final String APPLICATION_INVALID_PROVISION_DEPENDENCIES = SYMBOLICNAME_PREFIX + "application.invalid.provision.dependency";
1: 	private static final String APPLICATION_MISSING_DEPENDENCY = SYMBOLICNAME_PREFIX + "application.missing.dependency";
1: 	private static final String APPLICATION_PROVISION_DEPENDENCIES_INSTALL = SYMBOLICNAME_PREFIX + "application.provision.dependencies.install";
1: 	private static final String APPLICATION_START_FAILURE = SYMBOLICNAME_PREFIX + "application.start.failure";
1: 	private static final String BUNDLE_A = SYMBOLICNAME_PREFIX + "bundle.a";
1: 	private static final String BUNDLE_B = SYMBOLICNAME_PREFIX + "bundle.b";
1: 	private static final String BUNDLE_C = SYMBOLICNAME_PREFIX + "bundle.c";
1: 	private static final String BUNDLE_D = SYMBOLICNAME_PREFIX + "bundle.d";
1: 	private static final String BUNDLE_INVALID_MANIFEST = SYMBOLICNAME_PREFIX + "bundle.invalid.manifest";
1: 	private static final String BUNDLE_START_FAILURE = SYMBOLICNAME_PREFIX + "bundle.start.failure";
1: 	private static final String ESA_EXTENSION = ".esa";
1: 	private static final String FEATURE_PROVISION_DEPENDENCIES_INSTALL = "feature.provision.dependencies.install";
1: 	private static final String FEATURE_PROVISION_DEPENDENCIES_RESOLVE = "feature.provision.dependencies.resolve";
1: 	private static final String JAR_EXTENSION = ".jar";
1: 	private static final String MANIFEST_VERSION = "1.0";
1: 	private static final String PACKAGE_A = SYMBOLICNAME_PREFIX + "a";
1: 	private static final String PACKAGE_B = SYMBOLICNAME_PREFIX + "b";
1: 	private static final String PACKAGE_C = SYMBOLICNAME_PREFIX + "c";
1: 	private static final String PACKAGE_D = SYMBOLICNAME_PREFIX + "d";
1: 	private static final String SUBSYSTEM_MANIFEST_FILE = "OSGI-INF/SUBSYSTEM.MF";
1: 	
0: 	private final List<Subsystem> stoppableSubsystems = new ArrayList<Subsystem>();
0: 	private final List<Subsystem> uninstallableSubsystems = new ArrayList<Subsystem>();
1: 	
1: 	/*
1: 	 * (1) A set of subsystems with interleaving content dependencies are able 
1: 	 * to be independently, simultaneously, and successfully installed and 
1: 	 * started.
1: 	 */
1: 	@Test
1: 	public void test1() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		final Subsystem c1 = installSubsystem(
1: 				root,
1: 				"c1", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("c1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE + ';' 
1: 										+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(c1);
1: 		c1.start();
1: 		stoppableSubsystems.add(c1);
1: 		@SuppressWarnings("unchecked")
1: 		Callable<Subsystem>[] installCallables = new Callable[] {
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
0: 						return installSubsystem(
1: 								c1,
1: 								"a1", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("a1")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 										.content("b1")
1: 										.bundle(
1: 												"b1", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("b1")
1: 														.importPackage("b2")
1: 														.build())
1: 										.build(),
1: 								false);
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
0: 						return installSubsystem(
1: 								c1,
1: 								"f1", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("f1")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 										.content("b2")
1: 										.bundle(
1: 												"b2", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("b2")
1: 														.exportPackage("b2")
1: 														.importPackage("b3")
1: 														.build())
1: 										.build(),
1: 								false);
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
0: 						return installSubsystem(
1: 								c1,
1: 								"f2", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("f2")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 										.content("b4")
1: 										.bundle(
1: 												"b4", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("b4")
1: 														.exportPackage("b4")
1: 														.importPackage("b2")
1: 														.importPackage("b3")
1: 														.build())
1: 										.build(),
1: 								false);
1: 					}
1: 					
1: 				},
1: 				new Callable<Subsystem>() {
1: 					@Override
1: 					public Subsystem call() throws Exception {
0: 						return installSubsystem(
1: 								c1,
1: 								"c2", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("c2")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE + ';' 
1: 														+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 										.content("b3;version=\"[0,0]\"")
1: 										.exportPackage("b3")
1: 										.importPackage("b4")
1: 										.bundle(
1: 												"b3", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("b3")
1: 														.exportPackage("b3")
1: 														.importPackage("b4")
1: 														.build())
1: 										.build(),
1: 								false);
1: 					}
1: 					
1: 				}
1: 		};
1: 		ExecutorService executor = Executors.newFixedThreadPool(4);
1: 		List<Future<Subsystem>> installFutures = executor.invokeAll(Arrays.asList(installCallables));
1: 		final Subsystem a1 = installFutures.get(0).get();
1: 		uninstallableSubsystems.add(a1);
1: 		assertConstituent(a1, "b1");
1: 		final Subsystem f1 = installFutures.get(1).get();
1: 		uninstallableSubsystems.add(f1);
1: 		assertConstituent(f1, "b2");
1: 		final Subsystem f2 = installFutures.get(2).get();
1: 		uninstallableSubsystems.add(f2);
1: 		assertConstituent(f2, "b4");
1: 		final Subsystem c2 = installFutures.get(3).get();
1: 		uninstallableSubsystems.add(c2);
1: 		assertConstituent(c2, "b3");
1: 		@SuppressWarnings("unchecked")
1: 		Callable<Null>[] startCallables = new Callable[] {
1: 			new Callable<Null>() {
1: 				@Override
1: 				public Null call() throws Exception {
1: 					a1.start();
1: 					assertEvent(a1, State.INSTALLED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					assertEvent(a1, State.RESOLVING, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					assertEvent(a1, State.RESOLVED, subsystemEvents.poll(a1.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Null>() {
1: 				@Override
1: 				public Null call() throws Exception {
1: 					f1.start();
1: 					assertEvent(f1, State.INSTALLED, subsystemEvents.poll(f1.getSubsystemId(), 5000));
1: 					assertEvent(f1, State.RESOLVING, subsystemEvents.poll(f1.getSubsystemId(), 5000));
1: 					assertEvent(f1, State.RESOLVED, subsystemEvents.poll(f1.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Null>() {
1: 				@Override
1: 				public Null call() throws Exception {
1: 					f2.start();
1: 					assertEvent(f2, State.INSTALLED, subsystemEvents.poll(f2.getSubsystemId(), 5000));
1: 					assertEvent(f2, State.RESOLVING, subsystemEvents.poll(f2.getSubsystemId(), 5000));
1: 					assertEvent(f2, State.RESOLVED, subsystemEvents.poll(f2.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			},
1: 			new Callable<Null>() {
1: 				@Override
1: 				public Null call() throws Exception {
1: 					c2.start();
1: 					assertEvent(c2, State.INSTALLED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					assertEvent(c2, State.RESOLVING, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					assertEvent(c2, State.RESOLVED, subsystemEvents.poll(c2.getSubsystemId(), 5000));
1: 					return null;
1: 				}
1: 			}
1: 		};
1: 		List<Future<Null>> startFutures = executor.invokeAll(Arrays.asList(startCallables));
1: 		startFutures.get(0).get();
1: 		stoppableSubsystems.add(a1);
1: 		startFutures.get(1).get();
1: 		stoppableSubsystems.add(f1);
1: 		startFutures.get(2).get();
0: 		stoppableSubsystems.add(f2);
1: 		startFutures.get(3).get();
0: 		stoppableSubsystems.add(c2);
1: 	}
1: 	
1: 	/*
1: 	 * (2) Subsystem with apache-aries-provision-dependencies:=resolve is in the 
1: 	 * INSTALLING state after a successful installation.
1: 	 */
1: 	@Test
1: 	public void test2() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 		try {
1: 			assertState(State.INSTALLING, subsystem);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (3) Subsystem with apache-aries-provision-dependencies:=resolve is available 
1: 	 * as a service after a successful installation.
1: 	 */
1: 	@Test
1: 	public void test3() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 		try {
1: 			assertReferences(
1: 					Subsystem.class, 
1: 					"(&(subsystem.symbolicName=" 
1: 							+ APPLICATION_EMPTY 
1: 							+ ")(subsystem.version=0.0.0)(subsystem.type=" 
1: 							+ SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION 
1: 							+ ")(subsystem.state=" 
1: 							+ State.INSTALLING 
1: 							+ "))",
1: 					1);
1: 			assertReferences(
1: 					AriesSubsystem.class, 
1: 					"(&(subsystem.symbolicName=" 
1: 							+ APPLICATION_EMPTY 
1: 							+ ")(subsystem.version=0.0.0)(subsystem.type=" 
1: 							+ SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION 
1: 							+ ")(subsystem.state=" 
1: 							+ State.INSTALLING 
1: 							+ "))",
1: 					1);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (4) Subsystem with apache-aries-provision-dependencies:=resolve does not 
1: 	 * have its dependencies installed after a successful installation.
1: 	 */
1: 	@Test
1: 	public void test4() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_DEPENDENCY_IN_ARCHIVE, applicationDependencyInArchive(), false);
1: 		try {
1: 			assertConstituent(subsystem, BUNDLE_A);
1: 			assertNotConstituent(subsystem, BUNDLE_B);
1: 			assertNotConstituent(root, BUNDLE_B);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (5) Subsystem with apache-aries-provision-dependencies:=resolve undergoes 
1: 	 * the following state transitions when starting: INSTALLING -> INSTALLED 
1: 	 * -> RESOLVING -> RESOLVED -> STARTING -> ACTIVE.
1: 	 */
1: 	@Test
1: 	public void test5() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		Subsystem subsystem = root.install(
1: 				"application", 
1: 				new SubsystemArchiveBuilder()
1: 						.header(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, "application")
1: 						.header(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 								SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 										+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.build()
1: 		);
1: 		try {
1: 			long id = subsystem.getSubsystemId();
1: 			assertEvent(subsystem, State.INSTALLING, subsystemEvents.poll(id, 5000));
1: 			assertNull(subsystemEvents.poll(id, 1));
1: 			subsystem.start();
1: 			try {
1: 				assertEvent(subsystem, State.INSTALLED, subsystemEvents.poll(id, 5000));
1: 				assertEvent(subsystem, State.RESOLVING, subsystemEvents.poll(id, 5000));
1: 				assertEvent(subsystem, State.RESOLVED, subsystemEvents.poll(id, 5000));
1: 				assertEvent(subsystem, State.STARTING, subsystemEvents.poll(id, 5000));
1: 				assertEvent(subsystem, State.ACTIVE, subsystemEvents.poll(id, 5000));
1: 				assertNull(subsystemEvents.poll(id, 1));
1: 			}
1: 			finally {
1: 				stopSubsystemSilently(subsystem);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (6) Subsystem with apache-aries-provision-dependencies:=resolve has its 
1: 	 * dependencies installed after a successful start.
1: 	 */
1: 	@Test
1: 	public void test6() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = root.install(
1: 				"application", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("application")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 										+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("bundle1")
1: 						.bundle(
1: 								"bundle1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("bundle1")
1: 										.exportPackage("a")
1: 										.importPackage("b")
1: 										.build())
1: 						.bundle(
1: 								"bundle2", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("bundle2")
1: 										.exportPackage("b")
1: 										.build())
1: 						.build()
1: 		);
1: 		try {
1: 			assertNotConstituent(root, "bundle2");
1: 			startSubsystem(subsystem, false);
1: 			try {
1: 				assertConstituent(root, "bundle2");
1: 			}
1: 			finally {
1: 				stopSubsystemSilently(subsystem);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (7) Subsystem with apache-aries-provision-dependencies:=resolve is in the 
1: 	 * INSTALL_FAILED state after an unsuccessful installation.
1: 	 */
1: 	@Test
1: 	public void test7() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		try {
1: 			Subsystem subsystem = root.install(APPLICATION_INSTALL_FAILED, applicationInstallFailed());
1: 			uninstallSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			long id = lastSubsystemId();
1: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALL_FAILED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.UNINSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_INSTALL_FAILED, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.UNINSTALLED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (8) Subsystem with apache-aries-provision-dependencies:=resolve is not 
1: 	 * available as a service after an unsuccessful installation.
1: 	 */
1: 	@Test
1: 	public void test8() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem subsystem = installSubsystem(root, APPLICATION_INSTALL_FAILED, applicationInstallFailed(), false);
1: 			uninstallSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			assertEquals("Subsystem service should not exist", 0,
1: 					bundleContext.getServiceReferences(
1: 							Subsystem.class, 
1: 							"(" + SubsystemConstants.SUBSYSTEM_ID_PROPERTY + "=" + lastSubsystemId() + ")"
1: 					).size());
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (9) Subsystem with apache-aries-provision-dependencies:=resolve is in the 
1: 	 * INSTALLING state when dependencies cannot be provisioned after invoking 
1: 	 * the start method.
1: 	 */
1: 	@Test
1: 	public void test9() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_MISSING_DEPENDENCY, applicationMissingDependency(), false);
1: 		try {
1: 			startSubsystem(subsystem, false);
1: 			stopSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have started");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			assertState(State.INSTALLING, subsystem);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (10) Subsystem fails installation if the apache-aries-provision-dependencies 
1: 	 * directive has a value other than "install" or "resolve".
1: 	 */
1: 	@Test
1: 	public void test10() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem subsystem = installSubsystem(
1: 					root, 
1: 					APPLICATION_INVALID_PROVISION_DEPENDENCIES, 
1: 					applicationInvalidProvisionDependencies(), 
1: 					false);
1: 			uninstallSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (11) Subsystem with apache-aries-provision-dependencies:=resolve undergoes 
1: 	 * the following state transitions when starting fails due to a runtime 
1: 	 * resolution failure: INSTALLING -> INSTALLED -> RESOLVING -> INSTALLED.
1: 	 */
1: 	@Test
1: 	public void test11() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		Subsystem subsystem = root.install(APPLICATION_DEPENDENCY_IN_ARCHIVE, applicationDependencyInArchive());
1: 		ServiceRegistration<ResolverHookFactory> registration = bundleContext.registerService(
1: 				ResolverHookFactory.class, 
1: 				new ResolverHookFactory() {
1: 					@Override
1: 					public ResolverHook begin(Collection<BundleRevision> triggers) {
1: 						return new ResolverHook() {
1: 							@Override
1: 							public void filterResolvable(Collection<BundleRevision> candidates) {
1: 								for (Iterator<BundleRevision> i = candidates.iterator(); i.hasNext();) {
1: 									BundleRevision revision = i.next();
1: 									if (revision.getSymbolicName().equals(BUNDLE_B)) {
1: 										i.remove();
1: 									}
1: 								}
1: 							}
1: 
1: 							@Override
1: 							public void filterSingletonCollisions(
1: 									BundleCapability singleton,
1: 									Collection<BundleCapability> collisionCandidates) {
1: 								// Nothing.
1: 							}
1: 
1: 							@Override
1: 							public void filterMatches(
1: 									BundleRequirement requirement,
1: 									Collection<BundleCapability> candidates) {
1: 								// Nothing.
1: 							}
1: 
1: 							@Override
1: 							public void end() {
1: 								// Nothing.
1: 							}
1: 						};
1: 					}
1: 				}, 
1: 				null
1: 		);
1: 		try {
1: 			subsystem.start();
1: 			stopSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have started");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			long id = lastSubsystemId();
1: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.RESOLVING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_DEPENDENCY_IN_ARCHIVE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 		}
1: 		finally {
1: 			registration.unregister();
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (12) Subsystem with apache-aries-provision-dependencies:=resolve undergoes 
1: 	 * the following state transitions when starting fails due to a start 
1: 	 * failure: INSTALLING -> INSTALLED -> RESOLVING -> RESOLVED -> STARTING -> 
1: 	 * RESOLVED.
1: 	 */
1: 	@Test
1: 	public void test12() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		Subsystem subsystem = root.install(APPLICATION_START_FAILURE, applicationStartFailure());
1: 		try {
1: 			subsystem.start();
1: 			stopSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have started");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			long id = lastSubsystemId();
1: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.RESOLVING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.RESOLVED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.STARTING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertEvent(id, APPLICATION_START_FAILURE, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.RESOLVED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (13) The root subsystem has apache-aries-provision-dependencies:=install.
1: 	 */
1: 	@Test
1: 	public void test13() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Map<String, String> headers = root.getSubsystemHeaders(null);
1: 		String headerStr = headers.get(SubsystemConstants.SUBSYSTEM_TYPE);
1: 		SubsystemTypeHeader header = new SubsystemTypeHeader(headerStr);
1: 		AriesProvisionDependenciesDirective directive = header.getAriesProvisionDependenciesDirective();
1: 		assertEquals(
1: 				"Wrong directive", 
1: 				AriesProvisionDependenciesDirective.INSTALL,
1: 				directive);
1: 	}
1: 	
1: 	/*
1: 	 * (14) Subsystem with explicit apache-aries-provision-dependencies:=install 
1: 	 * works as before.
1: 	 */
1: 	@Test
1: 	public void test14() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_PROVISION_DEPENDENCIES_INSTALL,
1: 				applicationProvisionDependenciesInstall(), true);
1: 		try {
1: 			assertConstituent(subsystem, BUNDLE_A);
1: 			assertConstituent(root, BUNDLE_B);
1: 			startSubsystem(subsystem, true);
1: 			stopSubsystem(subsystem);
1: 		}
1: 		finally {
1: 			uninstallSubsystem(subsystem);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (15) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that is different than the scoped parent fails installation.
1: 	 */
1: 	@Test
1: 	public void test15a() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem subsystem = installSubsystem(root, FEATURE_PROVISION_DEPENDENCIES_RESOLVE,
1: 					featureProvisionDependenciesResolve(), false);
1: 			uninstallSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (15) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that is different than the scoped parent fails installation.
1: 	 */
1: 	@Test
1: 	public void test15b() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem application = installSubsystem(root, APPLICATION_PROVISION_DEPENDENCIES_INSTALL,
1: 				applicationProvisionDependenciesInstall(), true);
1: 		try {
1: 			Subsystem feature = installSubsystem(application, FEATURE_PROVISION_DEPENDENCIES_RESOLVE,
1: 					featureProvisionDependenciesResolve(), false);
1: 			uninstallSubsystemSilently(feature);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(application);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (16) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that is the same as the scoped parent installs successfully.
1: 	 */
1: 	@Test
1: 	public void test16a() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem subsystem = installSubsystem(
1: 					root, 
1: 					FEATURE_PROVISION_DEPENDENCIES_INSTALL,
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("application")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1: 							.build(), 
1: 					true);
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have installed");
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (16) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that is the same as the scoped parent installs successfully.
1: 	 */
1: 	@Test
1: 	public void test16b() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem application = installSubsystem(
1: 				root, 
1: 				"application",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("application")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 								+ AriesProvisionDependenciesDirective.INSTALL.toString())
1: 						.build(), 
1: 				true);
1: 		try {
1: 			Subsystem feature = installSubsystem(
1: 					application, 
1: 					"feature",
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("feature")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1: 							.build(),  
1: 					true);
1: 			uninstallSubsystemSilently(feature);
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have installed");
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(application);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (16) Unscoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that is the same as the scoped parent installs successfully.
1: 	 */
1: 	@Test
1: 	public void test16c() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem subsystem = installSubsystem(
1: 					root, 
1: 					"application",
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("application")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 									+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 							.subsystem(
1: 									"feature", 
1: 									new SubsystemArchiveBuilder()
1: 											.symbolicName("feature")
1: 											.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' 
1: 													+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 											.build())
1: 							.build(), 
1: 					false);
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have installed");
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (17) Scoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that is the same as the scoped parent behaves accordingly.
1: 	 */
1: 	@Test
1: 	public void test17() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		Subsystem parent = root.install(APPLICATION_B, applicationB());
1: 		try {
1: 			long id = parent.getSubsystemId();
1: 			assertEvent(id, APPLICATION_B, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 			assertNotConstituent(root, BUNDLE_B);
1: 			assertConstituent(parent, BUNDLE_A);
1: 			Subsystem child = getChild(parent, APPLICATION_A);
1: 			assertNotNull("Missing child", child);
1: 			id = child.getSubsystemId();
1: 			assertEvent(id, APPLICATION_A, Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 			assertNotConstituent(root, BUNDLE_D);
1: 			assertConstituent(child, BUNDLE_A);
1: 			assertConstituent(child, BUNDLE_C);
1: 			parent.start();
1: 			try {
1: 				id = parent.getSubsystemId();
1: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.STARTING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_B, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 				assertConstituent(root, BUNDLE_B);
1: 				id = child.getSubsystemId();
1: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.STARTING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, APPLICATION_A, Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 				assertConstituent(root, BUNDLE_D);
1: 			}
1: 			finally {
1: 				stopSubsystemSilently(parent);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(parent);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (18) Scoped subsystem with a value of apache-aries-provision-dependencies 
1: 	 * that overrides the scoped parent behaves accordingly.
1: 	 */
1: 	@Test
1: 	public void test18() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		Subsystem parent = root.install(
1: 				"parent", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("parent")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION 
1: 								+ ';' 
1: 								+ AriesProvisionDependenciesDirective.INSTALL.toString()
1: 								+ ';'
1: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 								+ ":="
1: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 						.content("bundle1")
1: 						.bundle(
1: 								"bundle1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("bundle1")
1: 										.importPackage("a")
1: 										.build())
1: 						.bundle(
1: 								"bundle2", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("bundle2")
1: 										.exportPackage("a")
1: 										.build())
1: 				.build()
1: 		);
1: 		try {
1: 			long id = parent.getSubsystemId();
1: 			assertEvent(id, "parent", Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertEvent(id, "parent", Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.MODIFIED);
1: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 			assertConstituent(parent, "bundle2");
1: 			assertConstituent(parent, "bundle1");
1: 			parent.start();
1: 			Subsystem child = parent.install(
1: 					"child", 
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("child")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 									+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 							.content("bundle3")
1: 							.bundle(
1: 									"bundle3", 
1: 									new BundleArchiveBuilder()
1: 											.symbolicName("bundle3")
1: 											.importPackage("b")
1: 											.build())
1: 							.bundle(
1: 									"bundle4", 
1: 									new BundleArchiveBuilder()
1: 											.symbolicName("bundle4")
1: 											.exportPackage("b")
1: 											.build())
1: 							.build()
1: 			);
1: 			id = child.getSubsystemId();
1: 			assertEvent(id, "child", Version.emptyVersion,
1: 					SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 					State.INSTALLING, subsystemEvents.poll(id, 5000),
1: 					ServiceEvent.REGISTERED);
1: 			assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 			assertNotConstituent(parent, "bundle4");
1: 			assertConstituent(child, "bundle3");
1: 			child.start();
1: 			try {
1: 				id = parent.getSubsystemId();
1: 				assertEvent(id, "parent", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "parent", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "parent", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.STARTING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "parent", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 				id = child.getSubsystemId();
1: 				assertEvent(id, "child", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.INSTALLED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "child", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "child", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.RESOLVED, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "child", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.STARTING, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertEvent(id, "child", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, 
1: 						State.ACTIVE, subsystemEvents.poll(id, 5000),
1: 						ServiceEvent.MODIFIED);
1: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 				assertConstituent(parent, "bundle4");
1: 			}
1: 			finally {
1: 				stopSubsystemSilently(parent);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(parent);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (19) Scoped subsystem with only features as parents is able to override 
1: 	 * the value of apache-aries-provision-dependencies.
1: 	 */
1: 	@Test
1: 	public void test19() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		Subsystem feature1 = installSubsystem(
1: 				root,
1: 				"feature1", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("feature1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1: 						.build()
1: 		);
1: 		try {
1: 			Subsystem feature2 = installSubsystem(
1: 					root,
1: 					"feature2", 
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("feature2")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE
1: 									+ ';'
1: 									+ AriesProvisionDependenciesDirective.INSTALL.toString())
1: 							.build()
1: 			);
1: 			try {
1: 				SubsystemArchiveBuilder applicationArchive = new SubsystemArchiveBuilder()
1: 						.symbolicName("application")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1: 								+ ';'
1: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 								+ ":="
1: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 						.content("bundle1")
1: 						.bundle(
1: 								"bundle1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("bundle1")
1: 										.importPackage("a")
1: 										.build())
1: 						.bundle(
1: 								"bundle2",
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("bundle2")
1: 										.exportPackage("a")
1: 										.build());
1: 				Subsystem application1 = feature1.install("application", applicationArchive.build());
1: 				Subsystem application2 = feature2.install("application", applicationArchive.build());
1: 				assertSame("Wrong subsystem", application1, application2);
1: 				assertEquals("Wrong subsystem", application1, application2);
1: 				assertChild(feature1, "application");
1: 				assertChild(feature2, "application");
1: 				long id = application1.getSubsystemId();
1: 				assertEvent(id, "application", Version.emptyVersion,
1: 						SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.INSTALLING, 
1: 						subsystemEvents.poll(id, 5000), ServiceEvent.REGISTERED);
1: 				assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 				assertConstituent(application1, "bundle1");
1: 				assertNotConstituent(application1, "bundle2");
1: 				application1.start();
1: 				try {
1: 					assertEvent(id, "application", Version.emptyVersion,
1: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.INSTALLED, 
1: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1: 					assertEvent(id, "application", Version.emptyVersion,
1: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.RESOLVING, 
1: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1: 					assertEvent(id, "application", Version.emptyVersion,
1: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.RESOLVED, 
1: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1: 					assertEvent(id, "application", Version.emptyVersion,
1: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.STARTING, 
1: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1: 					assertEvent(id, "application", Version.emptyVersion,
1: 							SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION, State.ACTIVE, 
1: 							subsystemEvents.poll(id, 5000), ServiceEvent.MODIFIED);
1: 					assertNull("Unexpected event", subsystemEvents.poll(id, 1));
1: 					assertConstituent(application1, "bundle2");
1: 				}
1: 				finally {
1: 					stopSubsystemSilently(application1);
1: 				}
1: 			}
1: 			finally {
1: 				uninstallSubsystemSilently(feature2);
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(feature1);
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * (20) Install a scoped subsystem, S1, with 
1: 	 * apache-aries-provision-dependencies:=resolve. Install two features, F1 and 
1: 	 * F2, independently as children of S1. F1 has bundle B1 as content. F2 has 
1: 	 * bundle B2 as content. B2 has B1 as a dependency. B1 should be a 
1: 	 * constituent of F1 but not of the root subsystem.
1: 	 */
1: 	@Test
1: 	public void test20() throws Exception {
1: 		serviceRegistrations.add(bundleContext.registerService(
1: 				Repository.class,
1: 				new TestRepository.Builder()
1: 		        		.resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b1")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b1")
1: 		                        		.exportPackage("a")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b2")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b2")
1: 		                        		.importPackage("a")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		        		.build(),
1:                 null));
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem s1 = installSubsystem(
1: 				root,
1: 				"s1",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("s1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(s1);
1: 		startSubsystem(s1, false);
1: 		stoppableSubsystems.add(s1);
1: 		Subsystem f2 = installSubsystem(
1: 				s1,
1: 				"f2",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("f2")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1: 						.content("b2")
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(f2);
1: 		assertChild(s1, "f2", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		assertConstituent(f2, "b2");
1: 		Subsystem f1 = installSubsystem(
1: 				s1,
1: 				"f1",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("f1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1: 						.content("b1")
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(f1);
1: 		assertChild(s1, "f1", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		assertConstituent(f1, "b1");
1: 		assertNotConstituent(root, "b1");
1: 	}
1: 	
1: 	/*
1: 	 * (21) Install a scoped subsystem, S1, with 
1: 	 * apache-aries-provision-dependencies:=resolve. Install two features, F1 and 
1: 	 * F2, independently as children of S1. F1 has bundle B1 and B2 as content. 
1: 	 * F2 has bundle B2 and B3 as content. B2 is shared content. B1 has a 
1: 	 * dependency on bundle B4, B2 has a dependency on bundle B5. B3 has a 
1: 	 * dependency on bundle B6. Start F1. Dependency bundles B4 and B5 should be 
1: 	 * provisioned but not B6.
1: 	 */
1: 	@Test
1: 	public void test21() throws Exception {
1: 		serviceRegistrations.add(bundleContext.registerService(
1: 				Repository.class,
1: 				new TestRepository.Builder()
1: 		        		.resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b1")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .requirement(new TestRequirement.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.directive(
1: 		                        				PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE,
1: 		                        				"(osgi.wiring.package=b4)"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b1")
1: 		                        		.importPackage("b4")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b2")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .requirement(new TestRequirement.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.directive(
1: 		                        				PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE,
1: 		                        				"(osgi.wiring.package=b5)"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b2")
1: 		                        		.importPackage("b5")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b3")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .requirement(new TestRequirement.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.directive(
1: 		                        				PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE,
1: 		                        				"(osgi.wiring.package=b6)"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b3")
1: 		                        		.importPackage("b6")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b4")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .capability(new TestCapability.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				PackageNamespace.PACKAGE_NAMESPACE,
1: 		                        				"b4"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b4")
1: 		                        		.exportPackage("b4")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b5")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .capability(new TestCapability.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				PackageNamespace.PACKAGE_NAMESPACE,
1: 		                        				"b5"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b5")
1: 		                        		.exportPackage("b5")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b6")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .capability(new TestCapability.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				PackageNamespace.PACKAGE_NAMESPACE,
1: 		                        				"b6"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b6")
1: 		                        		.exportPackage("b6")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		        		.build(),
1:                 null));
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem s1 = installSubsystem(
1: 				root,
1: 				"s1",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("s1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString()
1: 								+ ';'
1: 								+ SubsystemConstants.PROVISION_POLICY_DIRECTIVE
1: 								+ ":="
1: 								+ SubsystemConstants.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(s1);
1: 		startSubsystem(s1, false);
1: 		stoppableSubsystems.add(s1);
1: 		Subsystem f2 = installSubsystem(
1: 				s1,
1: 				"f2",
1: 				new SubsystemArchiveBuilder()
1: 				.symbolicName("f2")
1: 				.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1: 				.content("b2,b3")
1: 				.build(),
1: 				false
1: 				);
1: 		uninstallableSubsystems.add(f2);
1: 		assertChild(s1, "f2", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		assertConstituent(s1, "f2", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		assertConstituent(f2, "b2");
1: 		assertConstituent(f2, "b3");
1: 		Subsystem f1 = installSubsystem(
1: 				s1,
1: 				"f1",
1: 				new SubsystemArchiveBuilder()
1: 				.symbolicName("f1")
1: 				.type(SubsystemConstants.SUBSYSTEM_TYPE_FEATURE)
1: 				.content("b1,b2")
1: 				.build(),
1: 				false
1: 				);
1: 		uninstallableSubsystems.add(f1);
1: 		assertChild(s1, "f1", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		assertConstituent(s1, "f1", null, SubsystemConstants.SUBSYSTEM_TYPE_FEATURE);
1: 		assertConstituent(f1, "b1");
1: 		assertConstituent(f1, "b2");
1: 		startSubsystem(f1, false);
1: 		stoppableSubsystems.add(f1);
0: 		assertState(State.RESOLVED, f2);
1: 		assertConstituent(s1, "b4");
1: 		assertConstituent(s1, "b5");
1: 		assertConstituent(s1, "b6");
1: 	}
1: 	
1: 	@Test
1: 	public void testFullLifeCycle() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 		startSubsystem(subsystem, false);
1: 		stopSubsystem(subsystem);
1: 		uninstallSubsystem(subsystem);
1: 	}
1: 	
1: 	@Test
1: 	public void testImplicitlyInstalledChildOverridesProvisionDependencies() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		subsystemEvents.clear();
1: 		try {
1: 			Subsystem subsystem = root.install(
1: 					"parent", 
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("parent")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 									AriesProvisionDependenciesDirective.INSTALL.toString())
1: 							.subsystem(
1: 									"child", 
1: 									new SubsystemArchiveBuilder()
1: 											.symbolicName("child")
1: 											.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 													AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 											.build())
1: 							.build());
1: 			uninstallSubsystemSilently(subsystem);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testInstall() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have installed");
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testInstallChildIntoInstallingParent() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_DEPENDENCY_IN_ARCHIVE, applicationDependencyInArchive(), false);
1: 		try {
1: 			assertState(State.INSTALLING, subsystem);
1: 			installSubsystem(subsystem, APPLICATION_A, applicationA(), false);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testStart() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 		try {
1: 			startSubsystem(subsystem, false);
1: 			stopSubsystemSilently(subsystem);
1: 		}
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have started");
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testStop() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 		try {
1: 			startSubsystem(subsystem, false);
1: 			try {
1: 				stopSubsystem(subsystem);
1: 			}
1: 			catch (Exception e) {
1: 				e.printStackTrace();
1: 				fail("Subsystem should have stopped");
1: 			}
1: 		}
1: 		finally {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testUninstall() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem subsystem = installSubsystem(root, APPLICATION_EMPTY, applicationEmpty(), false);
1: 		try {
1: 			uninstallSubsystem(subsystem);
1: 		}
1: 		catch (Exception e) {
1: 			e.printStackTrace();
1: 			fail("Subsystem should have uninstalled");
1: 		}
1: 	}
1: 	
1: 	private InputStream applicationA() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_A);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ',' + BUNDLE_C);
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1: 				.add(BUNDLE_C + JAR_EXTENSION, bundleC())
1: 				.add(BUNDLE_D + JAR_EXTENSION, bundleD())
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationB() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_B);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A + ',' + APPLICATION_A + ";type=osgi.subsystem.application");
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1: 				.add(APPLICATION_A + ESA_EXTENSION, applicationA())
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationDependencyInArchive() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_DEPENDENCY_IN_ARCHIVE);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationEmpty() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), MANIFEST_VERSION);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_EMPTY);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationInstallFailed() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), MANIFEST_VERSION);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_INSTALL_FAILED);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_INVALID_MANIFEST + JAR_EXTENSION, bundleInvalidManifest())
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationInvalidProvisionDependencies() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_INVALID_PROVISION_DEPENDENCIES);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.NAME + ":=foo");
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationMissingDependency() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_MISSING_DEPENDENCY);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationProvisionDependenciesInstall() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_PROVISION_DEPENDENCIES_INSTALL);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.INSTALL.toString());
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_A);
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_A + JAR_EXTENSION, bundleA())
1: 				.add(BUNDLE_B + JAR_EXTENSION, bundleB())
1: 				.build();
1: 	}
1: 	
1: 	private InputStream applicationStartFailure() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, APPLICATION_START_FAILURE);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_CONTENT, BUNDLE_START_FAILURE);
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.add(BUNDLE_START_FAILURE + JAR_EXTENSION, bundleStartFailure())
1: 				.build();
1: 	}
1: 	
1: 	private void assertReferences(Class<?> clazz, String filter, int expected) throws Exception {
1: 		ServiceReference<?>[] references = bundleContext.getAllServiceReferences(clazz.getName(), filter);
1: 		if (expected < 1) {
1: 			assertNull("References exist", references);
1: 		}
1: 		else {
1: 			assertNotNull("No references", references);
1: 			assertEquals("No references or more than one", expected, references.length);
1: 		}
1: 	}
1: 
1: 	private InputStream bundleA() {
1: 		return TinyBundles
1: 				.bundle()
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_A)
1: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_A)
1: 				.set(Constants.IMPORT_PACKAGE, PACKAGE_B)
1: 				.build();
1: 	}
1: 	
1: 	private InputStream bundleB() {
1: 		return TinyBundles
1: 				.bundle()
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_B)
1: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_B)
1: 				.build();
1: 	}
1: 	
1: 	private InputStream bundleC() {
1: 		return TinyBundles
1: 				.bundle()
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_C)
1: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_C)
1: 				.set(Constants.IMPORT_PACKAGE, PACKAGE_B)
1: 				.set(Constants.IMPORT_PACKAGE, PACKAGE_D)
1: 				.build();
1: 	}
1: 	
1: 	private InputStream bundleD() {
1: 		return TinyBundles
1: 				.bundle()
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_D)
1: 				.set(Constants.EXPORT_PACKAGE, PACKAGE_D)
1: 				.build();
1: 	}
1: 	
1: 	private InputStream bundleInvalidManifest() {
1: 		return TinyBundles
1: 				.bundle()
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_INVALID_MANIFEST)
1: 				.set(Constants.PROVIDE_CAPABILITY, "osgi.ee;osgi.ee=J2SE-1.4")
1: 				.build();
1: 	}
1: 	
1: 	private InputStream bundleStartFailure() {
1: 		return TinyBundles
1: 				.bundle()
1: 				.set(Constants.BUNDLE_SYMBOLICNAME, BUNDLE_START_FAILURE)
1: 				.set(Constants.BUNDLE_ACTIVATOR, BundleStartFailureActivator.class.getName())
1: 				.add(BundleStartFailureActivator.class, InnerClassStrategy.NONE)
1: 				.build();
1: 	}
1: 	
1: 	private InputStream featureProvisionDependenciesResolve() throws Exception {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		attributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, FEATURE_PROVISION_DEPENDENCIES_RESOLVE);
1: 		attributes.putValue(SubsystemConstants.SUBSYSTEM_TYPE, 
1: 				SubsystemConstants.SUBSYSTEM_TYPE_FEATURE + ';' +
1: 				AriesProvisionDependenciesDirective.RESOLVE.toString());
1: 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
1: 		manifest.write(baos);
1: 		baos.close();
1: 		return TinyBundles
1: 				.bundle()
1: 				.add(SUBSYSTEM_MANIFEST_FILE, new ByteArrayInputStream(baos.toByteArray()))
1: 				.build();
1: 	}
1: 	
1: 	private static class BundleStartFailureActivator implements BundleActivator {
1: 		@Override
1: 		public void start(BundleContext context) throws Exception {
1: 			throw new IllegalStateException();
1: 		}
1: 
1: 		@Override
1: 		public void stop(BundleContext context) throws Exception {
1: 			// Nothing.
1: 		}
1: 	}
1: 	
1: 	@Override
0:     public void setUp() throws Exception {
0:         super.setUp();
0:         stoppableSubsystems.clear();
0:         uninstallableSubsystems.clear();
1:     }
1: 	
1: 	@Override
0:     public void tearDown() throws Exception {
0: 		for (Subsystem subsystem : stoppableSubsystems) {
1: 			stopSubsystemSilently(subsystem);
1: 		}
0: 		for (Subsystem subsystem : uninstallableSubsystems) {
1: 			uninstallSubsystemSilently(subsystem);
1: 		}
0:         super.tearDown();
1:     }
1: 	
1: 	@Test
1: 	public void testInterleavingContentDependencies() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem c1 = installSubsystem(
1: 				root,
1: 				"c1",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("c1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("c1b1;version=\"[0,0]\"")
1: 						.exportPackage("c1b1")
1: 						.importPackage("c2b1")
1: 						.bundle(
1: 								"c1b1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("c1b1")
1: 										.exportPackage("c1b1")
1: 										.importPackage("c2b1")
1: 										.build())
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(c1);
1: 		Subsystem c2 = installSubsystem(
1: 				root,
1: 				"c2",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("c2")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("c2b1;version=\"[0,0]\"")
1: 						.exportPackage("c2b1")
1: 						.importPackage("c1b1")
1: 						.bundle(
1: 								"c2b1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("c2b1")
1: 										.exportPackage("c2b1")
1: 										.importPackage("c1b1")
1: 										.build())
1: 						.build(),
1: 				false
1: 		);
1: 		uninstallableSubsystems.add(c2);
1: 		startSubsystem(c1, false);
1: 		stoppableSubsystems.add(c1);
1: 		assertState(EnumSet.of(State.RESOLVED, State.ACTIVE), c2);
1: 	}
1: 	
1: 	@Test
1: 	public void testRestart2() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem c1 = installSubsystem(
1: 				root,
1: 				"c1",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("c1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("c1b1;version=\"[0,0]\"")
1: 						.exportPackage("c1b1")
1: 						.importPackage("c2b1")
1: 						.bundle(
1: 								"c1b1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("c1b1")
1: 										.exportPackage("c1b1")
1: 										.importPackage("c2b1")
1: 										.build())
1: 						.build(),
1: 				false
1: 		);
1: 		Subsystem c2 = installSubsystem(
1: 				root,
1: 				"c2",
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("c2")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1: 								+ ';'
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("c2b1;version=\"[0,0]\"")
1: 						.exportPackage("c2b1")
1: 						.importPackage("c1b1")
1: 						.bundle(
1: 								"c2b1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("c2b1")
1: 										.exportPackage("c2b1")
1: 										.importPackage("c1b1")
1: 										.build())
1: 						.build(),
1: 				false
1: 		);
1: 		assertChild(root, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		assertChild(root, "c2", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		restartSubsystemsImplBundle();
1: 		root = getRootSubsystem();
1: 		c1 = getChild(root, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		assertNotNull("Missing child", c1);
1: 		uninstallableSubsystems.add(c1);
1: 		c2 = getChild(root, "c2", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		assertNotNull("Missing child", c2);
1: 		uninstallableSubsystems.add(c2);
1: 		startSubsystem(c1, false);
1: 		stoppableSubsystems.add(c1);
1: 		try {
1: 			assertState(EnumSet.of(State.RESOLVED, State.ACTIVE), c2);
1: 		}
1: 		catch (AssertionError e) {
1: 			System.out.println(c2.getState());
1: 		}
1: 	}
1: 	
1: 	@Test
1: 	public void testRestart() throws Exception {
1: 		Subsystem root = getRootSubsystem();
1: 		Subsystem a1 = installSubsystem(
1: 				root,
1: 				"a1", 
1: 				new SubsystemArchiveBuilder()
1: 						.symbolicName("a1")
1: 						.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION + ';' 
1: 								+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 						.content("b1,c1;type=osgi.subsystem.composite")
1: 						.bundle(
1: 								"b1", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("b1")
1: 										.importPackage("b2")
1: 										.build())
1: 						.bundle(
1: 								"b2", 
1: 								new BundleArchiveBuilder()
1: 										.symbolicName("b2")
1: 										.exportPackage("b2")
1: 										.build())
1: 						.subsystem(
1: 								"c1", 
1: 								new SubsystemArchiveBuilder()
1: 										.symbolicName("c1")
1: 										.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE
1: 												+ ';'
1: 												+ AriesProvisionDependenciesDirective.RESOLVE.toString())
1: 										.content("b1;version=\"[0,0]\"")
1: 										.importPackage("b2")
1: 										.bundle(
1: 												"b1", 
1: 												new BundleArchiveBuilder()
1: 														.symbolicName("b1")
1: 														.importPackage("b2")
1: 														.build())
1: 								.build())
1: 						.build(),
1: 				false);
1: 		uninstallableSubsystems.add(a1);
1: 		assertChild(root, "a1");
1: 		assertState(State.INSTALLING, a1);
1: 		Subsystem c1 = getChild(a1, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		assertNotNull("Missing child", c1);
1: 		assertState(State.INSTALLING, c1);
1: 
1: 		restartSubsystemsImplBundle();
1: 		root = getRootSubsystem();
1: 		
1: 		a1 = getChild(root, "a1");
1: 		assertNotNull("Missing child", a1);
1: 		uninstallableSubsystems.add(a1);
1: 		assertState(State.INSTALLING, a1);
1: 		assertConstituent(a1, "b1");
1: 		assertNotConstituent(root, "b2");
1: 		
1: 		c1 = getChild(a1, "c1", null, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
1: 		assertNotNull("Missing child", c1);
1: 		uninstallableSubsystems.add(c1);
1: 		assertConstituent(c1, "b1");
1: 		
1: 		startSubsystem(c1, false);
1: 		stoppableSubsystems.add(c1);
1: 		
1: 		assertState(State.INSTALLED, a1);
1: 		stoppableSubsystems.add(a1);
1: 		
1: 		assertConstituent(root, "b2");
1: 	}
1: 	
1: 	@Test
1: 	public void test4e3bCompliance() throws Exception {
1: 		serviceRegistrations.add(bundleContext.registerService(
1: 				Repository.class,
1: 				new TestRepository.Builder()
1: 		        		.resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"a")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .capability(new TestCapability.Builder()
1: 		                        		.namespace(PackageNamespace.PACKAGE_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				PackageNamespace.PACKAGE_NAMESPACE, 
1: 		                        				"x")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion))
1: 		                        .capability(new TestCapability.Builder()
1: 		                        		.namespace(BundleNamespace.BUNDLE_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				BundleNamespace.BUNDLE_NAMESPACE, 
1: 		                        				"a")
1: 		                        		.attribute(
1: 		                        				BundleNamespace.CAPABILITY_BUNDLE_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("a")
1: 		                        		.exportPackage("x")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		                .resource(new TestRepositoryContent.Builder()
1: 		                		.capability(new TestCapability.Builder()
1: 		                        		.namespace(IdentityNamespace.IDENTITY_NAMESPACE)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.IDENTITY_NAMESPACE, 
1: 		                        				"b")
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE, 
1: 		                        				Version.emptyVersion)
1: 		                        		.attribute(
1: 		                        				IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE,
1: 		                        				IdentityNamespace.TYPE_BUNDLE))
1: 		                        .capability(new TestCapability.Builder()
1: 		                        		.namespace("y"))
1: 		                        .content(new BundleArchiveBuilder()
1: 		                        		.symbolicName("b")
1: 		                        		.header("Provide-Capability", "y")
1: 		                        		.buildAsBytes())
1: 		                        .build())
1: 		        		.build(),
1:                 null));
1: 		Subsystem root = getRootSubsystem();
1: 		try {
1: 			Subsystem s1 = installSubsystem(
1: 					root,
1: 					"s1",
1: 					new SubsystemArchiveBuilder()
1: 							.symbolicName("s1")
1: 							.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 							.subsystem(
1: 									"s3",
1: 									new SubsystemArchiveBuilder()
1: 											.symbolicName("s3")
1: 											.type(SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE)
1: 											.subsystem(
1: 													"s2", 
1: 													new SubsystemArchiveBuilder()
1: 															.symbolicName("s2")
1: 															.type(SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION)
1: 															.bundle(
1: 																	"c", 
1: 																	new BundleArchiveBuilder()
1: 																			.symbolicName("c")
1: 																			.importPackage("x")
1: 																			.build())
1: 															.bundle(
1: 																	"d", 
1: 																	new BundleArchiveBuilder()
1: 																			.symbolicName("d")
1: 																			.header("Require-Bundle", "a")
1: 																			.build())
1: 															.bundle(
1: 																	"e", 
1: 																	new BundleArchiveBuilder()
1: 																			.symbolicName("e")
1: 																			.header("Require-Capability", "y")
1: 																			.build())
1: 															.build())
1: 											.build())
1: 							.build(),
1: 					true);
1: 			uninstallableSubsystems.add(s1);
1: 			fail("Subsystem should not have installed");
1: 		}
1: 		catch (SubsystemException e) {
1: 			e.printStackTrace();
1: 		}
1: 	}
1: }
============================================================================