1:f13c6ac: /**
1:f13c6ac:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:f13c6ac:  *  contributor license agreements.  See the NOTICE file distributed with
1:f13c6ac:  *  this work for additional information regarding copyright ownership.
1:f13c6ac:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:f13c6ac:  *  (the "License"); you may not use this file except in compliance with
1:f13c6ac:  *  the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *     http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  *  Unless required by applicable law or agreed to in writing, software
1:f13c6ac:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:f13c6ac:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f13c6ac:  *  See the License for the specific language governing permissions and
1:f13c6ac:  *  limitations under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint;
2:f13c6ac: 
1:f13c6ac: import java.net.URL;
1:3b2c33b: import java.util.Set;
1:f13c6ac: 
1:f13c6ac: import org.w3c.dom.Element;
1:f13c6ac: import org.w3c.dom.Node;
1:f13c6ac: 
1:f13c6ac: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: 
1:5dbb0fc: /**
1:5dbb0fc:  * A processor for custom blueprint extensions
1:5dbb0fc:  * 
1:5dbb0fc:  * Namespace handlers must be registered in the OSGi service registry with the 
1:5dbb0fc:  * <code>osgi.service.blueprint.namespace</code> service property denoting the namespace URIs this
1:5dbb0fc:  * handler can process. The service property value can be either a single <code>String</code> or <code>URI</code>, 
1:5dbb0fc:  * or a <code>Collection</code> respectively array of <code>String</code> or <code>URI</code>.
1:5dbb0fc:  * 
1:5dbb0fc:  * During parsing when the blueprint extender encounters an element from a non-blueprint namespace it will search
1:5dbb0fc:  * for a namespace handler for the namespace that is compatible with blueprint bundle being processed. Then
1:5dbb0fc:  * for a stand-alone component the parser will invoke the <code>parse</code> method 
1:5dbb0fc:  * to create the <code>Metadata</code> for the xml element while for an element that is part
1:5dbb0fc:  * of an existing component the parser will invoke the <code>decorated</code> method to augment
1:5dbb0fc:  * the enclosing <code>ComponentMetadata</code> instance.  Various utilities to interact with 
1:5dbb0fc:  * the blueprint parser are available to a namespace handler via the <code>ParserContext</code> argument 
1:5dbb0fc:  * passed to <code>parse</code> and <code>decorate</code>.
1:5dbb0fc:  * 
1:5dbb0fc:  * Recommended behaviour:
1:5dbb0fc:  * <ul>
1:5dbb0fc:  * <li>New metadata objects should be created via calling <code>ParserContext.createMetadata(..)</code> and
1:5dbb0fc:  * casting the returned object to the appropriate <code>MutableComponentMetadata</code> interface. 
1:5dbb0fc:  * This method ensures that the metadata object implements the interfaces necessary for other namespace handlers
1:baa10f5:  * to be able to use the metadata object.<br>
1:5dbb0fc:  * Also, to prevent id clashes, component ids should be generated by calling <code>ParserContext.generateId()</code>.
1:5dbb0fc:  * </li>
1:5dbb0fc:  * <li>A namespace handler should not return new metadata instances from the <code>decorate</code> method if 
1:5dbb0fc:  * the same result could also be achieved by operating on a <code>MutableComponentMetadata</code> instance.
1:5dbb0fc:  * </li>
1:85ec6f7:  * <li>A namespace handler should not assume the existence of predefined entries in the component definition
1:85ec6f7:  * registry such as <code>blueprintBundle</code> or <code>blueprintBundleContext</code>. In the case of a dry
1:85ec6f7:  * parse (i.e. a parse of the blueprint xml files without a backing OSGi bundle), these values will not be 
1:85ec6f7:  * available
1:85ec6f7:  * </li>
1:5dbb0fc:  * </ul>
1:5dbb0fc:  */
1:f13c6ac: public interface NamespaceHandler  {
1:85ec6f7:     /**
1:85ec6f7:      * Retrieve a URL from where the schema for a given namespace can be retrieved
1:85ec6f7:      * @param namespace The schema's namespace
1:85ec6f7:      * @return A URL that points to the location of the schema or null if the namespace validation
1:85ec6f7:      * is not needed
1:85ec6f7:      */
1:f13c6ac:     URL getSchemaLocation(String namespace);
1:3b2c33b: 
1:5dbb0fc:     /**
1:5dbb0fc:      * Specify a set of classes that must be consistent between a blueprint bundle and this namespace handler
1:5dbb0fc:      * 
1:5dbb0fc:      * The blueprint extender will not invoke a namespace handler if any of the managed classes are inconsistent
1:5dbb0fc:      * with the class space of the blueprint bundle (i.e. if the blueprint bundle loads any of the managed classes
1:5dbb0fc:      * from a different classloader).
1:5dbb0fc:      * 
1:5dbb0fc:      * @return a <code>Set</code> of classes that must be compatible with any blueprint bundle for which this namespace 
1:5dbb0fc:      * handler is to apply or <code>null</code> if no compatibility checks are to be performed
1:5dbb0fc:      */
1:3b2c33b:     Set<Class> getManagedClasses();
1:f13c6ac:     
1:85ec6f7:     /**
1:85ec6f7:      * Parse a stand-alone blueprint component 
1:85ec6f7:      *
1:85ec6f7:      * Given an <code>Element</code> node as a root, this method parses the stand-alone component and returns its
1:85ec6f7:      * metadata. The supplied <code>ParserContext</code> should be used to parse embedded blueprint elements as well
1:85ec6f7:      * as creating metadata.
1:85ec6f7:      * 
1:85ec6f7:      * @param element The DOM element representing the custom component
1:85ec6f7:      * @param context The <code>ParserContext</code> for parsing sub-components and creating metadata objects
1:85ec6f7:      * @return A metadata instance representing the custom component. This should be an instance of an appropriate
1:85ec6f7:      * <code>MutableMetadata</code> type to enable further decoration by other namespace handlers
1:85ec6f7:      */
1:f13c6ac:     Metadata parse(Element element, ParserContext context);
1:f13c6ac:     
1:bd69f44:     /**
1:bd69f44:      * Process a child node of an enclosing blueprint component. 
1:bd69f44:      * 
1:5dbb0fc:      * If the decorator method returns a new <code>ComponentMetadata</code> instance, this will replace the argument 
1:5dbb0fc:      * <code>ComponentMetadata</code> in subsequent parsing and namespace handler invocations. A namespace
1:5dbb0fc:      * handler that elects to return a new <code>ComponentMetadata</code> instance should
1:bd69f44:      * ensure that existing interceptors are registered against the new instance if appropriate.
1:bd69f44:      * 
1:5dbb0fc:      * Due to the interaction with interceptors, a namespace handler should prefer to change a component metadata
1:5dbb0fc:      * instead of returning a new instance wherever possible. This can be achieved by casting a 
1:5dbb0fc:      * <code>ComponentMetadata</code> to its corresponding <code>MutabableComponentMetadata</code> instance.
1:5dbb0fc:      * Note however that a given <code>ComponentMetadata</code> instance cannot be guaranteed to implement
1:5dbb0fc:      * the mutable interface if it was constructed by an agent other than the blueprint extender.
1:5dbb0fc:      * 
1:bd69f44:      * @param node The node associated with this NamespaceHandler that should be used to decorate the enclosing 
1:bd69f44:      * component
1:bd69f44:      * @param component The enclosing blueprint component
1:bd69f44:      * @param context The parser context
1:bd69f44:      * @return The decorated component to be used instead of the original enclosing component. This can of course be
1:bd69f44:      * the original component.
1:bd69f44:      */
1:f13c6ac:     ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context);
1:f13c6ac:              
1:f13c6ac: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:baa10f5
/////////////////////////////////////////////////////////////////////////
1:  * to be able to use the metadata object.<br>
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
commit:85ec6f7
/////////////////////////////////////////////////////////////////////////
1:  * <li>A namespace handler should not assume the existence of predefined entries in the component definition
1:  * registry such as <code>blueprintBundle</code> or <code>blueprintBundleContext</code>. In the case of a dry
1:  * parse (i.e. a parse of the blueprint xml files without a backing OSGi bundle), these values will not be 
1:  * available
1:  * </li>
1:     /**
1:      * Retrieve a URL from where the schema for a given namespace can be retrieved
1:      * @param namespace The schema's namespace
1:      * @return A URL that points to the location of the schema or null if the namespace validation
1:      * is not needed
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Parse a stand-alone blueprint component 
1:      *
1:      * Given an <code>Element</code> node as a root, this method parses the stand-alone component and returns its
1:      * metadata. The supplied <code>ParserContext</code> should be used to parse embedded blueprint elements as well
1:      * as creating metadata.
1:      * 
1:      * @param element The DOM element representing the custom component
1:      * @param context The <code>ParserContext</code> for parsing sub-components and creating metadata objects
1:      * @return A metadata instance representing the custom component. This should be an instance of an appropriate
1:      * <code>MutableMetadata</code> type to enable further decoration by other namespace handlers
1:      */
commit:5dbb0fc
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * A processor for custom blueprint extensions
1:  * 
1:  * Namespace handlers must be registered in the OSGi service registry with the 
1:  * <code>osgi.service.blueprint.namespace</code> service property denoting the namespace URIs this
1:  * handler can process. The service property value can be either a single <code>String</code> or <code>URI</code>, 
1:  * or a <code>Collection</code> respectively array of <code>String</code> or <code>URI</code>.
1:  * 
1:  * During parsing when the blueprint extender encounters an element from a non-blueprint namespace it will search
1:  * for a namespace handler for the namespace that is compatible with blueprint bundle being processed. Then
1:  * for a stand-alone component the parser will invoke the <code>parse</code> method 
1:  * to create the <code>Metadata</code> for the xml element while for an element that is part
1:  * of an existing component the parser will invoke the <code>decorated</code> method to augment
1:  * the enclosing <code>ComponentMetadata</code> instance.  Various utilities to interact with 
1:  * the blueprint parser are available to a namespace handler via the <code>ParserContext</code> argument 
1:  * passed to <code>parse</code> and <code>decorate</code>.
1:  * 
1:  * Recommended behaviour:
1:  * <ul>
1:  * <li>New metadata objects should be created via calling <code>ParserContext.createMetadata(..)</code> and
1:  * casting the returned object to the appropriate <code>MutableComponentMetadata</code> interface. 
1:  * This method ensures that the metadata object implements the interfaces necessary for other namespace handlers
0:  * to be able to use the metadata object.<br/>
1:  * Also, to prevent id clashes, component ids should be generated by calling <code>ParserContext.generateId()</code>.
1:  * </li>
1:  * <li>A namespace handler should not return new metadata instances from the <code>decorate</code> method if 
1:  * the same result could also be achieved by operating on a <code>MutableComponentMetadata</code> instance.
1:  * </li>
1:  * </ul>
1:  */
1:     /**
1:      * Specify a set of classes that must be consistent between a blueprint bundle and this namespace handler
1:      * 
1:      * The blueprint extender will not invoke a namespace handler if any of the managed classes are inconsistent
1:      * with the class space of the blueprint bundle (i.e. if the blueprint bundle loads any of the managed classes
1:      * from a different classloader).
1:      * 
1:      * @return a <code>Set</code> of classes that must be compatible with any blueprint bundle for which this namespace 
1:      * handler is to apply or <code>null</code> if no compatibility checks are to be performed
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * If the decorator method returns a new <code>ComponentMetadata</code> instance, this will replace the argument 
1:      * <code>ComponentMetadata</code> in subsequent parsing and namespace handler invocations. A namespace
1:      * handler that elects to return a new <code>ComponentMetadata</code> instance should
1:      * Due to the interaction with interceptors, a namespace handler should prefer to change a component metadata
1:      * instead of returning a new instance wherever possible. This can be achieved by casting a 
1:      * <code>ComponentMetadata</code> to its corresponding <code>MutabableComponentMetadata</code> instance.
1:      * Note however that a given <code>ComponentMetadata</code> instance cannot be guaranteed to implement
1:      * the mutable interface if it was constructed by an agent other than the blueprint extender.
1:      * 
commit:bd69f44
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Process a child node of an enclosing blueprint component. 
1:      * 
0:      * If the decorator returns a new ComponentMetadata instance, then this namespace handler must 
1:      * ensure that existing interceptors are registered against the new instance if appropriate.
1:      * 
1:      * @param node The node associated with this NamespaceHandler that should be used to decorate the enclosing 
1:      * component
1:      * @param component The enclosing blueprint component
1:      * @param context The parser context
1:      * @return The decorated component to be used instead of the original enclosing component. This can of course be
1:      * the original component.
1:      */
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: 
1:     Set<Class> getManagedClasses();
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
0: package org.apache.geronimo.blueprint;
1: 
1: import java.net.URL;
1: 
1: import org.w3c.dom.Element;
1: import org.w3c.dom.Node;
1: 
1: import org.osgi.service.blueprint.reflect.ComponentMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: 
1: public interface NamespaceHandler  {
1:     
1:     URL getSchemaLocation(String namespace);
1:     
1:     Metadata parse(Element element, ParserContext context);
1:     
1:     ComponentMetadata decorate(Node node, ComponentMetadata component, ParserContext context);
1:              
1: }
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint;
============================================================================