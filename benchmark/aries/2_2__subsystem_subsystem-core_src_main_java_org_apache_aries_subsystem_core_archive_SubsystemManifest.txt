1:a14f2fd: /*
1:a14f2fd:  * Licensed under the Apache License, Version 2.0 (the "License");
1:a14f2fd:  * you may not use this file except in compliance with the License.
1:a14f2fd:  * You may obtain a copy of the License at
1:a14f2fd:  *
1:a14f2fd:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a14f2fd:  *
1:a14f2fd:  * Unless required by applicable law or agreed to in writing, software
1:a14f2fd:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a14f2fd:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a14f2fd:  * See the License for the specific language governing permissions and
1:a14f2fd:  * limitations under the License.
1:a14f2fd:  */
1:1129914: package org.apache.aries.subsystem.core.archive;
1:1c9c28b: 
1:1129914: import java.io.File;
1:bda6868: import java.io.FileInputStream;
1:bda6868: import java.io.FileNotFoundException;
1:1129914: import java.io.IOException;
1:777b216: import java.io.InputStream;
1:bda6868: import java.io.OutputStream;
1:df175a6: import java.util.ArrayList;
1:1129914: import java.util.Collection;
1:1c9c28b: import java.util.Collections;
1:bda6868: import java.util.HashMap;
1:2ffcfb9: import java.util.Iterator;
1:df175a6: import java.util.List;
1:bda6868: import java.util.Map;
1:bda6868: import java.util.Map.Entry;
1:bda6868: import java.util.jar.Attributes;
1:bda6868: import java.util.jar.Manifest;
5:1129914: 
1:35094c6: import org.apache.aries.subsystem.core.internal.OsgiIdentityCapability;
1:bda6868: import org.apache.aries.util.manifest.ManifestProcessor;
1:bda6868: import org.osgi.framework.Constants;
1:1129914: import org.osgi.framework.Version;
1:df175a6: import org.osgi.resource.Capability;
1:df175a6: import org.osgi.resource.Requirement;
1:71fe81a: import org.osgi.resource.Resource;
1:bda6868: import org.osgi.service.subsystem.SubsystemConstants;
1:875a6d6: 
1:bda6868: public class SubsystemManifest {
1:875a6d6: 	public static class Builder {
1:875a6d6: 		private Map<String, Header<?>> headers = new HashMap<String, Header<?>>();
1:875a6d6: 		
1:875a6d6: 		public SubsystemManifest build() {
1:875a6d6: 			return new SubsystemManifest(headers);
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder content(String value) {
1:875a6d6: 			return value == null ? this : content(new SubsystemContentHeader(value));
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder content(Collection<Resource> value) {
1:547a8ce: 			return value == null || value.isEmpty() ? this : content(SubsystemContentHeader.newInstance(value));
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder content(SubsystemContentHeader value) {
1:875a6d6: 			return header(value);
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder header(Header<?> value) {
1:875a6d6: 			if (value != null)
1:875a6d6: 				headers.put(value.getName(), value);
1:875a6d6: 			return this;
1:875a6d6: 		}
1:875a6d6: 		
1:35094c6: 		public Builder manifest(SubsystemManifest value) {
1:35094c6: 			for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
1:35094c6: 				header(entry.getValue());
1:35094c6: 			return this;
1:35094c6: 		}
1:35094c6: 		
1:35094c6: 		public Builder symbolicName(String value) {
1:35094c6: 			return value == null ? this : symbolicName(new SubsystemSymbolicNameHeader(value));
1:35094c6: 		}
1:35094c6: 		
1:35094c6: 		public Builder symbolicName(SubsystemSymbolicNameHeader value) {
1:35094c6: 			return header(value);
1:35094c6: 		}
1:35094c6: 		
1:875a6d6: 		public Builder type(String value) {
1:875a6d6: 			return value == null ? this : type(new SubsystemTypeHeader(value));
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder type(SubsystemTypeHeader value) {
1:875a6d6: 			return header(value);
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder version(String value) {
1:875a6d6: 			return value == null ? this : version(Version.parseVersion(value));
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder version(Version value) {
1:875a6d6: 			return value == null ? this : version(new SubsystemVersionHeader(value));
1:875a6d6: 		}
1:875a6d6: 		
1:875a6d6: 		public Builder version(SubsystemVersionHeader value) {
1:875a6d6: 			return header(value);
1:875a6d6: 		}
1:875a6d6: 	}
1:875a6d6: 	
1:bda6868: 	public static final String EXPORT_PACKAGE = Constants.EXPORT_PACKAGE;
1:bda6868: 	public static final String IMPORT_PACKAGE = Constants.IMPORT_PACKAGE;
1:bda6868: 	public static final String PREFERRED_PROVIDER = SubsystemConstants.PREFERRED_PROVIDER;
1:bda6868: 	public static final String PROVIDE_CAPABILITY = Constants.PROVIDE_CAPABILITY;
1:bda6868: 	public static final String REQUIRE_BUNDLE = Constants.REQUIRE_BUNDLE;
1:bda6868: 	public static final String REQUIRE_CAPABILITY = Constants.REQUIRE_CAPABILITY;
1:bda6868: 	public static final String SUBSYSTEM_CONTENT = SubsystemConstants.SUBSYSTEM_CONTENT;
1:bda6868: 	public static final String SUBSYSTEM_DESCRIPTION = SubsystemConstants.SUBSYSTEM_DESCRIPTION;
1:bda6868: 	public static final String SUBSYSTEM_EXPORTSERVICE = SubsystemConstants.SUBSYSTEM_EXPORTSERVICE;
1:bda6868: 	public static final String SUBSYSTEM_IMPORTSERVICE = SubsystemConstants.SUBSYSTEM_IMPORTSERVICE;
1:d6eb080: 	public static final String SUBSYTEM_LOCALIZATION = SubsystemConstants.SUBSYSTEM_LOCALIZATION;
1:bda6868: 	public static final String SUBSYSTEM_MANIFESTVERSION = SubsystemConstants.SUBSYSTEM_MANIFESTVERSION;
1:bda6868: 	public static final String SUBSYSTEM_NAME = SubsystemConstants.SUBSYSTEM_NAME;
1:bda6868: 	public static final String SUBSYSTEM_SYMBOLICNAME = SubsystemConstants.SUBSYSTEM_SYMBOLICNAME;
1:bda6868: 	public static final String SUBSYSTEM_TYPE = SubsystemConstants.SUBSYSTEM_TYPE;
1:bda6868: 	public static final String SUBSYSTEM_VERSION = SubsystemConstants.SUBSYSTEM_VERSION;
1:1c9c28b: 	
1:35094c6: 	private static Map<String, Header<?>> parseHeaders(java.util.jar.Manifest manifest) {
1:35094c6: 		Map<String, Header<?>> result = new HashMap<String, Header<?>>();
1:35094c6: 		for (Entry<Object, Object> entry : manifest.getMainAttributes().entrySet()) {
1:35094c6: 			String key = String.valueOf(entry.getKey());
1:35094c6: 			result.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
1:35094c6: 		}
1:35094c6: 		return result;
1:35094c6: 	}
1:35094c6: 	
1:875a6d6: 	private static void fillInDefaults(Map<String, Header<?>> headers) {
1:875a6d6: 		Header<?> header = headers.get(SUBSYSTEM_VERSION);
1:875a6d6: 		if (header == null) {
1:875a6d6: 			headers.put(SUBSYSTEM_VERSION, SubsystemVersionHeader.DEFAULT);
1:875a6d6: 		}
1:875a6d6: 		header = headers.get(SUBSYSTEM_TYPE);
1:875a6d6: 		if (header == null)
1:875a6d6: 			headers.put(SUBSYSTEM_TYPE, SubsystemTypeHeader.DEFAULT);
1:d6eb080: 		header = headers.get(SUBSYTEM_LOCALIZATION);
2:bda6868: 		if (header == null)
1:d6eb080: 			headers.put(SUBSYTEM_LOCALIZATION, SubsystemLocalizationHeader.DEFAULT);
1:875a6d6: 	}
1:875a6d6: 	
1:bda6868: 	private final Map<String, Header<?>> headers;
1:1c9c28b: 	
1:875a6d6: 	private SubsystemManifest(Map<String, Header<?>> headers) {
1:875a6d6: 		Map<String, Header<?>> map = new HashMap<String, Header<?>>(headers);
1:875a6d6: 		fillInDefaults(map);
1:875a6d6: 		this.headers = Collections.unmodifiableMap(map);
1:875a6d6: 	}
1:875a6d6: 	
1:35094c6: 	public SubsystemManifest(java.util.jar.Manifest manifest) {
1:35094c6: 		this(parseHeaders(manifest));
1:35094c6: 	}
1:35094c6: 	
1:bda6868: 	public SubsystemManifest(File file) throws FileNotFoundException, IOException {
1:777b216: 		this(new FileInputStream(file));
1:777b216: 	}
1:777b216: 	
1:777b216: 	public SubsystemManifest(InputStream in) throws IOException {
1:777b216: 		Manifest manifest = ManifestProcessor.parseManifest(in);
1:bda6868: 		Attributes attributes = manifest.getMainAttributes();
1:bda6868: 		Map<String, Header<?>> headers = new HashMap<String, Header<?>>(attributes.size() + 4); // Plus the # of potentially derived headers.
1:bda6868: 		for (Entry<Object, Object> entry : attributes.entrySet()) {
1:bda6868: 			String key = String.valueOf(entry.getKey());
1:bda6868: 			headers.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
1:1c9c28b: 		}
1:875a6d6: 		fillInDefaults(headers);
1:bda6868: 		this.headers = Collections.unmodifiableMap(headers);
1:1c9c28b: 	}
1:1c9c28b: 	
1:bda6868: 	public SubsystemManifest(String symbolicName, Version version, Collection<Resource> content) {
1:bda6868: 		this(null, symbolicName, version, content);
1:bda6868: 	}
1:bda6868: 	
1:bda6868: 	public SubsystemManifest(SubsystemManifest manifest, String symbolicName, Version version, Collection<Resource> content) {
1:bda6868: 		Map<String, Header<?>> headers;
1:bda6868: 		if (manifest == null) {
1:bda6868: 			headers = new HashMap<String, Header<?>>(4);
1:1c9c28b: 		}
1:bda6868: 		else {
1:bda6868: 			headers = new HashMap<String, Header<?>>(manifest.headers);
1:bda6868: 		}
1:bda6868: 		Header<?> header = headers.get(SUBSYSTEM_SYMBOLICNAME);
1:bda6868: 		if (header == null)
1:875a6d6: 			headers.put(SUBSYSTEM_SYMBOLICNAME, new SubsystemSymbolicNameHeader(symbolicName));
1:bda6868: 		header = headers.get(SUBSYSTEM_VERSION);
1:875a6d6: 		if (header == null && !(version == null)) {
1:875a6d6: 			headers.put(SUBSYSTEM_VERSION, new SubsystemVersionHeader(version));
1:875a6d6: 		}
1:bda6868: 		header = headers.get(SUBSYSTEM_CONTENT);
1:bda6868: 		if (header == null && content != null && !content.isEmpty()) {
1:547a8ce: 			headers.put(SubsystemContentHeader.NAME, SubsystemContentHeader.newInstance(content));
1:bda6868: 		}
1:875a6d6: 		fillInDefaults(headers);
1:bda6868: 		this.headers = Collections.unmodifiableMap(headers);
1:bda6868: 	}
1:1c9c28b: 	
1:bda6868: 	public Map<String, Header<?>> getHeaders() {
1:bda6868: 		return headers;
1:bda6868: 	}
1:1129914: 	
1:7837a59: 	public ExportPackageHeader getExportPackageHeader() {
1:7837a59: 		return (ExportPackageHeader)getHeaders().get(EXPORT_PACKAGE);
1:7837a59: 	}
1:7837a59: 	
1:deca8ed: 	public ImportPackageHeader getImportPackageHeader() {
1:deca8ed: 		return (ImportPackageHeader)getHeaders().get(IMPORT_PACKAGE);
1:deca8ed: 	}
1:deca8ed: 	
1:f1b1384: 	public PreferredProviderHeader getPreferredProviderHeader() {
1:f1b1384: 		return (PreferredProviderHeader)getHeaders().get(PREFERRED_PROVIDER);
1:f1b1384: 	}
1:f1b1384: 	
1:26123d8: 	public ProvideCapabilityHeader getProvideCapabilityHeader() {
1:26123d8: 		return (ProvideCapabilityHeader)getHeaders().get(PROVIDE_CAPABILITY);
1:26123d8: 	}
1:26123d8: 	
1:47d9366: 	public RequireBundleHeader getRequireBundleHeader() {
1:47d9366: 		return (RequireBundleHeader)getHeaders().get(REQUIRE_BUNDLE);
1:47d9366: 	}
1:47d9366: 	
1:c1afebc: 	public RequireCapabilityHeader getRequireCapabilityHeader() {
1:c1afebc: 		return (RequireCapabilityHeader)getHeaders().get(REQUIRE_CAPABILITY);
1:c1afebc: 	}
1:c1afebc: 	
1:bda6868: 	public SubsystemContentHeader getSubsystemContentHeader() {
1:bda6868: 		return (SubsystemContentHeader)getHeaders().get(SUBSYSTEM_CONTENT);
1:bda6868: 	}
1:1129914: 	
1:097d28b: 	public SubsystemExportServiceHeader getSubsystemExportServiceHeader() {
1:097d28b: 		return (SubsystemExportServiceHeader)getHeaders().get(SUBSYSTEM_EXPORTSERVICE);
1:097d28b: 	}
1:097d28b: 	
1:124d6a3: 	public SubsystemImportServiceHeader getSubsystemImportServiceHeader() {
1:124d6a3: 		return (SubsystemImportServiceHeader)getHeaders().get(SUBSYSTEM_IMPORTSERVICE);
1:124d6a3: 	}
1:124d6a3: 	
1:d6eb080: 	public SubsystemLocalizationHeader getSubsystemLocalizationHeader() {
1:d6eb080: 		return (SubsystemLocalizationHeader)getHeaders().get(SUBSYTEM_LOCALIZATION);
6:1129914: 	}
1:1129914: 	
1:bda6868: 	public SubsystemSymbolicNameHeader getSubsystemSymbolicNameHeader() {
1:bda6868: 		return (SubsystemSymbolicNameHeader)getHeaders().get(SUBSYSTEM_SYMBOLICNAME);
1:1129914: 	}
1:1129914: 	
1:bda6868: 	public SubsystemTypeHeader getSubsystemTypeHeader() {
1:bda6868: 		return (SubsystemTypeHeader)getHeaders().get(SUBSYSTEM_TYPE);
1:1129914: 	}
1:1129914: 	
1:bda6868: 	public SubsystemVersionHeader getSubsystemVersionHeader() {
1:bda6868: 		return (SubsystemVersionHeader)getHeaders().get(SUBSYSTEM_VERSION);
1:bda6868: 	}
1:bda6868: 	
1:df175a6: 	public List<Capability> toCapabilities(Resource resource) {
1:35094c6: 		ArrayList<Capability> capabilities = new ArrayList<Capability>();
1:df175a6: 		for (Header<?> header : headers.values())
1:df175a6: 			if (header instanceof CapabilityHeader)
1:35094c6: 				capabilities.addAll(((CapabilityHeader<?>)header).toCapabilities(resource));
1:35094c6: 		capabilities.add(new OsgiIdentityCapability(
1:35094c6: 				resource,
1:35094c6: 				getSubsystemSymbolicNameHeader().getSymbolicName(),
1:35094c6: 				getSubsystemVersionHeader().getVersion(),
1:35094c6: 				getSubsystemTypeHeader().getType()));
1:35094c6: 		capabilities.trimToSize();
1:35094c6: 		return capabilities;
1:df175a6: 	}
1:df175a6: 	
1:df175a6: 	public List<Requirement> toRequirements(Resource resource) {
1:df175a6: 		ArrayList<Requirement> requirements = new ArrayList<Requirement>();
1:df175a6: 		for (Header<?> header : headers.values())
1:2b13b05: 			if (header instanceof RequirementHeader && !((header instanceof SubsystemContentHeader) || (header instanceof PreferredProviderHeader)))
1:df175a6: 				requirements.addAll(((RequirementHeader<?>)header).toRequirements(resource));
2:df175a6: 		requirements.trimToSize();
2:df175a6: 		return requirements;
1:df175a6: 	}
1:df175a6: 	
1:2ffcfb9: 	@Override
1:2ffcfb9: 	public String toString() {
1:2ffcfb9: 		StringBuilder builder = new StringBuilder("[Subsystem Manifest: ");
1:2ffcfb9: 		Iterator<Header<?>> iterator = headers.values().iterator();
1:2ffcfb9: 		if (iterator.hasNext()) {
1:2ffcfb9: 			Header<?> header = iterator.next();
1:2ffcfb9: 			builder.append(header.getName()).append('=').append(header.getValue());
1:2ffcfb9: 			while (iterator.hasNext()) {
1:2ffcfb9: 				header = iterator.next();
1:2ffcfb9: 				builder.append(", ").append(header.getName()).append('=').append(header.getValue());
1:2ffcfb9: 			}
1:2ffcfb9: 		}
1:2ffcfb9: 		return builder.append(']').toString();
1:2ffcfb9: 	}
1:2ffcfb9: 	
1:bda6868: 	public void write(OutputStream out) throws IOException {
1:bda6868: 		Manifest manifest = new Manifest();
1:bda6868: 		Attributes attributes = manifest.getMainAttributes();
1:bda6868: 		// The manifest won't write anything unless the following header is present.
1:bda6868: 		attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0");
1:bda6868: 		for (Entry<String, Header<?>> entry : headers.entrySet()) {
1:bda6868: 			attributes.putValue(entry.getKey(), entry.getValue().getValue());
1:bda6868: 		}
1:bda6868: 		manifest.write(out);
1:1c9c28b: 	}
1:2ffcfb9: 
1:2ffcfb9:     @Override
1:2ffcfb9:     public int hashCode() {
1:2ffcfb9:         return 31 * 17 + headers.hashCode();
1:2ffcfb9:     }
1:2ffcfb9: 
1:2ffcfb9:     @Override
1:2ffcfb9:     public boolean equals(Object o) {
1:2ffcfb9:     	if (o == this) {
1:2ffcfb9:     		return true;
1:2ffcfb9:     	}
1:2ffcfb9:     	if (!(o instanceof SubsystemManifest)) {
1:2ffcfb9:     		return false;
1:2ffcfb9:     	}
1:2ffcfb9:     	SubsystemManifest that = (SubsystemManifest)o;
1:2ffcfb9:     	return that.headers.equals(this.headers);
1:2ffcfb9:     }
1:1129914: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:2ffcfb9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: 	@Override
1: 	public String toString() {
1: 		StringBuilder builder = new StringBuilder("[Subsystem Manifest: ");
1: 		Iterator<Header<?>> iterator = headers.values().iterator();
1: 		if (iterator.hasNext()) {
1: 			Header<?> header = iterator.next();
1: 			builder.append(header.getName()).append('=').append(header.getValue());
1: 			while (iterator.hasNext()) {
1: 				header = iterator.next();
1: 				builder.append(", ").append(header.getName()).append('=').append(header.getValue());
1: 			}
1: 		}
1: 		return builder.append(']').toString();
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public int hashCode() {
1:         return 31 * 17 + headers.hashCode();
1:     }
1: 
1:     @Override
1:     public boolean equals(Object o) {
1:     	if (o == this) {
1:     		return true;
1:     	}
1:     	if (!(o instanceof SubsystemManifest)) {
1:     		return false;
1:     	}
1:     	SubsystemManifest that = (SubsystemManifest)o;
1:     	return that.headers.equals(this.headers);
1:     }
commit:a14f2fd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:2b13b05
/////////////////////////////////////////////////////////////////////////
1: 			if (header instanceof RequirementHeader && !((header instanceof SubsystemContentHeader) || (header instanceof PreferredProviderHeader)))
commit:547a8ce
/////////////////////////////////////////////////////////////////////////
1: 			return value == null || value.isEmpty() ? this : content(SubsystemContentHeader.newInstance(value));
/////////////////////////////////////////////////////////////////////////
1: 			headers.put(SubsystemContentHeader.NAME, SubsystemContentHeader.newInstance(content));
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
1: 		this(new FileInputStream(file));
1: 	}
1: 	
1: 	public SubsystemManifest(InputStream in) throws IOException {
1: 		Manifest manifest = ManifestProcessor.parseManifest(in);
commit:f1b1384
/////////////////////////////////////////////////////////////////////////
1: 	public PreferredProviderHeader getPreferredProviderHeader() {
1: 		return (PreferredProviderHeader)getHeaders().get(PREFERRED_PROVIDER);
1: 	}
1: 	
commit:35094c6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.internal.OsgiIdentityCapability;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		public Builder manifest(SubsystemManifest value) {
1: 			for (Entry<String, Header<?>> entry : value.getHeaders().entrySet())
1: 				header(entry.getValue());
1: 			return this;
1: 		}
1: 		
1: 		public Builder symbolicName(String value) {
1: 			return value == null ? this : symbolicName(new SubsystemSymbolicNameHeader(value));
1: 		}
1: 		
1: 		public Builder symbolicName(SubsystemSymbolicNameHeader value) {
1: 			return header(value);
1: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
1: 	private static Map<String, Header<?>> parseHeaders(java.util.jar.Manifest manifest) {
1: 		Map<String, Header<?>> result = new HashMap<String, Header<?>>();
1: 		for (Entry<Object, Object> entry : manifest.getMainAttributes().entrySet()) {
1: 			String key = String.valueOf(entry.getKey());
1: 			result.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
1: 		}
1: 		return result;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemManifest(java.util.jar.Manifest manifest) {
1: 		this(parseHeaders(manifest));
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		ArrayList<Capability> capabilities = new ArrayList<Capability>();
1: 				capabilities.addAll(((CapabilityHeader<?>)header).toCapabilities(resource));
1: 		capabilities.add(new OsgiIdentityCapability(
1: 				resource,
1: 				getSubsystemSymbolicNameHeader().getSymbolicName(),
1: 				getSubsystemVersionHeader().getVersion(),
1: 				getSubsystemTypeHeader().getType()));
1: 		capabilities.trimToSize();
1: 		return capabilities;
commit:df175a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.resource.Capability;
1: import org.osgi.resource.Requirement;
/////////////////////////////////////////////////////////////////////////
1: 	public List<Capability> toCapabilities(Resource resource) {
0: 		ArrayList<Capability> requirements = new ArrayList<Capability>();
1: 		for (Header<?> header : headers.values())
1: 			if (header instanceof CapabilityHeader)
0: 				requirements.addAll(((CapabilityHeader<?>)header).toCapabilities(resource));
1: 		requirements.trimToSize();
1: 		return requirements;
1: 	}
1: 	
1: 	public List<Requirement> toRequirements(Resource resource) {
1: 		ArrayList<Requirement> requirements = new ArrayList<Requirement>();
1: 		for (Header<?> header : headers.values())
0: 			if (header instanceof RequirementHeader)
1: 				requirements.addAll(((RequirementHeader<?>)header).toRequirements(resource));
1: 		requirements.trimToSize();
1: 		return requirements;
1: 	}
1: 	
commit:875a6d6
/////////////////////////////////////////////////////////////////////////
1: 	public static class Builder {
1: 		private Map<String, Header<?>> headers = new HashMap<String, Header<?>>();
1: 		
0: 		public Builder(String symbolicName) {
1: 			headers.put(SUBSYSTEM_SYMBOLICNAME, new SubsystemSymbolicNameHeader(symbolicName));
1: 		}
1: 		
1: 		public SubsystemManifest build() {
1: 			return new SubsystemManifest(headers);
1: 		}
1: 		
1: 		public Builder content(String value) {
1: 			return value == null ? this : content(new SubsystemContentHeader(value));
1: 		}
1: 		
1: 		public Builder content(Collection<Resource> value) {
0: 			return value == null || value.isEmpty() ? this : content(new SubsystemContentHeader(value));
1: 		}
1: 		
1: 		public Builder content(SubsystemContentHeader value) {
1: 			return header(value);
1: 		}
1: 		
1: 		public Builder header(Header<?> value) {
1: 			if (value != null)
1: 				headers.put(value.getName(), value);
1: 			return this;
1: 		}
1: 		
1: 		public Builder type(String value) {
1: 			return value == null ? this : type(new SubsystemTypeHeader(value));
1: 		}
1: 		
1: 		public Builder type(SubsystemTypeHeader value) {
1: 			return header(value);
1: 		}
1: 		
1: 		public Builder version(String value) {
1: 			return value == null ? this : version(Version.parseVersion(value));
1: 		}
1: 		
1: 		public Builder version(Version value) {
1: 			return value == null ? this : version(new SubsystemVersionHeader(value));
1: 		}
1: 		
1: 		public Builder version(SubsystemVersionHeader value) {
1: 			return header(value);
1: 		}
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	private static void fillInDefaults(Map<String, Header<?>> headers) {
1: 		Header<?> header = headers.get(SUBSYSTEM_VERSION);
1: 		if (header == null) {
1: 			headers.put(SUBSYSTEM_VERSION, SubsystemVersionHeader.DEFAULT);
1: 		}
1: 		header = headers.get(SUBSYSTEM_TYPE);
1: 		if (header == null)
1: 			headers.put(SUBSYSTEM_TYPE, SubsystemTypeHeader.DEFAULT);
1: 	}
1: 	
1: 	private SubsystemManifest(Map<String, Header<?>> headers) {
1: 		Map<String, Header<?>> map = new HashMap<String, Header<?>>(headers);
1: 		fillInDefaults(map);
1: 		this.headers = Collections.unmodifiableMap(map);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		fillInDefaults(headers);
/////////////////////////////////////////////////////////////////////////
1: 		if (header == null && !(version == null)) {
1: 			headers.put(SUBSYSTEM_VERSION, new SubsystemVersionHeader(version));
0: 			headers.put(SubsystemContentHeader.NAME, new SubsystemContentHeader(content));
1: 		fillInDefaults(headers);
commit:097d28b
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemExportServiceHeader getSubsystemExportServiceHeader() {
1: 		return (SubsystemExportServiceHeader)getHeaders().get(SUBSYSTEM_EXPORTSERVICE);
1: 	}
1: 	
commit:26123d8
/////////////////////////////////////////////////////////////////////////
1: 	public ProvideCapabilityHeader getProvideCapabilityHeader() {
1: 		return (ProvideCapabilityHeader)getHeaders().get(PROVIDE_CAPABILITY);
1: 	}
1: 	
commit:7837a59
/////////////////////////////////////////////////////////////////////////
1: 	public ExportPackageHeader getExportPackageHeader() {
1: 		return (ExportPackageHeader)getHeaders().get(EXPORT_PACKAGE);
1: 	}
1: 	
commit:47d9366
/////////////////////////////////////////////////////////////////////////
1: 	public RequireBundleHeader getRequireBundleHeader() {
1: 		return (RequireBundleHeader)getHeaders().get(REQUIRE_BUNDLE);
1: 	}
1: 	
commit:124d6a3
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemImportServiceHeader getSubsystemImportServiceHeader() {
1: 		return (SubsystemImportServiceHeader)getHeaders().get(SUBSYSTEM_IMPORTSERVICE);
1: 	}
1: 	
commit:c1afebc
/////////////////////////////////////////////////////////////////////////
1: 	public RequireCapabilityHeader getRequireCapabilityHeader() {
1: 		return (RequireCapabilityHeader)getHeaders().get(REQUIRE_CAPABILITY);
1: 	}
1: 	
commit:deca8ed
/////////////////////////////////////////////////////////////////////////
1: 	public ImportPackageHeader getImportPackageHeader() {
1: 		return (ImportPackageHeader)getHeaders().get(IMPORT_PACKAGE);
1: 	}
1: 	
commit:71fe81a
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.resource.Capability;
1: import org.osgi.resource.Resource;
commit:a1c6951
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.namespace.IdentityNamespace;
/////////////////////////////////////////////////////////////////////////
0: 				Capability c = resource.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0);
0: 				String s = (String)a.get(IdentityNamespace.IDENTITY_NAMESPACE);
0: 				Version v = (Version)a.get(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE);
0: 				String t = (String)a.get(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE);
0: 					.append(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE).append('=').append(v).append(';')
0: 					.append(IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE).append('=').append(t).append(',');
commit:bda6868
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
1: import java.io.OutputStream;
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.jar.Attributes;
1: import java.util.jar.Manifest;
1: import org.apache.aries.util.manifest.ManifestProcessor;
1: import org.osgi.framework.Constants;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: public class SubsystemManifest {
1: 	public static final String EXPORT_PACKAGE = Constants.EXPORT_PACKAGE;
1: 	public static final String IMPORT_PACKAGE = Constants.IMPORT_PACKAGE;
1: 	public static final String PREFERRED_PROVIDER = SubsystemConstants.PREFERRED_PROVIDER;
1: 	public static final String PROVIDE_CAPABILITY = Constants.PROVIDE_CAPABILITY;
1: 	public static final String REQUIRE_BUNDLE = Constants.REQUIRE_BUNDLE;
1: 	public static final String REQUIRE_CAPABILITY = Constants.REQUIRE_CAPABILITY;
1: 	public static final String SUBSYSTEM_CONTENT = SubsystemConstants.SUBSYSTEM_CONTENT;
1: 	public static final String SUBSYSTEM_DESCRIPTION = SubsystemConstants.SUBSYSTEM_DESCRIPTION;
1: 	public static final String SUBSYSTEM_EXPORTSERVICE = SubsystemConstants.SUBSYSTEM_EXPORTSERVICE;
1: 	public static final String SUBSYSTEM_IMPORTSERVICE = SubsystemConstants.SUBSYSTEM_IMPORTSERVICE;
1: 	public static final String SUBSYSTEM_MANIFESTVERSION = SubsystemConstants.SUBSYSTEM_MANIFESTVERSION;
1: 	public static final String SUBSYSTEM_NAME = SubsystemConstants.SUBSYSTEM_NAME;
1: 	public static final String SUBSYSTEM_SYMBOLICNAME = SubsystemConstants.SUBSYSTEM_SYMBOLICNAME;
1: 	public static final String SUBSYSTEM_TYPE = SubsystemConstants.SUBSYSTEM_TYPE;
1: 	public static final String SUBSYSTEM_VERSION = SubsystemConstants.SUBSYSTEM_VERSION;
1: 	private final Map<String, Header<?>> headers;
1: 	public SubsystemManifest(File file) throws FileNotFoundException, IOException {
0: 		Manifest manifest = ManifestProcessor.parseManifest(new FileInputStream(file));
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		Map<String, Header<?>> headers = new HashMap<String, Header<?>>(attributes.size() + 4); // Plus the # of potentially derived headers.
1: 		for (Entry<Object, Object> entry : attributes.entrySet()) {
1: 			String key = String.valueOf(entry.getKey());
1: 			headers.put(key, HeaderFactory.createHeader(key, String.valueOf(entry.getValue())));
0: 		Header<?> header = headers.get(SUBSYSTEM_VERSION);
0: 		if (header == null) {
0: 			headers.put(SUBSYSTEM_VERSION, SubsystemVersionHeader.DEFAULT);
0: 		header = headers.get(SUBSYSTEM_TYPE);
1: 		if (header == null)
0: 			headers.put(SUBSYSTEM_TYPE, SubsystemTypeHeader.DEFAULT);
1: 		this.headers = Collections.unmodifiableMap(headers);
1: 	public SubsystemManifest(String symbolicName, Version version, Collection<Resource> content) {
1: 		this(null, symbolicName, version, content);
1: 	}
1: 	
1: 	public SubsystemManifest(SubsystemManifest manifest, String symbolicName, Version version, Collection<Resource> content) {
1: 		Map<String, Header<?>> headers;
1: 		if (manifest == null) {
1: 			headers = new HashMap<String, Header<?>>(4);
1: 		else {
1: 			headers = new HashMap<String, Header<?>>(manifest.headers);
1: 		}
1: 		Header<?> header = headers.get(SUBSYSTEM_SYMBOLICNAME);
1: 		if (header == null)
0: 			headers.put(SUBSYSTEM_SYMBOLICNAME, new SubsystemSymbolicNameHeader(symbolicName));
1: 		header = headers.get(SUBSYSTEM_VERSION);
0: 		if (header == null) {
0: 			if (version == null)
0: 				headers.put(SUBSYSTEM_VERSION, SubsystemVersionHeader.DEFAULT);
0: 			else
0: 				headers.put(SUBSYSTEM_VERSION, new SubsystemVersionHeader(version));
1: 		}
1: 		header = headers.get(SUBSYSTEM_CONTENT);
1: 		if (header == null && content != null && !content.isEmpty()) {
0: 			// TODO Better way than using StringBuilder? Would require a more robust SubsystemContentHeader in order to fulfill the Header contract.
0: 			StringBuilder sb = new StringBuilder();
0: 			for (Resource resource : content) {
0: 				Capability c = resource.getCapabilities(ResourceConstants.IDENTITY_NAMESPACE).get(0);
0: 				Map<String, Object> a = c.getAttributes();
0: 				String s = (String)a.get(ResourceConstants.IDENTITY_NAMESPACE);
0: 				Version v = (Version)a.get(ResourceConstants.IDENTITY_VERSION_ATTRIBUTE);
0: 				String t = (String)a.get(ResourceConstants.IDENTITY_TYPE_ATTRIBUTE);
0: 				sb.append(s).append(';')
0: 					.append(ResourceConstants.IDENTITY_VERSION_ATTRIBUTE).append('=').append(v).append(';')
0: 					.append(ResourceConstants.IDENTITY_TYPE_ATTRIBUTE).append('=').append(t).append(',');
1: 			}
0: 			if (sb.length() != 0) {
0: 				// Remove the trailing comma.
0: 				sb.deleteCharAt(sb.length() - 1);
0: 				headers.put(SubsystemContentHeader.NAME, new SubsystemContentHeader(sb.toString()));
1: 			}
1: 		}
0: 		header = headers.get(SUBSYSTEM_TYPE);
1: 		if (header == null)
0: 			headers.put(SUBSYSTEM_TYPE, SubsystemTypeHeader.DEFAULT);
1: 		this.headers = Collections.unmodifiableMap(headers);
1: 	public Map<String, Header<?>> getHeaders() {
1: 		return headers;
1: 	public SubsystemContentHeader getSubsystemContentHeader() {
1: 		return (SubsystemContentHeader)getHeaders().get(SUBSYSTEM_CONTENT);
1: 	public SubsystemSymbolicNameHeader getSubsystemSymbolicNameHeader() {
1: 		return (SubsystemSymbolicNameHeader)getHeaders().get(SUBSYSTEM_SYMBOLICNAME);
1: 	public SubsystemTypeHeader getSubsystemTypeHeader() {
1: 		return (SubsystemTypeHeader)getHeaders().get(SUBSYSTEM_TYPE);
1: 	public SubsystemVersionHeader getSubsystemVersionHeader() {
1: 		return (SubsystemVersionHeader)getHeaders().get(SUBSYSTEM_VERSION);
1: 	}
1: 	
1: 	public void write(OutputStream out) throws IOException {
1: 		Manifest manifest = new Manifest();
1: 		Attributes attributes = manifest.getMainAttributes();
1: 		// The manifest won't write anything unless the following header is present.
1: 		attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0");
1: 		for (Entry<String, Header<?>> entry : headers.entrySet()) {
1: 			attributes.putValue(entry.getKey(), entry.getValue().getValue());
1: 		}
1: 		manifest.write(out);
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
0: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1: 
0: import java.util.ArrayList;
1: import java.util.Collections;
0: import java.util.List;
0: import org.apache.aries.subsystem.core.internal.OsgiIdentityCapability;
0: import org.osgi.framework.resource.Requirement;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: public class SubsystemManifest extends Manifest implements Resource {
0: 	public static final String IDENTITY_TYPE = "org.apache.aries.subsystem.manifest";
1: 	
0: 	private static final Logger logger = LoggerFactory.getLogger(SubsystemManifest.class);
1: 	
0: 		if (logger.isDebugEnabled())
0: 			logger.debug(LOG_ENTRY, "newInstance", new Object[]{symbolicName, version, resources});
/////////////////////////////////////////////////////////////////////////
0: 		if (content.length() != 0) {
0: 			// Remove the trailing comma.
0: 			content.deleteCharAt(content.length() - 1);
0: 			manifest.headers.put(SubsystemContentHeader.NAME, new SubsystemContentHeader(content.toString()));
1: 		}
0: 		logger.debug(LOG_EXIT, "newInstance", manifest);
/////////////////////////////////////////////////////////////////////////
0: 	@Override
0: 	public List<Capability> getCapabilities(String namespace) {
0: 		List<Capability> result = new ArrayList<Capability>(1);
0: 		if (namespace == null || namespace.equals(ResourceConstants.IDENTITY_NAMESPACE)) {
0: 			OsgiIdentityCapability capability = new OsgiIdentityCapability(
0: 					this,
0: 					// TODO Reusing IDENTITY_TYPE for the symbolic name here.
0: 					// Since there's only one subsystem manifest per subsystem,
0: 					// this shouldn't cause any technical issues. However, it
0: 					// might be best to use the subsystem's symbolic name here.
0: 					// But there are issues with that as well since type is not
0: 					// part of the unique identity.
0: 					IDENTITY_TYPE,
0: 					Version.emptyVersion,
0: 					IDENTITY_TYPE);
0: 			result.add(capability);
1: 		}
0: 		return result;
1: 	}
1: 	
0: 	@Override
0: 	public List<Requirement> getRequirements(String namespace) {
0: 		return Collections.emptyList();
1: 	}
1: 	
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.resource.Capability;
0: import org.osgi.framework.resource.Resource;
0: import org.osgi.framework.resource.ResourceConstants;
commit:1129914
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
1: package org.apache.aries.subsystem.core.archive;
1: 
1: import java.io.File;
1: import java.io.IOException;
0: import java.io.InputStream;
1: import java.util.Collection;
1: 
1: import org.osgi.framework.Version;
0: import org.osgi.framework.wiring.Capability;
0: import org.osgi.framework.wiring.Resource;
0: import org.osgi.framework.wiring.ResourceConstants;
0: import org.osgi.service.subsystem.SubsystemException;
1: 
0: public class SubsystemManifest extends Manifest {
0: 	public static SubsystemManifest newInstance(String symbolicName, Version version, Collection<Resource> resources) {
0: 		if (resources.isEmpty())
0: 			throw new SubsystemException("A subsystem must have content");
0: 		SubsystemManifest manifest = new SubsystemManifest();
0: 		manifest.headers.put(SubsystemTypeHeader.NAME, new SubsystemTypeHeader());
0: 		manifest.headers.put(ManifestVersionHeader.NAME, new ManifestVersionHeader());
0: 		manifest.headers.put(SubsystemManifestVersionHeader.NAME, new SubsystemManifestVersionHeader());
0: 		manifest.headers.put(ManifestVersionHeader.NAME, new ManifestVersionHeader());
0: 		manifest.headers.put(SubsystemSymbolicNameHeader.NAME, new SubsystemSymbolicNameHeader(symbolicName));
0: 		manifest.headers.put(SubsystemVersionHeader.NAME, new SubsystemVersionHeader(version.toString()));
0: 		// TODO Leaving out Subsystem-Name and Subsystem-Description.
0: 		// TODO Better way than using StringBuilder? Would require a more robust SubsystemContentHeader in order to fulfill the Header contract.
0: 		StringBuilder content = new StringBuilder();
0: 		for (Resource resource : resources) {
0: 			Capability osgiIdentity = resource.getCapabilities(ResourceConstants.IDENTITY_NAMESPACE).get(0);
0: 			String resourceSymbolicName = (String)osgiIdentity.getAttributes().get(ResourceConstants.IDENTITY_NAMESPACE);
0: 			Version resourceVersion = (Version)osgiIdentity.getAttributes().get(ResourceConstants.IDENTITY_VERSION_ATTRIBUTE);
0: 			String type = (String)osgiIdentity.getAttributes().get(ResourceConstants.IDENTITY_TYPE_ATTRIBUTE);
0: 			content.append(resourceSymbolicName).append(';')
0: 				// TODO Add to constants.
0: 				.append("version").append('=').append(resourceVersion).append(';')
0: 				// TODO Add to constants.
0: 				.append("type").append('=').append(type).append(',');
1: 		}
0: 		// Remove the trailing comma.
0: 		content.deleteCharAt(content.length() - 1);
0: 		manifest.headers.put(SubsystemContentHeader.NAME, new SubsystemContentHeader(content.toString()));
0: 		return manifest;
1: 	}
1: 
0: 	public SubsystemManifest(InputStream in) throws IOException {
0: 		super(in);
1: 	}
1: 
0: 	public SubsystemManifest(File file) throws IOException {
0: 		super(file);
1: 	}
1: 
0: 	private SubsystemManifest() {}
1: 	
0: 	public SubsystemContentHeader getSubsystemContent() {
0: 		return (SubsystemContentHeader)getHeader(SubsystemContentHeader.NAME);
1: 	}
1: 	
0: 	public SubsystemSymbolicNameHeader getSubsystemSymbolicName() {
0: 		return (SubsystemSymbolicNameHeader)getHeader(SubsystemSymbolicNameHeader.NAME);
1: 	}
1: 	
0: 	public SubsystemTypeHeader getSubsystemType() {
0: 		SubsystemTypeHeader result = (SubsystemTypeHeader)getHeader(SubsystemTypeHeader.NAME);
0: 		if (result == null)
0: 			return SubsystemTypeHeader.DEFAULT;
0: 		return result;
1: 	}
1: 	
0: 	public SubsystemVersionHeader getSubsystemVersion() {
0: 		SubsystemVersionHeader result = (SubsystemVersionHeader)getHeader(SubsystemVersionHeader.NAME);
0: 		if (result == null)
0: 			return SubsystemVersionHeader.DEFAULT;
0: 		return result;
1: 	}
1: }
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
1: 	public static final String SUBSYTEM_LOCALIZATION = SubsystemConstants.SUBSYSTEM_LOCALIZATION;
/////////////////////////////////////////////////////////////////////////
1: 		header = headers.get(SUBSYTEM_LOCALIZATION);
0: 		if (header == null)
1: 			headers.put(SUBSYTEM_LOCALIZATION, SubsystemLocalizationHeader.DEFAULT);
/////////////////////////////////////////////////////////////////////////
1: 	public SubsystemLocalizationHeader getSubsystemLocalizationHeader() {
1: 		return (SubsystemLocalizationHeader)getHeaders().get(SUBSYTEM_LOCALIZATION);
0: 	}
0: 	
============================================================================