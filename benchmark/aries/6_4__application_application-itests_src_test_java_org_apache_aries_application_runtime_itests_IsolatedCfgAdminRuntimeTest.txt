3:f82abd8: /*
1:f82abd8:  * Licensed to the Apache Software Foundation (ASF) under one
1:f82abd8:  * or more contributor license agreements.  See the NOTICE file
1:f82abd8:  * distributed with this work for additional information
1:f82abd8:  * regarding copyright ownership.  The ASF licenses this file
1:f82abd8:  * to you under the Apache License, Version 2.0 (the
1:f82abd8:  * "License"); you may not use this file except in compliance
1:f82abd8:  * with the License.  You may obtain a copy of the License at
26:f82abd8:  *
1:f82abd8:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f82abd8:  *
1:f82abd8:  * Unless required by applicable law or agreed to in writing,
1:f82abd8:  * software distributed under the License is distributed on an
1:f82abd8:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f82abd8:  * KIND, either express or implied.  See the License for the
1:f82abd8:  * specific language governing permissions and limitations
1:f82abd8:  * under the License.
3:f82abd8:  */
1:f82abd8: package org.apache.aries.application.runtime.itests;
55:f82abd8: 
1:0223547: import static org.ops4j.pax.exam.CoreOptions.*;
1:f82abd8: 
1:0223547: import java.io.*;
1:f82abd8: import java.net.URL;
1:0223547: import java.util.*;
1:f82abd8: import java.util.concurrent.CountDownLatch;
1:f82abd8: import java.util.concurrent.TimeUnit;
1:f82abd8: 
1:f82abd8: import junit.framework.Assert;
1:f82abd8: 
1:f82abd8: import org.apache.aries.application.management.AriesApplication;
1:f82abd8: import org.apache.aries.application.management.AriesApplicationContext;
1:f82abd8: import org.apache.aries.application.management.AriesApplicationManager;
1:f82abd8: import org.apache.aries.application.runtime.itests.util.IsolationTestUtils;
1:f82abd8: import org.apache.aries.isolated.sample.HelloWorld;
1:f82abd8: import org.apache.aries.isolated.sample.HelloWorldImpl;
1:f82abd8: import org.apache.aries.itest.AbstractIntegrationTest;
1:f82abd8: import org.apache.aries.itest.RichBundleContext;
1:f82abd8: import org.apache.aries.unittest.fixture.ArchiveFixture;
1:f82abd8: import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
1:f82abd8: import org.apache.aries.unittest.mocks.Skeleton;
1:f82abd8: import org.apache.aries.util.filesystem.FileSystem;
1:f82abd8: import org.apache.aries.util.filesystem.IDirectory;
1:f82abd8: import org.junit.After;
1:f82abd8: import org.junit.Before;
1:0223547: import org.junit.Ignore;
1:f82abd8: import org.junit.Test;
1:f82abd8: import org.junit.runner.RunWith;
1:f82abd8: import org.ops4j.pax.exam.Option;
1:0223547: import org.ops4j.pax.exam.junit.PaxExam;
1:f82abd8: import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
1:0223547: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1:0223547: import org.ops4j.pax.exam.spi.reactors.PerClass;
1:f82abd8: import org.osgi.framework.BundleContext;
1:f82abd8: import org.osgi.framework.Constants;
1:f82abd8: import org.osgi.framework.InvalidSyntaxException;
1:f82abd8: import org.osgi.framework.ServiceReference;
1:f82abd8: import org.osgi.service.cm.Configuration;
1:f82abd8: import org.osgi.service.cm.ConfigurationAdmin;
1:f82abd8: import org.osgi.service.cm.ManagedService;
1:f82abd8: import org.osgi.service.url.URLStreamHandlerService;
1:f82abd8: import org.osgi.util.tracker.ServiceTracker;
1:f82abd8: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1:f82abd8: 
1:f82abd8: /**
1:f82abd8:  * This test suite is responsible for validating that an application can package and use the
1:f82abd8:  * isolated configuration admin deployed. This includes both from Blueprint and manually.
1:0223547:  * <p/>
1:f82abd8:  * Blueprint Specific:
1:0223547:  * <p/>
1:f82abd8:  * Note that, the CmNamespaceHandler has been rewired to create a service reference to the configuration
1:0223547:  * admin that resides within the application framework. This will allow the configuration admin bundle
1:0223547:  * activator sufficient time to register a config admin service before the blueprint container for the bundle
1:f82abd8:  * requiring it is started (i.e. no configuration admin race condition).
1:0223547:  * <p/>
1:f82abd8:  * Other notes:
1:0223547:  * <p/>
1:f82abd8:  * In order to avoid boundary issues (i.e. class casting exceptions etc), the actual configuration admin bundle
1:f82abd8:  * classes are loaded from the shared framework. This is necessary as the blueprint-cm bundle refers to the
1:0223547:  * configuration admin classes directly, as we register a configuration admin and managed service in the
1:f82abd8:  * application scope, any attempt to use those services from the CM bundle would end up in a class cast exception.
1:f82abd8:  * This is why we use the classes already loaded in the root container, which are imported into the shared framework.
1:0223547:  * Behind the scenes a manifest transformer is used to make sure that the DEPLOYMENT.MF is augmented with the
1:f82abd8:  * necessary org.osgi.service.cm package import to make the class space consistent everywhere. From the developers
1:f82abd8:  * perspective, it appears as if they are deploying into a flat container as the wiring magic is hidden when the
1:f82abd8:  * application is created and installed. Note that the config package import only includes the CM API, nothing else.
1:f82abd8:  *
1:f82abd8:  * @version $Rev$ $Date$
1:f82abd8:  */
1:0223547: @RunWith(PaxExam.class)
1:0223547: @ExamReactorStrategy(PerClass.class)
1:f82abd8: public class IsolatedCfgAdminRuntimeTest extends AbstractIntegrationTest {
1:0223547: 
1:f82abd8:     private static final String APP_HWBP = "helloworld-bp.eba";
1:f82abd8:     private static final String APP_HWMN = "helloworld-mn.eba";
1:f82abd8:     private static final List<String> APPLICATIONS = Arrays.asList(APP_HWBP, APP_HWMN);
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Creates two applications, as follows:
1:0223547:      * <p/>
1:0223547:      * - helloworld-bp.eba ------
1:0223547:      * |
1:0223547:      * | This application contains a helloworld bundle which contains an interface and impl for HelloWorld. Upon being started
1:0223547:      * | blueprint will create a new container for this bundle and register the HelloWorld service. The service will be injected
1:0223547:      * | with a message coming from the ConfigurationAdmin service using the PID: helloworld-bp. As a CM property placeholder is
1:0223547:      * | used, a ManagedService will also be registered on the bundles behalf so that further updates can be captured. Note that
1:0223547:      * | the blueprint configuration is wired to reload the container on a configuration update (to allow easier tracking of when
1:0223547:      * | to test service contents etc).
1:0223547:      * |
1:0223547:      * | The application also contains a configuration admin bundle (pulled from Maven).
1:0223547:      * ---------------------------
1:0223547:      * <p/>
1:0223547:      * - helloworld-mn.eba -------
1:0223547:      * |
1:0223547:      * | This application contains a helloworld bundle containing an activator that will register itself as a ManagedService for the
1:0223547:      * | PID: helloworld-mn. The activator will also expose out a HelloWorld service. Upon recieving an update from the packaged
1:0223547:      * | Configuration Admin service, the HelloWorld service will be re-registered using the latest configuration, namely the "message".
1:0223547:      * |
1:0223547:      * | The application also contains a configuration admin bundle (pulled from Maven).
1:0223547:      * ---------------------------
1:0223547:      *
1:f82abd8:      * @throws Exception
1:f82abd8:      */
1:f82abd8:     @Before
1:0223547:     public void constructApplications() throws Exception {
1:0223547: 
1:f82abd8:         Assert.assertNotNull("Could not find Maven URL handler", (new RichBundleContext(context())).getService(URLStreamHandlerService.class, "url.handler.protocol=mvn", 300000));
1:f82abd8:         MavenArtifactProvisionOption configAdminProvisionOption = mavenBundleInTest(getClass().getClassLoader(), "org.apache.felix", "org.apache.felix.configadmin");
1:f82abd8:         Assert.assertNotNull("Unable to lookup config admin maven bundle", configAdminProvisionOption);
1:f82abd8:         URL configAdminUrl = new URL(configAdminProvisionOption.getURL());
1:0223547: 
1:f82abd8:         ZipFixture helloWorldBluePrintEba = ArchiveFixture
1:f82abd8:                 .newZip()
1:0223547:                 .binary("META-INF/APPLICATION.MF",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader()
1:0223547:                                 .getResourceAsStream("isolated/config/APPLICATION-BP.MF")
1:0223547:                 )
1:0223547:                 .binary("org.apache.felix.configadmin.jar", configAdminUrl.openStream())
1:0223547:                 .jar("helloworld-bundle.jar")
1:0223547:                 .manifest()
1:0223547:                 .symbolicName("org.apache.aries.isolated.helloworldbp")
1:0223547:                 .attribute("Bundle-Version", "1.0.0")
1:0223547:                 .attribute("Import-Package", "org.osgi.service.cm")
1:0223547:                 .end()
1:0223547:                 .binary("org/apache/aries/isolated/sample/HelloWorld.class",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:0223547:                                 "org/apache/aries/isolated/sample/HelloWorld.class")
1:0223547:                 )
1:0223547:                 .binary("org/apache/aries/isolated/sample/HelloWorldImpl.class",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:0223547:                                 "org/apache/aries/isolated/sample/HelloWorldImpl.class")
1:0223547:                 )
1:0223547:                 .binary("OSGI-INF/blueprint/blueprint.xml",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader()
1:0223547:                                 .getResourceAsStream("isolated/config/blueprint.xml")
1:0223547:                 ).end();
1:f82abd8: 
1:f82abd8:         ZipFixture helloWorldManualEba = ArchiveFixture
1:f82abd8:                 .newZip()
1:0223547:                 .binary("META-INF/APPLICATION.MF",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader()
1:0223547:                                 .getResourceAsStream("isolated/config/APPLICATION-MN.MF")
1:0223547:                 )
1:0223547:                 .binary("org.apache.felix.configadmin.jar", configAdminUrl.openStream())
1:0223547:                 .jar("helloworld-bundle.jar")
1:0223547:                 .manifest()
1:0223547:                 .symbolicName("org.apache.aries.isolated.helloworldmn")
1:0223547:                 .attribute("Bundle-Version", "1.0.0")
1:0223547:                 .attribute("Bundle-Activator", "org.apache.aries.isolated.config.HelloWorldManagedServiceImpl")
1:0223547:                 .attribute("Import-Package", "org.osgi.framework,org.osgi.service.cm")
1:0223547:                 .end()
1:0223547:                 .binary("org/apache/aries/isolated/sample/HelloWorld.class",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:0223547:                                 "org/apache/aries/isolated/sample/HelloWorld.class")
1:0223547:                 )
1:0223547:                 .binary("org/apache/aries/isolated/sample/HelloWorldImpl.class",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:0223547:                                 "org/apache/aries/isolated/sample/HelloWorldImpl.class")
1:0223547:                 )
1:0223547:                 .binary("org/apache/aries/isolated/config/HelloWorldManagedServiceImpl.class",
1:0223547:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:0223547:                                 "org/apache/aries/isolated/config/HelloWorldManagedServiceImpl.class")
1:0223547:                 ).end();
1:f82abd8: 
1:f82abd8:         FileOutputStream fout = new FileOutputStream(APP_HWBP);
1:f82abd8:         helloWorldBluePrintEba.writeOut(fout);
1:f82abd8:         fout.close();
1:f82abd8: 
1:f82abd8:         fout = new FileOutputStream(APP_HWMN);
1:f82abd8:         helloWorldManualEba.writeOut(fout);
1:f82abd8:         fout.close();
1:8069959:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Try and clean up the applications created by {@link #constructApplications()}
1:f34e6a1:      */
1:f82abd8:     @After
1:f82abd8:     public void deleteApplications() {
1:f82abd8:         for (String application : APPLICATIONS) {
1:f82abd8:             File eba = new File(application);
1:0223547: 
1:f82abd8:             if (eba.exists()) {
1:f82abd8:                 eba.delete();
1:f34e6a1:             }
1:8069959:         }
7:f82abd8:     }
1:f34e6a1: 
1:f82abd8:     /**
1:f82abd8:      * The purpose of this test is to make sure an application that contains an config admin bundle
1:f82abd8:      * can be used by Blueprint. The following steps are performed:
1:0223547:      * <p/>
1:0223547:      * - install the application
1:0223547:      * - start the application
1:0223547:      * - assert we have the following services in the isolated service registry (ConfigurationAdmin, ManagedService, HelloWorld)
1:0223547:      * - assert no configuration existed when the CM-PPH was invoked by BP (default message will be the token i.e. ${message})
1:0223547:      * - update the configuration (the message) for the PID (using a primitive boundary proxy), this will cause the blueprint container to reload
1:0223547:      * - check that the re-registered HelloWorld service contains the updated message
1:0223547:      * - clean up
1:0223547:      *
1:f82abd8:      * @throws Exception
1:f34e6a1:      */
1:f82abd8:     @Test
1:0223547:     @Ignore
1:f82abd8:     public void testIsolatedCfgAdminBPReload() throws Exception {
1:f82abd8:         validateApplicationConfiguration(
1:0223547:                 APP_HWBP,
1:0223547:                 "org.apache.aries.helloworldbpapp",
1:0223547:                 "helloworld-bp",
1:0223547:                 "${message}",
1:f82abd8:                 "blueprint");
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * The purpose of this test is to make sure an application that contains an config admin bundle
1:f82abd8:      * can be used by manually. The following steps are performed:
1:0223547:      * <p/>
1:0223547:      * - install the application
1:0223547:      * - start the application
1:0223547:      * - assert we have the following services in the isolated service registry (ConfigurationAdmin, ManagedService, HelloWorld)
1:0223547:      * - assert no configuration existed when the CM-PPH was invoked by BP (default message will be the token i.e. ${message})
1:0223547:      * - update the configuration (the message) for the PID (using a primitive boundary proxy), this will cause the HW service to be re-registered ({@link org.apache.aries.isolated.config.HelloWorldManagedServiceImpl}
1:0223547:      * - check that the re-registered HelloWorld service contains the updated message
1:0223547:      * - clean up
1:0223547:      *
1:f82abd8:      * @throws Exception
1:f82abd8:      */
1:f82abd8:     @Test
1:0223547:     @Ignore
1:0223547:     public void testIsolatedCfgAdminManualReload() throws Exception {
1:f82abd8:         validateApplicationConfiguration(
1:0223547:                 APP_HWMN,
1:0223547:                 "org.apache.aries.helloworldmnapp",
1:0223547:                 "helloworld-mn",
1:0223547:                 (new HelloWorldImpl()).getMessage(),
1:f82abd8:                 "manual");
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Central validation method for verifying configuration can be published and consumed correctly within
1:f82abd8:      * an isolated scope.
1:0223547:      *
1:0223547:      * @param application     the application file name
1:f82abd8:      * @param applicationName the application name
1:0223547:      * @param pid             the service.pid
1:0223547:      * @param defaultMessage  the default message for the HelloWorld service (checked before any configuration updates occur)
1:0223547:      * @param newMessage      the new message to set during a configuration update
1:f82abd8:      * @throws Exception
1:f82abd8:      */
1:f82abd8:     private void validateApplicationConfiguration(String application, String applicationName, String pid, String defaultMessage, String newMessage) throws Exception {
1:0223547: 
1:f82abd8:         //install and start the application
1:f82abd8:         Context ctx = installApplication(FileSystem.getFSRoot(new File(application)), applicationName);
1:0223547: 
1:f82abd8:         //assert we have the services that we're expecting
1:f82abd8:         assertExpectedServices(ctx.getBundleContext(), pid);
1:0223547: 
1:f82abd8:         //make sure we have the defaults set
1:f82abd8:         Assert.assertEquals("Invalid message set on the HW service", defaultMessage, IsolationTestUtils.findHelloWorldService(ctx.getBundleContext()).getMessage());
1:8069959: 
1:f82abd8:         //cause a configuration update to occur which should reload our HW service
1:f82abd8:         Dictionary<String, String> dictionary = new Hashtable<String, String>();
1:f82abd8:         dictionary.put("message", newMessage);
1:f82abd8:         Assert.assertTrue("Configuration update failed", executeConfigurationUpdate(ctx.getBundleContext(), pid, dictionary));
1:0223547: 
1:f82abd8:         //now make sure we have our new message set in the HW service
1:f82abd8:         Assert.assertEquals("Invalid message set on the HW service", newMessage, IsolationTestUtils.findHelloWorldService(ctx.getBundleContext()).getMessage());
1:0223547: 
1:f82abd8:         //clean up
1:f82abd8:         uninstallApplication(ctx);
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Executes a configuration update using the given dictionary. A HelloWorld service will be tracked
1:f82abd8:      * to ensure the configuration was successful (listening for add/remove tracker events).
1:0223547:      *
1:0223547:      * @param ctx        the application bundle context
1:0223547:      * @param pid        the service-pid to track
1:f82abd8:      * @param dictionary the dictionary containing updated properties
1:f82abd8:      * @return if the configuration update was successful
1:f82abd8:      * @throws Exception
1:f82abd8:      */
1:f82abd8:     private boolean executeConfigurationUpdate(BundleContext ctx, String pid, Dictionary<String, String> dictionary) throws Exception {
1:f82abd8:         boolean result = true;
1:f82abd8:         MonitorTask monitor = new MonitorTask(ctx, "(" + Constants.OBJECTCLASS + "=" + HelloWorld.class.getName() + ")", 2, 1);
1:0223547: 
1:f82abd8:         try {
1:f82abd8:             monitor.beginTracking();
1:f82abd8:             result &= (new ConfigurationTask(ctx, pid, dictionary)).execute();
1:f82abd8:             result &= monitor.execute();
1:0223547:         } finally {
1:f82abd8:             monitor.endTracking();
1:f82abd8:         }
1:0223547: 
1:f82abd8:         return result;
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Assert that the following services are present in the service registry:
1:0223547:      * <p/>
1:0223547:      * - ConfigurationAdmin
1:0223547:      * - ManagedService
1:0223547:      * - HelloWorld
1:0223547:      *
1:f82abd8:      * @param ctx the bundle context
1:f82abd8:      * @param pid the service pid used to register the underlying ManagedService
1:f82abd8:      * @throws Exception
1:f82abd8:      */
1:f82abd8:     private void assertExpectedServices(RichBundleContext ctx, String pid) throws Exception {
1:f82abd8:         //assert the CfgAdmin service was registered
1:f82abd8:         Assert.assertNotNull("Missing the ConfigurationAdmin service", ctx.getService(ConfigurationAdmin.class));
1:0223547: 
1:f82abd8:         //assert we have the ManagedService exposed
1:f82abd8:         Assert.assertNotNull("Missing the Managed service", ctx.getService(ManagedService.class, "(" + Constants.SERVICE_PID + "=" + pid + ")"));
1:f82abd8:         //now just make sure we can see it through the context of our config admin bundle context (should be in the same scope)
1:f82abd8:         ServiceReference ref = ctx.getServiceReference(ConfigurationAdmin.class.getName());
1:f82abd8:         Assert.assertNotNull("Couldn't find the ManagedService using the ConfigAdmin bundle context", new RichBundleContext(ref.getBundle().getBundleContext()).getService(ManagedService.class, "(" + Constants.SERVICE_PID + "=" + pid + ")"));
1:0223547: 
1:f82abd8:         //make sure we have the helloworld service registered
1:f82abd8:         HelloWorld helloWorldBluePrint = IsolationTestUtils.findHelloWorldService(ctx);
1:0223547:         Assert.assertNotNull("Missing the HelloWorld service", helloWorldBluePrint);
1:f82abd8:     }
1:0223547: 
1:f82abd8:     private Context installApplication(IDirectory application, String applicationName) throws Exception {
1:f82abd8:         //install the application and start it
1:f82abd8:         AriesApplicationManager appManager = context().getService(AriesApplicationManager.class);
1:f82abd8:         AriesApplication app = appManager.createApplication(application);
1:f82abd8:         AriesApplicationContext appCtx = appManager.install(app);
1:f82abd8:         appCtx.start();
1:8069959: 
1:f82abd8:         return new Context(appCtx, IsolationTestUtils.findIsolatedAppBundleContext(context(), applicationName));
1:f82abd8:     }
1:0223547: 
1:f82abd8:     private void uninstallApplication(Context ctx) throws Exception {
1:f82abd8:         AriesApplicationManager appManager = context().getService(AriesApplicationManager.class);
1:f82abd8:         appManager.uninstall(ctx.getApplicationContext());
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Create the configuration for the PAX container
1:0223547:      *
1:f82abd8:      * @return the various required options
1:f82abd8:      * @throws Exception
1:f82abd8:      */
1:0223547:     @org.ops4j.pax.exam.Configuration
1:0223547:     public static Option[] configuration() throws Exception {
1:0223547:         return options(
1:f82abd8: 
1:0223547:                 // framework / core bundles
1:0223547:                 mavenBundle("org.osgi", "org.osgi.core").versionAsInProject(),
1:0223547:                 mavenBundle("org.ops4j.pax.logging", "pax-logging-api").versionAsInProject(),
1:0223547:                 mavenBundle("org.ops4j.pax.logging", "pax-logging-service").versionAsInProject(),
1:0223547: 
1:0223547:                 // Repository
1:0223547:                 repository("http://repository.ops4j.org/maven2"),
1:0223547: 
1:0223547:                 // Logging
1:0223547:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1:0223547: 
1:0223547:                 // Bundles
1:0223547:                 junitBundles(),
1:0223547:                 mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit").versionAsInProject(),
1:0223547: 
1:0223547:                 // Bundles
1:0223547:                 mavenBundle("org.apache.aries.blueprint", "org.apache.aries.blueprint").versionAsInProject(),
1:0223547:                 mavenBundle("org.ow2.asm", "asm-all").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.proxy", "org.apache.aries.proxy").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.transaction", "org.apache.aries.transaction.blueprint").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries", "org.apache.aries.util").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.api").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.default.local.platform").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.resolver.obr").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.resolve.transform.cm").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.deployment.management").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.management").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.isolated").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.framework").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.framework.management").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.repository").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.felix", "org.apache.felix.configadmin").versionAsInProject(),
1:0223547:                 mavenBundle("org.apache.geronimo.specs", "geronimo-jta_1.1_spec").versionAsInProject(),
1:0223547:                 mavenBundle("org.ops4j.pax.url", "pax-url-aether").versionAsInProject());
1:f82abd8:     }
1:f82abd8: 
1:f82abd8:     /**
1:f82abd8:      * High level interface for executing a unit of work
1:f82abd8:      *
1:f82abd8:      * @version $Rev$ $Date$
1:f82abd8:      */
1:0223547:     private static interface Task {
1:f82abd8:         /**
1:f82abd8:          * Executes the task logic
1:0223547:          *
1:f82abd8:          * @return if the task was successful
1:f82abd8:          * @throws Exception
1:f82abd8:          */
1:f82abd8:         public boolean execute() throws Exception;
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Base class for a task implementation
1:f82abd8:      *
1:f82abd8:      * @version $Rev$ $Date$
1:f82abd8:      */
1:0223547:     private static abstract class BaseTask implements Task {
1:f82abd8:         private BundleContext ctx;
1:0223547: 
1:f82abd8:         public BaseTask(BundleContext ctx) {
1:f82abd8:             this.ctx = ctx;
1:f82abd8:         }
1:0223547: 
1:f82abd8:         protected BundleContext getBundleContext() {
1:f82abd8:             return ctx;
1:f82abd8:         }
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Trackable task that allows a service tracker to pickup service registration/un-registration events using the
1:f82abd8:      * supplied filter. Remember that if a service exists matching a filter while opening the underlying tracker
1:f82abd8:      * it will cause a addedService event to be fired, this must be taken into account when instantiating this type
1:f82abd8:      * task. For example if you had a ManagedService present in the container matching the given filter, you should
1:f82abd8:      * set the expected registerCount as 2 if you expect a re-register to occur due to a container reload etc.
1:f82abd8:      *
1:f82abd8:      * @version $Rev$ $Date$
1:f82abd8:      */
1:0223547:     public static abstract class TrackableTask extends BaseTask implements Task, ServiceTrackerCustomizer {
1:f82abd8:         private static final long DEFAULT_TIMEOUT = 5000;
1:0223547: 
1:f82abd8:         private String filter;
1:f82abd8:         private ServiceTracker tracker;
1:f82abd8:         private CountDownLatch addedLatch;
1:f82abd8:         private CountDownLatch removedLatch;
1:0223547: 
1:f82abd8:         public TrackableTask(BundleContext ctx, String filter) {
1:f82abd8:             this(ctx, filter, 1, 1);
1:f82abd8:         }
1:0223547: 
1:f82abd8:         public TrackableTask(BundleContext ctx, String filter, int registerCount) {
1:f82abd8:             this(ctx, filter, registerCount, 0);
1:f82abd8:         }
1:0223547: 
1:f82abd8:         public TrackableTask(BundleContext ctx, String filter, int registerCount, int unregisterCount) {
1:f82abd8:             super(ctx);
1:0223547: 
1:f82abd8:             this.filter = filter;
1:f82abd8:             this.addedLatch = new CountDownLatch(registerCount);
1:f82abd8:             this.removedLatch = new CountDownLatch(unregisterCount);
1:f82abd8:             this.tracker = null;
1:f82abd8:         }
1:0223547: 
1:f82abd8:         /**
1:f82abd8:          * Initiates the underlying service tracker
1:0223547:          *
1:f82abd8:          * @throws InvalidSyntaxException
1:f82abd8:          */
1:f82abd8:         protected synchronized void beginTracking() throws InvalidSyntaxException {
1:f82abd8:             if (tracker == null) {
1:f82abd8:                 tracker = new ServiceTracker(getBundleContext(), getBundleContext().createFilter(filter), this);
1:f82abd8:                 tracker.open();
1:f82abd8:             }
1:f82abd8:         }
1:0223547: 
1:f82abd8:         /**
1:f82abd8:          * Stops and clears the underlying service tracker
1:f82abd8:          */
1:f82abd8:         protected synchronized void endTracking() {
1:f82abd8:             if (tracker != null) {
1:f82abd8:                 tracker.close();
1:f82abd8:                 tracker = null;
1:f82abd8:             }
1:f82abd8:         }
1:0223547: 
1:f34e6a1:         /*
1:f82abd8:          * (non-Javadoc)
1:f82abd8:          * @see org.apache.aries.application.runtime.itests.IsolatedCfgAdminRuntimeTest.Task#execute()
1:f82abd8:          */
1:f82abd8:         public boolean execute() throws Exception {
1:f82abd8:             boolean result = true;
1:0223547: 
1:f82abd8:             try {
1:f82abd8:                 beginTracking();
1:f82abd8:                 doExecute();
1:f82abd8: 
1:f82abd8:                 result &= addedLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
1:f82abd8:                 result &= removedLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
1:0223547:             } finally {
1:f82abd8:                 endTracking();
1:f82abd8:             }
1:0223547: 
1:f82abd8:             return result;
1:f82abd8:         }
1:0223547: 
1:f34e6a1:         /*
1:f82abd8:          * (non-Javadoc)
1:f82abd8:          * @see org.osgi.util.tracker.ServiceTrackerCustomizer#addingService(org.osgi.framework.ServiceReference)
1:f82abd8:          */
1:f82abd8:         public synchronized Object addingService(ServiceReference serviceRef) {
1:f82abd8:             addedLatch.countDown();
1:f82abd8:             return serviceRef;
1:f82abd8:         }
1:f82abd8: 
1:f82abd8:         /*
1:f82abd8:          * (non-Javadoc)
1:f82abd8:          * @see org.osgi.util.tracker.ServiceTrackerCustomizer#modifiedService(org.osgi.framework.ServiceReference, java.lang.Object)
1:f82abd8:          */
1:0223547:         public void modifiedService(ServiceReference serviceRef, Object service) {
1:f82abd8:         }
1:f82abd8: 
1:f82abd8:         /*
1:f82abd8:          * (non-Javadoc)
1:f82abd8:          * @see org.osgi.util.tracker.ServiceTrackerCustomizer#removedService(org.osgi.framework.ServiceReference, java.lang.Object)
1:f82abd8:          */
1:f82abd8:         public synchronized void removedService(ServiceReference serviceRef, Object service) {
1:f82abd8:             removedLatch.countDown();
1:f82abd8:         }
1:0223547: 
1:f82abd8:         /**
1:f82abd8:          * Performs the task logic
1:0223547:          *
1:f82abd8:          * @throws Exception
1:f82abd8:          */
1:f82abd8:         protected abstract void doExecute() throws Exception;
1:f82abd8:     }
1:f82abd8: 
1:f82abd8:     /**
1:f82abd8:      * The configuration task is responsible for executing a configuration update within the scope
1:f82abd8:      * of the given context. Note, this task assumes the class space is inconsistent will not try
1:f82abd8:      * casting to classes that may exist in the test world and also in the application.
1:0223547:      *
1:f82abd8:      * @version $Rev$ $Date$
1:f82abd8:      */
1:0223547:     private static class ConfigurationTask extends BaseTask {
1:f82abd8:         private String pid;
1:f82abd8:         private Dictionary<String, String> dictionary;
1:0223547: 
1:0223547:         public ConfigurationTask(BundleContext ctx, String pid, Dictionary<String, String> dictionary) {
1:f82abd8:             super(ctx);
1:0223547: 
1:f82abd8:             this.pid = pid;
1:f82abd8:             this.dictionary = dictionary;
1:f82abd8:         }
1:f82abd8: 
1:f82abd8:         /*
1:f82abd8:          * (non-Javadoc)
1:f82abd8:          * @see org.apache.aries.application.runtime.itests.IsolatedCfgAdminRuntimeTest.Task#execute()
1:f82abd8:          */
1:f82abd8:         public boolean execute() throws Exception {
1:f82abd8:             boolean result = false;
1:0223547:             ServiceTracker tracker = new ServiceTracker(getBundleContext(), getBundleContext().createFilter("(" + Constants.OBJECTCLASS + "=" + ConfigurationAdmin.class.getName() + ")"), null);
1:0223547: 
1:f82abd8:             try {
1:f82abd8:                 tracker.open();
1:f82abd8:                 Object cfgAdminService = tracker.waitForService(5000);
1:0223547: 
1:f82abd8:                 if (cfgAdminService != null) {
1:0223547: 
1:f82abd8:                     ConfigurationAdmin proxy = Skeleton.newMock(cfgAdminService, ConfigurationAdmin.class);
1:f82abd8:                     Configuration configuration = proxy.getConfiguration(pid);
1:f82abd8:                     configuration.setBundleLocation(null);
1:f82abd8:                     configuration.update(dictionary);
1:f82abd8:                     result = true;
1:f82abd8:                 }
1:0223547:             } finally {
1:f82abd8:                 tracker.close();
1:f82abd8:             }
1:0223547: 
1:f82abd8:             return result;
1:f82abd8:         }
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Simple monitor class to keep track of services using the supplied filter, acts as a wrapper
1:f82abd8:      * so that it can be placed in side a composite task.
1:f82abd8:      *
1:f82abd8:      * @version $Rev$ $Date$
1:f82abd8:      */
1:0223547:     private static final class MonitorTask extends TrackableTask {
1:f82abd8:         public MonitorTask(BundleContext ctx, String filter, int registerCount, int unregisterCount) {
1:f82abd8:             super(ctx, filter, registerCount, unregisterCount);
1:f82abd8:         }
1:0223547: 
1:f82abd8:         /*
1:f82abd8:          * (non-Javadoc)
1:f82abd8:          * @see org.apache.aries.application.runtime.itests.IsolatedCfgAdminRuntimeTest.TrackableTask#doExecute()
1:f82abd8:          */
1:f82abd8:         @Override
1:f82abd8:         protected void doExecute() throws Exception {
1:f82abd8:             //do nothing, we just care about tracking
1:f82abd8:         }
1:0223547: 
1:f82abd8:     }
1:0223547: 
1:f82abd8:     /**
1:f82abd8:      * Simple wrapper for the various contexts required in this test suite
1:f82abd8:      *
1:f82abd8:      * @version $Rev$ $Date$
1:f82abd8:      */
1:0223547:     private static class Context {
1:f82abd8:         private AriesApplicationContext applicationContext;
1:f82abd8:         private RichBundleContext bundleContext;
1:0223547: 
1:f82abd8:         public Context(AriesApplicationContext applicationContext, BundleContext bundleContext) {
1:f82abd8:             this.applicationContext = applicationContext;
1:f82abd8:             this.bundleContext = new RichBundleContext(bundleContext);
1:f82abd8:         }
1:0223547: 
1:f82abd8:         public AriesApplicationContext getApplicationContext() {
1:f82abd8:             return applicationContext;
1:f82abd8:         }
1:0223547: 
1:f82abd8:         public RichBundleContext getBundleContext() {
1:f82abd8:             return bundleContext;
1:f82abd8:         }
1:f82abd8:     }
1:0223547: 
1:0223547:     public static MavenArtifactProvisionOption mavenBundleInTest(ClassLoader loader, String groupId, String artifactId) {
1:0223547:         return mavenBundle().groupId(groupId).artifactId(artifactId)
1:0223547:                 .version(getArtifactVersion(loader, groupId, artifactId));
1:0223547:     }
1:0223547: 
1:0223547:     //TODO getArtifactVersion and getFileFromClasspath are borrowed and modified from pax-exam.  They should be moved back ASAP.
1:0223547:     private static String getArtifactVersion(ClassLoader loader, final String groupId, final String artifactId) {
1:0223547:         final Properties dependencies = new Properties();
1:0223547:         try {
1:0223547:             InputStream in = getFileFromClasspath(loader, "META-INF/maven/dependencies.properties");
1:0223547:             try {
1:0223547:                 dependencies.load(in);
1:0223547:             } finally {
1:0223547:                 in.close();
1:0223547:             }
1:0223547:             final String version = dependencies.getProperty(groupId + "/" + artifactId + "/version");
1:0223547:             if (version == null) {
1:0223547:                 throw new RuntimeException(
1:0223547:                         "Could not resolve version. Do you have a dependency for " + groupId + "/" + artifactId
1:0223547:                                 + " in your maven project?"
1:0223547:                 );
1:0223547:             }
1:0223547:             return version;
1:0223547:         } catch (IOException e) {
1:0223547:             // TODO throw a better exception
1:0223547:             throw new RuntimeException(
1:0223547:                     "Could not resolve version. Did you configured the plugin in your maven project?"
1:0223547:                             + "Or maybe you did not run the maven build and you are using an IDE?"
1:0223547:             );
1:0223547:         }
1:0223547:     }
1:0223547: 
1:0223547:     private static InputStream getFileFromClasspath(ClassLoader loader, final String filePath)
1:0223547:             throws FileNotFoundException {
1:0223547:         try {
1:0223547:             URL fileURL = loader.getResource(filePath);
1:0223547:             if (fileURL == null) {
1:0223547:                 throw new FileNotFoundException("File [" + filePath + "] could not be found in classpath");
1:0223547:             }
1:0223547:             return fileURL.openStream();
1:0223547:         } catch (IOException e) {
1:0223547:             throw new FileNotFoundException("File [" + filePath + "] could not be found: " + e.getMessage());
1:0223547:         }
1:0223547:     }
1:f82abd8: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:e334773
/////////////////////////////////////////////////////////////////////////
author:Jean-Baptiste Onofre
-------------------------------------------------------------------------------
commit:0223547
/////////////////////////////////////////////////////////////////////////
1: import static org.ops4j.pax.exam.CoreOptions.*;
1: import java.io.*;
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Ignore;
1: import org.ops4j.pax.exam.junit.PaxExam;
1: import org.ops4j.pax.exam.spi.reactors.ExamReactorStrategy;
1: import org.ops4j.pax.exam.spi.reactors.PerClass;
/////////////////////////////////////////////////////////////////////////
1:  * <p/>
1:  * <p/>
1:  * admin that resides within the application framework. This will allow the configuration admin bundle
1:  * activator sufficient time to register a config admin service before the blueprint container for the bundle
1:  * <p/>
1:  * <p/>
1:  * configuration admin classes directly, as we register a configuration admin and managed service in the
1:  * Behind the scenes a manifest transformer is used to make sure that the DEPLOYMENT.MF is augmented with the
1: @RunWith(PaxExam.class)
1: @ExamReactorStrategy(PerClass.class)
1: 
1: 
1:      * <p/>
1:      * - helloworld-bp.eba ------
1:      * |
1:      * | This application contains a helloworld bundle which contains an interface and impl for HelloWorld. Upon being started
1:      * | blueprint will create a new container for this bundle and register the HelloWorld service. The service will be injected
1:      * | with a message coming from the ConfigurationAdmin service using the PID: helloworld-bp. As a CM property placeholder is
1:      * | used, a ManagedService will also be registered on the bundles behalf so that further updates can be captured. Note that
1:      * | the blueprint configuration is wired to reload the container on a configuration update (to allow easier tracking of when
1:      * | to test service contents etc).
1:      * |
1:      * | The application also contains a configuration admin bundle (pulled from Maven).
1:      * ---------------------------
1:      * <p/>
1:      * - helloworld-mn.eba -------
1:      * |
1:      * | This application contains a helloworld bundle containing an activator that will register itself as a ManagedService for the
1:      * | PID: helloworld-mn. The activator will also expose out a HelloWorld service. Upon recieving an update from the packaged
1:      * | Configuration Admin service, the HelloWorld service will be re-registered using the latest configuration, namely the "message".
1:      * |
1:      * | The application also contains a configuration admin bundle (pulled from Maven).
1:      * ---------------------------
1:      *
1:     public void constructApplications() throws Exception {
1: 
1: 
1:                 .binary("META-INF/APPLICATION.MF",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader()
1:                                 .getResourceAsStream("isolated/config/APPLICATION-BP.MF")
1:                 )
1:                 .binary("org.apache.felix.configadmin.jar", configAdminUrl.openStream())
1:                 .jar("helloworld-bundle.jar")
1:                 .manifest()
1:                 .symbolicName("org.apache.aries.isolated.helloworldbp")
1:                 .attribute("Bundle-Version", "1.0.0")
1:                 .attribute("Import-Package", "org.osgi.service.cm")
1:                 .end()
1:                 .binary("org/apache/aries/isolated/sample/HelloWorld.class",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:                                 "org/apache/aries/isolated/sample/HelloWorld.class")
1:                 )
1:                 .binary("org/apache/aries/isolated/sample/HelloWorldImpl.class",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:                                 "org/apache/aries/isolated/sample/HelloWorldImpl.class")
1:                 )
1:                 .binary("OSGI-INF/blueprint/blueprint.xml",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader()
1:                                 .getResourceAsStream("isolated/config/blueprint.xml")
1:                 ).end();
1:                 .binary("META-INF/APPLICATION.MF",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader()
1:                                 .getResourceAsStream("isolated/config/APPLICATION-MN.MF")
1:                 )
1:                 .binary("org.apache.felix.configadmin.jar", configAdminUrl.openStream())
1:                 .jar("helloworld-bundle.jar")
1:                 .manifest()
1:                 .symbolicName("org.apache.aries.isolated.helloworldmn")
1:                 .attribute("Bundle-Version", "1.0.0")
1:                 .attribute("Bundle-Activator", "org.apache.aries.isolated.config.HelloWorldManagedServiceImpl")
1:                 .attribute("Import-Package", "org.osgi.framework,org.osgi.service.cm")
1:                 .end()
1:                 .binary("org/apache/aries/isolated/sample/HelloWorld.class",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:                                 "org/apache/aries/isolated/sample/HelloWorld.class")
1:                 )
1:                 .binary("org/apache/aries/isolated/sample/HelloWorldImpl.class",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:                                 "org/apache/aries/isolated/sample/HelloWorldImpl.class")
1:                 )
1:                 .binary("org/apache/aries/isolated/config/HelloWorldManagedServiceImpl.class",
1:                         IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
1:                                 "org/apache/aries/isolated/config/HelloWorldManagedServiceImpl.class")
1:                 ).end();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * <p/>
1:      * - install the application
1:      * - start the application
1:      * - assert we have the following services in the isolated service registry (ConfigurationAdmin, ManagedService, HelloWorld)
1:      * - assert no configuration existed when the CM-PPH was invoked by BP (default message will be the token i.e. ${message})
1:      * - update the configuration (the message) for the PID (using a primitive boundary proxy), this will cause the blueprint container to reload
1:      * - check that the re-registered HelloWorld service contains the updated message
1:      * - clean up
1:      *
1:     @Ignore
1:                 APP_HWBP,
1:                 "org.apache.aries.helloworldbpapp",
1:                 "helloworld-bp",
1:                 "${message}",
1: 
1:      * <p/>
1:      * - install the application
1:      * - start the application
1:      * - assert we have the following services in the isolated service registry (ConfigurationAdmin, ManagedService, HelloWorld)
1:      * - assert no configuration existed when the CM-PPH was invoked by BP (default message will be the token i.e. ${message})
1:      * - update the configuration (the message) for the PID (using a primitive boundary proxy), this will cause the HW service to be re-registered ({@link org.apache.aries.isolated.config.HelloWorldManagedServiceImpl}
1:      * - check that the re-registered HelloWorld service contains the updated message
1:      * - clean up
1:      *
1:     @Ignore
1:     public void testIsolatedCfgAdminManualReload() throws Exception {
1:                 APP_HWMN,
1:                 "org.apache.aries.helloworldmnapp",
1:                 "helloworld-mn",
1:                 (new HelloWorldImpl()).getMessage(),
1: 
1:      *
1:      * @param application     the application file name
1:      * @param pid             the service.pid
1:      * @param defaultMessage  the default message for the HelloWorld service (checked before any configuration updates occur)
1:      * @param newMessage      the new message to set during a configuration update
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:      *
1:      * @param ctx        the application bundle context
1:      * @param pid        the service-pid to track
/////////////////////////////////////////////////////////////////////////
1: 
1:         } finally {
1: 
1: 
1:      * <p/>
1:      * - ConfigurationAdmin
1:      * - ManagedService
1:      * - HelloWorld
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         Assert.assertNotNull("Missing the HelloWorld service", helloWorldBluePrint);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
1:     @org.ops4j.pax.exam.Configuration
1:     public static Option[] configuration() throws Exception {
1:         return options(
1:                 // framework / core bundles
1:                 mavenBundle("org.osgi", "org.osgi.core").versionAsInProject(),
0:                 mavenBundle("org.osgi", "org.osgi.compendium").versionAsInProject(),
1:                 mavenBundle("org.ops4j.pax.logging", "pax-logging-api").versionAsInProject(),
1:                 mavenBundle("org.ops4j.pax.logging", "pax-logging-service").versionAsInProject(),
1: 
1:                 // Repository
1:                 repository("http://repository.ops4j.org/maven2"),
1: 
1:                 // Logging
1:                 systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("INFO"),
1: 
1:                 // Bundles
1:                 junitBundles(),
1:                 mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit").versionAsInProject(),
1: 
1:                 // Bundles
1:                 mavenBundle("org.apache.aries.blueprint", "org.apache.aries.blueprint").versionAsInProject(),
1:                 mavenBundle("org.ow2.asm", "asm-all").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.proxy", "org.apache.aries.proxy").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.transaction", "org.apache.aries.transaction.blueprint").versionAsInProject(),
1:                 mavenBundle("org.apache.aries", "org.apache.aries.util").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.api").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.default.local.platform").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").versionAsInProject(),
1:                 mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.resolver.obr").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.resolve.transform.cm").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.deployment.management").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.management").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.isolated").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.framework").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.framework.management").versionAsInProject(),
1:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.repository").versionAsInProject(),
1:                 mavenBundle("org.apache.felix", "org.apache.felix.configadmin").versionAsInProject(),
1:                 mavenBundle("org.apache.geronimo.specs", "geronimo-jta_1.1_spec").versionAsInProject(),
1:                 mavenBundle("org.ops4j.pax.url", "pax-url-aether").versionAsInProject());
1:     private static interface Task {
1:          *
1: 
1:     private static abstract class BaseTask implements Task {
1: 
1: 
1: 
1:     public static abstract class TrackableTask extends BaseTask implements Task, ServiceTrackerCustomizer {
1: 
1: 
1: 
1: 
1: 
1: 
1:          *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             } finally {
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         public void modifiedService(ServiceReference serviceRef, Object service) {
/////////////////////////////////////////////////////////////////////////
1: 
1:          *
/////////////////////////////////////////////////////////////////////////
1:      *
1:     private static class ConfigurationTask extends BaseTask {
1: 
1:         public ConfigurationTask(BundleContext ctx, String pid, Dictionary<String, String> dictionary) {
1: 
/////////////////////////////////////////////////////////////////////////
1:             ServiceTracker tracker = new ServiceTracker(getBundleContext(), getBundleContext().createFilter("(" + Constants.OBJECTCLASS + "=" + ConfigurationAdmin.class.getName() + ")"), null);
1: 
1: 
1: 
1:             } finally {
1: 
1: 
1:     private static final class MonitorTask extends TrackableTask {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     private static class Context {
1: 
1: 
1: 
1: 
1:     public static MavenArtifactProvisionOption mavenBundleInTest(ClassLoader loader, String groupId, String artifactId) {
1:         return mavenBundle().groupId(groupId).artifactId(artifactId)
1:                 .version(getArtifactVersion(loader, groupId, artifactId));
1:     }
1: 
1:     //TODO getArtifactVersion and getFileFromClasspath are borrowed and modified from pax-exam.  They should be moved back ASAP.
1:     private static String getArtifactVersion(ClassLoader loader, final String groupId, final String artifactId) {
1:         final Properties dependencies = new Properties();
1:         try {
1:             InputStream in = getFileFromClasspath(loader, "META-INF/maven/dependencies.properties");
1:             try {
1:                 dependencies.load(in);
1:             } finally {
1:                 in.close();
1:             }
1:             final String version = dependencies.getProperty(groupId + "/" + artifactId + "/version");
1:             if (version == null) {
1:                 throw new RuntimeException(
1:                         "Could not resolve version. Do you have a dependency for " + groupId + "/" + artifactId
1:                                 + " in your maven project?"
1:                 );
1:             }
1:             return version;
1:         } catch (IOException e) {
1:             // TODO throw a better exception
1:             throw new RuntimeException(
1:                     "Could not resolve version. Did you configured the plugin in your maven project?"
1:                             + "Or maybe you did not run the maven build and you are using an IDE?"
1:             );
1:         }
1:     }
1: 
1:     private static InputStream getFileFromClasspath(ClassLoader loader, final String filePath)
1:             throws FileNotFoundException {
1:         try {
1:             URL fileURL = loader.getResource(filePath);
1:             if (fileURL == null) {
1:                 throw new FileNotFoundException("File [" + filePath + "] could not be found in classpath");
1:             }
1:             return fileURL.openStream();
1:         } catch (IOException e) {
1:             throw new FileNotFoundException("File [" + filePath + "] could not be found: " + e.getMessage());
1:         }
1:     }
author:John Ross
-------------------------------------------------------------------------------
commit:cffbcb0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.ops4j.pax.exam.junit.MavenConfiguredJUnit4TestRunner;
/////////////////////////////////////////////////////////////////////////
0: @RunWith(MavenConfiguredJUnit4TestRunner.class)
/////////////////////////////////////////////////////////////////////////
0:     public static Option[] configuration() throws Exception
0:   			  PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties")        
commit:f34e6a1
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * Commented out to avoid an NPE due to a ConcurrentModificationException in
0:      * the Aries build. See https://issues.apache.org/jira/browse/ARIES-931.
1:      */
0:     //@org.ops4j.pax.exam.junit.Configuration
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * Commented out to avoid an NPE due to a ConcurrentModificationException in
0:      * the Aries build. See https://issues.apache.org/jira/browse/ARIES-931.
1:      */
0:     //@org.ops4j.pax.exam.junit.Configuration
/////////////////////////////////////////////////////////////////////////
1:     
0:     @org.ops4j.pax.exam.junit.Configuration
0:     public static Option[] equinox38Options() throws Exception
0:     {
0:   	  return testOptions(
0:   			  generalConfiguration(),
0:   			  PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),          
0:   	          equinox().version("3.8.0.V20120529-1548")
0:   	          );
1:     }
author:Holly Cummins
-------------------------------------------------------------------------------
commit:8069959
/////////////////////////////////////////////////////////////////////////
0: import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
/////////////////////////////////////////////////////////////////////////
0:     private static Option[] generalConfiguration() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                 mavenBundle("org.ops4j.pax.url", "pax-url-mvn"));
1:     }
1: 
0:     @org.ops4j.pax.exam.junit.Configuration
0:     public static Option[] equinox35Options() throws Exception
0:     {
0:   	  return testOptions(
0:   			  generalConfiguration(),
0:   	          equinox().version("3.5.0")
0:   	          );
1:     }
1: 
0:     @org.ops4j.pax.exam.junit.Configuration
0:     public static Option[] equinox37Options() throws Exception
0:     {
0:   	  return testOptions(
0:   			  generalConfiguration(),
0:   			  PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),          
0:   	          equinox().version("3.7.0.v20110613")
0:   	          );
author:Emily Jiang
-------------------------------------------------------------------------------
commit:2b7f337
/////////////////////////////////////////////////////////////////////////
0:                 mavenBundle("org.ow2.asm", "asm-all"),
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:f82abd8
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.application.runtime.itests;
1: 
0: //import static org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption;
1: 
0: import static org.apache.aries.itest.ExtraOptions.mavenBundle;
0: import static org.apache.aries.itest.ExtraOptions.mavenBundleInTest;
0: import static org.apache.aries.itest.ExtraOptions.paxLogging;
0: import static org.apache.aries.itest.ExtraOptions.testOptions;
0: import static org.ops4j.pax.exam.CoreOptions.equinox;
0: import static org.ops4j.pax.exam.container.def.PaxRunnerOptions.repository;
1: 
0: import java.io.File;
0: import java.io.FileOutputStream;
1: import java.net.URL;
0: import java.util.Arrays;
0: import java.util.Dictionary;
0: import java.util.Hashtable;
0: import java.util.List;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: 
1: import junit.framework.Assert;
1: 
1: import org.apache.aries.application.management.AriesApplication;
1: import org.apache.aries.application.management.AriesApplicationContext;
1: import org.apache.aries.application.management.AriesApplicationManager;
1: import org.apache.aries.application.runtime.itests.util.IsolationTestUtils;
1: import org.apache.aries.isolated.sample.HelloWorld;
1: import org.apache.aries.isolated.sample.HelloWorldImpl;
1: import org.apache.aries.itest.AbstractIntegrationTest;
1: import org.apache.aries.itest.RichBundleContext;
1: import org.apache.aries.unittest.fixture.ArchiveFixture;
1: import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
1: import org.apache.aries.unittest.mocks.Skeleton;
1: import org.apache.aries.util.filesystem.FileSystem;
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: import org.ops4j.pax.exam.Option;
0: import org.ops4j.pax.exam.junit.JUnit4TestRunner;
1: import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.service.cm.Configuration;
1: import org.osgi.service.cm.ConfigurationAdmin;
1: import org.osgi.service.cm.ManagedService;
1: import org.osgi.service.url.URLStreamHandlerService;
1: import org.osgi.util.tracker.ServiceTracker;
1: import org.osgi.util.tracker.ServiceTrackerCustomizer;
1: 
1: /**
1:  * This test suite is responsible for validating that an application can package and use the
1:  * isolated configuration admin deployed. This includes both from Blueprint and manually.
1:  * 
1:  * Blueprint Specific:
1:  * 
1:  * Note that, the CmNamespaceHandler has been rewired to create a service reference to the configuration
0:  * admin that resides within the application framework. This will allow the configuration admin bundle 
0:  * activator sufficient time to register a config admin service before the blueprint container for the bundle 
1:  * requiring it is started (i.e. no configuration admin race condition).
1:  * 
1:  * Other notes:
1:  * 
1:  * In order to avoid boundary issues (i.e. class casting exceptions etc), the actual configuration admin bundle
1:  * classes are loaded from the shared framework. This is necessary as the blueprint-cm bundle refers to the
0:  * configuration admin classes directly, as we register a configuration admin and managed service in the 
1:  * application scope, any attempt to use those services from the CM bundle would end up in a class cast exception.
1:  * This is why we use the classes already loaded in the root container, which are imported into the shared framework.
0:  * Behind the scenes a manifest transformer is used to make sure that the DEPLOYMENT.MF is augmented with the 
1:  * necessary org.osgi.service.cm package import to make the class space consistent everywhere. From the developers
1:  * perspective, it appears as if they are deploying into a flat container as the wiring magic is hidden when the
1:  * application is created and installed. Note that the config package import only includes the CM API, nothing else.
1:  *
1:  * @version $Rev$ $Date$
1:  */
0: @RunWith(JUnit4TestRunner.class)
1: public class IsolatedCfgAdminRuntimeTest extends AbstractIntegrationTest {
1:     
1:     private static final String APP_HWBP = "helloworld-bp.eba";
1:     private static final String APP_HWMN = "helloworld-mn.eba";
1:     private static final List<String> APPLICATIONS = Arrays.asList(APP_HWBP, APP_HWMN);
1:     
1:     /**
1:      * Creates two applications, as follows:
1:      * 
0:      *      - helloworld-bp.eba ------
0:      *      |
0:      *      | This application contains a helloworld bundle which contains an interface and impl for HelloWorld. Upon being started
0:      *      | blueprint will create a new container for this bundle and register the HelloWorld service. The service will be injected
0:      *      | with a message coming from the ConfigurationAdmin service using the PID: helloworld-bp. As a CM property placeholder is
0:      *      | used, a ManagedService will also be registered on the bundles behalf so that further updates can be captured. Note that
0:      *      | the blueprint configuration is wired to reload the container on a configuration update (to allow easier tracking of when 
0:      *      | to test service contents etc).
0:      *      |
0:      *      | The application also contains a configuration admin bundle (pulled from Maven).
0:      *      ---------------------------
1:      *      
0:      *      - helloworld-mn.eba -------
0:      *      |    
0:      *      | This application contains a helloworld bundle containing an activator that will register itself as a ManagedService for the
0:      *      | PID: helloworld-mn. The activator will also expose out a HelloWorld service. Upon recieving an update from the packaged
0:      *      | Configuration Admin service, the HelloWorld service will be re-registered using the latest configuration, namely the "message".
0:      *      | 
0:      *      | The application also contains a configuration admin bundle (pulled from Maven).
0:      *      ---------------------------
1:      *      
1:      * @throws Exception
1:      */
1:     @Before
0:     public void constructApplications() throws Exception {    
1:         
1:         Assert.assertNotNull("Could not find Maven URL handler", (new RichBundleContext(context())).getService(URLStreamHandlerService.class, "url.handler.protocol=mvn", 300000));
1:         MavenArtifactProvisionOption configAdminProvisionOption = mavenBundleInTest(getClass().getClassLoader(), "org.apache.felix", "org.apache.felix.configadmin");
1:         Assert.assertNotNull("Unable to lookup config admin maven bundle", configAdminProvisionOption);
1:         URL configAdminUrl = new URL(configAdminProvisionOption.getURL());
1:         
1:         ZipFixture helloWorldBluePrintEba = ArchiveFixture
1:                 .newZip()
0:                     .binary("META-INF/APPLICATION.MF",
0:                             IsolatedCfgAdminRuntimeTest.class.getClassLoader()
0:                                     .getResourceAsStream("isolated/config/APPLICATION-BP.MF"))
0:                     .binary("org.apache.felix.configadmin.jar", configAdminUrl.openStream())
0:                     .jar("helloworld-bundle.jar")
0:                         .manifest()
0:                             .symbolicName("org.apache.aries.isolated.helloworldbp")
0:                             .attribute("Bundle-Version", "1.0.0")
0:                             .attribute("Import-Package", "org.osgi.service.cm")
0:                         .end()
0:                         .binary("org/apache/aries/isolated/sample/HelloWorld.class",
0:                                 IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
0:                                         "org/apache/aries/isolated/sample/HelloWorld.class"))
0:                         .binary("org/apache/aries/isolated/sample/HelloWorldImpl.class",
0:                                 IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
0:                                         "org/apache/aries/isolated/sample/HelloWorldImpl.class"))
0:                         .binary("OSGI-INF/blueprint/blueprint.xml",
0:                                 IsolatedCfgAdminRuntimeTest.class.getClassLoader()
0:                                         .getResourceAsStream("isolated/config/blueprint.xml")).end();
1: 
1:         ZipFixture helloWorldManualEba = ArchiveFixture
1:                 .newZip()
0:                     .binary("META-INF/APPLICATION.MF",
0:                             IsolatedCfgAdminRuntimeTest.class.getClassLoader()
0:                                     .getResourceAsStream("isolated/config/APPLICATION-MN.MF"))
0:                     .binary("org.apache.felix.configadmin.jar", configAdminUrl.openStream())
0:                     .jar("helloworld-bundle.jar")
0:                     .manifest()
0:                         .symbolicName("org.apache.aries.isolated.helloworldmn")
0:                         .attribute("Bundle-Version", "1.0.0")
0:                         .attribute("Bundle-Activator", "org.apache.aries.isolated.config.HelloWorldManagedServiceImpl")
0:                         .attribute("Import-Package", "org.osgi.framework,org.osgi.service.cm")
0:                     .end()
0:                     .binary("org/apache/aries/isolated/sample/HelloWorld.class",
0:                             IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
0:                                     "org/apache/aries/isolated/sample/HelloWorld.class"))
0:                     .binary("org/apache/aries/isolated/sample/HelloWorldImpl.class",
0:                             IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
0:                                     "org/apache/aries/isolated/sample/HelloWorldImpl.class"))
0:                     .binary("org/apache/aries/isolated/config/HelloWorldManagedServiceImpl.class",
0:                             IsolatedCfgAdminRuntimeTest.class.getClassLoader().getResourceAsStream(
0:                                     "org/apache/aries/isolated/config/HelloWorldManagedServiceImpl.class")).end();
1: 
1:         FileOutputStream fout = new FileOutputStream(APP_HWBP);
1:         helloWorldBluePrintEba.writeOut(fout);
1:         fout.close();
1: 
1:         fout = new FileOutputStream(APP_HWMN);
1:         helloWorldManualEba.writeOut(fout);
1:         fout.close();
1:     }
1:     
1:     /**
1:      * Try and clean up the applications created by {@link #constructApplications()}
1:      */
1:     @After
1:     public void deleteApplications() {
1:         for (String application : APPLICATIONS) {
1:             File eba = new File(application);
1:             
1:             if (eba.exists()) {
1:                 eba.delete();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * The purpose of this test is to make sure an application that contains an config admin bundle
1:      * can be used by Blueprint. The following steps are performed:
1:      * 
0:      *      - install the application
0:      *      - start the application
0:      *      - assert we have the following services in the isolated service registry (ConfigurationAdmin, ManagedService, HelloWorld)
0:      *      - assert no configuration existed when the CM-PPH was invoked by BP (default message will be the token i.e. ${message})
0:      *      - update the configuration (the message) for the PID (using a primitive boundary proxy), this will cause the blueprint container to reload
0:      *      - check that the re-registered HelloWorld service contains the updated message
0:      *      - clean up
1:      * 
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testIsolatedCfgAdminBPReload() throws Exception {
1:         validateApplicationConfiguration(
0:                 APP_HWBP, 
0:                 "org.apache.aries.helloworldbpapp", 
0:                 "helloworld-bp", 
0:                 "${message}", 
1:                 "blueprint");
1:     }
1:     
1:     /**
1:      * The purpose of this test is to make sure an application that contains an config admin bundle
1:      * can be used by manually. The following steps are performed:
1:      * 
0:      *      - install the application
0:      *      - start the application
0:      *      - assert we have the following services in the isolated service registry (ConfigurationAdmin, ManagedService, HelloWorld)
0:      *      - assert no configuration existed when the CM-PPH was invoked by BP (default message will be the token i.e. ${message})
0:      *      - update the configuration (the message) for the PID (using a primitive boundary proxy), this will cause the HW service to be re-registered ({@link org.apache.aries.isolated.config.HelloWorldManagedServiceImpl}
0:      *      - check that the re-registered HelloWorld service contains the updated message
0:      *      - clean up
1:      * 
1:      * @throws Exception
1:      */
1:     @Test
0:     public void testIsolatedCfgAdminManualReload() throws Exception {      
1:         validateApplicationConfiguration(
0:                 APP_HWMN, 
0:                 "org.apache.aries.helloworldmnapp", 
0:                 "helloworld-mn", 
0:                 (new HelloWorldImpl()).getMessage(), 
1:                 "manual");
1:     }
1:     
1:     /**
1:      * Central validation method for verifying configuration can be published and consumed correctly within
1:      * an isolated scope.
1:      * 
0:      * @param application the application file name
1:      * @param applicationName the application name
0:      * @param pid the service.pid
0:      * @param defaultMessage the default message for the HelloWorld service (checked before any configuration updates occur)
0:      * @param newMessage the new message to set during a configuration update
1:      * @throws Exception
1:      */
1:     private void validateApplicationConfiguration(String application, String applicationName, String pid, String defaultMessage, String newMessage) throws Exception {
1:  
1:         //install and start the application
1:         Context ctx = installApplication(FileSystem.getFSRoot(new File(application)), applicationName);
1:         
1:         //assert we have the services that we're expecting
1:         assertExpectedServices(ctx.getBundleContext(), pid);
1:         
1:         //make sure we have the defaults set
1:         Assert.assertEquals("Invalid message set on the HW service", defaultMessage, IsolationTestUtils.findHelloWorldService(ctx.getBundleContext()).getMessage());
1: 
1:         //cause a configuration update to occur which should reload our HW service
1:         Dictionary<String, String> dictionary = new Hashtable<String, String>();
1:         dictionary.put("message", newMessage);
1:         Assert.assertTrue("Configuration update failed", executeConfigurationUpdate(ctx.getBundleContext(), pid, dictionary));
1:         
1:         //now make sure we have our new message set in the HW service
1:         Assert.assertEquals("Invalid message set on the HW service", newMessage, IsolationTestUtils.findHelloWorldService(ctx.getBundleContext()).getMessage());
1:         
1:         //clean up
1:         uninstallApplication(ctx);
1:     }
1:     
1:     /**
1:      * Executes a configuration update using the given dictionary. A HelloWorld service will be tracked
1:      * to ensure the configuration was successful (listening for add/remove tracker events).
1:      * 
0:      * @param ctx the application bundle context
0:      * @param pid the service-pid to track
1:      * @param dictionary the dictionary containing updated properties
1:      * @return if the configuration update was successful
1:      * @throws Exception
1:      */
1:     private boolean executeConfigurationUpdate(BundleContext ctx, String pid, Dictionary<String, String> dictionary) throws Exception {
1:         boolean result = true;
1:         MonitorTask monitor = new MonitorTask(ctx, "(" + Constants.OBJECTCLASS + "=" + HelloWorld.class.getName() + ")", 2, 1);
1:         
1:         try {
1:             monitor.beginTracking();
1:             result &= (new ConfigurationTask(ctx, pid, dictionary)).execute();
1:             result &= monitor.execute();
1:         }
0:         finally {
1:             monitor.endTracking();
1:         }
1:         
1:         return result;
1:     }
1:     
1:     /**
1:      * Assert that the following services are present in the service registry:
1:      * 
0:      *      - ConfigurationAdmin
0:      *      - ManagedService
0:      *      - HelloWorld
1:      *      
1:      * @param ctx the bundle context
1:      * @param pid the service pid used to register the underlying ManagedService
1:      * @throws Exception
1:      */
1:     private void assertExpectedServices(RichBundleContext ctx, String pid) throws Exception {
1:         //assert the CfgAdmin service was registered
1:         Assert.assertNotNull("Missing the ConfigurationAdmin service", ctx.getService(ConfigurationAdmin.class));
1:         
1:         //assert we have the ManagedService exposed
1:         Assert.assertNotNull("Missing the Managed service", ctx.getService(ManagedService.class, "(" + Constants.SERVICE_PID + "=" + pid + ")"));
1:         //now just make sure we can see it through the context of our config admin bundle context (should be in the same scope)
1:         ServiceReference ref = ctx.getServiceReference(ConfigurationAdmin.class.getName());
1:         Assert.assertNotNull("Couldn't find the ManagedService using the ConfigAdmin bundle context", new RichBundleContext(ref.getBundle().getBundleContext()).getService(ManagedService.class, "(" + Constants.SERVICE_PID + "=" + pid + ")"));
1:         
1:         //make sure we have the helloworld service registered
1:         HelloWorld helloWorldBluePrint = IsolationTestUtils.findHelloWorldService(ctx);
0:         Assert.assertNotNull("Missing the HelloWorld service", helloWorldBluePrint);        
1:     }
1:     
1:     private Context installApplication(IDirectory application, String applicationName) throws Exception {
1:         //install the application and start it
1:         AriesApplicationManager appManager = context().getService(AriesApplicationManager.class);
1:         AriesApplication app = appManager.createApplication(application);
1:         AriesApplicationContext appCtx = appManager.install(app);
1:         appCtx.start();
1: 
1:         return new Context(appCtx, IsolationTestUtils.findIsolatedAppBundleContext(context(), applicationName));
1:     }
1:     
1:     private void uninstallApplication(Context ctx) throws Exception {
1:         AriesApplicationManager appManager = context().getService(AriesApplicationManager.class);
1:         appManager.uninstall(ctx.getApplicationContext());
1:     }
1:     
1:     /**
1:      * Create the configuration for the PAX container
1:      * 
1:      * @return the various required options
1:      * @throws Exception
1:      */
0:     @org.ops4j.pax.exam.junit.Configuration
0:     public static Option[] configuration() throws Exception {
0:         return testOptions(
0:                 repository("http://repository.ops4j.org/maven2"),
0:                 paxLogging("DEBUG"),
0:                 mavenBundle("org.apache.aries.blueprint", "org.apache.aries.blueprint"),
0:                 mavenBundle("asm", "asm-all"),
0:                 mavenBundle("org.apache.aries.proxy", "org.apache.aries.proxy"),
0:                 mavenBundle("org.apache.aries.transaction", "org.apache.aries.transaction.blueprint"),
0:                 mavenBundle("org.apache.aries", "org.apache.aries.util"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.default.local.platform"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller"),
0:                 mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.resolver.obr"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.resolve.transform.cm"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.deployment.management"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.management"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.isolated"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.framework"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.framework.management"),
0:                 mavenBundle("org.apache.aries.application", "org.apache.aries.application.runtime.repository"),
0:                 mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
0:                 mavenBundle("org.apache.geronimo.specs", "geronimo-jta_1.1_spec"),
0:                 mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
0:                 //vmOption("-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5006"), 
0:                 equinox().version("3.5.0"));
1:     }
1: 
1:     /**
1:      * High level interface for executing a unit of work
1:      * 
1:      *
1:      * @version $Rev$ $Date$
1:      */
0:     private static interface Task
0:     {
1:         /**
1:          * Executes the task logic
1:          * 
1:          * @return if the task was successful
1:          * @throws Exception
1:          */
1:         public boolean execute() throws Exception;
1:     }
1:     
1:     /**
1:      * Base class for a task implementation
1:      * 
1:      *
1:      * @version $Rev$ $Date$
1:      */
0:     private static abstract class BaseTask implements Task
0:     {
1:         private BundleContext ctx;
1:         
1:         public BaseTask(BundleContext ctx) {
1:             this.ctx = ctx;
1:         }
1:         
1:         protected BundleContext getBundleContext() {
1:             return ctx;
1:         }
1:     }
1:     
1:     /**
1:      * Trackable task that allows a service tracker to pickup service registration/un-registration events using the
1:      * supplied filter. Remember that if a service exists matching a filter while opening the underlying tracker
1:      * it will cause a addedService event to be fired, this must be taken into account when instantiating this type
1:      * task. For example if you had a ManagedService present in the container matching the given filter, you should
1:      * set the expected registerCount as 2 if you expect a re-register to occur due to a container reload etc.
1:      * 
1:      *
1:      * @version $Rev$ $Date$
1:      */
0:     public static abstract class TrackableTask extends BaseTask implements Task, ServiceTrackerCustomizer
0:     {
1:         private static final long DEFAULT_TIMEOUT = 5000;
1:         
1:         private String filter;
1:         private ServiceTracker tracker;
1:         private CountDownLatch addedLatch;
1:         private CountDownLatch removedLatch;
1:         
1:         public TrackableTask(BundleContext ctx, String filter) {
1:             this(ctx, filter, 1, 1);
1:         }
1:         
1:         public TrackableTask(BundleContext ctx, String filter, int registerCount) {
1:             this(ctx, filter, registerCount, 0);
1:         }
1:         
1:         public TrackableTask(BundleContext ctx, String filter, int registerCount, int unregisterCount) {
1:             super(ctx);
1:             
1:             this.filter = filter;
1:             this.addedLatch = new CountDownLatch(registerCount);
1:             this.removedLatch = new CountDownLatch(unregisterCount);
1:             this.tracker = null;
1:         }
1:         
1:         /**
1:          * Initiates the underlying service tracker
1:          * 
1:          * @throws InvalidSyntaxException
1:          */
1:         protected synchronized void beginTracking() throws InvalidSyntaxException {
1:             if (tracker == null) {
1:                 tracker = new ServiceTracker(getBundleContext(), getBundleContext().createFilter(filter), this);
1:                 tracker.open();
1:             }
1:         }
1:         
1:         /**
1:          * Stops and clears the underlying service tracker
1:          */
1:         protected synchronized void endTracking() {
1:             if (tracker != null) {
1:                 tracker.close();
1:                 tracker = null;
1:             }
1:         }
1:         
1:         /*
1:          * (non-Javadoc)
1:          * @see org.apache.aries.application.runtime.itests.IsolatedCfgAdminRuntimeTest.Task#execute()
1:          */
1:         public boolean execute() throws Exception {
1:             boolean result = true;
1:             
1:             try {
1:                 beginTracking();
1:                 doExecute();
1: 
1:                 result &= addedLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
1:                 result &= removedLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
1:             }
0:             finally {
1:                 endTracking();
1:             }
1:             
1:             return result;
1:         }
1:         
1:         /*
1:          * (non-Javadoc)
1:          * @see org.osgi.util.tracker.ServiceTrackerCustomizer#addingService(org.osgi.framework.ServiceReference)
1:          */
1:         public synchronized Object addingService(ServiceReference serviceRef) {
1:             addedLatch.countDown();
1:             return serviceRef;
1:         }
1: 
1:         /*
1:          * (non-Javadoc)
1:          * @see org.osgi.util.tracker.ServiceTrackerCustomizer#modifiedService(org.osgi.framework.ServiceReference, java.lang.Object)
1:          */
0:         public void modifiedService(ServiceReference serviceRef, Object service) {    
1:         }
1: 
1:         /*
1:          * (non-Javadoc)
1:          * @see org.osgi.util.tracker.ServiceTrackerCustomizer#removedService(org.osgi.framework.ServiceReference, java.lang.Object)
1:          */
1:         public synchronized void removedService(ServiceReference serviceRef, Object service) {
1:             removedLatch.countDown();
1:         }
1:         
1:         /**
1:          * Performs the task logic
1:          * 
1:          * @throws Exception
1:          */
1:         protected abstract void doExecute() throws Exception;
1:     }
1: 
1:     /**
1:      * The configuration task is responsible for executing a configuration update within the scope
1:      * of the given context. Note, this task assumes the class space is inconsistent will not try
1:      * casting to classes that may exist in the test world and also in the application.
1:      * 
1:      * @version $Rev$ $Date$
1:      */
0:     private static class ConfigurationTask extends BaseTask
0:     {
1:         private String pid;
1:         private Dictionary<String, String> dictionary;
1:         
0:         public ConfigurationTask(BundleContext ctx, String pid, Dictionary<String, String> dictionary) {   
1:             super(ctx);
1:             
1:             this.pid = pid;
1:             this.dictionary = dictionary;
1:         }
1: 
1:         /*
1:          * (non-Javadoc)
1:          * @see org.apache.aries.application.runtime.itests.IsolatedCfgAdminRuntimeTest.Task#execute()
1:          */
1:         public boolean execute() throws Exception {
1:             boolean result = false;
0:             ServiceTracker tracker = new ServiceTracker(getBundleContext(), getBundleContext().createFilter("(" + Constants.OBJECTCLASS +  "=" + ConfigurationAdmin.class.getName() + ")"), null);
1:             
1:             try {
1:                 tracker.open();
1:                 Object cfgAdminService = tracker.waitForService(5000);
1:                 
1:                 if (cfgAdminService != null) {
1:                     
1:                     ConfigurationAdmin proxy = Skeleton.newMock(cfgAdminService, ConfigurationAdmin.class);
1:                     Configuration configuration = proxy.getConfiguration(pid);
1:                     configuration.setBundleLocation(null);
1:                     configuration.update(dictionary);
1:                     result = true;
1:                 }
1:             }
0:             finally {
1:                 tracker.close();
1:             }
1:             
1:             return result;
1:         }
1:     }
1:     
1:     /**
1:      * Simple monitor class to keep track of services using the supplied filter, acts as a wrapper
1:      * so that it can be placed in side a composite task.
1:      * 
1:      *
1:      * @version $Rev$ $Date$
1:      */
0:     private static final class MonitorTask extends TrackableTask
0:     {
1:         public MonitorTask(BundleContext ctx, String filter, int registerCount, int unregisterCount) {
1:             super(ctx, filter, registerCount, unregisterCount);
1:         }
1:         
1:         /*
1:          * (non-Javadoc)
1:          * @see org.apache.aries.application.runtime.itests.IsolatedCfgAdminRuntimeTest.TrackableTask#doExecute()
1:          */
1:         @Override
1:         protected void doExecute() throws Exception {
1:             //do nothing, we just care about tracking
1:         }
1:         
1:     }
1:     
1:     /**
1:      * Simple wrapper for the various contexts required in this test suite
1:      * 
1:      *
1:      * @version $Rev$ $Date$
1:      */
0:     private static class Context
0:     {
1:         private AriesApplicationContext applicationContext;
1:         private RichBundleContext bundleContext;
1:         
1:         public Context(AriesApplicationContext applicationContext, BundleContext bundleContext) {
1:             this.applicationContext = applicationContext;
1:             this.bundleContext = new RichBundleContext(bundleContext);
1:         }
1:         
1:         public AriesApplicationContext getApplicationContext() {
1:             return applicationContext;
1:         }
1:         
1:         public RichBundleContext getBundleContext() {
1:             return bundleContext;
1:         }
1:     }
1: }
============================================================================