1:f13c6ac: /**
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.ext;
1:f13c6ac: 
1:f13c6ac: import java.util.ArrayList;
1:fe22770: import java.util.LinkedList;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.regex.Matcher;
1:f13c6ac: import java.util.regex.Pattern;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:6414875: import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
1:fe22770: import org.apache.aries.blueprint.PassThroughMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableBeanArgument;
1:6414875: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableBeanProperty;
1:6414875: import org.apache.aries.blueprint.mutable.MutableCollectionMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableMapEntry;
1:6414875: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutablePropsMetadata;
1:6414875: import org.apache.aries.blueprint.mutable.MutableReferenceListener;
1:6414875: import org.apache.aries.blueprint.mutable.MutableRegistrationListener;
1:6414875: import org.apache.aries.blueprint.mutable.MutableServiceMetadata;
1:d46274e: import org.apache.aries.blueprint.mutable.MutableServiceReferenceMetadata;
1:fe22770: import org.osgi.framework.Bundle;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanArgument;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.BeanProperty;
1:f13c6ac: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapEntry;
1:f13c6ac: import org.osgi.service.blueprint.reflect.MapMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Metadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.NonNullMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.PropsMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.RegistrationListener;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1:fe22770: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
1:f13c6ac: import org.osgi.service.blueprint.reflect.Target;
1:f13c6ac: import org.osgi.service.blueprint.reflect.ValueMetadata;
1:03b9eab: import org.slf4j.Logger;
1:03b9eab: import org.slf4j.LoggerFactory;
1:f13c6ac: 
1:f13c6ac: /**
1:f13c6ac:  * Abstract class for property placeholders.
1:f13c6ac:  *
1:76b662a:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:f13c6ac: public abstract class AbstractPropertyPlaceholder implements ComponentDefinitionRegistryProcessor {
1:f13c6ac: 
1:03b9eab:     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractPropertyPlaceholder.class);
2:fe22770: 
1:f13c6ac:     private String placeholderPrefix = "${";
1:f13c6ac:     private String placeholderSuffix = "}";
1:f13c6ac:     private Pattern pattern;
1:f13c6ac: 
1:fe22770:     private LinkedList<String> processingStack = new LinkedList<String>();
1:fe22770: 
1:fe22770:     private Bundle blueprintBundle;
1:fe22770:     
1:f13c6ac:     public String getPlaceholderPrefix() {
1:f13c6ac:         return placeholderPrefix;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setPlaceholderPrefix(String placeholderPrefix) {
1:f13c6ac:         this.placeholderPrefix = placeholderPrefix;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public String getPlaceholderSuffix() {
1:f13c6ac:         return placeholderSuffix;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setPlaceholderSuffix(String placeholderSuffix) {
1:f13c6ac:         this.placeholderSuffix = placeholderSuffix;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void process(ComponentDefinitionRegistry registry) throws ComponentDefinitionException {
1:fe22770:         try {
1:fe22770:              blueprintBundle = (Bundle) ((PassThroughMetadata)registry.getComponentDefinition("blueprintBundle")).getObject();
1:fe22770:             
1:f13c6ac:             for (String name : registry.getComponentDefinitionNames()) {
1:f13c6ac:                 processMetadata(registry.getComponentDefinition(name));
1:f13c6ac:             }
1:fe22770:         } finally {
1:fe22770:           processingStack.clear();
1:fe22770:           blueprintBundle = null;
1:f13c6ac:         }
5:fe22770:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processMetadata(Metadata metadata) {
1:fe22770:         try {
1:f13c6ac:             if (metadata instanceof BeanMetadata) {
1:fe22770:                 BeanMetadata bmd = (BeanMetadata) metadata;
1:fe22770:                 processingStack.add("Bean named " + bmd.getId() + "->");
1:fe22770:                 return processBeanMetadata(bmd);
1:f13c6ac:             } else if (metadata instanceof ReferenceListMetadata) {
1:fe22770:                 ReferenceListMetadata rlmd = (ReferenceListMetadata) metadata;
1:fe22770:                 processingStack.add("Reference List named " + rlmd.getId() + "->");
1:fe22770:                 return processRefCollectionMetadata(rlmd);
1:f13c6ac:             } else if (metadata instanceof ReferenceMetadata) {
1:fe22770:                 ReferenceMetadata rmd = (ReferenceMetadata) metadata;
1:fe22770:                 processingStack.add("Reference named " + rmd.getId() + "->");
1:fe22770:                 return processReferenceMetadata(rmd);
1:f13c6ac:             } else if (metadata instanceof ServiceMetadata) {
1:fe22770:                 ServiceMetadata smd = (ServiceMetadata) metadata;
1:fe22770:                 processingStack.add("Service named " + smd.getId() + "->");
1:fe22770:                 return processServiceMetadata(smd);
1:f13c6ac:             } else if (metadata instanceof CollectionMetadata) {
1:fe22770:                 CollectionMetadata cmd = (CollectionMetadata) metadata;
1:fe22770:                 processingStack.add("Collection of type " + cmd.getCollectionClass() + "->");
1:fe22770:                 return processCollectionMetadata(cmd);
1:f13c6ac:             } else if (metadata instanceof MapMetadata) {
1:fe22770:                 processingStack.add("Map->");
1:f13c6ac:                 return processMapMetadata((MapMetadata) metadata);
1:f13c6ac:             } else if (metadata instanceof PropsMetadata) {
1:fe22770:                 processingStack.add("Properties->");
1:f13c6ac:                 return processPropsMetadata((PropsMetadata) metadata);
1:f13c6ac:             } else if (metadata instanceof ValueMetadata) {
1:fe22770:                 processingStack.add("Value->");
1:f13c6ac:                 return processValueMetadata((ValueMetadata) metadata);
1:f13c6ac:             } else {
1:fe22770:                 processingStack.add("Unknown Metadata " + metadata + "->");
1:f13c6ac:                 return metadata;
1:f13c6ac:             }
1:fe22770:         } finally {
1:fe22770:             processingStack.removeLast();
1:f13c6ac:         }
1:fe22770:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processBeanMetadata(BeanMetadata component) {
1:f13c6ac:         for (BeanArgument arg :  component.getArguments()) {
1:fe22770:             
1:fe22770:             try {
1:fe22770:                 processingStack.add(
1:fe22770:                     "Argument index " + arg.getIndex() + " and value type " + arg.getValueType() + "->");
1:fe22770:                 if(arg instanceof MutableBeanArgument) {
1:f13c6ac:                     ((MutableBeanArgument) arg).setValue(processMetadata(arg.getValue()));
2:fe22770:                 } else {
1:fe22770:                     //Say that we can't change this argument, but continue processing
1:fe22770:                     //If the value is mutable then we may be ok!
1:fe22770:                     printWarning(arg, "Constructor Argument");
1:fe22770:                     processMetadata(arg.getValue());
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:                 processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:f13c6ac:         for (BeanProperty prop : component.getProperties()) {
1:fe22770:           
1:fe22770:             try {
1:fe22770:                 processingStack.add("Property named " + prop.getName() + "->");
1:fe22770:                 if(prop instanceof MutableBeanProperty) {
1:f13c6ac:                     ((MutableBeanProperty) prop).setValue(processMetadata(prop.getValue()));
1:fe22770:                 } else {
1:fe22770:                     //Say that we can't change this property, but continue processing
1:fe22770:                     //If the value is mutable then we may be ok!
1:fe22770:                     printWarning(prop, "Injection Property");
1:fe22770:                     processMetadata(prop.getValue());
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:                 processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:fe22770:         
1:fe22770:         Target factoryComponent = component.getFactoryComponent();
1:fe22770:         if(factoryComponent != null) {
1:fe22770:             
1:fe22770:             try {
1:fe22770:                 
1:fe22770:                 if(component instanceof MutableBeanMetadata) {
1:fe22770:                     processingStack.add("Factory Component->");
1:fe22770:                     ((MutableBeanMetadata) component).setFactoryComponent(
1:fe22770:                         (Target) processMetadata(factoryComponent));
1:fe22770:                 } else {
1:fe22770:                     printWarning(component, "Factory Component");
1:fe22770:                     processingStack.add("Factory Component->");
1:fe22770:                     processMetadata(factoryComponent);
1:fe22770:                 }
1:fe22770:             } finally {
1:fe22770:                 processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:fe22770:         
2:f13c6ac:         return component;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processServiceMetadata(ServiceMetadata component) {
1:fe22770:       
1:fe22770:         try {
1:fe22770:             if(component instanceof MutableServiceMetadata) {
1:fe22770:                 processingStack.add("Service Component->");
1:fe22770:                 ((MutableServiceMetadata) component).setServiceComponent(
1:fe22770:                     (Target) processMetadata(component.getServiceComponent()));
1:fe22770:             } else {
1:fe22770:                 printWarning(component, "Service Component");
1:fe22770:                 processingStack.add("Service Component->");
1:fe22770:                 processMetadata(component.getServiceComponent());
1:fe22770:             }
1:fe22770:         } finally {
1:fe22770:             processingStack.removeLast();
1:fe22770:         }
1:fe22770:         
1:f13c6ac:         List<MapEntry> entries = new ArrayList<MapEntry>(component.getServiceProperties());
1:fe22770:         if(!!! entries.isEmpty()) {
1:fe22770:           
1:fe22770:             try {
1:fe22770:                 if(component instanceof MutableServiceMetadata) {
1:fe22770:                     processingStack.add("Service Properties->");
1:fe22770:                     MutableServiceMetadata msm = (MutableServiceMetadata) component;
1:fe22770:                 
1:f13c6ac:                     for (MapEntry entry : entries) {
1:fe22770:                         msm.removeServiceProperty(entry);
1:f13c6ac:                     }
1:f13c6ac:                     for (MapEntry entry : processMapEntries(entries)) {
1:fe22770:                         msm.addServiceProperty(entry);
1:f13c6ac:                     }
1:fe22770:                 } else {
1:fe22770:                     printWarning(component, "Service Properties");
1:fe22770:                     processingStack.add("Service Properties->");
1:fe22770:                     processMapEntries(entries);
1:fe22770:                 }
1:fe22770:             } finally {
1:fe22770:               processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:fe22770:         
1:f13c6ac:         for (RegistrationListener listener : component.getRegistrationListeners()) {
1:fe22770:             Target listenerComponent = listener.getListenerComponent();
1:fe22770:             try {
1:fe22770:                 processingStack.add("Registration Listener " + listenerComponent + "->");
1:fe22770:                 if(listener instanceof MutableRegistrationListener) {
1:fe22770:                     ((MutableRegistrationListener) listener).setListenerComponent((Target) processMetadata(listenerComponent));
1:fe22770:                 } else {
1:fe22770:                     //Say that we can't change this listener, but continue processing
1:fe22770:                     //If the value is mutable then we may be ok!
1:fe22770:                     printWarning(listener, "Service Registration Listener");
1:fe22770:                     processMetadata(listenerComponent);
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:             processingStack.removeLast();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return component;
1:fe22770:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processReferenceMetadata(ReferenceMetadata component) {
1:fe22770:         return processServiceReferenceMetadata(component);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processRefCollectionMetadata(ReferenceListMetadata component) {
1:fe22770:         return processServiceReferenceMetadata(component);
1:fe22770:     }
1:fe22770: 
1:fe22770:     private Metadata processServiceReferenceMetadata(ServiceReferenceMetadata component) {
1:d46274e:         if (component instanceof MutableServiceReferenceMetadata) {
1:d46274e:             ValueMetadata valueMetadata = ((MutableServiceReferenceMetadata) component).getExtendedFilter();
1:d46274e:             if (valueMetadata != null) {
1:d46274e:                 ((MutableServiceReferenceMetadata) component).setExtendedFilter(
1:d46274e:                         doProcessValueMetadata(valueMetadata));
1:d46274e:             }
1:d46274e:         }
2:f13c6ac:         for (ReferenceListener listener : component.getReferenceListeners()) {
1:fe22770:             Target listenerComponent = listener.getListenerComponent();
1:fe22770:             try {
1:fe22770:                 processingStack.add("Reference Listener " + listenerComponent + "->");
1:fe22770:                 if(listener instanceof MutableReferenceListener) {
1:fe22770:                     ((MutableReferenceListener) listener).setListenerComponent((Target) processMetadata(listenerComponent));
1:fe22770:                 } else {
1:fe22770:                     //Say that we can't change this listener, but continue processing
1:fe22770:                     //If the value is mutable then we may be ok!
1:fe22770:                     printWarning(listener, "Reference Binding Listener");
1:fe22770:                     processMetadata(listenerComponent);
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:             processingStack.removeLast();
1:f13c6ac:             }
1:fe22770:         }
1:f13c6ac:         return component;
1:fe22770:     }
1:f13c6ac:     
1:f13c6ac:     protected Metadata processPropsMetadata(PropsMetadata metadata) {
1:fe22770:       
1:f13c6ac:         List<MapEntry> entries = new ArrayList<MapEntry>(metadata.getEntries());
1:fe22770:         if(!!! entries.isEmpty()) {
1:f13c6ac:           
1:fe22770:             try {
1:fe22770:                 if(metadata instanceof MutablePropsMetadata) {
1:fe22770:                     processingStack.add("Properties->");
1:fe22770:                     MutablePropsMetadata mpm = (MutablePropsMetadata) metadata;
1:fe22770:                 
1:f13c6ac:                     for (MapEntry entry : entries) {
1:fe22770:                         mpm.removeEntry(entry);
1:f13c6ac:                     }
1:f13c6ac:                     for (MapEntry entry : processMapEntries(entries)) {
1:fe22770:                         mpm.addEntry(entry);
1:f13c6ac:                     }
1:fe22770:                 } else {
1:fe22770:                     printWarning(metadata, "Properties");
1:fe22770:                     processingStack.add("Properties->");
1:fe22770:                     processMapEntries(entries);
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:               processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:f13c6ac:         return metadata;
1:fe22770:     }
1:fe22770: 
1:f13c6ac:     protected Metadata processMapMetadata(MapMetadata metadata) {
1:f13c6ac:         List<MapEntry> entries = new ArrayList<MapEntry>(metadata.getEntries());
1:fe22770:         if(!!! entries.isEmpty()) {
1:f13c6ac:           
1:fe22770:             try {
1:fe22770:                 if(metadata instanceof MutableMapMetadata) {
1:fe22770:                     processingStack.add("Map->");
1:fe22770:                     MutableMapMetadata mmm = (MutableMapMetadata) metadata;
1:fe22770:                 
1:f13c6ac:                     for (MapEntry entry : entries) {
1:fe22770:                         mmm.removeEntry(entry);
1:f13c6ac:                     }
1:f13c6ac:                     for (MapEntry entry : processMapEntries(entries)) {
1:fe22770:                         mmm.addEntry(entry);
1:f13c6ac:                     }
1:fe22770:                 } else {
1:fe22770:                     printWarning(metadata, "Map");
1:fe22770:                     processingStack.add("Map->");
1:fe22770:                     processMapEntries(entries);
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:               processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:f13c6ac:         return metadata;
1:fe22770:     }
1:fe22770: 
1:f13c6ac:     protected List<MapEntry> processMapEntries(List<MapEntry> entries) {
1:f13c6ac:         for (MapEntry entry : entries) {
1:fe22770:             try {
1:fe22770:                 processingStack.add("Map Entry Key: " + entry.getKey() + " Value: " + entry.getValue() + "->" );
1:fe22770:             
1:fe22770:                 if(entry instanceof MutableMapEntry) {
1:f13c6ac:                     ((MutableMapEntry) entry).setKey((NonNullMetadata) processMetadata(entry.getKey()));
1:f13c6ac:                     ((MutableMapEntry) entry).setValue(processMetadata(entry.getValue()));
1:fe22770:                 } else {
1:fe22770:                   printWarning(entry, "Map Entry");
1:fe22770:                   processMetadata(entry.getKey());
1:fe22770:                   processMetadata(entry.getValue());
1:f13c6ac:                 }
1:fe22770:             } finally {
1:fe22770:                 processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:f13c6ac:         return entries;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processCollectionMetadata(CollectionMetadata metadata) {
1:fe22770:       
1:f13c6ac:         List<Metadata> values = new ArrayList<Metadata>(metadata.getValues());
1:fe22770:         if(!!! values.isEmpty()) {
1:fe22770:         
1:fe22770:             try {
1:fe22770:                 if(metadata instanceof MutableCollectionMetadata) {
1:fe22770:                     processingStack.add("Collection type: " + metadata.getValueType() + "->");
1:fe22770:                     MutableCollectionMetadata mcm = (MutableCollectionMetadata) metadata;
1:fe22770:                 
1:f13c6ac:                     for (Metadata value : values) {
1:fe22770:                         mcm.removeValue(value);
1:f13c6ac:                     }
1:f13c6ac:                     for (Metadata value : values) {
1:fe22770:                         mcm.addValue(processMetadata(value));
1:f13c6ac:                     }
1:fe22770:                 } else {
1:fe22770:                     printWarning(metadata, "Collection type: " + metadata.getValueType());
1:fe22770:                     processingStack.add("Collection type: " + metadata.getValueType() + "->");
3:fe22770:                     for (Metadata value : values) {
1:fe22770:                        processMetadata(value);
1:f13c6ac:                     }
1:fe22770:                 }
1:fe22770:             } finally {
1:fe22770:               processingStack.removeLast();
1:fe22770:             }
1:fe22770:         }
1:f13c6ac:         return metadata;
1:fe22770:     }
1:f13c6ac: 
1:f13c6ac:     protected Metadata processValueMetadata(ValueMetadata metadata) {
1:d46274e:         return doProcessValueMetadata(metadata);
1:d46274e:     }
1:d46274e: 
1:d46274e:     protected ValueMetadata doProcessValueMetadata(ValueMetadata metadata) {
1:f13c6ac:         return new LateBindingValueMetadata(metadata);
1:f13c6ac:     }
1:f13c6ac: 
1:fe22770:     private void printWarning(Object immutable, String processingType) {
1:fe22770:         StringBuilder sb = new StringBuilder("The property placeholder processor for ");
1:fe22770:         sb.append(placeholderPrefix).append(',').append(" ").append(placeholderSuffix)
1:db4243b:         .append(" in bundle ").append(blueprintBundle.getSymbolicName()).append("/")
1:fe22770:         .append(blueprintBundle.getVersion()).append(" found an immutable ").append(processingType)
1:fe22770:         .append(" at location ");
1:f13c6ac:         
1:fe22770:         for(String s : processingStack) {
1:fe22770:             sb.append(s);
1:fe22770:         }
1:fe22770:         
1:fe22770:         sb.append(". This may prevent properties, beans, or other items referenced by this component from being properly processed.");
1:fe22770:         
1:fe22770:         LOGGER.info(sb.toString());
1:fe22770:     }
1:fe22770:     
1:03b9eab:     protected String retrieveValue(String expression) {
1:03b9eab:         return getProperty(expression);
1:fe22770:     }
1:fe22770:     
1:f13c6ac:     protected String processString(String str) {
1:f13c6ac:         // TODO: we need to handle escapes on the prefix / suffix
1:f13c6ac:         Matcher matcher = getPattern().matcher(str);
1:f13c6ac:         while (matcher.find()) {
1:382bf57:             String n = matcher.group(1);
1:382bf57:             int idx = n.indexOf(placeholderPrefix);
1:382bf57:             if (idx >= 0) {
1:382bf57:                 matcher.region(matcher.start(1) + idx, str.length());
1:382bf57:                 continue;
1:382bf57:             }
1:03b9eab:             String rep = retrieveValue(matcher.group(1));
1:f13c6ac:             if (rep != null) {
1:f13c6ac:                 str = str.replace(matcher.group(0), rep);
1:f13c6ac:                 matcher.reset(str);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return str;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected String getProperty(String val) {
1:f13c6ac:         return null;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     protected Pattern getPattern() {
1:f13c6ac:         if (pattern == null) {
1:f822e15:             pattern = Pattern.compile("\\Q" + placeholderPrefix + "\\E(.+?)\\Q" + placeholderSuffix + "\\E");
1:f13c6ac:         }
1:f13c6ac:         return pattern;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public class LateBindingValueMetadata implements ValueMetadata {
1:f13c6ac: 
1:f13c6ac:         private final ValueMetadata metadata;
1:f13c6ac:         private boolean retrieved;
1:f13c6ac:         private String retrievedValue;
1:f13c6ac: 
1:f13c6ac:         public LateBindingValueMetadata(ValueMetadata metadata) {
1:f13c6ac:             this.metadata = metadata;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public String getStringValue() {
1:f13c6ac:             if (!retrieved) {
1:03b9eab:                 String v = metadata.getStringValue();
1:03b9eab:                 LOGGER.debug("Before process: {}", v);
1:03b9eab:                 retrievedValue = processString(v);
1:03b9eab:                 LOGGER.debug("After process: {}", retrievedValue);
1:f13c6ac:                 
1:f13c6ac:                 retrieved = true;
1:f13c6ac:             }
1:f13c6ac:             return retrievedValue;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public String getType() {
1:f13c6ac:             return metadata.getType();
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:382bf57
/////////////////////////////////////////////////////////////////////////
1:             String n = matcher.group(1);
1:             int idx = n.indexOf(placeholderPrefix);
1:             if (idx >= 0) {
1:                 matcher.region(matcher.start(1) + idx, str.length());
1:                 continue;
1:             }
commit:db4243b
/////////////////////////////////////////////////////////////////////////
1:         .append(" in bundle ").append(blueprintBundle.getSymbolicName()).append("/")
commit:d46274e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.mutable.MutableServiceReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         if (component instanceof MutableServiceReferenceMetadata) {
1:             ValueMetadata valueMetadata = ((MutableServiceReferenceMetadata) component).getExtendedFilter();
1:             if (valueMetadata != null) {
1:                 ((MutableServiceReferenceMetadata) component).setExtendedFilter(
1:                         doProcessValueMetadata(valueMetadata));
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return doProcessValueMetadata(metadata);
1:     }
1: 
1:     protected ValueMetadata doProcessValueMetadata(ValueMetadata metadata) {
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.ext;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: 
0: import org.apache.geronimo.blueprint.ComponentDefinitionRegistry;
0: import org.apache.geronimo.blueprint.ComponentDefinitionRegistryProcessor;
0: import org.apache.geronimo.blueprint.mutable.MutableBeanArgument;
0: import org.apache.geronimo.blueprint.mutable.MutableBeanMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableBeanProperty;
0: import org.apache.geronimo.blueprint.mutable.MutableCollectionMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableMapEntry;
0: import org.apache.geronimo.blueprint.mutable.MutableMapMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutablePropsMetadata;
0: import org.apache.geronimo.blueprint.mutable.MutableReferenceListener;
0: import org.apache.geronimo.blueprint.mutable.MutableRegistrationListener;
0: import org.apache.geronimo.blueprint.mutable.MutableServiceMetadata;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.osgi.service.blueprint.reflect.BeanArgument;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
1: import org.osgi.service.blueprint.reflect.BeanProperty;
1: import org.osgi.service.blueprint.reflect.CollectionMetadata;
1: import org.osgi.service.blueprint.reflect.MapEntry;
1: import org.osgi.service.blueprint.reflect.MapMetadata;
1: import org.osgi.service.blueprint.reflect.Metadata;
1: import org.osgi.service.blueprint.reflect.NonNullMetadata;
1: import org.osgi.service.blueprint.reflect.PropsMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
1: import org.osgi.service.blueprint.reflect.ReferenceListener;
1: import org.osgi.service.blueprint.reflect.ReferenceMetadata;
1: import org.osgi.service.blueprint.reflect.RegistrationListener;
1: import org.osgi.service.blueprint.reflect.ServiceMetadata;
1: import org.osgi.service.blueprint.reflect.Target;
1: import org.osgi.service.blueprint.reflect.ValueMetadata;
1: 
1: /**
1:  * Abstract class for property placeholders.
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
0:  * @version $Rev: 766508 $, $Date: 2009-04-19 22:09:27 +0200 (Sun, 19 Apr 2009) $
1:  */
1: public abstract class AbstractPropertyPlaceholder implements ComponentDefinitionRegistryProcessor {
1: 
1:     private String placeholderPrefix = "${";
1:     private String placeholderSuffix = "}";
1:     private Pattern pattern;
1: 
1:     public String getPlaceholderPrefix() {
1:         return placeholderPrefix;
1:     }
1: 
1:     public void setPlaceholderPrefix(String placeholderPrefix) {
1:         this.placeholderPrefix = placeholderPrefix;
1:     }
1: 
1:     public String getPlaceholderSuffix() {
1:         return placeholderSuffix;
1:     }
1: 
1:     public void setPlaceholderSuffix(String placeholderSuffix) {
1:         this.placeholderSuffix = placeholderSuffix;
1:     }
1: 
1:     public void process(ComponentDefinitionRegistry registry) throws ComponentDefinitionException {
1:         for (String name : registry.getComponentDefinitionNames()) {
1:             processMetadata(registry.getComponentDefinition(name));
1:         }
1:     }
1: 
1:     protected Metadata processMetadata(Metadata metadata) {
1:         if (metadata instanceof BeanMetadata) {
0:             return processBeanMetadata((BeanMetadata) metadata);
1:         } else if (metadata instanceof ReferenceListMetadata) {
0:             return processRefCollectionMetadata((ReferenceListMetadata) metadata);
1:         } else if (metadata instanceof ReferenceMetadata) {
0:             return processReferenceMetadata((ReferenceMetadata) metadata);
1:         } else if (metadata instanceof ServiceMetadata) {
0:             return processServiceMetadata((ServiceMetadata) metadata);
1:         } else if (metadata instanceof CollectionMetadata) {
0:             return processCollectionMetadata((CollectionMetadata) metadata);
1:         } else if (metadata instanceof MapMetadata) {
1:             return processMapMetadata((MapMetadata) metadata);
1:         } else if (metadata instanceof PropsMetadata) {
1:             return processPropsMetadata((PropsMetadata) metadata);
1:         } else if (metadata instanceof ValueMetadata) {
1:             return processValueMetadata((ValueMetadata) metadata);
1:         } else {
1:             return metadata;
1:         }
1:     }
1: 
1:     protected Metadata processBeanMetadata(BeanMetadata component) {
1:         for (BeanArgument arg :  component.getArguments()) {
1:             ((MutableBeanArgument) arg).setValue(processMetadata(arg.getValue()));
1:         }
1:         for (BeanProperty prop : component.getProperties()) {
1:             ((MutableBeanProperty) prop).setValue(processMetadata(prop.getValue()));
1:         }
0:         ((MutableBeanMetadata) component).setFactoryComponent((Target) processMetadata(component.getFactoryComponent()));
1:         return component;
1:     }
1: 
1:     protected Metadata processServiceMetadata(ServiceMetadata component) {
0:         ((MutableServiceMetadata) component).setServiceComponent((Target) processMetadata(component.getServiceComponent()));
1:         List<MapEntry> entries = new ArrayList<MapEntry>(component.getServiceProperties());
1:         for (MapEntry entry : entries) {
0:             ((MutableServiceMetadata) component).removeServiceProperty(entry);
1:         }
1:         for (MapEntry entry : processMapEntries(entries)) {
0:             ((MutableServiceMetadata) component).addServiceProperty(entry);
1:         }
1:         for (RegistrationListener listener : component.getRegistrationListeners()) {
0:             ((MutableRegistrationListener) listener).setListenerComponent((Target) processMetadata(listener.getListenerComponent()));
1:         }
1:         return component;
1:     }
1: 
1:     protected Metadata processReferenceMetadata(ReferenceMetadata component) {
1:         for (ReferenceListener listener : component.getReferenceListeners()) {
0:             ((MutableReferenceListener) listener).setListenerComponent((Target) processMetadata(listener.getListenerComponent()));
1:         }
1:         return component;
1:     }
1: 
1:     protected Metadata processRefCollectionMetadata(ReferenceListMetadata component) {
1:         for (ReferenceListener listener : component.getReferenceListeners()) {
0:             ((MutableReferenceListener) listener).setListenerComponent((Target) processMetadata(listener.getListenerComponent()));
1:         }
1:         return component;
1:     }
1: 
1:     protected Metadata processPropsMetadata(PropsMetadata metadata) {
1:         List<MapEntry> entries = new ArrayList<MapEntry>(metadata.getEntries());
1:         for (MapEntry entry : entries) {
0:             ((MutablePropsMetadata) metadata).removeEntry(entry);
1:         }
1:         for (MapEntry entry : processMapEntries(entries)) {
0:             ((MutablePropsMetadata) metadata).addEntry(entry);
1:         }
1:         return metadata;
1:     }
1: 
1:     protected Metadata processMapMetadata(MapMetadata metadata) {
1:         List<MapEntry> entries = new ArrayList<MapEntry>(metadata.getEntries());
1:         for (MapEntry entry : entries) {
0:             ((MutableMapMetadata) metadata).removeEntry(entry);
1:         }
1:         for (MapEntry entry : processMapEntries(entries)) {
0:             ((MutableMapMetadata) metadata).addEntry(entry);
1:         }
1:         return metadata;
1:     }
1: 
1:     protected List<MapEntry> processMapEntries(List<MapEntry> entries) {
1:         for (MapEntry entry : entries) {
1:             ((MutableMapEntry) entry).setKey((NonNullMetadata) processMetadata(entry.getKey()));
1:             ((MutableMapEntry) entry).setValue(processMetadata(entry.getValue()));
1:         }
1:         return entries;
1:     }
1: 
1:     protected Metadata processCollectionMetadata(CollectionMetadata metadata) {
1:         List<Metadata> values = new ArrayList<Metadata>(metadata.getValues());
1:         for (Metadata value : values) {
0:             ((MutableCollectionMetadata) metadata).removeValue(value);
1:         }
1:         for (Metadata value : values) {
0:             ((MutableCollectionMetadata) metadata).addValue(processMetadata(value));
1:         }
1:         return metadata;
1:     }
1: 
1:     protected Metadata processValueMetadata(ValueMetadata metadata) {
1:         return new LateBindingValueMetadata(metadata);
1:     }
1: 
1:     protected String processString(String str) {
1:         // TODO: we need to handle escapes on the prefix / suffix
1:         Matcher matcher = getPattern().matcher(str);
1:         while (matcher.find()) {
0:             String rep = getProperty(matcher.group(1));
1:             if (rep != null) {
1:                 str = str.replace(matcher.group(0), rep);
1:                 matcher.reset(str);
1:             }
1:         }
1:         return str;
1:     }
1: 
1:     protected String getProperty(String val) {
1:         return null;
1:     }
1: 
1:     protected Pattern getPattern() {
1:         if (pattern == null) {
0:             pattern = Pattern.compile("\\Q" + placeholderPrefix + "\\E(.+)\\Q" + placeholderSuffix + "\\E");
1:         }
1:         return pattern;
1:     }
1: 
1:     public class LateBindingValueMetadata implements ValueMetadata {
1: 
1:         private final ValueMetadata metadata;
1:         private boolean retrieved;
1:         private String retrievedValue;
1: 
1:         public LateBindingValueMetadata(ValueMetadata metadata) {
1:             this.metadata = metadata;
1:         }
1: 
1:         public String getStringValue() {
1:             if (!retrieved) {
1:                 retrieved = true;
0:                 retrievedValue = processString(metadata.getStringValue());
1:             }
1:             return retrievedValue;
1:         }
1: 
1:         public String getType() {
1:             return metadata.getType();
1:         }
1: 
1:     }
1: 
1: }
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:fe22770
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
1: import org.apache.aries.blueprint.PassThroughMetadata;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
/////////////////////////////////////////////////////////////////////////
1:     private LinkedList<String> processingStack = new LinkedList<String>();
1: 
1:     private Bundle blueprintBundle;
1:     
/////////////////////////////////////////////////////////////////////////
1:         try {
1:              blueprintBundle = (Bundle) ((PassThroughMetadata)registry.getComponentDefinition("blueprintBundle")).getObject();
1:             
0:             for (String name : registry.getComponentDefinitionNames()) {
0:                 processMetadata(registry.getComponentDefinition(name));
1:             }
1:         } finally {
1:           processingStack.clear();
1:           blueprintBundle = null;
1:         try {
0:             if (metadata instanceof BeanMetadata) {
1:                 BeanMetadata bmd = (BeanMetadata) metadata;
1:                 processingStack.add("Bean named " + bmd.getId() + "->");
1:                 return processBeanMetadata(bmd);
0:             } else if (metadata instanceof ReferenceListMetadata) {
1:                 ReferenceListMetadata rlmd = (ReferenceListMetadata) metadata;
1:                 processingStack.add("Reference List named " + rlmd.getId() + "->");
1:                 return processRefCollectionMetadata(rlmd);
0:             } else if (metadata instanceof ReferenceMetadata) {
1:                 ReferenceMetadata rmd = (ReferenceMetadata) metadata;
1:                 processingStack.add("Reference named " + rmd.getId() + "->");
1:                 return processReferenceMetadata(rmd);
0:             } else if (metadata instanceof ServiceMetadata) {
1:                 ServiceMetadata smd = (ServiceMetadata) metadata;
1:                 processingStack.add("Service named " + smd.getId() + "->");
1:                 return processServiceMetadata(smd);
0:             } else if (metadata instanceof CollectionMetadata) {
1:                 CollectionMetadata cmd = (CollectionMetadata) metadata;
1:                 processingStack.add("Collection of type " + cmd.getCollectionClass() + "->");
1:                 return processCollectionMetadata(cmd);
0:             } else if (metadata instanceof MapMetadata) {
1:                 processingStack.add("Map->");
0:                 return processMapMetadata((MapMetadata) metadata);
0:             } else if (metadata instanceof PropsMetadata) {
1:                 processingStack.add("Properties->");
0:                 return processPropsMetadata((PropsMetadata) metadata);
0:             } else if (metadata instanceof ValueMetadata) {
1:                 processingStack.add("Value->");
0:                 return processValueMetadata((ValueMetadata) metadata);
1:             } else {
1:                 processingStack.add("Unknown Metadata " + metadata + "->");
0:                 return metadata;
1:             }
1:         } finally {
1:             processingStack.removeLast();
1:             
1:             try {
1:                 processingStack.add(
1:                     "Argument index " + arg.getIndex() + " and value type " + arg.getValueType() + "->");
1:                 if(arg instanceof MutableBeanArgument) {
0:                     ((MutableBeanArgument) arg).setValue(processMetadata(arg.getValue()));
1:                 } else {
1:                     //Say that we can't change this argument, but continue processing
1:                     //If the value is mutable then we may be ok!
1:                     printWarning(arg, "Constructor Argument");
1:                     processMetadata(arg.getValue());
1:                 }
1:             } finally {
1:                 processingStack.removeLast();
1:             }
1:           
1:             try {
1:                 processingStack.add("Property named " + prop.getName() + "->");
1:                 if(prop instanceof MutableBeanProperty) {
0:                     ((MutableBeanProperty) prop).setValue(processMetadata(prop.getValue()));
1:                 } else {
1:                     //Say that we can't change this property, but continue processing
1:                     //If the value is mutable then we may be ok!
1:                     printWarning(prop, "Injection Property");
1:                     processMetadata(prop.getValue());
1:                 }
1:             } finally {
1:                 processingStack.removeLast();
1:             }
1:         
1:         Target factoryComponent = component.getFactoryComponent();
1:         if(factoryComponent != null) {
1:             
1:             try {
1:                 
1:                 if(component instanceof MutableBeanMetadata) {
1:                     processingStack.add("Factory Component->");
1:                     ((MutableBeanMetadata) component).setFactoryComponent(
1:                         (Target) processMetadata(factoryComponent));
1:                 } else {
1:                     printWarning(component, "Factory Component");
1:                     processingStack.add("Factory Component->");
1:                     processMetadata(factoryComponent);
1:                 }
1:             } finally {
1:                 processingStack.removeLast();
1:             }
1:         }
1:         
1:       
1:         try {
1:             if(component instanceof MutableServiceMetadata) {
1:                 processingStack.add("Service Component->");
1:                 ((MutableServiceMetadata) component).setServiceComponent(
1:                     (Target) processMetadata(component.getServiceComponent()));
1:             } else {
1:                 printWarning(component, "Service Component");
1:                 processingStack.add("Service Component->");
1:                 processMetadata(component.getServiceComponent());
1:             }
1:         } finally {
1:             processingStack.removeLast();
1:         }
1:         
1:         if(!!! entries.isEmpty()) {
1:           
1:             try {
1:                 if(component instanceof MutableServiceMetadata) {
1:                     processingStack.add("Service Properties->");
1:                     MutableServiceMetadata msm = (MutableServiceMetadata) component;
1:                 
0:                     for (MapEntry entry : entries) {
1:                         msm.removeServiceProperty(entry);
1:                     }
0:                     for (MapEntry entry : processMapEntries(entries)) {
1:                         msm.addServiceProperty(entry);
1:                     }
1:                 } else {
1:                     printWarning(component, "Service Properties");
1:                     processingStack.add("Service Properties->");
1:                     processMapEntries(entries);
1:                 }
1:             } finally {
1:               processingStack.removeLast();
1:             }
1:         
1:             Target listenerComponent = listener.getListenerComponent();
1:             try {
1:                 processingStack.add("Registration Listener " + listenerComponent + "->");
1:                 if(listener instanceof MutableRegistrationListener) {
1:                     ((MutableRegistrationListener) listener).setListenerComponent((Target) processMetadata(listenerComponent));
1:                 } else {
1:                     //Say that we can't change this listener, but continue processing
1:                     //If the value is mutable then we may be ok!
1:                     printWarning(listener, "Service Registration Listener");
1:                     processMetadata(listenerComponent);
1:                 }
1:             } finally {
1:             processingStack.removeLast();
1:             }
1:         return processServiceReferenceMetadata(component);
1:         return processServiceReferenceMetadata(component);
1:     }
1: 
1:     private Metadata processServiceReferenceMetadata(ServiceReferenceMetadata component) {
1:             Target listenerComponent = listener.getListenerComponent();
1:             try {
1:                 processingStack.add("Reference Listener " + listenerComponent + "->");
1:                 if(listener instanceof MutableReferenceListener) {
1:                     ((MutableReferenceListener) listener).setListenerComponent((Target) processMetadata(listenerComponent));
1:                 } else {
1:                     //Say that we can't change this listener, but continue processing
1:                     //If the value is mutable then we may be ok!
1:                     printWarning(listener, "Reference Binding Listener");
1:                     processMetadata(listenerComponent);
1:                 }
1:             } finally {
1:             processingStack.removeLast();
1:             }
1:     
1:       
1:         if(!!! entries.isEmpty()) {
1:           
1:             try {
1:                 if(metadata instanceof MutablePropsMetadata) {
1:                     processingStack.add("Properties->");
1:                     MutablePropsMetadata mpm = (MutablePropsMetadata) metadata;
1:                 
0:                     for (MapEntry entry : entries) {
1:                         mpm.removeEntry(entry);
1:                     }
0:                     for (MapEntry entry : processMapEntries(entries)) {
1:                         mpm.addEntry(entry);
1:                     }
1:                 } else {
1:                     printWarning(metadata, "Properties");
1:                     processingStack.add("Properties->");
1:                     processMapEntries(entries);
1:                 }
1:             } finally {
1:               processingStack.removeLast();
1:             }
1:         if(!!! entries.isEmpty()) {
1:           
1:             try {
1:                 if(metadata instanceof MutableMapMetadata) {
1:                     processingStack.add("Map->");
1:                     MutableMapMetadata mmm = (MutableMapMetadata) metadata;
1:                 
0:                     for (MapEntry entry : entries) {
1:                         mmm.removeEntry(entry);
1:                     }
0:                     for (MapEntry entry : processMapEntries(entries)) {
1:                         mmm.addEntry(entry);
1:                     }
1:                 } else {
1:                     printWarning(metadata, "Map");
1:                     processingStack.add("Map->");
1:                     processMapEntries(entries);
1:                 }
1:             } finally {
1:               processingStack.removeLast();
1:             }
1:             try {
1:                 processingStack.add("Map Entry Key: " + entry.getKey() + " Value: " + entry.getValue() + "->" );
1:             
1:                 if(entry instanceof MutableMapEntry) {
0:                     ((MutableMapEntry) entry).setKey((NonNullMetadata) processMetadata(entry.getKey()));
0:                     ((MutableMapEntry) entry).setValue(processMetadata(entry.getValue()));
1:                 } else {
1:                   printWarning(entry, "Map Entry");
1:                   processMetadata(entry.getKey());
1:                   processMetadata(entry.getValue());
1:                 }
1:             } finally {
1:                 processingStack.removeLast();
1:             }
1:       
1:         if(!!! values.isEmpty()) {
1:         
1:             try {
1:                 if(metadata instanceof MutableCollectionMetadata) {
1:                     processingStack.add("Collection type: " + metadata.getValueType() + "->");
1:                     MutableCollectionMetadata mcm = (MutableCollectionMetadata) metadata;
1:                 
1:                     for (Metadata value : values) {
1:                         mcm.removeValue(value);
1:                     }
1:                     for (Metadata value : values) {
1:                         mcm.addValue(processMetadata(value));
1:                     }
1:                 } else {
1:                     printWarning(metadata, "Collection type: " + metadata.getValueType());
1:                     processingStack.add("Collection type: " + metadata.getValueType() + "->");
1:                     for (Metadata value : values) {
1:                        processMetadata(value);
1:                     }
1:                 }
1:             } finally {
1:               processingStack.removeLast();
1:             }
1:       
1:     private void printWarning(Object immutable, String processingType) {
1:         StringBuilder sb = new StringBuilder("The property placeholder processor for ");
1:         sb.append(placeholderPrefix).append(',').append(" ").append(placeholderSuffix)
0:         .append(" in bundle ").append(blueprintBundle.getSymbolicName()).append("_")
1:         .append(blueprintBundle.getVersion()).append(" found an immutable ").append(processingType)
1:         .append(" at location ");
1:         
1:         for(String s : processingStack) {
1:             sb.append(s);
1:         }
1:         
1:         sb.append(". This may prevent properties, beans, or other items referenced by this component from being properly processed.");
1:         
1:         LOGGER.info(sb.toString());
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
author:Lei Wang
-------------------------------------------------------------------------------
commit:03b9eab
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractPropertyPlaceholder.class);
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected String retrieveValue(String expression) {
1:         return getProperty(expression);
0:     }
0:     
1:             String rep = retrieveValue(matcher.group(1));
/////////////////////////////////////////////////////////////////////////
1:                 String v = metadata.getStringValue();
1:                 LOGGER.debug("Before process: {}", v);
1:                 retrievedValue = processString(v);
1:                 LOGGER.debug("After process: {}", retrievedValue);
0:                 
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:f822e15
/////////////////////////////////////////////////////////////////////////
1:             pattern = Pattern.compile("\\Q" + placeholderPrefix + "\\E(.+?)\\Q" + placeholderSuffix + "\\E");
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:76b662a
/////////////////////////////////////////////////////////////////////////
1:  * @version $Rev$, $Date$
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.ext;
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
1: import org.apache.aries.blueprint.mutable.MutableBeanArgument;
1: import org.apache.aries.blueprint.mutable.MutableBeanMetadata;
1: import org.apache.aries.blueprint.mutable.MutableBeanProperty;
1: import org.apache.aries.blueprint.mutable.MutableCollectionMetadata;
1: import org.apache.aries.blueprint.mutable.MutableMapEntry;
1: import org.apache.aries.blueprint.mutable.MutableMapMetadata;
1: import org.apache.aries.blueprint.mutable.MutablePropsMetadata;
1: import org.apache.aries.blueprint.mutable.MutableReferenceListener;
1: import org.apache.aries.blueprint.mutable.MutableRegistrationListener;
1: import org.apache.aries.blueprint.mutable.MutableServiceMetadata;
============================================================================