1:628add4: /**
1:628add4:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:628add4:  *  contributor license agreements.  See the NOTICE file distributed with
1:628add4:  *  this work for additional information regarding copyright ownership.
1:628add4:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:628add4:  *  (the "License"); you may not use this file except in compliance with
1:628add4:  *  the License.  You may obtain a copy of the License at
1:628add4:  *
1:628add4:  *     http://www.apache.org/licenses/LICENSE-2.0
1:628add4:  *
1:628add4:  *  Unless required by applicable law or agreed to in writing, software
1:628add4:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:628add4:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:628add4:  *  See the License for the specific language governing permissions and
1:628add4:  *  limitations under the License.
1:628add4:  */
1:56a6860: package org.apache.aries.samples.ariestrader.util;
3:628add4: 
1:628add4: import java.math.BigDecimal;
1:628add4: import java.util.ArrayList;
1:628add4: import java.util.Random;
1:628add4: 
1:628add4: 
1:628add4: /**
1:628add4:  * TradeConfig is a JavaBean holding all configuration and runtime parameters for the Trade application
1:628add4:  * TradeConfig sets runtime parameters such as the RunTimeMode (EJB3, DIRECT, SESSION3, JDBC, JPA)
1:628add4:  *
1:628add4:  */
1:628add4: 
1:628add4: public class TradeConfig {
1:628add4: 
1:628add4: 	/* Trade Runtime Configuration Parameters */
1:628add4: 
1:628add4: 	/* Trade Runtime Mode parameters */
1:8ef753d:     public static String[] runTimeModeNames = { "JDBC", 
1:af24676:                                                 "JPA App Managed",
1:af24676:                                                 "JPA Container Managed"};
1:8ef753d:     public static enum ModeType{JDBC,JPA_AM,JPA_CM}
1:8ef753d:     public static ModeType runTimeMode = ModeType.JDBC;
1:628add4: 	
1:628add4:     /* Trade JPA Layer parameters */
1:628add4: 	public static String[] jpaLayerNames = {"OpenJPA", "Hibernate"};
1:628add4: 	public static final int OPENJPA = 0;
1:628add4: 	public static final int HIBERNATE = 1;
1:628add4: 	public static int jpaLayer = OPENJPA;
1:628add4: 
1:628add4: 	public static String[] orderProcessingModeNames =
1:628add4: 		{ "Synchronous", "Asynchronous_2-Phase" };
1:628add4: 	public static final int SYNCH = 0;
1:628add4: 	public static final int ASYNCH_2PHASE = 1;
1:628add4: 	public static int orderProcessingMode = SYNCH;
1:628add4: 
1:628add4: 	public static String[] accessModeNames = { "Standard", "WebServices" };
1:628add4: 	public static final int STANDARD = 0;
1:628add4: 	public static final int WEBSERVICES = 1;
1:628add4: 	private static int accessMode = STANDARD;
1:628add4: 
1:628add4: 	/* Trade Scenario Workload parameters */
1:628add4: 	public static String[] workloadMixNames = { "Standard", "High-Volume", };
1:628add4: 	public final static int SCENARIOMIX_STANDARD = 0;
1:628add4: 	public final static int SCENARIOMIX_HIGHVOLUME = 1;
1:628add4: 	public static int workloadMix = SCENARIOMIX_STANDARD;
1:628add4: 
1:628add4: 	/* Trade Web Interface parameters */
1:628add4: 	public static String[] webInterfaceNames = { "JSP", "JSP-Images" };
1:628add4: 	public static final int JSP = 0;
1:628add4: 	public static final int JSP_Images = 1;
1:628add4: 	public static int webInterface = JSP;
1:628add4: 
1:628add4: 	/* Trade Caching Type parameters */
1:628add4: 	public static String[] cachingTypeNames = { "DistributedMap", "Command Caching", "No Caching" };
1:628add4: 	public static final int DISTRIBUTEDMAP = 0;
1:628add4: 	public static final int COMMAND_CACHING = 1;
1:628add4: 	public static final int NO_CACHING = 2;
1:628add4: 	public static int cachingType = NO_CACHING;
1:628add4: 	
1:628add4: 	/* Trade Database Scaling parameters*/
1:6502b53: 	private static int MAX_USERS = 200;
1:6502b53: 	private static int MAX_QUOTES = 400;
1:628add4: 
1:b8c0170: 	/* Trade Database specific parameters */
1:628add4: 	public static String JDBC_UID = null;
1:628add4: 	public static String JDBC_PWD = null;
1:628add4: 
1:863e294:         /* OSGi specific parameters */
1:7151c9b: 	public static String OSGI_SERVICE_PREFIX = "osgi:service/";
1:01ce653:         public static String OSGI_DS_NAME_FILTER = "(osgi.jndi.service.name=jdbc/NoTxTradeDataSource)";
1:863e294: 
1:628add4: 	/*Trade SOAP specific parameters */
1:628add4: 	private static String SoapURL =
1:56a6860: 		"http://localhost:8080/ariestrader/services/TradeWSServices";
1:628add4: 
1:628add4: 	/*Trade XA Datasource specific parameters */
1:628add4: 	public static boolean JDBCDriverNeedsGlobalTransaction = false;
1:628add4: 
1:37fe36d: 	/* Trade Config Miscellaneous items */
1:628add4: 	public static int KEYBLOCKSIZE = 1000;
1:628add4: 	public static int QUOTES_PER_PAGE = 10;
1:628add4: 	public static boolean RND_USER = true;
1:628add4: 	private static int MAX_HOLDINGS = 10;
1:628add4: 	private static int count = 0;
1:628add4: 	private static Object userID_count_semaphore = new Object();
1:628add4: 	private static int userID_count = 0;
1:628add4: 	private static String hostName = null;
1:628add4: 	private static Random r0 = new Random(System.currentTimeMillis());
1:628add4: 	private static Random randomNumberGenerator = r0;
1:628add4: 	public static final String newUserPrefix = "ru:";
1:628add4: 	public static final int verifyPercent = 5;
1:628add4: 	private static boolean trace = false;
1:628add4: 	private static boolean actionTrace = false;
1:628add4: 	private static boolean updateQuotePrices = true;
1:628add4: 	private static int primIterations = 1;
1:628add4: 	private static boolean longRun = true;
1:628add4: 	private static boolean publishQuotePriceChange = false;
1:628add4: 	
1:628add4: 	/**
1:628add4: 	 *   -1 means every operation
1:628add4: 	 *    0 means never perform a market summary
1:628add4: 	 *  > 0 means number of seconds between summaries.  These will be
1:628add4: 	 *      synchronized so only one transaction in this period will create a summary and 
1:628add4: 	 *      will cache its results.
1:628add4: 	 */
1:628add4: 	private static int  marketSummaryInterval = 20;
1:628add4: 
1:628add4: 	/*
1:628add4: 	 * Penny stocks is a problem where the random price change factor gets a stock
1:628add4: 	 * down to $.01.  In this case trade jumpstarts the price back to $6.00 to
1:628add4: 	 * keep the math interesting.
1:628add4: 	 */
1:628add4: 	public static BigDecimal PENNY_STOCK_PRICE;
1:628add4: 	public static BigDecimal PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER;
1:628add4: 	static {
1:628add4: 		PENNY_STOCK_PRICE = new BigDecimal(0.01);
1:628add4: 		PENNY_STOCK_PRICE =
1:628add4: 			PENNY_STOCK_PRICE.setScale(2, BigDecimal.ROUND_HALF_UP);
1:628add4: 		PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER = new BigDecimal(600.0);
1:628add4: 		PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER.setScale(
1:628add4: 			2,
1:628add4: 			BigDecimal.ROUND_HALF_UP);
1:628add4: 	}
1:628add4: 
1:628add4: 	/* CJB (DAYTRADER-25) - Also need to impose a ceiling on the quote price to ensure
1:628add4: 	 * prevent account and holding balances from exceeding the databases decimal precision.
1:628add4: 	 * At some point, this maximum value can be used to trigger a stock split.
1:628add4: 	 */
1:628add4: 
1:628add4: 	public static BigDecimal MAXIMUM_STOCK_PRICE;
1:628add4: 	public static BigDecimal MAXIMUM_STOCK_SPLIT_MULTIPLIER;
1:628add4: 	static {
1:628add4: 		MAXIMUM_STOCK_PRICE = new BigDecimal(400);
1:628add4: 		MAXIMUM_STOCK_PRICE.setScale(2, BigDecimal.ROUND_HALF_UP);
1:628add4: 		MAXIMUM_STOCK_SPLIT_MULTIPLIER = new BigDecimal(0.5);
1:628add4: 		MAXIMUM_STOCK_SPLIT_MULTIPLIER.setScale(2, BigDecimal.ROUND_HALF_UP);
1:628add4: 	}
1:628add4: 
1:628add4: 	/* Trade Scenario actions mixes. Each of the array rows represents a specific Trade Scenario Mix. 
1:628add4: 	   The columns give the percentages for each action in the column header. Note: "login" is always 0. 
1:628add4: 	   logout represents both login and logout (because each logout operation will cause a new login when
1:628add4: 	   the user context attempts the next action.
1:628add4: 	 */
1:628add4: 	/* Trade Scenario Workload parameters */
1:628add4: 	public final static int HOME_OP = 0;
1:628add4: 	public final static int QUOTE_OP = 1;
1:628add4: 	public final static int LOGIN_OP = 2;
1:628add4: 	public final static int LOGOUT_OP = 3;
1:628add4: 	public final static int REGISTER_OP = 4;
1:628add4: 	public final static int ACCOUNT_OP = 5;
1:628add4: 	public final static int PORTFOLIO_OP = 6;
1:628add4: 	public final static int BUY_OP = 7;
1:628add4: 	public final static int SELL_OP = 8;
1:628add4: 	public final static int UPDATEACCOUNT_OP = 9;
1:628add4: 
1:628add4: 	private static int scenarioMixes[][] = {
1:628add4: 		//	h	q	l	o	r	a	p	b	s	u
1:628add4: 		{ 20, 40, 0, 4, 2, 10, 12, 4, 4, 4 }, //STANDARD
1:628add4: 		{
1:628add4: 			20, 40, 0, 4, 2, 7, 7, 7, 7, 6 }, //High Volume
1:628add4: 	};
1:628add4: 	private static char actions[] =
1:628add4: 		{ 'h', 'q', 'l', 'o', 'r', 'a', 'p', 'b', 's', 'u' };
1:628add4: 	private static int sellDeficit = 0;
1:628add4: 	//Tracks the number of buys over sell when a users portfolio is empty
1:628add4: 	// Used to maintain the correct ratio of buys/sells
1:628add4: 
1:628add4: 	/* JSP pages for all Trade Actions */
1:628add4: 
1:628add4: 	public final static int WELCOME_PAGE = 0;
1:628add4: 	public final static int REGISTER_PAGE = 1;
1:628add4: 	public final static int PORTFOLIO_PAGE = 2;
1:628add4: 	public final static int QUOTE_PAGE = 3;
1:628add4: 	public final static int HOME_PAGE = 4;
1:628add4: 	public final static int ACCOUNT_PAGE = 5;
1:628add4: 	public final static int ORDER_PAGE = 6;
1:628add4: 	public final static int CONFIG_PAGE = 7;
1:628add4: 	public final static int STATS_PAGE = 8;
1:628add4: 
1:628add4: 	//FUTURE Add XML/XSL View
1:628add4: 	public static String webUI[][] =
1:628add4: 		{
1:628add4: 			{
1:628add4: 				"/welcome.jsp",
1:628add4: 				"/register.jsp",
1:628add4: 				"/portfolio.jsp",
1:628add4: 				"/quote.jsp",
1:628add4: 				"/tradehome.jsp",
1:628add4: 				"/account.jsp",
1:628add4: 				"/order.jsp",
1:628add4: 				"/config.jsp",
1:628add4: 				"/runStats.jsp" },
1:628add4: 		//JSP Interface
1:628add4: 		{
1:628add4: 			"/welcomeImg.jsp",
1:628add4: 				"/registerImg.jsp",
1:628add4: 				"/portfolioImg.jsp",
1:628add4: 				"/quoteImg.jsp",
1:628add4: 				"/tradehomeImg.jsp",
1:628add4: 				"/accountImg.jsp",
1:628add4: 				"/orderImg.jsp",
1:628add4: 				"/config.jsp",
1:628add4: 				"/runStats.jsp" },
1:628add4: 		//JSP Interface	
1:628add4: 	};
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Return the hostname for this system
1:628add4: 	 * Creation date: (2/16/2000 9:02:25 PM)
1:628add4: 	 */
1:628add4: 
1:628add4: 	private static String getHostname() {
1:628add4: 		try {
1:628add4: 			if (hostName == null) {
1:628add4: 				hostName = java.net.InetAddress.getLocalHost().getHostName();
1:b8c0170: 				//Strip of fully qualified domain if necessary
1:628add4: 				try {
1:628add4: 					hostName = hostName.substring(0, hostName.indexOf('.'));
1:628add4: 				} catch (Exception e) {
1:628add4: 				}
1:628add4: 			}
1:628add4: 		} catch (Exception e) {
1:628add4: 			Log.error(
1:628add4: 				"Exception getting local host name using 'localhost' - ",
1:628add4: 				e);
1:628add4: 			hostName = "localhost";
1:628add4: 		}
1:628add4: 		return hostName;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Return a Trade UI Web page based on the current configuration
1:628add4: 	 * This may return a JSP page or a Servlet page 
1:628add4: 	 * Creation date: (3/14/2000 9:08:34 PM)
1:628add4: 	 */
1:628add4: 
1:628add4: 	public static String getPage(int pageNumber) {
1:628add4: 		return webUI[webInterface][pageNumber];
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Return the list of run time mode names
1:628add4: 	 * Creation date: (3/8/2000 5:58:34 PM)
1:628add4: 	 * @return java.lang.String[]
1:628add4: 	 */
1:628add4: 	public static java.lang.String[] getRunTimeModeNames() {
1:628add4: 		return runTimeModeNames;
1:628add4: 	}
1:628add4: 
1:628add4: 	private static int scenarioCount = 0;
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Return a Trade Scenario Operation based on the setting of the current mix (TradeScenarioMix)
1:628add4: 	 * Creation date: (2/10/2000 9:08:34 PM)
1:628add4: 	 */
1:628add4: 
1:628add4: 	public static char getScenarioAction(boolean newUser) {
1:628add4: 		int r = rndInt(100); //0 to 99 = 100
1:628add4: 		int i = 0;
1:628add4: 		int sum = scenarioMixes[workloadMix][i];
1:628add4: 		while (sum <= r) {
1:628add4: 			i++;
1:628add4: 			sum += scenarioMixes[workloadMix][i];
1:628add4: 		}
1:628add4: 
1:628add4: 		incrementScenarioCount();
1:628add4: 
1:628add4: 		/* In TradeScenarioServlet, if a sell action is selected, but the users portfolio is empty,
1:628add4: 		 * a buy is executed instead and sellDefecit is incremented. This allows the number of buy/sell
1:628add4: 		 * operations to stay in sync w/ the given Trade mix.
1:628add4: 		 */
1:628add4: 
1:628add4: 		if ((!newUser) && (actions[i] == 'b')) {
1:628add4: 			synchronized (TradeConfig.class) {
1:628add4: 				if (sellDeficit > 0) {
1:628add4: 					sellDeficit--;
1:628add4: 					return 's';
1:628add4: 					//Special case for TradeScenarioServlet to note this is a buy switched to a sell to fix sellDeficit
1:628add4: 				}
1:628add4: 			}
1:628add4: 		}
1:628add4: 
1:628add4: 		return actions[i];
1:628add4: 	}
1:628add4: 
1:628add4: 	public static String getUserID() {
1:628add4: 		String userID;
1:628add4: 		if (RND_USER) {
1:628add4: 			userID = rndUserID();
1:628add4: 		} else {
1:628add4: 			userID = nextUserID();
1:628add4: 		}
1:628add4: 		return userID;
1:628add4: 	}
1:628add4: 	private static final BigDecimal orderFee = new BigDecimal("24.95");
1:628add4: 	private static final BigDecimal cashFee = new BigDecimal("0.0");
1:628add4: 	public static BigDecimal getOrderFee(String orderType) {
1:628add4: 		if ((orderType.compareToIgnoreCase("BUY") == 0)
1:628add4: 			|| (orderType.compareToIgnoreCase("SELL") == 0))
1:628add4: 			return orderFee;
1:628add4: 
1:628add4: 		return cashFee;
1:628add4: 
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Increment the sell deficit counter
1:628add4: 	 * Creation date: (6/21/2000 11:33:45 AM)
1:628add4: 	 */
1:628add4: 	public synchronized static void incrementSellDeficit() {
1:628add4: 		sellDeficit++;
1:628add4: 	}
1:628add4: 
1:628add4: 	public static String nextUserID() {
1:628add4: 		String userID;
1:628add4: 		synchronized (userID_count_semaphore) {
1:628add4: 			userID = "uid:" + userID_count;
1:628add4: 			userID_count++;
1:628add4: 			if (userID_count % MAX_USERS == 0) {
1:628add4: 				userID_count = 0;
1:628add4: 			}
1:628add4: 		}
1:628add4: 		return userID;
1:628add4: 	}
1:628add4: 	public static double random() {
1:628add4: 		return randomNumberGenerator.nextDouble();
1:628add4: 	}
1:628add4: 	public static String rndAddress() {
1:628add4: 		return rndInt(1000) + " Oak St.";
1:628add4: 	}
1:628add4: 	public static String rndBalance() {
1:628add4: 		//Give all new users a cool mill in which to trade
1:628add4: 		return "1000000";
1:628add4: 	}
1:628add4: 	public static String rndCreditCard() {
1:628add4: 		return rndInt(100)
1:628add4: 			+ "-"
1:628add4: 			+ rndInt(1000)
1:628add4: 			+ "-"
1:628add4: 			+ rndInt(1000)
1:628add4: 			+ "-"
1:628add4: 			+ rndInt(1000);
1:628add4: 	}
1:628add4: 	public static String rndEmail(String userID) {
1:628add4: 		return userID + "@" + rndInt(100) + ".com";
1:628add4: 	}
1:628add4: 	public static String rndFullName() {
1:628add4: 		return "first:" + rndInt(1000) + " last:" + rndInt(5000);
1:628add4: 	}
1:628add4: 	public static int rndInt(int i) {
1:628add4: 		return (new Float(random() * i)).intValue();
1:628add4: 	}
1:628add4: 	public static float rndFloat(int i) {
1:628add4: 		return (new Float(random() * i)).floatValue();
1:628add4: 	}
1:628add4: 	public static BigDecimal rndBigDecimal(float f) {
1:628add4: 		return (new BigDecimal(random() * f)).setScale(
1:628add4: 			2,
1:628add4: 			BigDecimal.ROUND_HALF_UP);
1:628add4: 	}
1:628add4: 
1:628add4: 	public static boolean rndBoolean() {
1:628add4: 		return randomNumberGenerator.nextBoolean();
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Returns a new Trade user
1:628add4: 	 * Creation date: (2/16/2000 8:50:35 PM)
1:628add4: 	 */
1:628add4: 	public synchronized static String rndNewUserID() {
1:628add4: 
1:628add4: 		return newUserPrefix
1:628add4: 			+ getHostname()
1:628add4: 			+ System.currentTimeMillis()
1:628add4: 			+ count++;
1:628add4: 	}
1:628add4: 
1:628add4: 	public static float rndPrice() {
1:628add4: 		return ((new Integer(rndInt(200))).floatValue()) + 1.0f;
1:628add4: 	}
1:628add4: 	private final static BigDecimal ONE = new BigDecimal(1.0);
1:628add4: 	public static BigDecimal getRandomPriceChangeFactor() {
1:628add4: 		double percentGain = rndFloat(1) * 0.2;
1:628add4: 		if (random() < .5)
1:628add4: 			percentGain *= -1;
1:628add4: 		percentGain += 1;
1:628add4: 
1:628add4: 		// change factor is between +/- 20%
1:628add4: 		BigDecimal percentGainBD =
1:628add4: 			(new BigDecimal(percentGain)).setScale(2, BigDecimal.ROUND_HALF_UP);
1:628add4: 		if (percentGainBD.doubleValue() <= 0.0)
1:628add4: 			percentGainBD = ONE;
1:628add4: 
1:628add4: 		return percentGainBD;
1:628add4: 	}
1:628add4: 
1:628add4: 	public static float rndQuantity() {
1:628add4: 		return ((new Integer(rndInt(200))).floatValue()) + 1.0f;
1:628add4: 	}
1:628add4: 
1:628add4: 	public static String rndSymbol() {
1:628add4: 		return "s:" + rndInt(MAX_QUOTES - 1);
1:628add4: 	}
1:628add4: 	public static String rndSymbols() {
1:628add4: 
1:628add4: 		String symbols = "";
1:628add4: 		int num_symbols = rndInt(QUOTES_PER_PAGE);
1:628add4: 
1:628add4: 		for (int i = 0; i <= num_symbols; i++) {
1:628add4: 			symbols += "s:" + rndInt(MAX_QUOTES - 1);
1:628add4: 			if (i < num_symbols)
1:628add4: 				symbols += ",";
1:628add4: 		}
1:628add4: 		return symbols;
1:628add4: 	}
1:628add4: 
1:628add4: 	public static String rndUserID() {
1:628add4: 		String nextUser = getNextUserIDFromDeck();
1:628add4: 		if (Log.doTrace())
1:628add4: 			Log.trace("TradeConfig:rndUserID -- new trader = " + nextUser);
1:628add4: 
1:628add4: 		return nextUser;
1:628add4: 	}
1:628add4: 
1:628add4: 	private static synchronized String getNextUserIDFromDeck() {
1:628add4: 		int numUsers = getMAX_USERS();
1:628add4: 		if (deck == null) {
1:628add4: 			deck = new ArrayList(numUsers);
1:628add4: 			for (int i = 0; i < numUsers; i++)
1:628add4: 				deck.add(i, new Integer(i));
1:628add4: 			java.util.Collections.shuffle(deck, r0);
1:628add4: 		}
1:628add4: 		if (card >= numUsers)
1:628add4: 			card = 0;
1:628add4: 		return "uid:" + deck.get(card++);
1:628add4: 
1:628add4: 	}
1:628add4: 
1:628add4: 	//Trade implements a card deck approach to selecting 
1:628add4: 	// users for trading with tradescenarioservlet
1:628add4: 	private static ArrayList deck = null;
1:628add4: 	private static int card = 0;
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Set the list of run time mode names
1:628add4: 	 * Creation date: (3/8/2000 5:58:34 PM)
1:628add4: 	 * @param newRunTimeModeNames java.lang.String[]
1:628add4: 	 */
1:628add4: 	public static void setRunTimeModeNames(
1:628add4: 		java.lang.String[] newRunTimeModeNames) {
1:628add4: 		runTimeModeNames = newRunTimeModeNames;
1:628add4: 	}
1:628add4: 	/**
1:628add4: 	 * This is a convenience method for servlets to set Trade configuration parameters
1:628add4: 	 * from servlet initialization parameters. The servlet provides the init param and its
1:628add4: 	 * value as strings. This method then parses the parameter, converts the value to the
1:628add4: 	 * correct type and sets the corresponding TradeConfig parameter to the converted value
1:628add4: 	 * 
1:628add4: 	 */
1:628add4: 	public static void setConfigParam(String parm, String value) {
1:628add4: 		Log.log("TradeConfig setting parameter: " + parm + "=" + value);
1:628add4: 		// Compare the parm value to valid TradeConfig parameters that can be set
1:628add4: 		// by servlet initialization
1:628add4: 
1:628add4: 		// First check the proposed new parm and value - if empty or null ignore it
1:628add4: 		if (parm == null)
1:628add4: 			return;
1:628add4: 		parm = parm.trim();
1:628add4: 		if (parm.length() <= 0)
1:628add4: 			return;
1:628add4: 		if (value == null)
1:628add4: 			return;
1:628add4: 		value = value.trim();
1:628add4: 
1:628add4: 		if (parm.equalsIgnoreCase("runTimeMode")) {
1:628add4: 			try {
1:628add4: 				for (int i = 0; i < runTimeModeNames.length; i++) {
1:628add4: 					if (value.equalsIgnoreCase(runTimeModeNames[i])) {
1:8ef753d: 						setRunTimeMode(ModeType.values()[i]);
1:628add4: 						break;
1:628add4: 					}
1:628add4: 				}
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "trying to set runtimemode to "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:8ef753d: 						+ runTimeModeNames[getRunTimeMode().ordinal()],
1:628add4: 					e);
1:628add4: 			} // If the value is bad, simply revert to current
1:628add4: 		} else if (parm.equalsIgnoreCase("orderProcessingMode")) {
1:628add4: 			try {
1:628add4: 				for (int i = 0; i < orderProcessingModeNames.length; i++) {
1:628add4: 					if (value.equalsIgnoreCase(orderProcessingModeNames[i])) {
1:628add4: 						orderProcessingMode = i;
1:628add4: 						break;
1:628add4: 					}
1:628add4: 				}
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "trying to set orderProcessingMode to "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:628add4: 						+ orderProcessingModeNames[orderProcessingMode],
1:628add4: 					e);
1:628add4: 			} // If the value is bad, simply revert to current
1:628add4: 		} else if (parm.equalsIgnoreCase("accessMode")) {		
1:628add4: 			try {
1:628add4: 				for (int i = 0; i < accessModeNames.length; i++) {
1:628add4: 					if (value.equalsIgnoreCase(accessModeNames[i])) {
1:628add4: 						accessMode = i;
1:628add4: 						break;
1:628add4: 					}
1:628add4: 				}
1:628add4: 			}
1:628add4: 			catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "trying to set accessMode to "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:628add4: 						+ accessModeNames[accessMode],
1:628add4: 					e);
1:628add4: 			}
1:628add4: 		} else if (parm.equalsIgnoreCase("webServicesEndpoint")) {
1:628add4: 			try {
1:628add4: 				setSoapURL(value);
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "Setting web services endpoint",
1:628add4: 					e);
1:628add4: 			} //On error, revert to saved		
1:628add4: 		} else if (parm.equalsIgnoreCase("workloadMix")) {
1:628add4: 			try {
1:628add4: 				for (int i = 0; i < workloadMixNames.length; i++) {
1:628add4: 					if (value.equalsIgnoreCase(workloadMixNames[i])) {
1:628add4: 						workloadMix = i;
1:628add4: 						break;
1:628add4: 					}
1:628add4: 				}
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "trying to set workloadMix to "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:628add4: 						+ workloadMixNames[workloadMix],
1:628add4: 					e);
1:628add4: 			} // If the value is bad, simply revert to current		
1:628add4: 		} else if (parm.equalsIgnoreCase("WebInterface")) {
1:628add4: 			try {
1:628add4: 				for (int i = 0; i < webInterfaceNames.length; i++) {
1:628add4: 					if (value.equalsIgnoreCase(webInterfaceNames[i])) {
1:628add4: 						webInterface = i;
1:628add4: 						break;
1:628add4: 					}
1:628add4: 				}
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "trying to set WebInterface to "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:628add4: 						+ webInterfaceNames[webInterface],
1:628add4: 					e);
1:628add4: 
1:628add4: 			} // If the value is bad, simply revert to current
1:628add4: 		} else if (parm.equalsIgnoreCase("CachingType")) {
1:628add4: 			try {
1:628add4: 				for (int i = 0; i < cachingTypeNames.length; i++) {
1:628add4: 					if (value.equalsIgnoreCase(cachingTypeNames[i])) {
1:628add4: 						cachingType = i;
1:628add4: 						break;
1:628add4: 					}
1:628add4: 				}
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "trying to set CachingType to "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:628add4: 						+ cachingTypeNames[cachingType],
1:628add4: 					e);
1:628add4: 			} // If the value is bad, simply revert to current
1:628add4: 		} else if (parm.equalsIgnoreCase("maxUsers")) {
1:628add4: 			try {
1:628add4: 				MAX_USERS = Integer.parseInt(value);
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "Setting maxusers, error parsing string to int:"
1:628add4: 						+ value
1:628add4: 						+ "revering to current value: "
1:628add4: 						+ MAX_USERS,
1:628add4: 					e);
1:628add4: 			} //On error, revert to saved		
1:628add4: 		} else if (parm.equalsIgnoreCase("maxQuotes")) {
1:628add4: 			try {
1:628add4: 				MAX_QUOTES = Integer.parseInt(value);
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(...) minor exception caught"
1:628add4: 						+ "Setting max_quotes, error parsing string to int "
1:628add4: 						+ value
1:628add4: 						+ "reverting to current value: "
1:628add4: 						+ MAX_QUOTES,
1:628add4: 					e);
1:628add4: 			} //On error, revert to saved		
1:628add4: 		} else if (parm.equalsIgnoreCase("primIterations")) {
1:628add4: 			try {
1:628add4: 				primIterations = Integer.parseInt(value);
1:628add4: 			} catch (Exception e) {
1:628add4: 				Log.error(
1:628add4: 					"TradeConfig.setConfigParm(..): minor exception caught"
1:628add4: 						+ "Setting primIterations, error parsing string to int:"
1:628add4: 						+ value
1:628add4: 						+ "revering to current value: "
1:628add4: 						+ primIterations,
1:628add4: 					e);
1:628add4: 			} //On error, revert to saved
1:628add4: 		}		
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the orderProcessingModeNames
1:628add4: 	 * @return Returns a String[]
1:628add4: 	 */
1:628add4: 	public static String[] getOrderProcessingModeNames() {
1:628add4: 		return orderProcessingModeNames;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the workloadMixNames
1:628add4: 	 * @return Returns a String[]
1:628add4: 	 */
1:628add4: 	public static String[] getWorkloadMixNames() {
1:628add4: 		return workloadMixNames;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the webInterfaceNames
1:628add4: 	 * @return Returns a String[]
1:628add4: 	 */
1:628add4: 	public static String[] getWebInterfaceNames() {
1:628add4: 		return webInterfaceNames;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the webInterfaceNames
1:628add4: 	 * @return Returns a String[]
1:628add4: 	 */
1:628add4: 	public static String[] getCachingTypeNames() {
1:628add4: 		return cachingTypeNames;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the scenarioMixes
1:628add4: 	 * @return Returns a int[][]
1:628add4: 	 */
1:628add4: 	public static int[][] getScenarioMixes() {
1:628add4: 		return scenarioMixes;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the trace
1:628add4: 	 * @return Returns a boolean
1:628add4: 	 */
1:628add4: 	public static boolean getTrace() {
1:628add4: 		return trace;
1:628add4: 	}
1:628add4: 	/**
1:628add4: 	 * Sets the trace
1:628add4: 	 * @param trace The trace to set
1:628add4: 	 */
1:628add4: 	public static void setTrace(boolean traceValue) {
1:628add4: 		trace = traceValue;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the mAX_USERS.
1:628add4: 	 * @return Returns a int
1:628add4: 	 */
1:628add4: 	public static int getMAX_USERS() {
1:628add4: 		return MAX_USERS;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the mAX_USERS.
1:628add4: 	 * @param mAX_USERS The mAX_USERS to set
1:628add4: 	 */
1:628add4: 	public static void setMAX_USERS(int mAX_USERS) {
1:628add4: 		MAX_USERS = mAX_USERS;
1:628add4: 		deck = null; // reset the card deck for selecting users
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the mAX_QUOTES.
1:628add4: 	 * @return Returns a int
1:628add4: 	 */
1:628add4: 	public static int getMAX_QUOTES() {
1:628add4: 		return MAX_QUOTES;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the mAX_QUOTES.
1:628add4: 	 * @param mAX_QUOTES The mAX_QUOTES to set
1:628add4: 	 */
1:628add4: 	public static void setMAX_QUOTES(int mAX_QUOTES) {
1:628add4: 		MAX_QUOTES = mAX_QUOTES;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the mAX_HOLDINGS.
1:628add4: 	 * @return Returns a int
1:628add4: 	 */
1:628add4: 	public static int getMAX_HOLDINGS() {
1:628add4: 		return MAX_HOLDINGS;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the mAX_HOLDINGS.
1:628add4: 	 * @param mAX_HOLDINGS The mAX_HOLDINGS to set
1:628add4: 	 */
1:628add4: 	public static void setMAX_HOLDINGS(int mAX_HOLDINGS) {
1:628add4: 		MAX_HOLDINGS = mAX_HOLDINGS;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the actionTrace.
1:628add4: 	 * @return Returns a boolean
1:628add4: 	 */
1:628add4: 	public static boolean getActionTrace() {
1:628add4: 		return actionTrace;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the actionTrace.
1:628add4: 	 * @param actionTrace The actionTrace to set
1:628add4: 	 */
1:628add4: 	public static void setActionTrace(boolean actionTrace) {
1:628add4: 		TradeConfig.actionTrace = actionTrace;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the scenarioCount.
1:628add4: 	 * @return Returns a int
1:628add4: 	 */
1:628add4: 	public static int getScenarioCount() {
1:628add4: 		return scenarioCount;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the scenarioCount.
1:628add4: 	 * @param scenarioCount The scenarioCount to set
1:628add4: 	 */
1:628add4: 	public static void setScenarioCount(int scenarioCount) {
1:628add4: 		TradeConfig.scenarioCount = scenarioCount;
1:628add4: 	}
1:628add4: 
1:628add4: 	public static synchronized void incrementScenarioCount() {
1:628add4: 		scenarioCount++;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the jdbc driver needs global transaction
1:628add4: 	 * Some XA Drivers require a global transaction to be started
1:628add4: 	 * for all SQL calls.  To work around this, set this to true
1:628add4: 	 * to cause the direct mode to start a user transaction.
1:628add4: 	 * @return Returns a boolean
1:628add4: 	 */
1:628add4: 	public static boolean getJDBCDriverNeedsGlobalTransaction() {
1:628add4: 		return JDBCDriverNeedsGlobalTransaction;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the jdbc driver needs global transaction
1:628add4:          * @param JDBCDriverNeedsGlobalTransactionVal the value
1:628add4: 	 */
1:628add4: 	public static void setJDBCDriverNeedsGlobalTransaction(boolean JDBCDriverNeedsGlobalTransactionVal) {
1:628add4: 		JDBCDriverNeedsGlobalTransaction = JDBCDriverNeedsGlobalTransactionVal;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Gets the updateQuotePrices.
1:628add4: 	 * @return Returns a boolean
1:628add4: 	 */
1:628add4: 	public static boolean getUpdateQuotePrices() {
1:628add4: 		return updateQuotePrices;
1:628add4: 	}
1:628add4: 
1:628add4: 	/**
1:628add4: 	 * Sets the updateQuotePrices.
1:628add4: 	 * @param updateQuotePrices The updateQuotePrices to set
1:628add4: 	 */
1:628add4: 	public static void setUpdateQuotePrices(boolean updateQuotePrices) {
1:628add4: 		TradeConfig.updateQuotePrices = updateQuotePrices;
1:628add4: 	}
1:628add4: 	
1:628add4: 	public static String getSoapURL() {
1:628add4: 		return SoapURL;
1:628add4: 	}
1:628add4: 	
1:628add4: 	public static void setSoapURL(String value) {
1:628add4: 		SoapURL = value;
1:628add4: 	}
1:628add4: 	
1:628add4: 	public static int getAccessMode() {
1:628add4: 		return accessMode;
1:628add4: 	}
1:628add4: 	
1:628add4: 	public static void setAccessMode(int value) {
1:628add4: 		accessMode = value;
1:628add4: 	}
1:628add4: 
1:8ef753d:     public static ModeType getRunTimeMode() {
1:628add4:         return runTimeMode;
1:628add4:     }
1:628add4:     
1:8ef753d:     public static void setRunTimeMode(ModeType value) {
1:628add4:         runTimeMode = value;
1:628add4:     }
1:628add4: 
1:628add4: 	public static int getPrimIterations() {
1:628add4: 		return primIterations;
1:628add4: 	}
1:628add4: 	
1:628add4: 	public static void setPrimIterations(int iter) {
1:628add4: 		primIterations = iter;
1:628add4: 	}	
1:628add4: 
1:628add4:     public static boolean getLongRun() {
1:628add4:         return longRun;
1:628add4:     }
1:628add4: 
1:628add4:     public static void setLongRun(boolean longRun) {
1:628add4:         TradeConfig.longRun = longRun;
1:628add4:     }
1:628add4: 
1:628add4:     public static void setPublishQuotePriceChange(boolean publishQuotePriceChange) {
1:628add4:         TradeConfig.publishQuotePriceChange = publishQuotePriceChange;
1:628add4:     }
1:628add4:     
1:628add4:     public static boolean getPublishQuotePriceChange() {
1:628add4:         return publishQuotePriceChange;
1:628add4:     }
1:628add4: 
1:628add4:     public static void setMarketSummaryInterval(int seconds) {
1:628add4:         TradeConfig.marketSummaryInterval = seconds;
1:628add4:     }
1:628add4:     
1:628add4:     public static  int getMarketSummaryInterval() {
1:628add4:         return TradeConfig.marketSummaryInterval;
1:628add4:     }
1:628add4:     
1:628add4:     /**
1:628add4: 	 * Return the list of JPA Layer names
1:628add4: 	 * Creation date: (01/10/2009)
1:628add4: 	 * @return java.lang.String[]
1:628add4: 	 */
1:628add4: 	public static java.lang.String[] getJPALayerNames() {
1:628add4: 		return jpaLayerNames;
1:628add4:     }
1:628add4: 
1:628add4: }
============================================================================
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:7151c9b
/////////////////////////////////////////////////////////////////////////
1: 	public static String OSGI_SERVICE_PREFIX = "osgi:service/";
commit:8ef753d
/////////////////////////////////////////////////////////////////////////
1:     public static String[] runTimeModeNames = { "JDBC", 
1:     public static enum ModeType{JDBC,JPA_AM,JPA_CM}
1:     public static ModeType runTimeMode = ModeType.JDBC;
/////////////////////////////////////////////////////////////////////////
1: 						setRunTimeMode(ModeType.values()[i]);
/////////////////////////////////////////////////////////////////////////
1: 						+ runTimeModeNames[getRunTimeMode().ordinal()],
/////////////////////////////////////////////////////////////////////////
1:     public static ModeType getRunTimeMode() {
1:     public static void setRunTimeMode(ModeType value) {
commit:39f53f6
commit:b8c0170
/////////////////////////////////////////////////////////////////////////
1: 	/* Trade Database specific parameters */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				//Strip of fully qualified domain if necessary
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6502b53
/////////////////////////////////////////////////////////////////////////
1: 	private static int MAX_USERS = 200;
1: 	private static int MAX_QUOTES = 400;
commit:01ce653
/////////////////////////////////////////////////////////////////////////
1:         public static String OSGI_DS_NAME_FILTER = "(osgi.jndi.service.name=jdbc/NoTxTradeDataSource)";
commit:989ba4e
commit:863e294
/////////////////////////////////////////////////////////////////////////
1:         /* OSGi specific parameters */
0: 	public static String OSGI_SERVICE_PREFIX = "aries:services/";
0: 	public static String OSGI_DS_NAME_FILTER = "(osgi.jndi.serviceName=jdbc/TradeDataSource)";
1: 
commit:37fe36d
/////////////////////////////////////////////////////////////////////////
1: 	/* Trade Config Miscellaneous items */
commit:af24676
/////////////////////////////////////////////////////////////////////////
0:     public static String[] runTimeModeNames = { "Full EJB3", 
0:                                                 "Direct (JDBC)", 
0:                                                 "Session (EJB3) To Direct", 
0:                                                 "JDBC", 
1:                                                 "JPA App Managed",
1:                                                 "JPA Container Managed"};
0:     public static final int JPA_AM = 4;
0:     public static final int JPA_CM = 5;
commit:56a6860
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.samples.ariestrader.util;
/////////////////////////////////////////////////////////////////////////
1: 		"http://localhost:8080/ariestrader/services/TradeWSServices";
commit:3be9855
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.samples.daytrader.util;
commit:92b2ae7
commit:3d66c06
commit:628add4
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  */
0: package org.apache.geronimo.samples.daytrader.util;
1: 
1: import java.math.BigDecimal;
1: import java.util.ArrayList;
1: import java.util.Random;
1: 
1: 
1: /**
1:  * TradeConfig is a JavaBean holding all configuration and runtime parameters for the Trade application
1:  * TradeConfig sets runtime parameters such as the RunTimeMode (EJB3, DIRECT, SESSION3, JDBC, JPA)
1:  *
1:  */
1: 
1: public class TradeConfig {
1: 
1: 	/* Trade Runtime Configuration Parameters */
1: 
1: 	/* Trade Runtime Mode parameters */
0:     public static String[] runTimeModeNames = {"Full EJB3", "Direct (JDBC)", "Session (EJB3) To Direct", "Web JDBC", "Web JPA"};
0:     public static final int EJB3 = 0;
0:     public static final int DIRECT = 1;
0:     public static final int SESSION3 = 2;
0:     public static final int JDBC = 3;
0:     public static final int JPA = 4;
0:     public static int runTimeMode = JDBC;
1: 	
1:     /* Trade JPA Layer parameters */
1: 	public static String[] jpaLayerNames = {"OpenJPA", "Hibernate"};
1: 	public static final int OPENJPA = 0;
1: 	public static final int HIBERNATE = 1;
1: 	public static int jpaLayer = OPENJPA;
1: 
1: 	public static String[] orderProcessingModeNames =
1: 		{ "Synchronous", "Asynchronous_2-Phase" };
1: 	public static final int SYNCH = 0;
1: 	public static final int ASYNCH_2PHASE = 1;
1: 	public static int orderProcessingMode = SYNCH;
1: 
1: 	public static String[] accessModeNames = { "Standard", "WebServices" };
1: 	public static final int STANDARD = 0;
1: 	public static final int WEBSERVICES = 1;
1: 	private static int accessMode = STANDARD;
1: 
1: 	/* Trade Scenario Workload parameters */
1: 	public static String[] workloadMixNames = { "Standard", "High-Volume", };
1: 	public final static int SCENARIOMIX_STANDARD = 0;
1: 	public final static int SCENARIOMIX_HIGHVOLUME = 1;
1: 	public static int workloadMix = SCENARIOMIX_STANDARD;
1: 
1: 	/* Trade Web Interface parameters */
1: 	public static String[] webInterfaceNames = { "JSP", "JSP-Images" };
1: 	public static final int JSP = 0;
1: 	public static final int JSP_Images = 1;
1: 	public static int webInterface = JSP;
1: 
1: 	/* Trade Caching Type parameters */
1: 	public static String[] cachingTypeNames = { "DistributedMap", "Command Caching", "No Caching" };
1: 	public static final int DISTRIBUTEDMAP = 0;
1: 	public static final int COMMAND_CACHING = 1;
1: 	public static final int NO_CACHING = 2;
1: 	public static int cachingType = NO_CACHING;
1: 	
1: 	/* Trade Database Scaling parameters*/
0: 	private static int MAX_USERS = 500;
0: 	private static int MAX_QUOTES = 1000;
1: 
0: 	/* Trade Database specific paramters */
1: 	public static String JDBC_UID = null;
1: 	public static String JDBC_PWD = null;
0: 	public static String DS_NAME = "java:comp/env/jdbc/TradeDataSource";
1: 
1: 	/*Trade SOAP specific parameters */
1: 	private static String SoapURL =
0: 		"http://localhost:8080/daytrader/services/TradeWSServices";
1: 
1: 	/*Trade XA Datasource specific parameters */
1: 	public static boolean JDBCDriverNeedsGlobalTransaction = false;
1: 
0: 	/* Trade Config Miscellaneous itmes */
0: 	public static String DATASOURCE = "java:comp/env/jdbc/TradeDataSource";
1: 	public static int KEYBLOCKSIZE = 1000;
1: 	public static int QUOTES_PER_PAGE = 10;
1: 	public static boolean RND_USER = true;
0: 	//public static int		RND_SEED = 0;
1: 	private static int MAX_HOLDINGS = 10;
1: 	private static int count = 0;
1: 	private static Object userID_count_semaphore = new Object();
1: 	private static int userID_count = 0;
1: 	private static String hostName = null;
1: 	private static Random r0 = new Random(System.currentTimeMillis());
0: 	//private static Random r1 = new Random(RND_SEED);
1: 	private static Random randomNumberGenerator = r0;
1: 	public static final String newUserPrefix = "ru:";
1: 	public static final int verifyPercent = 5;
1: 	private static boolean trace = false;
1: 	private static boolean actionTrace = false;
1: 	private static boolean updateQuotePrices = true;
1: 	private static int primIterations = 1;
1: 	private static boolean longRun = true;
1: 	private static boolean publishQuotePriceChange = false;
1: 	
1: 	/**
1: 	 *   -1 means every operation
1: 	 *    0 means never perform a market summary
1: 	 *  > 0 means number of seconds between summaries.  These will be
1: 	 *      synchronized so only one transaction in this period will create a summary and 
1: 	 *      will cache its results.
1: 	 */
1: 	private static int  marketSummaryInterval = 20;
1: 
1: 	/*
1: 	 * Penny stocks is a problem where the random price change factor gets a stock
1: 	 * down to $.01.  In this case trade jumpstarts the price back to $6.00 to
1: 	 * keep the math interesting.
1: 	 */
1: 	public static BigDecimal PENNY_STOCK_PRICE;
1: 	public static BigDecimal PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER;
1: 	static {
1: 		PENNY_STOCK_PRICE = new BigDecimal(0.01);
1: 		PENNY_STOCK_PRICE =
1: 			PENNY_STOCK_PRICE.setScale(2, BigDecimal.ROUND_HALF_UP);
1: 		PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER = new BigDecimal(600.0);
1: 		PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER.setScale(
1: 			2,
1: 			BigDecimal.ROUND_HALF_UP);
1: 	}
1: 
1: 	/* CJB (DAYTRADER-25) - Also need to impose a ceiling on the quote price to ensure
1: 	 * prevent account and holding balances from exceeding the databases decimal precision.
1: 	 * At some point, this maximum value can be used to trigger a stock split.
1: 	 */
1: 
1: 	public static BigDecimal MAXIMUM_STOCK_PRICE;
1: 	public static BigDecimal MAXIMUM_STOCK_SPLIT_MULTIPLIER;
1: 	static {
1: 		MAXIMUM_STOCK_PRICE = new BigDecimal(400);
1: 		MAXIMUM_STOCK_PRICE.setScale(2, BigDecimal.ROUND_HALF_UP);
1: 		MAXIMUM_STOCK_SPLIT_MULTIPLIER = new BigDecimal(0.5);
1: 		MAXIMUM_STOCK_SPLIT_MULTIPLIER.setScale(2, BigDecimal.ROUND_HALF_UP);
1: 	}
1: 
1: 	/* Trade Scenario actions mixes. Each of the array rows represents a specific Trade Scenario Mix. 
1: 	   The columns give the percentages for each action in the column header. Note: "login" is always 0. 
1: 	   logout represents both login and logout (because each logout operation will cause a new login when
1: 	   the user context attempts the next action.
1: 	 */
1: 	/* Trade Scenario Workload parameters */
1: 	public final static int HOME_OP = 0;
1: 	public final static int QUOTE_OP = 1;
1: 	public final static int LOGIN_OP = 2;
1: 	public final static int LOGOUT_OP = 3;
1: 	public final static int REGISTER_OP = 4;
1: 	public final static int ACCOUNT_OP = 5;
1: 	public final static int PORTFOLIO_OP = 6;
1: 	public final static int BUY_OP = 7;
1: 	public final static int SELL_OP = 8;
1: 	public final static int UPDATEACCOUNT_OP = 9;
1: 
1: 	private static int scenarioMixes[][] = {
1: 		//	h	q	l	o	r	a	p	b	s	u
1: 		{ 20, 40, 0, 4, 2, 10, 12, 4, 4, 4 }, //STANDARD
1: 		{
1: 			20, 40, 0, 4, 2, 7, 7, 7, 7, 6 }, //High Volume
1: 	};
1: 	private static char actions[] =
1: 		{ 'h', 'q', 'l', 'o', 'r', 'a', 'p', 'b', 's', 'u' };
1: 	private static int sellDeficit = 0;
1: 	//Tracks the number of buys over sell when a users portfolio is empty
1: 	// Used to maintain the correct ratio of buys/sells
1: 
1: 	/* JSP pages for all Trade Actions */
1: 
1: 	public final static int WELCOME_PAGE = 0;
1: 	public final static int REGISTER_PAGE = 1;
1: 	public final static int PORTFOLIO_PAGE = 2;
1: 	public final static int QUOTE_PAGE = 3;
1: 	public final static int HOME_PAGE = 4;
1: 	public final static int ACCOUNT_PAGE = 5;
1: 	public final static int ORDER_PAGE = 6;
1: 	public final static int CONFIG_PAGE = 7;
1: 	public final static int STATS_PAGE = 8;
1: 
1: 	//FUTURE Add XML/XSL View
1: 	public static String webUI[][] =
1: 		{
1: 			{
1: 				"/welcome.jsp",
1: 				"/register.jsp",
1: 				"/portfolio.jsp",
1: 				"/quote.jsp",
1: 				"/tradehome.jsp",
1: 				"/account.jsp",
1: 				"/order.jsp",
1: 				"/config.jsp",
1: 				"/runStats.jsp" },
1: 		//JSP Interface
1: 		{
1: 			"/welcomeImg.jsp",
1: 				"/registerImg.jsp",
1: 				"/portfolioImg.jsp",
1: 				"/quoteImg.jsp",
1: 				"/tradehomeImg.jsp",
1: 				"/accountImg.jsp",
1: 				"/orderImg.jsp",
1: 				"/config.jsp",
1: 				"/runStats.jsp" },
1: 		//JSP Interface	
1: 	};
1: 
0: 	// These are the property settings the VAJ access beans look for.	
0: 	private static final String NAMESERVICE_TYPE_PROPERTY =
0: 		"java.naming.factory.initial";
0: 	private static final String NAMESERVICE_PROVIDER_URL_PROPERTY =
0: 		"java.naming.provider.url";
1: 
0: 	// FUTURE:
0: 	// If a "trade2.properties" property file is supplied, reset the default values 
0: 	// to match those specified in the file. This provides a persistent runtime 
0: 	// property mechanism during server startup
1: 
1: 	/**
1: 	 * Return the hostname for this system
1: 	 * Creation date: (2/16/2000 9:02:25 PM)
1: 	 */
1: 
1: 	private static String getHostname() {
1: 		try {
1: 			if (hostName == null) {
1: 				hostName = java.net.InetAddress.getLocalHost().getHostName();
0: 				//Strip of fully qualifed domain if necessary
1: 				try {
1: 					hostName = hostName.substring(0, hostName.indexOf('.'));
1: 				} catch (Exception e) {
1: 				}
1: 			}
1: 		} catch (Exception e) {
1: 			Log.error(
1: 				"Exception getting local host name using 'localhost' - ",
1: 				e);
1: 			hostName = "localhost";
1: 		}
1: 		return hostName;
1: 	}
1: 
1: 	/**
1: 	 * Return a Trade UI Web page based on the current configuration
1: 	 * This may return a JSP page or a Servlet page 
1: 	 * Creation date: (3/14/2000 9:08:34 PM)
1: 	 */
1: 
1: 	public static String getPage(int pageNumber) {
1: 		return webUI[webInterface][pageNumber];
1: 	}
1: 
1: 	/**
1: 	 * Return the list of run time mode names
1: 	 * Creation date: (3/8/2000 5:58:34 PM)
1: 	 * @return java.lang.String[]
1: 	 */
1: 	public static java.lang.String[] getRunTimeModeNames() {
1: 		return runTimeModeNames;
1: 	}
1: 
1: 	private static int scenarioCount = 0;
1: 
1: 	/**
1: 	 * Return a Trade Scenario Operation based on the setting of the current mix (TradeScenarioMix)
1: 	 * Creation date: (2/10/2000 9:08:34 PM)
1: 	 */
1: 
1: 	public static char getScenarioAction(boolean newUser) {
1: 		int r = rndInt(100); //0 to 99 = 100
1: 		int i = 0;
1: 		int sum = scenarioMixes[workloadMix][i];
1: 		while (sum <= r) {
1: 			i++;
1: 			sum += scenarioMixes[workloadMix][i];
1: 		}
1: 
1: 		incrementScenarioCount();
1: 
1: 		/* In TradeScenarioServlet, if a sell action is selected, but the users portfolio is empty,
1: 		 * a buy is executed instead and sellDefecit is incremented. This allows the number of buy/sell
1: 		 * operations to stay in sync w/ the given Trade mix.
1: 		 */
1: 
1: 		if ((!newUser) && (actions[i] == 'b')) {
1: 			synchronized (TradeConfig.class) {
1: 				if (sellDeficit > 0) {
1: 					sellDeficit--;
1: 					return 's';
1: 					//Special case for TradeScenarioServlet to note this is a buy switched to a sell to fix sellDeficit
1: 				}
1: 			}
1: 		}
1: 
1: 		return actions[i];
1: 	}
1: 
1: 	public static String getUserID() {
1: 		String userID;
1: 		if (RND_USER) {
1: 			userID = rndUserID();
1: 		} else {
1: 			userID = nextUserID();
1: 		}
1: 		return userID;
1: 	}
1: 	private static final BigDecimal orderFee = new BigDecimal("24.95");
1: 	private static final BigDecimal cashFee = new BigDecimal("0.0");
1: 	public static BigDecimal getOrderFee(String orderType) {
1: 		if ((orderType.compareToIgnoreCase("BUY") == 0)
1: 			|| (orderType.compareToIgnoreCase("SELL") == 0))
1: 			return orderFee;
1: 
1: 		return cashFee;
1: 
1: 	}
1: 
1: 	/**
1: 	 * Increment the sell deficit counter
1: 	 * Creation date: (6/21/2000 11:33:45 AM)
1: 	 */
1: 	public synchronized static void incrementSellDeficit() {
1: 		sellDeficit++;
1: 	}
1: 
1: 	public static String nextUserID() {
1: 		String userID;
1: 		synchronized (userID_count_semaphore) {
1: 			userID = "uid:" + userID_count;
1: 			userID_count++;
1: 			if (userID_count % MAX_USERS == 0) {
1: 				userID_count = 0;
1: 			}
1: 		}
1: 		return userID;
1: 	}
1: 	public static double random() {
1: 		return randomNumberGenerator.nextDouble();
1: 	}
1: 	public static String rndAddress() {
1: 		return rndInt(1000) + " Oak St.";
1: 	}
1: 	public static String rndBalance() {
1: 		//Give all new users a cool mill in which to trade
1: 		return "1000000";
1: 	}
1: 	public static String rndCreditCard() {
1: 		return rndInt(100)
1: 			+ "-"
1: 			+ rndInt(1000)
1: 			+ "-"
1: 			+ rndInt(1000)
1: 			+ "-"
1: 			+ rndInt(1000);
1: 	}
1: 	public static String rndEmail(String userID) {
1: 		return userID + "@" + rndInt(100) + ".com";
1: 	}
1: 	public static String rndFullName() {
1: 		return "first:" + rndInt(1000) + " last:" + rndInt(5000);
1: 	}
1: 	public static int rndInt(int i) {
1: 		return (new Float(random() * i)).intValue();
1: 	}
1: 	public static float rndFloat(int i) {
1: 		return (new Float(random() * i)).floatValue();
1: 	}
1: 	public static BigDecimal rndBigDecimal(float f) {
1: 		return (new BigDecimal(random() * f)).setScale(
1: 			2,
1: 			BigDecimal.ROUND_HALF_UP);
1: 	}
1: 
1: 	public static boolean rndBoolean() {
1: 		return randomNumberGenerator.nextBoolean();
1: 	}
1: 
1: 	/**
1: 	 * Returns a new Trade user
1: 	 * Creation date: (2/16/2000 8:50:35 PM)
1: 	 */
1: 	public synchronized static String rndNewUserID() {
1: 
1: 		return newUserPrefix
1: 			+ getHostname()
1: 			+ System.currentTimeMillis()
1: 			+ count++;
1: 	}
1: 
1: 	public static float rndPrice() {
1: 		return ((new Integer(rndInt(200))).floatValue()) + 1.0f;
1: 	}
1: 	private final static BigDecimal ONE = new BigDecimal(1.0);
1: 	public static BigDecimal getRandomPriceChangeFactor() {
0: 		// CJB (DAYTRADER-25) - Vary change factor between 1.2 and 0.8
1: 		double percentGain = rndFloat(1) * 0.2;
1: 		if (random() < .5)
1: 			percentGain *= -1;
1: 		percentGain += 1;
1: 
1: 		// change factor is between +/- 20%
1: 		BigDecimal percentGainBD =
1: 			(new BigDecimal(percentGain)).setScale(2, BigDecimal.ROUND_HALF_UP);
1: 		if (percentGainBD.doubleValue() <= 0.0)
1: 			percentGainBD = ONE;
1: 
1: 		return percentGainBD;
1: 	}
1: 
1: 	public static float rndQuantity() {
1: 		return ((new Integer(rndInt(200))).floatValue()) + 1.0f;
1: 	}
1: 
1: 	public static String rndSymbol() {
1: 		return "s:" + rndInt(MAX_QUOTES - 1);
1: 	}
1: 	public static String rndSymbols() {
1: 
1: 		String symbols = "";
1: 		int num_symbols = rndInt(QUOTES_PER_PAGE);
1: 
1: 		for (int i = 0; i <= num_symbols; i++) {
1: 			symbols += "s:" + rndInt(MAX_QUOTES - 1);
1: 			if (i < num_symbols)
1: 				symbols += ",";
1: 		}
1: 		return symbols;
1: 	}
1: 
1: 	public static String rndUserID() {
1: 		String nextUser = getNextUserIDFromDeck();
1: 		if (Log.doTrace())
1: 			Log.trace("TradeConfig:rndUserID -- new trader = " + nextUser);
1: 
1: 		return nextUser;
1: 	}
1: 
1: 	private static synchronized String getNextUserIDFromDeck() {
1: 		int numUsers = getMAX_USERS();
1: 		if (deck == null) {
1: 			deck = new ArrayList(numUsers);
1: 			for (int i = 0; i < numUsers; i++)
1: 				deck.add(i, new Integer(i));
1: 			java.util.Collections.shuffle(deck, r0);
1: 		}
1: 		if (card >= numUsers)
1: 			card = 0;
1: 		return "uid:" + deck.get(card++);
1: 
1: 	}
1: 
1: 	//Trade implements a card deck approach to selecting 
1: 	// users for trading with tradescenarioservlet
1: 	private static ArrayList deck = null;
1: 	private static int card = 0;
1: 
1: 	/**
1: 	 * Set the list of run time mode names
1: 	 * Creation date: (3/8/2000 5:58:34 PM)
1: 	 * @param newRunTimeModeNames java.lang.String[]
1: 	 */
1: 	public static void setRunTimeModeNames(
1: 		java.lang.String[] newRunTimeModeNames) {
1: 		runTimeModeNames = newRunTimeModeNames;
1: 	}
1: 	/**
1: 	 * This is a convenience method for servlets to set Trade configuration parameters
1: 	 * from servlet initialization parameters. The servlet provides the init param and its
1: 	 * value as strings. This method then parses the parameter, converts the value to the
1: 	 * correct type and sets the corresponding TradeConfig parameter to the converted value
1: 	 * 
1: 	 */
1: 	public static void setConfigParam(String parm, String value) {
1: 		Log.log("TradeConfig setting parameter: " + parm + "=" + value);
1: 		// Compare the parm value to valid TradeConfig parameters that can be set
1: 		// by servlet initialization
1: 
1: 		// First check the proposed new parm and value - if empty or null ignore it
1: 		if (parm == null)
1: 			return;
1: 		parm = parm.trim();
1: 		if (parm.length() <= 0)
1: 			return;
1: 		if (value == null)
1: 			return;
1: 		value = value.trim();
1: 
1: 		if (parm.equalsIgnoreCase("runTimeMode")) {
1: 			try {
1: 				for (int i = 0; i < runTimeModeNames.length; i++) {
1: 					if (value.equalsIgnoreCase(runTimeModeNames[i])) {
0: 						setRunTimeMode(i);
1: 						break;
1: 					}
1: 				}
1: 			} catch (Exception e) {
0: 				//>>rjm
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "trying to set runtimemode to "
1: 						+ value
1: 						+ "reverting to current value: "
0: 						+ runTimeModeNames[getRunTimeMode()],
1: 					e);
1: 			} // If the value is bad, simply revert to current
1: 		} else if (parm.equalsIgnoreCase("orderProcessingMode")) {
1: 			try {
1: 				for (int i = 0; i < orderProcessingModeNames.length; i++) {
1: 					if (value.equalsIgnoreCase(orderProcessingModeNames[i])) {
1: 						orderProcessingMode = i;
1: 						break;
1: 					}
1: 				}
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "trying to set orderProcessingMode to "
1: 						+ value
1: 						+ "reverting to current value: "
1: 						+ orderProcessingModeNames[orderProcessingMode],
1: 					e);
1: 			} // If the value is bad, simply revert to current
1: 		} else if (parm.equalsIgnoreCase("accessMode")) {		
1: 			try {
1: 				for (int i = 0; i < accessModeNames.length; i++) {
1: 					if (value.equalsIgnoreCase(accessModeNames[i])) {
1: 						accessMode = i;
1: 						break;
1: 					}
1: 				}
1: 			}
1: 			catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "trying to set accessMode to "
1: 						+ value
1: 						+ "reverting to current value: "
1: 						+ accessModeNames[accessMode],
1: 					e);
1: 			}
1: 		} else if (parm.equalsIgnoreCase("webServicesEndpoint")) {
1: 			try {
1: 				setSoapURL(value);
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "Setting web services endpoint",
1: 					e);
1: 			} //On error, revert to saved		
1: 		} else if (parm.equalsIgnoreCase("workloadMix")) {
1: 			try {
1: 				for (int i = 0; i < workloadMixNames.length; i++) {
1: 					if (value.equalsIgnoreCase(workloadMixNames[i])) {
1: 						workloadMix = i;
1: 						break;
1: 					}
1: 				}
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "trying to set workloadMix to "
1: 						+ value
1: 						+ "reverting to current value: "
1: 						+ workloadMixNames[workloadMix],
1: 					e);
1: 			} // If the value is bad, simply revert to current		
1: 		} else if (parm.equalsIgnoreCase("WebInterface")) {
1: 			try {
1: 				for (int i = 0; i < webInterfaceNames.length; i++) {
1: 					if (value.equalsIgnoreCase(webInterfaceNames[i])) {
1: 						webInterface = i;
1: 						break;
1: 					}
1: 				}
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "trying to set WebInterface to "
1: 						+ value
1: 						+ "reverting to current value: "
1: 						+ webInterfaceNames[webInterface],
1: 					e);
1: 
1: 			} // If the value is bad, simply revert to current
1: 		} else if (parm.equalsIgnoreCase("CachingType")) {
1: 			try {
1: 				for (int i = 0; i < cachingTypeNames.length; i++) {
1: 					if (value.equalsIgnoreCase(cachingTypeNames[i])) {
1: 						cachingType = i;
1: 						break;
1: 					}
1: 				}
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "trying to set CachingType to "
1: 						+ value
1: 						+ "reverting to current value: "
1: 						+ cachingTypeNames[cachingType],
1: 					e);
1: 			} // If the value is bad, simply revert to current
1: 		} else if (parm.equalsIgnoreCase("maxUsers")) {
1: 			try {
1: 				MAX_USERS = Integer.parseInt(value);
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "Setting maxusers, error parsing string to int:"
1: 						+ value
1: 						+ "revering to current value: "
1: 						+ MAX_USERS,
1: 					e);
1: 			} //On error, revert to saved		
1: 		} else if (parm.equalsIgnoreCase("maxQuotes")) {
1: 			try {
1: 				MAX_QUOTES = Integer.parseInt(value);
1: 			} catch (Exception e) {
0: 				//>>rjm
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(...) minor exception caught"
1: 						+ "Setting max_quotes, error parsing string to int "
1: 						+ value
1: 						+ "reverting to current value: "
1: 						+ MAX_QUOTES,
1: 					e);
0: 				//<<rjm
1: 			} //On error, revert to saved		
1: 		} else if (parm.equalsIgnoreCase("primIterations")) {
1: 			try {
1: 				primIterations = Integer.parseInt(value);
1: 			} catch (Exception e) {
1: 				Log.error(
1: 					"TradeConfig.setConfigParm(..): minor exception caught"
1: 						+ "Setting primIterations, error parsing string to int:"
1: 						+ value
1: 						+ "revering to current value: "
1: 						+ primIterations,
1: 					e);
1: 			} //On error, revert to saved
1: 		}		
1: 	}
1: 
1: 	/**
1: 	 * Gets the orderProcessingModeNames
1: 	 * @return Returns a String[]
1: 	 */
1: 	public static String[] getOrderProcessingModeNames() {
1: 		return orderProcessingModeNames;
1: 	}
1: 
1: 	/**
1: 	 * Gets the workloadMixNames
1: 	 * @return Returns a String[]
1: 	 */
1: 	public static String[] getWorkloadMixNames() {
1: 		return workloadMixNames;
1: 	}
1: 
1: 	/**
1: 	 * Gets the webInterfaceNames
1: 	 * @return Returns a String[]
1: 	 */
1: 	public static String[] getWebInterfaceNames() {
1: 		return webInterfaceNames;
1: 	}
1: 
1: 	/**
1: 	 * Gets the webInterfaceNames
1: 	 * @return Returns a String[]
1: 	 */
1: 	public static String[] getCachingTypeNames() {
1: 		return cachingTypeNames;
1: 	}
1: 
1: 	/**
1: 	 * Gets the scenarioMixes
1: 	 * @return Returns a int[][]
1: 	 */
1: 	public static int[][] getScenarioMixes() {
1: 		return scenarioMixes;
1: 	}
1: 
1: 	/**
1: 	 * Gets the trace
1: 	 * @return Returns a boolean
1: 	 */
1: 	public static boolean getTrace() {
1: 		return trace;
1: 	}
1: 	/**
1: 	 * Sets the trace
1: 	 * @param trace The trace to set
1: 	 */
1: 	public static void setTrace(boolean traceValue) {
1: 		trace = traceValue;
1: 	}
1: 
1: 	/**
1: 	 * Gets the mAX_USERS.
1: 	 * @return Returns a int
1: 	 */
1: 	public static int getMAX_USERS() {
1: 		return MAX_USERS;
1: 	}
1: 
1: 	/**
1: 	 * Sets the mAX_USERS.
1: 	 * @param mAX_USERS The mAX_USERS to set
1: 	 */
1: 	public static void setMAX_USERS(int mAX_USERS) {
1: 		MAX_USERS = mAX_USERS;
1: 		deck = null; // reset the card deck for selecting users
1: 	}
1: 
1: 	/**
1: 	 * Gets the mAX_QUOTES.
1: 	 * @return Returns a int
1: 	 */
1: 	public static int getMAX_QUOTES() {
1: 		return MAX_QUOTES;
1: 	}
1: 
1: 	/**
1: 	 * Sets the mAX_QUOTES.
1: 	 * @param mAX_QUOTES The mAX_QUOTES to set
1: 	 */
1: 	public static void setMAX_QUOTES(int mAX_QUOTES) {
1: 		MAX_QUOTES = mAX_QUOTES;
1: 	}
1: 
1: 	/**
1: 	 * Gets the mAX_HOLDINGS.
1: 	 * @return Returns a int
1: 	 */
1: 	public static int getMAX_HOLDINGS() {
1: 		return MAX_HOLDINGS;
1: 	}
1: 
1: 	/**
1: 	 * Sets the mAX_HOLDINGS.
1: 	 * @param mAX_HOLDINGS The mAX_HOLDINGS to set
1: 	 */
1: 	public static void setMAX_HOLDINGS(int mAX_HOLDINGS) {
1: 		MAX_HOLDINGS = mAX_HOLDINGS;
1: 	}
1: 
1: 	/**
1: 	 * Gets the actionTrace.
1: 	 * @return Returns a boolean
1: 	 */
1: 	public static boolean getActionTrace() {
1: 		return actionTrace;
1: 	}
1: 
1: 	/**
1: 	 * Sets the actionTrace.
1: 	 * @param actionTrace The actionTrace to set
1: 	 */
1: 	public static void setActionTrace(boolean actionTrace) {
1: 		TradeConfig.actionTrace = actionTrace;
1: 	}
1: 
1: 	/**
1: 	 * Gets the scenarioCount.
1: 	 * @return Returns a int
1: 	 */
1: 	public static int getScenarioCount() {
1: 		return scenarioCount;
1: 	}
1: 
1: 	/**
1: 	 * Sets the scenarioCount.
1: 	 * @param scenarioCount The scenarioCount to set
1: 	 */
1: 	public static void setScenarioCount(int scenarioCount) {
1: 		TradeConfig.scenarioCount = scenarioCount;
1: 	}
1: 
1: 	public static synchronized void incrementScenarioCount() {
1: 		scenarioCount++;
1: 	}
1: 
1: 	/**
1: 	 * Gets the jdbc driver needs global transaction
1: 	 * Some XA Drivers require a global transaction to be started
1: 	 * for all SQL calls.  To work around this, set this to true
1: 	 * to cause the direct mode to start a user transaction.
1: 	 * @return Returns a boolean
1: 	 */
1: 	public static boolean getJDBCDriverNeedsGlobalTransaction() {
1: 		return JDBCDriverNeedsGlobalTransaction;
1: 	}
1: 
1: 	/**
1: 	 * Sets the jdbc driver needs global transaction
1:          * @param JDBCDriverNeedsGlobalTransactionVal the value
1: 	 */
1: 	public static void setJDBCDriverNeedsGlobalTransaction(boolean JDBCDriverNeedsGlobalTransactionVal) {
1: 		JDBCDriverNeedsGlobalTransaction = JDBCDriverNeedsGlobalTransactionVal;
1: 	}
1: 
1: 	/**
1: 	 * Gets the updateQuotePrices.
1: 	 * @return Returns a boolean
1: 	 */
1: 	public static boolean getUpdateQuotePrices() {
1: 		return updateQuotePrices;
1: 	}
1: 
1: 	/**
1: 	 * Sets the updateQuotePrices.
1: 	 * @param updateQuotePrices The updateQuotePrices to set
1: 	 */
1: 	public static void setUpdateQuotePrices(boolean updateQuotePrices) {
1: 		TradeConfig.updateQuotePrices = updateQuotePrices;
1: 	}
1: 	
1: 	public static String getSoapURL() {
1: 		return SoapURL;
1: 	}
1: 	
1: 	public static void setSoapURL(String value) {
1: 		SoapURL = value;
0: //		TradeWebSoapProxy.updateServicePort();
1: 	}
1: 	
1: 	public static int getAccessMode() {
1: 		return accessMode;
1: 	}
1: 	
1: 	public static void setAccessMode(int value) {
1: 		accessMode = value;
0: //		TradeWebSoapProxy.updateServicePort();
1: 	}
1: 
0:     public static int getRunTimeMode() {
1:         return runTimeMode;
1:     }
1:     
0:     public static void setRunTimeMode(int value) {
1:         runTimeMode = value;
1:     }
1: 
1: 	public static int getPrimIterations() {
1: 		return primIterations;
1: 	}
1: 	
1: 	public static void setPrimIterations(int iter) {
1: 		primIterations = iter;
1: 	}	
1: 
1:     public static boolean getLongRun() {
1:         return longRun;
1:     }
1: 
1:     public static void setLongRun(boolean longRun) {
1:         TradeConfig.longRun = longRun;
1:     }
1: 
1:     public static void setPublishQuotePriceChange(boolean publishQuotePriceChange) {
1:         TradeConfig.publishQuotePriceChange = publishQuotePriceChange;
1:     }
1:     
1:     public static boolean getPublishQuotePriceChange() {
1:         return publishQuotePriceChange;
1:     }
1: 
1:     public static void setMarketSummaryInterval(int seconds) {
1:         TradeConfig.marketSummaryInterval = seconds;
1:     }
1:     
1:     public static  int getMarketSummaryInterval() {
1:         return TradeConfig.marketSummaryInterval;
1:     }
1:     
1:     /**
1: 	 * Return the list of JPA Layer names
1: 	 * Creation date: (01/10/2009)
1: 	 * @return java.lang.String[]
1: 	 */
1: 	public static java.lang.String[] getJPALayerNames() {
1: 		return jpaLayerNames;
1:     }
1: 
1: }
============================================================================