2:74884c6: /*
1:74884c6:  * Licensed under the Apache License, Version 2.0 (the "License");
1:74884c6:  * you may not use this file except in compliance with the License.
1:74884c6:  * You may obtain a copy of the License at
2:74884c6:  *
1:74884c6:  *      http://www.apache.org/licenses/LICENSE-2.0
1:74884c6:  *
1:74884c6:  * Unless required by applicable law or agreed to in writing, software
1:74884c6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:74884c6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:74884c6:  * See the License for the specific language governing permissions and
1:74884c6:  * limitations under the License.
3:74884c6:  */
1:74884c6: package org.apache.aries.quiesce.manager.impl;
1:2f3073f: 
1:74884c6: import java.util.ArrayList;
1:74884c6: import java.util.HashSet;
1:74884c6: import java.util.Iterator;
1:74884c6: import java.util.List;
1:74884c6: import java.util.Set;
1:74884c6: import java.util.concurrent.ConcurrentHashMap;
1:2f3073f: import java.util.concurrent.CountDownLatch;
1:2f3073f: import java.util.concurrent.ExecutionException;
1:74884c6: import java.util.concurrent.ExecutorService;
1:74884c6: import java.util.concurrent.Executors;
1:74884c6: import java.util.concurrent.Future;
1:74884c6: import java.util.concurrent.LinkedBlockingQueue;
1:74884c6: import java.util.concurrent.ScheduledExecutorService;
1:74884c6: import java.util.concurrent.ScheduledFuture;
1:74884c6: import java.util.concurrent.ThreadFactory;
1:74884c6: import java.util.concurrent.ThreadPoolExecutor;
1:74884c6: import java.util.concurrent.TimeUnit;
1:2f3073f: import java.util.concurrent.TimeoutException;
15:74884c6: 
1:74884c6: import org.apache.aries.quiesce.manager.QuiesceCallback;
1:74884c6: import org.apache.aries.quiesce.manager.QuiesceManager;
1:74884c6: import org.apache.aries.quiesce.participant.QuiesceParticipant;
1:81f0653: import org.apache.aries.util.nls.MessageUtil;
1:74884c6: import org.osgi.framework.Bundle;
1:74884c6: import org.osgi.framework.BundleContext;
1:74884c6: import org.osgi.framework.BundleException;
1:74884c6: import org.osgi.framework.InvalidSyntaxException;
1:74884c6: import org.osgi.framework.ServiceReference;
1:74884c6: import org.slf4j.Logger;
1:74884c6: import org.slf4j.LoggerFactory;
1:74884c6: 
1:74884c6: public class QuiesceManagerImpl implements QuiesceManager {
1:81f0653: 
1:81f0653:     /** Logger */
1:74884c6:     private static final Logger LOGGER = LoggerFactory.getLogger(QuiesceManagerImpl.class.getName());
1:81f0653:     /** MessageUtil */
1:81f0653:     private static final MessageUtil MESSAGES = MessageUtil.createMessageUtil(QuiesceManagerImpl.class, "org.apache.aries.quiesce.manager.nls.quiesceMessages");
1:74884c6:     /** The default timeout to use */
1:74884c6:     private static int defaultTimeout = 60000; 
1:74884c6:     /** The container's {@link BundleContext} */
1:74884c6:     private BundleContext bundleContext = null;
1:74884c6:     /** The thread pool to execute timeout commands */
1:2f3073f:     private ScheduledExecutorService timeoutExecutor = Executors.newScheduledThreadPool(10, new ThreadFactory() {
1:2f3073f:         public Thread newThread(Runnable r) {
1:2f3073f:             Thread t = new Thread(r, "Quiesce Manager Timeout Thread");
1:2f3073f:             t.setDaemon(true);
1:2f3073f:             return t;
1:2f3073f:         }
1:2f3073f:     });
1:2f3073f:     
1:74884c6:     /** The thread pool to execute quiesce commands */
1:74884c6:     private ExecutorService executor = new ThreadPoolExecutor(0, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),new ThreadFactory() {
1:81f0653:         
1:81f0653:         public Thread newThread(Runnable arg0) {
1:81f0653:             Thread t = new Thread(arg0, "Quiesce Manager Thread");
1:81f0653:             t.setDaemon(true);
1:81f0653:             return t;
1:81f0653:         }
1:81f0653:     });
1:2f3073f:     
1:74884c6:     /** The map of bundles that are currently being quiesced */
1:2f3073f:     private static ConcurrentHashMap<Bundle, Bundle> bundleMap = new ConcurrentHashMap<Bundle, Bundle>();
1:74884c6: 
1:74884c6: 
1:74884c6:     public QuiesceManagerImpl(BundleContext bc) {
1:81f0653:         bundleContext = bc;
1:2f3073f:     }
1:74884c6:     
2:74884c6:     /**
1:74884c6:      * Attempts to quiesce all bundles in the list. After the timeout has elapsed, 
1:74884c6:      * or if successfully quiesced before that, the bundles are stopped. This method 
1:74884c6:      * is non-blocking. Calling objects wishing to track the state of the bundles 
1:74884c6:      * need to listen for the resulting stop events. 
1:74884c6:      */
1:74884c6:     public void quiesce(long timeout, List<Bundle> bundles) {
1:2f3073f:         quiesceWithFuture(timeout, bundles);
1:2f3073f:     }
1:2f3073f:     
1:2f3073f:     public Future<?> quiesceWithFuture(List<Bundle> bundlesToQuiesce) {
1:2f3073f:         return quiesceWithFuture(defaultTimeout, bundlesToQuiesce);
1:2f3073f:     }
1:2f3073f:     
1:2f3073f:     public Future<?> quiesceWithFuture(long timeout, List<Bundle> bundles) {
1:2f3073f:         QuiesceFuture result = new QuiesceFuture();
1:2f3073f:         if (bundles != null && !!!bundles.isEmpty()) {
1:2f3073f:             //check that bundle b is not already quiescing
1:2f3073f:             Iterator<Bundle> it = bundles.iterator();
1:2f3073f:             Set<Bundle> bundlesToQuiesce = new HashSet<Bundle>();
1:2f3073f:             while(it.hasNext()) {
1:2f3073f:                 Bundle b = it.next();
1:2f3073f:                 Bundle priorBundle = bundleMap.putIfAbsent(b, b);
1:2f3073f:                 if (priorBundle == null) {
1:2f3073f:                     bundlesToQuiesce.add(b);
1:2f3073f:                 }else{
1:81f0653:                     LOGGER.warn(MESSAGES.getMessage("already.quiescing.bundle", b.getSymbolicName() + '/' + b.getVersion()));
1:2f3073f:                 }
1:2f3073f:             }
1:2f3073f:             Runnable command = new BundleQuiescer(bundlesToQuiesce, timeout, result, bundleMap);
1:2f3073f:             executor.execute(command);
1:2f3073f:             
1:2f3073f:             return result;
1:2f3073f:         } else {
1:2f3073f:             result.registerDone();
1:2f3073f:         }
1:2f3073f:         
1:2f3073f:         return result;
1:2f3073f:     }
1:2f3073f:     
1:2f3073f:     private static class QuiesceFuture implements Future<Object> {
1:2f3073f:         private CountDownLatch latch = new CountDownLatch(1);
1:2f3073f:         
1:2f3073f:         public boolean cancel(boolean mayInterruptIfRunning) {
1:81f0653:             throw new UnsupportedOperationException(MESSAGES.getMessage("quiesce.cannot.be.canceled"));
1:2f3073f:         }
1:2f3073f: 
1:2f3073f:         public Object get() throws InterruptedException, ExecutionException {
1:2f3073f:             latch.await();
1:2f3073f:             return null;
1:2f3073f:         }
1:2f3073f: 
1:2f3073f:         public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
1:2f3073f:             if (!!!latch.await(timeout, unit))
1:2f3073f:                 throw new TimeoutException();
1:2f3073f:             
1:2f3073f:             return null;
1:2f3073f:         }
1:2f3073f: 
1:2f3073f:         public boolean isCancelled() {
1:2f3073f:             return false;
1:2f3073f:         }
1:2f3073f: 
1:2f3073f:         public boolean isDone() {
1:2f3073f:             return latch.getCount() == 0;
1:2f3073f:         }
1:2f3073f:         
1:2f3073f:         public void registerDone() {
1:2f3073f:             if (!!!isDone()) {
1:2f3073f:                 latch.countDown();
1:2f3073f:             }
1:2f3073f:         }
1:2f3073f:         
1:2f3073f:     }
1:74884c6: 
1:74884c6:     /**
1:74884c6:      * Attempts to quiesce all bundles in the list, using the default timeout. 
1:74884c6:      * After the timeout has elapsed, or if successfully quiesced before that, 
1:74884c6:      * the bundles are stopped. This method is non-blocking. Calling objects 
1:74884c6:      * wishing to track the state of the bundles need to listen for the 
1:74884c6:      * resulting stop events. 
1:74884c6:      */
1:74884c6:     public void quiesce(List<Bundle> bundlesToQuiesce) {
1:81f0653:         quiesce(defaultTimeout, bundlesToQuiesce);
3:2f3073f:     }
1:74884c6:   
1:2f3073f:     /**
1:2f3073f:      * Stop a bundle that was to be quiesced. This happens either when all the participants
1:2f3073f:      * are finished or when the timeout has occurred.
1:2f3073f:      * 
1:2f3073f:      * The set of all bundles to quiesce is used to track stops, so that they do not occur twice.
1:2f3073f:      * @param bundleToStop
1:2f3073f:      * @param bundlesToStop
1:2f3073f:      * @return
1:2f3073f:      */
1:2f3073f:     private static boolean stopBundle(Bundle bundleToStop, Set<Bundle> bundlesToStop) {
1:81f0653:         try {
1:81f0653:             synchronized (bundlesToStop) {
1:81f0653:                 if (bundlesToStop.remove(bundleToStop)) {
1:81f0653:                     bundleToStop.stop();
1:81f0653:                     bundleMap.remove(bundleToStop);
1:81f0653:                 }
1:81f0653:             }
1:81f0653:         } catch (BundleException be) {
1:81f0653:             return false;
1:81f0653:         }
1:81f0653:         return true;
1:2f3073f:     }
1:2f3073f:     
1:2f3073f:     private static boolean stillQuiescing(Bundle bundleToStop) {
1:2f3073f:         return bundleMap.containsKey(bundleToStop);
1:2f3073f:     }
1:2f3073f:     
1:74884c6: 
1:74884c6:     /**
1:74884c6:      * BundleQuiescer is used for each bundle to quiesce. It creates a callback object for each 
1:74884c6:      * participant. Well-behaved participants will be non-blocking on their quiesce method.
1:74884c6:      * When all callbacks for the participants have completed, this thread will get an 
1:74884c6:      * interrupt, so it sleeps until it hits the timeout. When complete it stops the bundle
1:74884c6:      * and removes the bundles from the list of those that are being quiesced.
1:74884c6:      */
1:74884c6:     private class BundleQuiescer implements Runnable {
1:81f0653:       
1:81f0653:         private final Set<Bundle> bundlesToQuiesce;
1:81f0653:         private final long timeout;
1:81f0653:         private final QuiesceFuture future;
1:81f0653:         
1:81f0653:         public BundleQuiescer(Set<Bundle> bundlesToQuiesce, long timeout, QuiesceFuture future, ConcurrentHashMap<Bundle, Bundle> bundleMap) {
1:81f0653:             this.bundlesToQuiesce = new HashSet<Bundle>(bundlesToQuiesce);
1:81f0653:             this.timeout = timeout;
1:81f0653:             this.future = future;
1:81f0653:         }
1:74884c6: 
1:81f0653:         public void run() {
1:81f0653:             try {
1:81f0653:                 if (bundleContext != null) {
1:81f0653:                     ServiceReference[] serviceRefs = bundleContext.getServiceReferences(QuiesceParticipant.class.getName(), null);
1:81f0653:                     if (serviceRefs != null) {
1:81f0653:                         List<QuiesceParticipant> participants = new ArrayList<QuiesceParticipant>();
1:81f0653:                         final List<QuiesceCallbackImpl> callbacks = new ArrayList<QuiesceCallbackImpl>();
1:81f0653:                         List<Bundle> copyOfBundles = new ArrayList<Bundle>(bundlesToQuiesce);
1:81f0653:                         
1:81f0653:                         ScheduledFuture<?> timeoutFuture = timeoutExecutor.schedule(new Runnable() {
1:81f0653:                             public void run() {
1:81f0653:                                 try {
1:81f0653:                                   synchronized (bundlesToQuiesce) {
1:81f0653:                                       for (Bundle b : new ArrayList<Bundle>(bundlesToQuiesce)) {
1:81f0653:                                           LOGGER.warn(MESSAGES.getMessage("quiesce.failed", b.getSymbolicName() + '/' + b.getVersion()));
1:81f0653:                                           stopBundle(b, bundlesToQuiesce);
1:81f0653:                                       }
1:81f0653:                                   }
1:81f0653:                                 } finally { 
1:81f0653:                                   future.registerDone();
1:81f0653:                                   LOGGER.debug("Quiesce complete");
1:81f0653:                                 }
1:81f0653:                             }
1:81f0653:                         }, timeout, TimeUnit.MILLISECONDS);
1:81f0653: 
1:2f3073f:                         
1:81f0653:                         //Create callback objects for all participants
1:81f0653:                         for( ServiceReference sr : serviceRefs ) {
1:81f0653:                             QuiesceParticipant participant = (QuiesceParticipant) bundleContext.getService(sr);
1:81f0653:                             participants.add(participant);
1:81f0653:                             callbacks.add(new QuiesceCallbackImpl(bundlesToQuiesce, callbacks, future, timeoutFuture));
1:81f0653:                         }
1:81f0653:                         
1:81f0653:                         //Quiesce each participant and wait for an interrupt from a callback 
1:81f0653:                         //object when all are quiesced, or the timeout to be reached
1:81f0653:                         for( int i=0; i<participants.size(); i++ ) {
1:81f0653:                             QuiesceParticipant participant = participants.get(i);
1:81f0653:                             QuiesceCallbackImpl callback = callbacks.get(i);
1:81f0653:                             participant.quiesce(callback, copyOfBundles);
1:81f0653:                         }                        
1:2f3073f:                     }else{
1:2f3073f:                         for (Bundle b : bundlesToQuiesce) {
1:bd92378:                             stopBundle(b, bundlesToQuiesce);
1:bd92378:                         }
1:bd92378:                         future.registerDone();
1:bd92378:                     }
1:2f3073f:                 }
1:2f3073f:             } catch (InvalidSyntaxException e) {
1:81f0653:                 LOGGER.warn(MESSAGES.getMessage("null.is.invalid.filter"));
1:2f3073f:                 for (Bundle b : bundlesToQuiesce) {
1:2f3073f:                     stopBundle(b, bundlesToQuiesce);
1:81f0653:                 }
1:2f3073f:                 future.registerDone();
1:2f3073f:             }
1:2f3073f:         }
1:2f3073f:     }
1:74884c6:  
1:74884c6:     /**
1:74884c6:      * Callback object provided for each participant for each quiesce call 
1:74884c6:      * from the quiesce manager. 
1:74884c6:      */
1:74884c6:     private static class QuiesceCallbackImpl implements QuiesceCallback {
1:81f0653:         //Must be a copy
1:81f0653:         private final Set<Bundle> toQuiesce;
1:81f0653:         // Must not be a copy
1:81f0653:         private final Set<Bundle> toQuiesceShared;        
1:81f0653:         //Must not be a copy
1:81f0653:         private final List<QuiesceCallbackImpl> allCallbacks;
1:81f0653:         //Timer so we can cancel the alarm if all done
1:81f0653:         private final QuiesceFuture future;
1:81f0653:         //The cleanup action that runs at timeout
1:81f0653:         private final ScheduledFuture<?> timeoutFuture;
1:81f0653:         
1:81f0653:         public QuiesceCallbackImpl(Set<Bundle> toQuiesce, List<QuiesceCallbackImpl> allCallbacks, QuiesceFuture future, ScheduledFuture<?> timeoutFuture) 
1:81f0653:         {
1:81f0653:             this.toQuiesce = new HashSet<Bundle>(toQuiesce);
1:81f0653:             this.toQuiesceShared = toQuiesce;
1:81f0653:             this.allCallbacks = allCallbacks;
1:81f0653:             this.future = future;
1:81f0653:             this.timeoutFuture = timeoutFuture;
1:81f0653:         }
1:74884c6: 
1:81f0653:         /** 
1:81f0653:          * Removes the bundles from the list of those to quiesce. 
1:81f0653:          * If the list is now empty, this callback object is finished (i.e. 
1:81f0653:          * the participant linked to this object has quiesced all the bundles
1:81f0653:          * requested).  
1:81f0653:          * 
1:81f0653:          * If all other participants have also completed, then the 
1:81f0653:          * calling BundleQuieser thread is interrupted.
1:81f0653:          */
1:81f0653:         public void bundleQuiesced(Bundle... bundlesQuiesced) {
1:81f0653:             
1:2f3073f:             boolean timeoutOccurred = false; 
1:2f3073f:             
1:2f3073f:             synchronized (allCallbacks) {
1:2f3073f:                 for(Bundle b : bundlesQuiesced) {
1:2f3073f:                     if(QuiesceManagerImpl.stillQuiescing(b)) {
1:2f3073f:                         if(toQuiesce.remove(b)) {
1:2f3073f:                             if(checkOthers(b)){
1:2f3073f:                                 QuiesceManagerImpl.stopBundle(b, toQuiesceShared);
1:2f3073f:                                 if(allCallbacksComplete()){
2:2f3073f:                                     future.registerDone();
1:2f3073f:                                     timeoutFuture.cancel(false);
1:bd92378:                                     LOGGER.debug("Quiesce complete");
1:2f3073f:                                 }
1:2f3073f:                             }
1:2f3073f:                         }
1:2f3073f:                     } else {
1:2f3073f:                         timeoutOccurred = true;
1:2f3073f:                         break;
1:2f3073f:                     }
1:2f3073f:                 }
1:2f3073f:                 if (timeoutOccurred) {
1:2f3073f:                         Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
1:2f3073f:                         while (it.hasNext()) {
1:2f3073f:                             it.next().toQuiesce.clear();
1:81f0653:                         }
1:81f0653:                 }
1:2f3073f:             }
1:2f3073f:         }
1:74884c6: 
1:81f0653:         private boolean checkOthers(Bundle b) {
1:81f0653:             boolean allDone = true;
1:81f0653:             Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
1:81f0653:             while (allDone && it.hasNext()) {
1:81f0653:                 allDone = !!!it.next().toQuiesce.contains(b);
1:81f0653:             }
1:81f0653:             return allDone;
1:81f0653:         }
1:81f0653:         
1:81f0653:         private boolean allCallbacksComplete() {
1:81f0653:             boolean allDone = true;
1:81f0653:             Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
1:81f0653:             while (allDone && it.hasNext()) {
1:2f3073f:                 QuiesceCallbackImpl next = it.next();
1:2f3073f:                 if (!!!next.toQuiesce.isEmpty()) allDone = false;
1:81f0653:             }
1:81f0653:             return allDone;
1:81f0653:         }        
1:2f3073f:     }
1:2f3073f: }
============================================================================
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:81f0653
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.util.nls.MessageUtil;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Logger */
1:     /** MessageUtil */
1:     private static final MessageUtil MESSAGES = MessageUtil.createMessageUtil(QuiesceManagerImpl.class, "org.apache.aries.quiesce.manager.nls.quiesceMessages");
/////////////////////////////////////////////////////////////////////////
1:         
1:         public Thread newThread(Runnable arg0) {
1:             Thread t = new Thread(arg0, "Quiesce Manager Thread");
1:             t.setDaemon(true);
1:             return t;
1:         }
1:     });
1:         bundleContext = bc;
/////////////////////////////////////////////////////////////////////////
1:                     LOGGER.warn(MESSAGES.getMessage("already.quiescing.bundle", b.getSymbolicName() + '/' + b.getVersion()));
/////////////////////////////////////////////////////////////////////////
1:             throw new UnsupportedOperationException(MESSAGES.getMessage("quiesce.cannot.be.canceled"));
/////////////////////////////////////////////////////////////////////////
1:         quiesce(defaultTimeout, bundlesToQuiesce);
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             synchronized (bundlesToStop) {
1:                 if (bundlesToStop.remove(bundleToStop)) {
1:                     bundleToStop.stop();
1:                     bundleMap.remove(bundleToStop);
1:                 }
1:             }
1:         } catch (BundleException be) {
1:             return false;
1:         }
1:         return true;
/////////////////////////////////////////////////////////////////////////
1:       
1:         private final Set<Bundle> bundlesToQuiesce;
1:         private final long timeout;
1:         private final QuiesceFuture future;
1:         
1:         public BundleQuiescer(Set<Bundle> bundlesToQuiesce, long timeout, QuiesceFuture future, ConcurrentHashMap<Bundle, Bundle> bundleMap) {
1:             this.bundlesToQuiesce = new HashSet<Bundle>(bundlesToQuiesce);
1:             this.timeout = timeout;
1:             this.future = future;
1:         }
1:         public void run() {
1:             try {
1:                 if (bundleContext != null) {
1:                     ServiceReference[] serviceRefs = bundleContext.getServiceReferences(QuiesceParticipant.class.getName(), null);
1:                     if (serviceRefs != null) {
1:                         List<QuiesceParticipant> participants = new ArrayList<QuiesceParticipant>();
1:                         final List<QuiesceCallbackImpl> callbacks = new ArrayList<QuiesceCallbackImpl>();
1:                         List<Bundle> copyOfBundles = new ArrayList<Bundle>(bundlesToQuiesce);
1:                         
1:                         ScheduledFuture<?> timeoutFuture = timeoutExecutor.schedule(new Runnable() {
1:                             public void run() {
1:                                 try {
1:                                   synchronized (bundlesToQuiesce) {
1:                                       for (Bundle b : new ArrayList<Bundle>(bundlesToQuiesce)) {
1:                                           LOGGER.warn(MESSAGES.getMessage("quiesce.failed", b.getSymbolicName() + '/' + b.getVersion()));
1:                                           stopBundle(b, bundlesToQuiesce);
1:                                       }
1:                                   }
1:                                 } finally { 
1:                                   future.registerDone();
1:                                   LOGGER.debug("Quiesce complete");
1:                                 }
1:                             }
1:                         }, timeout, TimeUnit.MILLISECONDS);
1:                         
1:                         //Create callback objects for all participants
1:                         for( ServiceReference sr : serviceRefs ) {
1:                             QuiesceParticipant participant = (QuiesceParticipant) bundleContext.getService(sr);
1:                             participants.add(participant);
1:                             callbacks.add(new QuiesceCallbackImpl(bundlesToQuiesce, callbacks, future, timeoutFuture));
1:                         }
1:                         
1:                         //Quiesce each participant and wait for an interrupt from a callback 
1:                         //object when all are quiesced, or the timeout to be reached
1:                         for( int i=0; i<participants.size(); i++ ) {
1:                             QuiesceParticipant participant = participants.get(i);
1:                             QuiesceCallbackImpl callback = callbacks.get(i);
1:                             participant.quiesce(callback, copyOfBundles);
1:                         }                        
/////////////////////////////////////////////////////////////////////////
1:                 LOGGER.warn(MESSAGES.getMessage("null.is.invalid.filter"));
1:     }
1:         //Must be a copy
1:         private final Set<Bundle> toQuiesce;
1:         // Must not be a copy
1:         private final Set<Bundle> toQuiesceShared;        
1:         //Must not be a copy
1:         private final List<QuiesceCallbackImpl> allCallbacks;
1:         //Timer so we can cancel the alarm if all done
1:         private final QuiesceFuture future;
1:         //The cleanup action that runs at timeout
1:         private final ScheduledFuture<?> timeoutFuture;
1:         
1:         public QuiesceCallbackImpl(Set<Bundle> toQuiesce, List<QuiesceCallbackImpl> allCallbacks, QuiesceFuture future, ScheduledFuture<?> timeoutFuture) 
1:         {
1:             this.toQuiesce = new HashSet<Bundle>(toQuiesce);
1:             this.toQuiesceShared = toQuiesce;
1:             this.allCallbacks = allCallbacks;
1:             this.future = future;
1:             this.timeoutFuture = timeoutFuture;
1:         }
1:         /** 
1:          * Removes the bundles from the list of those to quiesce. 
1:          * If the list is now empty, this callback object is finished (i.e. 
1:          * the participant linked to this object has quiesced all the bundles
1:          * requested).  
1:          * 
1:          * If all other participants have also completed, then the 
1:          * calling BundleQuieser thread is interrupted.
1:          */
1:         public void bundleQuiesced(Bundle... bundlesQuiesced) {
1:             
/////////////////////////////////////////////////////////////////////////
1:             }
1:         }
1:         private boolean checkOthers(Bundle b) {
1:             boolean allDone = true;
1:             Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
1:             while (allDone && it.hasNext()) {
1:                 allDone = !!!it.next().toQuiesce.contains(b);
1:             }
1:             return allDone;
1:         }
1:         
1:         private boolean allCallbacksComplete() {
1:             boolean allDone = true;
1:             Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
1:             while (allDone && it.hasNext()) {
1:             }
1:             return allDone;
1:         }        
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:bd92378
/////////////////////////////////////////////////////////////////////////
0: 						        try {
0: 						          LOGGER.warn("Quiesce timed out");
0:   						        synchronized (bundlesToQuiesce) {
0:   						            for (Bundle b : new ArrayList<Bundle>(bundlesToQuiesce)) {
0:       						            LOGGER.warn("Could not quiesce within timeout, so stopping bundle "+ b.getSymbolicName());
1:       						            stopBundle(b, bundlesToQuiesce);
1:   						            }
1:   						        }
0: 						        } finally { 
1: 						          future.registerDone();
1: 						          LOGGER.debug("Quiesce complete");
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:2f3073f
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutionException;
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeoutException;
/////////////////////////////////////////////////////////////////////////
1:     private ScheduledExecutorService timeoutExecutor = Executors.newScheduledThreadPool(10, new ThreadFactory() {
1:         public Thread newThread(Runnable r) {
1:             Thread t = new Thread(r, "Quiesce Manager Timeout Thread");
1:             t.setDaemon(true);
1:             return t;
1:         }
1:     });
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     private static ConcurrentHashMap<Bundle, Bundle> bundleMap = new ConcurrentHashMap<Bundle, Bundle>();
/////////////////////////////////////////////////////////////////////////
1:         quiesceWithFuture(timeout, bundles);
1:     }
1:     
1:     public Future<?> quiesceWithFuture(List<Bundle> bundlesToQuiesce) {
1:         return quiesceWithFuture(defaultTimeout, bundlesToQuiesce);
1:     }
1:     
1:     public Future<?> quiesceWithFuture(long timeout, List<Bundle> bundles) {
1:         QuiesceFuture result = new QuiesceFuture();
1:         if (bundles != null && !!!bundles.isEmpty()) {
1:             //check that bundle b is not already quiescing
1:             Iterator<Bundle> it = bundles.iterator();
1:             Set<Bundle> bundlesToQuiesce = new HashSet<Bundle>();
1:             while(it.hasNext()) {
1:                 Bundle b = it.next();
1:                 Bundle priorBundle = bundleMap.putIfAbsent(b, b);
1:                 if (priorBundle == null) {
1:                     bundlesToQuiesce.add(b);
1:                 }else{
0:                     LOGGER.warn("Already quiescing bundle "+ b.getSymbolicName());
1:                 }
1:             }
1:             Runnable command = new BundleQuiescer(bundlesToQuiesce, timeout, result, bundleMap);
1:             executor.execute(command);
1:             
1:             return result;
1:         } else {
1:             result.registerDone();
1:         }
1:         
1:         return result;
1:     }
1:     
1:     private static class QuiesceFuture implements Future<Object> {
1:         private CountDownLatch latch = new CountDownLatch(1);
1:         
1:         public boolean cancel(boolean mayInterruptIfRunning) {
0:             throw new UnsupportedOperationException("Quiesce operations can be cancelled");
1:         }
1: 
1:         public Object get() throws InterruptedException, ExecutionException {
1:             latch.await();
1:             return null;
1:         }
1: 
1:         public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
1:             if (!!!latch.await(timeout, unit))
1:                 throw new TimeoutException();
1:             
1:             return null;
1:         }
1: 
1:         public boolean isCancelled() {
1:             return false;
1:         }
1: 
1:         public boolean isDone() {
1:             return latch.getCount() == 0;
1:         }
1:         
1:         public void registerDone() {
1:             if (!!!isDone()) {
1:                 latch.countDown();
1:             }
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Stop a bundle that was to be quiesced. This happens either when all the participants
1:      * are finished or when the timeout has occurred.
1:      * 
1:      * The set of all bundles to quiesce is used to track stops, so that they do not occur twice.
1:      * @param bundleToStop
1:      * @param bundlesToStop
1:      * @return
1:      */
1:     private static boolean stopBundle(Bundle bundleToStop, Set<Bundle> bundlesToStop) {
0:     	    synchronized (bundlesToStop) {
0:     	        if (bundlesToStop.remove(bundleToStop)) {
0:     	            bundleToStop.stop();
0:     	            bundleMap.remove(bundleToStop);
1:     	        }
1:     	    }
0:     	} catch (BundleException be) {
1:     
1:     private static boolean stillQuiescing(Bundle bundleToStop) {
1:         return bundleMap.containsKey(bundleToStop);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:     	private final Set<Bundle> bundlesToQuiesce;
0:     	private final long timeout;
0:     	private final QuiesceFuture future;
0:     	public BundleQuiescer(Set<Bundle> bundlesToQuiesce, long timeout, QuiesceFuture future, ConcurrentHashMap<Bundle, Bundle> bundleMap) {
0:     		this.future = future;
/////////////////////////////////////////////////////////////////////////
0: 						List<Bundle> copyOfBundles = new ArrayList<Bundle>(bundlesToQuiesce);
1: 						
0: 						ScheduledFuture<?> timeoutFuture = timeoutExecutor.schedule(new Runnable() {
0: 						    public void run() {
0: 						        LOGGER.warn("Quiesce timed out");
0: 						        synchronized (bundlesToQuiesce) {
0: 						            for (Bundle b : new ArrayList<Bundle>(bundlesToQuiesce)) {
0:     						            LOGGER.warn("Could not quiesce within timeout, so stopping bundle "+ b.getSymbolicName());
1:     						            stopBundle(b, bundlesToQuiesce);
1: 						            }
1: 						        }
1: 						        future.registerDone();
0: 						        LOGGER.debug("Quiesce complete");
1: 						    }
0: 						}, timeout, TimeUnit.MILLISECONDS);
1: 
0: 							callbacks.add(new QuiesceCallbackImpl(bundlesToQuiesce, callbacks, future, timeoutFuture));
/////////////////////////////////////////////////////////////////////////
0: 							participant.quiesce(callback, copyOfBundles);
1: 						}                        
1:                     }else{
0:                         LOGGER.warn("No quiesce participants, so stopping bundles");
1:                         for (Bundle b : bundlesToQuiesce) {
0:                             stopBundle(b, bundlesToQuiesce);
1:                         }
1:                         future.registerDone();
1:                     }
1:                 }
1:             } catch (InvalidSyntaxException e) {
0:                 LOGGER.warn("Exception trying to get service references for quiesce participants, so stopping bundles."+ e.getMessage());
1:                 for (Bundle b : bundlesToQuiesce) {
0:                     stopBundle(b, bundlesToQuiesce);
1:                 }
1:                 future.registerDone();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:     	// Must not be a copy
0:     	private final Set<Bundle> toQuiesceShared;    	
0:     	private final QuiesceFuture future;
0:     	//The cleanup action that runs at timeout
0:     	private final ScheduledFuture<?> timeoutFuture;
0:     	public QuiesceCallbackImpl(Set<Bundle> toQuiesce, List<QuiesceCallbackImpl> allCallbacks, QuiesceFuture future, ScheduledFuture<?> timeoutFuture) 
0:     		this.toQuiesceShared = toQuiesce;
0:     		this.future = future;
0:     		this.timeoutFuture = timeoutFuture;
/////////////////////////////////////////////////////////////////////////
1:             boolean timeoutOccurred = false; 
1:             
1:             synchronized (allCallbacks) {
1:                 for(Bundle b : bundlesQuiesced) {
1:                     if(QuiesceManagerImpl.stillQuiescing(b)) {
1:                         if(toQuiesce.remove(b)) {
1:                             if(checkOthers(b)){
1:                                 QuiesceManagerImpl.stopBundle(b, toQuiesceShared);
1:                                 if(allCallbacksComplete()){
0:                                     future.registerDone();
1:                                     timeoutFuture.cancel(false);
0:                                     LOGGER.debug("Quiesce complete");
1:                                 }
1:                             }
1:                         }
1:                     } else {
1:                         timeoutOccurred = true;
1:                         break;
1:                     }
1:                 }
1:                 if (timeoutOccurred) {
1:                         Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
1:                         while (it.hasNext()) {
1:                             it.next().toQuiesce.clear();
1:                         }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 QuiesceCallbackImpl next = it.next();
1:                 if (!!!next.toQuiesce.isEmpty()) allDone = false;
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:74884c6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.aries.quiesce.manager.impl;
1: 
1: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Enumeration;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Set;
0: import java.util.Timer;
0: import java.util.TimerTask;
0: import java.util.concurrent.Callable;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.ScheduledFuture;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: 
1: import org.apache.aries.quiesce.manager.QuiesceCallback;
1: import org.apache.aries.quiesce.manager.QuiesceManager;
1: import org.apache.aries.quiesce.participant.QuiesceParticipant;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceReference;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class QuiesceManagerImpl implements QuiesceManager {
1: 	
0: 	/** Logger */
1:     private static final Logger LOGGER = LoggerFactory.getLogger(QuiesceManagerImpl.class.getName());
1:     /** The default timeout to use */
1:     private static int defaultTimeout = 60000; 
1:     /** The container's {@link BundleContext} */
1:     private BundleContext bundleContext = null;
1:     /** The thread pool to execute timeout commands */
0:     private ScheduledExecutorService timeoutExecutor = Executors.newScheduledThreadPool(10);
1:     /** The thread pool to execute quiesce commands */
1:     private ExecutorService executor = new ThreadPoolExecutor(0, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),new ThreadFactory() {
1: 		
0: 		public Thread newThread(Runnable arg0) {
0: 			Thread t = new Thread(arg0, "Quiesce Manager Thread");
0: 			t.setDaemon(true);
0: 			return t;
0: 		}
0: 	});
1:     /** The map of bundles that are currently being quiesced */
0:     private static ConcurrentHashMap<Long, Bundle> bundleMap = new ConcurrentHashMap<Long, Bundle>();
1: 
1: 
1:     public QuiesceManagerImpl(BundleContext bc) {
0:     	bundleContext = bc;
0:     }
1:     
1:     /**
1:      * Attempts to quiesce all bundles in the list. After the timeout has elapsed, 
1:      * or if successfully quiesced before that, the bundles are stopped. This method 
1:      * is non-blocking. Calling objects wishing to track the state of the bundles 
1:      * need to listen for the resulting stop events. 
1:      */
1:     public void quiesce(long timeout, List<Bundle> bundles) {
0:     	if (bundles != null && !!!bundles.isEmpty()) {
0: 			//check that bundle b is not already quiescing
0: 			Iterator<Bundle> it = bundles.iterator();
0: 			Set<Bundle> bundlesToQuiesce = new HashSet<Bundle>();
0: 			while(it.hasNext()) {
0: 				Bundle b = it.next();
0: 				Bundle priorBundle = bundleMap.putIfAbsent(b.getBundleId(), b);
0: 				if (priorBundle == null) {
0: 					bundlesToQuiesce.add(b);
0: 				}else{
0: 					LOGGER.warn("Already quiescing bundle "+ b.getSymbolicName());
0: 				}
0: 	  	  	}
0: 			Runnable command = new BundleQuiescer(bundlesToQuiesce, timeout, bundleMap);
0: 			executor.execute(command);
0:     	}
0:     }
1: 
1:     /**
1:      * Attempts to quiesce all bundles in the list, using the default timeout. 
1:      * After the timeout has elapsed, or if successfully quiesced before that, 
1:      * the bundles are stopped. This method is non-blocking. Calling objects 
1:      * wishing to track the state of the bundles need to listen for the 
1:      * resulting stop events. 
1:      */
1:     public void quiesce(List<Bundle> bundlesToQuiesce) {
0:     	quiesce(defaultTimeout, bundlesToQuiesce);
0:     }
1:   
0:     private static boolean stopBundle(Bundle bundleToStop) {
0:     	try {
0:     		bundleToStop.stop();
0:     		bundleMap.remove(bundleToStop.getBundleId());
0:     	}catch (BundleException be) {
0:     		return false;
0:     	}
0:     	return true;
0:     }
1: 
1:     /**
1:      * BundleQuiescer is used for each bundle to quiesce. It creates a callback object for each 
1:      * participant. Well-behaved participants will be non-blocking on their quiesce method.
1:      * When all callbacks for the participants have completed, this thread will get an 
1:      * interrupt, so it sleeps until it hits the timeout. When complete it stops the bundle
1:      * and removes the bundles from the list of those that are being quiesced.
1:      */
1:     private class BundleQuiescer implements Runnable {
1: 	  
0:     	private Set<Bundle> bundlesToQuiesce;
0:     	private long timeout;
1:     	
0:     	public BundleQuiescer(Set<Bundle> bundlesToQuiesce, long timeout, ConcurrentHashMap<Long, Bundle> bundleMap) {
0:     		this.bundlesToQuiesce = new HashSet<Bundle>(bundlesToQuiesce);
0:     		this.timeout = timeout;
0:     	}
1: 
0:     	public void run() {
0:     		try {
0: 				if (bundleContext != null) {
0: 					ServiceReference[] serviceRefs = bundleContext.getServiceReferences(QuiesceParticipant.class.getName(), null);
0: 					if (serviceRefs != null) {
0: 						List<QuiesceParticipant> participants = new ArrayList<QuiesceParticipant>();
0: 						final List<QuiesceCallbackImpl> callbacks = new ArrayList<QuiesceCallbackImpl>();
0: 						Set<Bundle> copyOfBundles = new HashSet<Bundle>(bundlesToQuiesce);
0: 						Timer timer = new Timer();
1: 						
0: 						//Create callback objects for all participants
0: 						for( ServiceReference sr : serviceRefs ) {
0: 							QuiesceParticipant participant = (QuiesceParticipant) bundleContext.getService(sr);
0: 							participants.add(participant);
0: 							callbacks.add(new QuiesceCallbackImpl(copyOfBundles, callbacks, timer));
0: 						}
1: 						
0: 						//Quiesce each participant and wait for an interrupt from a callback 
0: 						//object when all are quiesced, or the timeout to be reached
0: 						for( int i=0; i<participants.size(); i++ ) {
0: 							QuiesceParticipant participant = participants.get(i);
0: 							QuiesceCallbackImpl callback = callbacks.get(i);
0: 							List<Bundle> participantBundles = new ArrayList<Bundle>();
0: 							//deep copy
0: 							for (Bundle b : copyOfBundles) {
0: 								participantBundles.add(b);
0: 							}
0: 							participant.quiesce(callback, participantBundles);
0: 						}
0: 						timer.schedule(new TimerTask() {
1: 
0: 							@Override
0: 							public void run() {
0: 								//stop bundles
0: 								//go through callbacks and cancel all bundles
0: 								for ( Enumeration<Bundle> remainingBundles = bundleMap.elements(); remainingBundles.hasMoreElements(); ) {
0: 									Bundle b = remainingBundles.nextElement();
0: 									LOGGER.warn("Could not quiesce, so stopping bundle "+ b.getSymbolicName());
0: 									stopBundle(b);
0: 								}
1: 								/*
0: 								for ( QuiesceCallbackImpl cb : callbacks ) {
0: 									System.out.println("Clearing callback");
0: 									cb.clear();
0: 									}
1: 									*/
0: 							}
1: 							
0: 						}, timeout);
0: 					}else{
0: 						LOGGER.warn("No participants, so stopping bundles");
0: 						for ( Enumeration<Bundle> remainingBundles = bundleMap.elements(); remainingBundles.hasMoreElements(); ) {
0: 							Bundle b = remainingBundles.nextElement();
0: 							stopBundle(b);
0: 						}
0: 					}
0: 				}
0: 			} catch (InvalidSyntaxException e) {
0: 				LOGGER.warn("Exception trying to get service references for quiesce participants "+ e.getMessage());
0: 			}
0: 		}
0: 	}
1:  
1:     /**
1:      * Callback object provided for each participant for each quiesce call 
1:      * from the quiesce manager. 
1:      */
1:     private static class QuiesceCallbackImpl implements QuiesceCallback {
0:     	//Must be a copy
0:     	private final Set<Bundle> toQuiesce;
0:     	//Must not be a copy
0:     	private final List<QuiesceCallbackImpl> allCallbacks;
0:     	//Timer so we can cancel the alarm if all done
0:     	private final Timer timer;
1:     	
0:     	public QuiesceCallbackImpl(Collection<Bundle> toQuiesce, List<QuiesceCallbackImpl> allCallbacks, Timer timer) 
0:     	{
0:     		this.toQuiesce = new HashSet<Bundle>(toQuiesce);
0:     		this.allCallbacks = allCallbacks;
0:     		this.timer = timer;
0:     	}
1: 
0:     	public void clear() {
0: 			// TODO Auto-generated method stub
1: 			
0: 		}
1: 
1: 		/** 
0:     	 * Removes the bundles from the list of those to quiesce. 
0:     	 * If the list is now empty, this callback object is finished (i.e. 
0:     	 * the participant linked to this object has quiesced all the bundles
0:     	 * requested).  
1:     	 * 
0:     	 * If all other participants have also completed, then the 
0:     	 * calling BundleQuieser thread is interrupted.
1:     	 */
0:     	public void bundleQuiesced(Bundle... bundlesQuiesced) {
1:     		
0:     		synchronized (allCallbacks) {
0: 			  for(Bundle b : bundlesQuiesced) {
0: 				  if(toQuiesce.remove(b)) {
0: 					  if(checkOthers(b)){
0: 						 QuiesceManagerImpl.stopBundle(b);
0: 						 if(allCallbacksComplete()){
0: 							 timer.cancel();
0: 						 }
0: 					  }
0: 				  }
0: 			  }
0: 			}
0:     	}
1: 
0: 		private boolean checkOthers(Bundle b) {
0: 			boolean allDone = true;
0: 			Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
0: 			while (allDone && it.hasNext()) {
0: 				allDone = !!!it.next().toQuiesce.contains(b);
0: 			}
0: 			return allDone;
0: 		}
1: 		
0: 		private boolean allCallbacksComplete() {
0: 			boolean allDone = true;
0: 			Iterator<QuiesceCallbackImpl> it = allCallbacks.iterator();
0: 			while (allDone && it.hasNext()) {
0: 				allDone = !!!it.next().toQuiesce.isEmpty();
0: 			}
0: 			return allDone;
0: 		}		
0:     }
0: }
============================================================================