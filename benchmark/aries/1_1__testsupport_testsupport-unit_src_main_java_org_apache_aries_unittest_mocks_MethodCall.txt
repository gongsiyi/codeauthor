1:264011e: /*
1:264011e:  * Licensed to the Apache Software Foundation (ASF) under one
1:264011e:  * or more contributor license agreements.  See the NOTICE file
1:264011e:  * distributed with this work for additional information
1:264011e:  * regarding copyright ownership.  The ASF licenses this file
1:264011e:  * to you under the Apache License, Version 2.0 (the
1:264011e:  * "License"); you may not use this file except in compliance
1:264011e:  * with the License.  You may obtain a copy of the License at
1:264011e:  *
1:264011e:  *   http://www.apache.org/licenses/LICENSE-2.0
1:264011e:  *
1:264011e:  * Unless required by applicable law or agreed to in writing,
1:264011e:  * software distributed under the License is distributed on an
1:264011e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:264011e:  * KIND, either express or implied.  See the License for the
1:264011e:  * specific language governing permissions and limitations
1:264011e:  * under the License.
1:264011e:  */
1:264011e: package org.apache.aries.unittest.mocks;
1:264011e: 
1:264011e: import java.lang.reflect.Proxy;
1:264011e: import java.util.Arrays;
1:264011e: import java.util.Comparator;
1:264011e: import java.util.HashMap;
1:264011e: import java.util.Map;
1:264011e: import java.util.concurrent.atomic.AtomicInteger;
1:264011e: 
1:264011e: /**
1:264011e:  * <p>This class represents a method call that has been or is expected to be 
1:264011e:  *   made. It encapsulates the class that the call was made on, the method
1:264011e:  *   that was invoked and the arguments passed.</p>
1:264011e:  */
1:264011e: public final class MethodCall
1:264011e: {
1:264011e:   /** An empty object array */
1:264011e:   private static Object[] EMPTY_OBJECT_ARRAY = new Object[0];
1:264011e:   /** The name of the class invoked */
1:264011e:   private String _className;
1:264011e:   /** The array of interfaces implemented by the class */
1:264011e:   private Class<?>[] _interfaces = new Class[0];
1:264011e:   /** The method invoked */
1:264011e:   private String _methodName;
1:264011e:   /** The arguments passed */
1:264011e:   private Object[] _arguments = EMPTY_OBJECT_ARRAY;
1:264011e:   /** The object invoked */
1:264011e:   private Object _invokedObject;
1:264011e:   /** A list of comparators to use, instead of the objects .equals methods */
1:264011e:   private static Map<Class<?>, Comparator<?>> equalsHelpers = new HashMap<Class<?>, Comparator<?>>();
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* MethodCall method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This constructor allows a MethodCall to be created when the class can be
1:264011e:    * located statically, rather than dynamically.
1:264011e:    * 
1:264011e:    * @param clazz      The class.
1:264011e:    * @param methodName The method name.
1:264011e:    * @param arguments  The arguments.
1:264011e:    */
1:264011e:   public MethodCall(Class<?> clazz, String methodName, Object ... arguments)
1:264011e:   {
1:264011e:     _className = clazz.getName();
1:264011e:     _methodName = methodName;
1:264011e:     _arguments = arguments;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* MethodCall method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method is used by the Skeleton in order create an instance of a 
1:264011e:    * MethodCall representing an invoked interface.
1:264011e:    * 
1:264011e:    * NOTE: If possible changing this so the constructor does not need to be
1:264011e:    * default visibility would be good, given the problems with default 
1:264011e:    * visibility. 
1:264011e:    * 
1:264011e:    * @param invokedObject The object that was invoked.
1:264011e:    * @param methodName    The name of the method invoked.
1:264011e:    * @param arguments     The arguments passed.
1:264011e:    */
1:264011e:   MethodCall(Object invokedObject, String methodName, Object ... arguments)
1:264011e:   {
1:264011e:     _className = invokedObject.getClass().getName();
1:264011e:     _interfaces = invokedObject.getClass().getInterfaces();
1:264011e:     _methodName = methodName;
1:264011e: 
1:264011e:     this._arguments = (arguments == null) ? EMPTY_OBJECT_ARRAY : arguments;
1:264011e:     
1:264011e:     _invokedObject = invokedObject;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getArguments method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns the arguments.
1:264011e:    * 
1:264011e:    * @return The arguments.
1:264011e:    */
1:264011e:   public Object[] getArguments()
1:264011e:   {
1:264011e:     return _arguments;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getClassName method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Returns the name of the class the method was invoked or was defined on.
1:264011e:    * 
1:264011e:    * @return the classname.
1:264011e:    */
1:264011e:   public String getClassName()
1:264011e:   {
1:264011e:     return _className;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getMethodName method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Returns the name of the method that was (or will be) invoked.
1:264011e:    * 
1:264011e:    * @return the method name
1:264011e:    */
1:264011e:   public String getMethodName()
1:264011e:   {
1:264011e:     return _methodName;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* checkClassName method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method checks that the class names specified in the method call are
1:264011e:    * compatible, i.e. one is a superclass of the other.
1:264011e:    * 
1:264011e:    * @param one The first method call.
1:264011e:    * @param two The second method call.
1:264011e:    * @return    true if the classes can be assigned to each other.
1:264011e:    */
1:264011e:   private boolean checkClassName(MethodCall one, MethodCall two)
1:264011e:   {
1:264011e:     // TODO make this stuff work better.
1:264011e:     if (one._className.equals("java.lang.Object"))
1:264011e:     {
1:264011e:       return true;
1:264011e:     }
1:264011e:     else if (two._className.equals("java.lang.Object"))
1:264011e:     {
1:264011e:       return true;
1:264011e:     }
1:264011e:     else if (one._className.equals(two._className))
1:264011e:     {
1:264011e:       return true;
1:264011e:     }
1:264011e:     else
1:264011e:     {
1:264011e:       // check the other class name is one of the implemented interfaces
1:264011e:       boolean result = false;
1:264011e:         
1:264011e:       for (int i = 0; i < two._interfaces.length; i++)
1:264011e:       {
1:264011e:         if (two._interfaces[i].getName().equals(one._className))
1:264011e:         {
1:264011e:           result = true;
1:264011e:           break;
1:264011e:         }
1:264011e:       }
1:264011e:         
1:264011e:       if (!result)
1:264011e:       {
1:264011e:         for (int i = 0; i < one._interfaces.length; i++)
1:264011e:         {
1:264011e:           if (one._interfaces[i].getName().equals(two._className))
1:264011e:           {
1:264011e:             result = true;
1:264011e:             break;
1:264011e:           }
1:264011e:         }
1:264011e:       }
1:264011e:         
1:264011e:       return result;
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* equals method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Returns true if and only if the two object represent the same call.
1:264011e:    * 
1:264011e:    * @param obj The object to be compared.
1:264011e:    * @return    true if the specified object is the same as this.
1:264011e:    */
1:264011e:   @Override
1:264011e:   public boolean equals(Object obj)
1:264011e:   {
1:264011e: 
1:264011e:     if (obj == null) return false;
1:264011e: 
1:264011e:     if (obj == this) return true;
1:264011e:     
1:264011e:     if (obj instanceof MethodCall)
1:264011e:     {
1:264011e:       MethodCall other = (MethodCall)obj;
1:264011e: 
1:264011e:       if (!checkClassName(this, other)) 
1:264011e:       {
1:264011e:         return false;
1:264011e:       }
1:264011e:       
1:264011e:       if (!other._methodName.equals(this._methodName)) return false;
1:264011e:       if (other._arguments.length != this._arguments.length) return false;
1:264011e:       
1:264011e:       for (int i = 0; i < this._arguments.length; i++)
1:264011e:       {
1:264011e:         boolean thisArgNull = this._arguments[i] == null;
1:264011e:         boolean otherArgClazz = other._arguments[i] instanceof Class;
1:264011e:         boolean otherArgNull = other._arguments[i] == null;
1:264011e:         boolean thisArgClazz = this._arguments[i] instanceof Class;
1:264011e:         
1:264011e:         if (thisArgNull)
1:264011e:         {
1:264011e:           if (otherArgNull)
1:264011e:           {
1:264011e:             // This is OK
1:264011e:           }
1:264011e:           else if (otherArgClazz)
1:264011e:           {
1:264011e:             // This is also OK
1:264011e:           }
1:264011e:           else
1:264011e:           {
1:264011e:             return false;
1:264011e:           }
1:264011e:           // this argument is OK.
1:264011e:         }
1:264011e:         else if (otherArgNull)
1:264011e:         {
1:264011e:           if (thisArgClazz)
1:264011e:           {
1:264011e:             // This is OK
1:264011e:           }
1:264011e:           else
1:264011e:           {
1:264011e:             return false;
1:264011e:           }
1:264011e:           // this argument is OK.
1:264011e:         }
1:264011e:         else if (otherArgClazz)
1:264011e:         {
1:264011e:           if (thisArgClazz)
1:264011e:           {
1:264011e:             Class<?> otherArgClass = (Class<?>) other._arguments[i];
1:264011e:             Class<?> thisArgClass = (Class<?>) this._arguments[i];
1:264011e:           
1:264011e:             if (otherArgClass.equals(Class.class) || thisArgClass.equals(Class.class))
1:264011e:             {
1:264011e:               // do nothing
1:264011e:             } else if (!(otherArgClass.isAssignableFrom(thisArgClass) ||
1:264011e:                 thisArgClass.isAssignableFrom(otherArgClass)))
1:264011e:             {
1:264011e:               return false;
1:264011e:             }
1:264011e:           }
1:264011e:           else
1:264011e:           {
1:264011e:             Class<?> clazz = (Class<?>)other._arguments[i];
1:264011e:             if (clazz.isPrimitive())
1:264011e:             {
1:264011e:               if (clazz.equals(byte.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Byte.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(boolean.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Boolean.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(short.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Short.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(char.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Character.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(int.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Integer.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(long.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Long.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(float.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Float.class);
1:264011e:               }
1:264011e:               else if (clazz.equals(double.class))
1:264011e:               {
1:264011e:                 return this._arguments[i].getClass().equals(Double.class);
1:264011e:               }
1:264011e:             }
1:264011e:             else
1:264011e:             {
1:264011e:               if (!clazz.isInstance(this._arguments[i]))
1:264011e:               {
1:264011e:                 return false;
1:264011e:               }
1:264011e:             }
1:264011e:           }
1:264011e:         }
1:264011e:         else if (thisArgClazz)
1:264011e:         {
1:264011e:           Class<?> clazz = (Class<?>)this._arguments[i];
1:264011e:           if (clazz.isPrimitive())
1:264011e:           {
1:264011e:             if (clazz.equals(byte.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Byte.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(boolean.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Boolean.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(short.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Short.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(char.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Character.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(int.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Integer.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(long.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Long.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(float.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Float.class);
1:264011e:             }
1:264011e:             else if (clazz.equals(double.class))
1:264011e:             {
1:264011e:               return other._arguments[i].getClass().equals(Double.class);
1:264011e:             }
1:264011e:           }
1:264011e:           else
1:264011e:           {
1:264011e:             if (!clazz.isInstance(other._arguments[i]))
1:264011e:             {
1:264011e:               return false;
1:264011e:             }
1:264011e:           }
1:264011e:         }
1:264011e:         else if (this._arguments[i] instanceof Object[] && other._arguments[i] instanceof Object[])
1:264011e:         {
1:264011e:           return equals((Object[])this._arguments[i], (Object[])other._arguments[i]);
1:264011e:         }
1:264011e:         else 
1:264011e:         {
1:264011e:           int result = compareUsingComparators(this._arguments[i], other._arguments[i]);
1:264011e:           
1:264011e:           if (result == 0) continue;
1:264011e:           else if (result == 1) return false;
1:264011e:           else if (!!!this._arguments[i].equals(other._arguments[i])) return false;
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e: 
1:264011e:     return true;
1:264011e:   }
1:264011e: 
1:264011e:   /**
1:264011e:    * Compare two arrays calling out to the custom comparators and handling
1:264011e:    * AtomicIntegers nicely.
1:264011e:    * 
1:264011e:    * TODO remove the special casing for AtomicInteger.
1:264011e:    * 
1:264011e:    * @param arr1 
1:264011e:    * @param arr2
1:264011e:    * @return true if the arrays are equals, false otherwise.
1:264011e:    */
1:264011e:   private boolean equals(Object[] arr1, Object[] arr2)
1:264011e:   {
1:264011e:     if (arr1.length != arr2.length) return false;
1:264011e:     
1:264011e:     for (int k = 0; k < arr1.length; k++) {
1:264011e:       if (arr1[k] == arr2[k]) continue;
1:264011e:       if (arr1[k] == null && arr2[k] != null) return false;
1:264011e:       if (arr1[k] != null && arr2[k] == null) return false;
1:264011e:       
1:264011e:       int result = compareUsingComparators(arr1[k], arr2[k]);
1:264011e:       
1:264011e:       if (result == 0) continue;
1:264011e:       else if (result == 1) return false;
1:264011e:       
1:264011e:       if (arr1[k] instanceof AtomicInteger && arr2[k] instanceof AtomicInteger && 
1:264011e:           ((AtomicInteger)arr1[k]).intValue() == ((AtomicInteger)arr2[k]).intValue()) 
1:264011e:         continue;
1:264011e: 
1:264011e:       if (!!!arr1[k].equals(arr2[k])) return false;
1:264011e: 
1:264011e:     }
1:264011e:     
1:264011e:     return true;
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Attempt to do the comparison using the comparators. This logic returns:
1:264011e:    * 
1:264011e:    * <ul>
1:264011e:    *   <li>0 if they are equal</li>
1:264011e:    *   <li>1 if they are not equal</li>
1:264011e:    *   <li>-1 no comparison was run</li>
1:264011e:    * </ul>
1:264011e:    * 
1:264011e:    * @param o1 The first object.
1:264011e:    * @param o2 The second object.
1:264011e:    * @return 0, 1 or -1 depending on whether the objects were equal, not equal or no comparason was run.
1:264011e:    */
1:264011e:   private int compareUsingComparators(Object o1, Object o2)
1:264011e:   {
1:264011e:     if (o1.getClass() == o2.getClass()) {
1:264011e:       @SuppressWarnings("unchecked")
1:264011e:       Comparator<Object> compare = (Comparator<Object>) equalsHelpers.get(o1.getClass());
1:264011e:       
1:264011e:       if (compare != null) {
1:264011e:         if (compare.compare(o1, o2) == 0) return 0;
1:264011e:         else return 1;
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     return -1;
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* hashCode method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Returns the hashCode (obtained by returning the hashCode of the 
1:264011e:    * methodName).
1:264011e:    * 
1:264011e:    * @return The hashCode
1:264011e:    */
1:264011e:   @Override
1:264011e:   public int hashCode()
1:264011e:   {
1:264011e:     return _methodName.hashCode();
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* toString method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * Returns a string representation of the method call.
1:264011e:    * 
1:264011e:    * @return string representation.
1:264011e:    */
1:264011e:   @Override
1:264011e:   public String toString()
1:264011e:   {
1:264011e:     StringBuffer buffer = new StringBuffer();
1:264011e:     buffer.append(this._className);
1:264011e:     buffer.append('.');
1:264011e:     buffer.append(this._methodName);
1:264011e:     buffer.append("(");
1:264011e: 
1:264011e:     for (int i = 0; i < this._arguments.length; i++)
1:264011e:     {
1:264011e:       if (this._arguments[i] != null)
1:264011e:       {
1:264011e:         if (this._arguments[i] instanceof Class)
1:264011e:         {
1:264011e:           buffer.append(((Class<?>)this._arguments[i]).getName());
1:264011e:         }
1:264011e:         else if (Proxy.isProxyClass(this._arguments[i].getClass()))
1:264011e:         {
1:264011e:           // If the object is a dynamic proxy, just use the proxy class name to avoid calling toString on the proxy
1:264011e:           buffer.append(this._arguments[i].getClass().getName());
1:264011e:         }
1:264011e:         else if (this._arguments[i] instanceof Object[])
1:264011e:         {
1:264011e:           buffer.append(Arrays.toString((Object[])this._arguments[i]));
1:264011e:         }
1:264011e:         else
1:264011e:         {  
1:264011e:           buffer.append(String.valueOf(this._arguments[i]));
1:264011e:         }
1:264011e:       } 
1:264011e:       else
1:264011e:       {  
1:264011e:         buffer.append("null");
1:264011e:       }
1:264011e: 
1:264011e:       if (i + 1 < this._arguments.length)
1:264011e:         buffer.append(", ");
1:264011e:     }
1:264011e: 
1:264011e:     buffer.append(")");
1:264011e:     String string = buffer.toString();
1:264011e:     return string;
1:264011e:   }
1:264011e: 
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getInterfaces method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns the list of interfaces implemented by the class that
1:264011e:    * was called.
1:264011e:    * 
1:264011e:    * @return Returns the interfaces.
1:264011e:    */
1:264011e:   public Class<?>[] getInterfaces()
1:264011e:   {
1:264011e:     return this._interfaces;
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* getInvokedObject method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method returns the invoked object.
1:264011e:    * 
1:264011e:    * @return The object that was invoked or null if an expected call.
1:264011e:    */
1:264011e:   public Object getInvokedObject()
1:264011e:   {
1:264011e:     return _invokedObject;
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* registerEqualsHelper method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * The native equals for an object may not provide the behaviour required by
1:264011e:    * the tests. As an example AtomicInteger does not define a .equals, but tests
1:264011e:    * may wish to compare it being passed in a method call for equality. This
1:264011e:    * method allows a Comparator to be specified for any type and the Comparator
1:264011e:    * will be used to determine equality in place of the .equals method.
1:264011e:    * 
1:264011e:    * <p>The Comparator must not throw exceptions, and must return 0 for equality
1:264011e:    *   or any other integer for inequality.
1:264011e:    * </p>
1:264011e:    * 
1:264011e:    * @param <T>        the type of the class and comparator.
1:264011e:    * @param type       the type of the class for which the comparator will be called.
1:264011e:    * @param comparator the comparator to call.
1:264011e:    */
1:264011e:   public static <T> void registerEqualsHelper(Class<T> type, Comparator<T> comparator)
1:264011e:   {
1:264011e:     equalsHelpers.put(type, comparator);
1:264011e:   }
1:264011e:   
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /* removeEqualsHelper method                                    
1:264011e:   /* ------------------------------------------------------------------------ */
1:264011e:   /**
1:264011e:    * This method removes any registered comparator specified for the given type.
1:264011e:    * 
1:264011e:    * @param type the type to remove the comparator from.
1:264011e:    */
1:264011e:   public static void removeEqualsHelper(Class<?> type)
1:264011e:   {
1:264011e:     equalsHelpers.remove(type);
1:264011e:   }
74:4e2fb0c: }
============================================================================
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:264011e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.unittest.mocks;
1: 
1: import java.lang.reflect.Proxy;
1: import java.util.Arrays;
1: import java.util.Comparator;
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: /**
1:  * <p>This class represents a method call that has been or is expected to be 
1:  *   made. It encapsulates the class that the call was made on, the method
1:  *   that was invoked and the arguments passed.</p>
1:  */
1: public final class MethodCall
1: {
1:   /** An empty object array */
1:   private static Object[] EMPTY_OBJECT_ARRAY = new Object[0];
1:   /** The name of the class invoked */
1:   private String _className;
1:   /** The array of interfaces implemented by the class */
1:   private Class<?>[] _interfaces = new Class[0];
1:   /** The method invoked */
1:   private String _methodName;
1:   /** The arguments passed */
1:   private Object[] _arguments = EMPTY_OBJECT_ARRAY;
1:   /** The object invoked */
1:   private Object _invokedObject;
1:   /** A list of comparators to use, instead of the objects .equals methods */
1:   private static Map<Class<?>, Comparator<?>> equalsHelpers = new HashMap<Class<?>, Comparator<?>>();
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* MethodCall method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This constructor allows a MethodCall to be created when the class can be
1:    * located statically, rather than dynamically.
1:    * 
1:    * @param clazz      The class.
1:    * @param methodName The method name.
1:    * @param arguments  The arguments.
1:    */
1:   public MethodCall(Class<?> clazz, String methodName, Object ... arguments)
1:   {
1:     _className = clazz.getName();
1:     _methodName = methodName;
1:     _arguments = arguments;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* MethodCall method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method is used by the Skeleton in order create an instance of a 
1:    * MethodCall representing an invoked interface.
1:    * 
1:    * NOTE: If possible changing this so the constructor does not need to be
1:    * default visibility would be good, given the problems with default 
1:    * visibility. 
1:    * 
1:    * @param invokedObject The object that was invoked.
1:    * @param methodName    The name of the method invoked.
1:    * @param arguments     The arguments passed.
1:    */
1:   MethodCall(Object invokedObject, String methodName, Object ... arguments)
1:   {
1:     _className = invokedObject.getClass().getName();
1:     _interfaces = invokedObject.getClass().getInterfaces();
1:     _methodName = methodName;
1: 
1:     this._arguments = (arguments == null) ? EMPTY_OBJECT_ARRAY : arguments;
1:     
1:     _invokedObject = invokedObject;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* getArguments method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns the arguments.
1:    * 
1:    * @return The arguments.
1:    */
1:   public Object[] getArguments()
1:   {
1:     return _arguments;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* getClassName method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Returns the name of the class the method was invoked or was defined on.
1:    * 
1:    * @return the classname.
1:    */
1:   public String getClassName()
1:   {
1:     return _className;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* getMethodName method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Returns the name of the method that was (or will be) invoked.
1:    * 
1:    * @return the method name
1:    */
1:   public String getMethodName()
1:   {
1:     return _methodName;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* checkClassName method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method checks that the class names specified in the method call are
1:    * compatible, i.e. one is a superclass of the other.
1:    * 
1:    * @param one The first method call.
1:    * @param two The second method call.
1:    * @return    true if the classes can be assigned to each other.
1:    */
1:   private boolean checkClassName(MethodCall one, MethodCall two)
1:   {
1:     // TODO make this stuff work better.
1:     if (one._className.equals("java.lang.Object"))
1:     {
1:       return true;
1:     }
1:     else if (two._className.equals("java.lang.Object"))
1:     {
1:       return true;
1:     }
1:     else if (one._className.equals(two._className))
1:     {
1:       return true;
1:     }
1:     else
1:     {
1:       // check the other class name is one of the implemented interfaces
1:       boolean result = false;
1:         
1:       for (int i = 0; i < two._interfaces.length; i++)
1:       {
1:         if (two._interfaces[i].getName().equals(one._className))
1:         {
1:           result = true;
1:           break;
1:         }
1:       }
1:         
1:       if (!result)
1:       {
1:         for (int i = 0; i < one._interfaces.length; i++)
1:         {
1:           if (one._interfaces[i].getName().equals(two._className))
1:           {
1:             result = true;
1:             break;
1:           }
1:         }
1:       }
1:         
1:       return result;
1:     }
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* equals method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Returns true if and only if the two object represent the same call.
1:    * 
1:    * @param obj The object to be compared.
1:    * @return    true if the specified object is the same as this.
1:    */
1:   @Override
1:   public boolean equals(Object obj)
1:   {
1: 
1:     if (obj == null) return false;
1: 
1:     if (obj == this) return true;
1:     
1:     if (obj instanceof MethodCall)
1:     {
1:       MethodCall other = (MethodCall)obj;
1: 
1:       if (!checkClassName(this, other)) 
1:       {
1:         return false;
1:       }
1:       
1:       if (!other._methodName.equals(this._methodName)) return false;
1:       if (other._arguments.length != this._arguments.length) return false;
1:       
1:       for (int i = 0; i < this._arguments.length; i++)
1:       {
1:         boolean thisArgNull = this._arguments[i] == null;
1:         boolean otherArgClazz = other._arguments[i] instanceof Class;
1:         boolean otherArgNull = other._arguments[i] == null;
1:         boolean thisArgClazz = this._arguments[i] instanceof Class;
1:         
1:         if (thisArgNull)
1:         {
1:           if (otherArgNull)
1:           {
1:             // This is OK
1:           }
1:           else if (otherArgClazz)
1:           {
1:             // This is also OK
1:           }
1:           else
1:           {
1:             return false;
1:           }
1:           // this argument is OK.
1:         }
1:         else if (otherArgNull)
1:         {
1:           if (thisArgClazz)
1:           {
1:             // This is OK
1:           }
1:           else
1:           {
1:             return false;
1:           }
1:           // this argument is OK.
1:         }
1:         else if (otherArgClazz)
1:         {
1:           if (thisArgClazz)
1:           {
1:             Class<?> otherArgClass = (Class<?>) other._arguments[i];
1:             Class<?> thisArgClass = (Class<?>) this._arguments[i];
1:           
1:             if (otherArgClass.equals(Class.class) || thisArgClass.equals(Class.class))
1:             {
1:               // do nothing
1:             } else if (!(otherArgClass.isAssignableFrom(thisArgClass) ||
1:                 thisArgClass.isAssignableFrom(otherArgClass)))
1:             {
1:               return false;
1:             }
1:           }
1:           else
1:           {
1:             Class<?> clazz = (Class<?>)other._arguments[i];
1:             if (clazz.isPrimitive())
1:             {
1:               if (clazz.equals(byte.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Byte.class);
1:               }
1:               else if (clazz.equals(boolean.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Boolean.class);
1:               }
1:               else if (clazz.equals(short.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Short.class);
1:               }
1:               else if (clazz.equals(char.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Character.class);
1:               }
1:               else if (clazz.equals(int.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Integer.class);
1:               }
1:               else if (clazz.equals(long.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Long.class);
1:               }
1:               else if (clazz.equals(float.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Float.class);
1:               }
1:               else if (clazz.equals(double.class))
1:               {
1:                 return this._arguments[i].getClass().equals(Double.class);
1:               }
1:             }
1:             else
1:             {
1:               if (!clazz.isInstance(this._arguments[i]))
1:               {
1:                 return false;
1:               }
1:             }
1:           }
1:         }
1:         else if (thisArgClazz)
1:         {
1:           Class<?> clazz = (Class<?>)this._arguments[i];
1:           if (clazz.isPrimitive())
1:           {
1:             if (clazz.equals(byte.class))
1:             {
1:               return other._arguments[i].getClass().equals(Byte.class);
1:             }
1:             else if (clazz.equals(boolean.class))
1:             {
1:               return other._arguments[i].getClass().equals(Boolean.class);
1:             }
1:             else if (clazz.equals(short.class))
1:             {
1:               return other._arguments[i].getClass().equals(Short.class);
1:             }
1:             else if (clazz.equals(char.class))
1:             {
1:               return other._arguments[i].getClass().equals(Character.class);
1:             }
1:             else if (clazz.equals(int.class))
1:             {
1:               return other._arguments[i].getClass().equals(Integer.class);
1:             }
1:             else if (clazz.equals(long.class))
1:             {
1:               return other._arguments[i].getClass().equals(Long.class);
1:             }
1:             else if (clazz.equals(float.class))
1:             {
1:               return other._arguments[i].getClass().equals(Float.class);
1:             }
1:             else if (clazz.equals(double.class))
1:             {
1:               return other._arguments[i].getClass().equals(Double.class);
1:             }
1:           }
1:           else
1:           {
1:             if (!clazz.isInstance(other._arguments[i]))
1:             {
1:               return false;
1:             }
1:           }
1:         }
1:         else if (this._arguments[i] instanceof Object[] && other._arguments[i] instanceof Object[])
1:         {
1:           return equals((Object[])this._arguments[i], (Object[])other._arguments[i]);
1:         }
1:         else 
1:         {
1:           int result = compareUsingComparators(this._arguments[i], other._arguments[i]);
1:           
1:           if (result == 0) continue;
1:           else if (result == 1) return false;
1:           else if (!!!this._arguments[i].equals(other._arguments[i])) return false;
1:         }
1:       }
1:     }
1: 
1:     return true;
1:   }
1: 
1:   /**
1:    * Compare two arrays calling out to the custom comparators and handling
1:    * AtomicIntegers nicely.
1:    * 
1:    * TODO remove the special casing for AtomicInteger.
1:    * 
1:    * @param arr1 
1:    * @param arr2
1:    * @return true if the arrays are equals, false otherwise.
1:    */
1:   private boolean equals(Object[] arr1, Object[] arr2)
1:   {
1:     if (arr1.length != arr2.length) return false;
1:     
1:     for (int k = 0; k < arr1.length; k++) {
1:       if (arr1[k] == arr2[k]) continue;
1:       if (arr1[k] == null && arr2[k] != null) return false;
1:       if (arr1[k] != null && arr2[k] == null) return false;
1:       
1:       int result = compareUsingComparators(arr1[k], arr2[k]);
1:       
1:       if (result == 0) continue;
1:       else if (result == 1) return false;
1:       
1:       if (arr1[k] instanceof AtomicInteger && arr2[k] instanceof AtomicInteger && 
1:           ((AtomicInteger)arr1[k]).intValue() == ((AtomicInteger)arr2[k]).intValue()) 
1:         continue;
1: 
1:       if (!!!arr1[k].equals(arr2[k])) return false;
1: 
1:     }
1:     
1:     return true;
1:   }
1:   
1:   /**
1:    * Attempt to do the comparison using the comparators. This logic returns:
1:    * 
1:    * <ul>
1:    *   <li>0 if they are equal</li>
1:    *   <li>1 if they are not equal</li>
1:    *   <li>-1 no comparison was run</li>
1:    * </ul>
1:    * 
1:    * @param o1 The first object.
1:    * @param o2 The second object.
1:    * @return 0, 1 or -1 depending on whether the objects were equal, not equal or no comparason was run.
1:    */
1:   private int compareUsingComparators(Object o1, Object o2)
1:   {
1:     if (o1.getClass() == o2.getClass()) {
1:       @SuppressWarnings("unchecked")
1:       Comparator<Object> compare = (Comparator<Object>) equalsHelpers.get(o1.getClass());
1:       
1:       if (compare != null) {
1:         if (compare.compare(o1, o2) == 0) return 0;
1:         else return 1;
1:       }
1:     }
1:     
1:     return -1;
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* hashCode method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Returns the hashCode (obtained by returning the hashCode of the 
1:    * methodName).
1:    * 
1:    * @return The hashCode
1:    */
1:   @Override
1:   public int hashCode()
1:   {
1:     return _methodName.hashCode();
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* toString method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * Returns a string representation of the method call.
1:    * 
1:    * @return string representation.
1:    */
1:   @Override
1:   public String toString()
1:   {
1:     StringBuffer buffer = new StringBuffer();
1:     buffer.append(this._className);
1:     buffer.append('.');
1:     buffer.append(this._methodName);
1:     buffer.append("(");
1: 
1:     for (int i = 0; i < this._arguments.length; i++)
1:     {
1:       if (this._arguments[i] != null)
1:       {
1:         if (this._arguments[i] instanceof Class)
1:         {
1:           buffer.append(((Class<?>)this._arguments[i]).getName());
1:         }
1:         else if (Proxy.isProxyClass(this._arguments[i].getClass()))
1:         {
1:           // If the object is a dynamic proxy, just use the proxy class name to avoid calling toString on the proxy
1:           buffer.append(this._arguments[i].getClass().getName());
1:         }
1:         else if (this._arguments[i] instanceof Object[])
1:         {
1:           buffer.append(Arrays.toString((Object[])this._arguments[i]));
1:         }
1:         else
1:         {  
1:           buffer.append(String.valueOf(this._arguments[i]));
1:         }
1:       } 
1:       else
1:       {  
1:         buffer.append("null");
1:       }
1: 
1:       if (i + 1 < this._arguments.length)
1:         buffer.append(", ");
1:     }
1: 
1:     buffer.append(")");
1:     String string = buffer.toString();
1:     return string;
1:   }
1: 
1:   /* ------------------------------------------------------------------------ */
1:   /* getInterfaces method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns the list of interfaces implemented by the class that
1:    * was called.
1:    * 
1:    * @return Returns the interfaces.
1:    */
1:   public Class<?>[] getInterfaces()
1:   {
1:     return this._interfaces;
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* getInvokedObject method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method returns the invoked object.
1:    * 
1:    * @return The object that was invoked or null if an expected call.
1:    */
1:   public Object getInvokedObject()
1:   {
1:     return _invokedObject;
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* registerEqualsHelper method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * The native equals for an object may not provide the behaviour required by
1:    * the tests. As an example AtomicInteger does not define a .equals, but tests
1:    * may wish to compare it being passed in a method call for equality. This
1:    * method allows a Comparator to be specified for any type and the Comparator
1:    * will be used to determine equality in place of the .equals method.
1:    * 
1:    * <p>The Comparator must not throw exceptions, and must return 0 for equality
1:    *   or any other integer for inequality.
1:    * </p>
1:    * 
1:    * @param <T>        the type of the class and comparator.
1:    * @param type       the type of the class for which the comparator will be called.
1:    * @param comparator the comparator to call.
1:    */
1:   public static <T> void registerEqualsHelper(Class<T> type, Comparator<T> comparator)
1:   {
1:     equalsHelpers.put(type, comparator);
1:   }
1:   
1:   /* ------------------------------------------------------------------------ */
1:   /* removeEqualsHelper method                                    
1:   /* ------------------------------------------------------------------------ */
1:   /**
1:    * This method removes any registered comparator specified for the given type.
1:    * 
1:    * @param type the type to remove the comparator from.
1:    */
1:   public static void removeEqualsHelper(Class<?> type)
1:   {
1:     equalsHelpers.remove(type);
1:   }
commit:4e2fb0c
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.aries.unittest.mocks;
0: 
0: import java.lang.reflect.Proxy;
0: import java.util.Arrays;
0: import java.util.Comparator;
0: import java.util.HashMap;
0: import java.util.Map;
0: import java.util.concurrent.atomic.AtomicInteger;
0: 
0: /**
0:  * <p>This class represents a method call that has been or is expected to be 
0:  *   made. It encapsulates the class that the call was made on, the method
0:  *   that was invoked and the arguments passed.</p>
0:  */
0: public final class MethodCall
0: {
0:   /** An empty object array */
0:   private static Object[] EMPTY_OBJECT_ARRAY = new Object[0];
0:   /** The name of the class invoked */
0:   private String _className;
0:   /** The array of interfaces implemented by the class */
0:   private Class<?>[] _interfaces = new Class[0];
0:   /** The method invoked */
0:   private String _methodName;
0:   /** The arguments passed */
0:   private Object[] _arguments = EMPTY_OBJECT_ARRAY;
0:   /** The object invoked */
0:   private Object _invokedObject;
0:   /** A list of comparators to use, instead of the objects .equals methods */
0:   private static Map<Class<?>, Comparator<?>> equalsHelpers = new HashMap<Class<?>, Comparator<?>>();
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* MethodCall method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This constructor allows a MethodCall to be created when the class can be
0:    * located statically, rather than dynamically.
0:    * 
0:    * @param clazz      The class.
0:    * @param methodName The method name.
0:    * @param arguments  The arguments.
0:    */
0:   public MethodCall(Class<?> clazz, String methodName, Object ... arguments)
0:   {
0:     _className = clazz.getName();
0:     _methodName = methodName;
0:     _arguments = arguments;
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* MethodCall method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method is used by the Skeleton in order create an instance of a 
0:    * MethodCall representing an invoked interface.
0:    * 
0:    * NOTE: If possible changing this so the constructor does not need to be
0:    * default visibility would be good, given the problems with default 
0:    * visibility. 
0:    * 
0:    * @param invokedObject The object that was invoked.
0:    * @param methodName    The name of the method invoked.
0:    * @param arguments     The arguments passed.
0:    */
0:   MethodCall(Object invokedObject, String methodName, Object ... arguments)
0:   {
0:     _className = invokedObject.getClass().getName();
0:     _interfaces = invokedObject.getClass().getInterfaces();
0:     _methodName = methodName;
0: 
0:     this._arguments = (arguments == null) ? EMPTY_OBJECT_ARRAY : arguments;
0:     
0:     _invokedObject = invokedObject;
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* getArguments method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns the arguments.
0:    * 
0:    * @return The arguments.
0:    */
0:   public Object[] getArguments()
0:   {
0:     return _arguments;
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* getClassName method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Returns the name of the class the method was invoked or was defined on.
0:    * 
0:    * @return the classname.
0:    */
0:   public String getClassName()
0:   {
0:     return _className;
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* getMethodName method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Returns the name of the method that was (or will be) invoked.
0:    * 
0:    * @return the method name
0:    */
0:   public String getMethodName()
0:   {
0:     return _methodName;
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* checkClassName method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method checks that the class names specified in the method call are
0:    * compatible, i.e. one is a superclass of the other.
0:    * 
0:    * @param one The first method call.
0:    * @param two The second method call.
0:    * @return    true if the classes can be assigned to each other.
0:    */
0:   private boolean checkClassName(MethodCall one, MethodCall two)
0:   {
0:     // TODO make this stuff work better.
0:     if (one._className.equals("java.lang.Object"))
0:     {
0:       return true;
1:     }
0:     else if (two._className.equals("java.lang.Object"))
0:     {
0:       return true;
1:     }
0:     else if (one._className.equals(two._className))
0:     {
0:       return true;
1:     }
0:     else
0:     {
0:       // check the other class name is one of the implemented interfaces
0:       boolean result = false;
0:         
0:       for (int i = 0; i < two._interfaces.length; i++)
0:       {
0:         if (two._interfaces[i].getName().equals(one._className))
0:         {
0:           result = true;
0:           break;
1:         }
1:       }
0:         
0:       if (!result)
0:       {
0:         for (int i = 0; i < one._interfaces.length; i++)
0:         {
0:           if (one._interfaces[i].getName().equals(two._className))
0:           {
0:             result = true;
0:             break;
1:           }
1:         }
1:       }
0:         
0:       return result;
1:     }
1:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* equals method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Returns true if and only if the two object represent the same call.
0:    * 
0:    * @param obj The object to be compared.
0:    * @return    true if the specified object is the same as this.
0:    */
0:   @Override
0:   public boolean equals(Object obj)
0:   {
0: 
0:     if (obj == null) return false;
0: 
0:     if (obj == this) return true;
0:     
0:     if (obj instanceof MethodCall)
0:     {
0:       MethodCall other = (MethodCall)obj;
0: 
0:       if (!checkClassName(this, other)) 
0:       {
0:         return false;
1:       }
0:       
0:       if (!other._methodName.equals(this._methodName)) return false;
0:       if (other._arguments.length != this._arguments.length) return false;
0:       
0:       for (int i = 0; i < this._arguments.length; i++)
0:       {
0:         boolean thisArgNull = this._arguments[i] == null;
0:         boolean otherArgClazz = other._arguments[i] instanceof Class;
0:         boolean otherArgNull = other._arguments[i] == null;
0:         boolean thisArgClazz = this._arguments[i] instanceof Class;
0:         
0:         if (thisArgNull)
0:         {
0:           if (otherArgNull)
0:           {
0:             // This is OK
1:           }
0:           else if (otherArgClazz)
0:           {
0:             // This is also OK
1:           }
0:           else
0:           {
0:             return false;
1:           }
0:           // this argument is OK.
1:         }
0:         else if (otherArgNull)
0:         {
0:           if (thisArgClazz)
0:           {
0:             // This is OK
1:           }
0:           else
0:           {
0:             return false;
1:           }
0:           // this argument is OK.
1:         }
0:         else if (otherArgClazz)
0:         {
0:           if (thisArgClazz)
0:           {
0:             Class<?> otherArgClass = (Class<?>) other._arguments[i];
0:             Class<?> thisArgClass = (Class<?>) this._arguments[i];
0:           
0:             if (otherArgClass.equals(Class.class) || thisArgClass.equals(Class.class))
0:             {
0:               // do nothing
0:             } else if (!(otherArgClass.isAssignableFrom(thisArgClass) ||
0:                 thisArgClass.isAssignableFrom(otherArgClass)))
0:             {
0:               return false;
1:             }
1:           }
0:           else
0:           {
0:             Class<?> clazz = (Class<?>)other._arguments[i];
0:             if (clazz.isPrimitive())
0:             {
0:               if (clazz.equals(byte.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Byte.class);
1:               }
0:               else if (clazz.equals(boolean.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Boolean.class);
1:               }
0:               else if (clazz.equals(short.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Short.class);
1:               }
0:               else if (clazz.equals(char.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Character.class);
1:               }
0:               else if (clazz.equals(int.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Integer.class);
1:               }
0:               else if (clazz.equals(long.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Long.class);
1:               }
0:               else if (clazz.equals(float.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Float.class);
1:               }
0:               else if (clazz.equals(double.class))
0:               {
0:                 return this._arguments[i].getClass().equals(Double.class);
1:               }
1:             }
0:             else
0:             {
0:               if (!clazz.isInstance(this._arguments[i]))
0:               {
0:                 return false;
1:               }
1:             }
1:           }
1:         }
0:         else if (thisArgClazz)
0:         {
0:           Class<?> clazz = (Class<?>)this._arguments[i];
0:           if (clazz.isPrimitive())
0:           {
0:             if (clazz.equals(byte.class))
0:             {
0:               return other._arguments[i].getClass().equals(Byte.class);
1:             }
0:             else if (clazz.equals(boolean.class))
0:             {
0:               return other._arguments[i].getClass().equals(Boolean.class);
1:             }
0:             else if (clazz.equals(short.class))
0:             {
0:               return other._arguments[i].getClass().equals(Short.class);
1:             }
0:             else if (clazz.equals(char.class))
0:             {
0:               return other._arguments[i].getClass().equals(Character.class);
1:             }
0:             else if (clazz.equals(int.class))
0:             {
0:               return other._arguments[i].getClass().equals(Integer.class);
1:             }
0:             else if (clazz.equals(long.class))
0:             {
0:               return other._arguments[i].getClass().equals(Long.class);
1:             }
0:             else if (clazz.equals(float.class))
0:             {
0:               return other._arguments[i].getClass().equals(Float.class);
1:             }
0:             else if (clazz.equals(double.class))
0:             {
0:               return other._arguments[i].getClass().equals(Double.class);
1:             }
1:           }
0:           else
0:           {
0:             if (!clazz.isInstance(other._arguments[i]))
0:             {
0:               return false;
1:             }
1:           }
1:         }
0:         else if (this._arguments[i] instanceof Object[] && other._arguments[i] instanceof Object[])
0:         {
0:           return equals((Object[])this._arguments[i], (Object[])other._arguments[i]);
1:         }
0:         else 
0:         {
0:           int result = compareUsingComparators(this._arguments[i], other._arguments[i]);
0:           
0:           if (result == 0) continue;
0:           else if (result == 1) return false;
0:           else if (!!!this._arguments[i].equals(other._arguments[i])) return false;
1:         }
1:       }
1:     }
0: 
0:     return true;
1:   }
0: 
0:   /**
0:    * Compare two arrays calling out to the custom comparators and handling
0:    * AtomicIntegers nicely.
0:    * 
0:    * TODO remove the special casing for AtomicInteger.
0:    * 
0:    * @param arr1 
0:    * @param arr2
0:    * @return true if the arrays are equals, false otherwise.
0:    */
0:   private boolean equals(Object[] arr1, Object[] arr2)
0:   {
0:     if (arr1.length != arr2.length) return false;
0:     
0:     for (int k = 0; k < arr1.length; k++) {
0:       if (arr1[k] == arr2[k]) continue;
0:       if (arr1[k] == null && arr2[k] != null) return false;
0:       if (arr1[k] != null && arr2[k] == null) return false;
0:       
0:       int result = compareUsingComparators(arr1[k], arr2[k]);
0:       
0:       if (result == 0) continue;
0:       else if (result == 1) return false;
0:       
0:       if (arr1[k] instanceof AtomicInteger && arr2[k] instanceof AtomicInteger && 
0:           ((AtomicInteger)arr1[k]).intValue() == ((AtomicInteger)arr2[k]).intValue()) 
0:         continue;
0: 
0:       if (!!!arr1[k].equals(arr2[k])) return false;
0: 
1:     }
0:     
0:     return true;
1:   }
0:   
0:   /**
0:    * Attempt to do the comparison using the comparators. This logic returns:
0:    * 
0:    * <ul>
0:    *   <li>0 if they are equal</li>
0:    *   <li>1 if they are not equal</li>
0:    *   <li>-1 no comparison was run</li>
0:    * </ul>
0:    * 
0:    * @param o1 The first object.
0:    * @param o2 The second object.
0:    * @return 0, 1 or -1 depending on whether the objects were equal, not equal or no comparason was run.
0:    */
0:   private int compareUsingComparators(Object o1, Object o2)
0:   {
0:     if (o1.getClass() == o2.getClass()) {
0:       @SuppressWarnings("unchecked")
0:       Comparator<Object> compare = (Comparator<Object>) equalsHelpers.get(o1.getClass());
0:       
0:       if (compare != null) {
0:         if (compare.compare(o1, o2) == 0) return 0;
0:         else return 1;
1:       }
1:     }
0:     
0:     return -1;
1:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* hashCode method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Returns the hashCode (obtained by returning the hashCode of the 
0:    * methodName).
0:    * 
0:    * @return The hashCode
0:    */
0:   @Override
0:   public int hashCode()
0:   {
0:     return _methodName.hashCode();
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* toString method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * Returns a string representation of the method call.
0:    * 
0:    * @return string representation.
0:    */
0:   @Override
0:   public String toString()
0:   {
0:     StringBuffer buffer = new StringBuffer();
0:     buffer.append(this._className);
0:     buffer.append('.');
0:     buffer.append(this._methodName);
0:     buffer.append("(");
0: 
0:     for (int i = 0; i < this._arguments.length; i++)
0:     {
0:       if (this._arguments[i] != null)
0:       {
0:         if (this._arguments[i] instanceof Class)
0:         {
0:           buffer.append(((Class<?>)this._arguments[i]).getName());
1:         }
0:         else if (Proxy.isProxyClass(this._arguments[i].getClass()))
0:         {
0:           // If the object is a dynamic proxy, just use the proxy class name to avoid calling toString on the proxy
0:           buffer.append(this._arguments[i].getClass().getName());
1:         }
0:         else if (this._arguments[i] instanceof Object[])
0:         {
0:           buffer.append(Arrays.toString((Object[])this._arguments[i]));
1:         }
0:         else
0:         {  
0:           buffer.append(String.valueOf(this._arguments[i]));
1:         }
1:       } 
0:       else
0:       {  
0:         buffer.append("null");
1:       }
0: 
0:       if (i + 1 < this._arguments.length)
0:         buffer.append(", ");
1:     }
0: 
0:     buffer.append(")");
0:     String string = buffer.toString();
0:     return string;
1:   }
0: 
0:   /* ------------------------------------------------------------------------ */
0:   /* getInterfaces method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns the list of interfaces implemented by the class that
0:    * was called.
0:    * 
0:    * @return Returns the interfaces.
0:    */
0:   public Class<?>[] getInterfaces()
0:   {
0:     return this._interfaces;
1:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* getInvokedObject method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method returns the invoked object.
0:    * 
0:    * @return The object that was invoked or null if an expected call.
0:    */
0:   public Object getInvokedObject()
0:   {
0:     return _invokedObject;
1:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* registerEqualsHelper method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * The native equals for an object may not provide the behaviour required by
0:    * the tests. As an example AtomicInteger does not define a .equals, but tests
0:    * may wish to compare it being passed in a method call for equality. This
0:    * method allows a Comparator to be specified for any type and the Comparator
0:    * will be used to determine equality in place of the .equals method.
0:    * 
0:    * <p>The Comparator must not throw exceptions, and must return 0 for equality
0:    *   or any other integer for inequality.
0:    * </p>
0:    * 
0:    * @param <T>        the type of the class and comparator.
0:    * @param type       the type of the class for which the comparator will be called.
0:    * @param comparator the comparator to call.
0:    */
0:   public static <T> void registerEqualsHelper(Class<T> type, Comparator<T> comparator)
0:   {
0:     equalsHelpers.put(type, comparator);
1:   }
0:   
0:   /* ------------------------------------------------------------------------ */
0:   /* removeEqualsHelper method                                    
0:   /* ------------------------------------------------------------------------ */
0:   /**
0:    * This method removes any registered comparator specified for the given type.
0:    * 
0:    * @param type the type to remove the comparator from.
0:    */
0:   public static void removeEqualsHelper(Class<?> type)
0:   {
0:     equalsHelpers.remove(type);
1:   }
1: }
============================================================================