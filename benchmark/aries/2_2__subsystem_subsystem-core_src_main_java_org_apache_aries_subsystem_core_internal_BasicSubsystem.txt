1:a14f2fd: /*
1:a14f2fd:  * Licensed under the Apache License, Version 2.0 (the "License");
1:a14f2fd:  * you may not use this file except in compliance with the License.
1:a14f2fd:  * You may obtain a copy of the License at
1:a14f2fd:  *
1:a14f2fd:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a14f2fd:  *
1:a14f2fd:  * Unless required by applicable law or agreed to in writing, software
1:a14f2fd:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a14f2fd:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a14f2fd:  * See the License for the specific language governing permissions and
1:a14f2fd:  * limitations under the License.
1:a14f2fd:  */
1:777b216: package org.apache.aries.subsystem.core.internal;
1:777b216: 
1:9ac48cd: import java.io.BufferedOutputStream;
1:777b216: import java.io.File;
1:777b216: import java.io.FileOutputStream;
1:777b216: import java.io.IOException;
1:777b216: import java.io.InputStream;
1:777b216: import java.net.URISyntaxException;
1:777b216: import java.security.AccessController;
1:4556ca7: import java.security.PrivilegedAction;
1:777b216: import java.util.ArrayList;
1:777b216: import java.util.Collection;
1:777b216: import java.util.Collections;
1:391a1aa: import java.util.EnumSet;
1:9ac48cd: import java.util.HashSet;
1:777b216: import java.util.Iterator;
1:777b216: import java.util.List;
1:777b216: import java.util.Locale;
1:777b216: import java.util.Map;
1:777b216: import java.util.Map.Entry;
1:9ac48cd: import java.util.Set;
1:b66ad7c: import java.util.concurrent.locks.ReentrantLock;
1:777b216: 
1:5bd3bf6: import org.apache.aries.subsystem.AriesSubsystem;
1:a990e32: import org.apache.aries.subsystem.core.archive.AriesProvisionDependenciesDirective;
1:307d743: import org.apache.aries.subsystem.core.archive.AriesSubsystemParentsHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.DeployedContentHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.DeploymentManifest;
1:777b216: import org.apache.aries.subsystem.core.archive.Header;
1:a990e32: import org.apache.aries.subsystem.core.archive.ProvisionResourceHeader;
1:307d743: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
1:777b216: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
1:a990e32: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
1:777b216: import org.apache.aries.util.filesystem.FileSystem;
1:a990e32: import org.apache.aries.util.filesystem.ICloseableDirectory;
1:777b216: import org.apache.aries.util.filesystem.IDirectory;
1:777b216: import org.apache.aries.util.io.IOUtils;
1:3f524ae: import org.eclipse.equinox.region.Region;
1:3f524ae: import org.osgi.framework.Bundle;
1:777b216: import org.osgi.framework.BundleContext;
1:777b216: import org.osgi.framework.BundleException;
1:777b216: import org.osgi.framework.InvalidSyntaxException;
1:777b216: import org.osgi.framework.Version;
1:e341c9b: import org.osgi.framework.namespace.IdentityNamespace;
1:777b216: import org.osgi.resource.Capability;
1:777b216: import org.osgi.resource.Requirement;
1:777b216: import org.osgi.resource.Resource;
1:2b13b05: import org.osgi.service.coordinator.Coordination;
1:2b13b05: import org.osgi.service.coordinator.Participant;
1:777b216: import org.osgi.service.resolver.ResolutionException;
1:777b216: import org.osgi.service.subsystem.Subsystem;
1:777b216: import org.osgi.service.subsystem.SubsystemConstants;
1:777b216: import org.osgi.service.subsystem.SubsystemException;
1:0b3775c: import org.slf4j.Logger;
1:0b3775c: import org.slf4j.LoggerFactory;
1:777b216: 
1:5bd3bf6: public class BasicSubsystem implements Resource, AriesSubsystem {
1:0b3775c: 	private static final Logger logger = LoggerFactory.getLogger(BasicSubsystem.class);
1:0b3775c: 	
1:777b216: 	public static final String ROOT_SYMBOLIC_NAME = "org.osgi.service.subsystem.root";
1:777b216: 	public static final Version ROOT_VERSION = Version.parseVersion("1.0.0");
1:777b216: 	public static final String ROOT_LOCATION = "subsystem://?"
1:777b216: 			+ SubsystemConstants.SUBSYSTEM_SYMBOLICNAME + '='
1:777b216: 			+ ROOT_SYMBOLIC_NAME + '&' + SubsystemConstants.SUBSYSTEM_VERSION
1:777b216: 			+ '=' + ROOT_VERSION;
1:777b216: 	
1:3f524ae: 	private volatile Bundle regionContextBundle;
1:3f524ae: 	
1:3f524ae: 	private DeploymentManifest deploymentManifest;    
1:777b216: 	private SubsystemResource resource;
1:777b216: 	private SubsystemManifest subsystemManifest;
1:777b216: 	
1:777b216: 	private final IDirectory directory;
1:777b216: 	
1:5bd3bf6: 	public BasicSubsystem(SubsystemResource resource) throws URISyntaxException, IOException, BundleException, InvalidSyntaxException {
1:d6eb080: 		this(resource, null);
1:2b251bb: 	}
1:777b216: 	
1:d6eb080: 	public BasicSubsystem(SubsystemResource resource, InputStream deploymentManifest) throws URISyntaxException, IOException, BundleException, InvalidSyntaxException {
1:777b216: 		this.resource = resource;
1:2b13b05: 		final File file = new File(Activator.getInstance().getBundleContext().getDataFile(""), Long.toString(resource.getId()));
1:777b216: 		file.mkdirs();
1:2b13b05: 		Coordination coordination = Activator.getInstance().getCoordinator().peek();
1:2b13b05: 		if (coordination != null) {
1:2b13b05: 			coordination.addParticipant(new Participant() {
1:2b13b05: 				@Override
1:2b13b05: 				public void ended(Coordination c) throws Exception {
1:2b13b05: 					// Nothing
1:2b13b05: 				}
1:2b13b05: 
1:2b13b05: 				@Override
1:2b13b05: 				public void failed(Coordination c) throws Exception {
1:2b13b05: 					IOUtils.deleteRecursive(file);
1:2b13b05: 				}
1:2b13b05: 			});
1:2b13b05: 		}
1:777b216: 		directory = FileSystem.getFSRoot(file);
1:777b216: 		setSubsystemManifest(resource.getSubsystemManifest());
1:777b216: 		SubsystemManifestValidator.validate(this, getSubsystemManifest());
5:777b216: 		setDeploymentManifest(new DeploymentManifest.Builder()
1:777b216: 				.manifest(resource.getSubsystemManifest())
1:d6eb080: 				.manifest(deploymentManifest == null ? resource.getDeploymentManifest() : new DeploymentManifest(deploymentManifest))
1:777b216: 				.location(resource.getLocation())
1:777b216: 				.autostart(false)
1:777b216: 				.id(resource.getId())
1:777b216: 				.lastId(SubsystemIdentifier.getLastId())
1:777b216: 				.region(resource.getRegion().getName())
1:777b216: 				.state(State.INSTALLING)
1:777b216: 				.build());
1:d6eb080: 		setTranslations();
7:777b216: 	}
1:777b216: 	
1:5bd3bf6: 	public BasicSubsystem(File file) throws IOException, URISyntaxException, ResolutionException {
1:777b216: 		this(FileSystem.getFSRoot(file));
1:777b216: 	}
1:777b216: 	
1:f803a4f: 	public BasicSubsystem(IDirectory directory) throws IOException,
1:f803a4f: 			URISyntaxException, ResolutionException {
1:777b216: 		this.directory = directory;
1:f803a4f: 		State state = State
1:f803a4f: 				.valueOf(getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_STATE));
1:f803a4f: 		if (EnumSet.of(State.STARTING, State.ACTIVE, State.STOPPING).contains(
1:f803a4f: 				state)) {
1:f803a4f: 			state = State.RESOLVED;
1:f803a4f: 		}
1:f803a4f: 		else if (State.RESOLVING.equals(state)) {
1:f803a4f: 			state = State.INSTALLED;
1:f803a4f: 		}
1:f803a4f: 		setDeploymentManifest(new DeploymentManifest.Builder()
1:f803a4f: 				.manifest(getDeploymentManifest()).state(state).build());
1:777b216: 	}
1:777b216: 	
1:777b216: 	/* BEGIN Resource interface methods. */
1:777b216: 	
1:777b216: 	@Override
1:307d743: 	public boolean equals(Object o) {
1:307d743: 		if (o == this)
1:307d743: 			return true;
1:5bd3bf6: 		if (!(o instanceof BasicSubsystem))
1:307d743: 			return false;
1:5bd3bf6: 		BasicSubsystem that = (BasicSubsystem)o;
1:307d743: 		return getLocation().equals(that.getLocation());
1:307d743: 	}
1:4821cbe: 	
1:4821cbe: 	@Override
1:777b216: 	public List<Capability> getCapabilities(String namespace) {
1:74c0437: 		// First, add the capabilities from the manifest.
1:777b216: 		SubsystemManifest manifest = getSubsystemManifest();
2:777b216: 		List<Capability> result = manifest.toCapabilities(this);
1:74c0437: 		if (namespace != null) {
1:74c0437: 			for (Iterator<Capability> i = result.iterator(); i.hasNext();) {
1:74c0437: 				if (!i.next().getNamespace().equals(namespace)) {
1:307d743: 					i.remove();
1:74c0437: 				}
1:74c0437: 			}
1:74c0437: 		}
1:74c0437: 		if (isScoped() || IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace)) {
1:74c0437: 			// Scoped subsystems have all capabilities explicitly declared in
1:74c0437: 			// their manifests. Also, we do not want to include the osgi.identity
1:74c0437: 			// capabilities of content since a resource must have zero or one
1:74c0437: 			// osgi.identity capabilities.
1:e341c9b: 			return result;
1:74c0437: 		}
1:74c0437: 		// This is an unscoped subsystem that implicitly exports everything.
1:74c0437: 		// Its capabilities must be derived from its content.
1:74c0437: 		if (resource == null) {
1:74c0437: 			// This is a persisted subsystem. We no longer have access to the
1:74c0437: 			// original content. We must look at constituents that are also 
1:74c0437: 			// content.
1:74c0437: 			SubsystemContentHeader header = manifest.getSubsystemContentHeader();
1:74c0437: 			for (Resource constituent : getConstituents()) {
1:74c0437: 				if (header.contains(constituent)) {
1:74c0437: 					for (Capability capability : constituent.getCapabilities(namespace)) {
1:d58e0a5: 						if (namespace == null && IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace())) {
1:d58e0a5: 							// Don't want to include the osgi.identity capabilities of
1:d58e0a5: 							// content. Need a second check here in case the namespace
1:d58e0a5: 							// is null.
1:d58e0a5: 							continue;
1:d58e0a5: 						}
1:74c0437: 						result.add(new BasicCapability(capability, this));
1:74c0437: 					}
1:74c0437: 				}
1:74c0437: 			}
1:74c0437: 			return result;
1:74c0437: 		}
1:74c0437: 		// This is a newly installing subsystem. We therefore have access to the
1:74c0437: 		// original content via the SubsystemResource and can derive the
1:74c0437: 		// capabilities from there.
1:74c0437: 		Collection<Resource> installableContent = resource.getInstallableContent();
1:74c0437: 		Collection<Resource> sharedContent = resource.getSharedContent();
1:74c0437: 		Collection<Resource> contents = new ArrayList<Resource>(installableContent.size() + sharedContent.size());
1:74c0437: 		contents.addAll(installableContent);
1:74c0437: 		contents.addAll(sharedContent);
1:74c0437: 		for (Resource content : contents) {
1:74c0437: 			for (Capability capability : content.getCapabilities(namespace)) {
1:74c0437: 				if (namespace == null && IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace())) {
1:74c0437: 					// Don't want to include the osgi.identity capabilities of
1:74c0437: 					// content. Need a second check here in case the namespace
1:74c0437: 					// is null.
1:74c0437: 					continue;
1:74c0437: 				}
1:74c0437: 				result.add(new BasicCapability(capability, this));
1:74c0437: 			}
1:74c0437: 		}
1:307d743: 		return result;
1:777b216: 	}
1:307d743: 
1:307d743: 	@Override
1:777b216: 	public List<Requirement> getRequirements(String namespace) {
1:74c0437: 		// First, add the requirements from the manifest.
1:777b216: 		SubsystemManifest manifest = getSubsystemManifest();
1:777b216: 		List<Requirement> result = manifest.toRequirements(this);
1:74c0437: 		if (namespace != null) {
1:74c0437: 			for (Iterator<Requirement> i = result.iterator(); i.hasNext();) {
1:74c0437: 				if (!i.next().getNamespace().equals(namespace)) {
1:307d743: 					i.remove();
1:74c0437: 				}
1:74c0437: 			}
1:74c0437: 		}
1:74c0437: 		if (isScoped()) {
1:74c0437: 			// Scoped subsystems have all requirements explicitly declared in
1:74c0437: 			// their manifests.
1:307d743: 			return result;
1:74c0437: 		}
1:74c0437: 		// This is an unscoped subsystem that implicitly imports everything.
1:74c0437: 		// Its requirements must be derived from its content.
1:74c0437: 		if (resource == null) {
1:74c0437: 			// This is a persisted subsystem. We no longer have access to the
1:74c0437: 			// original content. We must look at constituents that are also 
1:74c0437: 			// content.
1:74c0437: 			SubsystemContentHeader header = manifest.getSubsystemContentHeader();
1:74c0437: 			for (Resource constituent : getConstituents()) {
1:74c0437: 				if (header.contains(constituent)) {
1:74c0437: 					for (Requirement requirement : constituent.getRequirements(namespace)) {
1:74c0437: 						result.add(new BasicRequirement(requirement, this));
1:74c0437: 					}
1:74c0437: 				}
1:74c0437: 			}
1:74c0437: 			return result;
1:74c0437: 		}
1:74c0437: 		// This is a newly installing subsystem. We therefore have access to the
1:74c0437: 		// original content via the SubsystemResource and can derive the
1:74c0437: 		// requirements from there.
1:74c0437: 		Collection<Resource> installableContent = resource.getInstallableContent();
1:74c0437: 		Collection<Resource> sharedContent = resource.getSharedContent();
1:74c0437: 		Collection<Resource> contents = new ArrayList<Resource>(installableContent.size() + sharedContent.size());
1:74c0437: 		contents.addAll(installableContent);
1:74c0437: 		contents.addAll(sharedContent);
1:74c0437: 		for (Resource content : contents) {
1:74c0437: 			for (Requirement requirement : content.getRequirements(namespace)) {
1:74c0437: 				result.add(new BasicRequirement(requirement, this));
1:74c0437: 			}
1:74c0437: 		}
1:307d743: 		return result;
1:307d743: 	}
1:307d743: 	
1:307d743: 	@Override
1:307d743: 	public int hashCode() {
1:307d743: 		int result = 17;
1:307d743: 		result = 31 * result + getLocation().hashCode();
3:777b216: 		return result;
1:777b216: 	}
1:777b216: 	
1:777b216: 	/* END Resource interface methods. */
1:777b216: 	
1:777b216: 	/* BEGIN Subsystem interface methods. */
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public BundleContext getBundleContext() {
1:777b216: 		SecurityManager.checkContextPermission(this);
1:777b216: 		return AccessController.doPrivileged(new GetBundleContextAction(this));
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public Collection<Subsystem> getChildren() {
1:777b216: 		return Activator.getInstance().getSubsystems().getChildren(this);
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public Map<String, String> getSubsystemHeaders(Locale locale) {
1:777b216: 		SecurityManager.checkMetadataPermission(this);
1:d6eb080: 		return AccessController.doPrivileged(new GetSubsystemHeadersAction(this, locale));
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public String getLocation() {
1:542b8e4: 		SecurityManager.checkMetadataPermission(this);
1:777b216: 		return getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_LOCATION);
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public Collection<Subsystem> getParents() {
1:2b13b05: 		AriesSubsystemParentsHeader header = getDeploymentManifest().getAriesSubsystemParentsHeader();
1:777b216: 		if (header == null)
1:777b216: 			return Collections.emptyList();
1:307d743: 		Collection<Subsystem> result = new ArrayList<Subsystem>(header.getClauses().size());
1:307d743: 		for (AriesSubsystemParentsHeader.Clause clause : header.getClauses()) {
1:5bd3bf6: 			BasicSubsystem subsystem = Activator.getInstance().getSubsystems().getSubsystemById(clause.getId());
1:307d743: 			if (subsystem == null)
1:4b2d185: 				continue;
1:307d743: 			result.add(subsystem);
1:307d743: 		}
1:777b216: 		return result;
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public Collection<Resource> getConstituents() {
1:777b216: 		return Activator.getInstance().getSubsystems().getConstituents(this);
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public State getState() {
1:777b216: 		return State.valueOf(getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_STATE));
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public long getSubsystemId() {
1:777b216: 		return Long.parseLong(getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_ID));
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public String getSymbolicName() {
1:777b216: 		return getSubsystemManifest().getSubsystemSymbolicNameHeader().getSymbolicName();
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public String getType() {
1:777b216: 		return getSubsystemManifest().getSubsystemTypeHeader().getType();
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public Version getVersion() {
1:777b216: 		return getSubsystemManifest().getSubsystemVersionHeader().getVersion();
1:777b216: 	}
1:777b216: 
1:a990e32:     /** Get "aries-provision-dependencies" directive. 
1:a990e32:      * 
1:a990e32:      * @return requested directive or null if the directive is not specified in the header
1:a990e32:      */
1:a990e32: 	public AriesProvisionDependenciesDirective getAriesProvisionDependenciesDirective() {
1:a990e32:         return getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective();
1:a990e32:     }
1:a990e32: 	
1:a990e32: 	
1:777b216: 	@Override
1:5bd3bf6: 	public AriesSubsystem install(String location) {
1:5bd3bf6: 		return install(location, (InputStream)null);
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:d6eb080: 	public AriesSubsystem install(String location, InputStream content) {
1:d6eb080: 		return install(location, content, null);
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public void start() {
1:777b216: 		SecurityManager.checkExecutePermission(this);
1:4556ca7: 		// Changing the autostart setting must be privileged because of file IO.
1:ea4e772: 		// It cannot be done within StartAction because we only want to change 
1:ea4e772: 		// it on an explicit start operation but StartAction is also used for
1:4556ca7: 		// implicit operations.
1:4556ca7: 		AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:4556ca7: 			@Override
1:4556ca7: 			public Object run() {
1:4556ca7: 				setAutostart(true);
1:4556ca7: 				return null;
1:4556ca7: 			}
1:4556ca7: 		});
1:391a1aa: 		AccessController.doPrivileged(new StartAction(this, this, this));
1:777b216: 	}
1:777b216: 
1:5bd3bf6: 	@Override
1:777b216: 	public void stop() {
1:777b216: 		SecurityManager.checkExecutePermission(this);
1:4556ca7: 		// Changing the autostart setting must be privileged because of file IO.
1:4556ca7: 		// It cannot be done within StopAction because we only want to change it
1:4556ca7: 		// on an explicit stop operation but StopAction is also used for
1:4556ca7: 		// implicit operations.
1:4556ca7: 		AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:4556ca7: 			@Override
1:4556ca7: 			public Object run() {
1:4556ca7: 				setAutostart(false);
1:4556ca7: 				return null;
1:4556ca7: 			}
1:4556ca7: 		});
1:391a1aa: 		AccessController.doPrivileged(new StopAction(this, this, !isRoot()));
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:777b216: 	public void uninstall() {
1:777b216: 		SecurityManager.checkLifecyclePermission(this);
1:391a1aa: 		AccessController.doPrivileged(new UninstallAction(this, this, false));
1:777b216: 	}
1:777b216: 	
1:777b216: 	/* END Subsystem interface methods. */
1:777b216: 	
1:391a1aa: 	void addedConstituent(Resource resource, boolean referenced) {
1:4b2d185: 		try {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Adding constituent {} to deployment manifest...", resource);
1:0b3775c: 			synchronized (this) {
1:0b3775c: 				setDeploymentManifest(new DeploymentManifest.Builder()
1:0b3775c: 						.manifest(getDeploymentManifest()).content(resource, referenced).build());
1:0b3775c: 			}
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Added constituent {} to deployment manifest", resource);
1:777b216: 		} catch (Exception e) {
3:777b216: 			throw new SubsystemException(e);
1:4b2d185: 		}
1:777b216: 	}
1:777b216: 	
1:5bd3bf6: 	void addedParent(BasicSubsystem subsystem, boolean referenceCount) {
3:777b216: 		try {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Adding parent {} to deployment manifest...", subsystem.getSymbolicName());
1:0b3775c: 			synchronized (this) {
1:0b3775c: 				setDeploymentManifest(new DeploymentManifest.Builder()
1:0b3775c: 						.manifest(getDeploymentManifest()).parent(subsystem, referenceCount).build());
1:0b3775c: 			}
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Added parent {} to deployment manifest", subsystem.getSymbolicName());
1:777b216: 		} catch (Exception e) {
1:777b216: 			throw new SubsystemException(e);
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:777b216: 	synchronized DeploymentManifest getDeploymentManifest() {
1:777b216: 		if (deploymentManifest == null) {
1:777b216: 			try {
1:777b216: 				deploymentManifest = new DeploymentManifest(directory.getFile("OSGI-INF/DEPLOYMENT.MF").open());
1:777b216: 			}
1:777b216: 			catch (Throwable t) {
1:777b216: 				throw new SubsystemException(t);
1:777b216: 			}
1:777b216: 		}
1:777b216: 		return deploymentManifest;
1:777b216: 	}
1:777b216: 	
1:777b216: 	File getDirectory() {
1:777b216: 		try {
1:777b216: 			return new File(directory.toURL().toURI());
1:777b216: 		}
1:4b2d185: 		catch (Exception e) {
1:777b216: 			throw new SubsystemException(e);
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:3f524ae: 	Region getRegion() {
1:3f524ae: 	    Bundle bundle = regionContextBundle; // volatile variable
1:3f524ae: 	    if (bundle == null) {
1:3f524ae: 	        // At best, RegionDigraph.getRegion(String) is linear time.
1:3f524ae: 	        // Continue to call this when necessary, however, as a fail safe.
1:3f524ae: 	        return Activator.getInstance().getRegionDigraph().getRegion(getRegionName());
1:3f524ae: 	    }
1:3f524ae: 	    // RegionDigraph.getRegion(Bundle) is constant time.
1:3f524ae: 	    return Activator.getInstance().getRegionDigraph().getRegion(bundle);
1:2b13b05: 	}
1:2b13b05: 	
1:2b13b05: 	String getRegionName() {
1:777b216: 		DeploymentManifest manifest = getDeploymentManifest();
1:777b216: 		Header<?> header = manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_REGION);
1:2b13b05: 		if (header == null)
1:2b13b05: 			return null;
1:2b13b05: 		return header.getValue();
1:777b216: 	}
1:5bd3bf6: 	
1:777b216: 	synchronized SubsystemResource getResource() {
1:777b216: 		if (resource == null) {
1:777b216: 			try {
1:a990e32: 				resource = new SubsystemResource(null, directory);
1:777b216: 			}
1:5bd3bf6: 			catch (Exception e) {
1:777b216: 				throw new SubsystemException(e);
1:777b216: 			}
1:2b251bb: 			Collection<DeployedContentHeader.Clause> missingResources = resource.getMissingResources();
1:2b251bb: 			if (!missingResources.isEmpty()) {
1:2b251bb: 				if (isRoot())
1:2b251bb: 					// We don't care if the root subsystem has missing resources
1:2b251bb: 					// because they are either (1) extraneous bundles outside of
1:2b251bb: 					// the subsystems API or (2) provisioned dependencies of
1:2b251bb: 					// other subsystems. Those that fall in the latter category
1:2b251bb: 					// will be detected by the dependent subsystems.
1:2b251bb: 					removedContent(missingResources);
1:4b2d185: 				else
1:2b251bb: 					// If a non-root subsystem has missing dependencies, let's
1:2b251bb: 					// fail fast for now.
1:2b251bb: 					throw new SubsystemException("Missing resources: " + missingResources);
1:4b2d185: 			}
1:4b2d185: 		}
1:777b216: 		return resource;
1:4b2d185: 	}
1:777b216: 	
1:777b216: 	synchronized SubsystemManifest getSubsystemManifest() {
1:777b216: 		if (subsystemManifest == null) {
1:4b2d185: 			try {
1:777b216: 				subsystemManifest = new SubsystemManifest(directory.getFile("OSGI-INF/SUBSYSTEM.MF").open());
1:4b2d185: 			}
1:777b216: 			catch (Throwable t) {
1:777b216: 				throw new SubsystemException(t);
1:2b251bb: 			}
1:777b216: 		}
1:777b216: 		return subsystemManifest;
1:777b216: 	}
1:777b216: 	
1:777b216: 	boolean isApplication() {
1:777b216: 		return getSubsystemManifest().getSubsystemTypeHeader().isApplication();
1:777b216: 	}
1:777b216: 	
1:777b216: 	boolean isAutostart() {
1:777b216: 		DeploymentManifest manifest = getDeploymentManifest();
1:777b216: 		Header<?> header = manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_AUTOSTART);
1:777b216: 		return Boolean.valueOf(header.getValue());
1:777b216: 	}
1:777b216: 	
1:777b216: 	boolean isComposite() {
1:777b216: 		return getSubsystemManifest().getSubsystemTypeHeader().isComposite();
1:777b216: 	}
1:777b216: 	
1:777b216: 	boolean isFeature() {
1:777b216: 		return getSubsystemManifest().getSubsystemTypeHeader().isFeature();
1:777b216: 	}
1:777b216: 	
1:391a1aa: 	boolean isReadyToStart() {
1:391a1aa: 		if (isRoot())
1:391a1aa: 			return true;
1:391a1aa: 		for (Subsystem parent : getParents())
1:391a1aa: 			if (EnumSet.of(State.STARTING, State.ACTIVE).contains(parent.getState()) && isAutostart())
1:391a1aa: 				return true;
1:391a1aa: 		return false;
1:391a1aa: 	}
1:391a1aa: 	
1:391a1aa: 	boolean isReferenced(Resource resource) {
1:391a1aa: 		// Everything is referenced for the root subsystem during initialization.
1:391a1aa: 		if (isRoot() && EnumSet.of(State.INSTALLING, State.INSTALLED).contains(getState()))
1:391a1aa: 			return true;
1:391a1aa: 		DeployedContentHeader header = getDeploymentManifest().getDeployedContentHeader();
1:391a1aa: 		if (header == null)
1:391a1aa: 			return false;
1:391a1aa: 		return header.isReferenced(resource);
1:391a1aa: 	}
1:391a1aa: 	
1:777b216: 	boolean isRoot() {
1:777b216: 		return ROOT_LOCATION.equals(getLocation());
1:777b216: 	}
1:777b216: 	
1:777b216: 	boolean isScoped() {
1:777b216: 		return isApplication() || isComposite();
1:777b216: 	}
1:777b216: 	
1:777b216: 	void removedContent(Resource resource) {
1:777b216: 		DeploymentManifest manifest = getDeploymentManifest();
1:777b216: 		DeployedContentHeader header = manifest.getDeployedContentHeader();
1:777b216: 		if (header == null)
1:777b216: 			return;
1:777b216: 		DeployedContentHeader.Clause clause = header.getClause(resource);
1:777b216: 		if (clause == null)
1:777b216: 			return;
1:2b251bb: 		removedContent(Collections.singleton(clause));
1:4b2d185: 	}
1:2b251bb: 	
1:0b3775c: 	synchronized void removedContent(Collection<DeployedContentHeader.Clause> content) {
1:2b251bb: 		DeploymentManifest manifest = getDeploymentManifest();
1:2b251bb: 		DeployedContentHeader header = manifest.getDeployedContentHeader();
1:2b251bb: 		if (header == null)
1:2b251bb: 			return;
1:777b216: 		Collection<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses());
1:777b216: 		for (Iterator<DeployedContentHeader.Clause> i = clauses.iterator(); i.hasNext();)
1:2b251bb: 			if (content.contains(i.next())) {
3:777b216: 				i.remove();
1:4b2d185: 				break;
1:4b2d185: 			}
1:777b216: 		DeploymentManifest.Builder builder = new DeploymentManifest.Builder();
1:777b216: 		for (Entry<String, Header<?>> entry : manifest.getHeaders().entrySet()) {
1:777b216: 			if (DeployedContentHeader.NAME.equals(entry.getKey()))
1:4b2d185: 				continue;
1:777b216: 			builder.header(entry.getValue());
1:777b216: 		}
1:777b216: 		if (!clauses.isEmpty())
1:777b216: 			builder.header(new DeployedContentHeader(clauses));
1:777b216: 		try {
1:777b216: 			setDeploymentManifest(builder.build());
1:777b216: 		} catch (Exception e) {
1:4b2d185: 			throw new SubsystemException(e);
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:777b216: 	void setAutostart(boolean value) {
1:777b216: 		try {
1:0b3775c: 			synchronized (this) {
1:0b3775c: 				setDeploymentManifest(new DeploymentManifest.Builder()
1:0b3775c: 						.manifest(getDeploymentManifest()).autostart(value).build());
1:0b3775c: 			}
1:777b216: 		} catch (Exception e) {
1:5bd3bf6: 			throw new SubsystemException(e);
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:9ac48cd: 	synchronized void setDeploymentManifest(DeploymentManifest value) throws IOException {
1:9ac48cd: 		deploymentManifest = value;
1:9ac48cd: 		Coordination coordination = Activator.getInstance().getCoordinator().peek();
1:0b3775c: 		if (logger.isDebugEnabled())
1:0b3775c: 			logger.debug("Setting deployment manifest for subsystem {} using coordination {}", getSymbolicName(), coordination == null ? null : coordination.getName());
1:9ac48cd: 		if (coordination == null) {
1:9ac48cd: 			saveDeploymentManifest();
1:9ac48cd: 		} else {
1:9ac48cd: 			Map<Class<?>, Object> variables = coordination.getVariables();
1:9ac48cd: 			synchronized (variables) {
1:9ac48cd: 				@SuppressWarnings("unchecked")
1:9ac48cd: 				Set<BasicSubsystem> dirtySubsystems = (Set<BasicSubsystem>) variables.get(SaveManifestParticipant.class);
1:9ac48cd: 				if (dirtySubsystems == null) {
1:9ac48cd: 					// currently no dirty subsystems found;
1:9ac48cd: 					// create a list to hold them and store it as a variable
1:9ac48cd: 					dirtySubsystems = new HashSet<BasicSubsystem>();
1:9ac48cd: 					variables.put(SaveManifestParticipant.class, dirtySubsystems);
1:9ac48cd: 					// add the save manifest participant
1:9ac48cd: 					coordination.addParticipant(new SaveManifestParticipant());
1:9ac48cd: 				}
1:9ac48cd: 				dirtySubsystems.add(this);
1:9ac48cd: 			}
1:9ac48cd: 		}
1:9ac48cd: 	}
1:9ac48cd: 
1:9ac48cd: 	synchronized void saveDeploymentManifest() throws IOException {
1:777b216: 		File file = new File(getDirectory(), "OSGI-INF");
1:777b216: 		if (!file.exists())
1:777b216: 			file.mkdirs();
1:9ac48cd: 		BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(new File(file, "DEPLOYMENT.MF")));
1:777b216: 		try {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Writing deployment manifest for subsystem {} in state {}", getSymbolicName(), getState());
1:9ac48cd: 			deploymentManifest.write(out);
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Wrote deployment manifest for subsystem {} in state {}", getSymbolicName(), getState());
1:777b216: 		}
1:777b216: 		finally {
1:9ac48cd: 			IOUtils.close(out);
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:777b216: 	void setState(State value) {
1:0b3775c: 		if (logger.isDebugEnabled())
1:0b3775c: 			logger.debug("Setting state of subsystem {} to {}", getSymbolicName(), value);
1:0b3775c: 		State state = getState();
1:0b3775c: 		if (value.equals(state)) {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Requested state {} equals current state {}", value, state);
1:777b216: 			return;
1:0b3775c: 		}
1:777b216: 		try {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Setting the deployment manifest...");
1:0b3775c: 			synchronized (this) {
1:0b3775c: 				setDeploymentManifest(new DeploymentManifest.Builder()
1:0b3775c: 						.manifest(getDeploymentManifest()).state(value).build());
1:0b3775c: 			}
1:777b216: 		} catch (Exception e) {
1:777b216: 			throw new SubsystemException(e);
1:777b216: 		}
1:777b216: 		Activator.getInstance().getSubsystemServiceRegistrar().update(this);
1:777b216: 		synchronized (this) {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Notifying all waiting for state change of subsystem {}", getSymbolicName());
1:777b216: 			notifyAll();
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:3f524ae: 	void setRegionContextBundle(Bundle value) {
1:3f524ae: 	    regionContextBundle = value; // volatile variable
1:3f524ae: 	}
1:3f524ae: 	
1:777b216: 	synchronized void setSubsystemManifest(SubsystemManifest value) throws URISyntaxException, IOException {
1:777b216: 		File file = new File(getDirectory(), "OSGI-INF");
1:777b216: 		if (!file.exists())
1:777b216: 			file.mkdirs();
1:777b216: 		FileOutputStream fos = new FileOutputStream(new File(file, "SUBSYSTEM.MF"));
1:777b216: 		try {
2:777b216: 			value.write(fos);
1:777b216: 			subsystemManifest = value;
1:777b216: 		}
1:777b216: 		finally {
2:777b216: 			IOUtils.close(fos);
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:b66ad7c: 	private final ReentrantLock stateChangeLock = new ReentrantLock();
1:b66ad7c: 	ReentrantLock stateChangeLock() {
1:b66ad7c: 		return stateChangeLock;
1:b66ad7c: 	}
1:b66ad7c: 	
1:777b216: 	private String getDeploymentManifestHeaderValue(String name) {
1:777b216: 		DeploymentManifest manifest = getDeploymentManifest();
1:777b216: 		if (manifest == null)
1:777b216: 			return null;
1:777b216: 		Header<?> header = manifest.getHeaders().get(name);
1:777b216: 		if (header == null)
1:777b216: 			return null;
1:777b216: 		return header.getValue();
1:777b216: 	}
1:777b216: 
1:777b216: 	@Override
1:5bd3bf6: 	public synchronized void addRequirements(Collection<Requirement> requirements) {
1:5bd3bf6: 		// The root subsystem has no requirements (there is no parent to import from).
1:5bd3bf6: 		if (isRoot())
1:5bd3bf6: 			throw new UnsupportedOperationException("The root subsystem does not accept additional requirements");
1:d462023: 		// Unscoped subsystems import everything already.
1:5bd3bf6: 		if (!isScoped())
1:5bd3bf6: 			return;
1:d462023: 		RegionUpdater updater = new RegionUpdater(getRegion(), ((BasicSubsystem)getParents().iterator().next()).getRegion());
1:d462023: 		try {
1:d462023: 			updater.addRequirements(requirements);
1:d462023: 		}
1:d462023: 		catch (Exception e) {
1:d462023: 			throw new SubsystemException(e);
1:4b2d185: 		}
1:5bd3bf6: 	}
1:5bd3bf6: 
1:5bd3bf6: 	@Override
1:5bd3bf6: 	public AriesSubsystem install(String location, IDirectory content) {
1:d6eb080: 		return install(location, content, null);
1:5bd3bf6: 	}
1:9ac48cd: 	
1:777b216: 	@Override
1:d6eb080: 	public AriesSubsystem install(String location, IDirectory content, InputStream deploymentManifest) {
1:5bd3bf6: 		try {
1:d6eb080: 			return AccessController.doPrivileged(new InstallAction(location, content, this, AccessController.getContext(), deploymentManifest));
1:5bd3bf6: 		}
1:777b216: 		finally {
1:d6eb080: 			IOUtils.close(deploymentManifest);
1:5bd3bf6: 		}
1:5bd3bf6: 	}
1:777b216: 
1:9ac48cd: 	private static class SaveManifestParticipant implements Participant {
1:9ac48cd: 		protected SaveManifestParticipant() {}
1:9ac48cd: 
1:9ac48cd: 		@Override
1:9ac48cd: 		public void ended(Coordination coordination) throws Exception {
1:0b3775c: 			if (logger.isDebugEnabled())
1:0b3775c: 				logger.debug("Saving deployment manifests because coordination {} ended", coordination.getName());
1:9ac48cd: 			Map<Class<?>, Object> variables = coordination.getVariables();
1:9ac48cd: 			Set<BasicSubsystem> dirtySubsystems;
1:9ac48cd: 			synchronized (variables) {
1:9ac48cd: 				@SuppressWarnings("unchecked")
1:9ac48cd: 				Set<BasicSubsystem> temp = (Set<BasicSubsystem>) variables.remove(SaveManifestParticipant.class);
1:9ac48cd: 				dirtySubsystems = temp == null ? Collections. <BasicSubsystem>emptySet() : temp;
1:9ac48cd: 			}
1:9ac48cd: 			for (BasicSubsystem dirtySubsystem : dirtySubsystems) {
1:0b3775c: 				if (logger.isDebugEnabled())
1:0b3775c: 					logger.debug("Saving deployment manifest of subsystem {} for coordination {}", dirtySubsystem.getSymbolicName(), coordination.getName());
1:9ac48cd: 				dirtySubsystem.saveDeploymentManifest();
1:9ac48cd: 			}
1:9ac48cd: 		}
1:9ac48cd: 
1:9ac48cd: 		@Override
1:9ac48cd: 		public void failed(Coordination coordination) throws Exception {
1:9ac48cd: 			// Do no saving
1:9ac48cd: 		}
1:9ac48cd: 		
1:9ac48cd: 	}
1:c3ec212: 
1:225bcae: 	@Override
1:d6eb080: 	public Map<String, String> getDeploymentHeaders() {
1:dc5d52f: 		SecurityManager.checkMetadataPermission(this);
1:d6eb080: 		return AccessController.doPrivileged(new GetDeploymentHeadersAction(this));
1:5bd3bf6: 	}
1:c3ec212: 
1:225bcae: 	@Override
1:d6eb080: 	public AriesSubsystem install(String location, final InputStream content, InputStream deploymentManifest) {
1:a990e32: 		AriesSubsystem result = null;
1:a990e32: 		IDirectory directory = null;
1:777b216: 		try {
1:a990e32: 			directory = content == null ? null : 
1:5bd3bf6: 				AccessController.doPrivileged(new PrivilegedAction<IDirectory>() {
1:5bd3bf6: 					@Override
1:5bd3bf6: 					public IDirectory run() {
1:5bd3bf6: 						return FileSystem.getFSRoot(content);
1:5bd3bf6: 					}
1:a990e32: 				});
1:a990e32: 			result = install(location, directory, deploymentManifest);
1:a990e32: 			return result;
1:5bd3bf6: 		}
1:225bcae: 		finally {
1:777b216: 			// This method must guarantee the content input stream was closed.
1:a990e32: 			// TODO Not sure closing the content is necessary. The content will
1:a990e32: 			// either be null of will have been closed while copying the data
1:a990e32: 			// to the temporary file.
1:777b216: 			IOUtils.close(content);
1:a990e32: 			// If appropriate, delete the temporary file. Subsystems having
1:a990e32: 			// apache-aries-provision-dependencies:=resolve may need the file
1:a990e32: 			// at start time if it contains any dependencies.
1:a990e32: 			if (directory instanceof ICloseableDirectory) {
1:a990e32: 				if (result == null
1:a990e32: 						|| Utils.isProvisionDependenciesInstall((BasicSubsystem)result)
1:a990e32: 						|| !wasInstalledWithChildrenHavingProvisionDependenciesResolve()) {
1:a990e32: 					final IDirectory toClose = directory;
1:a990e32: 					AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:a990e32: 						@Override
1:a990e32: 						public Void run() {
1:a990e32: 							try {
1:a990e32: 								((ICloseableDirectory) toClose).close();
1:a990e32: 							}
1:a990e32: 							catch (IOException ioex) {
1:a990e32: 								logger.info("Exception calling close for content {}. Exception {}", 
1:a990e32: 										content, ioex);					
1:a990e32: 							}
1:a990e32: 							return null;
1:a990e32: 						}
1:a990e32: 					});
1:a990e32: 				}
1:a990e32: 			}
1:777b216: 		}
1:777b216: 	}
1:777b216: 	
1:d6eb080: 	private void setTranslations() throws IOException {
1:d6eb080: 		String directoryName = getSubsystemManifest().getSubsystemLocalizationHeader().getDirectoryName();
1:d6eb080: 		File file = directoryName == null ? getDirectory() : new File(getDirectory(), directoryName);
1:d6eb080: 		if (!file.exists())
1:d6eb080: 			file.mkdirs();
1:d6eb080: 		for (TranslationFile translation : getResource().getTranslations()) {
1:d6eb080: 			translation.write(file);
1:777b216: 		}
1:777b216: 	}
1:a990e32: 	
1:b66ad7c: 	void computeDependenciesPostInstallation(Coordination coordination) throws IOException {
1:b66ad7c: 		resource.computeDependencies(null, coordination);
1:a990e32: 		ProvisionResourceHeader header = resource.computeProvisionResourceHeader();
1:a990e32: 		setDeploymentManifest(
1:a990e32: 				new DeploymentManifest.Builder()
1:a990e32: 						.manifest(deploymentManifest)
1:a990e32: 						.header(header)
1:a990e32: 						.build());
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private boolean wasInstalledWithChildrenHavingProvisionDependenciesResolve() {
1:a990e32: 		return wasInstalledWithChildrenHavingProvisionDependenciesResolve(this);
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private static boolean wasInstalledWithChildrenHavingProvisionDependenciesResolve(Subsystem child) {
1:a990e32: 		BasicSubsystem bs = (BasicSubsystem) child;
1:a990e32: 		SubsystemManifest manifest = bs.getSubsystemManifest();
1:a990e32: 		SubsystemTypeHeader header = manifest.getSubsystemTypeHeader();
1:a990e32: 		AriesProvisionDependenciesDirective directive = header.getAriesProvisionDependenciesDirective();
1:a990e32: 		if (directive.isResolve()) {
1:a990e32: 			return true;
1:a990e32: 		}
1:a990e32: 		return wasInstalledWithChildrenHavingProvisionDependenciesResolve(child.getChildren());
1:a990e32: 	}
1:a990e32: 	
1:a990e32: 	private static boolean wasInstalledWithChildrenHavingProvisionDependenciesResolve(Collection<Subsystem> children) {
1:a990e32: 		for (Subsystem child : children) {
1:a990e32: 			if (wasInstalledWithChildrenHavingProvisionDependenciesResolve(child)) {
1:a990e32: 				return true;
1:a990e32: 			}
1:a990e32: 		}
1:a990e32: 		return false;
1:a990e32: 	}
4:c3ec212: 	
1:dc5d52f: 	@Override
1:4821cbe: 	public String toString() {
1:4821cbe: 		return new StringBuilder()
1:4821cbe: 				.append(getClass().getName())
1:4821cbe: 				.append(": ")
1:4821cbe: 				.append("children=")
1:4821cbe: 				.append(getChildren().size())
1:4821cbe: 				.append(", constituents=")
1:4821cbe: 				.append(getConstituents().size())
1:4821cbe: 				.append(", id=")
1:4821cbe: 				.append(getSubsystemId())
1:4821cbe: 				.append(", location=")
1:4821cbe: 				.append(getLocation())
1:4821cbe: 				.append(", parents=")
1:4821cbe: 				.append(getParents().size())
1:4821cbe: 				.append(", state=")
1:4821cbe: 				.append(getState())
1:4821cbe: 				.append(", symbolicName=")
1:4821cbe: 				.append(getSymbolicName())
1:4821cbe: 				.append(", type=")
1:4821cbe: 				.append(getType())
1:4821cbe: 				.append(", version=")
1:4821cbe: 				.append(getVersion())
1:4821cbe: 				.toString();
1:4821cbe: 	}
1:777b216: }
============================================================================
author:John Ross
-------------------------------------------------------------------------------
commit:d58e0a5
/////////////////////////////////////////////////////////////////////////
1: 						if (namespace == null && IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace())) {
1: 							// Don't want to include the osgi.identity capabilities of
1: 							// content. Need a second check here in case the namespace
1: 							// is null.
1: 							continue;
1: 						}
commit:74c0437
/////////////////////////////////////////////////////////////////////////
1: 		// First, add the capabilities from the manifest.
1: 		if (namespace != null) {
1: 			for (Iterator<Capability> i = result.iterator(); i.hasNext();) {
1: 				if (!i.next().getNamespace().equals(namespace)) {
1: 				}
1: 			}
1: 		}
1: 		if (isScoped() || IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace)) {
1: 			// Scoped subsystems have all capabilities explicitly declared in
1: 			// their manifests. Also, we do not want to include the osgi.identity
1: 			// capabilities of content since a resource must have zero or one
1: 			// osgi.identity capabilities.
1: 		}
1: 		// This is an unscoped subsystem that implicitly exports everything.
1: 		// Its capabilities must be derived from its content.
1: 		if (resource == null) {
1: 			// This is a persisted subsystem. We no longer have access to the
1: 			// original content. We must look at constituents that are also 
1: 			// content.
1: 			SubsystemContentHeader header = manifest.getSubsystemContentHeader();
1: 			for (Resource constituent : getConstituents()) {
1: 				if (header.contains(constituent)) {
1: 					for (Capability capability : constituent.getCapabilities(namespace)) {
1: 						result.add(new BasicCapability(capability, this));
1: 					}
1: 				}
1: 			}
1: 			return result;
1: 		}
1: 		// This is a newly installing subsystem. We therefore have access to the
1: 		// original content via the SubsystemResource and can derive the
1: 		// capabilities from there.
1: 		Collection<Resource> installableContent = resource.getInstallableContent();
1: 		Collection<Resource> sharedContent = resource.getSharedContent();
1: 		Collection<Resource> contents = new ArrayList<Resource>(installableContent.size() + sharedContent.size());
1: 		contents.addAll(installableContent);
1: 		contents.addAll(sharedContent);
1: 		for (Resource content : contents) {
1: 			for (Capability capability : content.getCapabilities(namespace)) {
1: 				if (namespace == null && IdentityNamespace.IDENTITY_NAMESPACE.equals(capability.getNamespace())) {
1: 					// Don't want to include the osgi.identity capabilities of
1: 					// content. Need a second check here in case the namespace
1: 					// is null.
1: 					continue;
1: 				}
1: 				result.add(new BasicCapability(capability, this));
1: 			}
1: 		}
1: 		// First, add the requirements from the manifest.
1: 		if (namespace != null) {
1: 			for (Iterator<Requirement> i = result.iterator(); i.hasNext();) {
1: 				if (!i.next().getNamespace().equals(namespace)) {
1: 				}
1: 			}
1: 		}
1: 		if (isScoped()) {
1: 			// Scoped subsystems have all requirements explicitly declared in
1: 			// their manifests.
1: 		}
1: 		// This is an unscoped subsystem that implicitly imports everything.
1: 		// Its requirements must be derived from its content.
1: 		if (resource == null) {
1: 			// This is a persisted subsystem. We no longer have access to the
1: 			// original content. We must look at constituents that are also 
1: 			// content.
1: 			SubsystemContentHeader header = manifest.getSubsystemContentHeader();
1: 			for (Resource constituent : getConstituents()) {
1: 				if (header.contains(constituent)) {
1: 					for (Requirement requirement : constituent.getRequirements(namespace)) {
1: 						result.add(new BasicRequirement(requirement, this));
1: 					}
1: 				}
1: 			}
1: 			return result;
1: 		}
1: 		// This is a newly installing subsystem. We therefore have access to the
1: 		// original content via the SubsystemResource and can derive the
1: 		// requirements from there.
1: 		Collection<Resource> installableContent = resource.getInstallableContent();
1: 		Collection<Resource> sharedContent = resource.getSharedContent();
1: 		Collection<Resource> contents = new ArrayList<Resource>(installableContent.size() + sharedContent.size());
1: 		contents.addAll(installableContent);
1: 		contents.addAll(sharedContent);
1: 		for (Resource content : contents) {
1: 			for (Requirement requirement : content.getRequirements(namespace)) {
1: 				result.add(new BasicRequirement(requirement, this));
1: 			}
1: 		}
commit:b66ad7c
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReentrantLock;
/////////////////////////////////////////////////////////////////////////
1: 	private final ReentrantLock stateChangeLock = new ReentrantLock();
1: 	ReentrantLock stateChangeLock() {
1: 		return stateChangeLock;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	void computeDependenciesPostInstallation(Coordination coordination) throws IOException {
1: 		resource.computeDependencies(null, coordination);
commit:ea4e772
/////////////////////////////////////////////////////////////////////////
1: 		// It cannot be done within StartAction because we only want to change 
1: 		// it on an explicit start operation but StartAction is also used for
commit:4821cbe
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	@Override
1: 	public String toString() {
1: 		return new StringBuilder()
1: 				.append(getClass().getName())
1: 				.append(": ")
1: 				.append("children=")
1: 				.append(getChildren().size())
1: 				.append(", constituents=")
1: 				.append(getConstituents().size())
1: 				.append(", id=")
1: 				.append(getSubsystemId())
1: 				.append(", location=")
1: 				.append(getLocation())
1: 				.append(", parents=")
1: 				.append(getParents().size())
1: 				.append(", state=")
1: 				.append(getState())
1: 				.append(", symbolicName=")
1: 				.append(getSymbolicName())
1: 				.append(", type=")
1: 				.append(getType())
1: 				.append(", version=")
1: 				.append(getVersion())
1: 				.toString();
1: 	}
commit:a990e32
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.AriesProvisionDependenciesDirective;
1: import org.apache.aries.subsystem.core.archive.ProvisionResourceHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
1: import org.apache.aries.util.filesystem.ICloseableDirectory;
/////////////////////////////////////////////////////////////////////////
1:     /** Get "aries-provision-dependencies" directive. 
1:      * 
1:      * @return requested directive or null if the directive is not specified in the header
1:      */
1: 	public AriesProvisionDependenciesDirective getAriesProvisionDependenciesDirective() {
1:         return getSubsystemManifest().getSubsystemTypeHeader().getAriesProvisionDependenciesDirective();
1:     }
1: 	
1: 	
/////////////////////////////////////////////////////////////////////////
1: 				resource = new SubsystemResource(null, directory);
/////////////////////////////////////////////////////////////////////////
1: 		AriesSubsystem result = null;
1: 		IDirectory directory = null;
1: 			directory = content == null ? null : 
1: 				});
1: 			result = install(location, directory, deploymentManifest);
1: 			return result;
1: 			// TODO Not sure closing the content is necessary. The content will
1: 			// either be null of will have been closed while copying the data
1: 			// to the temporary file.
1: 			// If appropriate, delete the temporary file. Subsystems having
1: 			// apache-aries-provision-dependencies:=resolve may need the file
1: 			// at start time if it contains any dependencies.
1: 			if (directory instanceof ICloseableDirectory) {
1: 				if (result == null
1: 						|| Utils.isProvisionDependenciesInstall((BasicSubsystem)result)
1: 						|| !wasInstalledWithChildrenHavingProvisionDependenciesResolve()) {
1: 					final IDirectory toClose = directory;
1: 					AccessController.doPrivileged(new PrivilegedAction<Void>() {
1: 						@Override
1: 						public Void run() {
1: 							try {
1: 								((ICloseableDirectory) toClose).close();
1: 							}
1: 							catch (IOException ioex) {
1: 								logger.info("Exception calling close for content {}. Exception {}", 
1: 										content, ioex);					
1: 							}
1: 							return null;
1: 						}
1: 					});
1: 				}
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	void computeDependenciesPostInstallation() throws IOException {
0: 		resource.computeDependencies(null);
1: 		ProvisionResourceHeader header = resource.computeProvisionResourceHeader();
1: 		setDeploymentManifest(
1: 				new DeploymentManifest.Builder()
1: 						.manifest(deploymentManifest)
1: 						.header(header)
1: 						.build());
1: 	}
1: 	
1: 	private boolean wasInstalledWithChildrenHavingProvisionDependenciesResolve() {
1: 		return wasInstalledWithChildrenHavingProvisionDependenciesResolve(this);
1: 	}
1: 	
1: 	private static boolean wasInstalledWithChildrenHavingProvisionDependenciesResolve(Subsystem child) {
1: 		BasicSubsystem bs = (BasicSubsystem) child;
1: 		SubsystemManifest manifest = bs.getSubsystemManifest();
1: 		SubsystemTypeHeader header = manifest.getSubsystemTypeHeader();
1: 		AriesProvisionDependenciesDirective directive = header.getAriesProvisionDependenciesDirective();
1: 		if (directive.isResolve()) {
1: 			return true;
1: 		}
1: 		return wasInstalledWithChildrenHavingProvisionDependenciesResolve(child.getChildren());
1: 	}
1: 	
1: 	private static boolean wasInstalledWithChildrenHavingProvisionDependenciesResolve(Collection<Subsystem> children) {
1: 		for (Subsystem child : children) {
1: 			if (wasInstalledWithChildrenHavingProvisionDependenciesResolve(child)) {
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
commit:f803a4f
/////////////////////////////////////////////////////////////////////////
1: 	public BasicSubsystem(IDirectory directory) throws IOException,
1: 			URISyntaxException, ResolutionException {
1: 		State state = State
1: 				.valueOf(getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_STATE));
1: 		if (EnumSet.of(State.STARTING, State.ACTIVE, State.STOPPING).contains(
1: 				state)) {
1: 			state = State.RESOLVED;
1: 		}
1: 		else if (State.RESOLVING.equals(state)) {
1: 			state = State.INSTALLED;
1: 		}
1: 		setDeploymentManifest(new DeploymentManifest.Builder()
1: 				.manifest(getDeploymentManifest()).state(state).build());
commit:3f524ae
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.equinox.region.Region;
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
1: 	private volatile Bundle regionContextBundle;
1: 	
1: 	private DeploymentManifest deploymentManifest;    
/////////////////////////////////////////////////////////////////////////
1: 	Region getRegion() {
1: 	    Bundle bundle = regionContextBundle; // volatile variable
1: 	    if (bundle == null) {
1: 	        // At best, RegionDigraph.getRegion(String) is linear time.
1: 	        // Continue to call this when necessary, however, as a fail safe.
1: 	        return Activator.getInstance().getRegionDigraph().getRegion(getRegionName());
1: 	    }
1: 	    // RegionDigraph.getRegion(Bundle) is constant time.
1: 	    return Activator.getInstance().getRegionDigraph().getRegion(bundle);
/////////////////////////////////////////////////////////////////////////
1: 	void setRegionContextBundle(Bundle value) {
1: 	    regionContextBundle = value; // volatile variable
1: 	}
1: 	
commit:0b3775c
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 	private static final Logger logger = LoggerFactory.getLogger(BasicSubsystem.class);
1: 	
/////////////////////////////////////////////////////////////////////////
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Adding constituent {} to deployment manifest...", resource);
1: 			synchronized (this) {
1: 				setDeploymentManifest(new DeploymentManifest.Builder()
1: 						.manifest(getDeploymentManifest()).content(resource, referenced).build());
1: 			}
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Added constituent {} to deployment manifest", resource);
/////////////////////////////////////////////////////////////////////////
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Adding parent {} to deployment manifest...", subsystem.getSymbolicName());
1: 			synchronized (this) {
1: 				setDeploymentManifest(new DeploymentManifest.Builder()
1: 						.manifest(getDeploymentManifest()).parent(subsystem, referenceCount).build());
1: 			}
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Added parent {} to deployment manifest", subsystem.getSymbolicName());
/////////////////////////////////////////////////////////////////////////
1: 	synchronized void removedContent(Collection<DeployedContentHeader.Clause> content) {
/////////////////////////////////////////////////////////////////////////
1: 			synchronized (this) {
1: 				setDeploymentManifest(new DeploymentManifest.Builder()
1: 						.manifest(getDeploymentManifest()).autostart(value).build());
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		if (logger.isDebugEnabled())
1: 			logger.debug("Setting deployment manifest for subsystem {} using coordination {}", getSymbolicName(), coordination == null ? null : coordination.getName());
/////////////////////////////////////////////////////////////////////////
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Writing deployment manifest for subsystem {} in state {}", getSymbolicName(), getState());
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Wrote deployment manifest for subsystem {} in state {}", getSymbolicName(), getState());
/////////////////////////////////////////////////////////////////////////
1: 		if (logger.isDebugEnabled())
1: 			logger.debug("Setting state of subsystem {} to {}", getSymbolicName(), value);
1: 		State state = getState();
1: 		if (value.equals(state)) {
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Requested state {} equals current state {}", value, state);
1: 		}
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Setting the deployment manifest...");
1: 			synchronized (this) {
1: 				setDeploymentManifest(new DeploymentManifest.Builder()
1: 						.manifest(getDeploymentManifest()).state(value).build());
1: 			}
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Notifying all waiting for state change of subsystem {}", getSymbolicName());
/////////////////////////////////////////////////////////////////////////
1: 			if (logger.isDebugEnabled())
1: 				logger.debug("Saving deployment manifests because coordination {} ended", coordination.getName());
/////////////////////////////////////////////////////////////////////////
1: 				if (logger.isDebugEnabled())
1: 					logger.debug("Saving deployment manifest of subsystem {} for coordination {}", dirtySubsystem.getSymbolicName(), coordination.getName());
commit:9ac48cd
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedOutputStream;
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: 	synchronized void setDeploymentManifest(DeploymentManifest value) throws IOException {
1: 		deploymentManifest = value;
1: 		Coordination coordination = Activator.getInstance().getCoordinator().peek();
1: 		if (coordination == null) {
1: 			saveDeploymentManifest();
1: 		} else {
1: 			Map<Class<?>, Object> variables = coordination.getVariables();
1: 			synchronized (variables) {
1: 				@SuppressWarnings("unchecked")
1: 				Set<BasicSubsystem> dirtySubsystems = (Set<BasicSubsystem>) variables.get(SaveManifestParticipant.class);
1: 				if (dirtySubsystems == null) {
1: 					// currently no dirty subsystems found;
1: 					// create a list to hold them and store it as a variable
1: 					dirtySubsystems = new HashSet<BasicSubsystem>();
1: 					variables.put(SaveManifestParticipant.class, dirtySubsystems);
1: 					// add the save manifest participant
1: 					coordination.addParticipant(new SaveManifestParticipant());
1: 				}
1: 				dirtySubsystems.add(this);
1: 			}
1: 		}
1: 	}
1: 
1: 	synchronized void saveDeploymentManifest() throws IOException {
1: 		BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(new File(file, "DEPLOYMENT.MF")));
1: 			deploymentManifest.write(out);
1: 			IOUtils.close(out);
/////////////////////////////////////////////////////////////////////////
1: 
1: 	private static class SaveManifestParticipant implements Participant {
1: 		protected SaveManifestParticipant() {}
1: 
1: 		@Override
1: 		public void ended(Coordination coordination) throws Exception {
1: 			Map<Class<?>, Object> variables = coordination.getVariables();
1: 			Set<BasicSubsystem> dirtySubsystems;
1: 			synchronized (variables) {
1: 				@SuppressWarnings("unchecked")
1: 				Set<BasicSubsystem> temp = (Set<BasicSubsystem>) variables.remove(SaveManifestParticipant.class);
1: 				dirtySubsystems = temp == null ? Collections. <BasicSubsystem>emptySet() : temp;
1: 			}
1: 			for (BasicSubsystem dirtySubsystem : dirtySubsystems) {
1: 				dirtySubsystem.saveDeploymentManifest();
1: 			}
1: 		}
1: 
1: 		@Override
1: 		public void failed(Coordination coordination) throws Exception {
1: 			// Do no saving
1: 		}
1: 		
1: 	}
commit:d462023
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		// Unscoped subsystems import everything already.
1: 		RegionUpdater updater = new RegionUpdater(getRegion(), ((BasicSubsystem)getParents().iterator().next()).getRegion());
1: 		try {
1: 			updater.addRequirements(requirements);
1: 		}
1: 		catch (Exception e) {
1: 			throw new SubsystemException(e);
commit:4b2d185
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: 		for (int i = 0; i < 10; i++) {
1: 			try {
0: 				Region oldRegion = getRegion();
0: 				RegionDigraph currentDigraph = oldRegion.getRegionDigraph();
0: 				Region newRegion = copiedDigraph.getRegion(oldRegion.getName());
0: 				// Store the bundle ids for future reference.
0: 				Set<Long> bundleIds = newRegion.getBundleIds();
0: 				// Store the current connection info with parent for future reference.
0: 				RegionFilterBuilder parentFilter = copiedDigraph.createRegionFilterBuilder();
0: 				for (FilteredRegion filteredRegion : newRegion.getEdges()) {
0: 					Map<String, Collection<String>> sharingPolicy = filteredRegion.getFilter().getSharingPolicy();
0: 					for (Map.Entry<String, Collection<String>> entry : sharingPolicy.entrySet())
0: 						for (String filter : entry.getValue())
0: 							parentFilter.allow(entry.getKey(), filter);
1: 				}
0: 				// Add the additional requirements to the connection info with parent.
0: 				for (Requirement requirement : requirements) {
0: 					String namespace = requirement.getNamespace();
0: 					// The osgi.service namespace requires translation.
0: 					if (ServiceNamespace.SERVICE_NAMESPACE.equals(namespace))
0: 						namespace = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
0: 					String filter = requirement.getDirectives().get(IdentityNamespace.REQUIREMENT_FILTER_DIRECTIVE);
0: 					// A null filter means import everything from that namespace.
0: 					if (filter == null)
0: 						parentFilter.allowAll(namespace);
1: 					else
0: 						parentFilter.allow(namespace, filter);
1: 				}
0: 				// Store the connection info with children for future reference.
0: 				Map<String, RegionFilterBuilder> childFilters = new HashMap<String, RegionFilterBuilder>();
0: 				for (Subsystem child : getChildren()) {
0: 					if (!((BasicSubsystem)child).isScoped())
1: 						continue;
0: 					Region childRegion = ((BasicSubsystem)child).getRegion();
0: 					RegionFilterBuilder childBuilder = copiedDigraph.createRegionFilterBuilder();
0: 					for (FilteredRegion filteredRegion : childRegion.getEdges()) {
0: 						Map<String, Collection<String>> sharingPolicy = filteredRegion.getFilter().getSharingPolicy();
0: 						for (Map.Entry<String, Collection<String>> entry : sharingPolicy.entrySet())
0: 							for (String filter : entry.getValue())
0: 								childBuilder.allow(entry.getKey(), filter);
1: 					}
0: 					childFilters.put(childRegion.getName(), childBuilder);
1: 				}
0: 				// Remove the region so the parent connection can be updated.
0: 				copiedDigraph.removeRegion(newRegion);
0: 				// Recreate the region.
0: 				newRegion = copiedDigraph.createRegion(newRegion.getName());
0: 				// Copy the bundle ids.
0: 				for (Long bundleId : bundleIds)
0: 					newRegion.addBundle(bundleId);
0: 				// Reconnect to the parent.
0: 				copiedDigraph.connect(newRegion, parentFilter.build(), copiedDigraph.getRegion(((BasicSubsystem)getParents().iterator().next()).getRegion().getName()));
0: 				// Reconnect the children.
0: 				for (Map.Entry<String, RegionFilterBuilder> entry : childFilters.entrySet())
0: 					copiedDigraph.connect(copiedDigraph.getRegion(entry.getKey()), entry.getValue().build(), newRegion);
0: 				// Replace the current digraph.
1: 				try {
0: 					currentDigraph.replace(copiedDigraph);
1: 				}
0: 				catch (BundleException e) {
0: 					// Something modified digraph since the copy was made.
0: 					if (i < 10)
0: 						// There are more attempts to make.
1: 						continue;
0: 					// Number of attempts has been exhausted.
0: 					throw e;
1: 				}
0: 				// Success! No need to continue looping.
1: 				break;
0: 			// If an exception occurs for any reason other than a replacement
0: 			// failure, or replacement failed with no more attempts left, break 
0: 			// out of the loop and throw it.
0: 			catch (SubsystemException e) {
0: 				throw e;
1: 			}
1: 			catch (Exception e) {
1: 				throw new SubsystemException(e);
1: 			}
commit:5bd3bf6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.AriesSubsystem;
/////////////////////////////////////////////////////////////////////////
0: import org.eclipse.equinox.region.Region;
0: import org.eclipse.equinox.region.RegionDigraph;
0: import org.eclipse.equinox.region.RegionDigraph.FilteredRegion;
0: import org.eclipse.equinox.region.RegionFilter;
0: import org.eclipse.equinox.region.RegionFilterBuilder;
0: import org.osgi.namespace.service.ServiceNamespace;
/////////////////////////////////////////////////////////////////////////
1: public class BasicSubsystem implements Resource, AriesSubsystem {
/////////////////////////////////////////////////////////////////////////
1: 	public BasicSubsystem(SubsystemResource resource) throws URISyntaxException, IOException, BundleException, InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 	public BasicSubsystem(File file) throws IOException, URISyntaxException, ResolutionException {
0: 	public BasicSubsystem(IDirectory directory) throws IOException, URISyntaxException, ResolutionException {
/////////////////////////////////////////////////////////////////////////
1: 		if (!(o instanceof BasicSubsystem))
1: 		BasicSubsystem that = (BasicSubsystem)o;
/////////////////////////////////////////////////////////////////////////
1: 			BasicSubsystem subsystem = Activator.getInstance().getSubsystems().getSubsystemById(clause.getId());
/////////////////////////////////////////////////////////////////////////
1: 	public AriesSubsystem install(String location) {
1: 		return install(location, (InputStream)null);
0: 	public AriesSubsystem install(String location, final InputStream content) {
0: 			return install(location, content == null ? null : 
1: 				AccessController.doPrivileged(new PrivilegedAction<IDirectory>() {
1: 					@Override
1: 					public IDirectory run() {
1: 						return FileSystem.getFSRoot(content);
1: 					}
0: 				}));
/////////////////////////////////////////////////////////////////////////
1: 	void addedParent(BasicSubsystem subsystem, boolean referenceCount) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 	@Override
1: 	public synchronized void addRequirements(Collection<Requirement> requirements) {
1: 		// The root subsystem has no requirements (there is no parent to import from).
1: 		if (isRoot())
1: 			throw new UnsupportedOperationException("The root subsystem does not accept additional requirements");
0: 		// Unscoped subsystems import everything.already.
1: 		if (!isScoped())
1: 			return;
0: 		Region currentRegion = getRegion();
0: 		RegionDigraph currentDigraph = currentRegion.getRegionDigraph();
0: 		RegionFilterBuilder filterBuilder = currentDigraph.createRegionFilterBuilder();
1: 		try {
0: 			// Copy the sharing policy of the current region.
0: 			for (FilteredRegion filteredRegion : currentRegion.getEdges()) {
0: 				Map<String, Collection<String>> sharingPolicy = filteredRegion.getFilter().getSharingPolicy();
0: 				for (Map.Entry<String, Collection<String>> entry : sharingPolicy.entrySet())
0: 					for (String filter : entry.getValue())
0: 						filterBuilder.allow(entry.getKey(), filter);
1: 			}
0: 			// Add the additional requirements to the sharing policy.
0: 			for (Requirement requirement : requirements) {
0: 				String namespace = requirement.getNamespace();
0: 				// The osgi.service namespace requires translation.
0: 				if (ServiceNamespace.SERVICE_NAMESPACE.equals(namespace))
0: 					namespace = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
0: 				String filter = requirement.getDirectives().get(IdentityNamespace.REQUIREMENT_FILTER_DIRECTIVE);
0: 				// A null filter means import everything from that namespace.
0: 				if (filter == null)
0: 					filterBuilder.allowAll(namespace);
0: 				else
0: 					filterBuilder.allow(namespace, filter);
1: 			}
0: 			// Update the region digraph. Lock on the class to prevent conflicts
0: 			// with other subsystems updating their own requirements.
0: 			// TODO This lock does not prevent conflicts with users outside of
0: 			// subsystems.
0: 			synchronized (BasicSubsystem.class) {
0: 				RegionDigraph copiedDigraph = currentDigraph.copy();
0: 				copiedDigraph.removeRegion(currentRegion);
0: 				Region fromRegion = copiedDigraph.createRegion(currentRegion.getName());
0: 				Region toRegion = ((BasicSubsystem)getParents().iterator().next()).getRegion();
0: 				copiedDigraph.connect(fromRegion, filterBuilder.build(), copiedDigraph.getRegion(toRegion.getName()));
0: 				// TODO Protect against the possibility of an already modified
0: 				// digraph with multiple attempts, if necessary?
0: 				currentDigraph.replace(copiedDigraph);
1: 			}
1: 		}
1: 		catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 
1: 	@Override
1: 	public AriesSubsystem install(String location, IDirectory content) {
0: 		return AccessController.doPrivileged(new InstallAction(location, content, this, AccessController.getContext()));
1: 	}
commit:ed5f3dc
/////////////////////////////////////////////////////////////////////////
commit:2b251bb
/////////////////////////////////////////////////////////////////////////
1: 			Collection<DeployedContentHeader.Clause> missingResources = resource.getMissingResources();
1: 			if (!missingResources.isEmpty()) {
1: 				if (isRoot())
1: 					// We don't care if the root subsystem has missing resources
1: 					// because they are either (1) extraneous bundles outside of
1: 					// the subsystems API or (2) provisioned dependencies of
1: 					// other subsystems. Those that fall in the latter category
1: 					// will be detected by the dependent subsystems.
1: 					removedContent(missingResources);
0: 				else
1: 					// If a non-root subsystem has missing dependencies, let's
1: 					// fail fast for now.
1: 					throw new SubsystemException("Missing resources: " + missingResources);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		removedContent(Collections.singleton(clause));
1: 	}
1: 	
0: 	void removedContent(Collection<DeployedContentHeader.Clause> content) {
1: 		DeploymentManifest manifest = getDeploymentManifest();
1: 		DeployedContentHeader header = manifest.getDeployedContentHeader();
1: 		if (header == null)
1: 			return;
1: 			if (content.contains(i.next())) {
commit:4556ca7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 		// Changing the autostart setting must be privileged because of file IO.
0: 		// It cannot be done within SartAction because we only want to change it
0: 		// on an explicit start operation but StartAction is also used for
1: 		// implicit operations.
1: 		AccessController.doPrivileged(new PrivilegedAction<Object>() {
1: 			@Override
1: 			public Object run() {
1: 				setAutostart(true);
1: 				return null;
1: 			}
1: 		});
1: 		// Changing the autostart setting must be privileged because of file IO.
1: 		// It cannot be done within StopAction because we only want to change it
1: 		// on an explicit stop operation but StopAction is also used for
1: 		// implicit operations.
1: 		AccessController.doPrivileged(new PrivilegedAction<Object>() {
1: 			@Override
1: 			public Object run() {
1: 				setAutostart(false);
1: 				return null;
1: 			}
1: 		});
commit:391a1aa
/////////////////////////////////////////////////////////////////////////
1: import java.util.EnumSet;
/////////////////////////////////////////////////////////////////////////
0: 		setDeploymentManifest(new DeploymentManifest.Builder().manifest(getDeploymentManifest()).build());
/////////////////////////////////////////////////////////////////////////
0: 		setAutostart(true);
1: 		AccessController.doPrivileged(new StartAction(this, this, this));
0: 		setAutostart(false);
1: 		AccessController.doPrivileged(new StopAction(this, this, !isRoot()));
1: 		AccessController.doPrivileged(new UninstallAction(this, this, false));
1: 	void addedConstituent(Resource resource, boolean referenced) {
0: 					.manifest(getDeploymentManifest()).content(resource, referenced).build());
/////////////////////////////////////////////////////////////////////////
1: 	boolean isReadyToStart() {
1: 		if (isRoot())
1: 			return true;
1: 		for (Subsystem parent : getParents())
1: 			if (EnumSet.of(State.STARTING, State.ACTIVE).contains(parent.getState()) && isAutostart())
1: 				return true;
1: 		return false;
1: 	}
1: 	
1: 	boolean isReferenced(Resource resource) {
1: 		// Everything is referenced for the root subsystem during initialization.
1: 		if (isRoot() && EnumSet.of(State.INSTALLING, State.INSTALLED).contains(getState()))
1: 			return true;
1: 		DeployedContentHeader header = getDeploymentManifest().getDeployedContentHeader();
1: 		if (header == null)
1: 			return false;
1: 		return header.isReferenced(resource);
1: 	}
1: 	
commit:a14f2fd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:542b8e4
/////////////////////////////////////////////////////////////////////////
1: 		SecurityManager.checkMetadataPermission(this);
commit:e341c9b
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.namespace.IdentityNamespace;
/////////////////////////////////////////////////////////////////////////
0: 		if (isScoped() || IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace))
1: 			return result;
0: 		SubsystemContentHeader header = manifest.getSubsystemContentHeader();
0: 		for (Resource constituent : getConstituents())
0: 			if (header.contains(constituent))
0: 				for (Capability capability : constituent.getCapabilities(namespace))
0: 					result.add(new BasicCapability(capability, this));
commit:2b13b05
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.service.coordinator.Coordination;
1: import org.osgi.service.coordinator.Participant;
/////////////////////////////////////////////////////////////////////////
1: 		final File file = new File(Activator.getInstance().getBundleContext().getDataFile(""), Long.toString(resource.getId()));
1: 		Coordination coordination = Activator.getInstance().getCoordinator().peek();
1: 		if (coordination != null) {
1: 			coordination.addParticipant(new Participant() {
1: 				@Override
1: 				public void ended(Coordination c) throws Exception {
1: 					// Nothing
1: 				}
1: 
1: 				@Override
1: 				public void failed(Coordination c) throws Exception {
1: 					IOUtils.deleteRecursive(file);
1: 				}
1: 			});
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		// TODO Somehow, exposing the capabilities of content resources of a
0: 		// feature is causing an infinite regression of feature2 installations
0: 		// in FeatureTest.testSharedContent() under certain conditions.
0: //		if (isScoped() || IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace))
0: //			return result;
0: //		SubsystemContentHeader header = manifest.getSubsystemContentHeader();
0: //		for (Resource constituent : getConstituents())
0: //			if (header.contains(constituent))
0: //				for (Capability capability : constituent.getCapabilities(namespace))
0: //					result.add(new BasicCapability(capability, this));
/////////////////////////////////////////////////////////////////////////
0: 		SubsystemContentHeader header = manifest.getSubsystemContentHeader();
/////////////////////////////////////////////////////////////////////////
1: 		AriesSubsystemParentsHeader header = getDeploymentManifest().getAriesSubsystemParentsHeader();
/////////////////////////////////////////////////////////////////////////
0: 		AccessController.doPrivileged(new StartAction(this, true));
0: 		AccessController.doPrivileged(new StopAction(this, !isRoot(), true));
0: 		AccessController.doPrivileged(new UninstallAction(this, false, true));
/////////////////////////////////////////////////////////////////////////
0: 		return Activator.getInstance().getRegionDigraph().getRegion(getRegionName());
1: 	}
1: 	
1: 	String getRegionName() {
1: 		if (header == null)
1: 			return null;
1: 		return header.getValue();
commit:307d743
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.subsystem.core.archive.AriesSubsystemParentsHeader;
1: import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public boolean equals(Object o) {
1: 		if (o == this)
1: 			return true;
0: 		if (!(o instanceof AriesSubsystem))
1: 			return false;
0: 		AriesSubsystem that = (AriesSubsystem)o;
1: 		return getLocation().equals(that.getLocation());
1: 	}
1: 	
1: 	@Override
0: 		if (namespace != null)
0: 			for (Iterator<Capability> i = result.iterator(); i.hasNext();)
0: 				if (!i.next().getNamespace().equals(namespace))
1: 					i.remove();
0: 		if (isScoped() || IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace))
1: 			return result;
0: 		SubsystemContentHeader header = subsystemManifest.getSubsystemContentHeader();
0: 		for (Resource constituent : getConstituents())
0: 			if (header.contains(constituent))
0: 				for (Capability capability : constituent.getCapabilities(namespace))
0: 					result.add(new BasicCapability(capability, this));
0: 		if (namespace != null)
0: 			for (Iterator<Requirement> i = result.iterator(); i.hasNext();)
0: 				if (!i.next().getNamespace().equals(namespace))
1: 					i.remove();
0: 		if (isScoped())
1: 			return result;
0: 		SubsystemContentHeader header = subsystemManifest.getSubsystemContentHeader();
0: 		for (Resource constituent : getConstituents())
0: 			if (header.contains(constituent))
0: 				for (Requirement requirement : constituent.getRequirements(namespace))
0: 					result.add(new BasicRequirement(requirement, this));
1: 		return result;
1: 	}
1: 	
1: 	@Override
1: 	public int hashCode() {
1: 		int result = 17;
1: 		result = 31 * result + getLocation().hashCode();
/////////////////////////////////////////////////////////////////////////
0: 		AriesSubsystemParentsHeader header = deploymentManifest.getAriesSubsystemParentsHeader();
1: 		Collection<Subsystem> result = new ArrayList<Subsystem>(header.getClauses().size());
1: 		for (AriesSubsystemParentsHeader.Clause clause : header.getClauses()) {
0: 			AriesSubsystem subsystem = Activator.getInstance().getSubsystems().getSubsystemById(clause.getId());
1: 			if (subsystem == null)
0: 				continue;
1: 			result.add(subsystem);
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 	void addedParent(AriesSubsystem subsystem, boolean referenceCount) {
0: 					.manifest(getDeploymentManifest()).parent(subsystem, referenceCount).build());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:777b216
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.subsystem.core.internal;
1: 
1: import java.io.File;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.net.URISyntaxException;
1: import java.security.AccessController;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Locale;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: 
1: import org.apache.aries.subsystem.core.archive.DeployedContentHeader;
1: import org.apache.aries.subsystem.core.archive.DeploymentManifest;
1: import org.apache.aries.subsystem.core.archive.Header;
1: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
1: import org.apache.aries.util.filesystem.FileSystem;
1: import org.apache.aries.util.filesystem.IDirectory;
1: import org.apache.aries.util.io.IOUtils;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.Version;
0: import org.osgi.framework.namespace.IdentityNamespace;
1: import org.osgi.resource.Capability;
1: import org.osgi.resource.Requirement;
1: import org.osgi.resource.Resource;
1: import org.osgi.service.resolver.ResolutionException;
1: import org.osgi.service.subsystem.Subsystem;
1: import org.osgi.service.subsystem.SubsystemConstants;
1: import org.osgi.service.subsystem.SubsystemException;
1: 
0: public class AriesSubsystem implements Resource, Subsystem {
0: 	public static final String ROOT_REGION = "org.eclipse.equinox.region.kernel";
1: 	public static final String ROOT_SYMBOLIC_NAME = "org.osgi.service.subsystem.root";
1: 	public static final Version ROOT_VERSION = Version.parseVersion("1.0.0");
1: 	public static final String ROOT_LOCATION = "subsystem://?"
1: 			+ SubsystemConstants.SUBSYSTEM_SYMBOLICNAME + '='
1: 			+ ROOT_SYMBOLIC_NAME + '&' + SubsystemConstants.SUBSYSTEM_VERSION
1: 			+ '=' + ROOT_VERSION;
1: 	
0: 	private DeploymentManifest deploymentManifest;
1: 	private SubsystemResource resource;
1: 	private SubsystemManifest subsystemManifest;
1: 	
1: 	private final IDirectory directory;
1: 	
0: 	public AriesSubsystem(SubsystemResource resource) throws URISyntaxException, IOException, BundleException, InvalidSyntaxException {
1: 		this.resource = resource;
0: //		long id;
0: //		if (resource.getParents().isEmpty())
0: //			id = 0;
0: //		else
0: //			id = SubsystemIdentifier.getNextId();
0: 		File file = new File(Activator.getInstance().getBundleContext().getDataFile(""), Long.toString(resource.getId()));
1: 		file.mkdirs();
1: 		directory = FileSystem.getFSRoot(file);
1: 		setSubsystemManifest(resource.getSubsystemManifest());
1: 		SubsystemManifestValidator.validate(this, getSubsystemManifest());
1: 		setDeploymentManifest(new DeploymentManifest.Builder()
1: 				.manifest(resource.getSubsystemManifest())
0: 				.manifest(resource.getDeploymentManifest())
1: 				.location(resource.getLocation())
1: 				.autostart(false)
1: 				.id(resource.getId())
1: 				.lastId(SubsystemIdentifier.getLastId())
1: 				.region(resource.getRegion().getName())
1: 				.state(State.INSTALLING)
1: 				.build());
1: 	}
1: 	
0: 	public AriesSubsystem(File file) throws IOException, URISyntaxException, ResolutionException {
1: 		this(FileSystem.getFSRoot(file));
1: 	}
1: 	
0: 	public AriesSubsystem(IDirectory directory) throws IOException, URISyntaxException, ResolutionException {
1: 		this.directory = directory;
0: 		setDeploymentManifest(new DeploymentManifest.Builder().manifest(getDeploymentManifest()).state(State.INSTALLING).build());
1: 	}
1: 	
1: 	/* BEGIN Resource interface methods. */
1: 	
1: 	@Override
1: 	public List<Capability> getCapabilities(String namespace) {
0: 		if (IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace)) {
0: 			Capability capability = new OsgiIdentityCapability(this, getSymbolicName(), getVersion(), getType());
0: 			return Collections.singletonList(capability);
1: 		}
1: 		SubsystemManifest manifest = getSubsystemManifest();
0: 		if (namespace == null) {
0: 			Capability capability = new OsgiIdentityCapability(this, getSymbolicName(), getVersion(), getType());
1: 			List<Capability> result = manifest.toCapabilities(this);
0: 			result.add(capability);
1: 			return result;
1: 		}
1: 		List<Capability> result = manifest.toCapabilities(this);
0: 		for (Iterator<Capability> i = result.iterator(); i.hasNext();)
0: 			if (!i.next().getNamespace().equals(namespace))
1: 				i.remove();
1: 		return result;
1: 	}
1: 
1: 	@Override
1: 	public List<Requirement> getRequirements(String namespace) {
1: 		SubsystemManifest manifest = getSubsystemManifest();
0: 		if (namespace == null)
0: 			return manifest.toRequirements(this);
1: 		List<Requirement> result = manifest.toRequirements(this);
0: 		for (Iterator<Requirement> i = result.iterator(); i.hasNext();)
0: 			if (!i.next().getNamespace().equals(namespace))
1: 				i.remove();
1: 		return result;
1: 	}
1: 	
1: 	/* END Resource interface methods. */
1: 	
1: 	/* BEGIN Subsystem interface methods. */
1: 
1: 	@Override
1: 	public BundleContext getBundleContext() {
1: 		SecurityManager.checkContextPermission(this);
1: 		return AccessController.doPrivileged(new GetBundleContextAction(this));
1: 	}
1: 
1: 	@Override
1: 	public Collection<Subsystem> getChildren() {
1: 		return Activator.getInstance().getSubsystems().getChildren(this);
1: 	}
1: 
1: 	@Override
1: 	public Map<String, String> getSubsystemHeaders(Locale locale) {
1: 		SecurityManager.checkMetadataPermission(this);
0: 		return AccessController.doPrivileged(new GetSubsystemHeadersAction(this));
1: 	}
1: 
1: 	@Override
1: 	public String getLocation() {
1: 		return getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_LOCATION);
1: 	}
1: 
1: 	@Override
1: 	public Collection<Subsystem> getParents() {
0: 		Header<?> header = deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_PARENTS);
1: 		if (header == null)
1: 			return Collections.emptyList();
0: 		String[] parents = header.getValue().split(",");
0: 		Collection<Subsystem> result = new ArrayList<Subsystem>(parents.length);
0: 		for (String parent : parents)
0: 			result.add(Activator.getInstance().getSubsystems().getSubsystemById(Long.valueOf(parent)));
1: 		return result;
1: 	}
1: 
1: 	@Override
1: 	public Collection<Resource> getConstituents() {
1: 		return Activator.getInstance().getSubsystems().getConstituents(this);
1: 	}
1: 
1: 	@Override
1: 	public State getState() {
1: 		return State.valueOf(getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_STATE));
1: 	}
1: 
1: 	@Override
1: 	public long getSubsystemId() {
1: 		return Long.parseLong(getDeploymentManifestHeaderValue(DeploymentManifest.ARIESSUBSYSTEM_ID));
1: 	}
1: 
1: 	@Override
1: 	public String getSymbolicName() {
1: 		return getSubsystemManifest().getSubsystemSymbolicNameHeader().getSymbolicName();
1: 	}
1: 
1: 	@Override
1: 	public String getType() {
1: 		return getSubsystemManifest().getSubsystemTypeHeader().getType();
1: 	}
1: 
1: 	@Override
1: 	public Version getVersion() {
1: 		return getSubsystemManifest().getSubsystemVersionHeader().getVersion();
1: 	}
1: 
1: 	@Override
0: 	public Subsystem install(String location) {
0: 		return install(location, null);
1: 	}
1: 
1: 	@Override
0: 	public Subsystem install(String location, InputStream content) {
1: 		try {
0: 			return AccessController.doPrivileged(new InstallAction(location, content, this, AccessController.getContext()));
1: 		}
1: 		finally {
1: 			// This method must guarantee the content input stream was closed.
1: 			IOUtils.close(content);
1: 		}
1: 	}
1: 
1: 	@Override
1: 	public void start() {
1: 		SecurityManager.checkExecutePermission(this);
0: 		AccessController.doPrivileged(new StartAction(this));
1: 	}
1: 
1: 	@Override
1: 	public void stop() {
1: 		SecurityManager.checkExecutePermission(this);
0: 		AccessController.doPrivileged(new StopAction(this));
1: 	}
1: 
1: 	@Override
1: 	public void uninstall() {
1: 		SecurityManager.checkLifecyclePermission(this);
0: 		AccessController.doPrivileged(new UninstallAction(this));
1: 	}
1: 	
1: 	/* END Subsystem interface methods. */
1: 	
0: 	void addedContent(Resource resource) {
1: 		try {
1: 			setDeploymentManifest(new DeploymentManifest.Builder()
0: 					.manifest(getDeploymentManifest()).content(resource).build());
1: 		} catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 	
0: 	void addedParent(AriesSubsystem subsystem) {
1: 		try {
1: 			setDeploymentManifest(new DeploymentManifest.Builder()
0: 					.manifest(getDeploymentManifest()).parent(subsystem.getSubsystemId()).build());
1: 		} catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 	
1: 	synchronized DeploymentManifest getDeploymentManifest() {
1: 		if (deploymentManifest == null) {
1: 			try {
1: 				deploymentManifest = new DeploymentManifest(directory.getFile("OSGI-INF/DEPLOYMENT.MF").open());
1: 			}
1: 			catch (Throwable t) {
1: 				throw new SubsystemException(t);
1: 			}
1: 		}
1: 		return deploymentManifest;
1: 	}
1: 	
1: 	File getDirectory() {
1: 		try {
1: 			return new File(directory.toURL().toURI());
1: 		}
0: 		catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 	
0: 	org.eclipse.equinox.region.Region getRegion() {
1: 		DeploymentManifest manifest = getDeploymentManifest();
1: 		Header<?> header = manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_REGION);
0: 		return Activator.getInstance().getRegionDigraph().getRegion(header.getValue());
1: 	}
1: 	
1: 	synchronized SubsystemResource getResource() {
1: 		if (resource == null) {
1: 			try {
0: 				resource = new SubsystemResource(directory);
1: 			}
0: 			catch (Exception e) {
1: 				throw new SubsystemException(e);
1: 			}
1: 		}
1: 		return resource;
1: 	}
1: 	
1: 	synchronized SubsystemManifest getSubsystemManifest() {
1: 		if (subsystemManifest == null) {
1: 			try {
1: 				subsystemManifest = new SubsystemManifest(directory.getFile("OSGI-INF/SUBSYSTEM.MF").open());
1: 			}
1: 			catch (Throwable t) {
1: 				throw new SubsystemException(t);
1: 			}
1: 		}
1: 		return subsystemManifest;
1: 	}
1: 	
1: 	boolean isApplication() {
1: 		return getSubsystemManifest().getSubsystemTypeHeader().isApplication();
1: 	}
1: 	
1: 	boolean isAutostart() {
1: 		DeploymentManifest manifest = getDeploymentManifest();
1: 		Header<?> header = manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_AUTOSTART);
1: 		return Boolean.valueOf(header.getValue());
1: 	}
1: 	
1: 	boolean isComposite() {
1: 		return getSubsystemManifest().getSubsystemTypeHeader().isComposite();
1: 	}
1: 	
1: 	boolean isFeature() {
1: 		return getSubsystemManifest().getSubsystemTypeHeader().isFeature();
1: 	}
1: 	
1: 	boolean isRoot() {
1: 		return ROOT_LOCATION.equals(getLocation());
1: 	}
1: 	
1: 	boolean isScoped() {
1: 		return isApplication() || isComposite();
1: 	}
1: 	
1: 	void removedContent(Resource resource) {
1: 		DeploymentManifest manifest = getDeploymentManifest();
1: 		DeployedContentHeader header = manifest.getDeployedContentHeader();
1: 		if (header == null)
1: 			return;
1: 		DeployedContentHeader.Clause clause = header.getClause(resource);
1: 		if (clause == null)
1: 			return;
1: 		Collection<DeployedContentHeader.Clause> clauses = new ArrayList<DeployedContentHeader.Clause>(header.getClauses());
1: 		for (Iterator<DeployedContentHeader.Clause> i = clauses.iterator(); i.hasNext();)
0: 			if (clause.equals(i.next())) {
1: 				i.remove();
0: 				break;
1: 			}
1: 		DeploymentManifest.Builder builder = new DeploymentManifest.Builder();
1: 		for (Entry<String, Header<?>> entry : manifest.getHeaders().entrySet()) {
1: 			if (DeployedContentHeader.NAME.equals(entry.getKey()))
0: 				continue;
1: 			builder.header(entry.getValue());
1: 		}
1: 		if (!clauses.isEmpty())
1: 			builder.header(new DeployedContentHeader(clauses));
1: 		try {
1: 			setDeploymentManifest(builder.build());
1: 		} catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 	
1: 	void setAutostart(boolean value) {
1: 		try {
1: 			setDeploymentManifest(new DeploymentManifest.Builder()
0: 					.manifest(getDeploymentManifest()).autostart(value).build());
1: 		} catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 	}
1: 	
0: 	synchronized void setDeploymentManifest(DeploymentManifest value) throws IOException, URISyntaxException {
1: 		File file = new File(getDirectory(), "OSGI-INF");
1: 		if (!file.exists())
1: 			file.mkdirs();
0: 		FileOutputStream fos = new FileOutputStream(new File(file, "DEPLOYMENT.MF"));
1: 		try {
1: 			value.write(fos);
0: 			deploymentManifest = value;
1: 		}
1: 		finally {
1: 			IOUtils.close(fos);
1: 		}
1: 	}
1: 	
1: 	void setState(State value) {
0: 		if (value.equals(getState()))
1: 			return;
1: 		try {
1: 			setDeploymentManifest(new DeploymentManifest.Builder()
0: 					.manifest(getDeploymentManifest()).state(value).build());
1: 		} catch (Exception e) {
1: 			throw new SubsystemException(e);
1: 		}
1: 		Activator.getInstance().getSubsystemServiceRegistrar().update(this);
1: 		synchronized (this) {
1: 			notifyAll();
1: 		}
1: 	}
1: 	
1: 	synchronized void setSubsystemManifest(SubsystemManifest value) throws URISyntaxException, IOException {
1: 		File file = new File(getDirectory(), "OSGI-INF");
1: 		if (!file.exists())
1: 			file.mkdirs();
1: 		FileOutputStream fos = new FileOutputStream(new File(file, "SUBSYSTEM.MF"));
1: 		try {
1: 			value.write(fos);
1: 			subsystemManifest = value;
1: 		}
1: 		finally {
1: 			IOUtils.close(fos);
1: 		}
1: 	}
1: 	
0: //	private org.eclipse.equinox.region.Region createRegion(SubsystemResource resource, long id) throws BundleException {
0: //		if (!isScoped())
0: //			return resource.getParents().iterator().next().getRegion();
0: //		Activator activator = Activator.getInstance();
0: //		RegionDigraph digraph = activator.getRegionDigraph();
0: //		if (resource.getParents().isEmpty())
0: //			return digraph.getRegion(ROOT_REGION);
0: //		String name = resource.getSubsystemManifest()
0: //				.getSubsystemSymbolicNameHeader().getSymbolicName()
0: //				+ ';'
0: //				+ resource.getSubsystemManifest().getSubsystemVersionHeader()
0: //						.getVersion()
0: //				+ ';'
0: //				+ resource.getSubsystemManifest().getSubsystemTypeHeader()
0: //						.getType() + ';' + Long.toString(id);
0: //		org.eclipse.equinox.region.Region region = digraph.getRegion(name);
0: //		// TODO New regions need to be cleaned up if this subsystem fails to
0: //		// install, but there's no access to the coordination here.
0: //		if (region == null)
0: //			return digraph.createRegion(name);
0: //		return region;
0: //	}
1: 	
1: 	private String getDeploymentManifestHeaderValue(String name) {
1: 		DeploymentManifest manifest = getDeploymentManifest();
1: 		if (manifest == null)
1: 			return null;
1: 		Header<?> header = manifest.getHeaders().get(name);
1: 		if (header == null)
1: 			return null;
1: 		return header.getValue();
1: 	}
1: 	
0: //	private Manifest getManifest(String name) {
0: //		try {
0: //			return ManifestProcessor.obtainManifestFromAppDir(directory, name);
0: //		}
0: //		catch (IOException e) {
0: //			throw new SubsystemException(e);
0: //		}
0: //	}
1: }
commit:c3ec212
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private final SubsystemResource resource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	SubsystemArchive getArchive() {
0: 		return archive;
0: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0: 	SubsystemManifest getSubsystemManifest() {
0: 		return resource.getSubsystemManifest();
0: 	}
1: 	
0: 		Coordination coordination = Utils.createCoordination(this);
/////////////////////////////////////////////////////////////////////////
0: 		if (!isRoot()) {
0: 			// TODO Why aren't shared dependencies being installed here?
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	boolean isApplication() {
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().isApplication();
0: 	}
1: 
0: 	boolean isComposite() {
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().isComposite();
0: 	}
1: 
0: 	boolean isFeature() {
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().isFeature();
0: 	}
1: 
0: 	boolean isRoot() {
0: 		return ROOT_LOCATION.equals(getLocation());
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 			Collections.sort(resources, new StartResourceComparator(getSubsystemManifest().getSubsystemContentHeader()));
0: 			Collections.reverse(resources);
/////////////////////////////////////////////////////////////////////////
commit:225bcae
/////////////////////////////////////////////////////////////////////////
0: import java.util.EnumSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.util.io.IOUtils;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.coordinator.CoordinationException;
/////////////////////////////////////////////////////////////////////////
0: 	final SubsystemResource resource;
0: 	boolean autostart;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		id = resource.getId();
0: 		directory = resource.getDirectory();
0: 			archive = new SubsystemArchive(resource);
/////////////////////////////////////////////////////////////////////////
0: 		return Activator.getInstance().getSubsystems().getChildren(this);
0: 	public Collection<Resource> getConstituents() {
0: 		return Activator.getInstance().getSubsystems().getConstituents(this);
/////////////////////////////////////////////////////////////////////////
0: 		return Activator.getInstance().getSubsystems().getParents(this);
/////////////////////////////////////////////////////////////////////////
0: 		try {
0: 			return AccessController.doPrivileged(new InstallAction(location, content, this, AccessController.getContext()));
0: 		}
1: 		finally {
0: 			// This method must guarantee the content input stream was closed.
0: 			IOUtils.close(content);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 				// UNINSTALLING is included here because the transition to
0: 				// UNINSTALLED is guaranteed, so there's no point in waiting.
0: 				if (EnumSet.of(State.UNINSTALLING, State.UNINSTALLED).contains(state))
0: 				else if (EnumSet.of(State.INSTALLING, State.RESOLVING, State.STARTING, State.STOPPING).contains(state)) {
0: 				else if (state.equals(State.ACTIVE)) {
0: 				ResourceUninstaller.newInstance(AriesSubsystem.this).uninstall();
/////////////////////////////////////////////////////////////////////////
0: 	File getDirectory() {
0: 		return directory;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 			// TODO Begin proof of concept.
0: 			// This is a proof of concept for initializing the relationships between the root subsystem and bundles
0: 			// that already existed in its region. Not sure this will be the final resting place. Plus, there are issues
0: 			// since this does not take into account the possibility of already existing bundles going away or new bundles
0: 			// being installed out of band while this initialization is taking place. Need a bundle event hook for that.
0: 			BundleContext context = Activator.getInstance().getBundleContext();
0: 			for (long id : region.getBundleIds()) {
0: 				BundleRevision br = context.getBundle(id).adapt(BundleRevision.class);
0: 				installResource(br, coordination, false);
0: 			}
0: 			// TODO End proof of concept.
/////////////////////////////////////////////////////////////////////////
0: 	synchronized void install(Coordination coordination, AriesSubsystem parent) throws Exception {
0: 		if (!State.INSTALLING.equals(getState()))
0: 			return;
0: 		Activator.getInstance().getSubsystems().addSubsystem(this);
0: 		coordination.addParticipant(new Participant() {
1: 			@Override
0: 			public void ended(Coordination arg0) throws Exception {
0: 				// Nothing
0: 			}
0: 	
1: 			@Override
0: 			public void failed(Coordination arg0) throws Exception {
0: 				Activator.getInstance().getSubsystems().removeSubsystem(AriesSubsystem.this);
0: 			}
0: 		});
0: 		if (!isFeature())
0: 			RegionContextBundleHelper.installRegionContextBundle(this);
0: 		Activator.getInstance().getSubsystemServiceRegistrar().register(this, parent);
0: 		// Set up the sharing policy before installing the resources so that the
0: 		// environment can filter out capabilities from dependencies being
0: 		// provisioned to regions that are out of scope. This doesn't hurt
0: 		// anything since the resources are disabled from resolving anyway.
0: 		setImportIsolationPolicy();
0: 		// The subsystem resource will be null for the root subsystem.
0: 		if (this.resource != null) {
0: 			Comparator<Resource> comparator = new InstallResourceComparator();
0: 			// Install dependencies first...
0: 			List<Resource> dependencies = new ArrayList<Resource>(resource.getInstallableDependencies());
0: 			Collections.sort(dependencies, comparator);
0: 			for (Resource resource : dependencies)
0: 				installResource(resource, coordination, true);
0: 			// ...followed by content.
0: 			List<Resource> content = new ArrayList<Resource>(resource.getInstallableContent());
0: 			Collections.sort(content, comparator);
0: 			for (Resource resource : content)
0: 				installResource(resource, coordination, false);
0: 			// Simulate installation of shared content so that necessary relationships are established.
0: 			for (Resource resource : this.resource.getSharedContent())
0: 				installResource(resource, coordination, false);
0: 		}
0: 		setState(State.INSTALLED);
0: 		if (autostart)
0: 			start();
0: 	}
0: 
0: 	void installResource(Resource resource) {
0: 		Coordination coordination = Utils.createCoordination(this);
0: 		try {
0: 			installResource(resource, coordination, false);
0: 		}
0: 		catch (Throwable t) {
0: 			coordination.fail(t);
0: 		}
0: 		finally {
0: 			try {
0: 				coordination.end();
0: 			}
0: 			catch (CoordinationException e) {
0: 				Throwable t = e.getCause();
0: 				if (t instanceof SubsystemException)
0: 					throw (SubsystemException)t;
0: 				if (t instanceof SecurityException)
0: 					throw (SecurityException)t;
0: 				throw new SubsystemException(t);
0: 			}
0: 		}
0: 	}
0: 
0: 	void installResource(Resource resource, Coordination coordination, boolean transitive) throws Exception {
0: 		String type = ResourceHelper.getTypeAttribute(resource);
0: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
0: 			new SubsystemResourceInstaller(coordination, resource, this, transitive).install();
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type) ||
0: 				IdentityNamespace.TYPE_FRAGMENT.equals(type))
0: 			new BundleResourceInstaller(coordination, resource, this, transitive).install();
0: 		else
0: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 	}
0: 
0: 	boolean isScoped() {
0: 		return isApplication() || isComposite();
0: 	}
0: 
0: 	void resolve() {
0: 		if (state != State.INSTALLED)
0: 			return;
0: 		setState(State.RESOLVING);
0: 		try {
0: 			for (Subsystem child : Activator.getInstance().getSubsystems().getChildren(this))
0: 				((AriesSubsystem)child).resolve();
0: 			// TODO I think this is insufficient. Do we need both
0: 			// pre-install and post-install environments for the Resolver?
0: 			Collection<Bundle> bundles = getBundles();
0: 			if (!Activator.getInstance().getBundleContext().getBundle(0)
0: 					.adapt(FrameworkWiring.class).resolveBundles(bundles)) {
0: 				LOGGER.error(
0: 						"Unable to resolve bundles for subsystem/version/id {}/{}/{}: {}",
0: 						new Object[] { getSymbolicName(), getVersion(),
0: 								getSubsystemId(), bundles });
0: 				// TODO SubsystemException?
0: 				throw new SubsystemException("Framework could not resolve the bundles");
0: 			}
0: 			setExportIsolationPolicy();
0: 			// TODO Could avoid calling setState (and notifyAll) here and
0: 			// avoid the need for a lock.
0: 			setState(State.RESOLVED);
0: 		}
0: 		catch (Throwable t) {
0: 			setState(State.INSTALLED);
0: 			if (t instanceof SubsystemException)
0: 				throw (SubsystemException)t;
0: 			throw new SubsystemException(t);
0: 		}
0: 	}
0: 
0: 	void startResource(Resource resource, Coordination coordination) throws BundleException, IOException {
0: 		String type = ResourceHelper.getTypeAttribute(resource);
0: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
0: 			startSubsystemResource(resource, coordination);
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type))
0: 			startBundleResource(resource, coordination);
0: 		else if (IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
0: 			// Fragments are not started.
0: 		}
0: 		else
0: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0: 			List<Resource> resources = new ArrayList<Resource>(Activator.getInstance().getSubsystems().getResourcesReferencedBy(this));
/////////////////////////////////////////////////////////////////////////
0: 	synchronized void waitForStateChange() {
0: 		try {
0: 			wait();
0: 		}
0: 		catch (InterruptedException e) {
0: 			throw new SubsystemException(e);
0: 		}
0: 	}
0: 	
0: 		return Activator.getInstance().getSubsystems().getConstituents(this).contains(resource);
0: 		Collection<Resource> constituents = Activator.getInstance().getSubsystems().getConstituents(this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:58ac4b7
/////////////////////////////////////////////////////////////////////////
0: 			if (isUnscoped())
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private DeploymentManifest getDeploymentManifest() {
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isUnscoped() {
0: 		return !isScoped();
0: 	}
0: 	
commit:dc5d52f
/////////////////////////////////////////////////////////////////////////
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	static final Map<String, AriesSubsystem> locationToSubsystem = Collections.synchronizedMap(new HashMap<String, AriesSubsystem>());
0: 	static final ResourceReferences resourceReferences = new ResourceReferences();
/////////////////////////////////////////////////////////////////////////
0: 	final SubsystemResource resource;
0: 	boolean autostart;
/////////////////////////////////////////////////////////////////////////
0: 	public AriesSubsystem(SubsystemResource resource, AriesSubsystem parent) {
/////////////////////////////////////////////////////////////////////////
0: 			throw new SubsystemException("Unable to make directory for " + directory.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
0: 		SecurityManager.checkContextPermission(this);
0: 		return AccessController.doPrivileged(new GetBundleContextAction(this));
/////////////////////////////////////////////////////////////////////////
1: 		SecurityManager.checkMetadataPermission(this);
/////////////////////////////////////////////////////////////////////////
0: 		SecurityManager.checkMetadataPermission(this);
0: 		return AccessController.doPrivileged(new GetSubsystemHeadersAction(this));
/////////////////////////////////////////////////////////////////////////
0: 	// TODO Remove this synchronization when the 'location lock' has been implemented.
0: 	public synchronized Subsystem install(String location, InputStream content) throws SubsystemException {
0: 		return AccessController.doPrivileged(new InstallAction(location, content, this, AccessController.getContext()));
/////////////////////////////////////////////////////////////////////////
0: 		SecurityManager.checkExecutePermission(this);
0: 		AccessController.doPrivileged(new StartAction(this));
/////////////////////////////////////////////////////////////////////////
0: 		SecurityManager.checkExecutePermission(this);
0: 		AccessController.doPrivileged(new PrivilegedAction<Object>() {
1: 			@Override
0: 			public Object run() {
0: 				// The root subsystem may not be stopped.
0: 				checkRoot();
0: 				autostart = false;
0: 				stop0();
0: 				return null;
0: 			}
0: 			
0: 		});
/////////////////////////////////////////////////////////////////////////
0: 		SecurityManager.checkLifecyclePermission(this);
0: 		AccessController.doPrivileged(new PrivilegedAction<Object>() {
0: 			@Override
0: 			public Object run() {
0: 				// The root subsystem may not be uninstalled.
0: 				checkRoot();
0: 				State state = getState();
0: 				if (state == State.UNINSTALLING || state == State.UNINSTALLED || state == State.INSTALL_FAILED) {
0: 					return null;
0: 				}
0: 				else if (state == State.INSTALLING || state == State.RESOLVING || state == State.STARTING || state == State.STOPPING) {
0: 					waitForStateChange();
0: 					uninstall();
0: 				}
0: 				else if (getState() == State.ACTIVE) {
0: 					stop();
0: 					uninstall();
0: 				}
0: 				uninstall(true);
0: 				return null;
0: 			}
0: 		});
/////////////////////////////////////////////////////////////////////////
0: 	AriesSubsystem findScopedSubsystemInRegion() {
0: 		AriesSubsystem result = this;
0: 		while (!result.isScoped())
0: 			result = (AriesSubsystem)result.getParents().iterator().next();
0: 		return result;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	synchronized void waitForStateChange() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	void installResource(Resource resource, Coordination coordination, boolean transitive) throws Exception {
/////////////////////////////////////////////////////////////////////////
0: 			InputStream content = ((RepositoryContent)resource).getContent();
0: 			return AccessController.doPrivileged(new InstallAction(location, content, this, null, coordination, true));
/////////////////////////////////////////////////////////////////////////
0: 	void resolve() {
/////////////////////////////////////////////////////////////////////////
0: 	void startResource(Resource resource, Coordination coordination) throws BundleException, IOException {
/////////////////////////////////////////////////////////////////////////
0: 	synchronized void subsystemInstalled(AriesSubsystem subsystem) {
0: 	synchronized void subsystemInstalling(AriesSubsystem subsystem) {
commit:2ac6b1a
/////////////////////////////////////////////////////////////////////////
0: 		if (state == State.UNINSTALLING || state == State.UNINSTALLED)
0: 		if (state == State.STARTING || state == State.ACTIVE)
/////////////////////////////////////////////////////////////////////////
0: 			List<Resource> resources = new ArrayList<Resource>(resourceReferences.getResources(this));
0: 			if (resource != null)
0: 				Collections.sort(resources, new StartResourceComparator(resource.getSubsystemManifest().getSubsystemContentHeader()));
0: 			for (Resource resource : resources)
/////////////////////////////////////////////////////////////////////////
0: //		for (Subsystem subsystem : subsystemGraph.getChildren(this)) {
0: //			try {
0: //				stopSubsystemResource((AriesSubsystem)subsystem);
0: //			}
0: //			catch (Exception e) {
0: //				LOGGER.error("An error occurred while stopping resource "
0: //						+ subsystem + " of subsystem " + this, e);
0: //			}
0: //		}
0: 			List<Resource> resources = new ArrayList<Resource>(resourceReferences.getResources(this));
0: 			if (resource != null) {
0: 				Collections.sort(resources, new StartResourceComparator(resource.getSubsystemManifest().getSubsystemContentHeader()));
0: 				Collections.reverse(resources);
0: 			}
0: 			for (Resource resource : resources) {
commit:67ef08f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private final SubsystemResource resource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		resource = null;
0: 		this.resource = resource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		resource = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// The subsystem resource will be null for the root subsystem.
0: 		if (this.resource != null) {
0: 			Comparator<Resource> comparator = new InstallResourceComparator();
0: 			// Install dependencies first...
0: 			List<Resource> dependencies = new ArrayList<Resource>(resource.getInstallableDependencies());
0: 			Collections.sort(dependencies, comparator);
0: 			for (Resource resource : dependencies)
0: 				installResource(resource, coordination, true);
0: 			// ...followed by content.
0: 			List<Resource> content = new ArrayList<Resource>(resource.getInstallableContent());
0: 			Collections.sort(content, comparator);
0: 			for (Resource resource : content)
0: 				installResource(resource, coordination, false);
0: 			// Simulate installation of shared content so that necessary relationships are established.
0: 			for (Resource resource : this.resource.getSharedContent())
0: 				installResource(resource, coordination, false);
/////////////////////////////////////////////////////////////////////////
0: 			ssr = new SubsystemResource(location, content, this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (resource instanceof RepositoryContent) {
/////////////////////////////////////////////////////////////////////////
0: 		else if (resource instanceof RawSubsystemResource) {
0: 			subsystem = new AriesSubsystem(new SubsystemResource((RawSubsystemResource)resource, this), this);
commit:3e4b2d5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		Coordination coordination = Activator.getInstance().getCoordinator().create(getSymbolicName() + '-' + getSubsystemId(), 0);
/////////////////////////////////////////////////////////////////////////
0: 				.getCoordinator()
/////////////////////////////////////////////////////////////////////////
0: 				.getCoordinator()
/////////////////////////////////////////////////////////////////////////
0: 		RegionDigraph digraph = activator.getRegionDigraph();
commit:23d86e6
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.resolver.ResolutionException;
/////////////////////////////////////////////////////////////////////////
0: 				new SubsystemResolveContext(this, Collections.EMPTY_LIST),
/////////////////////////////////////////////////////////////////////////
0: 		resolve();
/////////////////////////////////////////////////////////////////////////
0: 			DeploymentManifest manifest = new DeploymentManifest(
0: 					archive.getDeploymentManifest(),
0: 					null,
0: 					null,
0: 					autostart,
0: 					id,
0: 					SubsystemIdentifier.getLastId(),
0: 					location,
0: 					false,
0: 					false);
0: 		catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0: 	private DeploymentManifest getDeploymentManifest() throws IOException, URISyntaxException, ResolutionException {
0: 					new SubsystemResolveContext(this, Collections.EMPTY_LIST),
/////////////////////////////////////////////////////////////////////////
0: 		SubsystemResolveContext environment = new SubsystemResolveContext(this, Collections.EMPTY_LIST);
/////////////////////////////////////////////////////////////////////////
0: 		if (state != State.INSTALLED)
0: 			return;
/////////////////////////////////////////////////////////////////////////
0: 	private void setExportIsolationPolicy() throws InvalidSyntaxException, IOException, BundleException, URISyntaxException, ResolutionException {
commit:f1b1384
/////////////////////////////////////////////////////////////////////////
0: 		if (archive.getDeploymentManifest() == null)
/////////////////////////////////////////////////////////////////////////
0: 		if (!State.INSTALLING.equals(getState()))
0: 			return;
commit:52b079f
/////////////////////////////////////////////////////////////////////////
0: 		if (EnumSet.of(State.INSTALL_FAILED, State.UNINSTALLED).contains(
0: 				getState()))
0: 		AriesSubsystem subsystem = findScopedSubsystemInRegion();
0: 		return region.getBundle(
0: 				RegionContextBundleHelper.SYMBOLICNAME_PREFIX
0: 						+ subsystem.getSubsystemId(),
0: 				RegionContextBundleHelper.VERSION).getBundleContext();
/////////////////////////////////////////////////////////////////////////
0: 			install(coordination, null);
/////////////////////////////////////////////////////////////////////////
0: 	private void addSubsystemServiceImportToSharingPolicy(
0: 			RegionFilterBuilder builder) throws InvalidSyntaxException {
0: 		builder.allow(
0: 				RegionFilter.VISIBLE_SERVICE_NAMESPACE,
0: 				new StringBuilder("(&(")
0: 						.append(org.osgi.framework.Constants.OBJECTCLASS)
0: 						.append('=').append(Subsystem.class.getName())
0: 						.append(")(")
0: 						.append(Constants.SubsystemServicePropertyRegions)
0: 						.append('=').append(region.getName())
0: 						.append("))").toString());
0: 	}
0: 	
0: 	private void addSubsystemServiceImportToSharingPolicy(RegionFilterBuilder builder, Region to)
0: 			throws InvalidSyntaxException, BundleException {
0: 		// TODO This check seems brittle. There is apparently no constant for
0: 		// the root region's name in Digraph.
0: 		if (to.getName().equals("org.eclipse.equinox.region.kernel"))
0: 			addSubsystemServiceImportToSharingPolicy(builder);
0: 		else {
0: 			to = findRootRegion();
0: 			builder = to.getRegionDigraph().createRegionFilterBuilder();
0: 			addSubsystemServiceImportToSharingPolicy(builder);
0: 			RegionFilter regionFilter = builder.build();
0: 			region.connectRegion(to, regionFilter);
0: 		}
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	private Region findRootRegion() {
0: 		return findRootSubsystem().region;
0: 	}
0: 	
0: 	private AriesSubsystem findRootSubsystem() {
0: 		AriesSubsystem root = this;
0: 		while (!root.isRoot())
0: 			root = ((AriesSubsystem)root.getParents().iterator().next());
0: 		return root;
0: 	}
0: 	
0: 	private AriesSubsystem findScopedSubsystemInRegion() {
0: 		AriesSubsystem result = this;
0: 		while (!result.isScoped())
0: 			result = (AriesSubsystem)result.getParents().iterator().next();
0: 		return result;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	private synchronized void install(Coordination coordination, AriesSubsystem parent) throws Exception {
0: 		Activator.getInstance().getSubsystemServiceRegistrar().register(this, parent);
/////////////////////////////////////////////////////////////////////////
0: 				subsystemInstalling(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 				subsystemInstalling(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 		subsystemInstalling(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 		subsystem.install(coordination, this);
0: 		subsystemInstalled(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isScoped() {
0: 		return isApplication() || isComposite();
0: 	}
0: 	
0: 			for (Subsystem child : subsystemGraph.getChildren(this))
0: 				((AriesSubsystem)child).resolve();
/////////////////////////////////////////////////////////////////////////
0: 		if (isRoot() || isFeature())
0: 		Region to = ((AriesSubsystem)getParents().iterator().next()).region;
0: 		addSubsystemServiceImportToSharingPolicy(builder, to);
/////////////////////////////////////////////////////////////////////////
0: 		Activator.getInstance().getSubsystemServiceRegistrar().addRegion(subsystem, region);
0: 	}
0: 	
0: 	private synchronized void subsystemInstalling(AriesSubsystem subsystem) {
/////////////////////////////////////////////////////////////////////////
0: 		Activator.getInstance().getSubsystemServiceRegistrar().removeRegion(subsystem, region);
/////////////////////////////////////////////////////////////////////////
0: 			setState(State.INSTALLED);
0: 		setState(State.UNINSTALLING);
/////////////////////////////////////////////////////////////////////////
0: 		setState(State.UNINSTALLED);
commit:35094c6
/////////////////////////////////////////////////////////////////////////
0: import java.net.URISyntaxException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.resource.tmp.SubsystemResource;
/////////////////////////////////////////////////////////////////////////
0: //	private final SubsystemEnvironment environment;
/////////////////////////////////////////////////////////////////////////
0: 			subsystemManifest = new SubsystemManifest.Builder()
0: 					.symbolicName(uri.getSymbolicName())
/////////////////////////////////////////////////////////////////////////
0: 			subsystemManifest = new SubsystemManifest.Builder()
0: 					.symbolicName(getSymbolicName())
0: //		environment = new SubsystemEnvironment(this);
0: //				environment,
0: 				new SubsystemEnvironment(this),
/////////////////////////////////////////////////////////////////////////
0: //			environment = new SubsystemEnvironment(this);
/////////////////////////////////////////////////////////////////////////
0: 	public AriesSubsystem(SubsystemResource resource, AriesSubsystem parent) throws Exception {
0: 		subsystemGraph = parent.subsystemGraph;
0: 		this.location = resource.getLocation();
0: 		id = SubsystemIdentifier.getNextId();
0: 		String directoryName = "subsystem" + id;
0: //		String fileName = directoryName + ".esa";
0: //		File zipFile = new File(parent.directory, fileName);
0: 		directory = new File(Activator.getInstance().getBundleContext().getDataFile(""), directoryName);
0: 		if (!directory.mkdir())
0: 			throw new IOException("Unable to make directory for " + directory.getCanonicalPath());
0: 		try {
0: //			copyContent(resource.getContent(), zipFile);
0: //			unzipContent(zipFile, directory);
0: 			archive = new SubsystemArchive(resource, directory);
0: 			archive.setSubsystemManifest(resource.getSubsystemManifest());
0: 			if (resource.getDeploymentManifest() != null)
0: 				archive.setDeploymentManifest(resource.getDeploymentManifest());
0: 			SubsystemManifestValidator.validate(this, archive.getSubsystemManifest());
0: 			// Unscoped subsystems don't get their own region. They share the region with their scoped parent.
0: 			if (isFeature())
0: 				region = parent.region;
0: 			else
0: 				region = createRegion(getSymbolicName() + ';' + getVersion() + ';' + getType() + ';' + getSubsystemId());
0: 		}
0: 		catch (Throwable t) {
0: //			deleteFile(directory);
0: //			deleteFile(zipFile);
0: 			if (t instanceof SubsystemException)
0: 				throw (SubsystemException)t;
0: 			throw new SubsystemException(t);
0: 		}
0: 	}
0: 	
0: 		subsystemGraph = parent.subsystemGraph;
/////////////////////////////////////////////////////////////////////////
0: //		environment = new SubsystemEnvironment(this);
/////////////////////////////////////////////////////////////////////////
0: 	private DeploymentManifest getDeploymentManifest() throws IOException, URISyntaxException {
0: //		if (archive.getDeploymentManifest() == null) {
0: 					archive.getDeploymentManifest(),
0: //					environment,
0: 					new SubsystemEnvironment(this),
0: //		}
/////////////////////////////////////////////////////////////////////////
0: 		// Set up the sharing policy before installing the resources so that the
0: 		// environment can filter out capabilities from dependencies being
0: 		// provisioned to regions that are out of scope. This doesn't hurt
0: 		// anything since the resources are disabled from resolving anyway.
0: 		setImportIsolationPolicy();
0: 		SubsystemEnvironment environment = new SubsystemEnvironment(this);
/////////////////////////////////////////////////////////////////////////
0: 		// Install the content resources.
0: 		for (Resource resource : contentResources) {
0: 			installResource(resource, coordination, false);
0: 		}
0: 		SubsystemResource ssr = null;
0: 			ssr = SubsystemResource.newInstance(location, content);
0: 				if (!(subsystem.getSymbolicName().equals(ssr.getSubsystemManifest().getSubsystemSymbolicNameHeader().getSymbolicName())
0: 						&& subsystem.getVersion().equals(ssr.getSubsystemManifest().getSubsystemVersionHeader().getVersion())
0: 						&& subsystem.getType().equals(ssr.getSubsystemManifest().getSubsystemTypeHeader().getType())))
0: 				subsystemInstalled(subsystem);
0: 			subsystem = (AriesSubsystem)region.find(
0: 					ssr.getSubsystemManifest().getSubsystemSymbolicNameHeader().getSymbolicName(), 
0: 					ssr.getSubsystemManifest().getSubsystemVersionHeader().getVersion());
0: 				if (!subsystem.getType().equals(ssr.getSubsystemManifest().getSubsystemTypeHeader().getType()))
0: 				subsystemInstalled(subsystem);
0: 			subsystem = new AriesSubsystem(ssr, this);
/////////////////////////////////////////////////////////////////////////
0: //			if (ssr != null)
0: //				ssr.close();
/////////////////////////////////////////////////////////////////////////
0: 				// not actually occur here, and the event hook is not called.
/////////////////////////////////////////////////////////////////////////
0: 		else if (resource instanceof SubsystemResource) {
0: 			subsystem = new AriesSubsystem((SubsystemResource)resource, this);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 	private void setExportIsolationPolicy() throws InvalidSyntaxException, IOException, BundleException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 	private void setImportIsolationPolicy() throws BundleException, IOException, InvalidSyntaxException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 			Header<?> header = archive.getSubsystemManifest().getImportPackageHeader();
0: 			header = archive.getSubsystemManifest().getRequireCapabilityHeader();
0: 			header = archive.getSubsystemManifest().getSubsystemImportServiceHeader();
0: 			header = archive.getSubsystemManifest().getRequireBundleHeader();
/////////////////////////////////////////////////////////////////////////
0: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, ImportPackageHeader header) throws InvalidSyntaxException {
0: 			ImportPackageRequirement requirement = new ImportPackageRequirement(clause, this);
/////////////////////////////////////////////////////////////////////////
0: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, RequireBundleHeader header) throws InvalidSyntaxException {
0: 			RequireBundleRequirement requirement = new RequireBundleRequirement(clause, this);
/////////////////////////////////////////////////////////////////////////
0: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, RequireCapabilityHeader header) throws InvalidSyntaxException {
0: 			RequireCapabilityRequirement requirement = new RequireCapabilityRequirement(clause, this);
/////////////////////////////////////////////////////////////////////////
0: 	private void setImportIsolationPolicy(RegionFilterBuilder builder, SubsystemImportServiceHeader header) throws InvalidSyntaxException {
0: 			SubsystemImportServiceRequirement requirement = new SubsystemImportServiceRequirement(clause, this);
commit:f77cfb9
/////////////////////////////////////////////////////////////////////////
0: 		} catch (Throwable t) {
0: 			coordination.fail(t);
0: 				Throwable t = e.getCause();
0: 				if (t instanceof SubsystemException)
0: 					throw (SubsystemException)t;
0: 				throw new SubsystemException(t);
/////////////////////////////////////////////////////////////////////////
0: 		}
0: 		catch (Throwable t) {
0: 			if (t instanceof SubsystemException)
0: 				throw (SubsystemException)t;
0: 			throw new SubsystemException(t);
commit:df175a6
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: 	private static final ResourceReferences resourceReferences = new ResourceReferences();
/////////////////////////////////////////////////////////////////////////
0: 			bundleInstalled(br);
/////////////////////////////////////////////////////////////////////////
0: 		if (IdentityNamespace.IDENTITY_NAMESPACE.equals(namespace)) {
0: 			return Collections.singletonList(capability);
0: 		if (namespace == null) {
0: 			Capability capability = new OsgiIdentityCapability(this, getSymbolicName(), getVersion(), getType());
0: 			List<Capability> result = archive.getSubsystemManifest().toCapabilities(this);
0: 			result.add(capability);
0: 			return result;
0: 		}
0: 		List<Capability> result = archive.getSubsystemManifest().toCapabilities(this);
0: 		for (Iterator<Capability> i = result.iterator(); i.hasNext();)
0: 			if (!i.next().getNamespace().equals(namespace))
0: 				i.remove();
0: 		return result;
/////////////////////////////////////////////////////////////////////////
0: 		if (namespace == null)
0: 			return archive.getSubsystemManifest().toRequirements(this);
0: 		List<Requirement> result = archive.getSubsystemManifest().toRequirements(this);
0: 		for (Iterator<Requirement> i = result.iterator(); i.hasNext();)
0: 			if (!i.next().getNamespace().equals(namespace))
0: 				i.remove();
0: 		return result;
/////////////////////////////////////////////////////////////////////////
0: 			// TODO Need to make sure the resources are ordered by start level.
0: 			for (Resource resource : resourceReferences.getResources(this)) {
/////////////////////////////////////////////////////////////////////////
0: 			for (Resource resource : resourceReferences.getResources(this)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			installResource(subsystem, coordination, false);
/////////////////////////////////////////////////////////////////////////
0: 	private Resource installBundleResource(Resource resource,
0: 			Coordination coordination, boolean transitive)
0: 			throws BundleException, IOException {
0: 			revision = (BundleRevision) resource;
0: 			// Transitive runtime resources need no further processing here.
0: 			if (!transitive) {
0: 				// Need to simulate the install process since an install does
0: 				// not
0: 				// actually occur here, and the event hook is not called.
0: 				bundleInstalled(revision);
0: 			}
0: 			return revision;
0: 		InputStream content = ((RepositoryContent) resource).getContent();
0: 		// By default, the resource is provisioned into this subsystem.
0: 		AriesSubsystem provisionTo = this;
0: 		if (transitive) {
0: 			// But transitive dependencies should be provisioned into the
0: 			// first subsystem that accepts dependencies.
0: 			while (provisionTo.archive.getSubsystemManifest()
0: 					.getSubsystemTypeHeader().getProvisionPolicyDirective()
0: 					.isRejectDependencies()) {
0: 				provisionTo = (AriesSubsystem) provisionTo.getParents()
0: 						.iterator().next();
0: 			}
0: 		String location = provisionTo.getSubsystemId() + "@"
0: 				+ provisionTo.getSymbolicName() + "@"
0: 				+ ResourceHelper.getSymbolicNameAttribute(resource);
0: 		ThreadLocalSubsystem.set(provisionTo);
0: 		Bundle bundle = provisionTo.region.installBundle(location, content);
0: 		revision = bundle.adapt(BundleRevision.class);
0: 		// Only need to add a participant when this subsystem is the actual
0: 		// installer of the bundle.
0: 		coordination.addParticipant(new Participant() {
0: 			public void ended(Coordination coordination) throws Exception {
0: 				// noop
0: 			}
0: 
0: 			public void failed(Coordination coordination) throws Exception {
0: 				revision.getBundle().uninstall();
0: 			}
0: 		});
0: 		return revision;
0: 		final Resource installed;
0: 			installed = installSubsystemResource(resource, coordination, transitive);
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type) ||
0: 				IdentityNamespace.TYPE_FRAGMENT.equals(type))
0: 			installed = installBundleResource(resource, coordination, transitive);
0: 		resourceReferences.addReference(this, installed);
0: 		coordination.addParticipant(new Participant() {
0: 			@Override
0: 			public void ended(Coordination coordination) throws Exception {
0: 				// noop
0: 			}
0: 
0: 			@Override
0: 			public void failed(Coordination coordination) throws Exception {
0: 				resourceReferences.removeReference(AriesSubsystem.this, installed);
0: 			}
0: 		});
0: 	private Resource installSubsystemResource(Resource resource, Coordination coordination, boolean transitive) throws Exception {
0: 		if (resource instanceof SubsystemFileResource) {
0: 			return subsystem;
0: 			return subsystem;
0: 		}
0: 		else if (resource instanceof AriesSubsystem) {
0: 			subsystem = (AriesSubsystem)resource;
0: 		}
0: 		else if (resource instanceof SubsystemDirectoryResource) {
0: 			SubsystemDirectoryResource sdr = (SubsystemDirectoryResource)resource;
0: 			subsystem = new AriesSubsystem(sdr.getArchive(), this);
/////////////////////////////////////////////////////////////////////////
0: 		subsystemInstalled(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 				subsystemUninstalled(subsystem);
0: 		return subsystem;
/////////////////////////////////////////////////////////////////////////
0: 	private synchronized void subsystemInstalled(AriesSubsystem subsystem) {
0: 		locationToSubsystem.put(subsystem.getLocation(), subsystem);
0: 		subsystemGraph.add(this, subsystem);
0: 		addResourceToSubsystem(subsystem, this);
0: 		constituents.add(subsystem);
0: 	}
0: 	
0: 	private synchronized void subsystemUninstalled(AriesSubsystem subsystem) {
0: 		constituents.remove(subsystem);
0: 		removeResourceToSubsystem(subsystem, this);
0: 		subsystemGraph.remove(subsystem);
0: 		locationToSubsystem.remove(subsystem.getLocation());
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 		for (Resource resource : resourceReferences.getResources(this)) {
0: 			// Don't uninstall a resource that is still referenced by other subsystems.
0: 			if (resourceReferences.getSubsystems(resource).size() > 1)
0: 				continue;
/////////////////////////////////////////////////////////////////////////
0: 		resourceReferences.removeReference(this, resource);
commit:875a6d6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
/////////////////////////////////////////////////////////////////////////
0: 			// This is the first time the root subsystem has been initialized in
0: 			// this framework or a framework clean start was requested.
0: 			subsystemManifest = new SubsystemManifest.Builder(
0: 					uri.getSymbolicName())
0: 					.version(uri.getVersion())
0: 					.content(archive.getResources())
0: 					.type(SubsystemTypeHeader.TYPE_APPLICATION
0: 							+ ';'
0: 							+ SubsystemTypeHeader.DIRECTIVE_PROVISION_POLICY
0: 							+ ":="
0: 							+ SubsystemTypeHeader.PROVISION_POLICY_ACCEPT_DEPENDENCIES)
0: 					.build();
0: 		else {
0: 			subsystemManifest = new SubsystemManifest.Builder(getSymbolicName())
0: 					.version(getVersion()).content(archive.getResources())
0: 					.build();
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 		catch (Throwable t) {
0: 			if (t instanceof SubsystemException)
0: 				throw (SubsystemException)t;
0: 			throw new SubsystemException(t);
/////////////////////////////////////////////////////////////////////////
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().getType();
/////////////////////////////////////////////////////////////////////////
0: 		catch (Throwable t) {
0: 			coordination.fail(t);
0: 				Throwable t = e.getCause();
0: 				if (t instanceof SubsystemException)
0: 					throw (SubsystemException)t;
0: 				throw new SubsystemException(t);
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().isApplication();
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().isComposite();
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().isFeature();
/////////////////////////////////////////////////////////////////////////
0: 		// Content resources are provisioned into the subsystem that declares
0: 		// them.
0: 			// Transitive dependencies should be provisioned into the first
0: 			// subsystem that accepts dependencies.
0: 			while (provisionTo.archive.getSubsystemManifest().getSubsystemTypeHeader().getProvisionPolicyDirective().isRejectDependencies())
/////////////////////////////////////////////////////////////////////////
0: 		catch (SubsystemException e) {
0: 			throw e;
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 			// This means the resource is an already installed bundle.
0: 			// actually occur here, and the event hook is not called.
commit:95f6444
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		long lastId = 0;
0: 			SubsystemIdentifier.setLastId(lastId);
/////////////////////////////////////////////////////////////////////////
0: 		id = SubsystemIdentifier.getNextId();
/////////////////////////////////////////////////////////////////////////
0: 				SubsystemIdentifier.getLastId(),
/////////////////////////////////////////////////////////////////////////
0: 					SubsystemIdentifier.getLastId(),
/////////////////////////////////////////////////////////////////////////
0: 		bundle.start(Bundle.START_TRANSIENT | Bundle.START_ACTIVATION_POLICY);
commit:28c3eb7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// If the provided resource is null, all subsystems are desired.
0: 		if (resource == null)
0: 			return locationToSubsystem.values();
0: 		// Otherwise, only subsystems associated with the provided resource are
0: 		// desired.
0: 		// TODO Does this need to be a copy? Unmodifiable?
0: 			// TODO The new HashSet needs to be guarded by a lock.
/////////////////////////////////////////////////////////////////////////
0: 			addResourceToSubsystem(br, this);
/////////////////////////////////////////////////////////////////////////
0: 		return SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(archive
0: 				.getSubsystemManifest().getHeaders()
0: 				.get(SubsystemManifest.SUBSYSTEM_TYPE).getValue());
0: 
0: 		return SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(archive
0: 				.getSubsystemManifest().getHeaders()
0: 				.get(SubsystemManifest.SUBSYSTEM_TYPE).getValue());
0: 
0: 		return SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(archive
0: 				.getSubsystemManifest().getHeaders()
0: 				.get(SubsystemManifest.SUBSYSTEM_TYPE).getValue());
/////////////////////////////////////////////////////////////////////////
0: 	synchronized void bundleInstalled(BundleRevision revision) {
0: 		addResourceToSubsystem(revision, this);
0: 		constituents.add(revision);
0: 	}
0: 	
0: 	synchronized void bundleUninstalled(BundleRevision revision) {
0: 		constituents.remove(revision);
0: 		removeResourceToSubsystem(revision, this);
/////////////////////////////////////////////////////////////////////////
0: 			RegionContextBundleHelper.installRegionContextBundle(this);
/////////////////////////////////////////////////////////////////////////
0: 		AriesSubsystem provisionTo = getProvisionTo(resource, transitive);
0: 		if (resource instanceof BundleRevision) {
0: 			// This means the resource is a bundle that's already been installed, but we still need to establish the resource->subsystem relationship.
0: 			revision = (BundleRevision)resource;
0: 			// Need to simulate the install process since an install does not
0: 			// actually occur here and the event hook is not called.
0: 			provisionTo.bundleInstalled(revision);
0: 		else {
0: 			InputStream content = ((RepositoryContent)resource).getContent();
0: 			String location = provisionTo.getSubsystemId() + "@" + provisionTo.getSymbolicName() + "@" + ResourceHelper.getSymbolicNameAttribute(resource);
0: 			ThreadLocalSubsystem.set(provisionTo);
0: 			Bundle bundle = provisionTo.region.installBundle(location, content);
0: 			revision = bundle.adapt(BundleRevision.class);
0: 			// Only need to add a participant when this subsystem is the actual
0: 			// installer of the bundle.
0: 			coordination.addParticipant(new Participant() {
0: 				public void ended(Coordination coordination) throws Exception {
0: 					// noop
0: 		
0: 				public void failed(Coordination coordination) throws Exception {
0: 					revision.getBundle().uninstall();
0: 				}
0: 			});
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 				removeResourceToSubsystem(subsystem, AriesSubsystem.this);
0: 		addResourceToSubsystem(subsystem, this);
/////////////////////////////////////////////////////////////////////////
0: 		else if (IdentityNamespace.TYPE_FRAGMENT.equals(type))
0: 			return;
/////////////////////////////////////////////////////////////////////////
0: 			RegionContextBundleHelper.uninstallRegionContextBundle(this);
0: 		BundleRevision revision = (BundleRevision)resource;
0: 		if (getSubsystems(revision).size() > 1) {
0: 			bundleUninstalled(revision);
0: 			return;
0: 		Bundle bundle = revision.getBundle();
0: 		LOGGER.debug("Uninstalling bundle {}", bundle);
0: 		bundle.uninstall();
/////////////////////////////////////////////////////////////////////////
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type) || IdentityNamespace.TYPE_FRAGMENT.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 		removeResourceToSubsystem(resource, this);
commit:aac6a2a
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = new AriesSubsystem(location, ssr.getContent(), this);
/////////////////////////////////////////////////////////////////////////
0: 				InputStream content = ((RepositoryContent)resource).getContent();
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = (AriesSubsystem)install(sfr.getLocation(), sfr.getContent(), coordination);
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = (AriesSubsystem)install(location, ((RepositoryContent)resource).getContent(), coordination);
commit:574fba9
/////////////////////////////////////////////////////////////////////////
0: 			header = getDeploymentManifest().getRequireBundleHeader();
0: 			setImportIsolationPolicy(builder, (RequireBundleHeader)header);
/////////////////////////////////////////////////////////////////////////
commit:7e004f1
/////////////////////////////////////////////////////////////////////////
0: 	private static synchronized void addResourceToSubsystem(Resource resource, AriesSubsystem subsystem) {
0: 		Set<AriesSubsystem> subsystems = resourceToSubsystems.get(resource);
0: 		if (subsystems == null) {
0: 			subsystems = new HashSet<AriesSubsystem>();
0: 			resourceToSubsystems.put(resource, subsystems);
0: 		}
0: 		subsystems.add(subsystem);
0: 	}
0: 	
0: 	private static synchronized void removeResourceToSubsystem(Resource resource, AriesSubsystem subsystem) {
0: 		Set<AriesSubsystem> subsystems = resourceToSubsystems.get(resource);
0: 		if (subsystems == null)
0: 			return;
0: 		subsystems.remove(subsystem);
0: 		if (subsystems.isEmpty())
0: 			resourceToSubsystems.remove(resource);
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 		Resource resource = event.getBundle().adapt(BundleRevision.class);
0: 			case BundleEvent.INSTALLED:
0: 				addResourceToSubsystem(resource, this);
0: 				constituents.add(resource);
0: 				constituents.remove(resource);
0: 				removeResourceToSubsystem(resource, this);
commit:097d28b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceCapability;
0: import org.apache.aries.subsystem.core.archive.SubsystemExportServiceHeader;
/////////////////////////////////////////////////////////////////////////
0: 			setExportIsolationPolicy(builder, getDeploymentManifest().getSubsystemExportServiceHeader());
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	private void setExportIsolationPolicy(RegionFilterBuilder builder, SubsystemExportServiceHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		String policy = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
0: 		for (SubsystemExportServiceHeader.Clause clause : header.getClauses()) {
0: 			SubsystemExportServiceCapability capability = new SubsystemExportServiceCapability(clause, this);
0: 			String filter = capability.getDirectives().get(SubsystemExportServiceCapability.DIRECTIVE_FILTER);
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter.toString());
0: 		}
0: 	}
commit:26123d8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.ProvideCapabilityCapability;
0: import org.apache.aries.subsystem.core.archive.ProvideCapabilityHeader;
/////////////////////////////////////////////////////////////////////////
0: 			setExportIsolationPolicy(builder, getDeploymentManifest().getProvideCapabilityHeader());
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	private void setExportIsolationPolicy(RegionFilterBuilder builder, ProvideCapabilityHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		for (ProvideCapabilityHeader.Clause clause : header.getClauses()) {
0: 			ProvideCapabilityCapability capability = new ProvideCapabilityCapability(clause, this);
0: 			String policy = capability.getNamespace();
0: 			StringBuilder filter = new StringBuilder("(&");
0: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet())
0: 				filter.append('(').append(attribute.getKey()).append('=').append(attribute.getValue()).append(')');
0: 			filter.append(')');
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter.toString());
0: 		}
0: 	}
commit:7837a59
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.ExportPackageCapability;
0: import org.apache.aries.subsystem.core.archive.ExportPackageHeader;
/////////////////////////////////////////////////////////////////////////
0: 	private void setExportIsolationPolicy() throws InvalidSyntaxException, IOException, BundleException {
0: 		if (isRoot())
0: 			// Nothing to do if this is the root subsystem.
0: 		if (isFeature())
0: 			// Features share the same isolation as that of their scoped parent.
0: 			return;
0: 		Region from = ((AriesSubsystem)getParents().iterator().next()).region;
0: 		Region to = region;
0: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
0: 		if (isComposite()) {
0: 			setExportIsolationPolicy(builder, getDeploymentManifest().getExportPackageHeader());
0: 			// TODO Implement export isolation policy for composites.
0: 		}
0: 		RegionFilter regionFilter = builder.build();
0: 		if (LOGGER.isDebugEnabled())
0: 			LOGGER.debug("Establishing region connection: from=" + from
0: 					+ ", to=" + to + ", filter=" + regionFilter);
0: 		from.connectRegion(to, regionFilter);
0: 	}
0: 	
0: 	private void setExportIsolationPolicy(RegionFilterBuilder builder, ExportPackageHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
0: 		for (ExportPackageCapability capability : header.toCapabilities(this)) {
0: 			StringBuilder filter = new StringBuilder("(&");
0: 			for (Entry<String, Object> attribute : capability.getAttributes().entrySet())
0: 				filter.append('(').append(attribute.getKey()).append('=').append(attribute.getValue()).append(')');
0: 			filter.append(')');
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter.toString());
0: 		}
commit:47d9366
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.RequireBundleHeader;
0: import org.apache.aries.subsystem.core.archive.RequireBundleRequirement;
/////////////////////////////////////////////////////////////////////////
0: 		Region from = region;
0: 		Region to = ((AriesSubsystem)getParents().iterator().next()).region;
0: 		RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			Header<?> header = getDeploymentManifest().getRequireBundleHeader();
0: 			setImportIsolationPolicy(builder, (RequireBundleHeader)header);
0: 		RegionFilter regionFilter = builder.build();
0: 		if (LOGGER.isDebugEnabled())
0: 			LOGGER.debug("Establishing region connection: from=" + from
0: 					+ ", to=" + to + ", filter=" + regionFilter);
0: 		from.connectRegion(to, regionFilter);
/////////////////////////////////////////////////////////////////////////
0: 	private static void setImportIsolationPolicy(RegionFilterBuilder builder, RequireBundleHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		for (RequireBundleHeader.Clause clause : header.getClauses()) {
0: 			RequireBundleRequirement requirement = new RequireBundleRequirement(clause);
0: 			String policy = RegionFilter.VISIBLE_REQUIRE_NAMESPACE;
0: 			String filter = requirement.getDirectives().get(RequireBundleRequirement.DIRECTIVE_FILTER);
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter);
0: 		}
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 			String filter = requirement.getDirectives().get(SubsystemImportServiceRequirement.DIRECTIVE_FILTER);
commit:124d6a3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.SubsystemImportServiceHeader;
0: import org.apache.aries.subsystem.core.archive.SubsystemImportServiceRequirement;
/////////////////////////////////////////////////////////////////////////
0: 			// Both applications and composites have Subsystem-ImportService headers that require processing.
0: 			// In the case of applications, the header is generated.
0: 			header = getDeploymentManifest().getSubsystemImportServiceHeader();
0: 			setImportIsolationPolicy(builder, (SubsystemImportServiceHeader)header);
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	private static void setImportIsolationPolicy(RegionFilterBuilder builder, SubsystemImportServiceHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		for (SubsystemImportServiceHeader.Clause clause : header.getClauses()) {
0: 			SubsystemImportServiceRequirement requirement = new SubsystemImportServiceRequirement(clause);
0: 			String policy = RegionFilter.VISIBLE_SERVICE_NAMESPACE;
0: 			String filter = requirement.getDirectives().get(RequireCapabilityRequirement.DIRECTIVE_FILTER);
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter);
0: 		}
0: 	}
commit:c1afebc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
0: import org.apache.aries.subsystem.core.archive.RequireCapabilityRequirement;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			Region from = region;
0: 			Region to = ((AriesSubsystem)getParents().iterator().next()).region;
0: 			RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
0: 			Header<?> header = getDeploymentManifest().getImportPackageHeader();
0: 			setImportIsolationPolicy(builder, (ImportPackageHeader)header);
0: 			// Both applications and composites have Require-Capability headers that require processing.
0: 			// In the case of applications, the header is generated.
0: 			header = getDeploymentManifest().getRequireCapabilityHeader();
0: 			setImportIsolationPolicy(builder, (RequireCapabilityHeader)header);
0: 			RegionFilter regionFilter = builder.build();
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Establishing region connection: from=" + from
0: 						+ ", to=" + to + ", filter=" + regionFilter);
0: 			from.connectRegion(to, regionFilter);
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	private static void setImportIsolationPolicy(RegionFilterBuilder builder, ImportPackageHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
0: 		for (ImportPackageHeader.Clause clause : header.getClauses()) {
0: 			ImportPackageRequirement requirement = new ImportPackageRequirement(clause);
0: 			String filter = requirement.getDirectives().get(ImportPackageRequirement.DIRECTIVE_FILTER);
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter);
0: 		}
0: 	}
0: 	
0: 	private static void setImportIsolationPolicy(RegionFilterBuilder builder, RequireCapabilityHeader header) throws InvalidSyntaxException {
0: 		if (header == null)
0: 			return;
0: 		for (RequireCapabilityHeader.Clause clause : header.getClauses()) {
0: 			RequireCapabilityRequirement requirement = new RequireCapabilityRequirement(clause);
0: 			String policy = requirement.getNamespace();
0: 			String filter = requirement.getDirectives().get(RequireCapabilityRequirement.DIRECTIVE_FILTER);
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Allowing " + policy + " of " + filter);
0: 			builder.allow(policy, filter);
0: 		}
0: 	}
commit:deca8ed
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.ImportPackageRequirement;
/////////////////////////////////////////////////////////////////////////
0: import org.eclipse.equinox.region.RegionFilterBuilder;
/////////////////////////////////////////////////////////////////////////
0: 			// Nothing to do if this is the root subsystem.
0: 		if (isFeature())
0: 			// Features share the same isolation as that of their scoped parent.
0: 		if (isApplication() || isComposite()) {
0: 			// Both applications and composites have Import-Package headers that require processing.
0: 			// In the case of applications, the header is generated.
0: 			ImportPackageHeader importPackage = getDeploymentManifest().getImportPackageHeader();
0: 			if (importPackage != null) {
0: 				Region from = region;
0: 				Region to = ((AriesSubsystem)getParents().iterator().next()).region;
0: 				String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
0: 				RegionFilterBuilder builder = from.getRegionDigraph().createRegionFilterBuilder();
0: 				for (ImportPackageHeader.Clause clause : importPackage.getClauses()) {
0: 					ImportPackageRequirement requirement = new ImportPackageRequirement(clause);
0: 					String filter = requirement.getDirectives().get(PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE);
0: 					if (LOGGER.isDebugEnabled())
0: 						LOGGER.debug("Allowing " + policy + " of " + filter);
0: 					builder.allow(policy, filter);
0: 				}
0: 				RegionFilter regionFilter = builder.build();
0: 				if (LOGGER.isDebugEnabled())
0: 					LOGGER.debug("Establishing region connection: from="
0: 							+ from + ", to=" + to + ", policy=" + policy
0: 							+ ", filter=" + regionFilter);
0: 				from.connectRegion(to, regionFilter);
0: 			}
commit:8ee8aac
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = new AriesSubsystem(location, ssr.getContent(null), this);
/////////////////////////////////////////////////////////////////////////
0: 				InputStream content = ((RepositoryContent)resource).getContent(null);
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = (AriesSubsystem)install(sfr.getLocation(), sfr.getContent(null), coordination);
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = (AriesSubsystem)install(location, ((RepositoryContent)resource).getContent(null), coordination);
commit:71fe81a
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.resource.Capability;
0: import org.osgi.resource.Requirement;
0: import org.osgi.resource.Resource;
commit:fc759fb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.archive.ImportPackageHeader;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.InvalidSyntaxException;
0: import org.osgi.framework.namespace.PackageNamespace;
/////////////////////////////////////////////////////////////////////////
0: 				true,
/////////////////////////////////////////////////////////////////////////
0: 			// TODO This doesn't start dependencies that are constituents in a parent subsystem.
/////////////////////////////////////////////////////////////////////////
0: 				false,
/////////////////////////////////////////////////////////////////////////
0: 					true,
0: 					false));
/////////////////////////////////////////////////////////////////////////
0: 		setImportIsolationPolicy();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private void setExportIsolationPolicy() {
0: 		// TODO Implement export isolation policy for composites.
0: 	}
0: 
0: 	private void setImportIsolationPolicy() throws BundleException, IOException, InvalidSyntaxException {
0: 		// Nothing to do if this is the root subsystem.
0: 		if (isRoot())
0: 			return;
0: 		// Features share the same isolation as that of their scoped parent.
0: 			// TODO Support for generic requirements such as osgi.ee.
0: 			ImportPackageHeader importPackage = getDeploymentManifest().getImportPackageHeader();
0: 			if (importPackage != null) {
0: 				for (ImportPackageHeader.Clause clause : importPackage.getClauses()) {
0: 					Region from = region;
0: 					Region to = ((AriesSubsystem)getParents().iterator().next()).region;
0: 					String policy = RegionFilter.VISIBLE_PACKAGE_NAMESPACE;
0: 					String filter = clause.getRequirement(this).getDirectives().get(PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE);
0: 					if (LOGGER.isDebugEnabled())
0: 						LOGGER.debug("Establishing region connection: from="
0: 								+ from + ", to=" + to + ", policy=" + policy
0: 								+ ", filter=" + filter);
0: 					from.connectRegion(
0: 							to, 
0: 							from.getRegionDigraph().createRegionFilterBuilder().allow(
0: 									RegionFilter.VISIBLE_PACKAGE_NAMESPACE, 
0: 									filter).build());
0: 				}
0: 			}
commit:a1c6951
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.namespace.IdentityNamespace;
/////////////////////////////////////////////////////////////////////////
0: 		if (namespace == null || namespace.equals(IdentityNamespace.IDENTITY_NAMESPACE)) {
/////////////////////////////////////////////////////////////////////////
0: 		Coordination coordination = Activator.getInstance().getServiceProvider().getService(Coordinator.class).create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 		Subsystem result = null;
0: 			result = install(location, content, coordination);
0: 			coordination.fail(e);
0: 			try {
0: 				coordination.end();
0: 			}
0: 			catch (CoordinationException e) {
0: 				throw new SubsystemException(e);
0: 			}
0: 		return result;
/////////////////////////////////////////////////////////////////////////
0: 		uninstall(true);
/////////////////////////////////////////////////////////////////////////
0: 	void install() {
0: 		Coordination coordination = Activator.getInstance()
0: 				.getServiceProvider().getService(Coordinator.class)
0: 				.create(getSymbolicName() + "-" + getSubsystemId(), 0);
0: 		try {
0: 			install(coordination);
0: 		} catch (Exception e) {
0: 			coordination.fail(e);
0: 		} finally {
0: 			coordination.end();
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	private synchronized void install(Coordination coordination) throws Exception {
0: 		if (!isFeature())
0: 			constituents.add(RegionContextBundleHelper.installRegionContextBundle(this));
0: 		Activator.getInstance().getSubsystemServiceRegistrar().register(this);
0: 		Set<Resource> contentResources = new TreeSet<Resource>(
0: 				new Comparator<Resource>() {
0: 					@Override
0: 					public int compare(Resource o1, Resource o2) {
0: 						if (o1.equals(o2))
0: 							// Consistent with equals.
0: 							return 0;
0: 						String t1 = ResourceHelper.getTypeAttribute(o1);
0: 						String t2 = ResourceHelper.getTypeAttribute(o2);
0: 						boolean b1 = IdentityNamespace.TYPE_BUNDLE.equals(t1)
0: 								|| IdentityNamespace.TYPE_FRAGMENT.equals(t1);
0: 						boolean b2 = IdentityNamespace.TYPE_BUNDLE.equals(t2)
0: 								|| IdentityNamespace.TYPE_FRAGMENT.equals(t2);
0: 						if (b1 && !b2)
0: 							// o1 is a bundle or fragment but o2 is not.
0: 							return -1;
0: 						if (!b1 && b2)
0: 							// o1 is not a bundle or fragment but o2 is.
0: 							return 1;
0: 						// Either both or neither are bundles or fragments. In this case we don't care about the order.
0: 						return -1;
0: 					}
0: 				});
0: 		List<Resource> transitiveDependencies = new ArrayList<Resource>();
0: 		DeploymentManifest manifest = getDeploymentManifest();
0: 		DeployedContentHeader contentHeader = manifest.getDeployedContentHeader();
0: 		if (contentHeader != null) {
0: 			for (DeployedContent content : contentHeader.getDeployedContents()) {
0: 				Collection<Capability> capabilities = environment.findProviders(
0: 						new OsgiIdentityRequirement(content.getName(), content.getDeployedVersion(), content.getNamespace(), false));
0: 				if (capabilities.isEmpty())
0: 					throw new SubsystemException("Subsystem content resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: 				Resource resource = capabilities.iterator().next().getResource();
0: 				contentResources.add(resource);
0: 			}
0: 		}
0: 		ProvisionResourceHeader resourceHeader = manifest.getProvisionResourceHeader();
0: 		if (resourceHeader != null) {
0: 			for (ProvisionedResource content : resourceHeader.getProvisionedResources()) {
0: 				Collection<Capability> capabilities = environment.findProviders(
0: 						new OsgiIdentityRequirement(content.getName(), content.getDeployedVersion(), content.getNamespace(), true));
0: 				if (capabilities.isEmpty())
0: 					throw new SubsystemException("Subsystem provisioned resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: 				Resource resource = capabilities.iterator().next().getResource();
0: 				transitiveDependencies.add(resource);
0: 			}
0: 		}
0: 		// Install the content resources.
0: 		for (Resource resource : contentResources) {
0: 			installResource(resource, coordination, false);
0: 		}
0: 		// Discover and install transitive dependencies.
0: 		for (Resource resource : transitiveDependencies) {
0: 			installResource(resource, coordination, true);
0: 		}
0: 		setState(State.INSTALLED);
0: 		if (autostart)
0: 			start();
0: 	}
0: 	
0: 	private synchronized Subsystem install(String location, InputStream content, Coordination coordination) throws SubsystemException {
0: 		SubsystemStreamResource ssr = null;
0: 		try {
0: 			TargetRegion region = new TargetRegion(this);
0: 			ssr = new SubsystemStreamResource(location, content);
0: 			AriesSubsystem subsystem = locationToSubsystem.get(location);
0: 			if (subsystem != null) {
0: 				if (!region.contains(subsystem))
0: 					throw new SubsystemException("Location already exists but existing subsystem is not part of target region: " + location);
0: 				if (!(subsystem.getSymbolicName().equals(ssr.getSubsystemSymbolicName())
0: 						&& subsystem.getVersion().equals(ssr.getSubsystemVersion())
0: 						&& subsystem.getType().equals(ssr.getSubsystemType())))
0: 					throw new SubsystemException("Location already exists but symbolic name, version, and type are not the same: " + location);
0: 				subsystemGraph.add(this, subsystem);
0: 				constituents.add(subsystem);
0: 				return subsystem;
0: 			}
0: 			subsystem = (AriesSubsystem)region.find(ssr.getSubsystemSymbolicName(), ssr.getSubsystemVersion());
0: 			if (subsystem != null) {
0: 				if (!subsystem.getType().equals(ssr.getSubsystemType()))
0: 					throw new SubsystemException("Subsystem already exists in target region but has a different type: " + location);
0: 				subsystemGraph.add(this, subsystem);
0: 				constituents.add(subsystem);
0: 				return subsystem;
0: 			}
0: 			subsystem = new AriesSubsystem(location, ssr.getContent(), this);
0: 			installSubsystemResource(subsystem, coordination, false);
0: 			return subsystem;
0: 		}
0: 		catch (Exception e) {
0: 			throw new SubsystemException(e);
0: 		}
0: 		finally {
0: 			if (ssr != null)
0: 				ssr.close();
0: 			IOUtils.close(content);
0: 		}
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type))
0: 		else if (IdentityNamespace.TYPE_FRAGMENT.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = (AriesSubsystem)install(sfr.getLocation(), sfr.getContent(), coordination);
/////////////////////////////////////////////////////////////////////////
0: 			subsystem = (AriesSubsystem)install(location, ((RepositoryContent)resource).getContent(), coordination);
0: 		// Detect a cycle before becoming a participant; otherwise, install failure cleanup goes awry
0: 		// because the parent in the cycle (i.e. the subsystem attempting to install here) is cleaned up 
0: 		// before the child. This results in the child (i.e. this subsystem) being uninstalled as part
0: 		// of that process, but its state has not moved from INSTALLING to INSTALL_FAILED, which results
0: 		// in an eternal wait for a state change.
0: 				subsystem.setState(State.INSTALL_FAILED);
0: 				subsystem.uninstall(false);
0: 		Set<AriesSubsystem> subsystems = new HashSet<AriesSubsystem>();
0: 		subsystems.add(this);
0: 		resourceToSubsystems.put(subsystem, subsystems);
0: 		constituents.add(subsystem);
0: 		subsystem.install(coordination);
/////////////////////////////////////////////////////////////////////////
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type))
0: 		else if (IdentityNamespace.TYPE_FRAGMENT.equals(type)) {
/////////////////////////////////////////////////////////////////////////
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	private void uninstall(boolean changeState) {
0: 		if (changeState)
0: 			setState(State.UNINSTALLING);
0: 		// Uninstall child subsystems first.
0: 		for (Subsystem subsystem : getChildren()) {
0: 			try {
0: 				uninstallSubsystemResource((AriesSubsystem)subsystem);
0: 			}
0: 			catch (Exception e) {
0: 				LOGGER.error("An error occurred while uninstalling resource " + subsystem + " of subsystem " + this, e);
0: 				// TODO Should FAILED go out for each failure?
0: 			}
0: 		}
0: 		// Uninstall any remaining constituents.
0: 		for (Resource resource : getConstituents()) {
0: 			// Don't uninstall the region context bundle here.
0: 			if (ResourceHelper.getSymbolicNameAttribute(resource).startsWith(RegionContextBundleHelper.SYMBOLICNAME_PREFIX))
0: 				continue;
0: 			try {
0: 				uninstallResource(resource);
0: 			}
0: 			catch (Exception e) {
0: 				LOGGER.error("An error occurred while uninstalling resource " + resource + " of subsystem " + this, e);
0: 				// TODO Should FAILED go out for each failure?
0: 			}
0: 		}
0: 		for (Subsystem parent : getParents()) {
0: 			((AriesSubsystem)parent).constituents.remove(this);
0: 		}
0: 		subsystemGraph.remove(this);
0: 		locationToSubsystem.remove(location);
0: 		deleteFile(directory);
0: 		if (changeState)
0: 			setState(State.UNINSTALLED);
0: 		Activator.getInstance().getSubsystemServiceRegistrar().unregister(this);
0: 		if (!isFeature())
0: 			constituents.remove(RegionContextBundleHelper.uninstallRegionContextBundle(this));
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 		else if (IdentityNamespace.TYPE_BUNDLE.equals(type))
commit:74f2d79
/////////////////////////////////////////////////////////////////////////
0: 	private final SubsystemGraph subsystemGraph;
/////////////////////////////////////////////////////////////////////////
0: 		// The root subsystem establishes the subsystem graph;
0: 		subsystemGraph = new SubsystemGraph(this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		subsystemGraph = parent.subsystemGraph;
/////////////////////////////////////////////////////////////////////////
0: 		subsystemGraph = parent.subsystemGraph;
/////////////////////////////////////////////////////////////////////////
0: 	@Override
0: 		return subsystemGraph.getChildren(this);
/////////////////////////////////////////////////////////////////////////
0: 		return subsystemGraph.getParents(this);
/////////////////////////////////////////////////////////////////////////
0: 				subsystemGraph.add(this, subsystem);
/////////////////////////////////////////////////////////////////////////
0: 				subsystemGraph.add(this, subsystem);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (state == State.UNINSTALLING || state == State.UNINSTALLED || state == State.INSTALL_FAILED) {
/////////////////////////////////////////////////////////////////////////
0: 		for (Subsystem parent : getParents()) {
0: 			((AriesSubsystem)parent).constituents.remove(this);
0: 		subsystemGraph.remove(this);
/////////////////////////////////////////////////////////////////////////
0: 		for (Subsystem subsystem : subsystemGraph.getChildren(this)) {
0: 				stopSubsystemResource((AriesSubsystem)subsystem);
/////////////////////////////////////////////////////////////////////////
0: 			while (!provisionTo.getParents().isEmpty())
0: 				provisionTo = (AriesSubsystem)provisionTo.getParents().iterator().next();
/////////////////////////////////////////////////////////////////////////
0: 		subsystemGraph.add(this, subsystem);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					((AriesSubsystem)getParents().iterator().next()).region, 
commit:0d95583
/////////////////////////////////////////////////////////////////////////
0: 		// TODO Add to constants.
0: 		String fileName = directoryName + ".esa";
commit:b8ad309
/////////////////////////////////////////////////////////////////////////
0: 			SubsystemManifestValidator.validate(this, archive.getSubsystemManifest());
/////////////////////////////////////////////////////////////////////////
0: 			Capability capability = new OsgiIdentityCapability(this, getSymbolicName(), getVersion(), getType());
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(type)
0: 				|| SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(type))
commit:bd2f017
/////////////////////////////////////////////////////////////////////////
0: import java.util.Comparator;
0: import java.util.TreeSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.resource.SubsystemStreamResource;
0: import org.apache.aries.util.io.IOUtils;
/////////////////////////////////////////////////////////////////////////
0: 	private final Set<AriesSubsystem> parents = Collections.synchronizedSet(new HashSet<AriesSubsystem>());
/////////////////////////////////////////////////////////////////////////
0: 			environment = new SubsystemEnvironment(this);
0: 			// Make sure the relevant headers are derived, if absent.
0: 			archive.setSubsystemManifest(new SubsystemManifest(
0: 					archive.getSubsystemManifest(),
0: 					uri == null ? null : uri.getSymbolicName(), 
0: 					uri == null ? null : uri.getVersion(), 
0: 					archive.getResources()));
0: 			// Unscoped subsystems don't get their own region. They share the region with their scoped parent.
0: 			if (isFeature())
0: 				region = parent.region;
0: 			else
0: 				region = createRegion(getSymbolicName() + ';' + getVersion() + ';' + getType() + ';' + getSubsystemId());
/////////////////////////////////////////////////////////////////////////
0: 			region = parent.region;
/////////////////////////////////////////////////////////////////////////
0: 		Region region = this.region;
0: 		Subsystem subsystem = this;
0: 		if (isFeature()) {
0: 			for (Subsystem parent : getParents()) {
0: 				if (!((AriesSubsystem)parent).isFeature()) {
0: 					region = ((AriesSubsystem)parent).getRegion();
0: 					subsystem = parent;
0: 				}
0: 			}
0: 		}
0: 		return region.getBundle(RegionContextBundleHelper.SYMBOLICNAME_PREFIX + subsystem.getSubsystemId(), RegionContextBundleHelper.VERSION).getBundleContext();
0: 		if (namespace == null || namespace.equals(ResourceConstants.IDENTITY_NAMESPACE)) {
0: 			Capability capability = new OsgiIdentityCapability(this, getSymbolicName(), getVersion(), SubsystemConstants.IDENTITY_TYPE_SUBSYSTEM, getType());
0: 			return Arrays.asList(new Capability[]{capability});
0: 		}
0: 		return Collections.emptyList();
0: 		return (Collection<Subsystem>)(Collection)Collections.unmodifiableCollection(new ArrayList<Subsystem>(children));
0: 		return Collections.unmodifiableCollection(new ArrayList<Resource>(constituents));
/////////////////////////////////////////////////////////////////////////
0: 		return archive.getSubsystemManifest().getSubsystemSymbolicNameHeader().getSymbolicName();
0: 		return archive.getSubsystemManifest().getSubsystemTypeHeader().getValue();
0: 		return archive.getSubsystemManifest().getSubsystemVersionHeader().getVersion();
/////////////////////////////////////////////////////////////////////////
0: 		SubsystemStreamResource ssr = null;
0: 			TargetRegion region = new TargetRegion(this);
0: 			ssr = new SubsystemStreamResource(location, content);
0: 			if (subsystem != null) {
0: 				if (!region.contains(subsystem))
0: 					throw new SubsystemException("Location already exists but existing subsystem is not part of target region: " + location);
0: 				if (!(subsystem.getSymbolicName().equals(ssr.getSubsystemSymbolicName())
0: 						&& subsystem.getVersion().equals(ssr.getSubsystemVersion())
0: 						&& subsystem.getType().equals(ssr.getSubsystemType())))
0: 					throw new SubsystemException("Location already exists but symbolic name, version, and type are not the same: " + location);
0: 				children.add(subsystem);
0: 				constituents.add(subsystem);
0: 			}
0: 			subsystem = (AriesSubsystem)region.find(ssr.getSubsystemSymbolicName(), ssr.getSubsystemVersion());
0: 			if (subsystem != null) {
0: 				if (!subsystem.getType().equals(ssr.getSubsystemType()))
0: 					throw new SubsystemException("Subsystem already exists in target region but has a different type: " + location);
0: 				children.add(subsystem);
0: 				constituents.add(subsystem);
0: 				return subsystem;
0: 			}
0: 			subsystem = new AriesSubsystem(location, ssr.getContent(), this);
/////////////////////////////////////////////////////////////////////////
0: 			if (ssr != null)
0: 				ssr.close();
0: 			IOUtils.close(content);
/////////////////////////////////////////////////////////////////////////
0: 		// Uninstall child subsystems first.
0: 		for (Subsystem subsystem : getChildren()) {
0: 			try {
0: 				uninstallSubsystemResource((AriesSubsystem)subsystem);
0: 			}
0: 			catch (Exception e) {
0: 				LOGGER.error("An error occurred while uninstalling resource " + subsystem + " of subsystem " + this, e);
0: 				// TODO Should FAILED go out for each failure?
0: 			}
0: 		}
0: 		// Uninstall any remaining constituents.
0: 		for (Resource resource : getConstituents()) {
0: 			// Don't uninstall the region context bundle here.
0: 			if (ResourceHelper.getSymbolicNameAttribute(resource).startsWith(RegionContextBundleHelper.SYMBOLICNAME_PREFIX))
0: 				continue;
/////////////////////////////////////////////////////////////////////////
0: 		for (AriesSubsystem parent : parents) {
0: 			parent.children.remove(this);
0: 			parent.constituents.remove(this);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 		Set<Resource> contentResources = new TreeSet<Resource>(
0: 				new Comparator<Resource>() {
0: 					@Override
0: 					public int compare(Resource o1, Resource o2) {
0: 						if (o1.equals(o2))
0: 							// Consistent with equals.
0: 							return 0;
0: 						String t1 = ResourceHelper.getTypeAttribute(o1);
0: 						String t2 = ResourceHelper.getTypeAttribute(o2);
0: 						boolean b1 = ResourceConstants.IDENTITY_TYPE_BUNDLE.equals(t1)
0: 								|| ResourceConstants.IDENTITY_TYPE_FRAGMENT.equals(t1);
0: 						boolean b2 = ResourceConstants.IDENTITY_TYPE_BUNDLE.equals(t2)
0: 								|| ResourceConstants.IDENTITY_TYPE_FRAGMENT.equals(t2);
0: 						if (b1 && !b2)
0: 							// o1 is a bundle or fragment but o2 is not.
0: 							return -1;
0: 						if (!b1 && b2)
0: 							// o1 is not a bundle or fragment but o2 is.
0: 							return 1;
0: 						// Either both or neither are bundles or fragments. In this case we don't care about the order.
0: 						return -1;
0: 					}
0: 				});
/////////////////////////////////////////////////////////////////////////
0: 				stopSubsystemResource(subsystem);
/////////////////////////////////////////////////////////////////////////
0: 				// Don't stop the region context bundle.
0: 				if (ResourceHelper.getSymbolicNameAttribute(resource).startsWith(RegionContextBundleHelper.SYMBOLICNAME_PREFIX))
0: 					continue;
/////////////////////////////////////////////////////////////////////////
0: 				provisionTo = provisionTo.parents.iterator().next();
/////////////////////////////////////////////////////////////////////////
0: 		else if (resource instanceof SubsystemDirectoryResource) {
0: 		else if (resource instanceof RepositoryContent) {
0: 			String location = getSubsystemId() + "@" + getSymbolicName() + "@" + ResourceHelper.getSymbolicNameAttribute(resource);
0: 			subsystem = (AriesSubsystem)install(location, ((RepositoryContent)resource).getContent());
0: 			return;
0: 		}
0: 		else {
0: 			throw new IllegalArgumentException("Unrecognized subsystem resource: " + resource);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 					parents.iterator().next().region, 
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.IDENTITY_TYPE_SUBSYSTEM.equals(type))
commit:a677a53
/////////////////////////////////////////////////////////////////////////
0: 			constituents.add(br);
/////////////////////////////////////////////////////////////////////////
0: 		// Make sure the relevant headers are derived, if absent.
0: 		archive.setSubsystemManifest(new SubsystemManifest(
0: 				archive.getSubsystemManifest(),
0: 				uri == null ? null : uri.getSymbolicName(), 
0: 				uri == null ? null : uri.getVersion(), 
0: 				archive.getResources()));
0: 		// Unscoped subsystems don't get their own region. They share the region with their scoped parent.
0: 		if (isFeature())
0: 			region = parents.get(0).region;
0: 		else
0: 			region = createRegion(getSymbolicName() + ';' + getVersion() + ';' + getType() + ';' + getSubsystemId());
/////////////////////////////////////////////////////////////////////////
0: 		// Unscoped subsystems don't get their own region. They share the region with their scoped parent.
0: 		if (isFeature())
0: 			region = parents.get(0).region;
0: 		else
0: 			region = createRegion(getSymbolicName() + ';' + getVersion() + ';' + getType() + ';' + getSubsystemId());
/////////////////////////////////////////////////////////////////////////
0: 		// Features, and unscoped subsystems in general, do not have their own region context
0: 		// bundle but rather share with the scoped subsystem in the same region.
0: 		if (isFeature())
0: 			return parents.get(0).getBundleContext();
/////////////////////////////////////////////////////////////////////////
0: 		return Collections.unmodifiableCollection(constituents);
/////////////////////////////////////////////////////////////////////////
0: 						"An error occurred while starting a resource in subsystem "
/////////////////////////////////////////////////////////////////////////
0: 		if (!isFeature())
0: 			constituents.remove(RegionContextBundleHelper.uninstallRegionContextBundle(this));
/////////////////////////////////////////////////////////////////////////
0: 		if (!isFeature())
0: 			constituents.add(RegionContextBundleHelper.installRegionContextBundle(this));
/////////////////////////////////////////////////////////////////////////
0: 		// Stop child subsystems first.
0: 		for (AriesSubsystem subsystem : children) {
0: 				stopResource(subsystem);
0: 			}
0: 			catch (Exception e) {
0: 						+ subsystem + " of subsystem " + this, e);
0: 			}
0: 		}
0: 		// For non-root subsystems, stop any remaining constituents.
0: 		if (!isRoot()){
0: 			for (Resource resource : constituents) {
0: 				try {
0: 					// Don't stop the region context bundle.
0: 					if (ResourceHelper.getSymbolicNameAttribute(resource).startsWith(RegionContextBundleHelper.SYMBOLICNAME_PREFIX))
0: 						continue;
0: 					stopResource(resource);
0: 				} catch (Exception e) {
0: 					LOGGER.error("An error occurred while stopping resource "
0: 							+ resource + " of subsystem " + this, e);
0: 					// TODO Should FAILED go out for each failure?
0: 				}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				String location = provisionTo.getSubsystemId() + "@" + provisionTo.getSymbolicName() + "@" + ResourceHelper.getSymbolicNameAttribute(resource);
/////////////////////////////////////////////////////////////////////////
0: 			
0: 		constituentOf.constituents.add(revision);
0: 				// noop
0: 					constituentOf.constituents.remove(revision);
/////////////////////////////////////////////////////////////////////////
0: 		else if (ResourceConstants.IDENTITY_TYPE_FRAGMENT.equals(type))
0: 			installBundleResource(resource, coordination, transitive);
/////////////////////////////////////////////////////////////////////////
0: 		if ((bundle.getState() & (Bundle.STARTING | Bundle.ACTIVE)) != 0)
0: 			return;
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.IDENTITY_TYPE_SUBSYSTEM.equals(type))
0: 		else if (ResourceConstants.IDENTITY_TYPE_FRAGMENT.equals(type)) {
0: 			// Fragments are not started.
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 		if (SubsystemConstants.IDENTITY_TYPE_SUBSYSTEM.equals(type))
commit:bda6868
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.subsystem.core.resource.SubsystemDirectoryResource;
/////////////////////////////////////////////////////////////////////////
0: 	private boolean autostart;
/////////////////////////////////////////////////////////////////////////
0: 		DeploymentManifest deploymentManifest = archive.getDeploymentManifest();
0: 		if (deploymentManifest != null) {
0: 			autostart = Boolean.parseBoolean(deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_AUTOSTART).getValue());
0: 			id = Long.parseLong(deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_ID).getValue());
0: 			lastId = Long.parseLong(deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_LASTID).getValue());
0: 			location = deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_LOCATION).getValue();
0: 			autostart = true;
0: 			id = 0;
0: 			location = ROOT_LOCATION;
0: 		region = createRegion(null);
0: 		SubsystemManifest subsystemManifest = archive.getSubsystemManifest();
0: 		if (subsystemManifest == null) {
0: 			subsystemManifest = new SubsystemManifest(uri.getSymbolicName(), uri.getVersion(), archive.getResources());
0: 			archive.setSubsystemManifest(subsystemManifest);
0: 			subsystemManifest = new SubsystemManifest(getSymbolicName(), getVersion(), archive.getResources());
0: 		archive.setDeploymentManifest(new DeploymentManifest(
0: 				deploymentManifest, 
0: 				subsystemManifest, 
0: 				environment,
0: 				autostart,
0: 				id,
0: 				lastId,
0: 				location,
0: 				true));
/////////////////////////////////////////////////////////////////////////
0: 			archive.setSubsystemManifest(new SubsystemManifest(
0: 		region = createRegion(getSymbolicName() + ';' + getVersion() + ';' + getType() + ';' + getSubsystemId());
0: 		
0: 		DeploymentManifest manifest = archive.getDeploymentManifest();
0: 		if (manifest == null)
0: 			throw new IllegalStateException("Missing deployment manifest");
0: 		autostart = Boolean.parseBoolean(manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_AUTOSTART).getValue());
0: 		id = Long.parseLong(manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_ID).getValue());
0: 		location = manifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_LOCATION).getValue();
0: 		parents.add(parent);
0: 		region = createRegion(getSymbolicName() + ';' + getVersion() + ';' + getType() + ';' + getSubsystemId());
/////////////////////////////////////////////////////////////////////////
0: 		Collection<Resource> resources = new HashSet<Resource>();
/////////////////////////////////////////////////////////////////////////
0: 		Map<String, Header<?>> headers = archive.getSubsystemManifest().getHeaders();
0: 		for (Entry<String, Header<?>> entry: headers.entrySet()) {
0: 			Header<?> value = entry.getValue();
0: 			result.put(entry.getKey(), value.getValue());
/////////////////////////////////////////////////////////////////////////
0: 		return archive.getSubsystemManifest().getHeaders().get(SubsystemManifest.SUBSYSTEM_SYMBOLICNAME).getValue();
/////////////////////////////////////////////////////////////////////////
0: 		return !isRoot()
0: 				&& SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION.equals(archive
0: 						.getSubsystemManifest().getHeaders()
0: 						.get(SubsystemManifest.SUBSYSTEM_TYPE).getValue());
0: 		return !isRoot() 
0: 				&& SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE.equals(archive
0: 						.getSubsystemManifest().getHeaders()
0: 						.get(SubsystemManifest.SUBSYSTEM_TYPE).getValue());
0: 		return !isRoot() 
0: 				&& SubsystemConstants.SUBSYSTEM_TYPE_FEATURE.equals(archive
0: 						.getSubsystemManifest().getHeaders()
0: 						.get(SubsystemManifest.SUBSYSTEM_TYPE).getValue());
/////////////////////////////////////////////////////////////////////////
0: 		autostart = true;
/////////////////////////////////////////////////////////////////////////
0: 		autostart = false;
/////////////////////////////////////////////////////////////////////////
0: 		DeployedContentHeader contentHeader = manifest.getDeployedContentHeader();
/////////////////////////////////////////////////////////////////////////
0: 		ProvisionResourceHeader resourceHeader = manifest.getProvisionResourceHeader();
/////////////////////////////////////////////////////////////////////////
0: 		setState(State.INSTALLED);
0: 		if (autostart)
0: 			start();
/////////////////////////////////////////////////////////////////////////
0: 		DeploymentManifest manifest = new DeploymentManifest(
0: 				archive.getDeploymentManifest(),
0: 				null,
0: 				null,
0: 				autostart,
0: 				id,
0: 				lastId,
0: 				location,
0: 				false);
0: 		try {
0: 			archive.setDeploymentManifest(manifest);
0: 		}
0: 		catch (IOException e) {
0: 			throw new SubsystemException(e);
0: 		}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		Activator activator = Activator.getInstance();
0: 		RegionDigraph digraph = activator.getServiceProvider().getService(RegionDigraph.class);
0: 			return digraph.getRegion(activator.getBundleContext().getBundle());
0: 		Region region = digraph.getRegion(name);
0: 			return digraph.createRegion(name);
/////////////////////////////////////////////////////////////////////////
0: 			archive.setDeploymentManifest(new DeploymentManifest(
0: 					null,
0: 					archive.getSubsystemManifest(), 
0: 					environment,
0: 					autostart,
0: 					id,
0: 					lastId,
0: 					location,
0: 					true));
/////////////////////////////////////////////////////////////////////////
0: 			SubsystemDirectoryResource sdr = (SubsystemDirectoryResource)resource;
0: 			subsystem = new AriesSubsystem(sdr.getArchive(), this);
commit:f1ff8f8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (EnumSet.of(State.INSTALL_FAILED, State.UNINSTALLED).contains(getState()))
0: 			return null;
/////////////////////////////////////////////////////////////////////////
0: 			BundleContext context = getBundleContext();
/////////////////////////////////////////////////////////////////////////
0: 		String result = getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_TYPE);
0: 		if (result == null)
0: 			result = SubsystemConstants.SUBSYSTEM_TYPE_APPLICATION;
0: 		return result;
0: 		String version = getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_VERSION);
0: 		if (version == null)
0: 			return Version.emptyVersion;
0: 		return Version.parseVersion(version);
/////////////////////////////////////////////////////////////////////////
0: 		// The root subsystem may not be stopped.
0: 		checkRoot();
0: 		stop0();
/////////////////////////////////////////////////////////////////////////
0: 		// The root subsystem may not be uninstalled.
/////////////////////////////////////////////////////////////////////////
0: 		RegionContextBundleHelper.uninstallRegionContextBundle(this);
/////////////////////////////////////////////////////////////////////////
0: 	void stop0() {
0: 		if (getState() == State.UNINSTALLING || getState() == State.UNINSTALLED) {
0: 			throw new SubsystemException("Cannot stop from state " + getState());
0: 		}
0: 		else if (getState() == State.STARTING) {
0: 			waitForStateChange();
0: 			stop();
0: 		}
0: 		else if (getState() != State.ACTIVE) {
0: 			return;
0: 		}
0: 		setState(State.STOPPING);
0: 		for (Resource resource : constituents) {
0: 			try {
0: 				stopResource(resource);
0: 			} catch (Exception e) {
0: 				LOGGER.error("An error occurred while stopping resource "
0: 						+ resource + " of subsystem " + this, e);
0: 				// TODO Should FAILED go out for each failure?
0: 			}
0: 		}
0: 		// TODO Can we automatically assume it actually is resolved?
0: 		setState(State.RESOLVED);
0: 	}
0: 	
commit:5725f09
/////////////////////////////////////////////////////////////////////////
0: public class AriesSubsystem implements Subsystem, Resource {
/////////////////////////////////////////////////////////////////////////
0: 		return region.getBundle(RegionContextBundleHelper.SYMBOLICNAME_PREFIX + id, RegionContextBundleHelper.VERSION).getBundleContext();
/////////////////////////////////////////////////////////////////////////
0: 	public synchronized Collection<Resource> getConstituents() {
0: 		Collection<Resource> resources = new ArrayList<Resource>();
0: 		if (isRoot() || isApplication() || isComposite()) {
0: 		resources.addAll(constituents);
0: 		return Collections.unmodifiableCollection(resources);
/////////////////////////////////////////////////////////////////////////
0: 	synchronized void install() throws Exception {
0: 		RegionContextBundleHelper.installRegionContextBundle(this);
commit:d299aa1
/////////////////////////////////////////////////////////////////////////
0: 	private Subsystem.State state = State.INSTALLING;
0: 		DataFile data = archive.getDataFile();
0: 		if (data == null) {
0: 			id = 0;
0: 			location = ROOT_LOCATION;
0: 			region = createRegion(null);
0: 		}
0: 		else {
0: 			id = data.getSubsystemId();
0: 			location = data.getLocation();
0: 			region = createRegion(data.getRegionName());
0: 			state = data.getState();
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 		environment = new SubsystemEnvironment(this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		Activator.getInstance().getSubsystemServiceRegistrar().unregister(this);
/////////////////////////////////////////////////////////////////////////
0: 		Activator.getInstance().getSubsystemServiceRegistrar().register(this);
/////////////////////////////////////////////////////////////////////////
0: 		if (getState().equals(State.INSTALLING))
0: 			setState(State.INSTALLED);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		Activator.getInstance().getSubsystemServiceRegistrar().update(this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				// noop
commit:1c9c28b
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
0: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
0: 
0: import java.io.BufferedInputStream;
0: import java.io.BufferedOutputStream;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.io.OutputStream;
/////////////////////////////////////////////////////////////////////////
0: import java.util.Locale;
0: import java.util.zip.ZipEntry;
0: import java.util.zip.ZipInputStream;
0: import org.apache.aries.subsystem.core.archive.SubsystemArchive;
0: import org.apache.aries.subsystem.core.resource.SubsystemFileResource;
0: import org.eclipse.equinox.region.RegionDigraph;
0: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.wiring.FrameworkWiring;
0: import org.osgi.service.coordinator.Coordinator;
0: import org.osgi.service.repository.RepositoryContent;
0: public class AriesSubsystem implements Subsystem, Resource, RepositoryContent {
0: 	public static final String ROOT_SYMBOLIC_NAME = "org.osgi.service.subsystem.root";
0: 	public static final Version ROOT_VERSION = Version.parseVersion("1.0.0");
0: 	public static final String ROOT_LOCATION = "subsystem://?"
0: 			+ SubsystemConstants.SUBSYSTEM_SYMBOLICNAME + '='
0: 			+ ROOT_SYMBOLIC_NAME + '&' + SubsystemConstants.SUBSYSTEM_VERSION
0: 			+ '=' + ROOT_VERSION;
0: 	
0: 	private static final Map<String, AriesSubsystem> locationToSubsystem = Collections.synchronizedMap(new HashMap<String, AriesSubsystem>());
0: 	private static final Map<Resource, Set<AriesSubsystem>> resourceToSubsystems = Collections.synchronizedMap(new HashMap<Resource, Set<AriesSubsystem>>());
0: 	static synchronized Collection<AriesSubsystem> getSubsystems(Resource resource) {
0: 		// TODO Does this need to be a copy? Unmodifiable?
0: 		Collection<AriesSubsystem> result = resourceToSubsystems.get(resource);
0: 		if (result == null)
0: 			return Collections.emptyList();
0: 		return result;
0: 	}
0: 	
0: 	private static void copyContent(InputStream content, File destination) throws IOException {
0: 		copyContent(
0: 				new BufferedInputStream(content),
0: 				new BufferedOutputStream(new FileOutputStream(destination)));
0: 	}
0: 	
0: 	private static void copyContent(InputStream content, OutputStream destination) throws IOException {
0: 		// TODO What's the optimal byte array size? Put this in a constant?
0: 		byte[] bytes = new byte[2048];
0: 		int read;
0: 		try {
0: 			while ((read = content.read(bytes)) != -1)
0: 				destination.write(bytes, 0, read);
0: 		}
0: 		finally {
0: 			try {
0: 				destination.close();
0: 			}
0: 			catch (IOException e) {}
0: 			try {
0: 				content.close();
0: 			}
0: 			catch (IOException e) {}
0: 		}
0: 	}
0: 	
0: 	private static void unzipContent(File content, File destination) throws IOException {
0: 		unzipContent(
0: 				new BufferedInputStream(new FileInputStream(content)),
0: 				destination);
0: 	}
0: 	
0: 	private static void unzipContent(InputStream content, File destination) throws IOException {
0: 		ZipInputStream zis = new ZipInputStream(content);
0: 		try {
0: 			ZipEntry entry;
0: 			while ((entry = zis.getNextEntry()) != null) {
0: 				try {
0: 					File file = new File(destination, entry.getName());
0: 					if (entry.isDirectory()) {
0: 						if (!file.exists() && !file.mkdirs())
0: 							throw new SubsystemException("Failed to create resource directory: " + file);
0: 					}
0: 					// TODO Let's just overwrite any existing resources for now.
0: //					else if (file.exists())
0: //						throw new SubsystemException("Resource already exists: " + file);
0: 					else {
0: 						OutputStream fos = new FileOutputStream(file);
0: 						try {
0: 							byte[] bytes = new byte[2048];
0: 							int read;
0: 							while ((read = zis.read(bytes)) != -1)
0: 								fos.write(bytes, 0, read);
0: 						}
0: 						finally {
0: 							try {
0: 								fos.close();
0: 							}
0: 							catch (IOException e) {}
0: 						}
0: 					}
0: 				}
0: 				finally {
0: 					try {
0: 						zis.closeEntry();
0: 					}
0: 					catch (IOException e) {}
0: 				}
0: 			}
0: 		}
0: 		finally {
0: 			try {
0: 				zis.close();
0: 			}
0: 			catch (IOException e) {}
0: 		}
0: 	}
0: 
0: 		LOGGER.debug(LOG_ENTRY, "deleteFile", file);
0: 		LOGGER.debug("Deleting file {}", file);
0: 		if (!file.delete())
0: 			LOGGER.warn("Unable to delete file {}", file);
0: 		LOGGER.debug(LOG_EXIT, "deleteFile");
/////////////////////////////////////////////////////////////////////////
0: 	private final SubsystemArchive archive;
0: 	private final Set<Resource> constituents = Collections.synchronizedSet(new HashSet<Resource>());
0: 	private final File directory;
0: 	private final SubsystemEnvironment environment;
0: 	private final ArrayList<AriesSubsystem> parents = new ArrayList<AriesSubsystem>();
0: 	private final Region region;
0: 	 
0: 		// Create the root subsystem.
0: 		LOGGER.debug(LOG_ENTRY, "init");
0: 		region = createRegion(null);
0: 		setState(State.ACTIVE);
0: 		environment = new SubsystemEnvironment(this);
0: 		// TODO The directory field is kept separate from the archive so that it can be referenced
0: 		// by any embedded child subsystems during archive initialization. See the constructors.
0: 		directory = Activator.getInstance().getBundleContext().getDataFile("");
0: 		archive = new SubsystemArchive(directory);
0: 		// TODO The creation of the subsystem manifest is in two places. See other constructor.
0: 		SubsystemManifest manifest = archive.getSubsystemManifest();
0: 		if (manifest == null) {
0: 			// This is the first time the root subsystem has been initialized in this framework or
0: 			// a framework clean start was requested.
0: 			SubsystemUri uri = new SubsystemUri(ROOT_LOCATION);
0: 			manifest = SubsystemManifest.newInstance(uri.getSymbolicName(), uri.getVersion(), archive.getResources());
0: 			archive.setSubsystemManifest(manifest);
0: 		}
0: 		else
0: 			// Need to generate a new subsystem manifest in order to generated a new deployment manifest based
0: 			// on any persisted resources.
0: 			manifest = SubsystemManifest.newInstance(getSymbolicName(), getVersion(), archive.getResources());
0: 		archive.setDeploymentManifest(DeploymentManifest.newInstance(manifest, environment));
0: 		StaticDataFile sdf = archive.getStaticDataFile();
0: 		LOGGER.debug("Data file: {}", sdf);
0: 		if (sdf != null) {
0: 			lastId = sdf.getLastSubsystemId();
0: 		}
0: 		LOGGER.debug("Last ID will start at {}", lastId);
0: 		// TODO Begin proof of concept.
0: 		// This is a proof of concept for initializing the relationships between the root subsystem and bundles
0: 		// that already existed in its region. Not sure this will be the final resting place. Plus, there are issues
0: 		// since this does not take into account the possibility of already existing bundles going away or new bundles
0: 		// being installed out of band while this initialization is taking place. Need a bundle event hook for that.
0: 		BundleContext context = Activator.getInstance().getBundleContext();
0: 		for (long id : region.getBundleIds()) {
0: 			BundleRevision br = context.getBundle(id).adapt(BundleRevision.class);
0: 			Set<AriesSubsystem> s = resourceToSubsystems.get(br);
0: 			if (s == null) {
0: 				s = new HashSet<AriesSubsystem>();
0: 				resourceToSubsystems.put(br, s);
0: 			}
0: 			// TODO Escaping 'this' reference.
0: 			s.add(this);
0: 			// TODO What the heck is going on here? Don't we need to add the bundle revision
0: 			// as a constituent as well?
0: 		}
0: 		// TODO End proof of concept.
0: 		LOGGER.debug(LOG_EXIT, "init");
0: 	public AriesSubsystem(String location, InputStream content, AriesSubsystem parent) throws Exception {
0: 		// Create a non-root subsystem.
0: 		SubsystemUri uri = null;
0: 		if (location.startsWith("subsystem://"))
0: 			uri = new SubsystemUri(location);
0: 		if (content == null) {
0: 			if (uri != null)
0: 				content = uri.getURL().openStream();
0: 			else
0: 				content = new URL(location).openStream();
0: 			
0: 		}
0: 		this.parents.add(parent);
0: 		String directoryName = "subsystem" + id;
0: 		String fileName = directoryName + ".ssa";
0: 		File zipFile = new File(parent.directory, fileName);
0: 		directory = new File(parent.directory, directoryName);
0: 		if (!directory.mkdir())
0: 			throw new IOException("Unable to make directory for " + directory.getCanonicalPath());
0: 		try {
0: 			copyContent(content, zipFile);
0: 			unzipContent(zipFile, directory);
0: 			archive = new SubsystemArchive(directory);
0: 		}
0: 		catch (Exception e) {
0: 			deleteFile(directory);
0: 			deleteFile(zipFile);
0: 			throw new SubsystemException(e);
0: 		}
0: 		environment = new SubsystemEnvironment(this);
0: 		if (archive.getSubsystemManifest() == null) {
0: 			// TODO Since it's optional to use the subsystem URI, it might be
0: 			// better to create the URI in a try/catch block and throw an
0: 			// exception with a message indicating we received a subsystem
0: 			// with no manifest and no subsystem URI.
0: 			archive.setSubsystemManifest(SubsystemManifest.newInstance(
0: 					uri.getSymbolicName(), 
0: 					uri.getVersion(), 
0: 					archive.getResources()));
0: 			// TODO If the subsystem manifest is not null, need to provide default headers if subsystem URI was used.
0: 		}
0: 		region = createRegion(getSymbolicName() + ';' + getVersion());
0: 	public AriesSubsystem(SubsystemArchive archive, AriesSubsystem parent) throws Exception {
0: 		this.archive = archive;
0: 		DataFile data = archive.getDataFile();
0: 		if (data == null)
0: 			throw new IllegalArgumentException("Missing data file");
0: 		this.location = data.getLocation();
0: 		this.parents.add(parent);
0: 		id = data.getSubsystemId();
0: 		String directoryName = "subsystem" + id;
0: //		String fileName = directoryName + ".ssa";
0: 		directory = new File(parent.directory, directoryName);
0: //		if (!directory.mkdir())
0: //			throw new IOException("Unable to make directory for "
0: //					+ directory.getCanonicalPath());
0: //		File zipFile = new File(directory, fileName);
0: //		try {
0: //			copyContent(content, zipFile);
0: //			unzipContent(zipFile);
0: //			archive = new SubsystemArchive(directory);
0: //		} catch (Exception e) {
0: //			deleteFile(directory);
0: //			deleteFile(zipFile);
0: //			throw new SubsystemException(e);
0: //		}
0: 		environment = new SubsystemEnvironment(this);
0: //		if (archive.getSubsystemManifest() == null) {
0: //			// TODO Since it's optional to use the subsystem URI, it might be
0: //			// better to create the URI in a try/catch block and throw an
0: //			// exception with a message indicating we received a subsystem
0: //			// with no manifest and no subsystem URI.
0: //			archive.setSubsystemManifest(SubsystemManifest.newInstance(
0: //					uri.getSymbolicName(), uri.getVersion(),
0: //					archive.getResources()));
0: //			// TODO If the subsystem manifest is not null, need to provide
0: //			// default headers if subsystem URI was used.
0: //		}
0: 		region = createRegion(data.getRegionName());
0: //	public AriesSubsystem(File content, AriesSubsystem parent) throws Exception {
0: //		// Create a non-root, persisted subsystem.
0: //		if (!content.isDirectory())
0: //			throw new IllegalArgumentException(content.getCanonicalPath());
0: //		this.parents.add(parent);
0: //		directory = content;
0: //		// TODO The following call leads to a potentially dangerous escaping 'this' reference to this subsystem
0: //		// (as the parent) if there is an embedded subsystem archive within this subsystem's archive.
0: //		// Need to investigate.
0: //		archive = new SubsystemArchive(directory);
0: //		environment = new SubsystemEnvironment(this);
0: //		DataFile data = archive.getDataFile();
0: //		id = data.getSubsystemId();
0: //		location = data.getLocation();
0: //		ServiceProvider sp = Activator.getInstance().getServiceProvider();
0: //		RegionDigraph digraph = sp.getService(RegionDigraph.class);
0: //		region = digraph.getRegion(data.getRegionName());
0: //	}
0: 	
0: 	public SubsystemArchive getArchive() {
0: 	public BundleContext getBundleContext() {
0: 		// TODO Auto-generated method stub
0: 		return null;
0: 	}
0: 	
0: 	@Override
0: 		// TODO Need to filter by namespace.
/////////////////////////////////////////////////////////////////////////
0: 			BundleContext context = Activator.getInstance().getBundleContext();
0: 				resources.add(context.getBundle(bundleId).adapt(BundleRevision.class));
0: 	public InputStream getContent() throws IOException {
0: 		// TODO Assumes original archive location remains valid. Might want to
0: 		// copy zipped archive to subsystem directory as well as extracted contents.
0: 		return new URL(location).openStream();
/////////////////////////////////////////////////////////////////////////
0: 	public Collection<Subsystem> getParents() {
0: 		return Collections.unmodifiableCollection(new ArrayList<Subsystem>(parents));
/////////////////////////////////////////////////////////////////////////
0: 	public synchronized Subsystem.State getState() {
0: 	
0: 	@Override
0: 	public Map<String, String> getSubsystemHeaders(Locale locale) {
0: 		Collection<Header> headers = archive.getSubsystemManifest().getHeaders();
0: 		Map<String, String> result = new HashMap<String, String>(headers.size());
0: 		for (Header header : headers) {
0: 			String value = header.getValue();
0: 			result.put(header.getName(), value);
0: 		}
0: 		return result;
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 		if (isRoot())
0: 	
0: 	@Override
0: 	public String getType() {
0: 		return getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_TYPE);
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 	public Subsystem install(String location, InputStream content) throws SubsystemException {
0: 		try {
0: 			AriesSubsystem subsystem = locationToSubsystem.get(location);
0: 			if (subsystem != null)
0: 				return subsystem;
0: 			subsystem = new AriesSubsystem(location, content, this);
0: 			Coordination coordination = Activator.getInstance().getServiceProvider().getService(Coordinator.class).create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 			try {
0: 				installSubsystemResource(subsystem, coordination, false);
0: 				return subsystem;
0: 			catch (Exception e) {
0: 				coordination.fail(e);
0: 				throw e;
0: 			}
0: 			finally {
0: 				coordination.end();
0: 			}
0: 		}
0: 		catch (Exception e) {
0: 			LOGGER.error("Subsystem failed to install: " + location, e);
0: 			throw new SubsystemException(e);
0: 		}
0: 		finally {
0: 			if (content != null) {
0: 				try {
0: 					content.close();
0: 				}
0: 				catch (IOException e) {}
0: 			}
0: 		}
0: 		return !isRoot() && "osgi.application".equals(archive.getSubsystemManifest().getSubsystemType().getValue());
0: 		return !isRoot() && "osgi.composite".equals(archive.getSubsystemManifest().getSubsystemType().getValue());
0: 		return !isRoot() && "osgi.feature".equals(archive.getSubsystemManifest().getSubsystemType().getValue());
/////////////////////////////////////////////////////////////////////////
0: 		if (state == State.INSTALLING || state == State.RESOLVING || state == State.STOPPING) {
0: 		// TODO Should we wait on STARTING to see if the outcome is ACTIVE?
0: 		// Resolve the subsystem, if necessary.
0: 			resolve();
0: 		setState(State.STARTING);
0: 		// TODO Need to hold a lock here to guarantee that another start
0: 		// operation can't occur when the state goes to RESOLVED.
0: 		// Start the subsystem.
0: 		Coordination coordination = Activator.getInstance()
0: 				.getServiceProvider().getService(Coordinator.class)
0: 				.create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 		try {
0: 			// TODO Need to make sure the constituents are ordered by start level.
0: 			for (Resource resource : constituents) {
0: 				startResource(resource, coordination);
0: 			setState(State.ACTIVE);
0: //			persist(State.ACTIVE);
0: 		} catch (Exception e) {
0: 			coordination.fail(e);
0: 			// TODO Need to reinstate complete isolation by disconnecting the
0: 			// region and transition to INSTALLED.
0: 		} finally {
0: 			try {
0: 				coordination.end();
0: 			} catch (CoordinationException e) {
0: 				LOGGER.error(
0: 						"An error occurred while starting in a resource in subsystem "
0: 								+ this, e);
0: 				setState(State.RESOLVED);
0: 			}
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 			throw new SubsystemException("Cannot stop from state " + getState());
/////////////////////////////////////////////////////////////////////////
0: 		for (Resource resource : constituents) {
0: 			try {
0: 				stopResource(resource);
0: 			} catch (Exception e) {
0: 				LOGGER.error("An error occurred while stopping resource "
0: 						+ resource + " of subsystem " + this, e);
0: 				// TODO Should FAILED go out for each failure?
0: 		}
0: 		// TODO Can we automatically assume it actually is resolved?
0: 		setState(State.RESOLVED);
0: //		try {
0: //			persist(State.RESOLVED);
0: //		}
0: //		catch (IOException e) {
0: //			throw new SubsystemException(e);
0: //		}
/////////////////////////////////////////////////////////////////////////
0: 		else if (state == State.INSTALLING || state == State.RESOLVING || state == State.STARTING || state == State.STOPPING) {
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator<Resource> iterator = constituents.iterator(); iterator.hasNext();) {
0: 			Resource resource = iterator.next();
0: 			try {
0: 				uninstallResource(resource);
0: 			catch (Exception e) {
0: 				LOGGER.error("An error occurred while uninstalling resource " + resource + " of subsystem " + this, e);
0: 				// TODO Should FAILED go out for each failure?
0: 			}
0: 			iterator.remove();
0: 		}
0: 		for (AriesSubsystem parent : parents)
0: 			parent.children.remove(AriesSubsystem.this);
0: 		locationToSubsystem.remove(location);
0: 		deleteFile(directory);
0: 		setState(State.UNINSTALLED);
/////////////////////////////////////////////////////////////////////////
0: 	Region getRegion() {
0: 		return region;
0: 	}
0: 	
0: 	void install() throws Exception {
0: 		List<Resource> contentResources = new ArrayList<Resource>();
0: 		List<Resource> transitiveDependencies = new ArrayList<Resource>();
0: 		DeploymentManifest manifest = getDeploymentManifest();
0: 		DeployedContentHeader contentHeader = manifest.getDeployedContent();
0: 		if (contentHeader != null) {
0: 			for (DeployedContent content : contentHeader.getDeployedContents()) {
0: 				Collection<Capability> capabilities = environment.findProviders(
0: 						new OsgiIdentityRequirement(content.getName(), content.getDeployedVersion(), content.getNamespace(), false));
0: 				if (capabilities.isEmpty())
0: 					throw new SubsystemException("Subsystem content resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: 				Resource resource = capabilities.iterator().next().getResource();
0: 				contentResources.add(resource);
0: 			}
0: 		}
0: 		ProvisionResourceHeader resourceHeader = manifest.getProvisionResource();
0: 		if (resourceHeader != null) {
0: 			for (ProvisionedResource content : resourceHeader.getProvisionedResources()) {
0: 				Collection<Capability> capabilities = environment.findProviders(
0: 						new OsgiIdentityRequirement(content.getName(), content.getDeployedVersion(), content.getNamespace(), true));
0: 				if (capabilities.isEmpty())
0: 					throw new SubsystemException("Subsystem provisioned resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: 				Resource resource = capabilities.iterator().next().getResource();
0: 				transitiveDependencies.add(resource);
0: 			}
0: 		}
0: 		// Install content resources and transitive dependencies.
0: 		if (!contentResources.isEmpty()) {
0: 			Coordination coordination = Activator.getInstance().getServiceProvider().getService(Coordinator.class).create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 			try {
0: 				// Install the content resources.
0: 				for (Resource resource : contentResources) {
0: 					installResource(resource, coordination, false);
0: 				}
0: 				// Discover and install transitive dependencies.
0: 				for (Resource resource : transitiveDependencies) {
0: 					installResource(resource, coordination, true);
0: 				}
0: 			}
0: 			catch (Exception e) {
0: 				// TODO Log this exception? If not, who's responsible for logging it?
0: 				LOGGER.error("Failed to install subsystem", e);
0: 				coordination.fail(e);
0: 				throw e;
0: 			}
0: 			finally {
0: 				coordination.end();
0: 			}
0: 		}
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 		// TODO Need to update service registration properties so that a
0: 		// ServiceEvent goes out with the updated state.
0: 		// The archive will be null if this is the root subsystem.
0: 		if (archive != null) {
0: 			// If necessary, update this subsystem's data file to honor start and stop requests.
0: 			if (EnumSet.of(State.INSTALLED, State.RESOLVED, State.ACTIVE).contains(state)) {
0: 				DataFile data = new DataFile(location, region.getName(), state, id);
0: 				try {
0: 					archive.setDataFile(data);
0: 				}
0: 				catch (IOException e) {
0: 					throw new SubsystemException(e);
0: 				}
0: 			}
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 	private Region createRegion(String name) throws BundleException {
0: 		if (name == null)
0: 			return Activator.getInstance().getServiceProvider().getService(RegionDigraph.class).getRegion(Activator.getInstance().getBundleContext().getBundle());
0: 		Region region = Activator.getInstance().getServiceProvider().getService(RegionDigraph.class).getRegion(name);
0: 		if (region == null)
0: 			return Activator.getInstance().getServiceProvider().getService(RegionDigraph.class).createRegion(name);
0: 		return region;
/////////////////////////////////////////////////////////////////////////
0: 	private DeploymentManifest getDeploymentManifest() throws IOException {
0: 		if (archive.getDeploymentManifest() == null) {
0: 			archive.setDeploymentManifest(DeploymentManifest.newInstance(archive.getSubsystemManifest(), environment));
0: 		}
0: 		return archive.getDeploymentManifest();
0: 	}
0: 	
0: 			while (!provisionTo.parents.isEmpty())
0: 				provisionTo = provisionTo.parents.get(0);
0: 			while (provisionTo.isFeature())
0: 				provisionTo = provisionTo.parents.get(0);
/////////////////////////////////////////////////////////////////////////
0: 				InputStream content = ((RepositoryContent)resource).getContent();
0: 				Bundle bundle = provisionTo.region.installBundle(location, content);
0: 			Set<AriesSubsystem> subsystems = resourceToSubsystems.get(revision);
0: 				subsystems = new HashSet<AriesSubsystem>();
/////////////////////////////////////////////////////////////////////////
0: 					Set<AriesSubsystem> subsystems = resourceToSubsystems.get(revision);
/////////////////////////////////////////////////////////////////////////
0: 	private void installResource(Resource resource, Coordination coordination, boolean transitive) throws Exception {
0: 		if (SubsystemConstants.IDENTITY_TYPE_SUBSYSTEM.equals(type))
/////////////////////////////////////////////////////////////////////////
0: 	private void installSubsystemResource(Resource resource, Coordination coordination, boolean transitive) throws Exception {
0: 		if (resource instanceof AriesSubsystem) {
0: 			subsystem = (AriesSubsystem)resource;
0: 			locationToSubsystem.put(subsystem.getLocation(), subsystem);
0: 		else if (resource instanceof SubsystemFileResource) {
0: 			SubsystemFileResource sfr = (SubsystemFileResource)resource;
0: 			subsystem = (AriesSubsystem)install(sfr.getLocation(), sfr.getContent());
0: 			return;
0: 		}
0: 		else {
0: 			SubsystemArchive archive = (SubsystemArchive)resource;
0: 			subsystem = new AriesSubsystem(archive, this);
0: 			locationToSubsystem.put(subsystem.getLocation(), subsystem);
0: 		}
0: 		subsystem.setState(State.INSTALLING);
0: 		Set<AriesSubsystem> subsystems = new HashSet<AriesSubsystem>();
0: 		subsystems.add(this);
0: 		resourceToSubsystems.put(subsystem, subsystems);
0: 		children.add(subsystem);
0: 		constituents.add(subsystem);
0: 		subsystem.install();
0: 				subsystem.setState(State.INSTALLED);
0: 				constituents.remove(subsystem);
0: 				children.remove(subsystem);
0: 				Set<AriesSubsystem> subsystems = resourceToSubsystems.get(subsystem);
0: 				subsystems.remove(AriesSubsystem.this);
0: 				if (subsystems.isEmpty())
0: 					resourceToSubsystems.remove(subsystem);
0: 				locationToSubsystem.remove(location);
0: 				subsystem.setState(State.INSTALL_FAILED);
/////////////////////////////////////////////////////////////////////////
0: 	private void resolve() {
0: 		setState(State.RESOLVING);
0: 		try {
0: 			setImportIsolationPolicy();
0: 			// TODO I think this is insufficient. Do we need both
0: 			// pre-install and post-install environments for the Resolver?
0: 			Collection<Bundle> bundles = getBundles();
0: 			if (!Activator.getInstance().getBundleContext().getBundle(0)
0: 					.adapt(FrameworkWiring.class).resolveBundles(bundles)) {
0: 				LOGGER.error(
0: 						"Unable to resolve bundles for subsystem/version/id {}/{}/{}: {}",
0: 						new Object[] { getSymbolicName(), getVersion(),
0: 								getSubsystemId(), bundles });
0: 				// TODO SubsystemException?
0: 				throw new SubsystemException("Framework could not resolve the bundles");
0: 			}
0: 			setExportIsolationPolicy();
0: 			// TODO Could avoid calling setState (and notifyAll) here and
0: 			// avoid the need for a lock.
0: 			setState(State.RESOLVED);
0: 		} catch (Exception e) {
0: 			setState(State.INSTALLED);
0: 			throw new SubsystemException(e);
0: 		}
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 					parents.get(0).region, 
/////////////////////////////////////////////////////////////////////////
0: 	private void startResource(Resource resource, Coordination coordination) throws BundleException, IOException {
/////////////////////////////////////////////////////////////////////////
0: 	private void startSubsystemResource(Resource resource, Coordination coordination) throws IOException {
0: 		final AriesSubsystem subsystem = (AriesSubsystem)resource;
/////////////////////////////////////////////////////////////////////////
0: 	private void stopResource(Resource resource) throws BundleException, IOException {
/////////////////////////////////////////////////////////////////////////
0: 	private void stopSubsystemResource(Resource resource) throws IOException {
0: 		((AriesSubsystem)resource).stop();
0: 		LOGGER.debug(LOG_ENTRY, "uninstallBundleResource", resource);
0: 		Bundle bundle = null;
0: 			Set<AriesSubsystem> subsystems = resourceToSubsystems.get(resource);
0: 			if (LOGGER.isDebugEnabled())
0: 				LOGGER.debug("Subsystems that currently have {} as a constituent: {}", new Object[]{resource, subsystems});
0: 			if (subsystems.isEmpty()) {
0: 				resourceToSubsystems.remove(resource);
0: 				bundle = ((BundleRevision)resource).getBundle();
0: 		if (bundle != null) {
0: 			LOGGER.debug("Uninstalling bundle {}", bundle);
0: 			bundle.uninstall();
0: 		}
0: 		LOGGER.debug(LOG_EXIT, "uninstallBundleResource");
0: 		if (LOGGER.isDebugEnabled()) {
0: 			LOGGER.debug(LOG_ENTRY, "uninstallResource", resource);
0: 			LOGGER.debug("Subsystem {} is uninstalling resource {};{};{}", new Object[]{
0: 					getSymbolicName(),
0: 					ResourceHelper.getSymbolicNameAttribute(resource),
0: 					ResourceHelper.getVersionAttribute(resource),
0: 					ResourceHelper.getTypeAttribute(resource)
0: 			});
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 		LOGGER.debug(LOG_EXIT, "uninstallResource");
0: 			Set<AriesSubsystem> subsystems = resourceToSubsystems.get(resource);
0: 		((AriesSubsystem)resource).uninstall();
commit:0c3bb10
/////////////////////////////////////////////////////////////////////////
0: 		// Transitive resources always become constituents of the subsystem to which they were provisioned.
0: 		if (transitive)
0: 			return provisionTo;
0: 		// Non-transitive resources become constituents of the subsystem in which they were declared.
0: 		return this;
/////////////////////////////////////////////////////////////////////////
0: 	/*private*/ synchronized void initialize(InputStream content) throws BundleException, IOException, URISyntaxException {
0: 		// TODO Begin proof of concept.
0: 		// This is a proof of concept for initializing the relationships between the root subsystem and bundles
0: 		// that already existed in its region. Not sure this will be the final resting place. Plus, there are issues
0: 		// since this does not take into account the possibility of already existing bundles going away or new bundles
0: 		// being installed out of band while this initialization is taking place. Need a bundle event hook for that.
0: 		if (isRoot()) {
0: 			for (long id : region.getBundleIds()) {
0: 				BundleRevision br = Activator.getBundleContext().getBundle(id).adapt(BundleRevision.class);
0: 				synchronized (resourceToSubsystems) {
0: 					Set<Subsystem> s = resourceToSubsystems.get(br);
0: 					if (s == null) {
0: 						s = new HashSet<Subsystem>();
0: 						resourceToSubsystems.put(br, s);
0: 					}
0: 					s.add(this);
0: 				}
0: 			}
0: 			return;
0: 		}
0: 		// TODO End proof of concept.
/////////////////////////////////////////////////////////////////////////
0: 		AriesSubsystem provisionTo = null;
0: 		final BundleRevision revision;
0: 			provisionTo = getProvisionTo(resource, transitive);
0: 				revision = (BundleRevision)resource;
0: 			else {
0: 				URL content = environment.getContent(resource);
0: 				String location = provisionTo.getSubsystemId() + '@' + provisionTo.getSymbolicName() + '@' + content;
0: 				Bundle bundle = provisionTo.region.installBundle(location, content.openStream());
0: 				revision = bundle.adapt(BundleRevision.class);
0: 			}
0: 			// TODO The null check is necessary for when the bundle is in the root subsystem. Currently, the root subsystem is not initialized with
0: 			// these relationships. Need to decide if that would be better.
0: 			Set<Subsystem> subsystems = resourceToSubsystems.get(revision);
0: 			if (subsystems == null) {
0: 				subsystems = new HashSet<Subsystem>();
0: 				resourceToSubsystems.put(revision, subsystems);
0: 			}
0: 						revision.getBundle().uninstall();
/////////////////////////////////////////////////////////////////////////
0: 			resourceToSubsystems.remove(resource);
commit:046b8ec
/////////////////////////////////////////////////////////////////////////
0: 				// TODO Log this exception? If not, who's responsible for logging it?
/////////////////////////////////////////////////////////////////////////
0: 				// This means the resource is a bundle that's already been installed, but we still need to establish the resource->subsystem relationship.
0: 				// TODO The null check is necessary for when the bundle is in the root subsystem. Currently, the root subsystem is not initialized with
0: 				// these relationships. Need to decide if that would be better.
0: 				Set<Subsystem> subsystems = resourceToSubsystems.get(resource);
0: 				if (subsystems == null) {
0: 					subsystems = new HashSet<Subsystem>();
0: 					resourceToSubsystems.put(resource, subsystems);
0: 				}
0: 				subsystems.add(this);
commit:ead9c04
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.resource.Capability;
0: import org.osgi.framework.resource.Requirement;
0: import org.osgi.framework.resource.Resource;
0: import org.osgi.framework.resource.ResourceConstants;
/////////////////////////////////////////////////////////////////////////
0: 	private static void postEvent(Subsystem subsystem, SubsystemConstants.EVENT_TYPE type) {
0: 	private static void postEvent(Subsystem subsystem, SubsystemConstants.EVENT_TYPE type, Throwable t) {
0: 			map.put(SubsystemConstants.EVENT_SUBSYSTEM_ID, subsystem.getSubsystemId());
0: 			map.put(SubsystemConstants.EVENT_SUBSYSTEM_LOCATION, subsystem.getLocation());
/////////////////////////////////////////////////////////////////////////
0: 			archive.setDeploymentManifest(DeploymentManifest.newInstance(archive, environment));
/////////////////////////////////////////////////////////////////////////
0: 		postEvent(subsystem, SubsystemConstants.EVENT_TYPE.INSTALLING);
/////////////////////////////////////////////////////////////////////////
0: 					postEvent(subsystem, SubsystemConstants.EVENT_TYPE.INSTALLED);
0: 					LOGGER.error("Failed to install subsystem: " + subsystem, e);
0: 					postEvent(subsystem, SubsystemConstants.EVENT_TYPE.FAILED, e);
0: 					postEvent(subsystem, SubsystemConstants.EVENT_TYPE.UNINSTALLED);
/////////////////////////////////////////////////////////////////////////
0: 			postEvent(this, SubsystemConstants.EVENT_TYPE.RESOLVING);
0: 			postEvent(this, SubsystemConstants.EVENT_TYPE.STARTING);
/////////////////////////////////////////////////////////////////////////
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.RESOLVED);
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.STARTING);
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.FAILED, e);
/////////////////////////////////////////////////////////////////////////
0: 					postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.STARTED);
/////////////////////////////////////////////////////////////////////////
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.FAILED, e);
/////////////////////////////////////////////////////////////////////////
0: 		postEvent(this, SubsystemConstants.EVENT_TYPE.STOPPING);
/////////////////////////////////////////////////////////////////////////
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.FAILED, e);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.STOPPED);
/////////////////////////////////////////////////////////////////////////
0: 		postEvent(this, SubsystemConstants.EVENT_TYPE.UNINSTALLING);
/////////////////////////////////////////////////////////////////////////
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.FAILED, e);
/////////////////////////////////////////////////////////////////////////
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EVENT_TYPE.UNINSTALLED);
commit:4717af0
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URISyntaxException;
0: import java.util.Arrays;
0: import java.util.Iterator;
0: import org.apache.aries.subsystem.core.ResourceHelper;
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.wiring.BundleRevision;
0: import org.osgi.framework.wiring.Requirement;
0: import org.osgi.framework.wiring.ResourceConstants;
0: import org.osgi.service.coordinator.Participant;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: public class AriesSubsystem implements Subsystem, Resource {
0: 	private static final Logger LOGGER = LoggerFactory.getLogger(AriesSubsystem.class);
0: 	private static final Map<String, AriesSubsystem> locationToSubsystem = new HashMap<String, AriesSubsystem>();
0: 	private static final Map<Resource, Set<Subsystem>> resourceToSubsystems = new HashMap<Resource, Set<Subsystem>>();
0: 	
0: 	static synchronized Collection<AriesSubsystem> getSubsystems(Resource resource) {
0: 		ArrayList<AriesSubsystem> result = new ArrayList<AriesSubsystem>(locationToSubsystem.size());
0: 		for (AriesSubsystem subsystem : locationToSubsystem.values()) {
0: 			if (subsystem.contains(resource)) {
0: 				result.add(subsystem);
0: 			}
0: 		}
0: 		result.trimToSize();
0: 		return result;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 			try {
0: 				map.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, subsystem.getSymbolicName());
0: 			}
0: 			catch (IllegalStateException e) {}
0: 			try {
0: 				map.put(SubsystemConstants.SUBSYSTEM_VERSION, String.valueOf(subsystem.getVersion()));
0: 			}
0: 			catch (IllegalStateException e) {}
/////////////////////////////////////////////////////////////////////////
0: 	private final Set<AriesSubsystem> children = Collections.synchronizedSet(new HashSet<AriesSubsystem>());
0: 	private Archive archive;
0: 	private Region region;
/////////////////////////////////////////////////////////////////////////
0: 	private AriesSubsystem(String location, /*InputStream content,*/ AriesSubsystem parent) /*throws Exception*/ {
/////////////////////////////////////////////////////////////////////////
0: 	public synchronized Archive getArchive() {
0: 	@Override
0: 	public List<Capability> getCapabilities(String namespace) {
0: 		Capability capability = new OsgiIdentityCapability(this, getSymbolicName(), getVersion(), "osgi.subsystem");
0: 		return Arrays.asList(new Capability[]{capability});
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0: 		/* 
0: 		 * TODO The definition of constituents needs to be worked out from both a design and implementation perspective.
0: 		 * (1) In general, any Resource type except for osgi.subsystem.
0: 		 * (2) A transitive dependency if this is the root subsystem or provision-policy:=acceptTransitive.
0: 		 * (3) A content Resource of this subsystem if the Resource is not also a subsystem (also, doesn't apply to 
0: 		 *     the root subsystem since it has no content resources).
0: 		 * (4) A bundle Resource installed into a region by means other than the subsystem API (primarily for the 
0: 		 *     root subsystem which shares the kernel region but could apply to any subsystem).
0: 		 * (5) Caution with 4: this does not include feature content resources installed into a non-feature subsystem region. 
0: 		 *     These are constituents of the feature itself.
0: 		 */
0: 		if (isRoot()) {
0: 			// TODO This does not take into account the possibility that resource types other than bundle became part of the root subsystem.
0: 			Set<Long> bundleIds = region.getBundleIds();
0: 			Collection<Resource> resources = new ArrayList<Resource>(bundleIds.size());
0: 			for (Long bundleId : bundleIds)
0: 				resources.add(Activator.getBundleContext().getBundle(bundleId).adapt(BundleRevision.class));
0: 			return resources;
0: 		}
0: 		return Collections.unmodifiableCollection(constituents);
0: 	public DeploymentManifest getDeploymentManifest() throws IOException {
0: 		if (archive.getDeploymentManifest() == null) {
0: 			archive.setDeploymentManifest(DeploymentManifest.newInstance(archive.getSubsystemManifest(), environment));
0: 		}
0: 		return archive.getDeploymentManifest();
0: 	}
0: 	
0: 	public synchronized SubsystemEnvironment getEnvironment() {
/////////////////////////////////////////////////////////////////////////
0: 			if (rb != null && value.startsWith("%")) {
/////////////////////////////////////////////////////////////////////////
0: 
0: 	@Override
0: 	public List<Requirement> getRequirements(String namespace) {
0: 		return Collections.emptyList();
/////////////////////////////////////////////////////////////////////////
0: 			// If the archive is null, this is either the root subsystem or an installing subsystem not yet initialized.
0: 			if (State.INSTALLING.equals(getState()))
0: 				// The root subsystem's state will never be INSTALLING, so this is an uninitialized subsystem.
0: 				throw new IllegalStateException();
0: 			// This is the root subsystem.
/////////////////////////////////////////////////////////////////////////
0: 			// If the archive is null, this is either the root subsystem or an installing subsystem not yet initialized.
0: 			if (State.INSTALLING.equals(getState()))
0: 				// The root subsystem's state will never be INSTALLING, so this is an uninitialized subsystem.
0: 				throw new IllegalStateException();
0: 			// This is the root subsystem.
/////////////////////////////////////////////////////////////////////////
0: 	public synchronized Subsystem install(String location, final InputStream content) throws SubsystemException {
0: 		if (locationToSubsystem.containsKey(location))
0: 			return locationToSubsystem.get(location);
0: 		subsystem = new AriesSubsystem(location, this);
0: 		locationToSubsystem.put(location, subsystem);
0: 		children.add(subsystem);
0: 		constituents.add(subsystem);
0: 					subsystem.initialize(content);
0: 					subsystem.install();
0: 					subsystem.setState(Subsystem.State.INSTALLED);
0: 					postEvent(subsystem, SubsystemConstants.EventType.INSTALLED);
/////////////////////////////////////////////////////////////////////////
0: 	public void removeConstituent(Resource resource) {
0: 		constituents.remove(resource);
/////////////////////////////////////////////////////////////////////////
0: 				// TODO Need to hold a lock here to guarantee that another start operation can't occur when the state goes to RESOLVED.
0: 				// Resolve the subsystem, if necessary.
0: 				if (getState() == State.RESOLVING) { // Otherwise, the state will be STARTING.
0: 					try {
0: 						setImportIsolationPolicy();
0: 						// TODO I think this is insufficient. Do we need both pre-install and post-install environments for the Resolver?
0: 						if (!Activator.getFrameworkWiring().resolveBundles(getBundles())) {
0: 							throw new Exception("Framework could not resolve the bundles");
0: 						}
0: 						setExportIsolationPolicy();
0: 						// TODO Could avoid calling setState (and notifyAll) here and avoid the need for a lock.
0: 						setState(State.RESOLVED);
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EventType.RESOLVED);
0: 						setState(State.STARTING);
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EventType.STARTING);
0: 					}
0: 					catch (Exception e) {
0: 						setState(State.INSTALLED);
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 						return;
0: 					}
0: 				}
0: 				// Start the subsystem.
0: 				Coordination coordination = Activator.getCoordinator().create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 				try {
0: 					// TODO Need to make sure the consitutents are ordered by start level.
0: 					for (Resource resource : constituents) {
0: 						startResource(resource, coordination);
0: 					}
0: 					setState(State.ACTIVE);
0: 					postEvent(AriesSubsystem.this, SubsystemConstants.EventType.STARTED);
0: 				}
0: 				catch (Exception e) {
0: 					coordination.fail(e);
0: 					// TODO Need to reinstate complete isolation by disconnecting the region and transition to INSTALLED.
0: 				}
0: 				finally {
0: 					try {
0: 						coordination.end();
0: 					}
0: 					catch (CoordinationException e) {
0: 						LOGGER.error("An error occurred while starting in a resource in subsystem " + this, e);
0: 						setState(State.RESOLVED);
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 					}
0: 				}
/////////////////////////////////////////////////////////////////////////
0: 				// TODO Persist stop state.
0: 				for (Resource resource : constituents) {
0: 					try {
0: 						stopResource(resource);
0: 					}
0: 					catch (Exception e) {
0: 						LOGGER.error("An error occurred while stopping resource " + resource + " of subsystem " + this, e);
0: 						// TODO Should FAILED go out for each failure?
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 					}
0: 				}
0: 				// TODO Can we automatically assume it actually is resolved?
0: 				setState(State.RESOLVED);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.STOPPED);
/////////////////////////////////////////////////////////////////////////
0: 				for (Iterator<Resource> iterator = constituents.iterator(); iterator.hasNext();) {
0: 					Resource resource = iterator.next();
0: 					try {
0: 						uninstallResource(resource);
0: 					}
0: 					catch (Exception e) {
0: 						LOGGER.error("An error occurred while uninstalling resource " + resource + " of subsystem " + this, e);
0: 						// TODO Should FAILED go out for each failure?
0: 						postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 					}
0: 					iterator.remove();
0: 				}
0: 				parent.children.remove(AriesSubsystem.this);
0: 				locationToSubsystem.remove(location);
0: 				deleteFile(Activator.getBundleContext().getDataFile("subsystem" + id + System.getProperty("file.separator")));
0: 				setState(State.UNINSTALLED);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.UNINSTALLED);
/////////////////////////////////////////////////////////////////////////
0: 			if (resource instanceof BundleRevision)
0: 				result.add(((BundleRevision)resource).getBundle());
/////////////////////////////////////////////////////////////////////////
0: 			// The root subsystem's region should be the same one the subsystem bundle was installed into.
0: 			return Activator.getRegionDigraph().getRegion(Activator.getBundleContext().getBundle());
0: 		if (isFeature())
0: 			// Feature subsystems do not have regions because they are not isolated.
0: 			return null;
0: 		// All other subsystems get a dedicated region for isolation.
0: 	private AriesSubsystem getConstituentOf(Resource resource, AriesSubsystem provisionTo, boolean transitive) {
0: 		// Application and composite resources become constituents of the application or composite.
0: 		AriesSubsystem constituentOf;
0: 		if (transitive) {
0: 			// Transitive dependencies become constituents of the subsystem into which they were provisioned.
0: 			constituentOf = provisionTo;
0: 		} 
0: 		else {
0: 			// All other resources become constituents of the subsystem in which they were declared.
0: 			constituentOf = this;
0: 		return constituentOf;
0: 	private AriesSubsystem getProvisionTo(Resource resource, boolean transitive) {
0: 		// Application and composite resources are provisioned into the application or composite.
0: 		AriesSubsystem provisionTo = this;
0: 		if (transitive) {
0: 			// Transitive dependencies should be provisioned into the highest possible level.
0: 			// TODO Assumes root is always the appropriate level.
0: 			while (provisionTo.getParent() != null)
0: 				provisionTo = provisionTo.getParent();
0: 		}
0: 		else {
0: 			if (provisionTo.isFeature())
0: 				// Feature resources should be provisioned into the first parent that's not a feature.
0: 				while (provisionTo.region == null)
0: 					provisionTo = provisionTo.getParent();
0: 		}
0: 		return provisionTo;
0: 	}
0: 	
0: 	private synchronized void initialize(InputStream content) throws BundleException, IOException, URISyntaxException {
0: 		if (content == null)
0: 			content = new URL(location).openStream();
0: 		File rootDirectory = Activator.getBundleContext().getDataFile("");
0: 		File subsystemDirectory = new File(rootDirectory, "subsystem" + id + System.getProperty("file.separator"));
0: 		archive = new Archive(location, subsystemDirectory, content);
0: 		region = createRegion();
0: 		environment = new SubsystemEnvironment(this);
0: 		if (archive.getSubsystemManifest() == null) {
0: 			SubsystemUri uri = new SubsystemUri(location);
0: 			archive.setSubsystemManifest(SubsystemManifest.newInstance(uri.getSymbolicName(), uri.getVersion(), archive.getResources()));
0: 		}
0: 	}
0: 
0: 	private synchronized void install() throws Exception {
0: 		DeploymentManifest manifest = getDeploymentManifest();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					installResource(resource, coordination, false);
0: 					installResource(resource, coordination, true);
/////////////////////////////////////////////////////////////////////////
0: 	private void installBundleResource(Resource resource, Coordination coordination, boolean transitive) throws BundleException, IOException {
0: 		AriesSubsystem provisionTo;
0: 		Bundle bundle;
0: 		synchronized (resourceToSubsystems) {
0: 			if (resource instanceof BundleRevision) {
0: 				resourceToSubsystems.get(resource).add(this);
0: 				return;
0: 			}
0: 			provisionTo = getProvisionTo(resource, transitive);
0: 			URL content = environment.getContent(resource);
0: 			String location = provisionTo.getSubsystemId() + '@' + provisionTo.getSymbolicName() + '@' + content;
0: 			bundle = provisionTo.region.installBundle(location, content.openStream());
0: 			final BundleRevision revision = bundle.adapt(BundleRevision.class);
0: 			Set<Subsystem> subsystems = new HashSet<Subsystem>();
0: 			subsystems.add(this);
0: 			resourceToSubsystems.put(revision, subsystems);
0: 		}
0: 		final AriesSubsystem constituentOf = getConstituentOf(resource, provisionTo, transitive);
0: 		final BundleRevision revision = bundle.adapt(BundleRevision.class);
0: 		coordination.addParticipant(new Participant() {
0: 			public void ended(Coordination coordination) throws Exception {
0: 				constituentOf.constituents.add(revision);
0: 			}
0: 	
0: 			public void failed(Coordination coordination) throws Exception {
0: 				revision.getBundle().uninstall();
0: 				synchronized (resourceToSubsystems) {
0: 					Set<Subsystem> subsystems = resourceToSubsystems.get(revision);
0: 					subsystems.remove(AriesSubsystem.this);
0: 					if (subsystems.isEmpty()) {
0: 						resourceToSubsystems.remove(revision);
0: 					}
0: 				}
0: 			}
0: 		});
0: 	}
0: 
0: 	private void installResource(Resource resource, Coordination coordination, boolean transitive) throws IOException, BundleException {
0: 		String type = ResourceHelper.getTypeAttribute(resource);
0: 		// TODO Add to constants.
0: 		if ("osgi.subsystem".equals(type))
0: 			installSubsystemResource(resource, coordination, transitive);
0: 		else if (ResourceConstants.IDENTITY_TYPE_BUNDLE.equals(type))
0: 			installBundleResource(resource, coordination, transitive);
0: 		else
0: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 	}
0: 
0: 	private void installSubsystemResource(Resource resource, Coordination coordination, boolean transitive) throws IOException {
0: 		final AriesSubsystem subsystem;
0: 		synchronized (resourceToSubsystems) {
0: 			if (resource instanceof Subsystem) {
0: 				resourceToSubsystems.get(resource).add(this);
0: 				return;
0: 			}
0: 			URL content = environment.getContent(resource);
0: 			String location = id + '@' + getSymbolicName() + '@' + content;
0: 			subsystem = (AriesSubsystem)install(location, content.openStream());
0: 			Set<Subsystem> subsystems = new HashSet<Subsystem>();
0: 			subsystems.add(this);
0: 			resourceToSubsystems.put(subsystem, subsystems);
0: 		}
0: 		coordination.addParticipant(new Participant() {
0: 			public void ended(Coordination coordination) throws Exception {
0: 				// noop
0: 			}
0: 	
0: 			public void failed(Coordination coordination) throws Exception {
0: 				subsystem.uninstall();
0: 				synchronized (resourceToSubsystems) {
0: 					Set<Subsystem> subsystems = resourceToSubsystems.get(subsystem);
0: 					subsystems.remove(AriesSubsystem.this);
0: 					if (subsystems.isEmpty()) {
0: 						resourceToSubsystems.remove(subsystem);
0: 					}
0: 				}
0: 			}
0: 		});
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0: 					parent.region, 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	private void startBundleResource(Resource resource, Coordination coordination) throws BundleException {
0: 		final Bundle bundle = ((BundleRevision)resource).getBundle();
0: 		bundle.start(Bundle.START_TRANSIENT);
0: 		if (coordination == null)
0: 			return;
0: 		coordination.addParticipant(new Participant() {
0: 			public void ended(Coordination coordination) throws Exception {
0: 				// noop
0: 	
0: 			public void failed(Coordination coordination) throws Exception {
0: 				bundle.stop();
0: 			}
0: 		});
0: 	}
0: 
0: 	private void startResource(Resource resource, Coordination coordination) throws BundleException {
0: 		String type = ResourceHelper.getTypeAttribute(resource);
0: 		// TODO Add to constants.
0: 		if ("osgi.subsystem".equals(type))
0: 			startSubsystemResource(resource, coordination);
0: 		else if (ResourceConstants.IDENTITY_TYPE_BUNDLE.equals(type))
0: 			startBundleResource(resource, coordination);
0: 		else
0: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 	}
0: 
0: 	private void startSubsystemResource(Resource resource, Coordination coordination) {
0: 		final Subsystem subsystem = (Subsystem)resource;
0: 		subsystem.start();
0: 		if (coordination == null)
0: 			return;
0: 		coordination.addParticipant(new Participant() {
0: 			public void ended(Coordination coordination) throws Exception {
0: 				// noop
0: 			}
0: 	
0: 			public void failed(Coordination coordination) throws Exception {
0: 				subsystem.stop();
0: 			}
0: 		});
0: 	}
0: 
0: 	private void stopBundleResource(Resource resource) throws BundleException {
0: 		((BundleRevision)resource).getBundle().stop();
0: 	}
0: 
0: 	private void stopResource(Resource resource) throws BundleException {
0: 		String type = ResourceHelper.getTypeAttribute(resource);
0: 		// TODO Add to constants.
0: 		if ("osgi.subsystem".equals(type))
0: 			stopSubsystemResource(resource);
0: 		else if (ResourceConstants.IDENTITY_TYPE_BUNDLE.equals(type))
0: 			stopBundleResource(resource);
0: 		else
0: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 	}
0: 
0: 	private void stopSubsystemResource(Resource resource) {
0: 		((Subsystem)resource).stop();
0: 	}
0: 
0: 	private void uninstallBundleResource(Resource resource) throws BundleException {
0: 		synchronized (resourceToSubsystems) {
0: 			Set<Subsystem> subsystems = resourceToSubsystems.get(resource);
0: 			subsystems.remove(this);
0: 			if (!subsystems.isEmpty()) {
0: 			subsystems.remove(resource);
0: 		((BundleRevision)resource).getBundle().uninstall();
0: 
0: 	private void uninstallResource(Resource resource) throws BundleException {
0: 		String type = ResourceHelper.getTypeAttribute(resource);
0: 		// TODO Add to constants.
0: 		if ("osgi.subsystem".equals(type))
0: 			uninstallSubsystemResource(resource);
0: 		else if (ResourceConstants.IDENTITY_TYPE_BUNDLE.equals(type))
0: 			uninstallBundleResource(resource);
0: 		else
0: 			throw new SubsystemException("Unsupported resource type: " + type);
0: 
0: 	private void uninstallSubsystemResource(Resource resource) {
0: 		synchronized (resourceToSubsystems) {
0: 			Set<Subsystem> subsystems = resourceToSubsystems.get(resource);
0: 			subsystems.remove(this);
0: 			if (!subsystems.isEmpty()) {
0: 				return;
0: 			subsystems.remove(resource);
0: 		((Subsystem)resource).uninstall();
commit:226c63f
/////////////////////////////////////////////////////////////////////////
0: 	public void addConstituent(Resource resource) {
0: 		constituents.add(resource);
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isTransitive(Resource resource) {
0: 		SubsystemEnvironment environment = getEnvironment();
0: 		if (environment == null)
0: 			return true;
0: 		return !environment.isContentResource(resource);
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (isRoot())
0: 			return Activator.getRegionDigraph().getRegion(0);
/////////////////////////////////////////////////////////////////////////
0: //			final RuntimeResource runtimeResource;
0: //			if (transitive) {
0: //				AriesSubsystem subsystem = this;
0: //				while (subsystem.parent != null)
0: //					subsystem = subsystem.parent;
0: 				RuntimeResource runtimeResource = new RuntimeResourceFactoryImpl().create(resource, null, this);
0: //				subsystem.constituents.add(runtimeResource);
0: //			}
0: //			else if (region == null) {
0: //				runtimeResource = new RuntimeResourceFactoryImpl().create(resource, null, this);
0: //				runtimeResource.install(coordination);
0: //				constituents.add(runtimeResource);
0: //			}
0: //			else {
0: //				runtimeResource = new RuntimeResourceFactoryImpl().create(resource, null, this);
0: //				runtimeResource.install(coordination);
0: //				constituents.add(runtimeResource);
0: //			}
/////////////////////////////////////////////////////////////////////////
0: 					new OsgiIdentityRequirement(content.getName(), content.getDeployedVersion(), content.getNamespace(), false));
/////////////////////////////////////////////////////////////////////////
0: 						new OsgiIdentityRequirement(content.getName(), content.getDeployedVersion(), content.getNamespace(), true));
/////////////////////////////////////////////////////////////////////////
0: 			// TODO Implement import isolation policy for applications.
0: 			// Applications have an implicit import policy equating to "import everything that I require", which is not the same as features.
0: 			// This must be computed from the application requirements and will be done using the Wires returned by the Resolver, when one is available.
0: 		else if (isComposite()) {
0: 			// TODO Implement import isolation policy for composites.
0: 			// Composites specify an explicit import policy in their subsystem and deployment manifests.
0: 		}
commit:1129914
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.aries.subsystem.core.internal;
0: 
0: import java.io.File;
0: import java.io.InputStream;
0: import java.net.URL;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.EnumSet;
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.MissingResourceException;
0: import java.util.ResourceBundle;
0: import java.util.Set;
0: 
0: import org.apache.aries.subsystem.core.archive.Archive;
0: import org.apache.aries.subsystem.core.archive.DeployedContentHeader;
0: import org.apache.aries.subsystem.core.archive.DeployedContentHeader.DeployedContent;
0: import org.apache.aries.subsystem.core.archive.DeploymentManifest;
0: import org.apache.aries.subsystem.core.archive.Header;
0: import org.apache.aries.subsystem.core.archive.ProvisionResourceHeader;
0: import org.apache.aries.subsystem.core.archive.ProvisionResourceHeader.ProvisionedResource;
0: import org.apache.aries.subsystem.core.archive.SubsystemManifest;
0: import org.apache.aries.subsystem.core.archive.SubsystemSymbolicNameHeader;
0: import org.apache.aries.subsystem.core.archive.VersionHeader;
0: import org.apache.aries.subsystem.core.obr.SubsystemEnvironment;
0: import org.apache.aries.subsystem.core.resource.BundleRuntimeResource;
0: import org.apache.aries.subsystem.core.resource.RuntimeResource;
0: import org.apache.aries.subsystem.core.resource.RuntimeResourceFactoryImpl;
0: import org.eclipse.equinox.region.Region;
0: import org.eclipse.equinox.region.RegionFilter;
0: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleEvent;
0: import org.osgi.framework.BundleException;
0: import org.osgi.framework.Version;
0: import org.osgi.framework.wiring.Capability;
0: import org.osgi.framework.wiring.Resource;
0: import org.osgi.service.coordinator.Coordination;
0: import org.osgi.service.coordinator.CoordinationException;
0: import org.osgi.service.event.Event;
0: import org.osgi.service.event.EventAdmin;
0: import org.osgi.service.event.EventConstants;
0: import org.osgi.service.subsystem.Subsystem;
0: import org.osgi.service.subsystem.SubsystemConstants;
0: import org.osgi.service.subsystem.SubsystemException;
0: 
0: public class AriesSubsystem implements Subsystem {
0: 	public static AriesSubsystem newInstance(String location, InputStream content, AriesSubsystem parent) throws Exception {
0: 		AriesSubsystem subsystem = new AriesSubsystem(location, content, parent);
0: 		Archive archive = subsystem.getArchive();
0: 		subsystem.environment = new SubsystemEnvironment(subsystem);
0: 		if (archive.getSubsystemManifest() == null) {
0: 			SubsystemUri uri = new SubsystemUri(location);
0: 			archive.setSubsystemManifest(SubsystemManifest.newInstance(uri.getSymbolicName(), uri.getVersion(), archive.getResources()));
0: 		}
0: 		if (archive.getDeploymentManifest() == null) {
0: 			archive.setDeploymentManifest(DeploymentManifest.newInstance(archive.getSubsystemManifest(), subsystem.environment));
0: 		}
0: 		return subsystem;
0: 	}
0: 	
0: 	private static final String ROOT_LOCATION = "root";
0: 	private static final String ROOT_SYMBOLIC_NAME = "org.apache.aries.subsystem.root";
0: 	private static final Version ROOT_VERSION = Version.parseVersion("1.0.0");
0: 	
0: 	private static long lastId;
0: 	
0: 	private static void deleteFile(File file) {
0: 		if (file.isDirectory()) {
0: 			deleteFiles(file.listFiles());
0: 		}
0: 		file.delete();
0: 	}
0: 	
0: 	private static void deleteFiles(File[] files) {
0: 		for (File file : files) {
0: 			deleteFile(file);
0: 		}
0: 	}
0: 	
0: 	private synchronized static long getNextId() {
0: 		if (Long.MAX_VALUE == lastId)
0: 			throw new IllegalStateException("The next subsystem ID would exceed Long.MAX_VALUE: " + lastId);
0: 		return ++lastId;
0: 	}
0: 	
0: 	private static void postEvent(Subsystem subsystem, SubsystemConstants.EventType type) {
0: 		postEvent(subsystem, type, null);
0: 	}
0: 	
0: 	private static void postEvent(Subsystem subsystem, SubsystemConstants.EventType type, Throwable t) {
0: 		EventAdmin eventAdmin = Activator.getEventAdmin();
0: 		if (eventAdmin != null) {
0: 			Map<String, Object> map = new HashMap<String, Object>();
0: 			map.put(SubsystemConstants.SUBSYSTEM_ID, subsystem.getSubsystemId());
0: 			map.put(SubsystemConstants.SUBSYSTEM_LOCATION, subsystem.getLocation());
0: 			map.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, subsystem.getSymbolicName());
0: 			map.put(SubsystemConstants.SUBSYSTEM_VERSION, String.valueOf(subsystem.getVersion()));
0: 			// TODO This needs to be defined as a constant.
0: 			map.put("subsystem.state", String.valueOf(subsystem.getState()));
0: 			map.put(EventConstants.TIMESTAMP, System.currentTimeMillis());
0: 			if (t != null) {
0: 				map.put(EventConstants.EXCEPTION, t);
0: 				map.put(EventConstants.EXCEPTION_CLASS, t.getClass().getName());
0: 				map.put(EventConstants.EXCEPTION_MESSAGE, t.getMessage());
0: 			}
0: 			// TODO This needs to be defined as a constant.
0: 			Event event = new Event("org/osgi/service/Subsystem/" + type, map);
0: 			eventAdmin.postEvent(event);
0: 		}
0: 	}
0: 	
0: 	private final Archive archive;
0: 	private final Set<Resource> constituents = Collections.synchronizedSet(new HashSet<Resource>());
0: 	private final Set<AriesSubsystem> children = new HashSet<AriesSubsystem>();
0: 	private volatile SubsystemEnvironment environment;
0: 	private final long id;
0: 	private final String location;
0: 	private final AriesSubsystem parent;
0: 	private final Region region;
0: 	
0: 	private Subsystem.State state;
0: 	
0: 	public AriesSubsystem() throws Exception {
0: 		archive = null;
0: 		id = 0;
0: 		location = ROOT_LOCATION;
0: 		parent = null;
0: 		region = createRegion();
0: 		state = State.ACTIVE;
0: 		// TODO Haven't thought this through yet. Issues?
0: 		environment = null;
0: 	}
0: 	
0: 	private AriesSubsystem(String location, InputStream content, AriesSubsystem parent) throws Exception {
0: 		this.location = location;
0: 		this.parent = parent;
0: 		if (content == null) {
0: 			content = new URL(location).openStream();
0: 		}
0: 		File rootDirectory = Activator.getBundleContext().getDataFile("");
0: 		id = getNextId();
0: 		File subsystemDirectory = new File(rootDirectory, "subsystem" + id + System.getProperty("file.separator"));
0: 		// TODO Leaking reference. Issues?
0: //		environment = new SubsystemEnvironment(this);
0: //		archive = new Archive(location, subsystemDirectory, content, environment);
0: 		archive = new Archive(location, subsystemDirectory, content);
0: 		if (isFeature()) {
0: 			// Features do not have regions.
0: 			region = null;
0: 		}
0: 		else {
0: 			// Applications and composites have regions.
0: 			region = createRegion();
0: 		}
0: 		
0: 	}
0: 	
0: 	@Override
0: 	public void cancel() throws SubsystemException {
0: 		// TODO Auto-generated method stub
0: 	}
0: 	
0: 	public Archive getArchive() {
0: 		return archive;
0: 	}
0: 	
0: 	@SuppressWarnings({ "unchecked", "rawtypes" })
0: 	public Collection<Subsystem> getChildren() {
0: 		return (Collection<Subsystem>)(Collection)Collections.unmodifiableSet(children);
0: 	}
0: 
0: 	@Override
0: 	public Collection<Resource> getConstituents() {
0: 		return Collections.unmodifiableSet(constituents);
0: 	}
0: 	
0: 	public SubsystemEnvironment getEnvironment() {
0: 		return environment;
0: 	}
0: 
0: 	@Override
0: 	public Map<String, String> getHeaders() {
0: 		return getHeaders(null);
0: 	}
0: 
0: 	@Override
0: 	public Map<String, String> getHeaders(String locale) {
0: 		// Archive will be null for the root subsystem.
0: 		if (archive == null)
0: 			return Collections.emptyMap();
0: 		ResourceBundle rb = null;
0: 		if (locale != null && locale.length() != 0) {
0: 			try {
0: 				rb = ResourceBundle.getBundle(locale);
0: 			}
0: 			catch (MissingResourceException e) {}
0: 		}
0: 		Collection<Header> headers = archive.getSubsystemManifest().getHeaders();
0: 		Map<String, String> result = new HashMap<String, String>(headers.size());
0: 		for (Header header : headers) {
0: 			String value = header.getValue();
0: 			if (value.startsWith("%")) {
0: 				value = value.substring(1);
0: 				String translation = null;
0: 				try {
0: 					translation = rb.getString(value);
0: 				}
0: 				catch (MissingResourceException e) {}
0: 				if (translation != null)
0: 					value = translation;
0: 			}
0: 			result.put(header.getName(), value);
0: 		}
0: 		return result;
0: 	}
0: 
0: 	@Override
0: 	public String getLocation() {
0: 		return location;
0: 	}
0: 
0: 	@Override
0: 	public AriesSubsystem getParent() {
0: 		return parent;
0: 	}
0: 	
0: 	public Region getRegion() {
0: 		return region;
0: 	}
0: 
0: 	@Override
0: 	public Subsystem.State getState() {
0: 		return state;
0: 	}
0: 
0: 	@Override
0: 	public long getSubsystemId() {
0: 		return id;
0: 	}
0: 
0: 	@Override
0: 	public String getSymbolicName() {
0: 		if (archive == null) {
0: 			return ROOT_SYMBOLIC_NAME;
0: 		}
0: 		return ((SubsystemSymbolicNameHeader)archive.getSubsystemManifest().getSubsystemSymbolicName()).getSymbolicName();
0: 	}
0: 
0: 	@Override
0: 	public Version getVersion() {
0: 		if (archive == null) {
0: 			return ROOT_VERSION;
0: 		}
0: 		return ((VersionHeader)archive.getSubsystemManifest().getSubsystemVersion()).getVersion();
0: 	}
0: 
0: 	@Override
0: 	public Subsystem install(String location) throws SubsystemException {
0: 		return install(location, null);
0: 	}
0: 	
0: 	@Override
0: 	public Subsystem install(String location, InputStream content) throws SubsystemException {
0: 		final AriesSubsystem subsystem;
0: 		try {
0: 			subsystem = Activator.getSubsystemManager().newSubsystem(location, content, this);
0: 		}
0: 		catch (Exception e) {
0: 			throw new SubsystemException(e);
0: 		}
0: 		children.add(subsystem);
0: 		subsystem.setState(Subsystem.State.INSTALLING);
0: 		postEvent(subsystem, SubsystemConstants.EventType.INSTALLING);
0: 		Activator.getExecutor().execute(new Runnable() {
0: 			public void run() {
0: 				try {
0: 					subsystem.installAsync();
0: 				}
0: 				catch (Exception e) {
0: 					postEvent(subsystem, SubsystemConstants.EventType.FAILED, e);
0: 					subsystem.setState(Subsystem.State.UNINSTALLED);
0: 					postEvent(subsystem, SubsystemConstants.EventType.UNINSTALLED);
0: 				}
0: 			}
0: 		});
0: 		return subsystem;
0: 	}
0: 	
0: 	public boolean isApplication() {
0: 		// TODO Add to constants.
0: 		return "osgi.application".equals(archive.getSubsystemManifest().getSubsystemType().getValue());
0: 	}
0: 	
0: 	public boolean isComposite() {
0: 		// TODO Add to constants.
0: 		return "osgi.composite".equals(archive.getSubsystemManifest().getSubsystemType().getValue());
0: 	}
0: 	
0: 	public boolean isFeature() {
0: 		// TODO Add to constants.
0: 		return "osgi.feature".equals(archive.getSubsystemManifest().getSubsystemType().getValue());
0: 	}
0: 	
0: 	/* INSTALLING	Wait, Start
0: 	 * INSTALLED	-
0: 	 * RESOLVING	Wait, Start
0: 	 * RESOLVED		-
0: 	 * STARTING		Noop
0: 	 * ACTIVE		Noop
0: 	 * STOPPING		Wait, Start
0: 	 * UPDATING		Wait, Start
0: 	 * UNINSTALLING	Error
0: 	 * UNINSTALLED	Error
0: 	 */
0: 	@Override
0: 	public synchronized void start() throws SubsystemException {
0: 		checkRoot();
0: 		State state = getState();
0: 		if (state == State.UNINSTALLING || state == State.UNINSTALLED) {
0: 			throw new SubsystemException("Cannot stop from state " + state);
0: 		}
0: 		if (state == State.INSTALLING || state == State.RESOLVING || state == State.STOPPING || state == State.UPDATING) {
0: 			waitForStateChange();
0: 			start();
0: 			return;
0: 		}
0: 		if (state == State.STARTING || state == State.ACTIVE) {
0: 			return;
0: 		}
0: 		if (state == State.INSTALLED) {
0: 			setState(State.RESOLVING);
0: 			postEvent(this, SubsystemConstants.EventType.RESOLVING);
0: 		}
0: 		else {
0: 			setState(State.STARTING);
0: 			postEvent(this, SubsystemConstants.EventType.STARTING);
0: 		}
0: 		Activator.getExecutor().execute(new Runnable() {
0: 			public void run() {
0: 				startAsync();
0: 			}
0: 		});
0: 	}
0: 	
0: 	/* INSTALLING	Noop
0: 	 * INSTALLED	Noop
0: 	 * RESOLVING	Noop
0: 	 * RESOLVED		Noop
0: 	 * STARTING		Wait, Stop
0: 	 * ACTIVE		-
0: 	 * STOPPING		Noop
0: 	 * UPDATING		Noop
0: 	 * UNINSTALLING	Error
0: 	 * UNINSTALLED	Error
0: 	 */
0: 	@Override
0: 	public synchronized void stop() throws SubsystemException {
0: 		checkRoot();
0: 		if (getState() == State.UNINSTALLING || getState() == State.UNINSTALLED) {
0: 			throw new SubsystemException("Cannot stop from state " + state);
0: 		}
0: 		else if (getState() == State.STARTING) {
0: 			waitForStateChange();
0: 			stop();
0: 		}
0: 		else if (getState() != State.ACTIVE) {
0: 			return;
0: 		}
0: 		setState(State.STOPPING);
0: 		postEvent(this, SubsystemConstants.EventType.STOPPING);
0: 		// TODO Need to store the task for cancellation.
0: 		Activator.getExecutor().execute(new Runnable() {
0: 			public void run() {
0: 				stopAsync();
0: 			}
0: 		});
0: 	}
0: 	
0: 	/* INSTALLING	Wait, Uninstall
0: 	 * INSTALLED	-
0: 	 * RESOLVING	Wait, Uninstall
0: 	 * RESOLVED		-
0: 	 * STARTING		Wait, Uninstall
0: 	 * ACTIVE		Stop, Uninstall
0: 	 * STOPPING		Wait, Uninstall
0: 	 * UPDATING		Wait, Uninstall
0: 	 * UNINSTALLING	Noop
0: 	 * UNINSTALLED	Noop
0: 	 */
0: 	@Override
0: 	public synchronized void uninstall() throws SubsystemException {
0: 		checkRoot();
0: 		State state = getState();
0: 		if (state == State.UNINSTALLING || state == State.UNINSTALLED) {
0: 			return;
0: 		}
0: 		else if (state == State.INSTALLING || state == State.RESOLVING || state == State.STARTING || state == State.STOPPING || state == State.UPDATING) {
0: 			waitForStateChange();
0: 			uninstall();
0: 		}
0: 		else if (getState() == State.ACTIVE) {
0: 			stop();
0: 			uninstall();
0: 		}
0: 		setState(State.UNINSTALLING);
0: 		postEvent(this, SubsystemConstants.EventType.UNINSTALLING);
0: 		Activator.getExecutor().execute(new Runnable() {
0: 			public void run() {
0: 				uninstallAsync();
0: 			}
0: 		});
0: 	}
0: 	
0: 	void bundleChanged(BundleEvent event) {
0: 		switch (event.getType()) {
0: 			case BundleEvent.STARTING:
0: 				if (State.STARTING.equals(getState())) {
0: 					return;
0: 				}
0: 				start();
0: 				break;
0: 			case BundleEvent.STOPPING:
0: 				if (State.STOPPING.equals(getState())) {
0: 					return;
0: 				}
0: 				stop();
0: 				break;
0: 			case BundleEvent.UNINSTALLED:
0: 				if (EnumSet.of(State.UNINSTALLING, State.UNINSTALLED).contains(getState())) {
0: 					return;
0: 				}
0: 				uninstall();
0: 				break;
0: 		}
0: 	}
0: 	
0: 	protected void addConstituent(Resource resource) {
0: 		constituents.add(resource);
0: 	}
0: 	
0: 	protected boolean contains(Resource resource) {
0: 		return constituents.contains(resource);
0: 	}
0: 	
0: //	protected Resource findContentResource(String namespace, String symbolicName, String version) {
0: //		Requirement requirement = new OsgiIdentityRequirement(null, symbolicName, Version.parseVersion(version), namespace);
0: //		Resource result = null;
0: //		/* Root */
0: //		if (isRoot()) {
0: //			// For the root subsystem, simply look for a resource in the system repository.
0: //			result = ResourceHelper.getResource(requirement, repository);
0: //		}
0: //		/* Features */
0: //		else if (isFeature()) {
0: //			// Check for existing, accessible resources first.
0: //			result = parent.findContentResource(namespace, symbolicName, version);
0: //			// If necessary, look for the resource in the subsystem repository.
0: //			if (result == null) {
0: //				if (repository != null) {
0: //					// Repository will be null if the subsystem contained no resources.
0: //					result = ResourceHelper.getResource(requirement, repository);
0: //				}
0: //				// Finally, if necessary, look for the resource in other repositories.
0: //				if (result == null) {
0: //					result = Activator.getResourceResolver().find(symbolicName + ";version=" + version);
0: //				}
0: //			}
0: //			
0: //		}
0: //		/* Applications */
0: //		else if (isApplication()) {
0: //			// For applications, we never want to reuse an existing resource.
0: //			// Favor resources included with the subsystem definition.
0: //			if (repository != null) {
0: //				// Repository will be null if the subsystem contained no resources.
0: //				result = ResourceHelper.getResource(requirement, repository);
0: //			}
0: //			// If necessary, look for the resource in other repositories.
0: //			if (result == null) {
0: //				result = Activator.getResourceResolver().find(symbolicName + ";version=" + version);
0: //			}
0: //		}
0: //		/* Composites */
0: //		else {
0: //			// TODO Implement composite behavior.
0: //		}
0: //		return result;
0: //	}
0: 	
0: 	protected Collection<Bundle> getBundles() {
0: 		ArrayList<Bundle> result = new ArrayList<Bundle>(constituents.size());
0: 		for (Resource resource : constituents) {
0: 			if (resource instanceof BundleRuntimeResource)
0: 				result.add(((BundleRuntimeResource)resource).getBundle());
0: 		}
0: 		result.trimToSize();
0: 		return result;
0: 	}
0: 	
0: 	protected synchronized void setState(Subsystem.State state) {
0: 		this.state = state;
0: 		notifyAll();
0: 	}
0: 	
0: 	protected synchronized void waitForStateChange() {
0: 		try {
0: 			wait();
0: 		}
0: 		catch (InterruptedException e) {
0: 			throw new SubsystemException(e);
0: 		}
0: 	}
0: 	
0: 	private void checkRoot() {
0: 		if (isRoot()) {
0: 			throw new SubsystemException("This operation may not be performed on the root subsystem");
0: 		}
0: 	}
0: 	
0: 	private Region createRegion() throws BundleException {
0: 		return Activator.getRegionDigraph().createRegion(getSymbolicName() + ';' + getVersion());
0: 	}
0: 	
0: 	private void install(Resource resource, Coordination coordination, boolean transitive) {
0: //		String content = ResourceHelper.getContentAttribute(resource);
0: //		String location = getSubsystemId() + '@' + getSymbolicName() + '@' + content;
0: 		try {
0: 			final RuntimeResource runtimeResource;
0: //			final Bundle bundle;
0: 			if (transitive) {
0: 				// Transitive dependencies should be provisioned into the highest possible level.
0: 				// Transitive dependencies do not become a constituent.
0: 				// TODO Assumes root is always the appropriate level.
0: 				AriesSubsystem subsystem = this;
0: 				while (subsystem.parent != null)
0: 					subsystem = subsystem.parent;
0: 				runtimeResource = new RuntimeResourceFactoryImpl().create(resource, null, subsystem);
0: 				runtimeResource.install(coordination);
0: 				subsystem.constituents.add(runtimeResource);
0: //				bundle = subsystem.region.installBundle(location, new URL(content).openStream());
0: 			}
0: 			else if (region == null) {
0: 				// Feature resources should be provisioned into the parent, unless the parent is also a feature.
0: 				// TODO Assumes parent is always highest possible level.
0: //				AriesSubsystem subsystem = this.parent;
0: //				while (subsystem.region == null)
0: //					subsystem = subsystem.parent;
0: 				runtimeResource = new RuntimeResourceFactoryImpl().create(resource, null, this);
0: 				runtimeResource.install(coordination);
0: //				bundle = subsystem.region.installBundle(location, new URL(content).openStream());
0: 				// Features retain their constituents.
0: 				constituents.add(runtimeResource);
0: 			}
0: 			else {
0: 				// Constituent (non-transitive) resources must be provisioned into the owning subsystem, except for features.
0: 				// We know this isn't a feature because the region was not null.
0: 				runtimeResource = new RuntimeResourceFactoryImpl().create(resource, null, this);
0: 				runtimeResource.install(coordination);
0: //				bundle = region.installBundle(location, new URL(content).openStream());
0: 				constituents.add(runtimeResource);
0: 			}
0: //			coordination.addParticipant(new Participant() {
0: //				public void ended(Coordination coordination) throws Exception {
0: //					// noop
0: //				}
0: //	
0: //				public void failed(Coordination coordination) throws Exception {
0: //					constituents.remove(bundle.adapt(BundleRevision.class));
0: //					region.removeBundle(bundle);
0: //				}
0: //			});
0: 		}
0: 		catch (Exception e) {
0: 			throw new SubsystemException(e);
0: 		}
0: 	}
0: 	
0: 	private synchronized void installAsync() throws Exception {
0: 		List<Resource> contentResources = new ArrayList<Resource>();
0: 		List<Resource> transitiveDependencies = new ArrayList<Resource>();
0: //		// Get the resources included within the archive.
0: //		contentResources.addAll(archive.getResources());
0: //		// Create a subsystem repository from the contents of the subsystem archive.
0: //		if (!contentResources.isEmpty()) {
0: //			Document document = RepositoryDescriptorGenerator.generateRepositoryDescriptor("subsystem" + getSubsystemId(), contentResources);
0: //			File file = new File(archive.getDirectory() + "/repository.xml");
0: //			FileOutputStream fout = new FileOutputStream(file);
0: //		    TransformerFactory.newInstance().newTransformer().transform(new DOMSource(document), new StreamResult(fout));
0: //		    fout.close();
0: //		    repository = new RepositoryFactory().newRepository(file.toURI().toURL());
0: //		}
0: //		contentResources.clear();
0: 		DeploymentManifest manifest = archive.getDeploymentManifest();
0: 		DeployedContentHeader contentHeader = manifest.getDeployedContent();
0: 		for (DeployedContent content : contentHeader.getDeployedContents()) {
0: 			Collection<Capability> capabilities = environment.findProviders(
0: 					new OsgiIdentityRequirement(null, content.getName(), content.getDeployedVersion(), content.getNamespace()));
0: 			if (capabilities.isEmpty())
0: 				throw new SubsystemException("Subsystem content resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: 			Resource resource = capabilities.iterator().next().getResource();
0: 			contentResources.add(resource);
0: 			
0: //			// Find the most appropriate resource based on subsystem type.
0: //			Resource resource = findContentResource(content.getNamespace(), content.getName(), String.valueOf(content.getDeployedVersion()));
0: //			if (resource == null)
0: //				throw new SubsystemException("Subsystem content resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: //			contentResources.add(resource);
0: 		}
0: 		ProvisionResourceHeader resourceHeader = manifest.getProvisionResource();
0: 		if (resourceHeader != null) {
0: 			for (ProvisionedResource content : resourceHeader.getProvisionedResources()) {
0: 				Collection<Capability> capabilities = environment.findProviders(
0: 						new OsgiIdentityRequirement(null, content.getName(), content.getDeployedVersion(), content.getNamespace()));
0: 				if (capabilities.isEmpty())
0: 					throw new SubsystemException("Subsystem content resource does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: 				Resource resource = capabilities.iterator().next().getResource();
0: 				transitiveDependencies.add(resource);
0: 				
0: //				// Find the most appropriate resource based on subsystem type.
0: //				Resource resource = findContentResource(content.getNamespace(), content.getName(), String.valueOf(content.getDeployedVersion()));
0: //				if (resource == null)
0: //					throw new SubsystemException("Subsystem transitive dependency does not exist: " + content.getName() + ";version=" + content.getDeployedVersion());
0: //				transitiveDependencies.add(resource);
0: 			}
0: 		}
0: 		// Install content resources and transitive dependencies.
0: 		if (!contentResources.isEmpty()) {
0: 			Coordination coordination = Activator.getCoordinator().create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 			try {
0: 				// Install the content resources.
0: 				for (Resource resource : contentResources) {
0: 					install(resource, coordination, false);
0: 				}
0: 				// Discover and install transitive dependencies.
0: 				for (Resource resource : transitiveDependencies) {
0: 					install(resource, coordination, true);
0: 				}
0: 			}
0: 			catch (Exception e) {
0: 				coordination.fail(e);
0: 			}
0: 			finally {
0: 				coordination.end();
0: 			}
0: 		}
0: 		setState(Subsystem.State.INSTALLED);
0: 		postEvent(this, SubsystemConstants.EventType.INSTALLED);
0: 	}
0: 	
0: 	private boolean isRoot() {
0: 		return ROOT_LOCATION.equals(getLocation());
0: 	}
0: 	
0: 	private void setExportIsolationPolicy() {
0: 		// Archive is null for root subsystem.
0: 		if (archive == null)
0: 			return;
0: 		// TODO Implement export isolation policy for composites.
0: 	}
0: 	
0: 	private void setImportIsolationPolicy() throws BundleException {
0: 		// Archive is null for root subsystem.
0: 		if (archive == null)
0: 			return;
0: 		// Feature contents are stored in the parent (or higher) region and take on the associated isolation.
0: 		if (isFeature()) {
0: 			return;
0: 		}
0: 		if (isApplication()) {
0: 			region.connectRegion(
0: 					parent.getRegion(), 
0: 					region.getRegionDigraph().createRegionFilterBuilder().allowAll(RegionFilter.VISIBLE_ALL_NAMESPACE).build());
0: 		}
0: 		// TODO Implement import isolation policy for composites.
0: 	}
0: 	
0: //	private void start(Resource resource, Coordination coordination) throws BundleException {
0: //		if (!(resource instanceof BundleRevision)) {
0: //			throw new SubsystemException("Unsupported resource type: " + resource);
0: //		}
0: //		final Bundle bundle = ((BundleRevision)resource).getBundle();
0: //		// We don't want the bundles to autostart. Starting bundles must be under the control of the
0: //		// subsystem in order to guarantee ordering.
0: //		bundle.start(Bundle.START_TRANSIENT);
0: //		coordination.addParticipant(new Participant() {
0: //			public void ended(Coordination coordination) throws Exception {
0: //				// noop
0: //			}
0: //
0: //			public void failed(Coordination coordination) throws Exception {
0: //				bundle.stop();
0: //			}
0: //		});
0: //	}
0: 	
0: 	private void startAsync() {
0: 		// TODO Need to hold a lock here to guarantee that another start operation can't occur when the state goes to RESOLVED.
0: 		// Resolve the subsystem, if necessary.
0: 		if (getState() == State.RESOLVING) { // Otherwise, the state will be STARTING.
0: 			try {
0: 				setImportIsolationPolicy();
0: 				if (!Activator.getFrameworkWiring().resolveBundles(getBundles())) {
0: 					throw new Exception("Framework could not resolve the bundles");
0: 				}
0: 				setExportIsolationPolicy();
0: 				// TODO Could avoid calling setState (and notifyAll) here and avoid the need for a lock.
0: 				setState(State.RESOLVED);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.RESOLVED);
0: 				setState(State.STARTING);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.STARTING);
0: 			}
0: 			catch (Exception e) {
0: 				setState(State.INSTALLED);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 				return;
0: 			}
0: 		}
0: 		// Start the subsystem.
0: 		Coordination coordination = Activator.getCoordinator().create(getSymbolicName() + '-' + getSubsystemId(), 0);
0: 		try {
0: 			for (Resource resource : constituents) {
0: 				((RuntimeResource)resource).start(coordination);
0: 			}
0: 		}
0: 		catch (Exception e) {
0: 			coordination.fail(e);
0: 			// TODO Need to reinstate complete isolation by disconnecting the region and transition to INSTALLED.
0: 		}
0: 		finally {
0: 			try {
0: 				coordination.end();
0: 			}
0: 			catch (CoordinationException e) {
0: 				setState(State.RESOLVED);
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 			}
0: 		}
0: //		try {
0: //			for (Resource resource : constituents) {
0: //				start(resource, coordination);
0: //			}
0: //		}
0: //		catch (Exception e) {
0: //			coordination.fail(e);
0: //			// TODO Need to reinstate complete isolation by disconnecting the region and transition to INSTALLED.
0: //		}
0: //		finally {
0: //			try {
0: //				coordination.end();
0: //			}
0: //			catch (CoordinationException e) {
0: //				setState(State.RESOLVED);
0: //				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: //			}
0: //		}
0: 		setState(State.ACTIVE);
0: 		postEvent(AriesSubsystem.this, SubsystemConstants.EventType.STARTED);
0: 	}
0: 	
0: 	private void stop(Resource resource) throws Exception {
0: 		((RuntimeResource)resource).stop(null);
0: //		if (!(resource instanceof BundleRevision)) {
0: //			throw new SubsystemException("Unsupported resource type: " + resource);
0: //		}
0: //		final Bundle bundle = ((BundleRevision)resource).getBundle();
0: //		bundle.stop();
0: 	}
0: 	
0: 	private void stopAsync() {
0: 		// TODO Persist stop state.
0: 		for (Resource resource : constituents) {
0: 			try {
0: 				stop(resource);
0: 			}
0: 			catch (Exception e) {
0: 				// TODO Should FAILED go out for each failure?
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 			}
0: 		}
0: 		// TODO Can we automatically assume it actually is resolved?
0: 		setState(State.RESOLVED);
0: 		postEvent(AriesSubsystem.this, SubsystemConstants.EventType.STOPPED);
0: 	}
0: 	
0: 	private void uninstall(Resource resource) throws Exception {
0: 		((RuntimeResource)resource).uninstall(null);
0: //		if (!(resource instanceof BundleRevision)) {
0: //			throw new SubsystemException("Unsupported resource type: " + resource);
0: //		}
0: //		final Bundle bundle = ((BundleRevision)resource).getBundle();
0: //		bundle.uninstall();
0: 	}
0: 	
0: 	private void uninstallAsync() {
0: 		for (Resource resource : constituents) {
0: 			try {
0: 				uninstall(resource);
0: 			}
0: 			catch (Exception e) {
0: 				// TODO Should FAILED go out for each failure?
0: 				postEvent(AriesSubsystem.this, SubsystemConstants.EventType.FAILED, e);
0: 			}
0: 		}
0: 		parent.children.remove(this);
0: 		deleteFile(Activator.getBundleContext().getDataFile("subsystem" + id + System.getProperty("file.separator")));
0: 		setState(State.UNINSTALLED);
0: 		postEvent(AriesSubsystem.this, SubsystemConstants.EventType.UNINSTALLED);
0: 	}
0: }
author:Tom Watson
-------------------------------------------------------------------------------
commit:d6eb080
/////////////////////////////////////////////////////////////////////////
1: 		this(resource, null);
0: 	}
0: 	
1: 	public BasicSubsystem(SubsystemResource resource, InputStream deploymentManifest) throws URISyntaxException, IOException, BundleException, InvalidSyntaxException {
/////////////////////////////////////////////////////////////////////////
1: 				.manifest(deploymentManifest == null ? resource.getDeploymentManifest() : new DeploymentManifest(deploymentManifest))
/////////////////////////////////////////////////////////////////////////
1: 		setTranslations();
/////////////////////////////////////////////////////////////////////////
1: 		return AccessController.doPrivileged(new GetSubsystemHeadersAction(this, locale));
/////////////////////////////////////////////////////////////////////////
1: 	public AriesSubsystem install(String location, InputStream content) {
1: 		return install(location, content, null);
/////////////////////////////////////////////////////////////////////////
1: 		return install(location, content, null);
0: 	}
0: 	
0: 	@Override
1: 	public AriesSubsystem install(String location, IDirectory content, InputStream deploymentManifest) {
0: 		try {
1: 			return AccessController.doPrivileged(new InstallAction(location, content, this, AccessController.getContext(), deploymentManifest));
0: 		}
0: 		finally {
1: 			IOUtils.close(deploymentManifest);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 
0: 	@Override
1: 	public Map<String, String> getDeploymentHeaders() {
0: 		SecurityManager.checkMetadataPermission(this);
1: 		return AccessController.doPrivileged(new GetDeploymentHeadersAction(this));
0: 	}
0: 
0: 	@Override
1: 	public AriesSubsystem install(String location, final InputStream content, InputStream deploymentManifest) {
0: 		try {
0: 			return install(location, content == null ? null : 
0: 				AccessController.doPrivileged(new PrivilegedAction<IDirectory>() {
0: 					@Override
0: 					public IDirectory run() {
0: 						return FileSystem.getFSRoot(content);
0: 					}
0: 				}),
0: 				deploymentManifest);
0: 		}
0: 		finally {
0: 			// This method must guarantee the content input stream was closed.
0: 			IOUtils.close(content);
0: 		}
0: 	}
0: 	
1: 	private void setTranslations() throws IOException {
1: 		String directoryName = getSubsystemManifest().getSubsystemLocalizationHeader().getDirectoryName();
1: 		File file = directoryName == null ? getDirectory() : new File(getDirectory(), directoryName);
1: 		if (!file.exists())
1: 			file.mkdirs();
1: 		for (TranslationFile translation : getResource().getTranslations()) {
1: 			translation.write(file);
0: 		}
0: 	}
============================================================================