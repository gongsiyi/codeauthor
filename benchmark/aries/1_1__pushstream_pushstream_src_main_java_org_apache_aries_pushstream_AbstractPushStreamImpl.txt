1:7fa86e8: /*
1:7fa86e8:  * Licensed to the Apache Software Foundation (ASF) under one
1:7fa86e8:  * or more contributor license agreements.  See the NOTICE file
1:7fa86e8:  * distributed with this work for additional information
1:7fa86e8:  * regarding copyright ownership.  The ASF licenses this file
1:7fa86e8:  * to you under the Apache License, Version 2.0 (the
1:7fa86e8:  * "License"); you may not use this file except in compliance
1:7fa86e8:  * with the License.  You may obtain a copy of the License at
1:7fa86e8:  *
1:7fa86e8:  *   http://www.apache.org/licenses/LICENSE-2.0
1:7fa86e8:  *
1:7fa86e8:  * Unless required by applicable law or agreed to in writing,
1:7fa86e8:  * software distributed under the License is distributed on an
1:7fa86e8:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:7fa86e8:  * KIND, either express or implied.  See the License for the
1:7fa86e8:  * specific language governing permissions and limitations
1:7fa86e8:  * under the License.
1:7fa86e8:  */
1:7fa86e8: package org.apache.aries.pushstream;
1:7fa86e8: 
1:7fa86e8: import static java.util.Collections.emptyList;
1:7fa86e8: import static java.util.concurrent.TimeUnit.NANOSECONDS;
1:7fa86e8: import static org.apache.aries.pushstream.AbstractPushStreamImpl.State.*;
1:7fa86e8: import static org.osgi.util.pushstream.PushEventConsumer.*;
1:7fa86e8: 
1:7fa86e8: import java.time.Duration;
1:7fa86e8: import java.util.AbstractQueue;
1:7fa86e8: import java.util.ArrayList;
1:7fa86e8: import java.util.Arrays;
1:7fa86e8: import java.util.Collection;
1:7fa86e8: import java.util.Collections;
1:7fa86e8: import java.util.Comparator;
1:7fa86e8: import java.util.ConcurrentModificationException;
1:7fa86e8: import java.util.Iterator;
1:7fa86e8: import java.util.LinkedList;
1:7fa86e8: import java.util.List;
1:7fa86e8: import java.util.NoSuchElementException;
1:7fa86e8: import java.util.Optional;
1:7fa86e8: import java.util.Queue;
1:7fa86e8: import java.util.Set;
1:7fa86e8: import java.util.concurrent.BlockingQueue;
1:7fa86e8: import java.util.concurrent.ConcurrentHashMap;
1:7fa86e8: import java.util.concurrent.Executor;
1:7fa86e8: import java.util.concurrent.ScheduledExecutorService;
1:7fa86e8: import java.util.concurrent.Semaphore;
1:7fa86e8: import java.util.concurrent.atomic.AtomicBoolean;
1:7fa86e8: import java.util.concurrent.atomic.AtomicInteger;
1:7fa86e8: import java.util.concurrent.atomic.AtomicLong;
1:7fa86e8: import java.util.concurrent.atomic.AtomicReference;
1:7fa86e8: import java.util.concurrent.atomic.AtomicReferenceArray;
1:7fa86e8: import java.util.concurrent.atomic.LongAdder;
1:7fa86e8: import java.util.concurrent.locks.Lock;
1:7fa86e8: import java.util.concurrent.locks.ReentrantLock;
1:7fa86e8: import java.util.function.BiFunction;
1:7fa86e8: import java.util.function.BinaryOperator;
1:7fa86e8: import java.util.function.Consumer;
1:7fa86e8: import java.util.function.Function;
1:7fa86e8: import java.util.function.IntFunction;
1:7fa86e8: import java.util.function.IntSupplier;
1:7fa86e8: import java.util.function.Predicate;
1:7fa86e8: import java.util.function.Supplier;
1:7fa86e8: import java.util.stream.Collector;
1:7fa86e8: import java.util.stream.Collectors;
1:7fa86e8: 
1:7fa86e8: import org.osgi.util.promise.Deferred;
1:7fa86e8: import org.osgi.util.promise.Promise;
1:7fa86e8: import org.osgi.util.pushstream.PushEvent;
1:7fa86e8: import org.osgi.util.pushstream.PushEventConsumer;
1:7fa86e8: import org.osgi.util.pushstream.PushEventSource;
1:7fa86e8: import org.osgi.util.pushstream.PushStream;
1:7fa86e8: import org.osgi.util.pushstream.PushStreamBuilder;
1:7fa86e8: import org.osgi.util.pushstream.PushStreamProvider;
1:7fa86e8: import org.osgi.util.pushstream.PushEvent.EventType;
1:7fa86e8: 
1:7fa86e8: public abstract class AbstractPushStreamImpl<T> implements PushStream<T> {
1:7fa86e8: 	
1:7fa86e8: 	public static enum State {
1:7fa86e8: 		BUILDING, STARTED, CLOSED
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	protected final PushStreamProvider								psp;
1:7fa86e8: 	
1:7fa86e8: 	protected final Executor										defaultExecutor;
1:7fa86e8: 	protected final ScheduledExecutorService						scheduler;
1:7fa86e8: 
1:7fa86e8: 	protected final AtomicReference<State> closed = new AtomicReference<>(BUILDING);
1:7fa86e8: 	
1:7fa86e8: 	protected final AtomicReference<PushEventConsumer<T>>			next			= new AtomicReference<>();
1:7fa86e8: 	
1:7fa86e8: 	protected final AtomicReference<Runnable> onCloseCallback = new AtomicReference<>();
1:7fa86e8: 	protected final AtomicReference<Consumer<? super Throwable>> onErrorCallback = new AtomicReference<>();
1:7fa86e8: 
1:7fa86e8: 	protected abstract boolean begin();
1:7fa86e8: 	
1:7fa86e8: 	protected AbstractPushStreamImpl(PushStreamProvider psp,
1:7fa86e8: 			Executor executor, ScheduledExecutorService scheduler) {
1:7fa86e8: 		this.psp = psp;
1:7fa86e8: 		this.defaultExecutor = executor;
1:7fa86e8: 		this.scheduler = scheduler;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	protected long handleEvent(PushEvent< ? extends T> event) {
1:7fa86e8: 		if(closed.get() != CLOSED) {
1:7fa86e8: 			try {
1:7fa86e8: 				if(event.isTerminal()) {
1:7fa86e8: 					close(event.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				} else {
1:7fa86e8: 					PushEventConsumer<T> consumer = next.get();
1:7fa86e8: 					long val;
1:7fa86e8: 					if(consumer == null) {
1:7fa86e8: 						//TODO log a warning
1:7fa86e8: 						val = CONTINUE;
1:7fa86e8: 					} else {
1:7fa86e8: 						val = consumer.accept(event);
1:7fa86e8: 					}
1:7fa86e8: 					if(val < 0) {
1:7fa86e8: 						close();
1:7fa86e8: 					}
1:7fa86e8: 					return val;
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		}
1:7fa86e8: 		return ABORT;
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	@Override
1:7fa86e8: 	public void close() {
1:7fa86e8: 		close(PushEvent.close());
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	protected boolean close(PushEvent<T> event) {
1:7fa86e8: 		if(!event.isTerminal()) {
1:7fa86e8: 			throw new IllegalArgumentException("The event " + event  + " is not a close event.");
1:7fa86e8: 		}
1:7fa86e8: 		if(closed.getAndSet(CLOSED) != CLOSED) {
1:7fa86e8: 			PushEventConsumer<T> aec = next.getAndSet(null);
1:7fa86e8: 			if(aec != null) {
1:7fa86e8: 				try {
1:7fa86e8: 					aec.accept(event);
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 					// TODO Auto-generated catch block
1:7fa86e8: 					e.printStackTrace();
1:7fa86e8: 				}
1:7fa86e8: 			}
1:7fa86e8: 			Runnable handler = onCloseCallback.getAndSet(null);
1:7fa86e8: 			if(handler != null) {
1:7fa86e8: 				try {
1:7fa86e8: 					handler.run();
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 					// TODO Auto-generated catch block
1:7fa86e8: 					e.printStackTrace();
1:7fa86e8: 				}
1:7fa86e8: 			}
1:7fa86e8: 			if (event.getType() == EventType.ERROR) {
1:7fa86e8: 				Consumer<? super Throwable> errorHandler = onErrorCallback.getAndSet(null);
1:7fa86e8: 				if(errorHandler != null) {
1:7fa86e8: 					try {
1:7fa86e8: 						errorHandler.accept(event.getFailure());
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						// TODO Auto-generated catch block
1:7fa86e8: 						e.printStackTrace();
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 			}
1:7fa86e8: 			return true;
1:7fa86e8: 		}
1:7fa86e8: 		return false;
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> onClose(Runnable closeHandler) {
1:7fa86e8: 		if(onCloseCallback.compareAndSet(null, closeHandler)) {
1:7fa86e8: 			if(closed.get() == State.CLOSED && onCloseCallback.compareAndSet(closeHandler, null)) {
1:7fa86e8: 				closeHandler.run();
1:7fa86e8: 			}
1:7fa86e8: 		} else {
1:7fa86e8: 			throw new IllegalStateException("A close handler has already been defined for this stream object");
1:7fa86e8: 		}
1:7fa86e8: 		return this;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> onError(Consumer< ? super Throwable> closeHandler) {
1:7fa86e8: 		if(onErrorCallback.compareAndSet(null, closeHandler)) {
1:7fa86e8: 			if(closed.get() == State.CLOSED) { 
1:7fa86e8: 				//TODO log already closed
1:7fa86e8: 				onErrorCallback.set(null);
1:7fa86e8: 			}
1:7fa86e8: 		} else {
1:7fa86e8: 			throw new IllegalStateException("A close handler has already been defined for this stream object");
1:7fa86e8: 		}
1:7fa86e8: 		return this;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	private void updateNext(PushEventConsumer<T> consumer) {
1:7fa86e8: 		if(!next.compareAndSet(null, consumer)) {
1:7fa86e8: 			throw new IllegalStateException("This stream has already been chained");
1:7fa86e8: 		} else if(closed.get() == CLOSED && next.compareAndSet(consumer, null)) {
1:7fa86e8: 			try {
1:7fa86e8: 				consumer.accept(PushEvent.close());
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				//TODO log
1:7fa86e8: 				e.printStackTrace();
1:7fa86e8: 			}
1:7fa86e8: 		}
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> filter(Predicate< ? super T> predicate) {
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					if (predicate.test(event.getData())) {
1:7fa86e8: 						return eventStream.handleEvent(event);
1:7fa86e8: 					} else {
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 				return eventStream.handleEvent(event);
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> map(Function< ? super T, ? extends R> mapper) {
1:7fa86e8: 		
1:7fa86e8: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					return eventStream.handleEvent(
1:7fa86e8: 							PushEvent.data(mapper.apply(event.getData())));
1:7fa86e8: 				} else {
1:7fa86e8: 					return eventStream.handleEvent(event.nodata());
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> flatMap(
1:7fa86e8: 			Function< ? super T, ? extends PushStream< ? extends R>> mapper) {
1:7fa86e8: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 
1:7fa86e8: 		PushEventConsumer<R> consumer = e -> {
1:7fa86e8: 			switch (e.getType()) {
1:7fa86e8: 				case ERROR :
1:7fa86e8: 					close(e.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				case CLOSE :
1:7fa86e8: 					// Close should allow the next flat mapped entry
1:7fa86e8: 					// without closing the stream;
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				case DATA :
1:7fa86e8: 					long returnValue = eventStream.handleEvent(e);
1:7fa86e8: 					if (returnValue < 0) {
1:7fa86e8: 						close();
1:7fa86e8: 						return ABORT;
1:7fa86e8: 					}
1:7fa86e8: 					return returnValue;
1:7fa86e8: 				default :
1:7fa86e8: 					throw new IllegalArgumentException(
1:7fa86e8: 							"The event type " + e.getType() + " is unknown");
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					PushStream< ? extends R> mappedStream = mapper
1:7fa86e8: 							.apply(event.getData());
1:7fa86e8: 
1:7fa86e8: 					return mappedStream.forEachEvent(consumer)
1:7fa86e8: 							.getValue()
1:7fa86e8: 							.longValue();
1:7fa86e8: 				} else {
1:7fa86e8: 					return eventStream.handleEvent(event.nodata());
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> distinct() {
1:7fa86e8: 		Set<T> set = Collections.<T>newSetFromMap(new ConcurrentHashMap<>());
1:7fa86e8: 		return filter(set::add);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@SuppressWarnings({ "rawtypes", "unchecked" })
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> sorted() {
1:7fa86e8: 		return sorted((Comparator)Comparator.naturalOrder());
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> sorted(Comparator< ? super T> comparator) {
1:7fa86e8: 		List<T> list = Collections.synchronizedList(new ArrayList<>());
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				switch(event.getType()) {
1:7fa86e8: 					case DATA : 
1:7fa86e8: 						list.add(event.getData());
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					case CLOSE :
1:7fa86e8: 						list.sort(comparator);
1:7fa86e8: 						for(T t : list) {
1:7fa86e8: 							eventStream.handleEvent(PushEvent.data(t));
1:7fa86e8: 						}
1:7fa86e8: 						return ABORT;
1:7fa86e8: 					case ERROR :
1:7fa86e8: 						return eventStream.handleEvent(event.nodata());
1:7fa86e8: 				}
1:7fa86e8: 				return eventStream.handleEvent(event.nodata());
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> limit(long maxSize) {
1:7fa86e8: 		if(maxSize <= 0) {
1:7fa86e8: 			throw new IllegalArgumentException("The limit must be greater than zero");
1:7fa86e8: 		}
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		AtomicLong counter = new AtomicLong(maxSize);
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					long count = counter.decrementAndGet();
1:7fa86e8: 					if (count > 0) {
1:7fa86e8: 						return eventStream.handleEvent(event);
1:7fa86e8: 					} else if (count == 0) {
1:7fa86e8: 						eventStream.handleEvent(event);
1:7fa86e8: 					}
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				} else {
1:7fa86e8: 					return eventStream.handleEvent(event.nodata());
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> skip(long n) {
1:7fa86e8: 		if(n <= 0) {
1:7fa86e8: 			throw new IllegalArgumentException("The number to skip must be greater than zero");
1:7fa86e8: 		}
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		AtomicLong counter = new AtomicLong(n);
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					if (counter.get() > 0 && counter.decrementAndGet() >= 0) {
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					} else {
1:7fa86e8: 						return eventStream.handleEvent(event);
1:7fa86e8: 					} 				
1:7fa86e8: 				} else {
1:7fa86e8: 					return eventStream.handleEvent(event.nodata());
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> fork(int n, int delay, Executor ex) {
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, ex, scheduler, this);
1:7fa86e8: 		Semaphore s = new Semaphore(n);
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (event.isTerminal()) {
1:7fa86e8: 					s.acquire(n);
1:7fa86e8: 					eventStream.close(event.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 	
1:7fa86e8: 				s.acquire(1);
1:7fa86e8: 	
1:7fa86e8: 				ex.execute(() -> {
1:7fa86e8: 					try {
1:7fa86e8: 						if (eventStream.handleEvent(event) < 0) {
1:7fa86e8: 							eventStream.close(PushEvent.close());
1:7fa86e8: 						}
1:7fa86e8: 					} catch (Exception e1) {
1:7fa86e8: 						close(PushEvent.error(e1));
1:7fa86e8: 					} finally {
1:7fa86e8: 						s.release(1);
1:7fa86e8: 					}
1:7fa86e8: 				});
1:7fa86e8: 	
1:7fa86e8: 				return s.getQueueLength() * delay;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> buffer() {
1:7fa86e8: 		return psp.createStream(c -> {
1:7fa86e8: 			forEachEvent(c);
1:7fa86e8: 			return this;
1:7fa86e8: 		});
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <U extends BlockingQueue<PushEvent< ? extends T>>> PushStreamBuilder<T,U> buildBuffer() {
1:7fa86e8: 		return psp.buildStream(c -> {
1:7fa86e8: 			forEachEvent(c);
1:7fa86e8: 			return this;
1:7fa86e8: 		});
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> merge(
1:7fa86e8: 			PushEventSource< ? extends T> source) {
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		AtomicInteger count = new AtomicInteger(2);
1:7fa86e8: 		PushEventConsumer<T> consumer = event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					return eventStream.handleEvent(event);
1:7fa86e8: 				}
1:7fa86e8: 	
1:7fa86e8: 				if (count.decrementAndGet() == 0) {
1:7fa86e8: 					eventStream.handleEvent(event.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 				return CONTINUE;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				PushEvent<T> error = PushEvent.error(e);
1:7fa86e8: 				close(error);
1:7fa86e8: 				eventStream.close(event.nodata());
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 		updateNext(consumer);
1:7fa86e8: 		AutoCloseable second;
1:7fa86e8: 		try {
1:7fa86e8: 			second = source.open((PushEvent< ? extends T> event) -> {
1:7fa86e8: 				return consumer.accept(event);
1:7fa86e8: 			});
1:7fa86e8: 		} catch (Exception e) {
1:7fa86e8: 			// TODO Auto-generated catch block
1:7fa86e8: 			e.printStackTrace();
1:7fa86e8: 			throw new IllegalStateException(
1:7fa86e8: 					"Unable to merge events as the event source could not be opened.",
1:7fa86e8: 					e);
1:7fa86e8: 		}
1:7fa86e8: 		
1:7fa86e8: 		return eventStream.onClose(() -> {
1:7fa86e8: 			try {
1:7fa86e8: 				second.close();
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				// TODO Auto-generated catch block
1:7fa86e8: 				e.printStackTrace();
1:7fa86e8: 			} 
1:7fa86e8: 		}).map(Function.identity());
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> merge(PushStream< ? extends T> source) {
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		AtomicInteger count = new AtomicInteger(2);
1:7fa86e8: 		PushEventConsumer<T> consumer = event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					return eventStream.handleEvent(event);
1:7fa86e8: 				}
1:7fa86e8: 				
1:7fa86e8: 				if (count.decrementAndGet() == 0) {
1:7fa86e8: 					eventStream.handleEvent(event.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 				return CONTINUE;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				PushEvent<T> error = PushEvent.error(e);
1:7fa86e8: 				close(error);
1:7fa86e8: 				eventStream.close(event.nodata());
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 		updateNext(consumer);
1:7fa86e8: 		try {
1:7fa86e8: 			source.forEachEvent(event -> {
1:7fa86e8: 				return consumer.accept(event);
1:7fa86e8: 			}).then(p -> {
1:7fa86e8: 				count.decrementAndGet();
1:7fa86e8: 				consumer.accept(PushEvent.close());
1:7fa86e8: 				return null;
1:7fa86e8: 			}, p -> {
1:7fa86e8: 				count.decrementAndGet();
1:7fa86e8: 				consumer.accept(PushEvent.error((Exception) p.getFailure()));
1:7fa86e8: 			});
1:7fa86e8: 		} catch (Exception e) {
1:7fa86e8: 			// TODO Auto-generated catch block
1:7fa86e8: 			e.printStackTrace();
1:7fa86e8: 			throw new IllegalStateException(
1:7fa86e8: 					"Unable to merge events as the event source could not be opened.",
1:7fa86e8: 					e);
1:7fa86e8: 		}
1:7fa86e8: 		
1:7fa86e8: 		return eventStream.onClose(() -> {
1:7fa86e8: 			try {
1:7fa86e8: 				source.close();
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				// TODO Auto-generated catch block
1:7fa86e8: 				e.printStackTrace();
1:7fa86e8: 			} 
1:7fa86e8: 		}).map(Function.identity());
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@SuppressWarnings("unchecked")
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T>[] split(Predicate< ? super T>... predicates) {
1:7fa86e8: 		Predicate<? super T>[] tests = Arrays.copyOf(predicates, predicates.length);
1:7fa86e8: 		AbstractPushStreamImpl<T>[] rsult = new AbstractPushStreamImpl[tests.length];
1:7fa86e8: 		for(int i = 0; i < tests.length; i++) {
1:7fa86e8: 			rsult[i] = new IntermediatePushStreamImpl<>(psp, defaultExecutor,
1:7fa86e8: 					scheduler, this);
1:7fa86e8: 		}
1:7fa86e8: 		AtomicReferenceArray<Boolean> off = new AtomicReferenceArray<>(tests.length);
1:7fa86e8: 		AtomicInteger count = new AtomicInteger(tests.length);
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			if (!event.isTerminal()) {
1:7fa86e8: 				long delay = CONTINUE;
1:7fa86e8: 				for (int i = 0; i < tests.length; i++) {
1:7fa86e8: 					try {
1:7fa86e8: 						if (off.get(i).booleanValue()
1:7fa86e8: 								&& tests[i].test(event.getData())) {
1:7fa86e8: 							long accept = rsult[i].handleEvent(event);
1:7fa86e8: 							if (accept < 0) {
1:7fa86e8: 								off.set(i, Boolean.TRUE);
1:7fa86e8: 								count.decrementAndGet();
1:7fa86e8: 							} else if (accept > delay) {
1:7fa86e8: 								accept = delay;
1:7fa86e8: 							}
1:7fa86e8: 						}
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						try {
1:7fa86e8: 							rsult[i].close(PushEvent.error(e));
1:7fa86e8: 						} catch (Exception e2) {
1:7fa86e8: 							//TODO log
1:7fa86e8: 						}
1:7fa86e8: 						off.set(i, Boolean.TRUE);
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 				if (count.get() == 0)
1:7fa86e8: 					return ABORT;
1:7fa86e8: 
1:7fa86e8: 				return delay;
1:7fa86e8: 			}
1:7fa86e8: 			for (AbstractPushStreamImpl<T> as : rsult) {
1:7fa86e8: 				try {
1:7fa86e8: 					as.handleEvent(event.nodata());
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 					try {
1:7fa86e8: 						as.close(PushEvent.error(e));
1:7fa86e8: 					} catch (Exception e2) {
1:7fa86e8: 						//TODO log
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 			}
1:7fa86e8: 			return ABORT;
1:7fa86e8: 		});
1:7fa86e8: 		return Arrays.copyOf(rsult, tests.length);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public PushStream<T> sequential() {
1:7fa86e8: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		Lock lock = new ReentrantLock();
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 			try {
1:7fa86e8: 				lock.lock();
1:7fa86e8: 				try {
1:7fa86e8: 					return eventStream.handleEvent(event);
1:7fa86e8: 				} finally {
1:7fa86e8: 					lock.unlock();
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> coalesce(
1:7fa86e8: 			Function< ? super T,Optional<R>> accumulator) {
1:7fa86e8: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this);
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					Optional<PushEvent<R>> coalesced = accumulator
1:7fa86e8: 							.apply(event.getData()).map(PushEvent::data);
1:7fa86e8: 					if (coalesced.isPresent()) {
1:7fa86e8: 						try {
1:7fa86e8: 							return eventStream.handleEvent(coalesced.get());
1:7fa86e8: 						} catch (Exception ex) {
1:7fa86e8: 							close(PushEvent.error(ex));
1:7fa86e8: 							return ABORT;
1:7fa86e8: 						}
1:7fa86e8: 					} else {
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 				return eventStream.handleEvent(event.nodata());
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> coalesce(int count, Function<Collection<T>,R> f) {
1:7fa86e8: 		if (count <= 0)
1:7fa86e8: 			throw new IllegalArgumentException(
1:7fa86e8: 					"A coalesce operation must collect a positive number of events");
1:7fa86e8: 		// This could be optimised to only use a single collection queue.
1:7fa86e8: 		// It would save some GC, but is it worth it?
1:7fa86e8: 		return coalesce(() -> count, f);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> coalesce(IntSupplier count,
1:7fa86e8: 			Function<Collection<T>,R> f) {
1:7fa86e8: 		AtomicReference<Queue<T>> queueRef = new AtomicReference<Queue<T>>(
1:7fa86e8: 				null);
1:7fa86e8: 
1:7fa86e8: 		Runnable init = () -> queueRef
1:7fa86e8: 				.set(getQueueForInternalBuffering(count.getAsInt()));
1:7fa86e8: 
1:7fa86e8: 		@SuppressWarnings("resource")
1:7fa86e8: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<R>(
1:7fa86e8: 				psp, defaultExecutor, scheduler, this) {
1:7fa86e8: 			@Override
1:7fa86e8: 			protected void beginning() {
1:7fa86e8: 				init.run();
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 
1:7fa86e8: 		AtomicBoolean endPending = new AtomicBoolean();
1:7fa86e8: 		Object lock = new Object();
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 			try {
1:7fa86e8: 				Queue<T> queue;
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					synchronized (lock) {
1:7fa86e8: 						for (;;) {
1:7fa86e8: 							queue = queueRef.get();
1:7fa86e8: 							if (queue == null) {
1:7fa86e8: 								if (endPending.get()) {
1:7fa86e8: 									return ABORT;
1:7fa86e8: 								} else {
1:7fa86e8: 									continue;
1:7fa86e8: 								}
1:7fa86e8: 							} else if (queue.offer(event.getData())) {
1:7fa86e8: 								return CONTINUE;
1:7fa86e8: 							} else {
1:7fa86e8: 								queueRef.lazySet(null);
1:7fa86e8: 								break;
1:7fa86e8: 							}
1:7fa86e8: 						}
1:7fa86e8: 					}
1:7fa86e8: 
1:7fa86e8: 					queueRef.set(
1:7fa86e8: 							getQueueForInternalBuffering(count.getAsInt()));
1:7fa86e8: 
1:7fa86e8: 					// This call is on the same thread and so must happen
1:7fa86e8: 					// outside
1:7fa86e8: 					// the synchronized block.
1:7fa86e8: 					return aggregateAndForward(f, eventStream, event,
1:7fa86e8: 							queue);
1:7fa86e8: 				} else {
1:7fa86e8: 					synchronized (lock) {
1:7fa86e8: 						queue = queueRef.get();
1:7fa86e8: 						queueRef.lazySet(null);
1:7fa86e8: 						endPending.set(true);
1:7fa86e8: 					}
1:7fa86e8: 					if (queue != null) {
1:7fa86e8: 						eventStream.handleEvent(
1:7fa86e8: 								PushEvent.data(f.apply(queue)));
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 				return eventStream.handleEvent(event.nodata());
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	private <R> long aggregateAndForward(Function<Collection<T>,R> f,
1:7fa86e8: 			AbstractPushStreamImpl<R> eventStream,
1:7fa86e8: 			PushEvent< ? extends T> event, Queue<T> queue) {
1:7fa86e8: 		if (!queue.offer(event.getData())) {
1:7fa86e8: 			((ArrayQueue<T>) queue).forcePush(event.getData());
1:7fa86e8: 		}
1:7fa86e8: 		return eventStream.handleEvent(PushEvent.data(f.apply(queue)));
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> window(Duration time,
1:7fa86e8: 			Function<Collection<T>,R> f) {
1:7fa86e8: 		return window(time, defaultExecutor, f);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> window(Duration time, Executor executor,
1:7fa86e8: 			Function<Collection<T>,R> f) {
1:7fa86e8: 		return window(() -> time, () -> 0, executor, (t, c) -> f.apply(c));
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> window(Supplier<Duration> time,
1:7fa86e8: 			IntSupplier maxEvents,
1:7fa86e8: 			BiFunction<Long,Collection<T>,R> f) {
1:7fa86e8: 		return window(time, maxEvents, defaultExecutor, f);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R> PushStream<R> window(Supplier<Duration> time,
1:7fa86e8: 			IntSupplier maxEvents, Executor ex,
1:7fa86e8: 			BiFunction<Long,Collection<T>,R> f) {
1:7fa86e8: 
1:7fa86e8: 		AtomicLong timestamp = new AtomicLong();
1:7fa86e8: 		AtomicLong counter = new AtomicLong();
1:7fa86e8: 		Object lock = new Object();
1:7fa86e8: 		AtomicReference<Queue<T>> queueRef = new AtomicReference<Queue<T>>(
1:7fa86e8: 				null);
1:7fa86e8: 
1:7fa86e8: 		// This code is declared as a separate block to avoid any confusion
1:7fa86e8: 		// about which instance's methods and variables are in scope
1:7fa86e8: 		Consumer<AbstractPushStreamImpl<R>> begin = p -> {
1:7fa86e8: 
1:7fa86e8: 			synchronized (lock) {
1:7fa86e8: 				timestamp.lazySet(System.nanoTime());
1:7fa86e8: 				long count = counter.get();
1:7fa86e8: 
1:7fa86e8: 
1:7fa86e8: 				scheduler.schedule(
1:7fa86e8: 						getWindowTask(p, f, time, maxEvents, lock, count,
1:7fa86e8: 								queueRef, timestamp, counter, ex),
1:7fa86e8: 						time.get().toNanos(), NANOSECONDS);
1:7fa86e8: 			}
1:7fa86e8: 
1:7fa86e8: 			queueRef.set(getQueueForInternalBuffering(maxEvents.getAsInt()));
1:7fa86e8: 		};
1:7fa86e8: 
1:7fa86e8: 		@SuppressWarnings("resource")
1:7fa86e8: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<R>(
1:7fa86e8: 				psp, ex, scheduler, this) {
1:7fa86e8: 			@Override
1:7fa86e8: 			protected void beginning() {
1:7fa86e8: 				begin.accept(this);
1:7fa86e8: 			}
1:7fa86e8: 		};
1:7fa86e8: 
1:7fa86e8: 		AtomicBoolean endPending = new AtomicBoolean(false);
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (eventStream.closed.get() == CLOSED) {
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 				Queue<T> queue;
1:7fa86e8: 				if (!event.isTerminal()) {
1:7fa86e8: 					long elapsed;
1:7fa86e8: 					long newCount;
1:7fa86e8: 					synchronized (lock) {
1:7fa86e8: 						for (;;) {
1:7fa86e8: 							queue = queueRef.get();
1:7fa86e8: 							if (queue == null) {
1:7fa86e8: 								if (endPending.get()) {
1:7fa86e8: 									return ABORT;
1:7fa86e8: 								} else {
1:7fa86e8: 									continue;
1:7fa86e8: 								}
1:7fa86e8: 							} else if (queue.offer(event.getData())) {
1:7fa86e8: 								return CONTINUE;
1:7fa86e8: 							} else {
1:7fa86e8: 								queueRef.lazySet(null);
1:7fa86e8: 								break;
1:7fa86e8: 							}
1:7fa86e8: 						}
1:7fa86e8: 
1:7fa86e8: 						long now = System.nanoTime();
1:7fa86e8: 						elapsed = now - timestamp.get();
1:7fa86e8: 						timestamp.lazySet(now);
1:7fa86e8: 						newCount = counter.get() + 1;
1:7fa86e8: 						counter.lazySet(newCount);
1:7fa86e8: 
1:7fa86e8: 						// This is a non-blocking call, and must happen in the
1:7fa86e8: 						// synchronized block to avoid re=ordering the executor
1:7fa86e8: 						// enqueue with a subsequent incoming close operation
1:7fa86e8: 						aggregateAndForward(f, eventStream, event, queue,
1:7fa86e8: 								ex, elapsed);
1:7fa86e8: 					}
1:7fa86e8: 					// These must happen outside the synchronized block as we
1:7fa86e8: 					// call out to user code
1:7fa86e8: 					queueRef.set(
1:7fa86e8: 							getQueueForInternalBuffering(maxEvents.getAsInt()));
1:7fa86e8: 					scheduler.schedule(
1:7fa86e8: 							getWindowTask(eventStream, f, time, maxEvents, lock,
1:7fa86e8: 									newCount, queueRef, timestamp, counter, ex),
1:7fa86e8: 							time.get().toNanos(), NANOSECONDS);
1:7fa86e8: 
1:7fa86e8: 					return CONTINUE;
1:7fa86e8: 				} else {
1:7fa86e8: 					long elapsed;
1:7fa86e8: 					synchronized (lock) {
1:7fa86e8: 						queue = queueRef.get();
1:7fa86e8: 						queueRef.lazySet(null);
1:7fa86e8: 						endPending.set(true);
1:7fa86e8: 						long now = System.nanoTime();
1:7fa86e8: 						elapsed = now - timestamp.get();
1:7fa86e8: 						counter.lazySet(counter.get() + 1);
1:7fa86e8: 					}
1:7fa86e8: 					Collection<T> collected = queue == null ? emptyList()
1:7fa86e8: 							: queue;
1:7fa86e8: 					ex.execute(() -> {
1:7fa86e8: 						try {
1:7fa86e8: 							eventStream
1:7fa86e8: 									.handleEvent(PushEvent.data(f.apply(
1:7fa86e8: 											Long.valueOf(NANOSECONDS
1:7fa86e8: 													.toMillis(elapsed)),
1:7fa86e8: 											collected)));
1:7fa86e8: 						} catch (Exception e) {
1:7fa86e8: 							close(PushEvent.error(e));
1:7fa86e8: 						}
1:7fa86e8: 					});
1:7fa86e8: 				}
1:7fa86e8: 				ex.execute(() -> eventStream.handleEvent(event.nodata()));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		return eventStream;
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	protected Queue<T> getQueueForInternalBuffering(int size) {
1:7fa86e8: 		if (size == 0) {
1:7fa86e8: 			return new LinkedList<T>();
1:7fa86e8: 		} else {
1:7fa86e8: 			return new ArrayQueue<>(size - 1);
1:7fa86e8: 		}
1:7fa86e8: 	}
1:7fa86e8: 	
1:7fa86e8: 	@SuppressWarnings("unchecked")
1:7fa86e8: 	/**
1:7fa86e8: 	 * A special queue that keeps one element in reserve and can have that last
1:7fa86e8: 	 * element set using forcePush. After the element is set the capacity is
1:7fa86e8: 	 * permanently increased by one and cannot grow further.
1:7fa86e8: 	 * 
1:7fa86e8: 	 * @param <E> The element type
1:7fa86e8: 	 */
1:7fa86e8: 	private static class ArrayQueue<E> extends AbstractQueue<E>
1:7fa86e8: 			implements Queue<E> {
1:7fa86e8: 
1:7fa86e8: 		final Object[]	store;
1:7fa86e8: 
1:7fa86e8: 		int				normalLength;
1:7fa86e8: 
1:7fa86e8: 		int				nextIndex;
1:7fa86e8: 
1:7fa86e8: 		int				size;
1:7fa86e8: 
1:7fa86e8: 		ArrayQueue(int capacity) {
1:7fa86e8: 			store = new Object[capacity + 1];
1:7fa86e8: 			normalLength = store.length - 1;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public boolean offer(E e) {
1:7fa86e8: 			if (e == null)
1:7fa86e8: 				throw new NullPointerException("Null values are not supported");
1:7fa86e8: 			if (size < normalLength) {
1:7fa86e8: 				store[nextIndex] = e;
1:7fa86e8: 				size++;
1:7fa86e8: 				nextIndex++;
1:7fa86e8: 				nextIndex = nextIndex % normalLength;
1:7fa86e8: 				return true;
1:7fa86e8: 			}
1:7fa86e8: 			return false;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		public void forcePush(E e) {
1:7fa86e8: 			store[normalLength] = e;
1:7fa86e8: 			normalLength++;
1:7fa86e8: 			size++;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public E poll() {
1:7fa86e8: 			if (size == 0) {
1:7fa86e8: 				return null;
1:7fa86e8: 			} else {
1:7fa86e8: 				int idx = nextIndex - size;
1:7fa86e8: 				if (idx < 0) {
1:7fa86e8: 					idx += normalLength;
1:7fa86e8: 				}
1:7fa86e8: 				E value = (E) store[idx];
1:7fa86e8: 				store[idx] = null;
1:7fa86e8: 				size--;
1:7fa86e8: 				return value;
1:7fa86e8: 			}
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public E peek() {
1:7fa86e8: 			if (size == 0) {
1:7fa86e8: 				return null;
1:7fa86e8: 			} else {
1:7fa86e8: 				int idx = nextIndex - size;
1:7fa86e8: 				if (idx < 0) {
1:7fa86e8: 					idx += normalLength;
1:7fa86e8: 				}
1:7fa86e8: 				return (E) store[idx];
1:7fa86e8: 			}
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public Iterator<E> iterator() {
1:7fa86e8: 			final int previousNext = nextIndex;
1:7fa86e8: 			return new Iterator<E>() {
1:7fa86e8: 
1:7fa86e8: 				int idx;
1:7fa86e8: 
1:7fa86e8: 				int	remaining	= size;
1:7fa86e8: 
1:7fa86e8: 				{
1:7fa86e8: 					idx = nextIndex - size;
1:7fa86e8: 					if (idx < 0) {
1:7fa86e8: 						idx += normalLength;
1:7fa86e8: 					}
1:7fa86e8: 				}
1:7fa86e8: 
1:7fa86e8: 				@Override
1:7fa86e8: 				public boolean hasNext() {
1:7fa86e8: 					if (nextIndex != previousNext) {
1:7fa86e8: 						throw new ConcurrentModificationException(
1:7fa86e8: 								"The queue was concurrently modified");
1:7fa86e8: 					}
1:7fa86e8: 					return remaining > 0;
1:7fa86e8: 				}
1:7fa86e8: 
1:7fa86e8: 				@Override
1:7fa86e8: 				public E next() {
1:7fa86e8: 					if (!hasNext()) {
1:7fa86e8: 						throw new NoSuchElementException(
1:7fa86e8: 								"The iterator has no more values");
1:7fa86e8: 					}
1:7fa86e8: 					E value = (E) store[idx];
1:7fa86e8: 					idx++;
1:7fa86e8: 					remaining--;
1:7fa86e8: 					if (idx == normalLength) {
1:7fa86e8: 						idx = 0;
1:7fa86e8: 					}
1:7fa86e8: 					return value;
1:7fa86e8: 				}
1:7fa86e8: 
1:7fa86e8: 			};
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 		@Override
1:7fa86e8: 		public int size() {
1:7fa86e8: 			return size;
1:7fa86e8: 		}
1:7fa86e8: 
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	private <R> Runnable getWindowTask(AbstractPushStreamImpl<R> eventStream,
1:7fa86e8: 			BiFunction<Long,Collection<T>,R> f, Supplier<Duration> time,
1:7fa86e8: 			IntSupplier maxEvents, Object lock, long expectedCounter,
1:7fa86e8: 			AtomicReference<Queue<T>> queueRef, AtomicLong timestamp,
1:7fa86e8: 			AtomicLong counter, Executor executor) {
1:7fa86e8: 		return () -> {
1:7fa86e8: 
1:7fa86e8: 			Queue<T> queue = null;
1:7fa86e8: 			long elapsed;
1:7fa86e8: 			synchronized (lock) {
1:7fa86e8: 				
1:7fa86e8: 				if (counter.get() != expectedCounter) {
1:7fa86e8: 					return;
1:7fa86e8: 				}
1:7fa86e8: 				counter.lazySet(expectedCounter + 1);
1:7fa86e8: 
1:7fa86e8: 				long now = System.nanoTime();
1:7fa86e8: 				elapsed = now - timestamp.get();
1:7fa86e8: 				timestamp.lazySet(now);
1:7fa86e8: 
1:7fa86e8: 				queue = queueRef.get();
1:7fa86e8: 				queueRef.lazySet(null);
1:7fa86e8: 
1:7fa86e8: 				// This is a non-blocking call, and must happen in the
1:7fa86e8: 				// synchronized block to avoid re=ordering the executor
1:7fa86e8: 				// enqueue with a subsequent incoming close operation
1:7fa86e8: 
1:7fa86e8: 				Collection<T> collected = queue == null ? emptyList() : queue;
1:7fa86e8: 				executor.execute(() -> {
1:7fa86e8: 					try {
1:7fa86e8: 						eventStream.handleEvent(PushEvent.data(f.apply(
1:7fa86e8: 								Long.valueOf(NANOSECONDS.toMillis(elapsed)),
1:7fa86e8: 								collected)));
1:7fa86e8: 					} catch (Exception e) {
1:7fa86e8: 						close(PushEvent.error(e));
1:7fa86e8: 					}
1:7fa86e8: 				});
1:7fa86e8: 			}
1:7fa86e8: 
1:7fa86e8: 			// These must happen outside the synchronized block as we
1:7fa86e8: 			// call out to user code
1:7fa86e8: 			queueRef.set(getQueueForInternalBuffering(maxEvents.getAsInt()));
1:7fa86e8: 			scheduler.schedule(
1:7fa86e8: 					getWindowTask(eventStream, f, time, maxEvents, lock,
1:7fa86e8: 							expectedCounter + 1, queueRef, timestamp, counter,
1:7fa86e8: 							executor),
1:7fa86e8: 					time.get().toNanos(), NANOSECONDS);
1:7fa86e8: 		};
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	private <R> void aggregateAndForward(BiFunction<Long,Collection<T>,R> f,
1:7fa86e8: 			AbstractPushStreamImpl<R> eventStream,
1:7fa86e8: 			PushEvent< ? extends T> event, Queue<T> queue, Executor executor,
1:7fa86e8: 			long elapsed) {
1:7fa86e8: 		executor.execute(() -> {
1:7fa86e8: 			try {
1:7fa86e8: 				if (!queue.offer(event.getData())) {
1:7fa86e8: 					((ArrayQueue<T>) queue).forcePush(event.getData());
1:7fa86e8: 				}
1:7fa86e8: 				long result = eventStream.handleEvent(PushEvent.data(
1:7fa86e8: 						f.apply(Long.valueOf(NANOSECONDS.toMillis(elapsed)),
1:7fa86e8: 								queue)));
1:7fa86e8: 				if (result < 0) {
1:7fa86e8: 					close();
1:7fa86e8: 				}
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Void> forEach(Consumer< ? super T> action) {
1:7fa86e8: 		Deferred<Void> d = new Deferred<>();
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 				try {
1:7fa86e8: 					switch(event.getType()) {
1:7fa86e8: 						case DATA:
1:7fa86e8: 							action.accept(event.getData());
1:7fa86e8: 							return CONTINUE;
1:7fa86e8: 						case CLOSE:
1:7fa86e8: 							d.resolve(null);
1:7fa86e8: 							break;
1:7fa86e8: 						case ERROR:
1:7fa86e8: 							d.fail(event.getFailure());
1:7fa86e8: 							break;
1:7fa86e8: 					}
1:7fa86e8: 					close(event.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 					d.fail(e);
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 			});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Object[]> toArray() {
1:7fa86e8: 		return collect(Collectors.toList())
1:7fa86e8: 				.map(List::toArray);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <A extends T> Promise<A[]> toArray(IntFunction<A[]> generator) {
1:7fa86e8: 		return collect(Collectors.toList())
1:7fa86e8: 				.map(l -> l.toArray(generator.apply(l.size())));
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<T> reduce(T identity, BinaryOperator<T> accumulator) {
1:7fa86e8: 		Deferred<T> d = new Deferred<>();
1:7fa86e8: 		AtomicReference<T> iden = new AtomicReference<T>(identity);
1:7fa86e8: 
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				switch(event.getType()) {
1:7fa86e8: 					case DATA:
1:7fa86e8: 						iden.accumulateAndGet(event.getData(), accumulator);
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					case CLOSE:
1:7fa86e8: 						d.resolve(iden.get());
1:7fa86e8: 						break;
1:7fa86e8: 					case ERROR:
1:7fa86e8: 						d.fail(event.getFailure());
1:7fa86e8: 						break;
1:7fa86e8: 				}
1:7fa86e8: 				close(event.nodata());
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Optional<T>> reduce(BinaryOperator<T> accumulator) {
1:7fa86e8: 		Deferred<Optional<T>> d = new Deferred<>();
1:7fa86e8: 		AtomicReference<T> iden = new AtomicReference<T>(null);
1:7fa86e8: 
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				switch(event.getType()) {
1:7fa86e8: 					case DATA:
1:7fa86e8: 						if (!iden.compareAndSet(null, event.getData()))
1:7fa86e8: 							iden.accumulateAndGet(event.getData(), accumulator);
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					case CLOSE:
1:7fa86e8: 						d.resolve(Optional.ofNullable(iden.get()));
1:7fa86e8: 						break;
1:7fa86e8: 					case ERROR:
1:7fa86e8: 						d.fail(event.getFailure());
1:7fa86e8: 						break;
1:7fa86e8: 				}
1:7fa86e8: 				close(event.nodata());
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <U> Promise<U> reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
1:7fa86e8: 		Deferred<U> d = new Deferred<>();
1:7fa86e8: 		AtomicReference<U> iden = new AtomicReference<>(identity);
1:7fa86e8: 
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				switch(event.getType()) {
1:7fa86e8: 					case DATA:
1:7fa86e8: 						iden.updateAndGet((e) -> accumulator.apply(e, event.getData()));
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					case CLOSE:
1:7fa86e8: 						d.resolve(iden.get());
1:7fa86e8: 						break;
1:7fa86e8: 					case ERROR:
1:7fa86e8: 						d.fail(event.getFailure());
1:7fa86e8: 						break;
1:7fa86e8: 				}
1:7fa86e8: 				close(event.nodata());
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public <R, A> Promise<R> collect(Collector<? super T, A, R> collector) {
1:7fa86e8: 		A result = collector.supplier().get();
1:7fa86e8: 		Deferred<R> d = new Deferred<>();
1:7fa86e8: 		updateNext(event -> {
1:7fa86e8: 			try {
1:7fa86e8: 				switch(event.getType()) {
1:7fa86e8: 					case DATA:
1:7fa86e8: 						collector.accumulator().accept(result, event.getData());
1:7fa86e8: 						return CONTINUE;
1:7fa86e8: 					case CLOSE:
1:7fa86e8: 						d.resolve(collector.finisher().apply(result));
1:7fa86e8: 						break;
1:7fa86e8: 					case ERROR:
1:7fa86e8: 						d.fail(event.getFailure());
1:7fa86e8: 						break;
1:7fa86e8: 				}
1:7fa86e8: 				close(event.nodata());
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Optional<T>> min(Comparator<? super T> comparator)  {
1:7fa86e8: 		return reduce((a, b) -> comparator.compare(a, b) <= 0 ? a : b);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Optional<T>> max(Comparator<? super T> comparator) {
1:7fa86e8: 		return reduce((a, b) -> comparator.compare(a, b) > 0 ? a : b);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Long> count() {
1:7fa86e8: 		Deferred<Long> d = new Deferred<>();
1:7fa86e8: 		LongAdder counter = new LongAdder();
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 				try {
1:7fa86e8: 					switch(event.getType()) {
1:7fa86e8: 						case DATA:
1:7fa86e8: 						counter.add(1);
1:7fa86e8: 							return CONTINUE;
1:7fa86e8: 						case CLOSE:
1:7fa86e8: 						d.resolve(Long.valueOf(counter.sum()));
1:7fa86e8: 							break;
1:7fa86e8: 						case ERROR:
1:7fa86e8: 							d.fail(event.getFailure());
1:7fa86e8: 							break;
1:7fa86e8: 					}
1:7fa86e8: 					close(event.nodata());
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 			});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Boolean> anyMatch(Predicate<? super T> predicate) {
1:7fa86e8: 		return filter(predicate).findAny()
1:7fa86e8: 			.map(Optional::isPresent);
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Boolean> allMatch(Predicate<? super T> predicate) {
1:7fa86e8: 		return filter(x -> !predicate.test(x)).findAny()
1:7fa86e8: 				.map(o -> Boolean.valueOf(!o.isPresent()));
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Boolean> noneMatch(Predicate<? super T> predicate) {
1:7fa86e8: 		return filter(predicate).findAny()
1:7fa86e8: 				.map(o -> Boolean.valueOf(!o.isPresent()));
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Optional<T>> findFirst() {
1:7fa86e8: 		Deferred<Optional<T>> d = new Deferred<>();
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 				try {
1:7fa86e8: 					Optional<T> o = null;
1:7fa86e8: 					switch(event.getType()) {
1:7fa86e8: 						case DATA:
1:7fa86e8: 							o = Optional.of(event.getData());
1:7fa86e8: 							break;
1:7fa86e8: 						case CLOSE:
1:7fa86e8: 							o = Optional.empty();
1:7fa86e8: 							break;
1:7fa86e8: 						case ERROR:
1:7fa86e8: 							d.fail(event.getFailure());
1:7fa86e8: 							return ABORT;
1:7fa86e8: 					}
1:7fa86e8: 					if(!d.getPromise().isDone())
1:7fa86e8: 						d.resolve(o);
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 					return ABORT;
1:7fa86e8: 				}
1:7fa86e8: 			});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Optional<T>> findAny() {
1:7fa86e8: 		return findFirst();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: 	@Override
1:7fa86e8: 	public Promise<Long> forEachEvent(PushEventConsumer< ? super T> action) {
1:7fa86e8: 		Deferred<Long> d = new Deferred<>();
1:7fa86e8: 		LongAdder la = new LongAdder();
1:7fa86e8: 		updateNext((event) -> {
1:7fa86e8: 			try {
1:7fa86e8: 				switch(event.getType()) {
1:7fa86e8: 					case DATA:
1:7fa86e8: 						long value = action.accept(event);
1:7fa86e8: 						la.add(value);
1:7fa86e8: 						return value;
1:7fa86e8: 					case CLOSE:
1:7fa86e8: 						try {
1:7fa86e8: 							action.accept(event);
1:7fa86e8: 						} finally {
1:7fa86e8: 							d.resolve(Long.valueOf(la.sum()));
1:7fa86e8: 						}
1:7fa86e8: 						break;
1:7fa86e8: 					case ERROR:
1:7fa86e8: 						try {
1:7fa86e8: 							action.accept(event);
1:7fa86e8: 						} finally {
1:7fa86e8: 							d.fail(event.getFailure());
1:7fa86e8: 						}
1:7fa86e8: 						break;
1:7fa86e8: 				}
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			} catch (Exception e) {
1:7fa86e8: 				close(PushEvent.error(e));
1:7fa86e8: 				return ABORT;
1:7fa86e8: 			}
1:7fa86e8: 		});
1:7fa86e8: 		begin();
1:7fa86e8: 		return d.getPromise();
1:7fa86e8: 	}
1:7fa86e8: 
1:7fa86e8: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:7fa86e8
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.pushstream;
1: 
1: import static java.util.Collections.emptyList;
1: import static java.util.concurrent.TimeUnit.NANOSECONDS;
1: import static org.apache.aries.pushstream.AbstractPushStreamImpl.State.*;
1: import static org.osgi.util.pushstream.PushEventConsumer.*;
1: 
1: import java.time.Duration;
1: import java.util.AbstractQueue;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.Comparator;
1: import java.util.ConcurrentModificationException;
1: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.NoSuchElementException;
1: import java.util.Optional;
1: import java.util.Queue;
1: import java.util.Set;
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.Executor;
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.Semaphore;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.atomic.AtomicLong;
1: import java.util.concurrent.atomic.AtomicReference;
1: import java.util.concurrent.atomic.AtomicReferenceArray;
1: import java.util.concurrent.atomic.LongAdder;
1: import java.util.concurrent.locks.Lock;
1: import java.util.concurrent.locks.ReentrantLock;
1: import java.util.function.BiFunction;
1: import java.util.function.BinaryOperator;
1: import java.util.function.Consumer;
1: import java.util.function.Function;
1: import java.util.function.IntFunction;
1: import java.util.function.IntSupplier;
1: import java.util.function.Predicate;
1: import java.util.function.Supplier;
1: import java.util.stream.Collector;
1: import java.util.stream.Collectors;
1: 
1: import org.osgi.util.promise.Deferred;
1: import org.osgi.util.promise.Promise;
1: import org.osgi.util.pushstream.PushEvent;
1: import org.osgi.util.pushstream.PushEventConsumer;
1: import org.osgi.util.pushstream.PushEventSource;
1: import org.osgi.util.pushstream.PushStream;
1: import org.osgi.util.pushstream.PushStreamBuilder;
1: import org.osgi.util.pushstream.PushStreamProvider;
1: import org.osgi.util.pushstream.PushEvent.EventType;
1: 
1: public abstract class AbstractPushStreamImpl<T> implements PushStream<T> {
1: 	
1: 	public static enum State {
1: 		BUILDING, STARTED, CLOSED
1: 	}
1: 	
1: 	protected final PushStreamProvider								psp;
1: 	
1: 	protected final Executor										defaultExecutor;
1: 	protected final ScheduledExecutorService						scheduler;
1: 
1: 	protected final AtomicReference<State> closed = new AtomicReference<>(BUILDING);
1: 	
1: 	protected final AtomicReference<PushEventConsumer<T>>			next			= new AtomicReference<>();
1: 	
1: 	protected final AtomicReference<Runnable> onCloseCallback = new AtomicReference<>();
1: 	protected final AtomicReference<Consumer<? super Throwable>> onErrorCallback = new AtomicReference<>();
1: 
1: 	protected abstract boolean begin();
1: 	
1: 	protected AbstractPushStreamImpl(PushStreamProvider psp,
1: 			Executor executor, ScheduledExecutorService scheduler) {
1: 		this.psp = psp;
1: 		this.defaultExecutor = executor;
1: 		this.scheduler = scheduler;
1: 	}
1: 
1: 	protected long handleEvent(PushEvent< ? extends T> event) {
1: 		if(closed.get() != CLOSED) {
1: 			try {
1: 				if(event.isTerminal()) {
1: 					close(event.nodata());
1: 					return ABORT;
1: 				} else {
1: 					PushEventConsumer<T> consumer = next.get();
1: 					long val;
1: 					if(consumer == null) {
1: 						//TODO log a warning
1: 						val = CONTINUE;
1: 					} else {
1: 						val = consumer.accept(event);
1: 					}
1: 					if(val < 0) {
1: 						close();
1: 					}
1: 					return val;
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		}
1: 		return ABORT;
1: 	}
1: 	
1: 	@Override
1: 	public void close() {
1: 		close(PushEvent.close());
1: 	}
1: 	
1: 	protected boolean close(PushEvent<T> event) {
1: 		if(!event.isTerminal()) {
1: 			throw new IllegalArgumentException("The event " + event  + " is not a close event.");
1: 		}
1: 		if(closed.getAndSet(CLOSED) != CLOSED) {
1: 			PushEventConsumer<T> aec = next.getAndSet(null);
1: 			if(aec != null) {
1: 				try {
1: 					aec.accept(event);
1: 				} catch (Exception e) {
1: 					// TODO Auto-generated catch block
1: 					e.printStackTrace();
1: 				}
1: 			}
1: 			Runnable handler = onCloseCallback.getAndSet(null);
1: 			if(handler != null) {
1: 				try {
1: 					handler.run();
1: 				} catch (Exception e) {
1: 					// TODO Auto-generated catch block
1: 					e.printStackTrace();
1: 				}
1: 			}
1: 			if (event.getType() == EventType.ERROR) {
1: 				Consumer<? super Throwable> errorHandler = onErrorCallback.getAndSet(null);
1: 				if(errorHandler != null) {
1: 					try {
1: 						errorHandler.accept(event.getFailure());
1: 					} catch (Exception e) {
1: 						// TODO Auto-generated catch block
1: 						e.printStackTrace();
1: 					}
1: 				}
1: 			}
1: 			return true;
1: 		}
1: 		return false;
1: 	}
1: 	
1: 	@Override
1: 	public PushStream<T> onClose(Runnable closeHandler) {
1: 		if(onCloseCallback.compareAndSet(null, closeHandler)) {
1: 			if(closed.get() == State.CLOSED && onCloseCallback.compareAndSet(closeHandler, null)) {
1: 				closeHandler.run();
1: 			}
1: 		} else {
1: 			throw new IllegalStateException("A close handler has already been defined for this stream object");
1: 		}
1: 		return this;
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> onError(Consumer< ? super Throwable> closeHandler) {
1: 		if(onErrorCallback.compareAndSet(null, closeHandler)) {
1: 			if(closed.get() == State.CLOSED) { 
1: 				//TODO log already closed
1: 				onErrorCallback.set(null);
1: 			}
1: 		} else {
1: 			throw new IllegalStateException("A close handler has already been defined for this stream object");
1: 		}
1: 		return this;
1: 	}
1: 
1: 	private void updateNext(PushEventConsumer<T> consumer) {
1: 		if(!next.compareAndSet(null, consumer)) {
1: 			throw new IllegalStateException("This stream has already been chained");
1: 		} else if(closed.get() == CLOSED && next.compareAndSet(consumer, null)) {
1: 			try {
1: 				consumer.accept(PushEvent.close());
1: 			} catch (Exception e) {
1: 				//TODO log
1: 				e.printStackTrace();
1: 			}
1: 		}
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> filter(Predicate< ? super T> predicate) {
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		updateNext((event) -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					if (predicate.test(event.getData())) {
1: 						return eventStream.handleEvent(event);
1: 					} else {
1: 						return CONTINUE;
1: 					}
1: 				}
1: 				return eventStream.handleEvent(event);
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> map(Function< ? super T, ? extends R> mapper) {
1: 		
1: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		updateNext(event -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					return eventStream.handleEvent(
1: 							PushEvent.data(mapper.apply(event.getData())));
1: 				} else {
1: 					return eventStream.handleEvent(event.nodata());
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> flatMap(
1: 			Function< ? super T, ? extends PushStream< ? extends R>> mapper) {
1: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 
1: 		PushEventConsumer<R> consumer = e -> {
1: 			switch (e.getType()) {
1: 				case ERROR :
1: 					close(e.nodata());
1: 					return ABORT;
1: 				case CLOSE :
1: 					// Close should allow the next flat mapped entry
1: 					// without closing the stream;
1: 					return ABORT;
1: 				case DATA :
1: 					long returnValue = eventStream.handleEvent(e);
1: 					if (returnValue < 0) {
1: 						close();
1: 						return ABORT;
1: 					}
1: 					return returnValue;
1: 				default :
1: 					throw new IllegalArgumentException(
1: 							"The event type " + e.getType() + " is unknown");
1: 			}
1: 		};
1: 
1: 		updateNext(event -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					PushStream< ? extends R> mappedStream = mapper
1: 							.apply(event.getData());
1: 
1: 					return mappedStream.forEachEvent(consumer)
1: 							.getValue()
1: 							.longValue();
1: 				} else {
1: 					return eventStream.handleEvent(event.nodata());
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> distinct() {
1: 		Set<T> set = Collections.<T>newSetFromMap(new ConcurrentHashMap<>());
1: 		return filter(set::add);
1: 	}
1: 
1: 	@SuppressWarnings({ "rawtypes", "unchecked" })
1: 	@Override
1: 	public PushStream<T> sorted() {
1: 		return sorted((Comparator)Comparator.naturalOrder());
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> sorted(Comparator< ? super T> comparator) {
1: 		List<T> list = Collections.synchronizedList(new ArrayList<>());
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		updateNext(event -> {
1: 			try {
1: 				switch(event.getType()) {
1: 					case DATA : 
1: 						list.add(event.getData());
1: 						return CONTINUE;
1: 					case CLOSE :
1: 						list.sort(comparator);
1: 						for(T t : list) {
1: 							eventStream.handleEvent(PushEvent.data(t));
1: 						}
1: 						return ABORT;
1: 					case ERROR :
1: 						return eventStream.handleEvent(event.nodata());
1: 				}
1: 				return eventStream.handleEvent(event.nodata());
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> limit(long maxSize) {
1: 		if(maxSize <= 0) {
1: 			throw new IllegalArgumentException("The limit must be greater than zero");
1: 		}
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		AtomicLong counter = new AtomicLong(maxSize);
1: 		updateNext(event -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					long count = counter.decrementAndGet();
1: 					if (count > 0) {
1: 						return eventStream.handleEvent(event);
1: 					} else if (count == 0) {
1: 						eventStream.handleEvent(event);
1: 					}
1: 					return ABORT;
1: 				} else {
1: 					return eventStream.handleEvent(event.nodata());
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> skip(long n) {
1: 		if(n <= 0) {
1: 			throw new IllegalArgumentException("The number to skip must be greater than zero");
1: 		}
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		AtomicLong counter = new AtomicLong(n);
1: 		updateNext(event -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					if (counter.get() > 0 && counter.decrementAndGet() >= 0) {
1: 						return CONTINUE;
1: 					} else {
1: 						return eventStream.handleEvent(event);
1: 					} 				
1: 				} else {
1: 					return eventStream.handleEvent(event.nodata());
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> fork(int n, int delay, Executor ex) {
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, ex, scheduler, this);
1: 		Semaphore s = new Semaphore(n);
1: 		updateNext(event -> {
1: 			try {
1: 				if (event.isTerminal()) {
1: 					s.acquire(n);
1: 					eventStream.close(event.nodata());
1: 					return ABORT;
1: 				}
1: 	
1: 				s.acquire(1);
1: 	
1: 				ex.execute(() -> {
1: 					try {
1: 						if (eventStream.handleEvent(event) < 0) {
1: 							eventStream.close(PushEvent.close());
1: 						}
1: 					} catch (Exception e1) {
1: 						close(PushEvent.error(e1));
1: 					} finally {
1: 						s.release(1);
1: 					}
1: 				});
1: 	
1: 				return s.getQueueLength() * delay;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 
1: 		return eventStream;
1: 	}
1: 	
1: 	@Override
1: 	public PushStream<T> buffer() {
1: 		return psp.createStream(c -> {
1: 			forEachEvent(c);
1: 			return this;
1: 		});
1: 	}
1: 
1: 	@Override
1: 	public <U extends BlockingQueue<PushEvent< ? extends T>>> PushStreamBuilder<T,U> buildBuffer() {
1: 		return psp.buildStream(c -> {
1: 			forEachEvent(c);
1: 			return this;
1: 		});
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> merge(
1: 			PushEventSource< ? extends T> source) {
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		AtomicInteger count = new AtomicInteger(2);
1: 		PushEventConsumer<T> consumer = event -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					return eventStream.handleEvent(event);
1: 				}
1: 	
1: 				if (count.decrementAndGet() == 0) {
1: 					eventStream.handleEvent(event.nodata());
1: 					return ABORT;
1: 				}
1: 				return CONTINUE;
1: 			} catch (Exception e) {
1: 				PushEvent<T> error = PushEvent.error(e);
1: 				close(error);
1: 				eventStream.close(event.nodata());
1: 				return ABORT;
1: 			}
1: 		};
1: 		updateNext(consumer);
1: 		AutoCloseable second;
1: 		try {
1: 			second = source.open((PushEvent< ? extends T> event) -> {
1: 				return consumer.accept(event);
1: 			});
1: 		} catch (Exception e) {
1: 			// TODO Auto-generated catch block
1: 			e.printStackTrace();
1: 			throw new IllegalStateException(
1: 					"Unable to merge events as the event source could not be opened.",
1: 					e);
1: 		}
1: 		
1: 		return eventStream.onClose(() -> {
1: 			try {
1: 				second.close();
1: 			} catch (Exception e) {
1: 				// TODO Auto-generated catch block
1: 				e.printStackTrace();
1: 			} 
1: 		}).map(Function.identity());
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> merge(PushStream< ? extends T> source) {
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		AtomicInteger count = new AtomicInteger(2);
1: 		PushEventConsumer<T> consumer = event -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					return eventStream.handleEvent(event);
1: 				}
1: 				
1: 				if (count.decrementAndGet() == 0) {
1: 					eventStream.handleEvent(event.nodata());
1: 					return ABORT;
1: 				}
1: 				return CONTINUE;
1: 			} catch (Exception e) {
1: 				PushEvent<T> error = PushEvent.error(e);
1: 				close(error);
1: 				eventStream.close(event.nodata());
1: 				return ABORT;
1: 			}
1: 		};
1: 		updateNext(consumer);
1: 		try {
1: 			source.forEachEvent(event -> {
1: 				return consumer.accept(event);
1: 			}).then(p -> {
1: 				count.decrementAndGet();
1: 				consumer.accept(PushEvent.close());
1: 				return null;
1: 			}, p -> {
1: 				count.decrementAndGet();
1: 				consumer.accept(PushEvent.error((Exception) p.getFailure()));
1: 			});
1: 		} catch (Exception e) {
1: 			// TODO Auto-generated catch block
1: 			e.printStackTrace();
1: 			throw new IllegalStateException(
1: 					"Unable to merge events as the event source could not be opened.",
1: 					e);
1: 		}
1: 		
1: 		return eventStream.onClose(() -> {
1: 			try {
1: 				source.close();
1: 			} catch (Exception e) {
1: 				// TODO Auto-generated catch block
1: 				e.printStackTrace();
1: 			} 
1: 		}).map(Function.identity());
1: 	}
1: 
1: 	@SuppressWarnings("unchecked")
1: 	@Override
1: 	public PushStream<T>[] split(Predicate< ? super T>... predicates) {
1: 		Predicate<? super T>[] tests = Arrays.copyOf(predicates, predicates.length);
1: 		AbstractPushStreamImpl<T>[] rsult = new AbstractPushStreamImpl[tests.length];
1: 		for(int i = 0; i < tests.length; i++) {
1: 			rsult[i] = new IntermediatePushStreamImpl<>(psp, defaultExecutor,
1: 					scheduler, this);
1: 		}
1: 		AtomicReferenceArray<Boolean> off = new AtomicReferenceArray<>(tests.length);
1: 		AtomicInteger count = new AtomicInteger(tests.length);
1: 		updateNext(event -> {
1: 			if (!event.isTerminal()) {
1: 				long delay = CONTINUE;
1: 				for (int i = 0; i < tests.length; i++) {
1: 					try {
1: 						if (off.get(i).booleanValue()
1: 								&& tests[i].test(event.getData())) {
1: 							long accept = rsult[i].handleEvent(event);
1: 							if (accept < 0) {
1: 								off.set(i, Boolean.TRUE);
1: 								count.decrementAndGet();
1: 							} else if (accept > delay) {
1: 								accept = delay;
1: 							}
1: 						}
1: 					} catch (Exception e) {
1: 						try {
1: 							rsult[i].close(PushEvent.error(e));
1: 						} catch (Exception e2) {
1: 							//TODO log
1: 						}
1: 						off.set(i, Boolean.TRUE);
1: 					}
1: 				}
1: 				if (count.get() == 0)
1: 					return ABORT;
1: 
1: 				return delay;
1: 			}
1: 			for (AbstractPushStreamImpl<T> as : rsult) {
1: 				try {
1: 					as.handleEvent(event.nodata());
1: 				} catch (Exception e) {
1: 					try {
1: 						as.close(PushEvent.error(e));
1: 					} catch (Exception e2) {
1: 						//TODO log
1: 					}
1: 				}
1: 			}
1: 			return ABORT;
1: 		});
1: 		return Arrays.copyOf(rsult, tests.length);
1: 	}
1: 
1: 	@Override
1: 	public PushStream<T> sequential() {
1: 		AbstractPushStreamImpl<T> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		Lock lock = new ReentrantLock();
1: 		updateNext((event) -> {
1: 			try {
1: 				lock.lock();
1: 				try {
1: 					return eventStream.handleEvent(event);
1: 				} finally {
1: 					lock.unlock();
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> coalesce(
1: 			Function< ? super T,Optional<R>> accumulator) {
1: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<>(
1: 				psp, defaultExecutor, scheduler, this);
1: 		updateNext((event) -> {
1: 			try {
1: 				if (!event.isTerminal()) {
1: 					Optional<PushEvent<R>> coalesced = accumulator
1: 							.apply(event.getData()).map(PushEvent::data);
1: 					if (coalesced.isPresent()) {
1: 						try {
1: 							return eventStream.handleEvent(coalesced.get());
1: 						} catch (Exception ex) {
1: 							close(PushEvent.error(ex));
1: 							return ABORT;
1: 						}
1: 					} else {
1: 						return CONTINUE;
1: 					}
1: 				}
1: 				return eventStream.handleEvent(event.nodata());
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> coalesce(int count, Function<Collection<T>,R> f) {
1: 		if (count <= 0)
1: 			throw new IllegalArgumentException(
1: 					"A coalesce operation must collect a positive number of events");
1: 		// This could be optimised to only use a single collection queue.
1: 		// It would save some GC, but is it worth it?
1: 		return coalesce(() -> count, f);
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> coalesce(IntSupplier count,
1: 			Function<Collection<T>,R> f) {
1: 		AtomicReference<Queue<T>> queueRef = new AtomicReference<Queue<T>>(
1: 				null);
1: 
1: 		Runnable init = () -> queueRef
1: 				.set(getQueueForInternalBuffering(count.getAsInt()));
1: 
1: 		@SuppressWarnings("resource")
1: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<R>(
1: 				psp, defaultExecutor, scheduler, this) {
1: 			@Override
1: 			protected void beginning() {
1: 				init.run();
1: 			}
1: 		};
1: 
1: 		AtomicBoolean endPending = new AtomicBoolean();
1: 		Object lock = new Object();
1: 		updateNext((event) -> {
1: 			try {
1: 				Queue<T> queue;
1: 				if (!event.isTerminal()) {
1: 					synchronized (lock) {
1: 						for (;;) {
1: 							queue = queueRef.get();
1: 							if (queue == null) {
1: 								if (endPending.get()) {
1: 									return ABORT;
1: 								} else {
1: 									continue;
1: 								}
1: 							} else if (queue.offer(event.getData())) {
1: 								return CONTINUE;
1: 							} else {
1: 								queueRef.lazySet(null);
1: 								break;
1: 							}
1: 						}
1: 					}
1: 
1: 					queueRef.set(
1: 							getQueueForInternalBuffering(count.getAsInt()));
1: 
1: 					// This call is on the same thread and so must happen
1: 					// outside
1: 					// the synchronized block.
1: 					return aggregateAndForward(f, eventStream, event,
1: 							queue);
1: 				} else {
1: 					synchronized (lock) {
1: 						queue = queueRef.get();
1: 						queueRef.lazySet(null);
1: 						endPending.set(true);
1: 					}
1: 					if (queue != null) {
1: 						eventStream.handleEvent(
1: 								PushEvent.data(f.apply(queue)));
1: 					}
1: 				}
1: 				return eventStream.handleEvent(event.nodata());
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	private <R> long aggregateAndForward(Function<Collection<T>,R> f,
1: 			AbstractPushStreamImpl<R> eventStream,
1: 			PushEvent< ? extends T> event, Queue<T> queue) {
1: 		if (!queue.offer(event.getData())) {
1: 			((ArrayQueue<T>) queue).forcePush(event.getData());
1: 		}
1: 		return eventStream.handleEvent(PushEvent.data(f.apply(queue)));
1: 	}
1: 	
1: 	
1: 	@Override
1: 	public <R> PushStream<R> window(Duration time,
1: 			Function<Collection<T>,R> f) {
1: 		return window(time, defaultExecutor, f);
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> window(Duration time, Executor executor,
1: 			Function<Collection<T>,R> f) {
1: 		return window(() -> time, () -> 0, executor, (t, c) -> f.apply(c));
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> window(Supplier<Duration> time,
1: 			IntSupplier maxEvents,
1: 			BiFunction<Long,Collection<T>,R> f) {
1: 		return window(time, maxEvents, defaultExecutor, f);
1: 	}
1: 
1: 	@Override
1: 	public <R> PushStream<R> window(Supplier<Duration> time,
1: 			IntSupplier maxEvents, Executor ex,
1: 			BiFunction<Long,Collection<T>,R> f) {
1: 
1: 		AtomicLong timestamp = new AtomicLong();
1: 		AtomicLong counter = new AtomicLong();
1: 		Object lock = new Object();
1: 		AtomicReference<Queue<T>> queueRef = new AtomicReference<Queue<T>>(
1: 				null);
1: 
1: 		// This code is declared as a separate block to avoid any confusion
1: 		// about which instance's methods and variables are in scope
1: 		Consumer<AbstractPushStreamImpl<R>> begin = p -> {
1: 
1: 			synchronized (lock) {
1: 				timestamp.lazySet(System.nanoTime());
1: 				long count = counter.get();
1: 
1: 
1: 				scheduler.schedule(
1: 						getWindowTask(p, f, time, maxEvents, lock, count,
1: 								queueRef, timestamp, counter, ex),
1: 						time.get().toNanos(), NANOSECONDS);
1: 			}
1: 
1: 			queueRef.set(getQueueForInternalBuffering(maxEvents.getAsInt()));
1: 		};
1: 
1: 		@SuppressWarnings("resource")
1: 		AbstractPushStreamImpl<R> eventStream = new IntermediatePushStreamImpl<R>(
1: 				psp, ex, scheduler, this) {
1: 			@Override
1: 			protected void beginning() {
1: 				begin.accept(this);
1: 			}
1: 		};
1: 
1: 		AtomicBoolean endPending = new AtomicBoolean(false);
1: 		updateNext((event) -> {
1: 			try {
1: 				if (eventStream.closed.get() == CLOSED) {
1: 					return ABORT;
1: 				}
1: 				Queue<T> queue;
1: 				if (!event.isTerminal()) {
1: 					long elapsed;
1: 					long newCount;
1: 					synchronized (lock) {
1: 						for (;;) {
1: 							queue = queueRef.get();
1: 							if (queue == null) {
1: 								if (endPending.get()) {
1: 									return ABORT;
1: 								} else {
1: 									continue;
1: 								}
1: 							} else if (queue.offer(event.getData())) {
1: 								return CONTINUE;
1: 							} else {
1: 								queueRef.lazySet(null);
1: 								break;
1: 							}
1: 						}
1: 
1: 						long now = System.nanoTime();
1: 						elapsed = now - timestamp.get();
1: 						timestamp.lazySet(now);
1: 						newCount = counter.get() + 1;
1: 						counter.lazySet(newCount);
1: 
1: 						// This is a non-blocking call, and must happen in the
1: 						// synchronized block to avoid re=ordering the executor
1: 						// enqueue with a subsequent incoming close operation
1: 						aggregateAndForward(f, eventStream, event, queue,
1: 								ex, elapsed);
1: 					}
1: 					// These must happen outside the synchronized block as we
1: 					// call out to user code
1: 					queueRef.set(
1: 							getQueueForInternalBuffering(maxEvents.getAsInt()));
1: 					scheduler.schedule(
1: 							getWindowTask(eventStream, f, time, maxEvents, lock,
1: 									newCount, queueRef, timestamp, counter, ex),
1: 							time.get().toNanos(), NANOSECONDS);
1: 
1: 					return CONTINUE;
1: 				} else {
1: 					long elapsed;
1: 					synchronized (lock) {
1: 						queue = queueRef.get();
1: 						queueRef.lazySet(null);
1: 						endPending.set(true);
1: 						long now = System.nanoTime();
1: 						elapsed = now - timestamp.get();
1: 						counter.lazySet(counter.get() + 1);
1: 					}
1: 					Collection<T> collected = queue == null ? emptyList()
1: 							: queue;
1: 					ex.execute(() -> {
1: 						try {
1: 							eventStream
1: 									.handleEvent(PushEvent.data(f.apply(
1: 											Long.valueOf(NANOSECONDS
1: 													.toMillis(elapsed)),
1: 											collected)));
1: 						} catch (Exception e) {
1: 							close(PushEvent.error(e));
1: 						}
1: 					});
1: 				}
1: 				ex.execute(() -> eventStream.handleEvent(event.nodata()));
1: 				return ABORT;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		return eventStream;
1: 	}
1: 
1: 	protected Queue<T> getQueueForInternalBuffering(int size) {
1: 		if (size == 0) {
1: 			return new LinkedList<T>();
1: 		} else {
1: 			return new ArrayQueue<>(size - 1);
1: 		}
1: 	}
1: 	
1: 	@SuppressWarnings("unchecked")
1: 	/**
1: 	 * A special queue that keeps one element in reserve and can have that last
1: 	 * element set using forcePush. After the element is set the capacity is
1: 	 * permanently increased by one and cannot grow further.
1: 	 * 
1: 	 * @param <E> The element type
1: 	 */
1: 	private static class ArrayQueue<E> extends AbstractQueue<E>
1: 			implements Queue<E> {
1: 
1: 		final Object[]	store;
1: 
1: 		int				normalLength;
1: 
1: 		int				nextIndex;
1: 
1: 		int				size;
1: 
1: 		ArrayQueue(int capacity) {
1: 			store = new Object[capacity + 1];
1: 			normalLength = store.length - 1;
1: 		}
1: 
1: 		@Override
1: 		public boolean offer(E e) {
1: 			if (e == null)
1: 				throw new NullPointerException("Null values are not supported");
1: 			if (size < normalLength) {
1: 				store[nextIndex] = e;
1: 				size++;
1: 				nextIndex++;
1: 				nextIndex = nextIndex % normalLength;
1: 				return true;
1: 			}
1: 			return false;
1: 		}
1: 
1: 		public void forcePush(E e) {
1: 			store[normalLength] = e;
1: 			normalLength++;
1: 			size++;
1: 		}
1: 
1: 		@Override
1: 		public E poll() {
1: 			if (size == 0) {
1: 				return null;
1: 			} else {
1: 				int idx = nextIndex - size;
1: 				if (idx < 0) {
1: 					idx += normalLength;
1: 				}
1: 				E value = (E) store[idx];
1: 				store[idx] = null;
1: 				size--;
1: 				return value;
1: 			}
1: 		}
1: 
1: 		@Override
1: 		public E peek() {
1: 			if (size == 0) {
1: 				return null;
1: 			} else {
1: 				int idx = nextIndex - size;
1: 				if (idx < 0) {
1: 					idx += normalLength;
1: 				}
1: 				return (E) store[idx];
1: 			}
1: 		}
1: 
1: 		@Override
1: 		public Iterator<E> iterator() {
1: 			final int previousNext = nextIndex;
1: 			return new Iterator<E>() {
1: 
1: 				int idx;
1: 
1: 				int	remaining	= size;
1: 
1: 				{
1: 					idx = nextIndex - size;
1: 					if (idx < 0) {
1: 						idx += normalLength;
1: 					}
1: 				}
1: 
1: 				@Override
1: 				public boolean hasNext() {
1: 					if (nextIndex != previousNext) {
1: 						throw new ConcurrentModificationException(
1: 								"The queue was concurrently modified");
1: 					}
1: 					return remaining > 0;
1: 				}
1: 
1: 				@Override
1: 				public E next() {
1: 					if (!hasNext()) {
1: 						throw new NoSuchElementException(
1: 								"The iterator has no more values");
1: 					}
1: 					E value = (E) store[idx];
1: 					idx++;
1: 					remaining--;
1: 					if (idx == normalLength) {
1: 						idx = 0;
1: 					}
1: 					return value;
1: 				}
1: 
1: 			};
1: 		}
1: 
1: 		@Override
1: 		public int size() {
1: 			return size;
1: 		}
1: 
1: 	}
1: 
1: 	private <R> Runnable getWindowTask(AbstractPushStreamImpl<R> eventStream,
1: 			BiFunction<Long,Collection<T>,R> f, Supplier<Duration> time,
1: 			IntSupplier maxEvents, Object lock, long expectedCounter,
1: 			AtomicReference<Queue<T>> queueRef, AtomicLong timestamp,
1: 			AtomicLong counter, Executor executor) {
1: 		return () -> {
1: 
1: 			Queue<T> queue = null;
1: 			long elapsed;
1: 			synchronized (lock) {
1: 				
1: 				if (counter.get() != expectedCounter) {
1: 					return;
1: 				}
1: 				counter.lazySet(expectedCounter + 1);
1: 
1: 				long now = System.nanoTime();
1: 				elapsed = now - timestamp.get();
1: 				timestamp.lazySet(now);
1: 
1: 				queue = queueRef.get();
1: 				queueRef.lazySet(null);
1: 
1: 				// This is a non-blocking call, and must happen in the
1: 				// synchronized block to avoid re=ordering the executor
1: 				// enqueue with a subsequent incoming close operation
1: 
1: 				Collection<T> collected = queue == null ? emptyList() : queue;
1: 				executor.execute(() -> {
1: 					try {
1: 						eventStream.handleEvent(PushEvent.data(f.apply(
1: 								Long.valueOf(NANOSECONDS.toMillis(elapsed)),
1: 								collected)));
1: 					} catch (Exception e) {
1: 						close(PushEvent.error(e));
1: 					}
1: 				});
1: 			}
1: 
1: 			// These must happen outside the synchronized block as we
1: 			// call out to user code
1: 			queueRef.set(getQueueForInternalBuffering(maxEvents.getAsInt()));
1: 			scheduler.schedule(
1: 					getWindowTask(eventStream, f, time, maxEvents, lock,
1: 							expectedCounter + 1, queueRef, timestamp, counter,
1: 							executor),
1: 					time.get().toNanos(), NANOSECONDS);
1: 		};
1: 	}
1: 
1: 	private <R> void aggregateAndForward(BiFunction<Long,Collection<T>,R> f,
1: 			AbstractPushStreamImpl<R> eventStream,
1: 			PushEvent< ? extends T> event, Queue<T> queue, Executor executor,
1: 			long elapsed) {
1: 		executor.execute(() -> {
1: 			try {
1: 				if (!queue.offer(event.getData())) {
1: 					((ArrayQueue<T>) queue).forcePush(event.getData());
1: 				}
1: 				long result = eventStream.handleEvent(PushEvent.data(
1: 						f.apply(Long.valueOf(NANOSECONDS.toMillis(elapsed)),
1: 								queue)));
1: 				if (result < 0) {
1: 					close();
1: 				}
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 			}
1: 		});
1: 	}
1: 
1: 	@Override
1: 	public Promise<Void> forEach(Consumer< ? super T> action) {
1: 		Deferred<Void> d = new Deferred<>();
1: 		updateNext((event) -> {
1: 				try {
1: 					switch(event.getType()) {
1: 						case DATA:
1: 							action.accept(event.getData());
1: 							return CONTINUE;
1: 						case CLOSE:
1: 							d.resolve(null);
1: 							break;
1: 						case ERROR:
1: 							d.fail(event.getFailure());
1: 							break;
1: 					}
1: 					close(event.nodata());
1: 					return ABORT;
1: 				} catch (Exception e) {
1: 					d.fail(e);
1: 					return ABORT;
1: 				}
1: 			});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public Promise<Object[]> toArray() {
1: 		return collect(Collectors.toList())
1: 				.map(List::toArray);
1: 	}
1: 
1: 	@Override
1: 	public <A extends T> Promise<A[]> toArray(IntFunction<A[]> generator) {
1: 		return collect(Collectors.toList())
1: 				.map(l -> l.toArray(generator.apply(l.size())));
1: 	}
1: 
1: 	@Override
1: 	public Promise<T> reduce(T identity, BinaryOperator<T> accumulator) {
1: 		Deferred<T> d = new Deferred<>();
1: 		AtomicReference<T> iden = new AtomicReference<T>(identity);
1: 
1: 		updateNext(event -> {
1: 			try {
1: 				switch(event.getType()) {
1: 					case DATA:
1: 						iden.accumulateAndGet(event.getData(), accumulator);
1: 						return CONTINUE;
1: 					case CLOSE:
1: 						d.resolve(iden.get());
1: 						break;
1: 					case ERROR:
1: 						d.fail(event.getFailure());
1: 						break;
1: 				}
1: 				close(event.nodata());
1: 				return ABORT;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public Promise<Optional<T>> reduce(BinaryOperator<T> accumulator) {
1: 		Deferred<Optional<T>> d = new Deferred<>();
1: 		AtomicReference<T> iden = new AtomicReference<T>(null);
1: 
1: 		updateNext(event -> {
1: 			try {
1: 				switch(event.getType()) {
1: 					case DATA:
1: 						if (!iden.compareAndSet(null, event.getData()))
1: 							iden.accumulateAndGet(event.getData(), accumulator);
1: 						return CONTINUE;
1: 					case CLOSE:
1: 						d.resolve(Optional.ofNullable(iden.get()));
1: 						break;
1: 					case ERROR:
1: 						d.fail(event.getFailure());
1: 						break;
1: 				}
1: 				close(event.nodata());
1: 				return ABORT;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public <U> Promise<U> reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
1: 		Deferred<U> d = new Deferred<>();
1: 		AtomicReference<U> iden = new AtomicReference<>(identity);
1: 
1: 		updateNext(event -> {
1: 			try {
1: 				switch(event.getType()) {
1: 					case DATA:
1: 						iden.updateAndGet((e) -> accumulator.apply(e, event.getData()));
1: 						return CONTINUE;
1: 					case CLOSE:
1: 						d.resolve(iden.get());
1: 						break;
1: 					case ERROR:
1: 						d.fail(event.getFailure());
1: 						break;
1: 				}
1: 				close(event.nodata());
1: 				return ABORT;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public <R, A> Promise<R> collect(Collector<? super T, A, R> collector) {
1: 		A result = collector.supplier().get();
1: 		Deferred<R> d = new Deferred<>();
1: 		updateNext(event -> {
1: 			try {
1: 				switch(event.getType()) {
1: 					case DATA:
1: 						collector.accumulator().accept(result, event.getData());
1: 						return CONTINUE;
1: 					case CLOSE:
1: 						d.resolve(collector.finisher().apply(result));
1: 						break;
1: 					case ERROR:
1: 						d.fail(event.getFailure());
1: 						break;
1: 				}
1: 				close(event.nodata());
1: 				return ABORT;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public Promise<Optional<T>> min(Comparator<? super T> comparator)  {
1: 		return reduce((a, b) -> comparator.compare(a, b) <= 0 ? a : b);
1: 	}
1: 
1: 	@Override
1: 	public Promise<Optional<T>> max(Comparator<? super T> comparator) {
1: 		return reduce((a, b) -> comparator.compare(a, b) > 0 ? a : b);
1: 	}
1: 
1: 	@Override
1: 	public Promise<Long> count() {
1: 		Deferred<Long> d = new Deferred<>();
1: 		LongAdder counter = new LongAdder();
1: 		updateNext((event) -> {
1: 				try {
1: 					switch(event.getType()) {
1: 						case DATA:
1: 						counter.add(1);
1: 							return CONTINUE;
1: 						case CLOSE:
1: 						d.resolve(Long.valueOf(counter.sum()));
1: 							break;
1: 						case ERROR:
1: 							d.fail(event.getFailure());
1: 							break;
1: 					}
1: 					close(event.nodata());
1: 					return ABORT;
1: 				} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 					return ABORT;
1: 				}
1: 			});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public Promise<Boolean> anyMatch(Predicate<? super T> predicate) {
1: 		return filter(predicate).findAny()
1: 			.map(Optional::isPresent);
1: 	}
1: 
1: 	@Override
1: 	public Promise<Boolean> allMatch(Predicate<? super T> predicate) {
1: 		return filter(x -> !predicate.test(x)).findAny()
1: 				.map(o -> Boolean.valueOf(!o.isPresent()));
1: 	}
1: 
1: 	@Override
1: 	public Promise<Boolean> noneMatch(Predicate<? super T> predicate) {
1: 		return filter(predicate).findAny()
1: 				.map(o -> Boolean.valueOf(!o.isPresent()));
1: 	}
1: 
1: 	@Override
1: 	public Promise<Optional<T>> findFirst() {
1: 		Deferred<Optional<T>> d = new Deferred<>();
1: 		updateNext((event) -> {
1: 				try {
1: 					Optional<T> o = null;
1: 					switch(event.getType()) {
1: 						case DATA:
1: 							o = Optional.of(event.getData());
1: 							break;
1: 						case CLOSE:
1: 							o = Optional.empty();
1: 							break;
1: 						case ERROR:
1: 							d.fail(event.getFailure());
1: 							return ABORT;
1: 					}
1: 					if(!d.getPromise().isDone())
1: 						d.resolve(o);
1: 					return ABORT;
1: 				} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 					return ABORT;
1: 				}
1: 			});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: 	@Override
1: 	public Promise<Optional<T>> findAny() {
1: 		return findFirst();
1: 	}
1: 
1: 	@Override
1: 	public Promise<Long> forEachEvent(PushEventConsumer< ? super T> action) {
1: 		Deferred<Long> d = new Deferred<>();
1: 		LongAdder la = new LongAdder();
1: 		updateNext((event) -> {
1: 			try {
1: 				switch(event.getType()) {
1: 					case DATA:
1: 						long value = action.accept(event);
1: 						la.add(value);
1: 						return value;
1: 					case CLOSE:
1: 						try {
1: 							action.accept(event);
1: 						} finally {
1: 							d.resolve(Long.valueOf(la.sum()));
1: 						}
1: 						break;
1: 					case ERROR:
1: 						try {
1: 							action.accept(event);
1: 						} finally {
1: 							d.fail(event.getFailure());
1: 						}
1: 						break;
1: 				}
1: 				return ABORT;
1: 			} catch (Exception e) {
1: 				close(PushEvent.error(e));
1: 				return ABORT;
1: 			}
1: 		});
1: 		begin();
1: 		return d.getPromise();
1: 	}
1: 
1: }
============================================================================