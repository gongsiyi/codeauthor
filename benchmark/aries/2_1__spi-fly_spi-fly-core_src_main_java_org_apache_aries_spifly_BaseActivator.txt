1:1c43780: /**
1:1c43780:  * Licensed to the Apache Software Foundation (ASF) under one
1:1c43780:  * or more contributor license agreements.  See the NOTICE file
1:1c43780:  * distributed with this work for additional information
1:1c43780:  * regarding copyright ownership.  The ASF licenses this file
1:1c43780:  * to you under the Apache License, Version 2.0 (the
1:1c43780:  * "License"); you may not use this file except in compliance
1:1c43780:  * with the License.  You may obtain a copy of the License at
1:1c43780:  *
1:1c43780:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1c43780:  *
1:1c43780:  * Unless required by applicable law or agreed to in writing,
1:1c43780:  * software distributed under the License is distributed on an
1:1c43780:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:1c43780:  * KIND, either express or implied.  See the License for the
1:1c43780:  * specific language governing permissions and limitations
1:1c43780:  * under the License.
1:1c43780:  */
1:1c43780: package org.apache.aries.spifly;
1:021618a: 
1:1c43780: import java.util.ArrayList;
1:1c43780: import java.util.Collection;
1:1c43780: import java.util.Collections;
1:1c43780: import java.util.HashMap;
1:7dabe8c: import java.util.HashSet;
1:0028427: import java.util.Hashtable;
1:9644284: import java.util.Iterator;
1:1c43780: import java.util.List;
1:1c43780: import java.util.Map;
1:9644284: import java.util.Map.Entry;
1:021618a: import java.util.ServiceLoader;
1:1c43780: import java.util.Set;
1:1c43780: import java.util.SortedMap;
1:1c43780: import java.util.TreeMap;
1:1c43780: import java.util.concurrent.ConcurrentHashMap;
1:1c43780: import java.util.concurrent.ConcurrentMap;
1:1c43780: import java.util.concurrent.CopyOnWriteArrayList;
1:b1379cb: 
1:1c43780: import org.osgi.framework.Bundle;
1:1c43780: import org.osgi.framework.BundleActivator;
1:1c43780: import org.osgi.framework.BundleContext;
1:7dabe8c: import org.osgi.framework.wiring.BundleRevision;
1:7dabe8c: import org.osgi.framework.wiring.BundleWire;
1:7dabe8c: import org.osgi.framework.wiring.BundleWiring;
1:1c43780: import org.osgi.service.log.LogService;
1:1c43780: import org.osgi.util.tracker.BundleTracker;
1:b1379cb: 
1:b1379cb: public abstract class BaseActivator implements BundleActivator {
1:b1379cb:     private static final Set<WeavingData> NON_WOVEN_BUNDLE = Collections.emptySet();
1:a8ccbc9: 
1:a8ccbc9:     // Static access to the activator used by the woven code, therefore
1:b1379cb:     // this bundle must be a singleton.
1:b1379cb:     // TODO see if we can get rid of the static access.
1:a8ccbc9:     public static BaseActivator activator;
1:a8ccbc9: 
1:1c43780:     private BundleContext bundleContext;
1:1c43780:     private List<LogService> logServices = new CopyOnWriteArrayList<LogService>();
1:a8ccbc9:     private BundleTracker consumerBundleTracker;
1:4b6c670:     private BundleTracker providerBundleTracker;
1:b1379cb: 
1:a8ccbc9:     private final ConcurrentMap<Bundle, Set<WeavingData>> bundleWeavingData =
1:b1379cb:         new ConcurrentHashMap<Bundle, Set<WeavingData>>();
1:b1379cb: 
1:35cb846:     private final ConcurrentMap<String, SortedMap<Long, Pair<Bundle, Map<String, Object>>>> registeredProviders =
1:35cb846:             new ConcurrentHashMap<String, SortedMap<Long, Pair<Bundle, Map<String, Object>>>>();
1:b1379cb: 
1:a8ccbc9:     private final ConcurrentMap<Bundle, Map<ConsumerRestriction, List<BundleDescriptor>>> consumerRestrictions =
1:b1379cb:             new ConcurrentHashMap<Bundle, Map<ConsumerRestriction, List<BundleDescriptor>>>();
1:a8ccbc9: 
1:b1379cb:     public synchronized void start(BundleContext context, final String consumerHeaderName) throws Exception {
1:1c43780:         bundleContext = context;
1:a8ccbc9: 
1:4b6c670:         providerBundleTracker = new BundleTracker(context,
1:1c43780:                 Bundle.ACTIVE, new ProviderBundleTrackerCustomizer(this, context.getBundle()));
1:b1379cb:         providerBundleTracker.open();
1:a8ccbc9: 
1:a8ccbc9:         consumerBundleTracker = new BundleTracker(context,
1:faebae4:                 Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.ACTIVE, new ConsumerBundleTrackerCustomizer(this, consumerHeaderName));
1:b1379cb:         consumerBundleTracker.open();
1:a8ccbc9: 
1:b1379cb:         for (Bundle bundle : context.getBundles()) {
1:f886534:             addConsumerWeavingData(bundle, consumerHeaderName);
1:b1379cb:         }
1:35cb846: 
1:1c43780:         activator = this;
1:35cb846:     }
1:2ec7a50: 
1:a166d95:     public void addConsumerWeavingData(Bundle bundle, String consumerHeaderName) throws Exception {
1:b1379cb:         if (bundleWeavingData.containsKey(bundle)) {
1:b1379cb:             // This bundle was already processed
1:b1379cb:             return;
1:2ec7a50:         }
1:a8ccbc9: 
1:7dabe8c:         Map<String, List<String>> allHeaders = new HashMap<String, List<String>>();
1:7dabe8c:         allHeaders.put(consumerHeaderName, getAllHeaders(consumerHeaderName, bundle));
1:7dabe8c:         allHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, getAllHeaders(SpiFlyConstants.REQUIRE_CAPABILITY, bundle));
1:7dabe8c: 
1:7dabe8c:         Set<WeavingData> wd = new HashSet<WeavingData>();
1:7dabe8c:         for (Map.Entry<String, List<String>> entry : allHeaders.entrySet()) {
1:7dabe8c:             String headerName = entry.getKey();
1:7dabe8c:             for (String headerVal : entry.getValue()) {
1:7dabe8c:                 wd.addAll(ConsumerHeaderProcessor.processHeader(headerName, headerVal));
1:7dabe8c:             }
1:b1379cb:         }
1:a8ccbc9: 
1:7dabe8c:         if (!wd.isEmpty()) {
1:b1379cb:             bundleWeavingData.put(bundle, Collections.unmodifiableSet(wd));
1:a8ccbc9: 
1:b1379cb:             for (WeavingData w : wd) {
1:b1379cb:                 registerConsumerBundle(bundle, w.getArgRestrictions(), w.getAllowedBundles());
1:b1379cb:             }
1:b1379cb:         } else {
1:b1379cb:             bundleWeavingData.put(bundle, NON_WOVEN_BUNDLE);
1:b1379cb:         }
1:b1379cb:     }
1:a8ccbc9: 
1:7dabe8c:     private List<String> getAllHeaders(String headerName, Bundle bundle) {
1:7dabe8c:         List<Bundle> bundlesFragments = new ArrayList<Bundle>();
1:7dabe8c:         bundlesFragments.add(bundle);
1:7dabe8c: 
1:7dabe8c:         BundleRevision rev = bundle.adapt(BundleRevision.class);
1:7dabe8c:         if (rev != null) {
1:7dabe8c:             BundleWiring wiring = rev.getWiring();
1:7dabe8c:             if (wiring != null) {
1:7dabe8c:                 for (BundleWire wire : wiring.getProvidedWires("osgi.wiring.host")) {
1:7dabe8c:                     bundlesFragments.add(wire.getRequirement().getRevision().getBundle());
1:7dabe8c:                 }
1:7dabe8c:             }
1:7dabe8c:         }
1:7dabe8c: 
1:7dabe8c:         List<String> l = new ArrayList<String>();
1:7dabe8c:         for (Bundle bf : bundlesFragments) {
1:fb75ccc:             String header = bf.getHeaders().get(headerName);
1:fb75ccc:             if (header != null) {
1:fb75ccc:                 l.add(header);
1:fb75ccc:             }
1:7dabe8c:         }
1:7dabe8c: 
1:7dabe8c:         return l;
1:7dabe8c:     }
1:7dabe8c: 
1:a8ccbc9:     public void removeWeavingData(Bundle bundle) {
1:a8ccbc9:         bundleWeavingData.remove(bundle);
1:a8ccbc9:     }
1:a8ccbc9: 
4:b1379cb:     @Override
1:1c43780:     public synchronized void stop(BundleContext context) throws Exception {
1:1c43780:         activator = null;
1:a8ccbc9: 
1:b1379cb:         consumerBundleTracker.close();
1:b1379cb:         providerBundleTracker.close();
1:a8ccbc9:     }
1:a8ccbc9: 
1:b1379cb:     public void log(int level, String message) {
1:1c43780:         synchronized (logServices) {
1:1c43780:             for (LogService log : logServices) {
1:1c43780:                 log.log(level, message);
1:b1379cb:             }
1:b1379cb:         }
1:b1379cb:     }
1:b1379cb: 
1:b1379cb:     public void log(int level, String message, Throwable th) {
1:1c43780:         synchronized (logServices) {
1:1c43780:             for (LogService log : logServices) {
1:1c43780:                 log.log(level, message, th);
10:1c43780:             }
1:1c43780:         }
1:1c43780:     }
1:b1379cb: 
1:b1379cb:     public Set<WeavingData> getWeavingData(Bundle b) {
1:3e50f86:         // Simply return the value as it's already an immutable set.
1:b1379cb:         Set<WeavingData> wd = bundleWeavingData.get(b);
1:a8ccbc9:         if (wd == null)
1:b1379cb:             return null;
1:a8ccbc9: 
1:a8ccbc9:         if (wd.size() == 0)
1:b1379cb:             return null;
1:a8ccbc9: 
1:b1379cb:         return wd;
1:b1379cb:     }
1:b1379cb: 
1:35cb846:     public void registerProviderBundle(String registrationClassName, Bundle bundle, Map<String, Object> customAttributes) {
1:7158c23:         registrationClassName = registrationClassName.trim();
1:35cb846:         registeredProviders.putIfAbsent(registrationClassName,
1:35cb846:                 Collections.synchronizedSortedMap(new TreeMap<Long, Pair<Bundle, Map<String, Object>>>()));
1:35cb846: 
1:35cb846:         SortedMap<Long, Pair<Bundle, Map<String, Object>>> map = registeredProviders.get(registrationClassName);
1:35cb846:         map.put(bundle.getBundleId(), new Pair<Bundle, Map<String, Object>>(bundle, customAttributes));
1:1c43780:     }
1:b1379cb: 
1:9644284:     public void unregisterProviderBundle(Bundle bundle) {
1:9644284:         for (Map<Long, Pair<Bundle, Map<String, Object>>> value : registeredProviders.values()) {
1:9644284:             for(Iterator<Entry<Long, Pair<Bundle, Map<String, Object>>>> it = value.entrySet().iterator(); it.hasNext(); ) {
1:9644284:                 Entry<Long, Pair<Bundle, Map<String, Object>>> entry = it.next();
1:9644284:                 if (entry.getValue().getLeft().equals(bundle)) {
1:9644284:                     it.remove();
1:9644284:                 }
1:9644284:             }
1:9644284:         }
1:9644284:     }
1:9644284: 
1:1c43780:     public Collection<Bundle> findProviderBundles(String name) {
1:35cb846:         SortedMap<Long, Pair<Bundle, Map<String, Object>>> map = registeredProviders.get(name);
1:35cb846:         if (map == null)
1:35cb846:             return Collections.emptyList();
1:35cb846: 
1:35cb846:         List<Bundle> bundles = new ArrayList<Bundle>(map.size());
1:35cb846:         for(Pair<Bundle, Map<String, Object>> value : map.values()) {
1:35cb846:             bundles.add(value.getLeft());
1:35cb846:         }
1:35cb846: 
1:35cb846:         return bundles;
1:35cb846:     }
1:35cb846: 
1:708d00a:     public Map<String, Object> getCustomBundleAttributes(String name, Bundle b) {
1:35cb846:         SortedMap<Long, Pair<Bundle, Map<String, Object>>> map = registeredProviders.get(name);
1:35cb846:         if (map == null)
1:35cb846:             return Collections.emptyMap();
1:35cb846: 
1:35cb846:         Pair<Bundle, Map<String, Object>> data = map.get(b.getBundleId());
1:35cb846:         if (data == null)
1:35cb846:             return Collections.emptyMap();
1:35cb846: 
1:35cb846:         return data.getRight();
1:1c43780:     }
1:b1379cb: 
1:35cb846:     public void registerConsumerBundle(Bundle consumerBundle,
1:1c43780:             Set<ConsumerRestriction> restrictions, List<BundleDescriptor> allowedBundles) {
1:1c43780:         consumerRestrictions.putIfAbsent(consumerBundle, new HashMap<ConsumerRestriction, List<BundleDescriptor>>());
1:1c43780:         Map<ConsumerRestriction, List<BundleDescriptor>> map = consumerRestrictions.get(consumerBundle);
1:1c43780:         for (ConsumerRestriction restriction : restrictions) {
1:1c43780:             map.put(restriction, allowedBundles);
1:1c43780:         }
1:1c43780:     }
1:b1379cb: 
1:1c43780:     public Collection<Bundle> findConsumerRestrictions(Bundle consumer, String className, String methodName,
1:1c43780:             Map<Pair<Integer, String>, String> args) {
1:1c43780:         Map<ConsumerRestriction, List<BundleDescriptor>> restrictions = consumerRestrictions.get(consumer);
1:1c43780:         if (restrictions == null) {
1:1c43780:             // Null means: no restrictions
1:1c43780:             return null;
1:1c43780:         }
1:a8ccbc9: 
1:1c43780:         for (Map.Entry<ConsumerRestriction, List<BundleDescriptor>> entry : restrictions.entrySet()) {
1:1c43780:             if (entry.getKey().matches(className, methodName, args)) {
1:021618a:                 return getBundles(entry.getValue(), className, methodName, args);
1:1c43780:             }
1:1c43780:         }
1:a8ccbc9: 
1:1c43780:         // Empty collection: nothing matches
1:1c43780:         return Collections.emptySet();
1:1c43780:     }
1:b1379cb: 
1:021618a:     private Collection<Bundle> getBundles(List<BundleDescriptor> descriptors, String className, String methodName,
1:021618a:             Map<Pair<Integer, String>, String> args) {
1:1c43780:         if (descriptors == null) {
1:1c43780:             return null;
1:1c43780:         }
1:a8ccbc9: 
1:1c43780:         List<Bundle> bundles = new ArrayList<Bundle>();
1:1c43780:         for (Bundle b : bundleContext.getBundles()) {
1:1c43780:             for (BundleDescriptor desc : descriptors) {
1:f886534:                 if (desc.getBundleID() != BundleDescriptor.BUNDLE_ID_UNSPECIFIED) {
1:f886534:                     if (b.getBundleId() == desc.getBundleID()) {
1:1c43780:                         bundles.add(b);
1:1c43780:                     }
1:0028427:                 } else if (desc.getFilter() != null) {
1:35cb846:                     Hashtable<String, Object> d = new Hashtable<String, Object>();
2:b1379cb: 
1:021618a:                     if (ServiceLoader.class.getName().equals(className) &&
1:021618a:                         "load".equals(methodName)) {
1:021618a:                         String type = args.get(new Pair<Integer, String>(0, Class.class.getName()));
1:021618a:                         if (type != null) {
1:a166d95:                             d.put(SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE, type);
1:35cb846:                             d.putAll(getCustomBundleAttributes(type, b));
1:021618a:                         }
1:021618a:                     }
1:0028427:                     if (desc.getFilter().match(d))
1:0028427:                         bundles.add(b);
1:f886534:                 } else {
1:f886534:                     if (b.getSymbolicName().equals(desc.getSymbolicName())) {
1:f886534:                         if (desc.getVersion() == null || b.getVersion().equals(desc.getVersion())) {
1:f886534:                             bundles.add(b);
1:f886534:                         }
1:f886534:                     }
1:1c43780:                 }
1:1c43780:             }
1:1c43780:         }
1:1c43780:         return bundles;
1:1c43780:     }
1:b1379cb: 
1:1c43780: }
============================================================================
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:fb75ccc
/////////////////////////////////////////////////////////////////////////
1:             String header = bf.getHeaders().get(headerName);
1:             if (header != null) {
1:                 l.add(header);
1:             }
commit:7dabe8c
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.wiring.BundleRevision;
1: import org.osgi.framework.wiring.BundleWire;
1: import org.osgi.framework.wiring.BundleWiring;
/////////////////////////////////////////////////////////////////////////
1:         Map<String, List<String>> allHeaders = new HashMap<String, List<String>>();
1:         allHeaders.put(consumerHeaderName, getAllHeaders(consumerHeaderName, bundle));
1:         allHeaders.put(SpiFlyConstants.REQUIRE_CAPABILITY, getAllHeaders(SpiFlyConstants.REQUIRE_CAPABILITY, bundle));
1: 
1:         Set<WeavingData> wd = new HashSet<WeavingData>();
1:         for (Map.Entry<String, List<String>> entry : allHeaders.entrySet()) {
1:             String headerName = entry.getKey();
1:             for (String headerVal : entry.getValue()) {
1:                 wd.addAll(ConsumerHeaderProcessor.processHeader(headerName, headerVal));
1:             }
1:         if (!wd.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:     private List<String> getAllHeaders(String headerName, Bundle bundle) {
1:         List<Bundle> bundlesFragments = new ArrayList<Bundle>();
1:         bundlesFragments.add(bundle);
1: 
1:         BundleRevision rev = bundle.adapt(BundleRevision.class);
1:         if (rev != null) {
1:             BundleWiring wiring = rev.getWiring();
1:             if (wiring != null) {
1:                 for (BundleWire wire : wiring.getProvidedWires("osgi.wiring.host")) {
1:                     bundlesFragments.add(wire.getRequirement().getRevision().getBundle());
1:                 }
1:             }
1:         }
1: 
1:         List<String> l = new ArrayList<String>();
1:         for (Bundle bf : bundlesFragments) {
0:             l.add(bf.getHeaders().get(headerName));
1:         }
1: 
1:         return l;
1:     }
1: 
commit:e9a5257
/////////////////////////////////////////////////////////////////////////
commit:9644284
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
1: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
1:     public void unregisterProviderBundle(Bundle bundle) {
1:         for (Map<Long, Pair<Bundle, Map<String, Object>>> value : registeredProviders.values()) {
1:             for(Iterator<Entry<Long, Pair<Bundle, Map<String, Object>>>> it = value.entrySet().iterator(); it.hasNext(); ) {
1:                 Entry<Long, Pair<Bundle, Map<String, Object>>> entry = it.next();
1:                 if (entry.getValue().getLeft().equals(bundle)) {
1:                     it.remove();
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:a166d95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void addConsumerWeavingData(Bundle bundle, String consumerHeaderName) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                             d.put(SpiFlyConstants.SERVICELOADER_CAPABILITY_NAMESPACE, type);
commit:5e6f679
/////////////////////////////////////////////////////////////////////////
0:                     d.put(Constants.BUNDLE_VERSION_ATTRIBUTE, b.getVersion());
0:                             d.put(SpiFlyConstants.CONSUMED_SPI_CONDITION, type);
commit:7158c23
/////////////////////////////////////////////////////////////////////////
1:         registrationClassName = registrationClassName.trim();
commit:708d00a
/////////////////////////////////////////////////////////////////////////
1:     public Map<String, Object> getCustomBundleAttributes(String name, Bundle b) {
commit:35cb846
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<String, SortedMap<Long, Pair<Bundle, Map<String, Object>>>> registeredProviders =
1:             new ConcurrentHashMap<String, SortedMap<Long, Pair<Bundle, Map<String, Object>>>>();
/////////////////////////////////////////////////////////////////////////
0:         registerProviderBundle(registrationClassName, bundle, Collections.<String, Object>emptyMap());
1:     }
1: 
1:     public void registerProviderBundle(String registrationClassName, Bundle bundle, Map<String, Object> customAttributes) {
1:         registeredProviders.putIfAbsent(registrationClassName,
1:                 Collections.synchronizedSortedMap(new TreeMap<Long, Pair<Bundle, Map<String, Object>>>()));
1: 
1:         SortedMap<Long, Pair<Bundle, Map<String, Object>>> map = registeredProviders.get(registrationClassName);
1:         map.put(bundle.getBundleId(), new Pair<Bundle, Map<String, Object>>(bundle, customAttributes));
1:         SortedMap<Long, Pair<Bundle, Map<String, Object>>> map = registeredProviders.get(name);
1:         if (map == null)
1:             return Collections.emptyList();
1: 
1:         List<Bundle> bundles = new ArrayList<Bundle>(map.size());
1:         for(Pair<Bundle, Map<String, Object>> value : map.values()) {
1:             bundles.add(value.getLeft());
1:         }
1: 
1:         return bundles;
1:     }
1: 
0:     private Map<String, Object> getCustomBundleAttributes(String name, Bundle b) {
1:         SortedMap<Long, Pair<Bundle, Map<String, Object>>> map = registeredProviders.get(name);
1:         if (map == null)
1:             return Collections.emptyMap();
1: 
1:         Pair<Bundle, Map<String, Object>> data = map.get(b.getBundleId());
1:         if (data == null)
1:             return Collections.emptyMap();
1: 
1:         return data.getRight();
1:     public void registerConsumerBundle(Bundle consumerBundle,
/////////////////////////////////////////////////////////////////////////
1:                     Hashtable<String, Object> d = new Hashtable<String, Object>();
/////////////////////////////////////////////////////////////////////////
1:                             d.putAll(getCustomBundleAttributes(type, b));
/////////////////////////////////////////////////////////////////////////
commit:021618a
/////////////////////////////////////////////////////////////////////////
1: import java.util.ServiceLoader;
/////////////////////////////////////////////////////////////////////////
1:                 return getBundles(entry.getValue(), className, methodName, args);
/////////////////////////////////////////////////////////////////////////
1:     private Collection<Bundle> getBundles(List<BundleDescriptor> descriptors, String className, String methodName,
1:             Map<Pair<Integer, String>, String> args) {
/////////////////////////////////////////////////////////////////////////
1: 
1:                     if (ServiceLoader.class.getName().equals(className) &&
1:                         "load".equals(methodName)) {
1:                         String type = args.get(new Pair<Integer, String>(0, Class.class.getName()));
1:                         if (type != null) {
0:                             d.put(SpiFlyConstants.SERVICE_ATTRIBUTE, type);
1:                         }
1:                     }
commit:2ec7a50
/////////////////////////////////////////////////////////////////////////
0:         if (consumerHeader == null) {
0:             consumerHeaderName = SpiFlyConstants.REQUIRE_CAPABILITY;
0:             consumerHeader = bundle.getHeaders().get(consumerHeaderName);
1:         }
1: 
commit:0028427
/////////////////////////////////////////////////////////////////////////
0: import java.util.Dictionary;
1: import java.util.Hashtable;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.spifly.api.SpiFlyConstants;
0: import org.osgi.framework.Constants;
/////////////////////////////////////////////////////////////////////////
1:                 } else if (desc.getFilter() != null) {
0:                     Dictionary<String, Object> d = new Hashtable<String, Object>();
0:                     d.put(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE, b.getSymbolicName());
0:                     d.put(SpiFlyConstants.BUNDLE_VERSION_ATTRIBUTE, b.getVersion());
1:                     if (desc.getFilter().match(d))
1:                         bundles.add(b);
commit:6591ac7
/////////////////////////////////////////////////////////////////////////
0:             Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderName, (String) consumerHeader);
commit:3e50f86
/////////////////////////////////////////////////////////////////////////
1:         // Simply return the value as it's already an immutable set.
commit:faebae4
/////////////////////////////////////////////////////////////////////////
1:                 Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.ACTIVE, new ConsumerBundleTrackerCustomizer(this, consumerHeaderName));
commit:f886534
/////////////////////////////////////////////////////////////////////////
1:             addConsumerWeavingData(bundle, consumerHeaderName);
0:     public void addConsumerWeavingData(Bundle bundle, String consumerHeaderName) {
/////////////////////////////////////////////////////////////////////////
1:                 if (desc.getBundleID() != BundleDescriptor.BUNDLE_ID_UNSPECIFIED) {
1:                     if (b.getBundleId() == desc.getBundleID()) {
1:                 } else {
1:                     if (b.getSymbolicName().equals(desc.getSymbolicName())) {
1:                         if (desc.getVersion() == null || b.getVersion().equals(desc.getVersion())) {
1:                             bundles.add(b);
1:                         }
1:                     }
commit:a8ccbc9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Static access to the activator used by the woven code, therefore
1:     public static BaseActivator activator;
1: 
1:     private BundleTracker consumerBundleTracker;
1:     private final ConcurrentMap<Bundle, Set<WeavingData>> bundleWeavingData =
0:     private final ConcurrentMap<String, SortedMap<Long, Bundle>> registeredProviders =
1:     private final ConcurrentMap<Bundle, Map<ConsumerRestriction, List<BundleDescriptor>>> consumerRestrictions =
1: 
1: 
1:         consumerBundleTracker = new BundleTracker(context,
0:                 Bundle.INSTALLED, new ConsumerBundleTrackerCustomizer(this, consumerHeaderName));
1: 
0:             addWeavingData(bundle, consumerHeaderName);
1: 
0:     public void addWeavingData(Bundle bundle, String consumerHeaderName) {
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void removeWeavingData(Bundle bundle) {
1:         bundleWeavingData.remove(bundle);
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (wd == null)
1: 
1:         if (wd.size() == 0)
1: 
0:     public void registerProviderBundle(String registrationClassName, Bundle bundle) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         }
commit:4b6c670
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private BundleTracker consumerBundleTracker; 
1:     private BundleTracker providerBundleTracker;
/////////////////////////////////////////////////////////////////////////
1:         providerBundleTracker = new BundleTracker(context,
0:         consumerBundleTracker = new BundleTracker(context, Bundle.INSTALLED, null) {
/////////////////////////////////////////////////////////////////////////
0:         Object consumerHeader = bundle.getHeaders().get(consumerHeaderName);
0:         if (consumerHeader instanceof String) {
0:             Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader((String) consumerHeader);
/////////////////////////////////////////////////////////////////////////
0:     private class LogServiceTracker extends ServiceTracker {
0:             super(context, LogService.class.getName(), null);
0:         public Object addingService(ServiceReference reference) {
0:             Object svc = super.addingService(reference);
0:             if (svc instanceof LogService)
0:                 logServices.add((LogService) svc);
0:         public void removedService(ServiceReference reference, Object service) {
commit:b1379cb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.spifly.api.SpiFlyConstants;
0: import org.osgi.framework.BundleEvent;
1: public abstract class BaseActivator implements BundleActivator {
1:     private static final Set<WeavingData> NON_WOVEN_BUNDLE = Collections.emptySet();
1:     
0:     // Static access to the activator used by the woven code, therefore 
1:     // this bundle must be a singleton.
1:     // TODO see if we can get rid of the static access.
0:     static BaseActivator activator;
1:     
0:     private BundleTracker<Object> consumerBundleTracker; 
0:     private BundleTracker<List<ServiceRegistration<?>>> providerBundleTracker;
1: 
0:     private final ConcurrentMap<Bundle, Set<WeavingData>> bundleWeavingData = 
1:         new ConcurrentHashMap<Bundle, Set<WeavingData>>();
1:             new ConcurrentHashMap<Bundle, Map<ConsumerRestriction, List<BundleDescriptor>>>();
1:     public synchronized void start(BundleContext context, final String consumerHeaderName) throws Exception {
0:         providerBundleTracker = new BundleTracker<List<ServiceRegistration<?>>>(context,
1:         providerBundleTracker.open();
1:         
0:         consumerBundleTracker = new BundleTracker<Object>(context, Bundle.INSTALLED, null) {
1:             @Override
0:             public Object addingBundle(Bundle bundle, BundleEvent event) {
0:                 processBundle(bundle, consumerHeaderName);                    
1:                 
0:                 return super.addingBundle(bundle, event);
1:             }
1: 
1:             @Override
0:             public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) {
0:                 removedBundle(bundle, event, object);
0:                 addingBundle(bundle, event);
1:             }
1: 
1:             @Override
0:             public void removedBundle(Bundle bundle, BundleEvent event, Object object) {
0:                 bundleWeavingData.remove(bundle);
1:             }
0:         };
1:         consumerBundleTracker.open();
1:         
1:         for (Bundle bundle : context.getBundles()) {
0:             processBundle(bundle, consumerHeaderName);
1:         }
0:     private void processBundle(Bundle bundle, String consumerHeaderName) {
1:         if (bundleWeavingData.containsKey(bundle)) {
1:             // This bundle was already processed
1:             return;
1:         }
1:         
0:         String consumerHeader = bundle.getHeaders().get(consumerHeaderName);
0:         if (consumerHeader != null) {
0:             Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeader);
1:             bundleWeavingData.put(bundle, Collections.unmodifiableSet(wd));
1:             
1:             for (WeavingData w : wd) {
1:                 registerConsumerBundle(bundle, w.getArgRestrictions(), w.getAllowedBundles());
1:             }
1:         } else {
1:             bundleWeavingData.put(bundle, NON_WOVEN_BUNDLE);
1:         }
1:     }
1: 
1:     @Override
1:         
1:         consumerBundleTracker.close();
1:         providerBundleTracker.close();
1:     public void log(int level, String message) {
/////////////////////////////////////////////////////////////////////////
1:     public void log(int level, String message, Throwable th) {
1:     
1:     public Set<WeavingData> getWeavingData(Bundle b) {
0:         // Simply return the value as it's already an unmovable set.
1:         Set<WeavingData> wd = bundleWeavingData.get(b);
0:         if (wd == null) 
1:             return null;
1:         
0:         if (wd.size() == 0) 
1:             return null;
1:         
1:         return wd;
1:     }
commit:1c43780
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.spifly;
0: 
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.SortedMap;
1: import java.util.TreeMap;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
0: 
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleActivator;
1: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.ServiceReference;
0: import org.osgi.framework.ServiceRegistration;
0: import org.osgi.framework.hooks.weaving.WeavingHook;
1: import org.osgi.service.log.LogService;
1: import org.osgi.util.tracker.BundleTracker;
0: import org.osgi.util.tracker.ServiceTracker;
0: 
0: public class Activator implements BundleActivator {
0:     // Provide static access to this activator. The bundle must therefore be a singleton.
0:     static Activator activator;
0: 
1:     private BundleContext bundleContext;
0:     private ServiceRegistration<WeavingHook> weavingHookService;
0:     private LogServiceTracker logServiceTracker;
1:     private List<LogService> logServices = new CopyOnWriteArrayList<LogService>();
0:     private BundleTracker<List<ServiceRegistration<?>>> bundleTracker;
0: 
0:     private final ConcurrentMap<String, SortedMap<Long, Bundle>> registeredProviders = 
0:             new ConcurrentHashMap<String, SortedMap<Long, Bundle>>();
0: 
0:     private final ConcurrentMap<Bundle, Map<ConsumerRestriction, List<BundleDescriptor>>> consumerRestrictions = 
0:             new ConcurrentHashMap<Bundle, Map<ConsumerRestriction, List<BundleDescriptor>>>(); 
0:     
0:     public synchronized void start(BundleContext context) throws Exception {
1:         bundleContext = context;
0:         
0:         logServiceTracker = new LogServiceTracker(context);
0:         logServiceTracker.open();
0: 
0:         WeavingHook wh = new ClientWeavingHook(context);
0:         weavingHookService = context.registerService(WeavingHook.class, wh,
0:                 null);
0: 
0:         bundleTracker = new BundleTracker<List<ServiceRegistration<?>>>(context,
1:                 Bundle.ACTIVE, new ProviderBundleTrackerCustomizer(this, context.getBundle()));
0:         bundleTracker.open();
0:         
1:         activator = this;
1:     }
0: 
1:     public synchronized void stop(BundleContext context) throws Exception {
1:         activator = null;
0:         bundleTracker.close();
0:         weavingHookService.unregister();
0:         logServiceTracker.close();
1:     }
0: 
0:     void log(int level, String message) {
1:         synchronized (logServices) {
1:             for (LogService log : logServices) {
1:                 log.log(level, message);
1:             }
1:         }
1:     }
0: 
0:     void log(int level, String message, Throwable th) {
1:         synchronized (logServices) {
1:             for (LogService log : logServices) {
1:                 log.log(level, message, th);
1:             }
1:         }
1:     }
0: 
0:     public void registerProviderBundle(String registrationClassName, Bundle bundle) {        
0:         registeredProviders.putIfAbsent(registrationClassName, Collections.synchronizedSortedMap(new TreeMap<Long, Bundle>()));
0:         SortedMap<Long, Bundle> map = registeredProviders.get(registrationClassName);
0:         map.put(bundle.getBundleId(), bundle);
1:     }
0: 
1:     public Collection<Bundle> findProviderBundles(String name) {
0:         SortedMap<Long, Bundle> map = registeredProviders.get(name);
0:         return map == null ? Collections.<Bundle>emptyList() : map.values();
1:     }
0:     
0:     // TODO unRegisterProviderBundle();
0:     public void registerConsumerBundle( Bundle consumerBundle,
1:             Set<ConsumerRestriction> restrictions, List<BundleDescriptor> allowedBundles) {
1:         consumerRestrictions.putIfAbsent(consumerBundle, new HashMap<ConsumerRestriction, List<BundleDescriptor>>());
1:         Map<ConsumerRestriction, List<BundleDescriptor>> map = consumerRestrictions.get(consumerBundle);
1:         for (ConsumerRestriction restriction : restrictions) {
1:             map.put(restriction, allowedBundles);
1:         }
1:     }
0: 
1:     public Collection<Bundle> findConsumerRestrictions(Bundle consumer, String className, String methodName,
1:             Map<Pair<Integer, String>, String> args) {
1:         Map<ConsumerRestriction, List<BundleDescriptor>> restrictions = consumerRestrictions.get(consumer);
1:         if (restrictions == null) {
1:             // Null means: no restrictions
1:             return null;
1:         }
0:         
1:         for (Map.Entry<ConsumerRestriction, List<BundleDescriptor>> entry : restrictions.entrySet()) {
1:             if (entry.getKey().matches(className, methodName, args)) {
0:                 return getBundles(entry.getValue());
1:             }
1:         }
0:         
1:         // Empty collection: nothing matches
1:         return Collections.emptySet();
1:     }
0: 
0:     private Collection<Bundle> getBundles(List<BundleDescriptor> descriptors) {
1:         if (descriptors == null) {
1:             return null;
1:         }
0:         
1:         List<Bundle> bundles = new ArrayList<Bundle>();
1:         for (Bundle b : bundleContext.getBundles()) {
1:             for (BundleDescriptor desc : descriptors) {
0:                 if (b.getSymbolicName().equals(desc.getSymbolicName())) {
0:                     if (desc.getVersion() == null || b.getVersion().equals(desc.getVersion())) {
1:                         bundles.add(b);
1:                     }
1:                 }
1:             }
1:         }
1:         return bundles;
1:     }
0: 
0:     // TODO unRegisterConsumerBundle();
0:     
0:     private class LogServiceTracker extends ServiceTracker<LogService, LogService> {
0:         public LogServiceTracker(BundleContext context) {
0:             super(context, LogService.class, null);
1:         }
0: 
0:         public LogService addingService(ServiceReference<LogService> reference) {
0:             LogService svc = super.addingService(reference);
0:             if (svc != null)
0:                 logServices.add(svc);
0:             return svc;
1:         }
0: 
0:         @Override
0:         public void removedService(ServiceReference<LogService> reference, LogService service) {
0:             logServices.remove(service);
1:         }        
1:     }
1: }
commit:07a09cd
commit:75139f5
commit:25f6857
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
0: 	    bt = new BundleTracker(context, Bundle.ACTIVE, 
0: 	            new SPIBundleTrackerCustomizer(this, context.getBundle()));
commit:0424519
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
commit:0773cd2
/////////////////////////////////////////////////////////////////////////
0: package org.apache.aries.spifly;
0: 
0: import java.util.ArrayList;
0: import java.util.List;
0: 
0: import org.osgi.framework.BundleActivator;
0: import org.osgi.framework.BundleContext;
0: import org.osgi.framework.ServiceReference;
0: import org.osgi.service.log.LogService;
0: import org.osgi.util.tracker.BundleTracker;
0: import org.osgi.util.tracker.ServiceTracker;
0: import org.osgi.util.tracker.ServiceTrackerCustomizer;
0: 
0: public class Activator implements BundleActivator {
0:     BundleTracker bt;
0:     ServiceTracker lst;
0:     List<LogService> logServices = new ArrayList<LogService>();
0: 
0:     public synchronized void start(final BundleContext context) throws Exception {
0:         lst = new LogServiceTracker(context, LogService.class.getName(), null);
0:         lst.open();
0:         
0: 	    bt = new SPIBundleTracker(context, this);
0: 	    bt.open();
0: 	}
0: 
0: 	public synchronized void stop(BundleContext context) throws Exception {
0: 	    bt.close();
0: 	    lst.close();	    
0: 	}
0: 	
0: 	void log(int level, String message) {
0: 	    synchronized (logServices) {
0: 	        for (LogService log : logServices) {
0: 	            log.log(level, message);
0: 	        }
0:         }
0: 	}
0: 
0: 	void log(int level, String message, Throwable th) {
0:         synchronized (logServices) {
0:             for (LogService log : logServices) {
0:                 log.log(level, message, th);
0:             }
0:         }
0:     }
0:     
0: 	private final class LogServiceTracker extends ServiceTracker {
0:         private LogServiceTracker(BundleContext context, String clazz,
0:                 ServiceTrackerCustomizer customizer) {
0:             super(context, clazz, customizer);
0:         }
0: 
0:         @Override
0:         public Object addingService(ServiceReference reference) {
0:             Object svc = super.addingService(reference);
0:             if (svc instanceof LogService) {
0:                 synchronized (logServices) {
0:                     logServices.add((LogService) svc);
0:                 }
0:             }
0:             return svc;
0:         }
0: 
0:         @Override
0:         public void removedService(ServiceReference reference, Object service) {
0:             synchronized (logServices) {
0:                 logServices.remove(service);
0:             }
0:             super.removedService(reference, service);
0:         }
0:     }
0: }
author:Christian Schneider
-------------------------------------------------------------------------------
commit:60bf8cd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
============================================================================