1:264011e: /*
1:264011e:  * Licensed to the Apache Software Foundation (ASF) under one
1:264011e:  * or more contributor license agreements.  See the NOTICE file
1:264011e:  * distributed with this work for additional information
1:264011e:  * regarding copyright ownership.  The ASF licenses this file
1:264011e:  * to you under the Apache License, Version 2.0 (the
1:264011e:  * "License"); you may not use this file except in compliance
1:264011e:  * with the License.  You may obtain a copy of the License at
1:264011e:  *
1:264011e:  *   http://www.apache.org/licenses/LICENSE-2.0
1:264011e:  *
1:264011e:  * Unless required by applicable law or agreed to in writing,
1:264011e:  * software distributed under the License is distributed on an
1:264011e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:264011e:  * KIND, either express or implied.  See the License for the
1:264011e:  * specific language governing permissions and limitations
1:264011e:  * under the License.
1:264011e:  */
1:264011e: package org.apache.aries.mocks;
1:264011e: 
1:264011e: import static org.junit.Assert.assertFalse;
1:264011e: import static org.junit.Assert.assertTrue;
1:264011e: 
1:264011e: import java.io.File;
1:264011e: import java.io.FileInputStream;
1:264011e: import java.io.IOException;
1:264011e: import java.io.InputStream;
1:264011e: import java.net.MalformedURLException;
1:264011e: import java.net.URI;
1:264011e: import java.net.URISyntaxException;
1:264011e: import java.util.ArrayList;
1:264011e: import java.util.Dictionary;
1:264011e: import java.util.Enumeration;
1:264011e: import java.util.HashMap;
1:264011e: import java.util.Hashtable;
1:264011e: import java.util.Iterator;
1:264011e: import java.util.List;
1:264011e: import java.util.Map;
1:0d84fd2: import java.util.Random;
1:264011e: import java.util.jar.Attributes;
1:264011e: import java.util.jar.JarInputStream;
1:264011e: import java.util.jar.Manifest;
1:264011e: 
1:264011e: import junit.framework.AssertionFailedError;
1:264011e: 
1:264011e: import org.osgi.framework.Bundle;
1:264011e: import org.osgi.framework.BundleException;
1:264011e: import org.osgi.framework.Constants;
1:264011e: import org.osgi.framework.Filter;
1:264011e: import org.osgi.framework.FrameworkUtil;
1:264011e: import org.osgi.framework.InvalidSyntaxException;
1:264011e: import org.osgi.framework.ServiceEvent;
1:264011e: import org.osgi.framework.ServiceFactory;
1:264011e: import org.osgi.framework.ServiceListener;
1:264011e: import org.osgi.framework.ServiceReference;
1:264011e: import org.osgi.framework.ServiceRegistration;
1:264011e: 
1:264011e: import org.apache.aries.unittest.mocks.Skeleton;
1:264011e: 
1:264011e: /**
1:264011e:  *
1:264011e:  */
1:264011e: /**
1:264011e:  * This class is a partial implementation of BundleContext. Its main function
1:264011e:  * is to provide a service registry implementation
1:264011e:  */
1:264011e: public class BundleContextMock
1:264011e: {
1:264011e:   /** The service registry */
1:264011e:   private static Map<String, List<ServiceData>> registry = new HashMap<String, List<ServiceData>>();
1:264011e:   /** A list of bundles installed into the runtime */
1:264011e:   private static List<Bundle> bundles = new ArrayList<Bundle>();
1:264011e:   /** A list of service listeners */
1:264011e:   private static List<ServiceListener> listeners = new ArrayList<ServiceListener>();
1:264011e:   /** The next service id to be assigned */
1:264011e:   private static long nextId = 0;
1:264011e: 
1:264011e:   private static class MockServiceFactory implements ServiceFactory
1:264011e:   {
1:264011e:     private final Object service;
1:264011e:     
1:264011e:     public MockServiceFactory(Object obj)
1:264011e:     {
1:264011e:       service = obj;
1:264011e:     }
1:264011e:     
1:264011e:     public Object getService(Bundle arg0, ServiceRegistration arg1)
1:264011e:     {
1:264011e:       return service;
1:264011e:     }
1:264011e: 
1:264011e:     public void ungetService(Bundle arg0, ServiceRegistration arg1, Object arg2)
1:264011e:     {
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   private static class FilteredServiceListener implements ServiceListener
1:264011e:   {
1:264011e:     private Filter filter;
1:264011e:     private final ServiceListener listener;
1:264011e:     
1:264011e:     public FilteredServiceListener(String f, ServiceListener l)
1:264011e:     {
1:264011e:       listener = l;
1:264011e:       
1:264011e:       if (f != null) {
1:264011e:         try {
1:264011e:           filter = FrameworkUtil.createFilter(f);
1:264011e:         } catch (InvalidSyntaxException e) {
1:264011e:           AssertionFailedError err = new AssertionFailedError("The filter " + f + " is invalid");
1:264011e:           err.initCause(e);
1:264011e:           
1:264011e:           throw err;
1:264011e:         }
1:264011e:       }
1:264011e:     }
1:264011e: 
1:264011e:     public void serviceChanged(ServiceEvent arg0)
1:264011e:     {
1:264011e:       if (matches(arg0)) listener.serviceChanged(arg0);
1:264011e:     }
1:264011e: 
1:264011e:     private boolean matches(ServiceEvent arg0)
1:264011e:     {
1:264011e:       if (filter == null) return true;
1:264011e:       
1:264011e:       ServiceReference ref = arg0.getServiceReference();
1:264011e:       
1:264011e:       if (Skeleton.isSkeleton(ref)) {
1:264011e:         Object template = Skeleton.getSkeleton(ref).getTemplateObject();
1:264011e:         
1:264011e:         if (template instanceof ServiceData) {
1:264011e:           return filter.match(((ServiceData)template).getProperties());
1:264011e:         }
1:264011e:       }
1:264011e:       
1:264011e:       return filter.match(ref);
1:264011e:     }
1:264011e:     
1:264011e:     @Override
1:264011e:     public boolean equals(Object obj)
1:264011e:     {
1:264011e:       if (obj == null) return false;
1:264011e:       else if (obj instanceof FilteredServiceListener) {
1:264011e:         return listener.equals(((FilteredServiceListener)obj).listener);
1:264011e:       }
1:264011e:       
1:264011e:       return false;
1:264011e:     }
1:264011e:     
1:264011e:     @Override
1:264011e:     public int hashCode()
1:264011e:     {
1:264011e:       return listener.hashCode();
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This class represents the information registered about a service. It also
1:264011e:    * implements part of the ServiceRegistration and ServiceReference interfaces.
1:264011e:    */
1:a5a6778:   private class ServiceData implements Comparable<ServiceReference>
1:264011e:   {
1:264011e:     /** The service that was registered */
1:264011e:     private ServiceFactory serviceImpl;
1:264011e:     /** the service properties */
1:264011e:     @SuppressWarnings("unused")
1:264011e:     private final Hashtable<String, Object> serviceProps = new Hashtable<String, Object>();
1:264011e:     /** The interfaces the service publishes with */
1:264011e:     private String[] interfaceNames;
1:0d84fd2:     /** The bundle that defines this service */
1:0d84fd2:     private Bundle registeringBundle;
1:264011e: 
1:264011e:     /**
1:264011e:      * This method unregisters the service from the registry.
1:264011e:      */
1:264011e:     public void unregister()
1:264011e:     {
1:264011e:       for (String interfaceName : interfaceNames) {
1:264011e:         List<ServiceData> list = registry.get(interfaceName);
1:264011e:         if (list != null) {
1:264011e:           list.remove(this);
1:264011e:           if (list.isEmpty()) {
1:264011e:             registry.remove(interfaceName);
1:264011e:           }
1:264011e:         }
1:264011e:       }
1:264011e:       notifyAllListeners(ServiceEvent.UNREGISTERING);
1:0d84fd2:       registeringBundle = null;
1:264011e:     }
1:264011e: 
1:264011e:     /**
1:264011e:      * This method is used to register the service data in the registry
1:264011e:      */
1:264011e:     public void register()
1:264011e:     {
1:264011e:       for (String interfaceName : interfaceNames) {
1:264011e:         List<ServiceData> list = registry.get(interfaceName);
1:264011e:         if (list == null) {
1:264011e:           list = new ArrayList<ServiceData>();
1:264011e:           registry.put(interfaceName, list);
1:264011e:         }
1:264011e:         list.add(this);
1:264011e:       }
1:264011e:       notifyAllListeners(ServiceEvent.REGISTERED);
1:264011e:     }
1:264011e:     
1:264011e:     private void notifyAllListeners(int eventType) {
1:264011e:       List<ServiceListener> copy = new ArrayList<ServiceListener>(listeners.size());
1:264011e:       copy.addAll(listeners);
1:264011e:       for(ServiceListener listener : copy) {
1:264011e:         listener.serviceChanged(new ServiceEvent(eventType, Skeleton.newMock(this, ServiceReference.class)));
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     /**
1:264011e:      * Change the service properties
1:264011e:      * @param newProps
1:264011e:      */
1:264011e:     public void setProperties(Dictionary<String,Object> newProps)
1:264011e:     {
1:264011e:       // make sure we don't overwrite framework properties
1:264011e:       newProps.put(Constants.OBJECTCLASS, serviceProps.get(Constants.OBJECTCLASS));
1:264011e:       newProps.put(Constants.SERVICE_ID, serviceProps.get(Constants.SERVICE_ID));
1:264011e: 
1:264011e:       Enumeration<String> keys = newProps.keys();
1:264011e:       
1:264011e:       serviceProps.clear();
1:264011e:       while (keys.hasMoreElements()) {
1:264011e:         String key = keys.nextElement();
1:264011e:         serviceProps.put(key, newProps.get(key));
1:264011e:       }
1:264011e:       
1:264011e:       notifyAllListeners(ServiceEvent.MODIFIED);
1:264011e:     }
1:264011e:     
1:264011e:     /**
1:264011e:      * This implements the isAssignableTo method from ServiceReference.
1:264011e:      * 
1:264011e:      * @param b
1:264011e:      * @param className
1:264011e:      * @return true if the referenced service can be assigned to the requested
1:264011e:      *              class name.
1:264011e:      */
1:264011e:     public boolean isAssignableTo(Bundle b, String className)
1:264011e:     {
1:264011e:       boolean result = false;
1:264011e:       
1:264011e:       for (String iName : interfaceNames)
1:264011e:       {
1:264011e:         result = iName.equals(className);
1:264011e:         
1:264011e:         if (result) break;
1:264011e:       }
1:264011e:       
1:264011e:       return result;
1:264011e:     }
1:264011e:     
1:264011e:     /**
1:264011e:      * Returns the requested service property.
1:264011e:      * @param key the property to return.
1:264011e:      * @return the property value.
1:264011e:      */
1:264011e:     public Object getProperty(String key)
1:264011e:     {
1:264011e:       return serviceProps.get(key);
1:264011e:     }
1:264011e:     
1:264011e:     @Override
1:264011e:     public boolean equals(Object o) {
1:264011e:       if(o == null) return false;
1:264011e:       
1:264011e:       if(o == this) return true;
1:264011e:       
1:264011e:       if (o instanceof ServiceData) {
1:264011e:         ServiceData other = (ServiceData) o;
1:264011e:         return serviceImpl == other.serviceImpl;
1:264011e:       }
1:264011e:       
1:264011e:       return false;
1:264011e:     }
1:264011e:     
1:264011e:     @Override
1:264011e:     public int hashCode()
1:264011e:     {
1:264011e:       return serviceImpl.hashCode();
1:264011e:     }
1:264011e:     
1:264011e:     /**
1:264011e:      * @return the keys of all the service properties.
1:264011e:      */
1:264011e:     public String[] getPropertyKeys()
1:264011e:     {
1:264011e:       Enumeration<String> e = serviceProps.keys();
1:264011e:       
1:264011e:       String[] toReturn = new String[serviceProps.size()];
1:264011e:       
1:264011e:       for(int i = 0 ; i < serviceProps.size(); i++)
1:264011e:         toReturn[i] = e.nextElement();
1:264011e:       
1:264011e:       return toReturn;
1:264011e:     }
1:264011e:     
1:264011e:     /**
1:264011e:      * @return the bundle this service reference was registered against.
1:264011e:      */
1:264011e:     public Bundle getBundle()
1:264011e:     {
1:0d84fd2:       return registeringBundle;
1:264011e:     }
1:264011e:     
1:264011e:     /**
1:264011e:      * @return a service reference for this service registration.
1:264011e:      */
1:264011e:     public ServiceReference getReference()
1:264011e:     {
1:264011e:       return Skeleton.newMock(this, ServiceReference.class);
1:264011e:     }
1:264011e:     
1:264011e:     public Hashtable<String, Object> getProperties()
1:264011e:     {
1:264011e:       return new Hashtable<String, Object>(serviceProps);
1:264011e:     }
1:264011e: 
31:4e2fb0c:     /**
1:a5a6778:      * Implement the standard behaviour of the registry
33:4e2fb0c:      */
1:a5a6778:     public int compareTo(ServiceReference o) {
1:a5a6778:       Integer rank = (Integer) serviceProps.get(Constants.SERVICE_RANKING);
1:a5a6778:       if(rank == null)
1:a5a6778:         rank = 0;
1:264011e:       
1:a5a6778:       Integer otherRank = (Integer) o.getProperty(Constants.SERVICE_RANKING);
1:a5a6778:       if(otherRank == null)
1:a5a6778:         otherRank = 0;
1:a5a6778:       //Higher rank = higher order
1:a5a6778:       int result = rank.compareTo(otherRank);
106:4e2fb0c:       
1:a5a6778:       if(result == 0) {
1:a5a6778:         Long id = (Long) serviceProps.get(Constants.SERVICE_ID);
1:a5a6778:         Long otherId = (Long) o.getProperty(Constants.SERVICE_ID);
1:a5a6778:         //higher id = lower order
1:a5a6778:         return otherId.compareTo(id);
1:264011e:       }
1:4e2fb0c:       return result;
78:4e2fb0c:     }
1:4e2fb0c:   }
1:4e2fb0c: 
1:264011e:   /** The bundle associated with this bundle context */
1:264011e:   private Bundle bundle;
1:264011e: 
1:264011e:   /**
1:264011e:    * Default constructor, widely used in the tests.
1:264011e:    */
1:264011e:   public BundleContextMock()
1:264011e:   {
1:0d84fd2:     bundle = Skeleton.newMock(new BundleMock("test." + new Random(System.currentTimeMillis()).nextInt(),
1:0d84fd2:                               new Hashtable<Object, Object>()), Bundle.class);
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Constructor used by BundleMock, it ensures the bundle and its context are wired together correctly.
1:264011e:    * 
1:264011e:    * TODO We have to many Bundle mocks objects for a single OSGi bundle, we need to update this.
1:264011e:    * 
1:264011e:    * @param b
1:264011e:    */
1:264011e:   public BundleContextMock(Bundle b)
1:264011e:   {
1:264011e:     bundle = b;
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This checks that we have at least one service with this interface name.
1:264011e:    * 
1:264011e:    * @param interfaceName the name of the interface.
1:264011e:    */
1:264011e:   public static void assertServiceExists(String interfaceName)
1:264011e:   {
1:264011e:     assertTrue("No service registered with interface " + interfaceName + ". Services found: " + registry.keySet(), registry.containsKey(interfaceName));
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This checks that we have at no services with this interface name.
1:264011e:    * 
1:264011e:    * @param interfaceName the name of the interface.
1:264011e:    */
1:264011e:   public static void assertNoServiceExists(String interfaceName)
1:264011e:   {
1:264011e:     assertFalse("Services registered with interface " + interfaceName + ". Services found: " + registry.keySet(), registry.containsKey(interfaceName));
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This implements the registerService method from BundleContext.
1:264011e:    * 
1:264011e:    * @param interFace
1:264011e:    * @param service
1:264011e:    * @param properties
1:264011e:    * @return the ServiceRegistration object for this service.
1:264011e:    */
1:264011e:   public ServiceRegistration registerService(String interFace, final Object service, Dictionary<String, Object> properties)
1:264011e:   {
1:264011e:     // validate that the service implements interFace
1:264011e:     try {
1:264011e:       Class<?> clazz = Class.forName(interFace, false, service.getClass().getClassLoader());
1:264011e:       
1:264011e:       if (!!!clazz.isInstance(service) && !!!(service instanceof ServiceFactory)) {
1:264011e:         throw new AssertionFailedError("The service " + service + " does not implement " + interFace);
1:264011e:       }
1:264011e:     } catch (ClassNotFoundException e) {
1:264011e:       // TODO Auto-generated catch block
1:264011e:       e.printStackTrace();
1:264011e:     }
1:264011e: 
1:7b2544b:     return registerService(new String[] {interFace}, service, properties);
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This implements the registerService method from BundleContext.
1:264011e:    * 
1:264011e:    * @param interfaces
1:264011e:    * @param service
1:264011e:    * @param properties
1:264011e:    * @return the ServiceRegistration object for this service.
1:264011e:    */
1:264011e:   public ServiceRegistration registerService(String[] interfaces, Object service, Dictionary<String, Object> properties)
1:264011e:   {
1:264011e:     if (properties == null) properties = new Hashtable<String, Object>();
1:264011e:     
1:264011e:     ServiceData data = new ServiceData();
1:264011e:     // cast the service to a service factory because in our framework we only ever register
1:264011e:     // a service factory. If we every put a non-service factory object in that is a failure.
1:264011e:     properties.put(Constants.OBJECTCLASS, interfaces);
1:264011e:     properties.put(Constants.SERVICE_ID, nextId++);
1:264011e:     if (service instanceof ServiceFactory) {
1:264011e:       data.serviceImpl = (ServiceFactory)service;
1:264011e:     } else {
1:264011e:       data.serviceImpl = new MockServiceFactory(service);
1:264011e:     }
1:264011e:     data.interfaceNames = interfaces;
1:0d84fd2:     data.registeringBundle = bundle;
1:264011e:     
1:264011e:     Enumeration<String> keys = properties.keys();
1:264011e:     
1:264011e:     while (keys.hasMoreElements()) {
1:264011e:       String key = keys.nextElement();
1:264011e:       data.serviceProps.put(key, properties.get(key));
1:264011e:     }
1:264011e:     
1:264011e:     data.register();
1:264011e:     
1:264011e:     return Skeleton.newMock(data, ServiceRegistration.class);
1:264011e:   }
1:264011e: 
1:264011e:   /**
1:264011e:    * This helper method is used to get the service from the registry with the
1:264011e:    * given interface name.
1:264011e:    * 
1:264011e:    * <p>This should really return multiple services.
1:264011e:    * </p>
1:264011e:    * 
1:264011e:    * @param interfaceName the interface name.
1:264011e:    * @param bundle        the bundle name.
1:264011e:    * @return the registered service.
1:264011e:    */
1:264011e:   public static Object getService(String interfaceName, Bundle bundle)
1:264011e:   {
1:264011e:     List<ServiceData> datum = registry.get(interfaceName);
1:264011e:     
1:264011e:     if (datum == null) return null;
1:264011e:     else if (datum.isEmpty()) return null;
1:264011e:     // this is safe for now, but may not be when we do other scoped components.
1:264011e:     else {
1:264011e:       ServiceRegistration reg = Skeleton.newMock(ServiceRegistration.class);
1:264011e:       return datum.iterator().next().serviceImpl.getService(bundle, reg);
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * A mock implementation of the getServiceReferences method. It does not currently
1:264011e:    * process the filter, this is probably a bit hard, so we might cheat when we do.
1:264011e:    * 
1:264011e:    * <p>Note this does not check that the service classes are visible to the
1:264011e:    *   caller as OSGi does. It is equivalent to getAllServiceReferences.
1:264011e:    * </p>
1:264011e:    * 
1:264011e:    * @param className the name of the class the lookup is for.
1:264011e:    * @param filter
1:264011e:    * @return an array of matching service references.
1:264011e:    * @throws InvalidSyntaxException
1:264011e:    */
1:264011e:   public ServiceReference[] getServiceReferences(String className, String filter) throws InvalidSyntaxException
1:264011e:   {
1:264011e:     List<ServiceData> data = new ArrayList<ServiceData>();
1:264011e:     
1:264011e:     if (className != null) {
1:264011e:       List<ServiceData> tmpData = registry.get(className);
1:264011e:       if (tmpData != null) data.addAll(tmpData);
1:264011e:     } else {
1:264011e:       data = new ArrayList<ServiceData>();
1:264011e:       for (List<ServiceData> value : registry.values())
1:264011e:       data.addAll(value);
1:264011e:     }
1:264011e:     
1:264011e:     ServiceReference[] refs;
1:264011e: 
1:264011e:     if (data == null) {
1:264011e:       refs = null;
1:264011e:     } else {
1:264011e:       
1:264011e:       if (filter != null) {
1:264011e:         Filter f = FrameworkUtil.createFilter(filter);
1:264011e:         
1:264011e:         Iterator<ServiceData> it = data.iterator();
1:264011e:         
1:264011e:         while (it.hasNext()) {
1:264011e:           ServiceData sd = it.next();
1:264011e:           
1:264011e:           if (!!!f.match(sd.getProperties())) it.remove();
1:264011e:         }
1:264011e:       }
1:264011e:       
1:264011e:       if (data.isEmpty()) return null;
1:264011e:       
1:264011e:       refs = new ServiceReference[data.size()];
1:264011e:       for (int i = 0; i < refs.length; i++) {
1:264011e:         refs[i] = Skeleton.newMock(data.get(i), ServiceReference.class);
1:264011e:       }
1:264011e:     }
1:264011e:     
1:264011e:     return refs;
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Gets the first matching service reference.
1:264011e:    * 
1:264011e:    * @param className the class name wanted.
1:264011e:    * @return the matchine service, or null if one cannot be found.
1:264011e:    */
1:264011e:   public ServiceReference getServiceReference(String className)
1:264011e:   {
1:264011e:     ServiceReference[] refs;
1:264011e:     try {
1:264011e:       refs = getServiceReferences(className, null);
1:264011e:       if (refs != null) return refs[0];
1:264011e:       
1:264011e:       return null;
1:264011e:     } catch (InvalidSyntaxException e) {
1:264011e:       // should never happen.
1:264011e:       e.printStackTrace();
1:264011e:     }
1:264011e:     return null;
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This method finds all the service references in the registry with the
1:264011e:    * matching class name and filter.
1:264011e:    * 
1:264011e:    * @param className
1:264011e:    * @param filter
1:264011e:    * @return the matching service references.
1:264011e:    * @throws InvalidSyntaxException
1:264011e:    */
1:264011e:   public ServiceReference[] getAllServiceReferences(String className, String filter) throws InvalidSyntaxException
1:264011e:   {
1:264011e:     return getServiceReferences(className, filter);
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Retrieve a service from the registry.
1:264011e:    * @param ref the service reference.
1:264011e:    * @return    the returned service.
1:264011e:    */
1:264011e:   public Object getService(ServiceReference ref)
1:264011e:   {
1:264011e:     ServiceData data = (ServiceData)Skeleton.getSkeleton(ref).getTemplateObject();
1:264011e:     
1:264011e:     return data.serviceImpl.getService(getBundle(), Skeleton.newMock(data, ServiceRegistration.class));
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This method implements the installBundle method from BundleContext. It
1:264011e:    * makes use of the java.util.jar package to parse the manifest from the input
1:264011e:    * stream.
1:264011e:    * 
1:264011e:    * @param location the location of the bundle.
1:264011e:    * @param is       the input stream to read from.
1:264011e:    * @return         the created bundle.
1:264011e:    * @throws BundleException
1:264011e:    */
1:264011e:   public Bundle installBundle(String location, InputStream is) throws BundleException
1:264011e:   {
1:264011e:     Bundle b;
1:264011e:     JarInputStream jis;
1:264011e:     try {
1:264011e:       jis = new JarInputStream(is);
1:264011e: 
1:264011e:       Manifest man = jis.getManifest();
1:264011e:       
1:264011e:       b = createBundle(man, null);
1:264011e:       
1:264011e:     } catch (IOException e) {
1:264011e:       throw new BundleException(e.getMessage(), e);
1:264011e:     }
1:264011e:     
1:264011e:     return b;
1:264011e:   }
1:264011e: 
1:264011e:   /**
1:264011e:    * Create a mock bundle correctly configured using the supplied manifest and
1:264011e:    * location.
1:264011e:    * 
1:264011e:    * @param man      the manifest to load.
1:264011e:    * @param location the location on disk.
1:264011e:    * @return the created bundle
1:264011e:    * @throws MalformedURLException
1:264011e:    */
1:264011e:   private Bundle createBundle(Manifest man, String location) throws MalformedURLException
1:264011e:   {
1:264011e:     Attributes attribs = man.getMainAttributes();
1:264011e:     String symbolicName = attribs.getValue(Constants.BUNDLE_SYMBOLICNAME);
1:264011e:     
1:264011e:     Hashtable<Object, Object> attribMap = new Hashtable<Object, Object>();
1:264011e:     
1:264011e:     for (Map.Entry<Object, Object> entry : attribs.entrySet()) {
1:264011e:       Attributes.Name name = (Attributes.Name)entry.getKey();
1:264011e:       attribMap.put(name.toString(), entry.getValue());
1:264011e:     }
1:264011e:     
1:264011e:     BundleMock mock = new BundleMock(symbolicName, attribMap, location);
1:264011e: 
1:264011e:     mock.addToClassPath(new File("build/unittest/classes").toURL());
1:264011e: 
1:264011e:     Bundle b = Skeleton.newMock(mock, Bundle.class);
1:264011e:     
1:264011e:     bundles.add(b);
1:264011e: 
1:264011e:     return b;
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Asks to install an OSGi bundle from the given location.
1:264011e:    * 
1:264011e:    * @param location the location of the bundle on the file system.
1:264011e:    * @return the installed bundle.
1:264011e:    * @throws BundleException
1:264011e:    */
1:264011e:   public Bundle installBundle(String location) throws BundleException
1:264011e:   {
1:264011e:     try {
1:264011e:       URI uri = new URI(location.replaceAll(" ", "%20"));
1:264011e: 
1:264011e:       File baseDir = new File(uri);
1:264011e:       Manifest man = null;
1:264011e:       //check if it is a directory
1:264011e:       if (baseDir.isDirectory()){
1:264011e:       man = new Manifest(new FileInputStream(new File(baseDir, "META-INF/MANIFEST.MF")));
1:264011e:       }
1:264011e:       //if it isn't assume it is a jar file
1:264011e:       else{
1:264011e:         InputStream is = new FileInputStream(baseDir);
1:264011e:         JarInputStream jis = new JarInputStream(is);
1:264011e:         man = jis.getManifest();
1:264011e:         jis.close();
1:264011e:         if (man == null){
1:264011e:           throw new BundleException("Null manifest");
1:264011e:         }
1:264011e:       }
1:264011e:       
1:264011e:       return createBundle(man, location);
1:264011e:     } catch (IOException e) {
1:264011e:       throw new BundleException(e.getMessage(), e);
1:264011e:     } catch (URISyntaxException e) {
1:264011e:       // TODO Auto-generated catch block
1:264011e:       throw new BundleException(e.getMessage(), e);
1:264011e:     }
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * @return all the bundles in the system
1:264011e:    */
1:264011e:     public Bundle[] getBundles()
1:264011e:   {
1:264011e:     return bundles.toArray(new Bundle[bundles.size()]);
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Add a service listener.
1:264011e:    * 
1:264011e:    * @param listener
1:264011e:    * @param filter
1:264011e:    */
1:264011e:   public void addServiceListener(ServiceListener listener, String filter)
1:264011e:   {
1:264011e:     listeners.add(new FilteredServiceListener(filter, listener));
1:264011e:   }
1:264011e: 
1:264011e:   /**
1:264011e:    * Add a service listener.
1:264011e:    * 
1:264011e:    * @param listener
1:264011e:    */
1:264011e:   public void addServiceListener(ServiceListener listener) 
1:264011e:   {
1:264011e:     listeners.add(listener);
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * Remove a service listener
1:264011e:    * @param listener
1:264011e:    */
1:264011e:   public void removeServiceListener(ServiceListener listener)
1:264011e:   {
1:264011e:     listeners.remove(new FilteredServiceListener(null, listener));
1:264011e:   }
1:264011e:   
1:264011e:   public String getProperty(String name)
1:264011e:   {
1:264011e:     if (Constants.FRAMEWORK_VERSION.equals(name)) {
1:264011e:       return "4.1";
1:264011e:     }
1:264011e:     /*added System.getProperty so that tests can set a system property
1:264011e:      * but it is retrieved via the BundleContext.
1:264011e:      * This allows tests to emulate different properties being set on the
1:264011e:      * context, helpful for the feature pack launcher/kernel relationship
1:264011e:      */
1:264011e:     else if (System.getProperty(name) != null){
1:264011e:       return System.getProperty(name);
1:264011e:     }
1:264011e:     
1:264011e:     return "";
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * @return the bundle associated with this bundle context (if we created one).
1:264011e:    */
1:264011e:   public Bundle getBundle()
1:264011e:   {
2:264011e:     return bundle;
1:264011e:   }
1:264011e:   
1:264011e:   /**
1:264011e:    * This method clears the service registry.
1:264011e:    */
1:264011e:   public static void clear()
1:264011e:   {
1:264011e:     registry.clear();
1:264011e:     bundles.clear();
1:264011e:     listeners.clear();
1:264011e:     nextId = 0;
1:264011e:   }
1:264011e:   
1:264011e:   public static List<ServiceListener> getServiceListeners()
1:264011e:   {
1:264011e:     return listeners;
1:264011e:   }
1:264011e: 
1:264011e:   public void addBundle(Bundle b)
1:264011e:   {
1:264011e:     bundles.add(b);
1:264011e:   }
1:4e2fb0c: }
============================================================================
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:7b2544b
/////////////////////////////////////////////////////////////////////////
1:     return registerService(new String[] {interFace}, service, properties);
commit:264011e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.mocks;
1: 
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.net.MalformedURLException;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Hashtable;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.jar.Attributes;
1: import java.util.jar.JarInputStream;
1: import java.util.jar.Manifest;
1: 
1: import junit.framework.AssertionFailedError;
1: 
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleException;
1: import org.osgi.framework.Constants;
1: import org.osgi.framework.Filter;
1: import org.osgi.framework.FrameworkUtil;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.framework.ServiceEvent;
1: import org.osgi.framework.ServiceFactory;
1: import org.osgi.framework.ServiceListener;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.ServiceRegistration;
1: 
1: import org.apache.aries.unittest.mocks.Skeleton;
1: 
1: /**
1:  *
1:  */
1: /**
1:  * This class is a partial implementation of BundleContext. Its main function
1:  * is to provide a service registry implementation
1:  */
1: public class BundleContextMock
1: {
1:   /** The service registry */
1:   private static Map<String, List<ServiceData>> registry = new HashMap<String, List<ServiceData>>();
1:   /** A list of bundles installed into the runtime */
1:   private static List<Bundle> bundles = new ArrayList<Bundle>();
1:   /** A list of service listeners */
1:   private static List<ServiceListener> listeners = new ArrayList<ServiceListener>();
1:   /** The next service id to be assigned */
1:   private static long nextId = 0;
1: 
1:   private static class MockServiceFactory implements ServiceFactory
1:   {
1:     private final Object service;
1:     
1:     public MockServiceFactory(Object obj)
1:     {
1:       service = obj;
1:     }
1:     
1:     public Object getService(Bundle arg0, ServiceRegistration arg1)
1:     {
1:       return service;
1:     }
1: 
1:     public void ungetService(Bundle arg0, ServiceRegistration arg1, Object arg2)
1:     {
1:     }
1:   }
1:   
1:   private static class FilteredServiceListener implements ServiceListener
1:   {
1:     private Filter filter;
1:     private final ServiceListener listener;
1:     
1:     public FilteredServiceListener(String f, ServiceListener l)
1:     {
1:       listener = l;
1:       
1:       if (f != null) {
1:         try {
1:           filter = FrameworkUtil.createFilter(f);
1:         } catch (InvalidSyntaxException e) {
1:           AssertionFailedError err = new AssertionFailedError("The filter " + f + " is invalid");
1:           err.initCause(e);
1:           
1:           throw err;
1:         }
1:       }
1:     }
1: 
1:     public void serviceChanged(ServiceEvent arg0)
1:     {
1:       if (matches(arg0)) listener.serviceChanged(arg0);
1:     }
1: 
1:     private boolean matches(ServiceEvent arg0)
1:     {
1:       if (filter == null) return true;
1:       
1:       ServiceReference ref = arg0.getServiceReference();
1:       
1:       if (Skeleton.isSkeleton(ref)) {
1:         Object template = Skeleton.getSkeleton(ref).getTemplateObject();
1:         
1:         if (template instanceof ServiceData) {
1:           return filter.match(((ServiceData)template).getProperties());
1:         }
1:       }
1:       
1:       return filter.match(ref);
1:     }
1:     
1:     @Override
1:     public boolean equals(Object obj)
1:     {
1:       if (obj == null) return false;
1:       else if (obj instanceof FilteredServiceListener) {
1:         return listener.equals(((FilteredServiceListener)obj).listener);
1:       }
1:       
1:       return false;
1:     }
1:     
1:     @Override
1:     public int hashCode()
1:     {
1:       return listener.hashCode();
1:     }
1:   }
1:   
1:   /**
1:    * This class represents the information registered about a service. It also
1:    * implements part of the ServiceRegistration and ServiceReference interfaces.
1:    */
0:   private class ServiceData
1:   {
1:     /** The service that was registered */
1:     private ServiceFactory serviceImpl;
1:     /** the service properties */
1:     @SuppressWarnings("unused")
1:     private final Hashtable<String, Object> serviceProps = new Hashtable<String, Object>();
1:     /** The interfaces the service publishes with */
1:     private String[] interfaceNames;
1: 
1:     /**
1:      * This method unregisters the service from the registry.
1:      */
1:     public void unregister()
1:     {
1:       for (String interfaceName : interfaceNames) {
1:         List<ServiceData> list = registry.get(interfaceName);
1:         if (list != null) {
1:           list.remove(this);
1:           if (list.isEmpty()) {
1:             registry.remove(interfaceName);
1:           }
1:         }
1:       }
1:       notifyAllListeners(ServiceEvent.UNREGISTERING);
1:     }
1: 
1:     /**
1:      * This method is used to register the service data in the registry
1:      */
1:     public void register()
1:     {
1:       for (String interfaceName : interfaceNames) {
1:         List<ServiceData> list = registry.get(interfaceName);
1:         if (list == null) {
1:           list = new ArrayList<ServiceData>();
1:           registry.put(interfaceName, list);
1:         }
1:         list.add(this);
1:       }
1:       notifyAllListeners(ServiceEvent.REGISTERED);
1:     }
1:     
1:     private void notifyAllListeners(int eventType) {
1:       List<ServiceListener> copy = new ArrayList<ServiceListener>(listeners.size());
1:       copy.addAll(listeners);
1:       for(ServiceListener listener : copy) {
1:         listener.serviceChanged(new ServiceEvent(eventType, Skeleton.newMock(this, ServiceReference.class)));
1:       }
1:     }
1:     
1:     /**
1:      * Change the service properties
1:      * @param newProps
1:      */
1:     public void setProperties(Dictionary<String,Object> newProps)
1:     {
1:       // make sure we don't overwrite framework properties
1:       newProps.put(Constants.OBJECTCLASS, serviceProps.get(Constants.OBJECTCLASS));
1:       newProps.put(Constants.SERVICE_ID, serviceProps.get(Constants.SERVICE_ID));
1: 
1:       Enumeration<String> keys = newProps.keys();
1:       
1:       serviceProps.clear();
1:       while (keys.hasMoreElements()) {
1:         String key = keys.nextElement();
1:         serviceProps.put(key, newProps.get(key));
1:       }
1:       
1:       notifyAllListeners(ServiceEvent.MODIFIED);
1:     }
1:     
1:     /**
1:      * This implements the isAssignableTo method from ServiceReference.
1:      * 
1:      * @param b
1:      * @param className
1:      * @return true if the referenced service can be assigned to the requested
1:      *              class name.
1:      */
1:     public boolean isAssignableTo(Bundle b, String className)
1:     {
1:       boolean result = false;
1:       
1:       for (String iName : interfaceNames)
1:       {
1:         result = iName.equals(className);
1:         
1:         if (result) break;
1:       }
1:       
1:       return result;
1:     }
1:     
1:     /**
1:      * Returns the requested service property.
1:      * @param key the property to return.
1:      * @return the property value.
1:      */
1:     public Object getProperty(String key)
1:     {
1:       return serviceProps.get(key);
1:     }
1:     
1:     @Override
1:     public boolean equals(Object o) {
1:       if(o == null) return false;
1:       
1:       if(o == this) return true;
1:       
1:       if (o instanceof ServiceData) {
1:         ServiceData other = (ServiceData) o;
1:         return serviceImpl == other.serviceImpl;
1:       }
1:       
1:       return false;
1:     }
1:     
1:     @Override
1:     public int hashCode()
1:     {
1:       return serviceImpl.hashCode();
1:     }
1:     
1:     /**
1:      * @return the keys of all the service properties.
1:      */
1:     public String[] getPropertyKeys()
1:     {
1:       Enumeration<String> e = serviceProps.keys();
1:       
1:       String[] toReturn = new String[serviceProps.size()];
1:       
1:       for(int i = 0 ; i < serviceProps.size(); i++)
1:         toReturn[i] = e.nextElement();
1:       
1:       return toReturn;
1:     }
1:     
1:     /**
1:      * @return the bundle this service reference was registered against.
1:      */
1:     public Bundle getBundle()
1:     {
1:       return bundle;
1:     }
1:     
1:     /**
1:      * @return a service reference for this service registration.
1:      */
1:     public ServiceReference getReference()
1:     {
1:       return Skeleton.newMock(this, ServiceReference.class);
1:     }
1:     
1:     public Hashtable<String, Object> getProperties()
1:     {
1:       return new Hashtable<String, Object>(serviceProps);
1:     }
1:   }
1: 
1:   /** The bundle associated with this bundle context */
1:   private Bundle bundle;
1: 
1:   /**
1:    * Default constructor, widely used in the tests.
1:    */
1:   public BundleContextMock()
1:   {
1:     
1:   }
1:   
1:   /**
1:    * Constructor used by BundleMock, it ensures the bundle and its context are wired together correctly.
1:    * 
1:    * TODO We have to many Bundle mocks objects for a single OSGi bundle, we need to update this.
1:    * 
1:    * @param b
1:    */
1:   public BundleContextMock(Bundle b)
1:   {
1:     bundle = b;
1:   }
1:   
1:   /**
1:    * This checks that we have at least one service with this interface name.
1:    * 
1:    * @param interfaceName the name of the interface.
1:    */
1:   public static void assertServiceExists(String interfaceName)
1:   {
1:     assertTrue("No service registered with interface " + interfaceName + ". Services found: " + registry.keySet(), registry.containsKey(interfaceName));
1:   }
1:   
1:   /**
1:    * This checks that we have at no services with this interface name.
1:    * 
1:    * @param interfaceName the name of the interface.
1:    */
1:   public static void assertNoServiceExists(String interfaceName)
1:   {
1:     assertFalse("Services registered with interface " + interfaceName + ". Services found: " + registry.keySet(), registry.containsKey(interfaceName));
1:   }
1:   
1:   /**
1:    * This implements the registerService method from BundleContext.
1:    * 
1:    * @param interFace
1:    * @param service
1:    * @param properties
1:    * @return the ServiceRegistration object for this service.
1:    */
1:   public ServiceRegistration registerService(String interFace, final Object service, Dictionary<String, Object> properties)
1:   {
1:     // validate that the service implements interFace
1:     try {
1:       Class<?> clazz = Class.forName(interFace, false, service.getClass().getClassLoader());
1:       
1:       if (!!!clazz.isInstance(service) && !!!(service instanceof ServiceFactory)) {
1:         throw new AssertionFailedError("The service " + service + " does not implement " + interFace);
1:       }
1:     } catch (ClassNotFoundException e) {
1:       // TODO Auto-generated catch block
1:       e.printStackTrace();
1:     }
1: 
0:     ServiceFactory factory = new MockServiceFactory(service);
0:     return registerService(new String[] {interFace}, factory, properties);
1:   }
1:   
1:   /**
1:    * This implements the registerService method from BundleContext.
1:    * 
1:    * @param interfaces
1:    * @param service
1:    * @param properties
1:    * @return the ServiceRegistration object for this service.
1:    */
1:   public ServiceRegistration registerService(String[] interfaces, Object service, Dictionary<String, Object> properties)
1:   {
1:     if (properties == null) properties = new Hashtable<String, Object>();
1:     
1:     ServiceData data = new ServiceData();
1:     // cast the service to a service factory because in our framework we only ever register
1:     // a service factory. If we every put a non-service factory object in that is a failure.
1:     properties.put(Constants.OBJECTCLASS, interfaces);
1:     properties.put(Constants.SERVICE_ID, nextId++);
1:     if (service instanceof ServiceFactory) {
1:       data.serviceImpl = (ServiceFactory)service;
1:     } else {
1:       data.serviceImpl = new MockServiceFactory(service);
1:     }
1:     data.interfaceNames = interfaces;
1:     
1:     Enumeration<String> keys = properties.keys();
1:     
1:     while (keys.hasMoreElements()) {
1:       String key = keys.nextElement();
1:       data.serviceProps.put(key, properties.get(key));
1:     }
1:     
1:     data.register();
1:     
1:     return Skeleton.newMock(data, ServiceRegistration.class);
1:   }
1: 
1:   /**
1:    * This helper method is used to get the service from the registry with the
1:    * given interface name.
1:    * 
1:    * <p>This should really return multiple services.
1:    * </p>
1:    * 
1:    * @param interfaceName the interface name.
1:    * @param bundle        the bundle name.
1:    * @return the registered service.
1:    */
1:   public static Object getService(String interfaceName, Bundle bundle)
1:   {
1:     List<ServiceData> datum = registry.get(interfaceName);
1:     
1:     if (datum == null) return null;
1:     else if (datum.isEmpty()) return null;
1:     // this is safe for now, but may not be when we do other scoped components.
1:     else {
1:       ServiceRegistration reg = Skeleton.newMock(ServiceRegistration.class);
1:       return datum.iterator().next().serviceImpl.getService(bundle, reg);
1:     }
1:   }
1:   
1:   /**
1:    * A mock implementation of the getServiceReferences method. It does not currently
1:    * process the filter, this is probably a bit hard, so we might cheat when we do.
1:    * 
1:    * <p>Note this does not check that the service classes are visible to the
1:    *   caller as OSGi does. It is equivalent to getAllServiceReferences.
1:    * </p>
1:    * 
1:    * @param className the name of the class the lookup is for.
1:    * @param filter
1:    * @return an array of matching service references.
1:    * @throws InvalidSyntaxException
1:    */
1:   public ServiceReference[] getServiceReferences(String className, String filter) throws InvalidSyntaxException
1:   {
1:     List<ServiceData> data = new ArrayList<ServiceData>();
1:     
1:     if (className != null) {
1:       List<ServiceData> tmpData = registry.get(className);
1:       if (tmpData != null) data.addAll(tmpData);
1:     } else {
1:       data = new ArrayList<ServiceData>();
1:       for (List<ServiceData> value : registry.values())
1:       data.addAll(value);
1:     }
1:     
1:     ServiceReference[] refs;
1: 
1:     if (data == null) {
1:       refs = null;
1:     } else {
1:       
1:       if (filter != null) {
1:         Filter f = FrameworkUtil.createFilter(filter);
1:         
1:         Iterator<ServiceData> it = data.iterator();
1:         
1:         while (it.hasNext()) {
1:           ServiceData sd = it.next();
1:           
1:           if (!!!f.match(sd.getProperties())) it.remove();
1:         }
1:       }
1:       
1:       if (data.isEmpty()) return null;
1:       
1:       refs = new ServiceReference[data.size()];
1:       for (int i = 0; i < refs.length; i++) {
1:         refs[i] = Skeleton.newMock(data.get(i), ServiceReference.class);
1:       }
1:     }
1:     
1:     return refs;
1:   }
1:   
1:   /**
1:    * Gets the first matching service reference.
1:    * 
1:    * @param className the class name wanted.
1:    * @return the matchine service, or null if one cannot be found.
1:    */
1:   public ServiceReference getServiceReference(String className)
1:   {
1:     ServiceReference[] refs;
1:     try {
1:       refs = getServiceReferences(className, null);
1:       if (refs != null) return refs[0];
1:       
1:       return null;
1:     } catch (InvalidSyntaxException e) {
1:       // should never happen.
1:       e.printStackTrace();
1:     }
1:     return null;
1:   }
1:   
1:   /**
1:    * This method finds all the service references in the registry with the
1:    * matching class name and filter.
1:    * 
1:    * @param className
1:    * @param filter
1:    * @return the matching service references.
1:    * @throws InvalidSyntaxException
1:    */
1:   public ServiceReference[] getAllServiceReferences(String className, String filter) throws InvalidSyntaxException
1:   {
1:     return getServiceReferences(className, filter);
1:   }
1:   
1:   /**
1:    * Retrieve a service from the registry.
1:    * @param ref the service reference.
1:    * @return    the returned service.
1:    */
1:   public Object getService(ServiceReference ref)
1:   {
1:     ServiceData data = (ServiceData)Skeleton.getSkeleton(ref).getTemplateObject();
1:     
1:     return data.serviceImpl.getService(getBundle(), Skeleton.newMock(data, ServiceRegistration.class));
1:   }
1:   
1:   /**
1:    * This method implements the installBundle method from BundleContext. It
1:    * makes use of the java.util.jar package to parse the manifest from the input
1:    * stream.
1:    * 
1:    * @param location the location of the bundle.
1:    * @param is       the input stream to read from.
1:    * @return         the created bundle.
1:    * @throws BundleException
1:    */
1:   public Bundle installBundle(String location, InputStream is) throws BundleException
1:   {
1:     Bundle b;
1:     JarInputStream jis;
1:     try {
1:       jis = new JarInputStream(is);
1: 
1:       Manifest man = jis.getManifest();
1:       
1:       b = createBundle(man, null);
1:       
1:     } catch (IOException e) {
1:       throw new BundleException(e.getMessage(), e);
1:     }
1:     
1:     return b;
1:   }
1: 
1:   /**
1:    * Create a mock bundle correctly configured using the supplied manifest and
1:    * location.
1:    * 
1:    * @param man      the manifest to load.
1:    * @param location the location on disk.
1:    * @return the created bundle
1:    * @throws MalformedURLException
1:    */
1:   private Bundle createBundle(Manifest man, String location) throws MalformedURLException
1:   {
1:     Attributes attribs = man.getMainAttributes();
1:     String symbolicName = attribs.getValue(Constants.BUNDLE_SYMBOLICNAME);
1:     
1:     Hashtable<Object, Object> attribMap = new Hashtable<Object, Object>();
1:     
1:     for (Map.Entry<Object, Object> entry : attribs.entrySet()) {
1:       Attributes.Name name = (Attributes.Name)entry.getKey();
1:       attribMap.put(name.toString(), entry.getValue());
1:     }
1:     
1:     BundleMock mock = new BundleMock(symbolicName, attribMap, location);
1: 
1:     mock.addToClassPath(new File("build/unittest/classes").toURL());
1: 
1:     Bundle b = Skeleton.newMock(mock, Bundle.class);
1:     
1:     bundles.add(b);
1: 
1:     return b;
1:   }
1:   
1:   /**
1:    * Asks to install an OSGi bundle from the given location.
1:    * 
1:    * @param location the location of the bundle on the file system.
1:    * @return the installed bundle.
1:    * @throws BundleException
1:    */
1:   public Bundle installBundle(String location) throws BundleException
1:   {
1:     try {
1:       URI uri = new URI(location.replaceAll(" ", "%20"));
1: 
1:       File baseDir = new File(uri);
1:       Manifest man = null;
1:       //check if it is a directory
1:       if (baseDir.isDirectory()){
1:       man = new Manifest(new FileInputStream(new File(baseDir, "META-INF/MANIFEST.MF")));
1:       }
1:       //if it isn't assume it is a jar file
1:       else{
1:         InputStream is = new FileInputStream(baseDir);
1:         JarInputStream jis = new JarInputStream(is);
1:         man = jis.getManifest();
1:         jis.close();
1:         if (man == null){
1:           throw new BundleException("Null manifest");
1:         }
1:       }
1:       
1:       return createBundle(man, location);
1:     } catch (IOException e) {
1:       throw new BundleException(e.getMessage(), e);
1:     } catch (URISyntaxException e) {
1:       // TODO Auto-generated catch block
1:       throw new BundleException(e.getMessage(), e);
1:     }
1:   }
1:   
1:   /**
1:    * @return all the bundles in the system
1:    */
1:     public Bundle[] getBundles()
1:   {
1:     return bundles.toArray(new Bundle[bundles.size()]);
1:   }
1:   
1:   /**
1:    * Add a service listener.
1:    * 
1:    * @param listener
1:    * @param filter
1:    */
1:   public void addServiceListener(ServiceListener listener, String filter)
1:   {
1:     listeners.add(new FilteredServiceListener(filter, listener));
1:   }
1: 
1:   /**
1:    * Add a service listener.
1:    * 
1:    * @param listener
1:    */
1:   public void addServiceListener(ServiceListener listener) 
1:   {
1:     listeners.add(listener);
1:   }
1:   
1:   /**
1:    * Remove a service listener
1:    * @param listener
1:    */
1:   public void removeServiceListener(ServiceListener listener)
1:   {
1:     listeners.remove(new FilteredServiceListener(null, listener));
1:   }
1:   
1:   public String getProperty(String name)
1:   {
1:     if (Constants.FRAMEWORK_VERSION.equals(name)) {
1:       return "4.1";
1:     }
1:     /*added System.getProperty so that tests can set a system property
1:      * but it is retrieved via the BundleContext.
1:      * This allows tests to emulate different properties being set on the
1:      * context, helpful for the feature pack launcher/kernel relationship
1:      */
1:     else if (System.getProperty(name) != null){
1:       return System.getProperty(name);
1:     }
1:     
1:     return "";
1:   }
1:   
1:   /**
1:    * @return the bundle associated with this bundle context (if we created one).
1:    */
1:   public Bundle getBundle()
1:   {
1:     return bundle;
1:   }
1:   
1:   /**
1:    * This method clears the service registry.
1:    */
1:   public static void clear()
1:   {
1:     registry.clear();
1:     bundles.clear();
1:     listeners.clear();
1:     nextId = 0;
1:   }
1:   
1:   public static List<ServiceListener> getServiceListeners()
1:   {
1:     return listeners;
1:   }
1: 
1:   public void addBundle(Bundle b)
1:   {
1:     bundles.add(b);
1:   }
commit:4e2fb0c
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
0: package org.apache.aries.mocks;
1: 
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertTrue;
1: 
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.net.MalformedURLException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.Dictionary;
0: import java.util.Enumeration;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.jar.Attributes;
0: import java.util.jar.JarInputStream;
0: import java.util.jar.Manifest;
1: 
0: import junit.framework.AssertionFailedError;
1: 
0: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleException;
0: import org.osgi.framework.Constants;
0: import org.osgi.framework.Filter;
0: import org.osgi.framework.FrameworkUtil;
0: import org.osgi.framework.InvalidSyntaxException;
0: import org.osgi.framework.ServiceEvent;
0: import org.osgi.framework.ServiceFactory;
0: import org.osgi.framework.ServiceListener;
0: import org.osgi.framework.ServiceReference;
0: import org.osgi.framework.ServiceRegistration;
1: 
0: import org.apache.aries.unittest.mocks.Skeleton;
1: 
1: /**
0:  *
1:  */
1: /**
0:  * This class is a partial implementation of BundleContext. Its main function
0:  * is to provide a service registry implementation
1:  */
0: public class BundleContextMock
0: {
0:   /** The service registry */
0:   private static Map<String, List<ServiceData>> registry = new HashMap<String, List<ServiceData>>();
0:   /** A list of bundles installed into the runtime */
0:   private static List<Bundle> bundles = new ArrayList<Bundle>();
0:   /** A list of service listeners */
0:   private static List<ServiceListener> listeners = new ArrayList<ServiceListener>();
0:   /** The next service id to be assigned */
0:   private static long nextId = 0;
1: 
0:   private static class MockServiceFactory implements ServiceFactory
0:   {
0:     private final Object service;
1:     
0:     public MockServiceFactory(Object obj)
0:     {
0:       service = obj;
1:     }
1:     
0:     public Object getService(Bundle arg0, ServiceRegistration arg1)
0:     {
0:       return service;
1:     }
1: 
0:     public void ungetService(Bundle arg0, ServiceRegistration arg1, Object arg2)
0:     {
1:     }
1:   }
1:   
0:   private static class FilteredServiceListener implements ServiceListener
0:   {
0:     private Filter filter;
0:     private final ServiceListener listener;
1:     
0:     public FilteredServiceListener(String f, ServiceListener l)
0:     {
0:       listener = l;
1:       
0:       if (f != null) {
0:         try {
0:           filter = FrameworkUtil.createFilter(f);
0:         } catch (InvalidSyntaxException e) {
0:           AssertionFailedError err = new AssertionFailedError("The filter " + f + " is invalid");
0:           err.initCause(e);
1:           
0:           throw err;
1:         }
1:       }
1:     }
1: 
0:     public void serviceChanged(ServiceEvent arg0)
0:     {
0:       if (matches(arg0)) listener.serviceChanged(arg0);
1:     }
1: 
0:     private boolean matches(ServiceEvent arg0)
0:     {
0:       if (filter == null) return true;
1:       
0:       ServiceReference ref = arg0.getServiceReference();
1:       
0:       if (Skeleton.isSkeleton(ref)) {
0:         Object template = Skeleton.getSkeleton(ref).getTemplateObject();
1:         
0:         if (template instanceof ServiceData) {
0:           return filter.match(((ServiceData)template).getProperties());
1:         }
1:       }
1:       
0:       return filter.match(ref);
1:     }
1:     
0:     @Override
0:     public boolean equals(Object obj)
0:     {
0:       if (obj == null) return false;
0:       else if (obj instanceof FilteredServiceListener) {
0:         return listener.equals(((FilteredServiceListener)obj).listener);
1:       }
1:       
0:       return false;
1:     }
1:     
0:     @Override
0:     public int hashCode()
0:     {
0:       return listener.hashCode();
1:     }
1:   }
1:   
1:   /**
0:    * This class represents the information registered about a service. It also
0:    * implements part of the ServiceRegistration and ServiceReference interfaces.
1:    */
0:   private class ServiceData
0:   {
0:     /** The service that was registered */
0:     private ServiceFactory serviceImpl;
0:     /** the service properties */
0:     @SuppressWarnings("unused")
0:     private final Hashtable<String, Object> serviceProps = new Hashtable<String, Object>();
0:     /** The interfaces the service publishes with */
0:     private String[] interfaceNames;
1: 
1:     /**
0:      * This method unregisters the service from the registry.
1:      */
0:     public void unregister()
0:     {
0:       for (String interfaceName : interfaceNames) {
0:         List<ServiceData> list = registry.get(interfaceName);
0:         if (list != null) {
0:           list.remove(this);
0:           if (list.isEmpty()) {
0:             registry.remove(interfaceName);
1:           }
1:         }
1:       }
0:       notifyAllListeners(ServiceEvent.UNREGISTERING);
1:     }
1: 
1:     /**
0:      * This method is used to register the service data in the registry
1:      */
0:     public void register()
0:     {
0:       for (String interfaceName : interfaceNames) {
0:         List<ServiceData> list = registry.get(interfaceName);
0:         if (list == null) {
0:           list = new ArrayList<ServiceData>();
0:           registry.put(interfaceName, list);
1:         }
0:         list.add(this);
1:       }
0:       notifyAllListeners(ServiceEvent.REGISTERED);
1:     }
1:     
0:     private void notifyAllListeners(int eventType) {
0:       List<ServiceListener> copy = new ArrayList<ServiceListener>(listeners.size());
0:       copy.addAll(listeners);
0:       for(ServiceListener listener : copy) {
0:         listener.serviceChanged(new ServiceEvent(eventType, Skeleton.newMock(this, ServiceReference.class)));
1:       }
1:     }
1:     
1:     /**
0:      * Change the service properties
0:      * @param newProps
1:      */
0:     public void setProperties(Dictionary<String,Object> newProps)
0:     {
0:       // make sure we don't overwrite framework properties
0:       newProps.put(Constants.OBJECTCLASS, serviceProps.get(Constants.OBJECTCLASS));
0:       newProps.put(Constants.SERVICE_ID, serviceProps.get(Constants.SERVICE_ID));
1: 
0:       Enumeration<String> keys = newProps.keys();
1:       
0:       serviceProps.clear();
0:       while (keys.hasMoreElements()) {
0:         String key = keys.nextElement();
0:         serviceProps.put(key, newProps.get(key));
1:       }
1:       
0:       notifyAllListeners(ServiceEvent.MODIFIED);
1:     }
1:     
1:     /**
0:      * This implements the isAssignableTo method from ServiceReference.
0:      * 
0:      * @param b
0:      * @param className
0:      * @return true if the referenced service can be assigned to the requested
0:      *              class name.
1:      */
0:     public boolean isAssignableTo(Bundle b, String className)
0:     {
0:       boolean result = false;
1:       
0:       for (String iName : interfaceNames)
0:       {
0:         result = iName.equals(className);
1:         
0:         if (result) break;
1:       }
1:       
1:       return result;
1:     }
1:     
1:     /**
0:      * Returns the requested service property.
0:      * @param key the property to return.
0:      * @return the property value.
1:      */
0:     public Object getProperty(String key)
0:     {
0:       return serviceProps.get(key);
1:     }
1:     
0:     @Override
0:     public boolean equals(Object o) {
0:       if(o == null) return false;
1:       
0:       if(o == this) return true;
1:       
0:       if (o instanceof ServiceData) {
0:         ServiceData other = (ServiceData) o;
0:         return serviceImpl == other.serviceImpl;
1:       }
1:       
0:       return false;
1:     }
1:     
0:     @Override
0:     public int hashCode()
0:     {
0:       return serviceImpl.hashCode();
1:     }
1:     
1:     /**
0:      * @return the keys of all the service properties.
1:      */
0:     public String[] getPropertyKeys()
0:     {
0:       Enumeration<String> e = serviceProps.keys();
1:       
0:       String[] toReturn = new String[serviceProps.size()];
1:       
0:       for(int i = 0 ; i < serviceProps.size(); i++)
0:         toReturn[i] = e.nextElement();
1:       
0:       return toReturn;
1:     }
1:     
1:     /**
0:      * @return the bundle this service reference was registered against.
1:      */
0:     public Bundle getBundle()
0:     {
0:       return bundle;
1:     }
1:     
1:     /**
0:      * @return a service reference for this service registration.
1:      */
0:     public ServiceReference getReference()
0:     {
0:       return Skeleton.newMock(this, ServiceReference.class);
1:     }
1:     
0:     public Hashtable<String, Object> getProperties()
0:     {
0:       return new Hashtable<String, Object>(serviceProps);
1:     }
1:   }
1: 
0:   /** The bundle associated with this bundle context */
0:   private Bundle bundle;
1: 
1:   /**
0:    * Default constructor, widely used in the tests.
1:    */
0:   public BundleContextMock()
0:   {
1:     
1:   }
1:   
1:   /**
0:    * Constructor used by BundleMock, it ensures the bundle and its context are wired together correctly.
0:    * 
0:    * TODO We have to many Bundle mocks objects for a single OSGi bundle, we need to update this.
0:    * 
0:    * @param b
1:    */
0:   public BundleContextMock(Bundle b)
0:   {
0:     bundle = b;
1:   }
1:   
1:   /**
0:    * This checks that we have at least one service with this interface name.
0:    * 
0:    * @param interfaceName the name of the interface.
1:    */
0:   public static void assertServiceExists(String interfaceName)
0:   {
0:     assertTrue("No service registered with interface " + interfaceName + ". Services found: " + registry.keySet(), registry.containsKey(interfaceName));
1:   }
1:   
1:   /**
0:    * This checks that we have at no services with this interface name.
0:    * 
0:    * @param interfaceName the name of the interface.
1:    */
0:   public static void assertNoServiceExists(String interfaceName)
0:   {
0:     assertFalse("Services registered with interface " + interfaceName + ". Services found: " + registry.keySet(), registry.containsKey(interfaceName));
1:   }
1:   
1:   /**
0:    * This implements the registerService method from BundleContext.
0:    * 
0:    * @param interFace
0:    * @param service
0:    * @param properties
0:    * @return the ServiceRegistration object for this service.
1:    */
0:   public ServiceRegistration registerService(String interFace, final Object service, Dictionary<String, Object> properties)
0:   {
0:     // validate that the service implements interFace
0:     try {
0:       Class<?> clazz = Class.forName(interFace, false, service.getClass().getClassLoader());
1:       
0:       if (!!!clazz.isInstance(service) && !!!(service instanceof ServiceFactory)) {
0:         throw new AssertionFailedError("The service " + service + " does not implement " + interFace);
1:       }
0:     } catch (ClassNotFoundException e) {
0:       // TODO Auto-generated catch block
0:       e.printStackTrace();
1:     }
1: 
0:     ServiceFactory factory = new MockServiceFactory(service);
0:     return registerService(new String[] {interFace}, factory, properties);
1:   }
1:   
1:   /**
0:    * This implements the registerService method from BundleContext.
0:    * 
0:    * @param interfaces
0:    * @param service
0:    * @param properties
0:    * @return the ServiceRegistration object for this service.
1:    */
0:   public ServiceRegistration registerService(String[] interfaces, Object service, Dictionary<String, Object> properties)
0:   {
0:     if (properties == null) properties = new Hashtable<String, Object>();
1:     
0:     ServiceData data = new ServiceData();
0:     // cast the service to a service factory because in our framework we only ever register
0:     // a service factory. If we every put a non-service factory object in that is a failure.
0:     properties.put(Constants.OBJECTCLASS, interfaces);
0:     properties.put(Constants.SERVICE_ID, nextId++);
0:     if (service instanceof ServiceFactory) {
0:       data.serviceImpl = (ServiceFactory)service;
0:     } else {
0:       data.serviceImpl = new MockServiceFactory(service);
1:     }
0:     data.interfaceNames = interfaces;
1:     
0:     Enumeration<String> keys = properties.keys();
1:     
0:     while (keys.hasMoreElements()) {
0:       String key = keys.nextElement();
0:       data.serviceProps.put(key, properties.get(key));
1:     }
1:     
0:     data.register();
1:     
0:     return Skeleton.newMock(data, ServiceRegistration.class);
1:   }
1: 
1:   /**
0:    * This helper method is used to get the service from the registry with the
0:    * given interface name.
0:    * 
0:    * <p>This should really return multiple services.
0:    * </p>
0:    * 
0:    * @param interfaceName the interface name.
0:    * @param bundle        the bundle name.
0:    * @return the registered service.
1:    */
0:   public static Object getService(String interfaceName, Bundle bundle)
0:   {
0:     List<ServiceData> datum = registry.get(interfaceName);
1:     
0:     if (datum == null) return null;
0:     else if (datum.isEmpty()) return null;
0:     // this is safe for now, but may not be when we do other scoped components.
0:     else {
0:       ServiceRegistration reg = Skeleton.newMock(ServiceRegistration.class);
0:       return datum.iterator().next().serviceImpl.getService(bundle, reg);
1:     }
1:   }
1:   
1:   /**
0:    * A mock implementation of the getServiceReferences method. It does not currently
0:    * process the filter, this is probably a bit hard, so we might cheat when we do.
0:    * 
0:    * <p>Note this does not check that the service classes are visible to the
0:    *   caller as OSGi does. It is equivalent to getAllServiceReferences.
0:    * </p>
0:    * 
0:    * @param className the name of the class the lookup is for.
0:    * @param filter
0:    * @return an array of matching service references.
0:    * @throws InvalidSyntaxException
1:    */
0:   public ServiceReference[] getServiceReferences(String className, String filter) throws InvalidSyntaxException
0:   {
0:     List<ServiceData> data = new ArrayList<ServiceData>();
1:     
0:     if (className != null) {
0:       List<ServiceData> tmpData = registry.get(className);
0:       if (tmpData != null) data.addAll(tmpData);
0:     } else {
0:       data = new ArrayList<ServiceData>();
0:       for (List<ServiceData> value : registry.values())
0:       data.addAll(value);
1:     }
1:     
0:     ServiceReference[] refs;
1: 
0:     if (data == null) {
0:       refs = null;
0:     } else {
1:       
0:       if (filter != null) {
0:         Filter f = FrameworkUtil.createFilter(filter);
1:         
0:         Iterator<ServiceData> it = data.iterator();
1:         
0:         while (it.hasNext()) {
0:           ServiceData sd = it.next();
1:           
0:           if (!!!f.match(sd.getProperties())) it.remove();
1:         }
1:       }
1:       
0:       if (data.isEmpty()) return null;
1:       
0:       refs = new ServiceReference[data.size()];
0:       for (int i = 0; i < refs.length; i++) {
0:         refs[i] = Skeleton.newMock(data.get(i), ServiceReference.class);
1:       }
1:     }
1:     
0:     return refs;
1:   }
1:   
1:   /**
0:    * Gets the first matching service reference.
0:    * 
0:    * @param className the class name wanted.
0:    * @return the matchine service, or null if one cannot be found.
1:    */
0:   public ServiceReference getServiceReference(String className)
0:   {
0:     ServiceReference[] refs;
0:     try {
0:       refs = getServiceReferences(className, null);
0:       if (refs != null) return refs[0];
1:       
0:       return null;
0:     } catch (InvalidSyntaxException e) {
0:       // should never happen.
0:       e.printStackTrace();
1:     }
0:     return null;
1:   }
1:   
1:   /**
0:    * This method finds all the service references in the registry with the
0:    * matching class name and filter.
0:    * 
0:    * @param className
0:    * @param filter
0:    * @return the matching service references.
0:    * @throws InvalidSyntaxException
1:    */
0:   public ServiceReference[] getAllServiceReferences(String className, String filter) throws InvalidSyntaxException
0:   {
0:     return getServiceReferences(className, filter);
1:   }
1:   
1:   /**
0:    * Retrieve a service from the registry.
0:    * @param ref the service reference.
0:    * @return    the returned service.
1:    */
0:   public Object getService(ServiceReference ref)
0:   {
0:     ServiceData data = (ServiceData)Skeleton.getSkeleton(ref).getTemplateObject();
1:     
0:     return data.serviceImpl.getService(getBundle(), Skeleton.newMock(data, ServiceRegistration.class));
1:   }
1:   
1:   /**
0:    * This method implements the installBundle method from BundleContext. It
0:    * makes use of the java.util.jar package to parse the manifest from the input
0:    * stream.
0:    * 
0:    * @param location the location of the bundle.
0:    * @param is       the input stream to read from.
0:    * @return         the created bundle.
0:    * @throws BundleException
1:    */
0:   public Bundle installBundle(String location, InputStream is) throws BundleException
0:   {
0:     Bundle b;
0:     JarInputStream jis;
0:     try {
0:       jis = new JarInputStream(is);
1: 
0:       Manifest man = jis.getManifest();
1:       
0:       b = createBundle(man, null);
1:       
0:     } catch (IOException e) {
0:       throw new BundleException(e.getMessage(), e);
1:     }
1:     
0:     return b;
1:   }
1: 
1:   /**
0:    * Create a mock bundle correctly configured using the supplied manifest and
0:    * location.
0:    * 
0:    * @param man      the manifest to load.
0:    * @param location the location on disk.
0:    * @return the created bundle
0:    * @throws MalformedURLException
1:    */
0:   private Bundle createBundle(Manifest man, String location) throws MalformedURLException
0:   {
0:     Attributes attribs = man.getMainAttributes();
0:     String symbolicName = attribs.getValue(Constants.BUNDLE_SYMBOLICNAME);
1:     
0:     Hashtable<Object, Object> attribMap = new Hashtable<Object, Object>();
1:     
0:     for (Map.Entry<Object, Object> entry : attribs.entrySet()) {
0:       Attributes.Name name = (Attributes.Name)entry.getKey();
0:       attribMap.put(name.toString(), entry.getValue());
1:     }
1:     
0:     BundleMock mock = new BundleMock(symbolicName, attribMap, location);
1: 
0:     mock.addToClassPath(new File("build/unittest/classes").toURL());
1: 
0:     Bundle b = Skeleton.newMock(mock, Bundle.class);
1:     
0:     bundles.add(b);
1: 
0:     return b;
1:   }
1:   
1:   /**
0:    * Asks to install an OSGi bundle from the given location.
0:    * 
0:    * @param location the location of the bundle on the file system.
0:    * @return the installed bundle.
0:    * @throws BundleException
1:    */
0:   public Bundle installBundle(String location) throws BundleException
0:   {
0:     try {
0:       URI uri = new URI(location.replaceAll(" ", "%20"));
1: 
0:       File baseDir = new File(uri);
0:       Manifest man = null;
0:       //check if it is a directory
0:       if (baseDir.isDirectory()){
0:       man = new Manifest(new FileInputStream(new File(baseDir, "META-INF/MANIFEST.MF")));
1:       }
0:       //if it isn't assume it is a jar file
0:       else{
0:         InputStream is = new FileInputStream(baseDir);
0:         JarInputStream jis = new JarInputStream(is);
0:         man = jis.getManifest();
0:         jis.close();
0:         if (man == null){
0:           throw new BundleException("Null manifest");
1:         }
1:       }
1:       
0:       return createBundle(man, location);
0:     } catch (IOException e) {
0:       throw new BundleException(e.getMessage(), e);
0:     } catch (URISyntaxException e) {
0:       // TODO Auto-generated catch block
0:       throw new BundleException(e.getMessage(), e);
1:     }
1:   }
1:   
1:   /**
0:    * @return all the bundles in the system
1:    */
0:     public Bundle[] getBundles()
0:   {
0:     return bundles.toArray(new Bundle[bundles.size()]);
1:   }
1:   
1:   /**
0:    * Add a service listener.
0:    * 
0:    * @param listener
0:    * @param filter
1:    */
0:   public void addServiceListener(ServiceListener listener, String filter)
0:   {
0:     listeners.add(new FilteredServiceListener(filter, listener));
1:   }
1: 
1:   /**
0:    * Add a service listener.
0:    * 
0:    * @param listener
1:    */
0:   public void addServiceListener(ServiceListener listener) 
0:   {
0:     listeners.add(listener);
1:   }
1:   
1:   /**
0:    * Remove a service listener
0:    * @param listener
1:    */
0:   public void removeServiceListener(ServiceListener listener)
0:   {
0:     listeners.remove(new FilteredServiceListener(null, listener));
1:   }
1:   
0:   public String getProperty(String name)
0:   {
0:     if (Constants.FRAMEWORK_VERSION.equals(name)) {
0:       return "4.1";
1:     }
0:     /*added System.getProperty so that tests can set a system property
0:      * but it is retrieved via the BundleContext.
0:      * This allows tests to emulate different properties being set on the
0:      * context, helpful for the feature pack launcher/kernel relationship
1:      */
0:     else if (System.getProperty(name) != null){
0:       return System.getProperty(name);
1:     }
1:     
0:     return "";
1:   }
1:   
1:   /**
0:    * @return the bundle associated with this bundle context (if we created one).
1:    */
0:   public Bundle getBundle()
0:   {
0:     return bundle;
1:   }
1:   
1:   /**
0:    * This method clears the service registry.
1:    */
0:   public static void clear()
0:   {
0:     registry.clear();
0:     bundles.clear();
0:     listeners.clear();
0:     nextId = 0;
1:   }
1:   
0:   public static List<ServiceListener> getServiceListeners()
0:   {
0:     return listeners;
1:   }
1: 
0:   public void addBundle(Bundle b)
0:   {
0:     bundles.add(b);
1:   }
1: }
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:0d84fd2
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
1:     /** The bundle that defines this service */
1:     private Bundle registeringBundle;
/////////////////////////////////////////////////////////////////////////
1:       registeringBundle = null;
/////////////////////////////////////////////////////////////////////////
1:       return registeringBundle;
/////////////////////////////////////////////////////////////////////////
1:     bundle = Skeleton.newMock(new BundleMock("test." + new Random(System.currentTimeMillis()).nextInt(),
1:                               new Hashtable<Object, Object>()), Bundle.class);
/////////////////////////////////////////////////////////////////////////
1:     data.registeringBundle = bundle;
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:a5a6778
/////////////////////////////////////////////////////////////////////////
1:   private class ServiceData implements Comparable<ServiceReference>
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Implement the standard behaviour of the registry
0:      */
1:     public int compareTo(ServiceReference o) {
1:       Integer rank = (Integer) serviceProps.get(Constants.SERVICE_RANKING);
1:       if(rank == null)
1:         rank = 0;
0:       
1:       Integer otherRank = (Integer) o.getProperty(Constants.SERVICE_RANKING);
1:       if(otherRank == null)
1:         otherRank = 0;
1:       //Higher rank = higher order
1:       int result = rank.compareTo(otherRank);
0:       
1:       if(result == 0) {
1:         Long id = (Long) serviceProps.get(Constants.SERVICE_ID);
1:         Long otherId = (Long) o.getProperty(Constants.SERVICE_ID);
1:         //higher id = lower order
1:         return otherId.compareTo(id);
0:       }
0:       return result;
0:     }
============================================================================