1:9ca95bd: /*
1:9ca95bd:  * Licensed to the Apache Software Foundation (ASF) under one
1:9ca95bd:  * or more contributor license agreements.  See the NOTICE file
1:9ca95bd:  * distributed with this work for additional information
1:9ca95bd:  * regarding copyright ownership.  The ASF licenses this file
1:9ca95bd:  * to you under the Apache License, Version 2.0 (the
1:9ca95bd:  * "License"); you may not use this file except in compliance
1:9ca95bd:  * with the License.  You may obtain a copy of the License at
1:9ca95bd:  *
1:9ca95bd:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9ca95bd:  *
1:9ca95bd:  * Unless required by applicable law or agreed to in writing,
1:9ca95bd:  * software distributed under the License is distributed on an
1:9ca95bd:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:9ca95bd:  * KIND, either express or implied.  See the License for the
1:9ca95bd:  * specific language governing permissions and limitations
1:9ca95bd:  * under the License.
3:9ca95bd:  */
37:9ca95bd: 
1:9ca95bd: package org.apache.aries.application.runtime.isolated.impl;
1:354c219: 
1:92a0da5: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1:92a0da5: import static org.apache.aries.application.utils.AppConstants.LOG_EXCEPTION;
1:92a0da5: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1:92a0da5: 
1:ccca21b: import java.io.File;
1:ccca21b: import java.io.FileNotFoundException;
1:ccca21b: import java.io.IOException;
1:ccca21b: import java.io.OutputStream;
1:9ca95bd: import java.util.ArrayList;
1:8151f8c: import java.util.Collection;
1:9ca95bd: import java.util.Iterator;
1:a07c6cd: import java.util.LinkedHashSet;
1:9ca95bd: import java.util.List;
1:9ca95bd: import java.util.Map;
1:9ca95bd: import java.util.Set;
1:9ca95bd: 
1:ccca21b: import org.apache.aries.application.ApplicationMetadata;
1:9ca95bd: import org.apache.aries.application.DeploymentContent;
1:9ca95bd: import org.apache.aries.application.DeploymentMetadata;
1:9ca95bd: import org.apache.aries.application.management.AriesApplication;
1:9ca95bd: import org.apache.aries.application.management.AriesApplicationContext;
1:ccca21b: import org.apache.aries.application.management.BundleInfo;
1:8151f8c: import org.apache.aries.application.management.UpdateException;
1:89f804e: import org.apache.aries.application.management.spi.framework.BundleFrameworkManager;
1:cdbec1e: import org.apache.aries.application.management.spi.repository.BundleRepository.BundleSuggestion;
1:89f804e: import org.apache.aries.application.management.spi.repository.BundleRepositoryManager;
1:89f804e: import org.apache.aries.application.management.spi.repository.ContextException;
1:9ca95bd: import org.osgi.framework.Bundle;
1:9ca95bd: import org.osgi.framework.BundleException;
1:9ca95bd: import org.slf4j.Logger;
1:9ca95bd: import org.slf4j.LoggerFactory;
1:9ca95bd: 
1:9ca95bd: public class ApplicationContextImpl implements AriesApplicationContext
2:9ca95bd: {
1:9ca95bd:   private static final Logger LOGGER = LoggerFactory.getLogger(ApplicationContextImpl.class);
1:9ca95bd: 
1:ccca21b:   private final AriesApplication _application;
1:ccca21b:   private final Set<Bundle> _bundles;
1:9ca95bd:   private ApplicationState _state = ApplicationState.UNINSTALLED;
1:cdbec1e:   private boolean _closed;
1:ccca21b:   private final BundleRepositoryManager _bundleRepositoryManager;
1:ccca21b:   private final BundleFrameworkManager _bundleFrameworkManager;
1:9ca95bd: 
1:9ca95bd:   /** deployment metadata associated with aries application */
1:8151f8c:   private DeploymentMetadata _deploymentMF;
1:9ca95bd: 
1:9ca95bd:   public ApplicationContextImpl(AriesApplication app, ApplicationContextManagerImpl acm)
1:9db128e:       throws BundleException
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "ApplicationContextImpl", new Object[] { app, acm });
1:9ca95bd: 
1:9ca95bd:     _bundleFrameworkManager = acm.getBundleFrameworkManager();
1:9ca95bd:     _bundleRepositoryManager = acm.getBundleRepositoryManager();
1:a07c6cd:     _bundles = new LinkedHashSet<Bundle>();
1:9ca95bd: 
1:9ca95bd:     _application = app;
1:9ca95bd:     _deploymentMF = _application.getDeploymentMetadata();
1:9ca95bd: 
1:9ca95bd:     if (_deploymentMF.getApplicationDeploymentContents() != null
1:e22d71c:         && !_deploymentMF.getApplicationDeploymentContents().isEmpty()) {
1:9db128e:       install();
1:e22d71c:     }
1:cdbec1e:     
1:9ca95bd:     LOGGER.debug(LOG_EXIT, "ApplicationContextImpl", this);
1:8151f8c:   }
1:e22d71c: 
3:9ca95bd:   /**
1:06621c5:    * Called to install the application.
1:9ca95bd:    * @return whether the installation is successful
1:9ca95bd:    * 
1:9ca95bd:    */
1:9db128e:   private void install() throws BundleException
1:8151f8c:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "install");
1:8151f8c: 
1:9ca95bd:     List<DeploymentContent> bundlesToFind = new ArrayList<DeploymentContent>(_deploymentMF
1:9ca95bd:         .getApplicationDeploymentContents());
1:9ca95bd:     List<DeploymentContent> useBundlesToFind = new ArrayList<DeploymentContent>(_deploymentMF
1:9ca95bd:         .getDeployedUseBundle());
1:9ca95bd:     List<DeploymentContent> provisionBundlesToFind = new ArrayList<DeploymentContent>(_deploymentMF
1:9ca95bd:         .getApplicationProvisionBundles());
1:8151f8c: 
1:f805d6b:     try {
1:8151f8c:     	
1:9db128e:       installBundles(provisionBundlesToFind, true);
1:9db128e:       installBundles(useBundlesToFind, true);
1:9db128e:       installBundles(bundlesToFind, false);
1:8151f8c:       
1:354c219:       _state = ApplicationState.INSTALLED;
1:354c219:       
1:9ca95bd:       LOGGER.debug("Successfully installed application "
1:9ca95bd:           + _application.getApplicationMetadata().getApplicationSymbolicName());
1:9db128e:     } catch (BundleException e) {
1:9ca95bd:       LOGGER.debug(LOG_EXCEPTION, "Failed to install application "
1:9ca95bd:           + _application.getApplicationMetadata().getApplicationSymbolicName());
1:354c219:       
1:9ca95bd:       uninstall();
1:354c219:       
1:9db128e:       throw e;
10:9ca95bd:     }
1:354c219: 
1:9db128e:     LOGGER.debug(LOG_EXIT, "install");
1:ccca21b: 
1:ccca21b:   }
1:9db128e: 
1:ccca21b:   /**
1:9ca95bd:    * Called to remove the application, if called multiple times the subsequent
2:9ca95bd:    * calls will be ignored.
1:9ca95bd:    * @return whether the uninstallation is successful
1:9ca95bd:    */
1:354c219:   protected synchronized void uninstall() throws BundleException
1:8151f8c:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "uninstall");
1:9db128e:     
1:f805d6b:     if (_state != ApplicationState.UNINSTALLED) {
1:f805d6b:       // Iterate through all of the bundles that were started when this application was started, 
1:f805d6b:       // and attempt to stop and uninstall each of them. 
1:f805d6b:       for (Iterator<Bundle> bundleIter = _bundles.iterator(); bundleIter.hasNext();) {
1:f805d6b:         Bundle bundleToRemove = bundleIter.next();
1:f805d6b:   
1:8c79b02:         if (bundleToRemove.getState() != Bundle.UNINSTALLED) {
1:8c79b02:           try {
1:8c79b02:             // If Bundle is active, stop it first.
1:8c79b02:             if (bundleToRemove.getState() == Bundle.ACTIVE) {
1:8c79b02:               _bundleFrameworkManager.stopBundle(bundleToRemove);
1:8c79b02:             }
1:8c79b02:           } catch (BundleException be) {
1:8c79b02:             LOGGER.debug(LOG_EXCEPTION, be);
1:f805d6b:           }
1:f805d6b:   
1:8c79b02:           try {
1:8c79b02:             // Delegate the uninstall to the bundleFrameworkManager
1:8c79b02:             _bundleFrameworkManager.uninstallBundle(bundleToRemove);
1:8c79b02:     
1:8c79b02:           } catch (BundleException be) {
1:8c79b02:             LOGGER.debug(LOG_EXCEPTION, be);
1:8c79b02:           }
1:9ca95bd:         }
1:8c79b02:         bundleIter.remove();
1:9ca95bd:       }
1:f805d6b:       
1:f805d6b:       _state = ApplicationState.UNINSTALLED;
1:9ca95bd:     }
1:f805d6b:     
1:9db128e:     LOGGER.debug(LOG_EXIT, "uninstall");
1:9ca95bd: 
1:9ca95bd:   }
1:9ca95bd: 
1:8151f8c:   /**
1:9ca95bd:    * This method finds bundles matching the list of content passed in
1:9ca95bd:    * @param bundlesToFind       bundles to find and start if the bundle is shared.  If isolated, install it.
1:9ca95bd:    * @param shared                      whether the bundles will be shared or isolated
1:9ca95bd:    * @return the result of execution
1:9ca95bd:    */
1:9db128e:   private void installBundles(List<DeploymentContent> bundlesToFind, boolean shared)
1:9db128e:       throws BundleException
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "install", new Object[] { bundlesToFind, Boolean.valueOf(shared) });
1:9ca95bd: 
1:9ca95bd:     if (!bundlesToFind.isEmpty() || !shared) {
1:9ca95bd: 
1:9ca95bd:       Iterator<DeploymentContent> it = bundlesToFind.iterator();
1:9ca95bd: 
1:9ca95bd:       /**
1:9db128e:        * Dont install any bundles from the list which are already
1:9db128e:        * installed
1:9ca95bd:        */
1:9db128e:       Bundle[] sharedBundles = _bundleFrameworkManager.getSharedBundleFramework()
1:9db128e:           .getIsolatedBundleContext().getBundles();
1:9ca95bd:       if (shared) {
1:9ca95bd:         if (sharedBundles.length > 0) {
1:9ca95bd:           while (it.hasNext()) {
1:9ca95bd:             DeploymentContent bundleToFind = it.next();
1:9ca95bd: 
1:9ca95bd:             for (Bundle b : sharedBundles) {
1:9ca95bd:               if (bundleToFind.getContentName().equals(b.getSymbolicName())
1:9ca95bd:                   && bundleToFind.getExactVersion().equals(b.getVersion())) {
1:9ca95bd:                 it.remove();
1:9ca95bd:                 _bundles.add(b);
1:9ca95bd:                 break;
1:9ca95bd:               }
1:9ca95bd:             }
1:9ca95bd:           }
1:9ca95bd:         }
1:9ca95bd:       }
1:9ca95bd: 
1:9ca95bd:       /**
1:9db128e:        * Ask the repository manager to find us a list of suggested bundles
1:9db128e:        * to install based on our content list
1:9db128e:        */
1:9db128e:       Map<DeploymentContent, BundleSuggestion> bundlesToBeInstalled = 
1:9db128e:         findBundleSuggestions(bundlesToFind);
1:9db128e: 
1:9db128e:       /**
1:8151f8c:        * Perform the install of the bundles
1:8151f8c:        */
1:8151f8c:       try {
1:9db128e:         if (shared) _bundles.addAll(_bundleFrameworkManager.installSharedBundles(
1:ccca21b:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), makeAppProxy()));
1:9db128e:         else _bundles.add(_bundleFrameworkManager.installIsolatedBundles(
1:ccca21b:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), makeAppProxy()));
1:8151f8c: 
1:8151f8c:       } catch (BundleException e) {
2:9db128e:         LOGGER.debug(LOG_EXCEPTION, e);
1:9db128e:         throw e;
1:9ca95bd:       }
1:9ca95bd:     }
1:9db128e:     LOGGER.debug(LOG_EXIT, "install");
1:9ca95bd:   }
1:9db128e:   
1:9ca95bd:   /**
1:ccca21b:    * Create a proxy for the AriesApplication we pass on so as to respect the correct current deployment metadata.
1:ccca21b:    */
1:ccca21b:   private AriesApplication makeAppProxy() {
1:ccca21b:     return new AriesApplication() {
1:ccca21b:       
1:ccca21b:       public void store(OutputStream out) throws FileNotFoundException, IOException {
1:ccca21b:         throw new UnsupportedOperationException();
1:ccca21b:       }
1:ccca21b:       
1:ccca21b:       public void store(File f) throws FileNotFoundException, IOException {
1:ccca21b:         throw new UnsupportedOperationException();
1:ccca21b:       }
1:ccca21b:       
1:ccca21b:       public boolean isResolved() {
1:ccca21b:         return true;
1:ccca21b:       }
1:ccca21b:       
1:ccca21b:       public DeploymentMetadata getDeploymentMetadata() {
1:ccca21b:         return _deploymentMF;
1:ccca21b:       }
1:ccca21b:       
1:ccca21b:       public Set<BundleInfo> getBundleInfo() {
1:ccca21b:         return _application.getBundleInfo();
1:ccca21b:       }
1:ccca21b:       
1:ccca21b:       public ApplicationMetadata getApplicationMetadata() {
1:ccca21b:         return _application.getApplicationMetadata();
1:ccca21b:       }
1:ccca21b:     };
1:9ca95bd:   }
1:9ca95bd: 
1:9db128e:   private Map<DeploymentContent, BundleSuggestion> findBundleSuggestions(
1:9db128e:       Collection<DeploymentContent> bundlesToFind) throws BundleException
1:9ca95bd:   {
1:9db128e:     Map<DeploymentContent, BundleSuggestion> suggestions = null;
1:9db128e:     try {
1:9db128e:       suggestions = _bundleRepositoryManager.getBundleSuggestions(_application
1:8151f8c:           .getApplicationMetadata().getApplicationSymbolicName(), _application
1:8151f8c:           .getApplicationMetadata().getApplicationVersion().toString(), bundlesToFind);
1:9db128e:     } catch (ContextException e) {
1:8151f8c:       LOGGER.debug(LOG_EXCEPTION, e);
1:9db128e:       throw new BundleException("Failed to locate bundle suggestions", e);
1:8151f8c:     }
1:9db128e: 
1:9db128e:     return suggestions;
1:9db128e: 
1:8151f8c:   }
1:9ca95bd: 
1:9ca95bd:   public AriesApplication getApplication()
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "getApplication");
1:9ca95bd:     LOGGER.debug(LOG_EXIT, "getApplication", new Object[] { _application });
1:9ca95bd: 
1:9ca95bd:     return _application;
1:9db128e:   }
1:9ca95bd: 
1:9db128e:   public synchronized Set<Bundle> getApplicationContent()
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "getApplicationContent");
1:9ca95bd:     LOGGER.debug(LOG_EXIT, "getApplicationContent", new Object[] { _bundles });
1:9ca95bd: 
1:9ca95bd:     return _bundles;
1:9ca95bd:   }
1:9ca95bd: 
1:9db128e:   public synchronized ApplicationState getApplicationState()
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "getApplicationState");
1:9ca95bd:     LOGGER.debug(LOG_EXIT, "getApplicationState", new Object[] { _state });
1:9ca95bd: 
1:9ca95bd:     return _state;
1:9ca95bd:   }
1:9ca95bd: 
1:9db128e:   public synchronized void start() throws BundleException, IllegalStateException
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "start");
1:9ca95bd: 
1:9db128e:     if (!(_state == ApplicationState.INSTALLED || 
1:9db128e:         _state == ApplicationState.RESOLVED))
1:9db128e:       throw new IllegalStateException("Appication is in incorrect state " + _state + " expected " + ApplicationState.INSTALLED + " or " + ApplicationState.RESOLVED);
1:9db128e:     
1:9ca95bd:     List<Bundle> bundlesWeStarted = new ArrayList<Bundle>();
1:9db128e:     try {
1:9ca95bd:       for (Bundle b : _bundles) {
1:9ca95bd:         _bundleFrameworkManager.startBundle(b);
1:9ca95bd:         bundlesWeStarted.add(b);
1:9ca95bd:       }
1:f805d6b:     } catch (BundleException be) {
1:9ca95bd: 
1:9ca95bd:       for (Bundle b : bundlesWeStarted) {
1:9db128e:         try {
1:9ca95bd:           _bundleFrameworkManager.stopBundle(b);
1:9ca95bd:         } catch (BundleException be2) {
1:9ca95bd:           // we are doing tidyup here, so we don't want to replace the bundle exception
1:9ca95bd:           // that occurred during start with one from stop. We also want to try to stop
1:9ca95bd:           // all the bundles we started even if some bundles wouldn't stop.
1:9ca95bd:           LOGGER.debug(LOG_EXCEPTION, be2);
1:9ca95bd:         }
1:9ca95bd:       }
1:9db128e: 
1:f805d6b:       LOGGER.debug(LOG_EXCEPTION, be);
1:9ca95bd:       LOGGER.debug(LOG_EXIT, "start", new Object[] { be });
1:f805d6b:       throw be;
1:9ca95bd:     }
1:9db128e:     
1:9ca95bd:     _state = ApplicationState.ACTIVE;
1:9db128e: 
1:9ca95bd:     LOGGER.debug(LOG_EXIT, "start");
1:9db128e:   }
1:9db128e: 
1:9db128e:   public synchronized void stop() throws BundleException, IllegalStateException
1:9ca95bd:   {
1:9ca95bd:     LOGGER.debug(LOG_ENTRY, "stop");
1:9db128e:     
1:9db128e:     if (_state != ApplicationState.ACTIVE)
1:9db128e:       throw new IllegalStateException("Appication is in incorrect state " + _state + " expected " + ApplicationState.ACTIVE);
1:9db128e:         
1:9ca95bd:     for (Bundle entry : _bundles) {
1:9ca95bd:       Bundle b = entry;
1:9ca95bd:       _bundleFrameworkManager.stopBundle(b);
1:9db128e:     }
1:9db128e:     
1:9ca95bd:     _state = ApplicationState.RESOLVED;
1:9db128e: 
1:9ca95bd:     LOGGER.debug(LOG_EXIT, "stop");
1:9db128e:   }
1:9db128e: 
1:9db128e:   public synchronized void update(final DeploymentMetadata newMetadata, final DeploymentMetadata oldMetadata)
1:8151f8c:       throws UpdateException
1:9ca95bd:   {
1:8151f8c:     final boolean toStart = getApplicationState() == ApplicationState.ACTIVE;
1:9db128e: 
1:8151f8c:     if (_bundleFrameworkManager.allowsUpdate(newMetadata, oldMetadata)) {
1:9db128e:       _bundleFrameworkManager.updateBundles(newMetadata, oldMetadata, _application,
1:8151f8c:           new BundleFrameworkManager.BundleLocator() {
1:8151f8c:             public Map<DeploymentContent, BundleSuggestion> suggestBundle(
1:9db128e:                 Collection<DeploymentContent> bundles) throws BundleException
1:9db128e:             {
1:8151f8c:               return findBundleSuggestions(bundles);
1:8151f8c:             }
1:9db128e:           }, _bundles, toStart);
1:8151f8c: 
2:8151f8c:     } else {
1:8151f8c:       // fallback do a uninstall, followed by a reinstall
3:9db128e:       try {        
1:9db128e:         uninstall();
1:8151f8c:         _deploymentMF = newMetadata;        
1:8151f8c:         try {
1:9db128e:           install();
1:8151f8c:           
1:9db128e:           if (toStart)
1:8151f8c:             start();
1:8151f8c:         }
1:9db128e:         catch (BundleException e)
1:9db128e:         {
1:9db128e:           try {
1:9db128e:             uninstall();
1:8151f8c:             
1:8151f8c:             _deploymentMF = oldMetadata;
1:9db128e:             install();
1:8151f8c: 
1:9db128e:             if (toStart)
1:8151f8c:               start();
1:8151f8c:            
1:9db128e:             throw new UpdateException("Could not install updated application", e,
1:9db128e:                 true, null);
1:8151f8c:           }
1:9db128e:           catch (BundleException e2)
1:9db128e:           {
1:9db128e:             throw new UpdateException("Could not install updated application", e,
1:9db128e:                 false, e2);
1:8151f8c:           }          
1:8151f8c:         }       
1:8151f8c:       }
1:9db128e:       catch (BundleException e)
1:9db128e:       {
1:8151f8c:         try {          
2:9db128e:           _deploymentMF = oldMetadata;
1:9db128e:           install();
1:8151f8c: 
1:9db128e:           if (toStart)
3:9db128e:             start();
1:8151f8c:           
1:9db128e:           throw new UpdateException("Could not install updated application", e,
1:9db128e:               true, null);
1:8151f8c:         }
1:9db128e:         catch (BundleException e2)
1:9db128e:         {
1:9db128e:           throw new UpdateException("Could not install updated application", e,
1:9db128e:               false, e2);
1:8151f8c:         } 
1:8151f8c:       }
1:8151f8c:     }
1:9db128e:   }
1:9db128e: 
1:cdbec1e:   public synchronized void close() throws BundleException
1:cdbec1e:   {
1:cdbec1e:     uninstall();
1:cdbec1e:     _closed = true;
1:cdbec1e:   }
1:cdbec1e:   
1:cdbec1e:   public synchronized void open() throws BundleException
1:cdbec1e:   {
1:cdbec1e:     if (_closed) {
1:cdbec1e:       install();
1:cdbec1e:       _closed = false;
1:cdbec1e:     }
1:cdbec1e:   }
1:9db128e: }
============================================================================
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:8c79b02
/////////////////////////////////////////////////////////////////////////
1:         if (bundleToRemove.getState() != Bundle.UNINSTALLED) {
1:           try {
1:             // If Bundle is active, stop it first.
1:             if (bundleToRemove.getState() == Bundle.ACTIVE) {
1:               _bundleFrameworkManager.stopBundle(bundleToRemove);
1:             }
1:           } catch (BundleException be) {
1:             LOGGER.debug(LOG_EXCEPTION, be);
1:           try {
1:             // Delegate the uninstall to the bundleFrameworkManager
1:             _bundleFrameworkManager.uninstallBundle(bundleToRemove);
1:     
1:           } catch (BundleException be) {
1:             LOGGER.debug(LOG_EXCEPTION, be);
1:           }
1:         bundleIter.remove();
commit:f805d6b
/////////////////////////////////////////////////////////////////////////
1:     if (_state != ApplicationState.UNINSTALLED) {
1:       // Iterate through all of the bundles that were started when this application was started, 
1:       // and attempt to stop and uninstall each of them. 
1:       for (Iterator<Bundle> bundleIter = _bundles.iterator(); bundleIter.hasNext();) {
1:         Bundle bundleToRemove = bundleIter.next();
1:   
1:         try {
0:           // If Bundle is active, stop it first.
0:           if (bundleToRemove.getState() == Bundle.ACTIVE) {
0:             _bundleFrameworkManager.stopBundle(bundleToRemove);
1:           }
1:   
0:           // Delegate the uninstall to the bundleFrameworkManager
0:           _bundleFrameworkManager.uninstallBundle(bundleToRemove);
1:   
1:         } catch (BundleException be) {
1:           LOGGER.debug(LOG_EXCEPTION, be);
1:           throw be;
0:       _bundles.clear();
1:       
1:       _state = ApplicationState.UNINSTALLED;
commit:cdbec1e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.management.spi.repository.BundleRepository.BundleSuggestion;
/////////////////////////////////////////////////////////////////////////
1:   private boolean _closed;
/////////////////////////////////////////////////////////////////////////
1: 
1:   public synchronized void close() throws BundleException
1:   {
1:     uninstall();
1:     _closed = true;
1:   }
1:   
1:   public synchronized void open() throws BundleException
1:   {
1:     if (_closed) {
1:       install();
1:       _closed = false;
1:     }
1:   }
commit:e22d71c
/////////////////////////////////////////////////////////////////////////
1:         && !_deploymentMF.getApplicationDeploymentContents().isEmpty()) {
1:     }
1:     
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:ccca21b
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.FileNotFoundException;
1: import java.io.IOException;
1: import java.io.OutputStream;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.ApplicationMetadata;
1: import org.apache.aries.application.management.BundleInfo;
/////////////////////////////////////////////////////////////////////////
1:   private final AriesApplication _application;
1:   private final Set<Bundle> _bundles;
1:   private final BundleRepositoryManager _bundleRepositoryManager;
1:   private final BundleFrameworkManager _bundleFrameworkManager;
/////////////////////////////////////////////////////////////////////////
1:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), makeAppProxy()));
1:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), makeAppProxy()));
/////////////////////////////////////////////////////////////////////////
1:   }
1:   
1:   /**
1:    * Create a proxy for the AriesApplication we pass on so as to respect the correct current deployment metadata.
1:    */
1:   private AriesApplication makeAppProxy() {
1:     return new AriesApplication() {
1:       
1:       public void store(OutputStream out) throws FileNotFoundException, IOException {
1:         throw new UnsupportedOperationException();
1:       }
1:       
1:       public void store(File f) throws FileNotFoundException, IOException {
1:         throw new UnsupportedOperationException();
1:       }
1:       
1:       public boolean isResolved() {
1:         return true;
1:       }
1:       
1:       public DeploymentMetadata getDeploymentMetadata() {
1:         return _deploymentMF;
1:       }
1:       
1:       public Set<BundleInfo> getBundleInfo() {
1:         return _application.getBundleInfo();
1:       }
1:       
1:       public ApplicationMetadata getApplicationMetadata() {
1:         return _application.getApplicationMetadata();
1:       }
1:     };
commit:89f804e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.management.spi.framework.BundleFrameworkManager;
1: import org.apache.aries.application.management.spi.repository.BundleRepositoryManager;
1: import org.apache.aries.application.management.spi.repository.ContextException;
0: import org.apache.aries.application.management.spi.repository.BundleRepository.BundleSuggestion;
commit:8151f8c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.application.management.UpdateException;
/////////////////////////////////////////////////////////////////////////
1:   private DeploymentMetadata _deploymentMF;
/////////////////////////////////////////////////////////////////////////
0:         bundlesToBeInstalled = findBundleSuggestions(bundlesToFind);
0:       if (numException == 0) {
1:         /**
1:          * Perform the install of the bundles
1:          */
1:         try {
0:           if (shared) 
0:             _bundles.addAll(_bundleFrameworkManager.installSharedBundles(
0:               new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), _application));
0:           else 
0:             _bundles.add(_bundleFrameworkManager.installIsolatedBundles(
0:               new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), _application));
1:   
1:         } catch (BundleException e) {
0:           numException++;
1:           LOGGER.debug(LOG_EXCEPTION, e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:   
0:   private Map<DeploymentContent, BundleSuggestion> findBundleSuggestions(Collection<DeploymentContent> bundlesToFind)
0:     throws ContextException
1:   {
0:     return _bundleRepositoryManager.getBundleSuggestions(_application
1:         .getApplicationMetadata().getApplicationSymbolicName(), _application
1:         .getApplicationMetadata().getApplicationVersion().toString(), bundlesToFind);
1:   }
/////////////////////////////////////////////////////////////////////////
1:   
0:   public void update(final DeploymentMetadata newMetadata, final DeploymentMetadata oldMetadata) 
1:     throws UpdateException
1:   {
1:     final boolean toStart = getApplicationState() == ApplicationState.ACTIVE;
1:     
1:     if (_bundleFrameworkManager.allowsUpdate(newMetadata, oldMetadata)) {
0:       _bundleFrameworkManager.updateBundles(
0:           newMetadata, oldMetadata, 
0:           _application, 
1:           new BundleFrameworkManager.BundleLocator() {            
1:             public Map<DeploymentContent, BundleSuggestion> suggestBundle(
0:                 Collection<DeploymentContent> bundles) throws ContextException {
1:               return findBundleSuggestions(bundles);
1:             }
0:           },
0:           _bundles, 
0:           toStart);
1:       
1:     } else {
1:       // fallback do a uninstall, followed by a reinstall
1:       
0:       boolean uninstallSuccess = uninstall();
1:       
0:       if (uninstallSuccess) {
1:         _deploymentMF = newMetadata;
0:         boolean reinstallSuccess = processContent();
0:         Exception installException = null;
1:         
0:         if (reinstallSuccess) {
0:           if (toStart) {
1:             try {
1:               start();
0:             } catch (BundleException be) {
0:               reinstallSuccess = false;
0:               installException = be;              
1:             }
1:           }
1:         }
1:           
0:         if (!!!reinstallSuccess) {
0:           boolean rollbackSuccess = uninstall();
0:           Exception rollbackException = null;
1:           
0:           if (rollbackSuccess) {
1:             _deploymentMF = oldMetadata;
0:             rollbackSuccess = processContent();
1:             
0:             if (rollbackSuccess && toStart) {
1:               try {
1:                 start();
0:               } catch (BundleException be) {
0:                 rollbackException = be;
0:                 rollbackSuccess = false;
1:               }
1:             }
1:           }
1:            
0:           throw new UpdateException("Could not install updated application", installException, rollbackSuccess, rollbackException);
1:         }
1:       } else {
0:         throw new UpdateException("Could not uninstall old bundles", null, false, null);
1:       }
1:     }
1:   }
author:Chris Wilkinson
-------------------------------------------------------------------------------
commit:06621c5
/////////////////////////////////////////////////////////////////////////
1:    * Called to install the application.
commit:354c219
/////////////////////////////////////////////////////////////////////////
1:     	
1:       
1:       _state = ApplicationState.INSTALLED;
1:       
1:       
1:       
/////////////////////////////////////////////////////////////////////////
1:   protected synchronized void uninstall() throws BundleException
commit:9db128e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       throws BundleException
/////////////////////////////////////////////////////////////////////////
0:         && !_deploymentMF.getApplicationDeploymentContents().isEmpty())
1:       install();
/////////////////////////////////////////////////////////////////////////
1:   private void install() throws BundleException
/////////////////////////////////////////////////////////////////////////
1:     try {
1:       installBundles(provisionBundlesToFind, true);
1:       installBundles(useBundlesToFind, true);
1:       installBundles(bundlesToFind, false);
1:     } catch (BundleException e) {
1:       throw e;
1:     
0:     _state = ApplicationState.INSTALLED;
1:     LOGGER.debug(LOG_EXIT, "install");
/////////////////////////////////////////////////////////////////////////
0:   protected synchronized void uninstall() throws BundleException, IllegalStateException
1:     
0:     if (_state == ApplicationState.UNINSTALLED)
0:       throw new IllegalStateException("Appication is in incorrect state " + _state);
/////////////////////////////////////////////////////////////////////////
0:         throw be;
1:     
0:     _state = ApplicationState.UNINSTALLED;
1:     LOGGER.debug(LOG_EXIT, "uninstall");
/////////////////////////////////////////////////////////////////////////
1:   private void installBundles(List<DeploymentContent> bundlesToFind, boolean shared)
1:       throws BundleException
1:        * Dont install any bundles from the list which are already
1:        * installed
1:       Bundle[] sharedBundles = _bundleFrameworkManager.getSharedBundleFramework()
1:           .getIsolatedBundleContext().getBundles();
/////////////////////////////////////////////////////////////////////////
1:        * Ask the repository manager to find us a list of suggested bundles
1:        * to install based on our content list
1:       Map<DeploymentContent, BundleSuggestion> bundlesToBeInstalled = 
1:         findBundleSuggestions(bundlesToFind);
1:       /**
0:        * Perform the install of the bundles
1:        */
1:       try {
1:         if (shared) _bundles.addAll(_bundleFrameworkManager.installSharedBundles(
0:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), _application));
1:         else _bundles.add(_bundleFrameworkManager.installIsolatedBundles(
0:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), _application));
1: 
0:       } catch (BundleException e) {
1:         LOGGER.debug(LOG_EXCEPTION, e);
1:         throw e;
1:     LOGGER.debug(LOG_EXIT, "install");
1: 
1:   private Map<DeploymentContent, BundleSuggestion> findBundleSuggestions(
1:       Collection<DeploymentContent> bundlesToFind) throws BundleException
1:     Map<DeploymentContent, BundleSuggestion> suggestions = null;
1:     try {
1:       suggestions = _bundleRepositoryManager.getBundleSuggestions(_application
0:           .getApplicationMetadata().getApplicationSymbolicName(), _application
0:           .getApplicationMetadata().getApplicationVersion().toString(), bundlesToFind);
1:     } catch (ContextException e) {
1:       LOGGER.debug(LOG_EXCEPTION, e);
1:       throw new BundleException("Failed to locate bundle suggestions", e);
1:     }
1: 
1:     return suggestions;
1: 
/////////////////////////////////////////////////////////////////////////
1:   public synchronized Set<Bundle> getApplicationContent()
/////////////////////////////////////////////////////////////////////////
1:   public synchronized ApplicationState getApplicationState()
/////////////////////////////////////////////////////////////////////////
1:   public synchronized void start() throws BundleException, IllegalStateException
1:     if (!(_state == ApplicationState.INSTALLED || 
1:         _state == ApplicationState.RESOLVED))
1:       throw new IllegalStateException("Appication is in incorrect state " + _state + " expected " + ApplicationState.INSTALLED + " or " + ApplicationState.RESOLVED);
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:   public synchronized void stop() throws BundleException, IllegalStateException
1:     
1:     if (_state != ApplicationState.ACTIVE)
1:       throw new IllegalStateException("Appication is in incorrect state " + _state + " expected " + ApplicationState.ACTIVE);
1:         
1:     
1:   public synchronized void update(final DeploymentMetadata newMetadata, final DeploymentMetadata oldMetadata)
0:       throws UpdateException
1: 
1:       _bundleFrameworkManager.updateBundles(newMetadata, oldMetadata, _application,
0:           new BundleFrameworkManager.BundleLocator() {
1:                 Collection<DeploymentContent> bundles) throws BundleException
1:             {
1:           }, _bundles, toStart);
1: 
1:       try {        
1:         uninstall();
0:         _deploymentMF = newMetadata;        
1:         try {
1:           install();
1:           
1:           if (toStart)
1:             start();
1:         catch (BundleException e)
1:         {
1:           try {
1:             uninstall();
1:             _deploymentMF = oldMetadata;
1:             install();
1: 
1:             if (toStart)
1:               start();
1:             throw new UpdateException("Could not install updated application", e,
1:                 true, null);
1:           }
1:           catch (BundleException e2)
1:           {
1:             throw new UpdateException("Could not install updated application", e,
1:                 false, e2);
1:           }          
1:         }       
1:       }
1:       catch (BundleException e)
1:       {
1:         try {          
1:           _deploymentMF = oldMetadata;
1:           install();
1: 
1:           if (toStart)
1:             start();
1:           
1:           throw new UpdateException("Could not install updated application", e,
1:               true, null);
1:         catch (BundleException e2)
1:         {
1:           throw new UpdateException("Could not install updated application", e,
1:               false, e2);
1:         } 
commit:a07c6cd
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1:     _bundles = new LinkedHashSet<Bundle>();
author:Mark Nuttall
-------------------------------------------------------------------------------
commit:92a0da5
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
1: import static org.apache.aries.application.utils.AppConstants.LOG_EXCEPTION;
1: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9824b9a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     // calculate installed again as we only claim install success 
commit:9ca95bd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.aries.application.runtime.isolated.impl;
1: 
1: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.HashMap;
0: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import org.apache.aries.application.DeploymentContent;
1: import org.apache.aries.application.DeploymentMetadata;
1: import org.apache.aries.application.management.AriesApplication;
1: import org.apache.aries.application.management.AriesApplicationContext;
0: import org.apache.aries.application.management.BundleFramework;
0: import org.apache.aries.application.management.BundleFrameworkManager;
0: import org.apache.aries.application.management.BundleRepositoryManager;
0: import org.apache.aries.application.management.ContextException;
0: import org.apache.aries.application.management.ManagementException;
0: import org.apache.aries.application.management.BundleRepository.BundleSuggestion;
1: import org.osgi.framework.Bundle;
0: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.BundleException;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import static org.apache.aries.application.utils.AppConstants.LOG_ENTRY;
0: import static org.apache.aries.application.utils.AppConstants.LOG_EXIT;
0: import static org.apache.aries.application.utils.AppConstants.LOG_EXCEPTION;
1: 
1: public class ApplicationContextImpl implements AriesApplicationContext
1: {
1:   private static final Logger LOGGER = LoggerFactory.getLogger(ApplicationContextImpl.class);
1: 
0:   private AriesApplication _application;
0:   private Set<Bundle> _bundles;
1:   private ApplicationState _state = ApplicationState.UNINSTALLED;
0:   private BundleContext _bundleContext;
0:   private BundleRepositoryManager _bundleRepositoryManager;
0:   private BundleFrameworkManager _bundleFrameworkManager;
1: 
1:   /** deployment metadata associated with aries application */
0:   private final DeploymentMetadata _deploymentMF;
1: 
1:   public ApplicationContextImpl(AriesApplication app, ApplicationContextManagerImpl acm)
0:       throws BundleException, ManagementException
1:   {
1:     LOGGER.debug(LOG_ENTRY, "ApplicationContextImpl", new Object[] { app, acm });
1: 
1:     _bundleFrameworkManager = acm.getBundleFrameworkManager();
1:     _bundleRepositoryManager = acm.getBundleRepositoryManager();
0:     _bundles = new HashSet<Bundle>();
1: 
1:     _application = app;
1:     _deploymentMF = _application.getDeploymentMetadata();
1: 
1:     if (_deploymentMF.getApplicationDeploymentContents() != null
0:         && !_deploymentMF.getApplicationDeploymentContents().isEmpty()) {
0:       if (processContent()) 
0:         _state = ApplicationState.INSTALLED;
1:     }
1: 
1:     LOGGER.debug(LOG_EXIT, "ApplicationContextImpl", this);
1:   }
1: 
1:   /**
0:    * Called to install the application, if called multiple times the subsequent
1:    * calls will be ignored.
1:    * @return whether the installation is successful
1:    * 
1:    */
0:   private boolean processContent()
1:   {
1:     LOGGER.debug(LOG_ENTRY, "install");
1: 
0:     boolean success = true;
0:     boolean provisionBundleInstall = false;
0:     boolean useBundleInstall = false;
1:     List<DeploymentContent> bundlesToFind = new ArrayList<DeploymentContent>(_deploymentMF
1:         .getApplicationDeploymentContents());
1:     List<DeploymentContent> useBundlesToFind = new ArrayList<DeploymentContent>(_deploymentMF
1:         .getDeployedUseBundle());
1:     List<DeploymentContent> provisionBundlesToFind = new ArrayList<DeploymentContent>(_deploymentMF
1:         .getApplicationProvisionBundles());
1: 
0:     // In release 1, we'll only support regular bundles in Deployed-Content or CompositeBundle-Content
0:     // let's process provision bundle first.  if we find it, good, if not, install it
0:     // please note that provision bundle may contain CBAs.
0:     provisionBundleInstall = install(provisionBundlesToFind, true);
1: 
0:     // note that useBundle may contains CBAs
0:     useBundleInstall = install(useBundlesToFind, true);
1: 
0:     // let's process application content/deployment content second.
0:     // for isolated env, this means, we need to install all and there is no need 
0:     // to find if it exists in the shared bundle space
0:     success = install(bundlesToFind, false);
1: 
0:     if (success && provisionBundleInstall && useBundleInstall) {
1:       LOGGER.debug("Successfully installed application "
1:           + _application.getApplicationMetadata().getApplicationSymbolicName());
0:     } else {
1:       LOGGER.debug(LOG_EXCEPTION, "Failed to install application "
1:           + _application.getApplicationMetadata().getApplicationSymbolicName());
1:       uninstall();
1:     }
1: 
0:     // let's calculate installed again as we only claim install success 
0:     // when provision bundle and use bundle are installed too.
0:     success = success && provisionBundleInstall && useBundleInstall;
1: 
0:     LOGGER.debug(LOG_EXIT, "install", new Object[] { Boolean.valueOf(success) });
1: 
0:     return success;
1: 
1:   }
1: 
1:   /**
1:    * Called to remove the application, if called multiple times the subsequent
1:    * calls will be ignored.
1:    * @return whether the uninstallation is successful
1:    */
0:   protected boolean uninstall()
1:   {
1:     LOGGER.debug(LOG_ENTRY, "uninstall");
1: 
0:     int numErrorBundle = 0;
1: 
0:     // Iterate through all of the bundles that were started when this application was started, 
0:     // and attempt to stop and uninstall each of them. 
0:     for (Iterator<Bundle> bundleIter = _bundles.iterator(); bundleIter.hasNext();) {
0:       Bundle bundleToRemove = bundleIter.next();
1: 
0:       try {
0:         // If Bundle is active, stop it first.
0:         if (bundleToRemove.getState() == Bundle.ACTIVE) {
0:           _bundleFrameworkManager.stopBundle(bundleToRemove);
1:         }
1: 
0:         // Delegate the uninstall to the bundleFrameworkManager
0:         _bundleFrameworkManager.uninstallBundle(bundleToRemove);
1: 
0:       } catch (BundleException be) {
0:         numErrorBundle++;
0:         LOGGER.debug(LOG_EXCEPTION, be);
1:       }
1:     }
1: 
0:     _bundles.clear();
1: 
0:     // return success only if all bundles were uninstalled successfully
0:     boolean result = (numErrorBundle == 0);
1: 
0:     LOGGER.debug(LOG_EXIT, "uninstall", new Object[] { Boolean.valueOf(result) });
1: 
0:     return result;
1: 
1:   }
1: 
1:   /**
1:    * This method finds bundles matching the list of content passed in
1:    * @param bundlesToFind       bundles to find and start if the bundle is shared.  If isolated, install it.
1:    * @param shared                      whether the bundles will be shared or isolated
1:    * @return the result of execution
1:    */
0:   private boolean install(List<DeploymentContent> bundlesToFind, boolean shared)
1:   {
1:     LOGGER.debug(LOG_ENTRY, "install", new Object[] { bundlesToFind, Boolean.valueOf(shared) });
1: 
0:     int numException = 0; //log the number of exceptions, only assert success if no exception
1: 
1:     if (!bundlesToFind.isEmpty() || !shared) {
1: 
1:       Iterator<DeploymentContent> it = bundlesToFind.iterator();
1: 
1:       /**
0:        * Dont install any bundles from the list which are already installed
1:        */
0:       Bundle[] sharedBundles = 
0:         _bundleFrameworkManager.getSharedBundleFramework().
0:                                 getIsolatedBundleContext().
0:                                 getBundles();
1:       if (shared) {
1:         if (sharedBundles.length > 0) {
1:           while (it.hasNext()) {
1:             DeploymentContent bundleToFind = it.next();
1: 
1:             for (Bundle b : sharedBundles) {
1:               if (bundleToFind.getContentName().equals(b.getSymbolicName())
1:                   && bundleToFind.getExactVersion().equals(b.getVersion())) {
1:                 it.remove();
1:                 _bundles.add(b);
1:                 break;
1:               }
1:             }
1:           }
1:         }
1:       }
1: 
1:       /**
0:        * Ask the repository manager to find us a list of suggested bundles to install based on our
0:        * content list
1:        */
0:       Map<DeploymentContent, BundleSuggestion> bundlesToBeInstalled = new HashMap<DeploymentContent, BundleSuggestion>();
0:       try {
0:         bundlesToBeInstalled = _bundleRepositoryManager.getBundleSuggestions(_application
0:             .getApplicationMetadata().getApplicationSymbolicName(), _application
0:             .getApplicationMetadata().getApplicationVersion().toString(), bundlesToFind);
0:       } catch (ContextException e) {
0:         numException++;
0:         LOGGER.debug(LOG_EXCEPTION, e);
1:       }
1: 
1:       /**
0:        * Perform the install of the bundles
1:        */
0:       try {
0:         if (shared) 
0:           _bundles.addAll(_bundleFrameworkManager.installSharedBundles(
0:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), _application));
0:         else 
0:           _bundles.add(_bundleFrameworkManager.installIsolatedBundles(
0:             new ArrayList<BundleSuggestion>(bundlesToBeInstalled.values()), _application));
1: 
0:       } catch (BundleException e) {
0:         numException++;
0:         LOGGER.debug(LOG_EXCEPTION, e);
1:       }
1:     }
1: 
0:     LOGGER.debug(LOG_EXIT, "install", new Object[] { Boolean.valueOf(numException == 0) });
1: 
0:     return (numException == 0);
1:   }
1: 
1:   public AriesApplication getApplication()
1:   {
1:     LOGGER.debug(LOG_ENTRY, "getApplication");
1:     LOGGER.debug(LOG_EXIT, "getApplication", new Object[] { _application });
1: 
1:     return _application;
1:   }
1: 
0:   public Set<Bundle> getApplicationContent()
1:   {
1:     LOGGER.debug(LOG_ENTRY, "getApplicationContent");
1:     LOGGER.debug(LOG_EXIT, "getApplicationContent", new Object[] { _bundles });
1: 
1:     return _bundles;
1:   }
1: 
0:   public ApplicationState getApplicationState()
1:   {
1:     LOGGER.debug(LOG_ENTRY, "getApplicationState");
1:     LOGGER.debug(LOG_EXIT, "getApplicationState", new Object[] { _state });
1: 
1:     return _state;
1:   }
1: 
0:   public void start() throws BundleException
1:   {
1:     LOGGER.debug(LOG_ENTRY, "start");
1: 
0:     ApplicationState oldState = _state;
0:     _state = ApplicationState.STARTING;
1: 
1:     List<Bundle> bundlesWeStarted = new ArrayList<Bundle>();
0:     try {
1:       for (Bundle b : _bundles) {
1:         _bundleFrameworkManager.startBundle(b);
1:         bundlesWeStarted.add(b);
1:       }
0:     } catch (BundleException be) {
1: 
1:       for (Bundle b : bundlesWeStarted) {
0:         try {
1:           _bundleFrameworkManager.stopBundle(b);
1:         } catch (BundleException be2) {
1:           // we are doing tidyup here, so we don't want to replace the bundle exception
1:           // that occurred during start with one from stop. We also want to try to stop
1:           // all the bundles we started even if some bundles wouldn't stop.
1:           LOGGER.debug(LOG_EXCEPTION, be2);
1:         }
1:       }
0:       _state = oldState;
1: 
0:       LOGGER.debug(LOG_EXCEPTION, be);
1:       LOGGER.debug(LOG_EXIT, "start", new Object[] { be });
0:       throw be;
1:     }
1:     _state = ApplicationState.ACTIVE;
1: 
1:     LOGGER.debug(LOG_EXIT, "start");
1:   }
1: 
0:   public void stop() throws BundleException
1:   {
1:     LOGGER.debug(LOG_ENTRY, "stop");
1: 
1:     for (Bundle entry : _bundles) {
1:       Bundle b = entry;
1:       _bundleFrameworkManager.stopBundle(b);
1:     }
1:     _state = ApplicationState.RESOLVED;
1: 
1:     LOGGER.debug(LOG_EXIT, "stop");
1:   }
1: 
0:   public void setState(ApplicationState state)
1:   {
0:     LOGGER.debug(LOG_ENTRY, "setState", new Object[] { _state, state });
1: 
0:     _state = state;
1: 
0:     LOGGER.debug(LOG_EXIT, "setState");
1:   }
1: }
============================================================================