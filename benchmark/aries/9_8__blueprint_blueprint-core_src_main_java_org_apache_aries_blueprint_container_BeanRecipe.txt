1:f13c6ac: /*
1:f13c6ac:  * Licensed to the Apache Software Foundation (ASF) under one
1:f13c6ac:  * or more contributor license agreements.  See the NOTICE file
1:f13c6ac:  * distributed with this work for additional information
1:f13c6ac:  * regarding copyright ownership.  The ASF licenses this file
1:f13c6ac:  * to you under the Apache License, Version 2.0 (the
1:f13c6ac:  * "License"); you may not use this file except in compliance
1:f13c6ac:  * with the License.  You may obtain a copy of the License at
1:f13c6ac:  *
1:f13c6ac:  *   http://www.apache.org/licenses/LICENSE-2.0
1:f13c6ac:  *
1:f13c6ac:  * Unless required by applicable law or agreed to in writing,
1:f13c6ac:  * software distributed under the License is distributed on an
1:f13c6ac:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:f13c6ac:  * KIND, either express or implied.  See the License for the
1:f13c6ac:  * specific language governing permissions and limitations
1:f13c6ac:  * under the License.
1:f13c6ac:  */
1:6414875: package org.apache.aries.blueprint.container;
1:f13c6ac: 
1:f13c6ac: import java.lang.reflect.Constructor;
1:84c868d: import java.lang.reflect.InvocationTargetException;
1:f13c6ac: import java.lang.reflect.Method;
1:f13c6ac: import java.lang.reflect.Modifier;
1:f13c6ac: import java.lang.reflect.Type;
1:f13c6ac: import java.util.ArrayList;
1:f13c6ac: import java.util.Arrays;
1:d473e9a: import java.util.Collection;
1:f13c6ac: import java.util.HashMap;
1:f13c6ac: import java.util.Iterator;
1:f13c6ac: import java.util.LinkedHashMap;
1:f13c6ac: import java.util.List;
1:f13c6ac: import java.util.Map;
1:071e3fe: import java.util.concurrent.Callable;
1:4377012: import java.util.concurrent.Semaphore;
1:4377012: import java.util.concurrent.atomic.AtomicReference;
1:f13c6ac: 
1:6414875: import org.apache.aries.blueprint.BeanProcessor;
1:bb726ca: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1:bb726ca: import org.apache.aries.blueprint.Interceptor;
1:6414875: import org.apache.aries.blueprint.di.AbstractRecipe;
1:6414875: import org.apache.aries.blueprint.di.Recipe;
1:285f3a8: import org.apache.aries.blueprint.proxy.CollaboratorFactory;
1:24455ce: import org.apache.aries.blueprint.proxy.ProxyUtils;
1:4dfd2d8: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
1:6414875: import org.apache.aries.blueprint.utils.ReflectionUtils;
1:d08aba3: import org.apache.aries.blueprint.utils.ReflectionUtils.PropertyDescriptor;
1:4377012: import org.apache.aries.proxy.UnableToProxyException;
1:66dc5e9: import org.osgi.framework.Bundle;
1:84c868d: import org.osgi.framework.BundleContext;
1:24455ce: import org.osgi.framework.FrameworkUtil;
1:f13c6ac: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1:f13c6ac: import org.osgi.service.blueprint.container.ReifiedType;
1:aa58216: import org.osgi.service.blueprint.reflect.BeanMetadata;
1:f13c6ac: import org.slf4j.Logger;
1:f13c6ac: import org.slf4j.LoggerFactory;
1:4dfd2d8: 
1:c9e6b82: import static org.apache.aries.blueprint.utils.ReflectionUtils.getPublicMethods;
1:c9e6b82: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1:c9e6b82: 
1:f13c6ac: /**
1:f13c6ac:  * A <code>Recipe</code> to create POJOs.
1:f13c6ac:  *
1:f13c6ac:  * @version $Rev$, $Date$
1:f13c6ac:  */
1:adf0ce3: @SuppressWarnings("rawtypes")
1:f13c6ac: public class BeanRecipe extends AbstractRecipe {
1:f13c6ac: 
1:adf0ce3:     static class UnwrapperedBeanHolder {
1:adf0ce3:         final Object unwrapperedBean;
1:adf0ce3:         final BeanRecipe recipe;
1:f13c6ac: 
1:adf0ce3:         public UnwrapperedBeanHolder(Object unwrapperedBean, BeanRecipe recipe) {
1:adf0ce3:             this.unwrapperedBean = unwrapperedBean;
1:adf0ce3:             this.recipe = recipe;
1:adf0ce3:         }
1:6588a3e:     }
1:adf0ce3: 
1:4377012:     public class VoidableCallable implements Callable<Object>, Voidable {
1:adf0ce3: 
1:4377012:         private final AtomicReference<Object> ref = new AtomicReference<Object>();
1:adf0ce3:         
1:4377012:         private final Semaphore sem = new Semaphore(1);
1:5e2bd49:         
1:4377012:         private final ThreadLocal<Object> deadlockDetector = new ThreadLocal<Object>();
1:5e2bd49:         
1:4377012:         public void voidReference() {
1:4377012:             ref.set(null);
1:adf0ce3:         }
1:5e2bd49: 
1:4377012:         public Object call() throws ComponentDefinitionException {
1:4377012:             Object o = ref.get();
1:4377012:             
1:4377012:             if (o == null) {
1:4377012:                 if(deadlockDetector.get() != null) {
1:4377012:                     deadlockDetector.remove();
1:4377012:                     throw new ComponentDefinitionException("Construction cycle detected for bean " + name);
1:5e2bd49:                 }
1:4377012:                 
1:4377012:                 sem.acquireUninterruptibly();
1:8c4aa3a:                 try {
1:4377012:                     o = ref.get();
1:4377012:                     if (o == null) {
1:4377012:                         deadlockDetector.set(this);
3:6588a3e:                         try {
1:4377012:                             o = internalCreate2();
1:4377012:                             ref.set(o);
1:4377012:                         } finally {
1:4377012:                             deadlockDetector.remove();
1:8c4aa3a:                         }
1:6588a3e:                     }
1:4377012:                 } finally {
1:4377012:                   sem.release();
1:5e2bd49:                 }
1:4377012:             }
1:4377012:             
1:4377012:             return o;
1:4377012:         }
1:4377012: 
1:4377012:     }
1:4377012: 
1:f13c6ac:     private static final Logger LOGGER = LoggerFactory.getLogger(BeanRecipe.class);
1:f13c6ac: 
1:f13c6ac:     private final ExtendedBlueprintContainer blueprintContainer;
1:f13c6ac:     private final LinkedHashMap<String,Object> properties = new LinkedHashMap<String,Object>();
1:f13c6ac:     private final Object type;
1:f13c6ac: 
1:f13c6ac:     private String initMethod;
1:f13c6ac:     private String destroyMethod;
1:f13c6ac:     private List<Recipe> explicitDependencies;
1:f13c6ac:     
1:f13c6ac:     private Recipe factory;
1:f13c6ac:     private String factoryMethod;
1:f13c6ac:     private List<Object> arguments;
1:f13c6ac:     private List<String> argTypes;
1:f13c6ac:     private boolean reorderArguments;
1:d08aba3:     private final boolean allowsFieldInjection;
1:f0b2b91:     private BeanMetadata interceptorLookupKey;
1:f13c6ac:     
1:f13c6ac: 
1:d08aba3:     public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type, boolean allowsFieldInjection) {
1:f13c6ac:         super(name);
1:f13c6ac:         this.blueprintContainer = blueprintContainer;
1:f13c6ac:         this.type = type;
1:d08aba3:         this.allowsFieldInjection = allowsFieldInjection;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Object getProperty(String name) {
1:f13c6ac:         return properties.get(name);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Map<String, Object> getProperties() {
1:f13c6ac:         return new LinkedHashMap<String, Object>(properties);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setProperty(String name, Object value) {
1:f13c6ac:         properties.put(name, value);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setFactoryMethod(String method) {
1:f13c6ac:         this.factoryMethod = method;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void setFactoryComponent(Recipe factory) {
1:f13c6ac:         this.factory = factory;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void setArgTypes(List<String> argTypes) {
1:f13c6ac:         this.argTypes = argTypes;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void setArguments(List<Object> arguments) {
1:f13c6ac:         this.arguments = arguments;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void setReorderArguments(boolean reorder) {
1:f13c6ac:         this.reorderArguments = reorder;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void setInitMethod(String initMethod) {
1:f13c6ac:         this.initMethod = initMethod;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public String getInitMethod() {
1:f13c6ac:         return initMethod;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public void setDestroyMethod(String destroyMethod) {
1:f13c6ac:         this.destroyMethod = destroyMethod;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public String getDestroyMethod() {
1:f13c6ac:         return destroyMethod;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public List<Recipe> getExplicitDependencies() {
1:f13c6ac:         return explicitDependencies;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setExplicitDependencies(List<Recipe> explicitDependencies) {
1:f13c6ac:         this.explicitDependencies = explicitDependencies;
1:f13c6ac:     }
1:f13c6ac: 
1:f0b2b91:     public void setInterceptorLookupKey(BeanMetadata metadata) {
1:f0b2b91:     	interceptorLookupKey = metadata;
1:4377012:     }
1:4377012:     
1:f13c6ac:     @Override
1:f13c6ac:     public List<Recipe> getConstructorDependencies() {
1:f13c6ac:         List<Recipe> recipes = new ArrayList<Recipe>();
1:f13c6ac:         if (explicitDependencies != null) {
1:f13c6ac:             recipes.addAll(explicitDependencies);
1:f13c6ac:         }
1:f13c6ac:         if (arguments != null) {
1:f13c6ac:             for (Object argument : arguments) {
1:f13c6ac:                 if (argument instanceof Recipe) {
1:f13c6ac:                     recipes.add((Recipe)argument);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return recipes;
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     public List<Recipe> getDependencies() {
1:f13c6ac:         List<Recipe> recipes = new ArrayList<Recipe>();
1:f13c6ac:         for (Object o : properties.values()) {
1:f13c6ac:             if (o instanceof Recipe) {
1:f13c6ac:                 Recipe recipe = (Recipe) o;
1:f13c6ac:                 recipes.add(recipe);
1:f13c6ac:             }
1:f13c6ac:         }
1:1fdbc37:         if (factory != null) {
1:1fdbc37:             recipes.add(factory);
1:1fdbc37:         }
1:f13c6ac:         recipes.addAll(getConstructorDependencies());
1:f13c6ac:         return recipes; 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void instantiateExplicitDependencies() {
1:f13c6ac:         if (explicitDependencies != null) {
1:f13c6ac:             for (Recipe recipe : explicitDependencies) {
1:f13c6ac:                 recipe.create();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     @Override
1:f13c6ac:     protected Class loadClass(String className) {
1:f13c6ac:         ClassLoader loader = type instanceof Class ? ((Class) type).getClassLoader() : null;
1:f13c6ac:         ReifiedType t = loadType(className, loader);
1:f13c6ac:         return t != null ? t.getRawClass() : null;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     @Override
1:f13c6ac:     protected ReifiedType loadType(String className) {
1:f13c6ac:         return loadType(className, type instanceof Class ? ((Class) type).getClassLoader() : null);
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private Object getInstance() throws ComponentDefinitionException {
1:f13c6ac:         // Instanciate arguments
1:f13c6ac:         List<Object> args = new ArrayList<Object>();
1:f13c6ac:         List<ReifiedType> argTypes = new ArrayList<ReifiedType>();
1:f13c6ac:         if (arguments != null) {
1:f13c6ac:             for (int i = 0; i < arguments.size(); i++) {
1:f13c6ac:                 Object arg = arguments.get(i);
1:f13c6ac:                 if (arg instanceof Recipe) {
1:f13c6ac:                     args.add(((Recipe) arg).create());
1:f13c6ac:                 } else {
1:f13c6ac:                     args.add(arg);
1:f13c6ac:                 }
1:f13c6ac:                 if (this.argTypes != null) {
1:f13c6ac:                     argTypes.add(this.argTypes.get(i) != null ? loadType(this.argTypes.get(i)) : null);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         
1:f13c6ac:         if (factory != null) {
1:6588a3e:             return getInstanceFromFactory(args, argTypes);
1:f13c6ac:         } else if (factoryMethod != null) {
1:6588a3e:             return getInstanceFromStaticFactory(args, argTypes);
1:f13c6ac:         } else {
1:6588a3e:             return getInstanceFromType(args, argTypes);
1:6588a3e:         }
1:f13c6ac:         
1:6588a3e:     }
1:6588a3e:     
1:6588a3e:     private Object getInstanceFromFactory(List<Object> args, List<ReifiedType> argTypes) {
1:6588a3e:         Object factoryObj = getFactoryObj();
1:6588a3e:         
1:f13c6ac:         // Map of matching methods
1:f13c6ac:         Map<Method, List<Object>> matches = findMatchingMethods(factoryObj.getClass(), factoryMethod, true, args, argTypes);
1:f13c6ac:         if (matches.size() == 1) {
1:6588a3e:             try {
1:f13c6ac:                 Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:6588a3e:                 return invoke(match.getKey(), factoryObj, match.getValue().toArray());
2:f13c6ac:             } catch (Throwable e) {
1:6588a3e:                 throw wrapAsCompDefEx(e);
1:6588a3e:             }
1:f13c6ac:         } else if (matches.size() == 0) {
1:ae927fa:             throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName());
1:f13c6ac:         } else {
1:ae927fa:             throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + factoryObj.getClass().getName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName() + ": " + matches.keySet());
1:6588a3e:         }
1:6588a3e:     }
1:6588a3e: 
1:6588a3e:     private Object getFactoryObj() {
1:f13c6ac:         // look for instance method on factory object
1:f13c6ac:         Object factoryObj = factory.create();
1:6588a3e:         
1:6588a3e:         // If the factory is a service reference, we need to get hold of the actual proxy for the service
1:6588a3e:         if (factoryObj instanceof ReferenceRecipe.ServiceProxyWrapper) {
1:f13c6ac:             try {
1:6588a3e:                 factoryObj = ((ReferenceRecipe.ServiceProxyWrapper) factoryObj).convert(new ReifiedType(Object.class));
1:6588a3e:             } catch (Exception e) {
1:6588a3e:                 throw wrapAsCompDefEx(e);
1:f13c6ac:             }
1:6588a3e:         } else if (factoryObj instanceof UnwrapperedBeanHolder) {
1:6588a3e:                 factoryObj = wrap((UnwrapperedBeanHolder) factoryObj, Object.class);
1:f13c6ac:         }
1:6588a3e:         return factoryObj;
1:6588a3e:     }
1:6588a3e:     
1:6588a3e:     private Object getInstanceFromStaticFactory(List<Object> args, List<ReifiedType> argTypes) {
1:f13c6ac:         // Map of matching methods
1:f13c6ac:         Map<Method, List<Object>> matches = findMatchingMethods(getType(), factoryMethod, false, args, argTypes);
1:f13c6ac:         if (matches.size() == 1) {
1:f13c6ac:             try {
1:f13c6ac:                 Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:6588a3e:                 return invoke(match.getKey(), null, match.getValue().toArray());
1:f13c6ac:             } catch (Throwable e) {
1:6588a3e:                 throw wrapAsCompDefEx(e);
1:f13c6ac:             }
1:f13c6ac:         } else if (matches.size() == 0) {
1:ae927fa:             throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName());
1:f13c6ac:         } else {
1:ae927fa:             throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName() + ": " + matches.keySet());
1:f13c6ac:         }
1:6588a3e:     }
1:6588a3e: 
1:6588a3e:     private Object getInstanceFromType(List<Object> args, List<ReifiedType> argTypes) {
1:f13c6ac:         if (getType() == null) {
1:f13c6ac:             throw new ComponentDefinitionException("No factoryMethod nor class is defined for this bean");
1:f13c6ac:         }
1:f13c6ac:         // Map of matching constructors
1:f13c6ac:         Map<Constructor, List<Object>> matches = findMatchingConstructors(getType(), args, argTypes);
1:f13c6ac:         if (matches.size() == 1) {
1:f13c6ac:             try {
1:f13c6ac:                 Map.Entry<Constructor, List<Object>> match = matches.entrySet().iterator().next();
1:6588a3e:                 return newInstance(match.getKey(), match.getValue().toArray());
1:f13c6ac:             } catch (Throwable e) {
1:6588a3e:                 throw wrapAsCompDefEx(e);
1:f13c6ac:             }
1:f13c6ac:         } else if (matches.size() == 0) {
1:ae927fa:             throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName());
1:f13c6ac:         } else {
1:ae927fa:             throw new ComponentDefinitionException("Multiple matching constructors found on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName() + ": " + matches.keySet());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:6588a3e:     private ComponentDefinitionException wrapAsCompDefEx(Throwable e) {
1:6588a3e:         return new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getTypeName(), getRealCause(e));
1:f13c6ac:     }
1:f13c6ac: 
1:adf0ce3:     private String getTypeName() {
1:adf0ce3:         Class<?> type = getType();
1:adf0ce3:         return type == null ? null : type.getName();
1:6588a3e:     }
1:6588a3e: 
1:f13c6ac:     private Map<Method, List<Object>> findMatchingMethods(Class type, String name, boolean instance, List<Object> args, List<ReifiedType> types) {
1:f13c6ac:         Map<Method, List<Object>> matches = new HashMap<Method, List<Object>>();
1:f13c6ac:         // Get constructors
1:4d5683c:         List<Method> methods = new ArrayList<Method>(Arrays.asList(getPublicMethods(type)));
1:f13c6ac:         // Discard any signature with wrong cardinality
1:f13c6ac:         for (Iterator<Method> it = methods.iterator(); it.hasNext();) {
1:f13c6ac:             Method mth = it.next();
1:f13c6ac:             if (!mth.getName().equals(name)) {
1:f13c6ac:                 it.remove();
1:f13c6ac:             } else if (mth.getParameterTypes().length != args.size()) {
1:f13c6ac:                 it.remove();
1:f13c6ac:             } else if (instance ^ !Modifier.isStatic(mth.getModifiers())) {
1:f13c6ac:                 it.remove();
1:7c549ab:             } else if (mth.isBridge()) {
1:7c549ab:                 it.remove();
1:f13c6ac:             }
1:f13c6ac:         }
1:adf0ce3:         
1:d473e9a:         // on some JVMs (J9) hidden static methods are returned by Class.getMethods so we need to weed them out
1:d473e9a:         // to reduce ambiguity
1:d473e9a:         if (!instance) {
1:d473e9a:         	methods = applyStaticHidingRules(methods);
1:6588a3e:         }
1:4377012:         
1:f13c6ac:         // Find a direct match with assignment
1:f13c6ac:         if (matches.size() != 1) {
1:f13c6ac:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:f13c6ac:             for (Method mth : methods) {
1:f13c6ac:                 boolean found = true;
1:f13c6ac:                 List<Object> match = new ArrayList<Object>();
1:f13c6ac:                 for (int i = 0; i < args.size(); i++) {
1:f13c6ac:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:f13c6ac:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:ae927fa:                     // If the arg is an Unwrappered bean then we need to do the assignment
1:ae927fa:                     // check against the unwrappered bean itself.
1:5e2bd49:                     Object arg = args.get(i);
1:5e2bd49:                     Object argToTest = arg;
1:ae927fa:                     if (arg instanceof UnwrapperedBeanHolder)
1:5e2bd49:                     	argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:5e2bd49:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                     try {
1:5e2bd49:                         match.add(convert(arg, mth.getGenericParameterTypes()[i]));
2:f13c6ac:                     } catch (Throwable t) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:                 if (found) {
1:f13c6ac:                     nmatches.put(mth, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Find a direct match with conversion
1:f13c6ac:         if (matches.size() != 1) {
1:f13c6ac:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:f13c6ac:             for (Method mth : methods) {
1:f13c6ac:                 boolean found = true;
1:f13c6ac:                 List<Object> match = new ArrayList<Object>();
1:f13c6ac:                 for (int i = 0; i < args.size(); i++) {
1:f13c6ac:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:f13c6ac:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                     try {
1:f13c6ac:                         Object val = convert(args.get(i), argType);
1:f13c6ac:                         match.add(val);
1:f13c6ac:                     } catch (Throwable t) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:                 if (found) {
1:f13c6ac:                     nmatches.put(mth, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Start reordering with assignment
1:f13c6ac:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:f13c6ac:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:f13c6ac:             for (Method mth : methods) {
1:f13c6ac:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), false);
1:f13c6ac:                 List<Object> match = matcher.match(args, types);
1:f13c6ac:                 if (match != null) {
1:f13c6ac:                     nmatches.put(mth, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Start reordering with conversion
1:f13c6ac:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:f13c6ac:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:f13c6ac:             for (Method mth : methods) {
1:f13c6ac:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), true);
1:f13c6ac:                 List<Object> match = matcher.match(args, types);
1:f13c6ac:                 if (match != null) {
1:f13c6ac:                     nmatches.put(mth, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:4377012:         
1:f13c6ac:         return matches;
1:f13c6ac:     }
1:f13c6ac:     
1:d473e9a:     private static List<Method> applyStaticHidingRules(Collection<Method> methods) {
1:d473e9a:     	List<Method> result = new ArrayList<Method>(methods.size());
1:d473e9a:     	for (Method m : methods) {
1:d473e9a:     		boolean toBeAdded = true;
1:4377012: 
1:d473e9a:     		Iterator<Method> it = result.iterator();
1:d473e9a:     		inner: while (it.hasNext()) {
1:d473e9a:     			Method other = it.next();
1:d473e9a:     			if (hasIdenticalParameters(m, other)) {
1:d473e9a:     				Class<?> mClass = m.getDeclaringClass();
1:d473e9a:     				Class<?> otherClass = other.getDeclaringClass();
1:4377012:     				
1:d473e9a:     				if (mClass.isAssignableFrom(otherClass)) {
1:d473e9a:     					toBeAdded = false;
1:d473e9a:     					break inner;
1:d473e9a:     				} else if (otherClass.isAssignableFrom(mClass)) {
1:d473e9a:     					it.remove();
1:f13c6ac:     				}
1:f13c6ac:     			}
1:f13c6ac:     		}
1:4377012:     		
1:d473e9a:     		if (toBeAdded) result.add(m);
1:6588a3e:     	}
1:cab8bfe:     	
1:d473e9a:     	return result;
1:6588a3e:     }
1:f0b2b91:     
1:d473e9a:     private static boolean hasIdenticalParameters(Method one, Method two) {
1:d473e9a: 		Class<?>[] oneTypes = one.getParameterTypes();
1:d473e9a: 		Class<?>[] twoTypes = two.getParameterTypes();
1:f0b2b91:     	
1:d473e9a: 		if (oneTypes.length != twoTypes.length) return false;
1:d473e9a: 		
1:d473e9a: 		for (int i=0; i<oneTypes.length; i++) {
1:d473e9a: 			if (!oneTypes[i].equals(twoTypes[i])) return false;
1:6588a3e: 		}
1:d473e9a: 		
1:d473e9a: 		return true;
1:adf0ce3:     }
1:d473e9a: 
1:f13c6ac:     private Map<Constructor, List<Object>> findMatchingConstructors(Class type, List<Object> args, List<ReifiedType> types) {
1:f13c6ac:         Map<Constructor, List<Object>> matches = new HashMap<Constructor, List<Object>>();
1:f13c6ac:         // Get constructors
1:f13c6ac:         List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(type.getConstructors()));
1:f13c6ac:         // Discard any signature with wrong cardinality
1:f13c6ac:         for (Iterator<Constructor> it = constructors.iterator(); it.hasNext();) {
1:f13c6ac:             if (it.next().getParameterTypes().length != args.size()) {
1:f13c6ac:                 it.remove();
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Find a direct match with assignment
1:f13c6ac:         if (matches.size() != 1) {
1:f13c6ac:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:f13c6ac:             for (Constructor cns : constructors) {
1:f13c6ac:                 boolean found = true;
1:f13c6ac:                 List<Object> match = new ArrayList<Object>();
1:f13c6ac:                 for (int i = 0; i < args.size(); i++) {
1:f13c6ac:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:f13c6ac:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:ae927fa:                     // If the arg is an Unwrappered bean then we need to do the assignment
1:ae927fa:                     // check against the unwrappered bean itself.
1:5e2bd49:                     Object arg = args.get(i);
1:5e2bd49:                     Object argToTest = arg;
1:ae927fa:                     if (arg instanceof UnwrapperedBeanHolder)
1:5e2bd49:                     	argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:5e2bd49:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                     try {
1:5e2bd49:                         match.add(convert(arg, cns.getGenericParameterTypes()[i]));
1:f13c6ac:                     } catch (Throwable t) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:                 if (found) {
1:f13c6ac:                     nmatches.put(cns, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Find a direct match with conversion
1:f13c6ac:         if (matches.size() != 1) {
1:f13c6ac:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:f13c6ac:             for (Constructor cns : constructors) {
1:f13c6ac:                 boolean found = true;
1:f13c6ac:                 List<Object> match = new ArrayList<Object>();
1:f13c6ac:                 for (int i = 0; i < args.size(); i++) {
1:f13c6ac:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:f13c6ac:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                     try {
1:f13c6ac:                         Object val = convert(args.get(i), argType);
1:f13c6ac:                         match.add(val);
1:f13c6ac:                     } catch (Throwable t) {
1:f13c6ac:                         found = false;
1:f13c6ac:                         break;
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:                 if (found) {
1:f13c6ac:                     nmatches.put(cns, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:8b0e4b1:             }
1:4377012:         }
1:f13c6ac:         // Start reordering with assignment
1:f13c6ac:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:f13c6ac:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:f13c6ac:             for (Constructor cns : constructors) {
1:f13c6ac:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), false);
1:f13c6ac:                 List<Object> match = matcher.match(args, types);
1:f13c6ac:                 if (match != null) {
1:f13c6ac:                     nmatches.put(cns, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         // Start reordering with conversion
1:f13c6ac:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:f13c6ac:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:f13c6ac:             for (Constructor cns : constructors) {
1:f13c6ac:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), true);
1:f13c6ac:                 List<Object> match = matcher.match(args, types);
1:f13c6ac:                 if (match != null) {
1:f13c6ac:                     nmatches.put(cns, match);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             if (nmatches.size() > 0) {
1:f13c6ac:                 matches = nmatches;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return matches;
1:4377012:     }
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Returns init method (if any). Throws exception if the init-method was set explicitly on the bean
1:f13c6ac:      * and the method is not found on the instance.
1:f13c6ac:      */
1:f13c6ac:     protected Method getInitMethod(Object instance) throws ComponentDefinitionException {
1:f13c6ac:         Method method = null;        
1:f13c6ac:         if (initMethod != null && initMethod.length() > 0) {
1:f13c6ac:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), initMethod);
1:f13c6ac:             if (method == null) {
1:f13c6ac:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have init-method: " + initMethod);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return method;
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     /**
1:f13c6ac:      * Returns destroy method (if any). Throws exception if the destroy-method was set explicitly on the bean
1:f13c6ac:      * and the method is not found on the instance.
1:f13c6ac:      */
1:f13c6ac:     public Method getDestroyMethod(Object instance) throws ComponentDefinitionException {
1:f13c6ac:         Method method = null;        
1:ca323c1:         if (instance != null && destroyMethod != null && destroyMethod.length() > 0) {
1:f13c6ac:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), destroyMethod);
1:f13c6ac:             if (method == null) {
1:f13c6ac:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have destroy-method: " + destroyMethod);
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         return method;
1:f13c6ac:     }
1:f13c6ac:     
1:aa58216:     /**
1:aa58216:      * Small helper class, to construct a chain of BeanCreators.
1:aa58216:      * <br> 
1:aa58216:      * Each bean creator in the chain will return a bean that has been 
1:aa58216:      * processed by every BeanProcessor in the chain before it.
1:aa58216:      */
1:aa58216:     private static class BeanCreatorChain implements BeanProcessor.BeanCreator {
1:202eb59:         public enum ChainType{Before,After};
1:08c11fc:         private final BeanProcessor.BeanCreator parentBeanCreator;
1:08c11fc:         private final BeanProcessor parentBeanProcessor;
1:08c11fc:         private final BeanMetadata beanData;
1:08c11fc:         private final String beanName;        
1:08c11fc:         private final ChainType when;
1:aa58216:         public BeanCreatorChain(BeanProcessor.BeanCreator parentBeanCreator, 
1:aa58216:                                 BeanProcessor parentBeanProcessor,
1:aa58216:                                 BeanMetadata beanData,
1:202eb59:                                 String beanName,
1:202eb59:                                 ChainType when){
1:aa58216:             this.parentBeanCreator = parentBeanCreator;
1:aa58216:             this.parentBeanProcessor = parentBeanProcessor;
1:aa58216:             this.beanData = beanData;
1:aa58216:             this.beanName = beanName;
1:202eb59:             this.when = when;
1:4377012:         }
1:f13c6ac: 
1:aa58216:         public Object getBean() {
1:aa58216:             Object previousBean = parentBeanCreator.getBean();
1:202eb59:             Object processed = null;
1:202eb59:             switch(when){
1:202eb59:                 case Before :
1:202eb59:                   processed = parentBeanProcessor.beforeInit(previousBean, beanName, parentBeanCreator, beanData);
1:202eb59:                   break;
1:202eb59:                 case After:
1:202eb59:                   processed = parentBeanProcessor.afterInit(previousBean, beanName, parentBeanCreator, beanData);
1:202eb59:                   break;
1:4377012:             }
1:202eb59:             return processed;
1:4377012:         }   
1:4377012:     }
1:f13c6ac:     
1:202eb59:     private Object runBeanProcPreInit(Object obj){
2:202eb59:         String beanName = getName();
1:202eb59:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:202eb59:           .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
1:202eb59:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
1:d473e9a:         
1:202eb59:         //The start link of the chain, that provides the 
1:202eb59:         //original, unprocessed bean to the head of the chain.
1:202eb59:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
1:202eb59:             public Object getBean() {
1:f13c6ac:                 Object obj = getInstance();
1:202eb59:                 //getinit, getdestroy, addpartial object don't need calling again.
1:202eb59:                 //however, property injection does.
1:202eb59:                 setProperties(obj);
1:202eb59:                 return obj;
1:f13c6ac:             }
1:202eb59:         };
1:f13c6ac: 
1:202eb59:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:202eb59:         for(BeanProcessor processor : processors){
1:202eb59:             obj = processor.beforeInit(obj, getName(), currentCreator, beanData);
1:202eb59:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.Before);
1:5e2bd49:         }
1:202eb59:         return obj;
1:5e2bd49:     }
1:f13c6ac:     
1:202eb59:     private void runBeanProcInit(Method initMethod, Object obj){
1:f13c6ac:         // call init method
1:f13c6ac:         if (initMethod != null) {
1:f13c6ac:             try {
1:3b2c33b:                 invoke(initMethod, obj, (Object[]) null);
1:f13c6ac:             } catch (Throwable t) {
1:2cd0785:                 throw new ComponentDefinitionException("Unable to initialize bean " + getName(), getRealCause(t));
1:5e2bd49:             }
1:cab8bfe:         }   
1:f0b2b91:     }
1:d473e9a:     
1:202eb59:     private Object runBeanProcPostInit(Object obj){
1:bb726ca:         String beanName = getName();
1:202eb59:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:202eb59:           .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
1:202eb59:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
1:d473e9a:         
1:202eb59:         //The start link of the chain, that provides the 
1:202eb59:         //original, unprocessed bean to the head of the chain.
1:202eb59:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
1:202eb59:             public Object getBean() {                                
1:202eb59:                 Object obj = getInstance();
1:202eb59:                 //getinit, getdestroy, addpartial object don't need calling again.
1:202eb59:                 //however, property injection does.
1:202eb59:                 setProperties(obj);
1:202eb59:                 //as this is the post init chain, new beans need to go thru 
1:202eb59:                 //the pre-init chain, and then have init called, before 
1:202eb59:                 //being passed along the post-init chain.
1:202eb59:                 obj = runBeanProcPreInit(obj);
1:202eb59:                 runBeanProcInit(getInitMethod(obj), obj);
1:202eb59:                 return obj;
1:d473e9a:             }
1:202eb59:         };
1:d473e9a: 
1:202eb59:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:202eb59:         for(BeanProcessor processor : processors){
1:202eb59:             obj = processor.afterInit(obj, getName(), currentCreator, beanData);
1:202eb59:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.After);
4:d473e9a:         }
1:202eb59:         return obj;
1:d473e9a:     }    
1:d473e9a:     
1:5e2bd49:     private Object addInterceptors(final Object original, Collection<Class<?>> requiredInterfaces)
1:6a4e3c8:             throws ComponentDefinitionException {
1:d473e9a: 
1:bb726ca:         Object intercepted = null;
1:5e2bd49:         if(requiredInterfaces.isEmpty())
1:5e2bd49:         	requiredInterfaces.add(original.getClass());
1:5e2bd49:         
1:6a4e3c8:         ComponentDefinitionRegistry reg = blueprintContainer
1:6a4e3c8:                 .getComponentDefinitionRegistry();
1:f0b2b91:         List<Interceptor> interceptors = reg.getInterceptors(interceptorLookupKey);
1:6a4e3c8:         if (interceptors != null && interceptors.size() > 0) {
1:f13c6ac:             try {
1:5e2bd49:                 Bundle b = FrameworkUtil.getBundle(original.getClass());
1:5e2bd49:                 if (b == null) {
1:5e2bd49:                     // we have a class from the framework parent, so use our bundle for proxying.
1:5e2bd49:                     b = blueprintContainer.getBundleContext().getBundle();
1:5e2bd49:                 }
1:4dfd2d8:                 intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
1:285f3a8:                 requiredInterfaces, original, CollaboratorFactory.create(interceptorLookupKey, interceptors));
1:24455ce:             } catch (org.apache.aries.proxy.UnableToProxyException e) {
1:5e2bd49:                 Bundle b = blueprintContainer.getBundleContext().getBundle();
1:db4243b:                 throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + "/" + b.getVersion(), e);
1:ef2091c:             }
1:6588a3e:         } else {
1:bb726ca:             intercepted = original;
1:d473e9a:         }
1:bb726ca:         return intercepted;
1:d473e9a:     }
1:d473e9a:         
1:f13c6ac:     @Override
1:f13c6ac:     protected Object internalCreate() throws ComponentDefinitionException {
1:4377012:         if (factory instanceof ReferenceRecipe) {
1:4377012:             ReferenceRecipe rr = (ReferenceRecipe) factory;
1:4377012:             if (rr.getProxyChildBeanClasses() != null) {
1:4377012:                 return createProxyBean(rr);
1:4377012:             }
1:4377012:         } 
1:5e2bd49:         return new UnwrapperedBeanHolder(internalCreate2(), this);
1:4377012:     }
1:4377012:     
1:4377012:     private Object createProxyBean(ReferenceRecipe rr) {
1:f13c6ac:         try {
1:4377012:             VoidableCallable vc = new VoidableCallable();
1:4377012:             rr.addVoidableChild(vc);
1:4377012:             return blueprintContainer.getProxyManager().createDelegatingProxy(
1:4377012:                 blueprintContainer.getBundleContext().getBundle(), rr.getProxyChildBeanClasses(),
1:4377012:                 vc, vc.call());
1:8c4aa3a:         } catch (UnableToProxyException e) {
1:4377012:             throw new ComponentDefinitionException(e);
1:5e2bd49:         }
1:5e2bd49:     }
1:4377012:     
1:5e2bd49:     private Object internalCreate2() throws ComponentDefinitionException {
1:d473e9a:         
1:f13c6ac:         instantiateExplicitDependencies();
1:d473e9a: 
1:202eb59:         Object obj = getInstance();
1:f1ca666:                 
1:f13c6ac:         // check for init lifecycle method (if any)
1:f13c6ac:         Method initMethod = getInitMethod(obj);
1:f1ca666:         
1:f13c6ac:         // check for destroy lifecycle method (if any)
1:f13c6ac:         getDestroyMethod(obj);
1:f13c6ac:         
1:f13c6ac:         // Add partially created object to the container
1:f13c6ac: //        if (initMethod == null) {
1:f13c6ac:             addPartialObject(obj);
1:f13c6ac: //        }
1:f13c6ac: 
1:f13c6ac:         // inject properties
1:f13c6ac:         setProperties(obj);
1:f13c6ac:         
1:202eb59:         obj = runBeanProcPreInit(obj);
1:f13c6ac:         
1:202eb59:         runBeanProcInit(initMethod, obj);
1:f13c6ac:         
1:202eb59:         obj = runBeanProcPostInit(obj);
1:f13c6ac:         
1:5e2bd49:         //Replaced by calling wrap on the UnwrapperedBeanHolder
1:5e2bd49: //        obj = addInterceptors(obj);
1:f13c6ac:         
1:f13c6ac:         return obj;
1:f13c6ac:     }
2:6a4e3c8:     
1:5e2bd49:     static Object wrap(UnwrapperedBeanHolder holder, Collection<Class<?>> requiredViews) {
1:5e2bd49:         return holder.recipe.addInterceptors(holder.unwrapperedBean, requiredViews);
1:f13c6ac:     }
1:5e2bd49:     
1:5e2bd49:     static Object wrap(UnwrapperedBeanHolder holder, Class<?> requiredView) {
1:5e2bd49:         if(requiredView == Object.class) {
1:5e2bd49:           //We don't know what we need so we have to do everything
1:5e2bd49:             return holder.recipe.addInterceptors(holder.unwrapperedBean, new ArrayList<Class<?>>(1));
1:6588a3e:         } else {
1:5e2bd49:         	return holder.recipe.addInterceptors(holder.unwrapperedBean, ProxyUtils.asList(requiredView));
1:f13c6ac:         }
1:f13c6ac:     }
1:5e2bd49:     
1:5e2bd49:     
1:f13c6ac:     @Override
1:f3d0298:     public void destroy(Object obj) {
1:8b0e4b1:         if (!(obj instanceof UnwrapperedBeanHolder)) {
1:8b0e4b1:             LOGGER.warn("Object to be destroyed is not an instance of UnwrapperedBeanHolder, type: " + obj);
1:8b0e4b1:             return;
1:f13c6ac:         }
1:8b0e4b1:     
1:8b0e4b1:         obj = ((UnwrapperedBeanHolder)obj).unwrapperedBean;
1:8b0e4b1:     
2:f13c6ac:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:f13c6ac:             processor.beforeDestroy(obj, getName());
1:f13c6ac:         }
1:f13c6ac:         try {
1:f13c6ac:             Method method = getDestroyMethod(obj);
2:f13c6ac:             if (method != null) {
1:3b2c33b:                 invoke(method, obj, (Object[]) null);
1:f13c6ac:             }
1:84c868d:         } catch (ComponentDefinitionException e) {
1:84c868d:             // This exception occurs if the destroy method does not exist, so we just output the exception message.
1:84c868d:             LOGGER.error(e.getMessage());
1:84c868d:         } catch (InvocationTargetException ite) {
1:84c868d:           Throwable t = ite.getTargetException();
1:84c868d:           BundleContext ctx = blueprintContainer.getBundleContext();
1:84c868d:           Bundle b = ctx.getBundle();
1:db4243b:           LOGGER.error("The blueprint bean {} in bundle {}/{} incorrectly threw an exception from its destroy method.", getName(), b.getSymbolicName(), b.getVersion(), t);
1:f13c6ac:         } catch (Exception e) {
1:84c868d:             BundleContext ctx = blueprintContainer.getBundleContext();
1:84c868d:             Bundle b = ctx.getBundle();
1:db4243b:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean  in bundle {}/{}.", getName(), b.getSymbolicName(), b.getVersion(), getRealCause(e));
1:f13c6ac:         }
1:f13c6ac:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:f13c6ac:             processor.afterDestroy(obj, getName());
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public void setProperties(Object instance) throws ComponentDefinitionException {
1:f13c6ac:         // clone the properties so they can be used again
1:f13c6ac:         Map<String,Object> propertyValues = new LinkedHashMap<String,Object>(properties);
1:f13c6ac:         setProperties(propertyValues, instance, instance.getClass());
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     public Class getType() {
1:f13c6ac:         if (type instanceof Class) {
1:f13c6ac:             return (Class) type;
1:f13c6ac:         } else if (type instanceof String) {
1:f13c6ac:             return loadClass((String) type);
1:f13c6ac:         } else {
1:f13c6ac:             return null;
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void setProperties(Map<String, Object> propertyValues, Object instance, Class clazz) {
1:f13c6ac:         // set remaining properties
1:f13c6ac:         for (Map.Entry<String, Object> entry : propertyValues.entrySet()) {
1:f13c6ac:             String propertyName = entry.getKey();
1:f13c6ac:             Object propertyValue = entry.getValue();
1:f13c6ac: 
1:f13c6ac:             setProperty(instance, clazz, propertyName, propertyValue);
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private void setProperty(Object instance, Class clazz, String propertyName, Object propertyValue) {
1:f13c6ac:         String[] names = propertyName.split("\\.");
1:f13c6ac:         for (int i = 0; i < names.length - 1; i++) {
1:d08aba3:             PropertyDescriptor pd = getPropertyDescriptor(clazz, names[i]);
1:d08aba3:             if (pd.allowsGet()) {
1:f13c6ac:                 try {
1:08c11fc:                     instance = pd.get(instance, blueprintContainer);
1:f13c6ac:                 } catch (Exception e) {
1:f13c6ac:                     throw new ComponentDefinitionException("Error getting property: " + names[i] + " on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName(), getRealCause(e));
1:f13c6ac:                 }
1:f13c6ac:                 if (instance == null) {
1:f13c6ac:                     throw new ComponentDefinitionException("Error setting compound property " + propertyName + " on bean " + getName() + ". Property " + names[i] + " is null");
1:f13c6ac:                 }
1:f13c6ac:                 clazz = instance.getClass();
1:f13c6ac:             } else {
1:f13c6ac:                 throw new ComponentDefinitionException("No getter for " + names[i] + " property on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName());
1:f13c6ac:             }
1:f13c6ac:         }
1:5e2bd49:         
1:cab8bfe:         // Instantiate value
1:f13c6ac:         if (propertyValue instanceof Recipe) {
1:f13c6ac:             propertyValue = ((Recipe) propertyValue).create();
1:f13c6ac:         }
1:cab8bfe: 
1:d08aba3:         final PropertyDescriptor pd = getPropertyDescriptor(clazz, names[names.length - 1]);
1:d08aba3:         if (pd.allowsSet()) {
1:f13c6ac:             try {
1:08c11fc:                 pd.set(instance, propertyValue, blueprintContainer);
1:f13c6ac:             } catch (Exception e) {
1:d08aba3:                 throw new ComponentDefinitionException("Error setting property: " + pd, getRealCause(e));
1:f13c6ac:             }
1:f13c6ac:         } else {
1:f13c6ac:             throw new ComponentDefinitionException("No setter for " + names[names.length - 1] + " property");
1:f13c6ac:         }
1:f13c6ac:     }
1:f13c6ac: 
1:d08aba3:     private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String name) {
1:d08aba3:         for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz, allowsFieldInjection)) {
1:f13c6ac:             if (pd.getName().equals(name)) {
1:f13c6ac:                 return pd;
1:f13c6ac:             }
1:f13c6ac:         }
1:f13c6ac:         throw new ComponentDefinitionException("Unable to find property descriptor " + name + " on class " + clazz.getName());
1:f13c6ac:     }
1:f13c6ac:         
1:f13c6ac:     private Object invoke(Method method, Object instance, Object... args) throws Exception {
1:f13c6ac:         return ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), method, instance, args);        
1:f13c6ac:     }
1:f13c6ac:     
1:f13c6ac:     private Object newInstance(Constructor constructor, Object... args) throws Exception {
1:f13c6ac:         return ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), constructor, args);         
1:f13c6ac:     }
1:ae927fa: 
1:ae927fa:     private String argsToString(List<Object> args) {
1:ae927fa:         Iterator<Object> it = args.iterator();
1:ae927fa:         if (!it.hasNext())
1:ae927fa:             return "[]";
1:ae927fa:         StringBuilder sb = new StringBuilder();
1:ae927fa:         sb.append('[');
1:ae927fa:         for (;;) {
1:ae927fa:             Object e = it.next();
1:ae927fa:             if (e instanceof UnwrapperedBeanHolder) {
1:ae927fa:                 e = ((UnwrapperedBeanHolder) e).unwrapperedBean;
1:ae927fa:             }
1:ae927fa:             sb.append(e).append(" (").append(e.getClass()).append(")");
1:ae927fa:             if (!it.hasNext())
1:ae927fa:                 return sb.append(']').toString();
1:ae927fa:             sb.append(',').append(' ');
1:ae927fa:         }
1:ae927fa:     }
1:f13c6ac:     
1:f13c6ac:     private static Object UNMATCHED = new Object();
1:f13c6ac: 
1:f13c6ac:     private class ArgumentMatcher {
1:f13c6ac: 
1:08c11fc:         private final List<TypeEntry> entries;
1:08c11fc:         private final boolean convert;
1:f13c6ac: 
1:f13c6ac:         public ArgumentMatcher(Type[] types, boolean convert) {
1:f13c6ac:             entries = new ArrayList<TypeEntry>();
1:f13c6ac:             for (Type type : types) {
1:f13c6ac:                 entries.add(new TypeEntry(new GenericType(type)));
1:f13c6ac:             }
1:f13c6ac:             this.convert = convert;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         public List<Object> match(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:f13c6ac:             if (find(arguments, forcedTypes)) {
1:f13c6ac:                 return getArguments();
1:f13c6ac:             }
1:f13c6ac:             return null;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         private List<Object> getArguments() {
1:f13c6ac:             List<Object> list = new ArrayList<Object>();
1:f13c6ac:             for (TypeEntry entry : entries) {
1:f13c6ac:                 if (entry.argument == UNMATCHED) {
1:f13c6ac:                     throw new RuntimeException("There are unmatched types");
1:f13c6ac:                 } else {
1:f13c6ac:                     list.add(entry.argument);
1:f13c6ac:                 }
1:f13c6ac:             }
1:f13c6ac:             return list;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         private boolean find(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:f13c6ac:             if (entries.size() == arguments.size()) {
1:f13c6ac:                 boolean matched = true;
1:f13c6ac:                 for (int i = 0; i < arguments.size() && matched; i++) {
1:f13c6ac:                     matched = find(arguments.get(i), forcedTypes.get(i));
1:f13c6ac:                 }
1:f13c6ac:                 return matched;
1:f13c6ac:             }
1:f13c6ac:             return false;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:         private boolean find(Object arg, ReifiedType forcedType) {
1:f13c6ac:             for (TypeEntry entry : entries) {
1:f13c6ac:                 Object val = arg;
1:f13c6ac:                 if (entry.argument != UNMATCHED) {
1:f13c6ac:                     continue;
1:f13c6ac:                 }
1:f13c6ac:                 if (forcedType != null) {
1:f13c6ac:                     if (!forcedType.equals(entry.type)) {
1:f13c6ac:                         continue;
1:f13c6ac:                     }
1:f13c6ac:                 } else if (arg != null) {
1:f13c6ac:                     if (convert) {
1:5e2bd49:                         
1:5e2bd49:                         if(canConvert(arg, entry.type)) {
1:f13c6ac:                             try {
1:f13c6ac: 								val = convert(arg, entry.type);
1:f13c6ac: 							} catch (Exception e) {
1:5e2bd49: 								throw new ComponentDefinitionException(e);
1:f13c6ac: 							}
1:f13c6ac:                         } else { 
1:f13c6ac:                             continue;
1:f13c6ac:                         }
1:6588a3e:                     } else {
1:5e2bd49:                     	UnwrapperedBeanHolder holder = null;
1:5e2bd49:                         if(arg instanceof UnwrapperedBeanHolder) {
1:5e2bd49:                         	holder = (UnwrapperedBeanHolder)arg;
1:5e2bd49:                         	arg = holder.unwrapperedBean;
1:f13c6ac:                         }
1:f13c6ac:                         if (!AggregateConverter.isAssignable(arg, entry.type)) {
1:f13c6ac:                             continue;
1:5e2bd49:                         } else if (holder != null) {
1:5e2bd49:                             val = wrap(holder, entry.type.getRawClass());
1:f13c6ac:                         }
1:f13c6ac:                     }
1:f13c6ac:                 }
1:f13c6ac:                 entry.argument = val;
1:f13c6ac:                 return true;
1:f13c6ac:             }
1:f13c6ac:             return false;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac:     private static class TypeEntry {
1:f13c6ac: 
1:f13c6ac:         private final ReifiedType type;
1:f13c6ac:         private Object argument;
1:f13c6ac: 
1:f13c6ac:         public TypeEntry(ReifiedType type) {
1:f13c6ac:             this.type = type;
1:f13c6ac:             this.argument = UNMATCHED;
1:f13c6ac:         }
1:f13c6ac: 
1:f13c6ac:     }
1:f13c6ac: 
1:f13c6ac: }
============================================================================
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:ae927fa
/////////////////////////////////////////////////////////////////////////
1:             throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName());
1:             throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + factoryObj.getClass().getName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName() + ": " + matches.keySet());
/////////////////////////////////////////////////////////////////////////
1:             throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName());
1:             throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName() + ": " + matches.keySet());
/////////////////////////////////////////////////////////////////////////
1:             throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName());
1:             throw new ComponentDefinitionException("Multiple matching constructors found on class " + getTypeName() + " for arguments " + argsToString(args) + " when instanciating bean " + getName() + ": " + matches.keySet());
/////////////////////////////////////////////////////////////////////////
1:                     // If the arg is an Unwrappered bean then we need to do the assignment
1:                     // check against the unwrappered bean itself.
1:                     if (arg instanceof UnwrapperedBeanHolder)
/////////////////////////////////////////////////////////////////////////
1:                     // If the arg is an Unwrappered bean then we need to do the assignment
1:                     // check against the unwrappered bean itself.
1:                     if (arg instanceof UnwrapperedBeanHolder)
/////////////////////////////////////////////////////////////////////////
1: 
1:     private String argsToString(List<Object> args) {
1:         Iterator<Object> it = args.iterator();
1:         if (!it.hasNext())
1:             return "[]";
1:         StringBuilder sb = new StringBuilder();
1:         sb.append('[');
1:         for (;;) {
1:             Object e = it.next();
1:             if (e instanceof UnwrapperedBeanHolder) {
1:                 e = ((UnwrapperedBeanHolder) e).unwrapperedBean;
1:             }
1:             sb.append(e).append(" (").append(e.getClass()).append(")");
1:             if (!it.hasNext())
1:                 return sb.append(']').toString();
1:             sb.append(',').append(' ');
1:         }
1:     }
commit:285f3a8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.proxy.CollaboratorFactory;
/////////////////////////////////////////////////////////////////////////
1:                 requiredInterfaces, original, CollaboratorFactory.create(interceptorLookupKey, interceptors));
commit:db4243b
/////////////////////////////////////////////////////////////////////////
1:                 throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + "/" + b.getVersion(), e);
/////////////////////////////////////////////////////////////////////////
1:           LOGGER.error("The blueprint bean {} in bundle {}/{} incorrectly threw an exception from its destroy method.", getName(), b.getSymbolicName(), b.getVersion(), t);
1:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean  in bundle {}/{}.", getName(), b.getSymbolicName(), b.getVersion(), getRealCause(e));
commit:2cd0785
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
1:                 throw new ComponentDefinitionException("Unable to initialize bean " + getName(), getRealCause(t));
commit:4d5683c
/////////////////////////////////////////////////////////////////////////
1:         List<Method> methods = new ArrayList<Method>(Arrays.asList(getPublicMethods(type)));
commit:c9e6b82
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.aries.blueprint.utils.ReflectionUtils.getPublicMethods;
1: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1: 
/////////////////////////////////////////////////////////////////////////
0:         List<Method> methods = getPublicMethods(type);
commit:1fdbc37
/////////////////////////////////////////////////////////////////////////
1:         if (factory != null) {
1:             recipes.add(factory);
1:         }
commit:4dfd2d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1: 
/////////////////////////////////////////////////////////////////////////
1:               intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
commit:8c4aa3a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 intercepted = AsmInterceptorWrapper.createProxyObject(original
0:                         .getClass().getClassLoader(), interceptorLookupKey, interceptors,
0:                         AsmInterceptorWrapper.passThrough(original), original.getClass());
1:             } catch (UnableToProxyException e) {
0:                 throw new ComponentDefinitionException("Unable to create asm proxy", e);
1:             }
commit:071e3fe
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Callable;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 throw new ComponentDefinitionException(
0:                         "Interceptors have been configured but asm is not available",
0:                         t);
0:             // if asm is available we can proxy the original object with the
0:             // AsmInterceptorWrapper
0:             intercepted = AsmInterceptorWrapper.createProxyObject(original
0:                     .getClass().getClassLoader(), interceptorLookupKey, interceptors,
0:                     AsmInterceptorWrapper.passThrough(original), original.getClass());
commit:3b2c33b
/////////////////////////////////////////////////////////////////////////
1:                 invoke(initMethod, obj, (Object[]) null);
/////////////////////////////////////////////////////////////////////////
1:                 invoke(method, obj, (Object[]) null);
/////////////////////////////////////////////////////////////////////////
0:                 invoke(method, instance, (Object[]) null);
/////////////////////////////////////////////////////////////////////////
0:                     instance = invoke(getter, instance, (Object[]) null);
commit:f13c6ac
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
0: package org.apache.geronimo.blueprint.container;
1: 
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.lang.reflect.Type;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.List;
1: import java.util.Map;
1: 
0: import org.apache.geronimo.blueprint.BeanProcessor;
0: import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
0: import org.apache.geronimo.blueprint.di.AbstractRecipe;
0: import org.apache.geronimo.blueprint.di.Recipe;
0: import org.apache.geronimo.blueprint.utils.ReflectionUtils;
0: import static org.apache.geronimo.blueprint.utils.ReflectionUtils.getRealCause;
1: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.container.ComponentDefinitionException;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A <code>Recipe</code> to create POJOs.
1:  *
0:  * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
1:  * @version $Rev$, $Date$
1:  */
1: public class BeanRecipe extends AbstractRecipe {
1: 
1:     private static final Logger LOGGER = LoggerFactory.getLogger(BeanRecipe.class);
1: 
1:     private final ExtendedBlueprintContainer blueprintContainer;
1:     private final LinkedHashMap<String,Object> properties = new LinkedHashMap<String,Object>();
1:     private final Object type;
1: 
1:     private String initMethod;
1:     private String destroyMethod;
1:     private List<Recipe> explicitDependencies;
1:     
1:     private Recipe factory;
1:     private String factoryMethod;
1:     private List<Object> arguments;
1:     private List<String> argTypes;
1:     private boolean reorderArguments;
1: 
1: 
0:     public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type) {
1:         super(name);
1:         this.blueprintContainer = blueprintContainer;
1:         this.type = type;
1:     }
1: 
1:     public Object getProperty(String name) {
1:         return properties.get(name);
1:     }
1: 
1:     public Map<String, Object> getProperties() {
1:         return new LinkedHashMap<String, Object>(properties);
1:     }
1: 
1:     public void setProperty(String name, Object value) {
1:         properties.put(name, value);
1:     }
1: 
1:     public void setFactoryMethod(String method) {
1:         this.factoryMethod = method;
1:     }
1:     
1:     public void setFactoryComponent(Recipe factory) {
1:         this.factory = factory;
1:     }
1:     
1:     public void setArgTypes(List<String> argTypes) {
1:         this.argTypes = argTypes;
1:     }
1:     
1:     public void setArguments(List<Object> arguments) {
1:         this.arguments = arguments;
1:     }
1:     
1:     public void setReorderArguments(boolean reorder) {
1:         this.reorderArguments = reorder;
1:     }
1:     
1:     public void setInitMethod(String initMethod) {
1:         this.initMethod = initMethod;
1:     }
1:     
1:     public String getInitMethod() {
1:         return initMethod;
1:     }
1:     
1:     public void setDestroyMethod(String destroyMethod) {
1:         this.destroyMethod = destroyMethod;
1:     }
1:     
1:     public String getDestroyMethod() {
1:         return destroyMethod;
1:     }
1: 
1:     public List<Recipe> getExplicitDependencies() {
1:         return explicitDependencies;
1:     }
1: 
1:     public void setExplicitDependencies(List<Recipe> explicitDependencies) {
1:         this.explicitDependencies = explicitDependencies;
1:     }
1: 
1:     @Override
1:     public List<Recipe> getConstructorDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         if (explicitDependencies != null) {
1:             recipes.addAll(explicitDependencies);
1:         }
1:         if (arguments != null) {
1:             for (Object argument : arguments) {
1:                 if (argument instanceof Recipe) {
1:                     recipes.add((Recipe)argument);
1:                 }
1:             }
1:         }
1:         return recipes;
1:     }
1:     
1:     public List<Recipe> getDependencies() {
1:         List<Recipe> recipes = new ArrayList<Recipe>();
1:         for (Object o : properties.values()) {
1:             if (o instanceof Recipe) {
1:                 Recipe recipe = (Recipe) o;
1:                 recipes.add(recipe);
1:             }
1:         }
1:         recipes.addAll(getConstructorDependencies());
1:         return recipes; 
1:     }
1: 
1:     private void instantiateExplicitDependencies() {
1:         if (explicitDependencies != null) {
1:             for (Recipe recipe : explicitDependencies) {
1:                 recipe.create();
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     protected Class loadClass(String className) {
1:         ClassLoader loader = type instanceof Class ? ((Class) type).getClassLoader() : null;
1:         ReifiedType t = loadType(className, loader);
1:         return t != null ? t.getRawClass() : null;
1:     }
1: 
1:     @Override
1:     protected ReifiedType loadType(String className) {
1:         return loadType(className, type instanceof Class ? ((Class) type).getClassLoader() : null);
1:     }
1: 
1:     private Object getInstance() throws ComponentDefinitionException {
0:         Object instance;
1:         
1:         // Instanciate arguments
1:         List<Object> args = new ArrayList<Object>();
1:         List<ReifiedType> argTypes = new ArrayList<ReifiedType>();
1:         if (arguments != null) {
1:             for (int i = 0; i < arguments.size(); i++) {
1:                 Object arg = arguments.get(i);
1:                 if (arg instanceof Recipe) {
1:                     args.add(((Recipe) arg).create());
1:                 } else {
1:                     args.add(arg);
1:                 }
1:                 if (this.argTypes != null) {
1:                     argTypes.add(this.argTypes.get(i) != null ? loadType(this.argTypes.get(i)) : null);
1:                 }
1:             }
1:         }
1: 
1:         if (factory != null) {
1:             // look for instance method on factory object
1:             Object factoryObj = factory.create();
1:             // Map of matching methods
1:             Map<Method, List<Object>> matches = findMatchingMethods(factoryObj.getClass(), factoryMethod, true, args, argTypes);
1:             if (matches.size() == 1) {
1:                 try {
1:                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
0:                     instance = invoke(match.getKey(), factoryObj, match.getValue().toArray());
1:                 } catch (Throwable e) {
0:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else if (matches.size() == 0) {
0:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:             } else {
0:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:             }
1:         } else if (factoryMethod != null) {
1:             // Map of matching methods
1:             Map<Method, List<Object>> matches = findMatchingMethods(getType(), factoryMethod, false, args, argTypes);
1:             if (matches.size() == 1) {
1:                 try {
1:                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
0:                     instance = invoke(match.getKey(), null, match.getValue().toArray());
1:                 } catch (Throwable e) {
0:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else if (matches.size() == 0) {
0:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:             } else {
0:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:             }
1:         } else {
1:             if (getType() == null) {
1:                 throw new ComponentDefinitionException("No factoryMethod nor class is defined for this bean");
1:             }
1:             // Map of matching constructors
1:             Map<Constructor, List<Object>> matches = findMatchingConstructors(getType(), args, argTypes);
1:             if (matches.size() == 1) {
1:                 try {
1:                     Map.Entry<Constructor, List<Object>> match = matches.entrySet().iterator().next();
0:                     instance = newInstance(match.getKey(), match.getValue().toArray());
1:                 } catch (Throwable e) {
0:                     throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
1:                 }
1:             } else if (matches.size() == 0) {
0:                 throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:             } else {
0:                 throw new ComponentDefinitionException("Multiple matching constructors found on class " + getType().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:             }
1:         }
1:         
0:         return instance;
1:     }
1: 
1:     private Map<Method, List<Object>> findMatchingMethods(Class type, String name, boolean instance, List<Object> args, List<ReifiedType> types) {
1:         Map<Method, List<Object>> matches = new HashMap<Method, List<Object>>();
1:         // Get constructors
0:         List<Method> methods = new ArrayList<Method>(Arrays.asList(type.getMethods()));
1:         // Discard any signature with wrong cardinality
1:         for (Iterator<Method> it = methods.iterator(); it.hasNext();) {
1:             Method mth = it.next();
1:             if (!mth.getName().equals(name)) {
1:                 it.remove();
1:             } else if (mth.getParameterTypes().length != args.size()) {
1:                 it.remove();
1:             } else if (instance ^ !Modifier.isStatic(mth.getModifiers())) {
1:                 it.remove();
1:             }
1:         }
1:         // Find a direct match with assignment
1:         if (matches.size() != 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
0:                     if (!AggregateConverter.isAssignable(args.get(i), argType)) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
0:                         match.add(convert(args.get(i), mth.getGenericParameterTypes()[i]));
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Find a direct match with conversion
1:         if (matches.size() != 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(mth.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
1:                         Object val = convert(args.get(i), argType);
1:                         match.add(val);
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with assignment
1:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), false);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with conversion
1:         if (matches.size() != 1 && reorderArguments && args.size() > 1) {
1:             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
1:             for (Method mth : methods) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(mth.getGenericParameterTypes(), true);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(mth, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         return matches;
1:     }
1: 
1:     private Map<Constructor, List<Object>> findMatchingConstructors(Class type, List<Object> args, List<ReifiedType> types) {
1:         Map<Constructor, List<Object>> matches = new HashMap<Constructor, List<Object>>();
1:         // Get constructors
1:         List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(type.getConstructors()));
1:         // Discard any signature with wrong cardinality
1:         for (Iterator<Constructor> it = constructors.iterator(); it.hasNext();) {
1:             if (it.next().getParameterTypes().length != args.size()) {
1:                 it.remove();
1:             }
1:         }
1:         // Find a direct match with assignment
1:         if (matches.size() != 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
0:                     if (!AggregateConverter.isAssignable(args.get(i), argType)) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
0:                         match.add(convert(args.get(i), cns.getGenericParameterTypes()[i]));
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Find a direct match with conversion
1:         if (matches.size() != 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 boolean found = true;
1:                 List<Object> match = new ArrayList<Object>();
1:                 for (int i = 0; i < args.size(); i++) {
1:                     ReifiedType argType = new GenericType(cns.getGenericParameterTypes()[i]);
1:                     if (types.get(i) != null && !argType.getRawClass().equals(types.get(i).getRawClass())) {
1:                         found = false;
1:                         break;
1:                     }
1:                     try {
1:                         Object val = convert(args.get(i), argType);
1:                         match.add(val);
1:                     } catch (Throwable t) {
1:                         found = false;
1:                         break;
1:                     }
1:                 }
1:                 if (found) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with assignment
1:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), false);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         // Start reordering with conversion
1:         if (matches.size() != 1 && reorderArguments && arguments.size() > 1) {
1:             Map<Constructor, List<Object>> nmatches = new HashMap<Constructor, List<Object>>();
1:             for (Constructor cns : constructors) {
1:                 ArgumentMatcher matcher = new ArgumentMatcher(cns.getGenericParameterTypes(), true);
1:                 List<Object> match = matcher.match(args, types);
1:                 if (match != null) {
1:                     nmatches.put(cns, match);
1:                 }
1:             }
1:             if (nmatches.size() > 0) {
1:                 matches = nmatches;
1:             }
1:         }
1:         return matches;
1:     }
1: 
1:     /**
1:      * Returns init method (if any). Throws exception if the init-method was set explicitly on the bean
1:      * and the method is not found on the instance.
1:      */
1:     protected Method getInitMethod(Object instance) throws ComponentDefinitionException {
1:         Method method = null;        
1:         if (initMethod != null && initMethod.length() > 0) {
1:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), initMethod);
1:             if (method == null) {
1:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have init-method: " + initMethod);
1:             }
1:         }
1:         return method;
1:     }
1: 
1:     /**
1:      * Returns destroy method (if any). Throws exception if the destroy-method was set explicitly on the bean
1:      * and the method is not found on the instance.
1:      */
1:     public Method getDestroyMethod(Object instance) throws ComponentDefinitionException {
1:         Method method = null;        
0:         if (destroyMethod != null && destroyMethod.length() > 0) {
1:             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), destroyMethod);
1:             if (method == null) {
1:                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have destroy-method: " + destroyMethod);
1:             }
1:         }
1:         return method;
1:     }
1:     
1:     @Override
1:     protected Object internalCreate() throws ComponentDefinitionException {
1:         
1:         instantiateExplicitDependencies();
1: 
1:         Object obj = getInstance();
1:                 
1:         // check for init lifecycle method (if any)
1:         Method initMethod = getInitMethod(obj);
1:         
1:         // check for destroy lifecycle method (if any)
1:         getDestroyMethod(obj);
1:         
1:         // Add partially created object to the container
1: //        if (initMethod == null) {
1:             addPartialObject(obj);
1: //        }
1: 
1:         // inject properties
1:         setProperties(obj);
1: 
1:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
0:             obj = processor.beforeInit(obj, getName());
1:         }
1:         
1:         // call init method
1:         if (initMethod != null) {
1:             try {
0:                 invoke(initMethod, obj, null);
1:             } catch (Throwable t) {
0:                 throw new ComponentDefinitionException("Unable to intialize bean " + getName(), getRealCause(t));
1:             }
1:         }
1:         
1:         return obj;
1:     }
1:     
0:     public void destroyInstance(Object obj) {
1:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:             processor.beforeDestroy(obj, getName());
1:         }
1:         try {
1:             Method method = getDestroyMethod(obj);
1:             if (method != null) {
0:                 invoke(method, obj, null);
1:             }
1:         } catch (Exception e) {
0:             LOGGER.info("Error invoking destroy method", getRealCause(e));
1:         }
1:         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
1:             processor.afterDestroy(obj, getName());
1:         }
1:     }
1: 
1:     @Override
0:     public void destroy(Object instance) {
0:         Method method = getDestroyMethod(instance);
1:         if (method != null) {
1:             try {
0:                 invoke(method, instance, null);
1:             } catch (Throwable e) {
0:                 LOGGER.info("Error destroying bean " + getName(), getRealCause(e));
1:             }
1:         }
1:     }
1: 
1:     public void setProperties(Object instance) throws ComponentDefinitionException {
1:         // clone the properties so they can be used again
1:         Map<String,Object> propertyValues = new LinkedHashMap<String,Object>(properties);
1:         setProperties(propertyValues, instance, instance.getClass());
1:     }
1: 
1:     public Class getType() {
1:         if (type instanceof Class) {
1:             return (Class) type;
1:         } else if (type instanceof String) {
1:             return loadClass((String) type);
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     private void setProperties(Map<String, Object> propertyValues, Object instance, Class clazz) {
1:         // set remaining properties
1:         for (Map.Entry<String, Object> entry : propertyValues.entrySet()) {
1:             String propertyName = entry.getKey();
1:             Object propertyValue = entry.getValue();
1: 
1:             setProperty(instance, clazz, propertyName, propertyValue);
1:         }
1: 
1:     }
1: 
1:     private void setProperty(Object instance, Class clazz, String propertyName, Object propertyValue) {
1:         String[] names = propertyName.split("\\.");
1:         for (int i = 0; i < names.length - 1; i++) {
0:             Method getter = getPropertyDescriptor(clazz, names[i]).getGetter();
0:             if (getter != null) {
1:                 try {
0:                     instance = invoke(getter, instance, null);
1:                 } catch (Exception e) {
1:                     throw new ComponentDefinitionException("Error getting property: " + names[i] + " on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName(), getRealCause(e));
1:                 }
1:                 if (instance == null) {
1:                     throw new ComponentDefinitionException("Error setting compound property " + propertyName + " on bean " + getName() + ". Property " + names[i] + " is null");
1:                 }
1:                 clazz = instance.getClass();
1:             } else {
1:                 throw new ComponentDefinitionException("No getter for " + names[i] + " property on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName());
1:             }
1:         }
0:         Method setter = getPropertyDescriptor(clazz, names[names.length - 1]).getSetter();
0:         if (setter != null) {
0:             // convert the value to type of setter/field
0:             Type type = setter.getGenericParameterTypes()[0];
0:             // Instanciate value
1:             if (propertyValue instanceof Recipe) {
1:                 propertyValue = ((Recipe) propertyValue).create();
1:             }
1:             try {
0:                 propertyValue = convert(propertyValue, type);
1:             } catch (Exception e) {
0:                     String valueType = propertyValue == null ? "null" : propertyValue.getClass().getName();
0:                 String memberType = type instanceof Class ? ((Class) type).getName() : type.toString();
0:                 throw new ComponentDefinitionException("Unable to convert property value" +
0:                         " from " + valueType +
0:                         " to " + memberType +
0:                         " for injection " + setter, e);
1:             }
1:             try {
0:                 // set value
0:                 invoke(setter, instance, propertyValue);
1:             } catch (Exception e) {
0:                 throw new ComponentDefinitionException("Error setting property: " + setter, getRealCause(e));
1:             }
1:         } else {
1:             throw new ComponentDefinitionException("No setter for " + names[names.length - 1] + " property");
1:         }
1:     }
1: 
0:     private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class clazz, String name) {
0:         for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz)) {
1:             if (pd.getName().equals(name)) {
1:                 return pd;
1:             }
1:         }
1:         throw new ComponentDefinitionException("Unable to find property descriptor " + name + " on class " + clazz.getName());
1:     }
1:         
1:     private Object invoke(Method method, Object instance, Object... args) throws Exception {
1:         return ReflectionUtils.invoke(blueprintContainer.getAccessControlContext(), method, instance, args);        
1:     }
1:     
1:     private Object newInstance(Constructor constructor, Object... args) throws Exception {
1:         return ReflectionUtils.newInstance(blueprintContainer.getAccessControlContext(), constructor, args);         
1:     }
1:     
1:     private static Object UNMATCHED = new Object();
1: 
1:     private class ArgumentMatcher {
1: 
0:         private List<TypeEntry> entries;
0:         private boolean convert;
1: 
1:         public ArgumentMatcher(Type[] types, boolean convert) {
1:             entries = new ArrayList<TypeEntry>();
1:             for (Type type : types) {
1:                 entries.add(new TypeEntry(new GenericType(type)));
1:             }
1:             this.convert = convert;
1:         }
1: 
1:         public List<Object> match(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:             if (find(arguments, forcedTypes)) {
1:                 return getArguments();
1:             }
1:             return null;
1:         }
1: 
1:         private List<Object> getArguments() {
1:             List<Object> list = new ArrayList<Object>();
1:             for (TypeEntry entry : entries) {
1:                 if (entry.argument == UNMATCHED) {
1:                     throw new RuntimeException("There are unmatched types");
1:                 } else {
1:                     list.add(entry.argument);
1:                 }
1:             }
1:             return list;
1:         }
1: 
1:         private boolean find(List<Object> arguments, List<ReifiedType> forcedTypes) {
1:             if (entries.size() == arguments.size()) {
1:                 boolean matched = true;
1:                 for (int i = 0; i < arguments.size() && matched; i++) {
1:                     matched = find(arguments.get(i), forcedTypes.get(i));
1:                 }
1:                 return matched;
1:             }
1:             return false;
1:         }
1: 
1:         private boolean find(Object arg, ReifiedType forcedType) {
1:             for (TypeEntry entry : entries) {
1:                 Object val = arg;
1:                 if (entry.argument != UNMATCHED) {
1:                     continue;
1:                 }
1:                 if (forcedType != null) {
1:                     if (!forcedType.equals(entry.type)) {
1:                         continue;
1:                     }
1:                 } else if (arg != null) {
1:                     if (convert) {
1:                         try {
0:                             // TODO: call canConvert instead of convert()
1:                             val = convert(arg, entry.type);
1:                         } catch (Throwable t) {
1:                             continue;
1:                         }
1:                     } else {
1:                         if (!AggregateConverter.isAssignable(arg, entry.type)) {
1:                             continue;
1:                         }
1:                     }
1:                 }
1:                 entry.argument = val;
1:                 return true;
1:             }
1:             return false;
1:         }
1: 
1:     }
1: 
1:     private static class TypeEntry {
1: 
1:         private final ReifiedType type;
1:         private Object argument;
1: 
1:         public TypeEntry(ReifiedType type) {
1:             this.type = type;
1:             this.argument = UNMATCHED;
1:         }
1: 
1:     }
1: 
1: }
author:Christian Schneider
-------------------------------------------------------------------------------
commit:6588a3e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return getInstanceFromFactory(args, argTypes);
1:             return getInstanceFromStaticFactory(args, argTypes);
1:             return getInstanceFromType(args, argTypes);
1:     }
1:     
1:     private Object getInstanceFromFactory(List<Object> args, List<ReifiedType> argTypes) {
1:         Object factoryObj = getFactoryObj();
1:         
0:         // Map of matching methods
0:         Map<Method, List<Object>> matches = findMatchingMethods(factoryObj.getClass(), factoryMethod, true, args, argTypes);
0:         if (matches.size() == 1) {
1:             try {
0:                 Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:                 return invoke(match.getKey(), factoryObj, match.getValue().toArray());
0:             } catch (Throwable e) {
1:                 throw wrapAsCompDefEx(e);
1:             }
0:         } else if (matches.size() == 0) {
0:             throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName());
1:         } else {
0:             throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:         }
1:     }
1: 
1:     private Object getFactoryObj() {
0:         // look for instance method on factory object
0:         Object factoryObj = factory.create();
1:         
1:         // If the factory is a service reference, we need to get hold of the actual proxy for the service
1:         if (factoryObj instanceof ReferenceRecipe.ServiceProxyWrapper) {
1:             try {
1:                 factoryObj = ((ReferenceRecipe.ServiceProxyWrapper) factoryObj).convert(new ReifiedType(Object.class));
1:             } catch (Exception e) {
1:                 throw wrapAsCompDefEx(e);
1:             }
1:         } else if (factoryObj instanceof UnwrapperedBeanHolder) {
1:                 factoryObj = wrap((UnwrapperedBeanHolder) factoryObj, Object.class);
1:         }
1:         return factoryObj;
1:     }
1:     
1:     private Object getInstanceFromStaticFactory(List<Object> args, List<ReifiedType> argTypes) {
0:         // Map of matching methods
0:         Map<Method, List<Object>> matches = findMatchingMethods(getType(), factoryMethod, false, args, argTypes);
0:         if (matches.size() == 1) {
1:             try {
0:                 Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
1:                 return invoke(match.getKey(), null, match.getValue().toArray());
0:             } catch (Throwable e) {
1:                 throw wrapAsCompDefEx(e);
1:             }
0:         } else if (matches.size() == 0) {
0:             throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName());
1:         } else {
0:             throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:         }
1:     }
1: 
1:     private Object getInstanceFromType(List<Object> args, List<ReifiedType> argTypes) {
0:         if (getType() == null) {
0:             throw new ComponentDefinitionException("No factoryMethod nor class is defined for this bean");
1:         }
0:         // Map of matching constructors
0:         Map<Constructor, List<Object>> matches = findMatchingConstructors(getType(), args, argTypes);
0:         if (matches.size() == 1) {
1:             try {
0:                 Map.Entry<Constructor, List<Object>> match = matches.entrySet().iterator().next();
1:                 return newInstance(match.getKey(), match.getValue().toArray());
0:             } catch (Throwable e) {
1:                 throw wrapAsCompDefEx(e);
1:             }
0:         } else if (matches.size() == 0) {
0:             throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName());
1:         } else {
0:             throw new ComponentDefinitionException("Multiple matching constructors found on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:         }
1:     }
1: 
1:     private ComponentDefinitionException wrapAsCompDefEx(Throwable e) {
1:         return new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getTypeName(), getRealCause(e));
commit:adf0ce3
/////////////////////////////////////////////////////////////////////////
1: @SuppressWarnings("rawtypes")
1: 
1:     static class UnwrapperedBeanHolder {
1:         final Object unwrapperedBean;
1:         final BeanRecipe recipe;
1: 
1:         public UnwrapperedBeanHolder(Object unwrapperedBean, BeanRecipe recipe) {
1:             this.unwrapperedBean = unwrapperedBean;
1:             this.recipe = recipe;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getTypeName(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getTypeName(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getTypeName(), getRealCause(e));
0:                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName());
0:                 throw new ComponentDefinitionException("Multiple matching factory methods " + factoryMethod + " found on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getTypeName(), getRealCause(e));
0:                 throw new ComponentDefinitionException("Unable to find a matching constructor on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName());
0:                 throw new ComponentDefinitionException("Multiple matching constructors found on class " + getTypeName() + " for arguments " + args + " when instanciating bean " + getName() + ": " + matches.keySet());
1:     private String getTypeName() {
1:         Class<?> type = getType();
1:         return type == null ? null : type.getName();
1:     }
1: 
author:A. J. David Bosschaert
-------------------------------------------------------------------------------
commit:4f35898
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType().getName(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType().getName(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType().getName(), getRealCause(e));
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType().getName(), getRealCause(e));
author:Sergey Beryozkin
-------------------------------------------------------------------------------
commit:8b0e4b1
/////////////////////////////////////////////////////////////////////////
1:         if (!(obj instanceof UnwrapperedBeanHolder)) {
1:             LOGGER.warn("Object to be destroyed is not an instance of UnwrapperedBeanHolder, type: " + obj);
1:             return;
1:         }
1:     
1:         obj = ((UnwrapperedBeanHolder)obj).unwrapperedBean;
1:     
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:5e2bd49
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	static class UnwrapperedBeanHolder {
0: 		final Object unwrapperedBean;
0: 		final BeanRecipe recipe;
1: 		
0: 		public UnwrapperedBeanHolder(Object unwrapperedBean, BeanRecipe recipe) {
0: 			this.unwrapperedBean = unwrapperedBean;
0: 			this.recipe = recipe;
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
0:             } else if (factoryObj instanceof UnwrapperedBeanHolder) {
0:             	factoryObj = wrap((UnwrapperedBeanHolder) factoryObj, Object.class);
/////////////////////////////////////////////////////////////////////////
0:                     //If the arg is an Unwrappered bean then we need to do the assignment check against the
0:                     //unwrappered bean itself.
1:                     Object arg = args.get(i);
1:                     Object argToTest = arg;
0:                     if(arg instanceof UnwrapperedBeanHolder)
1:                     	argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:                         match.add(convert(arg, mth.getGenericParameterTypes()[i]));
/////////////////////////////////////////////////////////////////////////
0:                     //If the arg is an Unwrappered bean then we need to do the assignment check against the
0:                     //unwrappered bean itself.
1:                     Object arg = args.get(i);
1:                     Object argToTest = arg;
0:                     if(arg instanceof UnwrapperedBeanHolder)
1:                     	argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
1:                     if (!AggregateConverter.isAssignable(argToTest, argType)) {
1:                         match.add(convert(arg, cns.getGenericParameterTypes()[i]));
/////////////////////////////////////////////////////////////////////////
1:     private Object addInterceptors(final Object original, Collection<Class<?>> requiredInterfaces)
1:         if(requiredInterfaces.isEmpty())
1:         	requiredInterfaces.add(original.getClass());
1:         
1:                 Bundle b = FrameworkUtil.getBundle(original.getClass());
1:                 if (b == null) {
1:                     // we have a class from the framework parent, so use our bundle for proxying.
1:                     b = blueprintContainer.getBundleContext().getBundle();
1:                 }
0:                 intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
0:                 requiredInterfaces, original, new Collaborator(interceptorLookupKey, interceptors));
1:                 Bundle b = blueprintContainer.getBundleContext().getBundle();
0:                 throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + " version " + b.getVersion(), e);
/////////////////////////////////////////////////////////////////////////
1:         return new UnwrapperedBeanHolder(internalCreate2(), this);
/////////////////////////////////////////////////////////////////////////
1:     private Object internalCreate2() throws ComponentDefinitionException {
/////////////////////////////////////////////////////////////////////////
1:         //Replaced by calling wrap on the UnwrapperedBeanHolder
1: //        obj = addInterceptors(obj);
1:     static Object wrap(UnwrapperedBeanHolder holder, Collection<Class<?>> requiredViews) {
1:         return holder.recipe.addInterceptors(holder.unwrapperedBean, requiredViews);
1:     }
1:     
1:     static Object wrap(UnwrapperedBeanHolder holder, Class<?> requiredView) {
1:         if(requiredView == Object.class) {
1:           //We don't know what we need so we have to do everything
1:             return holder.recipe.addInterceptors(holder.unwrapperedBean, new ArrayList<Class<?>>(1));
0:         } else {
1:         	return holder.recipe.addInterceptors(holder.unwrapperedBean, ProxyUtils.asList(requiredView));
1:         }
1:     }
1:     
1:     
0:         //This object should *always* be an UnwrapperedBeanHolder, so cast it and get the bean out.
0:     	obj = ((UnwrapperedBeanHolder)obj).unwrapperedBean;
1:     	
/////////////////////////////////////////////////////////////////////////
1:                         
1:                         if(canConvert(arg, entry.type)) {
0:                             try {
0: 								val = convert(arg, entry.type);
0: 							} catch (Exception e) {
1: 								throw new ComponentDefinitionException(e);
1: 							}
0:                         } else { 
1:                     	UnwrapperedBeanHolder holder = null;
1:                         if(arg instanceof UnwrapperedBeanHolder) {
1:                         	holder = (UnwrapperedBeanHolder)arg;
1:                         	arg = holder.unwrapperedBean;
1:                         }
1:                         } else if (holder != null) {
1:                             val = wrap(holder, entry.type.getRawClass());
commit:4377012
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Callable;
1: import java.util.concurrent.Semaphore;
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.UnableToProxyException;
/////////////////////////////////////////////////////////////////////////
1:     public class VoidableCallable implements Callable<Object>, Voidable {
1: 
1:         private final AtomicReference<Object> ref = new AtomicReference<Object>();
1:         
1:         private final Semaphore sem = new Semaphore(1);
1:         
1:         private final ThreadLocal<Object> deadlockDetector = new ThreadLocal<Object>();
1:         
1:         public void voidReference() {
1:             ref.set(null);
1:         }
1: 
1:         public Object call() throws ComponentDefinitionException {
1:             Object o = ref.get();
1:             
1:             if (o == null) {
1:                 if(deadlockDetector.get() != null) {
1:                     deadlockDetector.remove();
1:                     throw new ComponentDefinitionException("Construction cycle detected for bean " + name);
1:                 }
1:                 
1:                 sem.acquireUninterruptibly();
0:                 try {
1:                     o = ref.get();
1:                     if (o == null) {
1:                         deadlockDetector.set(this);
0:                         try {
1:                             o = internalCreate2();
1:                             ref.set(o);
1:                         } finally {
1:                             deadlockDetector.remove();
1:                         }
1:                     }
1:                 } finally {
1:                   sem.release();
1:                 }
1:             }
1:             
1:             return o;
1:         }
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (factory instanceof ReferenceRecipe) {
1:             ReferenceRecipe rr = (ReferenceRecipe) factory;
1:             if (rr.getProxyChildBeanClasses() != null) {
1:                 return createProxyBean(rr);
1:             }
1:         } 
1:         
0:         return internalCreate2();
1:     }
1:     
1:     private Object createProxyBean(ReferenceRecipe rr) {
0:         try {
1:             VoidableCallable vc = new VoidableCallable();
1:             rr.addVoidableChild(vc);
1:             return blueprintContainer.getProxyManager().createDelegatingProxy(
1:                 blueprintContainer.getBundleContext().getBundle(), rr.getProxyChildBeanClasses(),
1:                 vc, vc.call());
0:         } catch (UnableToProxyException e) {
1:             throw new ComponentDefinitionException(e);
1:         }
1:     }
1:     
0:     protected Object internalCreate2() throws ComponentDefinitionException {
commit:69e59b8
/////////////////////////////////////////////////////////////////////////
0:               intercepted = BlueprintExtender.getProxyManager().createInterceptingProxy(b, 
0:                   ProxyUtils.asList(original.getClass()), original, 
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:ca323c1
/////////////////////////////////////////////////////////////////////////
1:         if (instance != null && destroyMethod != null && destroyMethod.length() > 0) {
commit:84c868d
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.BundleContext;
/////////////////////////////////////////////////////////////////////////
1:         } catch (ComponentDefinitionException e) {
1:             // This exception occurs if the destroy method does not exist, so we just output the exception message.
1:             LOGGER.error(e.getMessage());
1:         } catch (InvocationTargetException ite) {
1:           Throwable t = ite.getTargetException();
1:           BundleContext ctx = blueprintContainer.getBundleContext();
1:           Bundle b = ctx.getBundle();
0:           String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
0:           LOGGER.error("The blueprint bean " + getName() + " in bundle " + bundleIdentifier + " incorrectly threw an exception from its destroy method.", t);
1:             BundleContext ctx = blueprintContainer.getBundleContext();
1:             Bundle b = ctx.getBundle();
0:             String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
0:             LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean " + getName() + " in bundle " + bundleIdentifier + ".", getRealCause(e));
commit:ef2091c
/////////////////////////////////////////////////////////////////////////
0:               Bundle b = FrameworkUtil.getBundle(original.getClass());
0:               if (b == null) {
0:                 // we have a class from the framework parent, so use our bundle for proxying.
0:                 b = blueprintContainer.getBundleContext().getBundle();
1:               }
0:               intercepted = BlueprintExtender.getProxyManager().createProxy(b, 
commit:66dc5e9
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Bundle;
/////////////////////////////////////////////////////////////////////////
0:                   Bundle b = blueprintContainer.getBundleContext().getBundle();
0:                   throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + " version " + b.getVersion(), e);
commit:5254613
/////////////////////////////////////////////////////////////////////////
commit:24455ce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.proxy.Collaborator;
1: import org.apache.aries.blueprint.proxy.ProxyUtils;
1: import org.osgi.framework.FrameworkUtil;
/////////////////////////////////////////////////////////////////////////
0:     private Object addInterceptors(final Object original)
/////////////////////////////////////////////////////////////////////////
0:               intercepted = BlueprintExtender.getProxyManager().createProxy(FrameworkUtil.getBundle(original.getClass()), 
0:                   ProxyUtils.asList(original.getClass()), ProxyUtils.passThrough(original), 
0:                   new Collaborator(interceptorLookupKey, interceptors));
1:             } catch (org.apache.aries.proxy.UnableToProxyException e) {
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:09a7647
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
commit:08c11fc
/////////////////////////////////////////////////////////////////////////
1:         private final BeanProcessor.BeanCreator parentBeanCreator;
1:         private final BeanProcessor parentBeanProcessor;
1:         private final BeanMetadata beanData;
1:         private final String beanName;        
1:         private final ChainType when;
/////////////////////////////////////////////////////////////////////////
1:                     instance = pd.get(instance, blueprintContainer);
/////////////////////////////////////////////////////////////////////////
1:                 pd.set(instance, propertyValue, blueprintContainer);
/////////////////////////////////////////////////////////////////////////
1:         private final List<TypeEntry> entries;
1:         private final boolean convert;
commit:bfe66f6
/////////////////////////////////////////////////////////////////////////
commit:cab8bfe
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Instantiate value
0:         if (propertyValue instanceof Recipe) {
0:             propertyValue = ((Recipe) propertyValue).create();
1:         }
1: 
0: //            Type type = pd.getGenericType(propertyValue);
0: //            try {
0: //                propertyValue = convert(propertyValue, type);
0: //            } catch (Exception e) {
0: //                    String valueType = propertyValue == null ? "null" : propertyValue.getClass().getName();
0: //                String memberType = type instanceof Class ? ((Class) type).getName() : type.toString();
0: //                throw new ComponentDefinitionException("Unable to convert property value" +
0: //                        " from " + valueType +
0: //                        " to " + memberType +
0: //                        " for injection " + pd, e);
0: //            }
commit:f0b2b91
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private BeanMetadata interceptorLookupKey;
1:     
/////////////////////////////////////////////////////////////////////////
1:     public void setInterceptorLookupKey(BeanMetadata metadata) {
1:     	interceptorLookupKey = metadata;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         List<Interceptor> interceptors = reg.getInterceptors(interceptorLookupKey);
/////////////////////////////////////////////////////////////////////////
0:                         .getClass().getClassLoader(), interceptorLookupKey, interceptors,
0:                         original.getClass().getClassLoader(), interceptorLookupKey,
commit:d473e9a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1:         
1:         // on some JVMs (J9) hidden static methods are returned by Class.getMethods so we need to weed them out
1:         // to reduce ambiguity
1:         if (!instance) {
1:         	methods = applyStaticHidingRules(methods);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:     
1:     private static List<Method> applyStaticHidingRules(Collection<Method> methods) {
1:     	List<Method> result = new ArrayList<Method>(methods.size());
1:     	for (Method m : methods) {
1:     		boolean toBeAdded = true;
1: 
1:     		Iterator<Method> it = result.iterator();
1:     		inner: while (it.hasNext()) {
1:     			Method other = it.next();
1:     			if (hasIdenticalParameters(m, other)) {
1:     				Class<?> mClass = m.getDeclaringClass();
1:     				Class<?> otherClass = other.getDeclaringClass();
1:     				
1:     				if (mClass.isAssignableFrom(otherClass)) {
1:     					toBeAdded = false;
1:     					break inner;
1:     				} else if (otherClass.isAssignableFrom(mClass)) {
1:     					it.remove();
1:     				}
1:     			}
1:     		}
1:     		
1:     		if (toBeAdded) result.add(m);
1:     	}
1:     	
1:     	return result;
1:     }
1:     
1:     private static boolean hasIdenticalParameters(Method one, Method two) {
1: 		Class<?>[] oneTypes = one.getParameterTypes();
1: 		Class<?>[] twoTypes = two.getParameterTypes();
1:     	
1: 		if (oneTypes.length != twoTypes.length) return false;
1: 		
1: 		for (int i=0; i<oneTypes.length; i++) {
1: 			if (!oneTypes[i].equals(twoTypes[i])) return false;
1: 		}
1: 		
1: 		return true;
1:     }
commit:d08aba3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.utils.ReflectionUtils.PropertyDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     private final boolean allowsFieldInjection;
1:     public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type, boolean allowsFieldInjection) {
1:         this.allowsFieldInjection = allowsFieldInjection;
/////////////////////////////////////////////////////////////////////////
1:             PropertyDescriptor pd = getPropertyDescriptor(clazz, names[i]);
1:             if (pd.allowsGet()) {
0:                     instance = pd.get(instance, blueprintContainer.getAccessControlContext());
/////////////////////////////////////////////////////////////////////////
1:         final PropertyDescriptor pd = getPropertyDescriptor(clazz, names[names.length - 1]);
1:         if (pd.allowsSet()) {
0:             Type type = pd.getGenericType();
/////////////////////////////////////////////////////////////////////////
0:                         " for injection " + pd, e);
0:                 pd.set(instance, propertyValue, blueprintContainer.getAccessControlContext());
1:                 throw new ComponentDefinitionException("Error setting property: " + pd, getRealCause(e));
1:     private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String name) {
1:         for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz, allowsFieldInjection)) {
commit:7c549ab
/////////////////////////////////////////////////////////////////////////
1:             } else if (mth.isBridge()) {
1:                 it.remove();
commit:f1ca666
/////////////////////////////////////////////////////////////////////////
1:             
0:             // If the factory is a service reference, we need to get hold of the actual proxy for the service
0:             if (factoryObj instanceof ReferenceRecipe.ServiceProxyWrapper) {
0:                 try {
0:                     factoryObj = ((ReferenceRecipe.ServiceProxyWrapper) factoryObj).convert(new ReifiedType(Object.class));
0:                 } catch (Exception e) {
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
0:                 }
0:             }
1:             
/////////////////////////////////////////////////////////////////////////
0:                     throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
author:Andrew Osborne
-------------------------------------------------------------------------------
commit:6a4e3c8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.blueprint.proxy.AsmInterceptorWrapper;
/////////////////////////////////////////////////////////////////////////
0:     private Object addInterceptors(Object original)
1:             throws ComponentDefinitionException {
1: 
1:         ComponentDefinitionRegistry reg = blueprintContainer
1:                 .getComponentDefinitionRegistry();
0:         List<Interceptor> interceptors = reg.getInterceptors(metaData);
1:         if (interceptors != null && interceptors.size() > 0) {
0:             boolean asmAvailable = false;
0:                 // Try load load an asm class (to make sure it's actually
0:                 // available)
0:                 getClass().getClassLoader().loadClass(
0:                         "org.objectweb.asm.ClassVisitor");
0:                 LOGGER.debug("asm available for interceptors");
0:                 asmAvailable = true;
0:                 try {
0:                     // Try load load a cglib class (to make sure it's actually
0:                     // available)
0:                     getClass().getClassLoader().loadClass(
0:                             "net.sf.cglib.proxy.Enhancer");
0:                 } catch (Throwable u) {
0:                     throw new ComponentDefinitionException(
0:                             "Interceptors have been configured but neither asm nor cglib are available",
0:                             u);
0:                 }
0:             }
0:             if (asmAvailable) {
0:                 // if asm is available we can proxy the original object with the
0:                 // AsmInterceptorWrapper
0:                 intercepted = AsmInterceptorWrapper.createProxyObject(original
0:                         .getClass().getClassLoader(), metaData, interceptors,
0:                         original, original.getClass());
0:             } else {
0:                 LOGGER.debug("cglib available for interceptors");
0:                 // otherwise we're using cglib and need to use the interfaces
0:                 // with the CgLibInterceptorWrapper
0:                 intercepted = CgLibInterceptorWrapper.createProxyObject(
0:                         original.getClass().getClassLoader(), metaData,
0:                         interceptors, original, original.getClass()
0:                                 .getInterfaces());
0:             }
1: 
0:         } else {
commit:f3d0298
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:     public void destroy(Object obj) {
/////////////////////////////////////////////////////////////////////////
commit:2953ccf
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 // Try load load a cglib class (to make sure it's actually available
0:                 getClass().getClassLoader().loadClass("net.sf.cglib.proxy.Enhancer");
0:             } catch (Throwable t) {
0:                 throw new ComponentDefinitionException("Interceptors have been configured but cglib can not be used", t);
0:             }            
0:             
commit:bb726ca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.ComponentDefinitionRegistry;
1: import org.apache.aries.blueprint.Interceptor;
0: import org.apache.aries.blueprint.container.AbstractServiceReferenceRecipe.CgLibProxyFactory;
0: import org.apache.aries.blueprint.container.AbstractServiceReferenceRecipe.JdkProxyFactory;
0: import org.apache.aries.blueprint.proxy.CgLibInterceptorWrapper;
0: import org.osgi.service.blueprint.reflect.ComponentMetadata;
/////////////////////////////////////////////////////////////////////////
0:     
0:     private Object addInterceptors(Object original) throws ComponentDefinitionException{
0:         
0:         try {
0:             // Try load load a cglib class (to make sure it's actually available
0:             getClass().getClassLoader().loadClass("net.sf.cglib.proxy.Enhancer");
0:         } catch (Throwable t) {
0:             throw new ComponentDefinitionException("Interceptors have been configured but cglib can not be used", t);
0:         }
0:         
1:         Object intercepted = null;
1:         String beanName = getName();
0:         ComponentDefinitionRegistry reg = blueprintContainer.getComponentDefinitionRegistry();
0:         ComponentMetadata metaData = reg.getComponentDefinition(beanName);
0:         List<Interceptor> interceptors = reg.getInterceptors(metaData); 
0:         if(interceptors!=null && interceptors.size()>0){
0:             intercepted = CgLibInterceptorWrapper.createProxyObject(original.getClass().getClassLoader(), 
0:                                                                 metaData, 
0:                                                                 interceptors, 
0:                                                                 original, 
0:                                                                 original.getClass().getInterfaces());
0:         }else{
1:             intercepted = original;
0:         }
1:         return intercepted;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         obj = addInterceptors(obj);
0:         
commit:202eb59
/////////////////////////////////////////////////////////////////////////
1:         public enum ChainType{Before,After};
0:         private String beanName;        
0:         private ChainType when;
1:                                 String beanName,
1:                                 ChainType when){
1:             this.when = when;
1:             Object processed = null;
1:             switch(when){
1:                 case Before :
1:                   processed = parentBeanProcessor.beforeInit(previousBean, beanName, parentBeanCreator, beanData);
1:                   break;
1:                 case After:
1:                   processed = parentBeanProcessor.afterInit(previousBean, beanName, parentBeanCreator, beanData);
1:                   break;
0:             }
1:             return processed;
0:     
1:     private Object runBeanProcPreInit(Object obj){
1:         String beanName = getName();
1:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:           .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
1:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
0:         
1:         //The start link of the chain, that provides the 
1:         //original, unprocessed bean to the head of the chain.
1:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
1:             public Object getBean() {
1:                 Object obj = getInstance();
1:                 //getinit, getdestroy, addpartial object don't need calling again.
1:                 //however, property injection does.
1:                 setProperties(obj);
1:                 return obj;
0:             }
1:         };
0: 
1:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:         for(BeanProcessor processor : processors){
1:             obj = processor.beforeInit(obj, getName(), currentCreator, beanData);
1:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.Before);
0:         }
1:         return obj;
0:     }
0:     
1:     private void runBeanProcInit(Method initMethod, Object obj){
0:         // call init method
0:         if (initMethod != null) {
0:             try {
0:                 invoke(initMethod, obj, (Object[]) null);
0:             } catch (Throwable t) {
0:                 throw new ComponentDefinitionException("Unable to intialize bean " + getName(), getRealCause(t));
0:             }
0:         }   
0:     }
0:     
1:     private Object runBeanProcPostInit(Object obj){
1:         String beanName = getName();
1:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
1:           .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
1:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
0:         
1:         //The start link of the chain, that provides the 
1:         //original, unprocessed bean to the head of the chain.
1:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
1:             public Object getBean() {                                
1:                 Object obj = getInstance();
1:                 //getinit, getdestroy, addpartial object don't need calling again.
1:                 //however, property injection does.
1:                 setProperties(obj);
1:                 //as this is the post init chain, new beans need to go thru 
1:                 //the pre-init chain, and then have init called, before 
1:                 //being passed along the post-init chain.
1:                 obj = runBeanProcPreInit(obj);
1:                 runBeanProcInit(getInitMethod(obj), obj);
1:                 return obj;
0:             }
1:         };
0: 
1:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
1:         for(BeanProcessor processor : processors){
1:             obj = processor.afterInit(obj, getName(), currentCreator, beanData);
1:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.After);
0:         }
1:         return obj;
0:     }    
/////////////////////////////////////////////////////////////////////////
1:         obj = runBeanProcPreInit(obj);
1:         runBeanProcInit(initMethod, obj);
1:         obj = runBeanProcPostInit(obj);
commit:aa58216
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.blueprint.container.ReifiedType;
1: import org.osgi.service.blueprint.reflect.BeanMetadata;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Small helper class, to construct a chain of BeanCreators.
1:      * <br> 
1:      * Each bean creator in the chain will return a bean that has been 
1:      * processed by every BeanProcessor in the chain before it.
1:      */
1:     private static class BeanCreatorChain implements BeanProcessor.BeanCreator {
0:         private BeanProcessor.BeanCreator parentBeanCreator;
0:         private BeanProcessor parentBeanProcessor;
0:         private BeanMetadata beanData;
0:         private String beanName;
1:         public BeanCreatorChain(BeanProcessor.BeanCreator parentBeanCreator, 
1:                                 BeanProcessor parentBeanProcessor,
1:                                 BeanMetadata beanData,
0:                                 String beanName){
1:             this.parentBeanCreator = parentBeanCreator;
1:             this.parentBeanProcessor = parentBeanProcessor;
1:             this.beanData = beanData;
1:             this.beanName = beanName;
0:         }
0: 
1:         public Object getBean() {
1:             Object previousBean = parentBeanCreator.getBean();
0:             return parentBeanProcessor.beforeInit(previousBean, beanName, parentBeanCreator, beanData);
0:         }   
0:     }
0:         
/////////////////////////////////////////////////////////////////////////
0:         
0:         String beanName = getName();
0:         BeanMetadata beanData = (BeanMetadata) blueprintContainer
0:           .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
0:         List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
0:         
0:         //The start link of the chain, that provides the 
0:         //original, unprocessed bean to the head of the chain.
0:         BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
0:             public Object getBean() {
0:                 Object obj = getInstance();
0:                 //getinit, getdestroy, addpartial object don't need calling again.
0:                 //however, property injection does.
0:                 setProperties(obj);
0:                 return obj;
0:             }
0:         };
0:         BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
0:         for(BeanProcessor processor : processors){
0:             obj = processor.beforeInit(obj, getName(), currentCreator, beanData);
0:             currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName);
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:de68801
/////////////////////////////////////////////////////////////////////////
commit:6414875
/////////////////////////////////////////////////////////////////////////
1: package org.apache.aries.blueprint.container;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.blueprint.BeanProcessor;
0: import org.apache.aries.blueprint.ExtendedBlueprintContainer;
1: import org.apache.aries.blueprint.di.AbstractRecipe;
1: import org.apache.aries.blueprint.di.Recipe;
1: import org.apache.aries.blueprint.utils.ReflectionUtils;
0: import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
============================================================================