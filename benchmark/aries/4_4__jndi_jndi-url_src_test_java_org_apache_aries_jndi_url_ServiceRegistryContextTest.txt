1:87e8fb4: /*
1:87e8fb4:  * Licensed to the Apache Software Foundation (ASF) under one
1:87e8fb4:  * or more contributor license agreements.  See the NOTICE file
1:87e8fb4:  * distributed with this work for additional information
1:87e8fb4:  * regarding copyright ownership.  The ASF licenses this file
1:87e8fb4:  * to you under the Apache License, Version 2.0 (the
1:87e8fb4:  * "License"); you may not use this file except in compliance
1:87e8fb4:  * with the License.  You may obtain a copy of the License at
1:87e8fb4:  *
1:87e8fb4:  *   http://www.apache.org/licenses/LICENSE-2.0
1:87e8fb4:  *
1:87e8fb4:  * Unless required by applicable law or agreed to in writing,
1:87e8fb4:  * software distributed under the License is distributed on an
1:3c19a77:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:87e8fb4:  * KIND, either express or implied.  See the License for the
1:87e8fb4:  * specific language governing permissions and limitations
1:87e8fb4:  * under the License.
1:87e8fb4:  */
1:87e8fb4: package org.apache.aries.jndi.url;
8:87e8fb4: 
1:87e8fb4: import static org.junit.Assert.assertEquals;
1:87e8fb4: import static org.junit.Assert.assertFalse;
1:87e8fb4: import static org.junit.Assert.assertNotNull;
1:87e8fb4: import static org.junit.Assert.assertTrue;
1:b792590: import static org.junit.Assert.fail;
1:87e8fb4: 
1:e19d5ba: import java.lang.reflect.InvocationHandler;
1:e19d5ba: import java.lang.reflect.Method;
1:e19d5ba: import java.lang.reflect.Proxy;
1:ba5ec82: import java.sql.SQLException;
1:e19d5ba: import java.util.Collection;
1:87e8fb4: import java.util.Hashtable;
1:e19d5ba: import java.util.Iterator;
1:87e8fb4: import java.util.Properties;
1:e19d5ba: import java.util.concurrent.Callable;
1:87e8fb4: 
1:87e8fb4: import javax.naming.Binding;
1:87e8fb4: import javax.naming.Context;
1:87e8fb4: import javax.naming.InitialContext;
1:87e8fb4: import javax.naming.NameClassPair;
1:87e8fb4: import javax.naming.NameNotFoundException;
1:87e8fb4: import javax.naming.NamingEnumeration;
1:87e8fb4: import javax.naming.NamingException;
1:87e8fb4: import javax.naming.spi.ObjectFactory;
1:ba5ec82: import javax.sql.DataSource;
1:87e8fb4: 
1:c20c37b: import org.apache.aries.jndi.api.JNDIConstants;
1:e9395b8: import org.apache.aries.mocks.BundleContextMock;
1:e9395b8: import org.apache.aries.mocks.BundleMock;
1:e19d5ba: import org.apache.aries.proxy.ProxyManager;
1:e9395b8: import org.apache.aries.unittest.mocks.MethodCall;
1:e19d5ba: import org.apache.aries.unittest.mocks.MethodCallHandler;
1:e9395b8: import org.apache.aries.unittest.mocks.Skeleton;
1:87e8fb4: import org.junit.After;
1:87e8fb4: import org.junit.Before;
1:87e8fb4: import org.junit.Test;
1:87e8fb4: import org.osgi.framework.Bundle;
1:87e8fb4: import org.osgi.framework.BundleContext;
1:e100639: import org.osgi.framework.Constants;
1:b792590: import org.osgi.framework.ServiceException;
1:87e8fb4: import org.osgi.framework.ServiceFactory;
1:87e8fb4: import org.osgi.framework.ServiceReference;
1:87e8fb4: import org.osgi.framework.ServiceRegistration;
1:87e8fb4: 
1:87e8fb4: /**
1:87e8fb4:  * Tests for our JNDI implementation for the service registry.
1:87e8fb4:  */
1:87e8fb4: public class ServiceRegistryContextTest
1:87e8fb4: {
1:87e8fb4:   /** The service we register by default */
1:e9395b8:   private Runnable service;
1:87e8fb4:   /** The bundle context for the test */
1:87e8fb4:   private BundleContext bc;
1:87e8fb4:   /** The service registration for the service */
1:87e8fb4:   private ServiceRegistration reg;
1:87e8fb4:   
1:87e8fb4:   /**
1:87e8fb4:    * This method does the setup to ensure we always have a service.
1:87e8fb4:    * @throws NamingException 
1:87e8fb4:    * @throws NoSuchFieldException 
1:87e8fb4:    * @throws SecurityException 
1:87e8fb4:    * @throws IllegalAccessException 
1:87e8fb4:    * @throws IllegalArgumentException 
1:87e8fb4:    */
1:87e8fb4:   @Before
1:87e8fb4:   public void registerService() throws NamingException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException 
1:87e8fb4:   {
1:87e8fb4:     bc =  Skeleton.newMock(new BundleContextMock(), BundleContext.class);
1:e19d5ba:     registerProxyManager();
1:87e8fb4:     new org.apache.aries.jndi.startup.Activator().start(bc);
1:7b2544b:     new Activator().start(bc);
1:7b2544b:         
1:e9395b8:     service = Skeleton.newMock(Runnable.class);
1:87e8fb4:     
1:87e8fb4:     registerService(service);
2:87e8fb4:   }
1:87e8fb4:   
1:e19d5ba:   private void registerProxyManager() 
1:e19d5ba:   {
1:e19d5ba:     ProxyManager mgr = Skeleton.newMock(ProxyManager.class);
1:e19d5ba:     
1:1e75fdb:     //   public Object createDelegatingProxy(Bundle clientBundle, Collection<Class<?>> classes, Callable<Object> dispatcher, Object template) throws UnableToProxyException;
1:e19d5ba: 
1:1e75fdb:     Skeleton.getSkeleton(mgr).registerMethodCallHandler(new MethodCall(ProxyManager.class, "createDelegatingProxy", Bundle.class, Collection.class, Callable.class, Object.class),
1:e19d5ba:         new MethodCallHandler() 
1:e19d5ba:         {
1:e19d5ba:           public Object handle(MethodCall methodCall, Skeleton skeleton) throws Exception 
1:e19d5ba:           {
1:e19d5ba:             @SuppressWarnings("unchecked")
1:e19d5ba:             Collection<Class<?>> interfaceClasses = (Collection<Class<?>>) methodCall.getArguments()[1];
1:e19d5ba:             Class<?>[] classes = new Class<?>[interfaceClasses.size()];
1:e19d5ba:             
1:e19d5ba:             Iterator<Class<?>> it = interfaceClasses.iterator(); 
1:e19d5ba:             for (int i = 0; it.hasNext(); i++) {
1:e19d5ba:               classes[i] = it.next();
1:e19d5ba:             }
1:e19d5ba:             
1:e19d5ba:             @SuppressWarnings("unchecked")
1:e19d5ba:             final Callable<Object> target = (Callable<Object>) methodCall.getArguments()[2];
1:e19d5ba:             
1:e19d5ba:             return Proxy.newProxyInstance(this.getClass().getClassLoader(), classes, new InvocationHandler() 
1:e19d5ba:             {
1:e19d5ba:               public Object invoke(Object mock, Method method, Object[] arguments)
1:e19d5ba:                   throws Throwable 
1:e19d5ba:               {
1:e19d5ba:                 return method.invoke(target.call(), arguments);
1:e19d5ba:               }
1:e19d5ba:             });
1:e19d5ba:           }
1:e19d5ba:         });
1:e19d5ba:     
1:e19d5ba:     bc.registerService(ProxyManager.class.getName(), mgr, null);
1:e19d5ba:   }
1:e19d5ba: 
1:87e8fb4:   /**
1:87e8fb4:    * Register a service in our map.
1:87e8fb4:    * 
1:87e8fb4:    * @param service2 The service to register.
1:87e8fb4:    */
1:e9395b8:   private void registerService(Runnable service2)
1:87e8fb4:   {
1:87e8fb4:     ServiceFactory factory = Skeleton.newMock(ServiceFactory.class);
1:87e8fb4:     Skeleton skel = Skeleton.getSkeleton(factory);
1:87e8fb4:     
1:87e8fb4:     skel.setReturnValue(new MethodCall(ServiceFactory.class, "getService", Bundle.class, ServiceRegistration.class), service2);
1:87e8fb4:     
1:87e8fb4:     Hashtable<String, String> props = new Hashtable<String, String>();
1:87e8fb4:     props.put("rubbish", "smelly");
1:87e8fb4:     
1:87e8fb4:     reg = bc.registerService(new String[] {"java.lang.Runnable"}, factory, props);
1:87e8fb4:   }
1:87e8fb4:   
1:87e8fb4:   /**
1:87e8fb4:    * Make sure we clear the caches out before the next test.
1:87e8fb4:    */
1:87e8fb4:   @After
1:87e8fb4:   public void teardown()
1:87e8fb4:   {
1:87e8fb4:     BundleContextMock.clear();
1:87e8fb4:     
1:87e8fb4:     Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
1:87e8fb4:   }
1:87e8fb4:   
1:a724dca:   @Test
1:a724dca:   public void testBaseLookup() throws NamingException
1:a724dca:   {
1:a724dca:      BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:a724dca:         
1:a724dca:      Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:a724dca: 
1:a724dca:      InitialContext ctx = new InitialContext();
1:a724dca:      
1:a724dca:      Context ctx2 = (Context) ctx.lookup("osgi:service");
1:a724dca:      
1:e65b402:      Runnable r1 = (Runnable) ctx2.lookup("java.lang.Runnable");   
1:e65b402:      assertNotNull(r1);
1:e65b402:      assertTrue("expected proxied service class", r1 != service);
1:a724dca:      
1:e65b402:      Runnable r2 = (Runnable) ctx.lookup("aries:services/java.lang.Runnable");
1:e65b402:      assertNotNull(r2);
1:e65b402:      assertTrue("expected non-proxied service class", r2 == service);
1:a724dca:   }
1:a724dca:   
1:c20c37b:   @Test
1:c20c37b:   public void testLookupWithPause() throws NamingException
1:c20c37b:   {
1:c20c37b:      BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:c20c37b:         
1:c20c37b:      Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:c20c37b: 
1:c20c37b:      Hashtable<Object, Object> env = new Hashtable<Object, Object>();
1:c20c37b:      env.put(JNDIConstants.REBIND_TIMEOUT, 1000);
1:c20c37b:      
1:c20c37b:      InitialContext ctx = new InitialContext(env);
1:c20c37b:      
1:c20c37b:      Context ctx2 = (Context) ctx.lookup("osgi:service");
1:c20c37b:      
1:c20c37b:      Runnable r1 = (Runnable) ctx2.lookup("java.lang.Runnable");   
1:c20c37b:      
1:c20c37b:      reg.unregister();
1:c20c37b:      
1:c20c37b:      long startTime = System.currentTimeMillis();
1:c20c37b:      
1:c20c37b:      try {
1:c20c37b:        r1.run();
1:c20c37b:        fail("Should have received an exception");
1:c20c37b:      } catch (ServiceException e) {
1:c20c37b:        long endTime = System.currentTimeMillis();
1:c20c37b:        long diff = endTime - startTime;
1:c20c37b:        
1:c20c37b:        assertTrue("The run method did not fail in the expected time (1s): " + diff, diff >= 1000);
1:c20c37b:      }
1:c20c37b:   }
1:c20c37b:   
1:87e8fb4:   /**
1:87e8fb4:    * This test checks that we correctly register and deregister the url context
1:87e8fb4:    * object factory in the service registry.
1:87e8fb4:    */
3:87e8fb4:   @Test
1:87e8fb4:   public void testJNDIRegistration()
1:87e8fb4:   {
1:87e8fb4:     ServiceReference ref = bc.getServiceReference(ObjectFactory.class.getName());
1:87e8fb4:     
1:87e8fb4:     assertNotNull("The aries url context object factory was not registered", ref);
1:87e8fb4:     
1:87e8fb4:     ObjectFactory factory = (ObjectFactory) bc.getService(ref);
1:87e8fb4:     
1:87e8fb4:     assertNotNull("The aries url context object factory was null", factory);
1:87e8fb4:   }
1:87e8fb4:   
1:ba5ec82:   @Test
1:ba5ec82:   public void jndiLookupServiceNameTest() throws NamingException, SQLException
1:ba5ec82:   {
1:ba5ec82:     InitialContext ctx = new InitialContext(new Hashtable<Object, Object>());
1:ba5ec82:     
1:ba5ec82:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:ba5ec82:     
1:ba5ec82:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:ba5ec82:     
1:ba5ec82:     DataSource first = Skeleton.newMock(DataSource.class);
1:ba5ec82:     DataSource second = Skeleton.newMock(DataSource.class);
1:ba5ec82:     
1:ba5ec82:     Hashtable<String, String> properties = new Hashtable<String, String>();
1:ba5ec82:     properties.put("osgi.jndi.service.name", "jdbc/myDataSource");
1:ba5ec82:     
1:ba5ec82:     bc.registerService(DataSource.class.getName(), first, properties);
1:ba5ec82: 
1:ba5ec82:     properties = new Hashtable<String, String>();
1:ba5ec82:     properties.put("osgi.jndi.service.name", "jdbc/myDataSource2");
1:ba5ec82:     
1:ba5ec82:     bc.registerService(DataSource.class.getName(), second, properties);
1:ba5ec82:     
1:ba5ec82:     DataSource s = (DataSource) ctx.lookup("osgi:service/jdbc/myDataSource");
1:ba5ec82:     
1:ba5ec82:     assertNotNull(s);
1:ba5ec82:     
1:ba5ec82:     s = (DataSource) ctx.lookup("osgi:service/javax.sql.DataSource/(osgi.jndi.service.name=jdbc/myDataSource2)");
1:ba5ec82:     
1:ba5ec82:     assertNotNull(s);
1:ba5ec82:     
1:ba5ec82:     s.isWrapperFor(DataSource.class); // don't care about the method, just need to call something.
1:ba5ec82:     
1:ba5ec82:     Skeleton.getSkeleton(second).assertCalled(new MethodCall(DataSource.class, "isWrapperFor", Class.class));
1:ba5ec82:   }
1:ba5ec82:   
1:87e8fb4:   /**
1:87e8fb4:    * This test does a simple JNDI lookup to prove that works.
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   @Test
1:87e8fb4:   public void simpleJNDILookup() throws NamingException
1:87e8fb4:   {
1:87e8fb4:     System.setProperty(Context.URL_PKG_PREFIXES, "helloMatey");
1:87e8fb4:         
1:87e8fb4:     InitialContext ctx = new InitialContext(new Hashtable<Object, Object>());
1:87e8fb4:     
1:7b2544b:     BundleMock mock = new BundleMock("scooby.doo.1", new Properties());
1:87e8fb4:     
1:87e8fb4:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:87e8fb4:     
1:e65b402:     Runnable s = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:87e8fb4:     
1:87e8fb4:     assertNotNull("We didn't get a service back from our lookup :(", s);
1:87e8fb4:     
1:e9395b8:     s.run();
1:e9395b8:     
1:e9395b8:     Skeleton.getSkeleton(service).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:87e8fb4:     
1:87e8fb4:     Skeleton skel = Skeleton.getSkeleton(mock.getBundleContext());
1:87e8fb4:     
1:e100639:     skel.assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", null));
1:87e8fb4: 
1:7b2544b:     ctx = new InitialContext(new Hashtable<Object, Object>());
1:7b2544b:     
1:7b2544b:     mock = new BundleMock("scooby.doo.2", new Properties());
1:87e8fb4:     
1:87e8fb4:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:87e8fb4: 
1:e9395b8:     s = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:87e8fb4:     
1:87e8fb4:     // Check we have the packages set correctly
1:87e8fb4:     
1:87e8fb4:     String packages = System.getProperty(Context.URL_PKG_PREFIXES, null);
1:87e8fb4:     
1:87e8fb4:     assertTrue(ctx.getEnvironment().containsValue(packages));
1:e9395b8: 
1:87e8fb4:     assertNotNull("We didn't get a service back from our lookup :(", s);
1:87e8fb4: 
1:e9395b8:     s.run();
1:87e8fb4:     
1:e9395b8:     Skeleton.getSkeleton(service).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 2);
1:7b2544b:        
1:87e8fb4:     skel = Skeleton.getSkeleton(mock.getBundleContext());
1:e100639:     skel.assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", null));
1:87e8fb4:   }
1:87e8fb4: 
1:87e8fb4:   /**
1:87e8fb4:    * This test checks that we can pass a filter in without things blowing up.
1:87e8fb4:    * Right now our mock service registry does not implement filtering, so the
1:87e8fb4:    * effect is the same as simpleJNDILookup, but we at least know it is not
1:87e8fb4:    * blowing up.
1:87e8fb4:    * 
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   @Test
1:87e8fb4:   public void jndiLookupWithFilter() throws NamingException
1:87e8fb4:   {
1:e9395b8:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:e9395b8:     
1:e9395b8:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:e9395b8: 
1:87e8fb4:     InitialContext ctx = new InitialContext();
1:87e8fb4:     
1:e65b402:     Object s = ctx.lookup("osgi:service/java.lang.Runnable/(rubbish=smelly)");
1:87e8fb4:     
1:87e8fb4:     assertNotNull("We didn't get a service back from our lookup :(", s);
1:87e8fb4:     
1:e9395b8:     service.run();
1:e9395b8:     
1:e9395b8:     Skeleton.getSkeleton(service).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:87e8fb4: 
1:e9395b8:     Skeleton.getSkeleton(mock.getBundleContext()).assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", "(rubbish=smelly)"));
1:87e8fb4:   }
1:87e8fb4:   
1:87e8fb4:   /**
1:87e8fb4:    * Check that we get a NameNotFoundException if we lookup after the service
1:87e8fb4:    * has been unregistered.
1:87e8fb4:    * 
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   @Test(expected=NameNotFoundException.class)
1:87e8fb4:   public void testLookupWhenServiceHasBeenRemoved() throws NamingException
1:87e8fb4:   {
1:87e8fb4:     reg.unregister();
1:e9395b8: 
1:e9395b8:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:e9395b8:     
1:e9395b8:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:e9395b8: 
1:87e8fb4:     InitialContext ctx = new InitialContext();
1:87e8fb4:     
1:e65b402:     ctx.lookup("osgi:service/java.lang.Runnable");
1:87e8fb4:   }
1:87e8fb4:   
1:87e8fb4:   /**
1:87e8fb4:    * Check that we get a NameNotFoundException if we lookup something not in the
1:87e8fb4:    * registry.
1:87e8fb4:    * 
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   @Test(expected=NameNotFoundException.class)
1:87e8fb4:   public void testLookupForServiceWeNeverHad() throws NamingException
1:87e8fb4:   {
1:e9395b8:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:e9395b8:     
1:e9395b8:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:e9395b8: 
1:87e8fb4:     InitialContext ctx = new InitialContext();
1:87e8fb4:     
1:e65b402:     ctx.lookup("osgi:service/java.lang.Integer");
1:87e8fb4:   }
1:87e8fb4:   
1:87e8fb4:   /**
1:87e8fb4:    * This test checks that we can list the contents of the repository using the
1:87e8fb4:    * list method
1:87e8fb4:    * 
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   public void listRepositoryContents() throws NamingException
1:87e8fb4:   {
1:87e8fb4:     InitialContext ctx = new InitialContext();
1:87e8fb4:     
1:e65b402:     NamingEnumeration<NameClassPair> serviceList = ctx.list("osgi:service/java.lang.Runnable/(rubbish=smelly)");
1:87e8fb4:     
1:87e8fb4:     checkThreadRetrievedViaListMethod(serviceList);
1:87e8fb4:     
1:87e8fb4:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:e100639:     
1:87e8fb4:     //Now add a second service
1:e100639:     
1:87e8fb4:     registerService(new Thread());
1:87e8fb4:     
1:e65b402:     serviceList = ctx.list("osgi:service/java.lang.Runnable/(rubbish=smelly)");
1:87e8fb4:     
1:87e8fb4:     checkThreadRetrievedViaListMethod(serviceList);
1:87e8fb4:     
1:87e8fb4:     checkThreadRetrievedViaListMethod(serviceList);
1:87e8fb4:     
1:87e8fb4:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:87e8fb4:   }
1:87e8fb4: 
1:e100639:   @Test
1:e9395b8:   public void checkProxyDynamism() throws NamingException
1:e100639:   {
1:e9395b8:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:e9395b8:     
1:e9395b8:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:e9395b8: 
1:e100639:     InitialContext ctx = new InitialContext();
1:87e8fb4:     
1:e100639:     String className = Runnable.class.getName();
1:e100639:     
1:e9395b8:     Runnable t = Skeleton.newMock(Runnable.class);
1:e9395b8:     Runnable t2 = Skeleton.newMock(Runnable.class);
1:e9395b8:     
1:e9395b8:     // we don't want the default service
1:e9395b8:     reg.unregister();
1:e9395b8:     
1:e9395b8:     ServiceRegistration reg = bc.registerService(className, t, null);
1:e9395b8:     bc.registerService(className, t2, null);
1:e9395b8:     
1:e9395b8:     Runnable r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:e9395b8:     
1:e9395b8:     r.run();
1:e9395b8:     
1:e9395b8:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:e9395b8:     Skeleton.getSkeleton(t2).assertNotCalled(new MethodCall(Runnable.class, "run"));
1:e9395b8:     
1:e9395b8:     reg.unregister();
1:e9395b8:     
1:e9395b8:     r.run();
1:e9395b8:     
1:e9395b8:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:e9395b8:     Skeleton.getSkeleton(t2).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:b792590:   }
1:b792590:   
1:b792590:   @Test
1:b792590:   public void checkServiceListLookup() throws NamingException
1:b792590:   {
1:b792590:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:b792590:     
1:b792590:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:b792590: 
1:b792590:     InitialContext ctx = new InitialContext();
1:b792590:     
1:b792590:     String className = Runnable.class.getName();
1:b792590:     
1:b792590:     Runnable t = Skeleton.newMock(Runnable.class);
1:b792590:     
1:b792590:     // we don't want the default service
1:b792590:     reg.unregister();
1:e9395b8:     
1:b792590:     ServiceRegistration reg = bc.registerService(className, t, null);
1:b792590:     ServiceRegistration reg2 = bc.registerService("java.lang.Thread", new Thread(), null);
1:b792590:     
1:b792590:     Context ctx2 = (Context) ctx.lookup("osgi:servicelist/java.lang.Runnable");
1:b792590:     
1:b792590:     Runnable r = (Runnable) ctx2.lookup(String.valueOf(reg.getReference().getProperty(Constants.SERVICE_ID)));
1:b792590: 
1:b792590:     r.run();
1:b792590:     
1:b792590:     Skeleton.getSkeleton(t).assertCalled(new MethodCall(Runnable.class, "run"));
1:b792590:     
1:b792590:     reg.unregister();
1:b792590:     
1:b792590:     try {
1:b792590:       r.run();
1:b792590:       fail("Should have received a ServiceException");
1:b792590:     } catch (ServiceException e) {
1:b792590:       assertEquals("service exception has the wrong type", ServiceException.UNREGISTERED, e.getType());
1:b792590:     }
1:b792590:     
1:b792590:     try {
1:b792590:       ctx2.lookup(String.valueOf(reg2.getReference().getProperty(Constants.SERVICE_ID)));
1:b792590:       fail("Expected a NameNotFoundException");
1:b792590:     } catch (NameNotFoundException e) {
1:b792590:     }
1:b792590:   }
1:b792590:   
1:b792590:   @Test
1:b792590:   public void checkServiceListList() throws NamingException
1:b792590:   {
1:b792590:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:b792590:     
1:b792590:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:b792590: 
1:b792590:     InitialContext ctx = new InitialContext();
1:b792590:     
1:b792590:     String className = Runnable.class.getName();
1:b792590:     
1:b792590:     Runnable t = Skeleton.newMock(Runnable.class);
1:b792590:     
1:b792590:     // we don't want the default service
1:b792590:     reg.unregister();
1:b792590:     
1:b792590:     ServiceRegistration reg = bc.registerService(className, t, null);
1:b792590:     ServiceRegistration reg2 = bc.registerService(className, new Thread(), null);
1:b792590:     
1:b792590:     NamingEnumeration<NameClassPair> ne = ctx.list("osgi:servicelist/" + className);
1:b792590:     
1:b792590:     assertTrue(ne.hasMoreElements());
1:b792590:     
1:b792590:     NameClassPair ncp = ne.nextElement();
1:b792590:     
1:b792590:     assertEquals(String.valueOf(reg.getReference().getProperty(Constants.SERVICE_ID)), ncp.getName());
1:b792590:     assertTrue("Class name not correct. Was: " + ncp.getClassName(), ncp.getClassName().contains("Proxy"));
1:b792590:     
1:b792590:     assertTrue(ne.hasMoreElements());
1:b792590:     
1:b792590:     ncp = ne.nextElement();
1:b792590:     
1:b792590:     assertEquals(String.valueOf(reg2.getReference().getProperty(Constants.SERVICE_ID)), ncp.getName());
1:b792590:     assertEquals("Class name not correct.", Thread.class.getName(), ncp.getClassName());
1:b792590:     
1:b792590:     assertFalse(ne.hasMoreElements());
1:b792590:   }
1:b792590: 
1:b792590:   @Test
1:b792590:   public void checkServiceListListBindings() throws NamingException
1:b792590:   {
1:b792590:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:b792590:     
1:b792590:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:b792590: 
1:b792590:     InitialContext ctx = new InitialContext();
1:b792590:     
1:b792590:     String className = Runnable.class.getName();
1:b792590:     
1:b792590:     MethodCall run = new MethodCall(Runnable.class, "run");
1:b792590:     
1:b792590:     Runnable t = Skeleton.newMock(Runnable.class);
1:b792590:     Runnable t2 = Skeleton.newMock(Runnable.class);
1:b792590:     
1:b792590:     // we don't want the default service
1:b792590:     reg.unregister();
1:b792590:     
1:b792590:     ServiceRegistration reg = bc.registerService(className, t, null);
1:b792590:     ServiceRegistration reg2 = bc.registerService(className, t2, null);
1:b792590:     
1:b792590:     NamingEnumeration<Binding> ne = ctx.listBindings("osgi:servicelist/" + className);
1:b792590:     
1:b792590:     assertTrue(ne.hasMoreElements());
1:b792590:     
1:b792590:     Binding bnd = ne.nextElement();
1:b792590:     
1:b792590:     assertEquals(String.valueOf(reg.getReference().getProperty(Constants.SERVICE_ID)), bnd.getName());
1:f8842fe:     assertTrue("Class name not correct. Was: " + bnd.getClassName(), bnd.getClassName().contains("Proxy") || bnd.getClassName().contains("EnhancerByCGLIB"));
1:b792590:     
1:b792590:     Runnable r = (Runnable) bnd.getObject();
1:b792590:     
1:a724dca:     assertNotNull(r);
1:b792590:     
1:b792590:     r.run();
1:b792590:     
1:b792590:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(run, 1);
1:b792590:     Skeleton.getSkeleton(t2).assertNotCalled(run);
1:b792590:     
1:b792590:     assertTrue(ne.hasMoreElements());
1:b792590:     
1:b792590:     bnd = ne.nextElement();
1:b792590:     
1:b792590:     assertEquals(String.valueOf(reg2.getReference().getProperty(Constants.SERVICE_ID)), bnd.getName());
1:f8842fe:     assertTrue("Class name not correct. Was: " + bnd.getClassName(), bnd.getClassName().contains("Proxy") || bnd.getClassName().contains("EnhancerByCGLIB"));
1:b792590:     
1:b792590:     r = (Runnable) bnd.getObject();
1:b792590:     
2:b792590:     assertNotNull(r);
1:b792590:     
1:b792590:     r.run();
1:b792590:     
1:b792590:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(run, 1);
1:b792590:     Skeleton.getSkeleton(t2).assertCalledExactNumberOfTimes(run, 1);
1:b792590:     
1:b792590:     assertFalse(ne.hasMoreElements());
1:b792590:   }
1:b792590: 
1:b792590:   @Test(expected=ServiceException.class)
1:b792590:   public void checkProxyWhenServiceGoes() throws ServiceException, NamingException
1:b792590:   {
1:b792590:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:b792590:     
1:b792590:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:b792590: 
1:b792590:     InitialContext ctx = new InitialContext();
1:b792590:     
1:b792590:     Runnable r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:b792590:     
1:b792590:     r.run();
1:b792590:     
1:b792590:     Skeleton.getSkeleton(service).assertCalled(new MethodCall(Runnable.class, "run"));
1:b792590:     
1:b792590:     reg.unregister();
1:b792590:     
1:b792590:     r.run();
1:b792590:   }
1:b792590:   
1:e9395b8:   @Test
1:e9395b8:   public void checkServiceOrderObserved() throws NamingException
1:e9395b8:   {
1:e9395b8:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:e9395b8:     
1:e9395b8:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:e9395b8: 
1:e9395b8:     InitialContext ctx = new InitialContext();
1:e9395b8:     
1:e9395b8:     String className = Runnable.class.getName();
1:e9395b8:     
1:e9395b8:     Runnable t = Skeleton.newMock(Runnable.class);
1:e9395b8:     Runnable t2 = Skeleton.newMock(Runnable.class);
1:e9395b8:     
1:e100639:     // we don't want the default service
1:e100639:     reg.unregister();
1:e100639:     
1:e100639:     ServiceRegistration reg = bc.registerService(className, t, null);
1:e100639:     ServiceRegistration reg2 = bc.registerService(className, t2, null);
1:e100639:     
1:e9395b8:     Runnable r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:e100639:     
1:e9395b8:     r.run();
1:e100639:     
1:e9395b8:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:e9395b8:     Skeleton.getSkeleton(t2).assertNotCalled(new MethodCall(Runnable.class, "run"));
1:87e8fb4:     
1:e100639:     reg.unregister();
1:e100639:     reg2.unregister();
1:e100639:     
1:e100639:     Hashtable<String, Object> props = new Hashtable<String, Object>();
1:e100639:     props.put(Constants.SERVICE_RANKING, 55);
1:e100639:     
1:e9395b8:     t = Skeleton.newMock(Runnable.class);
1:e9395b8:     t2 = Skeleton.newMock(Runnable.class);
1:e9395b8: 
1:5240f2a:     bc.registerService(className, t, null);
1:5240f2a:     bc.registerService(className, t2, props);
1:e100639:     
1:e9395b8:     r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:e9395b8:     
1:e9395b8:     r.run();
1:e100639:     
1:e9395b8:     Skeleton.getSkeleton(t).assertNotCalled(new MethodCall(Runnable.class, "run"));
1:e9395b8:     Skeleton.getSkeleton(t2).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:e9395b8:   }
1:e100639:   
1:87e8fb4:   /**
1:87e8fb4:    * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
1:87e8fb4:    * @param serviceList
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   private void checkThreadRetrievedViaListMethod(NamingEnumeration<NameClassPair> serviceList)
1:87e8fb4:       throws NamingException
1:87e8fb4:   {
1:87e8fb4:     assertTrue("The repository was empty", serviceList.hasMoreElements());
1:87e8fb4:     
1:87e8fb4:     NameClassPair ncp = serviceList.next();
1:87e8fb4:     
1:87e8fb4:     assertNotNull("We didn't get a service back from our lookup :(", ncp);
1:87e8fb4:     
1:87e8fb4:     assertNotNull("The object from the SR was null", ncp.getClassName());
1:87e8fb4:     
1:87e8fb4:     assertEquals("The service retrieved was not of the correct type", "java.lang.Thread", ncp.getClassName());
1:87e8fb4:     
1:e65b402:     assertEquals("osgi:service/java.lang.Runnable/(rubbish=smelly)", ncp.getName().toString());
1:e100639:   }
1:87e8fb4:   
1:87e8fb4:   /**
1:87e8fb4:    * This test checks that we can list the contents of the repository using the
1:87e8fb4:    * list method
1:87e8fb4:    * 
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   public void listRepositoryBindings() throws NamingException
1:87e8fb4:   {
1:87e8fb4:     InitialContext ctx = new InitialContext();
1:87e8fb4:     
1:e65b402:     NamingEnumeration<Binding> serviceList = ctx.listBindings("osgi:service/java.lang.Runnable/(rubbish=smelly)");
1:87e8fb4:     
1:87e8fb4:     Object returnedService = checkThreadRetrievedViaListBindingsMethod(serviceList);
1:87e8fb4:     
1:87e8fb4:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:87e8fb4:     
1:87e8fb4:     assertTrue("The returned service was not the service we expected", returnedService == service);
1:87e8fb4:     
1:87e8fb4:     //Now add a second service
1:87e8fb4:     Thread secondService = new Thread();
1:87e8fb4:     registerService(secondService);
1:87e8fb4:     
1:e65b402:     serviceList = ctx.listBindings("osgi:service/java.lang.Runnable/(rubbish=smelly)");
1:87e8fb4:     
1:87e8fb4:     Object returnedService1 = checkThreadRetrievedViaListBindingsMethod(serviceList);
1:87e8fb4:     
1:87e8fb4:     Object returnedService2 = checkThreadRetrievedViaListBindingsMethod(serviceList);
1:87e8fb4:     
1:87e8fb4:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:87e8fb4:     
1:87e8fb4:     assertTrue("The services were not the ones we expected!",(returnedService1 == service || returnedService2 == service) && (returnedService1 == secondService || returnedService2 == secondService) && (returnedService1 != returnedService2));
1:87e8fb4:     
1:87e8fb4:   }
1:87e8fb4: 
1:87e8fb4:   /**
1:87e8fb4:    * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
1:87e8fb4:    * @param serviceList
1:87e8fb4:    * @return the object in the registry
1:87e8fb4:    * @throws NamingException
1:87e8fb4:    */
1:87e8fb4:   private Object checkThreadRetrievedViaListBindingsMethod(NamingEnumeration<Binding> serviceList)
1:87e8fb4:       throws NamingException
1:87e8fb4:   {
1:87e8fb4:     assertTrue("The repository was empty", serviceList.hasMoreElements());
1:87e8fb4:     
1:87e8fb4:     Binding binding = serviceList.nextElement();
1:87e8fb4:     
1:87e8fb4:     assertNotNull("We didn't get a service back from our lookup :(", binding);
1:87e8fb4:     
1:87e8fb4:     assertNotNull("The object from the SR was null", binding.getObject());
1:87e8fb4:     
1:87e8fb4:     assertTrue("The service retrieved was not of the correct type", binding.getObject() instanceof Thread);
1:87e8fb4:     
1:e65b402:     assertEquals("osgi:service/java.lang.Runnable/(rubbish=smelly)", binding.getName().toString());
1:87e8fb4:     
1:87e8fb4:     return binding.getObject();
1:87e8fb4:   }
1:87e8fb4:   
1:87e8fb4: }
============================================================================
author:Timothy James Ward
-------------------------------------------------------------------------------
commit:1e75fdb
/////////////////////////////////////////////////////////////////////////
1:     //   public Object createDelegatingProxy(Bundle clientBundle, Collection<Class<?>> classes, Callable<Object> dispatcher, Object template) throws UnableToProxyException;
1:     Skeleton.getSkeleton(mgr).registerMethodCallHandler(new MethodCall(ProxyManager.class, "createDelegatingProxy", Bundle.class, Collection.class, Callable.class, Object.class),
commit:69e59b8
/////////////////////////////////////////////////////////////////////////
0:     Skeleton.getSkeleton(mgr).registerMethodCallHandler(new MethodCall(ProxyManager.class, "createDelegatingProxy", Bundle.class, Collection.class, Callable.class),
author:Alasdair Nottingham
-------------------------------------------------------------------------------
commit:c20c37b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.jndi.api.JNDIConstants;
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testLookupWithPause() throws NamingException
1:   {
1:      BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:         
1:      Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:      Hashtable<Object, Object> env = new Hashtable<Object, Object>();
1:      env.put(JNDIConstants.REBIND_TIMEOUT, 1000);
1:      
1:      InitialContext ctx = new InitialContext(env);
1:      
1:      Context ctx2 = (Context) ctx.lookup("osgi:service");
1:      
1:      Runnable r1 = (Runnable) ctx2.lookup("java.lang.Runnable");   
1:      
1:      reg.unregister();
1:      
1:      long startTime = System.currentTimeMillis();
1:      
1:      try {
1:        r1.run();
1:        fail("Should have received an exception");
1:      } catch (ServiceException e) {
1:        long endTime = System.currentTimeMillis();
1:        long diff = endTime - startTime;
1:        
1:        assertTrue("The run method did not fail in the expected time (1s): " + diff, diff >= 1000);
1:      }
1:   }
1:   
commit:e19d5ba
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationHandler;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Proxy;
1: import java.util.Collection;
1: import java.util.Iterator;
1: import java.util.concurrent.Callable;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.aries.proxy.ProxyManager;
1: import org.apache.aries.unittest.mocks.MethodCallHandler;
/////////////////////////////////////////////////////////////////////////
1:     registerProxyManager();
/////////////////////////////////////////////////////////////////////////
1:   private void registerProxyManager() 
1:   {
1:     ProxyManager mgr = Skeleton.newMock(ProxyManager.class);
1:     
0:     //   public Object createProxy(Bundle clientBundle, Collection<Class<?>> classes, Callable<Object> dispatcher) throws UnableToProxyException;
1: 
0:     Skeleton.getSkeleton(mgr).registerMethodCallHandler(new MethodCall(ProxyManager.class, "createProxy", Bundle.class, Collection.class, Callable.class),
1:         new MethodCallHandler() 
1:         {
1:           public Object handle(MethodCall methodCall, Skeleton skeleton) throws Exception 
1:           {
1:             @SuppressWarnings("unchecked")
1:             Collection<Class<?>> interfaceClasses = (Collection<Class<?>>) methodCall.getArguments()[1];
1:             Class<?>[] classes = new Class<?>[interfaceClasses.size()];
1:             
1:             Iterator<Class<?>> it = interfaceClasses.iterator(); 
1:             for (int i = 0; it.hasNext(); i++) {
1:               classes[i] = it.next();
1:             }
1:             
1:             @SuppressWarnings("unchecked")
1:             final Callable<Object> target = (Callable<Object>) methodCall.getArguments()[2];
1:             
1:             return Proxy.newProxyInstance(this.getClass().getClassLoader(), classes, new InvocationHandler() 
1:             {
1:               public Object invoke(Object mock, Method method, Object[] arguments)
1:                   throws Throwable 
1:               {
1:                 return method.invoke(target.call(), arguments);
1:               }
1:             });
1:           }
1:         });
1:     
1:     bc.registerService(ProxyManager.class.getName(), mgr, null);
1:   }
1: 
commit:3a658a8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:a724dca
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void testBaseLookup() throws NamingException
1:   {
1:      BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:         
1:      Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:      InitialContext ctx = new InitialContext();
1:      
1:      Context ctx2 = (Context) ctx.lookup("osgi:service");
1:      
0:      Runnable r = (Runnable) ctx2.lookup("java.lang.Runnable");
1:      
1:      assertNotNull(r);
1:   }
1:   
commit:ba5ec82
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.DataSource;
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void jndiLookupServiceNameTest() throws NamingException, SQLException
1:   {
1:     InitialContext ctx = new InitialContext(new Hashtable<Object, Object>());
1:     
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:     
1:     DataSource first = Skeleton.newMock(DataSource.class);
1:     DataSource second = Skeleton.newMock(DataSource.class);
1:     
1:     Hashtable<String, String> properties = new Hashtable<String, String>();
1:     properties.put("osgi.jndi.service.name", "jdbc/myDataSource");
1:     
1:     bc.registerService(DataSource.class.getName(), first, properties);
1: 
1:     properties = new Hashtable<String, String>();
1:     properties.put("osgi.jndi.service.name", "jdbc/myDataSource2");
1:     
1:     bc.registerService(DataSource.class.getName(), second, properties);
1:     
1:     DataSource s = (DataSource) ctx.lookup("osgi:service/jdbc/myDataSource");
1:     
1:     assertNotNull(s);
1:     
1:     s = (DataSource) ctx.lookup("osgi:service/javax.sql.DataSource/(osgi.jndi.service.name=jdbc/myDataSource2)");
1:     
1:     assertNotNull(s);
1:     
1:     s.isWrapperFor(DataSource.class); // don't care about the method, just need to call something.
1:     
1:     Skeleton.getSkeleton(second).assertCalled(new MethodCall(DataSource.class, "isWrapperFor", Class.class));
1:   }
1:   
commit:5240f2a
/////////////////////////////////////////////////////////////////////////
1:     bc.registerService(className, t, null);
1:     bc.registerService(className, t2, props);
commit:b792590
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.ServiceException;
/////////////////////////////////////////////////////////////////////////
1:   }
1:   
1:   @Test
1:   public void checkServiceListLookup() throws NamingException
1:   {
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:     InitialContext ctx = new InitialContext();
1:     
1:     String className = Runnable.class.getName();
1:     
1:     Runnable t = Skeleton.newMock(Runnable.class);
1:     
1:     // we don't want the default service
1:     reg.unregister();
1:     
1:     ServiceRegistration reg = bc.registerService(className, t, null);
1:     ServiceRegistration reg2 = bc.registerService("java.lang.Thread", new Thread(), null);
1:     
1:     Context ctx2 = (Context) ctx.lookup("osgi:servicelist/java.lang.Runnable");
1:     
1:     Runnable r = (Runnable) ctx2.lookup(String.valueOf(reg.getReference().getProperty(Constants.SERVICE_ID)));
1: 
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertCalled(new MethodCall(Runnable.class, "run"));
1:     
1:     reg.unregister();
1:     
1:     try {
1:       r.run();
1:       fail("Should have received a ServiceException");
1:     } catch (ServiceException e) {
1:       assertEquals("service exception has the wrong type", ServiceException.UNREGISTERED, e.getType());
1:     }
1:     
1:     try {
1:       ctx2.lookup(String.valueOf(reg2.getReference().getProperty(Constants.SERVICE_ID)));
1:       fail("Expected a NameNotFoundException");
1:     } catch (NameNotFoundException e) {
1:     }
1:   }
1:   
1:   @Test
1:   public void checkServiceListList() throws NamingException
1:   {
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:     InitialContext ctx = new InitialContext();
1:     
1:     String className = Runnable.class.getName();
1:     
1:     Runnable t = Skeleton.newMock(Runnable.class);
1:     
1:     // we don't want the default service
1:     reg.unregister();
1:     
1:     ServiceRegistration reg = bc.registerService(className, t, null);
1:     ServiceRegistration reg2 = bc.registerService(className, new Thread(), null);
1:     
1:     NamingEnumeration<NameClassPair> ne = ctx.list("osgi:servicelist/" + className);
1:     
1:     assertTrue(ne.hasMoreElements());
1:     
1:     NameClassPair ncp = ne.nextElement();
1:     
1:     assertEquals(String.valueOf(reg.getReference().getProperty(Constants.SERVICE_ID)), ncp.getName());
1:     assertTrue("Class name not correct. Was: " + ncp.getClassName(), ncp.getClassName().contains("Proxy"));
1:     
1:     assertTrue(ne.hasMoreElements());
1:     
1:     ncp = ne.nextElement();
1:     
1:     assertEquals(String.valueOf(reg2.getReference().getProperty(Constants.SERVICE_ID)), ncp.getName());
1:     assertEquals("Class name not correct.", Thread.class.getName(), ncp.getClassName());
1:     
1:     assertFalse(ne.hasMoreElements());
1:   }
1: 
1:   @Test
1:   public void checkServiceListListBindings() throws NamingException
1:   {
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:     InitialContext ctx = new InitialContext();
1:     
1:     String className = Runnable.class.getName();
1:     
1:     MethodCall run = new MethodCall(Runnable.class, "run");
1:     
1:     Runnable t = Skeleton.newMock(Runnable.class);
1:     Runnable t2 = Skeleton.newMock(Runnable.class);
1:     
1:     // we don't want the default service
1:     reg.unregister();
1:     
1:     ServiceRegistration reg = bc.registerService(className, t, null);
1:     ServiceRegistration reg2 = bc.registerService(className, t2, null);
1:     
1:     NamingEnumeration<Binding> ne = ctx.listBindings("osgi:servicelist/" + className);
1:     
1:     assertTrue(ne.hasMoreElements());
1:     
1:     Binding bnd = ne.nextElement();
1:     
1:     assertEquals(String.valueOf(reg.getReference().getProperty(Constants.SERVICE_ID)), bnd.getName());
0:     assertTrue("Class name not correct. Was: " + bnd.getClassName(), bnd.getClassName().contains("Proxy"));
1:     
1:     Runnable r = (Runnable) bnd.getObject();
1:     
1:     assertNotNull(r);
1:     
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(run, 1);
1:     Skeleton.getSkeleton(t2).assertNotCalled(run);
1:     
1:     assertTrue(ne.hasMoreElements());
1:     
1:     bnd = ne.nextElement();
1:     
1:     assertEquals(String.valueOf(reg2.getReference().getProperty(Constants.SERVICE_ID)), bnd.getName());
0:     assertTrue("Class name not correct. Was: " + bnd.getClassName(), bnd.getClassName().contains("Proxy"));
1:     
1:     r = (Runnable) bnd.getObject();
1:     
1:     assertNotNull(r);
1:     
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(run, 1);
1:     Skeleton.getSkeleton(t2).assertCalledExactNumberOfTimes(run, 1);
1:     
1:     assertFalse(ne.hasMoreElements());
1:   }
1: 
1:   @Test(expected=ServiceException.class)
1:   public void checkProxyWhenServiceGoes() throws ServiceException, NamingException
1:   {
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:     InitialContext ctx = new InitialContext();
1:     
1:     Runnable r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:     
1:     r.run();
1:     
1:     Skeleton.getSkeleton(service).assertCalled(new MethodCall(Runnable.class, "run"));
1:     
1:     reg.unregister();
1:     
1:     r.run();
1:   }
1:   
commit:e9395b8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.jndi.ContextHelper;
0: import org.apache.aries.jndi.OSGiObjectFactoryBuilder;
1: import org.apache.aries.mocks.BundleContextMock;
1: import org.apache.aries.mocks.BundleMock;
1: import org.apache.aries.unittest.mocks.MethodCall;
1: import org.apache.aries.unittest.mocks.Skeleton;
/////////////////////////////////////////////////////////////////////////
1:   private Runnable service;
/////////////////////////////////////////////////////////////////////////
0:     Field f = ContextHelper.class.getDeclaredField("context");
/////////////////////////////////////////////////////////////////////////
1:     service = Skeleton.newMock(Runnable.class);
/////////////////////////////////////////////////////////////////////////
1:   private void registerService(Runnable service2)
/////////////////////////////////////////////////////////////////////////
0:     Runnable s = (Runnable) ctx.lookup("aries:services/java.lang.Runnable");
1:     s.run();
1:     
1:     Skeleton.getSkeleton(service).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
/////////////////////////////////////////////////////////////////////////
1:     s = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
/////////////////////////////////////////////////////////////////////////
1: 
1:     s.run();
1:     Skeleton.getSkeleton(service).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 2);
/////////////////////////////////////////////////////////////////////////
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:     service.run();
1:     Skeleton.getSkeleton(service).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1: 
1:     Skeleton.getSkeleton(mock.getBundleContext()).assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", "(rubbish=smelly)"));
/////////////////////////////////////////////////////////////////////////
1: 
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
/////////////////////////////////////////////////////////////////////////
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
/////////////////////////////////////////////////////////////////////////
1:   public void checkProxyDynamism() throws NamingException
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:     Runnable t = Skeleton.newMock(Runnable.class);
1:     Runnable t2 = Skeleton.newMock(Runnable.class);
1:     
1:     // we don't want the default service
1:     reg.unregister();
1:     
1:     ServiceRegistration reg = bc.registerService(className, t, null);
1:     bc.registerService(className, t2, null);
1:     
1:     Runnable r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:     
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:     Skeleton.getSkeleton(t2).assertNotCalled(new MethodCall(Runnable.class, "run"));
1:     
1:     reg.unregister();
1:     
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:     Skeleton.getSkeleton(t2).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:   }  
1: 
1:   @Test
1:   public void checkServiceOrderObserved() throws NamingException
1:   {
1:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
1:     InitialContext ctx = new InitialContext();
1:     
1:     String className = Runnable.class.getName();
1:     
1:     Runnable t = Skeleton.newMock(Runnable.class);
1:     Runnable t2 = Skeleton.newMock(Runnable.class);
/////////////////////////////////////////////////////////////////////////
1:     Runnable r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
1:     Skeleton.getSkeleton(t2).assertNotCalled(new MethodCall(Runnable.class, "run"));
/////////////////////////////////////////////////////////////////////////
1:     t = Skeleton.newMock(Runnable.class);
1:     t2 = Skeleton.newMock(Runnable.class);
1: 
1:     r = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
1:     r.run();
1:     
1:     Skeleton.getSkeleton(t).assertNotCalled(new MethodCall(Runnable.class, "run"));
1:     Skeleton.getSkeleton(t2).assertCalledExactNumberOfTimes(new MethodCall(Runnable.class, "run"), 1);
commit:b2858b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e100639
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertSame;
/////////////////////////////////////////////////////////////////////////
1: import org.osgi.framework.Constants;
/////////////////////////////////////////////////////////////////////////
1:     skel.assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", null));
/////////////////////////////////////////////////////////////////////////
1:     skel.assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", null));
/////////////////////////////////////////////////////////////////////////
0:     Skeleton.getSkeleton(bc).assertCalled(new MethodCall(BundleContext.class, "getServiceReferences", "java.lang.Runnable", "(rubbish=smelly)"));
/////////////////////////////////////////////////////////////////////////
1:   @Test
0:   public void checkServiceOrderObserved() throws NamingException
1:   {
1:     InitialContext ctx = new InitialContext();
1:     
1:     String className = Runnable.class.getName();
1:     
0:     Thread t = new Thread();
0:     Thread t2 = new Thread();
1:     
1:     // we don't want the default service
1:     reg.unregister();
1:     
1:     ServiceRegistration reg = bc.registerService(className, t, null);
1:     ServiceRegistration reg2 = bc.registerService(className, t2, null);
1:     
0:     Runnable r = (Runnable) ctx.lookup("osgi:services/java.lang.Runnable");
1:     
0:     assertSame("The wrong runnable was returned", t, r);
1:     
1:     reg.unregister();
1:     reg2.unregister();
1:     
1:     Hashtable<String, Object> props = new Hashtable<String, Object>();
1:     props.put(Constants.SERVICE_RANKING, 55);
1:     
0:     reg = bc.registerService(className, t, null);
0:     reg2 = bc.registerService(className, t2, props);
1:     
0:     r = (Runnable) ctx.lookup("osgi:services/java.lang.Runnable");
1:     
0:     assertSame("The wrong runnable was returned", t2, r);
1:   }
1:   
author:Jarek Gawor
-------------------------------------------------------------------------------
commit:e65b402
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Proxy;
/////////////////////////////////////////////////////////////////////////
1:      Runnable r1 = (Runnable) ctx2.lookup("java.lang.Runnable");   
1:      assertNotNull(r1);
1:      assertTrue("expected proxied service class", r1 != service);
1:      Runnable r2 = (Runnable) ctx.lookup("aries:services/java.lang.Runnable");
1:      assertNotNull(r2);
1:      assertTrue("expected non-proxied service class", r2 == service);
/////////////////////////////////////////////////////////////////////////
1:     Runnable s = (Runnable) ctx.lookup("osgi:service/java.lang.Runnable");
/////////////////////////////////////////////////////////////////////////
1:     Object s = ctx.lookup("osgi:service/java.lang.Runnable/(rubbish=smelly)");
/////////////////////////////////////////////////////////////////////////
1:     ctx.lookup("osgi:service/java.lang.Runnable");
/////////////////////////////////////////////////////////////////////////
1:     ctx.lookup("osgi:service/java.lang.Integer");
/////////////////////////////////////////////////////////////////////////
1:     NamingEnumeration<NameClassPair> serviceList = ctx.list("osgi:service/java.lang.Runnable/(rubbish=smelly)");
/////////////////////////////////////////////////////////////////////////
1:     serviceList = ctx.list("osgi:service/java.lang.Runnable/(rubbish=smelly)");
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("osgi:service/java.lang.Runnable/(rubbish=smelly)", ncp.getName().toString());
/////////////////////////////////////////////////////////////////////////
1:     NamingEnumeration<Binding> serviceList = ctx.listBindings("osgi:service/java.lang.Runnable/(rubbish=smelly)");
/////////////////////////////////////////////////////////////////////////
1:     serviceList = ctx.listBindings("osgi:service/java.lang.Runnable/(rubbish=smelly)");
/////////////////////////////////////////////////////////////////////////
1:     assertEquals("osgi:service/java.lang.Runnable/(rubbish=smelly)", binding.getName().toString());
commit:7b2544b
/////////////////////////////////////////////////////////////////////////
0: import org.osgi.service.jndi.JNDIConstants;
/////////////////////////////////////////////////////////////////////////
1:     new Activator().start(bc);
1:         
/////////////////////////////////////////////////////////////////////////
1:     BundleMock mock = new BundleMock("scooby.doo.1", new Properties());
/////////////////////////////////////////////////////////////////////////
1:     ctx = new InitialContext(new Hashtable<Object, Object>());
1:     
1:     mock = new BundleMock("scooby.doo.2", new Properties());
/////////////////////////////////////////////////////////////////////////
1:        
commit:9e140bf
/////////////////////////////////////////////////////////////////////////
0:     OSGiObjectFactoryBuilder.setBundleContext(bc);
commit:3c19a77
/////////////////////////////////////////////////////////////////////////
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
commit:87e8fb4
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.jndi.url;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertTrue;
1: 
0: import java.lang.reflect.Field;
1: import java.util.Hashtable;
1: import java.util.Properties;
1: 
1: import javax.naming.Binding;
1: import javax.naming.Context;
1: import javax.naming.InitialContext;
1: import javax.naming.NameClassPair;
1: import javax.naming.NameNotFoundException;
1: import javax.naming.NamingEnumeration;
1: import javax.naming.NamingException;
1: import javax.naming.spi.ObjectFactory;
1: 
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.osgi.framework.Bundle;
1: import org.osgi.framework.BundleContext;
1: import org.osgi.framework.ServiceFactory;
1: import org.osgi.framework.ServiceReference;
1: import org.osgi.framework.ServiceRegistration;
1: 
0: import org.apache.aries.unittest.mocks.MethodCall;
0: import org.apache.aries.unittest.mocks.Skeleton;
0: import org.apache.aries.jndi.ContextHelper;
0: import org.apache.aries.jndi.OSGiObjectFactoryBuilder;
0: import org.apache.aries.jndi.services.ServiceHelper;
0: import org.apache.aries.jndi.url.Activator;
0: import org.apache.aries.mocks.BundleContextMock;
0: import org.apache.aries.mocks.BundleMock;
1: 
1: /**
1:  * Tests for our JNDI implementation for the service registry.
1:  */
1: public class ServiceRegistryContextTest
1: {
1:   /** The service we register by default */
0:   private Thread service;
1:   /** The bundle context for the test */
1:   private BundleContext bc;
1:   /** The service registration for the service */
1:   private ServiceRegistration reg;
1:   
1:   /**
1:    * This method does the setup to ensure we always have a service.
1:    * @throws NamingException 
1:    * @throws NoSuchFieldException 
1:    * @throws SecurityException 
1:    * @throws IllegalAccessException 
1:    * @throws IllegalArgumentException 
1:    */
1:   @Before
1:   public void registerService() throws NamingException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException 
1:   {
1:     bc =  Skeleton.newMock(new BundleContextMock(), BundleContext.class);
0:     new Activator().start(bc);
1:     new org.apache.aries.jndi.startup.Activator().start(bc);
1:     
0:     Field f = ServiceHelper.class.getDeclaredField("context");
0:     f.setAccessible(true);
0:     f.set(null, bc);
0:     f = ContextHelper.class.getDeclaredField("context");
0:     f.setAccessible(true);
0:     f.set(null, bc);
0:     f = OSGiObjectFactoryBuilder.class.getDeclaredField("context");
0:     f.setAccessible(true);
0:     f.set(null, bc);
1: 
1: 
0:     service = new Thread();
1:     
1:     registerService(service);
1:   }
1:   
1:   /**
1:    * Register a service in our map.
1:    * 
1:    * @param service2 The service to register.
1:    */
0:   private void registerService(Thread service2)
1:   {
1:     ServiceFactory factory = Skeleton.newMock(ServiceFactory.class);
1:     Skeleton skel = Skeleton.getSkeleton(factory);
1:     
1:     skel.setReturnValue(new MethodCall(ServiceFactory.class, "getService", Bundle.class, ServiceRegistration.class), service2);
1:     
1:     Hashtable<String, String> props = new Hashtable<String, String>();
1:     props.put("rubbish", "smelly");
1:     
1:     reg = bc.registerService(new String[] {"java.lang.Runnable"}, factory, props);
1:   }
1:   
1:   /**
1:    * Make sure we clear the caches out before the next test.
1:    */
1:   @After
1:   public void teardown()
1:   {
1:     BundleContextMock.clear();
1:     
1:     Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
1:   }
1:   
1:   /**
1:    * This test checks that we correctly register and deregister the url context
1:    * object factory in the service registry.
1:    */
1:   @Test
1:   public void testJNDIRegistration()
1:   {
1:     ServiceReference ref = bc.getServiceReference(ObjectFactory.class.getName());
1:     
1:     assertNotNull("The aries url context object factory was not registered", ref);
1:     
1:     ObjectFactory factory = (ObjectFactory) bc.getService(ref);
1:     
1:     assertNotNull("The aries url context object factory was null", factory);
1:   }
1:   
1:   /**
1:    * This test does a simple JNDI lookup to prove that works.
1:    * @throws NamingException
1:    */
1:   @Test
1:   public void simpleJNDILookup() throws NamingException
1:   {
1:     System.setProperty(Context.URL_PKG_PREFIXES, "helloMatey");
1:         
1:     InitialContext ctx = new InitialContext(new Hashtable<Object, Object>());
1:     
0:     BundleMock mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1:     
0:     Object s = ctx.lookup("aries:services/java.lang.Runnable");
1:     
1:     assertNotNull("We didn't get a service back from our lookup :(", s);
1:     
0:     assertEquals("The SR did not return the object we expected", service, s);
1:     
1:     Skeleton skel = Skeleton.getSkeleton(mock.getBundleContext());
1:     
0:     skel.assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", null));
1: 
0:     mock = new BundleMock("scooby.doo", new Properties());
1:     
1:     Thread.currentThread().setContextClassLoader(mock.getClassLoader());
1: 
0:     s = ctx.lookup("osgi:services/java.lang.Runnable");
1:     
1:     // Check we have the packages set correctly
1:     
1:     String packages = System.getProperty(Context.URL_PKG_PREFIXES, null);
1:     
1:     assertTrue(ctx.getEnvironment().containsValue(packages));
1: 
1:     
1:     assertNotNull("We didn't get a service back from our lookup :(", s);
1:     
0:     assertEquals("The SR did not return the object we expected", service, s);
1: 
1:     skel = Skeleton.getSkeleton(mock.getBundleContext());
0:     skel.assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", null));
1:   }
1: 
1:   /**
1:    * This test checks that we can pass a filter in without things blowing up.
1:    * Right now our mock service registry does not implement filtering, so the
1:    * effect is the same as simpleJNDILookup, but we at least know it is not
1:    * blowing up.
1:    * 
1:    * @throws NamingException
1:    */
1:   @Test
1:   public void jndiLookupWithFilter() throws NamingException
1:   {
1:     InitialContext ctx = new InitialContext();
1:     
0:     Object s = ctx.lookup("aries:services/java.lang.Runnable/(rubbish=smelly)");
1:     
1:     assertNotNull("We didn't get a service back from our lookup :(", s);
1:     
0:     assertEquals("The SR did not return the object we expected", service, s);
1:     
0:     Skeleton.getSkeleton(bc).assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", "(rubbish=smelly)"));
1:   }
1:   
1:   /**
1:    * Check that we get a NameNotFoundException if we lookup after the service
1:    * has been unregistered.
1:    * 
1:    * @throws NamingException
1:    */
1:   @Test(expected=NameNotFoundException.class)
1:   public void testLookupWhenServiceHasBeenRemoved() throws NamingException
1:   {
1:     reg.unregister();
1:     InitialContext ctx = new InitialContext();
1:     
0:     ctx.lookup("aries:services/java.lang.Runnable");
1:   }
1:   
1:   /**
1:    * Check that we get a NameNotFoundException if we lookup something not in the
1:    * registry.
1:    * 
1:    * @throws NamingException
1:    */
1:   @Test(expected=NameNotFoundException.class)
1:   public void testLookupForServiceWeNeverHad() throws NamingException
1:   {
1:     InitialContext ctx = new InitialContext();
1:     
0:     ctx.lookup("aries:services/java.lang.Integer");
1:   }
1:   
1:   /**
1:    * This test checks that we can list the contents of the repository using the
1:    * list method
1:    * 
1:    * @throws NamingException
1:    */
1:   @Test
1:   public void listRepositoryContents() throws NamingException
1:   {
1:     InitialContext ctx = new InitialContext();
1:     
0:     NamingEnumeration<NameClassPair> serviceList = ctx.list("aries:services/java.lang.Runnable/(rubbish=smelly)");
1:     
1:     checkThreadRetrievedViaListMethod(serviceList);
1:     
1:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:     
1:     //Now add a second service
1:     
1:     registerService(new Thread());
1:     
0:     serviceList = ctx.list("aries:services/java.lang.Runnable/(rubbish=smelly)");
1:     
1:     checkThreadRetrievedViaListMethod(serviceList);
1:     
1:     checkThreadRetrievedViaListMethod(serviceList);
1:     
1:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:     
1:   }
1: 
1:   /**
1:    * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
1:    * @param serviceList
1:    * @throws NamingException
1:    */
1:   private void checkThreadRetrievedViaListMethod(NamingEnumeration<NameClassPair> serviceList)
1:       throws NamingException
1:   {
1:     assertTrue("The repository was empty", serviceList.hasMoreElements());
1:     
1:     NameClassPair ncp = serviceList.next();
1:     
1:     assertNotNull("We didn't get a service back from our lookup :(", ncp);
1:     
1:     assertNotNull("The object from the SR was null", ncp.getClassName());
1:     
1:     assertEquals("The service retrieved was not of the correct type", "java.lang.Thread", ncp.getClassName());
1:     
0:     assertEquals("aries:services/java.lang.Runnable/(rubbish=smelly)", ncp.getName().toString());
1:   }
1:   
1:   /**
1:    * This test checks that we can list the contents of the repository using the
1:    * list method
1:    * 
1:    * @throws NamingException
1:    */
1:   @Test
1:   public void listRepositoryBindings() throws NamingException
1:   {
1:     InitialContext ctx = new InitialContext();
1:     
0:     NamingEnumeration<Binding> serviceList = ctx.listBindings("aries:services/java.lang.Runnable/(rubbish=smelly)");
1:     
1:     Object returnedService = checkThreadRetrievedViaListBindingsMethod(serviceList);
1:     
1:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:     
1:     assertTrue("The returned service was not the service we expected", returnedService == service);
1:     
1:     //Now add a second service
1:     Thread secondService = new Thread();
1:     registerService(secondService);
1:     
0:     serviceList = ctx.listBindings("aries:services/java.lang.Runnable/(rubbish=smelly)");
1:     
1:     Object returnedService1 = checkThreadRetrievedViaListBindingsMethod(serviceList);
1:     
1:     Object returnedService2 = checkThreadRetrievedViaListBindingsMethod(serviceList);
1:     
1:     assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
1:     
1:     assertTrue("The services were not the ones we expected!",(returnedService1 == service || returnedService2 == service) && (returnedService1 == secondService || returnedService2 == secondService) && (returnedService1 != returnedService2));
1:     
1:   }
1: 
1:   /**
1:    * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
1:    * @param serviceList
1:    * @return the object in the registry
1:    * @throws NamingException
1:    */
1:   private Object checkThreadRetrievedViaListBindingsMethod(NamingEnumeration<Binding> serviceList)
1:       throws NamingException
1:   {
1:     assertTrue("The repository was empty", serviceList.hasMoreElements());
1:     
1:     Binding binding = serviceList.nextElement();
1:     
1:     assertNotNull("We didn't get a service back from our lookup :(", binding);
1:     
1:     assertNotNull("The object from the SR was null", binding.getObject());
1:     
1:     assertTrue("The service retrieved was not of the correct type", binding.getObject() instanceof Thread);
1:     
0:     assertEquals("aries:services/java.lang.Runnable/(rubbish=smelly)", binding.getName().toString());
1:     
1:     return binding.getObject();
1:   }
1:   
1: }
commit:e6f69cc
commit:fc02f66
/////////////////////////////////////////////////////////////////////////
0: ///*
0: // * Licensed to the Apache Software Foundation (ASF) under one
0: // * or more contributor license agreements.  See the NOTICE file
0: // * distributed with this work for additional information
0: // * regarding copyright ownership.  The ASF licenses this file
0: // * to you under the Apache License, Version 2.0 (the
0: // * "License"); you may not use this file except in compliance
0: // * with the License.  You may obtain a copy of the License at
0: // *
0: // *   http://www.apache.org/licenses/LICENSE-2.0
0: // *
0: // * Unless required by applicable law or agreed to in writing,
0: // * software distributed under the License is distributed on an
0: // * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0: // * KIND, either express or implied.  See the License for the
0: // * specific language governing permissions and limitations
0: // * under the License.
0: // */
0: //package org.apache.aries.jndi.url;
0: //
0: //import static org.junit.Assert.assertEquals;
0: //import static org.junit.Assert.assertFalse;
0: //import static org.junit.Assert.assertNotNull;
0: //import static org.junit.Assert.assertTrue;
0: //
0: //import java.lang.reflect.Field;
0: //import java.util.Hashtable;
0: //import java.util.Properties;
0: //
0: //import javax.naming.Binding;
0: //import javax.naming.Context;
0: //import javax.naming.InitialContext;
0: //import javax.naming.NameClassPair;
0: //import javax.naming.NameNotFoundException;
0: //import javax.naming.NamingEnumeration;
0: //import javax.naming.NamingException;
0: //import javax.naming.spi.ObjectFactory;
0: //
0: //import mocks.BundleContextMock;
0: //import mocks.BundleMock;
0: //
0: //import org.junit.After;
0: //import org.junit.Before;
0: //import org.junit.Test;
0: //import org.osgi.framework.Bundle;
0: //import org.osgi.framework.BundleContext;
0: //import org.osgi.framework.ServiceFactory;
0: //import org.osgi.framework.ServiceReference;
0: //import org.osgi.framework.ServiceRegistration;
0: //
0: //import com.ibm.aries.unittest.mocks.MethodCall;
0: //import com.ibm.aries.unittest.mocks.Skeleton;
0: //import org.apache.aries.jndi.ContextHelper;
0: //import org.apache.aries.jndi.OSGiObjectFactoryBuilder;
0: //import org.apache.aries.jndi.services.ServiceHelper;
0: //import org.apache.aries.jndi.url.Activator;
0: //
0: ///**
0: // * Tests for our JNDI implementation for the service registry.
0: // */
0: //public class ServiceRegistryContextTest
0: //{
0: //  /** The service we register by default */
0: //  private Thread service;
0: //  /** The bundle context for the test */
0: //  private BundleContext bc;
0: //  /** The service registration for the service */
0: //  private ServiceRegistration reg;
0: //  
0: //  /**
0: //   * This method does the setup to ensure we always have a service.
0: //   * @throws NamingException 
0: //   * @throws NoSuchFieldException 
0: //   * @throws SecurityException 
0: //   * @throws IllegalAccessException 
0: //   * @throws IllegalArgumentException 
0: //   */
0: //  @Before
0: //  public void registerService() throws NamingException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException 
0: //  {
0: //    bc =  Skeleton.newMock(new BundleContextMock(), BundleContext.class);
0: //    new Activator().start(bc);
0: //    new com.ibm.osgi.jndi.startup.Activator().start(bc);
0: //    
0: //    Field f = ServiceHelper.class.getDeclaredField("context");
0: //    f.setAccessible(true);
0: //    f.set(null, bc);
0: //    f = ContextHelper.class.getDeclaredField("context");
0: //    f.setAccessible(true);
0: //    f.set(null, bc);
0: //    f = OSGiObjectFactoryBuilder.class.getDeclaredField("context");
0: //    f.setAccessible(true);
0: //    f.set(null, bc);
0: //
0: //
0: //    service = new Thread();
0: //    
0: //    registerService(service);
0: //  }
0: //  
0: //  /**
0: //   * Register a service in our map.
0: //   * 
0: //   * @param service2 The service to register.
0: //   */
0: //  private void registerService(Thread service2)
0: //  {
0: //    ServiceFactory factory = Skeleton.newMock(ServiceFactory.class);
0: //    Skeleton skel = Skeleton.getSkeleton(factory);
0: //    
0: //    skel.setReturnValue(new MethodCall(ServiceFactory.class, "getService", Bundle.class, ServiceRegistration.class), service2);
0: //    
0: //    Hashtable<String, String> props = new Hashtable<String, String>();
0: //    props.put("rubbish", "smelly");
0: //    
0: //    reg = bc.registerService(new String[] {"java.lang.Runnable"}, factory, props);
0: //  }
0: //  
0: //  /**
0: //   * Make sure we clear the caches out before the next test.
0: //   */
0: //  @After
0: //  public void teardown()
0: //  {
0: //    BundleContextMock.clear();
0: //    
0: //    Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
0: //  }
0: //  
0: //  /**
0: //   * This test checks that we correctly register and deregister the url context
0: //   * object factory in the service registry.
0: //   */
0: //  @Test
0: //  public void testJNDIRegistration()
0: //  {
0: //    ServiceReference ref = bc.getServiceReference(ObjectFactory.class.getName());
0: //    
0: //    assertNotNull("The aries url context object factory was not registered", ref);
0: //    
0: //    ObjectFactory factory = (ObjectFactory) bc.getService(ref);
0: //    
0: //    assertNotNull("The aries url context object factory was null", factory);
0: //  }
0: //  
0: //  /**
0: //   * This test does a simple JNDI lookup to prove that works.
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void simpleJNDILookup() throws NamingException
0: //  {
0: //    System.setProperty(Context.URL_PKG_PREFIXES, "helloMatey");
0: //        
0: //    InitialContext ctx = new InitialContext(new Hashtable<Object, Object>());
0: //    
0: //    BundleMock mock = new BundleMock("scooby.doo", new Properties());
0: //    
0: //    Thread.currentThread().setContextClassLoader(mock.getClassLoader());
0: //    
0: //    Object s = ctx.lookup("aries:services/java.lang.Runnable");
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", s);
0: //    
0: //    assertEquals("The SR did not return the object we expected", service, s);
0: //    
0: //    Skeleton skel = Skeleton.getSkeleton(mock.getBundleContext());
0: //    
0: //    skel.assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", null));
0: //
0: //    mock = new BundleMock("scooby.doo", new Properties());
0: //    
0: //    Thread.currentThread().setContextClassLoader(mock.getClassLoader());
0: //
0: //    s = ctx.lookup("osgi:services/java.lang.Runnable");
0: //    
0: //    // Check we have the packages set correctly
0: //    
0: //    String packages = System.getProperty(Context.URL_PKG_PREFIXES, null);
0: //    
0: //    assertTrue(ctx.getEnvironment().containsValue(packages));
0: //
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", s);
0: //    
0: //    assertEquals("The SR did not return the object we expected", service, s);
0: //
0: //    skel = Skeleton.getSkeleton(mock.getBundleContext());
0: //    skel.assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", null));
0: //  }
0: //
0: //  /**
0: //   * This test checks that we can pass a filter in without things blowing up.
0: //   * Right now our mock service registry does not implement filtering, so the
0: //   * effect is the same as simpleJNDILookup, but we at least know it is not
0: //   * blowing up.
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void jndiLookupWithFilter() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    Object s = ctx.lookup("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", s);
0: //    
0: //    assertEquals("The SR did not return the object we expected", service, s);
0: //    
0: //    Skeleton.getSkeleton(bc).assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", "(rubbish=smelly)"));
0: //  }
0: //  
0: //  /**
0: //   * Check that we get a NameNotFoundException if we lookup after the service
0: //   * has been unregistered.
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test(expected=NameNotFoundException.class)
0: //  public void testLookupWhenServiceHasBeenRemoved() throws NamingException
0: //  {
0: //    reg.unregister();
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    ctx.lookup("aries:services/java.lang.Runnable");
0: //  }
0: //  
0: //  /**
0: //   * Check that we get a NameNotFoundException if we lookup something not in the
0: //   * registry.
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test(expected=NameNotFoundException.class)
0: //  public void testLookupForServiceWeNeverHad() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    ctx.lookup("aries:services/java.lang.Integer");
0: //  }
0: //  
0: //  /**
0: //   * This test checks that we can list the contents of the repository using the
0: //   * list method
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void listRepositoryContents() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    NamingEnumeration<NameClassPair> serviceList = ctx.list("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    checkThreadRetrievedViaListMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //    //Now add a second service
0: //    
0: //    registerService(new Thread());
0: //    
0: //    serviceList = ctx.list("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    checkThreadRetrievedViaListMethod(serviceList);
0: //    
0: //    checkThreadRetrievedViaListMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //  }
0: //
0: //  /**
0: //   * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
0: //   * @param serviceList
0: //   * @throws NamingException
0: //   */
0: //  private void checkThreadRetrievedViaListMethod(NamingEnumeration<NameClassPair> serviceList)
0: //      throws NamingException
0: //  {
0: //    assertTrue("The repository was empty", serviceList.hasMoreElements());
0: //    
0: //    NameClassPair ncp = serviceList.next();
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", ncp);
0: //    
0: //    assertNotNull("The object from the SR was null", ncp.getClassName());
0: //    
0: //    assertEquals("The service retrieved was not of the correct type", "java.lang.Thread", ncp.getClassName());
0: //    
0: //    assertEquals("aries:services/java.lang.Runnable/(rubbish=smelly)", ncp.getName().toString());
0: //  }
0: //  
0: //  /**
0: //   * This test checks that we can list the contents of the repository using the
0: //   * list method
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void listRepositoryBindings() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    NamingEnumeration<Binding> serviceList = ctx.listBindings("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    Object returnedService = checkThreadRetrievedViaListBindingsMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //    assertTrue("The returned service was not the service we expected", returnedService == service);
0: //    
0: //    //Now add a second service
0: //    Thread secondService = new Thread();
0: //    registerService(secondService);
0: //    
0: //    serviceList = ctx.listBindings("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    Object returnedService1 = checkThreadRetrievedViaListBindingsMethod(serviceList);
0: //    
0: //    Object returnedService2 = checkThreadRetrievedViaListBindingsMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //    assertTrue("The services were not the ones we expected!",(returnedService1 == service || returnedService2 == service) && (returnedService1 == secondService || returnedService2 == secondService) && (returnedService1 != returnedService2));
0: //    
0: //  }
0: //
0: //  /**
0: //   * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
0: //   * @param serviceList
0: //   * @return the object in the registry
0: //   * @throws NamingException
0: //   */
0: //  private Object checkThreadRetrievedViaListBindingsMethod(NamingEnumeration<Binding> serviceList)
0: //      throws NamingException
0: //  {
0: //    assertTrue("The repository was empty", serviceList.hasMoreElements());
0: //    
0: //    Binding binding = serviceList.nextElement();
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", binding);
0: //    
0: //    assertNotNull("The object from the SR was null", binding.getObject());
0: //    
0: //    assertTrue("The service retrieved was not of the correct type", binding.getObject() instanceof Thread);
0: //    
0: //    assertEquals("aries:services/java.lang.Runnable/(rubbish=smelly)", binding.getName().toString());
0: //    
0: //    return binding.getObject();
0: //  }
0: //  
commit:1a3015d
/////////////////////////////////////////////////////////////////////////
0: ///*
0: // * Licensed to the Apache Software Foundation (ASF) under one
0: // * or more contributor license agreements.  See the NOTICE file
0: // * distributed with this work for additional information
0: // * regarding copyright ownership.  The ASF licenses this file
0: // * to you under the Apache License, Version 2.0 (the
0: // * "License"); you may not use this file except in compliance
0: // * with the License.  You may obtain a copy of the License at
0: // *
0: // *   http://www.apache.org/licenses/LICENSE-2.0
0: // *
0: // * Unless required by applicable law or agreed to in writing,
0: // * software distributed under the License is distributed on an
0: // * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
0: // * KIND, either express or implied.  See the License for the
0: // * specific language governing permissions and limitations
0: // * under the License.
0: // */
0: //package org.apache.aries.jndi.url;
0: //
0: //import static org.junit.Assert.assertEquals;
0: //import static org.junit.Assert.assertFalse;
0: //import static org.junit.Assert.assertNotNull;
0: //import static org.junit.Assert.assertTrue;
0: //
0: //import java.lang.reflect.Field;
0: //import java.util.Hashtable;
0: //import java.util.Properties;
0: //
0: //import javax.naming.Binding;
0: //import javax.naming.Context;
0: //import javax.naming.InitialContext;
0: //import javax.naming.NameClassPair;
0: //import javax.naming.NameNotFoundException;
0: //import javax.naming.NamingEnumeration;
0: //import javax.naming.NamingException;
0: //import javax.naming.spi.ObjectFactory;
0: //
0: //import mocks.BundleContextMock;
0: //import mocks.BundleMock;
0: //
0: //import org.junit.After;
0: //import org.junit.Before;
0: //import org.junit.Test;
0: //import org.osgi.framework.Bundle;
0: //import org.osgi.framework.BundleContext;
0: //import org.osgi.framework.ServiceFactory;
0: //import org.osgi.framework.ServiceReference;
0: //import org.osgi.framework.ServiceRegistration;
0: //
0: //import com.ibm.aries.unittest.mocks.MethodCall;
0: //import com.ibm.aries.unittest.mocks.Skeleton;
0: //import org.apache.aries.jndi.ContextHelper;
0: //import org.apache.aries.jndi.OSGiObjectFactoryBuilder;
0: //import org.apache.aries.jndi.services.ServiceHelper;
0: //import org.apache.aries.jndi.url.Activator;
0: //
0: ///**
0: // * Tests for our JNDI implementation for the service registry.
0: // */
0: //public class ServiceRegistryContextTest
0: //{
0: //  /** The service we register by default */
0: //  private Thread service;
0: //  /** The bundle context for the test */
0: //  private BundleContext bc;
0: //  /** The service registration for the service */
0: //  private ServiceRegistration reg;
0: //  
0: //  /**
0: //   * This method does the setup to ensure we always have a service.
0: //   * @throws NamingException 
0: //   * @throws NoSuchFieldException 
0: //   * @throws SecurityException 
0: //   * @throws IllegalAccessException 
0: //   * @throws IllegalArgumentException 
0: //   */
0: //  @Before
0: //  public void registerService() throws NamingException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException 
0: //  {
0: //    bc =  Skeleton.newMock(new BundleContextMock(), BundleContext.class);
0: //    new Activator().start(bc);
0: //    new com.ibm.osgi.jndi.startup.Activator().start(bc);
0: //    
0: //    Field f = ServiceHelper.class.getDeclaredField("context");
0: //    f.setAccessible(true);
0: //    f.set(null, bc);
0: //    f = ContextHelper.class.getDeclaredField("context");
0: //    f.setAccessible(true);
0: //    f.set(null, bc);
0: //    f = OSGiObjectFactoryBuilder.class.getDeclaredField("context");
0: //    f.setAccessible(true);
0: //    f.set(null, bc);
0: //
0: //
0: //    service = new Thread();
0: //    
0: //    registerService(service);
0: //  }
0: //  
0: //  /**
0: //   * Register a service in our map.
0: //   * 
0: //   * @param service2 The service to register.
0: //   */
0: //  private void registerService(Thread service2)
0: //  {
0: //    ServiceFactory factory = Skeleton.newMock(ServiceFactory.class);
0: //    Skeleton skel = Skeleton.getSkeleton(factory);
0: //    
0: //    skel.setReturnValue(new MethodCall(ServiceFactory.class, "getService", Bundle.class, ServiceRegistration.class), service2);
0: //    
0: //    Hashtable<String, String> props = new Hashtable<String, String>();
0: //    props.put("rubbish", "smelly");
0: //    
0: //    reg = bc.registerService(new String[] {"java.lang.Runnable"}, factory, props);
0: //  }
0: //  
0: //  /**
0: //   * Make sure we clear the caches out before the next test.
0: //   */
0: //  @After
0: //  public void teardown()
0: //  {
0: //    BundleContextMock.clear();
0: //    
0: //    Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
0: //  }
0: //  
0: //  /**
0: //   * This test checks that we correctly register and deregister the url context
0: //   * object factory in the service registry.
0: //   */
0: //  @Test
0: //  public void testJNDIRegistration()
0: //  {
0: //    ServiceReference ref = bc.getServiceReference(ObjectFactory.class.getName());
0: //    
0: //    assertNotNull("The aries url context object factory was not registered", ref);
0: //    
0: //    ObjectFactory factory = (ObjectFactory) bc.getService(ref);
0: //    
0: //    assertNotNull("The aries url context object factory was null", factory);
0: //  }
0: //  
0: //  /**
0: //   * This test does a simple JNDI lookup to prove that works.
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void simpleJNDILookup() throws NamingException
0: //  {
0: //    System.setProperty(Context.URL_PKG_PREFIXES, "helloMatey");
0: //        
0: //    InitialContext ctx = new InitialContext(new Hashtable<Object, Object>());
0: //    
0: //    BundleMock mock = new BundleMock("scooby.doo", new Properties());
0: //    
0: //    Thread.currentThread().setContextClassLoader(mock.getClassLoader());
0: //    
0: //    Object s = ctx.lookup("aries:services/java.lang.Runnable");
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", s);
0: //    
0: //    assertEquals("The SR did not return the object we expected", service, s);
0: //    
0: //    Skeleton skel = Skeleton.getSkeleton(mock.getBundleContext());
0: //    
0: //    skel.assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", null));
0: //
0: //    mock = new BundleMock("scooby.doo", new Properties());
0: //    
0: //    Thread.currentThread().setContextClassLoader(mock.getClassLoader());
0: //
0: //    s = ctx.lookup("osgi:services/java.lang.Runnable");
0: //    
0: //    // Check we have the packages set correctly
0: //    
0: //    String packages = System.getProperty(Context.URL_PKG_PREFIXES, null);
0: //    
0: //    assertTrue(ctx.getEnvironment().containsValue(packages));
0: //
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", s);
0: //    
0: //    assertEquals("The SR did not return the object we expected", service, s);
0: //
0: //    skel = Skeleton.getSkeleton(mock.getBundleContext());
0: //    skel.assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", null));
0: //  }
0: //
0: //  /**
0: //   * This test checks that we can pass a filter in without things blowing up.
0: //   * Right now our mock service registry does not implement filtering, so the
0: //   * effect is the same as simpleJNDILookup, but we at least know it is not
0: //   * blowing up.
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void jndiLookupWithFilter() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    Object s = ctx.lookup("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", s);
0: //    
0: //    assertEquals("The SR did not return the object we expected", service, s);
0: //    
0: //    Skeleton.getSkeleton(bc).assertCalled(new MethodCall(BundleContext.class, "getAllServiceReferences", "java.lang.Runnable", "(rubbish=smelly)"));
0: //  }
0: //  
0: //  /**
0: //   * Check that we get a NameNotFoundException if we lookup after the service
0: //   * has been unregistered.
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test(expected=NameNotFoundException.class)
0: //  public void testLookupWhenServiceHasBeenRemoved() throws NamingException
0: //  {
0: //    reg.unregister();
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    ctx.lookup("aries:services/java.lang.Runnable");
0: //  }
0: //  
0: //  /**
0: //   * Check that we get a NameNotFoundException if we lookup something not in the
0: //   * registry.
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test(expected=NameNotFoundException.class)
0: //  public void testLookupForServiceWeNeverHad() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    ctx.lookup("aries:services/java.lang.Integer");
0: //  }
0: //  
0: //  /**
0: //   * This test checks that we can list the contents of the repository using the
0: //   * list method
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void listRepositoryContents() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    NamingEnumeration<NameClassPair> serviceList = ctx.list("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    checkThreadRetrievedViaListMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //    //Now add a second service
0: //    
0: //    registerService(new Thread());
0: //    
0: //    serviceList = ctx.list("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    checkThreadRetrievedViaListMethod(serviceList);
0: //    
0: //    checkThreadRetrievedViaListMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //  }
0: //
0: //  /**
0: //   * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
0: //   * @param serviceList
0: //   * @throws NamingException
0: //   */
0: //  private void checkThreadRetrievedViaListMethod(NamingEnumeration<NameClassPair> serviceList)
0: //      throws NamingException
0: //  {
0: //    assertTrue("The repository was empty", serviceList.hasMoreElements());
0: //    
0: //    NameClassPair ncp = serviceList.next();
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", ncp);
0: //    
0: //    assertNotNull("The object from the SR was null", ncp.getClassName());
0: //    
0: //    assertEquals("The service retrieved was not of the correct type", "java.lang.Thread", ncp.getClassName());
0: //    
0: //    assertEquals("aries:services/java.lang.Runnable/(rubbish=smelly)", ncp.getName().toString());
0: //  }
0: //  
0: //  /**
0: //   * This test checks that we can list the contents of the repository using the
0: //   * list method
0: //   * 
0: //   * @throws NamingException
0: //   */
0: //  @Test
0: //  public void listRepositoryBindings() throws NamingException
0: //  {
0: //    InitialContext ctx = new InitialContext();
0: //    
0: //    NamingEnumeration<Binding> serviceList = ctx.listBindings("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    Object returnedService = checkThreadRetrievedViaListBindingsMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //    assertTrue("The returned service was not the service we expected", returnedService == service);
0: //    
0: //    //Now add a second service
0: //    Thread secondService = new Thread();
0: //    registerService(secondService);
0: //    
0: //    serviceList = ctx.listBindings("aries:services/java.lang.Runnable/(rubbish=smelly)");
0: //    
0: //    Object returnedService1 = checkThreadRetrievedViaListBindingsMethod(serviceList);
0: //    
0: //    Object returnedService2 = checkThreadRetrievedViaListBindingsMethod(serviceList);
0: //    
0: //    assertFalse("The repository contained more objects than we expected", serviceList.hasMoreElements());
0: //    
0: //    assertTrue("The services were not the ones we expected!",(returnedService1 == service || returnedService2 == service) && (returnedService1 == secondService || returnedService2 == secondService) && (returnedService1 != returnedService2));
0: //    
0: //  }
0: //
0: //  /**
0: //   * Check that the NamingEnumeration passed in has another element, which represents a java.lang.Thread
0: //   * @param serviceList
0: //   * @return the object in the registry
0: //   * @throws NamingException
0: //   */
0: //  private Object checkThreadRetrievedViaListBindingsMethod(NamingEnumeration<Binding> serviceList)
0: //      throws NamingException
0: //  {
0: //    assertTrue("The repository was empty", serviceList.hasMoreElements());
0: //    
0: //    Binding binding = serviceList.nextElement();
0: //    
0: //    assertNotNull("We didn't get a service back from our lookup :(", binding);
0: //    
0: //    assertNotNull("The object from the SR was null", binding.getObject());
0: //    
0: //    assertTrue("The service retrieved was not of the correct type", binding.getObject() instanceof Thread);
0: //    
0: //    assertEquals("aries:services/java.lang.Runnable/(rubbish=smelly)", binding.getName().toString());
0: //    
0: //    return binding.getObject();
0: //  }
0: //  
0: //}
author:David Jencks
-------------------------------------------------------------------------------
commit:f8842fe
/////////////////////////////////////////////////////////////////////////
1:     assertTrue("Class name not correct. Was: " + bnd.getClassName(), bnd.getClassName().contains("Proxy") || bnd.getClassName().contains("EnhancerByCGLIB"));
/////////////////////////////////////////////////////////////////////////
1:     assertTrue("Class name not correct. Was: " + bnd.getClassName(), bnd.getClassName().contains("Proxy") || bnd.getClassName().contains("EnhancerByCGLIB"));
============================================================================