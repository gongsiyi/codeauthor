1:6f219fd: /*
1:6f219fd:  * Licensed to the Apache Software Foundation (ASF) under one
1:6f219fd:  * or more contributor license agreements.  See the NOTICE file
1:6f219fd:  * distributed with this work for additional information
1:6f219fd:  * regarding copyright ownership.  The ASF licenses this file
1:6f219fd:  * to you under the Apache License, Version 2.0 (the
1:6f219fd:  * "License"); you may not use this file except in compliance
1:6f219fd:  * with the License.  You may obtain a copy of the License at
1:6f219fd:  *
1:6f219fd:  *   http://www.apache.org/licenses/LICENSE-2.0
1:6f219fd:  *
1:6f219fd:  * Unless required by applicable law or agreed to in writing,
1:6f219fd:  * software distributed under the License is distributed on an
1:6f219fd:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6f219fd:  * KIND, either express or implied.  See the License for the
1:6f219fd:  * specific language governing permissions and limitations
1:6f219fd:  * under the License.
1:6f219fd:  */
1:6f219fd: package org.apache.aries.transaction;
16:6f219fd: 
1:febc5c2: import static org.easymock.EasyMock.createControl;
1:febc5c2: import static org.easymock.EasyMock.expect;
1:febc5c2: import static org.easymock.EasyMock.expectLastCall;
1:6f219fd: import static org.junit.Assert.assertNotNull;
1:6f219fd: import static org.junit.Assert.assertNull;
1:6f219fd: import static org.junit.Assert.fail;
1:6f219fd: 
1:6f219fd: import java.util.HashSet;
1:6f219fd: import java.util.Iterator;
1:6f219fd: import java.util.Set;
1:6f219fd: 
1:6f219fd: import javax.transaction.NotSupportedException;
1:6f219fd: import javax.transaction.Status;
1:6f219fd: import javax.transaction.SystemException;
1:6f219fd: import javax.transaction.Transaction;
1:6f219fd: import javax.transaction.TransactionManager;
1:6f219fd: 
1:febc5c2: import org.easymock.EasyMock;
1:febc5c2: import org.easymock.IMocksControl;
1:6f219fd: import org.junit.Before;
1:6f219fd: import org.junit.Test;
1:6f219fd: 
1:6f219fd: public class TranStrategyTest {
1:6f219fd: 
1:febc5c2:     TransactionManager tm;
1:febc5c2:     Transaction t;
1:febc5c2:     private IMocksControl c;
1:6f219fd:    
1:6f219fd:     @Before
1:6f219fd:     public void clean()
1:6f219fd:     {
1:febc5c2:       c = createControl();
1:febc5c2:       tm = c.createMock(TransactionManager.class);
1:febc5c2:       t = c.createMock(Transaction.class);
11:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testMandatoryBegin() throws Exception
1:6f219fd:     {
1:6f219fd:       // MANDATORY strategy should throw IllegalStateException when tran manager 
1:6f219fd:       // status is Status.STATUS_NO_TRANSACTION it should not return null.
1:febc5c2:       expect(tm.getStatus()).andReturn(Status.STATUS_NO_TRANSACTION);
1:6f219fd: 
7:6f219fd:       try {
1:6f219fd:         assertNotNull("TransactionStrategy.MANDATORY.begin(tm) returned null when manager " +
1:92e371f:               "status is STATUS_NO_TRANSACTION", TransactionAttribute.MANDATORY.begin(tm).getActiveTransaction());
2:6f219fd:       } catch (IllegalStateException ise) {
1:6f219fd:           // Expected to be in here
5:6f219fd:       } catch (Exception e) {
1:6f219fd:           fail("TransactionStrategy.MANDATORY.begin() threw an unexpected exception when tran manager status is STATUS_NO_TRANSACTION");
1:6f219fd:       }
1:6f219fd:           
1:6f219fd:       // MANDATORY strategy should return null for all tran manager states other
1:6f219fd:       // than Status.STATUS_NO_TRANSACTION.
2:6f219fd:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
2:6f219fd:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
2:6f219fd:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:6f219fd:       
2:6f219fd:       for (int i = 0; i < invalids.length ; i++) {
1:febc5c2:         c.reset();
1:febc5c2:         expect(tm.getStatus()).andReturn(invalids[i]);
1:febc5c2:         expect(tm.getTransaction()).andReturn(null);
1:febc5c2:         c.replay();
1:6f219fd:         try {
1:92e371f:           Transaction tran = TransactionAttribute.MANDATORY.begin(tm).getActiveTransaction();
1:5c15102:           assertNull("TransactionStrategy.MANDATORY.begin() did not return null when manager status value is " + invalids[i], tran);
2:6f219fd:         } catch (Exception ise) {
1:5c15102:           fail("TransactionStrategy.MANDATORY.begin() threw Exception when manager status value is " + invalids[i]);
1:febc5c2:         }
1:febc5c2:         c.verify();
1:6f219fd:       }
1:6f219fd:     }
1:6f219fd:      
1:6f219fd:     @Test
1:6f219fd:     public void testMandatoryFinish()
1:6f219fd:     {
1:6f219fd:       try {
1:92e371f:         TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.MANDATORY);
1:92e371f:         TransactionAttribute.MANDATORY.finish(tm, tranToken);
1:6f219fd:       } catch (Exception e) {
1:6f219fd:           fail("TransactionStrategy.MANDATORY.finish() threw an unexpected exception");
1:6f219fd:       }
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testNeverBegin() throws Exception
1:6f219fd:     {
1:febc5c2:         // NEVER strategy should throw IllegalStateException when tran manager 
1:febc5c2:         // status is Status.STATUS_ACTIVE it should not return null.
1:febc5c2:         expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:febc5c2: 
1:6f219fd:         try {
1:febc5c2:             assertNotNull("TransactionStrategy.NEVER.begin() returned null when manager status is STATUS_ACTIVE", TransactionAttribute.NEVER.begin(tm));
1:febc5c2:         } catch (IllegalStateException ise) {
1:febc5c2:             // Expect to be in here
1:febc5c2:         } catch (Exception e) {
1:febc5c2:             fail("TransactionStrategy.NEVER.begin() threw an unexpected exception when tran manager status is STATUS_ACTIVE");
1:febc5c2:         }
1:febc5c2: 
1:febc5c2:         // NEVER strategy should return null for all tran manager states other
1:febc5c2:         // than Status.STATUS_ACTIVE.
1:febc5c2:         int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:febc5c2:                                     Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:febc5c2:                                     Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:febc5c2: 
1:febc5c2:         for (int i = 0; i < invalids.length ; i++) {
1:febc5c2:             c.reset();
1:febc5c2:             expect(tm.getStatus()).andReturn(invalids[i]);
1:febc5c2:             expect(tm.getTransaction()).andReturn(null).anyTimes();
1:febc5c2:             c.replay();
1:febc5c2:             try {
1:febc5c2:                 assertNull("TransactionStrategy.NEVER.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.NEVER.begin(tm).getActiveTransaction());
1:febc5c2:             } catch (Exception ise) {
1:febc5c2:                 fail("TransactionStrategy.NEVER.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:febc5c2:             } 
1:febc5c2:             c.verify();
1:febc5c2:         }
1:6f219fd: 
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testNeverFinish()
1:6f219fd:     {
1:6f219fd:       try {
1:92e371f:         TransactionToken tranToken = new TransactionToken(null, null, TransactionAttribute.NEVER);
1:92e371f:         TransactionAttribute.NEVER.finish(tm, tranToken);
1:6f219fd:       } catch (Exception e) {
1:6f219fd:           fail("TransactionStrategy.NEVER.finish() threw an unexpected exception");
1:6f219fd:       }
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testNotSupportedBegin() throws Exception
1:6f219fd:     {
1:6f219fd:       // NOT_SUPPORTED strategy should suspend an active transaction
1:6f219fd:       // and _NOT_ begin a new one
1:febc5c2:       expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:febc5c2:       expect(tm.suspend()).andReturn(null);
1:febc5c2:       c.replay();
1:bd98451:       TransactionAttribute.NOT_SUPPORTED.begin(tm);
1:febc5c2:       c.verify();
1:6f219fd:        
1:6f219fd:       // For all situations where there is no active transaction the
1:6f219fd:       // NOT_SUPPORTED strategy should return null
1:6f219fd:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
2:6f219fd:           Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:6f219fd:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:6f219fd:       
1:6f219fd:       for (int i = 0; i < invalids.length ; i++) {
1:febc5c2:           c.reset();
1:febc5c2:           expect(tm.getStatus()).andReturn(invalids[i]);
1:febc5c2:           expect(tm.getTransaction()).andReturn(null).anyTimes();
1:febc5c2:           c.replay();
1:6f219fd:         try {
1:bd98451:           assertNull("TransactionStrategy.NOT_SUPPORTED.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.NOT_SUPPORTED.begin(tm).getActiveTransaction());
1:6f219fd:         } catch (Exception ise) {
1:6f219fd:             fail("TransactionStrategy.NOT_SUPPORTED.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:6f219fd:         } 
1:febc5c2:         c.verify();
1:6f219fd:       }
1:6f219fd:      
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testNotSupportedFinish()
1:6f219fd:     {
1:6f219fd:       // If finish is called with a previously active transaction, then
1:6f219fd:       // we expect this transaction to be resumed for a NOT_SUPPORTED strategy
1:6f219fd:       try {
1:febc5c2:         tm.resume(t);
1:febc5c2:         EasyMock.expectLastCall();
1:febc5c2:         c.replay();
1:bd98451:         TransactionToken tranToken = new TransactionToken(null, t, TransactionAttribute.NOT_SUPPORTED);
1:bd98451:         TransactionAttribute.NOT_SUPPORTED.finish(tm, tranToken);
1:febc5c2:         c.verify();
1:febc5c2:         
1:febc5c2:         c.reset();
1:bd98451:         tranToken = new TransactionToken(null, null, TransactionAttribute.NOT_SUPPORTED);
1:bd98451:         TransactionAttribute.NOT_SUPPORTED.finish(tm, tranToken);
1:6f219fd:       } catch (Exception e) {
1:5c15102:           fail("TransactionStrategy.NOT_SUPPORTED.finish() threw unexpected exception, " + e);
1:6f219fd:       }
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testRequiredBegin() throws Exception
1:6f219fd:     {
1:6f219fd:       // If there is no previously active transaction when the REQUIRED strategy
1:6f219fd:       // is invoked then we expect a call to begin one
1:febc5c2:       expect(tm.getStatus()).andReturn(Status.STATUS_NO_TRANSACTION);
1:febc5c2:       expect(tm.getTransaction()).andReturn(null);
1:febc5c2:       tm.begin();
1:febc5c2:       expectLastCall();
1:febc5c2:       c.replay();
1:92e371f:       TransactionAttribute.REQUIRED.begin(tm);
1:febc5c2:       c.verify();
1:febc5c2:       c.reset();
1:6f219fd:        
1:6f219fd:       // For all cases where there is a transaction we expect REQUIRED to return null
1:6f219fd:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:6f219fd:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:6f219fd:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:6f219fd:       
1:6f219fd:       for (int i = 0; i < invalids.length ; i++) {
1:febc5c2:           c.reset();
1:febc5c2:           expect(tm.getStatus()).andReturn(invalids[i]);
1:febc5c2:           expect(tm.getTransaction()).andReturn(null);
1:febc5c2:           c.replay();
1:6f219fd:         try {
1:92e371f:           assertNull("TransactionStrategy.REQUIRED.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.REQUIRED.begin(tm).getActiveTransaction());
1:6f219fd:         } catch (Exception ise) {
1:6f219fd:             fail("TransactionStrategy.REQUIRED.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:6f219fd:         } 
1:febc5c2:         c.verify();
1:6f219fd:       }
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:febc5c2:     public void testRequiredFinish() throws Exception
1:6f219fd:     {
1:6f219fd:       // In the REQUIRED strategy we expect a call to rollback when a call to finish()
1:6f219fd:       // is made with a tran where the tran manager status shows Status.STATUS_MARKED_ROLLBACK
1:febc5c2:         expect(tm.getStatus()).andReturn(Status.STATUS_MARKED_ROLLBACK);
1:6f219fd:       
1:92e371f:         TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.REQUIRED, true);
1:febc5c2:         tm.rollback();
1:febc5c2:         expectLastCall();
1:febc5c2:         c.replay();
1:92e371f:         TransactionAttribute.REQUIRED.finish(tm, tranToken);
1:febc5c2:         c.verify();
1:6f219fd:         
1:6f219fd:         int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:6f219fd:             Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:6f219fd:             Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:6f219fd:         
1:6f219fd:         // For all other tran manager states we expect a call to commit
1:6f219fd:         for (int i = 0; i < invalids.length ; i++) {
1:febc5c2:           c.reset();
1:febc5c2:           expect(tm.getStatus()).andReturn(invalids[i]);
1:febc5c2:           tm.commit();
1:febc5c2:           expectLastCall();
1:febc5c2:           c.replay();
1:92e371f:           TransactionAttribute.REQUIRED.finish(tm, tranToken);
1:febc5c2:           c.verify();
1:6f219fd:         }
1:6f219fd:         
1:6f219fd:         // If null is passed instead of a tran we expect nothing to happen
1:febc5c2:         c.reset();
1:febc5c2:         c.replay();
1:92e371f:         tranToken = new TransactionToken(null, null, TransactionAttribute.REQUIRED);
1:febc5c2:         c.verify();
1:92e371f:         TransactionAttribute.REQUIRED.finish(tm, tranToken);
1:6f219fd:       
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testRequiresNew_BeginActiveTran() throws Exception
1:6f219fd:     {
1:6f219fd:       // Suspend case (no exception from tm.begin())
1:febc5c2:       expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:6f219fd:       
1:6f219fd:       // In the case of the REQUIRES_NEW strategy we expect an active tran to be suspended
1:febc5c2:       // a new new transaction to begin
1:febc5c2:       expect(tm.suspend()).andReturn(null);
1:febc5c2:       expectLastCall();
1:febc5c2:       tm.begin();
1:febc5c2:       expectLastCall();
1:febc5c2:       expect(tm.getTransaction()).andReturn(null);
1:febc5c2:       c.replay();
1:bd98451:       TransactionAttribute.REQUIRES_NEW.begin(tm);
1:febc5c2:       c.verify();
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:6f219fd:     public void testRequiresNew_BeginNoActiveTran() throws Exception
1:6f219fd:     {
1:6f219fd:       // No active tran cases (no exception from tm.begin())
1:6f219fd: 
1:6f219fd:       int[] manStatus = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:6f219fd:           Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:6f219fd:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:6f219fd:       
1:6f219fd:       // For all cases where the tran manager state is _not_ Status.STATUS_ACTIVE 
1:6f219fd:       // we expect a call to begin a new tran, no call to suspend and null to be
1:6f219fd:       // returned from TransactionStrategy.REQUIRES_NEW.begin(tm)
1:6f219fd:       for (int i = 0; i < manStatus.length ; i++) {
1:febc5c2:           c.reset();
1:febc5c2:           expect(tm.getStatus()).andReturn(manStatus[i]);
1:febc5c2:           expect(tm.getTransaction()).andReturn(null);
1:febc5c2:           tm.begin();
1:febc5c2:           expectLastCall();
1:febc5c2:           c.replay();
1:6f219fd:         try {
1:bd98451:           assertNull("TransactionStrategy.REQUIRES_NEW.begin() did not return null when manager status value is " + manStatus[i], TransactionAttribute.REQUIRES_NEW.begin(tm).getActiveTransaction());
1:6f219fd:         } catch (Exception ise) {
1:6f219fd:             fail("TransactionStrategy.REQUIRES_NEW.begin() threw unexpected exception when manager status value is " + manStatus[i]);
1:6f219fd:         } 
1:febc5c2:         c.verify();
1:6f219fd:       }
1:6f219fd:      
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:febc5c2:     public void testRequiresNew_TmExceptions() throws Exception
1:6f219fd:     {
2:6f219fd:       int[] allStates = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:6f219fd:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
2:6f219fd:           Status.STATUS_MARKED_ROLLBACK, Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:6f219fd:       
1:6f219fd:       // SystemException and NotSupportedException from tm.begin()
1:6f219fd:       Set<Exception> ees = new HashSet<Exception>();
1:6f219fd:       ees.add(new SystemException("KABOOM!"));
1:6f219fd:       ees.add(new NotSupportedException("KABOOM!"));
1:6f219fd:       
1:6f219fd:       // Loop through all states states twice changing the exception thrown
1:6f219fd:       // from tm.begin()
2:6f219fd:       for (int i = 0 ; i < allStates.length ; i++ ) {
1:6f219fd:         Iterator<Exception> iterator = ees.iterator();
1:6f219fd:         while (iterator.hasNext()) {
1:6f219fd:           Exception e = iterator.next();
1:febc5c2:           c.reset();
1:febc5c2:           expect(tm.getStatus()).andReturn(allStates[i]);
1:febc5c2:           expect(tm.getTransaction()).andReturn(null).anyTimes();
1:febc5c2:           tm.begin();
1:febc5c2:           expectLastCall().andThrow(e);
1:febc5c2:           requiresNewExceptionCheck(tm, allStates[i]);
1:6f219fd:         }
1:6f219fd:       }
1:6f219fd:     }
1:6f219fd:     
1:febc5c2:     private void requiresNewExceptionCheck(TransactionManager tm, int managerStatus) throws Exception
1:6f219fd:     {
1:6f219fd:       // If an ACTIVE tran is already present we expect a call to suspend this tran.
1:6f219fd:       // All states should call begin(), whereupon we receive our exception resulting
1:6f219fd:       // in calls to resume(t)
1:febc5c2:       if (managerStatus == Status.STATUS_ACTIVE) {
1:febc5c2:           expect(tm.suspend()).andReturn(null);
1:febc5c2:       }
1:febc5c2:       tm.resume(EasyMock.anyObject(Transaction.class));
1:febc5c2:       expectLastCall();
1:febc5c2:       c.replay();
1:6f219fd:       try {
1:bd98451:           TransactionAttribute.REQUIRES_NEW.begin(tm);
1:6f219fd:       } catch (SystemException se) {
2:6f219fd:           // Expect to be in here
1:6f219fd:       } catch (NotSupportedException nse) {
1:6f219fd:           // or to be in here
1:6f219fd:       } catch (Exception thrownE) {
1:6f219fd:           fail("TransactionStrategy.REQUIRES_NEW.begin() threw unexpected exception when manager status is " + managerStatus);
3:6f219fd:       } finally {
1:6f219fd:           // If Status.STATUS_ACTIVE
1:6f219fd:       }
1:febc5c2:       c.verify();
1:febc5c2:       c.reset();
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:febc5c2:     public void testRequiresNew_Finish() throws Exception
1:6f219fd:     {
1:febc5c2:         int[] allStates = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:febc5c2:                                      Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:febc5c2:                                      Status.STATUS_MARKED_ROLLBACK, Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:febc5c2: 
1:febc5c2:         // Loop through all states calling TransactionStrategy.REQUIRES_NEW.finish
1:febc5c2:         // passing tran manager and a tran, then passing tran manager and null
1:febc5c2:         for (int i = 0 ; i < allStates.length ; i++ ) {
1:febc5c2:             c.reset();
1:febc5c2:             expect(tm.getStatus()).andReturn(allStates[i]);
1:febc5c2:             requiresNew_assertion(tm, allStates[i]);
1:febc5c2:             tm.resume(EasyMock.anyObject(Transaction.class));
1:febc5c2:             expectLastCall();
1:febc5c2:             c.replay();
1:febc5c2:             try {
1:bd98451:                 TransactionToken tranToken = new TransactionToken(t, t, TransactionAttribute.REQUIRES_NEW, true);
1:bd98451:                 TransactionAttribute.REQUIRES_NEW.finish(tm, tranToken);
1:febc5c2:             } catch (Exception e) {
1:febc5c2:                 fail("TransactionStrategy.REQUIRES_NEW.finish() threw unexpected exception when manager status is " + allStates[i]);
1:febc5c2:             }
1:febc5c2:             c.verify();
1:febc5c2:             c.reset();
1:febc5c2:             try {
1:febc5c2:                 expect(tm.getStatus()).andReturn(allStates[i]);
1:febc5c2:                 requiresNew_assertion(tm, allStates[i]);
1:febc5c2:                 c.replay();
1:bd98451:                 TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.REQUIRES_NEW, true);
1:bd98451:                 TransactionAttribute.REQUIRES_NEW.finish(tm, tranToken);
1:febc5c2:             } catch (Throwable e) {
1:febc5c2:                 e.printStackTrace();
1:febc5c2:                 fail("TransactionStrategy.REQUIRES_NEW.finish() threw unexpected exception when manager status is " + allStates[i]);
1:febc5c2:             } finally {
1:febc5c2:             }
1:febc5c2:             c.verify();
1:6f219fd:         }
1:febc5c2: 
1:6f219fd:     }
1:6f219fd: 
1:febc5c2:     // If tran manager status reports Status.STATUS_MARKED_ROLLBACK we expect
1:febc5c2:     // a call to rollback ... otherwise we expect a call to commit
1:febc5c2:     private void requiresNew_assertion(TransactionManager tm, int status) throws Exception
1:6f219fd:     {
1:febc5c2:       if (status == Status.STATUS_MARKED_ROLLBACK) {
1:febc5c2:           tm.rollback();
1:6f219fd:       }
1:6f219fd:       else {
1:febc5c2:           tm.commit();
1:6f219fd:       }
1:febc5c2:       expectLastCall();
1:6f219fd:     }
1:6f219fd:     
1:6f219fd:     @Test
1:febc5c2:     public void testSupports() throws Exception
1:6f219fd:     {
1:febc5c2:       expect(tm.getTransaction()).andReturn(null);
1:febc5c2:       expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:febc5c2:       c.replay();
1:febc5c2:       assertNull("TransTransactionStrategy.SUPPORTS.begin(tm) did not return null", TransactionAttribute.SUPPORTS.begin(tm).getActiveTransaction());
1:febc5c2:       c.verify();
1:6f219fd:     }
1:6f219fd: }
============================================================================
author:Christian Schneider
-------------------------------------------------------------------------------
commit:bd98451
/////////////////////////////////////////////////////////////////////////
1:       TransactionAttribute.NOT_SUPPORTED.begin(tm);
/////////////////////////////////////////////////////////////////////////
1:           assertNull("TransactionStrategy.NOT_SUPPORTED.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.NOT_SUPPORTED.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
1:         TransactionToken tranToken = new TransactionToken(null, t, TransactionAttribute.NOT_SUPPORTED);
1:         TransactionAttribute.NOT_SUPPORTED.finish(tm, tranToken);
1:         tranToken = new TransactionToken(null, null, TransactionAttribute.NOT_SUPPORTED);
1:         TransactionAttribute.NOT_SUPPORTED.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
1:       TransactionAttribute.REQUIRES_NEW.begin(tm);
/////////////////////////////////////////////////////////////////////////
1:           assertNull("TransactionStrategy.REQUIRES_NEW.begin() did not return null when manager status value is " + manStatus[i], TransactionAttribute.REQUIRES_NEW.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
1:           TransactionAttribute.REQUIRES_NEW.begin(tm);
/////////////////////////////////////////////////////////////////////////
1:                 TransactionToken tranToken = new TransactionToken(t, t, TransactionAttribute.REQUIRES_NEW, true);
1:                 TransactionAttribute.REQUIRES_NEW.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
1:                 TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.REQUIRES_NEW, true);
1:                 TransactionAttribute.REQUIRES_NEW.finish(tm, tranToken);
commit:febc5c2
/////////////////////////////////////////////////////////////////////////
1: import static org.easymock.EasyMock.createControl;
1: import static org.easymock.EasyMock.expect;
1: import static org.easymock.EasyMock.expectLastCall;
/////////////////////////////////////////////////////////////////////////
1: import org.easymock.EasyMock;
1: import org.easymock.IMocksControl;
1:     TransactionManager tm;
1:     Transaction t;
1:     private IMocksControl c;
1:       c = createControl();
1:       tm = c.createMock(TransactionManager.class);
1:       t = c.createMock(Transaction.class);
/////////////////////////////////////////////////////////////////////////
1:       expect(tm.getStatus()).andReturn(Status.STATUS_NO_TRANSACTION);
/////////////////////////////////////////////////////////////////////////
1:         c.reset();
1:         expect(tm.getStatus()).andReturn(invalids[i]);
1:         expect(tm.getTransaction()).andReturn(null);
1:         c.replay();
1:         }
1:         c.verify();
/////////////////////////////////////////////////////////////////////////
1:         // NEVER strategy should throw IllegalStateException when tran manager 
1:         // status is Status.STATUS_ACTIVE it should not return null.
1:         expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1: 
1:             assertNotNull("TransactionStrategy.NEVER.begin() returned null when manager status is STATUS_ACTIVE", TransactionAttribute.NEVER.begin(tm));
1:         } catch (IllegalStateException ise) {
1:             // Expect to be in here
1:         } catch (Exception e) {
1:             fail("TransactionStrategy.NEVER.begin() threw an unexpected exception when tran manager status is STATUS_ACTIVE");
1:         }
1: 
1:         // NEVER strategy should return null for all tran manager states other
1:         // than Status.STATUS_ACTIVE.
1:         int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:                                     Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:                                     Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1: 
1:         for (int i = 0; i < invalids.length ; i++) {
1:             c.reset();
1:             expect(tm.getStatus()).andReturn(invalids[i]);
1:             expect(tm.getTransaction()).andReturn(null).anyTimes();
1:             c.replay();
1:             try {
1:                 assertNull("TransactionStrategy.NEVER.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.NEVER.begin(tm).getActiveTransaction());
1:             } catch (Exception ise) {
1:                 fail("TransactionStrategy.NEVER.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:             } 
1:             c.verify();
1:         }
/////////////////////////////////////////////////////////////////////////
1:       expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:       expect(tm.suspend()).andReturn(null);
1:       c.replay();
1:       c.verify();
/////////////////////////////////////////////////////////////////////////
1:           c.reset();
1:           expect(tm.getStatus()).andReturn(invalids[i]);
1:           expect(tm.getTransaction()).andReturn(null).anyTimes();
1:           c.replay();
1:         c.verify();
/////////////////////////////////////////////////////////////////////////
1:         tm.resume(t);
1:         EasyMock.expectLastCall();
1:         c.replay();
1:         c.verify();
1:         
1:         c.reset();
/////////////////////////////////////////////////////////////////////////
1:       expect(tm.getStatus()).andReturn(Status.STATUS_NO_TRANSACTION);
1:       expect(tm.getTransaction()).andReturn(null);
1:       tm.begin();
1:       expectLastCall();
1:       c.replay();
1:       c.verify();
1:       c.reset();
/////////////////////////////////////////////////////////////////////////
1:           c.reset();
1:           expect(tm.getStatus()).andReturn(invalids[i]);
1:           expect(tm.getTransaction()).andReturn(null);
1:           c.replay();
1:         c.verify();
1:     public void testRequiredFinish() throws Exception
1:         expect(tm.getStatus()).andReturn(Status.STATUS_MARKED_ROLLBACK);
1:         tm.rollback();
1:         expectLastCall();
1:         c.replay();
1:         c.verify();
/////////////////////////////////////////////////////////////////////////
1:           c.reset();
1:           expect(tm.getStatus()).andReturn(invalids[i]);
1:           tm.commit();
1:           expectLastCall();
1:           c.replay();
1:           c.verify();
1:         c.reset();
1:         c.replay();
1:         c.verify();
1:       expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:       // a new new transaction to begin
1:       expect(tm.suspend()).andReturn(null);
1:       expectLastCall();
1:       tm.begin();
1:       expectLastCall();
1:       expect(tm.getTransaction()).andReturn(null);
1:       c.replay();
1:       c.verify();
/////////////////////////////////////////////////////////////////////////
1:           c.reset();
1:           expect(tm.getStatus()).andReturn(manStatus[i]);
1:           expect(tm.getTransaction()).andReturn(null);
1:           tm.begin();
1:           expectLastCall();
1:           c.replay();
1:         c.verify();
1:     public void testRequiresNew_TmExceptions() throws Exception
/////////////////////////////////////////////////////////////////////////
1:           c.reset();
1:           expect(tm.getStatus()).andReturn(allStates[i]);
1:           expect(tm.getTransaction()).andReturn(null).anyTimes();
1:           tm.begin();
1:           expectLastCall().andThrow(e);
1:           requiresNewExceptionCheck(tm, allStates[i]);
1:     private void requiresNewExceptionCheck(TransactionManager tm, int managerStatus) throws Exception
1:       if (managerStatus == Status.STATUS_ACTIVE) {
1:           expect(tm.suspend()).andReturn(null);
1:       }
1:       tm.resume(EasyMock.anyObject(Transaction.class));
1:       expectLastCall();
1:       c.replay();
/////////////////////////////////////////////////////////////////////////
1:       c.verify();
1:       c.reset();
1:     public void testRequiresNew_Finish() throws Exception
1:         int[] allStates = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:                                      Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:                                      Status.STATUS_MARKED_ROLLBACK, Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1: 
1:         // Loop through all states calling TransactionStrategy.REQUIRES_NEW.finish
1:         // passing tran manager and a tran, then passing tran manager and null
1:         for (int i = 0 ; i < allStates.length ; i++ ) {
1:             c.reset();
1:             expect(tm.getStatus()).andReturn(allStates[i]);
1:             requiresNew_assertion(tm, allStates[i]);
1:             tm.resume(EasyMock.anyObject(Transaction.class));
1:             expectLastCall();
1:             c.replay();
1:             try {
0:                 TransactionToken tranToken = new TransactionToken(t, t, TransactionAttribute.REQUIRESNEW, true);
0:                 TransactionAttribute.REQUIRESNEW.finish(tm, tranToken);
1:             } catch (Exception e) {
1:                 fail("TransactionStrategy.REQUIRES_NEW.finish() threw unexpected exception when manager status is " + allStates[i]);
1:             }
1:             c.verify();
1:             c.reset();
1:             try {
1:                 expect(tm.getStatus()).andReturn(allStates[i]);
1:                 requiresNew_assertion(tm, allStates[i]);
1:                 c.replay();
0:                 TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.REQUIRESNEW, true);
0:                 TransactionAttribute.REQUIRESNEW.finish(tm, tranToken);
1:             } catch (Throwable e) {
1:                 e.printStackTrace();
1:                 fail("TransactionStrategy.REQUIRES_NEW.finish() threw unexpected exception when manager status is " + allStates[i]);
1:             } finally {
1:             }
1:             c.verify();
1: 
1:     // If tran manager status reports Status.STATUS_MARKED_ROLLBACK we expect
1:     // a call to rollback ... otherwise we expect a call to commit
1:     private void requiresNew_assertion(TransactionManager tm, int status) throws Exception
1:       if (status == Status.STATUS_MARKED_ROLLBACK) {
1:           tm.rollback();
1:           tm.commit();
1:       expectLastCall();
1:     public void testSupports() throws Exception
1:       expect(tm.getTransaction()).andReturn(null);
1:       expect(tm.getStatus()).andReturn(Status.STATUS_ACTIVE);
1:       c.replay();
1:       assertNull("TransTransactionStrategy.SUPPORTS.begin(tm) did not return null", TransactionAttribute.SUPPORTS.begin(tm).getActiveTransaction());
1:       c.verify();
commit:aa15c54
/////////////////////////////////////////////////////////////////////////
author:Lin Sun
-------------------------------------------------------------------------------
commit:92e371f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.aries.transaction.TransactionAttribute;
/////////////////////////////////////////////////////////////////////////
1:               "status is STATUS_NO_TRANSACTION", TransactionAttribute.MANDATORY.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
1:           Transaction tran = TransactionAttribute.MANDATORY.begin(tm).getActiveTransaction();
/////////////////////////////////////////////////////////////////////////
1:         TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.MANDATORY);
1:         TransactionAttribute.MANDATORY.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:         assertNotNull("TransactionStrategy.NEVER.begin() returned null when manager status is STATUS_ACTIVE", TransactionAttribute.NEVER.begin(tm));
/////////////////////////////////////////////////////////////////////////
0:           assertNull("TransactionStrategy.NEVER.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.NEVER.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
1:         TransactionToken tranToken = new TransactionToken(null, null, TransactionAttribute.NEVER);
1:         TransactionAttribute.NEVER.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:       TransactionAttribute.NOTSUPPORTED.begin(tm);
/////////////////////////////////////////////////////////////////////////
0:           assertNull("TransactionStrategy.NOT_SUPPORTED.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.NOTSUPPORTED.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:         TransactionToken tranToken = new TransactionToken(null, t, TransactionAttribute.NOTSUPPORTED);
0:         TransactionAttribute.NOTSUPPORTED.finish(tm, tranToken);
0:         tranToken = new TransactionToken(null, null, TransactionAttribute.NOTSUPPORTED);
0:         TransactionAttribute.NOTSUPPORTED.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
1:       TransactionAttribute.REQUIRED.begin(tm);
/////////////////////////////////////////////////////////////////////////
1:           assertNull("TransactionStrategy.REQUIRED.begin() did not return null when manager status value is " + invalids[i], TransactionAttribute.REQUIRED.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
1:         TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.REQUIRED, true);
1:         TransactionAttribute.REQUIRED.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
1:           TransactionAttribute.REQUIRED.finish(tm, tranToken);
1:         tranToken = new TransactionToken(null, null, TransactionAttribute.REQUIRED);
1:         TransactionAttribute.REQUIRED.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:       TransactionAttribute.REQUIRESNEW.begin(tm);
/////////////////////////////////////////////////////////////////////////
0:           assertNull("TransactionStrategy.REQUIRES_NEW.begin() did not return null when manager status value is " + manStatus[i], TransactionAttribute.REQUIRESNEW.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:           TransactionAttribute.REQUIRESNEW.begin(tm);
/////////////////////////////////////////////////////////////////////////
0:           TransactionToken tranToken = new TransactionToken(t, t, TransactionAttribute.REQUIRESNEW, true);
0:           TransactionAttribute.REQUIRESNEW.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:           TransactionToken tranToken = new TransactionToken(t, null, TransactionAttribute.REQUIRESNEW, true);
0:           TransactionAttribute.REQUIRESNEW.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:         assertNull("TransTransactionStrategy.SUPPORTS.begin(tm) did not return null", TransactionAttribute.SUPPORTS.begin(tm).getActiveTransaction());
author:Valentin Mahrwald
-------------------------------------------------------------------------------
commit:5c15102
/////////////////////////////////////////////////////////////////////////
0:               "status is STATUS_NO_TRANSACTION", TransactionStrategy.MANDATORY.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:           skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), invalids[i]);
0:           skel.setReturnValue(new MethodCall(TransactionManager.class, "getTransaction"), null);
0:           Transaction tran = TransactionStrategy.MANDATORY.begin(tm).getActiveTransaction();
1:           assertNull("TransactionStrategy.MANDATORY.begin() did not return null when manager status value is " + invalids[i], tran);
1:           fail("TransactionStrategy.MANDATORY.begin() threw Exception when manager status value is " + invalids[i]);
/////////////////////////////////////////////////////////////////////////
0:         TransactionToken tranToken = new TransactionToken(t, null, TransactionStrategy.MANDATORY);
0:         TransactionStrategy.MANDATORY.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getTransaction"), null);
0:           assertNull("TransactionStrategy.NEVER.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.NEVER.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:         TransactionToken tranToken = new TransactionToken(null, null, TransactionStrategy.NEVER);
0:         TransactionStrategy.NEVER.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:       TransactionStrategy.NOTSUPPORTED.begin(tm);
/////////////////////////////////////////////////////////////////////////
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getTransaction"), null);
0:           assertNull("TransactionStrategy.NOT_SUPPORTED.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.NOTSUPPORTED.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:         TransactionToken tranToken = new TransactionToken(null, t, TransactionStrategy.NOTSUPPORTED);
0:         TransactionStrategy.NOTSUPPORTED.finish(tm, tranToken);
0:         tranToken = new TransactionToken(null, null, TransactionStrategy.NOTSUPPORTED);
0:         TransactionStrategy.NOTSUPPORTED.finish(tm, tranToken);
1:           fail("TransactionStrategy.NOT_SUPPORTED.finish() threw unexpected exception, " + e);
/////////////////////////////////////////////////////////////////////////
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getTransaction"), null);
0:           assertNull("TransactionStrategy.REQUIRED.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.REQUIRED.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:         TransactionToken tranToken = new TransactionToken(t, null, TransactionStrategy.REQUIRED, true);
0:         TransactionStrategy.REQUIRED.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:           TransactionStrategy.REQUIRED.finish(tm, tranToken);
0:         tranToken = new TransactionToken(null, null, TransactionStrategy.REQUIRED);
0:         TransactionStrategy.REQUIRED.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:       TransactionStrategy.REQUIRESNEW.begin(tm);
/////////////////////////////////////////////////////////////////////////
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getTransaction"), null);
0:           assertNull("TransactionStrategy.REQUIRES_NEW.begin() did not return null when manager status value is " + manStatus[i], TransactionStrategy.REQUIRESNEW.begin(tm).getActiveTransaction());
/////////////////////////////////////////////////////////////////////////
0:         TransactionStrategy.REQUIRESNEW.begin(tm);
/////////////////////////////////////////////////////////////////////////
0:           TransactionToken tranToken = new TransactionToken(t, t, TransactionStrategy.REQUIRESNEW, true);
0:           TransactionStrategy.REQUIRESNEW.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:           TransactionToken tranToken = new TransactionToken(t, null, TransactionStrategy.REQUIRESNEW, true);
0:           TransactionStrategy.REQUIRESNEW.finish(tm, tranToken);
/////////////////////////////////////////////////////////////////////////
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getTransaction"), null);
0:         assertNull("TransTransactionStrategy.SUPPORTS.begin(tm) did not return null", TransactionStrategy.SUPPORTS.begin(tm).getActiveTransaction());
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:3fbf745
author:Joseph Alan Bohn
-------------------------------------------------------------------------------
commit:6f219fd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.aries.transaction;
1: 
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.fail;
1: 
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.Set;
1: 
1: import javax.transaction.NotSupportedException;
1: import javax.transaction.Status;
1: import javax.transaction.SystemException;
1: import javax.transaction.Transaction;
1: import javax.transaction.TransactionManager;
1: 
1: import org.junit.Before;
1: import org.junit.Test;
1: 
0: import org.apache.aries.transaction.TransactionStrategy;
0: import org.apache.aries.unittest.mocks.MethodCall;
0: import org.apache.aries.unittest.mocks.Skeleton;
1: 
1: public class TranStrategyTest {
1: 
0:     TransactionManager tm = Skeleton.newMock(TransactionManager.class);
0:     Transaction t = Skeleton.newMock(Transaction.class);
0:     Skeleton skel = Skeleton.getSkeleton(tm);
1:    
1:     @Before
1:     public void clean()
1:     {
0:       skel.clearMethodCalls();
1:     }
1:     
1:     @Test
1:     public void testMandatoryBegin() throws Exception
1:     {
1:       // MANDATORY strategy should throw IllegalStateException when tran manager 
1:       // status is Status.STATUS_NO_TRANSACTION it should not return null.
0:       skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), Status.STATUS_NO_TRANSACTION);
1: 
1:       try {
1:         assertNotNull("TransactionStrategy.MANDATORY.begin(tm) returned null when manager " +
0:               "status is STATUS_NO_TRANSACTION", TransactionStrategy.MANDATORY.begin(tm));
1:       } catch (IllegalStateException ise) {
1:           // Expected to be in here
1:       } catch (Exception e) {
1:           fail("TransactionStrategy.MANDATORY.begin() threw an unexpected exception when tran manager status is STATUS_NO_TRANSACTION");
1:       }
1:           
1:       // MANDATORY strategy should return null for all tran manager states other
1:       // than Status.STATUS_NO_TRANSACTION.
1:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:       
1:       for (int i = 0; i < invalids.length ; i++) {
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), invalids[i]);
1:         try {
0:           assertNull("TransactionStrategy.MANDATORY.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.MANDATORY.begin(tm));
1:         } catch (Exception ise) {
0:             fail("TransactionStrategy.MANDATORY.begin() threw Exception when manager status value is " + invalids[i]);
1:         } 
1:       }
1:     }
1:      
1:     @Test
1:     public void testMandatoryFinish()
1:     {
1:       try {
0:         TransactionStrategy.MANDATORY.finish(tm, t);
1:       } catch (Exception e) {
1:           fail("TransactionStrategy.MANDATORY.finish() threw an unexpected exception");
1:       }
1:     }
1:     
1:     
1:     @Test
1:     public void testNeverBegin() throws Exception
1:     {
0:       // NEVER strategy should throw IllegalStateException when tran manager 
0:       // status is Status.STATUS_ACTIVE it should not return null.
0:       skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), Status.STATUS_ACTIVE);
1:       
1:       try {
0:         assertNotNull("TransactionStrategy.NEVER.begin() returned null when manager status is STATUS_ACTIVE", TransactionStrategy.NEVER.begin(tm));
1:       } catch (IllegalStateException ise) {
1:           // Expect to be in here
1:       } catch (Exception e) {
0:           fail("TransactionStrategy.NEVER.begin() threw an unexpected exception when tran manager status is STATUS_ACTIVE");
1:       }
1:       
0:       // NEVER strategy should return null for all tran manager states other
0:       // than Status.STATUS_ACTIVE.
1:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:           Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:       
1:       for (int i = 0; i < invalids.length ; i++) {
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), invalids[i]);
1:         try {
0:           assertNull("TransactionStrategy.NEVER.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.NEVER.begin(tm));
1:         } catch (Exception ise) {
0:             fail("TransactionStrategy.NEVER.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:         } 
1:       }
1: 
1:     }
1:     
1:     @Test
1:     public void testNeverFinish()
1:     {
1:       try {
0:         TransactionStrategy.NEVER.finish(tm, t);
1:       } catch (Exception e) {
1:           fail("TransactionStrategy.NEVER.finish() threw an unexpected exception");
1:       }
1:     }
1:     
1:     @Test
1:     public void testNotSupportedBegin() throws Exception
1:     {
1:       // NOT_SUPPORTED strategy should suspend an active transaction
1:       // and _NOT_ begin a new one
0:       skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), Status.STATUS_ACTIVE);
1:        
0:       TransactionStrategy.NOT_SUPPORTED.begin(tm);
0:       skel.assertCalled(new MethodCall(TransactionManager.class, "suspend"));
0:       skel.assertNotCalled(new MethodCall(TransactionManager.class, "begin"));
1:        
1:       // For all situations where there is no active transaction the
1:       // NOT_SUPPORTED strategy should return null
1:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:           Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:       
1:       for (int i = 0; i < invalids.length ; i++) {
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), invalids[i]);
1:         try {
0:           assertNull("TransactionStrategy.NOT_SUPPORTED.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.NOT_SUPPORTED.begin(tm));
1:         } catch (Exception ise) {
1:             fail("TransactionStrategy.NOT_SUPPORTED.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:         } 
1:       }
1:      
1:     }
1:     
1:     @Test
1:     public void testNotSupportedFinish()
1:     {
1:       // If finish is called with a previously active transaction, then
1:       // we expect this transaction to be resumed for a NOT_SUPPORTED strategy
1:       try {
0:         TransactionStrategy.NOT_SUPPORTED.finish(tm, t);
0:         skel.assertCalled(new MethodCall(TransactionManager.class, "resume", t));
0:         skel.clearMethodCalls();
0:         TransactionStrategy.NOT_SUPPORTED.finish(tm, null);
0:         skel.assertNotCalled(new MethodCall(TransactionManager.class, "resume", Transaction.class));
1:       } catch (Exception e) {
0:           fail("TransactionStrategy.NOT_SUPPORTED.finish() threw unexpected exception");
1:       }
1:     }
1:     
1:     @Test
1:     public void testRequiredBegin() throws Exception
1:     {
1:       // If there is no previously active transaction when the REQUIRED strategy
1:       // is invoked then we expect a call to begin one
0:       skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), Status.STATUS_NO_TRANSACTION);
1:        
0:       TransactionStrategy.REQUIRED.begin(tm);
0:       skel.assertCalled(new MethodCall(TransactionManager.class, "begin"));
0:       skel.assertNotCalled(new MethodCall(TransactionManager.class, "suspend"));
1:        
1:       // For all cases where there is a transaction we expect REQUIRED to return null
1:       int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:       
1:       for (int i = 0; i < invalids.length ; i++) {
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), invalids[i]);
1:         try {
0:           assertNull("TransactionStrategy.REQUIRED.begin() did not return null when manager status value is " + invalids[i], TransactionStrategy.REQUIRED.begin(tm));
1:         } catch (Exception ise) {
1:             fail("TransactionStrategy.REQUIRED.begin() threw unexpected exception when manager status value is " + invalids[i]);
1:         } 
1:       }
1:     }
1:     
1:     @Test
0:     public void testRequiredFinish()
1:     {
1:       // In the REQUIRED strategy we expect a call to rollback when a call to finish()
1:       // is made with a tran where the tran manager status shows Status.STATUS_MARKED_ROLLBACK
0:       skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), Status.STATUS_MARKED_ROLLBACK);
1:       
1:       try {
0:         TransactionStrategy.REQUIRED.finish(tm, t);
0:         skel.assertCalled(new MethodCall(TransactionManager.class, "rollback"));
0:         skel.assertNotCalled(new MethodCall(TransactionManager.class, "commit"));
1:         
1:         int[] invalids = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:             Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:             Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:         
1:         // For all other tran manager states we expect a call to commit
1:         for (int i = 0; i < invalids.length ; i++) {
0:           skel.clearMethodCalls();
0:           skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), invalids[i]);
0:           TransactionStrategy.REQUIRED.finish(tm, t);
0:           skel.assertCalled(new MethodCall(TransactionManager.class, "commit"));
0:           skel.assertNotCalled(new MethodCall(TransactionManager.class, "rollback"));
1:         }
1:         
1:         // If null is passed instead of a tran we expect nothing to happen
0:         skel.clearMethodCalls();
0:         TransactionStrategy.REQUIRED.finish(tm, null);
0:         skel.assertNotCalled(new MethodCall(TransactionManager.class, "commit"));
0:         skel.assertNotCalled(new MethodCall(TransactionManager.class, "rollback"));
1:       
0:       }catch (Exception e) {
0:           fail("TransactionStrategy.REQUIRED.begin() threw unexpected exception");
1:       }
1:     }
1:     
1:     @Test
1:     public void testRequiresNew_BeginActiveTran() throws Exception
1:     {
1:       // Suspend case (no exception from tm.begin())
0:       skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), Status.STATUS_ACTIVE);
1:       
1:       // In the case of the REQUIRES_NEW strategy we expect an active tran to be suspended
0:       // a new new transaction to begin 
0:       TransactionStrategy.REQUIRES_NEW.begin(tm);
0:       skel.assertCalled(new MethodCall(TransactionManager.class, "suspend"));
0:       skel.assertCalled(new MethodCall(TransactionManager.class, "begin"));
1:       
1:     }
1:     
1:     @Test
1:     public void testRequiresNew_BeginNoActiveTran() throws Exception
1:     {
1:       // No active tran cases (no exception from tm.begin())
1: 
1:       int[] manStatus = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_MARKED_ROLLBACK,
1:           Status.STATUS_NO_TRANSACTION, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:       
1:       // For all cases where the tran manager state is _not_ Status.STATUS_ACTIVE 
1:       // we expect a call to begin a new tran, no call to suspend and null to be
1:       // returned from TransactionStrategy.REQUIRES_NEW.begin(tm)
1:       for (int i = 0; i < manStatus.length ; i++) {
0:         skel.clearMethodCalls();
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), manStatus[i]);
1:         try {
0:           assertNull("TransactionStrategy.REQUIRES_NEW.begin() did not return null when manager status value is " + manStatus[i], TransactionStrategy.REQUIRES_NEW.begin(tm));
0:           skel.assertCalled(new MethodCall(TransactionManager.class, "begin"));
0:           skel.assertNotCalled(new MethodCall(TransactionManager.class, "suspend"));
1:         } catch (Exception ise) {
1:             fail("TransactionStrategy.REQUIRES_NEW.begin() threw unexpected exception when manager status value is " + manStatus[i]);
1:         } 
1:       }
1:      
1:     }
1:     
1:     @Test
0:     public void testRequiresNew_TmExceptions()
1:     {
1:       int[] allStates = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_MARKED_ROLLBACK, Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:       
1:       // SystemException and NotSupportedException from tm.begin()
1:       Set<Exception> ees = new HashSet<Exception>();
1:       ees.add(new SystemException("KABOOM!"));
1:       ees.add(new NotSupportedException("KABOOM!"));
1:       
1:       // Loop through all states states twice changing the exception thrown
1:       // from tm.begin()
1:       for (int i = 0 ; i < allStates.length ; i++ ) {
1:         Iterator<Exception> iterator = ees.iterator();
1:         while (iterator.hasNext()) {
1:           Exception e = iterator.next();
0:           skel.clearMethodCalls();
0:           skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), allStates[i]);
0:           skel.setThrows(new MethodCall(TransactionManager.class, "begin"), e); 
0:           requiresNewExceptionCheck(tm, skel);
1:         }
1:       }
1:     }
1:     
0:     private void requiresNewExceptionCheck(TransactionManager tm, Skeleton skel)
1:     {
0:       int managerStatus = -1 ;
1:       
1:       try {
0:         managerStatus = tm.getStatus();
0:       } catch (SystemException se){
0:         fail("Unable to obtain tran manager status");
1:       }
1:       
1:       // If an ACTIVE tran is already present we expect a call to suspend this tran.
1:       // All states should call begin(), whereupon we receive our exception resulting
1:       // in calls to resume(t)
1:       
1:       try {
0:         TransactionStrategy.REQUIRES_NEW.begin(tm);
1:       } catch (SystemException se) {
1:           // Expect to be in here
1:       } catch (NotSupportedException nse) {
1:           // or to be in here
1:       } catch (Exception thrownE) {
1:           fail("TransactionStrategy.REQUIRES_NEW.begin() threw unexpected exception when manager status is " + managerStatus);
1:       } finally {
1:           // If Status.STATUS_ACTIVE
0:           if (managerStatus == 0) {
0:             skel.assertCalled(new MethodCall(TransactionManager.class, "suspend"));
0:           } else {
0:             skel.assertNotCalled(new MethodCall(TransactionManager.class, "suspend"));
1:           }
0:           skel.assertCalled(new MethodCall(TransactionManager.class, "begin"));
0:           skel.assertCalled(new MethodCall(TransactionManager.class, "resume", Transaction.class));
1:       }
1:     }
1:     
1:     @Test
0:     public void testRequiresNew_Finish()
1:     {
1:       int[] allStates = new int[]{ Status.STATUS_COMMITTED, Status.STATUS_COMMITTING, Status.STATUS_NO_TRANSACTION,
1:           Status.STATUS_ACTIVE, Status.STATUS_PREPARED, Status.STATUS_PREPARING, Status.STATUS_ROLLEDBACK, 
1:           Status.STATUS_MARKED_ROLLBACK, Status.STATUS_ROLLING_BACK, Status.STATUS_UNKNOWN };
1:      
0:       // Loop through all states calling TransactionStrategy.REQUIRES_NEW.finish
0:       // passing tran manager and a tran, then passing tran manager and null
1:       for (int i = 0 ; i < allStates.length ; i++ ) {
0:         skel.clearMethodCalls();
0:         skel.setReturnValue(new MethodCall(TransactionManager.class, "getStatus"), allStates[i]);
1:         
1:         try {
0:           TransactionStrategy.REQUIRES_NEW.finish(tm, t);
1:         } catch (Exception e) {
0:             fail("TransactionStrategy.REQUIRES_NEW.finish() threw unexpected exception when manager status is " + allStates[i]);
1:         } finally {
0:             requiresNew_assertion(skel, allStates, i);
0:             skel.assertCalled(new MethodCall(TransactionManager.class, "resume", t));
1:         }
1:         
1:         try {
0:           skel.clearMethodCalls();
0:           TransactionStrategy.REQUIRES_NEW.finish(tm, null);
1:         } catch (Exception e) {
0:             fail("TransactionStrategy.REQUIRES_NEW.finish() threw unexpected exception when manager status is " + allStates[i]);
1:         } finally {
0:             requiresNew_assertion(skel, allStates, i);
0:             skel.assertNotCalled(new MethodCall(TransactionManager.class, "resume", Transaction.class));
1:         }
1:       }
1:     
1:     }
1: 
0:     private void requiresNew_assertion(Skeleton skel, int[] allStates, int i)
1:     {
0:       // If tran manager status reports Status.STATUS_MARKED_ROLLBACK we expect
0:       // a call to rollback ... otherwise we expect a call to commit
0:       if (allStates[i] == Status.STATUS_MARKED_ROLLBACK) {
0:         skel.assertCalled(new MethodCall(TransactionManager.class, "rollback"));
0:         skel.assertNotCalled(new MethodCall(TransactionManager.class, "commit"));
1:       }
1:       else {
0:         skel.assertCalled(new MethodCall(TransactionManager.class, "commit"));
0:         skel.assertNotCalled(new MethodCall(TransactionManager.class, "rollback"));
1:       }
1:     }
1:     
1:     @Test
0:     public void testSupports()
1:     {
1:       try {
0:         assertNull("TransTransactionStrategy.SUPPORTS.begin(tm) did not return null", TransactionStrategy.SUPPORTS.begin(tm));
1:       } catch (Exception e) {
0:           fail("TransTransactionStrategy.SUPPORTS.begin(tm) threw an unexpected exception");
1:       }
1:       
1:     }
1: }
============================================================================