2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
12:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:28e234d: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   A b-tree controller corresponds to an instance of an open b-tree conglomerate.
1:eac0369:   <P>
1:227eaef:   <B>Concurrency Notes</B>
1:eac0369:   <P>
1:eac0369:   The concurrency rules are derived from OpenBTree.
1:eac0369:   <P>
1:eac0369:   @see OpenBTree
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class BTreeController extends OpenBTree implements ConglomerateController
1:1f9b9c4: {
1:eac0369: 
1:eac0369:     transient DataValueDescriptor[] scratch_template = null;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Whether to get lock on the row being inserted, usually this lock
1:eac0369:      * has already been gotten when the row was inserted into the base table.
1:eac0369:      **/
1:eac0369:     boolean get_insert_row_lock;
1:28e234d:     
1:28e234d:     //constants for the status of dupicate checking
1:28e234d:     private static final int NO_MATCH = 0;
1:28e234d:     private static final int MATCH_FOUND = 1;
1:28e234d:     private static final int RESCAN_REQUIRED = 2;
1:eac0369: 
1:eac0369:     /* Constructors: */
1:eac0369: 
1:eac0369: 	public BTreeController()
4:eac0369: 	{
5:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** private Methods of BTreeController
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Attempt to reclaim committed deleted rows from the page.
1:eac0369:      * <p>
1:eac0369:      * Get exclusive latch on page, and then loop backward through
1:eac0369:      * page searching for deleted rows which are committed.  The routine
1:eac0369:      * assumes that it is called from a transaction which cannot have 
1:eac0369:      * deleted any rows on the page.  For each deleted row on the page
1:eac0369:      * it attempts to get an exclusive lock on the deleted row, NOWAIT.
1:eac0369:      * If it succeeds, and since this row did not delete the row then the
1:eac0369:      * row must have been deleted by a transaction which has committed, so
1:eac0369:      * it is safe to purge the row.  It then purges the row from the page.
1:eac0369:      * <p>
1:eac0369:      * Note that this routine may remove all rows from the page, it will not
1:eac0369:      * attempt a merge in this situation.  This is because this routine is
1:eac0369:      * called from split which is attempting an insert on the given page, so
1:eac0369:      * it would be a waste to merge the page only to split it again to allow
1:eac0369:      * the insert of the row causing the split.
1:eac0369:      *
1:b1043a6: 	 * @return true if at least one row was purged.  If true, then the routine
1:b1043a6:      *              will leave the page latched, and the caller will release
1:b1043a6:      *              the latch by committing or aborting the transaction.  The
1:b1043a6:      *              latch must be held to end transaction to insure space on
1:b1043a6:      *              the page remains available for a undo of the purge.
1:eac0369:      *
1:eac0369:      * @param open_btree The already open btree to use to get latch on page.
1:eac0369:      * @param pageno     The page number of the leaf to attempt the reclaim on.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     private boolean reclaim_deleted_rows(
1:eac0369:     OpenBTree   open_btree,
1:eac0369:     long        pageno)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         boolean     purged_at_least_one_row = false;
1:eac0369:         ControlRow  controlRow              = null; 
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369: 
1:4a2b0d9:             if ((controlRow = ControlRow.get(open_btree, pageno)) == null)
1:eac0369:                 return(false);
1:eac0369: 
1:eac0369:             LeafControlRow leaf       = (LeafControlRow) controlRow;
1:eac0369: 
1:eac0369:             BTreeLockingPolicy  btree_locking_policy = 
1:eac0369:                 open_btree.getLockingPolicy();
1:eac0369: 
1:eac0369: 
1:eac0369:             // The number records that can be reclaimed is:
1:eac0369:             // total recs - control row - recs_not_deleted
1:eac0369:             int num_possible_commit_delete = 
1:eac0369:                 leaf.page.recordCount() - 1 - leaf.page.nonDeletedRecordCount();
1:eac0369: 
1:86e051f:             if (num_possible_commit_delete > 0)
1:eac0369:             {
1:eac0369: 
1:eac0369:                 Page page   = leaf.page;
1:eac0369: 
1:eac0369: 
1:eac0369:                 // RowLocation column is in last column of template.
1:eac0369:                 FetchDescriptor lock_fetch_desc = 
1:eac0369:                     RowUtil.getFetchDescriptorConstant(
1:eac0369:                         scratch_template.length - 1);
1:eac0369: 
1:eac0369:                 // loop backward so that purges which affect the slot table 
1:eac0369:                 // don't affect the loop (ie. they only move records we 
1:eac0369:                 // have already looked at).
1:eac0369:                 for (int slot_no = page.recordCount() - 1; 
1:eac0369:                      slot_no > 0; 
1:eac0369:                      slot_no--) 
1:eac0369:                 {
1:eac0369:                     if (page.isDeletedAtSlot(slot_no))
1:eac0369:                     {
1:eac0369:                         // try to get an exclusive lock on the row, if we can 
1:eac0369:                         // then the row is a committed deleted row and it is 
1:eac0369:                         // safe to purge it.
1:eac0369:                         if (btree_locking_policy.lockScanCommittedDeletedRow(
1:eac0369:                                 open_btree, leaf, scratch_template, 
1:eac0369:                                 lock_fetch_desc, slot_no))
1:eac0369:                         {
1:eac0369:                             // the row is a committed deleted row, purge it.
1:eac0369:                             page.purgeAtSlot(slot_no, 1, true);
1:eac0369: 
1:eac0369:                             purged_at_least_one_row = true;
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:             }
1:eac0369:         }
1:eac0369:         catch (java.lang.ClassCastException cce)
1:eac0369:         {
1:eac0369:             // because we give up the latch on the leaf before entering this
1:eac0369:             // routine, the page might change from a leaf to branch.  If that
1:eac0369:             // happens this routine will get a ClassCastException, and we
1:eac0369:             // just give up trying to reclaim space.
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:b1043a6:             if (controlRow != null) 
1:b1043a6:             {
1:b1043a6:                 if (purged_at_least_one_row) 
1:b1043a6:                 {
1:86e051f:                     // Set a hint in the page that scans positioned on it
1:86e051f:                     // need to reposition because rows have disappeared from
1:b1043a6:                     // the page.  If at least one row has been purged, then
1:b1043a6:                     // do not release the latch.  Purge requires latch to 
1:b1043a6:                     // be held until commit, where it will be released after
1:b1043a6:                     // the commit log record has been logged.
1:86e051f:                     controlRow.page.setRepositionNeeded();
1:86e051f:                 }
1:b1043a6:                 else
1:b1043a6:                 {
1:b1043a6:                     // Ok to release latch if no purging has happened.
1:b1043a6:                     controlRow.release();
1:86e051f:                 }
1:b1043a6:             }
1:eac0369:         }
1:15fbd86: 
1:15fbd86:         return(purged_at_least_one_row);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Start an internal transaction and do the split.
1:eac0369:      * <p>
1:eac0369:      * This routine starts a new transaction, and handles any errors that
1:eac0369:      * may come during the transaction.  This transation must not obtain any
1:eac0369:      * locks as they are likely to conflict with the current user transaction.
1:eac0369:      * <p>
1:eac0369:      * If attempt_to_reclaim_deleted_rows is true this routine will 
1:eac0369:      * attempt to reclaim space on the leaf page input, by purging 
1:eac0369:      * committed deleted rows from the leaf.  If it succeeds in purging at
1:eac0369:      * least one row, then it will commit the internal transaction and return
1:eac0369:      * without actually performing a split.  
1:eac0369:      *
1:eac0369:      * @param scratch_template  A scratch template used to search a page.
1:eac0369:      * @param rowToInsert       The row to insert, make sure during split to
1:eac0369:      *                          make room for this row.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     private long 
1:eac0369:     start_xact_and_dosplit(
1:eac0369:     boolean                 attempt_to_reclaim_deleted_rows,
1:eac0369:     long                    leaf_pageno,
1:eac0369:     DataValueDescriptor[]   scratch_template, 
1:eac0369:     DataValueDescriptor[]   rowToInsert,
1:eac0369:     int                     flag)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         TransactionManager split_xact       = null;
1:eac0369:         OpenBTree          split_open_btree = null;
1:eac0369:         ControlRow         root             = null;
1:eac0369: 
1:eac0369:         // Get an internal transaction to be used for the split.
1:eac0369:         split_xact = this.init_open_user_scans.getInternalTransaction();
1:eac0369: 
1:eac0369:         // open the btree again so that actions on it take place in the
1:eac0369:         // split_xact, don't get any locks in this transaction.
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:             if (((getOpenMode() & ContainerHandle.MODE_FORUPDATE) !=
1:eac0369: 								   ContainerHandle.MODE_FORUPDATE))
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "Container not opened with update should not cause split");
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369:         boolean do_split = true;
1:eac0369:         if (attempt_to_reclaim_deleted_rows)
1:eac0369:         {
1:eac0369:             // Get lock on base table.
1:eac0369: 
1:eac0369:             ConglomerateController base_cc = null;
1:eac0369: 
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 base_cc = 
1:eac0369:                     this.getConglomerate().lockTable(
1:eac0369:                         split_xact, 
1:eac0369:                         (ContainerHandle.MODE_FORUPDATE |
1:eac0369:                          ContainerHandle.MODE_LOCK_NOWAIT), 
1:eac0369:                         TransactionController.MODE_RECORD,
1:eac0369:                         TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369:             }
1:eac0369:             catch (StandardException se)
1:eac0369:             {
1:eac0369:                 // any error just don't try to reclaim deleted rows.  The
1:eac0369:                 // expected error is that we can't get the lock, which the
1:eac0369:                 // current interface throws as a containerNotFound exception.
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (base_cc != null)
1:eac0369:             {
1:eac0369:                 // we got IX lock on the base table, so can try reclaim space.
1:eac0369: 
1:eac0369: 
1:eac0369:                 // We can only reclaim space by opening the btree in row lock 
1:eac0369:                 // mode.  Table level lock row recovery is hard as we can't 
1:eac0369:                 // determine if the deleted rows we encounter have been 
1:eac0369:                 // deleted by our parent caller and have been committed or 
1:eac0369:                 // not.  We will have to get those rows offline.
1:eac0369:                 split_open_btree = new OpenBTree();
1:eac0369:                 split_open_btree.init(
1:eac0369:                     this.init_open_user_scans, 
1:eac0369:                     split_xact, 
1:eac0369:                     null,                           // open the container.
1:eac0369:                     split_xact.getRawStoreXact(), 
1:eac0369:                     false,
1:eac0369:                     (ContainerHandle.MODE_FORUPDATE | 
1:eac0369:                      ContainerHandle.MODE_LOCK_NOWAIT),
1:eac0369:                     TransactionManager.MODE_RECORD,
1:eac0369:                     this.getConglomerate().getBtreeLockingPolicy(
1:eac0369:                         split_xact.getRawStoreXact(), 
1:eac0369:                         TransactionController.MODE_RECORD,
1:eac0369:                         LockingPolicy.MODE_RECORD,
1:eac0369:                         TransactionController.ISOLATION_REPEATABLE_READ, 
1:eac0369:                         (ConglomerateController) base_cc, 
1:eac0369:                         split_open_btree),
2:eac0369:                     this.getConglomerate(), 
1:eac0369:                     (LogicalUndo) null,
1:eac0369:                     (DynamicCompiledOpenConglomInfo) null);
1:eac0369: 
1:eac0369:                 // don't split if we reclaim any rows.
1:eac0369:                 do_split = !reclaim_deleted_rows(split_open_btree, leaf_pageno);
1:eac0369: 
1:b1043a6:                 // on return if !do_split then the latch on leaf_pageno is held
1:b1043a6:                 // and will be released by the committing or aborting the 
1:b1043a6:                 // transaction.  If a purge has been done, no other action on
1:b1043a6:                 // the page should be attempted (ie. a split) before committing
1:b1043a6:                 // the purges.
1:b1043a6: 
1:eac0369:                 split_open_btree.close();
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         long new_leaf_pageno = leaf_pageno; 
1:eac0369:         if (do_split)
1:eac0369:         {
1:b1043a6:             // no space was reclaimed from deleted rows, so do split to allow
1:b1043a6:             // space for a subsequent insert.
1:b1043a6: 
1:eac0369:             split_open_btree = new OpenBTree();
1:eac0369:             split_open_btree.init(
1:eac0369:                 this.init_open_user_scans, 
1:eac0369:                 split_xact, 
1:eac0369:                 null,                           // open the container.
1:eac0369:                 split_xact.getRawStoreXact(), 
1:eac0369:                 false,
1:eac0369:                 getOpenMode(),                  // use same mode this controller
1:eac0369:                                                 // was opened with
1:eac0369:                 TransactionManager.MODE_NONE,
1:eac0369:                 this.getConglomerate().getBtreeLockingPolicy(
1:eac0369:                     split_xact.getRawStoreXact(), 
1:eac0369:                     this.init_lock_level,
1:eac0369:                     LockingPolicy.MODE_RECORD,
1:eac0369:                     TransactionController.ISOLATION_REPEATABLE_READ, 
1:eac0369:                     (ConglomerateController) null, // no base row locks during split
1:eac0369:                     split_open_btree),
1:eac0369:                 this.getConglomerate(), 
1:eac0369:                 (LogicalUndo) null,
1:eac0369:                 (DynamicCompiledOpenConglomInfo) null);
1:eac0369: 
1:eac0369: 
1:eac0369:             // Get the root page back, and perform a split following the
1:eac0369:             // to-be-inserted key.  The split releases the root page latch.
1:4a2b0d9:             root = ControlRow.get(split_open_btree, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(root.page.isLatched());
1:eac0369: 
1:eac0369:             new_leaf_pageno = 
1:eac0369:                 root.splitFor(
1:eac0369:                     split_open_btree, scratch_template, 
1:eac0369:                     null, rowToInsert, flag);
1:eac0369: 
1:eac0369:             split_open_btree.close();
1:eac0369:         }
1:eac0369: 
1:eac0369:         split_xact.commit();
1:eac0369: 
1:eac0369:         split_xact.destroy();
1:eac0369: 
1:eac0369:         return(new_leaf_pageno);
1:eac0369:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Compares the oldrow with the one at 'slot' or the one left to it. 
1:28e234d:      * If the slot is first slot it will move to the left sibiling of 
1:28e234d:      * the 'leaf' and will compare with the record from the last slot.
1:28e234d:      * @param slot slot number to start with
1:28e234d:      * @param leaf LeafControlRow of the current page
1:28e234d:      * @param rows DataValueDescriptot array to fill it with fetched values
2:28e234d:      * @return  0 if no duplicate
2:28e234d:      *          1 if duplicate 
2:28e234d:      *          2 if rescan required
1:28e234d:      * @throws StandardException
1:28e234d:      */
1:28e234d:     private int comparePreviousRecord (int slot, 
1:28e234d:                                     LeafControlRow  leaf, 
1:28e234d:                                     DataValueDescriptor [] rows,
1:28e234d:                                     DataValueDescriptor [] oldRows) 
1:28e234d:                                         throws StandardException {
1:28e234d:         RecordHandle rh = null;
1:28e234d:         boolean newLeaf = false;
1:28e234d:         LeafControlRow originalLeaf = leaf;
1:28e234d:         while (leaf != null) {
1:28e234d:             if (slot == 0) {
1:24d3856:                 LeafControlRow oldLeaf = leaf;
1:28e234d:                 try {
1:28e234d:                     //slot is pointing before the first slot
1:28e234d:                     //get left sibiling
1:28e234d:                     leaf = (LeafControlRow) leaf.getLeftSibling(this);
1:4f37664:                     if (newLeaf) {
1:4f37664:                         oldLeaf.release();
1:4f37664:                     }
1:4f37664:                     newLeaf = true;
1:28e234d:                     //no left sibiling
1:28e234d:                     if (leaf == null)
2:28e234d:                         return NO_MATCH;
1:28e234d:                     //set the slot to last slot number
1:28e234d:                     slot = leaf.page.recordCount() - 1;
1:8072a56:                     // DERBY-4027: We have moved to the previous page and need
1:8072a56:                     // to recheck that the slot number is valid (it won't be
1:8072a56:                     // if the page we moved to is empty). Restart from the top
1:8072a56:                     // of the loop body to get the slot number rechecked.
1:8072a56:                     continue;
1:28e234d:                 } catch (WaitError we) {
1:24d3856:                     // DERBY-4097: Couldn't latch the left sibling without
1:24d3856:                     // waiting. Release all latches and rescan from top of
1:24d3856:                     // B-tree to prevent deadlock.
1:24d3856:                     if (newLeaf) {
1:24d3856:                         oldLeaf.release();
1:24d3856:                     }
1:24d3856:                     originalLeaf.release();
1:24d3856:                     return RESCAN_REQUIRED;
1:28e234d:                 }
1:28e234d:             }
1:28e234d:             rh = leaf.page.fetchFromSlot(null, slot, rows, null, true);
1:28e234d:             if (rh != null) {
1:28e234d:                 int ret = compareRowsForInsert(rows, oldRows, leaf, slot);
1:4d5163b: 
1:4d5163b:                 // If we found a deleted row, we don't know whether there
1:4d5163b:                 // is a duplicate, so we need to continue the search.
1:4d5163b:                 final boolean continueSearch =
1:4d5163b:                         (ret == MATCH_FOUND && leaf.page.isDeletedAtSlot(slot));
1:4d5163b: 
1:4d5163b:                 if (!continueSearch) {
1:4d5163b:                     if (newLeaf) {
1:4d5163b:                         // Since we have moved away from the original leaf,
1:4d5163b:                         // we need some logic to make sure we don't hold
1:4d5163b:                         // latches that we're not supposed to hold.
1:4d5163b:                         if (ret == RESCAN_REQUIRED) {
1:4d5163b:                             // When a rescan is required, we must release the
1:4d5163b:                             // original leaf, since the callers expect all
1:4d5163b:                             // latches to have been released (and so they
1:4d5163b:                             // should have been, so this is probably a bug -
1:4d5163b:                             // see DERBY-4080).
1:4d5163b:                             originalLeaf.release();
1:4d5163b:                         }
1:4d5163b:                         if (ret != RESCAN_REQUIRED) {
1:4d5163b:                             // Since a rescan is not required, we still hold
1:4d5163b:                             // the latch on the non-original leaf. No other
1:4d5163b:                             // leaves than the original one should be latched
1:4d5163b:                             // when we return, so release the current leaf.
1:4d5163b:                             leaf.release();
1:4d5163b:                         }
1:4d5163b:                     }
1:4d5163b:                     return ret;
1:4d5163b:                 }
1:28e234d:             }
1:4d5163b:             slot--;
1:28e234d:         }
1:28e234d:         return NO_MATCH;
1:28e234d:     }
1:4d5163b:     
1:28e234d:     /**
1:28e234d:      * Compares the new record with the one at slot or the one 
1:28e234d:      * right to it. If the slot is last slot in the page it will move to 
1:28e234d:      * the right to sibling of the leaf and will compare with the record 
1:28e234d:      * from the last slot. 
1:28e234d:      * @param slot slot number to start with
1:28e234d:      * @param leaf LeafControlRow of the current page
1:28e234d:      * @param rows DataValueDescriptot array to fill it with fetched values
1:28e234d:      * @return  0 if no duplicate
1:28e234d:      *          1 if duplicate 
1:28e234d:      *          2 if rescan required
1:28e234d:      * @throws StandardException
1:28e234d:      */
1:28e234d:     private int compareNextRecord (int slot, 
1:28e234d:                                     LeafControlRow  leaf, 
1:28e234d:                                     DataValueDescriptor [] rows,
1:28e234d:                                     DataValueDescriptor [] oldRows) 
1:28e234d:                                         throws StandardException {
1:28e234d:         RecordHandle rh = null;
1:28e234d:         boolean newLeaf = false;
1:28e234d:         LeafControlRow originalLeaf = leaf;
1:28e234d:         while (leaf != null) {
1:28e234d:             if (slot >= leaf.page.recordCount()) {
1:28e234d:                 //slot is pointing to last slot
1:28e234d:                 //get next sibling
2:28e234d:                 LeafControlRow oldLeaf = leaf;
1:28e234d:                 leaf = (LeafControlRow) leaf.getRightSibling(this);
1:28e234d:                 if (newLeaf) {
2:28e234d:                     oldLeaf.release();
1:28e234d:                 }
2:28e234d:                 newLeaf = true;
1:28e234d:                 //this was right most leaf
1:28e234d:                 //no record at the right
1:28e234d:                 if (leaf == null)
1:28e234d:                     return NO_MATCH;
1:28e234d:                 //point slot to the first record of new leaf
1:28e234d:                 slot = 1;
1:8072a56:                 // DERBY-4027: We have moved to the next page and need
1:8072a56:                 // to recheck that the slot number is valid (it won't be
1:8072a56:                 // if the page we moved to is empty). Restart from the top
1:8072a56:                 // of the loop body to get the slot number rechecked.
1:8072a56:                 continue;
1:28e234d:             }
1:28e234d:             rh = leaf.page.fetchFromSlot(null, slot, rows, null, true);
1:28e234d:             if (rh != null) {
1:28e234d:                 int ret =  compareRowsForInsert(rows, oldRows, leaf, slot);
1:4d5163b: 
1:4d5163b:                 // If we found a deleted row, we don't know whether there
1:4d5163b:                 // is a duplicate, so we need to continue the search.
1:4d5163b:                 final boolean continueSearch =
1:4d5163b:                         (ret == MATCH_FOUND && leaf.page.isDeletedAtSlot(slot));
1:28e234d: 
1:4d5163b:                 if (!continueSearch) {
1:4d5163b:                     if (newLeaf) {
1:4d5163b:                         // Since we have moved away from the original leaf,
1:4d5163b:                         // we need some logic to make sure we don't hold
1:4d5163b:                         // latches that we're not supposed to hold.
1:4d5163b:                         if (ret == RESCAN_REQUIRED) {
1:4d5163b:                             // When a rescan is required, we must release the
1:4d5163b:                             // original leaf, since the callers expect all
1:4d5163b:                             // latches to have been released (and so they
1:4d5163b:                             // should have been, so this is probably a bug -
1:4d5163b:                             // see DERBY-4080).
1:4d5163b:                             originalLeaf.release();
1:4d5163b:                         }
1:4d5163b:                         if (ret != RESCAN_REQUIRED) {
1:4d5163b:                             // Since a rescan is not required, we still hold
1:4d5163b:                             // the latch on the non-original leaf. No other
1:4d5163b:                             // leaves than the original one should be latched
1:4d5163b:                             // when we return, so release the current leaf.
1:4d5163b:                             leaf.release();
1:4d5163b:                         }
1:28e234d:                     }
1:4d5163b:                     return ret;
1:28e234d:                 }
1:28e234d:             }
2:28e234d:             slot++;
1:28e234d:         }
1:28e234d:         return NO_MATCH;
1:28e234d:     }
1:28e234d:     
1:28e234d:     /**
1:4d5163b:      * Compares two rows for insert. If the two rows are not equal,
1:4d5163b:      * {@link #NO_MATCH} is returned. Otherwise, it tries to get a lock on
1:4d5163b:      * the row in the tree. If the lock is obtained without waiting,
1:4d5163b:      * {@link #MATCH_FOUND} is returned (even if the row has been deleted).
1:4d5163b:      * Otherwise, {@link #RESCAN_REQUIRED} is returned to indicate that the
1:4d5163b:      * latches have been released and the B-tree must be rescanned.
1:4d5163b:      *
1:4d5163b:      * If {@code MATCH_FOUND} is returned, the caller should check whether
1:4d5163b:      * the row has been deleted. If so, it may have to move to check the
1:4d5163b:      * adjacent rows to be sure that there is no non-deleted duplicate row.
1:4d5163b:      *
1:4d5163b:      * If {@code MATCH_FOUND} or {@code RESCAN_REQUIRED} is returned, the
1:4d5163b:      * transaction will hold an update lock on the specified record when
1:4d5163b:      * the method returns.
1:4d5163b:      *
1:4d5163b:      * <b>Note!</b> This method should only be called when the index is almost
1:4d5163b:      * unique (that is, a non-unique index backing a unique constraint).
1:4d5163b:      *
1:28e234d:      * @param originalRow row from the tree
1:28e234d:      * @param newRow row to be inserted
1:28e234d:      * @param leaf leaf where originalRow resides
1:28e234d:      * @param slot slot where originalRow
1:4d5163b:      * @return  {@code NO_MATCH} if no duplicate is found,
1:4d5163b:      *          {@code MATCH_FOUND} if a duplicate is found, or
1:4d5163b:      *          {@code RESCAN_REQUIRED} if the B-tree must be rescanned
1:28e234d:      */
1:28e234d:     private int compareRowsForInsert (DataValueDescriptor [] originalRow,
1:28e234d:                                       DataValueDescriptor [] newRow,
1:28e234d:                                       LeafControlRow leaf, int slot) 
1:28e234d:                                             throws StandardException {
1:28e234d:         for (int i = 0; i < originalRow.length - 1; i++) {
1:28e234d:             if (!originalRow [i].equals(newRow [i]))
1:28e234d:                 return NO_MATCH;
1:28e234d:         }
1:28e234d:         //It might be a deleted record try getting a lock on it
1:28e234d:         DataValueDescriptor[] template = runtime_mem.get_template(getRawTran());
1:28e234d:         FetchDescriptor lock_fetch_desc = RowUtil.getFetchDescriptorConstant(
1:28e234d:                                                     template.length - 1);
1:28e234d:         RowLocation lock_row_loc = 
1:28e234d:             (RowLocation) scratch_template[scratch_template.length - 1];
1:28e234d:         boolean latch_released = !getLockingPolicy().lockNonScanRowOnPage(
1:f6fea40:                 leaf, slot, lock_fetch_desc, template,
1:28e234d:                 lock_row_loc, ConglomerateController.LOCK_UPD);
1:28e234d:         //if latch was released some other transaction was operating on this
1:28e234d:         //record and might have changed the tree by now
1:28e234d:         if (latch_released)
1:28e234d:             return RESCAN_REQUIRED;
1:4d5163b: 
1:4d5163b:         return MATCH_FOUND;
1:28e234d:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Compares immidiate left and right records to check for duplicates.
1:28e234d:      * This methods compares new record (being inserted) with the record 
1:28e234d:      * in immidate left and right postion to see if its duplicate (only for
1:28e234d:      * almost unique index and for non null keys)
1:28e234d:      * @param rowToInsert row being inserted
1:28e234d:      * @param insert_slot slot where rowToInsert is being inserted
1:28e234d:      * @param targetleaf page where rowToInsert
1:28e234d:      * @return  0 if no duplicate
1:28e234d:      *          1 if duplicate 
1:28e234d:      *          2 if rescan required
1:28e234d:      * @throws StandardException
1:28e234d:      */
1:28e234d:     private int compareLeftAndRightSiblings (
1:28e234d:                             DataValueDescriptor[] rowToInsert, 
1:28e234d:                             int insert_slot, 
1:28e234d:                             LeafControlRow  targetleaf) throws StandardException {
1:28e234d:         //proceed only if almost unique index
1:28e234d:         if (this.getConglomerate().isUniqueWithDuplicateNulls()) {
1:28e234d:             int keyParts = rowToInsert.length - 1;
1:28e234d:             boolean hasnull = false;
1:28e234d:             for (int i = 0; i < keyParts; i++) {
1:28e234d:                 //keys with null in it are unique
1:28e234d:                 //no need to compare
1:28e234d:                 if (rowToInsert [i].isNull()) {
1:28e234d:                     return NO_MATCH;
1:28e234d:                 }
1:28e234d:             }
1:28e234d:             if (!hasnull) {
1:28e234d:                 DataValueDescriptor index [] =  
1:28e234d:                         runtime_mem.get_template(getRawTran());
1:28e234d:                 int ret = comparePreviousRecord(insert_slot - 1, 
1:28e234d:                         targetleaf, index, rowToInsert);
1:28e234d:                 if (ret > 0) {
3:28e234d:                     return ret;                        
1:28e234d:                 }
1:28e234d:                 return compareNextRecord(insert_slot, targetleaf, index, rowToInsert);
1:28e234d:             }
1:28e234d:         }
1:28e234d:         return NO_MATCH;
1:28e234d:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     Insert a row into the conglomerate.
1:eac0369: 
1:eac0369:     @param rowToInsert The row to insert into the conglomerate.  The stored
1:eac0369: 	representations of the row's columns are copied into a new row
1:eac0369: 	somewhere in the conglomerate.
1:eac0369: 
1:eac0369: 	@return Returns 0 if insert succeeded.  Returns 
1:eac0369:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
1:eac0369:     checks and has been created to disallow duplicates, and the row inserted
1:eac0369:     had key columns which were duplicate of a row already in the table.  Other
1:eac0369:     insert failures will raise StandardException's.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369: 	private int doIns(DataValueDescriptor[] rowToInsert)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		LeafControlRow  targetleaf                      = null;
1:eac0369: 		LeafControlRow  save_targetleaf                 = null;
1:eac0369:         int             insert_slot                     = 0;
1:eac0369:         int             result_slot                     = 0;
1:eac0369:         int             ret_val                         = 0;
1:eac0369:         boolean         reclaim_deleted_rows_attempted  = false;
1:eac0369: 
1:eac0369:         if (scratch_template == null)
1:722a889:         {
1:722a889:             scratch_template = runtime_mem.get_template(getRawTran());
1:28e234d:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             this.isIndexableRowConsistent(rowToInsert);
1:eac0369: 
1:eac0369:         // Create the objects needed for the insert.
1:eac0369:         // RESOLVE (mikem) - should we cache this in the controller?
1:eac0369:         SearchParameters sp = 
1:eac0369:             new SearchParameters(
2:eac0369:                 rowToInsert,
1:eac0369:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:eac0369:                 scratch_template, this, false);
1:eac0369: 
1:eac0369:         // RowLocation column is in last column of template.
1:eac0369:         FetchDescriptor lock_fetch_desc = 
1:eac0369:             RowUtil.getFetchDescriptorConstant(
1:eac0369:                 scratch_template.length - 1);
1:eac0369:         RowLocation lock_row_loc = 
1:eac0369:             (RowLocation) scratch_template[scratch_template.length - 1];
1:eac0369: 
1:eac0369:         // Row locking - lock the row being inserted.
1:eac0369: 
1:eac0369:         if (get_insert_row_lock)
1:722a889:         {
1:eac0369:             // I don't hold any latch yet so I can wait on this lock, so I
1:eac0369:             // don't care about return value from this call.  This
1:eac0369:             // lock can only wait if the base table row was inserted in a
1:eac0369:             // separate transaction which never happens in sql tables, but
1:eac0369:             // does happen in the sparse indexes that synchronization builds.
1:eac0369:         
1:eac0369:             this.getLockingPolicy().lockNonScanRow(
1:eac0369:                 this.getConglomerate(),
1:eac0369:                 (LeafControlRow) null,
1:eac0369:                 (LeafControlRow) null,
1:eac0369:                 rowToInsert, 
1:eac0369:                 (ConglomerateController.LOCK_INS | 
1:eac0369:                  ConglomerateController.LOCK_UPD));
1:28e234d:         }
1:eac0369: 
1:eac0369:         while (true)
1:eac0369:         {
1:eac0369:             // Search the location at which the new row should be inserted.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(this.container != null);
1:eac0369: 
1:eac0369:             targetleaf = (LeafControlRow)
1:4a2b0d9:                 ControlRow.get(this, BTree.ROOTPAGEID).search(sp);
1:eac0369: 
1:eac0369: 
1:eac0369:             // Row locking - first lock row previous to row being inserted:
1:eac0369:             //     o if (sp.resultExact) then the row must be deleted and
1:eac0369:             //           we will be replacing it with the new row, lock
1:eac0369:             //           the row before the slot as the previous key.
1:eac0369:             //     o else 
1:eac0369:             //           we will be inserting after the current slot so
1:eac0369:             //           lock the current slot as the previous key.
1:eac0369:             //
1:eac0369:             int slot_after_previous = 
1:eac0369:                 (sp.resultExact ? sp.resultSlot : sp.resultSlot + 1);
1:eac0369: 
1:eac0369:             boolean latch_released = false;
1:eac0369: 
1:eac0369:             latch_released = 
1:eac0369:                 !this.getLockingPolicy().lockNonScanPreviousRow(
1:eac0369:                     targetleaf, 
1:eac0369:                     slot_after_previous, 
1:eac0369:                     lock_fetch_desc,
1:eac0369:                     scratch_template,
1:eac0369:                     lock_row_loc,
1:eac0369:                     this, 
1:eac0369:                     (ConglomerateController.LOCK_INS_PREVKEY |
1:eac0369:                      ConglomerateController.LOCK_UPD),
1:eac0369:                     TransactionManager.LOCK_INSTANT_DURATION);
1:eac0369: 
1:eac0369:             // special test to see if latch release code works
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 latch_released = 
1:eac0369:                     test_errors(
1:eac0369:                         this,
1:86e051f:                         "BTreeController_doIns", null,
1:eac0369:                         this.getLockingPolicy(), 
1:eac0369:                         targetleaf, latch_released);
1:28e234d:             }
1:eac0369: 
1:eac0369:             if (latch_released)
1:eac0369:             {
1:eac0369:                 // Had to release latch in order to get the lock, probably 
1:eac0369:                 // because of a forward scanner, research tree, and try again.
1:eac0369:                 targetleaf = null;
1:eac0369:                 continue;
1:722a889:             }
1:eac0369: 
1:eac0369:             // If the row is there already, simply undelete it.
1:eac0369:             // The rationale for this is, since the index does
1:eac0369:             // not support duplicates, the only way we could
1:eac0369:             // find a duplicate is if we found a deleted row.
1:eac0369:             // If we could lock it, then no other transaction
1:eac0369:             // is deleting it; either this transaction deleted
1:eac0369:             // it earlier, or it's simply a row that the space
1:eac0369:             // reclaimer hasn't reclaimed yet.
1:eac0369:             // Since inserts are done directly (i.e., not to a
1:eac0369:             // location provided by a scan, we will see the 
1:eac0369:             // deleted row).
1:eac0369:             if (sp.resultExact)
1:eac0369:             {
1:eac0369:                 result_slot = insert_slot = sp.resultSlot;
1:eac0369: 
1:eac0369:                 if (this.getConglomerate().nKeyFields != 
1:eac0369:                         this.getConglomerate().nUniqueColumns)
1:eac0369:                 {
1:eac0369:                     // The key fields match, but not the row location.  We
1:eac0369:                     // must wait on the lock on the other row location before
1:eac0369:                     // preceding, so as to serialize behind any work being done
1:eac0369:                     // to the row as part of another transaction.
1:eac0369: 
1:eac0369:                     latch_released = 
1:eac0369:                         !this.getLockingPolicy().lockNonScanRowOnPage(
1:f6fea40:                             targetleaf, insert_slot,
1:eac0369:                             lock_fetch_desc, scratch_template, lock_row_loc,
1:eac0369:                             ConglomerateController.LOCK_UPD);
1:eac0369: 
1:eac0369:                     if (latch_released)
1:eac0369:                     {
1:eac0369:                         // Had to release latch in order to get the lock, 
1:eac0369:                         // probably to wait for deleting xact to commit or 
1:eac0369:                         // abort.  Research tree, and try again.
1:eac0369:                         targetleaf = null;
1:eac0369:                         continue;
1:722a889:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // The row better be deleted, or something is very wrong.
1:eac0369: 
1:eac0369:                 if (!(targetleaf.page.isDeletedAtSlot(insert_slot)))
1:eac0369:                 {
1:eac0369:                     // attempt to insert a duplicate into the index.
1:eac0369:                     ret_val = ConglomerateController.ROWISDUPLICATE;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     if (this.getConglomerate().nKeyFields == 
1:eac0369:                         this.getConglomerate().nUniqueColumns)
1:eac0369:                     {
1:eac0369:                         // The row that we found deleted is exactly the new row.
1:eac0369:                         targetleaf.page.deleteAtSlot(
1:eac0369:                             insert_slot, false, this.btree_undo);
1:eac0369: 
1:eac0369:                         break;
1:eac0369:                     }
1:eac0369:                     else if (this.getConglomerate().nUniqueColumns == 
1:eac0369:                              (this.getConglomerate().nKeyFields - 1))
1:eac0369:                     {
1:eac0369:                         // The row that we found deleted has matching keys
1:eac0369:                         // which form the unique key fields,
1:eac0369:                         // but the nonkey fields may differ (for now the
1:eac0369:                         // heap rowlocation is the only nonkey field 
1:eac0369:                         // allowed).
1:eac0369:                         
1:eac0369:                         // RESOLVE BT39 (mikem) - when/if heap row location
1:eac0369:                         // is not fixed we must handle update failing for
1:eac0369:                         // out of space and split if it does.  For now
1:eac0369:                         // if the update fails because of lack of space
1:eac0369:                         // an exception is thrown and the statement is 
1:eac0369:                         // backed out.  Should not happen very often.
1:eac0369:                         targetleaf.page.deleteAtSlot(
1:eac0369:                             insert_slot, false, this.btree_undo);
1:eac0369: 
1:eac0369:                         boolean update_succeeded = true;
1:eac0369:                         try 
1:eac0369:                         {
1:9a3cbed:                             if (runtime_mem.hasCollatedTypes())
1:9a3cbed:                             {
1:9a3cbed:                                 // See DERBY-5367.
1:9a3cbed:                                 // There are types in the BTree with a 
1:9a3cbed:                                 // collation different than UCS BASIC, we
1:9a3cbed:                                 // update all fields to make sure they hold
1:9a3cbed:                                 // the correct values.
1:9a3cbed:                                 // NOTE: We could optimize here by only
1:9a3cbed:                                 // updating the fields that actually hold
1:9a3cbed:                                 // collated types.
1:9a3cbed:                                 int rowsToUpdate = getConglomerate().nKeyFields;
1:9a3cbed:                                 for (int i=0; i < rowsToUpdate; i++) {
1:9a3cbed:                                 targetleaf.page.updateFieldAtSlot(
1:9a3cbed:                                     insert_slot, i, 
1:9a3cbed:                                     (DataValueDescriptor) RowUtil.getColumn(
1:9a3cbed:                                         rowToInsert, 
1:9a3cbed:                                         (FormatableBitSet) null, i),
1:9a3cbed:                                     this.btree_undo);
1:9a3cbed:                                 }
1:9a3cbed:                             }
1:9a3cbed:                             else
1:9a3cbed:                             {
1:9a3cbed:                                 // There are no collated types in the BTree,
1:9a3cbed:                                 // which means that the values currently
1:9a3cbed:                                 // stored in the undeleted row are correct.
1:9a3cbed:                                 // We simply update the row location to point
1:9a3cbed:                                 // to the correct row in the heap.
1:9a3cbed:                                 int rowloc_index =
1:9a3cbed:                                         this.getConglomerate().nKeyFields - 1;
1:9a3cbed:                                 targetleaf.page.updateFieldAtSlot(
1:9a3cbed:                                     insert_slot, rowloc_index, 
1:9a3cbed:                                     (DataValueDescriptor) RowUtil.getColumn(
1:9a3cbed:                                         rowToInsert, 
1:9a3cbed:                                         (FormatableBitSet) null, rowloc_index),
1:9a3cbed:                                     this.btree_undo);
1:9a3cbed:                             }
1:eac0369:                         }
1:eac0369:                         catch (StandardException se)
1:eac0369:                         {
1:eac0369:                             // check if the exception is for out of space
1:eac0369:                             if (!se.getMessageId().equals(SQLState.DATA_NO_SPACE_FOR_RECORD))
1:eac0369:                             {
1:eac0369:                                 throw se;
1:eac0369:                             }
1:eac0369: 
1:eac0369:                             // The statement exception is
1:eac0369:                             // because the update failed for out of
1:eac0369:                             // space (ie. the field got longer and there
1:eac0369:                             // is no room on the page for the expanded
1:eac0369:                             // field).  Address this error by falling
1:eac0369:                             // through the code and doing a split.
1:eac0369:                             update_succeeded = false;                          // update failed.
1:eac0369:                             targetleaf.page.deleteAtSlot(
1:eac0369:                                 insert_slot, true, this.btree_undo);
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         if (update_succeeded)
1:eac0369:                             break;
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         // Can only happen with non key fields in the btree.
1:eac0369:                         throw(
1:eac0369:                             StandardException.newException(
1:eac0369:                                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:0750c7b:             else if (targetleaf.page.recordCount() - 1 < BTree.maxRowsPerPage)
1:eac0369:             {
1:eac0369:                 // The row wasn't there, so try to insert it
1:eac0369:                 // on the page returned by the search.
1:eac0369:                 insert_slot = sp.resultSlot + 1;
1:eac0369:                 result_slot = insert_slot + 1;
1:0efe521:                 if (getConglomerate().isUniqueWithDuplicateNulls()) 
1:0efe521:                 {
1:28e234d:                     int ret = compareLeftAndRightSiblings(rowToInsert, 
1:28e234d:                             insert_slot, targetleaf);
1:0efe521:                     if (ret == MATCH_FOUND) 
1:0efe521:                     {
1:0efe521:                         ret_val = ConglomerateController.ROWISDUPLICATE;
1:0efe521:                         break;
1:0efe521:                     }
1:28e234d:                     if (ret == RESCAN_REQUIRED)
1:28e234d:                         continue;
1:28e234d:                 }
1:eac0369:                 // By default maxRowsPerPage is set to MAXINT, some tests
1:eac0369:                 // set it small to cause splitting to happen quicker with
1:eac0369:                 // less data.
1:eac0369: 
1:eac0369:                 if (targetleaf.page.insertAtSlot(
1:eac0369:                         insert_slot, 
1:eac0369:                         rowToInsert, (FormatableBitSet) null,
1:eac0369:                         this.btree_undo,
1:eac0369:                         Page.INSERT_DEFAULT,
1:eac0369: 						AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) != null)
1:eac0369:                 {
1:eac0369:                     // Insert succeeded, so we're done.
1:eac0369: 
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // RESOLVE (mikem) - another long row issue.
1:eac0369:                 // For now if a row does not fit on a page and there 
1:eac0369:                 // is only the control row on the page and at most one
1:eac0369:                 // other row on the page, throw an exception
1:eac0369: 
1:eac0369:                 if (targetleaf.page.recordCount() <= 2)
1:eac0369:                 {
2:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // start splitting ...
1:0efe521:             }
1:0efe521:             if (getConglomerate().isUniqueWithDuplicateNulls()) 
1:0efe521:             {
1:28e234d:                 int ret = compareLeftAndRightSiblings(rowToInsert, 
1:28e234d:                         insert_slot, targetleaf);
1:0efe521:                 if (ret == MATCH_FOUND) 
1:0efe521:                 {
1:0efe521:                     ret_val = ConglomerateController.ROWISDUPLICATE;
1:0efe521:                     break;
1:28e234d:                 }
1:28e234d:                 if (ret == RESCAN_REQUIRED)
1:28e234d:                     continue;
1:eac0369:             }
1:eac0369:             
1:eac0369:             // Create some space by splitting pages.
1:eac0369: 
1:eac0369:             // determine where in page/table row causing split would go
1:eac0369:             int flag = 0;
1:eac0369:             if (insert_slot == 1)
1:eac0369:             {
1:eac0369:                 flag |= ControlRow.SPLIT_FLAG_FIRST_ON_PAGE;
1:eac0369:                 if (targetleaf.isLeftmostLeaf())
1:eac0369:                     flag |= ControlRow.SPLIT_FLAG_FIRST_IN_TABLE;
1:eac0369:             }
1:eac0369:             else if (insert_slot == targetleaf.page.recordCount())
1:eac0369:             {
1:eac0369:                 flag |= ControlRow.SPLIT_FLAG_LAST_ON_PAGE;
1:eac0369:                 if (targetleaf.isRightmostLeaf())
1:eac0369:                     flag |= ControlRow.SPLIT_FLAG_LAST_IN_TABLE;
1:eac0369:             }
1:eac0369: 
1:eac0369:             long targetleaf_pageno = targetleaf.page.getPageNumber();
1:eac0369: 
1:eac0369:             if ((targetleaf.page.recordCount() - 
1:eac0369:                  targetleaf.page.nonDeletedRecordCount()) <= 0)
1:eac0369:             {
1:eac0369:                 // Don't do reclaim work if there are no deleted records.
1:eac0369:                 reclaim_deleted_rows_attempted = true;
1:eac0369:             }
1:eac0369: 
1:eac0369:             BranchRow branchrow = 
1:eac0369:                 BranchRow.createBranchRowFromOldLeafRow(
1:eac0369:                     rowToInsert, targetleaf_pageno);
1:eac0369: 
1:eac0369:             // Release the target page because (a) it may change as a 
1:eac0369:             // result of the split, (b) the latch ordering requires us 
1:eac0369:             // to acquire latches from top to bottom, and (c) this 
1:eac0369:             // loop should be done in a system transaction.
1:eac0369:             targetleaf.release();
1:eac0369:             targetleaf = null;
1:eac0369: 
1:eac0369:             start_xact_and_dosplit(
1:eac0369:                 !reclaim_deleted_rows_attempted, targetleaf_pageno, 
1:eac0369:                 scratch_template, branchrow.getRow(), flag);
1:eac0369: 
1:eac0369:             // only attempt to reclaim deleted rows once, otherwise the
1:eac0369:             // split loop could loop forever, trying to reclaim a deleted
1:eac0369:             // row that was not committed.
1:eac0369:             reclaim_deleted_rows_attempted = true;
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) possible optimization could be to save
1:eac0369:             // split location and look there first, if this has 
1:eac0369:             // already caused a split.  Or even return a latched page
1:eac0369:             // from splitFor().  For now just execute the loop again
1:eac0369:             // searching the tree for somewhere to put the row.
1:eac0369:         }
1:eac0369: 
1:eac0369:         // set in-memory hint of where last row on page was inserted.
1:eac0369:         targetleaf.last_search_result = result_slot;
1:eac0369: 
1:eac0369:         // Check that page just updated is consistent.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:             {
1:eac0369:                 targetleaf.checkConsistency(this, null, true);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Done with the target page.
1:eac0369:         targetleaf.release();
1:eac0369:         targetleaf = null;
1:eac0369: 
1:eac0369:         // return the status about insert - 0 is ok, or duplicate status.
1:eac0369:         return(ret_val);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Just insert the row on the current page/slot if it fits.
1:eac0369:      * <p>
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	private boolean do_load_insert(
1:eac0369:     DataValueDescriptor[]   rowToInsert,
1:eac0369:     LeafControlRow          leaf,
1:eac0369:     int                     insert_slot)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		LeafControlRow old_leaf         = null;
1:eac0369:         boolean        row_inserted     = false;
1:eac0369:         int            num_rows_on_page = leaf.page.recordCount() - 1;
1:eac0369: 
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(insert_slot == leaf.page.recordCount());
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 leaf.getrightSiblingPageNumber() == 
1:eac0369:                     ContainerHandle.INVALID_PAGE_NUMBER);
1:eac0369:             this.isIndexableRowConsistent(rowToInsert);
1:eac0369:         }
1:eac0369: 
1:0750c7b:         if (num_rows_on_page < BTree.maxRowsPerPage)
1:eac0369:         {
1:eac0369:             // By default maxRowsPerPage is set to MAXINT, some tests
1:eac0369:             // set it small to cause splitting to happen quicker with
1:eac0369:             // less data.
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // Caller should have sorted and done duplicate checking.
1:eac0369: 
1:eac0369:                 if (insert_slot > 1)
1:eac0369:                 {
1:eac0369:                     // verify that the row inserted is >= than previous row.
1:eac0369:                     int compare_result =
1:4a2b0d9:                         ControlRow.compareIndexRowFromPageToKey(
1:eac0369:                             leaf,
1:eac0369:                             insert_slot - 1,
1:eac0369:                             scratch_template,
1:eac0369:                             rowToInsert,
1:eac0369:                             this.getConglomerate().nUniqueColumns,
1:eac0369:                             0,
1:eac0369: 							this.getConglomerate().ascDescInfo);
1:eac0369:                     
1:eac0369:                     if (compare_result >= 0)
1:eac0369:                     {
1:eac0369:                         // Rows must be presented in order, so the row we are
1:eac0369:                         // inserting must always be greater than the previous 
1:eac0369:                         // row on the page.
1:eac0369:                         SanityManager.THROWASSERT("result = " + compare_result);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369: 
1:eac0369:             if (leaf.page.insertAtSlot(
1:eac0369:                     insert_slot, 
1:eac0369:                     rowToInsert, 
1:eac0369:                     (FormatableBitSet) null, 
1:eac0369:                     this.btree_undo,
1:eac0369:                     Page.INSERT_DEFAULT,
1:eac0369: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) != null)
1:eac0369:             {
1:eac0369:                 // Insert succeeded, so we're done.
1:eac0369:                 row_inserted = true;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // RESOLVE (mikem) - another long row issue.
1:eac0369:                 // For now if a row does not fit on a page and there 
1:eac0369:                 // is only the control row on the page and at most one
1:eac0369:                 // other row on the page, throw an exception
1:eac0369: 
1:eac0369:                 if (leaf.page.recordCount() <= 2)
1:eac0369:                 {
1:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Check that page just updated is consistent.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:             {
1:eac0369:                 leaf.checkConsistency(this, null, true);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(row_inserted);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create room to insert a row to the right of the largest key in table.
1:eac0369:      * <p>
1:eac0369:      * Perform a split pass on the tree which will move the largest key in
1:eac0369:      * leaf right to a new leaf, splitting parent branch pages as necessary.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	private LeafControlRow do_load_split(
1:eac0369:     DataValueDescriptor[]   rowToInsert,
1:eac0369:     LeafControlRow          leaf)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		LeafControlRow new_leaf = null;
1:eac0369: 
1:eac0369:         BranchRow branchrow = 
1:eac0369:             BranchRow.createBranchRowFromOldLeafRow(
1:eac0369:                 rowToInsert, leaf.page.getPageNumber());
1:eac0369: 
1:eac0369:         // Release the target page because (a) it may change as a 
1:eac0369:         // result of the split, (b) the latch ordering requires us 
1:eac0369:         // to acquire latches from top to bottom, and (c) this 
1:eac0369:         // loop should be done in a system transaction.
1:eac0369:         long old_leafpage = leaf.page.getPageNumber();
1:eac0369: 
2:28e234d:         leaf.release();
1:eac0369:         leaf = null;
1:eac0369:         
1:eac0369:         long new_leaf_pageno = 
1:eac0369:             start_xact_and_dosplit(
1:eac0369:                 false /* don't try to reclaim deleted rows */,
1:eac0369:                 old_leafpage,
1:eac0369:                 scratch_template, 
1:eac0369:                 branchrow.getRow(), 
1:eac0369:                 (ControlRow.SPLIT_FLAG_LAST_ON_PAGE | 
1:eac0369:                     ControlRow.SPLIT_FLAG_LAST_IN_TABLE));
1:eac0369: 
1:4a2b0d9:         new_leaf = (LeafControlRow) ControlRow.get(this, new_leaf_pageno);
1:eac0369: 
1:eac0369:         // The leaf must be the rightmost leaf in the table, the first time
1:eac0369:         // the root grows from leaf to branch it will be a leaf with many
1:eac0369:         // rows which will probably have to be split soon, after that it will
1:eac0369:         // be a leaf with only one row.  The current algorithm requires that
1:eac0369:         // there be at least one row for duplicate checking (the duplicate
1:eac0369:         // checking code does not handle going left to the previous leaf) - 
1:eac0369:         // this is the way the split at rightmost leaf row works currently.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (new_leaf.getrightSiblingPageNumber() != 
1:eac0369:                     ContainerHandle.INVALID_PAGE_NUMBER)
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "new_leaf.getrightSiblingPageNumber() = " + 
1:eac0369:                         new_leaf.getrightSiblingPageNumber());
1:eac0369:             }
1:eac0369:             if (new_leaf.page.recordCount() <= 1)
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "new_leaf.page.recordCount() = " + 
1:eac0369:                     new_leaf.page.recordCount());
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(new_leaf);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** public Methods of BTreeController
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Initialize the controller for use.
1:eac0369: 	<p>
1:eac0369: 	Any changes to this method will probably have to be reflected in close as 
1:eac0369:     well.
1:eac0369: 	<p>
1:eac0369: 	Currently delegates to OpenBTree.  If the btree controller ends up not 
1:eac0369:     having any state of its own, we can remove this method (the VM will 
1:eac0369:     dispatch to OpenBTree), gaining some small efficiency.  For now, this 
1:eac0369:     method remains for clarity.  
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public void init(
1:eac0369:     TransactionManager              xact_manager,
1:44e4f27:     boolean                         hold,
1:eac0369:     ContainerHandle                 container,
1:eac0369:     Transaction                     rawtran, 
1:eac0369: 	int					            open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     BTreeLockingPolicy              btree_locking_policy,
1:eac0369:     BTree                           conglomerate,
1:eac0369:     LogicalUndo                     undo,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         get_insert_row_lock = 
1:eac0369:             ((open_mode & 
1:eac0369:               TransactionController.OPENMODE_BASEROW_INSERT_LOCKED) == 0);
1:eac0369: 
1:eac0369: 		super.init(
1:eac0369:             xact_manager, xact_manager, 
1:44e4f27:             container, rawtran, hold, open_mode,
1:eac0369:             lock_level, btree_locking_policy,
1:eac0369:             conglomerate, undo, dynamic_info);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ConglomerateController
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:06dbbcf:     Close the conglomerate controller.
1:eac0369: 	<p>
1:eac0369: 	Any changes to this method will probably have to be reflected in close as 
1:eac0369:     well.
1:eac0369: 	<p>
1:eac0369: 	Currently delegates to OpenBTree.  If the btree controller ends up not 
1:eac0369:     having any state of its own, we can remove this method (the VM will 
1:eac0369:     dispatch to OpenBTree), gaining some small efficiency.  For now, this 
1:eac0369:     method remains for clarity.  
1:eac0369: 
1:eac0369: 	@see ConglomerateController#close
1:eac0369:     **/
1:eac0369:     public void close()
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		super.close();
1:eac0369: 
1:eac0369: 		// If we are closed due to catching an error in the middle of init,
1:eac0369: 		// xact_manager may not be set yet. 
1:eac0369: 		if (getXactMgr() != null)
1:eac0369: 			getXactMgr().closeMe(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Close conglomerate controller as part of terminating a transaction.
1:eac0369:      * <p>
1:eac0369:      * Use this call to close the conglomerate controller resources as part of
1:eac0369:      * committing or aborting a transaction.  The normal close() routine may 
1:eac0369:      * do some cleanup that is either unnecessary, or not correct due to the 
1:eac0369:      * unknown condition of the controller following a transaction ending error.
1:eac0369:      * Use this call when closing all controllers as part of an abort of a 
1:eac0369:      * transaction.
1:dbed020:      * <p>
1:eac0369:      * This call is meant to only be used internally by the Storage system,
1:eac0369:      * clients of the storage system should use the simple close() interface.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:06dbbcf:      * @param closeHeldScan     If true, means to close controller even if
1:06dbbcf:      *                          it has been opened to be kept opened 
1:06dbbcf:      *                          across commit.  This is
1:06dbbcf:      *                          used to close these controllers on abort.
1:eac0369:      *
1:eac0369: 	 * @return boolean indicating that the close has resulted in a real close
1:eac0369:      *                 of the controller.  A held scan will return false if 
1:eac0369:      *                 called by closeForEndTransaction(false), otherwise it 
1:eac0369:      *                 will return true.  A non-held scan will always return 
1:eac0369:      *                 true.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean closeForEndTransaction(boolean closeHeldScan)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         super.close();
1:eac0369: 
1:eac0369:         if ((!getHold()) || closeHeldScan) 
1:eac0369:         {
1:eac0369:             // If we are closed due to catching an error in the middle of init,
1:eac0369:             // xact_manager may not be set yet. 
1:eac0369:             if (getXactMgr() != null)
1:eac0369:                 getXactMgr().closeMe(this);
1:eac0369: 
1:eac0369:             return(true);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(false);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:3486786: 	/**
1:eac0369:     Insert a row into the conglomerate.
1:eac0369: 	@see ConglomerateController#insert
1:eac0369: 
1:eac0369:     @param row The row to insert into the conglomerate.  The stored
1:eac0369: 	representations of the row's columns are copied into a new row
1:eac0369: 	somewhere in the conglomerate.
1:eac0369: 
1:eac0369: 	@return Returns 0 if insert succeeded.  Returns 
1:eac0369:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
1:eac0369:     checks and has been created to disallow duplicates, and the row inserted
1:eac0369:     had key columns which were duplicate of a row already in the table.  Other
1:eac0369:     insert failures will raise StandardException's.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369: 	public int insert(DataValueDescriptor[] row) 
1:eac0369:          throws StandardException
1:eac0369:     {
1:eac0369: 
1:bbc927c: 		if (isClosed())
1:bbc927c:         {
1:bbc927c:             if (getHold())
1:bbc927c:             {
1:bbc927c:                 reopen();
1:bbc927c:             }
1:bbc927c:             else
1:bbc927c:             {
1:bbc927c:                 throw StandardException.newException(
1:bbc927c:                             SQLState.BTREE_IS_CLOSED,
1:ce40a31:                             err_containerid);
1:bbc927c:             } 
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(this.container != null);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return doIns(row);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	Return whether this is a keyed conglomerate.
1:eac0369: 	<p>
1:eac0369: 	All b-trees are keyed.
1:eac0369: 	@see ConglomerateController#isKeyed
1:eac0369: 	**/
1:eac0369: 	public boolean isKeyed()
1:eac0369: 	{
1:eac0369: 		return(true);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request the system properties associated with a table. 
1:eac0369:      * <p>
1:eac0369:      * Request the value of properties that are associated with a table.  The
1:eac0369:      * following properties can be requested:
1:eac0369:      *     derby.storage.pageSize 
1:eac0369:      *     derby.storage.pageReservedSpace
1:eac0369:      *     derby.storage.minimumRecordSize
1:eac0369:      *     derby.storage.initialPages
1:eac0369:      * <p>
1:eac0369:      * To get the value of a particular property add it to the property list,
1:eac0369:      * and on return the value of the property will be set to it's current 
1:eac0369:      * value.  For example:
1:eac0369:      *
1:eac0369:      * get_prop(ConglomerateController cc)
1:eac0369:      * {
1:eac0369:      *     Properties prop = new Properties();
1:eac0369:      *     prop.put("derby.storage.pageSize", "");
1:eac0369:      *     cc.getTableProperties(prop);
1:eac0369:      *
1:eac0369:      *     System.out.println(
1:eac0369:      *         "table's page size = " + 
1:eac0369:      *         prop.getProperty("derby.storage.pageSize");
1:eac0369:      * }
1:eac0369:      *
1:eac0369:      * @param prop   Property list to fill in.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void getTableProperties(Properties prop)
1:eac0369: 		throws StandardException
1:eac0369:     {
2:eac0369: 		if (this.container == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
2:eac0369:                         SQLState.BTREE_IS_CLOSED,
1:ce40a31:                         err_containerid);
1:eac0369:         }
1:eac0369: 
1:eac0369:         container.getContainerProperties(prop);
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request set of properties associated with a table. 
1:eac0369:      * <p>
1:eac0369:      * Returns a property object containing all properties that the store
1:eac0369:      * knows about, which are stored persistently by the store.  This set
1:eac0369:      * of properties may vary from implementation to implementation of the
1:eac0369:      * store.
1:eac0369:      * <p>
1:eac0369:      * This call is meant to be used only for internal query of the properties
1:eac0369:      * by jbms, for instance by language during bulk insert so that it can
1:eac0369:      * create a new conglomerate which exactly matches the properties that
1:eac0369:      * the original container was created with.  This call should not be used
1:eac0369:      * by the user interface to present properties to users as it may contain
1:eac0369:      * properties that are meant to be internal to jbms.  Some properties are 
1:eac0369:      * meant only to be specified by jbms code and not by users on the command
1:eac0369:      * line.
1:eac0369:      * <p>
1:eac0369:      * Note that not all properties passed into createConglomerate() are stored
1:eac0369:      * persistently, and that set may vary by store implementation.
1:eac0369:      *
1:eac0369:      * @param prop   Property list to add properties to.  If null, routine will
1:eac0369:      *               create a new Properties object, fill it in and return it.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public Properties getInternalTablePropertySet(Properties prop)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         Properties  ret_properties = 
1:eac0369:             ConglomerateUtil.createRawStorePropertySet(prop);
1:eac0369: 
1:eac0369:         getTableProperties(ret_properties);
1:eac0369: 
1:eac0369:         return(ret_properties);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Load rows from rowSource into the opened btree.
1:eac0369:      * <p>
1:eac0369:      * Efficiently load rows into the already opened btree.  The btree must
1:eac0369:      * be table locked, as no row locks will be requested by this routine.  
1:eac0369:      * On exit from this routine the conglomerate will be closed (on both
1:eac0369:      * error or success).
1:eac0369:      * <p>
1:eac0369:      * This routine does an almost bottom up build of a btree.  It assumes
1:eac0369:      * all rows arrive in sorted order, and inserts them directly into the
1:eac0369:      * next (to the right) spot in the current leaf until there is no space.
1:eac0369:      * Then it calls the generic split code to add the next leaf (RESOLVE - 
1:eac0369:      * in the future we could optimize this to split bottom up rather than
1:eac0369:      * top down for create index).
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.  If conglomerate
1:eac0369: 	 *                              supports uniqueness checks and has been 
1:eac0369:      *                              created to disallow duplicates, and one of 
1:eac0369:      *                              the rows being loaded had key columns which
1:eac0369:      *                              were duplicate of a row already in the 
1:eac0369:      *                              conglomerate, then raise 
1:eac0369:      *                              SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#load
1:eac0369:      **/
1:eac0369: 	public long load(
1:eac0369:     TransactionManager      xact_manager,
1:eac0369:     boolean                 createConglom,
1:eac0369:     RowLocationRetRowSource rowSource)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369:         long num_rows_loaded = 0;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(createConglom,
1:eac0369: 				"Cannot load a btree incrementally - it must either be entirely logged, or entirely not logged.  Doesn't make sense to log only the allocation when one cannot guarantee to not touch any pre-existing pages");
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if (scratch_template == null)
1:eac0369:         {
1:722a889:             scratch_template = runtime_mem.get_template(getRawTran());
1:eac0369:         }
1:eac0369: 
1:eac0369:         LeafControlRow current_leaf = null;
1:eac0369: 
1:eac0369:         try 
1:eac0369:         {
1:eac0369:             // Btree must just have been created and empty, so there must
1:eac0369:             // be one root leaf page which is empty except for the control row.
1:eac0369:             current_leaf = 
1:4a2b0d9:                 (LeafControlRow) ControlRow.get(this, BTree.ROOTPAGEID);
1:eac0369:             int current_insert_slot = 1;
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // root must be empty except for the control row.
1:eac0369:                 SanityManager.ASSERT(current_leaf.page.recordCount() == 1);
1:eac0369:             }
1:eac0369:            
1:eac0369:             // now loop thru the row source and insert into the btree
1:eac0369:             FormatableBitSet  validColumns = rowSource.getValidColumns();
1:eac0369:             
1:eac0369: 			// get the next row and its valid columns from the rowSource
1:eac0369: 			DataValueDescriptor[] row;
1:eac0369:             while ((row = rowSource.getNextRowFromRowSource()) != null)
1:eac0369:             {
1:eac0369:                 num_rows_loaded++;
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT(
1:eac0369:                         validColumns == null, "Does not support partial row");
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 while (true)
1:eac0369:                 {
1:eac0369:                     if (do_load_insert(row, current_leaf, current_insert_slot))
1:eac0369:                     {
1:eac0369:                         // row inserted successfully.
1:eac0369:                         break;
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         // if insert fails, do a split pass. There is an edge
1:eac0369:                         // case where multiple split passes are necessary if
1:eac0369:                         // branch splits are necessary, thus the loop.  It is
1:eac0369:                         // most likely that only a single split pass will be
1:eac0369:                         // necessary.
1:eac0369:                         current_leaf = do_load_split(row, current_leaf);
1:eac0369: 
1:eac0369:                         current_insert_slot = current_leaf.page.recordCount();
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 current_insert_slot++;
1:eac0369:             }
1:eac0369: 
1:eac0369:             current_leaf.release();
1:eac0369:             current_leaf = null;
1:eac0369: 
1:eac0369:             // Loading done, must flush all pages to disk since it is unlogged.
1:eac0369:             if (!this.getConglomerate().isTemporary())
1:eac0369:                 container.flushContainer();
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             this.close();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(num_rows_loaded);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ConglomerateController which are not supported.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Delete a row from the conglomerate.  
1:eac0369: 	@see ConglomerateController#delete
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean delete(RowLocation loc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         throw(StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Fetch the row at the given location.
1:eac0369: 	@see ConglomerateController#fetch
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean fetch(
1:eac0369:     RowLocation loc, 
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 validColumns) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         throw(StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Fetch the row at the given location.
1:eac0369: 	@see ConglomerateController#fetch
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean fetch(
1:eac0369:     RowLocation             loc, 
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 validColumns,
1:eac0369:     boolean                 waitForLock) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         throw(StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Insert a row into the conglomerate, and store its location in the
1:eac0369: 	provided template row location.
1:eac0369: 
1:eac0369:     Unimplemented by btree.
1:eac0369: 
1:eac0369: 	@see ConglomerateController#insertAndFetchLocation
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public void insertAndFetchLocation(
1:eac0369:     DataValueDescriptor[]	row,
1:eac0369:     RowLocation             templateRowLocation)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return a row location object of the correct type to be
1:eac0369: 	used in calls to insertAndFetchLocation.
1:eac0369: 
1:eac0369: 	@see ConglomerateController#newRowLocationTemplate
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public RowLocation newRowLocationTemplate()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the given row location.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @return true if lock was granted, only can be false if wait was false.
1:eac0369:      *
1:eac0369: 	 * @param loc    The "RowLocation" which describes the exact row to lock.
1:eac0369:      * @param wait   Should the lock call wait to be granted?
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean lockRow(
1:eac0369:     RowLocation loc,
1:eac0369:     int         lock_operation,
1:eac0369:     boolean     wait,
1:eac0369:     int         lock_duration)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public boolean lockRow(
1:eac0369:     long        page_num,
1:eac0369:     int         record_id,
1:eac0369:     int         lock_operation,
1:eac0369:     boolean     wait,
1:eac0369:     int         lock_duration)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public void unlockRowAfterRead(
1:eac0369:     RowLocation     loc,
1:eac0369:     boolean         forUpdate,
1:eac0369:     boolean         row_qualifies)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     Replace the entire row at the given location.  
1:eac0369: 	@see ConglomerateController#replace
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean replace(
1:eac0369:     RowLocation             loc, 
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 validColumns)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * <p>
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                             err_containerid);
/////////////////////////////////////////////////////////////////////////
1:                         err_containerid);
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f6fea40
/////////////////////////////////////////////////////////////////////////
1:                 leaf, slot, lock_fetch_desc, template,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             targetleaf, insert_slot,
commit:4f37664
/////////////////////////////////////////////////////////////////////////
1:                     if (newLeaf) {
1:                         oldLeaf.release();
1:                     }
1:                     newLeaf = true;
commit:24d3856
/////////////////////////////////////////////////////////////////////////
1:                 LeafControlRow oldLeaf = leaf;
/////////////////////////////////////////////////////////////////////////
1:                     // DERBY-4097: Couldn't latch the left sibling without
1:                     // waiting. Release all latches and rescan from top of
1:                     // B-tree to prevent deadlock.
1:                     if (newLeaf) {
1:                         oldLeaf.release();
1:                     }
1:                     originalLeaf.release();
1:                     return RESCAN_REQUIRED;
commit:86e051f
/////////////////////////////////////////////////////////////////////////
1:             if (num_possible_commit_delete > 0)
/////////////////////////////////////////////////////////////////////////
0:             if (controlRow != null) {
0:                 if (purged_at_least_one_row) {
1:                     // Set a hint in the page that scans positioned on it
1:                     // need to reposition because rows have disappeared from
0:                     // the page.
1:                     controlRow.page.setRepositionNeeded();
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:                         "BTreeController_doIns", null,
commit:4d5163b
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // If we found a deleted row, we don't know whether there
1:                 // is a duplicate, so we need to continue the search.
1:                 final boolean continueSearch =
1:                         (ret == MATCH_FOUND && leaf.page.isDeletedAtSlot(slot));
1: 
1:                 if (!continueSearch) {
1:                     if (newLeaf) {
1:                         // Since we have moved away from the original leaf,
1:                         // we need some logic to make sure we don't hold
1:                         // latches that we're not supposed to hold.
1:                         if (ret == RESCAN_REQUIRED) {
1:                             // When a rescan is required, we must release the
1:                             // original leaf, since the callers expect all
1:                             // latches to have been released (and so they
1:                             // should have been, so this is probably a bug -
1:                             // see DERBY-4080).
1:                             originalLeaf.release();
1:                         }
1:                         if (ret != RESCAN_REQUIRED) {
1:                             // Since a rescan is not required, we still hold
1:                             // the latch on the non-original leaf. No other
1:                             // leaves than the original one should be latched
1:                             // when we return, so release the current leaf.
1:                             leaf.release();
1:                         }
1:                     }
1:                     return ret;
1:             slot--;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // If we found a deleted row, we don't know whether there
1:                 // is a duplicate, so we need to continue the search.
1:                 final boolean continueSearch =
1:                         (ret == MATCH_FOUND && leaf.page.isDeletedAtSlot(slot));
1: 
1:                 if (!continueSearch) {
1:                     if (newLeaf) {
1:                         // Since we have moved away from the original leaf,
1:                         // we need some logic to make sure we don't hold
1:                         // latches that we're not supposed to hold.
1:                         if (ret == RESCAN_REQUIRED) {
1:                             // When a rescan is required, we must release the
1:                             // original leaf, since the callers expect all
1:                             // latches to have been released (and so they
1:                             // should have been, so this is probably a bug -
1:                             // see DERBY-4080).
1:                             originalLeaf.release();
1:                         }
1:                         if (ret != RESCAN_REQUIRED) {
1:                             // Since a rescan is not required, we still hold
1:                             // the latch on the non-original leaf. No other
1:                             // leaves than the original one should be latched
1:                             // when we return, so release the current leaf.
1:                             leaf.release();
1:                         }
1:                     }
1:                     return ret;
/////////////////////////////////////////////////////////////////////////
1:      * Compares two rows for insert. If the two rows are not equal,
1:      * {@link #NO_MATCH} is returned. Otherwise, it tries to get a lock on
1:      * the row in the tree. If the lock is obtained without waiting,
1:      * {@link #MATCH_FOUND} is returned (even if the row has been deleted).
1:      * Otherwise, {@link #RESCAN_REQUIRED} is returned to indicate that the
1:      * latches have been released and the B-tree must be rescanned.
1:      *
1:      * If {@code MATCH_FOUND} is returned, the caller should check whether
1:      * the row has been deleted. If so, it may have to move to check the
1:      * adjacent rows to be sure that there is no non-deleted duplicate row.
1:      *
1:      * If {@code MATCH_FOUND} or {@code RESCAN_REQUIRED} is returned, the
1:      * transaction will hold an update lock on the specified record when
1:      * the method returns.
1:      *
1:      * <b>Note!</b> This method should only be called when the index is almost
1:      * unique (that is, a non-unique index backing a unique constraint).
1:      *
1:      * @return  {@code NO_MATCH} if no duplicate is found,
1:      *          {@code MATCH_FOUND} if a duplicate is found, or
1:      *          {@code RESCAN_REQUIRED} if the B-tree must be rescanned
/////////////////////////////////////////////////////////////////////////
1: 
1:         return MATCH_FOUND;
commit:8072a56
/////////////////////////////////////////////////////////////////////////
1:                     // DERBY-4027: We have moved to the previous page and need
1:                     // to recheck that the slot number is valid (it won't be
1:                     // if the page we moved to is empty). Restart from the top
1:                     // of the loop body to get the slot number rechecked.
1:                     continue;
/////////////////////////////////////////////////////////////////////////
1:                 // DERBY-4027: We have moved to the next page and need
1:                 // to recheck that the slot number is valid (it won't be
1:                 // if the page we moved to is empty). Restart from the top
1:                 // of the loop body to get the slot number rechecked.
1:                 continue;
commit:15fbd86
/////////////////////////////////////////////////////////////////////////
1: 
1:         return(purged_at_least_one_row);
commit:3486786
/////////////////////////////////////////////////////////////////////////
1:     /**
commit:227eaef
/////////////////////////////////////////////////////////////////////////
1:   <B>Concurrency Notes</B>
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0750c7b
/////////////////////////////////////////////////////////////////////////
1:             else if (targetleaf.page.recordCount() - 1 < BTree.maxRowsPerPage)
/////////////////////////////////////////////////////////////////////////
1:         if (num_rows_on_page < BTree.maxRowsPerPage)
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a3cbed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             if (runtime_mem.hasCollatedTypes())
1:                             {
1:                                 // See DERBY-5367.
1:                                 // There are types in the BTree with a 
1:                                 // collation different than UCS BASIC, we
1:                                 // update all fields to make sure they hold
1:                                 // the correct values.
1:                                 // NOTE: We could optimize here by only
1:                                 // updating the fields that actually hold
1:                                 // collated types.
1:                                 int rowsToUpdate = getConglomerate().nKeyFields;
1:                                 for (int i=0; i < rowsToUpdate; i++) {
1:                                 targetleaf.page.updateFieldAtSlot(
1:                                     insert_slot, i, 
1:                                     (DataValueDescriptor) RowUtil.getColumn(
1:                                         rowToInsert, 
1:                                         (FormatableBitSet) null, i),
1:                                     this.btree_undo);
1:                                 }
1:                             }
1:                             else
1:                             {
1:                                 // There are no collated types in the BTree,
1:                                 // which means that the values currently
1:                                 // stored in the undeleted row are correct.
1:                                 // We simply update the row location to point
1:                                 // to the correct row in the heap.
1:                                 int rowloc_index =
1:                                         this.getConglomerate().nKeyFields - 1;
1:                                 targetleaf.page.updateFieldAtSlot(
1:                                     insert_slot, rowloc_index, 
1:                                     (DataValueDescriptor) RowUtil.getColumn(
1:                                         rowToInsert, 
1:                                         (FormatableBitSet) null, rowloc_index),
1:                                     this.btree_undo);
1:                             }
commit:f9cb888
/////////////////////////////////////////////////////////////////////////
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:             if ((controlRow = ControlRow.get(open_btree, pageno)) == null)
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(split_open_btree, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:                 ControlRow.get(this, BTree.ROOTPAGEID).search(sp);
/////////////////////////////////////////////////////////////////////////
1:                         ControlRow.compareIndexRowFromPageToKey(
/////////////////////////////////////////////////////////////////////////
1:         new_leaf = (LeafControlRow) ControlRow.get(this, new_leaf_pageno);
/////////////////////////////////////////////////////////////////////////
1:                 (LeafControlRow) ControlRow.get(this, BTree.ROOTPAGEID);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#load
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b1043a6
/////////////////////////////////////////////////////////////////////////
1: 	 * @return true if at least one row was purged.  If true, then the routine
1:      *              will leave the page latched, and the caller will release
1:      *              the latch by committing or aborting the transaction.  The
1:      *              latch must be held to end transaction to insure space on
1:      *              the page remains available for a undo of the purge.
/////////////////////////////////////////////////////////////////////////
1:             if (controlRow != null) 
1:             {
1:                 if (purged_at_least_one_row) 
1:                 {
1:                     // the page.  If at least one row has been purged, then
1:                     // do not release the latch.  Purge requires latch to 
1:                     // be held until commit, where it will be released after
1:                     // the commit log record has been logged.
1:                 else
1:                 {
1:                     // Ok to release latch if no purging has happened.
1:                     controlRow.release();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 // on return if !do_split then the latch on leaf_pageno is held
1:                 // and will be released by the committing or aborting the 
1:                 // transaction.  If a purge has been done, no other action on
1:                 // the page should be attempted (ie. a split) before committing
1:                 // the purges.
1: 
/////////////////////////////////////////////////////////////////////////
1:             // no space was reclaimed from deleted rows, so do split to allow
1:             // space for a subsequent insert.
1: 
commit:0efe521
/////////////////////////////////////////////////////////////////////////
1:                 if (getConglomerate().isUniqueWithDuplicateNulls()) 
1:                 {
1:                     if (ret == MATCH_FOUND) 
1:                     {
1:                         ret_val = ConglomerateController.ROWISDUPLICATE;
1:                         break;
1:                     }
/////////////////////////////////////////////////////////////////////////
1:             if (getConglomerate().isUniqueWithDuplicateNulls()) 
1:             {
1:                 if (ret == MATCH_FOUND) 
1:                 {
1:                     ret_val = ConglomerateController.ROWISDUPLICATE;
1:                     break;
1:                 }
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.RecordHandle;
/////////////////////////////////////////////////////////////////////////
1:     
1:     //constants for the status of dupicate checking
1:     private static final int NO_MATCH = 0;
1:     private static final int MATCH_FOUND = 1;
1:     private static final int RESCAN_REQUIRED = 2;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Compares the oldrow with the one at 'slot' or the one left to it. 
1:      * If the slot is first slot it will move to the left sibiling of 
1:      * the 'leaf' and will compare with the record from the last slot.
1:      * @param slot slot number to start with
1:      * @param leaf LeafControlRow of the current page
1:      * @param rows DataValueDescriptot array to fill it with fetched values
1:      * @return  0 if no duplicate
1:      *          1 if duplicate 
1:      *          2 if rescan required
1:      * @throws StandardException
1:      */
1:     private int comparePreviousRecord (int slot, 
1:                                     LeafControlRow  leaf, 
1:                                     DataValueDescriptor [] rows,
1:                                     DataValueDescriptor [] oldRows) 
1:                                         throws StandardException {
1:         RecordHandle rh = null;
1:         boolean newLeaf = false;
1:         LeafControlRow originalLeaf = leaf;
1:         while (leaf != null) {
1:             if (slot == 0) {
1:                 try {
1:                     LeafControlRow oldLeaf = leaf;
1:                     //slot is pointing before the first slot
1:                     //get left sibiling
1:                     leaf = (LeafControlRow) leaf.getLeftSibling(this);
1:                     //no left sibiling
1:                     if (leaf == null)
1:                         return NO_MATCH;
1:                     //set the slot to last slot number
1:                     slot = leaf.page.recordCount() - 1;
0:                     if (newLeaf)
1:                         oldLeaf.release();
1:                     newLeaf = true;
1:                 } catch (WaitError we) {
0:                     throw StandardException.plainWrapException(we);
1:                 }
1:             }
1:             rh = leaf.page.fetchFromSlot(null, slot, rows, null, true);
1:             if (rh != null) {
1:                 int ret = compareRowsForInsert(rows, oldRows, leaf, slot);
0:                 //release the page if required
0:                 if (ret == RESCAN_REQUIRED && newLeaf) {
0:                     originalLeaf.release();
1:                 }
0:                 if (ret != RESCAN_REQUIRED && newLeaf) {
1:                     leaf.release();
1:                 }
1:                 return ret;
1:             }
1:             slot++;
1:         }
1:         return NO_MATCH;
1:     }
1:     
1:     /**
1:      * Compares the new record with the one at slot or the one 
1:      * right to it. If the slot is last slot in the page it will move to 
1:      * the right to sibling of the leaf and will compare with the record 
1:      * from the last slot. 
1:      * @param slot slot number to start with
1:      * @param leaf LeafControlRow of the current page
1:      * @param rows DataValueDescriptot array to fill it with fetched values
1:      * @return  0 if no duplicate
1:      *          1 if duplicate 
1:      *          2 if rescan required
1:      * @throws StandardException
1:      */
1:     private int compareNextRecord (int slot, 
1:                                     LeafControlRow  leaf, 
1:                                     DataValueDescriptor [] rows,
1:                                     DataValueDescriptor [] oldRows) 
1:                                         throws StandardException {
1:         RecordHandle rh = null;
1:         boolean newLeaf = false;
1:         LeafControlRow originalLeaf = leaf;
1:         while (leaf != null) {
1:             if (slot >= leaf.page.recordCount()) {
1:                 //slot is pointing to last slot
1:                 //get next sibling
1:                 LeafControlRow oldLeaf = leaf;
1:                 leaf = (LeafControlRow) leaf.getRightSibling(this);
1:                 if (newLeaf) {
1:                     oldLeaf.release();
1:                 }
1:                 newLeaf = true;
1:                 //this was right most leaf
1:                 //no record at the right
1:                 if (leaf == null)
1:                     return NO_MATCH;
1:                 //point slot to the first record of new leaf
1:                 slot = 1;
1:             }
1:             rh = leaf.page.fetchFromSlot(null, slot, rows, null, true);
1:             if (rh != null) {
1:                 int ret =  compareRowsForInsert(rows, oldRows, leaf, slot);
0:                 if (ret == RESCAN_REQUIRED && newLeaf) {
0:                     originalLeaf.release();
1:                 }
0:                 if (ret != RESCAN_REQUIRED && newLeaf) {
1:                     leaf.release();
1:                 }
1:                 return ret;
1:             }
1:             slot++;
1:         }
1:         return NO_MATCH;
1:     }
1:     
1:     /**
0:      * Compares two row for insert. If the two rows are equal it checks if the 
0:      * row in tree is deleted. If not MATCH_FOUND is returned. If the row is 
0:      * deleted it tries to get a lock on that. If a lock is obtained without 
0:      * waiting (ie without losing the latch) the row was deleted within the 
0:      * same transaction and its safe to insert. NO_MATCH is returned in this 
0:      * case. If latch is released while waiting for lock rescaning the tree 
0:      * is required as the tree might have been rearanged by some other 
0:      * transaction. RESCAN_REQUIRED is returned in this case.
0:      * In case of NO_MATCH and MATCH_FOUND latch is also released.
1:      * @param originalRow row from the tree
1:      * @param newRow row to be inserted
1:      * @param leaf leaf where originalRow resides
1:      * @param slot slot where originalRow
1:      * @return  0 if no duplicate
1:      *          1 if duplicate 
1:      *          2 if rescan required
1:      */
1:     private int compareRowsForInsert (DataValueDescriptor [] originalRow,
1:                                       DataValueDescriptor [] newRow,
1:                                       LeafControlRow leaf, int slot) 
1:                                             throws StandardException {
1:         for (int i = 0; i < originalRow.length - 1; i++) {
1:             if (!originalRow [i].equals(newRow [i]))
1:                 return NO_MATCH;
1:         }
1:         //It might be a deleted record try getting a lock on it
1:         DataValueDescriptor[] template = runtime_mem.get_template(getRawTran());
1:         FetchDescriptor lock_fetch_desc = RowUtil.getFetchDescriptorConstant(
1:                                                     template.length - 1);
1:         RowLocation lock_row_loc = 
1:             (RowLocation) scratch_template[scratch_template.length - 1];
1:         boolean latch_released = !getLockingPolicy().lockNonScanRowOnPage(
0:                 this.getConglomerate(), leaf, slot, lock_fetch_desc,template, 
1:                 lock_row_loc, ConglomerateController.LOCK_UPD);
1:         //if latch was released some other transaction was operating on this
1:         //record and might have changed the tree by now
1:         if (latch_released)
1:             return RESCAN_REQUIRED;
0:         //there is match check if its not deleted
0:         if (!leaf.page.isDeletedAtSlot(slot)) {
0:             //its a genuine match
0:             return MATCH_FOUND;
1:         }
0:         //it is a deleted record within same transaction
0:         //safe to insert
1:         return NO_MATCH;
1:     }
1:     
1:     /**
1:      * Compares immidiate left and right records to check for duplicates.
1:      * This methods compares new record (being inserted) with the record 
1:      * in immidate left and right postion to see if its duplicate (only for
1:      * almost unique index and for non null keys)
1:      * @param rowToInsert row being inserted
1:      * @param insert_slot slot where rowToInsert is being inserted
1:      * @param targetleaf page where rowToInsert
1:      * @return  0 if no duplicate
1:      *          1 if duplicate 
1:      *          2 if rescan required
1:      * @throws StandardException
1:      */
1:     private int compareLeftAndRightSiblings (
1:                             DataValueDescriptor[] rowToInsert, 
1:                             int insert_slot, 
1:                             LeafControlRow  targetleaf) throws StandardException {
1:         //proceed only if almost unique index
1:         if (this.getConglomerate().isUniqueWithDuplicateNulls()) {
1:             int keyParts = rowToInsert.length - 1;
1:             boolean hasnull = false;
1:             for (int i = 0; i < keyParts; i++) {
1:                 //keys with null in it are unique
1:                 //no need to compare
1:                 if (rowToInsert [i].isNull()) {
1:                     return NO_MATCH;
1:                 }
1:             }
1:             if (!hasnull) {
1:                 DataValueDescriptor index [] =  
1:                         runtime_mem.get_template(getRawTran());
1:                 int ret = comparePreviousRecord(insert_slot - 1, 
1:                         targetleaf, index, rowToInsert);
1:                 if (ret > 0) {
1:                     return ret;                        
1:                 }
1:                 return compareNextRecord(insert_slot, targetleaf, index, rowToInsert);
1:             }
1:         }
1:         return NO_MATCH;
1:     }
/////////////////////////////////////////////////////////////////////////
0:                 if (getConglomerate().isUniqueWithDuplicateNulls()) {
1:                     int ret = compareLeftAndRightSiblings(rowToInsert, 
1:                             insert_slot, targetleaf);
0:                     if (ret == MATCH_FOUND)
0:                         return ConglomerateController.ROWISDUPLICATE;
1:                     if (ret == RESCAN_REQUIRED)
1:                         continue;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             if (getConglomerate().isUniqueWithDuplicateNulls()) {
1:                 int ret = compareLeftAndRightSiblings(rowToInsert, 
1:                         insert_slot, targetleaf);
0:                 if (ret == MATCH_FOUND)
0:                     return ConglomerateController.ROWISDUPLICATE;
1:                 if (ret == RESCAN_REQUIRED)
1:                     continue;
1:             }
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:         {
1:             scratch_template = runtime_mem.get_template(getRawTran());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         {
1:             scratch_template = runtime_mem.get_template(getRawTran());
1:         }
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
1:     Close the conglomerate controller.
/////////////////////////////////////////////////////////////////////////
1:      * @param closeHeldScan     If true, means to close controller even if
1:      *                          it has been opened to be kept opened 
1:      *                          across commit.  This is
1:      *                          used to close these controllers on abort.
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: 		if (isClosed())
1:         {
1:             if (getHold())
1:             {
1:                 reopen();
1:             }
1:             else
1:             {
1:                 throw StandardException.newException(
1:                             SQLState.BTREE_IS_CLOSED,
0:                             new Long(err_containerid));
1:             } 
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:44e4f27
/////////////////////////////////////////////////////////////////////////
1:     boolean                         hold,
/////////////////////////////////////////////////////////////////////////
1:             container, rawtran, hold, open_mode,
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeController
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
1: {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
0: import java.io.IOException;
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
1: 
1: 
1: 
1: /**
1: 
1:   A b-tree controller corresponds to an instance of an open b-tree conglomerate.
1:   <P>
0:   <B>Concurrency Notes<\B>
1:   <P>
1:   The concurrency rules are derived from OpenBTree.
1:   <P>
1:   @see OpenBTree
1: 
1: **/
1: 
1: public class BTreeController extends OpenBTree implements ConglomerateController
1: { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:     transient DataValueDescriptor[] scratch_template = null;
1: 
1:     /**
1:      * Whether to get lock on the row being inserted, usually this lock
1:      * has already been gotten when the row was inserted into the base table.
1:      **/
1:     boolean get_insert_row_lock;
1: 
1:     /* Constructors: */
1: 
1: 	public BTreeController()
1: 	{
1: 	}
1: 
1: 	/*
1: 	** private Methods of BTreeController
1: 	*/
1: 
1:     /**
1:      * Attempt to reclaim committed deleted rows from the page.
1:      * <p>
1:      * Get exclusive latch on page, and then loop backward through
1:      * page searching for deleted rows which are committed.  The routine
1:      * assumes that it is called from a transaction which cannot have 
1:      * deleted any rows on the page.  For each deleted row on the page
1:      * it attempts to get an exclusive lock on the deleted row, NOWAIT.
1:      * If it succeeds, and since this row did not delete the row then the
1:      * row must have been deleted by a transaction which has committed, so
1:      * it is safe to purge the row.  It then purges the row from the page.
1:      * <p>
1:      * Note that this routine may remove all rows from the page, it will not
1:      * attempt a merge in this situation.  This is because this routine is
1:      * called from split which is attempting an insert on the given page, so
1:      * it would be a waste to merge the page only to split it again to allow
1:      * the insert of the row causing the split.
1:      *
0: 	 * @return true if at least one row was purged.
1:      *
1:      * @param open_btree The already open btree to use to get latch on page.
1:      * @param pageno     The page number of the leaf to attempt the reclaim on.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private boolean reclaim_deleted_rows(
1:     OpenBTree   open_btree,
1:     long        pageno)
1: 		throws StandardException
1:     {
1:         boolean     purged_at_least_one_row = false;
1:         ControlRow  controlRow              = null; 
1: 
1:         try
1:         {
1: 
0:             if ((controlRow = ControlRow.Get(open_btree, pageno)) == null)
1:                 return(false);
1: 
1:             LeafControlRow leaf       = (LeafControlRow) controlRow;
1: 
1:             BTreeLockingPolicy  btree_locking_policy = 
1:                 open_btree.getLockingPolicy();
1: 
1: 
1:             // The number records that can be reclaimed is:
1:             // total recs - control row - recs_not_deleted
1:             int num_possible_commit_delete = 
1:                 leaf.page.recordCount() - 1 - leaf.page.nonDeletedRecordCount();
1: 
0:             if ((num_possible_commit_delete > 0) &&
0:                 (btree_locking_policy.lockScanForReclaimSpace(leaf)))
1:             {
0:                 // Need to get an exclusive scan lock on the page before we can
0:                 // do any sort of purges, otherwise other concurrent scans would
0:                 // not work.  If we can't get the lock NOWAIT, just give up on
0:                 // purging rows and do the split without reclaiming rows.
1: 
1:                 Page page   = leaf.page;
1: 
1: 
1:                 // RowLocation column is in last column of template.
1:                 FetchDescriptor lock_fetch_desc = 
1:                     RowUtil.getFetchDescriptorConstant(
1:                         scratch_template.length - 1);
1: 
1:                 // loop backward so that purges which affect the slot table 
1:                 // don't affect the loop (ie. they only move records we 
1:                 // have already looked at).
1:                 for (int slot_no = page.recordCount() - 1; 
1:                      slot_no > 0; 
1:                      slot_no--) 
1:                 {
1:                     if (page.isDeletedAtSlot(slot_no))
1:                     {
1:                         // try to get an exclusive lock on the row, if we can 
1:                         // then the row is a committed deleted row and it is 
1:                         // safe to purge it.
1:                         if (btree_locking_policy.lockScanCommittedDeletedRow(
1:                                 open_btree, leaf, scratch_template, 
1:                                 lock_fetch_desc, slot_no))
1:                         {
1:                             // the row is a committed deleted row, purge it.
1:                             page.purgeAtSlot(slot_no, 1, true);
1: 
1:                             purged_at_least_one_row = true;
1:                         }
1:                     }
1:                 }
1: 
1:             }
1:         }
1:         catch (java.lang.ClassCastException cce)
1:         {
1:             // because we give up the latch on the leaf before entering this
1:             // routine, the page might change from a leaf to branch.  If that
1:             // happens this routine will get a ClassCastException, and we
1:             // just give up trying to reclaim space.
1:         }
1:         finally
1:         {
0:             if (controlRow != null)
0:                 controlRow.release();
1: 
0:             return(purged_at_least_one_row);
1:         }
1:     }
1: 
1:     /**
1:      * Start an internal transaction and do the split.
1:      * <p>
1:      * This routine starts a new transaction, and handles any errors that
1:      * may come during the transaction.  This transation must not obtain any
1:      * locks as they are likely to conflict with the current user transaction.
1:      * <p>
1:      * If attempt_to_reclaim_deleted_rows is true this routine will 
1:      * attempt to reclaim space on the leaf page input, by purging 
1:      * committed deleted rows from the leaf.  If it succeeds in purging at
1:      * least one row, then it will commit the internal transaction and return
1:      * without actually performing a split.  
1:      *
1:      * @param scratch_template  A scratch template used to search a page.
1:      * @param rowToInsert       The row to insert, make sure during split to
1:      *                          make room for this row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private long 
1:     start_xact_and_dosplit(
1:     boolean                 attempt_to_reclaim_deleted_rows,
1:     long                    leaf_pageno,
1:     DataValueDescriptor[]   scratch_template, 
1:     DataValueDescriptor[]   rowToInsert,
1:     int                     flag)
1:         throws StandardException
1:     {
1:         TransactionManager split_xact       = null;
1:         OpenBTree          split_open_btree = null;
1:         ControlRow         root             = null;
1: 
1:         // Get an internal transaction to be used for the split.
1:         split_xact = this.init_open_user_scans.getInternalTransaction();
1: 
1:         // open the btree again so that actions on it take place in the
1:         // split_xact, don't get any locks in this transaction.
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1:             if (((getOpenMode() & ContainerHandle.MODE_FORUPDATE) !=
1: 								   ContainerHandle.MODE_FORUPDATE))
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "Container not opened with update should not cause split");
1:             }
1: 		}
1: 
1: 
1:         boolean do_split = true;
1:         if (attempt_to_reclaim_deleted_rows)
1:         {
1:             // Get lock on base table.
1: 
1:             ConglomerateController base_cc = null;
1: 
1:             try
1:             {
1:                 base_cc = 
1:                     this.getConglomerate().lockTable(
1:                         split_xact, 
1:                         (ContainerHandle.MODE_FORUPDATE |
1:                          ContainerHandle.MODE_LOCK_NOWAIT), 
1:                         TransactionController.MODE_RECORD,
1:                         TransactionController.ISOLATION_REPEATABLE_READ);
1:             }
1:             catch (StandardException se)
1:             {
1:                 // any error just don't try to reclaim deleted rows.  The
1:                 // expected error is that we can't get the lock, which the
1:                 // current interface throws as a containerNotFound exception.
1:             }
1: 
1:             if (base_cc != null)
1:             {
1:                 // we got IX lock on the base table, so can try reclaim space.
1: 
1: 
1:                 // We can only reclaim space by opening the btree in row lock 
1:                 // mode.  Table level lock row recovery is hard as we can't 
1:                 // determine if the deleted rows we encounter have been 
1:                 // deleted by our parent caller and have been committed or 
1:                 // not.  We will have to get those rows offline.
1:                 split_open_btree = new OpenBTree();
1:                 split_open_btree.init(
1:                     this.init_open_user_scans, 
1:                     split_xact, 
1:                     null,                           // open the container.
1:                     split_xact.getRawStoreXact(), 
1:                     false,
1:                     (ContainerHandle.MODE_FORUPDATE | 
1:                      ContainerHandle.MODE_LOCK_NOWAIT),
1:                     TransactionManager.MODE_RECORD,
1:                     this.getConglomerate().getBtreeLockingPolicy(
1:                         split_xact.getRawStoreXact(), 
1:                         TransactionController.MODE_RECORD,
1:                         LockingPolicy.MODE_RECORD,
1:                         TransactionController.ISOLATION_REPEATABLE_READ, 
1:                         (ConglomerateController) base_cc, 
1:                         split_open_btree),
1:                     this.getConglomerate(), 
1:                     (LogicalUndo) null,
1:                     (DynamicCompiledOpenConglomInfo) null);
1: 
1:                 // don't split if we reclaim any rows.
1:                 do_split = !reclaim_deleted_rows(split_open_btree, leaf_pageno);
1: 
1:                 split_open_btree.close();
1:             }
1:         }
1: 
1:         long new_leaf_pageno = leaf_pageno; 
1:         if (do_split)
1:         {
1:             split_open_btree = new OpenBTree();
1:             split_open_btree.init(
1:                 this.init_open_user_scans, 
1:                 split_xact, 
1:                 null,                           // open the container.
1:                 split_xact.getRawStoreXact(), 
1:                 false,
1:                 getOpenMode(),                  // use same mode this controller
1:                                                 // was opened with
1:                 TransactionManager.MODE_NONE,
1:                 this.getConglomerate().getBtreeLockingPolicy(
1:                     split_xact.getRawStoreXact(), 
1:                     this.init_lock_level,
1:                     LockingPolicy.MODE_RECORD,
1:                     TransactionController.ISOLATION_REPEATABLE_READ, 
1:                     (ConglomerateController) null, // no base row locks during split
1:                     split_open_btree),
1:                 this.getConglomerate(), 
1:                 (LogicalUndo) null,
1:                 (DynamicCompiledOpenConglomInfo) null);
1: 
1: 
1:             // Get the root page back, and perform a split following the
1:             // to-be-inserted key.  The split releases the root page latch.
0:             root = ControlRow.Get(split_open_btree, BTree.ROOTPAGEID);
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(root.page.isLatched());
1: 
1:             new_leaf_pageno = 
1:                 root.splitFor(
1:                     split_open_btree, scratch_template, 
1:                     null, rowToInsert, flag);
1: 
1:             split_open_btree.close();
1:         }
1: 
1:         split_xact.commit();
1: 
1:         split_xact.destroy();
1: 
1:         return(new_leaf_pageno);
1:     }
1: 
1: 	/**
1:     Insert a row into the conglomerate.
1: 
1:     @param rowToInsert The row to insert into the conglomerate.  The stored
1: 	representations of the row's columns are copied into a new row
1: 	somewhere in the conglomerate.
1: 
1: 	@return Returns 0 if insert succeeded.  Returns 
1:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
1:     checks and has been created to disallow duplicates, and the row inserted
1:     had key columns which were duplicate of a row already in the table.  Other
1:     insert failures will raise StandardException's.
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1: 	private int doIns(DataValueDescriptor[] rowToInsert)
1:         throws StandardException
1: 	{
1: 		LeafControlRow  targetleaf                      = null;
1: 		LeafControlRow  save_targetleaf                 = null;
1:         int             insert_slot                     = 0;
1:         int             result_slot                     = 0;
1:         int             ret_val                         = 0;
1:         boolean         reclaim_deleted_rows_attempted  = false;
1: 
1:         if (scratch_template == null)
0:             scratch_template = runtime_mem.get_template();
1: 
1:         if (SanityManager.DEBUG)
1:             this.isIndexableRowConsistent(rowToInsert);
1: 
1:         // Create the objects needed for the insert.
1:         // RESOLVE (mikem) - should we cache this in the controller?
1:         SearchParameters sp = 
1:             new SearchParameters(
1:                 rowToInsert,
1:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:                 scratch_template, this, false);
1: 
1:         // RowLocation column is in last column of template.
1:         FetchDescriptor lock_fetch_desc = 
1:             RowUtil.getFetchDescriptorConstant(
1:                 scratch_template.length - 1);
1:         RowLocation lock_row_loc = 
1:             (RowLocation) scratch_template[scratch_template.length - 1];
1: 
1:         // Row locking - lock the row being inserted.
1: 
1:         if (get_insert_row_lock)
1:         {
1:             // I don't hold any latch yet so I can wait on this lock, so I
1:             // don't care about return value from this call.  This
1:             // lock can only wait if the base table row was inserted in a
1:             // separate transaction which never happens in sql tables, but
1:             // does happen in the sparse indexes that synchronization builds.
1:         
1:             this.getLockingPolicy().lockNonScanRow(
1:                 this.getConglomerate(),
1:                 (LeafControlRow) null,
1:                 (LeafControlRow) null,
1:                 rowToInsert, 
1:                 (ConglomerateController.LOCK_INS | 
1:                  ConglomerateController.LOCK_UPD));
1:         }
1: 
1:         while (true)
1:         {
1:             // Search the location at which the new row should be inserted.
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(this.container != null);
1: 
1:             targetleaf = (LeafControlRow)
0:                 ControlRow.Get(this, BTree.ROOTPAGEID).search(sp);
1: 
1: 
1:             // Row locking - first lock row previous to row being inserted:
1:             //     o if (sp.resultExact) then the row must be deleted and
1:             //           we will be replacing it with the new row, lock
1:             //           the row before the slot as the previous key.
1:             //     o else 
1:             //           we will be inserting after the current slot so
1:             //           lock the current slot as the previous key.
1:             //
1:             int slot_after_previous = 
1:                 (sp.resultExact ? sp.resultSlot : sp.resultSlot + 1);
1: 
1:             boolean latch_released = false;
1: 
1:             latch_released = 
1:                 !this.getLockingPolicy().lockNonScanPreviousRow(
1:                     this.getConglomerate(),
1:                     targetleaf, 
1:                     slot_after_previous, 
1:                     lock_fetch_desc,
1:                     scratch_template,
1:                     lock_row_loc,
1:                     this, 
1:                     (ConglomerateController.LOCK_INS_PREVKEY |
1:                      ConglomerateController.LOCK_UPD),
1:                     TransactionManager.LOCK_INSTANT_DURATION);
1: 
1:             // special test to see if latch release code works
1:             if (SanityManager.DEBUG)
1:             {
1:                 latch_released = 
1:                     test_errors(
1:                         this,
0:                         "BTreeController_doIns", false,
1:                         this.getLockingPolicy(), 
1:                         targetleaf, latch_released);
1:             }
1: 
1:             if (latch_released)
1:             {
1:                 // Had to release latch in order to get the lock, probably 
1:                 // because of a forward scanner, research tree, and try again.
1:                 targetleaf = null;
1:                 continue;
1:             }
1: 
1:             // If the row is there already, simply undelete it.
1:             // The rationale for this is, since the index does
1:             // not support duplicates, the only way we could
1:             // find a duplicate is if we found a deleted row.
1:             // If we could lock it, then no other transaction
1:             // is deleting it; either this transaction deleted
1:             // it earlier, or it's simply a row that the space
1:             // reclaimer hasn't reclaimed yet.
1:             // Since inserts are done directly (i.e., not to a
1:             // location provided by a scan, we will see the 
1:             // deleted row).
1:             if (sp.resultExact)
1:             {
1:                 result_slot = insert_slot = sp.resultSlot;
1: 
1:                 if (this.getConglomerate().nKeyFields != 
1:                         this.getConglomerate().nUniqueColumns)
1:                 {
1:                     // The key fields match, but not the row location.  We
1:                     // must wait on the lock on the other row location before
1:                     // preceding, so as to serialize behind any work being done
1:                     // to the row as part of another transaction.
1: 
1:                     latch_released = 
1:                         !this.getLockingPolicy().lockNonScanRowOnPage(
0:                             this.getConglomerate(), targetleaf, insert_slot, 
1:                             lock_fetch_desc, scratch_template, lock_row_loc,
1:                             ConglomerateController.LOCK_UPD);
1: 
1:                     if (latch_released)
1:                     {
1:                         // Had to release latch in order to get the lock, 
1:                         // probably to wait for deleting xact to commit or 
1:                         // abort.  Research tree, and try again.
1:                         targetleaf = null;
1:                         continue;
1:                     }
1:                 }
1: 
1:                 // The row better be deleted, or something is very wrong.
1: 
1:                 if (!(targetleaf.page.isDeletedAtSlot(insert_slot)))
1:                 {
1:                     // attempt to insert a duplicate into the index.
1:                     ret_val = ConglomerateController.ROWISDUPLICATE;
1:                     break;
1:                 }
1:                 else
1:                 {
1:                     if (this.getConglomerate().nKeyFields == 
1:                         this.getConglomerate().nUniqueColumns)
1:                     {
1:                         // The row that we found deleted is exactly the new row.
1:                         targetleaf.page.deleteAtSlot(
1:                             insert_slot, false, this.btree_undo);
1: 
1:                         break;
1:                     }
1:                     else if (this.getConglomerate().nUniqueColumns == 
1:                              (this.getConglomerate().nKeyFields - 1))
1:                     {
1:                         // The row that we found deleted has matching keys
1:                         // which form the unique key fields,
1:                         // but the nonkey fields may differ (for now the
1:                         // heap rowlocation is the only nonkey field 
1:                         // allowed).
1:                         
1:                         // RESOLVE BT39 (mikem) - when/if heap row location
1:                         // is not fixed we must handle update failing for
1:                         // out of space and split if it does.  For now
1:                         // if the update fails because of lack of space
1:                         // an exception is thrown and the statement is 
1:                         // backed out.  Should not happen very often.
1:                         targetleaf.page.deleteAtSlot(
1:                             insert_slot, false, this.btree_undo);
1: 
1:                         boolean update_succeeded = true;
1: 
1:                         try 
1:                         {
0:                             int rowloc_index = 
0:                                 this.getConglomerate().nKeyFields - 1;
0:                             targetleaf.page.updateFieldAtSlot(
0:                                 insert_slot, rowloc_index, 
0:                                 (DataValueDescriptor) RowUtil.getColumn(
1:                                     rowToInsert, 
0:                                     (FormatableBitSet) null, rowloc_index),
0:                                 this.btree_undo);
1:                         }
1:                         catch (StandardException se)
1:                         {
1:                             // check if the exception is for out of space
1:                             if (!se.getMessageId().equals(SQLState.DATA_NO_SPACE_FOR_RECORD))
1:                             {
1:                                 throw se;
1:                             }
1: 
1:                             // The statement exception is
1:                             // because the update failed for out of
1:                             // space (ie. the field got longer and there
1:                             // is no room on the page for the expanded
1:                             // field).  Address this error by falling
1:                             // through the code and doing a split.
1:                             update_succeeded = false;                          // update failed.
1:                             targetleaf.page.deleteAtSlot(
1:                                 insert_slot, true, this.btree_undo);
1:                         }
1: 
1:                         if (update_succeeded)
1:                             break;
1:                     }
1:                     else
1:                     {
1:                         // Can only happen with non key fields in the btree.
1:                         throw(
1:                             StandardException.newException(
1:                                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1:                     }
1:                 }
1:             }
0:             else if (targetleaf.page.recordCount() - 1 < 
0:                     this.getConglomerate().maxRowsPerPage)
1:             {
1:                 // The row wasn't there, so try to insert it
1:                 // on the page returned by the search.
1:                 insert_slot = sp.resultSlot + 1;
1:                 result_slot = insert_slot + 1;
1: 
1:                 // By default maxRowsPerPage is set to MAXINT, some tests
1:                 // set it small to cause splitting to happen quicker with
1:                 // less data.
1: 
1:                 if (targetleaf.page.insertAtSlot(
1:                         insert_slot, 
1:                         rowToInsert, (FormatableBitSet) null,
1:                         this.btree_undo,
1:                         Page.INSERT_DEFAULT,
1: 						AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) != null)
1:                 {
1:                     // Insert succeeded, so we're done.
1: 
1:                     break;
1:                 }
1: 
1:                 // RESOLVE (mikem) - another long row issue.
1:                 // For now if a row does not fit on a page and there 
1:                 // is only the control row on the page and at most one
1:                 // other row on the page, throw an exception
1: 
1:                 if (targetleaf.page.recordCount() <= 2)
1:                 {
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
1:                 }
1: 
1:                 // start splitting ...
1:             }
1: 
1:             
1:             // Create some space by splitting pages.
1: 
1:             // determine where in page/table row causing split would go
1:             int flag = 0;
1:             if (insert_slot == 1)
1:             {
1:                 flag |= ControlRow.SPLIT_FLAG_FIRST_ON_PAGE;
1:                 if (targetleaf.isLeftmostLeaf())
1:                     flag |= ControlRow.SPLIT_FLAG_FIRST_IN_TABLE;
1:             }
1:             else if (insert_slot == targetleaf.page.recordCount())
1:             {
1:                 flag |= ControlRow.SPLIT_FLAG_LAST_ON_PAGE;
1:                 if (targetleaf.isRightmostLeaf())
1:                     flag |= ControlRow.SPLIT_FLAG_LAST_IN_TABLE;
1:             }
1: 
1:             long targetleaf_pageno = targetleaf.page.getPageNumber();
1: 
1:             if ((targetleaf.page.recordCount() - 
1:                  targetleaf.page.nonDeletedRecordCount()) <= 0)
1:             {
1:                 // Don't do reclaim work if there are no deleted records.
1:                 reclaim_deleted_rows_attempted = true;
1:             }
1: 
1:             BranchRow branchrow = 
1:                 BranchRow.createBranchRowFromOldLeafRow(
1:                     rowToInsert, targetleaf_pageno);
1: 
1:             // Release the target page because (a) it may change as a 
1:             // result of the split, (b) the latch ordering requires us 
1:             // to acquire latches from top to bottom, and (c) this 
1:             // loop should be done in a system transaction.
1:             targetleaf.release();
1:             targetleaf = null;
1: 
1:             start_xact_and_dosplit(
1:                 !reclaim_deleted_rows_attempted, targetleaf_pageno, 
1:                 scratch_template, branchrow.getRow(), flag);
1: 
1:             // only attempt to reclaim deleted rows once, otherwise the
1:             // split loop could loop forever, trying to reclaim a deleted
1:             // row that was not committed.
1:             reclaim_deleted_rows_attempted = true;
1: 
1:             // RESOLVE (mikem) possible optimization could be to save
1:             // split location and look there first, if this has 
1:             // already caused a split.  Or even return a latched page
1:             // from splitFor().  For now just execute the loop again
1:             // searching the tree for somewhere to put the row.
1:         }
1: 
1:         // set in-memory hint of where last row on page was inserted.
1:         targetleaf.last_search_result = result_slot;
1: 
1:         // Check that page just updated is consistent.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:             {
1:                 targetleaf.checkConsistency(this, null, true);
1:             }
1:         }
1: 
1:         // Done with the target page.
1:         targetleaf.release();
1:         targetleaf = null;
1: 
1:         // return the status about insert - 0 is ok, or duplicate status.
1:         return(ret_val);
1: 	}
1: 
1:     /**
1:      * Just insert the row on the current page/slot if it fits.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	private boolean do_load_insert(
1:     DataValueDescriptor[]   rowToInsert,
1:     LeafControlRow          leaf,
1:     int                     insert_slot)
1:         throws StandardException
1: 	{
1: 		LeafControlRow old_leaf         = null;
1:         boolean        row_inserted     = false;
1:         int            num_rows_on_page = leaf.page.recordCount() - 1;
1: 
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(insert_slot == leaf.page.recordCount());
1:             SanityManager.ASSERT(
1:                 leaf.getrightSiblingPageNumber() == 
1:                     ContainerHandle.INVALID_PAGE_NUMBER);
1:             this.isIndexableRowConsistent(rowToInsert);
1:         }
1: 
0:         if (num_rows_on_page < this.getConglomerate().maxRowsPerPage)
1:         {
1:             // By default maxRowsPerPage is set to MAXINT, some tests
1:             // set it small to cause splitting to happen quicker with
1:             // less data.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // Caller should have sorted and done duplicate checking.
1: 
1:                 if (insert_slot > 1)
1:                 {
1:                     // verify that the row inserted is >= than previous row.
1:                     int compare_result =
0:                         ControlRow.CompareIndexRowFromPageToKey(
1:                             leaf,
1:                             insert_slot - 1,
1:                             scratch_template,
1:                             rowToInsert,
1:                             this.getConglomerate().nUniqueColumns,
1:                             0,
1: 							this.getConglomerate().ascDescInfo);
1:                     
1:                     if (compare_result >= 0)
1:                     {
1:                         // Rows must be presented in order, so the row we are
1:                         // inserting must always be greater than the previous 
1:                         // row on the page.
1:                         SanityManager.THROWASSERT("result = " + compare_result);
1:                     }
1:                 }
1:             }
1: 
1: 
1:             if (leaf.page.insertAtSlot(
1:                     insert_slot, 
1:                     rowToInsert, 
1:                     (FormatableBitSet) null, 
1:                     this.btree_undo,
1:                     Page.INSERT_DEFAULT,
1: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) != null)
1:             {
1:                 // Insert succeeded, so we're done.
1:                 row_inserted = true;
1:             }
1:             else
1:             {
1:                 // RESOLVE (mikem) - another long row issue.
1:                 // For now if a row does not fit on a page and there 
1:                 // is only the control row on the page and at most one
1:                 // other row on the page, throw an exception
1: 
1:                 if (leaf.page.recordCount() <= 2)
1:                 {
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
1:                 }
1:             }
1:         }
1: 
1:         // Check that page just updated is consistent.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:             {
1:                 leaf.checkConsistency(this, null, true);
1:             }
1:         }
1: 
1:         return(row_inserted);
1: 	}
1: 
1:     /**
1:      * Create room to insert a row to the right of the largest key in table.
1:      * <p>
1:      * Perform a split pass on the tree which will move the largest key in
1:      * leaf right to a new leaf, splitting parent branch pages as necessary.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	private LeafControlRow do_load_split(
1:     DataValueDescriptor[]   rowToInsert,
1:     LeafControlRow          leaf)
1:         throws StandardException
1: 	{
1: 		LeafControlRow new_leaf = null;
1: 
1:         BranchRow branchrow = 
1:             BranchRow.createBranchRowFromOldLeafRow(
1:                 rowToInsert, leaf.page.getPageNumber());
1: 
1:         // Release the target page because (a) it may change as a 
1:         // result of the split, (b) the latch ordering requires us 
1:         // to acquire latches from top to bottom, and (c) this 
1:         // loop should be done in a system transaction.
1:         long old_leafpage = leaf.page.getPageNumber();
1: 
0:         leaf.release();
1:         leaf = null;
1:         
1:         long new_leaf_pageno = 
1:             start_xact_and_dosplit(
1:                 false /* don't try to reclaim deleted rows */,
1:                 old_leafpage,
1:                 scratch_template, 
1:                 branchrow.getRow(), 
1:                 (ControlRow.SPLIT_FLAG_LAST_ON_PAGE | 
1:                     ControlRow.SPLIT_FLAG_LAST_IN_TABLE));
1: 
0:         new_leaf = (LeafControlRow) ControlRow.Get(this, new_leaf_pageno);
1: 
1:         // The leaf must be the rightmost leaf in the table, the first time
1:         // the root grows from leaf to branch it will be a leaf with many
1:         // rows which will probably have to be split soon, after that it will
1:         // be a leaf with only one row.  The current algorithm requires that
1:         // there be at least one row for duplicate checking (the duplicate
1:         // checking code does not handle going left to the previous leaf) - 
1:         // this is the way the split at rightmost leaf row works currently.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (new_leaf.getrightSiblingPageNumber() != 
1:                     ContainerHandle.INVALID_PAGE_NUMBER)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "new_leaf.getrightSiblingPageNumber() = " + 
1:                         new_leaf.getrightSiblingPageNumber());
1:             }
1:             if (new_leaf.page.recordCount() <= 1)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "new_leaf.page.recordCount() = " + 
1:                     new_leaf.page.recordCount());
1:             }
1:         }
1: 
1:         return(new_leaf);
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	** public Methods of BTreeController
1: 	*/
1: 
1: 	/**
1: 	Initialize the controller for use.
1: 	<p>
1: 	Any changes to this method will probably have to be reflected in close as 
1:     well.
1: 	<p>
1: 	Currently delegates to OpenBTree.  If the btree controller ends up not 
1:     having any state of its own, we can remove this method (the VM will 
1:     dispatch to OpenBTree), gaining some small efficiency.  For now, this 
1:     method remains for clarity.  
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public void init(
1:     TransactionManager              xact_manager,
1:     ContainerHandle                 container,
1:     Transaction                     rawtran, 
1: 	int					            open_mode,
1:     int                             lock_level,
1:     BTreeLockingPolicy              btree_locking_policy,
1:     BTree                           conglomerate,
1:     LogicalUndo                     undo,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException
1: 	{
1:         get_insert_row_lock = 
1:             ((open_mode & 
1:               TransactionController.OPENMODE_BASEROW_INSERT_LOCKED) == 0);
1: 
1: 		super.init(
1:             xact_manager, xact_manager, 
0:             container, rawtran, false, open_mode,
1:             lock_level, btree_locking_policy,
1:             conglomerate, undo, dynamic_info);
1: 	}
1: 
1: 	/*
1: 	** Methods of ConglomerateController
1: 	*/
1: 
1:     /**
0:     Close the conglomerate controller
1: 	<p>
1: 	Any changes to this method will probably have to be reflected in close as 
1:     well.
1: 	<p>
1: 	Currently delegates to OpenBTree.  If the btree controller ends up not 
1:     having any state of its own, we can remove this method (the VM will 
1:     dispatch to OpenBTree), gaining some small efficiency.  For now, this 
1:     method remains for clarity.  
1: 
1: 	@see ConglomerateController#close
1:     **/
1:     public void close()
1:         throws StandardException
1: 	{
1: 		super.close();
1: 
1: 		// If we are closed due to catching an error in the middle of init,
1: 		// xact_manager may not be set yet. 
1: 		if (getXactMgr() != null)
1: 			getXactMgr().closeMe(this);
1: 	}
1: 
1:     /**
1:      * Close conglomerate controller as part of terminating a transaction.
1:      * <p>
1:      * Use this call to close the conglomerate controller resources as part of
1:      * committing or aborting a transaction.  The normal close() routine may 
1:      * do some cleanup that is either unnecessary, or not correct due to the 
1:      * unknown condition of the controller following a transaction ending error.
1:      * Use this call when closing all controllers as part of an abort of a 
1:      * transaction.
0:      * <p)
1:      * This call is meant to only be used internally by the Storage system,
1:      * clients of the storage system should use the simple close() interface.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
0:      * @param closeHeldController     If true, means to close controller even if
0:      *                                it has been opened to be kept opened 
0:      *                                across commit.  This is
0:      *                                used to close these controllers on abort.
1:      *
1: 	 * @return boolean indicating that the close has resulted in a real close
1:      *                 of the controller.  A held scan will return false if 
1:      *                 called by closeForEndTransaction(false), otherwise it 
1:      *                 will return true.  A non-held scan will always return 
1:      *                 true.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean closeForEndTransaction(boolean closeHeldScan)
1: 		throws StandardException
1:     {
1:         super.close();
1: 
1:         if ((!getHold()) || closeHeldScan) 
1:         {
1:             // If we are closed due to catching an error in the middle of init,
1:             // xact_manager may not be set yet. 
1:             if (getXactMgr() != null)
1:                 getXactMgr().closeMe(this);
1: 
1:             return(true);
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:             {
0:                 SanityManager.THROWASSERT("There is currently no requirement for a held btree conglomerate controller.");
1:             }
1: 
1:             return(false);
1:         }
1:     }
1: 
1: 	/**
1:     Insert a row into the conglomerate.
1: 	@see ConglomerateController#insert
1: 
1:     @param row The row to insert into the conglomerate.  The stored
1: 	representations of the row's columns are copied into a new row
1: 	somewhere in the conglomerate.
1: 
1: 	@return Returns 0 if insert succeeded.  Returns 
1:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
1:     checks and has been created to disallow duplicates, and the row inserted
1:     had key columns which were duplicate of a row already in the table.  Other
1:     insert failures will raise StandardException's.
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1: 	public int insert(DataValueDescriptor[] row) 
1:          throws StandardException
1:     {
1: 
1: 		if (this.container == null)       
1: 		{
1:             throw StandardException.newException(
1:                         SQLState.BTREE_IS_CLOSED,
0:                         new Long(err_containerid));
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(this.container != null);
1: 
0:             TemplateRow.checkPartialColumnTypes(
0:                 this.getConglomerate().format_ids, 
0:                 (FormatableBitSet) null, (int []) null, row);
1:         }
1: 
1: 		return doIns(row);
1: 	}
1: 
1:     /**
1: 	Return whether this is a keyed conglomerate.
1: 	<p>
1: 	All b-trees are keyed.
1: 	@see ConglomerateController#isKeyed
1: 	**/
1: 	public boolean isKeyed()
1: 	{
1: 		return(true);
1: 	}
1: 
1:     /*
1:      * Request the system properties associated with a table. 
1:      * <p>
1:      * Request the value of properties that are associated with a table.  The
1:      * following properties can be requested:
1:      *     derby.storage.pageSize 
1:      *     derby.storage.pageReservedSpace
1:      *     derby.storage.minimumRecordSize
1:      *     derby.storage.initialPages
1:      * <p>
1:      * To get the value of a particular property add it to the property list,
1:      * and on return the value of the property will be set to it's current 
1:      * value.  For example:
1:      *
1:      * get_prop(ConglomerateController cc)
1:      * {
1:      *     Properties prop = new Properties();
1:      *     prop.put("derby.storage.pageSize", "");
1:      *     cc.getTableProperties(prop);
1:      *
1:      *     System.out.println(
1:      *         "table's page size = " + 
1:      *         prop.getProperty("derby.storage.pageSize");
1:      * }
1:      *
1:      * @param prop   Property list to fill in.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void getTableProperties(Properties prop)
1: 		throws StandardException
1:     {
1: 		if (this.container == null)
1:         {
1:             throw StandardException.newException(
1:                         SQLState.BTREE_IS_CLOSED,
0:                         new Long(err_containerid));
1:         }
1: 
1:         container.getContainerProperties(prop);
1: 
1:         return;
1:     }
1: 
1:     /**
1:      * Request set of properties associated with a table. 
1:      * <p>
1:      * Returns a property object containing all properties that the store
1:      * knows about, which are stored persistently by the store.  This set
1:      * of properties may vary from implementation to implementation of the
1:      * store.
1:      * <p>
1:      * This call is meant to be used only for internal query of the properties
1:      * by jbms, for instance by language during bulk insert so that it can
1:      * create a new conglomerate which exactly matches the properties that
1:      * the original container was created with.  This call should not be used
1:      * by the user interface to present properties to users as it may contain
1:      * properties that are meant to be internal to jbms.  Some properties are 
1:      * meant only to be specified by jbms code and not by users on the command
1:      * line.
1:      * <p>
1:      * Note that not all properties passed into createConglomerate() are stored
1:      * persistently, and that set may vary by store implementation.
1:      *
1:      * @param prop   Property list to add properties to.  If null, routine will
1:      *               create a new Properties object, fill it in and return it.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public Properties getInternalTablePropertySet(Properties prop)
1: 		throws StandardException
1:     {
1:         Properties  ret_properties = 
1:             ConglomerateUtil.createRawStorePropertySet(prop);
1: 
1:         getTableProperties(ret_properties);
1: 
1:         return(ret_properties);
1:     }
1: 
1:     /**
1:      * Load rows from rowSource into the opened btree.
1:      * <p>
1:      * Efficiently load rows into the already opened btree.  The btree must
1:      * be table locked, as no row locks will be requested by this routine.  
1:      * On exit from this routine the conglomerate will be closed (on both
1:      * error or success).
1:      * <p>
1:      * This routine does an almost bottom up build of a btree.  It assumes
1:      * all rows arrive in sorted order, and inserts them directly into the
1:      * next (to the right) spot in the current leaf until there is no space.
1:      * Then it calls the generic split code to add the next leaf (RESOLVE - 
1:      * in the future we could optimize this to split bottom up rather than
1:      * top down for create index).
1:      *
1:      * @exception StandardException Standard exception policy.  If conglomerate
1: 	 *                              supports uniqueness checks and has been 
1:      *                              created to disallow duplicates, and one of 
1:      *                              the rows being loaded had key columns which
1:      *                              were duplicate of a row already in the 
1:      *                              conglomerate, then raise 
1:      *                              SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION.
1:      *
0: 	 * @see Conglomerate#load
1:      **/
1: 	public long load(
1:     TransactionManager      xact_manager,
1:     boolean                 createConglom,
1:     RowLocationRetRowSource rowSource)
1: 		 throws StandardException
1: 	{
1:         long num_rows_loaded = 0;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(createConglom,
1: 				"Cannot load a btree incrementally - it must either be entirely logged, or entirely not logged.  Doesn't make sense to log only the allocation when one cannot guarantee to not touch any pre-existing pages");
1: 		}
1: 
1:         if (scratch_template == null)
0:             scratch_template = runtime_mem.get_template();
1: 
1:         LeafControlRow current_leaf = null;
1: 
1:         try 
1:         {
1:             // Btree must just have been created and empty, so there must
1:             // be one root leaf page which is empty except for the control row.
1:             current_leaf = 
0:                 (LeafControlRow) ControlRow.Get(this, BTree.ROOTPAGEID);
1:             int current_insert_slot = 1;
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // root must be empty except for the control row.
1:                 SanityManager.ASSERT(current_leaf.page.recordCount() == 1);
1:             }
1:            
1:             // now loop thru the row source and insert into the btree
1:             FormatableBitSet  validColumns = rowSource.getValidColumns();
1:             
1: 			// get the next row and its valid columns from the rowSource
1: 			DataValueDescriptor[] row;
1:             while ((row = rowSource.getNextRowFromRowSource()) != null)
1:             {
1:                 num_rows_loaded++;
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT(
1:                         validColumns == null, "Does not support partial row");
1:                 }
1: 
1:                 while (true)
1:                 {
1:                     if (do_load_insert(row, current_leaf, current_insert_slot))
1:                     {
1:                         // row inserted successfully.
1:                         break;
1:                     }
1:                     else
1:                     {
1:                         // if insert fails, do a split pass. There is an edge
1:                         // case where multiple split passes are necessary if
1:                         // branch splits are necessary, thus the loop.  It is
1:                         // most likely that only a single split pass will be
1:                         // necessary.
1:                         current_leaf = do_load_split(row, current_leaf);
1: 
1:                         current_insert_slot = current_leaf.page.recordCount();
1:                     }
1:                 }
1:                 current_insert_slot++;
1:             }
1: 
1:             current_leaf.release();
1:             current_leaf = null;
1: 
1:             // Loading done, must flush all pages to disk since it is unlogged.
1:             if (!this.getConglomerate().isTemporary())
1:                 container.flushContainer();
1:         }
1:         finally
1:         {
1:             this.close();
1:         }
1: 
1:         return(num_rows_loaded);
1: 	}
1: 
1: 	/*
1: 	** Methods of ConglomerateController which are not supported.
1: 	*/
1: 
1:     /**
1:     Delete a row from the conglomerate.  
1: 	@see ConglomerateController#delete
1: 
1:     @exception StandardException Standard exception policy.
1:     **/
1:     public boolean delete(RowLocation loc)
1: 		throws StandardException
1: 	{
1:         throw(StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1: 	}
1: 
1:     /**
1:     Fetch the row at the given location.
1: 	@see ConglomerateController#fetch
1: 
1:     @exception StandardException Standard exception policy.
1:     **/
1:     public boolean fetch(
1:     RowLocation loc, 
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 validColumns) 
1: 		throws StandardException
1: 	{
1:         throw(StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1: 	}
1: 
1:     /**
1:     Fetch the row at the given location.
1: 	@see ConglomerateController#fetch
1: 
1:     @exception StandardException Standard exception policy.
1:     **/
1:     public boolean fetch(
1:     RowLocation             loc, 
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 validColumns,
1:     boolean                 waitForLock) 
1: 		throws StandardException
1: 	{
1:         throw(StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
1: 	}
1: 
1: 	/**
1: 	Insert a row into the conglomerate, and store its location in the
1: 	provided template row location.
1: 
1:     Unimplemented by btree.
1: 
1: 	@see ConglomerateController#insertAndFetchLocation
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public void insertAndFetchLocation(
1:     DataValueDescriptor[]	row,
1:     RowLocation             templateRowLocation)
1:         throws StandardException
1: 	{
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1: 	}
1: 
1: 	/**
1: 	Return a row location object of the correct type to be
1: 	used in calls to insertAndFetchLocation.
1: 
1: 	@see ConglomerateController#newRowLocationTemplate
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public RowLocation newRowLocationTemplate()
1: 		throws StandardException
1: 	{
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1: 	}
1: 
1:     /**
1:      * Lock the given row location.
1:      * <p>
1:      * Should only be called by access.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @return true if lock was granted, only can be false if wait was false.
1:      *
1: 	 * @param loc    The "RowLocation" which describes the exact row to lock.
1:      * @param wait   Should the lock call wait to be granted?
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean lockRow(
1:     RowLocation loc,
1:     int         lock_operation,
1:     boolean     wait,
1:     int         lock_duration)
1:         throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     public boolean lockRow(
1:     long        page_num,
1:     int         record_id,
1:     int         lock_operation,
1:     boolean     wait,
1:     int         lock_duration)
1:         throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     public void unlockRowAfterRead(
1:     RowLocation     loc,
1:     boolean         forUpdate,
1:     boolean         row_qualifies)
1:         throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1: 	/**
1:     Replace the entire row at the given location.  
1: 	@see ConglomerateController#replace
1: 
1:     @exception StandardException Standard exception policy.
1:     **/
1:     public boolean replace(
1:     RowLocation             loc, 
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 validColumns)
1: 		throws StandardException
1: 	{
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import java.io.IOException;
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
0: 
0: 
0: 
0: /**
0: 
0:   A b-tree controller corresponds to an instance of an open b-tree conglomerate.
0:   <P>
0:   <B>Concurrency Notes<\B>
0:   <P>
0:   The concurrency rules are derived from OpenBTree.
0:   <P>
0:   @see OpenBTree
0: 
0: **/
0: 
0: public class BTreeController extends OpenBTree implements ConglomerateController
0: { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:     transient DataValueDescriptor[] scratch_template = null;
0: 
0:     /**
0:      * Whether to get lock on the row being inserted, usually this lock
0:      * has already been gotten when the row was inserted into the base table.
0:      **/
0:     boolean get_insert_row_lock;
0: 
0:     /* Constructors: */
0: 
0: 	public BTreeController()
0: 	{
0: 	}
0: 
0: 	/*
0: 	** private Methods of BTreeController
0: 	*/
0: 
0:     /**
0:      * Attempt to reclaim committed deleted rows from the page.
0:      * <p>
0:      * Get exclusive latch on page, and then loop backward through
0:      * page searching for deleted rows which are committed.  The routine
0:      * assumes that it is called from a transaction which cannot have 
0:      * deleted any rows on the page.  For each deleted row on the page
0:      * it attempts to get an exclusive lock on the deleted row, NOWAIT.
0:      * If it succeeds, and since this row did not delete the row then the
0:      * row must have been deleted by a transaction which has committed, so
0:      * it is safe to purge the row.  It then purges the row from the page.
0:      * <p>
0:      * Note that this routine may remove all rows from the page, it will not
0:      * attempt a merge in this situation.  This is because this routine is
0:      * called from split which is attempting an insert on the given page, so
0:      * it would be a waste to merge the page only to split it again to allow
0:      * the insert of the row causing the split.
0:      *
0: 	 * @return true if at least one row was purged.
0:      *
0:      * @param open_btree The already open btree to use to get latch on page.
0:      * @param pageno     The page number of the leaf to attempt the reclaim on.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private boolean reclaim_deleted_rows(
0:     OpenBTree   open_btree,
0:     long        pageno)
0: 		throws StandardException
0:     {
0:         boolean     purged_at_least_one_row = false;
0:         ControlRow  controlRow              = null; 
0: 
0:         try
0:         {
0: 
0:             if ((controlRow = ControlRow.Get(open_btree, pageno)) == null)
0:                 return(false);
0: 
0:             LeafControlRow leaf       = (LeafControlRow) controlRow;
0: 
0:             BTreeLockingPolicy  btree_locking_policy = 
0:                 open_btree.getLockingPolicy();
0: 
0: 
0:             // The number records that can be reclaimed is:
0:             // total recs - control row - recs_not_deleted
0:             int num_possible_commit_delete = 
0:                 leaf.page.recordCount() - 1 - leaf.page.nonDeletedRecordCount();
0: 
0:             if ((num_possible_commit_delete > 0) &&
0:                 (btree_locking_policy.lockScanForReclaimSpace(leaf)))
0:             {
0:                 // Need to get an exclusive scan lock on the page before we can
0:                 // do any sort of purges, otherwise other concurrent scans would
0:                 // not work.  If we can't get the lock NOWAIT, just give up on
0:                 // purging rows and do the split without reclaiming rows.
0: 
0:                 Page page   = leaf.page;
0: 
0: 
0:                 // RowLocation column is in last column of template.
0:                 FetchDescriptor lock_fetch_desc = 
0:                     RowUtil.getFetchDescriptorConstant(
0:                         scratch_template.length - 1);
0: 
0:                 // loop backward so that purges which affect the slot table 
0:                 // don't affect the loop (ie. they only move records we 
0:                 // have already looked at).
0:                 for (int slot_no = page.recordCount() - 1; 
0:                      slot_no > 0; 
0:                      slot_no--) 
0:                 {
0:                     if (page.isDeletedAtSlot(slot_no))
0:                     {
0:                         // try to get an exclusive lock on the row, if we can 
0:                         // then the row is a committed deleted row and it is 
0:                         // safe to purge it.
0:                         if (btree_locking_policy.lockScanCommittedDeletedRow(
0:                                 open_btree, leaf, scratch_template, 
0:                                 lock_fetch_desc, slot_no))
0:                         {
0:                             // the row is a committed deleted row, purge it.
0:                             page.purgeAtSlot(slot_no, 1, true);
0: 
0:                             purged_at_least_one_row = true;
0:                         }
0:                     }
0:                 }
0: 
0:             }
0:         }
0:         catch (java.lang.ClassCastException cce)
0:         {
0:             // because we give up the latch on the leaf before entering this
0:             // routine, the page might change from a leaf to branch.  If that
0:             // happens this routine will get a ClassCastException, and we
0:             // just give up trying to reclaim space.
0:         }
0:         finally
0:         {
0:             if (controlRow != null)
0:                 controlRow.release();
0: 
0:             return(purged_at_least_one_row);
0:         }
0:     }
0: 
0:     /**
0:      * Start an internal transaction and do the split.
0:      * <p>
0:      * This routine starts a new transaction, and handles any errors that
0:      * may come during the transaction.  This transation must not obtain any
0:      * locks as they are likely to conflict with the current user transaction.
0:      * <p>
0:      * If attempt_to_reclaim_deleted_rows is true this routine will 
0:      * attempt to reclaim space on the leaf page input, by purging 
0:      * committed deleted rows from the leaf.  If it succeeds in purging at
0:      * least one row, then it will commit the internal transaction and return
0:      * without actually performing a split.  
0:      *
0:      * @param scratch_template  A scratch template used to search a page.
0:      * @param rowToInsert       The row to insert, make sure during split to
0:      *                          make room for this row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private long 
0:     start_xact_and_dosplit(
0:     boolean                 attempt_to_reclaim_deleted_rows,
0:     long                    leaf_pageno,
0:     DataValueDescriptor[]   scratch_template, 
0:     DataValueDescriptor[]   rowToInsert,
0:     int                     flag)
0:         throws StandardException
0:     {
0:         TransactionManager split_xact       = null;
0:         OpenBTree          split_open_btree = null;
0:         ControlRow         root             = null;
0: 
0:         // Get an internal transaction to be used for the split.
0:         split_xact = this.init_open_user_scans.getInternalTransaction();
0: 
0:         // open the btree again so that actions on it take place in the
0:         // split_xact, don't get any locks in this transaction.
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0:             if (((getOpenMode() & ContainerHandle.MODE_FORUPDATE) !=
0: 								   ContainerHandle.MODE_FORUPDATE))
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "Container not opened with update should not cause split");
0:             }
0: 		}
0: 
0: 
0:         boolean do_split = true;
0:         if (attempt_to_reclaim_deleted_rows)
0:         {
0:             // Get lock on base table.
0: 
0:             ConglomerateController base_cc = null;
0: 
0:             try
0:             {
0:                 base_cc = 
0:                     this.getConglomerate().lockTable(
0:                         split_xact, 
0:                         (ContainerHandle.MODE_FORUPDATE |
0:                          ContainerHandle.MODE_LOCK_NOWAIT), 
0:                         TransactionController.MODE_RECORD,
0:                         TransactionController.ISOLATION_REPEATABLE_READ);
0:             }
0:             catch (StandardException se)
0:             {
0:                 // any error just don't try to reclaim deleted rows.  The
0:                 // expected error is that we can't get the lock, which the
0:                 // current interface throws as a containerNotFound exception.
0:             }
0: 
0:             if (base_cc != null)
0:             {
0:                 // we got IX lock on the base table, so can try reclaim space.
0: 
0: 
0:                 // We can only reclaim space by opening the btree in row lock 
0:                 // mode.  Table level lock row recovery is hard as we can't 
0:                 // determine if the deleted rows we encounter have been 
0:                 // deleted by our parent caller and have been committed or 
0:                 // not.  We will have to get those rows offline.
0:                 split_open_btree = new OpenBTree();
0:                 split_open_btree.init(
0:                     this.init_open_user_scans, 
0:                     split_xact, 
0:                     null,                           // open the container.
0:                     split_xact.getRawStoreXact(), 
0:                     false,
0:                     (ContainerHandle.MODE_FORUPDATE | 
0:                      ContainerHandle.MODE_LOCK_NOWAIT),
0:                     TransactionManager.MODE_RECORD,
0:                     this.getConglomerate().getBtreeLockingPolicy(
0:                         split_xact.getRawStoreXact(), 
0:                         TransactionController.MODE_RECORD,
0:                         LockingPolicy.MODE_RECORD,
0:                         TransactionController.ISOLATION_REPEATABLE_READ, 
0:                         (ConglomerateController) base_cc, 
0:                         split_open_btree),
0:                     this.getConglomerate(), 
0:                     (LogicalUndo) null,
0:                     (DynamicCompiledOpenConglomInfo) null);
0: 
0:                 // don't split if we reclaim any rows.
0:                 do_split = !reclaim_deleted_rows(split_open_btree, leaf_pageno);
0: 
0:                 split_open_btree.close();
0:             }
0:         }
0: 
0:         long new_leaf_pageno = leaf_pageno; 
0:         if (do_split)
0:         {
0:             split_open_btree = new OpenBTree();
0:             split_open_btree.init(
0:                 this.init_open_user_scans, 
0:                 split_xact, 
0:                 null,                           // open the container.
0:                 split_xact.getRawStoreXact(), 
0:                 false,
0:                 getOpenMode(),                  // use same mode this controller
0:                                                 // was opened with
0:                 TransactionManager.MODE_NONE,
0:                 this.getConglomerate().getBtreeLockingPolicy(
0:                     split_xact.getRawStoreXact(), 
0:                     this.init_lock_level,
0:                     LockingPolicy.MODE_RECORD,
0:                     TransactionController.ISOLATION_REPEATABLE_READ, 
0:                     (ConglomerateController) null, // no base row locks during split
0:                     split_open_btree),
0:                 this.getConglomerate(), 
0:                 (LogicalUndo) null,
0:                 (DynamicCompiledOpenConglomInfo) null);
0: 
0: 
0:             // Get the root page back, and perform a split following the
0:             // to-be-inserted key.  The split releases the root page latch.
0:             root = ControlRow.Get(split_open_btree, BTree.ROOTPAGEID);
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(root.page.isLatched());
0: 
0:             new_leaf_pageno = 
0:                 root.splitFor(
0:                     split_open_btree, scratch_template, 
0:                     null, rowToInsert, flag);
0: 
0:             split_open_btree.close();
0:         }
0: 
0:         split_xact.commit();
0: 
0:         split_xact.destroy();
0: 
0:         return(new_leaf_pageno);
0:     }
0: 
0: 	/**
0:     Insert a row into the conglomerate.
0: 
0:     @param rowToInsert The row to insert into the conglomerate.  The stored
0: 	representations of the row's columns are copied into a new row
0: 	somewhere in the conglomerate.
0: 
0: 	@return Returns 0 if insert succeeded.  Returns 
0:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
0:     checks and has been created to disallow duplicates, and the row inserted
0:     had key columns which were duplicate of a row already in the table.  Other
0:     insert failures will raise StandardException's.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0: 	private int doIns(DataValueDescriptor[] rowToInsert)
0:         throws StandardException
0: 	{
0: 		LeafControlRow  targetleaf                      = null;
0: 		LeafControlRow  save_targetleaf                 = null;
0:         int             insert_slot                     = 0;
0:         int             result_slot                     = 0;
0:         int             ret_val                         = 0;
0:         boolean         reclaim_deleted_rows_attempted  = false;
0: 
0:         if (scratch_template == null)
0:             scratch_template = runtime_mem.get_template();
0: 
0:         if (SanityManager.DEBUG)
0:             this.isIndexableRowConsistent(rowToInsert);
0: 
0:         // Create the objects needed for the insert.
0:         // RESOLVE (mikem) - should we cache this in the controller?
0:         SearchParameters sp = 
0:             new SearchParameters(
0:                 rowToInsert,
0:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
0:                 scratch_template, this, false);
0: 
0:         // RowLocation column is in last column of template.
0:         FetchDescriptor lock_fetch_desc = 
0:             RowUtil.getFetchDescriptorConstant(
0:                 scratch_template.length - 1);
0:         RowLocation lock_row_loc = 
0:             (RowLocation) scratch_template[scratch_template.length - 1];
0: 
0:         // Row locking - lock the row being inserted.
0: 
0:         if (get_insert_row_lock)
0:         {
0:             // I don't hold any latch yet so I can wait on this lock, so I
0:             // don't care about return value from this call.  This
0:             // lock can only wait if the base table row was inserted in a
0:             // separate transaction which never happens in sql tables, but
0:             // does happen in the sparse indexes that synchronization builds.
0:         
0:             this.getLockingPolicy().lockNonScanRow(
0:                 this.getConglomerate(),
0:                 (LeafControlRow) null,
0:                 (LeafControlRow) null,
0:                 rowToInsert, 
0:                 (ConglomerateController.LOCK_INS | 
0:                  ConglomerateController.LOCK_UPD));
0:         }
0: 
0:         while (true)
0:         {
0:             // Search the location at which the new row should be inserted.
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(this.container != null);
0: 
0:             targetleaf = (LeafControlRow)
0:                 ControlRow.Get(this, BTree.ROOTPAGEID).search(sp);
0: 
0: 
0:             // Row locking - first lock row previous to row being inserted:
0:             //     o if (sp.resultExact) then the row must be deleted and
0:             //           we will be replacing it with the new row, lock
0:             //           the row before the slot as the previous key.
0:             //     o else 
0:             //           we will be inserting after the current slot so
0:             //           lock the current slot as the previous key.
0:             //
0:             int slot_after_previous = 
0:                 (sp.resultExact ? sp.resultSlot : sp.resultSlot + 1);
0: 
0:             boolean latch_released = false;
0: 
0:             latch_released = 
0:                 !this.getLockingPolicy().lockNonScanPreviousRow(
0:                     this.getConglomerate(),
0:                     targetleaf, 
0:                     slot_after_previous, 
0:                     lock_fetch_desc,
0:                     scratch_template,
0:                     lock_row_loc,
0:                     this, 
0:                     (ConglomerateController.LOCK_INS_PREVKEY |
0:                      ConglomerateController.LOCK_UPD),
0:                     TransactionManager.LOCK_INSTANT_DURATION);
0: 
0:             // special test to see if latch release code works
0:             if (SanityManager.DEBUG)
0:             {
0:                 latch_released = 
0:                     test_errors(
0:                         this,
0:                         "BTreeController_doIns", false,
0:                         this.getLockingPolicy(), 
0:                         targetleaf, latch_released);
0:             }
0: 
0:             if (latch_released)
0:             {
0:                 // Had to release latch in order to get the lock, probably 
0:                 // because of a forward scanner, research tree, and try again.
0:                 targetleaf = null;
0:                 continue;
0:             }
0: 
0:             // If the row is there already, simply undelete it.
0:             // The rationale for this is, since the index does
0:             // not support duplicates, the only way we could
0:             // find a duplicate is if we found a deleted row.
0:             // If we could lock it, then no other transaction
0:             // is deleting it; either this transaction deleted
0:             // it earlier, or it's simply a row that the space
0:             // reclaimer hasn't reclaimed yet.
0:             // Since inserts are done directly (i.e., not to a
0:             // location provided by a scan, we will see the 
0:             // deleted row).
0:             if (sp.resultExact)
0:             {
0:                 result_slot = insert_slot = sp.resultSlot;
0: 
0:                 if (this.getConglomerate().nKeyFields != 
0:                         this.getConglomerate().nUniqueColumns)
0:                 {
0:                     // The key fields match, but not the row location.  We
0:                     // must wait on the lock on the other row location before
0:                     // preceding, so as to serialize behind any work being done
0:                     // to the row as part of another transaction.
0: 
0:                     latch_released = 
0:                         !this.getLockingPolicy().lockNonScanRowOnPage(
0:                             this.getConglomerate(), targetleaf, insert_slot, 
0:                             lock_fetch_desc, scratch_template, lock_row_loc,
0:                             ConglomerateController.LOCK_UPD);
0: 
0:                     if (latch_released)
0:                     {
0:                         // Had to release latch in order to get the lock, 
0:                         // probably to wait for deleting xact to commit or 
0:                         // abort.  Research tree, and try again.
0:                         targetleaf = null;
0:                         continue;
0:                     }
0:                 }
0: 
0:                 // The row better be deleted, or something is very wrong.
0: 
0:                 if (!(targetleaf.page.isDeletedAtSlot(insert_slot)))
0:                 {
0:                     // attempt to insert a duplicate into the index.
0:                     ret_val = ConglomerateController.ROWISDUPLICATE;
0:                     break;
0:                 }
0:                 else
0:                 {
0:                     if (this.getConglomerate().nKeyFields == 
0:                         this.getConglomerate().nUniqueColumns)
0:                     {
0:                         // The row that we found deleted is exactly the new row.
0:                         targetleaf.page.deleteAtSlot(
0:                             insert_slot, false, this.btree_undo);
0: 
0:                         break;
0:                     }
0:                     else if (this.getConglomerate().nUniqueColumns == 
0:                              (this.getConglomerate().nKeyFields - 1))
0:                     {
0:                         // The row that we found deleted has matching keys
0:                         // which form the unique key fields,
0:                         // but the nonkey fields may differ (for now the
0:                         // heap rowlocation is the only nonkey field 
0:                         // allowed).
0:                         
0:                         // RESOLVE BT39 (mikem) - when/if heap row location
0:                         // is not fixed we must handle update failing for
0:                         // out of space and split if it does.  For now
0:                         // if the update fails because of lack of space
0:                         // an exception is thrown and the statement is 
0:                         // backed out.  Should not happen very often.
0:                         targetleaf.page.deleteAtSlot(
0:                             insert_slot, false, this.btree_undo);
0: 
0:                         boolean update_succeeded = true;
0: 
0:                         try 
0:                         {
0:                             int rowloc_index = 
0:                                 this.getConglomerate().nKeyFields - 1;
0:                             targetleaf.page.updateFieldAtSlot(
0:                                 insert_slot, rowloc_index, 
0:                                 (DataValueDescriptor) RowUtil.getColumn(
0:                                     rowToInsert, 
0:                                     (FormatableBitSet) null, rowloc_index),
0:                                 this.btree_undo);
0:                         }
0:                         catch (StandardException se)
0:                         {
0:                             // check if the exception is for out of space
0:                             if (!se.getMessageId().equals(SQLState.DATA_NO_SPACE_FOR_RECORD))
0:                             {
0:                                 throw se;
0:                             }
0: 
0:                             // The statement exception is
0:                             // because the update failed for out of
0:                             // space (ie. the field got longer and there
0:                             // is no room on the page for the expanded
0:                             // field).  Address this error by falling
0:                             // through the code and doing a split.
0:                             update_succeeded = false;                          // update failed.
0:                             targetleaf.page.deleteAtSlot(
0:                                 insert_slot, true, this.btree_undo);
0:                         }
0: 
0:                         if (update_succeeded)
0:                             break;
0:                     }
0:                     else
0:                     {
0:                         // Can only happen with non key fields in the btree.
0:                         throw(
0:                             StandardException.newException(
0:                                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
0:                     }
0:                 }
0:             }
0:             else if (targetleaf.page.recordCount() - 1 < 
0:                     this.getConglomerate().maxRowsPerPage)
0:             {
0:                 // The row wasn't there, so try to insert it
0:                 // on the page returned by the search.
0:                 insert_slot = sp.resultSlot + 1;
0:                 result_slot = insert_slot + 1;
0: 
0:                 // By default maxRowsPerPage is set to MAXINT, some tests
0:                 // set it small to cause splitting to happen quicker with
0:                 // less data.
0: 
0:                 if (targetleaf.page.insertAtSlot(
0:                         insert_slot, 
0:                         rowToInsert, (FormatableBitSet) null,
0:                         this.btree_undo,
0:                         Page.INSERT_DEFAULT,
0: 						AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) != null)
0:                 {
0:                     // Insert succeeded, so we're done.
0: 
0:                     break;
0:                 }
0: 
0:                 // RESOLVE (mikem) - another long row issue.
0:                 // For now if a row does not fit on a page and there 
0:                 // is only the control row on the page and at most one
0:                 // other row on the page, throw an exception
0: 
0:                 if (targetleaf.page.recordCount() <= 2)
0:                 {
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
0:                 }
0: 
0:                 // start splitting ...
0:             }
0: 
0:             
0:             // Create some space by splitting pages.
0: 
0:             // determine where in page/table row causing split would go
0:             int flag = 0;
0:             if (insert_slot == 1)
0:             {
0:                 flag |= ControlRow.SPLIT_FLAG_FIRST_ON_PAGE;
0:                 if (targetleaf.isLeftmostLeaf())
0:                     flag |= ControlRow.SPLIT_FLAG_FIRST_IN_TABLE;
0:             }
0:             else if (insert_slot == targetleaf.page.recordCount())
0:             {
0:                 flag |= ControlRow.SPLIT_FLAG_LAST_ON_PAGE;
0:                 if (targetleaf.isRightmostLeaf())
0:                     flag |= ControlRow.SPLIT_FLAG_LAST_IN_TABLE;
0:             }
0: 
0:             long targetleaf_pageno = targetleaf.page.getPageNumber();
0: 
0:             if ((targetleaf.page.recordCount() - 
0:                  targetleaf.page.nonDeletedRecordCount()) <= 0)
0:             {
0:                 // Don't do reclaim work if there are no deleted records.
0:                 reclaim_deleted_rows_attempted = true;
0:             }
0: 
0:             BranchRow branchrow = 
0:                 BranchRow.createBranchRowFromOldLeafRow(
0:                     rowToInsert, targetleaf_pageno);
0: 
0:             // Release the target page because (a) it may change as a 
0:             // result of the split, (b) the latch ordering requires us 
0:             // to acquire latches from top to bottom, and (c) this 
0:             // loop should be done in a system transaction.
0:             targetleaf.release();
0:             targetleaf = null;
0: 
0:             start_xact_and_dosplit(
0:                 !reclaim_deleted_rows_attempted, targetleaf_pageno, 
0:                 scratch_template, branchrow.getRow(), flag);
0: 
0:             // only attempt to reclaim deleted rows once, otherwise the
0:             // split loop could loop forever, trying to reclaim a deleted
0:             // row that was not committed.
0:             reclaim_deleted_rows_attempted = true;
0: 
0:             // RESOLVE (mikem) possible optimization could be to save
0:             // split location and look there first, if this has 
0:             // already caused a split.  Or even return a latched page
0:             // from splitFor().  For now just execute the loop again
0:             // searching the tree for somewhere to put the row.
0:         }
0: 
0:         // set in-memory hint of where last row on page was inserted.
0:         targetleaf.last_search_result = result_slot;
0: 
0:         // Check that page just updated is consistent.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:             {
0:                 targetleaf.checkConsistency(this, null, true);
0:             }
0:         }
0: 
0:         // Done with the target page.
0:         targetleaf.release();
0:         targetleaf = null;
0: 
0:         // return the status about insert - 0 is ok, or duplicate status.
0:         return(ret_val);
0: 	}
0: 
0:     /**
0:      * Just insert the row on the current page/slot if it fits.
0:      * <p>
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	private boolean do_load_insert(
0:     DataValueDescriptor[]   rowToInsert,
0:     LeafControlRow          leaf,
0:     int                     insert_slot)
0:         throws StandardException
0: 	{
0: 		LeafControlRow old_leaf         = null;
0:         boolean        row_inserted     = false;
0:         int            num_rows_on_page = leaf.page.recordCount() - 1;
0: 
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(insert_slot == leaf.page.recordCount());
0:             SanityManager.ASSERT(
0:                 leaf.getrightSiblingPageNumber() == 
0:                     ContainerHandle.INVALID_PAGE_NUMBER);
0:             this.isIndexableRowConsistent(rowToInsert);
0:         }
0: 
0:         if (num_rows_on_page < this.getConglomerate().maxRowsPerPage)
0:         {
0:             // By default maxRowsPerPage is set to MAXINT, some tests
0:             // set it small to cause splitting to happen quicker with
0:             // less data.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // Caller should have sorted and done duplicate checking.
0: 
0:                 if (insert_slot > 1)
0:                 {
0:                     // verify that the row inserted is >= than previous row.
0:                     int compare_result =
0:                         ControlRow.CompareIndexRowFromPageToKey(
0:                             leaf,
0:                             insert_slot - 1,
0:                             scratch_template,
0:                             rowToInsert,
0:                             this.getConglomerate().nUniqueColumns,
0:                             0,
0: 							this.getConglomerate().ascDescInfo);
0:                     
0:                     if (compare_result >= 0)
0:                     {
0:                         // Rows must be presented in order, so the row we are
0:                         // inserting must always be greater than the previous 
0:                         // row on the page.
0:                         SanityManager.THROWASSERT("result = " + compare_result);
0:                     }
0:                 }
0:             }
0: 
0: 
0:             if (leaf.page.insertAtSlot(
0:                     insert_slot, 
0:                     rowToInsert, 
0:                     (FormatableBitSet) null, 
0:                     this.btree_undo,
0:                     Page.INSERT_DEFAULT,
0: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) != null)
0:             {
0:                 // Insert succeeded, so we're done.
0:                 row_inserted = true;
0:             }
0:             else
0:             {
0:                 // RESOLVE (mikem) - another long row issue.
0:                 // For now if a row does not fit on a page and there 
0:                 // is only the control row on the page and at most one
0:                 // other row on the page, throw an exception
0: 
0:                 if (leaf.page.recordCount() <= 2)
0:                 {
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
0:                 }
0:             }
0:         }
0: 
0:         // Check that page just updated is consistent.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:             {
0:                 leaf.checkConsistency(this, null, true);
0:             }
0:         }
0: 
0:         return(row_inserted);
0: 	}
0: 
0:     /**
0:      * Create room to insert a row to the right of the largest key in table.
0:      * <p>
0:      * Perform a split pass on the tree which will move the largest key in
0:      * leaf right to a new leaf, splitting parent branch pages as necessary.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	private LeafControlRow do_load_split(
0:     DataValueDescriptor[]   rowToInsert,
0:     LeafControlRow          leaf)
0:         throws StandardException
0: 	{
0: 		LeafControlRow new_leaf = null;
0: 
0:         BranchRow branchrow = 
0:             BranchRow.createBranchRowFromOldLeafRow(
0:                 rowToInsert, leaf.page.getPageNumber());
0: 
0:         // Release the target page because (a) it may change as a 
0:         // result of the split, (b) the latch ordering requires us 
0:         // to acquire latches from top to bottom, and (c) this 
0:         // loop should be done in a system transaction.
0:         long old_leafpage = leaf.page.getPageNumber();
0: 
0:         leaf.release();
0:         leaf = null;
0:         
0:         long new_leaf_pageno = 
0:             start_xact_and_dosplit(
0:                 false /* don't try to reclaim deleted rows */,
0:                 old_leafpage,
0:                 scratch_template, 
0:                 branchrow.getRow(), 
0:                 (ControlRow.SPLIT_FLAG_LAST_ON_PAGE | 
0:                     ControlRow.SPLIT_FLAG_LAST_IN_TABLE));
0: 
0:         new_leaf = (LeafControlRow) ControlRow.Get(this, new_leaf_pageno);
0: 
0:         // The leaf must be the rightmost leaf in the table, the first time
0:         // the root grows from leaf to branch it will be a leaf with many
0:         // rows which will probably have to be split soon, after that it will
0:         // be a leaf with only one row.  The current algorithm requires that
0:         // there be at least one row for duplicate checking (the duplicate
0:         // checking code does not handle going left to the previous leaf) - 
0:         // this is the way the split at rightmost leaf row works currently.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (new_leaf.getrightSiblingPageNumber() != 
0:                     ContainerHandle.INVALID_PAGE_NUMBER)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "new_leaf.getrightSiblingPageNumber() = " + 
0:                         new_leaf.getrightSiblingPageNumber());
0:             }
0:             if (new_leaf.page.recordCount() <= 1)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "new_leaf.page.recordCount() = " + 
0:                     new_leaf.page.recordCount());
0:             }
0:         }
0: 
0:         return(new_leaf);
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	** public Methods of BTreeController
0: 	*/
0: 
0: 	/**
0: 	Initialize the controller for use.
0: 	<p>
0: 	Any changes to this method will probably have to be reflected in close as 
0:     well.
0: 	<p>
0: 	Currently delegates to OpenBTree.  If the btree controller ends up not 
0:     having any state of its own, we can remove this method (the VM will 
0:     dispatch to OpenBTree), gaining some small efficiency.  For now, this 
0:     method remains for clarity.  
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public void init(
0:     TransactionManager              xact_manager,
0:     ContainerHandle                 container,
0:     Transaction                     rawtran, 
0: 	int					            open_mode,
0:     int                             lock_level,
0:     BTreeLockingPolicy              btree_locking_policy,
0:     BTree                           conglomerate,
0:     LogicalUndo                     undo,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 		throws StandardException
0: 	{
0:         get_insert_row_lock = 
0:             ((open_mode & 
0:               TransactionController.OPENMODE_BASEROW_INSERT_LOCKED) == 0);
0: 
0: 		super.init(
0:             xact_manager, xact_manager, 
0:             container, rawtran, false, open_mode,
0:             lock_level, btree_locking_policy,
0:             conglomerate, undo, dynamic_info);
0: 	}
0: 
0: 	/*
0: 	** Methods of ConglomerateController
0: 	*/
0: 
0:     /**
0:     Close the conglomerate controller
0: 	<p>
0: 	Any changes to this method will probably have to be reflected in close as 
0:     well.
0: 	<p>
0: 	Currently delegates to OpenBTree.  If the btree controller ends up not 
0:     having any state of its own, we can remove this method (the VM will 
0:     dispatch to OpenBTree), gaining some small efficiency.  For now, this 
0:     method remains for clarity.  
0: 
0: 	@see ConglomerateController#close
0:     **/
0:     public void close()
0:         throws StandardException
0: 	{
0: 		super.close();
0: 
0: 		// If we are closed due to catching an error in the middle of init,
0: 		// xact_manager may not be set yet. 
0: 		if (getXactMgr() != null)
0: 			getXactMgr().closeMe(this);
0: 	}
0: 
0:     /**
0:      * Close conglomerate controller as part of terminating a transaction.
0:      * <p>
0:      * Use this call to close the conglomerate controller resources as part of
0:      * committing or aborting a transaction.  The normal close() routine may 
0:      * do some cleanup that is either unnecessary, or not correct due to the 
0:      * unknown condition of the controller following a transaction ending error.
0:      * Use this call when closing all controllers as part of an abort of a 
0:      * transaction.
0:      * <p)
0:      * This call is meant to only be used internally by the Storage system,
0:      * clients of the storage system should use the simple close() interface.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0:      * @param closeHeldController     If true, means to close controller even if
0:      *                                it has been opened to be kept opened 
0:      *                                across commit.  This is
0:      *                                used to close these controllers on abort.
0:      *
0: 	 * @return boolean indicating that the close has resulted in a real close
0:      *                 of the controller.  A held scan will return false if 
0:      *                 called by closeForEndTransaction(false), otherwise it 
0:      *                 will return true.  A non-held scan will always return 
0:      *                 true.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean closeForEndTransaction(boolean closeHeldScan)
0: 		throws StandardException
0:     {
0:         super.close();
0: 
0:         if ((!getHold()) || closeHeldScan) 
0:         {
0:             // If we are closed due to catching an error in the middle of init,
0:             // xact_manager may not be set yet. 
0:             if (getXactMgr() != null)
0:                 getXactMgr().closeMe(this);
0: 
0:             return(true);
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.THROWASSERT("There is currently no requirement for a held btree conglomerate controller.");
0:             }
0: 
0:             return(false);
0:         }
0:     }
0: 
0: 	/**
0:     Insert a row into the conglomerate.
0: 	@see ConglomerateController#insert
0: 
0:     @param row The row to insert into the conglomerate.  The stored
0: 	representations of the row's columns are copied into a new row
0: 	somewhere in the conglomerate.
0: 
0: 	@return Returns 0 if insert succeeded.  Returns 
0:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
0:     checks and has been created to disallow duplicates, and the row inserted
0:     had key columns which were duplicate of a row already in the table.  Other
0:     insert failures will raise StandardException's.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0: 	public int insert(DataValueDescriptor[] row) 
0:          throws StandardException
0:     {
0: 
0: 		if (this.container == null)       
0: 		{
0:             throw StandardException.newException(
0:                         SQLState.BTREE_IS_CLOSED,
0:                         new Long(err_containerid));
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(this.container != null);
0: 
0:             TemplateRow.checkPartialColumnTypes(
0:                 this.getConglomerate().format_ids, 
0:                 (FormatableBitSet) null, (int []) null, row);
0:         }
0: 
0: 		return doIns(row);
0: 	}
0: 
0:     /**
0: 	Return whether this is a keyed conglomerate.
0: 	<p>
0: 	All b-trees are keyed.
0: 	@see ConglomerateController#isKeyed
0: 	**/
0: 	public boolean isKeyed()
0: 	{
0: 		return(true);
0: 	}
0: 
0:     /*
0:      * Request the system properties associated with a table. 
0:      * <p>
0:      * Request the value of properties that are associated with a table.  The
0:      * following properties can be requested:
0:      *     derby.storage.pageSize 
0:      *     derby.storage.pageReservedSpace
0:      *     derby.storage.minimumRecordSize
0:      *     derby.storage.initialPages
0:      * <p>
0:      * To get the value of a particular property add it to the property list,
0:      * and on return the value of the property will be set to it's current 
0:      * value.  For example:
0:      *
0:      * get_prop(ConglomerateController cc)
0:      * {
0:      *     Properties prop = new Properties();
0:      *     prop.put("derby.storage.pageSize", "");
0:      *     cc.getTableProperties(prop);
0:      *
0:      *     System.out.println(
0:      *         "table's page size = " + 
0:      *         prop.getProperty("derby.storage.pageSize");
0:      * }
0:      *
0:      * @param prop   Property list to fill in.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void getTableProperties(Properties prop)
0: 		throws StandardException
0:     {
0: 		if (this.container == null)
0:         {
0:             throw StandardException.newException(
0:                         SQLState.BTREE_IS_CLOSED,
0:                         new Long(err_containerid));
0:         }
0: 
0:         container.getContainerProperties(prop);
0: 
0:         return;
0:     }
0: 
0:     /**
0:      * Request set of properties associated with a table. 
0:      * <p>
0:      * Returns a property object containing all properties that the store
0:      * knows about, which are stored persistently by the store.  This set
0:      * of properties may vary from implementation to implementation of the
0:      * store.
0:      * <p>
0:      * This call is meant to be used only for internal query of the properties
0:      * by jbms, for instance by language during bulk insert so that it can
0:      * create a new conglomerate which exactly matches the properties that
0:      * the original container was created with.  This call should not be used
0:      * by the user interface to present properties to users as it may contain
0:      * properties that are meant to be internal to jbms.  Some properties are 
0:      * meant only to be specified by jbms code and not by users on the command
0:      * line.
0:      * <p>
0:      * Note that not all properties passed into createConglomerate() are stored
0:      * persistently, and that set may vary by store implementation.
0:      *
0:      * @param prop   Property list to add properties to.  If null, routine will
0:      *               create a new Properties object, fill it in and return it.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public Properties getInternalTablePropertySet(Properties prop)
0: 		throws StandardException
0:     {
0:         Properties  ret_properties = 
0:             ConglomerateUtil.createRawStorePropertySet(prop);
0: 
0:         getTableProperties(ret_properties);
0: 
0:         return(ret_properties);
0:     }
0: 
0:     /**
0:      * Load rows from rowSource into the opened btree.
0:      * <p>
0:      * Efficiently load rows into the already opened btree.  The btree must
0:      * be table locked, as no row locks will be requested by this routine.  
0:      * On exit from this routine the conglomerate will be closed (on both
0:      * error or success).
0:      * <p>
0:      * This routine does an almost bottom up build of a btree.  It assumes
0:      * all rows arrive in sorted order, and inserts them directly into the
0:      * next (to the right) spot in the current leaf until there is no space.
0:      * Then it calls the generic split code to add the next leaf (RESOLVE - 
0:      * in the future we could optimize this to split bottom up rather than
0:      * top down for create index).
0:      *
0:      * @exception StandardException Standard exception policy.  If conglomerate
0: 	 *                              supports uniqueness checks and has been 
0:      *                              created to disallow duplicates, and one of 
0:      *                              the rows being loaded had key columns which
0:      *                              were duplicate of a row already in the 
0:      *                              conglomerate, then raise 
0:      *                              SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION.
0:      *
0: 	 * @see Conglomerate#load
0:      **/
0: 	public long load(
0:     TransactionManager      xact_manager,
0:     boolean                 createConglom,
0:     RowLocationRetRowSource rowSource)
0: 		 throws StandardException
0: 	{
0:         long num_rows_loaded = 0;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(createConglom,
0: 				"Cannot load a btree incrementally - it must either be entirely logged, or entirely not logged.  Doesn't make sense to log only the allocation when one cannot guarantee to not touch any pre-existing pages");
0: 		}
0: 
0:         if (scratch_template == null)
0:             scratch_template = runtime_mem.get_template();
0: 
0:         LeafControlRow current_leaf = null;
0: 
0:         try 
0:         {
0:             // Btree must just have been created and empty, so there must
0:             // be one root leaf page which is empty except for the control row.
0:             current_leaf = 
0:                 (LeafControlRow) ControlRow.Get(this, BTree.ROOTPAGEID);
0:             int current_insert_slot = 1;
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // root must be empty except for the control row.
0:                 SanityManager.ASSERT(current_leaf.page.recordCount() == 1);
0:             }
0:            
0:             // now loop thru the row source and insert into the btree
0:             FormatableBitSet  validColumns = rowSource.getValidColumns();
0:             
0: 			// get the next row and its valid columns from the rowSource
0: 			DataValueDescriptor[] row;
0:             while ((row = rowSource.getNextRowFromRowSource()) != null)
0:             {
0:                 num_rows_loaded++;
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT(
0:                         validColumns == null, "Does not support partial row");
0:                 }
0: 
0:                 while (true)
0:                 {
0:                     if (do_load_insert(row, current_leaf, current_insert_slot))
0:                     {
0:                         // row inserted successfully.
0:                         break;
0:                     }
0:                     else
0:                     {
0:                         // if insert fails, do a split pass. There is an edge
0:                         // case where multiple split passes are necessary if
0:                         // branch splits are necessary, thus the loop.  It is
0:                         // most likely that only a single split pass will be
0:                         // necessary.
0:                         current_leaf = do_load_split(row, current_leaf);
0: 
0:                         current_insert_slot = current_leaf.page.recordCount();
0:                     }
0:                 }
0:                 current_insert_slot++;
0:             }
0: 
0:             current_leaf.release();
0:             current_leaf = null;
0: 
0:             // Loading done, must flush all pages to disk since it is unlogged.
0:             if (!this.getConglomerate().isTemporary())
0:                 container.flushContainer();
0:         }
0:         finally
0:         {
0:             this.close();
0:         }
0: 
0:         return(num_rows_loaded);
0: 	}
0: 
0: 	/*
0: 	** Methods of ConglomerateController which are not supported.
0: 	*/
0: 
0:     /**
0:     Delete a row from the conglomerate.  
0: 	@see ConglomerateController#delete
0: 
0:     @exception StandardException Standard exception policy.
0:     **/
0:     public boolean delete(RowLocation loc)
0: 		throws StandardException
0: 	{
0:         throw(StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
0: 	}
0: 
0:     /**
0:     Fetch the row at the given location.
0: 	@see ConglomerateController#fetch
0: 
0:     @exception StandardException Standard exception policy.
0:     **/
0:     public boolean fetch(
0:     RowLocation loc, 
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 validColumns) 
0: 		throws StandardException
0: 	{
0:         throw(StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
0: 	}
0: 
0:     /**
0:     Fetch the row at the given location.
0: 	@see ConglomerateController#fetch
0: 
0:     @exception StandardException Standard exception policy.
0:     **/
0:     public boolean fetch(
0:     RowLocation             loc, 
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 validColumns,
0:     boolean                 waitForLock) 
0: 		throws StandardException
0: 	{
0:         throw(StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE));
0: 	}
0: 
0: 	/**
0: 	Insert a row into the conglomerate, and store its location in the
0: 	provided template row location.
0: 
0:     Unimplemented by btree.
0: 
0: 	@see ConglomerateController#insertAndFetchLocation
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public void insertAndFetchLocation(
0:     DataValueDescriptor[]	row,
0:     RowLocation             templateRowLocation)
0:         throws StandardException
0: 	{
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0: 	}
0: 
0: 	/**
0: 	Return a row location object of the correct type to be
0: 	used in calls to insertAndFetchLocation.
0: 
0: 	@see ConglomerateController#newRowLocationTemplate
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public RowLocation newRowLocationTemplate()
0: 		throws StandardException
0: 	{
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0: 	}
0: 
0:     /**
0:      * Lock the given row location.
0:      * <p>
0:      * Should only be called by access.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @return true if lock was granted, only can be false if wait was false.
0:      *
0: 	 * @param loc    The "RowLocation" which describes the exact row to lock.
0:      * @param wait   Should the lock call wait to be granted?
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean lockRow(
0:     RowLocation loc,
0:     int         lock_operation,
0:     boolean     wait,
0:     int         lock_duration)
0:         throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     public boolean lockRow(
0:     long        page_num,
0:     int         record_id,
0:     int         lock_operation,
0:     boolean     wait,
0:     int         lock_duration)
0:         throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     public void unlockRowAfterRead(
0:     RowLocation     loc,
0:     boolean         forUpdate,
0:     boolean         row_qualifies)
0:         throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0: 	/**
0:     Replace the entire row at the given location.  
0: 	@see ConglomerateController#replace
0: 
0:     @exception StandardException Standard exception policy.
0:     **/
0:     public boolean replace(
0:     RowLocation             loc, 
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 validColumns)
0: 		throws StandardException
0: 	{
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0: 	}
0: }
============================================================================