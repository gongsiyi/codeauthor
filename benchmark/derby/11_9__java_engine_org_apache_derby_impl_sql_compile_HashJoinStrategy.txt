1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.HashJoinStrategy
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
10:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:1c6c2e8: import java.util.ArrayList;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.cache.ClassSize;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.io.ArrayUtil;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1:eac0369: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:0be2d6e: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
1:3bb140c: class HashJoinStrategy extends BaseJoinStrategy {
1:3bb140c:     HashJoinStrategy() {
3:eac0369: 	}
1:eac0369: 
2:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#feasible
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean feasible(Optimizable innerTable,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							Optimizer optimizer
1:eac0369: 							)
1:eac0369: 					throws StandardException 
3:eac0369: 	{
1:eac0369: 		ConglomerateDescriptor cd = null;
1:eac0369: 
1:eac0369: 		/* If the innerTable is a VTI, then we
1:eac0369: 		 * must check to see if there are any
1:eac0369: 		 * join columns in the VTI's parameters.
1:eac0369: 		 * If so, then hash join is not feasible.
1:eac0369: 		 */
1:eac0369: 		if (! innerTable.isMaterializable())
1:eac0369: 		{
1:9881ca4:             if ( innerTable.optimizerTracingIsOn() ) { innerTable.getOptimizerTracer().traceSkipUnmaterializableHashJoin(); }
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Don't consider hash join on the target table of an update/delete.
1:eac0369: 		 * RESOLVE - this is a temporary restriction.  Problem is that we
1:eac0369: 		 * do not put RIDs into the row in the hash table when scanning
1:eac0369: 		 * the heap and we need them for a target table.
1:eac0369: 		 */
1:eac0369: 		if (innerTable.isTargetTable())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:0be2d6e: 		/* If the predicate given by the user _directly_ references
1:0be2d6e: 		 * any of the base tables _beneath_ this node, then we
1:0be2d6e: 		 * cannot safely use the predicate for a hash because the
1:0be2d6e: 		 * predicate correlates two nodes at different nesting levels. 
1:0be2d6e: 		 * If we did a hash join in this case, materialization of
1:0be2d6e: 		 * innerTable could lead to incorrect results--and in particular,
1:0be2d6e: 		 * results that are missing rows.  We can check for this by
1:0be2d6e: 		 * looking at the predicates' reference maps, which are set based
1:0be2d6e: 		 * on the initial query (as part of pre-processing).  Note that
1:0be2d6e: 		 * by the time we get here, it's possible that a predicate's
1:0be2d6e: 		 * reference map holds table numbers that do not agree with the
1:0be2d6e: 		 * table numbers of the column references used by the predicate.
1:0be2d6e: 		 * That's okay--this occurs as a result of "remapping" predicates
1:0be2d6e: 		 * that have been pushed down the query tree.  And in fact
1:0be2d6e: 		 * it's a good thing because, by looking at the column reference's
1:0be2d6e: 		 * own table numbers instead of the predicate's referenced map,
1:0be2d6e: 		 * we are more readily able to find equijoin predicates that
1:0be2d6e: 		 * we otherwise would not have found.
1:0be2d6e: 		 *
1:0be2d6e: 		 * Note: do not perform this check if innerTable is a FromBaseTable
1:0be2d6e: 		 * because a base table does not have a "subtree" to speak of.
1:eac0369: 		 */
1:0be2d6e: 		if ((predList != null) && (predList.size() > 0) &&
1:0be2d6e: 			!(innerTable instanceof FromBaseTable))
1:eac0369: 		{
1:0be2d6e: 			FromTable ft = (FromTable)innerTable;
1:eac0369: 
1:0be2d6e: 			// First get a list of all of the base tables in the subtree
1:0be2d6e: 			// below innerTable.
1:0be2d6e: 			JBitSet tNums = new JBitSet(ft.getReferencedTableMap().size());
1:0be2d6e: 			BaseTableNumbersVisitor btnVis = new BaseTableNumbersVisitor(tNums);
1:0be2d6e: 			ft.accept(btnVis);
1:eac0369: 
1:0be2d6e: 			// Now get a list of all table numbers referenced by the
1:0be2d6e: 			// join predicates that we'll be searching.
1:0be2d6e: 			JBitSet pNums = new JBitSet(tNums.size());
1:3bb140c: 
1:3bb140c:             for (int i = 0; i < predList.size(); i++)
1:eac0369: 			{
1:3bb140c:                 Predicate pred = (Predicate)predList.getOptPredicate(i);
1:0be2d6e: 				if (pred.isJoinPredicate())
1:0be2d6e: 					pNums.or(pred.getReferencedSet());
1:eac0369: 			}
1:eac0369: 
1:0be2d6e: 			// If tNums and pNums have anything in common, then at
1:0be2d6e: 			// least one predicate in the list refers directly to
1:0be2d6e: 			// a base table beneath this node (as opposed to referring
1:0be2d6e: 			// just to this node), which means it's not safe to do a
1:0be2d6e: 			// hash join.
1:0be2d6e: 			tNums.and(pNums);
1:0be2d6e: 			if (tNums.getFirstSetBit() != -1)
1:0be2d6e: 				return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (innerTable.isBaseTable())
1:eac0369: 		{
1:eac0369: 			/* Must have an equijoin on a column in the conglomerate */
1:eac0369: 			cd = innerTable.getCurrentAccessPath().getConglomerateDescriptor();
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		/* Look for equijoins in the predicate list */
1:3bb140c:         int[] hashKeyColumns = findHashKeyColumns(
1:3bb140c:                 innerTable,
1:3bb140c:                 cd,
1:3bb140c:                 predList);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:9858a84: 		{
1:9881ca4:             if ( innerTable.optimizerTracingIsOn() )
1:eac0369:             {
1:9858a84:                 if (hashKeyColumns == null)
1:9858a84:                 {
1:9881ca4:                     innerTable.getOptimizerTracer().traceSkipHashJoinNoHashKeys();
1:9858a84:                 }
1:9858a84:                 else
1:9858a84:                 {
1:9881ca4:                     innerTable.getOptimizerTracer().traceHashKeyColumns( ArrayUtil.copy( hashKeyColumns ) );
1:9858a84:                 }
1:9858a84:             }
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		if (hashKeyColumns == null)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#ignoreBulkFetch */
1:3bb140c:     @Override
1:eac0369: 	public boolean ignoreBulkFetch() {
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#multiplyBaseCostByOuterRows */
1:eac0369: 	public boolean multiplyBaseCostByOuterRows() {
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#getBasePredicates
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public OptimizablePredicateList getBasePredicates(
1:eac0369: 									OptimizablePredicateList predList,
1:eac0369: 									OptimizablePredicateList basePredicates,
1:eac0369: 									Optimizable innerTable)
1:eac0369: 							throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(basePredicates.size() == 0,
1:eac0369: 				"The base predicate list should be empty.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = predList.size() - 1; i >= 0; i--) {
1:eac0369: 			OptimizablePredicate pred = predList.getOptPredicate(i);
1:eac0369: 
1:eac0369: 			if (innerTable.getReferencedTableMap().contains(pred.getReferencedMap()))
1:eac0369: 			{
1:eac0369: 				basePredicates.addOptPredicate(pred);
1:eac0369: 				predList.removeOptPredicate(i);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		basePredicates.classify(
2:eac0369: 				innerTable,
1:eac0369: 				innerTable.getCurrentAccessPath().getConglomerateDescriptor());
1:eac0369: 
1:eac0369: 		return basePredicates;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#nonBasePredicateSelectivity */
1:eac0369: 	public double nonBasePredicateSelectivity(
1:eac0369: 										Optimizable innerTable,
1:d5bc20f: 										OptimizablePredicateList predList) 
1:eac0369: 	throws StandardException {
1:eac0369: 		double retval = 1.0;
1:eac0369: 
1:eac0369: 		if (predList != null) {
1:eac0369: 			for (int i = 0; i < predList.size(); i++) {
1:eac0369: 				// Don't include redundant join predicates in selectivity calculations
1:eac0369: 				if (predList.isRedundantPredicate(i))
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				retval *= predList.getOptPredicate(i).selectivity(innerTable);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#putBasePredicates
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void putBasePredicates(OptimizablePredicateList predList,
1:eac0369: 									OptimizablePredicateList basePredicates)
1:eac0369: 						throws StandardException {
1:eac0369: 		for (int i = basePredicates.size() - 1; i >= 0; i--) {
1:eac0369: 			OptimizablePredicate pred = basePredicates.getOptPredicate(i);
1:eac0369: 
1:eac0369: 			predList.addOptPredicate(pred);
1:eac0369: 			basePredicates.removeOptPredicate(i);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#estimateCost */
1:eac0369: 	public void estimateCost(Optimizable innerTable,
1:eac0369: 							 OptimizablePredicateList predList,
1:eac0369: 							 ConglomerateDescriptor cd,
1:eac0369: 							 CostEstimate outerCost,
1:eac0369: 							 Optimizer optimizer,
1:eac0369: 							 CostEstimate costEstimate) {
1:eac0369: 		/*
1:eac0369: 		** The cost of a hash join is the cost of building the hash table.
1:eac0369: 		** There is no extra cost per outer row, so don't do anything here.
1:eac0369: 		*/
1:eac0369: 	}
1:eac0369: 
1:b223f72: 	/** @see JoinStrategy#maxCapacity */
1:b223f72: 	public int maxCapacity( int userSpecifiedCapacity,
1:b223f72:                             int maxMemoryPerTable,
1:b223f72:                             double perRowUsage) {
1:b223f72:         if( userSpecifiedCapacity >= 0)
1:b223f72:             return userSpecifiedCapacity;
1:b223f72:         perRowUsage += ClassSize.estimateHashEntrySize();
1:b223f72:         if( perRowUsage <= 1)
1:b223f72:             return maxMemoryPerTable;
1:b223f72:         return (int)(maxMemoryPerTable/perRowUsage);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#getName */
1:eac0369: 	public String getName() {
1:eac0369: 		return "HASH";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#scanCostType */
1:eac0369: 	public int scanCostType() {
1:eac0369: 		return StoreCostController.STORECOST_SCAN_SET;
1:eac0369: 	}
1:eac0369: 
1:b6cc9d7: 	/** @see JoinStrategy#getOperatorSymbol */
1:b6cc9d7:     public  String  getOperatorSymbol() { return "#"; }
1:b6cc9d7: 
1:b6cc9d7: 
1:eac0369: 	/** @see JoinStrategy#resultSetMethodName */
1:af1c18c:     public String resultSetMethodName(
1:af1c18c:             boolean bulkFetch,
1:af1c18c:             boolean multiprobe,
1:af1c18c:             boolean validatingCheckConstraint) {
1:eac0369: 		return "getHashScanResultSet";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#joinResultSetMethodName */
1:eac0369: 	public String joinResultSetMethodName() {
1:eac0369: 		return "getHashJoinResultSet";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#halfOuterJoinResultSetMethodName */
1:eac0369: 	public String halfOuterJoinResultSetMethodName() {
1:eac0369: 		return "getHashLeftOuterJoinResultSet";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#getScanArgs
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public int getScanArgs(
1:eac0369: 							TransactionController tc,
1:eac0369: 							MethodBuilder mb,
1:eac0369: 							Optimizable innerTable,
1:eac0369: 							OptimizablePredicateList storeRestrictionList,
1:eac0369: 							OptimizablePredicateList nonStoreRestrictionList,
1:eac0369: 							ExpressionClassBuilderInterface acbi,
1:eac0369: 							int bulkFetch,
1:959fef2: 							int resultRowTemplate,
1:eac0369: 							int colRefItem,
1:eac0369: 							int indexColItem,
1:eac0369: 							int lockMode,
1:eac0369: 							boolean tableLocked,
1:b223f72: 							int isolationLevel,
1:cbdc90c: 							int maxMemoryPerTable,
1:cbdc90c: 							boolean genInListVals
1:eac0369: 							)
1:cbdc90c: 						throws StandardException
1:cbdc90c: 	{
1:435c451: 		/* We do not currently support IN-list "multi-probing" for hash scans
1:435c451: 		 * (though we could do so in the future).  So if we're doing a hash
1:435c451: 		 * join then we shouldn't have any IN-list probe predicates in the
1:435c451: 		 * store restriction list at this point.  The reason is that, in the
1:435c451: 		 * absence of proper multi-probing logic, such predicates would act
1:435c451: 		 * as restrictions on the rows read from disk.  That would be wrong
1:435c451: 		 * because a probe predicate is of the form "col = <val>" where <val>
1:435c451: 		 * is the first value in the IN-list.  Enforcement of that restriction
1:435c451: 		 * would lead to incorrect results--we need to return all rows having
1:435c451: 		 * any value that appears in the IN-list, not just those rows matching
1:435c451: 		 * the first value.  Checks elsewhere in the code should ensure that
1:435c451: 		 * no probe predicates have made it this far, but if we're running in
1:435c451: 		 * SANE mode it doesn't hurt to verify.
1:cbdc90c: 		 */
1:cbdc90c: 		if (SanityManager.DEBUG)
1:cbdc90c: 		{
1:cbdc90c: 			for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
1:cbdc90c: 			{
1:3bb140c:                 Predicate pred =
1:3bb140c:                         (Predicate)storeRestrictionList.getOptPredicate(i);
1:9d82913: 				if (pred.isInListProbePredicate())
1:cbdc90c: 				{
1:cbdc90c: 					SanityManager.THROWASSERT("Found IN-list probing " +
1:cbdc90c: 						"(" + pred.binaryRelOpColRefsToString() +
1:cbdc90c: 						") while generating HASH join, which should " +
1:cbdc90c: 						"not happen.");
1:cbdc90c: 				}
1:cbdc90c: 			}
1:cbdc90c: 		}
1:cbdc90c: 
1:eac0369: 		ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1:eac0369: 
1:eac0369: 		fillInScanArgs1(tc,
1:eac0369: 										mb,
1:eac0369: 										innerTable,
1:eac0369: 										storeRestrictionList,
1:eac0369: 										acb,
1:959fef2: 										resultRowTemplate);
1:eac0369: 
1:eac0369: 		nonStoreRestrictionList.generateQualifiers(acb,	mb, innerTable, true);
1:eac0369: 		mb.push(innerTable.initialCapacity());
1:eac0369: 		mb.push(innerTable.loadFactor());
1:b223f72: 		mb.push(innerTable.maxCapacity( (JoinStrategy) this, maxMemoryPerTable));
1:eac0369: 		/* Get the hash key columns and wrap them in a formattable */
1:eac0369: 		int[] hashKeyColumns = innerTable.hashKeyColumns();
1:eac0369: 		FormatableIntHolder[] fihArray = 
1:eac0369: 				FormatableIntHolder.getFormatableIntHolders(hashKeyColumns); 
1:eac0369: 		FormatableArrayHolder hashKeyHolder = new FormatableArrayHolder(fihArray);
1:eac0369: 		int hashKeyItem = acb.addItem(hashKeyHolder);
1:eac0369: 		mb.push(hashKeyItem);
1:eac0369: 
1:eac0369: 		fillInScanArgs2(mb,
1:eac0369: 						innerTable,
1:eac0369: 						bulkFetch,
1:eac0369: 						colRefItem,
1:eac0369: 						indexColItem,
1:eac0369: 						lockMode,
1:eac0369: 						tableLocked,
1:eac0369: 						isolationLevel);
1:eac0369: 
1:9e6e461: 		return 28;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#divideUpPredicateLists
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void divideUpPredicateLists(
1:eac0369: 					Optimizable				 innerTable,
1:eac0369: 					OptimizablePredicateList originalRestrictionList,
1:eac0369: 					OptimizablePredicateList storeRestrictionList,
1:eac0369: 					OptimizablePredicateList nonStoreRestrictionList,
1:eac0369: 					OptimizablePredicateList requalificationRestrictionList,
1:eac0369: 					DataDictionary			 dd
1:eac0369: 					) throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** If we are walking a non-covering index, then all predicates that
1:eac0369: 		** get evaluated in the HashScanResultSet, whether during the building
1:eac0369: 		** or probing of the hash table, need to be evaluated at both the
1:eac0369: 		** IndexRowToBaseRowResultSet and the HashScanResultSet to ensure
1:eac0369: 		** that the rows materialized into the hash table still qualify when
1:eac0369: 		** we go to read the row from the heap.  This also includes predicates
1:eac0369:         ** that are not qualifier/start/stop keys (hence not in store/non-store
1:eac0369:         ** list).
1:eac0369: 		*/
1:eac0369: 		originalRestrictionList.copyPredicatesToOtherList(
1:eac0369:             requalificationRestrictionList);
1:eac0369: 
1:eac0369: 		ConglomerateDescriptor cd =
1:eac0369: 			innerTable.getTrulyTheBestAccessPath().getConglomerateDescriptor();
1:eac0369: 
1:eac0369: 		/* For the inner table of a hash join, then divide up the predicates:
1:eac0369:          *
1:eac0369: 		 *	o restrictionList	- predicates that get applied when creating 
1:eac0369: 		 *						  the hash table (single table clauses)
1:eac0369:          *
1:eac0369: 		 *  o nonBaseTableRestrictionList
1:eac0369: 		 *						- those that get applied when probing into the 
1:eac0369: 		 *						  hash table (equijoin clauses on key columns,
1:eac0369: 		 *						  ordered by key column position first, followed
1:eac0369: 		 *						  by any other join predicates. (All predicates
1:eac0369:          *						  in this list are qualifiers which can be 
1:eac0369:          *						  evaluated in the store).
1:eac0369:          *
1:eac0369: 		 *  o baseTableRL		- Only applicable if this is not a covering 
1:eac0369:          *                        index.  In that case, we will need to 
1:eac0369:          *                        requalify the data page.  Thus, this list 
1:eac0369:          *                        will include all predicates.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		// Build the list to be applied when creating the hash table
1:eac0369: 		originalRestrictionList.transferPredicates(
1:eac0369: 									storeRestrictionList,
1:eac0369: 									innerTable.getReferencedTableMap(),
1:eac0369: 									innerTable);
1:eac0369: 
1:eac0369: 		/* 
1:eac0369:          * Eliminate any non-qualifiers that may have been pushed, but
1:eac0369:          * are redundant and not useful for hash join.
1:eac0369:          * 
1:eac0369:          * For instance "in" (or other non-qualifier) was pushed down for 
1:eac0369:          * start/stop key, * but for hash join, it may no longer be because 
1:eac0369:          * previous key column may have been disqualified (eg., correlation).  
1:eac0369:          * We simply remove 
1:eac0369:          * such non-qualifier ("in") because we left it as residual predicate 
1:eac0369:          * anyway.  It's easier/safer to filter it out here than detect it 
1:eac0369:          * ealier (and not push it down). Beetle 4316.
1:eac0369:          *
1:eac0369:          * Can't filter out OR list, as it is not a residual predicate, 
1:eac0369: 		 */
1:eac0369: 		for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
1:eac0369: 		{
1:eac0369: 			Predicate p1 = (Predicate) storeRestrictionList.getOptPredicate(i);
1:eac0369: 
1:eac0369:            
1:eac0369:             if (!p1.isStoreQualifier() && !p1.isStartKey() && !p1.isStopKey())
1:eac0369:             {
1:eac0369: 				storeRestrictionList.removeOptPredicate(i);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = originalRestrictionList.size() - 1; i >= 0; i--)
1:eac0369: 		{
1:eac0369: 			Predicate p1 = 
1:eac0369:                 (Predicate) originalRestrictionList.getOptPredicate(i);
1:eac0369: 
1:eac0369:             if (!p1.isStoreQualifier())
1:eac0369: 				originalRestrictionList.removeOptPredicate(i);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Copy the rest of the predicates to the non-store list */
1:eac0369: 		originalRestrictionList.copyPredicatesToOtherList(
1:eac0369: 													nonStoreRestrictionList);
1:eac0369: 
1:eac0369: 		/* If innerTable is ProjectRestrictNode, we need to use its child
1:eac0369: 		 * to find hash key columns, this is because ProjectRestrictNode may
1:eac0369: 		 * not have underlying node's every result column as result column,
1:eac0369: 		 * and the predicate's column reference was bound to the underlying
1:eac0369: 		 * node's column position.  Also we have to pass in the 
1:eac0369: 	 	 * ProjectRestrictNode rather than the underlying node to this method
1:eac0369: 		 * because a predicate's referencedTableMap references the table number
1:eac0369: 		 * of the ProjectRestrictiveNode.  And we need this info to see if
1:eac0369: 		 * a predicate is in storeRestrictionList that can be pushed down.
1:eac0369: 		 * Beetle 3458.
1:eac0369: 		 */
1:eac0369: 		Optimizable hashTableFor = innerTable;
1:eac0369: 		if (innerTable instanceof ProjectRestrictNode)
1:eac0369: 		{
1:eac0369: 			ProjectRestrictNode prn = (ProjectRestrictNode) innerTable;
1:eac0369: 			if (prn.getChildResult() instanceof Optimizable)
1:eac0369: 				hashTableFor = (Optimizable) (prn.getChildResult());
1:eac0369: 		}
1:eac0369: 		int[] hashKeyColumns = findHashKeyColumns(hashTableFor,
2:eac0369: 												cd,
1:eac0369: 												nonStoreRestrictionList);
1:eac0369: 		if (hashKeyColumns != null)
1:eac0369: 		{
1:eac0369: 			innerTable.setHashKeyColumns(hashKeyColumns);
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			String name;
1:eac0369: 			if (cd != null && cd.isIndex())
1:eac0369: 			{
1:eac0369: 				name = cd.getConglomerateName();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				name = innerTable.getBaseTableName();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			throw StandardException.newException(SQLState.LANG_HASH_NO_EQUIJOIN_FOUND, 
1:eac0369: 						name,
1:eac0369: 						innerTable.getBaseTableName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Mark all of the predicates in the probe list as qualifiers
1:eac0369: 		nonStoreRestrictionList.markAllPredicatesQualifiers();
1:eac0369: 
1:eac0369: 		int[] conglomColumn = new int[hashKeyColumns.length];
1:eac0369: 		if (cd != null && cd.isIndex())
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** If the conglomerate is an index, get the column numbers of the
1:eac0369: 			** hash keys in the base heap.
1:eac0369: 			*/
1:eac0369: 			for (int index = 0; index < hashKeyColumns.length; index++)
1:eac0369: 			{
1:eac0369: 				conglomColumn[index] =
1:eac0369: 				  cd.getIndexDescriptor().baseColumnPositions()[hashKeyColumns[index]];
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** If the conglomerate is a heap, the column numbers of the hash
1:eac0369: 			** key are the column numbers returned by findHashKeyColumns().
1:eac0369: 			**
1:eac0369: 			** NOTE: Must switch from zero-based to one-based
1:eac0369: 			*/
1:eac0369: 			for (int index = 0; index < hashKeyColumns.length; index++)
1:eac0369: 			{
1:eac0369: 				conglomColumn[index] = hashKeyColumns[index] + 1;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Put the equality predicates on the key columns for the hash first.
1:eac0369: 		 * (Column # is columns[colCtr] from above.)
1:eac0369: 		 */
1:eac0369: 		for (int index = hashKeyColumns.length - 1; index >= 0; index--)
1:eac0369: 		{
1:eac0369: 			nonStoreRestrictionList.putOptimizableEqualityPredicateFirst(
1:eac0369: 					innerTable,
1:eac0369: 					conglomColumn[index]);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#isHashJoin
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean isHashJoin()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#doesMaterialization
1:eac0369: 	 */
1:eac0369: 	public boolean doesMaterialization()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Find the hash key columns, if any, to use with this join.
1:eac0369: 	 *
1:eac0369: 	 * @param innerTable	The inner table of the join
1:eac0369: 	 * @param cd			The conglomerate descriptor to use on inner table
1:eac0369: 	 * @param predList		The predicate list to look for the equijoin in
1:eac0369: 	 *
1:eac0369: 	 * @return	the numbers of the hash key columns, or null if no hash key column
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private int[] findHashKeyColumns(Optimizable innerTable,
1:eac0369: 									ConglomerateDescriptor cd,
1:eac0369: 									OptimizablePredicateList predList)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		if (predList == null)
2:eac0369: 			return (int[]) null;
1:eac0369: 
1:eac0369: 		/* Find the column to use as the hash key.
1:eac0369: 		 * (There must be an equijoin condition on this column.)
1:eac0369: 		 * If cd is null, then Optimizable is not a scan.
1:eac0369: 		 * For indexes, we start at the first column in the key
1:eac0369: 		 * and walk the key columns until we find the first one with
1:eac0369: 		 * an equijoin condition on it.  We do essentially the same
1:eac0369: 		 * for heaps.  (From column 1 through column n.)
1:eac0369: 		 */
1:3bb140c:         int[] columns;
1:eac0369: 		if (cd == null)
1:eac0369: 		{
1:eac0369: 			columns = new int[innerTable.getNumColumnsReturned()];
1:eac0369: 			for (int j = 0; j < columns.length; j++)
1:eac0369: 			{
1:eac0369: 				columns[j] = j + 1;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else if (cd.isIndex())
1:eac0369: 		{
1:eac0369: 			columns = cd.getIndexDescriptor().baseColumnPositions();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			columns =
1:eac0369: 				new int[innerTable.getTableDescriptor().getNumberOfColumns()];
1:eac0369: 			for (int j = 0; j < columns.length; j++)
1:eac0369: 			{
1:eac0369: 				columns[j] = j + 1;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:1c6c2e8:         // Build a list of all the hash key columns
1:9d5bd0e:         ArrayList<Integer> hashKeys = new ArrayList<Integer>();
1:1c6c2e8:         for (int colCtr = 0; colCtr < columns.length; colCtr++)
1:eac0369: 		{
1:eac0369: 			// Is there an equijoin condition on this column?
1:eac0369: 			if (predList.hasOptimizableEquijoin(innerTable, columns[colCtr]))
1:eac0369: 			{
1:bb5be6f:                 hashKeys.add(colCtr);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:1c6c2e8:         // Convert the list into an int[], if there are hash key columns
1:1c6c2e8:         if (hashKeys.isEmpty())
1:1c6c2e8:         {
1:1c6c2e8:             return null;
1:1c6c2e8:         }
1:1c6c2e8: 
1:1c6c2e8:         int[] keyCols = new int[hashKeys.size()];
1:1c6c2e8:         for (int index = 0; index < keyCols.length; index++)
1:1c6c2e8:         {
1:3bb140c:             keyCols[index] = hashKeys.get(index).intValue();
1:1c6c2e8:         }
1:1c6c2e8:         return keyCols;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		return getName();
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 hashKeys.add(colCtr);
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
1:         // Build a list of all the hash key columns
0:         ArrayList hashKeys = new ArrayList();
1:         for (int colCtr = 0; colCtr < columns.length; colCtr++)
0:                 hashKeys.add(ReuseFactory.getInteger(colCtr));
1:         // Convert the list into an int[], if there are hash key columns
1:         if (hashKeys.isEmpty())
1:         {
1:             return null;
1:         }
1: 
1:         int[] keyCols = new int[hashKeys.size()];
1:         for (int index = 0; index < keyCols.length; index++)
1:         {
0:             keyCols[index] = ((Integer) hashKeys.get(index)).intValue();
1:         }
1:         return keyCols;
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 										resultRowTemplate);
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 				hashKeyVector.add(new Integer(colCtr));
/////////////////////////////////////////////////////////////////////////
0: 				keyCols[index] = ((Integer) hashKeyVector.get(index)).intValue();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     public String resultSetMethodName(
1:             boolean bulkFetch,
1:             boolean multiprobe,
1:             boolean validatingCheckConstraint) {
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.io.ArrayUtil;
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: class HashJoinStrategy extends BaseJoinStrategy {
1:     HashJoinStrategy() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             for (int i = 0; i < predList.size(); i++)
1:                 Predicate pred = (Predicate)predList.getOptPredicate(i);
/////////////////////////////////////////////////////////////////////////
1:         int[] hashKeyColumns = findHashKeyColumns(
1:                 innerTable,
1:                 cd,
1:                 predList);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 Predicate pred =
1:                         (Predicate)storeRestrictionList.getOptPredicate(i);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         int[] columns;
/////////////////////////////////////////////////////////////////////////
1:             keyCols[index] = hashKeys.get(index).intValue();
1:     @Override
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9881ca4
/////////////////////////////////////////////////////////////////////////
1:             if ( innerTable.optimizerTracingIsOn() ) { innerTable.getOptimizerTracer().traceSkipUnmaterializableHashJoin(); }
/////////////////////////////////////////////////////////////////////////
1:             if ( innerTable.optimizerTracingIsOn() )
1:                     innerTable.getOptimizerTracer().traceSkipHashJoinNoHashKeys();
1:                     innerTable.getOptimizerTracer().traceHashKeyColumns( ArrayUtil.copy( hashKeyColumns ) );
commit:b6cc9d7
/////////////////////////////////////////////////////////////////////////
1: 	/** @see JoinStrategy#getOperatorSymbol */
1:     public  String  getOperatorSymbol() { return "#"; }
1: 
1: 
commit:9d5bd0e
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Integer> hashKeys = new ArrayList<Integer>();
commit:9858a84
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
0:             if ( optimizer.tracingIsOn() ) { optimizer.tracer().traceSkipUnmaterializableHashJoin(); }
/////////////////////////////////////////////////////////////////////////
0:             if ( optimizer.tracingIsOn() )
1:             {
1:                 if (hashKeyColumns == null)
1:                 {
0:                     optimizer.tracer().traceSkipHashJoinNoHashKeys();
1:                 }
1:                 else
1:                 {
0:                     optimizer.tracer().traceHashKeyColumns( ArrayUtil.copy( hashKeyColumns ) );
1:                 }
1:             }
author:Army
-------------------------------------------------------------------------------
commit:435c451
/////////////////////////////////////////////////////////////////////////
1: 		/* We do not currently support IN-list "multi-probing" for hash scans
1: 		 * (though we could do so in the future).  So if we're doing a hash
1: 		 * join then we shouldn't have any IN-list probe predicates in the
1: 		 * store restriction list at this point.  The reason is that, in the
1: 		 * absence of proper multi-probing logic, such predicates would act
1: 		 * as restrictions on the rows read from disk.  That would be wrong
1: 		 * because a probe predicate is of the form "col = <val>" where <val>
1: 		 * is the first value in the IN-list.  Enforcement of that restriction
1: 		 * would lead to incorrect results--we need to return all rows having
1: 		 * any value that appears in the IN-list, not just those rows matching
1: 		 * the first value.  Checks elsewhere in the code should ensure that
1: 		 * no probe predicates have made it this far, but if we're running in
1: 		 * SANE mode it doesn't hurt to verify.
commit:9d82913
/////////////////////////////////////////////////////////////////////////
1: 				if (pred.isInListProbePredicate())
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
0: 	public String resultSetMethodName(boolean bulkFetch, boolean multiprobe) {
/////////////////////////////////////////////////////////////////////////
1: 							int maxMemoryPerTable,
1: 							boolean genInListVals
1: 						throws StandardException
1: 	{
0: 		/* If we're doing a Hash join then we shouldn't have any IN-list
0: 		 * probe predicates in the store restriction list.  The reason
0: 		 * is that those predicates are one-sided and thus if they
0: 		 * make it this far they will be pushed down to the base table
0: 		 * as restrictions on the rows read from disk.  That would be
0: 		 * wrong because a probe predicate is of the form "col = <val>"
0: 		 * where <val> is the first value in the IN-list.  But that's
0: 		 * not correct--we need to return all rows having any value that
0: 		 * appears in the IN-list (not just those rows matching the
0: 		 * first value).  Checks elsewhere in the code should ensure
0: 		 * that no probe predicates have made it this far, but if we're
0: 		 * running in SANE mode it doesn't hurt to verify.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			Predicate pred = null;
1: 			for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
1: 			{
0: 				pred = (Predicate)storeRestrictionList.getOptPredicate(i);
0: 				if (pred.getSourceInList() != null)
1: 				{
1: 					SanityManager.THROWASSERT("Found IN-list probing " +
1: 						"(" + pred.binaryRelOpColRefsToString() +
1: 						") while generating HASH join, which should " +
1: 						"not happen.");
1: 				}
1: 			}
1: 		}
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 		return 28;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.HashJoinStrategy
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
0: public class HashJoinStrategy extends BaseJoinStrategy {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ProjectRestrictNode;
0: import org.apache.derby.impl.sql.compile.Predicate;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1: 
0: import java.util.Vector;
1: 
0: public class HashJoinStrategy extends BaseJoinStrategy { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	public HashJoinStrategy() {
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#feasible
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean feasible(Optimizable innerTable,
1: 							OptimizablePredicateList predList,
1: 							Optimizer optimizer
1: 							)
1: 					throws StandardException 
1: 	{
0: 		int[] hashKeyColumns = null;
1: 
1: 		ConglomerateDescriptor cd = null;
1: 
1: 		/* If the innerTable is a VTI, then we
1: 		 * must check to see if there are any
1: 		 * join columns in the VTI's parameters.
1: 		 * If so, then hash join is not feasible.
1: 		 */
1: 		if (! innerTable.isMaterializable())
1: 		{
1: 
0: 			optimizer.trace(Optimizer.HJ_SKIP_NOT_MATERIALIZABLE, 0, 0, 0.0,
0: 							null);
1: 			return false;
1: 		}
1: 
1: 		/* Don't consider hash join on the target table of an update/delete.
1: 		 * RESOLVE - this is a temporary restriction.  Problem is that we
1: 		 * do not put RIDs into the row in the hash table when scanning
1: 		 * the heap and we need them for a target table.
1: 		 */
1: 		if (innerTable.isTargetTable())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		if (innerTable.isBaseTable())
1: 		{
1: 			/* Must have an equijoin on a column in the conglomerate */
1: 			cd = innerTable.getCurrentAccessPath().getConglomerateDescriptor();
1: 		}
1: 		
1: 		/* Look for equijoins in the predicate list */
0: 		hashKeyColumns = findHashKeyColumns(
1: 											innerTable,
1: 											cd,
0: 											predList);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (hashKeyColumns == null)
1: 			{
0: 				optimizer.trace(Optimizer.HJ_SKIP_NO_JOIN_COLUMNS, 0, 0, 0.0, null);
1: 			}
1: 			else
1: 			{
0: 				optimizer.trace(Optimizer.HJ_HASH_KEY_COLUMNS, 0, 0, 0.0, hashKeyColumns);
1: 			}
1: 		}
1: 
1: 		if (hashKeyColumns == null)
1: 		{
1: 			return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/** @see JoinStrategy#ignoreBulkFetch */
1: 	public boolean ignoreBulkFetch() {
1: 		return true;
1: 	}
1: 
1: 	/** @see JoinStrategy#multiplyBaseCostByOuterRows */
1: 	public boolean multiplyBaseCostByOuterRows() {
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#getBasePredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public OptimizablePredicateList getBasePredicates(
1: 									OptimizablePredicateList predList,
1: 									OptimizablePredicateList basePredicates,
1: 									Optimizable innerTable)
1: 							throws StandardException {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(basePredicates.size() == 0,
1: 				"The base predicate list should be empty.");
1: 		}
1: 
1: 		for (int i = predList.size() - 1; i >= 0; i--) {
1: 			OptimizablePredicate pred = predList.getOptPredicate(i);
1: 
1: 			if (innerTable.getReferencedTableMap().contains(pred.getReferencedMap()))
1: 			{
1: 				basePredicates.addOptPredicate(pred);
1: 				predList.removeOptPredicate(i);
1: 			}
1: 		}
1: 
1: 		basePredicates.classify(
1: 				innerTable,
1: 				innerTable.getCurrentAccessPath().getConglomerateDescriptor());
1: 
1: 		return basePredicates;
1: 	}
1: 
1: 	/** @see JoinStrategy#nonBasePredicateSelectivity */
1: 	public double nonBasePredicateSelectivity(
1: 										Optimizable innerTable,
0: 										OptimizablePredicateList predList) {
1: 		double retval = 1.0;
1: 
1: 		if (predList != null) {
1: 			for (int i = 0; i < predList.size(); i++) {
1: 				// Don't include redundant join predicates in selectivity calculations
1: 				if (predList.isRedundantPredicate(i))
1: 				{
1: 					continue;
1: 				}
1: 
1: 				retval *= predList.getOptPredicate(i).selectivity(innerTable);
1: 			}
1: 		}
1: 
1: 		return retval;
1: 	}
1: 	
1: 	/**
1: 	 * @see JoinStrategy#putBasePredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void putBasePredicates(OptimizablePredicateList predList,
1: 									OptimizablePredicateList basePredicates)
1: 						throws StandardException {
1: 		for (int i = basePredicates.size() - 1; i >= 0; i--) {
1: 			OptimizablePredicate pred = basePredicates.getOptPredicate(i);
1: 
1: 			predList.addOptPredicate(pred);
1: 			basePredicates.removeOptPredicate(i);
1: 		}
1: 	}
1: 
1: 	/** @see JoinStrategy#estimateCost */
1: 	public void estimateCost(Optimizable innerTable,
1: 							 OptimizablePredicateList predList,
1: 							 ConglomerateDescriptor cd,
1: 							 CostEstimate outerCost,
1: 							 Optimizer optimizer,
1: 							 CostEstimate costEstimate) {
1: 		/*
1: 		** The cost of a hash join is the cost of building the hash table.
1: 		** There is no extra cost per outer row, so don't do anything here.
1: 		*/
1: 	}
1: 
0: 	/** @see JoinStrategy#memoryUsage */
0: 	public double memoryUsage(double memoryPerRow, double rowCount) {
0: 		return memoryPerRow * rowCount;
1: 	}
1: 
1: 	/** @see JoinStrategy#getName */
1: 	public String getName() {
1: 		return "HASH";
1: 	}
1: 
1: 	/** @see JoinStrategy#scanCostType */
1: 	public int scanCostType() {
1: 		return StoreCostController.STORECOST_SCAN_SET;
1: 	}
1: 
1: 	/** @see JoinStrategy#resultSetMethodName */
0: 	public String resultSetMethodName(boolean bulkFetch) {
1: 		return "getHashScanResultSet";
1: 	}
1: 
1: 	/** @see JoinStrategy#joinResultSetMethodName */
1: 	public String joinResultSetMethodName() {
1: 		return "getHashJoinResultSet";
1: 	}
1: 
1: 	/** @see JoinStrategy#halfOuterJoinResultSetMethodName */
1: 	public String halfOuterJoinResultSetMethodName() {
1: 		return "getHashLeftOuterJoinResultSet";
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#getScanArgs
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public int getScanArgs(
1: 							TransactionController tc,
1: 							MethodBuilder mb,
1: 							Optimizable innerTable,
1: 							OptimizablePredicateList storeRestrictionList,
1: 							OptimizablePredicateList nonStoreRestrictionList,
1: 							ExpressionClassBuilderInterface acbi,
1: 							int bulkFetch,
0: 							MethodBuilder resultRowAllocator,
1: 							int colRefItem,
1: 							int indexColItem,
1: 							int lockMode,
1: 							boolean tableLocked,
0: 							int isolationLevel
1: 							)
1: 						throws StandardException {
1: 		ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1: 
1: 		fillInScanArgs1(tc,
1: 										mb,
1: 										innerTable,
1: 										storeRestrictionList,
1: 										acb,
0: 										resultRowAllocator);
1: 
1: 		nonStoreRestrictionList.generateQualifiers(acb,	mb, innerTable, true);
1: 		mb.push(innerTable.initialCapacity());
1: 		mb.push(innerTable.loadFactor());
0: 		mb.push(innerTable.maxCapacity());
1: 		/* Get the hash key columns and wrap them in a formattable */
1: 		int[] hashKeyColumns = innerTable.hashKeyColumns();
1: 		FormatableIntHolder[] fihArray = 
1: 				FormatableIntHolder.getFormatableIntHolders(hashKeyColumns); 
1: 		FormatableArrayHolder hashKeyHolder = new FormatableArrayHolder(fihArray);
1: 		int hashKeyItem = acb.addItem(hashKeyHolder);
1: 		mb.push(hashKeyItem);
1: 
1: 		fillInScanArgs2(mb,
1: 						innerTable,
1: 						bulkFetch,
1: 						colRefItem,
1: 						indexColItem,
1: 						lockMode,
1: 						tableLocked,
1: 						isolationLevel);
1: 
0: 		return 28;
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#divideUpPredicateLists
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void divideUpPredicateLists(
1: 					Optimizable				 innerTable,
1: 					OptimizablePredicateList originalRestrictionList,
1: 					OptimizablePredicateList storeRestrictionList,
1: 					OptimizablePredicateList nonStoreRestrictionList,
1: 					OptimizablePredicateList requalificationRestrictionList,
1: 					DataDictionary			 dd
1: 					) throws StandardException
1: 	{
1: 		/*
1: 		** If we are walking a non-covering index, then all predicates that
1: 		** get evaluated in the HashScanResultSet, whether during the building
1: 		** or probing of the hash table, need to be evaluated at both the
1: 		** IndexRowToBaseRowResultSet and the HashScanResultSet to ensure
1: 		** that the rows materialized into the hash table still qualify when
1: 		** we go to read the row from the heap.  This also includes predicates
1:         ** that are not qualifier/start/stop keys (hence not in store/non-store
1:         ** list).
1: 		*/
1: 		originalRestrictionList.copyPredicatesToOtherList(
1:             requalificationRestrictionList);
1: 
1: 		ConglomerateDescriptor cd =
1: 			innerTable.getTrulyTheBestAccessPath().getConglomerateDescriptor();
1: 
1: 		/* For the inner table of a hash join, then divide up the predicates:
1:          *
1: 		 *	o restrictionList	- predicates that get applied when creating 
1: 		 *						  the hash table (single table clauses)
1:          *
1: 		 *  o nonBaseTableRestrictionList
1: 		 *						- those that get applied when probing into the 
1: 		 *						  hash table (equijoin clauses on key columns,
1: 		 *						  ordered by key column position first, followed
1: 		 *						  by any other join predicates. (All predicates
1:          *						  in this list are qualifiers which can be 
1:          *						  evaluated in the store).
1:          *
1: 		 *  o baseTableRL		- Only applicable if this is not a covering 
1:          *                        index.  In that case, we will need to 
1:          *                        requalify the data page.  Thus, this list 
1:          *                        will include all predicates.
1: 		 */
1: 
1: 		// Build the list to be applied when creating the hash table
1: 		originalRestrictionList.transferPredicates(
1: 									storeRestrictionList,
1: 									innerTable.getReferencedTableMap(),
1: 									innerTable);
1: 
1: 		/* 
1:          * Eliminate any non-qualifiers that may have been pushed, but
1:          * are redundant and not useful for hash join.
1:          * 
1:          * For instance "in" (or other non-qualifier) was pushed down for 
1:          * start/stop key, * but for hash join, it may no longer be because 
1:          * previous key column may have been disqualified (eg., correlation).  
1:          * We simply remove 
1:          * such non-qualifier ("in") because we left it as residual predicate 
1:          * anyway.  It's easier/safer to filter it out here than detect it 
1:          * ealier (and not push it down). Beetle 4316.
1:          *
1:          * Can't filter out OR list, as it is not a residual predicate, 
1: 		 */
1: 		for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
1: 		{
1: 			Predicate p1 = (Predicate) storeRestrictionList.getOptPredicate(i);
1: 
1:            
1:             if (!p1.isStoreQualifier() && !p1.isStartKey() && !p1.isStopKey())
1:             {
1: 				storeRestrictionList.removeOptPredicate(i);
1:             }
1: 		}
1: 
1: 		for (int i = originalRestrictionList.size() - 1; i >= 0; i--)
1: 		{
1: 			Predicate p1 = 
1:                 (Predicate) originalRestrictionList.getOptPredicate(i);
1: 
1:             if (!p1.isStoreQualifier())
1: 				originalRestrictionList.removeOptPredicate(i);
1: 		}
1: 
1: 		/* Copy the rest of the predicates to the non-store list */
1: 		originalRestrictionList.copyPredicatesToOtherList(
1: 													nonStoreRestrictionList);
1: 
1: 		/* If innerTable is ProjectRestrictNode, we need to use its child
1: 		 * to find hash key columns, this is because ProjectRestrictNode may
1: 		 * not have underlying node's every result column as result column,
1: 		 * and the predicate's column reference was bound to the underlying
1: 		 * node's column position.  Also we have to pass in the 
1: 	 	 * ProjectRestrictNode rather than the underlying node to this method
1: 		 * because a predicate's referencedTableMap references the table number
1: 		 * of the ProjectRestrictiveNode.  And we need this info to see if
1: 		 * a predicate is in storeRestrictionList that can be pushed down.
1: 		 * Beetle 3458.
1: 		 */
1: 		Optimizable hashTableFor = innerTable;
1: 		if (innerTable instanceof ProjectRestrictNode)
1: 		{
1: 			ProjectRestrictNode prn = (ProjectRestrictNode) innerTable;
1: 			if (prn.getChildResult() instanceof Optimizable)
1: 				hashTableFor = (Optimizable) (prn.getChildResult());
1: 		}
1: 		int[] hashKeyColumns = findHashKeyColumns(hashTableFor,
1: 												cd,
1: 												nonStoreRestrictionList);
1: 		if (hashKeyColumns != null)
1: 		{
1: 			innerTable.setHashKeyColumns(hashKeyColumns);
1: 		}
1: 		else
1: 		{
1: 			String name;
1: 			if (cd != null && cd.isIndex())
1: 			{
1: 				name = cd.getConglomerateName();
1: 			}
1: 			else
1: 			{
1: 				name = innerTable.getBaseTableName();
1: 			}
1: 
1: 			throw StandardException.newException(SQLState.LANG_HASH_NO_EQUIJOIN_FOUND, 
1: 						name,
1: 						innerTable.getBaseTableName());
1: 		}
1: 
1: 		// Mark all of the predicates in the probe list as qualifiers
1: 		nonStoreRestrictionList.markAllPredicatesQualifiers();
1: 
1: 		int[] conglomColumn = new int[hashKeyColumns.length];
1: 		if (cd != null && cd.isIndex())
1: 		{
1: 			/*
1: 			** If the conglomerate is an index, get the column numbers of the
1: 			** hash keys in the base heap.
1: 			*/
1: 			for (int index = 0; index < hashKeyColumns.length; index++)
1: 			{
1: 				conglomColumn[index] =
1: 				  cd.getIndexDescriptor().baseColumnPositions()[hashKeyColumns[index]];
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** If the conglomerate is a heap, the column numbers of the hash
1: 			** key are the column numbers returned by findHashKeyColumns().
1: 			**
1: 			** NOTE: Must switch from zero-based to one-based
1: 			*/
1: 			for (int index = 0; index < hashKeyColumns.length; index++)
1: 			{
1: 				conglomColumn[index] = hashKeyColumns[index] + 1;
1: 			}
1: 		}
1: 
1: 		/* Put the equality predicates on the key columns for the hash first.
1: 		 * (Column # is columns[colCtr] from above.)
1: 		 */
1: 		for (int index = hashKeyColumns.length - 1; index >= 0; index--)
1: 		{
1: 			nonStoreRestrictionList.putOptimizableEqualityPredicateFirst(
1: 					innerTable,
1: 					conglomColumn[index]);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#isHashJoin
1: 	 */
1: 	public boolean isHashJoin()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#doesMaterialization
1: 	 */
1: 	public boolean doesMaterialization()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Find the hash key columns, if any, to use with this join.
1: 	 *
1: 	 * @param innerTable	The inner table of the join
1: 	 * @param cd			The conglomerate descriptor to use on inner table
1: 	 * @param predList		The predicate list to look for the equijoin in
1: 	 *
1: 	 * @return	the numbers of the hash key columns, or null if no hash key column
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private int[] findHashKeyColumns(Optimizable innerTable,
1: 									ConglomerateDescriptor cd,
1: 									OptimizablePredicateList predList)
1: 				throws StandardException
1: 	{
1: 		if (predList == null)
1: 			return (int[]) null;
1: 
1: 		/* Find the column to use as the hash key.
1: 		 * (There must be an equijoin condition on this column.)
1: 		 * If cd is null, then Optimizable is not a scan.
1: 		 * For indexes, we start at the first column in the key
1: 		 * and walk the key columns until we find the first one with
1: 		 * an equijoin condition on it.  We do essentially the same
1: 		 * for heaps.  (From column 1 through column n.)
1: 		 */
0: 		int[] columns = null;
1: 		if (cd == null)
1: 		{
1: 			columns = new int[innerTable.getNumColumnsReturned()];
1: 			for (int j = 0; j < columns.length; j++)
1: 			{
1: 				columns[j] = j + 1;
1: 			}
1: 		}
1: 		else if (cd.isIndex())
1: 		{
1: 			columns = cd.getIndexDescriptor().baseColumnPositions();
1: 		}
1: 		else
1: 		{
1: 			columns =
1: 				new int[innerTable.getTableDescriptor().getNumberOfColumns()];
1: 			for (int j = 0; j < columns.length; j++)
1: 			{
1: 				columns[j] = j + 1;
1: 			}
1: 		}
1: 
0: 		// Build a Vector of all the hash key columns
0: 		int colCtr;
0: 		Vector hashKeyVector = new Vector();
0: 		for (colCtr = 0; colCtr < columns.length; colCtr++)
1: 		{
1: 			// Is there an equijoin condition on this column?
1: 			if (predList.hasOptimizableEquijoin(innerTable, columns[colCtr]))
1: 			{
0: 				hashKeyVector.addElement(new Integer(colCtr));
1: 			}
1: 		}
1: 
0: 		// Convert the Vector into an int[], if there are hash key columns
0: 		if (hashKeyVector.size() > 0)
1: 		{
0: 			int[] keyCols = new int[hashKeyVector.size()];
0: 			for (int index = 0; index < keyCols.length; index++)
1: 			{
0: 				keyCols[index] = ((Integer) hashKeyVector.elementAt(index)).intValue();
1: 			}
0: 			return keyCols;
1: 		}
1: 		else
1: 			return (int[]) null;
1: 	}
1: 
1: 	public String toString() {
1: 		return getName();
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0be2d6e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.JBitSet;
0: 
/////////////////////////////////////////////////////////////////////////
1: 		/* If the predicate given by the user _directly_ references
1: 		 * any of the base tables _beneath_ this node, then we
1: 		 * cannot safely use the predicate for a hash because the
1: 		 * predicate correlates two nodes at different nesting levels. 
1: 		 * If we did a hash join in this case, materialization of
1: 		 * innerTable could lead to incorrect results--and in particular,
1: 		 * results that are missing rows.  We can check for this by
1: 		 * looking at the predicates' reference maps, which are set based
1: 		 * on the initial query (as part of pre-processing).  Note that
1: 		 * by the time we get here, it's possible that a predicate's
1: 		 * reference map holds table numbers that do not agree with the
1: 		 * table numbers of the column references used by the predicate.
1: 		 * That's okay--this occurs as a result of "remapping" predicates
1: 		 * that have been pushed down the query tree.  And in fact
1: 		 * it's a good thing because, by looking at the column reference's
1: 		 * own table numbers instead of the predicate's referenced map,
1: 		 * we are more readily able to find equijoin predicates that
1: 		 * we otherwise would not have found.
1: 		 *
1: 		 * Note: do not perform this check if innerTable is a FromBaseTable
1: 		 * because a base table does not have a "subtree" to speak of.
0: 		 */
1: 		if ((predList != null) && (predList.size() > 0) &&
1: 			!(innerTable instanceof FromBaseTable))
0: 		{
1: 			FromTable ft = (FromTable)innerTable;
0: 
1: 			// First get a list of all of the base tables in the subtree
1: 			// below innerTable.
1: 			JBitSet tNums = new JBitSet(ft.getReferencedTableMap().size());
1: 			BaseTableNumbersVisitor btnVis = new BaseTableNumbersVisitor(tNums);
1: 			ft.accept(btnVis);
0: 
1: 			// Now get a list of all table numbers referenced by the
1: 			// join predicates that we'll be searching.
1: 			JBitSet pNums = new JBitSet(tNums.size());
0: 			Predicate pred = null;
0: 			for (int i = 0; i < predList.size(); i++)
0: 			{
0: 				pred = (Predicate)predList.getOptPredicate(i);
1: 				if (pred.isJoinPredicate())
1: 					pNums.or(pred.getReferencedSet());
0: 			}
0: 
1: 			// If tNums and pNums have anything in common, then at
1: 			// least one predicate in the list refers directly to
1: 			// a base table beneath this node (as opposed to referring
1: 			// just to this node), which means it's not safe to do a
1: 			// hash join.
1: 			tNums.and(pNums);
1: 			if (tNums.getFirstSetBit() != -1)
1: 				return false;
0: 		}
0: 
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
0: 		return 29;
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 										OptimizablePredicateList predList) 
0: 	throws StandardException {
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
/////////////////////////////////////////////////////////////////////////
1: 	/** @see JoinStrategy#maxCapacity */
1: 	public int maxCapacity( int userSpecifiedCapacity,
1:                             int maxMemoryPerTable,
1:                             double perRowUsage) {
1:         if( userSpecifiedCapacity >= 0)
1:             return userSpecifiedCapacity;
1:         perRowUsage += ClassSize.estimateHashEntrySize();
1:         if( perRowUsage <= 1)
1:             return maxMemoryPerTable;
1:         return (int)(maxMemoryPerTable/perRowUsage);
/////////////////////////////////////////////////////////////////////////
1: 							int isolationLevel,
0:                             int maxMemoryPerTable
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(innerTable.maxCapacity( (JoinStrategy) this, maxMemoryPerTable));
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
0: import org.apache.derby.iapi.sql.compile.JoinStrategy;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ProjectRestrictNode;
0: import org.apache.derby.impl.sql.compile.Predicate;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: 
0: import java.util.Vector;
0: 
0: public class HashJoinStrategy extends BaseJoinStrategy { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	public HashJoinStrategy() {
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#feasible
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean feasible(Optimizable innerTable,
0: 							OptimizablePredicateList predList,
0: 							Optimizer optimizer
0: 							)
0: 					throws StandardException 
0: 	{
0: 		int[] hashKeyColumns = null;
0: 
0: 		ConglomerateDescriptor cd = null;
0: 
0: 		/* If the innerTable is a VTI, then we
0: 		 * must check to see if there are any
0: 		 * join columns in the VTI's parameters.
0: 		 * If so, then hash join is not feasible.
0: 		 */
0: 		if (! innerTable.isMaterializable())
0: 		{
0: 
0: 			optimizer.trace(Optimizer.HJ_SKIP_NOT_MATERIALIZABLE, 0, 0, 0.0,
0: 							null);
0: 			return false;
0: 		}
0: 
0: 		/* Don't consider hash join on the target table of an update/delete.
0: 		 * RESOLVE - this is a temporary restriction.  Problem is that we
0: 		 * do not put RIDs into the row in the hash table when scanning
0: 		 * the heap and we need them for a target table.
0: 		 */
0: 		if (innerTable.isTargetTable())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		if (innerTable.isBaseTable())
0: 		{
0: 			/* Must have an equijoin on a column in the conglomerate */
0: 			cd = innerTable.getCurrentAccessPath().getConglomerateDescriptor();
0: 		}
0: 		
0: 		/* Look for equijoins in the predicate list */
0: 		hashKeyColumns = findHashKeyColumns(
0: 											innerTable,
0: 											cd,
0: 											predList);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (hashKeyColumns == null)
0: 			{
0: 				optimizer.trace(Optimizer.HJ_SKIP_NO_JOIN_COLUMNS, 0, 0, 0.0, null);
0: 			}
0: 			else
0: 			{
0: 				optimizer.trace(Optimizer.HJ_HASH_KEY_COLUMNS, 0, 0, 0.0, hashKeyColumns);
0: 			}
0: 		}
0: 
0: 		if (hashKeyColumns == null)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/** @see JoinStrategy#ignoreBulkFetch */
0: 	public boolean ignoreBulkFetch() {
0: 		return true;
0: 	}
0: 
0: 	/** @see JoinStrategy#multiplyBaseCostByOuterRows */
0: 	public boolean multiplyBaseCostByOuterRows() {
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#getBasePredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public OptimizablePredicateList getBasePredicates(
0: 									OptimizablePredicateList predList,
0: 									OptimizablePredicateList basePredicates,
0: 									Optimizable innerTable)
0: 							throws StandardException {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(basePredicates.size() == 0,
0: 				"The base predicate list should be empty.");
0: 		}
0: 
0: 		for (int i = predList.size() - 1; i >= 0; i--) {
0: 			OptimizablePredicate pred = predList.getOptPredicate(i);
0: 
0: 			if (innerTable.getReferencedTableMap().contains(pred.getReferencedMap()))
0: 			{
0: 				basePredicates.addOptPredicate(pred);
0: 				predList.removeOptPredicate(i);
0: 			}
0: 		}
0: 
0: 		basePredicates.classify(
0: 				innerTable,
0: 				innerTable.getCurrentAccessPath().getConglomerateDescriptor());
0: 
0: 		return basePredicates;
0: 	}
0: 
0: 	/** @see JoinStrategy#nonBasePredicateSelectivity */
0: 	public double nonBasePredicateSelectivity(
0: 										Optimizable innerTable,
0: 										OptimizablePredicateList predList) {
0: 		double retval = 1.0;
0: 
0: 		if (predList != null) {
0: 			for (int i = 0; i < predList.size(); i++) {
0: 				// Don't include redundant join predicates in selectivity calculations
0: 				if (predList.isRedundantPredicate(i))
0: 				{
0: 					continue;
0: 				}
0: 
0: 				retval *= predList.getOptPredicate(i).selectivity(innerTable);
0: 			}
0: 		}
0: 
0: 		return retval;
0: 	}
0: 	
0: 	/**
0: 	 * @see JoinStrategy#putBasePredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void putBasePredicates(OptimizablePredicateList predList,
0: 									OptimizablePredicateList basePredicates)
0: 						throws StandardException {
0: 		for (int i = basePredicates.size() - 1; i >= 0; i--) {
0: 			OptimizablePredicate pred = basePredicates.getOptPredicate(i);
0: 
0: 			predList.addOptPredicate(pred);
0: 			basePredicates.removeOptPredicate(i);
0: 		}
0: 	}
0: 
0: 	/** @see JoinStrategy#estimateCost */
0: 	public void estimateCost(Optimizable innerTable,
0: 							 OptimizablePredicateList predList,
0: 							 ConglomerateDescriptor cd,
0: 							 CostEstimate outerCost,
0: 							 Optimizer optimizer,
0: 							 CostEstimate costEstimate) {
0: 		/*
0: 		** The cost of a hash join is the cost of building the hash table.
0: 		** There is no extra cost per outer row, so don't do anything here.
0: 		*/
0: 	}
0: 
0: 	/** @see JoinStrategy#memoryUsage */
0: 	public double memoryUsage(double memoryPerRow, double rowCount) {
0: 		return memoryPerRow * rowCount;
0: 	}
0: 
0: 	/** @see JoinStrategy#getName */
0: 	public String getName() {
0: 		return "HASH";
0: 	}
0: 
0: 	/** @see JoinStrategy#scanCostType */
0: 	public int scanCostType() {
0: 		return StoreCostController.STORECOST_SCAN_SET;
0: 	}
0: 
0: 	/** @see JoinStrategy#resultSetMethodName */
0: 	public String resultSetMethodName(boolean bulkFetch) {
0: 		return "getHashScanResultSet";
0: 	}
0: 
0: 	/** @see JoinStrategy#joinResultSetMethodName */
0: 	public String joinResultSetMethodName() {
0: 		return "getHashJoinResultSet";
0: 	}
0: 
0: 	/** @see JoinStrategy#halfOuterJoinResultSetMethodName */
0: 	public String halfOuterJoinResultSetMethodName() {
0: 		return "getHashLeftOuterJoinResultSet";
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#getScanArgs
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public int getScanArgs(
0: 							TransactionController tc,
0: 							MethodBuilder mb,
0: 							Optimizable innerTable,
0: 							OptimizablePredicateList storeRestrictionList,
0: 							OptimizablePredicateList nonStoreRestrictionList,
0: 							ExpressionClassBuilderInterface acbi,
0: 							int bulkFetch,
0: 							MethodBuilder resultRowAllocator,
0: 							int colRefItem,
0: 							int indexColItem,
0: 							int lockMode,
0: 							boolean tableLocked,
0: 							int isolationLevel
0: 							)
0: 						throws StandardException {
0: 		ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
0: 
0: 		fillInScanArgs1(tc,
0: 										mb,
0: 										innerTable,
0: 										storeRestrictionList,
0: 										acb,
0: 										resultRowAllocator);
0: 
0: 		nonStoreRestrictionList.generateQualifiers(acb,	mb, innerTable, true);
0: 		mb.push(innerTable.initialCapacity());
0: 		mb.push(innerTable.loadFactor());
0: 		mb.push(innerTable.maxCapacity());
0: 		/* Get the hash key columns and wrap them in a formattable */
0: 		int[] hashKeyColumns = innerTable.hashKeyColumns();
0: 		FormatableIntHolder[] fihArray = 
0: 				FormatableIntHolder.getFormatableIntHolders(hashKeyColumns); 
0: 		FormatableArrayHolder hashKeyHolder = new FormatableArrayHolder(fihArray);
0: 		int hashKeyItem = acb.addItem(hashKeyHolder);
0: 		mb.push(hashKeyItem);
0: 
0: 		fillInScanArgs2(mb,
0: 						innerTable,
0: 						bulkFetch,
0: 						colRefItem,
0: 						indexColItem,
0: 						lockMode,
0: 						tableLocked,
0: 						isolationLevel);
0: 
0: 		return 28;
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#divideUpPredicateLists
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void divideUpPredicateLists(
0: 					Optimizable				 innerTable,
0: 					OptimizablePredicateList originalRestrictionList,
0: 					OptimizablePredicateList storeRestrictionList,
0: 					OptimizablePredicateList nonStoreRestrictionList,
0: 					OptimizablePredicateList requalificationRestrictionList,
0: 					DataDictionary			 dd
0: 					) throws StandardException
0: 	{
0: 		/*
0: 		** If we are walking a non-covering index, then all predicates that
0: 		** get evaluated in the HashScanResultSet, whether during the building
0: 		** or probing of the hash table, need to be evaluated at both the
0: 		** IndexRowToBaseRowResultSet and the HashScanResultSet to ensure
0: 		** that the rows materialized into the hash table still qualify when
0: 		** we go to read the row from the heap.  This also includes predicates
0:         ** that are not qualifier/start/stop keys (hence not in store/non-store
0:         ** list).
0: 		*/
0: 		originalRestrictionList.copyPredicatesToOtherList(
0:             requalificationRestrictionList);
0: 
0: 		ConglomerateDescriptor cd =
0: 			innerTable.getTrulyTheBestAccessPath().getConglomerateDescriptor();
0: 
0: 		/* For the inner table of a hash join, then divide up the predicates:
0:          *
0: 		 *	o restrictionList	- predicates that get applied when creating 
0: 		 *						  the hash table (single table clauses)
0:          *
0: 		 *  o nonBaseTableRestrictionList
0: 		 *						- those that get applied when probing into the 
0: 		 *						  hash table (equijoin clauses on key columns,
0: 		 *						  ordered by key column position first, followed
0: 		 *						  by any other join predicates. (All predicates
0:          *						  in this list are qualifiers which can be 
0:          *						  evaluated in the store).
0:          *
0: 		 *  o baseTableRL		- Only applicable if this is not a covering 
0:          *                        index.  In that case, we will need to 
0:          *                        requalify the data page.  Thus, this list 
0:          *                        will include all predicates.
0: 		 */
0: 
0: 		// Build the list to be applied when creating the hash table
0: 		originalRestrictionList.transferPredicates(
0: 									storeRestrictionList,
0: 									innerTable.getReferencedTableMap(),
0: 									innerTable);
0: 
0: 		/* 
0:          * Eliminate any non-qualifiers that may have been pushed, but
0:          * are redundant and not useful for hash join.
0:          * 
0:          * For instance "in" (or other non-qualifier) was pushed down for 
0:          * start/stop key, * but for hash join, it may no longer be because 
0:          * previous key column may have been disqualified (eg., correlation).  
0:          * We simply remove 
0:          * such non-qualifier ("in") because we left it as residual predicate 
0:          * anyway.  It's easier/safer to filter it out here than detect it 
0:          * ealier (and not push it down). Beetle 4316.
0:          *
0:          * Can't filter out OR list, as it is not a residual predicate, 
0: 		 */
0: 		for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
0: 		{
0: 			Predicate p1 = (Predicate) storeRestrictionList.getOptPredicate(i);
0: 
0:            
0:             if (!p1.isStoreQualifier() && !p1.isStartKey() && !p1.isStopKey())
0:             {
0: 				storeRestrictionList.removeOptPredicate(i);
0:             }
0: 		}
0: 
0: 		for (int i = originalRestrictionList.size() - 1; i >= 0; i--)
0: 		{
0: 			Predicate p1 = 
0:                 (Predicate) originalRestrictionList.getOptPredicate(i);
0: 
0:             if (!p1.isStoreQualifier())
0: 				originalRestrictionList.removeOptPredicate(i);
0: 		}
0: 
0: 		/* Copy the rest of the predicates to the non-store list */
0: 		originalRestrictionList.copyPredicatesToOtherList(
0: 													nonStoreRestrictionList);
0: 
0: 		/* If innerTable is ProjectRestrictNode, we need to use its child
0: 		 * to find hash key columns, this is because ProjectRestrictNode may
0: 		 * not have underlying node's every result column as result column,
0: 		 * and the predicate's column reference was bound to the underlying
0: 		 * node's column position.  Also we have to pass in the 
0: 	 	 * ProjectRestrictNode rather than the underlying node to this method
0: 		 * because a predicate's referencedTableMap references the table number
0: 		 * of the ProjectRestrictiveNode.  And we need this info to see if
0: 		 * a predicate is in storeRestrictionList that can be pushed down.
0: 		 * Beetle 3458.
0: 		 */
0: 		Optimizable hashTableFor = innerTable;
0: 		if (innerTable instanceof ProjectRestrictNode)
0: 		{
0: 			ProjectRestrictNode prn = (ProjectRestrictNode) innerTable;
0: 			if (prn.getChildResult() instanceof Optimizable)
0: 				hashTableFor = (Optimizable) (prn.getChildResult());
0: 		}
0: 		int[] hashKeyColumns = findHashKeyColumns(hashTableFor,
0: 												cd,
0: 												nonStoreRestrictionList);
0: 		if (hashKeyColumns != null)
0: 		{
0: 			innerTable.setHashKeyColumns(hashKeyColumns);
0: 		}
0: 		else
0: 		{
0: 			String name;
0: 			if (cd != null && cd.isIndex())
0: 			{
0: 				name = cd.getConglomerateName();
0: 			}
0: 			else
0: 			{
0: 				name = innerTable.getBaseTableName();
0: 			}
0: 
0: 			throw StandardException.newException(SQLState.LANG_HASH_NO_EQUIJOIN_FOUND, 
0: 						name,
0: 						innerTable.getBaseTableName());
0: 		}
0: 
0: 		// Mark all of the predicates in the probe list as qualifiers
0: 		nonStoreRestrictionList.markAllPredicatesQualifiers();
0: 
0: 		int[] conglomColumn = new int[hashKeyColumns.length];
0: 		if (cd != null && cd.isIndex())
0: 		{
0: 			/*
0: 			** If the conglomerate is an index, get the column numbers of the
0: 			** hash keys in the base heap.
0: 			*/
0: 			for (int index = 0; index < hashKeyColumns.length; index++)
0: 			{
0: 				conglomColumn[index] =
0: 				  cd.getIndexDescriptor().baseColumnPositions()[hashKeyColumns[index]];
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** If the conglomerate is a heap, the column numbers of the hash
0: 			** key are the column numbers returned by findHashKeyColumns().
0: 			**
0: 			** NOTE: Must switch from zero-based to one-based
0: 			*/
0: 			for (int index = 0; index < hashKeyColumns.length; index++)
0: 			{
0: 				conglomColumn[index] = hashKeyColumns[index] + 1;
0: 			}
0: 		}
0: 
0: 		/* Put the equality predicates on the key columns for the hash first.
0: 		 * (Column # is columns[colCtr] from above.)
0: 		 */
0: 		for (int index = hashKeyColumns.length - 1; index >= 0; index--)
0: 		{
0: 			nonStoreRestrictionList.putOptimizableEqualityPredicateFirst(
0: 					innerTable,
0: 					conglomColumn[index]);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#isHashJoin
0: 	 */
0: 	public boolean isHashJoin()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#doesMaterialization
0: 	 */
0: 	public boolean doesMaterialization()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Find the hash key columns, if any, to use with this join.
0: 	 *
0: 	 * @param innerTable	The inner table of the join
0: 	 * @param cd			The conglomerate descriptor to use on inner table
0: 	 * @param predList		The predicate list to look for the equijoin in
0: 	 *
0: 	 * @return	the numbers of the hash key columns, or null if no hash key column
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private int[] findHashKeyColumns(Optimizable innerTable,
0: 									ConglomerateDescriptor cd,
0: 									OptimizablePredicateList predList)
0: 				throws StandardException
0: 	{
0: 		if (predList == null)
0: 			return (int[]) null;
0: 
0: 		/* Find the column to use as the hash key.
0: 		 * (There must be an equijoin condition on this column.)
0: 		 * If cd is null, then Optimizable is not a scan.
0: 		 * For indexes, we start at the first column in the key
0: 		 * and walk the key columns until we find the first one with
0: 		 * an equijoin condition on it.  We do essentially the same
0: 		 * for heaps.  (From column 1 through column n.)
0: 		 */
0: 		int[] columns = null;
0: 		if (cd == null)
0: 		{
0: 			columns = new int[innerTable.getNumColumnsReturned()];
0: 			for (int j = 0; j < columns.length; j++)
0: 			{
0: 				columns[j] = j + 1;
0: 			}
0: 		}
0: 		else if (cd.isIndex())
0: 		{
0: 			columns = cd.getIndexDescriptor().baseColumnPositions();
0: 		}
0: 		else
0: 		{
0: 			columns =
0: 				new int[innerTable.getTableDescriptor().getNumberOfColumns()];
0: 			for (int j = 0; j < columns.length; j++)
0: 			{
0: 				columns[j] = j + 1;
0: 			}
0: 		}
0: 
0: 		// Build a Vector of all the hash key columns
0: 		int colCtr;
0: 		Vector hashKeyVector = new Vector();
0: 		for (colCtr = 0; colCtr < columns.length; colCtr++)
0: 		{
0: 			// Is there an equijoin condition on this column?
0: 			if (predList.hasOptimizableEquijoin(innerTable, columns[colCtr]))
0: 			{
0: 				hashKeyVector.addElement(new Integer(colCtr));
0: 			}
0: 		}
0: 
0: 		// Convert the Vector into an int[], if there are hash key columns
0: 		if (hashKeyVector.size() > 0)
0: 		{
0: 			int[] keyCols = new int[hashKeyVector.size()];
0: 			for (int index = 0; index < keyCols.length; index++)
0: 			{
0: 				keyCols[index] = ((Integer) hashKeyVector.elementAt(index)).intValue();
0: 			}
0: 			return keyCols;
0: 		}
0: 		else
0: 			return (int[]) null;
0: 	}
0: 
0: 	public String toString() {
0: 		return getName();
0: 	}
0: }
============================================================================