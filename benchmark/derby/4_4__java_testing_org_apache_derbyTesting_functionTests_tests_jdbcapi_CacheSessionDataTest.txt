1:659f564: 
1:659f564: /*
1:659f564:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.CacheSessionDataTest
1:659f564:    Licensed to the Apache Software Foundation (ASF) under one
1:659f564:    or more contributor license agreements.  See the NOTICE file
1:659f564:    distributed with this work for additional information
1:659f564:    regarding copyright ownership.  The ASF licenses this file
1:659f564:    to you under the Apache License, Version 2.0 (the
1:659f564:    "License"); you may not use this file except in compliance
1:659f564:    with the License.  You may obtain a copy of the License at
1:659f564:   
1:659f564:      http://www.apache.org/licenses/LICENSE-2.0
1:659f564:   
1:659f564:    Unless required by applicable law or agreed to in writing,
1:659f564:    software distributed under the License is distributed on an
1:659f564:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:659f564:    KIND, either express or implied.  See the License for the
1:659f564:    specific language governing permissions and limitations
1:659f564:    under the License.
1:659f564:  */
1:659f564: 
1:659f564: 
1:659f564: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:659f564: 
1:659f564: import java.sql.CallableStatement;
1:659f564: import java.sql.Connection;
1:659f564: import java.sql.DatabaseMetaData;
1:659f564: import java.sql.DriverManager;
1:659f564: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:659f564: import java.sql.SQLException;
1:659f564: import java.sql.Statement;
1:659f564: import java.sql.Types;
1:c6c4d4d: import java.util.Arrays;
1:659f564: import junit.framework.Test;
1:69e3d06: import org.apache.derby.client.am.ClientConnection;
1:659f564: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:659f564: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:d4a1ecd: import org.apache.derbyTesting.junit.JDBC;
1:659f564: import org.apache.derbyTesting.junit.TestConfiguration;
1:659f564: 
1:659f564: /**
1:659f564:  * Utility class for representing isolation levels. Provides a convenient way 
1:659f564:  * to track the JDBC constant, the JDBC constant name and the SQL name of an
1:659f564:  * isolation level. By overriding equals and toString it becomes convenient to
1:659f564:  * use this class in JUnit's assertEquals methods. 
1:659f564:  */
1:659f564: final class IsoLevel {
1:659f564:     private final int isoLevel_;
1:659f564:     private final String jdbcName_;
1:659f564:     private final String sqlName_;
1:659f564:     
1:659f564:     /**
1:659f564:      * Constructs an IsoLevel object from a ResultSet. The ResultSet must be 
1:659f564:      * equivalent to 'SELECT * FROM ISOLATION_NAMES'. Calls next() on the 
1:659f564:      * ResultSet, so the caller must position the ResultSet on the row before
1:659f564:      * the row that is to be used to create the IsoLevel object.
1:659f564:      * @param rs ResultSet holding isolation level descriptions
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public IsoLevel(ResultSet rs) throws SQLException {
1:659f564:         rs.next();
1:659f564:         isoLevel_ = rs.getInt("ISOLEVEL");
1:659f564:         jdbcName_ = rs.getString("JDBCNAME");
1:659f564:         sqlName_ = rs.getString("SQLNAME");
1:659f564:     }
1:659f564: 
1:659f564:     public int getIsoLevel() { return isoLevel_; }
1:659f564:     public String getJdbcName() { return jdbcName_; }
1:659f564:     public String getSqlName() { return sqlName_; }
1:659f564:     public String toString() {
1:659f564:         return "(" + jdbcName_ + ", " + sqlName_ + ")";
1:659f564:     }
1:659f564:     public boolean equals(Object that) {
1:659f564:         if (this == that) {
1:659f564:             return true;
1:659f564:         }
1:659f564:         if (that instanceof IsoLevel) {
1:659f564:             return (isoLevel_ == ((IsoLevel) that).isoLevel_);
1:659f564:         }
1:659f564:         return false;
1:659f564:     }
1:659f564:     public int hashCode() { return isoLevel_; }
1:659f564: }
1:659f564: 
1:659f564: /**
1:659f564:  * This is a test for DERBY-3192 (https://issues.apache.org/jira/browse/DERBY-3192) 
1:659f564:  * which tries to avoid unecessary roundtrips by piggybacking session 
1:659f564:  * information on the messages going back to the client. The goal is that
1:659f564:  * whenever a user requests session information from the client driver, the 
1:659f564:  * correct information should already be available and no special roundtrip
1:659f564:  * be required. 
1:659f564:  * So far the test only checks caching of the isolation level, but other 
1:659f564:  * session attributes can be added later. The test attempts to "fool" 
1:659f564:  * the caching mechanism by
1:659f564:  * modifying the isolation level without going through the client's 
1:659f564:  * Connection.setTransactionIsolation method. 
1:659f564:  * The effect of modifying the isolation level in and 
1:659f564:  * out of XA transactions is covered by the XA tests and not tested here.
1:659f564:  */
1:659f564: public class CacheSessionDataTest extends BaseJDBCTestCase {
1:659f564:     
1:659f564:     public CacheSessionDataTest(String name) {
1:659f564:         super(name);
1:659f564:     }
1:659f564: 
1:659f564:     /**
1:659f564:      * Adds both the embedded and client-server versions of the baseSuite to
1:1ae02c9:      * the Test. An empty BaseTestSuite is returned unless we have JDBC3
1:1ae02c9:  support, because all test cases call verifyCachedIsolation() which in
1:1ae02c9:  turn makes use of getTransactionIsolationJDBC()
1:1ae02c9:  (GET_TRANSACTION_ISOLATION_JDBC) which uses DriverManager to access the
1:1ae02c9:  default connection.
1:659f564:      * @return the resulting Test object
1:659f564:      */
1:659f564:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("CacheSessionDataTest");
1:d4a1ecd:         if (JDBC.vmSupportsJDBC3()) {
1:d4a1ecd:             suite.addTest(baseSuite("CacheSessionDataTest:embedded"));
1:d4a1ecd:             suite.addTest(TestConfiguration.clientServerDecorator(
1:d4a1ecd:                     baseSuite("CacheSessionDataTest:client")));
1:d4a1ecd:         }
1:659f564:         return suite;
1:659f564:     }
1:659f564:     
1:659f564:     /**
1:1ae02c9:      * Creates a new BaseTestSuite with all the tests, and wraps it in a
1:1ae02c9:  CleanDatabaseSetup with a custom decorator.
1:1ae02c9:      * @param name BaseTestSuite name
1:659f564:      * @return wrapped TestSuite
1:659f564:      */
1:659f564:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:659f564:         suite.addTestSuite(CacheSessionDataTest.class);
1:659f564:         
1:659f564:         return new CleanDatabaseTestSetup(suite) {
1:659f564:             /**
1:659f564:             * Creates the tables, stored procedures, and functions 
1:659f564:             * shared by all test cases.
1:659f564:             * @throws SQLException 
1:659f564:             */
1:659f564:             protected void decorateSQL(Statement s) throws SQLException {
1:659f564:                 s.execute("CREATE TABLE ISOLATION_NAMES(ISOLEVEL INT, JDBCNAME " +
1:659f564:                         "VARCHAR(30), SQLNAME VARCHAR(2))");
1:659f564:                 PreparedStatement insert = s.getConnection().prepareStatement(
1:659f564:                         "INSERT INTO ISOLATION_NAMES VALUES (?, ?, ?)");
1:659f564:                 
1:659f564:                 insert.setInt(1, Connection.TRANSACTION_NONE);
1:659f564:                 insert.setString(2, "TRANSACTION_NONE"); 
1:659f564:                 insert.setNull(3, Types.VARCHAR);
1:659f564:                 insert.execute();
1:659f564:                 
1:659f564:                 insert.setInt(1, Connection.TRANSACTION_READ_UNCOMMITTED);
1:659f564:                 insert.setString(2, "TRANSACTION_READ_UNCOMMITTED");
1:659f564:                 insert.setString(3, "UR");
1:659f564:                 insert.execute();
1:659f564:                 
1:659f564:                 insert.setInt(1, Connection.TRANSACTION_READ_COMMITTED);
1:659f564:                 insert.setString(2, "TRANSACTION_READ_COMMITTED");
1:659f564:                 insert.setString(3, "CS");
1:659f564:                 insert.execute();
1:659f564:                 
1:659f564:                 insert.setInt(1, Connection.TRANSACTION_REPEATABLE_READ);
1:659f564:                 insert.setString(2, "TRANSACTION_REPEATABLE_READ");
1:659f564:                 insert.setString(3, "RS");
1:659f564:                 insert.execute();
1:659f564:                 
1:659f564:                 insert.setInt(1, Connection.TRANSACTION_SERIALIZABLE);
1:659f564:                 insert.setString(2, "TRANSACTION_SERIALIZABLE");
1:659f564:                 insert.setString(3, "RR");
1:659f564:                 insert.execute();
1:659f564:                 insert.close();
1:659f564:                 
1:659f564:                 s.execute("CREATE TABLE BIG(C1 VARCHAR(32672), " +
1:659f564:                         "C2 VARCHAR(32672), C3 VARCHAR(32672), C4 VARCHAR(32672))");                
1:659f564:                 s.execute("CREATE PROCEDURE INSERTDATA1(IN A INT) LANGUAGE JAVA " +
1:659f564:                         "PARAMETER STYLE JAVA EXTERNAL NAME " +
1:659f564:                         "'org.apache.derbyTesting.functionTests.util." +
1:659f564:                         "ProcedureTest.bigTestData'");
1:659f564:                 CallableStatement cs = s.getConnection().prepareCall("CALL INSERTDATA1(?)");
1:659f564:                 cs.setInt(1,9);
1:659f564:                 for (int i = 0; i < 10; ++i) {
1:659f564:                     cs.execute();
1:659f564:                 }
1:d4a1ecd:                 ResultSet x = s.executeQuery("SELECT COUNT(*) FROM BIG");
1:d4a1ecd:                 x.next();
1:d4a1ecd:                 println("BIG has "+x.getInt(1)+" rows");
1:659f564:                 
1:659f564:                 // Create procedures
1:659f564:                 s.execute("CREATE PROCEDURE SET_ISOLATION_JDBC" +
1:659f564:                         " (ISO INT) NO SQL LANGUAGE JAVA PARAMETER STYLE " +
1:659f564:                         "JAVA EXTERNAL NAME '" + 
1:659f564:                         CacheSessionDataTest.class.getName() + 
1:659f564:                         ".setIsolationJDBC'");
1:659f564:                 
1:659f564:                 s.execute("CREATE PROCEDURE SET_ISOLATION_SQL " +
1:659f564:                         "(SQLNAME VARCHAR(2)) MODIFIES SQL DATA LANGUAGE JAVA PARAMETER STYLE " +
1:659f564:                         "JAVA EXTERNAL NAME '" +
1:659f564:                         CacheSessionDataTest.class.getName() + 
1:659f564:                         ".setIsolationSQL'");
1:659f564:                 
1:659f564:                 // Create functions
1:659f564:                 s.execute("CREATE FUNCTION GET_TRANSACTION_ISOLATION_JDBC " +
1:659f564:                         "() RETURNS INT NO SQL LANGUAGE JAVA " +
1:659f564:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:659f564:                         CacheSessionDataTest.class.getName() + 
1:659f564:                         ".getTransactionIsolationJDBC'");        
1:659f564:                         
1:659f564:                 s.execute("CREATE FUNCTION GET_CYCLE_ISOLATION_JDBC " +
1:659f564:                         "() RETURNS INT NO SQL LANGUAGE JAVA " +
1:659f564:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:659f564:                         CacheSessionDataTest.class.getName() + 
1:659f564:                         ".getCycleIsolationJDBC'");
1:659f564:  
1:659f564:                 s.execute("CREATE FUNCTION GET_CYCLE_ISOLATION_SQL " +
1:c6c4d4d:                         "() RETURNS VARCHAR(2) READS SQL DATA LANGUAGE JAVA " +
1:c6c4d4d:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:659f564:                         CacheSessionDataTest.class.getName() + 
1:659f564:                         ".getCycleIsolationSQL'");
1:c6c4d4d: 
1:c6c4d4d:                 // Schema testing
1:c6c4d4d:                 s.execute("CREATE SCHEMA FOO");
1:c6c4d4d:                 String unicodeschema = "\u00bbMY\u20ac\u00ab";
1:c6c4d4d:                 s.execute("CREATE SCHEMA \"" + unicodeschema + "\"");
1:c6c4d4d: 
1:c6c4d4d:                 s.execute("CREATE PROCEDURE APP.SET_SCHEMA (SCHEMANAME " +
1:c6c4d4d:                         "VARCHAR(128)) MODIFIES SQL DATA LANGUAGE JAVA " +
1:c6c4d4d:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:c6c4d4d:                         CacheSessionDataTest.class.getName() + ".setSchema'");
1:c6c4d4d: 
1:c6c4d4d:                 s.execute("CREATE FUNCTION APP.GET_SCHEMA_TRANSITION " +
1:c6c4d4d:                         "(SCHEMANAME VARCHAR(128)) RETURNS VARCHAR(128) READS " +
1:c6c4d4d:                         "SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL " +
1:c6c4d4d:                         "NAME '" + CacheSessionDataTest.class.getName() +
1:c6c4d4d:                         ".getSchemaTransition'");
1:c6c4d4d: 
1:c6c4d4d:                 s.execute("CREATE TABLE APP.LARGE(X VARCHAR(32000), " +
1:c6c4d4d:                         "SCHEMANAME VARCHAR(128), Y VARCHAR(32000))");
1:c6c4d4d: 
1:c6c4d4d:                 char[] carray = new char[32000];
1:c6c4d4d:                 Arrays.fill(carray, 'x');
1:c6c4d4d:                 String xs = new String(carray);
1:c6c4d4d:                 Arrays.fill(carray, 'y');
1:c6c4d4d:                 String ys = new String(carray);
1:c6c4d4d: 
1:c6c4d4d:                 s.execute("INSERT INTO APP.LARGE (SELECT '" + xs + "', " +
1:c6c4d4d:                         "SCHEMANAME, " + " '" + ys + "' FROM SYS.SYSSCHEMAS)");
1:659f564:             }
1:659f564:         };
1:659f564:     } // End baseSuite
1:659f564:     
1:659f564:     /**
1:659f564:      * Turns off auto commit on the default connection and verifies that the 
1:659f564:      * isolation level is read committed. Initailizes the array 'isoLevels' 
1:659f564:      * with the 4 standard isolation levels if this has not already been done.
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public void setUp() throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         c.setAutoCommit(false);
1:d4a1ecd:         assertEquals(Connection.TRANSACTION_READ_COMMITTED, c.getTransactionIsolation());
1:659f564:         if (isoLevels == null) {
1:d4a1ecd:             Statement s = createStatement();
1:659f564:             ResultSet rs = s.executeQuery(
1:659f564:                     "SELECT * FROM ISOLATION_NAMES WHERE ISOLEVEL > 0 " +
1:659f564:                     "ORDER BY ISOLEVEL");
1:659f564:             isoLevels = new IsoLevel[4];
1:659f564:             
1:659f564:             for (int i = 0; i < 4; ++i) {
1:659f564:                 isoLevels[i] = new IsoLevel(rs);
1:d4a1ecd:                 println(isoLevels[i].toString()); 
1:659f564:             }
1:659f564:             assertFalse(rs.next());
1:659f564:             rs.close();
1:659f564:             s.close();
1:659f564:         }
1:659f564:         assertNotNull(isoLevels[0]);
1:659f564:         assertNotNull(isoLevels[1]);
1:659f564:         assertNotNull(isoLevels[2]);
1:659f564:         assertNotNull(isoLevels[3]);
1:659f564:     }
1:659f564:     /**
1:659f564:      * Removes all tables in schema APP which has the prefix 'T', before calling
1:659f564:      * super.tearDown().
1:659f564:      * @throws java.lang.Exception
1:659f564:      */
1:659f564:     public void tearDown() throws Exception {
1:659f564:         DatabaseMetaData meta = getConnection().getMetaData();
1:659f564:         ResultSet tables = meta.getTables(null, "APP", "T%", null);
1:659f564:         Statement s = createStatement();
1:659f564:         while (tables.next()) {
1:659f564:             s.execute("DROP TABLE " + tables.getString("TABLE_NAME"));
1:659f564:         }
1:659f564:         tables.close();
1:659f564:         s.close();
1:659f564:         commit();
1:659f564:         super.tearDown();
1:659f564:     }
1:659f564:     
1:659f564:     /**
1:659f564:      * Implementation of the stored procedure SET_ISOLATION_JDBC.
1:659f564:      * Sets the the isolation level given as argument on the default connection
1:659f564:      * using Connection.setTransactionIasolation.
1:659f564:      * @param isolation JDBC isolation level constant representing the 
1:659f564:      * new isolation level
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public static void setIsolationJDBC(int isolation)
1:659f564:             throws SQLException {
1:659f564:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:659f564:         c.setTransactionIsolation(isolation);
1:659f564:     }
1:659f564:     /**
1:659f564:      * Implementation of the SQL function SET_ISOLATION_SQL.
1:659f564:      * Sets the the isolation level given as argument on the default connection
1:659f564:      * using SQL.
1:659f564:      * @param sqlName SQL string representing the new isolation level
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public static void setIsolationSQL(String sqlName)
1:659f564:             throws SQLException {
1:659f564:         Connection c = DriverManager.getConnection("jdbc:default:connection");
8:659f564:         Statement s = c.createStatement();
1:659f564:         s.execute("SET ISOLATION " + sqlName);
1:659f564:         s.close();
1:659f564:     }
1:659f564:     /**
1:659f564:      * Implementation of the SQL function GET_TRANSACTION_ISOLATION_JDBC.
1:659f564:      * Returns the isolation level reported by the default EmbedConnection 
1:659f564:      * on the server. Used to verify that the isolation level reported by 
1:659f564:      * the client is correct.
1:659f564:      * @return JDBC isolation level constant reported by the embedded driver
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public static int getTransactionIsolationJDBC()
1:659f564:             throws SQLException {
1:659f564:         return DriverManager.getConnection("jdbc:default:connection").
1:659f564:                 getTransactionIsolation();
1:659f564:     }
1:659f564:     /**
1:659f564:      * Implementation of the SQL function GET_CYCLE_ISOLATION_JDBC.
1:659f564:      * Cycles the isolation level on the default Connection.
1:659f564:      * @return the new JDBC isolation level constant
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public static int getCycleIsolationJDBC()
1:659f564:             throws SQLException {
1:659f564:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:659f564:         c.setTransactionIsolation(cycleIsolation().getIsoLevel());
1:d4a1ecd:         println("getCycleIsolationJDBC() -> "+c.getTransactionIsolation());
1:659f564:         return c.getTransactionIsolation();
1:659f564:     }
1:659f564:     /**
1:659f564:      * Implementation of the SQL function GET_CYCLE_ISOLATION_SQL.
1:659f564:      * Cycles the isolation level on the default Connection.
1:659f564:      * @return the SQL name of the new isolation level
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     public static String getCycleIsolationSQL()
1:659f564:             throws SQLException {
1:659f564:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:659f564:         Statement s = c.createStatement();
1:659f564:         s.execute("SET ISOLATION "+cycleIsolation().getSqlName());
1:659f564:         ResultSet rs = s.executeQuery("VALUES CURRENT ISOLATION");
1:659f564:         rs.next();
1:659f564:         String sqlName = rs.getString(1);
1:659f564:         rs.close();
1:659f564:         s.close();
1:d4a1ecd:         println("getCycleIsolationSQL() -> "+sqlName);
1:659f564:         return sqlName;
1:659f564:     }
1:659f564: 
1:c6c4d4d:     /**
1:c6c4d4d:      * Implementation of the SQL procedure SET_SCHEMA.
1:c6c4d4d:      * Sets a different schema on the default Connection.
1:c6c4d4d:      * @param schemaName name of the new schema
1:c6c4d4d:      * @throws java.sql.SQLException
1:c6c4d4d:      */
1:c6c4d4d:     public static void setSchema(String schemaName)
1:c6c4d4d:             throws SQLException {
1:c6c4d4d:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:c6c4d4d:         Statement s = c.createStatement();
1:c6c4d4d:         s.execute("SET SCHEMA " + schemaName);
1:c6c4d4d:         s.close();
1:c6c4d4d:     }
1:c6c4d4d: 
1:c6c4d4d:     /**
1:c6c4d4d:      * Implementation of the SQL function GET_SCHEMA_TRANSITION.
1:c6c4d4d:      * Sets the current schema to the name given as argument and returns the
1:c6c4d4d:      * schema transition.
1:c6c4d4d:      * @param nextSchema schema to transition to
1:dbed020:      * @return a string of the form oldSchema-&gt;newSchema
1:c6c4d4d:      * @throws java.sql.SQLException
1:c6c4d4d:      */
1:c6c4d4d:     public static String getSchemaTransition(String nextSchema)
1:c6c4d4d:             throws SQLException {
1:c6c4d4d:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:c6c4d4d:         Statement s = c.createStatement();
1:c6c4d4d:         ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
1:c6c4d4d:         rs.next();
1:c6c4d4d:         String prevSchema = rs.getString(1);
1:c6c4d4d:         rs.close();
1:c6c4d4d:         s.execute("SET SCHEMA \"" + nextSchema + "\"");
1:c6c4d4d:         s.close();
1:c6c4d4d:         return (prevSchema + "->" + nextSchema);
1:c6c4d4d:     }
1:c6c4d4d: 
1:659f564:     // Utilities
1:659f564:     private static IsoLevel[] isoLevels;    
1:659f564:     private static int isolationIndex = -1;
1:659f564:     
1:659f564:     /**
1:659f564:      * Utility that cycles through the legal isolation levels in the following
1:dbed020:      * order: read uncommitted -&gt; read committed -&gt; repeatable read -&gt; 
1:dbed020:      * serializable -&gt; read uncommitted -&gt; ...
1:659f564:      * @return IsoLevel object representing the isolation level.
1:659f564:      */
1:659f564:     private static IsoLevel cycleIsolation() {
1:659f564:         ++isolationIndex;
1:659f564:         isolationIndex %= 4;
1:659f564:         return isoLevels[isolationIndex];
1:659f564:     }
1:659f564: 
1:659f564:     /**
1:659f564:      * Utility that verifies that the isolation level reported by the client 
1:659f564:      * is the same as evaluating 'VALUES CURRENT ISOLATION' and getting the
1:659f564:      * isolation level from the EmbedConnection on the server.
1:659f564:      * @param c Connection to check
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:d4a1ecd:     private void verifyCachedIsolation(Connection c) throws SQLException {
1:659f564:         final int clientInt = c.getTransactionIsolation();
1:659f564:         
1:d4a1ecd:         Statement s = createStatement();
1:659f564:         final IsoLevel serverSql = new IsoLevel(s.executeQuery(
1:659f564:                 "SELECT * FROM ISOLATION_NAMES " +
1:659f564:                 "WHERE SQLNAME = (VALUES CURRENT ISOLATION)"));
1:659f564:         
1:659f564:         final IsoLevel serverJdbc = new IsoLevel(s.executeQuery(
1:659f564:                 "SELECT * FROM ISOLATION_NAMES " +
1:659f564:                 "WHERE ISOLEVEL = GET_TRANSACTION_ISOLATION_JDBC()"));
1:659f564:         
1:659f564:         final IsoLevel client = new IsoLevel(s.executeQuery("SELECT * FROM " +
1:659f564:                 "ISOLATION_NAMES WHERE ISOLEVEL = "+clientInt));
1:659f564:         s.getResultSet().close();
1:659f564:         s.close();
1:d4a1ecd:         assertEquals(serverSql, client);
1:d4a1ecd:         assertEquals(serverJdbc, client);
1:659f564:     }
1:659f564:     
1:c6c4d4d:     private void verifyCachedSchema(Connection c) throws SQLException {
1:8f0d45d:         if (usingDerbyNetClient()) {
1:c6c4d4d:             String cached =
1:69e3d06:                     ((ClientConnection) c).getCurrentSchemaName();
1:c6c4d4d:             Statement s = c.createStatement();
1:c6c4d4d:             ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
1:c6c4d4d:             rs.next();
1:c6c4d4d:             String reported = rs.getString(1);
1:c6c4d4d:             assertEquals(reported, cached);
1:c6c4d4d:         } else {
1:c6c4d4d:             println("Cannot verify cached schema for "+c.getClass());
1:c6c4d4d:         }
1:c6c4d4d:     }
1:c6c4d4d: 
1:659f564:     // Test cases (fixtures) 
1:659f564:     // Change the isolation level using SQL
1:659f564:     public void testChangeIsoLevelStatementSQL() throws SQLException {
1:659f564:         Connection c = getConnection();
1:d4a1ecd:         Statement s = createStatement();
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             s.execute("SET ISOLATION "+isoLevels[i].getSqlName());
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         s.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelPreparedStatementSQL() throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         for (int i = 0; i < 4; ++i) {
1:d4a1ecd:             PreparedStatement ps = prepareStatement("SET ISOLATION " + 
1:659f564:                     isoLevels[i].getSqlName());
1:659f564:             ps.execute();
1:659f564:             verifyCachedIsolation(c);
1:659f564:             ps.close();
1:659f564:         }
1:659f564:     }
1:659f564:     
1:659f564:     // Change the isolation level using a function
1:659f564:     public void testChangeIsoLevelFunctionJDBC() throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         c.setAutoCommit(true);
1:d4a1ecd:         Statement s = createStatement();
1:659f564:         s.execute("CREATE TABLE T1(ISOLEVEL INT)");
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             s.execute("INSERT INTO T1 VALUES GET_CYCLE_ISOLATION_JDBC()");
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         s.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelFunctionSQL() throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         c.setAutoCommit(true);
1:d4a1ecd:         Statement s = createStatement();
1:659f564:         s.execute("CREATE TABLE T1(SQLNAME VARCHAR(2))");
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             s.executeUpdate("INSERT INTO T1 VALUES GET_CYCLE_ISOLATION_SQL()");
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         s.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelPreparedFunctionJDBC() throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         c.setAutoCommit(true);
1:659f564:         Statement s = createStatement();
1:659f564:         s.execute("CREATE TABLE T1(ISOLEVEL INT)");
1:d4a1ecd:         PreparedStatement ps = prepareStatement("INSERT INTO T1 VALUES " +
1:659f564:                 "GET_CYCLE_ISOLATION_JDBC()");
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             ps.executeUpdate();
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         ps.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelPreparedFunctionSQL() throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         c.setAutoCommit(true);
1:659f564:         Statement s = createStatement();
1:659f564:         s.execute("CREATE TABLE T1(SQLNAME VARCHAR(2))");
1:d4a1ecd:         PreparedStatement ps = prepareStatement("INSERT INTO T1 VALUES " +
1:659f564:                 "GET_CYCLE_ISOLATION_SQL()");
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             ps.executeUpdate();
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         ps.close();
1:659f564:     }
1:659f564:  
1:659f564:     // Change isolation level from a stored procedure
1:659f564:     public void testChangeIsoLevelProcedureJDBC() throws SQLException {
1:659f564:         Connection c = getConnection();
1:d4a1ecd:         Statement s = createStatement();
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             s.execute("CALL SET_ISOLATION_JDBC(" + isoLevels[i].getIsoLevel() + ")");
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         s.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelProcedureSQL() throws SQLException {
1:659f564:         Connection c = getConnection();
1:d4a1ecd:         Statement s = createStatement();
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             s.execute("CALL SET_ISOLATION_SQL('" + isoLevels[i].getSqlName() + "')");
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         s.close();
1:659f564:     }
1:659f564: 
1:659f564:     // Changing isolation level from a stored procedure invoked from a 
1:659f564:     // callable statement
1:659f564:     public void testChangeIsoLevelCallableStatementJDBC() throws SQLException {
1:659f564:         Connection c = getConnection();
1:d4a1ecd:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_JDBC(?)");
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             cs.setInt(1, isoLevels[i].getIsoLevel());
1:659f564:             cs.execute();
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         cs.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelCallableStatementSQL() throws SQLException {
1:659f564:         Connection c = getConnection();
1:d4a1ecd:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_SQL(?)");
1:659f564:         for (int i = 0; i < 4; ++i) {
1:659f564:             cs.setString(1, isoLevels[i].getSqlName());
1:659f564:             cs.execute();
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         cs.close();
1:659f564:     }
1:659f564:     
1:659f564:     // Changing isolation level from executeBatch()
1:659f564:     public void testChangeIsoLevelSQLInBatch() throws SQLException {
1:659f564:         Statement s = createStatement();
1:659f564:         for (int i = 0; i < isoLevels.length; ++i) {
1:659f564:             s.addBatch("SET ISOLATION " + isoLevels[i].getSqlName());
1:659f564:         }
1:659f564: 
1:659f564:         try {
1:659f564:             s.executeBatch();
1:659f564:         } catch (SQLException e) {
1:659f564:             SQLException prev = e;
1:659f564:             while (e != null) {
1:659f564:                 prev = e;
1:659f564:                 e = e.getNextException();
1:659f564:             }
1:659f564:             throw prev;
1:659f564:         }
1:659f564:         verifyCachedIsolation(s.getConnection());
1:659f564:         s.close();
1:659f564:     }
1:659f564:     
1:659f564:     public void testChangeIsoLevelProcedureJdbcBatch() throws SQLException {
1:659f564:         Statement s = createStatement();
1:659f564:         for (int i = 0; i < isoLevels.length; ++i) {
1:659f564:             s.addBatch("CALL SET_ISOLATION_JDBC(" + isoLevels[i].getIsoLevel() + ")");
1:659f564:         }
1:659f564:         try {
1:659f564:             s.executeBatch();
1:659f564:         } catch (SQLException e) {
1:659f564:             SQLException prev = e;
1:659f564:             while (e != null) {
1:659f564:                 prev = e;
1:659f564:                 e = e.getNextException();
1:659f564:             }
1:659f564:             throw prev;
1:659f564:         }
1:659f564:         verifyCachedIsolation(s.getConnection());
1:659f564:         s.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelProcedureSqlBatch() throws SQLException {
1:659f564:         Statement s = createStatement();
1:659f564:         for (int i = 0; i < isoLevels.length; ++i) {
1:659f564:             s.addBatch("CALL SET_ISOLATION_SQL('" + isoLevels[i].getSqlName() + "')");
1:659f564:         }
1:659f564:         
1:659f564:         try {
1:659f564:             s.executeBatch();
1:659f564:         } catch (SQLException e) {
1:659f564:             SQLException prev = e;
1:659f564:             while (e != null) {
1:659f564:                 prev = e;
1:659f564:                 e = e.getNextException();
1:659f564:             }
1:659f564:             throw prev;
1:659f564:         }
1:659f564:         verifyCachedIsolation(s.getConnection());
1:659f564:         s.close();
1:659f564:     }
1:659f564:     
1:659f564:     public void testChangeIsoLevelProcedureJdbcCallableBatch() throws SQLException {
1:659f564:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_JDBC(?)");
1:659f564:         for (int i = 0; i < isoLevels.length; ++i) {
1:659f564:             cs.setInt(1, isoLevels[i].getIsoLevel());
1:659f564:             cs.addBatch();
1:659f564:         }
1:659f564:         try {
1:659f564:             cs.executeBatch();
1:659f564:         } catch (SQLException e) {
1:659f564:             SQLException prev = e;
1:659f564:             while (e != null) {
1:659f564:                 prev = e;
1:659f564:                 e = e.getNextException();
1:659f564:             }
1:659f564:             throw prev;
1:659f564:         }
1:659f564:         verifyCachedIsolation(cs.getConnection());
1:659f564:         cs.close();
1:659f564:     }
1:659f564:     public void testChangeIsoLevelProcedureSqlCallableBatch() throws SQLException {
1:659f564:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_SQL(?)");
1:659f564:         for (int i = 0; i < isoLevels.length; ++i) {
1:659f564:             cs.setString(1, isoLevels[i].getSqlName());
1:659f564:             cs.addBatch();
1:659f564:         }
1:659f564:         try {
1:659f564:             cs.executeBatch();
1:659f564:         } catch (SQLException e) {
1:659f564:             SQLException prev = e;
1:659f564:             while (e != null) {
1:659f564:                 prev = e;
1:659f564:                 e = e.getNextException();
1:659f564:             }
1:659f564:             throw prev;
1:659f564:         }
1:659f564:         verifyCachedIsolation(cs.getConnection());
1:659f564:         cs.close();
1:659f564:     }
1:659f564: 
1:659f564:     
1:659f564:     /**
1:659f564:      * Utility method for testing Statements that return different 
1:659f564:      * types of ResultSets to check that piggybacking doesn't cause problems.
1:659f564:      * @param table table to select from
1:659f564:      * @param type type of ResultSet
1:659f564:      * @param concur concurrency of ResultSet
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     private void cursorTest(String table, int type, int concur) 
1:659f564:             throws SQLException {
1:659f564:         Connection c = getConnection();
1:d4a1ecd:         Statement s = createStatement(type, concur);
1:659f564:         ResultSet rs = s.executeQuery("SELECT * FROM "+table);
1:659f564:         verifyCachedIsolation(c);
1:659f564:         while (rs.next()) {
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         rs.close();
1:659f564:         s.close();
1:659f564:     }
1:659f564:     
1:659f564:     /**
1:659f564:      * Utility method for testing PreparedStatements that return different 
1:659f564:      * types of ResultSets to check that piggybacking doesn't cause problems.
1:659f564:      * 
1:659f564:      * @param table table to select from
1:659f564:      * @param type type of ResultSet
1:659f564:      * @param concur concurrency of ResultSet
1:659f564:      * @throws java.sql.SQLException
1:659f564:      */
1:659f564:     private void preparedCursorTest(String table, int type, int concur)
1:659f564:             throws SQLException {
1:659f564:         Connection c = getConnection();
1:659f564:         PreparedStatement ps = c.prepareStatement("SELECT * FROM " + table, 
1:659f564:                 type, concur);
1:659f564:         ResultSet rs = ps.executeQuery();
1:659f564:         verifyCachedIsolation(c);
1:659f564:         while (rs.next()) {
1:659f564:             verifyCachedIsolation(c);
1:659f564:         }
1:659f564:         rs.close();
1:659f564:         ps.close();
1:659f564:     }
1:659f564: 
1:659f564:     public void testSmallForwardOnlyReadOnly() throws SQLException {
1:659f564:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY, 
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:659f564:     public void testSmallScrollInsensitiveReadOnly() throws SQLException {
1:659f564:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_INSENSITIVE,                
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:659f564:     public void testSmallScrollSensitiveReadOnly() throws SQLException {
1:659f564:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:659f564:     public void testSmallForwardOnlyUpdatable() throws SQLException {
1:659f564:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY, 
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     public void testSmallScrollInsensitiveUpdatable() throws SQLException {
1:659f564:         cursorTest("ISOLATION_NAMES",ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     public void testSmallScrollSensitiveUpdatable() throws SQLException {
1:659f564:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:    
1:659f564: 
1:659f564:     public void testSmallPreparedForwardOnlyReadOnly() throws SQLException {
1:659f564:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY, 
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }    
1:659f564:     public void testSmallPreparedScrollSensitiveReadOnly() throws SQLException {
1:659f564:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }     
1:659f564:     public void testSmallPreparedScrollInsensitiveReadOnly() throws SQLException {
1:659f564:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:659f564:     public void testSmallPreparedForwardOnlyUpdatable() throws SQLException {
1:659f564:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     public void testSmallPreparedScrollSensitiveUpdatable() throws SQLException {
1:659f564:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     public void testSmallPreparedScrollInsensitiveUpdatable() throws SQLException {
1:659f564:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     
1:659f564:     
1:659f564:     public void testLargeForwardOnlyReadOnly() throws SQLException {
1:659f564:         cursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY, 
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }    
1:659f564:     public void testLargeScrollSensitiveReadOnly() throws SQLException {
1:659f564:         cursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE, 
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }    
1:659f564:     public void testLargeScrollInsensitiveReadOnly() throws SQLException {
1:659f564:         cursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:659f564:     public void testLargeForwardOnlyUpdatable() throws SQLException {
1:659f564:         cursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY, 
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     public void testLargeScrollSensitiveUpdatable() throws SQLException {
1:659f564:         cursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE, 
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564:     public void testLargeScrollInsensitiveUpdatable() throws SQLException {
1:659f564:         cursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:659f564: 
1:659f564: 
1:659f564:     public void testLargePreparedForwardOnlyReadOnly() throws SQLException {
1:659f564:         preparedCursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY,
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }     
1:659f564:     public void testLargePreparedScrollSensitiveReadOnly() throws SQLException {
1:659f564:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE,
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:c6c4d4d:     public void testLargePreparedScrollInsensitiveReadOnly()
1:c6c4d4d:             throws SQLException {
1:659f564:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:659f564:                 ResultSet.CONCUR_READ_ONLY);
1:659f564:     }
1:659f564:     public void testLargePreparedForwardOnlyUpdatable() throws SQLException {
1:659f564:         preparedCursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:c6c4d4d:     public void testLargePreparedScrollSensitiveUpdatable()
1:c6c4d4d:             throws SQLException {
1:659f564:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:c6c4d4d:     public void testLargePreparedScrollInsensitiveUpdatable()
1:c6c4d4d:             throws SQLException {
1:659f564:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:659f564:                 ResultSet.CONCUR_UPDATABLE);
1:659f564:     }
1:c6c4d4d: 
1:c6c4d4d:     // Test that the current schema is piggy-backed correctly
1:c6c4d4d:     public void testSetSchema() throws SQLException {
1:c6c4d4d:         Statement s = createStatement();
1:c6c4d4d:         s.execute("SET SCHEMA FOO");
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:         s.execute("SET SCHEMA \"\u00bbMY\u20ac\u00ab\"");
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:     }
1:c6c4d4d:     public void testPreparedSetSchema() throws SQLException {
1:c6c4d4d:         PreparedStatement ps = prepareStatement("SET SCHEMA ?");
1:c6c4d4d:         ps.setString(1, "FOO");
1:c6c4d4d:         ps.execute();
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:         ps.setString(1, "\u00bbMY\u20ac\u00ab");
1:c6c4d4d:         ps.execute();
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:     }
1:c6c4d4d:     public void testSetSchemaProcedure() throws SQLException {
1:c6c4d4d:         Statement s = createStatement();
1:c6c4d4d:         s.execute("CALL APP.SET_SCHEMA('FOO')");
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:         s.execute("CALL APP.SET_SCHEMA('\"\u00bbMY\u20ac\u00ab\"')");
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:     }
1:c6c4d4d:     public void testPreparedSetSchemaProcedure() throws SQLException {
1:c6c4d4d:         CallableStatement cs = prepareCall("CALL APP.SET_SCHEMA(?)");
1:c6c4d4d:         cs.setString(1, "FOO");
1:c6c4d4d:         cs.execute();
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:         cs.setString(1, "\"\u00bbMY\u20ac\u00ab\"");
1:c6c4d4d:         cs.execute();
1:c6c4d4d:         verifyCachedSchema(getConnection());
1:c6c4d4d:     }
1:c6c4d4d: 
1:c6c4d4d:     public void testSetSchemaFunction() throws SQLException {
1:c6c4d4d:         Statement s = createStatement();
1:c6c4d4d:         ResultSet rs = s.executeQuery("SELECT " +
1:c6c4d4d:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME) FROM SYS.SYSSCHEMAS");
1:c6c4d4d:         while (rs.next()) {
1:c6c4d4d:             assertTrue(rs.getString(1).length() > 2);
1:c6c4d4d:             verifyCachedSchema(getConnection());
1:c6c4d4d:         }
1:c6c4d4d:     }
1:c6c4d4d: 
1:c6c4d4d:     public void testPreparedSetSchemaFunction() throws SQLException {
1:c6c4d4d:         PreparedStatement ps = prepareStatement("SELECT " +
1:c6c4d4d:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME) FROM SYS.SYSSCHEMAS");
1:c6c4d4d:         ResultSet rs = ps.executeQuery();
1:c6c4d4d:         while (rs.next()) {
1:c6c4d4d:             assertTrue(rs.getString(1).length() > 2);
1:c6c4d4d:             verifyCachedSchema(getConnection());
1:c6c4d4d:         }
1:c6c4d4d:     }
1:c6c4d4d: 
1:c6c4d4d:     public void testSetSchemaFunctionLarge() throws SQLException {
1:c6c4d4d:         Statement s = createStatement();
1:c6c4d4d:         ResultSet rs = s.executeQuery("SELECT X, " +
1:c6c4d4d:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME), " +
1:c6c4d4d:                 "Y FROM APP.LARGE");
1:c6c4d4d:         while (rs.next()) {
1:c6c4d4d:             assertTrue(rs.getString(2).length() > 2);
1:c6c4d4d:             verifyCachedSchema(getConnection());
1:c6c4d4d:         }
1:c6c4d4d:     }
1:c6c4d4d: 
1:c6c4d4d:     public void testPreparedSetSchemaFunctionLarge() throws SQLException {
1:c6c4d4d:         PreparedStatement ps = prepareStatement("SELECT X, " +
1:c6c4d4d:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME), " +
1:c6c4d4d:                 "Y FROM APP.LARGE");
1:c6c4d4d:         ResultSet rs = ps.executeQuery();
1:c6c4d4d:         while (rs.next()) {
1:c6c4d4d:             assertTrue(rs.getString(2).length() > 2);
1:c6c4d4d:             verifyCachedSchema(getConnection());
1:c6c4d4d:         }
1:c6c4d4d:     }
1:659f564: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * @return a string of the form oldSchema-&gt;newSchema
/////////////////////////////////////////////////////////////////////////
1:      * order: read uncommitted -&gt; read committed -&gt; repeatable read -&gt; 
1:      * serializable -&gt; read uncommitted -&gt; ...
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:      * the Test. An empty BaseTestSuite is returned unless we have JDBC3
1:  support, because all test cases call verifyCachedIsolation() which in
1:  turn makes use of getTransactionIsolationJDBC()
1:  (GET_TRANSACTION_ISOLATION_JDBC) which uses DriverManager to access the
1:  default connection.
1:         BaseTestSuite suite = new BaseTestSuite("CacheSessionDataTest");
/////////////////////////////////////////////////////////////////////////
1:      * Creates a new BaseTestSuite with all the tests, and wraps it in a
1:  CleanDatabaseSetup with a custom decorator.
1:      * @param name BaseTestSuite name
1:         BaseTestSuite suite = new BaseTestSuite(name);
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientConnection;
/////////////////////////////////////////////////////////////////////////
1:                     ((ClientConnection) c).getCurrentSchemaName();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8f0d45d
/////////////////////////////////////////////////////////////////////////
1:         if (usingDerbyNetClient()) {
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:                         "() RETURNS VARCHAR(2) READS SQL DATA LANGUAGE JAVA " +
1:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1: 
1:                 // Schema testing
1:                 s.execute("CREATE SCHEMA FOO");
1:                 String unicodeschema = "\u00bbMY\u20ac\u00ab";
1:                 s.execute("CREATE SCHEMA \"" + unicodeschema + "\"");
1: 
1:                 s.execute("CREATE PROCEDURE APP.SET_SCHEMA (SCHEMANAME " +
1:                         "VARCHAR(128)) MODIFIES SQL DATA LANGUAGE JAVA " +
1:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:                         CacheSessionDataTest.class.getName() + ".setSchema'");
1: 
1:                 s.execute("CREATE FUNCTION APP.GET_SCHEMA_TRANSITION " +
1:                         "(SCHEMANAME VARCHAR(128)) RETURNS VARCHAR(128) READS " +
1:                         "SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL " +
1:                         "NAME '" + CacheSessionDataTest.class.getName() +
1:                         ".getSchemaTransition'");
1: 
1:                 s.execute("CREATE TABLE APP.LARGE(X VARCHAR(32000), " +
1:                         "SCHEMANAME VARCHAR(128), Y VARCHAR(32000))");
1: 
1:                 char[] carray = new char[32000];
1:                 Arrays.fill(carray, 'x');
1:                 String xs = new String(carray);
1:                 Arrays.fill(carray, 'y');
1:                 String ys = new String(carray);
1: 
1:                 s.execute("INSERT INTO APP.LARGE (SELECT '" + xs + "', " +
1:                         "SCHEMANAME, " + " '" + ys + "' FROM SYS.SYSSCHEMAS)");
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Implementation of the SQL procedure SET_SCHEMA.
1:      * Sets a different schema on the default Connection.
1:      * @param schemaName name of the new schema
1:      * @throws java.sql.SQLException
1:      */
1:     public static void setSchema(String schemaName)
1:             throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1:         s.execute("SET SCHEMA " + schemaName);
1:         s.close();
1:     }
1: 
1:     /**
1:      * Implementation of the SQL function GET_SCHEMA_TRANSITION.
1:      * Sets the current schema to the name given as argument and returns the
1:      * schema transition.
1:      * @param nextSchema schema to transition to
0:      * @return a string of the form oldSchema->newSchema
1:      * @throws java.sql.SQLException
1:      */
1:     public static String getSchemaTransition(String nextSchema)
1:             throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1:         ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
1:         rs.next();
1:         String prevSchema = rs.getString(1);
1:         rs.close();
1:         s.execute("SET SCHEMA \"" + nextSchema + "\"");
1:         s.close();
1:         return (prevSchema + "->" + nextSchema);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void verifyCachedSchema(Connection c) throws SQLException {
0:         if (c instanceof org.apache.derby.client.am.Connection) {
1:             String cached =
0:                     ((org.apache.derby.client.am.Connection) c).
0:                     getCurrentSchemaName();
1:             Statement s = c.createStatement();
1:             ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
1:             rs.next();
1:             String reported = rs.getString(1);
1:             assertEquals(reported, cached);
1:         } else {
1:             println("Cannot verify cached schema for "+c.getClass());
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testLargePreparedScrollInsensitiveReadOnly()
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void testLargePreparedScrollSensitiveUpdatable()
1:             throws SQLException {
1:     public void testLargePreparedScrollInsensitiveUpdatable()
1:             throws SQLException {
1: 
1:     // Test that the current schema is piggy-backed correctly
1:     public void testSetSchema() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("SET SCHEMA FOO");
1:         verifyCachedSchema(getConnection());
1:         s.execute("SET SCHEMA \"\u00bbMY\u20ac\u00ab\"");
1:         verifyCachedSchema(getConnection());
1:     }
1:     public void testPreparedSetSchema() throws SQLException {
1:         PreparedStatement ps = prepareStatement("SET SCHEMA ?");
1:         ps.setString(1, "FOO");
1:         ps.execute();
1:         verifyCachedSchema(getConnection());
1:         ps.setString(1, "\u00bbMY\u20ac\u00ab");
1:         ps.execute();
1:         verifyCachedSchema(getConnection());
1:     }
1:     public void testSetSchemaProcedure() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CALL APP.SET_SCHEMA('FOO')");
1:         verifyCachedSchema(getConnection());
1:         s.execute("CALL APP.SET_SCHEMA('\"\u00bbMY\u20ac\u00ab\"')");
1:         verifyCachedSchema(getConnection());
1:     }
1:     public void testPreparedSetSchemaProcedure() throws SQLException {
1:         CallableStatement cs = prepareCall("CALL APP.SET_SCHEMA(?)");
1:         cs.setString(1, "FOO");
1:         cs.execute();
1:         verifyCachedSchema(getConnection());
1:         cs.setString(1, "\"\u00bbMY\u20ac\u00ab\"");
1:         cs.execute();
1:         verifyCachedSchema(getConnection());
1:     }
1: 
1:     public void testSetSchemaFunction() throws SQLException {
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery("SELECT " +
1:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME) FROM SYS.SYSSCHEMAS");
1:         while (rs.next()) {
1:             assertTrue(rs.getString(1).length() > 2);
1:             verifyCachedSchema(getConnection());
1:         }
1:     }
1: 
1:     public void testPreparedSetSchemaFunction() throws SQLException {
1:         PreparedStatement ps = prepareStatement("SELECT " +
1:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME) FROM SYS.SYSSCHEMAS");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             assertTrue(rs.getString(1).length() > 2);
1:             verifyCachedSchema(getConnection());
1:         }
1:     }
1: 
1:     public void testSetSchemaFunctionLarge() throws SQLException {
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery("SELECT X, " +
1:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME), " +
1:                 "Y FROM APP.LARGE");
1:         while (rs.next()) {
1:             assertTrue(rs.getString(2).length() > 2);
1:             verifyCachedSchema(getConnection());
1:         }
1:     }
1: 
1:     public void testPreparedSetSchemaFunctionLarge() throws SQLException {
1:         PreparedStatement ps = prepareStatement("SELECT X, " +
1:                 "APP.GET_SCHEMA_TRANSITION(SCHEMANAME), " +
1:                 "Y FROM APP.LARGE");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             assertTrue(rs.getString(2).length() > 2);
1:             verifyCachedSchema(getConnection());
1:         }
1:     }
commit:d4a1ecd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:      * the Test. An empty TestSuite is returned unless we have JDBC3 support, because
0:      * all test cases call verifyCachedIsolation() which in turn 
0:      * makes use of getTransactionIsolationJDBC()
0:      * (GET_TRANSACTION_ISOLATION_JDBC) which uses DriverManager to access the 
0:      * default connection.
1:         if (JDBC.vmSupportsJDBC3()) {
1:             suite.addTest(baseSuite("CacheSessionDataTest:embedded"));
1:             suite.addTest(TestConfiguration.clientServerDecorator(
1:                     baseSuite("CacheSessionDataTest:client")));
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet x = s.executeQuery("SELECT COUNT(*) FROM BIG");
1:                 x.next();
1:                 println("BIG has "+x.getInt(1)+" rows");
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Connection.TRANSACTION_READ_COMMITTED, c.getTransactionIsolation());
1:             Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:                 println(isoLevels[i].toString()); 
/////////////////////////////////////////////////////////////////////////
1:         println("getCycleIsolationJDBC() -> "+c.getTransactionIsolation());
/////////////////////////////////////////////////////////////////////////
1:         println("getCycleIsolationSQL() -> "+sqlName);
/////////////////////////////////////////////////////////////////////////
1:     private void verifyCachedIsolation(Connection c) throws SQLException {
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(serverSql, client);
1:         assertEquals(serverJdbc, client);
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:             PreparedStatement ps = prepareStatement("SET ISOLATION " + 
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement("INSERT INTO T1 VALUES " +
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement("INSERT INTO T1 VALUES " +
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_JDBC(?)");
/////////////////////////////////////////////////////////////////////////
1:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_SQL(?)");
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(type, concur);
commit:659f564
/////////////////////////////////////////////////////////////////////////
1: 
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.CacheSessionDataTest
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1:   
1:      http://www.apache.org/licenses/LICENSE-2.0
1:   
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1:  */
1: 
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
0: import java.sql.ResultSet;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Utility class for representing isolation levels. Provides a convenient way 
1:  * to track the JDBC constant, the JDBC constant name and the SQL name of an
1:  * isolation level. By overriding equals and toString it becomes convenient to
1:  * use this class in JUnit's assertEquals methods. 
1:  */
1: final class IsoLevel {
1:     private final int isoLevel_;
1:     private final String jdbcName_;
1:     private final String sqlName_;
1:     
1:     /**
1:      * Constructs an IsoLevel object from a ResultSet. The ResultSet must be 
1:      * equivalent to 'SELECT * FROM ISOLATION_NAMES'. Calls next() on the 
1:      * ResultSet, so the caller must position the ResultSet on the row before
1:      * the row that is to be used to create the IsoLevel object.
1:      * @param rs ResultSet holding isolation level descriptions
1:      * @throws java.sql.SQLException
1:      */
1:     public IsoLevel(ResultSet rs) throws SQLException {
1:         rs.next();
1:         isoLevel_ = rs.getInt("ISOLEVEL");
1:         jdbcName_ = rs.getString("JDBCNAME");
1:         sqlName_ = rs.getString("SQLNAME");
1:     }
1: 
1:     public int getIsoLevel() { return isoLevel_; }
1:     public String getJdbcName() { return jdbcName_; }
1:     public String getSqlName() { return sqlName_; }
1:     public String toString() {
1:         return "(" + jdbcName_ + ", " + sqlName_ + ")";
1:     }
1:     public boolean equals(Object that) {
1:         if (this == that) {
1:             return true;
1:         }
1:         if (that instanceof IsoLevel) {
1:             return (isoLevel_ == ((IsoLevel) that).isoLevel_);
1:         }
1:         return false;
1:     }
1:     public int hashCode() { return isoLevel_; }
1: }
1: 
1: /**
1:  * This is a test for DERBY-3192 (https://issues.apache.org/jira/browse/DERBY-3192) 
1:  * which tries to avoid unecessary roundtrips by piggybacking session 
1:  * information on the messages going back to the client. The goal is that
1:  * whenever a user requests session information from the client driver, the 
1:  * correct information should already be available and no special roundtrip
1:  * be required. 
1:  * So far the test only checks caching of the isolation level, but other 
1:  * session attributes can be added later. The test attempts to "fool" 
1:  * the caching mechanism by
1:  * modifying the isolation level without going through the client's 
1:  * Connection.setTransactionIsolation method. 
1:  * The effect of modifying the isolation level in and 
1:  * out of XA transactions is covered by the XA tests and not tested here.
1:  */
1: public class CacheSessionDataTest extends BaseJDBCTestCase {
1:     
1:     public CacheSessionDataTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Adds both the embedded and client-server versions of the baseSuite to
0:      * the Test
1:      * @return the resulting Test object
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("CacheSessionDataTest");
0:         suite.addTest(baseSuite("CacheSessionDataTest:embedded"));
0:         suite.addTest(TestConfiguration.clientServerDecorator(
0:             baseSuite("CacheSessionDataTest:client")));
1:         return suite;
1:     }
1:     
1:     /**
0:      * Creates a new TestSuite with all the tests, and wraps it in a 
0:      * CleanDatabaseSetup with a custom decorator.
0:      * @param name TestSuite name
1:      * @return wrapped TestSuite
1:      */
1:     private static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(CacheSessionDataTest.class);
1:         
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:             * Creates the tables, stored procedures, and functions 
1:             * shared by all test cases.
1:             * @throws SQLException 
1:             */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 s.execute("CREATE TABLE ISOLATION_NAMES(ISOLEVEL INT, JDBCNAME " +
1:                         "VARCHAR(30), SQLNAME VARCHAR(2))");
1:                 PreparedStatement insert = s.getConnection().prepareStatement(
1:                         "INSERT INTO ISOLATION_NAMES VALUES (?, ?, ?)");
1:                 
1:                 insert.setInt(1, Connection.TRANSACTION_NONE);
1:                 insert.setString(2, "TRANSACTION_NONE"); 
1:                 insert.setNull(3, Types.VARCHAR);
1:                 insert.execute();
1:                 
1:                 insert.setInt(1, Connection.TRANSACTION_READ_UNCOMMITTED);
1:                 insert.setString(2, "TRANSACTION_READ_UNCOMMITTED");
1:                 insert.setString(3, "UR");
1:                 insert.execute();
1:                 
1:                 insert.setInt(1, Connection.TRANSACTION_READ_COMMITTED);
1:                 insert.setString(2, "TRANSACTION_READ_COMMITTED");
1:                 insert.setString(3, "CS");
1:                 insert.execute();
1:                 
1:                 insert.setInt(1, Connection.TRANSACTION_REPEATABLE_READ);
1:                 insert.setString(2, "TRANSACTION_REPEATABLE_READ");
1:                 insert.setString(3, "RS");
1:                 insert.execute();
1:                 
1:                 insert.setInt(1, Connection.TRANSACTION_SERIALIZABLE);
1:                 insert.setString(2, "TRANSACTION_SERIALIZABLE");
1:                 insert.setString(3, "RR");
1:                 insert.execute();
1:                 insert.close();
1:                 
1:                 s.execute("CREATE TABLE BIG(C1 VARCHAR(32672), " +
1:                         "C2 VARCHAR(32672), C3 VARCHAR(32672), C4 VARCHAR(32672))");                
1:                 s.execute("CREATE PROCEDURE INSERTDATA1(IN A INT) LANGUAGE JAVA " +
1:                         "PARAMETER STYLE JAVA EXTERNAL NAME " +
1:                         "'org.apache.derbyTesting.functionTests.util." +
1:                         "ProcedureTest.bigTestData'");
1:                 CallableStatement cs = s.getConnection().prepareCall("CALL INSERTDATA1(?)");
1:                 cs.setInt(1,9);
1:                 for (int i = 0; i < 10; ++i) {
1:                     cs.execute();
1:                 }
0: //                ResultSet x = s.executeQuery("SELECT COUNT(*) FROM BIG");
0: //                x.next();
0: //                System.out.println("BIG has "+x.getInt(1)+" rows");
1:                 
1:                 // Create procedures
1:                 s.execute("CREATE PROCEDURE SET_ISOLATION_JDBC" +
1:                         " (ISO INT) NO SQL LANGUAGE JAVA PARAMETER STYLE " +
1:                         "JAVA EXTERNAL NAME '" + 
1:                         CacheSessionDataTest.class.getName() + 
1:                         ".setIsolationJDBC'");
1:                 
1:                 s.execute("CREATE PROCEDURE SET_ISOLATION_SQL " +
1:                         "(SQLNAME VARCHAR(2)) MODIFIES SQL DATA LANGUAGE JAVA PARAMETER STYLE " +
1:                         "JAVA EXTERNAL NAME '" +
1:                         CacheSessionDataTest.class.getName() + 
1:                         ".setIsolationSQL'");
1:                 
1:                 // Create functions
1:                 s.execute("CREATE FUNCTION GET_TRANSACTION_ISOLATION_JDBC " +
1:                         "() RETURNS INT NO SQL LANGUAGE JAVA " +
1:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:                         CacheSessionDataTest.class.getName() + 
1:                         ".getTransactionIsolationJDBC'");        
1:                         
1:                 s.execute("CREATE FUNCTION GET_CYCLE_ISOLATION_JDBC " +
1:                         "() RETURNS INT NO SQL LANGUAGE JAVA " +
1:                         "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:                         CacheSessionDataTest.class.getName() + 
1:                         ".getCycleIsolationJDBC'");
1:  
1:                 s.execute("CREATE FUNCTION GET_CYCLE_ISOLATION_SQL " +
0:                         "() RETURNS VARCHAR(2) READS SQL DATA LANGUAGE JAVA PARAMETER " +
0:                         "STYLE JAVA EXTERNAL NAME '" +
1:                         CacheSessionDataTest.class.getName() + 
1:                         ".getCycleIsolationSQL'");
1:             }
1:         };
1:     } // End baseSuite
1:     
1:     /**
1:      * Turns off auto commit on the default connection and verifies that the 
1:      * isolation level is read committed. Initailizes the array 'isoLevels' 
1:      * with the 4 standard isolation levels if this has not already been done.
1:      * @throws java.sql.SQLException
1:      */
1:     public void setUp() throws SQLException {
1:         Connection c = getConnection();
1:         c.setAutoCommit(false);
0:         assertEquals(c.getTransactionIsolation(),
0:                 Connection.TRANSACTION_READ_COMMITTED);
1:         if (isoLevels == null) {
1:             Statement s = c.createStatement();
1:             ResultSet rs = s.executeQuery(
1:                     "SELECT * FROM ISOLATION_NAMES WHERE ISOLEVEL > 0 " +
1:                     "ORDER BY ISOLEVEL");
1:             isoLevels = new IsoLevel[4];
1:             
1:             for (int i = 0; i < 4; ++i) {
1:                 isoLevels[i] = new IsoLevel(rs);
0:                 System.out.println(isoLevels[i]); 
1:             }
1:             assertFalse(rs.next());
1:             rs.close();
1:             s.close();
1:         }
1:         assertNotNull(isoLevels[0]);
1:         assertNotNull(isoLevels[1]);
1:         assertNotNull(isoLevels[2]);
1:         assertNotNull(isoLevels[3]);
1:     }
1:     /**
1:      * Removes all tables in schema APP which has the prefix 'T', before calling
1:      * super.tearDown().
1:      * @throws java.lang.Exception
1:      */
1:     public void tearDown() throws Exception {
1:         DatabaseMetaData meta = getConnection().getMetaData();
1:         ResultSet tables = meta.getTables(null, "APP", "T%", null);
1:         Statement s = createStatement();
1:         while (tables.next()) {
1:             s.execute("DROP TABLE " + tables.getString("TABLE_NAME"));
1:         }
1:         tables.close();
1:         s.close();
1:         commit();
1:         super.tearDown();
1:     }
1:     
1:     /**
1:      * Implementation of the stored procedure SET_ISOLATION_JDBC.
1:      * Sets the the isolation level given as argument on the default connection
1:      * using Connection.setTransactionIasolation.
1:      * @param isolation JDBC isolation level constant representing the 
1:      * new isolation level
1:      * @throws java.sql.SQLException
1:      */
1:     public static void setIsolationJDBC(int isolation)
1:             throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         c.setTransactionIsolation(isolation);
1:     }
1:     /**
1:      * Implementation of the SQL function SET_ISOLATION_SQL.
1:      * Sets the the isolation level given as argument on the default connection
1:      * using SQL.
1:      * @param sqlName SQL string representing the new isolation level
1:      * @throws java.sql.SQLException
1:      */
1:     public static void setIsolationSQL(String sqlName)
1:             throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1:         s.execute("SET ISOLATION " + sqlName);
1:         s.close();
1:     }
1:     /**
1:      * Implementation of the SQL function GET_TRANSACTION_ISOLATION_JDBC.
1:      * Returns the isolation level reported by the default EmbedConnection 
1:      * on the server. Used to verify that the isolation level reported by 
1:      * the client is correct.
1:      * @return JDBC isolation level constant reported by the embedded driver
1:      * @throws java.sql.SQLException
1:      */
1:     public static int getTransactionIsolationJDBC()
1:             throws SQLException {
1:         return DriverManager.getConnection("jdbc:default:connection").
1:                 getTransactionIsolation();
1:     }
1:     /**
1:      * Implementation of the SQL function GET_CYCLE_ISOLATION_JDBC.
1:      * Cycles the isolation level on the default Connection.
1:      * @return the new JDBC isolation level constant
1:      * @throws java.sql.SQLException
1:      */
1:     public static int getCycleIsolationJDBC()
1:             throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         c.setTransactionIsolation(cycleIsolation().getIsoLevel());
0:         System.out.println("getCycleIsolationJDBC() -> "+c.getTransactionIsolation());
1:         return c.getTransactionIsolation();
1:     }
1:     /**
1:      * Implementation of the SQL function GET_CYCLE_ISOLATION_SQL.
1:      * Cycles the isolation level on the default Connection.
1:      * @return the SQL name of the new isolation level
1:      * @throws java.sql.SQLException
1:      */
1:     public static String getCycleIsolationSQL()
1:             throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1:         s.execute("SET ISOLATION "+cycleIsolation().getSqlName());
1:         ResultSet rs = s.executeQuery("VALUES CURRENT ISOLATION");
1:         rs.next();
1:         String sqlName = rs.getString(1);
1:         rs.close();
1:         s.close();
0:         System.out.println("getCycleIsolationSQL() -> "+sqlName);
1:         return sqlName;
1:     }
1: 
1:     // Utilities
1:     private static IsoLevel[] isoLevels;    
1:     private static int isolationIndex = -1;
1:     
1:     /**
1:      * Utility that cycles through the legal isolation levels in the following
0:      * order: read uncommitted -> read committed -> repeatable read -> 
0:      * serializable -> read uncommitted -> ...
1:      * @return IsoLevel object representing the isolation level.
1:      */
1:     private static IsoLevel cycleIsolation() {
1:         ++isolationIndex;
1:         isolationIndex %= 4;
1:         return isoLevels[isolationIndex];
1:     }
1: 
1:     /**
1:      * Utility that verifies that the isolation level reported by the client 
1:      * is the same as evaluating 'VALUES CURRENT ISOLATION' and getting the
1:      * isolation level from the EmbedConnection on the server.
1:      * @param c Connection to check
1:      * @throws java.sql.SQLException
1:      */
0:     private static void verifyCachedIsolation(Connection c) throws SQLException {
1:         final int clientInt = c.getTransactionIsolation();
1:         
1:         Statement s = c.createStatement();
1:         final IsoLevel serverSql = new IsoLevel(s.executeQuery(
1:                 "SELECT * FROM ISOLATION_NAMES " +
1:                 "WHERE SQLNAME = (VALUES CURRENT ISOLATION)"));
1:         
1:         final IsoLevel serverJdbc = new IsoLevel(s.executeQuery(
1:                 "SELECT * FROM ISOLATION_NAMES " +
1:                 "WHERE ISOLEVEL = GET_TRANSACTION_ISOLATION_JDBC()"));
1:         
1:         final IsoLevel client = new IsoLevel(s.executeQuery("SELECT * FROM " +
1:                 "ISOLATION_NAMES WHERE ISOLEVEL = "+clientInt));
1:         s.getResultSet().close();
1:         s.close();
0:         assertEquals(client, serverSql);
0:         assertEquals(client, serverJdbc);
1:     }
1:     
1:     // Test cases (fixtures) 
1:     // Change the isolation level using SQL
1:     public void testChangeIsoLevelStatementSQL() throws SQLException {
1:         Connection c = getConnection();
1:         Statement s = c.createStatement();
1:         for (int i = 0; i < 4; ++i) {
1:             s.execute("SET ISOLATION "+isoLevels[i].getSqlName());
1:             verifyCachedIsolation(c);
1:         }
1:         s.close();
1:     }
1:     public void testChangeIsoLevelPreparedStatementSQL() throws SQLException {
1:         Connection c = getConnection();
1:         for (int i = 0; i < 4; ++i) {
0:             PreparedStatement ps = c.prepareStatement("SET ISOLATION " + 
1:                     isoLevels[i].getSqlName());
1:             ps.execute();
1:             verifyCachedIsolation(c);
1:             ps.close();
1:         }
1:     }
1:     
1:     // Change the isolation level using a function
1:     public void testChangeIsoLevelFunctionJDBC() throws SQLException {
1:         Connection c = getConnection();
1:         c.setAutoCommit(true);
1:         Statement s = c.createStatement();
1:         s.execute("CREATE TABLE T1(ISOLEVEL INT)");
1:         for (int i = 0; i < 4; ++i) {
1:             s.execute("INSERT INTO T1 VALUES GET_CYCLE_ISOLATION_JDBC()");
1:             verifyCachedIsolation(c);
1:         }
1:         s.close();
1:     }
1:     public void testChangeIsoLevelFunctionSQL() throws SQLException {
1:         Connection c = getConnection();
1:         c.setAutoCommit(true);
1:         Statement s = c.createStatement();
1:         s.execute("CREATE TABLE T1(SQLNAME VARCHAR(2))");
1:         for (int i = 0; i < 4; ++i) {
1:             s.executeUpdate("INSERT INTO T1 VALUES GET_CYCLE_ISOLATION_SQL()");
1:             verifyCachedIsolation(c);
1:         }
1:         s.close();
1:     }
1:     public void testChangeIsoLevelPreparedFunctionJDBC() throws SQLException {
1:         Connection c = getConnection();
1:         c.setAutoCommit(true);
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE T1(ISOLEVEL INT)");
0:         PreparedStatement ps = c.prepareStatement("INSERT INTO T1 VALUES " +
1:                 "GET_CYCLE_ISOLATION_JDBC()");
1:         for (int i = 0; i < 4; ++i) {
1:             ps.executeUpdate();
1:             verifyCachedIsolation(c);
1:         }
1:         ps.close();
1:     }
1:     public void testChangeIsoLevelPreparedFunctionSQL() throws SQLException {
1:         Connection c = getConnection();
1:         c.setAutoCommit(true);
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE T1(SQLNAME VARCHAR(2))");
0:         PreparedStatement ps = c.prepareStatement("INSERT INTO T1 VALUES " +
1:                 "GET_CYCLE_ISOLATION_SQL()");
1:         for (int i = 0; i < 4; ++i) {
1:             ps.executeUpdate();
1:             verifyCachedIsolation(c);
1:         }
1:         ps.close();
1:     }
1:  
1:     // Change isolation level from a stored procedure
1:     public void testChangeIsoLevelProcedureJDBC() throws SQLException {
1:         Connection c = getConnection();
1:         Statement s = c.createStatement();
1:         for (int i = 0; i < 4; ++i) {
1:             s.execute("CALL SET_ISOLATION_JDBC(" + isoLevels[i].getIsoLevel() + ")");
1:             verifyCachedIsolation(c);
1:         }
1:         s.close();
1:     }
1:     public void testChangeIsoLevelProcedureSQL() throws SQLException {
1:         Connection c = getConnection();
1:         Statement s = c.createStatement();
1:         for (int i = 0; i < 4; ++i) {
1:             s.execute("CALL SET_ISOLATION_SQL('" + isoLevels[i].getSqlName() + "')");
1:             verifyCachedIsolation(c);
1:         }
1:         s.close();
1:     }
1: 
1:     // Changing isolation level from a stored procedure invoked from a 
1:     // callable statement
1:     public void testChangeIsoLevelCallableStatementJDBC() throws SQLException {
1:         Connection c = getConnection();
0:         CallableStatement cs = c.prepareCall("CALL SET_ISOLATION_JDBC(?)");
1:         for (int i = 0; i < 4; ++i) {
1:             cs.setInt(1, isoLevels[i].getIsoLevel());
1:             cs.execute();
1:             verifyCachedIsolation(c);
1:         }
1:         cs.close();
1:     }
1:     public void testChangeIsoLevelCallableStatementSQL() throws SQLException {
1:         Connection c = getConnection();
0:         CallableStatement cs = c.prepareCall("CALL SET_ISOLATION_SQL(?)");
1:         for (int i = 0; i < 4; ++i) {
1:             cs.setString(1, isoLevels[i].getSqlName());
1:             cs.execute();
1:             verifyCachedIsolation(c);
1:         }
1:         cs.close();
1:     }
1:     
1:     // Changing isolation level from executeBatch()
1:     public void testChangeIsoLevelSQLInBatch() throws SQLException {
1:         Statement s = createStatement();
1:         for (int i = 0; i < isoLevels.length; ++i) {
1:             s.addBatch("SET ISOLATION " + isoLevels[i].getSqlName());
1:         }
1: 
1:         try {
1:             s.executeBatch();
1:         } catch (SQLException e) {
1:             SQLException prev = e;
1:             while (e != null) {
1:                 prev = e;
1:                 e = e.getNextException();
1:             }
1:             throw prev;
1:         }
1:         verifyCachedIsolation(s.getConnection());
1:         s.close();
1:     }
1:     
1:     public void testChangeIsoLevelProcedureJdbcBatch() throws SQLException {
1:         Statement s = createStatement();
1:         for (int i = 0; i < isoLevels.length; ++i) {
1:             s.addBatch("CALL SET_ISOLATION_JDBC(" + isoLevels[i].getIsoLevel() + ")");
1:         }
1:         try {
1:             s.executeBatch();
1:         } catch (SQLException e) {
1:             SQLException prev = e;
1:             while (e != null) {
1:                 prev = e;
1:                 e = e.getNextException();
1:             }
1:             throw prev;
1:         }
1:         verifyCachedIsolation(s.getConnection());
1:         s.close();
1:     }
1:     public void testChangeIsoLevelProcedureSqlBatch() throws SQLException {
1:         Statement s = createStatement();
1:         for (int i = 0; i < isoLevels.length; ++i) {
1:             s.addBatch("CALL SET_ISOLATION_SQL('" + isoLevels[i].getSqlName() + "')");
1:         }
1:         
1:         try {
1:             s.executeBatch();
1:         } catch (SQLException e) {
1:             SQLException prev = e;
1:             while (e != null) {
1:                 prev = e;
1:                 e = e.getNextException();
1:             }
1:             throw prev;
1:         }
1:         verifyCachedIsolation(s.getConnection());
1:         s.close();
1:     }
1:     
1:     public void testChangeIsoLevelProcedureJdbcCallableBatch() throws SQLException {
1:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_JDBC(?)");
1:         for (int i = 0; i < isoLevels.length; ++i) {
1:             cs.setInt(1, isoLevels[i].getIsoLevel());
1:             cs.addBatch();
1:         }
1:         try {
1:             cs.executeBatch();
1:         } catch (SQLException e) {
1:             SQLException prev = e;
1:             while (e != null) {
1:                 prev = e;
1:                 e = e.getNextException();
1:             }
1:             throw prev;
1:         }
1:         verifyCachedIsolation(cs.getConnection());
1:         cs.close();
1:     }
1:     public void testChangeIsoLevelProcedureSqlCallableBatch() throws SQLException {
1:         CallableStatement cs = prepareCall("CALL SET_ISOLATION_SQL(?)");
1:         for (int i = 0; i < isoLevels.length; ++i) {
1:             cs.setString(1, isoLevels[i].getSqlName());
1:             cs.addBatch();
1:         }
1:         try {
1:             cs.executeBatch();
1:         } catch (SQLException e) {
1:             SQLException prev = e;
1:             while (e != null) {
1:                 prev = e;
1:                 e = e.getNextException();
1:             }
1:             throw prev;
1:         }
1:         verifyCachedIsolation(cs.getConnection());
1:         cs.close();
1:     }
1: 
1:     
1:     /**
1:      * Utility method for testing Statements that return different 
1:      * types of ResultSets to check that piggybacking doesn't cause problems.
1:      * @param table table to select from
1:      * @param type type of ResultSet
1:      * @param concur concurrency of ResultSet
1:      * @throws java.sql.SQLException
1:      */
1:     private void cursorTest(String table, int type, int concur) 
1:             throws SQLException {
1:         Connection c = getConnection();
0:         Statement s = c.createStatement(type, concur);
1:         ResultSet rs = s.executeQuery("SELECT * FROM "+table);
1:         verifyCachedIsolation(c);
1:         while (rs.next()) {
1:             verifyCachedIsolation(c);
1:         }
1:         rs.close();
1:         s.close();
1:     }
1:     
1:     /**
1:      * Utility method for testing PreparedStatements that return different 
1:      * types of ResultSets to check that piggybacking doesn't cause problems.
1:      * 
1:      * @param table table to select from
1:      * @param type type of ResultSet
1:      * @param concur concurrency of ResultSet
1:      * @throws java.sql.SQLException
1:      */
1:     private void preparedCursorTest(String table, int type, int concur)
1:             throws SQLException {
1:         Connection c = getConnection();
1:         PreparedStatement ps = c.prepareStatement("SELECT * FROM " + table, 
1:                 type, concur);
1:         ResultSet rs = ps.executeQuery();
1:         verifyCachedIsolation(c);
1:         while (rs.next()) {
1:             verifyCachedIsolation(c);
1:         }
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     public void testSmallForwardOnlyReadOnly() throws SQLException {
1:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
1:     public void testSmallScrollInsensitiveReadOnly() throws SQLException {
1:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_INSENSITIVE,                
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
1:     public void testSmallScrollSensitiveReadOnly() throws SQLException {
1:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
1:     public void testSmallForwardOnlyUpdatable() throws SQLException {
1:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     public void testSmallScrollInsensitiveUpdatable() throws SQLException {
1:         cursorTest("ISOLATION_NAMES",ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     public void testSmallScrollSensitiveUpdatable() throws SQLException {
1:         cursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:    
1: 
1:     public void testSmallPreparedForwardOnlyReadOnly() throws SQLException {
1:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }    
1:     public void testSmallPreparedScrollSensitiveReadOnly() throws SQLException {
1:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }     
1:     public void testSmallPreparedScrollInsensitiveReadOnly() throws SQLException {
1:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
1:     public void testSmallPreparedForwardOnlyUpdatable() throws SQLException {
1:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     public void testSmallPreparedScrollSensitiveUpdatable() throws SQLException {
1:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     public void testSmallPreparedScrollInsensitiveUpdatable() throws SQLException {
1:         preparedCursorTest("ISOLATION_NAMES", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     
1:     
1:     public void testLargeForwardOnlyReadOnly() throws SQLException {
1:         cursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }    
1:     public void testLargeScrollSensitiveReadOnly() throws SQLException {
1:         cursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE, 
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }    
1:     public void testLargeScrollInsensitiveReadOnly() throws SQLException {
1:         cursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
1:     public void testLargeForwardOnlyUpdatable() throws SQLException {
1:         cursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     public void testLargeScrollSensitiveUpdatable() throws SQLException {
1:         cursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1:     public void testLargeScrollInsensitiveUpdatable() throws SQLException {
1:         cursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1: 
1: 
1:     public void testLargePreparedForwardOnlyReadOnly() throws SQLException {
1:         preparedCursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }     
1:     public void testLargePreparedScrollSensitiveReadOnly() throws SQLException {
1:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
0:     public void testLargePreparedScrollInsensitiveReadOnly() throws SQLException {
1:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:     }
1:     public void testLargePreparedForwardOnlyUpdatable() throws SQLException {
1:         preparedCursorTest("BIG", ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
0:     public void testLargePreparedScrollSensitiveUpdatable() throws SQLException {
1:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
0:     public void testLargePreparedScrollInsensitiveUpdatable() throws SQLException {
1:         preparedCursorTest("BIG", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_UPDATABLE);
1:     }
1: }
============================================================================