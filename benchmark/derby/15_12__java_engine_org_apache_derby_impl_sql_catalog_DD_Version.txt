2:eac0369: /*
1:bb40bcb: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.catalog.DD_Version
1:ec2bfaf: 
1:f739ad1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f739ad1:    contributor license agreements.  See the NOTICE file distributed with
1:f739ad1:    this work for additional information regarding copyright ownership.
1:f739ad1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f739ad1:    (the "License"); you may not use this file except in compliance with
1:f739ad1:    the License.  You may obtain a copy of the License at
1:78c2db1: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
7:eac0369:  */
1:1cd97e8: 
1:eac0369: package org.apache.derby.impl.sql.catalog;
1:703bc91: 
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:345de35: 
1:eac0369: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1:50ba36b: import org.apache.derby.iapi.util.IdUtil;
1:345de35: 
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.ObjectOutput;
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:1cd97e8: import java.util.HashSet;
1:eac0369: import java.util.Properties;
15:eac0369: 
5:eac0369: /**
1:eac0369:  * Generic code for upgrading data dictionaries.
1:eac0369:  * Currently has all minor version upgrade logic.
1:eac0369:  * <p>
1:eac0369:  * A word about minor vs. major upgraded.  Minor
1:eac0369:  * upgrades must be backwards/forwards compatible.
1:eac0369:  * So they cannot version classes or introduce new
1:eac0369:  * classes.  Major releases are only backwards compatible;
1:eac0369:  * they will run against an old database, but not the
1:eac0369:  * other way around.  So they can introduce new classes,
1:eac0369:  * etc.
7:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public	class DD_Version implements	Formatable
4:eac0369: {
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	STATE
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	private		transient	DataDictionaryImpl	bootingDictionary;
1:eac0369: 
1:eac0369: 	int majorVersionNumber;
1:eac0369: 	private int minorVersionNumber;
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Public niladic constructor needed for Formatable interface.
1:eac0369: 	  */
1:eac0369: 	public	DD_Version() {}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Construct a Version for the currently booting data dictionary.
1:eac0369: 	 * The minor version is set by the subclass.
1:eac0369: 	 *
1:eac0369: 	 * @param	bootingDictionary	The booting dictionary that needs to be upgraded.
1:eac0369: 	 */
1:eac0369: 	DD_Version( DataDictionaryImpl bootingDictionary, int majorVersionNumber)
1:eac0369: 	{
1:eac0369: 		this.majorVersionNumber = majorVersionNumber;
1:eac0369: 		this.minorVersionNumber = getJBMSMinorVersionNumber();
1:eac0369: 		this.bootingDictionary = bootingDictionary;
4:eac0369: 	}
1:ec2bfaf: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	OVERRIDE OBJECT METHODS
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:ec2bfaf: 
1:eac0369: 	/**
1:eac0369: 	  *	Stringify this Version.
1:703bc91: 	  *
1:eac0369: 	  *	@return	String representation of this Version.
1:703bc91: 	  */
1:eac0369: 	public	String	toString()
1:aa609d5: 	{
1:eac0369: 		return DD_Version.majorToString(majorVersionNumber);
1:ec2bfaf: 	}
1:eac0369: 
1:eac0369: 	private static String majorToString(int majorVersionNumber) {
1:eac0369: 		switch (majorVersionNumber) {
1:eac0369: 		case DataDictionary.DD_VERSION_CS_5_0:
1:eac0369: 			return "5.0";
1:eac0369: 		case DataDictionary.DD_VERSION_CS_5_1:
1:eac0369: 			return "5.1";
1:eac0369: 		case DataDictionary.DD_VERSION_CS_5_2:
1:eac0369: 			return "5.2";
1:eac0369: 		case DataDictionary.DD_VERSION_CS_8_1:
1:eac0369: 			return "8.1";
1:eac0369: 		case DataDictionary.DD_VERSION_CS_10_0:
1:eac0369: 			return "10.0";
1:36d3bed: 		case DataDictionary.DD_VERSION_DERBY_10_1:
1:36d3bed: 			return "10.1";
1:2dc0b91: 		case DataDictionary.DD_VERSION_DERBY_10_2:
1:2dc0b91: 			return "10.2";
1:16c8b88: 		case DataDictionary.DD_VERSION_DERBY_10_3:
1:16c8b88: 			return "10.3";
1:10dc4fc: 		case DataDictionary.DD_VERSION_DERBY_10_4:
1:10dc4fc: 			return "10.4";
1:963d9f4: 		case DataDictionary.DD_VERSION_DERBY_10_5:
1:963d9f4: 			return "10.5";
1:48a9884: 		case DataDictionary.DD_VERSION_DERBY_10_6:
1:48a9884: 			return "10.6";
1:a584888: 		case DataDictionary.DD_VERSION_DERBY_10_7:
1:a584888: 			return "10.7";
1:1299897: 		case DataDictionary.DD_VERSION_DERBY_10_8:
1:1299897: 			return "10.8";
1:23f244c: 		case DataDictionary.DD_VERSION_DERBY_10_9:
1:23f244c: 			return "10.9";
1:45f5174: 		case DataDictionary.DD_VERSION_DERBY_10_10:
1:45f5174: 			return "10.10";
1:94b316d: 		case DataDictionary.DD_VERSION_DERBY_10_11:
1:94b316d: 			return "10.11";
1:aa841e7: 		case DataDictionary.DD_VERSION_DERBY_10_12:
1:aa841e7: 			return "10.12";
1:a93cd20: 		case DataDictionary.DD_VERSION_DERBY_10_13:
1:a93cd20: 			return "10.13";
1:b104719: 		case DataDictionary.DD_VERSION_DERBY_10_14:
1:b104719: 			return "10.14";
1:eac0369: 		default:
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	DataDictionary SPECIFIC
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Upgrade the data dictionary catalogs to the version represented by this
1:eac0369: 	 * DD_Version.
1:eac0369: 	 *
1:eac0369: 	 * @param dictionaryVersion the version of the data dictionary tables.
1:eac0369: 	 * @exception StandardException Ooops
1:eac0369: 	 */
1:eac0369: 	void upgradeIfNeeded(DD_Version dictionaryVersion,
1:eac0369: 								TransactionController tc, Properties startParams)
5:eac0369: 		 throws StandardException
1:963d9f4: 	{
1:eac0369: 		// database has been upgrade with a later engine version than this?
1:eac0369: 		if (dictionaryVersion.majorVersionNumber > majorVersionNumber) {
1:eac0369: 			throw StandardException.newException(SQLState.LANG_CANT_UPGRADE_CATALOGS,  
1:eac0369: 				dictionaryVersion, this);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		boolean minorOnly = false;
1:eac0369: 		boolean performMajorUpgrade = false;
1:eac0369: 		boolean softUpgradeRun = false;
1:1b29824: 		boolean isReadOnly = bootingDictionary.af.isReadOnly();	
1:eac0369: 
1:eac0369: 		if (dictionaryVersion.majorVersionNumber == majorVersionNumber) {
1:eac0369: 
1:eac0369: 			// exact match of engine to database, do nothing.
1:eac0369: 			if (dictionaryVersion.minorVersionNumber == minorVersionNumber)
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			// database and engine at same major level
1:eac0369: 			minorOnly = true;
1:eac0369: 
1:eac0369: 		} else {
1:eac0369:            
1:56c1dc2: 			if (isFullUpgrade(startParams, dictionaryVersion.toString())) {
1:eac0369: 				performMajorUpgrade = true;
1:eac0369: 			} else {
1:eac0369: 				softUpgradeRun = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// make sure we have a clean transaction for the upgrade
1:eac0369: 		tc.commit();
1:eac0369: 
1:eac0369: 		if (performMajorUpgrade) {
1:50ba36b: 			// real upgrade changes. Get user name of current user.
1:50ba36b: 			String userName = IdUtil.getUserNameFromURLProps(startParams);
1:50ba36b: 			doFullUpgrade(tc, dictionaryVersion.majorVersionNumber,IdUtil.getUserAuthorizationId(userName));
1:9496f49:             //DERBY-5996(Create readme files (cautioning users against 
1:9496f49:             // modifying database files) at database hard upgrade time)
1:9496f49:             //Following will create 3 readme files.
1:9496f49:             // one in database directory, one in "seg0" directory and one in 
1:9496f49:             // log directory. These readme files warn users against touching 
1:9496f49:             // any of files associated with derby database 
1:9496f49: 			bootingDictionary.af.createReadMeFiles();
1:eac0369: 		}
1:eac0369: 
1:1b29824: 		if (!minorOnly && !isReadOnly) {
1:eac0369: 			// apply changes that can be made and will continue to work
1:eac0369: 			// against previous version.
1:eac0369: 
1:eac0369: 			// See if we have already applied these changes.
1:eac0369: 			DD_Version softUpgradeVersion = (DD_Version) tc.getProperty(
1:eac0369: 											DataDictionary.SOFT_DATA_DICTIONARY_VERSION);
1:eac0369: 
1:eac0369: 			// need to apply them if we have never performed a soft upgrade
1:eac0369: 			// or only a soft upgrade using a previous version.
1:eac0369: 			int softUpgradeMajorVersion = 0;
1:eac0369: 			if (softUpgradeVersion != null)
1:eac0369: 				softUpgradeMajorVersion = softUpgradeVersion.majorVersionNumber;
1:eac0369: 
1:eac0369: 			if (softUpgradeMajorVersion < majorVersionNumber) {
1:eac0369: 				applySafeChanges( tc, dictionaryVersion.majorVersionNumber, softUpgradeMajorVersion);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// changes such as invalidating SPS so they will recompile against
1:eac0369: 		// the new internal classes.
1:eac0369: 		// this method also changes the on-disk format version on the disk and in-memory as well.
1:eac0369: 		handleMinorRevisionChange(tc, dictionaryVersion, softUpgradeRun);
1:eac0369: 
1:eac0369: 		// commit any upgrade
1:eac0369: 		tc.commit();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Apply changes that can safely be made in soft upgrade.
1:eac0369: 		Any changes must not prevent the database from being re-booted
1:703bc91: 		by the a Derby engine at the older version fromMajorVersionNumber.
1:703bc91: 		<BR>
1:703bc91: 		Examples are fixes to catalog meta data, e.g. fix nullability of
1:703bc91: 		a system column.
1:eac0369: 
1:703bc91: 		<BR>
1:703bc91: 		<B>Upgrade items for 10.1</B>
1:703bc91: 		<UL>
1:703bc91: 		<LI> None.
1:703bc91: 		</UL>
1:eac0369: 	  *
1:eac0369: 	  * @param	tc	transaction controller
1:eac0369: 	  * @param	fromMajorVersionNumber	version of the on-disk database
1:eac0369: 	    @param  lastSoftUpgradeVersion last engine to perform a soft upgrade that made changes.
1:eac0369: 	  *
1:94f158a: 	  *	@exception StandardException  Standard Derby error policy.
1:eac0369: 	  */
1:eac0369: 	private	void	applySafeChanges(TransactionController tc, int fromMajorVersionNumber, int lastSoftUpgradeVersion)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:16c8b88: 		/*
1:703bc91: 		 * OLD Cloudscape 5.1 upgrade code, Derby does not support
1:703bc91: 		 * upgrade from Cloudscape 5.x databases. If it ever is changed
1:703bc91: 		 * to do so, this code would be useful.
1:703bc91: 		 * 
1:703bc91: 		 * 
1:eac0369: 		if (lastSoftUpgradeVersion <= DataDictionary.DD_VERSION_CS_5_1)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			// All these soft upgrade actions are new in 5.2 (first ever soft upgrade)
1:eac0369: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_0)
1:eac0369: 				modifySysTableNullability(tc,
1:eac0369: 					DataDictionaryImpl.SYSALIASES_CATALOG_NUM);
1:eac0369: 
1:eac0369: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_1)
1:eac0369: 				modifySysTableNullability(tc,
1:eac0369: 					DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM);
1:eac0369: 
1:eac0369: 		}
1:703bc91: 		*/
1:eac0369: 
1:703bc91: 		/*
1:16c8b88: 		 * Derby soft upgrade code
1:16c8b88: 		 */
1:16c8b88: 		if (lastSoftUpgradeVersion <= DataDictionary.DD_VERSION_DERBY_10_2)
1:16c8b88: 		{
1:16c8b88: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_2)
1:16c8b88: 			{
1:16c8b88: 				modifySysTableNullability(tc,
1:16c8b88: 					DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM);
1:16c8b88: 			
1:16c8b88: 				modifySysTableNullability(tc,
1:16c8b88: 					DataDictionaryImpl.SYSVIEWS_CATALOG_NUM);
1:16c8b88: 			}
1:16c8b88: 		}
1:16c8b88: 		
1:eac0369: 		tc.setProperty(DataDictionary.SOFT_DATA_DICTIONARY_VERSION, this, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Do full upgrade.  Apply changes that can NOT be safely made in soft upgrade.
1:703bc91: 		
1:703bc91: 		<BR>
1:2dc0b91: 		<B>Upgrade items for every new release</B>
1:703bc91: 		<UL>
1:2dc0b91: 		<LI> Drop and recreate the stored versions of the JDBC database metadata queries
1:703bc91: 		</UL>
1:eac0369: 		
1:2dc0b91: 		<BR>
1:703bc91: 		<B>Upgrade items for 10.1</B>
1:2dc0b91: 		<UL>
1:703bc91: 		<LI> None.
1:2dc0b91: 		</UL>
1:eac0369: 		
1:eac0369: 	  *
1:eac0369: 	  * @param	tc	transaction controller
1:eac0369: 	  * @param	fromMajorVersionNumber	version of the on-disk database
1:439d1e8: 	  * @param	aid	 AuthorizationID of current user to be made Database Owner
1:eac0369: 	  *
1:94f158a: 	  *	@exception StandardException  Standard Derby error policy.
1:eac0369: 	  */
1:50ba36b: 	private	void	doFullUpgrade(TransactionController tc, int fromMajorVersionNumber, String aid)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:703bc91: 		// Only supports upgrade from Derby 10.0 releases onwards
1:703bc91: 		if (fromMajorVersionNumber < DataDictionary.DD_VERSION_CS_10_0)
1:703bc91: 		{
1:703bc91: 			throw StandardException.newException(SQLState.UPGRADE_UNSUPPORTED,
1:703bc91: 					DD_Version.majorToString(fromMajorVersionNumber), this);			
1:703bc91: 		}
1:703bc91: 
1:2dc0b91: 		//Drop and recreate the stored versions of the JDBC database metadata queries
1:2dc0b91: 		//This is to make sure that we have the stored versions of JDBC database
1:2dc0b91: 		//metadata queries matching with this release of the engine.
1:3f523e6: 		bootingDictionary.updateMetadataSPSes(tc);
1:703bc91: 
1:703bc91: 		/*
1:703bc91: 		 * OLD Cloudscape 5.1 upgrade code, Derby does not support
1:703bc91: 		 * upgrade from Cloudscape 5.x databases. If it ever is changed
1:703bc91: 		 * to do so, this code would be useful.
1:eac0369: 	
1:eac0369: 		if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_1)
1:eac0369: 		{
1:eac0369: 			// drop sps in SYSIBM, SYSIBM, recreate SYSIBM, SYSDUMMY1, populate SYSDUMMY1, create procs
1:eac0369: 			dropJDBCMetadataSPSes(tc, true);
1:eac0369: 			SchemaDescriptor sd = bootingDictionary.getSchemaDescriptor("SYSIBM", null, false);
1:eac0369: 			if (sd != null)
1:eac0369: 				bootingDictionary.dropSchemaDescriptor("SYSIBM", tc);
1:eac0369: 			sd = bootingDictionary.getSysIBMSchemaDescriptor();
1:eac0369: 			bootingDictionary.addDescriptor(sd, null, DataDictionary.SYSSCHEMAS_CATALOG_NUM, false, tc);
1:eac0369: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSDUMMY1_CATALOG_NUM);
1:eac0369: 			bootingDictionary.populateSYSDUMMY1(tc);
1:eac0369: 			bootingDictionary.create_SYSIBM_procedures(tc);
1:ec2bfaf: 			bootingDictionary.createSystemSps(tc);
1:eac0369: 		}
1:703bc91: 		
1:703bc91: 		*/
1:eac0369: 
1:f2fad75:         HashSet<String>  newlyCreatedRoutines = new HashSet<String>();
1:eac0369:         
1:aaa1403: 		if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_3)
1:aaa1403: 		{
1:aaa1403: 			// Add new system catalogs created for roles
1:aa609d5: 			bootingDictionary.upgradeMakeCatalog(
1:aaa1403: 				tc, DataDictionary.SYSROLES_CATALOG_NUM);
1:aaa1403: 		}
1:aaa1403: 
1:c243be1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_1)
1:eac0369:         {
1:c243be1:             // add catalogs 1st, subsequent procedure adding may depend on
1:c243be1:             // catalogs.
1:eac0369: 
1:c243be1: 			// Add new system catalogs created for grant and revoke
1:aaa1403: 			bootingDictionary.upgradeMakeCatalog(
1:c243be1:                 tc, DataDictionary.SYSTABLEPERMS_CATALOG_NUM);
2:c243be1: 			bootingDictionary.upgradeMakeCatalog(
1:c243be1:                 tc, DataDictionary.SYSCOLPERMS_CATALOG_NUM);
1:c243be1: 			bootingDictionary.upgradeMakeCatalog(
1:c243be1:                 tc, DataDictionary.SYSROUTINEPERMS_CATALOG_NUM);
1:eac0369:         }
1:eac0369: 
1:522127b:         if (fromMajorVersionNumber == DataDictionary.DD_VERSION_CS_10_0)
1:eac0369:         {
1:522127b:             // This upgrade depends on the SYSUTIL schema, which only exists
1:522127b:             // since 10.0.  Will not work to upgrade any db previous to 10.0,
1:522127b:             // thus only checks for 10.0 rather than <= 10.0.
1:522127b:             bootingDictionary.create_10_1_system_procedures(
1:1cd97e8:                 tc,
1:1cd97e8:                 newlyCreatedRoutines,
1:522127b:                 bootingDictionary.getSystemUtilSchemaDescriptor().getUUID());
1:eac0369:         }
1:eac0369: 
1:48a9884:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_5)
1:48a9884:         {
1:314a19a:             // On upgrade from versions before 10.6, create system procedures
1:48a9884:             // added in 10.6.
1:48a9884:             bootingDictionary.create_10_6_system_procedures(tc,
1:48a9884:                     newlyCreatedRoutines);
1:48a9884:             
1:bb40bcb:             // On upgrade from versions before 10.6, create system catalogs
1:bb40bcb:             // added in 10.6
1:bb40bcb:             bootingDictionary.upgradeMakeCatalog(
1:bb40bcb:                     tc, DataDictionary.SYSSEQUENCES_CATALOG_NUM);
1:bb40bcb:             bootingDictionary.upgradeMakeCatalog(
1:bb40bcb:                     tc, DataDictionary.SYSPERMS_CATALOG_NUM);
1:48a9884:         }
1:eac0369: 
1:fbb8866:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_1)
1:eac0369:         {
1:314a19a:             // On upgrade from versions before 10.2, create system procedures
1:fbb8866:             // added in 10.2.
1:fbb8866:             bootingDictionary.create_10_2_system_procedures(
1:1cd97e8:                 tc,
1:1cd97e8:                 newlyCreatedRoutines,
1:fbb8866:                 bootingDictionary.getSystemUtilSchemaDescriptor().getUUID());
1:eac0369: 
1:50ba36b: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:c243be1: 				SanityManager.ASSERT((aid != null), 
1:c243be1:                     "Failed to get new Database Owner authorization");
1:eac0369:             }
1:eac0369: 
1:50ba36b: 			// Change system schemas to be owned by aid
1:50ba36b: 			bootingDictionary.updateSystemSchemaAuthorization(aid, tc);
1:1cd97e8: 
1:1cd97e8:             // make sure we flag that we need to add permissions to the
1:1cd97e8:             // following pre-existing routines:
1:1cd97e8:             newlyCreatedRoutines.add( "SYSCS_INPLACE_COMPRESS_TABLE" );
1:1cd97e8:             newlyCreatedRoutines.add( "SYSCS_GET_RUNTIMESTATISTICS" );
1:1cd97e8:             newlyCreatedRoutines.add( "SYSCS_SET_RUNTIMESTATISTICS" );
1:1cd97e8:             newlyCreatedRoutines.add( "SYSCS_COMPRESS_TABLE" );
1:1cd97e8:             newlyCreatedRoutines.add( "SYSCS_SET_STATISTICS_TIMING" );
1:276925a: 			
1:eac0369:         }
1:eac0369: 
1:fef20ca:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_2)
1:eac0369:         {
1:314a19a:             // On upgrade from versions before 10.3, create system procedures
1:fef20ca:             // added in 10.3.
1:1cd97e8:             bootingDictionary.create_10_3_system_procedures(tc, newlyCreatedRoutines );
1:eac0369:         }
1:1cd97e8: 
1:1cd97e8:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_4)
1:1cd97e8:         {
1:1cd97e8:             // On upgrade from versions before 10.5, create system procedures
1:1cd97e8:             // added in 10.5.
1:1cd97e8:             bootingDictionary.create_10_5_system_procedures(tc, newlyCreatedRoutines);
1:1cd97e8:         }
1:1cd97e8: 
1:b05fa6e:         //
1:b05fa6e:         // Change the return type of SYSIBM.CLOBGETSUBSTRING if necessary. See
1:a61fd53:         // DERBY-4214. That function was added in 10.3 and the return type was
1:a61fd53:         // changed (but not upgraded) in 10.5. We can't distinguish
1:a61fd53:         // between databases which were originally created by 10.5 and databases
1:a61fd53:         // which were upgraded to 10.5.
1:b05fa6e:         //
1:a61fd53:         if (
1:a61fd53:             ( fromMajorVersionNumber > DataDictionary.DD_VERSION_DERBY_10_2) &&
1:a61fd53:             ( fromMajorVersionNumber < DataDictionary.DD_VERSION_DERBY_10_6)
1:a61fd53:             )
1:a61fd53:         {
1:a61fd53:             bootingDictionary.upgradeCLOBGETSUBSTRING_10_6( tc );
1:a61fd53:         }
1:b05fa6e: 
1:b05fa6e:         //
1:b05fa6e:         // Remove the bad permissions tuple for SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE if necessary.
1:b05fa6e:         // See DERBY-4215. That procedure will have an extra permissions tuple
1:b05fa6e:         // with a null GRANTOR field if the database was created by 10.0 and then
1:b05fa6e:         // hard-upgraded to 10.2 or higher without an intermediate upgrade to 10.1.
1:b05fa6e:         //
1:b05fa6e:         if (
1:b05fa6e:             ( fromMajorVersionNumber > DataDictionary.DD_VERSION_DERBY_10_1) &&
1:b05fa6e:             ( fromMajorVersionNumber < DataDictionary.DD_VERSION_DERBY_10_6)
1:b05fa6e:             )
1:b05fa6e:         {
1:b05fa6e:             bootingDictionary.upgradeSYSROUTINEPERMS_10_6( tc );
1:b05fa6e:         }
1:a61fd53:         
1:3dbd09b:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_8)
1:eac0369:         {
1:314a19a:             // On upgrade from versions before 10.9, create system procedures
1:aa609d5:             // added in 10.9.
1:92268ac:             bootingDictionary.create_10_9_system_procedures( tc, newlyCreatedRoutines );
1:aa609d5:             
1:aa609d5:             // On upgrade from versions before 10.9, create system catalogs
1:aa609d5:             // added in 10.9
1:92268ac:             bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSUSERS_CATALOG_NUM );
1:963d9f4: 
1:78c2db1:             // On upgrade from versions before 10.9, upgrade the way we store
1:78c2db1:             // jars: we now use UUID as part of the file name and sanitize the
1:78c2db1:             // sql (schema, schema object) parts of the file name to remove
1:78c2db1:             // path delimiters. ALso, we now use no schema subdirectories since
1:78c2db1:             // there is no chance of name collision with the UUID.
1:78c2db1:             bootingDictionary.upgradeJarStorage(tc);
1:963d9f4:         }
1:eac0369: 
1:3dbd09b:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_9)
1:3dbd09b:         {
1:314a19a:             // On upgrade from versions before 10.10, create system procedures
1:3dbd09b:             // added in 10.10.
1:3dbd09b:             bootingDictionary.create_10_10_system_procedures( tc, newlyCreatedRoutines );
1:3dbd09b:         }
1:3dbd09b: 
1:d9878ca:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_10)
1:d9878ca:         {
1:d9878ca:             // On upgrade from versions before 10.11, add a column to the
1:d9878ca:             // SYSTRIGGERS table in order to support the WHEN clause.
1:d9878ca:             bootingDictionary.upgrade_addColumns(
1:d9878ca:               bootingDictionary.getNonCoreTIByNumber(
1:d9878ca:                 DataDictionary.SYSTRIGGERS_CATALOG_NUM).getCatalogRowFactory(),
1:d9878ca:                 new int[] { 18 }, tc);
1:7fd0c6e:             
1:314a19a:             // On upgrade from versions before 10.11, create system procedures
1:7fd0c6e:             // added in 10.11.
1:7fd0c6e:             bootingDictionary.create_10_11_system_procedures( tc, newlyCreatedRoutines );
1:7fd0c6e: 
1:7fd0c6e:             // Add a sequence generator for every identity column
1:7fd0c6e:             bootingDictionary.createIdentitySequences( tc );
1:aa609d5:         }
1:aa609d5: 
1:314a19a:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_11)
1:314a19a:         {
1:314a19a:             // On upgrade from versions before 10.12, create system procedures
1:314a19a:             // added in 10.12.
1:314a19a:             bootingDictionary.create_10_12_system_procedures( tc, newlyCreatedRoutines );
1:314a19a:         }
1:314a19a: 
1:ea2e939: 	if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_12)
1:ea2e939:         {
1:ea2e939:             // On upgrade from versions before 10.13, create system procedures
1:ea2e939:             // added in 10.13.
1:ea2e939: 	    bootingDictionary.create_10_13_system_procedures( tc, newlyCreatedRoutines );
1:ea2e939:         }
1:ea2e939: 
1:1cd97e8:         // Grant PUBLIC access to some system routines
1:1cd97e8:         bootingDictionary.grantPublicAccessToSystemRoutines(newlyCreatedRoutines, tc, aid);
1:d9878ca: 	}
1:d9878ca: 
1:eac0369: 	/**
1:eac0369: 	 * Do any work needed for a minor revision change.
1:eac0369: 	 * For the data dictionary this is always invalidating
1:eac0369: 	 * stored prepared statements.  When we are done 
1:eac0369: 	 * with the upgrade, we always recompile all SPSes
1:eac0369: 	 * so the customer doesn't have to (and isn't going
1:eac0369: 	 * to get deadlocks because of the recomp).
1:eac0369: 	 *
2:eac0369: 	 * @param tc the xact
1:eac0369: 	 *
1:94f158a: 	 * @exception StandardException  Standard Derby error policy.
1:eac0369: 	 */
1:eac0369: 	private void handleMinorRevisionChange(TransactionController tc, DD_Version fromVersion, boolean softUpgradeRun) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isReadOnly = bootingDictionary.af.isReadOnly();
1:eac0369: 
1:eac0369: 		if (!isReadOnly) {
1:e6ea644:             // Make sure all stored plans are cleared, both for triggers and
1:e6ea644:             // for metadata queries. The plans will be recompiled automatically
1:e6ea644:             // on the first execution after upgrade. We clear the plans because
1:e6ea644:             // the stored format may have changed between the versions, so it
1:e6ea644:             // might not be possible to read or execute them in this version.
1:598c595:             bootingDictionary.clearSPSPlans();
1:e6ea644: 
1:3f523e6: 			// Once a database is version 10.5 we will start updating metadata SPSes
1:3f523e6: 			// on any version change,up or down.  This will ensure that metadata queries 
1:3f523e6: 			// match the version we are using.  We don't want to do this for lower 
1:3f523e6: 			// database versions because on reverting to the previous version the 
1:3f523e6: 			// SPSes won't be restored.
1:3f523e6: 			if (fromVersion.majorVersionNumber >= DataDictionary.DD_VERSION_DERBY_10_5)
1:3f523e6: 				bootingDictionary.updateMetadataSPSes(tc);
1:eac0369: 
1:eac0369: 			DD_Version lastRun;
1:eac0369: 			
1:eac0369: 			if (softUpgradeRun)
1:eac0369: 			{
1:eac0369: 				// log a version that will cause a minor revision change
1:eac0369: 				// for any subsequent re-boot, including an old Cloudscape version
1:eac0369: 				fromVersion.minorVersionNumber = 1; // see getJBMSMinorVersionNumber
1:eac0369: 				lastRun = fromVersion;
1:eac0369: 			}
1:3f523e6: 			else
1:eac0369: 			{
1:eac0369: 				// log the new version
1:eac0369: 				lastRun = this;
1:eac0369: 			
1:eac0369: 				// and change the in-memory version.
1:eac0369: 				fromVersion.majorVersionNumber = majorVersionNumber;
1:eac0369: 				fromVersion.minorVersionNumber = minorVersionNumber;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			tc.setProperty(DataDictionary.CORE_DATA_DICTIONARY_VERSION, fromVersion, true);
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// For a readonly database where we need some kind of upgrade
1:eac0369: 			// (either minor release or soft upgrade) then since we cannot
1:eac0369: 			// invalidate all the procedures we need to indicate that
1:eac0369: 			// any procedure we read off disk is automatically invalid,
1:eac0369: 			// so we do not try to load the generated class.
1:1ea68f8: 			bootingDictionary.setReadOnlyUpgrade();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		bootingDictionary.clearCaches();
1:eac0369: 	}
1:3f523e6: 
1:eac0369: 	/**
1:eac0369: 	  Remove the description of a System table from the data dictionary.
1:eac0369: 	  This does not delete the conglomerates that hold the catalog or
1:eac0369: 	  its indexes.
1:eac0369: 	  @param	tc TransactionController
1:eac0369: 	  @param    td Table descriptor for the catalog to drop. 
1:94f158a: 	  @exception StandardException  Standard Derby error policy.
1:eac0369: 	  */
1:eac0369: 	protected void
1:eac0369: 	dropSystemCatalogDescription(TransactionController tc, TableDescriptor td)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Drop the columns */
1:eac0369: 		bootingDictionary.dropAllColumnDescriptors(td.getUUID(), tc);
1:eac0369: 
1:eac0369: 		/* Drop the conglomerate descriptors */
1:eac0369: 		bootingDictionary.dropAllConglomerateDescriptors(td, tc);
1:eac0369: 
1:eac0369: 		/* Drop table descriptor */
1:eac0369: 		bootingDictionary.dropTableDescriptor( td, td.getSchemaDescriptor(), tc );
1:eac0369: 		bootingDictionary.clearCaches();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:  	 * Drop a System catalog.
2:eac0369: 	 *	@param	tc	TransactionController
2:eac0369: 	 *  @param  crf CatalogRowFactory for the catalog to drop.
1:94f158a: 	 *	@exception StandardException  Standard Derby error policy.
1:eac0369: 	 */
1:eac0369: 	protected void dropSystemCatalog(TransactionController tc,
1:eac0369: 							 CatalogRowFactory crf)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		SchemaDescriptor		sd = bootingDictionary.getSystemSchemaDescriptor();
1:eac0369: 		TableDescriptor			td = bootingDictionary.getTableDescriptor(
1:eac0369: 											crf.getCatalogName(),
1:0978789: 											sd, tc);
1:eac0369: 		ConglomerateDescriptor[]	cds = td.getConglomerateDescriptors();
1:eac0369: 		for (int index = 0; index < cds.length; index++)
1:eac0369: 		{
1:eac0369: 			tc.dropConglomerate(cds[index].getConglomerateNumber());
1:eac0369: 		}
1:eac0369: 		dropSystemCatalogDescription(tc,td);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	FORMATABLE INTERFACE
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	   Map to the 5.0 version identifier so that 5.0 will understand
1:eac0369: 	   this object when we write it out in soft upgrade mode.
1:eac0369: 	   CS 5.0 will de-serialize it correctly.
1:eac0369: 	   When we are writing out a 5.1 version number we write out
1:eac0369: 	   the 5.1 version just to ensure no problems.
1:eac0369: 	   
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:eac0369: 	 */
1:eac0369: 	public	int	getTypeFormatId()	{
1:eac0369: 		return majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?
1:eac0369: 			StoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects. Set
1:eac0369: 	 * the minor version.  Ignore the major version.  
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException on error
1:eac0369: 	 */
1:eac0369: 	public final void readExternal( ObjectInput in ) throws IOException
1:eac0369: 	{
1:eac0369: 		majorVersionNumber = in.readInt();
1:eac0369: 		minorVersionNumber = in.readInt();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects. Write
1:eac0369: 	 * out the minor version which is bumped across minor release.
1:eac0369: 	 * Just to be safe, write out the major version too.  This
1:eac0369: 	 * will allow us to do versioning of a specific Version impl
1:eac0369: 	 * in the future.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException on error
1:eac0369: 	 */
1:eac0369: 	public final void writeExternal( ObjectOutput out ) throws IOException
1:eac0369: 	{ 
1:eac0369: 		out.writeInt(majorVersionNumber);
1:eac0369: 		out.writeInt(minorVersionNumber);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Get the minor version from the JBMS product minor version/maint version.
1:eac0369: 	 * Bumps it up by 1 if production, or 0 if beta to ensure
1:eac0369: 	 * minor upgrade across beta.  Starts at 2 because of an
1:eac0369: 	 * old convention. We use this starting at 2 to allow soft upgrade to
1:eac0369: 	 * write a version of 1 with the old major number to ensure a minor upgrade
1:eac0369: 	   when reverting to an old version afer a soft upgrade. E.g run with 5.0.2,
1:eac0369: 	   then 5.2.1.1, then 5.0.2. Want to ensure 5.0.2 does the minor upgrade.
1:eac0369: 	 *
1:eac0369: 	 * @return the minor version
1:eac0369: 
1:eac0369: 		For 5.0 and 5.1 the minor number was calculated as
1:eac0369: 
1:eac0369: 		jbmsVersion.getMinorVersion()*100 +jbmsVersion.getMaintVersion() + (jbmsVersion.isBeta() ? 0 : 1) + 2
1:eac0369: 
1:dbed020: 		5.0.22 =&gt; (0*100) + 22 + 2 =  24 - (5.0 has a unique major number)
1:dbed020: 		5.1.2  =&gt; (1*100) + 2 + 2  = 104 - (5.1 has a unique major number) 
1:eac0369: 
1:eac0369: 
1:eac0369: 		With the switch to the four part scheme in 5.2, the maint number now is in increments of one million,
1:eac0369: 		thus the above scheme could lead to duplicate numbers. Note that the major number may not change
1:eac0369: 		when the minor external release changes, e.g. 5.2 and 5.3 could share a DD_Version major number.
1:eac0369: 
1:dbed020: 		5.2.1.100 =&gt; (2*100) + 1000100 + 2 = 1000302
1:dbed020: 		5.3.1.0   =&gt; (3*100) + 1000000 + 2 = 1000302
1:eac0369: 
1:eac0369: 		
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	private int getJBMSMinorVersionNumber() 
1:eac0369: 	{
1:56c1dc2: 		ProductVersionHolder jbmsVersion = DataDictionaryImpl.getMonitor().getEngineVersion();
1:eac0369: 
1:eac0369: 		return jbmsVersion.getMinorVersion()*100 +jbmsVersion.getMaintVersion() + (jbmsVersion.isBeta() ? 0 : 1) + 2;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * 
1:eac0369: 	 * Modifies the nullability of the system table corresponding
1:eac0369: 	 * to the received catalog number.
1:16c8b88: 	 * 
1:eac0369: 	 * @param tc			TransactionController.
1:eac0369: 	 * @param catalogNum	The catalog number corresponding
1:eac0369: 	 *  to the table for which we will modify the nullability.
1:16c8b88: 	 *  
1:16c8b88: 	 *  OLD Cloudscape 5.1 upgrade code
1:eac0369: 	 *  If this corresponds to SYSALIASES, then the nullability of
1:eac0369: 	 *  the SYSALIASES.ALIASINFO column will be changed to true
1:eac0369: 	 *  (Beetle 4430).  If this corresponds to SYSSTATEMENTS,
1:eac0369: 	 *  the nullability of the SYSSTATEMENTS.LASTCOMPILED
1:eac0369: 	 *  column will be changed to true.
1:eac0369: 	 *
1:16c8b88: 	 *  Derby upgrade code
1:16c8b88: 	 *  If this corresponds to SYSSTATEMENTS, then the nullability of
1:16c8b88: 	 *  the SYSSTATEMENTS.COMPILATION_SCHEMAID column will 
1:16c8b88: 	 *  be changed to true.  If this corresponds to SYSVIEWS, the nullability
1:16c8b88: 	 *  of the SYSVIEWS.COMPILATION_SCHEMAID column will be changed to true.
1:16c8b88: 	 *  
1:16c8b88: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	private void modifySysTableNullability(TransactionController tc, int catalogNum)
1:16c8b88: 		throws StandardException
1:16c8b88: 	{		
1:16c8b88: 		TabInfoImpl ti = bootingDictionary.getNonCoreTIByNumber(catalogNum);
1:eac0369: 		CatalogRowFactory rowFactory = ti.getCatalogRowFactory();
1:16c8b88: 		
1:16c8b88: 		if (catalogNum == DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM)
1:16c8b88: 		{
1:16c8b88: 			// SYSSTATEMENTS table ==> SYSSTATEMENTS_COMPILATION_SCHEMAID needs 
1:16c8b88: 			// to be modified.
1:d1e9d3c: 			bootingDictionary.upgradeFixSystemColumnDefinition(rowFactory,
1:16c8b88: 				SYSSTATEMENTSRowFactory.SYSSTATEMENTS_COMPILATION_SCHEMAID, 
1:ec2bfaf: 				tc);
1:16c8b88: 		}
1:16c8b88: 		else if (catalogNum == DataDictionaryImpl.SYSVIEWS_CATALOG_NUM)
1:16c8b88: 		{
1:16c8b88: 			// SYSVIEWS table ==> SYSVIEWS_COMPILATION_SCHEMAID needs 
1:16c8b88: 			// to be modified.
1:d1e9d3c: 			bootingDictionary.upgradeFixSystemColumnDefinition(rowFactory,
1:16c8b88: 				SYSVIEWSRowFactory.SYSVIEWS_COMPILATION_SCHEMAID, 
2:d1e9d3c: 				tc);
1:16c8b88: 		}
1:16c8b88: 		
1:16c8b88: 		/* OLD Cloudscape 5.1 upgrade code. See applySafeChanges(). 
1:eac0369: 		if (catalogNum == DataDictionaryImpl.SYSALIASES_CATALOG_NUM) {
1:eac0369: 		// SYSALIASES table ==> ALIASINFO needs to be modified.
1:16c8b88: 			bootingDictionary.upgrade_setNullability(rowFactory,
1:eac0369: 				SYSALIASESRowFactory.SYSALIASES_ALIASINFO, true, tc);
1:eac0369: 		}
1:eac0369: 		else if (catalogNum == DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM) {
1:eac0369: 		// SYSSTATEMENTS table ==> LASTCOMPILED needs to be modified.
1:16c8b88: 			bootingDictionary.upgrade_setNullability(rowFactory,
1:eac0369: 				SYSSTATEMENTSRowFactory.SYSSTATEMENTS_LASTCOMPILED, true, tc);
1:eac0369: 		}
1:16c8b88: 		*/		
1:16c8b88: 		
1:eac0369: 	}
1:16c8b88: 
1:eac0369: 	/**
1:eac0369: 		Check to see if a database has been upgraded to the required
1:eac0369: 		level in order to use a language feature.
1:eac0369: 
1:6b50965: 		@param requiredMajorVersion Data Dictionary major version
1:eac0369: 		@param feature Non-null to throw an error, null to return the state of the version match.
1:eac0369: 
1:eac0369: 		@return True if the database has been upgraded to the required level, false otherwise.
1:eac0369: 	*/
1:eac0369: 	boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {
1:eac0369: 
1:eac0369: 		if (majorVersionNumber < requiredMajorVersion) {
1:eac0369: 
1:eac0369: 			if (feature != null)
1:eac0369: 				throw StandardException.newException(SQLState.LANG_STATEMENT_UPGRADE_REQUIRED, feature,
1:eac0369: 					DD_Version.majorToString(majorVersionNumber),
1:eac0369: 					DD_Version.majorToString(requiredMajorVersion));
1:eac0369: 
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  boolean isFullUpgrade( final Properties startParams, final String oldVersionInfo )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Boolean>()
1:56c1dc2:                  {
1:56c1dc2:                      public Boolean run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.isFullUpgrade( startParams, oldVersionInfo );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  ).booleanValue();
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b104719
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_14:
1: 			return "10.14";
commit:ea2e939
/////////////////////////////////////////////////////////////////////////
1: 	if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_12)
1:         {
1:             // On upgrade from versions before 10.13, create system procedures
1:             // added in 10.13.
1: 	    bootingDictionary.create_10_13_system_procedures( tc, newlyCreatedRoutines );
1:         }
1: 
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_6:
1: 			return "10.6";
/////////////////////////////////////////////////////////////////////////
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_5)
1:         {
0:             // On ugrade from versions before 10.6, create system procedures
1:             // added in 10.6.
1:             bootingDictionary.create_10_6_system_procedures(tc,
1:                     newlyCreatedRoutines);
1:         }
1: 
commit:16c8b88
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_3:
1: 			return "10.3";
/////////////////////////////////////////////////////////////////////////
1: 		/*
1: 		 * Derby soft upgrade code
1: 		 */
1: 		if (lastSoftUpgradeVersion <= DataDictionary.DD_VERSION_DERBY_10_2)
1: 		{
1: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_2)
1: 			{
1: 				modifySysTableNullability(tc,
1: 					DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM);
1: 			
1: 				modifySysTableNullability(tc,
1: 					DataDictionaryImpl.SYSVIEWS_CATALOG_NUM);
1: 			}
1: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 *  
1: 	 *  OLD Cloudscape 5.1 upgrade code
1: 	 *  Derby upgrade code
1: 	 *  If this corresponds to SYSSTATEMENTS, then the nullability of
1: 	 *  the SYSSTATEMENTS.COMPILATION_SCHEMAID column will 
1: 	 *  be changed to true.  If this corresponds to SYSVIEWS, the nullability
1: 	 *  of the SYSVIEWS.COMPILATION_SCHEMAID column will be changed to true.
1: 	 *  
1: 	 * @exception StandardException   Thrown on error
1: 		throws StandardException
1: 	{		
1: 		TabInfoImpl ti = bootingDictionary.getNonCoreTIByNumber(catalogNum);
1: 		
1: 		if (catalogNum == DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM)
1: 		{
1: 			// SYSSTATEMENTS table ==> SYSSTATEMENTS_COMPILATION_SCHEMAID needs 
1: 			// to be modified.
1: 			bootingDictionary.upgrade_setNullability(rowFactory,
1: 				SYSSTATEMENTSRowFactory.SYSSTATEMENTS_COMPILATION_SCHEMAID, 
0: 				true, tc);
1: 		}
1: 		else if (catalogNum == DataDictionaryImpl.SYSVIEWS_CATALOG_NUM)
1: 		{
1: 			// SYSVIEWS table ==> SYSVIEWS_COMPILATION_SCHEMAID needs 
1: 			// to be modified.
1: 			bootingDictionary.upgrade_setNullability(rowFactory,
1: 				SYSVIEWSRowFactory.SYSVIEWS_COMPILATION_SCHEMAID, 
0: 				true, tc);
1: 		}
1: 		
1: 		/* OLD Cloudscape 5.1 upgrade code. See applySafeChanges(). 
/////////////////////////////////////////////////////////////////////////
1: 		*/		
1: 		
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		5.0.22 =&gt; (0*100) + 22 + 2 =  24 - (5.0 has a unique major number)
1: 		5.1.2  =&gt; (1*100) + 2 + 2  = 104 - (5.1 has a unique major number) 
1: 		5.2.1.100 =&gt; (2*100) + 1000100 + 2 = 1000302
1: 		5.3.1.0   =&gt; (3*100) + 1000000 + 2 = 1000302
commit:a93cd20
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_13:
1: 			return "10.13";
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 			if (isFullUpgrade(startParams, dictionaryVersion.toString())) {
/////////////////////////////////////////////////////////////////////////
1: 		ProductVersionHolder jbmsVersion = DataDictionaryImpl.getMonitor().getEngineVersion();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  boolean isFullUpgrade( final Properties startParams, final String oldVersionInfo )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Boolean>()
1:                  {
1:                      public Boolean run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.isFullUpgrade( startParams, oldVersionInfo );
1:                      }
1:                  }
1:                  ).booleanValue();
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
commit:aa841e7
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_12:
1: 			return "10.12";
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1:             
0:             // On ugrade from versions before 10.11, create system procedures
1:             // added in 10.11.
1:             bootingDictionary.create_10_11_system_procedures( tc, newlyCreatedRoutines );
1: 
1:             // Add a sequence generator for every identity column
1:             bootingDictionary.createIdentitySequences( tc );
commit:f2fad75
/////////////////////////////////////////////////////////////////////////
1:         HashSet<String>  newlyCreatedRoutines = new HashSet<String>();
commit:94b316d
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_11:
1: 			return "10.11";
commit:3dbd09b
/////////////////////////////////////////////////////////////////////////
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_8)
/////////////////////////////////////////////////////////////////////////
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_9)
1:         {
0:             // On ugrade from versions before 10.10, create system procedures
1:             // added in 10.10.
1:             bootingDictionary.create_10_10_system_procedures( tc, newlyCreatedRoutines );
1:         }
1: 
commit:45f5174
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_10:
1: 			return "10.10";
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:             bootingDictionary.create_10_9_system_procedures( tc, newlyCreatedRoutines );
1:             bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSUSERS_CATALOG_NUM );
commit:aa609d5
/////////////////////////////////////////////////////////////////////////
0:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_9)
1:         {
0:             // On ugrade from versions before 10.9, create system procedures
1:             // added in 10.9.
1:             
1:             // On upgrade from versions before 10.9, create system catalogs
1:             // added in 10.9
1:             bootingDictionary.upgradeMakeCatalog(
0:                     tc, DataDictionary.SYSUSERS_CATALOG_NUM);
1:         }
1: 
commit:23f244c
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_9:
1: 			return "10.9";
commit:1299897
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_8:
1: 			return "10.8";
commit:a584888
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_7:
1: 			return "10.7";
commit:bb40bcb
/////////////////////////////////////////////////////////////////////////
1:             
1:             // On upgrade from versions before 10.6, create system catalogs
1:             // added in 10.6
1:             bootingDictionary.upgradeMakeCatalog(
1:                     tc, DataDictionary.SYSSEQUENCES_CATALOG_NUM);
1:             bootingDictionary.upgradeMakeCatalog(
1:                     tc, DataDictionary.SYSPERMS_CATALOG_NUM);
commit:b05fa6e
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Change the return type of SYSIBM.CLOBGETSUBSTRING if necessary. See
1:         //
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // Remove the bad permissions tuple for SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE if necessary.
1:         // See DERBY-4215. That procedure will have an extra permissions tuple
1:         // with a null GRANTOR field if the database was created by 10.0 and then
1:         // hard-upgraded to 10.2 or higher without an intermediate upgrade to 10.1.
1:         //
1:         if (
1:             ( fromMajorVersionNumber > DataDictionary.DD_VERSION_DERBY_10_1) &&
1:             ( fromMajorVersionNumber < DataDictionary.DD_VERSION_DERBY_10_6)
1:             )
1:         {
1:             bootingDictionary.upgradeSYSROUTINEPERMS_10_6( tc );
1:         }
commit:a61fd53
/////////////////////////////////////////////////////////////////////////
0:         // change the return type of SYSIBM.CLOBGETSUBSTRING if necessary. See
1:         // DERBY-4214. That function was added in 10.3 and the return type was
1:         // changed (but not upgraded) in 10.5. We can't distinguish
1:         // between databases which were originally created by 10.5 and databases
1:         // which were upgraded to 10.5.
1:         if (
1:             ( fromMajorVersionNumber > DataDictionary.DD_VERSION_DERBY_10_2) &&
1:             ( fromMajorVersionNumber < DataDictionary.DD_VERSION_DERBY_10_6)
1:             )
1:         {
1:             bootingDictionary.upgradeCLOBGETSUBSTRING_10_6( tc );
1:         }
1:         
commit:1cd97e8
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:         HashSet  newlyCreatedRoutines = new HashSet();
1:         
/////////////////////////////////////////////////////////////////////////
1:                 tc,
1:                 newlyCreatedRoutines,
1:                 tc,
1:                 newlyCreatedRoutines,
/////////////////////////////////////////////////////////////////////////
1: 
1:             // make sure we flag that we need to add permissions to the
1:             // following pre-existing routines:
1:             newlyCreatedRoutines.add( "SYSCS_INPLACE_COMPRESS_TABLE" );
1:             newlyCreatedRoutines.add( "SYSCS_GET_RUNTIMESTATISTICS" );
1:             newlyCreatedRoutines.add( "SYSCS_SET_RUNTIMESTATISTICS" );
1:             newlyCreatedRoutines.add( "SYSCS_COMPRESS_TABLE" );
1:             newlyCreatedRoutines.add( "SYSCS_SET_STATISTICS_TIMING" );
1:             bootingDictionary.create_10_3_system_procedures(tc, newlyCreatedRoutines );
1: 
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_4)
1:         {
1:             // On upgrade from versions before 10.5, create system procedures
1:             // added in 10.5.
1:             bootingDictionary.create_10_5_system_procedures(tc, newlyCreatedRoutines);
1:         }
1: 
1:         // Grant PUBLIC access to some system routines
1:         bootingDictionary.grantPublicAccessToSystemRoutines(newlyCreatedRoutines, tc, aid);
commit:bbe895f
/////////////////////////////////////////////////////////////////////////
0:             bootingDictionary.create_10_3_system_procedures(tc);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:314a19a
/////////////////////////////////////////////////////////////////////////
1:             // On upgrade from versions before 10.6, create system procedures
/////////////////////////////////////////////////////////////////////////
1:             // On upgrade from versions before 10.2, create system procedures
/////////////////////////////////////////////////////////////////////////
1:             // On upgrade from versions before 10.3, create system procedures
/////////////////////////////////////////////////////////////////////////
1:             // On upgrade from versions before 10.9, create system procedures
/////////////////////////////////////////////////////////////////////////
1:             // On upgrade from versions before 10.10, create system procedures
/////////////////////////////////////////////////////////////////////////
1:             // On upgrade from versions before 10.11, create system procedures
/////////////////////////////////////////////////////////////////////////
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_11)
1:         {
1:             // On upgrade from versions before 10.12, create system procedures
1:             // added in 10.12.
1:             bootingDictionary.create_10_12_system_procedures( tc, newlyCreatedRoutines );
1:         }
1: 
commit:9496f49
/////////////////////////////////////////////////////////////////////////
1:             //DERBY-5996(Create readme files (cautioning users against 
1:             // modifying database files) at database hard upgrade time)
1:             //Following will create 3 readme files.
1:             // one in database directory, one in "seg0" directory and one in 
1:             // log directory. These readme files warn users against touching 
1:             // any of files associated with derby database 
1: 			bootingDictionary.af.createReadMeFiles();
commit:598c595
/////////////////////////////////////////////////////////////////////////
0: 			//Following make sure that the stored plans (including the ones for
0: 			//triggers) will get cleared during upgrade and hence we will not
0: 			//hold on to stale plans.
1: 			bootingDictionary.clearSPSPlans();
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_5:
1: 			return "10.5";
/////////////////////////////////////////////////////////////////////////
0:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_4)
1:         {
0:             // On ugrade from versions before 10.5, create system procedures
0:             // added in 10.5.
0:             bootingDictionary.create_10_5_system_procedures(tc);
1:         }
1: 
commit:10dc4fc
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_4:
1: 			return "10.4";
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_10)
1:         {
1:             // On upgrade from versions before 10.11, add a column to the
1:             // SYSTRIGGERS table in order to support the WHEN clause.
1:             bootingDictionary.upgrade_addColumns(
1:               bootingDictionary.getNonCoreTIByNumber(
1:                 DataDictionary.SYSTRIGGERS_CATALOG_NUM).getCatalogRowFactory(),
1:                 new int[] { 18 }, tc);
1:         }
1: 
commit:e6ea644
/////////////////////////////////////////////////////////////////////////
1:             // Make sure all stored plans are cleared, both for triggers and
1:             // for metadata queries. The plans will be recompiled automatically
1:             // on the first execution after upgrade. We clear the plans because
1:             // the stored format may have changed between the versions, so it
1:             // might not be possible to read or execute them in this version.
0:             bootingDictionary.clearSPSPlans();
1: 
/////////////////////////////////////////////////////////////////////////
commit:05623b6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1ea68f8
/////////////////////////////////////////////////////////////////////////
1: 			bootingDictionary.setReadOnlyUpgrade();
commit:ec2bfaf
/////////////////////////////////////////////////////////////////////////
1: 		bootingDictionary.createSystemSps(tc);
/////////////////////////////////////////////////////////////////////////
0: 	 * @param removeSYSIBMonly if <code>true</code>, remove stored
0: 	 * prepared statements in the SYSIBM schema only; otherwise,
0: 	 * remove stored prepared statements in all system schemas
0: 	 * (including SYSIBM)
/////////////////////////////////////////////////////////////////////////
1: 
0: 			// don't drop statements in non-system schemas
0: 			if (!sd.isSystemSchema() && !isSYSIBM) {
1: 
0: 			// don't drop statements outside the SYSIBM schema if
0: 			// we're told not to
0: 			if (removeSYSIBMonly && !isSYSIBM) {
0: 				continue;
1: 			}
1: 
0: 			bootingDictionary.dropSPSDescriptor(spsd, tc);
0: 			bootingDictionary.dropDependentsStoredDependencies(spsd.getUUID(),
1: 															   tc);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
1: 
1:             // On upgrade from versions before 10.9, upgrade the way we store
1:             // jars: we now use UUID as part of the file name and sanitize the
1:             // sql (schema, schema object) parts of the file name to remove
1:             // path delimiters. ALso, we now use no schema subdirectories since
1:             // there is no chance of name collision with the UUID.
1:             bootingDictionary.upgradeJarStorage(tc);
commit:aaa1403
/////////////////////////////////////////////////////////////////////////
1: 		if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_3)
1: 		{
1: 			// Add new system catalogs created for roles
1: 			bootingDictionary.upgradeMakeCatalog(
1: 				tc, DataDictionary.SYSROLES_CATALOG_NUM);
1: 		}
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3f523e6
/////////////////////////////////////////////////////////////////////////
1: 		bootingDictionary.updateMetadataSPSes(tc);
/////////////////////////////////////////////////////////////////////////
1: 			// Once a database is version 10.5 we will start updating metadata SPSes
1: 			// on any version change,up or down.  This will ensure that metadata queries 
1: 			// match the version we are using.  We don't want to do this for lower 
1: 			// database versions because on reverting to the previous version the 
1: 			// SPSes won't be restored.
1: 			if (fromVersion.majorVersionNumber >= DataDictionary.DD_VERSION_DERBY_10_5)
1: 				bootingDictionary.updateMetadataSPSes(tc);
1: 			else
0: 				bootingDictionary.clearSPSPlans();
/////////////////////////////////////////////////////////////////////////
1: 	
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d1e9d3c
/////////////////////////////////////////////////////////////////////////
1: 			bootingDictionary.upgradeFixSystemColumnDefinition(rowFactory,
1: 				tc);
1: 			bootingDictionary.upgradeFixSystemColumnDefinition(rowFactory,
1: 				tc);
commit:0978789
/////////////////////////////////////////////////////////////////////////
1: 											sd, tc);
commit:f7e090f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 									 TabInfoImpl ti)
/////////////////////////////////////////////////////////////////////////
0: 		TabInfoImpl					tabInfo,
commit:276925a
/////////////////////////////////////////////////////////////////////////
1: 			
0: 			// Grant PUBLIC access to some system routines
0: 			bootingDictionary.grantPublicAccessToSystemRoutines(tc, aid);
commit:885e276
/////////////////////////////////////////////////////////////////////////
commit:d3a4f64
/////////////////////////////////////////////////////////////////////////
0: 		while ( heapScan.fetchNext(heapRow.getRowArray()) )
0:  			heapScan.fetchLocation( heapLocation );
commit:703bc91
/////////////////////////////////////////////////////////////////////////
1: 		by the a Derby engine at the older version fromMajorVersionNumber.
1: 		<BR>
1: 		Examples are fixes to catalog meta data, e.g. fix nullability of
1: 		a system column.
1: 		<BR>
1: 		<B>Upgrade items for 10.1</B>
1: 		<UL>
1: 		<LI> None.
1: 		</UL>
/////////////////////////////////////////////////////////////////////////
1: 		/*
1: 		 * OLD Cloudscape 5.1 upgrade code, Derby does not support
1: 		 * upgrade from Cloudscape 5.x databases. If it ever is changed
1: 		 * to do so, this code would be useful.
1: 		 * 
1: 		 * 
/////////////////////////////////////////////////////////////////////////
1: 		*/
1: 		
1: 		<BR>
1: 		<B>Upgrade items for 10.1</B>
1: 		<UL>
1: 		<LI> None.
1: 		</UL>
/////////////////////////////////////////////////////////////////////////
1: 		// Only supports upgrade from Derby 10.0 releases onwards
1: 		if (fromMajorVersionNumber < DataDictionary.DD_VERSION_CS_10_0)
1: 		{
1: 			throw StandardException.newException(SQLState.UPGRADE_UNSUPPORTED,
1: 					DD_Version.majorToString(fromMajorVersionNumber), this);			
1: 		}
1: 
1: 		/*
1: 		 * OLD Cloudscape 5.1 upgrade code, Derby does not support
1: 		 * upgrade from Cloudscape 5.x databases. If it ever is changed
1: 		 * to do so, this code would be useful.
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		*/
/////////////////////////////////////////////////////////////////////////
1: 	 * 
0: 	 * OLD Cloudscape 5.1 upgrade code
/////////////////////////////////////////////////////////////////////////
0: 	/* OLD Cloudscape 5.1 upgrade code. See applySafeChanges().
1: 
/////////////////////////////////////////////////////////////////////////
1: */
commit:36d3bed
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_1:
1: 			return "10.1";
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.catalog.DD_Version
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:e1e80ad
/////////////////////////////////////////////////////////////////////////
0: 			bootingDictionary.createSystemSps(tc);
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.catalog
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.catalog;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TabInfo;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.info.ProductGenusNames;
1: import org.apache.derby.iapi.services.info.ProductVersionHolder;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
0: import java.sql.Types;
0: import java.util.Enumeration;
1: import java.util.Properties;
1: 
1: /**
1:  * Generic code for upgrading data dictionaries.
1:  * Currently has all minor version upgrade logic.
1:  * <p>
1:  * A word about minor vs. major upgraded.  Minor
1:  * upgrades must be backwards/forwards compatible.
1:  * So they cannot version classes or introduce new
1:  * classes.  Major releases are only backwards compatible;
1:  * they will run against an old database, but not the
1:  * other way around.  So they can introduce new classes,
1:  * etc.
1:  *
0:  * @author Rick
1:  */
1: 
1: public	class DD_Version implements	Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 	private		transient	DataDictionaryImpl	bootingDictionary;
1: 
1: 	int majorVersionNumber;
1: 	private int minorVersionNumber;
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTORS
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Public niladic constructor needed for Formatable interface.
1: 	  */
1: 	public	DD_Version() {}
1: 
1: 
1: 	/**
1: 	 * Construct a Version for the currently booting data dictionary.
1: 	 * The minor version is set by the subclass.
1: 	 *
1: 	 * @param	bootingDictionary	The booting dictionary that needs to be upgraded.
1: 	 */
1: 	DD_Version( DataDictionaryImpl bootingDictionary, int majorVersionNumber)
1: 	{
1: 		this.majorVersionNumber = majorVersionNumber;
1: 		this.minorVersionNumber = getJBMSMinorVersionNumber();
1: 		this.bootingDictionary = bootingDictionary;
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	OVERRIDE OBJECT METHODS
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Stringify this Version.
1: 	  *
1: 	  *	@return	String representation of this Version.
1: 	  */
1: 	public	String	toString()
1: 	{
1: 		return DD_Version.majorToString(majorVersionNumber);
1: 	}
1: 
1: 	private static String majorToString(int majorVersionNumber) {
1: 		switch (majorVersionNumber) {
1: 		case DataDictionary.DD_VERSION_CS_5_0:
1: 			return "5.0";
1: 		case DataDictionary.DD_VERSION_CS_5_1:
1: 			return "5.1";
1: 		case DataDictionary.DD_VERSION_CS_5_2:
1: 			return "5.2";
1: 		case DataDictionary.DD_VERSION_CS_8_1:
1: 			return "8.1";
1: 		case DataDictionary.DD_VERSION_CS_10_0:
1: 			return "10.0";
1: 		default:
1: 			return null;
1: 		}
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	DataDictionary SPECIFIC
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Upgrade the data dictionary catalogs to the version represented by this
1: 	 * DD_Version.
1: 	 *
1: 	 * @param dictionaryVersion the version of the data dictionary tables.
1: 	 * @exception StandardException Ooops
1: 	 */
1: 	void upgradeIfNeeded(DD_Version dictionaryVersion,
1: 								TransactionController tc, Properties startParams)
1: 		 throws StandardException
1: 	{
1: 		// database has been upgrade with a later engine version than this?
1: 		if (dictionaryVersion.majorVersionNumber > majorVersionNumber) {
1: 			throw StandardException.newException(SQLState.LANG_CANT_UPGRADE_CATALOGS,  
1: 				dictionaryVersion, this);
1: 		}
1: 
1: 
1: 		boolean minorOnly = false;
1: 		boolean performMajorUpgrade = false;
1: 		boolean softUpgradeRun = false;
1: 
1: 
1: 		if (dictionaryVersion.majorVersionNumber == majorVersionNumber) {
1: 
1: 			// exact match of engine to database, do nothing.
1: 			if (dictionaryVersion.minorVersionNumber == minorVersionNumber)
1: 				return;
1: 
1: 			// database and engine at same major level
1: 			minorOnly = true;
1: 
1: 		} else {
1:            
0: 			if (Monitor.isFullUpgrade(startParams, dictionaryVersion.toString())) {
1: 				performMajorUpgrade = true;
1: 			} else {
1: 				softUpgradeRun = true;
1: 			}
1: 		}
1: 
1: 		// make sure we have a clean transaction for the upgrade
1: 		tc.commit();
1: 
1: 		if (performMajorUpgrade) {
0: 			// real upgrade changes.
0: 			doFullUpgrade( tc, dictionaryVersion.majorVersionNumber );
1: 		}
1: 
0: 		if (!minorOnly) {
1: 			// apply changes that can be made and will continue to work
1: 			// against previous version.
1: 
1: 			// See if we have already applied these changes.
1: 			DD_Version softUpgradeVersion = (DD_Version) tc.getProperty(
1: 											DataDictionary.SOFT_DATA_DICTIONARY_VERSION);
1: 
1: 			// need to apply them if we have never performed a soft upgrade
1: 			// or only a soft upgrade using a previous version.
1: 			int softUpgradeMajorVersion = 0;
1: 			if (softUpgradeVersion != null)
1: 				softUpgradeMajorVersion = softUpgradeVersion.majorVersionNumber;
1: 
1: 			if (softUpgradeMajorVersion < majorVersionNumber) {
1: 				applySafeChanges( tc, dictionaryVersion.majorVersionNumber, softUpgradeMajorVersion);
1: 			}
1: 		}
1: 
1: 		// changes such as invalidating SPS so they will recompile against
1: 		// the new internal classes.
1: 		// this method also changes the on-disk format version on the disk and in-memory as well.
1: 		handleMinorRevisionChange(tc, dictionaryVersion, softUpgradeRun);
1: 
1: 		// commit any upgrade
1: 		tc.commit();
1: 	}
1: 
1: 	/**
1: 		Apply changes that can safely be made in soft upgrade.
1: 		Any changes must not prevent the database from being re-booted
0: 		by the a Cloudscape engine at the older version fromMajorVersionNumber
1: 
1: 	  *
1: 	  * @param	tc	transaction controller
1: 	  * @param	fromMajorVersionNumber	version of the on-disk database
1: 	    @param  lastSoftUpgradeVersion last engine to perform a soft upgrade that made changes.
1: 	  *
0: 	  *	@exception StandardException  Standard Cloudscape error policy.
1: 	  */
1: 	private	void	applySafeChanges(TransactionController tc, int fromMajorVersionNumber, int lastSoftUpgradeVersion)
1: 		throws StandardException
1: 	{
1: 
1: 		if (lastSoftUpgradeVersion <= DataDictionary.DD_VERSION_CS_5_1)
1: 		{
1: 
1: 			// All these soft upgrade actions are new in 5.2 (first ever soft upgrade)
1: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_0)
1: 				modifySysTableNullability(tc,
1: 					DataDictionaryImpl.SYSALIASES_CATALOG_NUM);
1: 
1: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_1)
1: 				modifySysTableNullability(tc,
1: 					DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM);
1: 
1: 		}
1: 
1: 		tc.setProperty(DataDictionary.SOFT_DATA_DICTIONARY_VERSION, this, true);
1: 	}
1: 
1: 	/**
1: 		Do full upgrade.  Apply changes that can NOT be safely made in soft upgrade.
1: 
1: 	  *
1: 	  * @param	tc	transaction controller
1: 	  * @param	fromMajorVersionNumber	version of the on-disk database
1: 	  *
0: 	  *	@exception StandardException  Standard Cloudscape error policy.
1: 	  */
0: 	private	void	doFullUpgrade(TransactionController tc, int fromMajorVersionNumber)
1: 		throws StandardException
1: 	{
1: 		if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_1)
1: 		{
1: 			// drop sps in SYSIBM, SYSIBM, recreate SYSIBM, SYSDUMMY1, populate SYSDUMMY1, create procs
1: 			dropJDBCMetadataSPSes(tc, true);
1: 			SchemaDescriptor sd = bootingDictionary.getSchemaDescriptor("SYSIBM", null, false);
1: 			if (sd != null)
1: 				bootingDictionary.dropSchemaDescriptor("SYSIBM", tc);
1: 			sd = bootingDictionary.getSysIBMSchemaDescriptor();
1: 			bootingDictionary.addDescriptor(sd, null, DataDictionary.SYSSCHEMAS_CATALOG_NUM, false, tc);
1: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSDUMMY1_CATALOG_NUM);
1: 			bootingDictionary.populateSYSDUMMY1(tc);
1: 			bootingDictionary.create_SYSIBM_procedures(tc);
0: 			bootingDictionary.createNetworkServerMetadataSps(tc);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Do any work needed for a minor revision change.
1: 	 * For the data dictionary this is always invalidating
1: 	 * stored prepared statements.  When we are done 
1: 	 * with the upgrade, we always recompile all SPSes
1: 	 * so the customer doesn't have to (and isn't going
1: 	 * to get deadlocks because of the recomp).
1: 	 *
1: 	 * @param tc the xact
1: 	 *
0: 	 * @exception StandardException  Standard Cloudscape error policy.
1: 	 */
1: 	private void handleMinorRevisionChange(TransactionController tc, DD_Version fromVersion, boolean softUpgradeRun) 
1: 		throws StandardException
1: 	{
1: 		boolean isReadOnly = bootingDictionary.af.isReadOnly();
1: 
1: 		if (!isReadOnly) {
0: 			bootingDictionary.clearSPSPlans();
1: 
1: 			DD_Version lastRun;
1: 			
1: 			if (softUpgradeRun)
1: 			{
1: 				// log a version that will cause a minor revision change
1: 				// for any subsequent re-boot, including an old Cloudscape version
1: 				fromVersion.minorVersionNumber = 1; // see getJBMSMinorVersionNumber
1: 				lastRun = fromVersion;
1: 			}
1: 			else
1: 			{
1: 				// log the new version
1: 				lastRun = this;
1: 			
1: 				// and change the in-memory version.
1: 				fromVersion.majorVersionNumber = majorVersionNumber;
1: 				fromVersion.minorVersionNumber = minorVersionNumber;
1: 			}
1: 
1: 			tc.setProperty(DataDictionary.CORE_DATA_DICTIONARY_VERSION, fromVersion, true);
1: 		}
1: 		else
1: 		{
1: 			// For a readonly database where we need some kind of upgrade
1: 			// (either minor release or soft upgrade) then since we cannot
1: 			// invalidate all the procedures we need to indicate that
1: 			// any procedure we read off disk is automatically invalid,
1: 			// so we do not try to load the generated class.
0: 			bootingDictionary.readOnlyUpgrade = true;
1: 		}
1: 
1: 		bootingDictionary.clearCaches();
1: 	}
1: 
1: 	/**
0: 	 * Drop all jdbc metadata spses.  This
0: 	 * it to ensure that we don't have any problems
0: 	 * with old metadata queries that have outdated
0: 	 * query text (the plans are always cleared out
0: 	 * on upgrade time).
1: 	 *
1: 	 * @param tc the xact
1: 	 *
0: 	 * @exception StandardException  Standard Cloudscape error policy.
1: 	 */
0: 	protected void dropJDBCMetadataSPSes(TransactionController tc, boolean removeSYSIBMonly)
1: 		throws StandardException
1: 	{
0: 		for (java.util.Iterator it = bootingDictionary.getAllSPSDescriptors().iterator(); it.hasNext(); )
1: 		{
0: 			SPSDescriptor spsd = (SPSDescriptor) it.next();
0: 			SchemaDescriptor sd = spsd.getSchemaDescriptor();
0: 			// need to compare the name, old SYSIBM is not built-in
0: 			boolean isSYSIBM = sd.getSchemaName().equals(SchemaDescriptor.IBM_SYSTEM_SCHEMA_NAME);
0: 			if (! sd.isSystemSchema() && ! isSYSIBM)
0: 				continue;
1: 			/*
0: 			** Is it in SYS? if so, zap it.
1: 			*/
0: 			if ((removeSYSIBMonly && isSYSIBM) || (! removeSYSIBMonly && ! isSYSIBM))
1: 			{
0: 				bootingDictionary.dropSPSDescriptor(spsd, tc);
0: 				bootingDictionary.dropDependentsStoredDependencies(spsd.getUUID(), tc);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0:  	 * Make a catalog.
1: 	 *	@param	tc	TransactionController
1: 	 *  @param  crf CatalogRowFactory for the catalog to drop.
0: 	 *	@exception StandardException  Standard Cloudscape error policy.
1: 	 */
0: 	protected void makeSystemCatalog(TransactionController tc,
0: 									 TabInfo ti)
1: 		throws StandardException
1: 	{
0: 		SchemaDescriptor sd = bootingDictionary.getSystemSchemaDescriptor();
0: 		bootingDictionary.makeCatalog(ti,sd,tc);
1: 	}
1: 
1: 	/**
1: 	  Remove the description of a System table from the data dictionary.
1: 	  This does not delete the conglomerates that hold the catalog or
1: 	  its indexes.
1: 	  @param	tc TransactionController
1: 	  @param    td Table descriptor for the catalog to drop. 
0: 	  @exception StandardException  Standard Cloudscape error policy.
1: 	  */
1: 	protected void
1: 	dropSystemCatalogDescription(TransactionController tc, TableDescriptor td)
1: 		throws StandardException
1: 	{
1: 		/* Drop the columns */
1: 		bootingDictionary.dropAllColumnDescriptors(td.getUUID(), tc);
1: 
1: 		/* Drop the conglomerate descriptors */
1: 		bootingDictionary.dropAllConglomerateDescriptors(td, tc);
1: 
1: 		/* Drop table descriptor */
1: 		bootingDictionary.dropTableDescriptor( td, td.getSchemaDescriptor(), tc );
1: 		bootingDictionary.clearCaches();
1: 	}
1: 
1: 	/**
1:  	 * Drop a System catalog.
1: 	 *	@param	tc	TransactionController
1: 	 *  @param  crf CatalogRowFactory for the catalog to drop.
0: 	 *	@exception StandardException  Standard Cloudscape error policy.
1: 	 */
1: 	protected void dropSystemCatalog(TransactionController tc,
1: 							 CatalogRowFactory crf)
1: 		throws StandardException
1: 	{
1: 		SchemaDescriptor		sd = bootingDictionary.getSystemSchemaDescriptor();
1: 		TableDescriptor			td = bootingDictionary.getTableDescriptor(
1: 											crf.getCatalogName(),
0: 											sd);
1: 		ConglomerateDescriptor[]	cds = td.getConglomerateDescriptors();
1: 		for (int index = 0; index < cds.length; index++)
1: 		{
1: 			tc.dropConglomerate(cds[index].getConglomerateNumber());
1: 		}
1: 		dropSystemCatalogDescription(tc,td);
1: 	}
1: 
1: 
1: 	/**
0: 	 * Populates a new system index from the base system table.
1: 	 *
0: 	 *	@param	tc						transaction controller
0: 	 *	@param	heapConglomerateNumber	identifies system table to Store
0: 	 *	@param	tabInfo					describes base system table
0: 	 *	@param	indexNumber				index to populate
1: 	 *
1: 	 *
0: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	protected	void	fillIndex
0: 	(
0: 		TransactionController	tc,
0: 		long					heapConglomerateNumber,
0: 		TabInfo					tabInfo,
0: 		int						indexNumber
0:     )
1: 		throws StandardException
1: 	{
0: 		long						indexConglomerateNumber = tabInfo.getIndexConglomerate( indexNumber );
0: 		IndexRowGenerator			indexRowGenerator = tabInfo.getIndexRowGenerator( indexNumber );
0: 		CatalogRowFactory			rowFactory = tabInfo.getCatalogRowFactory();
0: 		ExecRow						heapRow = rowFactory.makeEmptyRow();
0: 		ExecIndexRow				indexableRow = indexRowGenerator.getIndexRowTemplate();
1: 
0: 		ScanController				heapScan =
0: 			tc.openScan(
0: 				heapConglomerateNumber,       // conglomerate to open
0: 				false,                          // don't hold open across commit
0: 				0,                              // for read
0:                 TransactionController.MODE_TABLE,
0:                 TransactionController.ISOLATION_REPEATABLE_READ,
0: 				(FormatableBitSet) null,                 // all fields as objects
0: 				null,                           // start position - first row
0: 				ScanController.GE,              // startSearchOperation
0: 				null,                           //scanQualifier,
0: 				null,                           //stop position-through last row
0: 				ScanController.GT);             // stopSearchOperation
1: 
0: 		RowLocation					heapLocation = 
0:             heapScan.newRowLocationTemplate();
1: 
0: 		ConglomerateController		indexController = 
0: 			tc.openConglomerate( 
0: 				indexConglomerateNumber, 
0:                 false,
0: 				TransactionController.OPENMODE_FORUPDATE,
0: 				TransactionController.MODE_TABLE,
0: 				TransactionController.ISOLATION_REPEATABLE_READ);
1: 
0: 		while ( heapScan.next() )
1:         {
0:             heapScan.fetch( heapRow.getRowArray() );
0: 			heapScan.fetchLocation( heapLocation );
1: 
0: 			indexRowGenerator.getIndexRow( heapRow, heapLocation, indexableRow, (FormatableBitSet) null );
1: 
0: 			indexController.insert(indexableRow.getRowArray());
1: 		}
1: 
0: 		indexController.close();
0: 		heapScan.close();
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	FORMATABLE INTERFACE
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	   Map to the 5.0 version identifier so that 5.0 will understand
1: 	   this object when we write it out in soft upgrade mode.
1: 	   CS 5.0 will de-serialize it correctly.
1: 	   When we are writing out a 5.1 version number we write out
1: 	   the 5.1 version just to ensure no problems.
1: 	   
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
1: 	public	int	getTypeFormatId()	{
1: 		return majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?
1: 			StoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;
1: 	}
1: 	/**
1: 	 * Read this object from a stream of stored objects. Set
1: 	 * the minor version.  Ignore the major version.  
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException on error
1: 	 */
1: 	public final void readExternal( ObjectInput in ) throws IOException
1: 	{
1: 		majorVersionNumber = in.readInt();
1: 		minorVersionNumber = in.readInt();
1: 	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects. Write
1: 	 * out the minor version which is bumped across minor release.
1: 	 * Just to be safe, write out the major version too.  This
1: 	 * will allow us to do versioning of a specific Version impl
1: 	 * in the future.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 *
1: 	 * @exception IOException on error
1: 	 */
1: 	public final void writeExternal( ObjectOutput out ) throws IOException
1: 	{ 
1: 		out.writeInt(majorVersionNumber);
1: 		out.writeInt(minorVersionNumber);
1: 	}
1: 	/**
1: 	 * Get the minor version from the JBMS product minor version/maint version.
1: 	 * Bumps it up by 1 if production, or 0 if beta to ensure
1: 	 * minor upgrade across beta.  Starts at 2 because of an
1: 	 * old convention. We use this starting at 2 to allow soft upgrade to
1: 	 * write a version of 1 with the old major number to ensure a minor upgrade
1: 	   when reverting to an old version afer a soft upgrade. E.g run with 5.0.2,
1: 	   then 5.2.1.1, then 5.0.2. Want to ensure 5.0.2 does the minor upgrade.
1: 	 *
1: 	 * @return the minor version
1: 
1: 		For 5.0 and 5.1 the minor number was calculated as
1: 
1: 		jbmsVersion.getMinorVersion()*100 +jbmsVersion.getMaintVersion() + (jbmsVersion.isBeta() ? 0 : 1) + 2
1: 
0: 		5.0.22 => (0*100) + 22 + 2 =  24 - (5.0 has a unique major number)
0: 		5.1.2  => (1*100) + 2 + 2  = 104 - (5.1 has a unique major number) 
1: 
1: 
1: 		With the switch to the four part scheme in 5.2, the maint number now is in increments of one million,
1: 		thus the above scheme could lead to duplicate numbers. Note that the major number may not change
1: 		when the minor external release changes, e.g. 5.2 and 5.3 could share a DD_Version major number.
1: 
0: 		5.2.1.100 => (2*100) + 1000100 + 2 = 1000302
0: 		5.3.1.0   => (3*100) + 1000000 + 2 = 1000302
1: 
1: 		
1: 
1: 	 */
1: 	private int getJBMSMinorVersionNumber() 
1: 	{
0: 		ProductVersionHolder jbmsVersion = Monitor.getMonitor().getEngineVersion();
1: 
1: 		return jbmsVersion.getMinorVersion()*100 +jbmsVersion.getMaintVersion() + (jbmsVersion.isBeta() ? 0 : 1) + 2;
1: 	}
1: 	
1: 	/**
1: 	 * Modifies the nullability of the system table corresponding
1: 	 * to the received catalog number.
1: 	 *
1: 	 * @param tc			TransactionController.
1: 	 * @param catalogNum	The catalog number corresponding
1: 	 *  to the table for which we will modify the nullability.
1: 	 *  If this corresponds to SYSALIASES, then the nullability of
1: 	 *  the SYSALIASES.ALIASINFO column will be changed to true
1: 	 *  (Beetle 4430).  If this corresponds to SYSSTATEMENTS,
1: 	 *  the nullability of the SYSSTATEMENTS.LASTCOMPILED
1: 	 *  column will be changed to true.
1: 	 *
0: 	 * @exception StandardException
1: 	 */
1: 
1: 	private void modifySysTableNullability(TransactionController tc, int catalogNum)
1: 	throws StandardException
1: 	{
1: 
0: 		TabInfo ti = bootingDictionary.getNonCoreTIByNumber(catalogNum);
1: 		CatalogRowFactory rowFactory = ti.getCatalogRowFactory();
1: 		if (catalogNum == DataDictionaryImpl.SYSALIASES_CATALOG_NUM) {
1: 		// SYSALIASES table ==> ALIASINFO needs to be modified.
0: 			bootingDictionary.upgrade_setNullability(rowFactory,
1: 				SYSALIASESRowFactory.SYSALIASES_ALIASINFO, true, tc);
1: 		}
1: 		else if (catalogNum == DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM) {
1: 		// SYSSTATEMENTS table ==> LASTCOMPILED needs to be modified.
0: 			bootingDictionary.upgrade_setNullability(rowFactory,
1: 				SYSSTATEMENTSRowFactory.SYSSTATEMENTS_LASTCOMPILED, true, tc);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 		Check to see if a database has been upgraded to the required
1: 		level in order to use a language feature.
1: 
0: 		@param majorVersion Data Dictionary major version
1: 		@param feature Non-null to throw an error, null to return the state of the version match.
1: 
1: 		@return True if the database has been upgraded to the required level, false otherwise.
1: 	*/
1: 	boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {
1: 
1: 		if (majorVersionNumber < requiredMajorVersion) {
1: 
1: 			if (feature != null)
1: 				throw StandardException.newException(SQLState.LANG_STATEMENT_UPGRADE_REQUIRED, feature,
1: 					DD_Version.majorToString(majorVersionNumber),
1: 					DD_Version.majorToString(requiredMajorVersion));
1: 
1: 			return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c243be1
/////////////////////////////////////////////////////////////////////////
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_1)
0:         {
1:             // add catalogs 1st, subsequent procedure adding may depend on
1:             // catalogs.
0: 
1: 			// Add new system catalogs created for grant and revoke
1: 			bootingDictionary.upgradeMakeCatalog(
1:                 tc, DataDictionary.SYSTABLEPERMS_CATALOG_NUM);
1: 			bootingDictionary.upgradeMakeCatalog(
1:                 tc, DataDictionary.SYSCOLPERMS_CATALOG_NUM);
1: 			bootingDictionary.upgradeMakeCatalog(
1:                 tc, DataDictionary.SYSROUTINEPERMS_CATALOG_NUM);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:             {
1: 				SanityManager.ASSERT((aid != null), 
1:                     "Failed to get new Database Owner authorization");
0:             }
commit:439d1e8
/////////////////////////////////////////////////////////////////////////
1: 	  * @param	aid	 AuthorizationID of current user to be made Database Owner
/////////////////////////////////////////////////////////////////////////
0: 				SanityManager.ASSERT((aid != null), "Failed to get new Database Owner authorization");
commit:fbb8866
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_1)
0:         {
0:             // On ugrade from versions before 10.2, create system procedures
1:             // added in 10.2.
1:             bootingDictionary.create_10_2_system_procedures(
0:                 tc, 
1:                 bootingDictionary.getSystemUtilSchemaDescriptor().getUUID());
0:         }
0:         
commit:522127b
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (fromMajorVersionNumber == DataDictionary.DD_VERSION_CS_10_0)
0:         {
1:             // This upgrade depends on the SYSUTIL schema, which only exists
1:             // since 10.0.  Will not work to upgrade any db previous to 10.0,
1:             // thus only checks for 10.0 rather than <= 10.0.
1:             bootingDictionary.create_10_1_system_procedures(
0:                 tc, 
1:                 bootingDictionary.getSystemUtilSchemaDescriptor().getUUID());
0:         }
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:fef20ca
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_DERBY_10_2)
0:         {
0:             // On ugrade from versions before 10.3, create system procedures
1:             // added in 10.3.
0:             bootingDictionary.create_10_3_system_procedures(
0:                 tc, 
0:                 bootingDictionary.getSystemUtilSchemaDescriptor().getUUID());
0:         }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	  *	@exception StandardException  Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
1: 	  *	@exception StandardException  Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception StandardException  Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
0: 	 * @exception StandardException  Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
1: 	 *	@exception StandardException  Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
1: 	  @exception StandardException  Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
0: 	 *	@exception StandardException  Standard Derby error policy.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f739ad1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		@param requiredMajorVersion Data Dictionary major version
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
1: 			// real upgrade changes. Get user name of current user.
1: 			String userName = IdUtil.getUserNameFromURLProps(startParams);
1: 			doFullUpgrade(tc, dictionaryVersion.majorVersionNumber,IdUtil.getUserAuthorizationId(userName));
/////////////////////////////////////////////////////////////////////////
0: 	  * @param	aid						AuthorizationID of current user to be made DBA
1: 	private	void	doFullUpgrade(TransactionController tc, int fromMajorVersionNumber, String aid)
/////////////////////////////////////////////////////////////////////////
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT((aid != null), "Failed to get new DBA authorization");
0: 
0: 
1: 			// Change system schemas to be owned by aid
1: 			bootingDictionary.updateSystemSchemaAuthorization(aid, tc);
commit:617fe8f
/////////////////////////////////////////////////////////////////////////
0: 
0: 			// Add new system catalogs created for grant and revoke
0: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSTABLEPERMS_CATALOG_NUM);
0: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSCOLPERMS_CATALOG_NUM);
0: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSROUTINEPERMS_CATALOG_NUM);
0: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSREQUIREDPERM_CATALOG_NUM);
commit:1b29824
/////////////////////////////////////////////////////////////////////////
1: 		boolean isReadOnly = bootingDictionary.af.isReadOnly();	
/////////////////////////////////////////////////////////////////////////
1: 		if (!minorOnly && !isReadOnly) {
commit:2dc0b91
/////////////////////////////////////////////////////////////////////////
1: 		case DataDictionary.DD_VERSION_DERBY_10_2:
1: 			return "10.2";
/////////////////////////////////////////////////////////////////////////
1: 		<B>Upgrade items for every new release</B>
1: 		<UL>
1: 		<LI> Drop and recreate the stored versions of the JDBC database metadata queries
1: 		</UL>
0: 		
1: 		<BR>
0: 		
/////////////////////////////////////////////////////////////////////////
1: 		//Drop and recreate the stored versions of the JDBC database metadata queries
1: 		//This is to make sure that we have the stored versions of JDBC database
1: 		//metadata queries matching with this release of the engine.
0: 		dropJDBCMetadataSPSes(tc, false);
0: 		bootingDictionary.createSPSSet(tc, false, bootingDictionary.getSystemSchemaDescriptor().getUUID());
0: 
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.catalog
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.catalog;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TabInfo;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.info.ProductGenusNames;
0: import org.apache.derby.iapi.services.info.ProductVersionHolder;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import java.io.IOException;
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import java.sql.Types;
0: import java.util.Enumeration;
0: import java.util.Properties;
0: 
0: /**
0:  * Generic code for upgrading data dictionaries.
0:  * Currently has all minor version upgrade logic.
0:  * <p>
0:  * A word about minor vs. major upgraded.  Minor
0:  * upgrades must be backwards/forwards compatible.
0:  * So they cannot version classes or introduce new
0:  * classes.  Major releases are only backwards compatible;
0:  * they will run against an old database, but not the
0:  * other way around.  So they can introduce new classes,
0:  * etc.
0:  *
0:  * @author Rick
0:  */
0: 
0: public	class DD_Version implements	Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATE
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	private		transient	DataDictionaryImpl	bootingDictionary;
0: 
0: 	int majorVersionNumber;
0: 	private int minorVersionNumber;
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTORS
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Public niladic constructor needed for Formatable interface.
0: 	  */
0: 	public	DD_Version() {}
0: 
0: 
0: 	/**
0: 	 * Construct a Version for the currently booting data dictionary.
0: 	 * The minor version is set by the subclass.
0: 	 *
0: 	 * @param	bootingDictionary	The booting dictionary that needs to be upgraded.
0: 	 */
0: 	DD_Version( DataDictionaryImpl bootingDictionary, int majorVersionNumber)
0: 	{
0: 		this.majorVersionNumber = majorVersionNumber;
0: 		this.minorVersionNumber = getJBMSMinorVersionNumber();
0: 		this.bootingDictionary = bootingDictionary;
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	OVERRIDE OBJECT METHODS
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Stringify this Version.
0: 	  *
0: 	  *	@return	String representation of this Version.
0: 	  */
0: 	public	String	toString()
0: 	{
0: 		return DD_Version.majorToString(majorVersionNumber);
0: 	}
0: 
0: 	private static String majorToString(int majorVersionNumber) {
0: 		switch (majorVersionNumber) {
0: 		case DataDictionary.DD_VERSION_CS_5_0:
0: 			return "5.0";
0: 		case DataDictionary.DD_VERSION_CS_5_1:
0: 			return "5.1";
0: 		case DataDictionary.DD_VERSION_CS_5_2:
0: 			return "5.2";
0: 		case DataDictionary.DD_VERSION_CS_8_1:
0: 			return "8.1";
0: 		case DataDictionary.DD_VERSION_CS_10_0:
0: 			return "10.0";
0: 		default:
0: 			return null;
0: 		}
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	DataDictionary SPECIFIC
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Upgrade the data dictionary catalogs to the version represented by this
0: 	 * DD_Version.
0: 	 *
0: 	 * @param dictionaryVersion the version of the data dictionary tables.
0: 	 * @exception StandardException Ooops
0: 	 */
0: 	void upgradeIfNeeded(DD_Version dictionaryVersion,
0: 								TransactionController tc, Properties startParams)
0: 		 throws StandardException
0: 	{
0: 		// database has been upgrade with a later engine version than this?
0: 		if (dictionaryVersion.majorVersionNumber > majorVersionNumber) {
0: 			throw StandardException.newException(SQLState.LANG_CANT_UPGRADE_CATALOGS,  
0: 				dictionaryVersion, this);
0: 		}
0: 
0: 
0: 		boolean minorOnly = false;
0: 		boolean performMajorUpgrade = false;
0: 		boolean softUpgradeRun = false;
0: 
0: 
0: 		if (dictionaryVersion.majorVersionNumber == majorVersionNumber) {
0: 
0: 			// exact match of engine to database, do nothing.
0: 			if (dictionaryVersion.minorVersionNumber == minorVersionNumber)
0: 				return;
0: 
0: 			// database and engine at same major level
0: 			minorOnly = true;
0: 
0: 		} else {
0:            
0: 			if (Monitor.isFullUpgrade(startParams, dictionaryVersion.toString())) {
0: 				performMajorUpgrade = true;
0: 			} else {
0: 				softUpgradeRun = true;
0: 			}
0: 		}
0: 
0: 		// make sure we have a clean transaction for the upgrade
0: 		tc.commit();
0: 
0: 		if (performMajorUpgrade) {
0: 			// real upgrade changes.
0: 			doFullUpgrade( tc, dictionaryVersion.majorVersionNumber );
0: 		}
0: 
0: 		if (!minorOnly) {
0: 			// apply changes that can be made and will continue to work
0: 			// against previous version.
0: 
0: 			// See if we have already applied these changes.
0: 			DD_Version softUpgradeVersion = (DD_Version) tc.getProperty(
0: 											DataDictionary.SOFT_DATA_DICTIONARY_VERSION);
0: 
0: 			// need to apply them if we have never performed a soft upgrade
0: 			// or only a soft upgrade using a previous version.
0: 			int softUpgradeMajorVersion = 0;
0: 			if (softUpgradeVersion != null)
0: 				softUpgradeMajorVersion = softUpgradeVersion.majorVersionNumber;
0: 
0: 			if (softUpgradeMajorVersion < majorVersionNumber) {
0: 				applySafeChanges( tc, dictionaryVersion.majorVersionNumber, softUpgradeMajorVersion);
0: 			}
0: 		}
0: 
0: 		// changes such as invalidating SPS so they will recompile against
0: 		// the new internal classes.
0: 		// this method also changes the on-disk format version on the disk and in-memory as well.
0: 		handleMinorRevisionChange(tc, dictionaryVersion, softUpgradeRun);
0: 
0: 		// commit any upgrade
0: 		tc.commit();
0: 	}
0: 
0: 	/**
0: 		Apply changes that can safely be made in soft upgrade.
0: 		Any changes must not prevent the database from being re-booted
0: 		by the a Cloudscape engine at the older version fromMajorVersionNumber
0: 
0: 	  *
0: 	  * @param	tc	transaction controller
0: 	  * @param	fromMajorVersionNumber	version of the on-disk database
0: 	    @param  lastSoftUpgradeVersion last engine to perform a soft upgrade that made changes.
0: 	  *
0: 	  *	@exception StandardException  Standard Cloudscape error policy.
0: 	  */
0: 	private	void	applySafeChanges(TransactionController tc, int fromMajorVersionNumber, int lastSoftUpgradeVersion)
0: 		throws StandardException
0: 	{
0: 
0: 		if (lastSoftUpgradeVersion <= DataDictionary.DD_VERSION_CS_5_1)
0: 		{
0: 
0: 			// All these soft upgrade actions are new in 5.2 (first ever soft upgrade)
0: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_0)
0: 				modifySysTableNullability(tc,
0: 					DataDictionaryImpl.SYSALIASES_CATALOG_NUM);
0: 
0: 			if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_1)
0: 				modifySysTableNullability(tc,
0: 					DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM);
0: 
0: 		}
0: 
0: 		tc.setProperty(DataDictionary.SOFT_DATA_DICTIONARY_VERSION, this, true);
0: 	}
0: 
0: 	/**
0: 		Do full upgrade.  Apply changes that can NOT be safely made in soft upgrade.
0: 
0: 	  *
0: 	  * @param	tc	transaction controller
0: 	  * @param	fromMajorVersionNumber	version of the on-disk database
0: 	  *
0: 	  *	@exception StandardException  Standard Cloudscape error policy.
0: 	  */
0: 	private	void	doFullUpgrade(TransactionController tc, int fromMajorVersionNumber)
0: 		throws StandardException
0: 	{
0: 		if (fromMajorVersionNumber <= DataDictionary.DD_VERSION_CS_5_1)
0: 		{
0: 			// drop sps in SYSIBM, SYSIBM, recreate SYSIBM, SYSDUMMY1, populate SYSDUMMY1, create procs
0: 			dropJDBCMetadataSPSes(tc, true);
0: 			SchemaDescriptor sd = bootingDictionary.getSchemaDescriptor("SYSIBM", null, false);
0: 			if (sd != null)
0: 				bootingDictionary.dropSchemaDescriptor("SYSIBM", tc);
0: 			sd = bootingDictionary.getSysIBMSchemaDescriptor();
0: 			bootingDictionary.addDescriptor(sd, null, DataDictionary.SYSSCHEMAS_CATALOG_NUM, false, tc);
0: 			bootingDictionary.upgradeMakeCatalog(tc, DataDictionary.SYSDUMMY1_CATALOG_NUM);
0: 			bootingDictionary.populateSYSDUMMY1(tc);
0: 			bootingDictionary.create_SYSIBM_procedures(tc);
0: 			bootingDictionary.createNetworkServerMetadataSps(tc);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Do any work needed for a minor revision change.
0: 	 * For the data dictionary this is always invalidating
0: 	 * stored prepared statements.  When we are done 
0: 	 * with the upgrade, we always recompile all SPSes
0: 	 * so the customer doesn't have to (and isn't going
0: 	 * to get deadlocks because of the recomp).
0: 	 *
0: 	 * @param tc the xact
0: 	 *
0: 	 * @exception StandardException  Standard Cloudscape error policy.
0: 	 */
0: 	private void handleMinorRevisionChange(TransactionController tc, DD_Version fromVersion, boolean softUpgradeRun) 
0: 		throws StandardException
0: 	{
0: 		boolean isReadOnly = bootingDictionary.af.isReadOnly();
0: 
0: 		if (!isReadOnly) {
0: 			bootingDictionary.clearSPSPlans();
0: 
0: 			DD_Version lastRun;
0: 			
0: 			if (softUpgradeRun)
0: 			{
0: 				// log a version that will cause a minor revision change
0: 				// for any subsequent re-boot, including an old Cloudscape version
0: 				fromVersion.minorVersionNumber = 1; // see getJBMSMinorVersionNumber
0: 				lastRun = fromVersion;
0: 			}
0: 			else
0: 			{
0: 				// log the new version
0: 				lastRun = this;
0: 			
0: 				// and change the in-memory version.
0: 				fromVersion.majorVersionNumber = majorVersionNumber;
0: 				fromVersion.minorVersionNumber = minorVersionNumber;
0: 			}
0: 
0: 			tc.setProperty(DataDictionary.CORE_DATA_DICTIONARY_VERSION, fromVersion, true);
0: 		}
0: 		else
0: 		{
0: 			// For a readonly database where we need some kind of upgrade
0: 			// (either minor release or soft upgrade) then since we cannot
0: 			// invalidate all the procedures we need to indicate that
0: 			// any procedure we read off disk is automatically invalid,
0: 			// so we do not try to load the generated class.
0: 			bootingDictionary.readOnlyUpgrade = true;
0: 		}
0: 
0: 		bootingDictionary.clearCaches();
0: 	}
0: 
0: 	/**
0: 	 * Drop all jdbc metadata spses.  This
0: 	 * it to ensure that we don't have any problems
0: 	 * with old metadata queries that have outdated
0: 	 * query text (the plans are always cleared out
0: 	 * on upgrade time).
0: 	 *
0: 	 * @param tc the xact
0: 	 *
0: 	 * @exception StandardException  Standard Cloudscape error policy.
0: 	 */
0: 	protected void dropJDBCMetadataSPSes(TransactionController tc, boolean removeSYSIBMonly)
0: 		throws StandardException
0: 	{
0: 		for (java.util.Iterator it = bootingDictionary.getAllSPSDescriptors().iterator(); it.hasNext(); )
0: 		{
0: 			SPSDescriptor spsd = (SPSDescriptor) it.next();
0: 			SchemaDescriptor sd = spsd.getSchemaDescriptor();
0: 			// need to compare the name, old SYSIBM is not built-in
0: 			boolean isSYSIBM = sd.getSchemaName().equals(SchemaDescriptor.IBM_SYSTEM_SCHEMA_NAME);
0: 			if (! sd.isSystemSchema() && ! isSYSIBM)
0: 				continue;
0: 			/*
0: 			** Is it in SYS? if so, zap it.
0: 			*/
0: 			if ((removeSYSIBMonly && isSYSIBM) || (! removeSYSIBMonly && ! isSYSIBM))
0: 			{
0: 				bootingDictionary.dropSPSDescriptor(spsd, tc);
0: 				bootingDictionary.dropDependentsStoredDependencies(spsd.getUUID(), tc);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0:  	 * Make a catalog.
0: 	 *	@param	tc	TransactionController
0: 	 *  @param  crf CatalogRowFactory for the catalog to drop.
0: 	 *	@exception StandardException  Standard Cloudscape error policy.
0: 	 */
0: 	protected void makeSystemCatalog(TransactionController tc,
0: 									 TabInfo ti)
0: 		throws StandardException
0: 	{
0: 		SchemaDescriptor sd = bootingDictionary.getSystemSchemaDescriptor();
0: 		bootingDictionary.makeCatalog(ti,sd,tc);
0: 	}
0: 
0: 	/**
0: 	  Remove the description of a System table from the data dictionary.
0: 	  This does not delete the conglomerates that hold the catalog or
0: 	  its indexes.
0: 	  @param	tc TransactionController
0: 	  @param    td Table descriptor for the catalog to drop. 
0: 	  @exception StandardException  Standard Cloudscape error policy.
0: 	  */
0: 	protected void
0: 	dropSystemCatalogDescription(TransactionController tc, TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		/* Drop the columns */
0: 		bootingDictionary.dropAllColumnDescriptors(td.getUUID(), tc);
0: 
0: 		/* Drop the conglomerate descriptors */
0: 		bootingDictionary.dropAllConglomerateDescriptors(td, tc);
0: 
0: 		/* Drop table descriptor */
0: 		bootingDictionary.dropTableDescriptor( td, td.getSchemaDescriptor(), tc );
0: 		bootingDictionary.clearCaches();
0: 	}
0: 
0: 	/**
0:  	 * Drop a System catalog.
0: 	 *	@param	tc	TransactionController
0: 	 *  @param  crf CatalogRowFactory for the catalog to drop.
0: 	 *	@exception StandardException  Standard Cloudscape error policy.
0: 	 */
0: 	protected void dropSystemCatalog(TransactionController tc,
0: 							 CatalogRowFactory crf)
0: 		throws StandardException
0: 	{
0: 		SchemaDescriptor		sd = bootingDictionary.getSystemSchemaDescriptor();
0: 		TableDescriptor			td = bootingDictionary.getTableDescriptor(
0: 											crf.getCatalogName(),
0: 											sd);
0: 		ConglomerateDescriptor[]	cds = td.getConglomerateDescriptors();
0: 		for (int index = 0; index < cds.length; index++)
0: 		{
0: 			tc.dropConglomerate(cds[index].getConglomerateNumber());
0: 		}
0: 		dropSystemCatalogDescription(tc,td);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Populates a new system index from the base system table.
0: 	 *
0: 	 *	@param	tc						transaction controller
0: 	 *	@param	heapConglomerateNumber	identifies system table to Store
0: 	 *	@param	tabInfo					describes base system table
0: 	 *	@param	indexNumber				index to populate
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	protected	void	fillIndex
0: 	(
0: 		TransactionController	tc,
0: 		long					heapConglomerateNumber,
0: 		TabInfo					tabInfo,
0: 		int						indexNumber
0:     )
0: 		throws StandardException
0: 	{
0: 		long						indexConglomerateNumber = tabInfo.getIndexConglomerate( indexNumber );
0: 		IndexRowGenerator			indexRowGenerator = tabInfo.getIndexRowGenerator( indexNumber );
0: 		CatalogRowFactory			rowFactory = tabInfo.getCatalogRowFactory();
0: 		ExecRow						heapRow = rowFactory.makeEmptyRow();
0: 		ExecIndexRow				indexableRow = indexRowGenerator.getIndexRowTemplate();
0: 
0: 		ScanController				heapScan =
0: 			tc.openScan(
0: 				heapConglomerateNumber,       // conglomerate to open
0: 				false,                          // don't hold open across commit
0: 				0,                              // for read
0:                 TransactionController.MODE_TABLE,
0:                 TransactionController.ISOLATION_REPEATABLE_READ,
0: 				(FormatableBitSet) null,                 // all fields as objects
0: 				null,                           // start position - first row
0: 				ScanController.GE,              // startSearchOperation
0: 				null,                           //scanQualifier,
0: 				null,                           //stop position-through last row
0: 				ScanController.GT);             // stopSearchOperation
0: 
0: 		RowLocation					heapLocation = 
0:             heapScan.newRowLocationTemplate();
0: 
0: 		ConglomerateController		indexController = 
0: 			tc.openConglomerate( 
0: 				indexConglomerateNumber, 
0:                 false,
0: 				TransactionController.OPENMODE_FORUPDATE,
0: 				TransactionController.MODE_TABLE,
0: 				TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0: 		while ( heapScan.next() )
0:         {
0:             heapScan.fetch( heapRow.getRowArray() );
0: 			heapScan.fetchLocation( heapLocation );
0: 
0: 			indexRowGenerator.getIndexRow( heapRow, heapLocation, indexableRow, (FormatableBitSet) null );
0: 
0: 			indexController.insert(indexableRow.getRowArray());
0: 		}
0: 
0: 		indexController.close();
0: 		heapScan.close();
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	FORMATABLE INTERFACE
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	   Map to the 5.0 version identifier so that 5.0 will understand
0: 	   this object when we write it out in soft upgrade mode.
0: 	   CS 5.0 will de-serialize it correctly.
0: 	   When we are writing out a 5.1 version number we write out
0: 	   the 5.1 version just to ensure no problems.
0: 	   
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{
0: 		return majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?
0: 			StoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;
0: 	}
0: 	/**
0: 	 * Read this object from a stream of stored objects. Set
0: 	 * the minor version.  Ignore the major version.  
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException on error
0: 	 */
0: 	public final void readExternal( ObjectInput in ) throws IOException
0: 	{
0: 		majorVersionNumber = in.readInt();
0: 		minorVersionNumber = in.readInt();
0: 	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects. Write
0: 	 * out the minor version which is bumped across minor release.
0: 	 * Just to be safe, write out the major version too.  This
0: 	 * will allow us to do versioning of a specific Version impl
0: 	 * in the future.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 *
0: 	 * @exception IOException on error
0: 	 */
0: 	public final void writeExternal( ObjectOutput out ) throws IOException
0: 	{ 
0: 		out.writeInt(majorVersionNumber);
0: 		out.writeInt(minorVersionNumber);
0: 	}
0: 	/**
0: 	 * Get the minor version from the JBMS product minor version/maint version.
0: 	 * Bumps it up by 1 if production, or 0 if beta to ensure
0: 	 * minor upgrade across beta.  Starts at 2 because of an
0: 	 * old convention. We use this starting at 2 to allow soft upgrade to
0: 	 * write a version of 1 with the old major number to ensure a minor upgrade
0: 	   when reverting to an old version afer a soft upgrade. E.g run with 5.0.2,
0: 	   then 5.2.1.1, then 5.0.2. Want to ensure 5.0.2 does the minor upgrade.
0: 	 *
0: 	 * @return the minor version
0: 
0: 		For 5.0 and 5.1 the minor number was calculated as
0: 
0: 		jbmsVersion.getMinorVersion()*100 +jbmsVersion.getMaintVersion() + (jbmsVersion.isBeta() ? 0 : 1) + 2
0: 
0: 		5.0.22 => (0*100) + 22 + 2 =  24 - (5.0 has a unique major number)
0: 		5.1.2  => (1*100) + 2 + 2  = 104 - (5.1 has a unique major number) 
0: 
0: 
0: 		With the switch to the four part scheme in 5.2, the maint number now is in increments of one million,
0: 		thus the above scheme could lead to duplicate numbers. Note that the major number may not change
0: 		when the minor external release changes, e.g. 5.2 and 5.3 could share a DD_Version major number.
0: 
0: 		5.2.1.100 => (2*100) + 1000100 + 2 = 1000302
0: 		5.3.1.0   => (3*100) + 1000000 + 2 = 1000302
0: 
0: 		
0: 
0: 	 */
0: 	private int getJBMSMinorVersionNumber() 
0: 	{
0: 		ProductVersionHolder jbmsVersion = Monitor.getMonitor().getEngineVersion();
0: 
0: 		return jbmsVersion.getMinorVersion()*100 +jbmsVersion.getMaintVersion() + (jbmsVersion.isBeta() ? 0 : 1) + 2;
0: 	}
0: 	
0: 	/**
0: 	 * Modifies the nullability of the system table corresponding
0: 	 * to the received catalog number.
0: 	 *
0: 	 * @param tc			TransactionController.
0: 	 * @param catalogNum	The catalog number corresponding
0: 	 *  to the table for which we will modify the nullability.
0: 	 *  If this corresponds to SYSALIASES, then the nullability of
0: 	 *  the SYSALIASES.ALIASINFO column will be changed to true
0: 	 *  (Beetle 4430).  If this corresponds to SYSSTATEMENTS,
0: 	 *  the nullability of the SYSSTATEMENTS.LASTCOMPILED
0: 	 *  column will be changed to true.
0: 	 *
0: 	 * @exception StandardException
0: 	 */
0: 
0: 	private void modifySysTableNullability(TransactionController tc, int catalogNum)
0: 	throws StandardException
0: 	{
0: 
0: 		TabInfo ti = bootingDictionary.getNonCoreTIByNumber(catalogNum);
0: 		CatalogRowFactory rowFactory = ti.getCatalogRowFactory();
0: 		if (catalogNum == DataDictionaryImpl.SYSALIASES_CATALOG_NUM) {
0: 		// SYSALIASES table ==> ALIASINFO needs to be modified.
0: 			bootingDictionary.upgrade_setNullability(rowFactory,
0: 				SYSALIASESRowFactory.SYSALIASES_ALIASINFO, true, tc);
0: 		}
0: 		else if (catalogNum == DataDictionaryImpl.SYSSTATEMENTS_CATALOG_NUM) {
0: 		// SYSSTATEMENTS table ==> LASTCOMPILED needs to be modified.
0: 			bootingDictionary.upgrade_setNullability(rowFactory,
0: 				SYSSTATEMENTSRowFactory.SYSSTATEMENTS_LASTCOMPILED, true, tc);
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 		Check to see if a database has been upgraded to the required
0: 		level in order to use a language feature.
0: 
0: 		@param majorVersion Data Dictionary major version
0: 		@param feature Non-null to throw an error, null to return the state of the version match.
0: 
0: 		@return True if the database has been upgraded to the required level, false otherwise.
0: 	*/
0: 	boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {
0: 
0: 		if (majorVersionNumber < requiredMajorVersion) {
0: 
0: 			if (feature != null)
0: 				throw StandardException.newException(SQLState.LANG_STATEMENT_UPGRADE_REQUIRED, feature,
0: 					DD_Version.majorToString(majorVersionNumber),
0: 					DD_Version.majorToString(requiredMajorVersion));
0: 
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: }
============================================================================