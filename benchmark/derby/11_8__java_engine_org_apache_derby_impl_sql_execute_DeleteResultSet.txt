1:eac0369: /*
11:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.DeleteResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:b31849d: 
1:b31849d: import java.util.Properties;
1:b31849d: import org.apache.derby.iapi.db.TriggerExecutionContext;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b31849d: import org.apache.derby.iapi.reference.SQLState;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.RowChanger;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:b31849d: import org.apache.derby.iapi.types.DataValueDescriptor;
2:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:45da2f5: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * Delete the rows from the specified
1:eac0369:  * base table. This will cause constraints to be checked
1:eac0369:  * and triggers to be executed based on the c's and t's
1:eac0369:  * compiled into the insert plan.
1:eac0369:  */
1:6bc9897: class DeleteResultSet extends DMLWriteResultSet
5:eac0369: {
1:6bc9897: 	private TransactionController   	tc;
1:6bc9897: 	DeleteConstantAction		constants;
1:eac0369: 	protected  NoPutResultSet			source;
1:6bc9897: 	NoPutResultSet			savedSource;
1:eac0369: 	int 							numIndexes;
1:eac0369: 	protected RowChanger 			rc;
1:6bc9897: 	private ExecRow					row;
1:eac0369: 
1:eac0369: 	protected ConglomerateController	deferredBaseCC;
1:eac0369: 
1:eac0369: 	protected TemporaryRowHolderImpl	rowHolder;
1:eac0369: 
1:eac0369: 	private int						numOpens; // number of opens w/o a close
1:eac0369: 	private boolean 				firstExecute;
1:eac0369: 
1:eac0369: 	// cached across opens()s
1:eac0369: 	private FormatableBitSet 				baseRowReadList; 
1:eac0369: 	private int						rlColumnNumber;
1:eac0369: 	protected FKInfo[]				fkInfoArray;
1:eac0369: 	private TriggerInfo 			triggerInfo;
1:eac0369: 	private	RISetChecker			fkChecker;
1:eac0369: 	private TriggerEventActivator	triggerActivator;
1:eac0369: 	private boolean					noTriggersOrFks;
1:eac0369: 
1:eac0369: 	ExecRow		deferredSparseRow; 
1:eac0369: 	ExecRow		deferredBaseRow;
1:eac0369: 	int lockMode; 
1:eac0369: 	protected  boolean cascadeDelete;
3:eac0369: 	ExecRow		deferredRLRow = null;
1:eac0369: 	int	numberOfBaseColumns = 0;
1:c69c8b0: 
1:eac0369:     /*
1:eac0369:      * class interface
1:eac0369:      *
1:c69c8b0:      */
1:6bc9897:     DeleteResultSet
1:eac0369: 	(
1:eac0369: 		NoPutResultSet		source,
1:eac0369: 		Activation			activation
1:eac0369: 	)
1:18a6fb2: 		throws StandardException
1:c69c8b0:     {
1:eac0369: 		this(source, activation.getConstantAction(), activation);
1:c69c8b0: 	}
1:45da2f5:     /**
1:eac0369:      * REMIND: At present this takes just the conglomerate id
1:eac0369:      * of the table. We can expect this to expand to include
1:eac0369:      * passing information about triggers, constraints, and
1:eac0369:      * any additional conglomerates on the underlying table
1:eac0369:      * for access methods.
1:eac0369:      *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:6bc9897:     DeleteResultSet
1:eac0369: 	(
1:eac0369: 		NoPutResultSet		source,
1:eac0369: 		ConstantAction		passedInConstantAction,
1:eac0369: 		Activation			activation
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		super(activation, passedInConstantAction);
1:eac0369: 		this.source = source;
1:eac0369: 
1:eac0369: 		tc = activation.getTransactionController();
1:eac0369: 		constants = (DeleteConstantAction) constantAction;
1:4119c42: 		fkInfoArray = constants.getFKInfo();
1:4119c42: 		triggerInfo = constants.getTriggerInfo();
1:eac0369: 		noTriggersOrFks = ((fkInfoArray == null) && (triggerInfo == null));
1:eac0369: 		baseRowReadList = constants.getBaseRowReadList();
1:eac0369: 		if(source != null)
1:c69c8b0: 			resultDescription = source.getResultDescription();
2:eac0369: 		else
1:eac0369: 			resultDescription = constants.resultDescription;
1:eac0369: 
5:eac0369: 	}
1:eac0369: 
1:c69c8b0: 	/**
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:45da2f5:     @Override
1:eac0369: 	public void open() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		setup();
1:eac0369: 		boolean rowsFound = collectAffectedRows(); //this call also deletes rows , if not deferred
1:eac0369: 		if (! rowsFound)
1:eac0369: 		{
1:eac0369: 			activation.addWarning(
1:eac0369: 						StandardException.newWarning(
1:eac0369: 							SQLState.LANG_NO_ROW_FOUND));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If the delete is deferred, scan the temporary conglomerate to
1:eac0369: 		** get the RowLocations of the rows to be deleted.  Re-fetch the
1:eac0369: 		** rows and delete them using the RowChanger.
1:eac0369: 		*/
1:eac0369: 		if (constants.deferred)
1:eac0369: 		{
1:45da2f5:             runFkChecker(true); // check for only RESTRICT referential
1:18a6fb2:                                       // action rule violations
1:eac0369: 			fireBeforeTriggers();
1:45da2f5:             deleteDeferredRows();
1:45da2f5:             runFkChecker(false); //check for all constraint violations
1:eac0369: 			// apply 
1:eac0369: 			rc.finish();
1:eac0369: 			fireAfterTriggers();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	
1:eac0369: 		/* Cache query plan text for source, before it gets blown away */
1:eac0369: 		if (lcc.getRunTimeStatisticsMode())
1:eac0369: 		{
1:eac0369: 			/* savedSource nulled after run time statistics generation */
1:eac0369: 			savedSource = source;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		cleanUp();
1:eac0369: 		endTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369:     }
1:eac0369: 	
1:eac0369: 
1:eac0369: 	//this routine open the source and find the dependent rows 
1:45da2f5:     @Override
1:eac0369: 	void  setup() throws StandardException
1:eac0369: 	{
1:6369b54: 		super.setup();
1:eac0369: 
1:eac0369: 		// Remember if this is the 1st execution
1:eac0369: 		firstExecute = (rc == null);
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 			//open the source for the parent tables
1:eac0369: 			if (numOpens++ == 0)
1:eac0369: 			{
1:eac0369: 				source.openCore();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369:         		source.reopenCore();
1:eac0369: 			}
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			activation.checkStatementValidity();
1:eac0369: 			throw se;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		activation.checkStatementValidity();
1:eac0369: 
1:eac0369: 		/* Get or re-use the row changer.
1:eac0369: 		 */
1:eac0369: 		if (firstExecute)
1:eac0369: 		{
1:eac0369: 			rc = lcc.getLanguageConnectionFactory().getExecutionFactory().
1:eac0369: 					     getRowChanger( 
1:eac0369: 								constants.conglomId,
2:eac0369: 								constants.heapSCOCI, 
1:eac0369: 								heapDCOCI,
1:eac0369: 								constants.irgs,
1:eac0369: 								constants.indexCIDS,
1:eac0369: 								constants.indexSCOCIs,
1:eac0369: 							    indexDCOCIs,
1:eac0369: 								constants.numColumns,
2:eac0369: 								tc,
1:eac0369: 								(int[])null,
1:eac0369: 								baseRowReadList,
1:eac0369: 								constants.getBaseRowReadMap(),
1:eac0369: 								constants.getStreamStorableHeapColIds(),
1:eac0369: 								activation);
1:eac0369: 		}
1:300bbeb: 
1:eac0369: 		/* decode the lock mode for the execution isolation level */
1:6369b54: 		lockMode = decodeLockMode(constants.lockMode);
1:eac0369: 
1:eac0369: 		/* Open the RowChanger before the source ResultSet so that
1:eac0369: 		 * the store will see the RowChanger's lock as a covering lock
1:eac0369: 		 * if it is a table lock.
1:eac0369: 		 */
1:eac0369: 		rc.open(lockMode); 
1:eac0369: 
1:eac0369: 		/* The source does not know whether or not we are doing a
1:eac0369: 		 * deferred mode delete.  If we are, then we must clear the
1:eac0369: 		 * index scan info from the activation so that the row changer
1:eac0369: 		 * does not re-use that information (which won't be valid for
1:eac0369: 		 * a deferred mode delete).
1:eac0369: 		 */
1:eac0369: 		if (constants.deferred || cascadeDelete)
1:eac0369: 		{
1:eac0369: 			activation.clearIndexScanInfo();
1:eac0369: 		}
1:eac0369: 
1:7fb9956:         rowCount = 0L;
1:eac0369:         if(!cascadeDelete)
1:eac0369: 			row = getNextRowCore(source);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** We need the number of columns even if there are
1:eac0369: 		** no rows. Note that source.ressultDescription() may 
1:eac0369: 		** be null on a rep target doing a refresh.
1:eac0369: 		*/
1:eac0369: 		if (resultDescription == null)
1:eac0369: 		{
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** We NEED a result description when we are going to
1:eac0369: 				** to have to kick off a trigger.  In a replicated environment
1:eac0369: 				** we don't get a result description when we are replaying
1:eac0369: 				** source xacts on the target, but we shouldn't be firing
1:eac0369: 				** a trigger in that case anyway.
1:eac0369: 				*/
1:eac0369: 				SanityManager.ASSERT(triggerInfo == null, "result description is needed to supply to trigger result sets");
1:eac0369: 			}
1:eac0369: 			numberOfBaseColumns = (row == null) ? 0 : row.nColumns();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			numberOfBaseColumns = resultDescription.getColumnCount();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		numIndexes = constants.irgs.length;
1:eac0369: 
1:eac0369: 		if (constants.deferred || cascadeDelete)
1:eac0369: 		{
1:eac0369: 			Properties properties = new Properties();
1:eac0369: 
1:eac0369: 			// Get the properties on the old heap
1:eac0369: 			rc.getHeapConglomerateController().getInternalTablePropertySet(properties);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If deferred and fk or trigger, we are going to grab
1:eac0369: 			** the entire row.  
1:eac0369: 			**
1:eac0369: 			** If we are deferred w/o a fk, then we only
1:eac0369: 			** save the row location.
1:eac0369: 			*/
1:eac0369: 			deferredRLRow = RowUtil.getEmptyValueRow(1, lcc);
1:eac0369: 			rlColumnNumber = noTriggersOrFks ? 1: numberOfBaseColumns;
1:eac0369: 			if(cascadeDelete)
1:eac0369: 			{
1:81b9853: 				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
1:c69c8b0: 						(resultDescription != null) ?
1:c69c8b0: 							resultDescription.truncateColumns(rlColumnNumber) :
1:c69c8b0: 							null, false);
1:eac0369: 
1:eac0369: 
1:eac0369: 			}else
1:eac0369: 			{
1:eac0369: 
1:c69c8b0: 				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
1:c69c8b0: 						(resultDescription != null) ?
1:c69c8b0: 							resultDescription.truncateColumns(rlColumnNumber) :
1:c69c8b0: 							null);
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			rc.setRowHolder(rowHolder);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (fkInfoArray != null)
1:eac0369: 		{
1:eac0369: 			if (fkChecker == null)
1:eac0369: 			{
1:4cc0287:                 fkChecker = new RISetChecker(lcc, tc, fkInfoArray);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				fkChecker.reopen();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	boolean  collectAffectedRows() throws StandardException
1:eac0369: 	{	
1:eac0369: 
1:eac0369: 		DataValueDescriptor		rlColumn;
1:eac0369: 		RowLocation	baseRowLocation;
1:eac0369: 		boolean rowsFound = false;
1:eac0369: 
1:eac0369: 		if(cascadeDelete)
1:eac0369: 			row = getNextRowCore(source);
1:eac0369: 
1:eac0369: 		while ( row != null )
1:eac0369: 		{
1:508a010: 			/* By convention, the last column for a delete contains a data value
1:508a010: 			 * wrapping the RowLocation of the row to be deleted.  If we're
1:eac0369: 			 * doing a deferred delete, store the RowLocations in the
1:eac0369: 			 * temporary conglomerate.  If we're not doing a deferred delete,
1:eac0369: 			 * just delete the rows immediately.
1:eac0369: 			 */
1:eac0369: 
1:eac0369: 			rowsFound = true;
1:eac0369: 
1:eac0369: 			rlColumn = row.getColumn( row.nColumns() );
1:eac0369: 		
1:eac0369: 			if (constants.deferred || cascadeDelete)
1:eac0369: 			{
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If we are deferred because of a trigger or foreign
1:eac0369: 				** key, we need to save off the entire row.  Otherwise,
1:eac0369: 				** we just save the RID.
1:eac0369: 				*/
1:eac0369: 				if (noTriggersOrFks)
1:eac0369: 				{
1:eac0369: 					deferredRLRow.setColumn(1, rlColumn);
1:eac0369: 					rowHolder.insert(deferredRLRow);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					rowHolder.insert(row);
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				/*
1:eac0369: 				** If we haven't already, lets get a template to
1:eac0369: 				** use as a template for our rescan of the base table.
1:eac0369: 				** Do this now while we have a real row to use
1:eac0369: 				** as a copy.
1:eac0369: 				**
1:eac0369: 				** There is one less column in the base row than
1:eac0369: 				** there is in source row, because the base row
1:eac0369: 				** doesn't contain the row location.
1:eac0369: 				*/
1:eac0369: 				if (deferredBaseRow == null)
1:eac0369: 				{
1:eac0369: 					deferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns - 1, lcc);
1:eac0369: 			
1:eac0369: 					RowUtil.copyCloneColumns(deferredBaseRow, row, 
1:eac0369: 											numberOfBaseColumns - 1);
1:eac0369: 					deferredSparseRow = makeDeferredSparseRow(deferredBaseRow,
1:eac0369: 																baseRowReadList,
1:eac0369: 																lcc);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (fkChecker != null)
1:eac0369: 				{
1:18a6fb2:                     // Argument "2" below: If a PK referenced by an FK is
1:18a6fb2:                     // deferred, require at least two rows to be present in the
1:18a6fb2:                     // primary table since we are deleting one of them below,
1:18a6fb2:                     // and we need at least one to fulfill the constraint.
1:45da2f5:                     fkChecker.doPKCheck(activation, row, false, 2);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				baseRowLocation = 
1:eac0369: 					(RowLocation) (rlColumn).getObject();
1:eac0369: 
1:508a010:                 if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(baseRowLocation != null,
1:eac0369: 							"baseRowLocation is null");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				rc.deleteRow(row,baseRowLocation);
1:2700e3d: 				source.markRowAsDeleted();
1:eac0369: 			}
1:eac0369: 
1:eac0369:             rowCount++;
1:eac0369: 
1:eac0369: 			// No need to do a next on a single row source
1:eac0369: 			if (constants.singleRowSource)
1:eac0369: 			{
1:eac0369: 				row = null;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				row = getNextRowCore(source);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return rowsFound;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// execute the before triggers set on the table
1:eac0369:     void fireBeforeTriggers() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (triggerInfo != null)
1:eac0369: 		{
1:eac0369: 			if (triggerActivator == null)
1:eac0369: 			{
1:eac0369: 				triggerActivator = new TriggerEventActivator(lcc, 
1:eac0369: 															 constants.targetUUID,
1:eac0369: 															 triggerInfo,
1:eac0369: 															 TriggerExecutionContext.DELETE_EVENT,
1:eac0369: 															 activation, null
1:eac0369: 															 );
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				triggerActivator.reopen();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// fire BEFORE trigger
1:eac0369: 			triggerActivator.notifyEvent(TriggerEvents.BEFORE_DELETE, 
1:eac0369: 										 rowHolder.getResultSet(), 
1:d9d1bc8: 										 (CursorResultSet)null,
1:d9d1bc8: 										 constants.getBaseRowReadMap());
1:ddf1ea6: 			triggerActivator.cleanup();
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//execute the after triggers set on the table.
1:eac0369: 	void fireAfterTriggers() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		// fire AFTER trigger
2:eac0369: 		if (triggerActivator != null)
1:eac0369: 		{
1:ddf1ea6: 			triggerActivator.reopen();
1:eac0369: 			triggerActivator.notifyEvent(TriggerEvents.AFTER_DELETE, 
1:eac0369: 										 rowHolder.getResultSet(),
1:d9d1bc8: 										 (CursorResultSet)null,
1:d9d1bc8: 										 constants.getBaseRowReadMap());
1:eac0369: 			triggerActivator.cleanup();
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//delete the rows that in case deferred case and
1:eac0369: 	//during cascade delete (All deletes are deferred during cascade action)
1:eac0369: 	void deleteDeferredRows() throws StandardException
1:eac0369: 	{
1:eac0369: 		
1:eac0369: 		DataValueDescriptor		rlColumn;
1:eac0369:  		RowLocation	baseRowLocation;
1:801cf0d:         ExecRow     defRLRow;
1:eac0369: 
1:801cf0d:         deferredBaseCC = tc.openCompiledConglomerate(
1:801cf0d:                 false,
1:801cf0d:                 (TransactionController.OPENMODE_FORUPDATE|
1:801cf0d:                  TransactionController.OPENMODE_SECONDARY_LOCKED),
1:801cf0d:                 lockMode,
1:801cf0d:                 TransactionController.ISOLATION_SERIALIZABLE,
1:801cf0d:                 constants.heapSCOCI,
1:801cf0d:                 heapDCOCI);
1:eac0369: 			
1:eac0369: 		CursorResultSet rs = rowHolder.getResultSet();
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** We need to do a fetch doing a partial row
1:eac0369: 			** read.  We need to shift our 1-based bit
1:eac0369: 			** set to a zero based bit set like the store
1:eac0369: 			** expects.
1:eac0369: 			*/
1:eac0369: 			FormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);
1:eac0369: 
1:eac0369: 			rs.open();
1:801cf0d:             while ((defRLRow = rs.getNextRow()) != null)
1:eac0369: 			{
1:801cf0d:                 rlColumn = defRLRow.getColumn(rlColumnNumber);
1:eac0369: 				baseRowLocation = 
1:eac0369: 					(RowLocation) (rlColumn).getObject();
1:801cf0d: 	
1:eac0369: 				/* Get the base row at the given RowLocation */
1:eac0369: 				boolean row_exists = 
1:eac0369: 					deferredBaseCC.fetch(
1:eac0369: 										 baseRowLocation, deferredSparseRow.getRowArray(), 
1:eac0369: 										 readBitSet);
1:eac0369: 
1:eac0369: 				// In case of cascade delete , things like before triggers can delete 
1:eac0369: 				// the rows before the dependent result get a chance to delete
1:eac0369: 				if(cascadeDelete && !row_exists)
1:eac0369: 					continue;
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					if (!row_exists)
1:eac0369: 					{
1:eac0369:                         	SanityManager.THROWASSERT("could not find row "+baseRowLocation);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 	
1:eac0369: 				rc.deleteRow(deferredBaseRow, baseRowLocation);
1:2700e3d: 				source.markRowAsDeleted();
1:eac0369: 			}
1:eac0369: 		} finally
1:eac0369: 		{
1:eac0369: 				rs.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:45da2f5:      * Make sure foreign key constraints are not violated
1:45da2f5:      */
1:45da2f5:     void runFkChecker(boolean restrictCheckOnly)
1:eac0369:             throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (fkChecker != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Second scan to make sure all the foreign key
1:eac0369: 			** constraints are ok.  We have to do this after
1:eac0369: 			** we have completed the deletes in case of self referencing
1:eac0369: 			** constraints.
1:eac0369: 			*/
1:eac0369: 			CursorResultSet rs = rowHolder.getResultSet();
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				rs.open();
1:eac0369: 
1:801cf0d:                 ExecRow defRLRow;
1:18a6fb2: 
1:801cf0d:                 while ((defRLRow = rs.getNextRow()) != null)
1:eac0369: 				{
1:18a6fb2:                     // Argument "1" below: If a PK referenced by an FK is
1:18a6fb2:                     // deferred, require at least one to be present in the
1:18a6fb2:                     // primary table since we have deleted the row unless
1:18a6fb2:                     // postCheck == true, in which the call to postChecks does
1:18a6fb2:                     // the actual checking, and we need at least one to fulfill
1:18a6fb2:                     // the constraint.
1:4cc0287:                     fkChecker.doPKCheck(
1:18a6fb2:                             activation,
1:18a6fb2:                             defRLRow,
1:18a6fb2:                             restrictCheckOnly,
1:18a6fb2:                             1);
1:eac0369: 				}
1:18a6fb2: 
1:45da2f5:                 if (restrictCheckOnly) {
1:18a6fb2:                     fkChecker.postCheck();
1:18a6fb2:                 }
1:18a6fb2: 
1:eac0369: 			} finally
1:eac0369: 			{
1:eac0369: 				rs.close();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	create a source for the dependent table
1:eac0369: 	  *
1:eac0369: 	  * <P>Delete Cascade ResultSet class will override this method.
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	NoPutResultSet createDependentSource(RowChanger rc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#cleanUp
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:801cf0d:     @Override
1:eac0369: 	public void	cleanUp() throws StandardException
1:eac0369: 	{ 
1:eac0369: 		numOpens = 0;
1:eac0369: 
1:eac0369: 		/* Close down the source ResultSet tree */
1:eac0369: 		if (source != null)
1:eac0369: 		{
1:eac0369: 			source.close();
1:eac0369: 			// source is reused across executions
1:eac0369: 		}
1:eac0369: 		if (rc != null)
1:eac0369: 		{
1:eac0369: 			rc.close();
1:eac0369: 			// rc is reused across executions
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (rowHolder != null)
1:eac0369: 		{
1:eac0369: 			rowHolder.close();
1:eac0369: 			// rowHolder is reused across executions
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (fkChecker != null)
1:eac0369: 		{
1:eac0369: 			fkChecker.close();
1:eac0369: 			// fkcheckers is reused across executions
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (deferredBaseCC != null)
1:eac0369: 			deferredBaseCC.close();
1:eac0369: 		deferredBaseCC = null;
1:eac0369: 
1:67549f0: 		if (rc != null) {
1:67549f0: 			rc.close();
1:67549f0: 		}
1:01632c2: 		close();
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     @Override
1:01632c2:     public void close() throws StandardException
1:01632c2:     {
1:45da2f5:         super.close( constants.underMerge() );
1:01632c2:     }
1:01632c2:                                
1:801cf0d:     @Override
1:eac0369: 	public void finish() throws StandardException {
1:eac0369: 		if (source != null)
1:eac0369: 			source.finish();
1:eac0369: 		super.finish();
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:bedbcf2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:45da2f5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             runFkChecker(true); // check for only RESTRICT referential
1:             deleteDeferredRows();
1:             runFkChecker(false); //check for all constraint violations
/////////////////////////////////////////////////////////////////////////
1:                     fkChecker.doPKCheck(activation, row, false, 2);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure foreign key constraints are not violated
1:      */
1:     void runFkChecker(boolean restrictCheckOnly)
/////////////////////////////////////////////////////////////////////////
1:                 if (restrictCheckOnly) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         super.close( constants.underMerge() );
commit:18a6fb2
/////////////////////////////////////////////////////////////////////////
0:             runFkChecker(true, true); // check for only RESTRICT referential
1:                                       // action rule violations
0:             runFkChecker(false, false); //check for all constraint violations
/////////////////////////////////////////////////////////////////////////
1:                     // Argument "2" below: If a PK referenced by an FK is
1:                     // deferred, require at least two rows to be present in the
1:                     // primary table since we are deleting one of them below,
1:                     // and we need at least one to fulfill the constraint.
0:                     fkChecker.doPKCheck(activation, row, false, false, 2);
/////////////////////////////////////////////////////////////////////////
0:     void runFkChecker(boolean restrictCheckOnly, boolean postCheck)
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // Argument "1" below: If a PK referenced by an FK is
1:                     // deferred, require at least one to be present in the
1:                     // primary table since we have deleted the row unless
1:                     // postCheck == true, in which the call to postChecks does
1:                     // the actual checking, and we need at least one to fulfill
1:                     // the constraint.
1:                             activation,
1:                             defRLRow,
1:                             restrictCheckOnly,
0:                             postCheck,
1:                             1);
1: 
0:                 if (postCheck) {
1:                     fkChecker.postCheck();
1:                 }
1: 
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:                 fkChecker = new RISetChecker(lcc, tc, fkInfoArray);
/////////////////////////////////////////////////////////////////////////
0:                     fkChecker.doPKCheck(activation, row, false);
/////////////////////////////////////////////////////////////////////////
1:                     fkChecker.doPKCheck(
0:                         activation, defRLRow, restrictCheckOnly);
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         ExecRow     defRLRow;
1:         deferredBaseCC = tc.openCompiledConglomerate(
1:                 false,
1:                 (TransactionController.OPENMODE_FORUPDATE|
1:                  TransactionController.OPENMODE_SECONDARY_LOCKED),
1:                 lockMode,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 constants.heapSCOCI,
1:                 heapDCOCI);
/////////////////////////////////////////////////////////////////////////
1:             while ((defRLRow = rs.getNextRow()) != null)
1:                 rlColumn = defRLRow.getColumn(rlColumnNumber);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:                 ExecRow defRLRow;
1:                 while ((defRLRow = rs.getNextRow()) != null)
0:                     fkChecker.doPKCheck(defRLRow, restrictCheckOnly);
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 		close();
1:     public void close() throws StandardException
1:     {
0:         close( constants.underMerge() );
1:     }
1:                                
0:     @Override
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: 			/* By convention, the last column for a delete contains a data value
1: 			 * wrapping the RowLocation of the row to be deleted.  If we're
/////////////////////////////////////////////////////////////////////////
1:                 if (SanityManager.DEBUG)
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1:         rowCount = 0L;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c67f5dd
/////////////////////////////////////////////////////////////////////////
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: 	/**
0:      * Returns the description of the deleted rows.
0:      * REVISIT: Do we want this to return NULL instead?
1: 	 */
0: 	public ResultDescription getResultDescription()
1: 	{
0: 	    return resultDescription;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 			resultDescription = source.getResultDescription();
/////////////////////////////////////////////////////////////////////////
1: 						(resultDescription != null) ?
1: 							resultDescription.truncateColumns(rlColumnNumber) :
1: 							null, false);
1: 				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
1: 						(resultDescription != null) ?
1: 							resultDescription.truncateColumns(rlColumnNumber) :
1: 							null);
commit:300bbeb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:6369b54
/////////////////////////////////////////////////////////////////////////
1: 		super.setup();
/////////////////////////////////////////////////////////////////////////
1: 		lockMode = decodeLockMode(constants.lockMode);
commit:67549f0
/////////////////////////////////////////////////////////////////////////
1: 		if (rc != null) {
1: 			rc.close();
1: 		}
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 				source.markRowAsDeleted();
/////////////////////////////////////////////////////////////////////////
1: 				source.markRowAsDeleted();
commit:81b9853
/////////////////////////////////////////////////////////////////////////
1: 				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
/////////////////////////////////////////////////////////////////////////
0: 				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
1: 										 (CursorResultSet)null,
1: 										 constants.getBaseRowReadMap());
/////////////////////////////////////////////////////////////////////////
1: 										 (CursorResultSet)null,
1: 										 constants.getBaseRowReadMap());
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:24e3f7e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			resultDescription = activation.getResultDescription();
commit:88bb146
/////////////////////////////////////////////////////////////////////////
0: 						 false);
0: 				rowHolder = new TemporaryRowHolderImpl(activation, properties);
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.db.TriggerExecutionContext;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.RowChanger;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
commit:4119c42
/////////////////////////////////////////////////////////////////////////
1: 		fkInfoArray = constants.getFKInfo();
1: 		triggerInfo = constants.getTriggerInfo();
commit:6bc9897
/////////////////////////////////////////////////////////////////////////
1: class DeleteResultSet extends DMLWriteResultSet
1: 	private TransactionController   	tc;
1: 	DeleteConstantAction		constants;
1: 	NoPutResultSet			savedSource;
1: 	private ExecRow					row;
/////////////////////////////////////////////////////////////////////////
1:     DeleteResultSet
/////////////////////////////////////////////////////////////////////////
1:     DeleteResultSet
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.DeleteResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: 
1: /**
1:  * Delete the rows from the specified
1:  * base table. This will cause constraints to be checked
1:  * and triggers to be executed based on the c's and t's
1:  * compiled into the insert plan.
1:  */
0: public class DeleteResultSet extends DMLWriteResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public TransactionController   	tc;
0: 	public DeleteConstantAction		constants;
0:     protected ResultDescription 				resultDescription;
1: 	protected  NoPutResultSet			source;
0: 	public  NoPutResultSet			savedSource;
1: 	int 							numIndexes;
1: 	protected RowChanger 			rc;
0: 	public ExecRow					row;
1: 
1: 	protected ConglomerateController	deferredBaseCC;
0: 	public		LanguageConnectionContext lcc;
1: 
1: 	protected TemporaryRowHolderImpl	rowHolder;
1: 
1: 	private int						numOpens; // number of opens w/o a close
1: 	private boolean 				firstExecute;
1: 
1: 	// cached across opens()s
1: 	private FormatableBitSet 				baseRowReadList; 
1: 	private int						rlColumnNumber;
1: 	protected FKInfo[]				fkInfoArray;
1: 	private TriggerInfo 			triggerInfo;
1: 	private	RISetChecker			fkChecker;
1: 	private TriggerEventActivator	triggerActivator;
1: 	private boolean					noTriggersOrFks;
1: 
1: 	ExecRow		deferredSparseRow; 
1: 	ExecRow		deferredBaseRow;
1: 	int lockMode; 
1: 	protected  boolean cascadeDelete;
1: 	ExecRow		deferredRLRow = null;
1: 	int	numberOfBaseColumns = 0;
1: 
1: 	/**
0:      * Returns the description of the deleted rows.
0:      * REVISIT: Do we want this to return NULL instead?
1: 	 */
0: 	public ResultDescription getResultDescription()
1: 	{
0: 	    return resultDescription;
1: 	}
1: 
1:     /*
1:      * class interface
1:      *
1:      */
0:     public DeleteResultSet
1: 	(
1: 		NoPutResultSet		source,
1: 		Activation			activation
1: 	)
1: 		throws StandardException
1:     {
1: 		this(source, activation.getConstantAction(), activation);
1: 	}
1:     /**
1:      * REMIND: At present this takes just the conglomerate id
1:      * of the table. We can expect this to expand to include
1:      * passing information about triggers, constraints, and
1:      * any additional conglomerates on the underlying table
1:      * for access methods.
1:      *
1: 	 * @exception StandardException		Thrown on error
1:      */
0:     protected DeleteResultSet
1: 	(
1: 		NoPutResultSet		source,
1: 		ConstantAction		passedInConstantAction,
1: 		Activation			activation
1: 	)
1: 		throws StandardException
1:     {
1: 		super(activation, passedInConstantAction);
1: 		this.source = source;
1: 
0: 		lcc = activation.getLanguageConnectionContext();
1: 		tc = activation.getTransactionController();
1: 		constants = (DeleteConstantAction) constantAction;
0: 		fkInfoArray = constants.getFKInfo( lcc.getExecutionContext() );
0: 		triggerInfo = constants.getTriggerInfo(lcc.getExecutionContext());
1: 		noTriggersOrFks = ((fkInfoArray == null) && (triggerInfo == null));
1: 		baseRowReadList = constants.getBaseRowReadList();
1: 		if(source != null)
0: 			resultDescription = source.getResultDescription();
1: 		else
1: 			resultDescription = constants.resultDescription;
1: 
1: 	}
1: 
1: 	/**
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public void open() throws StandardException
1: 	{
1: 
1: 		setup();
1: 		boolean rowsFound = collectAffectedRows(); //this call also deletes rows , if not deferred
1: 		if (! rowsFound)
1: 		{
1: 			activation.addWarning(
1: 						StandardException.newWarning(
1: 							SQLState.LANG_NO_ROW_FOUND));
1: 		}
1: 
1: 		/*
1: 		** If the delete is deferred, scan the temporary conglomerate to
1: 		** get the RowLocations of the rows to be deleted.  Re-fetch the
1: 		** rows and delete them using the RowChanger.
1: 		*/
1: 		if (constants.deferred)
1: 		{
0: 			runFkChecker(true); //check for only RESTRICT referential action rule violations
1: 			fireBeforeTriggers();
0: 			deleteDeferredRows();
0: 			runFkChecker(false); //check for all constraint violations
1: 			// apply 
1: 			rc.finish();
1: 			fireAfterTriggers();
1: 		}
1: 
1: 	
1: 		/* Cache query plan text for source, before it gets blown away */
1: 		if (lcc.getRunTimeStatisticsMode())
1: 		{
1: 			/* savedSource nulled after run time statistics generation */
1: 			savedSource = source;
1: 		}
1: 
1: 		cleanUp();
1: 		endTime = getCurrentTimeMillis();
1: 
1:     }
1: 	
1: 
1: 	//this routine open the source and find the dependent rows 
1: 	void  setup() throws StandardException
1: 	{
1: 
1: 		// Remember if this is the 1st execution
1: 		firstExecute = (rc == null);
1: 
1: 		try {
1: 
1: 			//open the source for the parent tables
1: 			if (numOpens++ == 0)
1: 			{
1: 				source.openCore();
1: 			}
1: 			else
1: 			{
1:         		source.reopenCore();
1: 			}
1: 		} catch (StandardException se) {
1: 			activation.checkStatementValidity();
1: 			throw se;
1: 
1: 		}
1: 
1: 		activation.checkStatementValidity();
1: 
1: 		/* Get or re-use the row changer.
0: 		 * NOTE: We need to set ourself as the top result set
0: 		 * if this is not the 1st execution.  (Done in constructor
0: 		 * for 1st execution.)
1: 		 */
1: 		if (firstExecute)
1: 		{
1: 			rc = lcc.getLanguageConnectionFactory().getExecutionFactory().
1: 					     getRowChanger( 
1: 								constants.conglomId,
1: 								constants.heapSCOCI, 
1: 								heapDCOCI,
1: 								constants.irgs,
1: 								constants.indexCIDS,
1: 								constants.indexSCOCIs,
1: 							    indexDCOCIs,
1: 								constants.numColumns,
1: 								tc,
1: 								(int[])null,
1: 								baseRowReadList,
1: 								constants.getBaseRowReadMap(),
1: 								constants.getStreamStorableHeapColIds(),
1: 								activation);
1: 		}
1: 		else
1: 		{
0: 			lcc.getStatementContext().setTopResultSet(this, subqueryTrackingArray);
1: 		}
1: 		/* decode the lock mode for the execution isolation level */
0: 		lockMode = UpdateResultSet.decodeLockMode(lcc, constants.lockMode);
1: 
1: 		/* Open the RowChanger before the source ResultSet so that
1: 		 * the store will see the RowChanger's lock as a covering lock
1: 		 * if it is a table lock.
1: 		 */
1: 		rc.open(lockMode); 
1: 
1: 		/* The source does not know whether or not we are doing a
1: 		 * deferred mode delete.  If we are, then we must clear the
1: 		 * index scan info from the activation so that the row changer
1: 		 * does not re-use that information (which won't be valid for
1: 		 * a deferred mode delete).
1: 		 */
1: 		if (constants.deferred || cascadeDelete)
1: 		{
1: 			activation.clearIndexScanInfo();
1: 		}
1: 
0:         rowCount = 0;
1:         if(!cascadeDelete)
1: 			row = getNextRowCore(source);
1: 
1: 		/*
1: 		** We need the number of columns even if there are
1: 		** no rows. Note that source.ressultDescription() may 
1: 		** be null on a rep target doing a refresh.
1: 		*/
1: 		if (resultDescription == null)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				/*
1: 				** We NEED a result description when we are going to
1: 				** to have to kick off a trigger.  In a replicated environment
1: 				** we don't get a result description when we are replaying
1: 				** source xacts on the target, but we shouldn't be firing
1: 				** a trigger in that case anyway.
1: 				*/
1: 				SanityManager.ASSERT(triggerInfo == null, "result description is needed to supply to trigger result sets");
1: 			}
1: 			numberOfBaseColumns = (row == null) ? 0 : row.nColumns();
1: 		}
1: 		else
1: 		{
1: 			numberOfBaseColumns = resultDescription.getColumnCount();
1: 		}
1: 
1: 		numIndexes = constants.irgs.length;
1: 
1: 		if (constants.deferred || cascadeDelete)
1: 		{
1: 			Properties properties = new Properties();
1: 
1: 			// Get the properties on the old heap
1: 			rc.getHeapConglomerateController().getInternalTablePropertySet(properties);
1: 
1: 			/*
1: 			** If deferred and fk or trigger, we are going to grab
1: 			** the entire row.  
1: 			**
1: 			** If we are deferred w/o a fk, then we only
1: 			** save the row location.
1: 			*/
1: 			deferredRLRow = RowUtil.getEmptyValueRow(1, lcc);
1: 			rlColumnNumber = noTriggersOrFks ? 1: numberOfBaseColumns;
1: 			if(cascadeDelete)
1: 			{
0: 				rowHolder = new TemporaryRowHolderImpl(tc, properties, 
0: 						(resultDescription != null) ?
0: 							resultDescription.truncateColumns(rlColumnNumber) :
0: 							null, false);
1: 
1: 
1: 			}else
1: 			{
1: 
0: 				rowHolder = new TemporaryRowHolderImpl(tc, properties, 
0: 						(resultDescription != null) ?
0: 							resultDescription.truncateColumns(rlColumnNumber) :
0: 							null);
1: 
1: 			}
1: 
1: 			rc.setRowHolder(rowHolder);
1: 		}
1: 
1: 		if (fkInfoArray != null)
1: 		{
1: 			if (fkChecker == null)
1: 			{
0: 				fkChecker = new RISetChecker(tc, fkInfoArray);
1: 			}
1: 			else
1: 			{
1: 				fkChecker.reopen();
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	boolean  collectAffectedRows() throws StandardException
1: 	{	
1: 
1: 		DataValueDescriptor		rlColumn;
1: 		RowLocation	baseRowLocation;
1: 		boolean rowsFound = false;
1: 
1: 		if(cascadeDelete)
1: 			row = getNextRowCore(source);
1: 
1: 		while ( row != null )
1: 		{
0: 			/* By convention, the last column for a delete contains a SQLRef
0: 			 * containing the RowLocation of the row to be deleted.  If we're
1: 			 * doing a deferred delete, store the RowLocations in the
1: 			 * temporary conglomerate.  If we're not doing a deferred delete,
1: 			 * just delete the rows immediately.
1: 			 */
1: 
1: 			rowsFound = true;
1: 
1: 			rlColumn = row.getColumn( row.nColumns() );
1: 		
1: 			if (constants.deferred || cascadeDelete)
1: 			{
1: 
1: 				/*
1: 				** If we are deferred because of a trigger or foreign
1: 				** key, we need to save off the entire row.  Otherwise,
1: 				** we just save the RID.
1: 				*/
1: 				if (noTriggersOrFks)
1: 				{
1: 					deferredRLRow.setColumn(1, rlColumn);
1: 					rowHolder.insert(deferredRLRow);
1: 				}
1: 				else
1: 				{
1: 					rowHolder.insert(row);
1: 				}
1: 				
1: 				/*
1: 				** If we haven't already, lets get a template to
1: 				** use as a template for our rescan of the base table.
1: 				** Do this now while we have a real row to use
1: 				** as a copy.
1: 				**
1: 				** There is one less column in the base row than
1: 				** there is in source row, because the base row
1: 				** doesn't contain the row location.
1: 				*/
1: 				if (deferredBaseRow == null)
1: 				{
1: 					deferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns - 1, lcc);
1: 			
1: 					RowUtil.copyCloneColumns(deferredBaseRow, row, 
1: 											numberOfBaseColumns - 1);
1: 					deferredSparseRow = makeDeferredSparseRow(deferredBaseRow,
1: 																baseRowReadList,
1: 																lcc);
1: 				}
1: 			}
1: 			else
1: 			{
1: 				if (fkChecker != null)
1: 				{
0: 					fkChecker.doPKCheck(row, false);
1: 				}
1: 
1: 				baseRowLocation = 
1: 					(RowLocation) (rlColumn).getObject();
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(baseRowLocation != null,
1: 							"baseRowLocation is null");
1: 				}
1: 
1: 				rc.deleteRow(row,baseRowLocation);
1: 			}
1: 
1:             rowCount++;
1: 
1: 			// No need to do a next on a single row source
1: 			if (constants.singleRowSource)
1: 			{
1: 				row = null;
1: 			}
1: 			else
1: 			{
1: 				row = getNextRowCore(source);
1: 			}
1: 		}
1: 
1: 		return rowsFound;
1: 	}
1: 
1: 
1: 	// execute the before triggers set on the table
1:     void fireBeforeTriggers() throws StandardException
1: 	{
1: 
1: 		if (triggerInfo != null)
1: 		{
1: 			if (triggerActivator == null)
1: 			{
1: 				triggerActivator = new TriggerEventActivator(lcc, 
1: 															 tc, 
1: 															 constants.targetUUID,
1: 															 triggerInfo,
1: 															 TriggerExecutionContext.DELETE_EVENT,
1: 															 activation, null
1: 															 );
1: 			}
1: 			else
1: 			{
1: 				triggerActivator.reopen();
1: 			}
1: 
1: 			// fire BEFORE trigger
1: 			triggerActivator.notifyEvent(TriggerEvents.BEFORE_DELETE, 
1: 										 rowHolder.getResultSet(), 
0: 										 (CursorResultSet)null);
1: 
1: 		}
1: 
1: 	}
1: 
1: 	//execute the after triggers set on the table.
1: 	void fireAfterTriggers() throws StandardException
1: 	{
1: 
1: 		// fire AFTER trigger
1: 		if (triggerActivator != null)
1: 		{
1: 			triggerActivator.notifyEvent(TriggerEvents.AFTER_DELETE, 
1: 										 rowHolder.getResultSet(),
0: 										 (CursorResultSet)null);
1: 		}
1: 		
1: 	}
1: 
1: 
1: 	//delete the rows that in case deferred case and
1: 	//during cascade delete (All deletes are deferred during cascade action)
1: 	void deleteDeferredRows() throws StandardException
1: 	{
1: 		
1: 		DataValueDescriptor		rlColumn;
1:  		RowLocation	baseRowLocation;
1: 		ExecRow		deferredRLRow = null;
1: 
0: 		deferredBaseCC = tc.openCompiledConglomerate(false,
0: 													 tc.OPENMODE_FORUPDATE|tc.OPENMODE_SECONDARY_LOCKED,
0: 													 lockMode,
0: 													 TransactionController.ISOLATION_SERIALIZABLE,
1: 													 constants.heapSCOCI,
0: 													 heapDCOCI);
1: 			
1: 		CursorResultSet rs = rowHolder.getResultSet();
1: 		try
1: 		{
1: 			/*
1: 			** We need to do a fetch doing a partial row
1: 			** read.  We need to shift our 1-based bit
1: 			** set to a zero based bit set like the store
1: 			** expects.
1: 			*/
1: 			FormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);
1: 
1: 			rs.open();
0: 			while ((deferredRLRow = rs.getNextRow()) != null)
1: 			{
0: 				rlColumn = deferredRLRow.getColumn(rlColumnNumber);
1: 				baseRowLocation = 
1: 					(RowLocation) (rlColumn).getObject();
1: 	
1: 				/* Get the base row at the given RowLocation */
1: 				boolean row_exists = 
1: 					deferredBaseCC.fetch(
1: 										 baseRowLocation, deferredSparseRow.getRowArray(), 
1: 										 readBitSet);
1: 
1: 				// In case of cascade delete , things like before triggers can delete 
1: 				// the rows before the dependent result get a chance to delete
1: 				if(cascadeDelete && !row_exists)
1: 					continue;
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					if (!row_exists)
1: 					{
1:                         	SanityManager.THROWASSERT("could not find row "+baseRowLocation);
1: 					}
1: 				}
1: 	
1: 				rc.deleteRow(deferredBaseRow, baseRowLocation);
1: 			}
1: 		} finally
1: 		{
1: 				rs.close();
1: 		}
1: 	}
1: 
1: 
0: 	// make sure foreign key constraints are not violated
0:     void runFkChecker(boolean restrictCheckOnly) throws StandardException
1: 	{
1: 
1: 		ExecRow		deferredRLRow = null;
1: 		if (fkChecker != null)
1: 		{
1: 			/*
1: 			** Second scan to make sure all the foreign key
1: 			** constraints are ok.  We have to do this after
1: 			** we have completed the deletes in case of self referencing
1: 			** constraints.
1: 			*/
1: 			CursorResultSet rs = rowHolder.getResultSet();
1: 			try
1: 			{
1: 				rs.open();
0: 				while ((deferredRLRow = rs.getNextRow()) != null)
1: 				{
0: 					fkChecker.doPKCheck(deferredRLRow, restrictCheckOnly);
1: 				}
1: 			} finally
1: 			{
1: 				rs.close();
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  *	create a source for the dependent table
1: 	  *
1: 	  * <P>Delete Cascade ResultSet class will override this method.
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	NoPutResultSet createDependentSource(RowChanger rc)
1: 		throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see ResultSet#cleanUp
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void	cleanUp() throws StandardException
1: 	{ 
1: 		numOpens = 0;
1: 
1: 		if (triggerActivator != null)
1: 		{
1: 			triggerActivator.cleanup();
0: 			// trigger activator is reused
1: 		}
1: 
1: 		/* Close down the source ResultSet tree */
1: 		if (source != null)
1: 		{
1: 			source.close();
1: 			// source is reused across executions
1: 		}
1: 		if (rc != null)
1: 		{
1: 			rc.close();
1: 			// rc is reused across executions
1: 		}
1: 
1: 		if (rowHolder != null)
1: 		{
1: 			rowHolder.close();
1: 			// rowHolder is reused across executions
1: 		}
1: 
1: 		if (fkChecker != null)
1: 		{
1: 			fkChecker.close();
1: 			// fkcheckers is reused across executions
1: 		}
1: 
1: 		if (deferredBaseCC != null)
1: 			deferredBaseCC.close();
1: 		deferredBaseCC = null;
1: 
0: 		super.close();
1: 	}
1: 
1: 	public void finish() throws StandardException {
1: 		if (source != null)
1: 			source.finish();
1: 		super.finish();
1: 	}
1: 
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:ddf1ea6
/////////////////////////////////////////////////////////////////////////
1: 			triggerActivator.cleanup();
/////////////////////////////////////////////////////////////////////////
1: 			triggerActivator.reopen();
0: 			triggerActivator.cleanup();
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: 
0: /**
0:  * Delete the rows from the specified
0:  * base table. This will cause constraints to be checked
0:  * and triggers to be executed based on the c's and t's
0:  * compiled into the insert plan.
0:  */
0: public class DeleteResultSet extends DMLWriteResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public TransactionController   	tc;
0: 	public DeleteConstantAction		constants;
0:     protected ResultDescription 				resultDescription;
0: 	protected  NoPutResultSet			source;
0: 	public  NoPutResultSet			savedSource;
0: 	int 							numIndexes;
0: 	protected RowChanger 			rc;
0: 	public ExecRow					row;
0: 
0: 	protected ConglomerateController	deferredBaseCC;
0: 	public		LanguageConnectionContext lcc;
0: 
0: 	protected TemporaryRowHolderImpl	rowHolder;
0: 
0: 	private int						numOpens; // number of opens w/o a close
0: 	private boolean 				firstExecute;
0: 
0: 	// cached across opens()s
0: 	private FormatableBitSet 				baseRowReadList; 
0: 	private int						rlColumnNumber;
0: 	protected FKInfo[]				fkInfoArray;
0: 	private TriggerInfo 			triggerInfo;
0: 	private	RISetChecker			fkChecker;
0: 	private TriggerEventActivator	triggerActivator;
0: 	private boolean					noTriggersOrFks;
0: 
0: 	ExecRow		deferredSparseRow; 
0: 	ExecRow		deferredBaseRow;
0: 	int lockMode; 
0: 	protected  boolean cascadeDelete;
0: 	ExecRow		deferredRLRow = null;
0: 	int	numberOfBaseColumns = 0;
0: 
0: 	/**
0:      * Returns the description of the deleted rows.
0:      * REVISIT: Do we want this to return NULL instead?
0: 	 */
0: 	public ResultDescription getResultDescription()
0: 	{
0: 	    return resultDescription;
0: 	}
0: 
0:     /*
0:      * class interface
0:      *
0:      */
0:     public DeleteResultSet
0: 	(
0: 		NoPutResultSet		source,
0: 		Activation			activation
0: 	)
0: 		throws StandardException
0:     {
0: 		this(source, activation.getConstantAction(), activation);
0: 	}
0:     /**
0:      * REMIND: At present this takes just the conglomerate id
0:      * of the table. We can expect this to expand to include
0:      * passing information about triggers, constraints, and
0:      * any additional conglomerates on the underlying table
0:      * for access methods.
0:      *
0: 	 * @exception StandardException		Thrown on error
0:      */
0:     protected DeleteResultSet
0: 	(
0: 		NoPutResultSet		source,
0: 		ConstantAction		passedInConstantAction,
0: 		Activation			activation
0: 	)
0: 		throws StandardException
0:     {
0: 		super(activation, passedInConstantAction);
0: 		this.source = source;
0: 
0: 		lcc = activation.getLanguageConnectionContext();
0: 		tc = activation.getTransactionController();
0: 		constants = (DeleteConstantAction) constantAction;
0: 		fkInfoArray = constants.getFKInfo( lcc.getExecutionContext() );
0: 		triggerInfo = constants.getTriggerInfo(lcc.getExecutionContext());
0: 		noTriggersOrFks = ((fkInfoArray == null) && (triggerInfo == null));
0: 		baseRowReadList = constants.getBaseRowReadList();
0: 		if(source != null)
0: 			resultDescription = source.getResultDescription();
0: 		else
0: 			resultDescription = constants.resultDescription;
0: 
0: 	}
0: 
0: 	/**
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public void open() throws StandardException
0: 	{
0: 
0: 		setup();
0: 		boolean rowsFound = collectAffectedRows(); //this call also deletes rows , if not deferred
0: 		if (! rowsFound)
0: 		{
0: 			activation.addWarning(
0: 						StandardException.newWarning(
0: 							SQLState.LANG_NO_ROW_FOUND));
0: 		}
0: 
0: 		/*
0: 		** If the delete is deferred, scan the temporary conglomerate to
0: 		** get the RowLocations of the rows to be deleted.  Re-fetch the
0: 		** rows and delete them using the RowChanger.
0: 		*/
0: 		if (constants.deferred)
0: 		{
0: 			runFkChecker(true); //check for only RESTRICT referential action rule violations
0: 			fireBeforeTriggers();
0: 			deleteDeferredRows();
0: 			runFkChecker(false); //check for all constraint violations
0: 			// apply 
0: 			rc.finish();
0: 			fireAfterTriggers();
0: 		}
0: 
0: 	
0: 		/* Cache query plan text for source, before it gets blown away */
0: 		if (lcc.getRunTimeStatisticsMode())
0: 		{
0: 			/* savedSource nulled after run time statistics generation */
0: 			savedSource = source;
0: 		}
0: 
0: 		cleanUp();
0: 		endTime = getCurrentTimeMillis();
0: 
0:     }
0: 	
0: 
0: 	//this routine open the source and find the dependent rows 
0: 	void  setup() throws StandardException
0: 	{
0: 
0: 		// Remember if this is the 1st execution
0: 		firstExecute = (rc == null);
0: 
0: 		try {
0: 
0: 			//open the source for the parent tables
0: 			if (numOpens++ == 0)
0: 			{
0: 				source.openCore();
0: 			}
0: 			else
0: 			{
0:         		source.reopenCore();
0: 			}
0: 		} catch (StandardException se) {
0: 			activation.checkStatementValidity();
0: 			throw se;
0: 
0: 		}
0: 
0: 		activation.checkStatementValidity();
0: 
0: 		/* Get or re-use the row changer.
0: 		 * NOTE: We need to set ourself as the top result set
0: 		 * if this is not the 1st execution.  (Done in constructor
0: 		 * for 1st execution.)
0: 		 */
0: 		if (firstExecute)
0: 		{
0: 			rc = lcc.getLanguageConnectionFactory().getExecutionFactory().
0: 					     getRowChanger( 
0: 								constants.conglomId,
0: 								constants.heapSCOCI, 
0: 								heapDCOCI,
0: 								constants.irgs,
0: 								constants.indexCIDS,
0: 								constants.indexSCOCIs,
0: 							    indexDCOCIs,
0: 								constants.numColumns,
0: 								tc,
0: 								(int[])null,
0: 								baseRowReadList,
0: 								constants.getBaseRowReadMap(),
0: 								constants.getStreamStorableHeapColIds(),
0: 								activation);
0: 		}
0: 		else
0: 		{
0: 			lcc.getStatementContext().setTopResultSet(this, subqueryTrackingArray);
0: 		}
0: 		/* decode the lock mode for the execution isolation level */
0: 		lockMode = UpdateResultSet.decodeLockMode(lcc, constants.lockMode);
0: 
0: 		/* Open the RowChanger before the source ResultSet so that
0: 		 * the store will see the RowChanger's lock as a covering lock
0: 		 * if it is a table lock.
0: 		 */
0: 		rc.open(lockMode); 
0: 
0: 		/* The source does not know whether or not we are doing a
0: 		 * deferred mode delete.  If we are, then we must clear the
0: 		 * index scan info from the activation so that the row changer
0: 		 * does not re-use that information (which won't be valid for
0: 		 * a deferred mode delete).
0: 		 */
0: 		if (constants.deferred || cascadeDelete)
0: 		{
0: 			activation.clearIndexScanInfo();
0: 		}
0: 
0:         rowCount = 0;
0:         if(!cascadeDelete)
0: 			row = getNextRowCore(source);
0: 
0: 		/*
0: 		** We need the number of columns even if there are
0: 		** no rows. Note that source.ressultDescription() may 
0: 		** be null on a rep target doing a refresh.
0: 		*/
0: 		if (resultDescription == null)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				/*
0: 				** We NEED a result description when we are going to
0: 				** to have to kick off a trigger.  In a replicated environment
0: 				** we don't get a result description when we are replaying
0: 				** source xacts on the target, but we shouldn't be firing
0: 				** a trigger in that case anyway.
0: 				*/
0: 				SanityManager.ASSERT(triggerInfo == null, "result description is needed to supply to trigger result sets");
0: 			}
0: 			numberOfBaseColumns = (row == null) ? 0 : row.nColumns();
0: 		}
0: 		else
0: 		{
0: 			numberOfBaseColumns = resultDescription.getColumnCount();
0: 		}
0: 
0: 		numIndexes = constants.irgs.length;
0: 
0: 		if (constants.deferred || cascadeDelete)
0: 		{
0: 			Properties properties = new Properties();
0: 
0: 			// Get the properties on the old heap
0: 			rc.getHeapConglomerateController().getInternalTablePropertySet(properties);
0: 
0: 			/*
0: 			** If deferred and fk or trigger, we are going to grab
0: 			** the entire row.  
0: 			**
0: 			** If we are deferred w/o a fk, then we only
0: 			** save the row location.
0: 			*/
0: 			deferredRLRow = RowUtil.getEmptyValueRow(1, lcc);
0: 			rlColumnNumber = noTriggersOrFks ? 1: numberOfBaseColumns;
0: 			if(cascadeDelete)
0: 			{
0: 				rowHolder = new TemporaryRowHolderImpl(tc, properties, 
0: 						(resultDescription != null) ?
0: 							resultDescription.truncateColumns(rlColumnNumber) :
0: 							null, false);
0: 
0: 
0: 			}else
0: 			{
0: 
0: 				rowHolder = new TemporaryRowHolderImpl(tc, properties, 
0: 						(resultDescription != null) ?
0: 							resultDescription.truncateColumns(rlColumnNumber) :
0: 							null);
0: 
0: 			}
0: 
0: 			rc.setRowHolder(rowHolder);
0: 		}
0: 
0: 		if (fkInfoArray != null)
0: 		{
0: 			if (fkChecker == null)
0: 			{
0: 				fkChecker = new RISetChecker(tc, fkInfoArray);
0: 			}
0: 			else
0: 			{
0: 				fkChecker.reopen();
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	boolean  collectAffectedRows() throws StandardException
0: 	{	
0: 
0: 		DataValueDescriptor		rlColumn;
0: 		RowLocation	baseRowLocation;
0: 		boolean rowsFound = false;
0: 
0: 		if(cascadeDelete)
0: 			row = getNextRowCore(source);
0: 
0: 		while ( row != null )
0: 		{
0: 			/* By convention, the last column for a delete contains a SQLRef
0: 			 * containing the RowLocation of the row to be deleted.  If we're
0: 			 * doing a deferred delete, store the RowLocations in the
0: 			 * temporary conglomerate.  If we're not doing a deferred delete,
0: 			 * just delete the rows immediately.
0: 			 */
0: 
0: 			rowsFound = true;
0: 
0: 			rlColumn = row.getColumn( row.nColumns() );
0: 		
0: 			if (constants.deferred || cascadeDelete)
0: 			{
0: 
0: 				/*
0: 				** If we are deferred because of a trigger or foreign
0: 				** key, we need to save off the entire row.  Otherwise,
0: 				** we just save the RID.
0: 				*/
0: 				if (noTriggersOrFks)
0: 				{
0: 					deferredRLRow.setColumn(1, rlColumn);
0: 					rowHolder.insert(deferredRLRow);
0: 				}
0: 				else
0: 				{
0: 					rowHolder.insert(row);
0: 				}
0: 				
0: 				/*
0: 				** If we haven't already, lets get a template to
0: 				** use as a template for our rescan of the base table.
0: 				** Do this now while we have a real row to use
0: 				** as a copy.
0: 				**
0: 				** There is one less column in the base row than
0: 				** there is in source row, because the base row
0: 				** doesn't contain the row location.
0: 				*/
0: 				if (deferredBaseRow == null)
0: 				{
0: 					deferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns - 1, lcc);
0: 			
0: 					RowUtil.copyCloneColumns(deferredBaseRow, row, 
0: 											numberOfBaseColumns - 1);
0: 					deferredSparseRow = makeDeferredSparseRow(deferredBaseRow,
0: 																baseRowReadList,
0: 																lcc);
0: 				}
0: 			}
0: 			else
0: 			{
0: 				if (fkChecker != null)
0: 				{
0: 					fkChecker.doPKCheck(row, false);
0: 				}
0: 
0: 				baseRowLocation = 
0: 					(RowLocation) (rlColumn).getObject();
0: 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(baseRowLocation != null,
0: 							"baseRowLocation is null");
0: 				}
0: 
0: 				rc.deleteRow(row,baseRowLocation);
0: 			}
0: 
0:             rowCount++;
0: 
0: 			// No need to do a next on a single row source
0: 			if (constants.singleRowSource)
0: 			{
0: 				row = null;
0: 			}
0: 			else
0: 			{
0: 				row = getNextRowCore(source);
0: 			}
0: 		}
0: 
0: 		return rowsFound;
0: 	}
0: 
0: 
0: 	// execute the before triggers set on the table
0:     void fireBeforeTriggers() throws StandardException
0: 	{
0: 
0: 		if (triggerInfo != null)
0: 		{
0: 			if (triggerActivator == null)
0: 			{
0: 				triggerActivator = new TriggerEventActivator(lcc, 
0: 															 tc, 
0: 															 constants.targetUUID,
0: 															 triggerInfo,
0: 															 TriggerExecutionContext.DELETE_EVENT,
0: 															 activation, null
0: 															 );
0: 			}
0: 			else
0: 			{
0: 				triggerActivator.reopen();
0: 			}
0: 
0: 			// fire BEFORE trigger
0: 			triggerActivator.notifyEvent(TriggerEvents.BEFORE_DELETE, 
0: 										 rowHolder.getResultSet(), 
0: 										 (CursorResultSet)null);
0: 
0: 		}
0: 
0: 	}
0: 
0: 	//execute the after triggers set on the table.
0: 	void fireAfterTriggers() throws StandardException
0: 	{
0: 
0: 		// fire AFTER trigger
0: 		if (triggerActivator != null)
0: 		{
0: 			triggerActivator.notifyEvent(TriggerEvents.AFTER_DELETE, 
0: 										 rowHolder.getResultSet(),
0: 										 (CursorResultSet)null);
0: 		}
0: 		
0: 	}
0: 
0: 
0: 	//delete the rows that in case deferred case and
0: 	//during cascade delete (All deletes are deferred during cascade action)
0: 	void deleteDeferredRows() throws StandardException
0: 	{
0: 		
0: 		DataValueDescriptor		rlColumn;
0:  		RowLocation	baseRowLocation;
0: 		ExecRow		deferredRLRow = null;
0: 
0: 		deferredBaseCC = tc.openCompiledConglomerate(false,
0: 													 tc.OPENMODE_FORUPDATE|tc.OPENMODE_SECONDARY_LOCKED,
0: 													 lockMode,
0: 													 TransactionController.ISOLATION_SERIALIZABLE,
0: 													 constants.heapSCOCI,
0: 													 heapDCOCI);
0: 			
0: 		CursorResultSet rs = rowHolder.getResultSet();
0: 		try
0: 		{
0: 			/*
0: 			** We need to do a fetch doing a partial row
0: 			** read.  We need to shift our 1-based bit
0: 			** set to a zero based bit set like the store
0: 			** expects.
0: 			*/
0: 			FormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);
0: 
0: 			rs.open();
0: 			while ((deferredRLRow = rs.getNextRow()) != null)
0: 			{
0: 				rlColumn = deferredRLRow.getColumn(rlColumnNumber);
0: 				baseRowLocation = 
0: 					(RowLocation) (rlColumn).getObject();
0: 	
0: 				/* Get the base row at the given RowLocation */
0: 				boolean row_exists = 
0: 					deferredBaseCC.fetch(
0: 										 baseRowLocation, deferredSparseRow.getRowArray(), 
0: 										 readBitSet);
0: 
0: 				// In case of cascade delete , things like before triggers can delete 
0: 				// the rows before the dependent result get a chance to delete
0: 				if(cascadeDelete && !row_exists)
0: 					continue;
0: 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if (!row_exists)
0: 					{
0:                         	SanityManager.THROWASSERT("could not find row "+baseRowLocation);
0: 					}
0: 				}
0: 	
0: 				rc.deleteRow(deferredBaseRow, baseRowLocation);
0: 			}
0: 		} finally
0: 		{
0: 				rs.close();
0: 		}
0: 	}
0: 
0: 
0: 	// make sure foreign key constraints are not violated
0:     void runFkChecker(boolean restrictCheckOnly) throws StandardException
0: 	{
0: 
0: 		ExecRow		deferredRLRow = null;
0: 		if (fkChecker != null)
0: 		{
0: 			/*
0: 			** Second scan to make sure all the foreign key
0: 			** constraints are ok.  We have to do this after
0: 			** we have completed the deletes in case of self referencing
0: 			** constraints.
0: 			*/
0: 			CursorResultSet rs = rowHolder.getResultSet();
0: 			try
0: 			{
0: 				rs.open();
0: 				while ((deferredRLRow = rs.getNextRow()) != null)
0: 				{
0: 					fkChecker.doPKCheck(deferredRLRow, restrictCheckOnly);
0: 				}
0: 			} finally
0: 			{
0: 				rs.close();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  *	create a source for the dependent table
0: 	  *
0: 	  * <P>Delete Cascade ResultSet class will override this method.
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	NoPutResultSet createDependentSource(RowChanger rc)
0: 		throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see ResultSet#cleanUp
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void	cleanUp() throws StandardException
0: 	{ 
0: 		numOpens = 0;
0: 
0: 		if (triggerActivator != null)
0: 		{
0: 			triggerActivator.cleanup();
0: 			// trigger activator is reused
0: 		}
0: 
0: 		/* Close down the source ResultSet tree */
0: 		if (source != null)
0: 		{
0: 			source.close();
0: 			// source is reused across executions
0: 		}
0: 		if (rc != null)
0: 		{
0: 			rc.close();
0: 			// rc is reused across executions
0: 		}
0: 
0: 		if (rowHolder != null)
0: 		{
0: 			rowHolder.close();
0: 			// rowHolder is reused across executions
0: 		}
0: 
0: 		if (fkChecker != null)
0: 		{
0: 			fkChecker.close();
0: 			// fkcheckers is reused across executions
0: 		}
0: 
0: 		if (deferredBaseCC != null)
0: 			deferredBaseCC.close();
0: 		deferredBaseCC = null;
0: 
0: 		super.close();
0: 	}
0: 
0: 	public void finish() throws StandardException {
0: 		if (source != null)
0: 			source.finish();
0: 		super.finish();
0: 	}
0: 
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================