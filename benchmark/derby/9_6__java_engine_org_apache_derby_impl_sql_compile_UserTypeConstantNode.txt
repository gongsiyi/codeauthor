1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.UserTypeConstantNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
21:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: import java.sql.Types;
1:3bb140c: import org.apache.derby.catalog.TypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.SQLDate;
1:3bb140c: import org.apache.derby.iapi.types.SQLTime;
1:3bb140c: import org.apache.derby.iapi.types.SQLTimestamp;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
6:eac0369: /**
1:eac0369: 	User type constants.  These are created by built-in types
1:eac0369: 	that use user types as their implementation. This could also
1:eac0369: 	potentially be used by an optimizer that wanted to store plans
1:eac0369: 	for frequently-used parameter values.
1:eac0369: 
1:eac0369: 	This is also used to represent nulls in user types, which occurs
1:eac0369: 	when NULL is inserted into or supplied as the update value for
1:3bb140c:    a user type column.
1:eac0369: 
1:eac0369:  */
1:3bb140c: class UserTypeConstantNode extends ConstantNode {
1:eac0369: 	/*
1:eac0369: 	** This value field hides the value in the super-type.  It is here
1:eac0369: 	** Because user-type constants work differently from built-in constants.
1:eac0369: 	** User-type constant values are stored as Objects, while built-in
1:eac0369: 	** constants are stored as StorableDataValues.
1:eac0369: 	**
1:eac0369: 	** RESOLVE: This is a bit of a mess, and should be fixed.  All constants
1:eac0369: 	** should be represented the same way.
1:eac0369: 	*/
1:3bb140c:     Object  val;
1:eac0369: 
1:3bb140c:     UserTypeConstantNode(TypeId t, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(t, true, TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN, cm);
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     UserTypeConstantNode(Date d, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(TypeId.getBuiltInTypeId(Types.DATE),
1:3bb140c:               d == null,
1:3bb140c:               TypeId.DATE_MAXWIDTH,
1:3bb140c:               cm);
1:3bb140c:         setValue(new SQLDate(d));
1:3bb140c:         val = d;
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     UserTypeConstantNode(Time t, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(TypeId.getBuiltInTypeId(Types.TIME),
1:3bb140c:               t == null,
1:3bb140c:               TypeId.TIME_MAXWIDTH,
1:3bb140c:               cm);
1:3bb140c:         setValue(new SQLTime(t));
1:3bb140c:         val = t;
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     UserTypeConstantNode(Timestamp t, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(TypeId.getBuiltInTypeId(Types.TIMESTAMP),
1:3bb140c:                 t == null,
1:3bb140c:                 TypeId.TIMESTAMP_MAXWIDTH,
1:3bb140c:                 cm);
1:3bb140c:         setValue(new SQLTimestamp(t));
1:3bb140c:         val = t;
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     /**
1:3bb140c:      * @param dvd Must contain a Date, Time or Timestamp value
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     UserTypeConstantNode(DataValueDescriptor dvd, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(getTypeId(dvd),
1:3bb140c:               dvd == null,
1:3bb140c:               getWidth(dvd),
1:3bb140c:               cm);
1:3bb140c:         setValue(dvd);
1:3bb140c:         val = dvd;
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     private static TypeId getTypeId(DataValueDescriptor dvd) {
1:3bb140c:         if (dvd != null) {
1:3bb140c:             switch (dvd.getTypeFormatId()) {
1:3bb140c:                 case StoredFormatIds.SQL_DATE_ID:
1:3bb140c:                     return TypeId.getBuiltInTypeId(Types.DATE);
1:3bb140c:                 case StoredFormatIds.SQL_TIME_ID:
1:3bb140c:                     return TypeId.getBuiltInTypeId(Types.TIME);
1:3bb140c:                 case StoredFormatIds.SQL_TIMESTAMP_ID:
1:3bb140c:                     return TypeId.getBuiltInTypeId(Types.TIMESTAMP);
1:3bb140c:                 default:
1:3bb140c:                     if (SanityManager.DEBUG) {
1:3bb140c:                         SanityManager.THROWASSERT(
1:3bb140c:                                 "Unexpected class " + dvd.getClass().getName());
1:3bb140c:                     }
1:3bb140c:                     return null;
1:3bb140c:             }
1:3bb140c:         } else {
1:3bb140c:             return null;
1:3bb140c:         }
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     private static int getWidth(DataValueDescriptor dvd) {
1:3bb140c:         if (dvd != null) {
1:3bb140c:             switch (dvd.getTypeFormatId()) {
1:3bb140c:                 case StoredFormatIds.SQL_DATE_ID:
1:3bb140c:                     return TypeId.DATE_MAXWIDTH;
1:3bb140c:                 case StoredFormatIds.SQL_TIME_ID:
1:3bb140c:                     return TypeId.TIME_MAXWIDTH;
1:3bb140c:                 case StoredFormatIds.SQL_TIMESTAMP_ID:
1:3bb140c:                     return TypeId.TIMESTAMP_MAXWIDTH;
1:3bb140c:                 default:
1:3bb140c:                     if (SanityManager.DEBUG) {
1:3bb140c:                         SanityManager.THROWASSERT(
1:3bb140c:                                 "Unexpected class " + dvd.getClass().getName());
1:3bb140c:                     }
1:3bb140c:                     return 0;
1:3bb140c:             }
1:3bb140c:         } else {
1:3bb140c:             return 0;
1:3bb140c:         }
1:3bb140c:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the object value of this user defined type.
10:eac0369: 	 *
1:eac0369: 	 * @return	the value of this constant. can't use getValue() for this.
1:eac0369: 	 *			getValue() returns the DataValueDescriptor for the built-in
1:eac0369: 	 *			types that are implemented as user types (date, time, timestamp)
1:eac0369: 	 */
1:3bb140c:     public  Object  getObjectValue() { return val; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this node represents a typed null constant.
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isNull()
16:eac0369: 	{
1:3bb140c:         return (val == null);
17:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return an Object representing the bind time value of this
1:eac0369: 	 * expression tree.  If the expression tree does not evaluate to
1:eac0369: 	 * a constant at bind time then we return null.
1:eac0369: 	 * This is useful for bind time resolution of VTIs.
1:eac0369: 	 * RESOLVE: What do we do for primitives?
1:eac0369: 	 *
1:eac0369: 	 * @return	An Object representing the bind time value of this expression tree.
1:eac0369: 	 *			(null if not a bind time constant.)
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     Object getConstantValueAsObject()
1:eac0369: 	{
1:3bb140c:         return val;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * For a UserTypeConstantNode, we have to store away the object somewhere
1:eac0369: 	 * and have a way to get it back at runtime.
1:eac0369: 	 * These objects are serializable.  This gives us at least two options:
1:eac0369: 	 * 1) serialize it out into a byte array field, and serialize
1:eac0369: 	 *	  it back in when needed, from the field.
1:eac0369: 	 * 2) have an array of objects in the prepared statement and a #,
1:eac0369: 	 *	  to find the object directly. Because it is serializable, it
1:eac0369: 	 *	  will store with the rest of the executable just fine.
1:eac0369: 	 * Choice 2 gives better performance -- the ser/deser cost is paid
1:eac0369: 	 * on database access for the statement, not for each execution of it.
1:eac0369: 	 * However, it requires some infrastructure support from prepared
1:eac0369: 	 * statements.  For now, we take choice 3, and make some assumptions
1:eac0369: 	 * about available methods on the user type.  This choice has the
1:eac0369: 	 * shortcoming that it will not work for arbitrary user types.
1:eac0369: 	 * REVISIT and implement choice 2 when a general solution is needed.
1:eac0369: 	 * <p>
1:eac0369: 	 * A null is generated as a Null value cast to the type of
1:eac0369: 	 * the constant node.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
2:eac0369: 									throws StandardException {
1:eac0369: 
1:eac0369: 		TypeCompiler		tc = getTypeCompiler();
1:eac0369:         String fieldType = tc.interfaceName();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** NOTE: DO NOT CALL THE CONSTRUCTOR TO GENERATE ANYTHING.  IT HAS
1:eac0369: 		** A DIFFERENT value FIELD.
1:eac0369: 		*/
1:eac0369: 		
1:eac0369: 		/* Are we generating a SQL null value? */
1:3bb140c:         if (val == null)
1:eac0369: 	    {
1:ba7683c: 			acb.generateNull(mb, tc, getTypeServices().getCollationType());
1:eac0369: 	    }
1:eac0369:         // The code generated here is invoked when the generated class is constructed. However the prepared statement
1:eac0369:         // is not set into the activation class when it is constructed, but later. So we cannot use the getSavedObject
1:eac0369:         // method to retrieve the value.
1:eac0369: //         else if( value instanceof DataValueDescriptor)
1:eac0369: //         {
1:eac0369: //             acb.pushThisAsActivation( mb);
1:eac0369: //             mb.callMethod( VMOpcode.INVOKEINTERFACE,
1:eac0369: //                            null,
1:eac0369: //                            "getPreparedStatement",
1:eac0369: //                            ClassName.ExecPreparedStatement,
1:eac0369: //                            0);
1:eac0369: //             mb.push( acb.addItem( value));
1:eac0369: //             mb.callMethod( VMOpcode.INVOKEINTERFACE,
1:eac0369: //                            null,
1:eac0369: //                            "getSavedObject",
1:eac0369: //                            "java.lang.Object",
1:eac0369: //                            1);
1:eac0369: //             mb.cast( fieldType);
1:eac0369: //         }
4:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 				The generated java is the expression:
1:eac0369: 					<java type name>.valueOf("<value.toString>")
1:eac0369: 
1:eac0369: 				super.generateValue will wrap this expression in
1:eac0369: 				the appropriate column constructor.
1:eac0369: 
1:eac0369: 				If the type doesn't have a valueOf method, then we will
1:eac0369: 				give an error.  We have to assume that valueOf will
1:eac0369: 				reconstruct the object from a String literal.  If this is
1:eac0369: 				a false assumption, some other object may be constructed,
1:eac0369: 				or a runtime error may result due to valueOf failing.
1:eac0369: 		 	*/
1:eac0369: 			String typeName = getTypeId().getCorrespondingJavaTypeName();
1:eac0369: 
1:3bb140c:             mb.push(val.toString());
1:eac0369: 			mb.callMethod(VMOpcode.INVOKESTATIC, typeName, "valueOf", typeName, 1);
1:eac0369: 
1:eac0369: 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, fieldType);
1:eac0369: 
1:ba7683c: 			acb.generateDataValue(mb, tc, getTypeServices().getCollationType(), field);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Should never be called for UserTypeConstantNode because
1:eac0369: 	 * we have our own generateExpression().
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb) 
2:eac0369: 	throws StandardException
1:eac0369: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("geneateConstant() not expected to be called for UserTypeConstantNode because we have implemented our own generateExpression().");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:4309044
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLDate((Date) arg1));
0: 				setValue(new SQLTime((Time) arg1));
0: 				setValue(new SQLTimestamp((Timestamp) arg1));
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.SQLDate;
1: import org.apache.derby.iapi.types.SQLTime;
1: import org.apache.derby.iapi.types.SQLTimestamp;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:    a user type column.
1: class UserTypeConstantNode extends ConstantNode {
/////////////////////////////////////////////////////////////////////////
1:     Object  val;
1:     UserTypeConstantNode(TypeId t, ContextManager cm)
1:             throws StandardException {
1:         super(t, true, TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN, cm);
0:         setNodeType(C_NodeTypes.USERTYPE_CONSTANT_NODE);
1:     }
1:     UserTypeConstantNode(Date d, ContextManager cm)
1:             throws StandardException {
1:         super(TypeId.getBuiltInTypeId(Types.DATE),
1:               d == null,
1:               TypeId.DATE_MAXWIDTH,
1:               cm);
1:         setValue(new SQLDate(d));
1:         val = d;
0:         setNodeType(C_NodeTypes.USERTYPE_CONSTANT_NODE);
1:     }
1:     UserTypeConstantNode(Time t, ContextManager cm)
1:             throws StandardException {
1:         super(TypeId.getBuiltInTypeId(Types.TIME),
1:               t == null,
1:               TypeId.TIME_MAXWIDTH,
1:               cm);
1:         setValue(new SQLTime(t));
1:         val = t;
0:         setNodeType(C_NodeTypes.USERTYPE_CONSTANT_NODE);
1:     }
1:     UserTypeConstantNode(Timestamp t, ContextManager cm)
1:             throws StandardException {
1:         super(TypeId.getBuiltInTypeId(Types.TIMESTAMP),
1:                 t == null,
1:                 TypeId.TIMESTAMP_MAXWIDTH,
1:                 cm);
1:         setValue(new SQLTimestamp(t));
1:         val = t;
0:         setNodeType(C_NodeTypes.USERTYPE_CONSTANT_NODE);
1:     }
1:     /**
1:      * @param dvd Must contain a Date, Time or Timestamp value
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     UserTypeConstantNode(DataValueDescriptor dvd, ContextManager cm)
1:             throws StandardException {
1:         super(getTypeId(dvd),
1:               dvd == null,
1:               getWidth(dvd),
1:               cm);
1:         setValue(dvd);
1:         val = dvd;
0:         setNodeType(C_NodeTypes.USERTYPE_CONSTANT_NODE);
1:     }
1: 
1:     private static TypeId getTypeId(DataValueDescriptor dvd) {
1:         if (dvd != null) {
1:             switch (dvd.getTypeFormatId()) {
1:                 case StoredFormatIds.SQL_DATE_ID:
1:                     return TypeId.getBuiltInTypeId(Types.DATE);
1:                 case StoredFormatIds.SQL_TIME_ID:
1:                     return TypeId.getBuiltInTypeId(Types.TIME);
1:                 case StoredFormatIds.SQL_TIMESTAMP_ID:
1:                     return TypeId.getBuiltInTypeId(Types.TIMESTAMP);
1:                 default:
1:                     if (SanityManager.DEBUG) {
1:                         SanityManager.THROWASSERT(
1:                                 "Unexpected class " + dvd.getClass().getName());
1:                     }
1:                     return null;
1:             }
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     private static int getWidth(DataValueDescriptor dvd) {
1:         if (dvd != null) {
1:             switch (dvd.getTypeFormatId()) {
1:                 case StoredFormatIds.SQL_DATE_ID:
1:                     return TypeId.DATE_MAXWIDTH;
1:                 case StoredFormatIds.SQL_TIME_ID:
1:                     return TypeId.TIME_MAXWIDTH;
1:                 case StoredFormatIds.SQL_TIMESTAMP_ID:
1:                     return TypeId.TIMESTAMP_MAXWIDTH;
1:                 default:
1:                     if (SanityManager.DEBUG) {
1:                         SanityManager.THROWASSERT(
1:                                 "Unexpected class " + dvd.getClass().getName());
1:                     }
1:                     return 0;
1:             }
1:         } else {
1:             return 0;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public  Object  getObjectValue() { return val; }
1:     @Override
1:     boolean isNull()
1:         return (val == null);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     Object getConstantValueAsObject()
1:         return val;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (val == null)
/////////////////////////////////////////////////////////////////////////
1:             mb.push(val.toString());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
1: 			acb.generateNull(mb, tc, getTypeServices().getCollationType());
/////////////////////////////////////////////////////////////////////////
1: 			acb.generateDataValue(mb, tc, getTypeServices().getCollationType(), field);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a48949
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.UserTypeConstantNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.UserDataValue;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.catalog.TypeDescriptor;
1: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.types.*;
1: 
1: import java.lang.reflect.Modifier;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Types;
1: 
1: /**
1: 	User type constants.  These are created by built-in types
1: 	that use user types as their implementation. This could also
1: 	potentially be used by an optimizer that wanted to store plans
1: 	for frequently-used parameter values.
1: 
1: 	This is also used to represent nulls in user types, which occurs
1: 	when NULL is inserted into or supplied as the update value for
0: 	a usertype column.
1: 
0: 	@author ames
1:  */
0: public class UserTypeConstantNode extends ConstantNode {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	** This value field hides the value in the super-type.  It is here
1: 	** Because user-type constants work differently from built-in constants.
1: 	** User-type constant values are stored as Objects, while built-in
1: 	** constants are stored as StorableDataValues.
1: 	**
1: 	** RESOLVE: This is a bit of a mess, and should be fixed.  All constants
1: 	** should be represented the same way.
1: 	*/
0: 	Object	value;
1: 
1: 	/**
0: 	 * Initializer for a typed null node
0: 	 * or a date, time, or timestamp value
1: 	 *
0: 	 * @param arg1	The TypeId for the type of the node
0: 	 * @param arg2	The factory to get the TypeId
0: 	 *			and DataTypeServices factories from.
1: 	 *
0: 	 * - OR -
1: 	 *
0: 	 * @param arg1 the date, time, or timestamp value
1: 	 *
0: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	public void init(Object arg1)
1: 			throws StandardException {
0:         DataValueDescriptor dvd = null;
1:         
0: 		if (arg1 instanceof TypeId)
1: 		{
0: 			super.init(
0: 					arg1,
0: 					Boolean.TRUE,
0: 					ReuseFactory.getInteger(
0: 										TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN));
1: 		}
1: 		else
1: 		{
0: 			Integer maxWidth = null;
0: 			TypeId	typeId = null;
1: 
0:             if( arg1 instanceof DataValueDescriptor)
0:                 dvd = (DataValueDescriptor) arg1;
0: 			if (arg1 instanceof Date
0:                 || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_DATE_ID))
1: 			{
0: 				maxWidth = ReuseFactory.getInteger(TypeId.DATE_MAXWIDTH);
0: 				typeId = TypeId.getBuiltInTypeId(Types.DATE);
1: 			}
0: 			else if (arg1 instanceof Time
0:                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIME_ID))
1: 			{
0: 				maxWidth = ReuseFactory.getInteger(TypeId.TIME_MAXWIDTH);
0: 				typeId = TypeId.getBuiltInTypeId(Types.TIME);
1: 			}
0: 			else if (arg1 instanceof Timestamp
0:                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIMESTAMP_ID))
1: 			{
0: 				maxWidth = ReuseFactory.getInteger(TypeId.TIMESTAMP_MAXWIDTH);
0: 				typeId = TypeId.getBuiltInTypeId(Types.TIMESTAMP);
1: 			}
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
0: 					SanityManager.THROWASSERT(
0: 							"Unexpected class " + arg1.getClass().getName());
1: 				}
1: 			}
1: 
0: 			super.init( 
0: 				typeId,
0: 				(arg1 == null) ? Boolean.TRUE : Boolean.FALSE,
0: 				maxWidth);
1: 
0:             if( dvd != null)
0:                 setValue( dvd);
0: 			else if (arg1 instanceof Date)
1: 			{
0: 				setValue(getDataValueFactory().getDataValue((Date) arg1));
1: 			}
0: 			else if (arg1 instanceof Time)
1: 			{
0: 				setValue(getDataValueFactory().getDataValue((Time) arg1));
1: 			}
0: 			else if (arg1 instanceof Timestamp)
1: 			{
0: 				setValue(getDataValueFactory().getDataValue((Timestamp) arg1));
1: 			}
1: 
0: 			value = arg1;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return the object value of this user defined type.
1: 	 *
1: 	 * @return	the value of this constant. can't use getValue() for this.
1: 	 *			getValue() returns the DataValueDescriptor for the built-in
1: 	 *			types that are implemented as user types (date, time, timestamp)
1: 	 */
0:     public	Object	getObjectValue() { return value; }
1: 
1: 	/**
1: 	 * Return whether or not this node represents a typed null constant.
1: 	 *
1: 	 */
0: 	public boolean isNull()
1: 	{
0: 		return (value == null);
1: 	}
1: 
1: 	/**
0: 	 * Return the value of this user defined type as a Storable
1: 	 *
0: 	 * @return	the value of this constant as a UserType
0: 	 * @exception StandardException thrown on failure
1: 	 */
0:     public	DataValueDescriptor	getStorableValue()
1: 			throws StandardException
1: 	{
0:         if( value instanceof DataValueDescriptor)
0:             return ((DataValueDescriptor) value).getClone();
1:         
0: 		DataValueFactory			dvf = getDataValueFactory();
0: 		TypeId			typeID = getTypeId();
0: 		String						typeName = typeID.getSQLTypeName();
1: 
0: 		if ( typeName.equals( TypeId.DATE_NAME ) )
1: 		{
0: 			return	new SQLDate((Date) value);
1: 		}
0: 		else if ( typeName.equals( TypeId.TIME_NAME ) )
1: 		{
0: 			return	new SQLTime( (Time) value);
1: 		}
0: 		else if ( typeName.equals( TypeId.TIMESTAMP_NAME ) )
1: 		{
0: 			return	new SQLTimestamp( (Timestamp) value);
1: 		}
1: 		else
1: 		{
0: 			return	dvf.getDataValue( value, (UserDataValue) null );
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Sets the object value of this user defined type
1: 	 *
0: 	 * @param	the value of this constant. can't use setValue() for this.
1: 	 */
0:     public	void	setObjectValue( Object newValue ) { value = newValue; }
1: 
1: 	/**
0: 	 * Return the length
1: 	 *
0: 	 * @return	The length of the value this node represents
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	//public int	getLength() throws StandardException {
0: 	//	return TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;
0: 	//}
1: 
1: 	/**
1: 	 * Return an Object representing the bind time value of this
1: 	 * expression tree.  If the expression tree does not evaluate to
1: 	 * a constant at bind time then we return null.
1: 	 * This is useful for bind time resolution of VTIs.
1: 	 * RESOLVE: What do we do for primitives?
1: 	 *
1: 	 * @return	An Object representing the bind time value of this expression tree.
1: 	 *			(null if not a bind time constant.)
1: 	 *
1: 	 */
0: 	public Object getConstantValueAsObject()
1: 	{
0: 		return value;
1: 	}
1: 
1: 	/**
1: 	 * For a UserTypeConstantNode, we have to store away the object somewhere
1: 	 * and have a way to get it back at runtime.
1: 	 * These objects are serializable.  This gives us at least two options:
1: 	 * 1) serialize it out into a byte array field, and serialize
1: 	 *	  it back in when needed, from the field.
1: 	 * 2) have an array of objects in the prepared statement and a #,
1: 	 *	  to find the object directly. Because it is serializable, it
1: 	 *	  will store with the rest of the executable just fine.
1: 	 * Choice 2 gives better performance -- the ser/deser cost is paid
1: 	 * on database access for the statement, not for each execution of it.
1: 	 * However, it requires some infrastructure support from prepared
1: 	 * statements.  For now, we take choice 3, and make some assumptions
1: 	 * about available methods on the user type.  This choice has the
1: 	 * shortcoming that it will not work for arbitrary user types.
1: 	 * REVISIT and implement choice 2 when a general solution is needed.
1: 	 * <p>
1: 	 * A null is generated as a Null value cast to the type of
1: 	 * the constant node.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException {
1: 
1: 		TypeCompiler		tc = getTypeCompiler();
1:         String fieldType = tc.interfaceName();
1: 
1: 		/*
1: 		** NOTE: DO NOT CALL THE CONSTRUCTOR TO GENERATE ANYTHING.  IT HAS
1: 		** A DIFFERENT value FIELD.
1: 		*/
1: 		
1: 		/* Are we generating a SQL null value? */
0: 	    if (value == null)
1: 	    {
0: 			acb.generateNull(mb, tc);
1: 	    }
1:         // The code generated here is invoked when the generated class is constructed. However the prepared statement
1:         // is not set into the activation class when it is constructed, but later. So we cannot use the getSavedObject
1:         // method to retrieve the value.
1: //         else if( value instanceof DataValueDescriptor)
1: //         {
1: //             acb.pushThisAsActivation( mb);
1: //             mb.callMethod( VMOpcode.INVOKEINTERFACE,
1: //                            null,
1: //                            "getPreparedStatement",
1: //                            ClassName.ExecPreparedStatement,
1: //                            0);
1: //             mb.push( acb.addItem( value));
1: //             mb.callMethod( VMOpcode.INVOKEINTERFACE,
1: //                            null,
1: //                            "getSavedObject",
1: //                            "java.lang.Object",
1: //                            1);
1: //             mb.cast( fieldType);
1: //         }
1: 		else
1: 		{
1: 			/*
1: 				The generated java is the expression:
1: 					<java type name>.valueOf("<value.toString>")
1: 
1: 				super.generateValue will wrap this expression in
1: 				the appropriate column constructor.
1: 
1: 				If the type doesn't have a valueOf method, then we will
1: 				give an error.  We have to assume that valueOf will
1: 				reconstruct the object from a String literal.  If this is
1: 				a false assumption, some other object may be constructed,
1: 				or a runtime error may result due to valueOf failing.
1: 		 	*/
1: 			String typeName = getTypeId().getCorrespondingJavaTypeName();
1: 
0: 			mb.push(value.toString());
1: 			mb.callMethod(VMOpcode.INVOKESTATIC, typeName, "valueOf", typeName, 1);
1: 
1: 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, fieldType);
1: 
0: 			acb.generateDataValue(mb, tc, field);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Should never be called for UserTypeConstantNode because
1: 	 * we have our own generateExpression().
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
0: 	 * @return		The compiled Expression, 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb) 
1: 	throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("geneateConstant() not expected to be called for UserTypeConstantNode because we have implemented our own generateExpression().");
1: 		}
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * or a date, time, or timestamp value. Parameters may be:
0: 	 * <ul>
0: 	 * <li>arg1	The TypeId for the type of the node</li>
0: 	 * <li>arg2	The factory to get the TypeId and DataTypeServices factories from.</li>
0: 	 * </ul>
0: 	 * <p>
0: 	 * </p>
0: 	 * <ul>
0: 	 * <li>arg1 the date, time, or timestamp value</li>
0: 	 * </ul>
/////////////////////////////////////////////////////////////////////////
0: 	 * @param	newValue	the value of this constant. can't use setValue() for this.
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.UserDataValue;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.types.*;
0: 
0: import java.lang.reflect.Modifier;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: 
0: /**
0: 	User type constants.  These are created by built-in types
0: 	that use user types as their implementation. This could also
0: 	potentially be used by an optimizer that wanted to store plans
0: 	for frequently-used parameter values.
0: 
0: 	This is also used to represent nulls in user types, which occurs
0: 	when NULL is inserted into or supplied as the update value for
0: 	a usertype column.
0: 
0: 	@author ames
0:  */
0: public class UserTypeConstantNode extends ConstantNode {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	** This value field hides the value in the super-type.  It is here
0: 	** Because user-type constants work differently from built-in constants.
0: 	** User-type constant values are stored as Objects, while built-in
0: 	** constants are stored as StorableDataValues.
0: 	**
0: 	** RESOLVE: This is a bit of a mess, and should be fixed.  All constants
0: 	** should be represented the same way.
0: 	*/
0: 	Object	value;
0: 
0: 	/**
0: 	 * Initializer for a typed null node
0: 	 * or a date, time, or timestamp value
0: 	 *
0: 	 * @param arg1	The TypeId for the type of the node
0: 	 * @param arg2	The factory to get the TypeId
0: 	 *			and DataTypeServices factories from.
0: 	 *
0: 	 * - OR -
0: 	 *
0: 	 * @param arg1 the date, time, or timestamp value
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public void init(Object arg1)
0: 			throws StandardException {
0:         DataValueDescriptor dvd = null;
0:         
0: 		if (arg1 instanceof TypeId)
0: 		{
0: 			super.init(
0: 					arg1,
0: 					Boolean.TRUE,
0: 					ReuseFactory.getInteger(
0: 										TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN));
0: 		}
0: 		else
0: 		{
0: 			Integer maxWidth = null;
0: 			TypeId	typeId = null;
0: 
0:             if( arg1 instanceof DataValueDescriptor)
0:                 dvd = (DataValueDescriptor) arg1;
0: 			if (arg1 instanceof Date
0:                 || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_DATE_ID))
0: 			{
0: 				maxWidth = ReuseFactory.getInteger(TypeId.DATE_MAXWIDTH);
0: 				typeId = TypeId.getBuiltInTypeId(Types.DATE);
0: 			}
0: 			else if (arg1 instanceof Time
0:                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIME_ID))
0: 			{
0: 				maxWidth = ReuseFactory.getInteger(TypeId.TIME_MAXWIDTH);
0: 				typeId = TypeId.getBuiltInTypeId(Types.TIME);
0: 			}
0: 			else if (arg1 instanceof Timestamp
0:                      || (dvd != null && dvd.getTypeFormatId() == StoredFormatIds.SQL_TIMESTAMP_ID))
0: 			{
0: 				maxWidth = ReuseFactory.getInteger(TypeId.TIMESTAMP_MAXWIDTH);
0: 				typeId = TypeId.getBuiltInTypeId(Types.TIMESTAMP);
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 							"Unexpected class " + arg1.getClass().getName());
0: 				}
0: 			}
0: 
0: 			super.init( 
0: 				typeId,
0: 				(arg1 == null) ? Boolean.TRUE : Boolean.FALSE,
0: 				maxWidth);
0: 
0:             if( dvd != null)
0:                 setValue( dvd);
0: 			else if (arg1 instanceof Date)
0: 			{
0: 				setValue(getDataValueFactory().getDataValue((Date) arg1));
0: 			}
0: 			else if (arg1 instanceof Time)
0: 			{
0: 				setValue(getDataValueFactory().getDataValue((Time) arg1));
0: 			}
0: 			else if (arg1 instanceof Timestamp)
0: 			{
0: 				setValue(getDataValueFactory().getDataValue((Timestamp) arg1));
0: 			}
0: 
0: 			value = arg1;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return the object value of this user defined type.
0: 	 *
0: 	 * @return	the value of this constant. can't use getValue() for this.
0: 	 *			getValue() returns the DataValueDescriptor for the built-in
0: 	 *			types that are implemented as user types (date, time, timestamp)
0: 	 */
0:     public	Object	getObjectValue() { return value; }
0: 
0: 	/**
0: 	 * Return whether or not this node represents a typed null constant.
0: 	 *
0: 	 */
0: 	public boolean isNull()
0: 	{
0: 		return (value == null);
0: 	}
0: 
0: 	/**
0: 	 * Return the value of this user defined type as a Storable
0: 	 *
0: 	 * @return	the value of this constant as a UserType
0: 	 * @exception StandardException thrown on failure
0: 	 */
0:     public	DataValueDescriptor	getStorableValue()
0: 			throws StandardException
0: 	{
0:         if( value instanceof DataValueDescriptor)
0:             return ((DataValueDescriptor) value).getClone();
0:         
0: 		DataValueFactory			dvf = getDataValueFactory();
0: 		TypeId			typeID = getTypeId();
0: 		String						typeName = typeID.getSQLTypeName();
0: 
0: 		if ( typeName.equals( TypeId.DATE_NAME ) )
0: 		{
0: 			return	new SQLDate((Date) value);
0: 		}
0: 		else if ( typeName.equals( TypeId.TIME_NAME ) )
0: 		{
0: 			return	new SQLTime( (Time) value);
0: 		}
0: 		else if ( typeName.equals( TypeId.TIMESTAMP_NAME ) )
0: 		{
0: 			return	new SQLTimestamp( (Timestamp) value);
0: 		}
0: 		else
0: 		{
0: 			return	dvf.getDataValue( value, (UserDataValue) null );
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Sets the object value of this user defined type
0: 	 *
0: 	 * @param	the value of this constant. can't use setValue() for this.
0: 	 */
0:     public	void	setObjectValue( Object newValue ) { value = newValue; }
0: 
0: 	/**
0: 	 * Return the length
0: 	 *
0: 	 * @return	The length of the value this node represents
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	//public int	getLength() throws StandardException {
0: 	//	return TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;
0: 	//}
0: 
0: 	/**
0: 	 * Return an Object representing the bind time value of this
0: 	 * expression tree.  If the expression tree does not evaluate to
0: 	 * a constant at bind time then we return null.
0: 	 * This is useful for bind time resolution of VTIs.
0: 	 * RESOLVE: What do we do for primitives?
0: 	 *
0: 	 * @return	An Object representing the bind time value of this expression tree.
0: 	 *			(null if not a bind time constant.)
0: 	 *
0: 	 */
0: 	public Object getConstantValueAsObject()
0: 	{
0: 		return value;
0: 	}
0: 
0: 	/**
0: 	 * For a UserTypeConstantNode, we have to store away the object somewhere
0: 	 * and have a way to get it back at runtime.
0: 	 * These objects are serializable.  This gives us at least two options:
0: 	 * 1) serialize it out into a byte array field, and serialize
0: 	 *	  it back in when needed, from the field.
0: 	 * 2) have an array of objects in the prepared statement and a #,
0: 	 *	  to find the object directly. Because it is serializable, it
0: 	 *	  will store with the rest of the executable just fine.
0: 	 * Choice 2 gives better performance -- the ser/deser cost is paid
0: 	 * on database access for the statement, not for each execution of it.
0: 	 * However, it requires some infrastructure support from prepared
0: 	 * statements.  For now, we take choice 3, and make some assumptions
0: 	 * about available methods on the user type.  This choice has the
0: 	 * shortcoming that it will not work for arbitrary user types.
0: 	 * REVISIT and implement choice 2 when a general solution is needed.
0: 	 * <p>
0: 	 * A null is generated as a Null value cast to the type of
0: 	 * the constant node.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException {
0: 
0: 		TypeCompiler		tc = getTypeCompiler();
0:         String fieldType = tc.interfaceName();
0: 
0: 		/*
0: 		** NOTE: DO NOT CALL THE CONSTRUCTOR TO GENERATE ANYTHING.  IT HAS
0: 		** A DIFFERENT value FIELD.
0: 		*/
0: 		
0: 		/* Are we generating a SQL null value? */
0: 	    if (value == null)
0: 	    {
0: 			acb.generateNull(mb, tc);
0: 	    }
0:         // The code generated here is invoked when the generated class is constructed. However the prepared statement
0:         // is not set into the activation class when it is constructed, but later. So we cannot use the getSavedObject
0:         // method to retrieve the value.
0: //         else if( value instanceof DataValueDescriptor)
0: //         {
0: //             acb.pushThisAsActivation( mb);
0: //             mb.callMethod( VMOpcode.INVOKEINTERFACE,
0: //                            null,
0: //                            "getPreparedStatement",
0: //                            ClassName.ExecPreparedStatement,
0: //                            0);
0: //             mb.push( acb.addItem( value));
0: //             mb.callMethod( VMOpcode.INVOKEINTERFACE,
0: //                            null,
0: //                            "getSavedObject",
0: //                            "java.lang.Object",
0: //                            1);
0: //             mb.cast( fieldType);
0: //         }
0: 		else
0: 		{
0: 			/*
0: 				The generated java is the expression:
0: 					<java type name>.valueOf("<value.toString>")
0: 
0: 				super.generateValue will wrap this expression in
0: 				the appropriate column constructor.
0: 
0: 				If the type doesn't have a valueOf method, then we will
0: 				give an error.  We have to assume that valueOf will
0: 				reconstruct the object from a String literal.  If this is
0: 				a false assumption, some other object may be constructed,
0: 				or a runtime error may result due to valueOf failing.
0: 		 	*/
0: 			String typeName = getTypeId().getCorrespondingJavaTypeName();
0: 
0: 			mb.push(value.toString());
0: 			mb.callMethod(VMOpcode.INVOKESTATIC, typeName, "valueOf", typeName, 1);
0: 
0: 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, fieldType);
0: 
0: 			acb.generateDataValue(mb, tc, field);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Should never be called for UserTypeConstantNode because
0: 	 * we have our own generateExpression().
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @return		The compiled Expression, 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb) 
0: 	throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("geneateConstant() not expected to be called for UserTypeConstantNode because we have implemented our own generateExpression().");
0: 		}
0: 	}
0: }
============================================================================