1:ffdaf1e: /*
9:ffdaf1e: 
1:ffdaf1e:    Derby - Class org.apache.derbyTesting.functionTests.tests.
1:ffdaf1e:                                          tools.ImportExportLobTest
1:ffdaf1e: 
1:ffdaf1e:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ffdaf1e:    contributor license agreements.  See the NOTICE file distributed with
1:ffdaf1e:    this work for additional information regarding copyright ownership.
1:ffdaf1e:    The ASF licenses this file to You under the Apache License, Version 2.0
1:ffdaf1e:    (the "License"); you may not use this file except in compliance with
1:ffdaf1e:    the License.  You may obtain a copy of the License at
1:ffdaf1e: 
1:ffdaf1e:       http://www.apache.org/licenses/LICENSE-2.0
1:ffdaf1e: 
1:ffdaf1e:    Unless required by applicable law or agreed to in writing, software
1:ffdaf1e:    distributed under the License is distributed on an "AS IS" BASIS,
1:ffdaf1e:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ffdaf1e:    See the License for the specific language governing permissions and
1:ffdaf1e:    limitations under the License.
1:ffdaf1e: 
2:ffdaf1e:  */
1:ffdaf1e: package org.apache.derbyTesting.functionTests.tests.tools;
1:ffdaf1e: 
1:1ae02c9: import java.io.IOException;
1:1ae02c9: import java.io.InputStream;
1:1ae02c9: import java.io.Reader;
1:1ae02c9: import java.sql.Connection;
1:ffdaf1e: import java.sql.PreparedStatement;
1:ffdaf1e: import java.sql.ResultSet;
1:ffdaf1e: import java.sql.SQLException;
1:ffdaf1e: import java.sql.Statement;
1:ffdaf1e: import junit.framework.Test;
1:ffdaf1e: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:ffdaf1e: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e: /**
1:ffdaf1e:  * This class tests import/export of a table with data types clob and blob.
1:ffdaf1e:  */
1:ffdaf1e: 
1:ffdaf1e: public class ImportExportLobTest extends ImportExportBaseTest
1:ffdaf1e: {
1:ffdaf1e: 
1:ffdaf1e:     String fileName; // main file used to perform import/export.
1:ffdaf1e:     String lobsFileName; // file name used to store lobs.
1:89ed7a4:     String lobsFileName2; // file name used to store lobs.
1:ffdaf1e: 
1:ffdaf1e:     public ImportExportLobTest(String name) throws SQLException {
1:ffdaf1e:         super(name);
1:ffdaf1e:         // set the file that is used by the import/export test cases.
1:ffdaf1e:         fileName = 
1:ffdaf1e:             (SupportFilesSetup.getReadWrite("books.del")).getPath();
1:ffdaf1e:         lobsFileName = 
1:ffdaf1e:             (SupportFilesSetup.getReadWrite("books_lobs.dat")).getPath();
1:89ed7a4: 	lobsFileName2 =
1:89ed7a4:             (SupportFilesSetup.getReadWrite("unql_books_lobs.dat")).getPath();
1:ffdaf1e:     }
1:e17a43d: 
1:e17a43d:     /**
1:ffdaf1e:      * Runs the tests in the default embedded configuration and then
1:ffdaf1e:      * the client server configuration.
1:ffdaf1e:      */
1:ffdaf1e:     public static Test suite()
1:ffdaf1e:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(ImportExportLobTest.class);
1:ffdaf1e:         suite.addTest(TestConfiguration.clientServerSuite(
1:ffdaf1e:                              ImportExportLobTest.class));
1:ffdaf1e:         Test test = suite;
1:ffdaf1e:         test = new SupportFilesSetup(test);
1:ffdaf1e:         return new CleanDatabaseTestSetup(test) {
1:ffdaf1e:                 protected void decorateSQL(Statement s) throws SQLException {
1:ffdaf1e:                     // table used to test  export.
1:ffdaf1e:                     s.execute("CREATE TABLE BOOKS(id int," +
1:ffdaf1e:                               "name varchar(30)," + 
1:ffdaf1e:                               "content clob, " + 
1:ffdaf1e:                               "pic blob )");
1:ffdaf1e:                     // load some data into the above table. 
1:ffdaf1e:                     loadData(s);
1:ffdaf1e:                     // table used to test import. 
1:ffdaf1e:                     s.execute("CREATE TABLE BOOKS_IMP(id int," +
1:ffdaf1e:                               "name varchar(30)," + 
1:ffdaf1e:                               "content clob," +  
1:ffdaf1e:                               "pic blob )");
1:ffdaf1e:                     // table that holds some invalid hex strings. 
1:ffdaf1e:                     s.execute("CREATE TABLE hex_tab(id int," +
1:ffdaf1e:                               "C1 varchar(20)," + 
1:ffdaf1e:                               "C2 varchar(20)," +
1:ffdaf1e:                               "C3 varchar(20))");
1:927ad05: 		    s.execute("CREATE TABLE derby_2925_lob(id int," +
1:927ad05: 			      "name varchar(30), content clob," +
1:927ad05: 			      "pic blob)");
1:ffdaf1e:                 }
1:ffdaf1e:             };
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e:     
1:ffdaf1e:     /**
1:ffdaf1e:      * Simple set up, just empty the import table.
1:ffdaf1e:      * @throws SQLException 
1:ffdaf1e:      */
1:ffdaf1e:     protected void setUp() throws SQLException
1:ffdaf1e:     {
1:ffdaf1e:         Statement s  = createStatement();
1:ffdaf1e:         // delete the rows from the import table.
1:ffdaf1e:         s.executeUpdate("DELETE FROM BOOKS_IMP");
1:ffdaf1e:         s.close();
1:e17a43d:         // delete the export files. 
1:e17a43d:         SupportFilesSetup.deleteFile(fileName);
1:e17a43d:         SupportFilesSetup.deleteFile(lobsFileName);
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e:     /**
1:e17a43d:      * Test import/export of a table, using 
1:ffdaf1e:      * SYSCS_EXPORT_TABLE and SYSCS_IMPORT_TABLE procedures.
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportTableExportTable()  
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:ffdaf1e:         doExportTable("APP", "BOOKS", fileName, null, null , null);
1:ffdaf1e: 	    doImportTable("APP", "BOOKS_IMP", fileName, null, null, null, 0);
2:ffdaf1e:         verifyData(" * ");
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e:     
1:ffdaf1e:     /*
1:ffdaf1e:      * Test import/export of all the columns using 
2:ffdaf1e:      * SYSCS_EXPORT_QUERY and SYSCS_IMPORT_DATA procedures.  
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportDataExportQuery() 
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:ffdaf1e:         doExportQuery("select * from BOOKS", fileName,
1:ffdaf1e:                       null, null , null);
1:ffdaf1e: 	    doImportData(null, "BOOKS_IMP", null, null, fileName, 
3:ffdaf1e:                      null, null, null, 0);
1:ffdaf1e:         verifyData(" * ");
1:ffdaf1e: 
1:ffdaf1e:         // perform import with column names specified in random order.
1:ffdaf1e:         doImportData(null, "BOOKS_IMP", "PIC, CONTENT, NAME, ID", 
1:ffdaf1e:                      "4, 3, 2, 1",  fileName, null, null, null, 1);
1:ffdaf1e:         verifyData("PIC, CONTENT, NAME, ID");
1:927ad05: 	
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:927ad05: 
1:ffdaf1e:         // test with  non-default delimiters. 
1:ffdaf1e:         doExportQuery("select * from BOOKS_IMP", fileName,
1:ffdaf1e:                       ";", "%" , null);
1:ffdaf1e: 	    doImportData(null, "BOOKS_IMP", null, null, fileName, 
1:ffdaf1e:                      ";", "%", null, 1);
1:ffdaf1e: 
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e:     /*
1:ffdaf1e:      * Test import of only some columns of the table 
2:ffdaf1e:      * using  SYSCS_EXPOR_QUERY and IMPORT_DATA procedures.  
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportDataExportQueryWithFewColumns() 
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:ffdaf1e:         doExportQuery("select id, name, content, pic from BOOKS",  
1:ffdaf1e:                       fileName,  null, null, null);
1:ffdaf1e:         doImportData(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
2:ffdaf1e:                      fileName, null, null, null, 0);
1:ffdaf1e:         verifyData("ID,PIC");
1:ffdaf1e:         doImportData(null, "BOOKS_IMP", "ID, PIC, NAME", "1, 4, 2",
1:ffdaf1e:                      fileName, null, null, null, 1);
1:ffdaf1e:         verifyData("ID, PIC, NAME");
1:ffdaf1e:         doImportData(null, "BOOKS_IMP", "ID, CONTENT, NAME", "1, 3, 2",
1:ffdaf1e:                      fileName, null, null, null, 1);
1:ffdaf1e:         verifyData("ID, CONTENT, NAME");
1:927ad05: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:ffdaf1e: 
1:ffdaf1e:         // test with  non-default delimiters. 
1:ffdaf1e:         doExportQuery("select id, name, content, pic from BOOKS",  
1:ffdaf1e:                       fileName,  "$", "!" , null);
1:ffdaf1e:         doImportData(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:ffdaf1e:                      fileName, "$", "!", null, 0);
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e:     /* 
1:ffdaf1e:      * Test import procedures with invalid hex strings in 
1:ffdaf1e:      * the import file for the blob column. 
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportWithInvalidHexStrings() 
1:ffdaf1e:         throws SQLException   
1:ffdaf1e:     {
1:ffdaf1e:         Statement s = createStatement();
1:ffdaf1e:         // Insert row with correctly formed hex strings.  
1:ffdaf1e:         s.executeUpdate("insert into hex_tab " + 
1:ffdaf1e:                         "values(1, 'row 1', 'clob 1', 'B1C201DA')");
1:ffdaf1e: 
1:ffdaf1e:         // Insert row with an invalid hex string, because 
1:ffdaf1e:         // it's length is not a multiple of 2 (B1C201A) , 
1:ffdaf1e:         s.executeUpdate("insert into hex_tab " + 
1:ffdaf1e:                         "values(2, 'row 2', 'clob2 ', 'B1C201A')");
1:ffdaf1e: 
1:ffdaf1e:         // Insert row with an invalid hex string that contains 
1:ffdaf1e:         // a non-hex character (3122A1F20Z). 
1:ffdaf1e:         s.executeUpdate("insert into hex_tab " + 
1:ffdaf1e:                         "values(3, '', 'clobs 3', '3122A1F20Z')");
1:ffdaf1e: 
1:ffdaf1e:         // Insert row with an invalid hex string that contains 
1:ffdaf1e:         // a delimiter character (B1C2\"01DA). 
1:ffdaf1e:         s.executeUpdate("insert into hex_tab " + 
1:ffdaf1e:                         "values(4, 'row \"4', '3122A1F20Z', 'B1C2\"01DA')");
1:ffdaf1e:         s.close();
1:ffdaf1e: 
1:ffdaf1e:         // export the invalid hex strings from the table to a file. 
1:ffdaf1e:         doExportTable("APP", "HEX_TAB", fileName, null, null , null);
1:ffdaf1e: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:ffdaf1e: 
1:ffdaf1e:         // attempt to import the invalid hex string data into a table 
1:ffdaf1e:         // with binary columns. It should fail.
1:ffdaf1e:  
1:ffdaf1e:         try {
1:ffdaf1e:             
1:ffdaf1e:             doExportQuery("select * from hex_tab where id <= 2",  
1:ffdaf1e:                           fileName,  null, null, null);
1:ffdaf1e:             // import should fail because of invalied hex string length
1:ffdaf1e:             doImportTable("APP", "BOOKS_IMP", fileName, null, null, null, 0);
1:ffdaf1e:             fail("import did not fail on data with invalid hex string");
1:ffdaf1e:         } catch (SQLException e) {
1:de3b108:              assertSQLState("XIE0N", e);
1:ffdaf1e:         }
1:927ad05: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:927ad05: 
1:ffdaf1e:         try {
1:ffdaf1e:             doExportQuery("select * from hex_tab where id = 3",  
1:ffdaf1e:                           fileName,  null, null, null);
1:ffdaf1e:             // import should fail because hex string contains invalid 
1:ffdaf1e:             // hex chatacters.
1:ffdaf1e:             doImportData(null, "BOOKS_IMP", "ID, PIC", "1,4",
1:ffdaf1e:                          fileName, null, null, null, 1);
1:ffdaf1e:             fail("import did not fail on data with invalid hex strings");
1:ffdaf1e:         } catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0N", e);
1:ffdaf1e:         }
1:ffdaf1e: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:ffdaf1e: 
1:ffdaf1e:         try {
1:ffdaf1e:             doExportQuery("select * from hex_tab where id = 4",  
1:ffdaf1e:                           fileName,  null, null, null);
1:ffdaf1e:             // import should fail because hex string contains invalid 
1:ffdaf1e:             // hex chatacters.
1:ffdaf1e:             doImportData(null, "BOOKS_IMP", "ID, PIC", "1,4",
1:ffdaf1e:                          fileName, null, null, null, 1);
1:ffdaf1e:             fail("import did not fail on data with invalid hex strings");
1:ffdaf1e:         } catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0N", e);
1:ffdaf1e:         }
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e: 
1:e17a43d:     /**
1:e17a43d:      * Test import/export of a table, using 
1:e17a43d:      * SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE and 
1:c8f894e:      * SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE  procedures.
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportTableExportTableLobsInExtFile()  
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:c8f894e:         doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
2:ffdaf1e:                                    null, null , null, lobsFileName);
1:e17a43d: 	    doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
1:c8f894e:                                      null, null, null, 0);
1:ffdaf1e:         verifyData(" * ");
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e:     /**
1:ffdaf1e:      * Test import/export of a table, using 
1:e17a43d:      * SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE and 
1:e17a43d:      * SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE  procedures, 
1:e17a43d:      * with an unqualified lob data file name as parameter
1:e17a43d:      * for the export procedure.
1:e17a43d:      */
1:e17a43d:     public void testImportTableExportTableLobsInUnqalifiedExtFile()  
1:e17a43d:         throws SQLException, IOException
1:e17a43d:     {
1:e17a43d:         // test export procedure with unqulified lob data  file name
1:e17a43d:         // lob data file should get crated at the same location, where
1:e17a43d:         // the main export file is created. And also perform import/export
1:e17a43d:         // using "UTF-16" code set.
1:89ed7a4:        
1:89ed7a4: 	// delete the export files.
1:89ed7a4:         SupportFilesSetup.deleteFile(lobsFileName2);
1:89ed7a4:  
1:e17a43d:         doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:e17a43d:                                     "\t", "|", "UTF-16", 
1:89ed7a4:                                    lobsFileName2);
1:2d3034f:         // DERBY-2546 - with JSR this hits a JVM issue
1:2d3034f:         if (JDBC.vmSupportsJDBC3()) 
1:2d3034f:         {
1:2d3034f:             doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
1:2d3034f:                 "\t", "|", "UTF-16", 0);
1:2d3034f:             verifyData(" * ");
1:2d3034f:         }
1:2d3034f:         
1:e17a43d:     }
1:e17a43d: 
1:e17a43d: 
1:e17a43d:     
1:ffdaf1e:     /*
1:ffdaf1e:      * Test import/export of all the columns using 
1:c8f894e:      * SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE and 
1:c8f894e:      * SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE procedures.  
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportDataExportQueryLobsInExtFile() 
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:c8f894e:         doExportQueryLobsToExtFile("select * from BOOKS", fileName,
1:e17a43d:                                   null, null, "8859_1", lobsFileName);
1:c8f894e: 	    doImportDataLobsFromExtFile(null, "BOOKS_IMP", null, null, fileName, 
1:e17a43d:                                    null, null , "8859_1", 0);
1:e17a43d:         verifyData(" * ");
1:ffdaf1e: 
1:ffdaf1e:         // perform import with column names specified in random order.
1:c8f894e:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "PIC, CONTENT, NAME, ID", 
1:27e22fd:                                   "4, 3, 2, 1", fileName, null, null, "8859_1", 1);
1:ffdaf1e:         verifyData("PIC, CONTENT, NAME, ID");
1:ffdaf1e: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:927ad05:         SupportFilesSetup.deleteFile(lobsFileName);
1:ffdaf1e: 
1:ffdaf1e:         // test with  non-default delimiters. 
1:c8f894e:         doExportQueryLobsToExtFile("select * from BOOKS_IMP", fileName,
1:ffdaf1e:                                    ";", "%" , null, lobsFileName);
1:c8f894e: 	    doImportDataLobsFromExtFile(null, "BOOKS_IMP", null, null, fileName, 
1:ffdaf1e:                                   ";", "%", null, 1);
1:ffdaf1e: 
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e:     /*
1:ffdaf1e:      * Test import of only some columns of the table 
1:c8f894e:      * using  SYSCS_EXPOR_QUERY_LOBS_TO_EXTFILE and 
1:c8f894e:      * SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE procedures.  
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportDataExportQueryWithFewColsLobsInExtFile() 
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:c8f894e:         doExportQueryLobsToExtFile("select id, name, content, pic from BOOKS",
1:ffdaf1e:                                    fileName,  null, null, null, lobsFileName);
1:c8f894e:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:c8f894e:                                     fileName, null, null, null, 0);
1:ffdaf1e:         verifyData("ID,PIC");
1:c8f894e:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID, PIC, NAME", "1, 4, 2",
1:ffdaf1e:                                   fileName, null, null, null, 1);
1:ffdaf1e:         verifyData("ID, PIC, NAME");
1:c8f894e:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID, CONTENT, NAME", 
1:ffdaf1e:                                   "1, 3, 2", fileName, null, null, null, 1);
1:ffdaf1e:         verifyData("ID, CONTENT, NAME");
1:927ad05: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:927ad05:         SupportFilesSetup.deleteFile(lobsFileName);
1:ffdaf1e: 
1:ffdaf1e:         // test with  non-default delimiters. 
1:c8f894e:         doExportQueryLobsToExtFile("select id, name, content, pic from BOOKS",  
1:ffdaf1e:                                    fileName,  "$", "!" , null, lobsFileName);
1:c8f894e:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:ffdaf1e:                                   fileName, "$", "!", null, 0);
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e:     /* 
1:ffdaf1e:      *  Test lobs in exteranl file import/export procedures 
1:ffdaf1e:      *  with invalid delimiters. 
1:ffdaf1e:      */
1:ffdaf1e:     public void testImportExportInvalideDelimiters() 
1:ffdaf1e:          throws SQLException, IOException   
1:ffdaf1e:     {
1:ffdaf1e:         try {
1:c8f894e:             doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:ffdaf1e:                                        null, "9" , null, lobsFileName);
1:94d395e:             fail();
1:ffdaf1e:         } catch (SQLException e) {
1:ffdaf1e:             assertSQLState("XIE0J", e);
1:ffdaf1e:         }
1:927ad05: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:927ad05:         SupportFilesSetup.deleteFile(lobsFileName);
1:927ad05: 
1:ffdaf1e:         try {
1:c8f894e:             doExportQueryLobsToExtFile("select * from BOOKS", fileName,
1:ffdaf1e:                                        "|", "f", null, lobsFileName);
1:94d395e:             fail();
1:ffdaf1e:         } catch (SQLException e) {
1:ffdaf1e:             assertSQLState("XIE0J", e);
1:ffdaf1e:         }
1:ffdaf1e: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:927ad05:         SupportFilesSetup.deleteFile(lobsFileName);
1:ffdaf1e: 
1:c8f894e:         doExportQueryLobsToExtFile("select * from BOOKS where id < 10", 
1:ffdaf1e:                                    fileName, null, null, null, lobsFileName);
1:ffdaf1e: 
1:ffdaf1e:         try {
1:c8f894e:             doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, "2", 
1:c8f894e:                                          null, null, 0);
1:94d395e:             fail();
1:ffdaf1e:         } catch (SQLException e) {
1:de3b108:              assertSQLState("XIE0J", e);
1:ffdaf1e:         }
1:ffdaf1e: 
1:ffdaf1e:         try {
1:c8f894e:             doImportDataLobsFromExtFile(null, "BOOKS_IMP", null, 
1:ffdaf1e:                                       null,  fileName, null, "c", null, 1);
1:94d395e:             fail();
1:ffdaf1e:         } catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0J", e);
1:ffdaf1e:         }
1:ffdaf1e:     }
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e: 
1:ffdaf1e:     /**
1:ffdaf1e:      * Test import/export of a table, using 
1:c8f894e:      * SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE and 
1:e17a43d:      * SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE  procedures, with an unqualified
1:e17a43d:      * lobs file name as an argument value.
1:e17a43d:      */
1:e17a43d:     public void testImportTableExportWithInvalidLobFileName()  
1:e17a43d:         throws SQLException, IOException
1:e17a43d:     {
1:e17a43d:         // test export of lob data with lob file name parameter 
1:e17a43d:         // value as null,  it should fail.
1:e17a43d:         try {
1:e17a43d:             doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:e17a43d:                                        null, null , null, 
1:e17a43d:                                        null);
1:94d395e:             fail();
1:e17a43d:         }catch (SQLException e) {
1:e17a43d:             assertSQLState("XIE0Q", e);
1:e17a43d:         }
1:927ad05: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:e17a43d: 
1:e17a43d:         // export of lob data into an external file.
1:e17a43d:         doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:e17a43d:                                    null, null , null, 
1:e17a43d:                                    lobsFileName);
1:e17a43d:         // delete the lob data file, and then perfom the import.
1:e17a43d:         // import should fail with lob data file not found error. 
1:e17a43d:         SupportFilesSetup.deleteFile(lobsFileName);
1:e17a43d:         try {
1:e17a43d:             // missing lob file, refered by the main import file.
1:e17a43d:             doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
1:e17a43d:                                          null, null, null, 0);
1:94d395e:             fail();
1:e17a43d:         }catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0P", e);
1:e17a43d:         }
1:e17a43d:     }
1:e17a43d: 
1:927ad05:     public void testDerby2955ExportQueryLobs()
1:927ad05: 	throws SQLException
1:927ad05:     {
1:927ad05: 	doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:927ad05:                                    "\t", "|", "UTF-16",
1:927ad05:                                    lobsFileName);
1:927ad05: 	try {
1:927ad05:        	    doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:927ad05:                                    "\t", "|", "UTF-16",
1:927ad05:                                    lobsFileName);
1:927ad05: 	    fail("export should have failed as the data file exists.");
1:927ad05: 	}
1:927ad05: 	catch (SQLException e) {
1:927ad05:             assertSQLState("XIE0S", e);
1:927ad05:         }
1:927ad05: 
1:927ad05: 	//DERBY-2925: need to delete export files first
1:927ad05:         SupportFilesSetup.deleteFile(fileName);
1:927ad05:         SupportFilesSetup.deleteFile(lobsFileName);
1:927ad05: 
1:927ad05: 	doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:927ad05:                                    "\t", "|", "UTF-16",
1:927ad05:                                    lobsFileName);
1:927ad05:         // delete the data file, and then perform export
1:927ad05: 	// export should fail with lob file already exists error. 
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:927ad05: 
1:927ad05:         try {
1:927ad05:             doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:927ad05:                                    "\t", "|", "UTF-16",
1:927ad05:                                    lobsFileName);
1:927ad05:             fail("export should have failed as the data file exists.");
1:927ad05:         }
1:927ad05:         catch (SQLException e) {
1:927ad05:             assertSQLState("XIE0T", e);
1:927ad05:         }
1:927ad05:     }
1:927ad05: 
1:927ad05: 
1:927ad05: 
1:e17a43d: 
1:e17a43d: 
1:ffdaf1e:     /* 
1:ffdaf1e:      * Verifies data in the import test table (BOOKS_IMP) is same 
1:ffdaf1e:      * as the test table from which the data was exported earlier(BOOKS). 
1:ffdaf1e:      * @param cols  imported columns , if all then " * ", otherwise 
1:ffdaf1e:      *              comma separated column list. 
1:ffdaf1e:      * @exception SQLException  if the data does match or if 
1:ffdaf1e:      *                          any other error during comparision.  
1:ffdaf1e:      */
1:ffdaf1e:     private void verifyData(String cols)  
1:ffdaf1e:         throws SQLException, IOException
1:ffdaf1e:     {
1:ffdaf1e:         Statement s1 = createStatement();
1:ffdaf1e:         ResultSet rsExport = s1.executeQuery("SELECT " + cols  +  
1:ffdaf1e:                                              " FROM BOOKS order by id");
1:ffdaf1e:         Statement s2 = createStatement();
1:ffdaf1e:         ResultSet rsImport = s2.executeQuery("SELECT " + cols  +  
1:ffdaf1e:                                              " FROM BOOKS_IMP order by id");
1:ffdaf1e:         JDBC.assertSameContents(rsExport, rsImport);
1:ffdaf1e:         
1:ffdaf1e:         s1.close();
1:ffdaf1e:         s2.close();
1:ffdaf1e:     }
1:ffdaf1e:     
1:ffdaf1e: 
1:ffdaf1e:     /*
1:ffdaf1e:      * Insert data to the into the table, whose data will be exported.
1:ffdaf1e:      */
1:ffdaf1e:     private static void loadData(Statement s) throws SQLException {
1:ffdaf1e: 
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(1, 'book 1', 'clob 1'," +  
1:ffdaf1e:                         "cast(X'3743640ADE12337610' as blob))");
1:ffdaf1e:         // rows with empty strings. 
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(2, 'book 2', 'clob 2',  cast (X'' as blob))");
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(3, 'book 3', '', cast(X'42' as blob))");
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(4, 'book 4', 'clob 4',  " + 
1:ffdaf1e:                         "cast (X'3233445578990122558820' as blob))");
1:ffdaf1e:         
1:ffdaf1e:         // rows with a null
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(5, null, 'clob 5'," +  
1:ffdaf1e:                         "cast(X'3843640ADE12337610' as blob))");
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(6,  'book  6', null,  " + 
1:ffdaf1e:                         "cast(X'3843640ADE12337610' as blob))");
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(7,  'book  7',  'clob 7' , null)");
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(8, '', null,  cast (X'3843640ADE12' as blob))");
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(9, 'book  9', null,  cast (X'' as blob))");
1:ffdaf1e:         
1:ffdaf1e:         // insert data that contains some delimiter characters 
1:ffdaf1e:         // ( "(x22) ,(x2C) %(x25) ;(x3B) , tab(9) LF(A) )
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(10, 'book ;10', '%asdadasdasd'," + 
1:ffdaf1e:                         " cast (X'222C23B90A' as blob))");
1:ffdaf1e:         // !(x21) $(24)
1:ffdaf1e:         s.executeUpdate("insert into books values " + 
1:ffdaf1e:                         "(11, '212C3B24', '2422412221', " + 
1:ffdaf1e:                         "  cast (X'212421222C23B90A2124' as blob))");
1:c8f894e:         // insert some clob data with default char delimiter inside 
1:c8f894e:         // the data. It should get exported in double-delimiter format
1:c8f894e:         // when exporting to the main export file. 
1:c8f894e:         s.executeUpdate("insert into books values" +
1:c8f894e:                         "(12, 'Transaction Processing' , " +
1:c8f894e:                         "'This books covers \"Transaction\" \"processing\" concepts'"+
1:c8f894e:                         ",cast (X'144594322143423214ab35f2e54e' as blob))");
1:c8f894e:         s.executeUpdate("insert into books values" + 
1:c8f894e:                         "(13, 'effective java' ," +  
1:c8f894e:                         "'describes how to write \" quality java \" code', " +
1:c8f894e:                         "cast (X'124594322143423214ab35f2e34c' as blob))");
1:ffdaf1e: 
1:ffdaf1e:         // insert some more randomly genrated data.
1:ffdaf1e:         Connection conn = s.getConnection();
1:ffdaf1e:         String sql = "insert into books values(? , ? , ? , ?)";
1:ffdaf1e:         PreparedStatement ps = conn.prepareStatement(sql);
1:ffdaf1e:         int blobSize = 0;
1:c8f894e:         int id = 14;
1:ffdaf1e:         for (int i = 0 ; i < 17 ; i++) {
1:ffdaf1e:             ps.setInt(1 , id++);
1:ffdaf1e:             ps.setString(2 , "book" +i);
1:ffdaf1e:             blobSize +=  1024 * i;
1:ffdaf1e:             int clobSize = 1024 * i;
1:ffdaf1e:             Reader reader = new LoopingAlphabetReader(clobSize);
1:ffdaf1e:             ps.setCharacterStream(3, reader, clobSize);
1:ffdaf1e:             InputStream stream = new LoopingAlphabetStream(blobSize);
1:ffdaf1e:             ps.setBinaryStream(4, stream, blobSize);
1:ffdaf1e:             ps.executeUpdate();
1:ffdaf1e: 
1:ffdaf1e:             if ((i % 10) == 0) 
1:ffdaf1e:                 conn.commit();
1:ffdaf1e:         }
1:ffdaf1e: 
1:ffdaf1e:         ps.close();
1:ffdaf1e:         conn.commit();
1:ffdaf1e:     }
1:ffdaf1e: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.sql.Connection;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(ImportExportLobTest.class);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:94d395e
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1:              assertSQLState("XIE0N", e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XIE0N", e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XIE0N", e);
/////////////////////////////////////////////////////////////////////////
1:              assertSQLState("XIE0J", e);
1:             assertSQLState("XIE0J", e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XIE0P", e);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:27e22fd
/////////////////////////////////////////////////////////////////////////
1:                                   "4, 3, 2, 1", fileName, null, null, "8859_1", 1);
commit:89ed7a4
/////////////////////////////////////////////////////////////////////////
1:     String lobsFileName2; // file name used to store lobs.
/////////////////////////////////////////////////////////////////////////
1: 	lobsFileName2 =
1:             (SupportFilesSetup.getReadWrite("unql_books_lobs.dat")).getPath();
/////////////////////////////////////////////////////////////////////////
1:        
1: 	// delete the export files.
1:         SupportFilesSetup.deleteFile(lobsFileName2);
1:  
1:                                    lobsFileName2);
commit:927ad05
/////////////////////////////////////////////////////////////////////////
1: 		    s.execute("CREATE TABLE derby_2925_lob(id int," +
1: 			      "name varchar(30), content clob," +
1: 			      "pic blob)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	//DERBY-2925: need to delete export files first
1: 	SupportFilesSetup.deleteFile(fileName);
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1:         SupportFilesSetup.deleteFile(lobsFileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1:         SupportFilesSetup.deleteFile(lobsFileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1:         SupportFilesSetup.deleteFile(lobsFileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1:         SupportFilesSetup.deleteFile(lobsFileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testDerby2955ExportQueryLobs()
1: 	throws SQLException
1:     {
1: 	doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:                                    "\t", "|", "UTF-16",
1:                                    lobsFileName);
1: 	try {
1:        	    doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:                                    "\t", "|", "UTF-16",
1:                                    lobsFileName);
1: 	    fail("export should have failed as the data file exists.");
1: 	}
1: 	catch (SQLException e) {
1:             assertSQLState("XIE0S", e);
1:         }
1: 
1: 	//DERBY-2925: need to delete export files first
1:         SupportFilesSetup.deleteFile(fileName);
1:         SupportFilesSetup.deleteFile(lobsFileName);
1: 
1: 	doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:                                    "\t", "|", "UTF-16",
1:                                    lobsFileName);
1:         // delete the data file, and then perform export
1: 	// export should fail with lob file already exists error. 
1: 	SupportFilesSetup.deleteFile(fileName);
1: 
1:         try {
1:             doExportTableLobsToExtFile("APP", "DERBY_2925_LOB", fileName,
1:                                    "\t", "|", "UTF-16",
1:                                    lobsFileName);
1:             fail("export should have failed as the data file exists.");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("XIE0T", e);
1:         }
1:     }
1: 
1: 
1: 
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2d3034f
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-2546 - with JSR this hits a JVM issue
1:         if (JDBC.vmSupportsJDBC3()) 
1:         {
1:             doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
1:                 "\t", "|", "UTF-16", 0);
1:             verifyData(" * ");
1:         }
1:         
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ca42bbe
/////////////////////////////////////////////////////////////////////////
0:              assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0N", e);
/////////////////////////////////////////////////////////////////////////
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0N", e);
/////////////////////////////////////////////////////////////////////////
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0N", e);
/////////////////////////////////////////////////////////////////////////
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0P", e);
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:e17a43d
/////////////////////////////////////////////////////////////////////////
1:         // delete the export files. 
1:         SupportFilesSetup.deleteFile(fileName);
1:         SupportFilesSetup.deleteFile(lobsFileName);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test import/export of a table, using 
1:      * SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE and 
1:      * SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE  procedures, 
1:      * with an unqualified lob data file name as parameter
1:      * for the export procedure.
1:      */
1:     public void testImportTableExportTableLobsInUnqalifiedExtFile()  
1:         throws SQLException, IOException
1:     {
1:         // test export procedure with unqulified lob data  file name
1:         // lob data file should get crated at the same location, where
1:         // the main export file is created. And also perform import/export
1:         // using "UTF-16" code set.
1:         
1:         doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:                                     "\t", "|", "UTF-16", 
0:                                    "unql_books_lobs.dat");
1: 	    doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
0:                                      "\t", "|", "UTF-16", 0);
1:         verifyData(" * ");
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                                   null, null, "8859_1", lobsFileName);
1:                                    null, null , "8859_1", 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test import/export of a table, using 
1:      * SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE and 
1:      * SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE  procedures, with an unqualified
1:      * lobs file name as an argument value.
1:      */
1:     public void testImportTableExportWithInvalidLobFileName()  
1:         throws SQLException, IOException
1:     {
1:         // test export of lob data with lob file name parameter 
1:         // value as null,  it should fail.
1:         try {
1:             doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:                                        null, null , null, 
1:                                        null);
1:         }catch (SQLException e) {
1:             assertSQLState("XIE0Q", e);
1:         }
1: 
1:         // export of lob data into an external file.
1:         doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:                                    null, null , null, 
1:                                    lobsFileName);
1:         // delete the lob data file, and then perfom the import.
1:         // import should fail with lob data file not found error. 
1:         SupportFilesSetup.deleteFile(lobsFileName);
1:         try {
1:             // missing lob file, refered by the main import file.
1:             doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
1:                                          null, null, null, 0);
1:         }catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0P", e);
1:         }
1:     }
1: 
1: 
1: 
commit:c8f894e
/////////////////////////////////////////////////////////////////////////
1:      * SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE and 
1:      * SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE  procedures.
1:         doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
0: 	    doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, 
1:                                      null, null, null, 0);
1:      * SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE and 
1:      * SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE procedures.  
1:         doExportQueryLobsToExtFile("select * from BOOKS", fileName,
1: 	    doImportDataLobsFromExtFile(null, "BOOKS_IMP", null, null, fileName, 
1:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "PIC, CONTENT, NAME, ID", 
1:         doExportQueryLobsToExtFile("select * from BOOKS_IMP", fileName,
1: 	    doImportDataLobsFromExtFile(null, "BOOKS_IMP", null, null, fileName, 
/////////////////////////////////////////////////////////////////////////
1:      * using  SYSCS_EXPOR_QUERY_LOBS_TO_EXTFILE and 
1:      * SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE procedures.  
1:         doExportQueryLobsToExtFile("select id, name, content, pic from BOOKS",
1:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:                                     fileName, null, null, null, 0);
1:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID, PIC, NAME", "1, 4, 2",
1:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID, CONTENT, NAME", 
1:         doExportQueryLobsToExtFile("select id, name, content, pic from BOOKS",  
1:         doImportDataLobsFromExtFile(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
/////////////////////////////////////////////////////////////////////////
1:             doExportTableLobsToExtFile("APP", "BOOKS", fileName, 
1:             doExportQueryLobsToExtFile("select * from BOOKS", fileName,
1:         doExportQueryLobsToExtFile("select * from BOOKS where id < 10", 
/////////////////////////////////////////////////////////////////////////
1:             doImportTableLobsFromExtFile("APP", "BOOKS_IMP", fileName, "2", 
1:                                          null, null, 0);
1:             doImportDataLobsFromExtFile(null, "BOOKS_IMP", null, 
/////////////////////////////////////////////////////////////////////////
1:         // insert some clob data with default char delimiter inside 
1:         // the data. It should get exported in double-delimiter format
1:         // when exporting to the main export file. 
1:         s.executeUpdate("insert into books values" +
1:                         "(12, 'Transaction Processing' , " +
1:                         "'This books covers \"Transaction\" \"processing\" concepts'"+
1:                         ",cast (X'144594322143423214ab35f2e54e' as blob))");
1:         s.executeUpdate("insert into books values" + 
1:                         "(13, 'effective java' ," +  
1:                         "'describes how to write \" quality java \" code', " +
1:                         "cast (X'124594322143423214ab35f2e34c' as blob))");
1:         int id = 14;
commit:ffdaf1e
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.
1:                                          tools.ImportExportLobTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.tools;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.sql.Connection;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.Reader;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: 
1: 
1: /**
1:  * This class tests import/export of a table with data types clob and blob.
1:  */
1: 
1: public class ImportExportLobTest extends ImportExportBaseTest
1: {
1: 
1:     String fileName; // main file used to perform import/export.
1:     String lobsFileName; // file name used to store lobs.
1: 
1:     public ImportExportLobTest(String name) throws SQLException {
1:         super(name);
1:         // set the file that is used by the import/export test cases.
1:         fileName = 
1:             (SupportFilesSetup.getReadWrite("books.del")).getPath();
1:         lobsFileName = 
1:             (SupportFilesSetup.getReadWrite("books_lobs.dat")).getPath();
1:     }
1: 
1:     /**
1:      * Runs the tests in the default embedded configuration and then
1:      * the client server configuration.
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite(ImportExportLobTest.class);
1:         suite.addTest(TestConfiguration.clientServerSuite(
1:                              ImportExportLobTest.class));
1:         Test test = suite;
1:         test = new SupportFilesSetup(test);
1:         return new CleanDatabaseTestSetup(test) {
1:                 protected void decorateSQL(Statement s) throws SQLException {
1:                     // table used to test  export.
1:                     s.execute("CREATE TABLE BOOKS(id int," +
1:                               "name varchar(30)," + 
1:                               "content clob, " + 
1:                               "pic blob )");
1:                     // load some data into the above table. 
1:                     loadData(s);
1:                     // table used to test import. 
1:                     s.execute("CREATE TABLE BOOKS_IMP(id int," +
1:                               "name varchar(30)," + 
1:                               "content clob," +  
1:                               "pic blob )");
1:                     // table that holds some invalid hex strings. 
1:                     s.execute("CREATE TABLE hex_tab(id int," +
1:                               "C1 varchar(20)," + 
1:                               "C2 varchar(20)," +
1:                               "C3 varchar(20))");
1:                 }
1:             };
1:     }
1: 
1:     
1:     /**
1:      * Simple set up, just empty the import table.
1:      * @throws SQLException 
1:      */
1:     protected void setUp() throws SQLException
1:     {
1:         Statement s  = createStatement();
1:         // delete the rows from the import table.
1:         s.executeUpdate("DELETE FROM BOOKS_IMP");
1:         s.close();
1:     }
1: 
1:     
1: 
1:     /**
1:      * Test import/export of a table, using 
1:      * SYSCS_EXPORT_TABLE and SYSCS_IMPORT_TABLE procedures.
1:      */
1:     public void testImportTableExportTable()  
1:         throws SQLException, IOException
1:     {
1:         doExportTable("APP", "BOOKS", fileName, null, null , null);
1: 	    doImportTable("APP", "BOOKS_IMP", fileName, null, null, null, 0);
1:         verifyData(" * ");
1:     }
1: 
1:     
1:     /*
1:      * Test import/export of all the columns using 
1:      * SYSCS_EXPORT_QUERY and SYSCS_IMPORT_DATA procedures.  
1:      */
1:     public void testImportDataExportQuery() 
1:         throws SQLException, IOException
1:     {
1:         doExportQuery("select * from BOOKS", fileName,
1:                       null, null , null);
1: 	    doImportData(null, "BOOKS_IMP", null, null, fileName, 
1:                      null, null, null, 0);
1:         verifyData(" * ");
1: 
1:         // perform import with column names specified in random order.
1:         doImportData(null, "BOOKS_IMP", "PIC, CONTENT, NAME, ID", 
1:                      "4, 3, 2, 1",  fileName, null, null, null, 1);
1:         verifyData("PIC, CONTENT, NAME, ID");
1: 
1:         // test with  non-default delimiters. 
1:         doExportQuery("select * from BOOKS_IMP", fileName,
1:                       ";", "%" , null);
1: 	    doImportData(null, "BOOKS_IMP", null, null, fileName, 
1:                      ";", "%", null, 1);
1: 
1:     }
1: 
1: 
1:     /*
1:      * Test import of only some columns of the table 
1:      * using  SYSCS_EXPOR_QUERY and IMPORT_DATA procedures.  
1:      */
1:     public void testImportDataExportQueryWithFewColumns() 
1:         throws SQLException, IOException
1:     {
1:         doExportQuery("select id, name, content, pic from BOOKS",  
1:                       fileName,  null, null, null);
1:         doImportData(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:                      fileName, null, null, null, 0);
1:         verifyData("ID,PIC");
1:         doImportData(null, "BOOKS_IMP", "ID, PIC, NAME", "1, 4, 2",
1:                      fileName, null, null, null, 1);
1:         verifyData("ID, PIC, NAME");
1:         doImportData(null, "BOOKS_IMP", "ID, CONTENT, NAME", "1, 3, 2",
1:                      fileName, null, null, null, 1);
1:         verifyData("ID, CONTENT, NAME");
1: 
1:         // test with  non-default delimiters. 
1:         doExportQuery("select id, name, content, pic from BOOKS",  
1:                       fileName,  "$", "!" , null);
1:         doImportData(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:                      fileName, "$", "!", null, 0);
1:     }
1: 
1: 
1: 
1: 
1:     /* 
1:      * Test import procedures with invalid hex strings in 
1:      * the import file for the blob column. 
1:      */
1:     public void testImportWithInvalidHexStrings() 
1:         throws SQLException   
1:     {
1:         Statement s = createStatement();
1:         // Insert row with correctly formed hex strings.  
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(1, 'row 1', 'clob 1', 'B1C201DA')");
1: 
1:         // Insert row with an invalid hex string, because 
1:         // it's length is not a multiple of 2 (B1C201A) , 
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(2, 'row 2', 'clob2 ', 'B1C201A')");
1: 
1:         // Insert row with an invalid hex string that contains 
1:         // a non-hex character (3122A1F20Z). 
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(3, '', 'clobs 3', '3122A1F20Z')");
1: 
1:         // Insert row with an invalid hex string that contains 
1:         // a delimiter character (B1C2\"01DA). 
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(4, 'row \"4', '3122A1F20Z', 'B1C2\"01DA')");
1:         s.close();
1: 
1:         // export the invalid hex strings from the table to a file. 
1:         doExportTable("APP", "HEX_TAB", fileName, null, null , null);
1: 
1: 
1:         // attempt to import the invalid hex string data into a table 
1:         // with binary columns. It should fail.
1:  
1:         try {
1:             
1:             doExportQuery("select * from hex_tab where id <= 2",  
1:                           fileName,  null, null, null);
1:             // import should fail because of invalied hex string length
1:             doImportTable("APP", "BOOKS_IMP", fileName, null, null, null, 0);
1:             fail("import did not fail on data with invalid hex string");
1:         } catch (SQLException e) {
0:              assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0N", e);
1:         }
1: 
1:         try {
1:             doExportQuery("select * from hex_tab where id = 3",  
1:                           fileName,  null, null, null);
1:             // import should fail because hex string contains invalid 
1:             // hex chatacters.
1:             doImportData(null, "BOOKS_IMP", "ID, PIC", "1,4",
1:                          fileName, null, null, null, 1);
1:             fail("import did not fail on data with invalid hex strings");
1:         } catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0N", e);
1:         }
1: 
1:         try {
1:             doExportQuery("select * from hex_tab where id = 4",  
1:                           fileName,  null, null, null);
1:             // import should fail because hex string contains invalid 
1:             // hex chatacters.
1:             doImportData(null, "BOOKS_IMP", "ID, PIC", "1,4",
1:                          fileName, null, null, null, 1);
1:             fail("import did not fail on data with invalid hex strings");
1:         } catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0N", e);
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Test import/export of a table, using 
0:      * SYSCS_EXPORT_TABLE_LOBS_IN_EXTFILE and 
0:      * SYSCS_IMPORT_TABLE_LOBS_IN_EXTFILE  procedures.
1:      */
1:     public void testImportTableExportTableLobsInExtFile()  
1:         throws SQLException, IOException
1:     {
0:         doExportTableLobsInExtFile("APP", "BOOKS", fileName, 
1:                                    null, null , null, lobsFileName);
0: 	    doImportTableLobsInExtFile("APP", "BOOKS_IMP", fileName, 
1:                                    null, null, null, 0);
1:         verifyData(" * ");
1:     }
1: 
1:     
1:     /*
1:      * Test import/export of all the columns using 
1:      * SYSCS_EXPORT_QUERY and SYSCS_IMPORT_DATA procedures.  
1:      */
1:     public void testImportDataExportQueryLobsInExtFile() 
1:         throws SQLException, IOException
1:     {
0:         doExportQueryLobsInExtFile("select * from BOOKS", fileName,
1:                                    null, null , null, lobsFileName);
0: 	    doImportDataLobsInExtFile(null, "BOOKS_IMP", null, null, fileName, 
1:                                    null, null, null, 0);
1:         verifyData(" * ");
1: 
1:         // perform import with column names specified in random order.
0:         doImportDataLobsInExtFile(null, "BOOKS_IMP", "PIC, CONTENT, NAME, ID", 
0:                                   "4, 3, 2, 1", fileName, null, null, null, 1);
1:         verifyData("PIC, CONTENT, NAME, ID");
1: 
1:         // test with  non-default delimiters. 
0:         doExportQueryLobsInExtFile("select * from BOOKS_IMP", fileName,
1:                                    ";", "%" , null, lobsFileName);
0: 	    doImportDataLobsInExtFile(null, "BOOKS_IMP", null, null, fileName, 
1:                                   ";", "%", null, 1);
1: 
1:     }
1: 
1: 
1:     /*
1:      * Test import of only some columns of the table 
1:      * using  SYSCS_EXPOR_QUERY and IMPORT_DATA procedures.  
1:      */
1:     public void testImportDataExportQueryWithFewColsLobsInExtFile() 
1:         throws SQLException, IOException
1:     {
0:         doExportQueryLobsInExtFile("select id, name, content, pic from BOOKS",
1:                                    fileName,  null, null, null, lobsFileName);
0:         doImportDataLobsInExtFile(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:                                   fileName, null, null, null, 0);
1:         verifyData("ID,PIC");
0:         doImportDataLobsInExtFile(null, "BOOKS_IMP", "ID, PIC, NAME", "1, 4, 2",
1:                                   fileName, null, null, null, 1);
1:         verifyData("ID, PIC, NAME");
0:         doImportDataLobsInExtFile(null, "BOOKS_IMP", "ID, CONTENT, NAME", 
1:                                   "1, 3, 2", fileName, null, null, null, 1);
1:         verifyData("ID, CONTENT, NAME");
1: 
1:         // test with  non-default delimiters. 
0:         doExportQueryLobsInExtFile("select id, name, content, pic from BOOKS",  
1:                                    fileName,  "$", "!" , null, lobsFileName);
0:         doImportDataLobsInExtFile(null, "BOOKS_IMP", "ID,PIC", "1 , 4",
1:                                   fileName, "$", "!", null, 0);
1:     }
1: 
1: 
1:     /* 
1:      *  Test lobs in exteranl file import/export procedures 
1:      *  with invalid delimiters. 
1:      */
1:     public void testImportExportInvalideDelimiters() 
1:          throws SQLException, IOException   
1:     {
1:         try {
0:             doExportTableLobsInExtFile("APP", "BOOKS", fileName, 
1:                                        null, "9" , null, lobsFileName);
1:         } catch (SQLException e) {
1:             assertSQLState("XIE0J", e);
1:         }
1: 
1:         try {
0:             doExportQueryLobsInExtFile("select * from BOOKS", fileName,
1:                                        "|", "f", null, lobsFileName);
1:         } catch (SQLException e) {
1:             assertSQLState("XIE0J", e);
1:         }
1: 
0:         doExportQueryLobsInExtFile("select * from BOOKS where id < 10", 
1:                                    fileName, null, null, null, lobsFileName);
1: 
1: 
0:         /* Currently BaseJDBCTestCase.assertSQLState() is unable
0:          * to find nested SQLSTATEs with 1.6 JVMs, so we have to
0:          * check for the top-level SQLSTATE in that case.  When
0:          * that changes the "JDBC.vmSupportsJDBC4()" call can be
0:          * removed from the following assertSQLState() calls.
0:          * (DERBY-1440)
1:          */
1: 
1:         try {
0:             doImportTableLobsInExtFile("APP", "BOOKS_IMP", fileName, "2", 
0:                                        null, null, 0);
1:         } catch (SQLException e) {
0:              assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0J", e);
1:         }
1: 
1:         try {
0:             doImportDataLobsInExtFile(null, "BOOKS_IMP", null, 
1:                                       null,  fileName, null, "c", null, 1);
1:         } catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0J", e);
1:         }
1:     }
1: 
1: 
1:     /* 
1:      * Verifies data in the import test table (BOOKS_IMP) is same 
1:      * as the test table from which the data was exported earlier(BOOKS). 
1:      * @param cols  imported columns , if all then " * ", otherwise 
1:      *              comma separated column list. 
1:      * @exception SQLException  if the data does match or if 
1:      *                          any other error during comparision.  
1:      */
1:     private void verifyData(String cols)  
1:         throws SQLException, IOException
1:     {
1:         Statement s1 = createStatement();
1:         ResultSet rsExport = s1.executeQuery("SELECT " + cols  +  
1:                                              " FROM BOOKS order by id");
1:         Statement s2 = createStatement();
1:         ResultSet rsImport = s2.executeQuery("SELECT " + cols  +  
1:                                              " FROM BOOKS_IMP order by id");
1:         JDBC.assertSameContents(rsExport, rsImport);
1:         
1:         s1.close();
1:         s2.close();
1:     }
1:     
1: 
1:     /*
1:      * Insert data to the into the table, whose data will be exported.
1:      */
1:     private static void loadData(Statement s) throws SQLException {
1: 
1:         s.executeUpdate("insert into books values " + 
1:                         "(1, 'book 1', 'clob 1'," +  
1:                         "cast(X'3743640ADE12337610' as blob))");
1:         // rows with empty strings. 
1:         s.executeUpdate("insert into books values " + 
1:                         "(2, 'book 2', 'clob 2',  cast (X'' as blob))");
1:         s.executeUpdate("insert into books values " + 
1:                         "(3, 'book 3', '', cast(X'42' as blob))");
1:         s.executeUpdate("insert into books values " + 
1:                         "(4, 'book 4', 'clob 4',  " + 
1:                         "cast (X'3233445578990122558820' as blob))");
1:         
1:         // rows with a null
1:         s.executeUpdate("insert into books values " + 
1:                         "(5, null, 'clob 5'," +  
1:                         "cast(X'3843640ADE12337610' as blob))");
1:         s.executeUpdate("insert into books values " + 
1:                         "(6,  'book  6', null,  " + 
1:                         "cast(X'3843640ADE12337610' as blob))");
1:         s.executeUpdate("insert into books values " + 
1:                         "(7,  'book  7',  'clob 7' , null)");
1:         s.executeUpdate("insert into books values " + 
1:                         "(8, '', null,  cast (X'3843640ADE12' as blob))");
1:         s.executeUpdate("insert into books values " + 
1:                         "(9, 'book  9', null,  cast (X'' as blob))");
1:         
1:         // insert data that contains some delimiter characters 
1:         // ( "(x22) ,(x2C) %(x25) ;(x3B) , tab(9) LF(A) )
1:         s.executeUpdate("insert into books values " + 
1:                         "(10, 'book ;10', '%asdadasdasd'," + 
1:                         " cast (X'222C23B90A' as blob))");
1:         // !(x21) $(24)
1:         s.executeUpdate("insert into books values " + 
1:                         "(11, '212C3B24', '2422412221', " + 
1:                         "  cast (X'212421222C23B90A2124' as blob))");
1: 
1:         // insert some more randomly genrated data.
1:         Connection conn = s.getConnection();
1:         String sql = "insert into books values(? , ? , ? , ?)";
1:         PreparedStatement ps = conn.prepareStatement(sql);
1:         int blobSize = 0;
0:         int id = 12;
1:         for (int i = 0 ; i < 17 ; i++) {
1:             ps.setInt(1 , id++);
1:             ps.setString(2 , "book" +i);
1:             blobSize +=  1024 * i;
1:             int clobSize = 1024 * i;
1:             Reader reader = new LoopingAlphabetReader(clobSize);
1:             ps.setCharacterStream(3, reader, clobSize);
1:             InputStream stream = new LoopingAlphabetStream(blobSize);
1:             ps.setBinaryStream(4, stream, blobSize);
1:             ps.executeUpdate();
1: 
1:             if ((i % 10) == 0) 
1:                 conn.commit();
1:         }
1: 
1:         ps.close();
1:         conn.commit();
1:     }
1: }
============================================================================