1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.heap.HeapConglomerateFactory
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.heap;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
1:888d12e: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:888d12e: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:c6ca304: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:888d12e: import org.apache.derby.iapi.store.raw.PageKey;
1:b61f876: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:888d12e: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:fa09146: // For JavaDoc references (i.e. @see)
1:fa09146: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1:fa09146: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   The heap conglomerate factory manages heap conglomerates implemented
1:eac0369:   on the raw store.
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class HeapConglomerateFactory implements ConglomerateFactory, ModuleControl, ModuleSupportable
1:eac0369: {
1:eac0369: 
1:eac0369: 	private static final String IMPLEMENTATIONID = "heap";
1:eac0369: 	private static final String FORMATUUIDSTRING = "D2976090-D9F5-11d0-B54D-00A024BF8878";
1:eac0369: 	private UUID formatUUID;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Methods of MethodFactory (via ConglomerateFactory)
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the default properties for this kind of conglomerate.
1:eac0369: 	@see MethodFactory#defaultProperties
1:eac0369: 	**/
1:eac0369: 	public Properties defaultProperties()
1:eac0369: 	{
1:eac0369: 		// Heap has no properties.
1:eac0369: 		return new Properties();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return whether this access method implements the implementation
1:eac0369: 	type given in the argument string.
1:eac0369: 	The heap only has one implementation type, "heap".
1:eac0369: 
1:eac0369: 	@see MethodFactory#supportsImplementation
1:eac0369: 	**/
1:eac0369: 	public boolean supportsImplementation(String implementationId)
1:eac0369: 	{
1:eac0369: 		return implementationId.equals(IMPLEMENTATIONID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the primary implementation type for this access method.
1:eac0369: 	The heap only has one implementation type, "heap".
1:eac0369: 
1:eac0369: 	@see MethodFactory#primaryImplementationType
1:eac0369: 	**/
1:eac0369: 	public String primaryImplementationType()
1:eac0369: 	{
1:eac0369: 		return IMPLEMENTATIONID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return whether this access method supports the format supplied in
1:eac0369: 	the argument.
1:eac0369: 	The heap currently only supports one format, HEAPFORMAT1.
1:eac0369: 
1:eac0369: 	@see MethodFactory#supportsFormat
1:eac0369: 	**/
1:eac0369: 	public boolean supportsFormat(UUID formatid)
1:eac0369: 	{
1:eac0369: 		return formatid.equals(formatUUID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the primary format that this access method supports.
1:eac0369: 	The heap currently only supports one format, HEAPFORMAT1.
1:eac0369: 
1:eac0369: 	@see MethodFactory#primaryFormat
1:eac0369: 	**/
1:eac0369: 	public UUID primaryFormat()
1:eac0369: 	{
1:eac0369: 		return formatUUID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ConglomerateFactory
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the conglomerate factory id.
1:eac0369:      * <p>
1:eac0369:      * Return a number in the range of 0-15 which identifies this factory.
1:eac0369:      * Code which names conglomerates depends on this range currently, but
1:eac0369:      * could be easily changed to handle larger ranges.   One hex digit seemed
1:eac0369:      * reasonable for the number of conglomerate types being currently 
1:eac0369:      * considered (heap, btree, gist, gist btree, gist rtree, hash, others? ).
1:eac0369:      * <p>
1:eac0369: 	 * @see ConglomerateFactory#getConglomerateFactoryId
1:eac0369:      *
1:eac0369: 	 * @return an unique identifier used to the factory into the conglomid.
1:eac0369:      *
1:eac0369:      **/
1:eac0369:     public int getConglomerateFactoryId()
1:eac0369:     {
1:eac0369:         return(ConglomerateFactory.HEAP_FACTORY_ID);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Create the conglomerate and return a conglomerate object for it.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 
1:eac0369: 	@see ConglomerateFactory#createConglomerate
1:eac0369: 	**/
1:eac0369: 	public Conglomerate createConglomerate(	
1:eac0369:     TransactionManager      xact_mgr,
1:eac0369:     int                     segment,
1:eac0369:     long                    input_containerid,
1:eac0369:     DataValueDescriptor[]   template,
1:b61f876: 	ColumnOrdering[]        columnOrder,
1:b61f876:     int[]                   collationIds,
1:eac0369:     Properties              properties,
1:eac0369: 	int                     temporaryFlag)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:b61f876: 		Heap heap = null;
1:b61f876: 
1:b61f876: 
1:c6ca304:         if ((temporaryFlag & TransactionController.IS_TEMPORARY) != 0 &&
1:c6ca304:                 xact_mgr.getAccessManager().isReadOnly())
1:c6ca304:         {
1:c6ca304:             // If this is a temporary conglomerate created for a read-only
1:c6ca304:             // database, we don't really care which disk format we use, since
1:c6ca304:             // it is not used for persisting data in the database. Use the
1:c6ca304:             // current format. A special case is needed because checkVersion()
1:c6ca304:             // throws an exception in read-only databases (DERBY-2354).
1:c6ca304:             heap = new Heap();
1:c6ca304:         }
1:c6ca304:         else if (xact_mgr.checkVersion(
1:b61f876:                 RawStoreFactory.DERBY_STORE_MAJOR_VERSION_10,
1:b61f876:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_3,
1:b61f876:                 null))
1:b61f876:         {
1:b61f876:             // on disk databases with version higher than 10.2 should use
1:b61f876:             // current disk format B2I.  This includes new databases or
1:b61f876:             // hard upgraded databases.
1:b61f876:             heap = new Heap();
1:b61f876:         }
1:b61f876:         else
1:b61f876:         {
1:b61f876:             // Old databases that are running in new versions of the software,
1:b61f876:             // but are running in soft upgrade mode at release level 10.2
1:b61f876:             // and before should use the old B2I version.  This version will
1:b61f876:             // continue to write metadata that can be read by 10.2 and previous
1:b61f876:             // versions.
1:b61f876:             heap = new Heap_v10_2();
1:b61f876:         }
1:b61f876: 
1:eac0369: 		heap.create(
1:eac0369:             xact_mgr.getRawStoreXact(), segment, input_containerid, 
1:b61f876:             template, columnOrder, collationIds, properties, 
1:b61f876:             heap.getTypeFormatId(), 
1:b61f876:             temporaryFlag);
1:eac0369: 
1:eac0369: 		return heap;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return Conglomerate object for conglomerate with container_key.
1:eac0369:      * <p>
1:eac0369:      * Return the Conglomerate Object.  This is implementation specific.
1:eac0369:      * Examples of what will be done is using the key to find the file where
1:eac0369:      * the conglomerate is located, and then executing implementation specific
1:eac0369:      * code to instantiate an object from reading a "special" row from a
1:eac0369:      * known location in the file.  In the btree case the btree conglomerate
1:eac0369:      * is stored as a column in the control row on the root page.
1:eac0369:      * <p>
1:eac0369:      * This operation is costly so it is likely an implementation using this
1:eac0369:      * will cache the conglomerate row in memory so that subsequent accesses
1:eac0369:      * need not perform this operation.
1:eac0369:      *
1:eac0369:      * @param xact_mgr      transaction to perform the create in.
1:eac0369:      * @param container_key The unique id of the existing conglomerate.
1:eac0369:      *
1:eac0369: 	 * @return An instance of the conglomerate.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public Conglomerate readConglomerate(
1:eac0369:     TransactionManager      xact_mgr,
1:eac0369:     ContainerKey            container_key)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         ContainerHandle         container   = null;
1:eac0369:         Page                    page        = null;
1:eac0369:         DataValueDescriptor[]   control_row = new DataValueDescriptor[1];
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // open container to read the Heap object out of it's control row.
1:eac0369:             container = 
1:eac0369:                 xact_mgr.getRawStoreXact().openContainer(
1:eac0369:                     container_key, (LockingPolicy) null, 0);
1:eac0369: 
1:eac0369:             if (container == null)
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                     SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST,
1:ce40a31:                     container_key.getContainerId());
1:eac0369:             }
1:eac0369: 
1:eac0369:             // row in slot 0 of heap page 1 which is just a single column with
1:eac0369:             // the heap entry.
1:eac0369:             control_row[0]       = new Heap();
1:eac0369: 
1:eac0369:             page = container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1:eac0369: 
1:eac0369:             RecordHandle rh = 
1:eac0369:                 page.fetchFromSlot(
1:eac0369:                    (RecordHandle) null, 0, control_row, 
1:eac0369:                    (FetchDescriptor) null,
1:eac0369:                    true);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(rh != null);
1:eac0369: 
1:eac0369:                 // for now the control row is always the first id assigned on
1:eac0369:                 // page 1.
1:eac0369:                 SanityManager.ASSERT(rh.getId() == 6);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (page != null)
1:eac0369:                 page.unlatch();
1:eac0369: 
1:eac0369:             if (container != null)
1:eac0369:                 container.close();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return((Conglomerate) control_row[0]);
1:eac0369:     }
1:eac0369: 
1:888d12e:     /**
1:888d12e:      * Interface to be called when an undo of an insert is processed.
1:888d12e:      * <p>
1:888d12e:      * Implementer of this class provides interface to be called by the raw
1:888d12e:      * store when an undo of an insert is processed.  Initial implementation
1:888d12e:      * will be by Access layer to queue space reclaiming events if necessary
1:888d12e:      * when a rows is logically "deleted" as part of undo of the original
1:888d12e:      * insert.  This undo can happen a lot for many applications if they
1:888d12e:      * generate expected and handled duplicate key errors.
1:888d12e:      * <p>
1:888d12e:      * Caller may decide to call or not based on deleted row count of the
1:888d12e:      * page, or if overflow rows/columns are present.
1:888d12e:      *
1:888d12e:      *
1:888d12e:      * @param access_factory    current access_factory of the aborted insert.
1:888d12e:      * @param xact              transaction that is being backed out.
1:888d12e:      * @param page_key          page key of the aborted insert.
1:888d12e:      *
1:888d12e:      * @exception  StandardException  Standard exception policy.
1:888d12e:      **/
1:888d12e:     public void insertUndoNotify(
1:888d12e:     AccessFactory       access_factory,
1:888d12e:     Transaction         xact,
1:888d12e:     PageKey             page_key)
1:888d12e:         throws StandardException
1:888d12e:     {
1:888d12e:         // try to reclaim rows when the page is only full of deleted rows,
1:888d12e:         // or in the special case of the first page when all rows except the
1:888d12e:         // "control row" are deleted.  Or if the row we just deleted is
1:888d12e:         // a long row or has a long column.
1:888d12e:         //
1:888d12e:         // This logic is currently embedded in raw store InsertOperation
1:888d12e:         // abort code which triggers the event to notify the 
1:888d12e:         // HeapConglomerateFactory to post the HeapPostCommit work item.
1:888d12e:         xact.addPostAbortWork(new HeapPostCommit(access_factory, page_key));
1:888d12e:     }
1:888d12e: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ModuleControl.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public boolean canSupport(Properties startParams) {
1:eac0369: 
1:eac0369: 		String impl = 
1:eac0369:             startParams.getProperty("derby.access.Conglomerate.type");
1:eac0369: 
1:eac0369: 		if (impl == null)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		return supportsImplementation(impl);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Find the UUID factory.
1:eac0369: 		UUIDFactory uuidFactory = 
1:56c1dc2:             getMonitor().getUUIDFactory();
1:eac0369: 		
1:eac0369: 		// Make a UUID that identifies this conglomerate's format.
1:eac0369: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	stop()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of HeapConglomerateFactory
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public HeapConglomerateFactory()
1:eac0369: 	{
1:eac0369: 	}
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                     container_key.getContainerId());
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1:             getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1: import org.apache.derby.iapi.store.access.AccessFactory;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.PageKey;
1: import org.apache.derby.iapi.store.raw.Transaction;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Interface to be called when an undo of an insert is processed.
1:      * <p>
1:      * Implementer of this class provides interface to be called by the raw
1:      * store when an undo of an insert is processed.  Initial implementation
1:      * will be by Access layer to queue space reclaiming events if necessary
1:      * when a rows is logically "deleted" as part of undo of the original
1:      * insert.  This undo can happen a lot for many applications if they
1:      * generate expected and handled duplicate key errors.
1:      * <p>
1:      * Caller may decide to call or not based on deleted row count of the
1:      * page, or if overflow rows/columns are present.
1:      *
1:      *
1:      * @param access_factory    current access_factory of the aborted insert.
1:      * @param xact              transaction that is being backed out.
1:      * @param page_key          page key of the aborted insert.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void insertUndoNotify(
1:     AccessFactory       access_factory,
1:     Transaction         xact,
1:     PageKey             page_key)
1:         throws StandardException
1:     {
1:         // try to reclaim rows when the page is only full of deleted rows,
1:         // or in the special case of the first page when all rows except the
1:         // "control row" are deleted.  Or if the row we just deleted is
1:         // a long row or has a long column.
1:         //
1:         // This logic is currently embedded in raw store InsertOperation
1:         // abort code which triggers the event to notify the 
1:         // HeapConglomerateFactory to post the HeapPostCommit work item.
1:         xact.addPostAbortWork(new HeapPostCommit(access_factory, page_key));
1:     }
1: 
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	ColumnOrdering[]        columnOrder,
1:     int[]                   collationIds,
1: 		Heap heap = null;
1: 
1: 
0:         if (xact_mgr.checkVersion(
1:                 RawStoreFactory.DERBY_STORE_MAJOR_VERSION_10,
1:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_3,
1:                 null))
1:         {
1:             // on disk databases with version higher than 10.2 should use
1:             // current disk format B2I.  This includes new databases or
1:             // hard upgraded databases.
1:             heap = new Heap();
1:         }
1:         else
1:         {
1:             // Old databases that are running in new versions of the software,
1:             // but are running in soft upgrade mode at release level 10.2
1:             // and before should use the old B2I version.  This version will
1:             // continue to write metadata that can be read by 10.2 and previous
1:             // versions.
1:             heap = new Heap_v10_2();
1:         }
1: 
1:             template, columnOrder, collationIds, properties, 
1:             heap.getTypeFormatId(), 
1:             temporaryFlag);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6ca304
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
1:         if ((temporaryFlag & TransactionController.IS_TEMPORARY) != 0 &&
1:                 xact_mgr.getAccessManager().isReadOnly())
1:         {
1:             // If this is a temporary conglomerate created for a read-only
1:             // database, we don't really care which disk format we use, since
1:             // it is not used for persisting data in the database. Use the
1:             // current format. A special case is needed because checkVersion()
1:             // throws an exception in read-only databases (DERBY-2354).
1:             heap = new Heap();
1:         }
1:         else if (xact_mgr.checkVersion(
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: // For JavaDoc references (i.e. @see)
1: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.heap.HeapConglomerateFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import java.util.Properties;
1: 
1: /**
1: 
1:   The heap conglomerate factory manages heap conglomerates implemented
1:   on the raw store.
1: 
1: **/
1: 
1: public class HeapConglomerateFactory implements ConglomerateFactory, ModuleControl, ModuleSupportable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
0: 	// RESOLVE (mikem) (STO062) 
0:     // The heap implementation id should be "heap table".
1: 	private static final String IMPLEMENTATIONID = "heap";
1: 	private static final String FORMATUUIDSTRING = "D2976090-D9F5-11d0-B54D-00A024BF8878";
1: 	private UUID formatUUID;
1: 
1: 	/*
1: 	 * Methods of MethodFactory (via ConglomerateFactory)
1: 	 */
1: 
1: 	/**
1: 	Return the default properties for this kind of conglomerate.
1: 	@see MethodFactory#defaultProperties
1: 	**/
1: 	public Properties defaultProperties()
1: 	{
1: 		// Heap has no properties.
1: 		return new Properties();
1: 	}
1: 
1: 	/**
1: 	Return whether this access method implements the implementation
1: 	type given in the argument string.
1: 	The heap only has one implementation type, "heap".
1: 
1: 	@see MethodFactory#supportsImplementation
1: 	**/
1: 	public boolean supportsImplementation(String implementationId)
1: 	{
1: 		return implementationId.equals(IMPLEMENTATIONID);
1: 	}
1: 
1: 	/**
1: 	Return the primary implementation type for this access method.
1: 	The heap only has one implementation type, "heap".
1: 
1: 	@see MethodFactory#primaryImplementationType
1: 	**/
1: 	public String primaryImplementationType()
1: 	{
1: 		return IMPLEMENTATIONID;
1: 	}
1: 
1: 	/**
1: 	Return whether this access method supports the format supplied in
1: 	the argument.
1: 	The heap currently only supports one format, HEAPFORMAT1.
1: 
1: 	@see MethodFactory#supportsFormat
1: 	**/
1: 	public boolean supportsFormat(UUID formatid)
1: 	{
1: 		return formatid.equals(formatUUID);
1: 	}
1: 
1: 	/**
1: 	Return the primary format that this access method supports.
1: 	The heap currently only supports one format, HEAPFORMAT1.
1: 
1: 	@see MethodFactory#primaryFormat
1: 	**/
1: 	public UUID primaryFormat()
1: 	{
1: 		return formatUUID;
1: 	}
1: 
1: 	/*
1: 	** Methods of ConglomerateFactory
1: 	*/
1: 
1:     /**
1:      * Return the conglomerate factory id.
1:      * <p>
1:      * Return a number in the range of 0-15 which identifies this factory.
1:      * Code which names conglomerates depends on this range currently, but
1:      * could be easily changed to handle larger ranges.   One hex digit seemed
1:      * reasonable for the number of conglomerate types being currently 
1:      * considered (heap, btree, gist, gist btree, gist rtree, hash, others? ).
1:      * <p>
1: 	 * @see ConglomerateFactory#getConglomerateFactoryId
1:      *
1: 	 * @return an unique identifier used to the factory into the conglomid.
1:      *
1:      **/
1:     public int getConglomerateFactoryId()
1:     {
1:         return(ConglomerateFactory.HEAP_FACTORY_ID);
1:     }
1: 
1: 	/**
1: 	Create the conglomerate and return a conglomerate object for it.
1: 
1: 	@exception StandardException Standard exception policy.
1: 
1: 	@see ConglomerateFactory#createConglomerate
1: 	**/
1: 	public Conglomerate createConglomerate(	
1:     TransactionManager      xact_mgr,
1:     int                     segment,
1:     long                    input_containerid,
1:     DataValueDescriptor[]   template,
0: 	ColumnOrdering[]        columnOrder,  //only meant for BTree type congloms
1:     Properties              properties,
1: 	int                     temporaryFlag)
1: 		throws StandardException
1: 	{
0: 		//parent.register(heap);
0: 		Heap heap = new Heap();
1: 		heap.create(
1:             xact_mgr.getRawStoreXact(), segment, input_containerid, 
0:             template, properties, temporaryFlag);
1: 
1: 		return heap;
1: 	}
1: 
1:     /**
1:      * Return Conglomerate object for conglomerate with container_key.
1:      * <p>
1:      * Return the Conglomerate Object.  This is implementation specific.
1:      * Examples of what will be done is using the key to find the file where
1:      * the conglomerate is located, and then executing implementation specific
1:      * code to instantiate an object from reading a "special" row from a
1:      * known location in the file.  In the btree case the btree conglomerate
1:      * is stored as a column in the control row on the root page.
1:      * <p>
1:      * This operation is costly so it is likely an implementation using this
1:      * will cache the conglomerate row in memory so that subsequent accesses
1:      * need not perform this operation.
1:      *
1:      * @param xact_mgr      transaction to perform the create in.
1:      * @param container_key The unique id of the existing conglomerate.
1:      *
1: 	 * @return An instance of the conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public Conglomerate readConglomerate(
1:     TransactionManager      xact_mgr,
1:     ContainerKey            container_key)
1: 		throws StandardException
1:     {
1:         ContainerHandle         container   = null;
1:         Page                    page        = null;
1:         DataValueDescriptor[]   control_row = new DataValueDescriptor[1];
1: 
1:         try
1:         {
1:             // open container to read the Heap object out of it's control row.
1:             container = 
1:                 xact_mgr.getRawStoreXact().openContainer(
1:                     container_key, (LockingPolicy) null, 0);
1: 
1:             if (container == null)
1:             {
1:                 throw StandardException.newException(
1:                     SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST,
0:                     new Long(container_key.getContainerId()));
1:             }
1: 
1:             // row in slot 0 of heap page 1 which is just a single column with
1:             // the heap entry.
1:             control_row[0]       = new Heap();
1: 
1:             page = container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1:             RecordHandle rh = 
1:                 page.fetchFromSlot(
1:                    (RecordHandle) null, 0, control_row, 
1:                    (FetchDescriptor) null,
1:                    true);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(rh != null);
1: 
1:                 // for now the control row is always the first id assigned on
1:                 // page 1.
1:                 SanityManager.ASSERT(rh.getId() == 6);
1:             }
1:         }
1:         finally
1:         {
1:             if (page != null)
1:                 page.unlatch();
1: 
1:             if (container != null)
1:                 container.close();
1:         }
1: 
1:         return((Conglomerate) control_row[0]);
1:     }
1: 
1: 	/*
1: 	** Methods of ModuleControl.
1: 	*/
1: 
1: 	public boolean canSupport(Properties startParams) {
1: 
1: 		String impl = 
1:             startParams.getProperty("derby.access.Conglomerate.type");
1: 
1: 		if (impl == null)
1: 			return false;
1: 
1: 		return supportsImplementation(impl);
1: 	}
1: 
1: 	public void	boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 		// Find the UUID factory.
1: 		UUIDFactory uuidFactory = 
0:             Monitor.getMonitor().getUUIDFactory();
1: 		
1: 		// Make a UUID that identifies this conglomerate's format.
1: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
1: 	}
1: 
1: 	public void	stop()
1: 	{
1: 	}
1: 
1: 	/*
1: 	** Methods of HeapConglomerateFactory
1: 	*/
1: 
1: 	public HeapConglomerateFactory()
1: 	{
1: 	}
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.util.Properties;
0: 
0: /**
0: 
0:   The heap conglomerate factory manages heap conglomerates implemented
0:   on the raw store.
0: 
0: **/
0: 
0: public class HeapConglomerateFactory implements ConglomerateFactory, ModuleControl, ModuleSupportable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	// RESOLVE (mikem) (STO062) 
0:     // The heap implementation id should be "heap table".
0: 	private static final String IMPLEMENTATIONID = "heap";
0: 	private static final String FORMATUUIDSTRING = "D2976090-D9F5-11d0-B54D-00A024BF8878";
0: 	private UUID formatUUID;
0: 
0: 	/*
0: 	 * Methods of MethodFactory (via ConglomerateFactory)
0: 	 */
0: 
0: 	/**
0: 	Return the default properties for this kind of conglomerate.
0: 	@see MethodFactory#defaultProperties
0: 	**/
0: 	public Properties defaultProperties()
0: 	{
0: 		// Heap has no properties.
0: 		return new Properties();
0: 	}
0: 
0: 	/**
0: 	Return whether this access method implements the implementation
0: 	type given in the argument string.
0: 	The heap only has one implementation type, "heap".
0: 
0: 	@see MethodFactory#supportsImplementation
0: 	**/
0: 	public boolean supportsImplementation(String implementationId)
0: 	{
0: 		return implementationId.equals(IMPLEMENTATIONID);
0: 	}
0: 
0: 	/**
0: 	Return the primary implementation type for this access method.
0: 	The heap only has one implementation type, "heap".
0: 
0: 	@see MethodFactory#primaryImplementationType
0: 	**/
0: 	public String primaryImplementationType()
0: 	{
0: 		return IMPLEMENTATIONID;
0: 	}
0: 
0: 	/**
0: 	Return whether this access method supports the format supplied in
0: 	the argument.
0: 	The heap currently only supports one format, HEAPFORMAT1.
0: 
0: 	@see MethodFactory#supportsFormat
0: 	**/
0: 	public boolean supportsFormat(UUID formatid)
0: 	{
0: 		return formatid.equals(formatUUID);
0: 	}
0: 
0: 	/**
0: 	Return the primary format that this access method supports.
0: 	The heap currently only supports one format, HEAPFORMAT1.
0: 
0: 	@see MethodFactory#primaryFormat
0: 	**/
0: 	public UUID primaryFormat()
0: 	{
0: 		return formatUUID;
0: 	}
0: 
0: 	/*
0: 	** Methods of ConglomerateFactory
0: 	*/
0: 
0:     /**
0:      * Return the conglomerate factory id.
0:      * <p>
0:      * Return a number in the range of 0-15 which identifies this factory.
0:      * Code which names conglomerates depends on this range currently, but
0:      * could be easily changed to handle larger ranges.   One hex digit seemed
0:      * reasonable for the number of conglomerate types being currently 
0:      * considered (heap, btree, gist, gist btree, gist rtree, hash, others? ).
0:      * <p>
0: 	 * @see ConglomerateFactory#getConglomerateFactoryId
0:      *
0: 	 * @return an unique identifier used to the factory into the conglomid.
0:      *
0:      **/
0:     public int getConglomerateFactoryId()
0:     {
0:         return(ConglomerateFactory.HEAP_FACTORY_ID);
0:     }
0: 
0: 	/**
0: 	Create the conglomerate and return a conglomerate object for it.
0: 
0: 	@exception StandardException Standard exception policy.
0: 
0: 	@see ConglomerateFactory#createConglomerate
0: 	**/
0: 	public Conglomerate createConglomerate(	
0:     TransactionManager      xact_mgr,
0:     int                     segment,
0:     long                    input_containerid,
0:     DataValueDescriptor[]   template,
0: 	ColumnOrdering[]        columnOrder,  //only meant for BTree type congloms
0:     Properties              properties,
0: 	int                     temporaryFlag)
0: 		throws StandardException
0: 	{
0: 		//parent.register(heap);
0: 		Heap heap = new Heap();
0: 		heap.create(
0:             xact_mgr.getRawStoreXact(), segment, input_containerid, 
0:             template, properties, temporaryFlag);
0: 
0: 		return heap;
0: 	}
0: 
0:     /**
0:      * Return Conglomerate object for conglomerate with container_key.
0:      * <p>
0:      * Return the Conglomerate Object.  This is implementation specific.
0:      * Examples of what will be done is using the key to find the file where
0:      * the conglomerate is located, and then executing implementation specific
0:      * code to instantiate an object from reading a "special" row from a
0:      * known location in the file.  In the btree case the btree conglomerate
0:      * is stored as a column in the control row on the root page.
0:      * <p>
0:      * This operation is costly so it is likely an implementation using this
0:      * will cache the conglomerate row in memory so that subsequent accesses
0:      * need not perform this operation.
0:      *
0:      * @param xact_mgr      transaction to perform the create in.
0:      * @param container_key The unique id of the existing conglomerate.
0:      *
0: 	 * @return An instance of the conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public Conglomerate readConglomerate(
0:     TransactionManager      xact_mgr,
0:     ContainerKey            container_key)
0: 		throws StandardException
0:     {
0:         ContainerHandle         container   = null;
0:         Page                    page        = null;
0:         DataValueDescriptor[]   control_row = new DataValueDescriptor[1];
0: 
0:         try
0:         {
0:             // open container to read the Heap object out of it's control row.
0:             container = 
0:                 xact_mgr.getRawStoreXact().openContainer(
0:                     container_key, (LockingPolicy) null, 0);
0: 
0:             if (container == null)
0:             {
0:                 throw StandardException.newException(
0:                     SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST,
0:                     new Long(container_key.getContainerId()));
0:             }
0: 
0:             // row in slot 0 of heap page 1 which is just a single column with
0:             // the heap entry.
0:             control_row[0]       = new Heap();
0: 
0:             page = container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0:             RecordHandle rh = 
0:                 page.fetchFromSlot(
0:                    (RecordHandle) null, 0, control_row, 
0:                    (FetchDescriptor) null,
0:                    true);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(rh != null);
0: 
0:                 // for now the control row is always the first id assigned on
0:                 // page 1.
0:                 SanityManager.ASSERT(rh.getId() == 6);
0:             }
0:         }
0:         finally
0:         {
0:             if (page != null)
0:                 page.unlatch();
0: 
0:             if (container != null)
0:                 container.close();
0:         }
0: 
0:         return((Conglomerate) control_row[0]);
0:     }
0: 
0: 	/*
0: 	** Methods of ModuleControl.
0: 	*/
0: 
0: 	public boolean canSupport(Properties startParams) {
0: 
0: 		String impl = 
0:             startParams.getProperty("derby.access.Conglomerate.type");
0: 
0: 		if (impl == null)
0: 			return false;
0: 
0: 		return supportsImplementation(impl);
0: 	}
0: 
0: 	public void	boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		// Find the UUID factory.
0: 		UUIDFactory uuidFactory = 
0:             Monitor.getMonitor().getUUIDFactory();
0: 		
0: 		// Make a UUID that identifies this conglomerate's format.
0: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
0: 	}
0: 
0: 	public void	stop()
0: 	{
0: 	}
0: 
0: 	/*
0: 	** Methods of HeapConglomerateFactory
0: 	*/
0: 
0: 	public HeapConglomerateFactory()
0: 	{
0: 	}
0: }
0: 
============================================================================