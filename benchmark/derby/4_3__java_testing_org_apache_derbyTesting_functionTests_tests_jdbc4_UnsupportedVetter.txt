1:32f71fe:  /**
1:4a47eda:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbc4.UnsupportedVetter
4:4a47eda:  *
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:6e3dbab: 
1:6e3dbab:       http://www.apache.org/licenses/LICENSE-2.0
1:6e3dbab: 
1:6e3dbab:    Unless required by applicable law or agreed to in writing, software
1:6e3dbab:    distributed under the License is distributed on an "AS IS" BASIS,
1:6e3dbab:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6e3dbab:    See the License for the specific language governing permissions and
1:6e3dbab:    limitations under the License.
1:4a47eda:  *
1:4a47eda:  */
3:4a47eda: 
1:4a47eda: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:4a47eda: 
1:88a2109: import java.io.*;
1:4a47eda: import java.sql.*;
1:4a47eda: import javax.sql.*;
1:4a47eda: 
1:4a47eda: import java.lang.reflect.*;
1:4a47eda: import java.util.*;
1:4a47eda: import junit.framework.*;
1:4a47eda: 
1:32f71fe: import java.net.URL;
1:32f71fe: 
1:4a47eda: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:8ed08b2: import org.apache.derbyTesting.junit.J2EEDataSource;
1:dd7903b: import org.apache.derbyTesting.junit.JDBC;
1:8ed08b2: import org.apache.derbyTesting.junit.JDBCDataSource;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:4a47eda: 
1:d04e05e: /**
1:7a1db7b:  * JUnit test which checks that only expected methods throw
1:7a1db7b:  * SQLFeatureNotSupporteException. As currently compiled, this class
1:7a1db7b:  * does not object to a handful of mandatory LOB-supporting methods which Derby
1:7a1db7b:  * does not implement. You can expose these methods by setting
1:7a1db7b:  * the STRICT_ENFORCEMENT constant to true.
1:7a1db7b:  *
1:4a47eda:  */
1:4a47eda: public class UnsupportedVetter	extends BaseJDBCTestCase
3:4a47eda: {
1:4a47eda: 	/////////////////////////////////////////////////////////////
5:4a47eda: 	//
1:4a47eda: 	//	CONSTANTS
1:7a1db7b: 	//
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:7a1db7b: 
1:4a47eda: 	public	static	final	String	SQL_PACKAGE_NAME = "java.sql";
1:7a1db7b: 
1:7a1db7b: 	private	static	final	boolean	STRICT_ENFORCEMENT = false;
1:4a47eda: 	
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:7a1db7b: 	//
1:4a47eda: 	//	STATE
1:4a47eda: 	//
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Table of methods which are allowed to raise
1:4a47eda: 	// SQLFeatureNotSupportedException. Derived from the 1.6 Javadoc.
1:4a47eda: 	//
1:4a47eda: 	private	static	Exclusions[]	rawExcludables = new Exclusions[]
1:32f71fe: 		{
1:7a1db7b: 		    new Exclusions
1:7a1db7b: 		    (
1:32f71fe: 				java.sql.Connection.class,
1:7a1db7b: 				new MD[]
1:7a1db7b: 				{
1:7c3b39d: 						new MD( "createArrayOf", new Class[] { String.class, Object[].class } ),
1:32f71fe: 						new MD( "createNClob", new Class[] { } ),
1:32f71fe: 						new MD( "createSQLXML", new Class[] { } ),
1:32f71fe: 						new MD( "createStruct", new Class[] { String.class, Object[].class } ),
1:9c8b717: 						new MD( "getNetworkTimeout", new Class[] { }, JDBC.vmSupportsJDBC41() ),
1:32f71fe: 						new MD( "getTypeMap", new Class[] { } ),
1:32f71fe: 						new MD( "prepareStatement", new Class[] { String.class, int[].class } ),
1:b0551db: 						new MD( "prepareStatement", new Class[] { String.class, String[].class } ),
1:9c8b717: 						new MD( "setNetworkTimeout", new Class[] { java.util.concurrent.Executor.class, int.class }, JDBC.vmSupportsJDBC41() ),
1:b0551db: 						new MD( "setTypeMap", new Class[] { Map.class } ),
1:7a1db7b: 						} ),
1:32f71fe: 		    new Exclusions
1:32f71fe: 		    (
1:32f71fe: 				java.sql.Statement.class,
1:32f71fe: 				new MD[]
1:32f71fe: 				{
1:88a2109: 						new MD( "cancel", new Class[] { } ),
1:32f71fe: 				    new MD( "execute", new Class[] { String.class, int[].class } ),
1:32f71fe: 						new MD( "execute", new Class[] { String.class, String[].class } ),
1:32f71fe: 						new MD( "executeUpdate", new Class[] { String.class, int[].class } ),
1:32f71fe: 						new MD( "executeUpdate", new Class[] { String.class, String[].class } )
1:7a1db7b: 						} )
1:32f71fe: 		    ,
1:7a1db7b: 
1:32f71fe: 		    new Exclusions 
1:32f71fe: 			(
1:32f71fe: 				java.sql.PreparedStatement.class,
1:32f71fe: 				new MD[]
1:32f71fe: 				{
1:32f71fe: 					new MD( "setArray", new Class[] { int.class, java.sql.Array.class } ),
1:c586481: 						new MD( "setNCharacterStream", new Class[] { int.class, java.io.Reader.class } ),
1:32f71fe: 						new MD( "setNCharacterStream", new Class[] { int.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "setNClob", new Class[] { int.class, NClob.class } ),
1:c586481: 						new MD( "setNClob", new Class[] { int.class, java.io.Reader.class } ),
1:32f71fe: 						new MD( "setNClob", new Class[] { int.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "setNString", new Class[] { int.class, String.class } ),
1:32f71fe: 						new MD( "setRef", new Class[] { int.class, Ref.class } ),
1:c1ecc42:                         new MD( "setRowId", new Class[] { int.class, RowId.class } ),
1:32f71fe: 						new MD( "setSQLXML", new Class[] { int.class, SQLXML.class } ),
1:b0551db: 					    new MD( "setURL", new Class[] { int.class, URL.class } ),
1:88a2109: 					    new MD( "setNull", new Class[] { int.class, int.class, String.class } ),
1:88a2109: 					    new MD( "setUnicodeStream", new Class[] { int.class, InputStream.class, int.class } ),
1:32f71fe: 						} ),
1:32f71fe: 			new Exclusions
1:32f71fe: 			(
1:4a47eda: 			    java.sql.CallableStatement.class,
1:32f71fe: 				new MD[]
1:4a47eda: 				{
1:7a1db7b: 					//
1:7a1db7b: 					// THE FOLLOWING METHODS ARE MANDATORY ACCORDING TO THE
1:7a1db7b: 					// JDBC SPEC. HOWEVER, DERBY DOES NOT IMPLEMENT THEM IN ONE
1:7a1db7b: 					// OR THE OTHER OF OUR CLIENTS.
1:7a1db7b: 					//
1:7a1db7b: 					new FD( "getBlob", new Class[] { int.class } ),
1:7a1db7b: 					new FD( "getClob", new Class[] { int.class } ),
1:7a1db7b: 					
1:7a1db7b: 
1:7a1db7b: 					//
1:7a1db7b: 					// According to the JDBC4 spec and javadoc, the following
1:7a1db7b: 					// methods are optional and do not have to be implemented.
1:7a1db7b: 					//
1:7a1db7b: 					
1:4a47eda: 					new MD( "getArray", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getArray", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getBigDecimal", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getBoolean", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getBlob", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getBoolean", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getByte", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getBytes", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getCharacterStream", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getClob", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getDate", new Class[] { String.class } ),
1:32f71fe: 					new MD( "getDate", new Class[] { String.class, Calendar.class } ),
1:4a47eda: 					new MD( "getDouble", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getFloat", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getInt", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getLong", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getNCharacterStream", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getNCharacterStream", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getNClob", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getNClob", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getNString", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getNString", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getObject", new Class[] { String.class } ),
1:9c8b717: 					new MD( "getObject", new Class[] { String.class, Class.class }, JDBC.vmSupportsJDBC41() ),
1:4a47eda: 					new MD( "getRef", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getRef", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getRowId", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getRowId", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getShort", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getSQLXML", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getSQLXML", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getString", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getTime", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getTime", new Class[] { String.class, java.util.Calendar.class } ),
1:4a47eda: 					new MD( "getTimestamp", new Class[] { String.class } ),
1:4a47eda: 					new MD( "getTimestamp", new Class[] { String.class, java.util.Calendar.class } ),
1:4a47eda: 					new MD( "getURL", new Class[] { int.class } ),
1:4a47eda: 					new MD( "getURL", new Class[] { String.class } ),
1:9064515:                     new MD( "registerOutParameter", new Class[] { String.class, int.class } ),
1:9064515:                     new MD( "registerOutParameter", new Class[] { String.class, int.class, int.class } ),
1:9064515:                     new MD( "registerOutParameter", new Class[] { String.class, int.class, String.class } ),
1:9064515:                     new MD( "registerOutParameter", new Class[] { int.class, int.class, String.class } ),
1:9064515:                     makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType" }, JDBC.vmSupportsJDBC42() ),
1:9064515:                     makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType", "int" }, JDBC.vmSupportsJDBC42() ),
1:9064515:                     makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType", "java.lang.String" }, JDBC.vmSupportsJDBC42() ),
1:32f71fe: 						new MD( "setArray", new Class[] { int.class, java.sql.Array.class } ),
1:c586481: 						new MD( "setAsciiStream", new Class[] { String.class, java.io.InputStream.class } ),
1:32f71fe: 						new MD( "setAsciiStream", new Class[] { String.class, java.io.InputStream.class, int.class } ),
1:c511410:                                                 new MD( "setAsciiStream", new Class[] { String.class, java.io.InputStream.class, long.class } ),
1:32f71fe: 						new MD( "setBigDecimal", new Class[] { String.class, java.math.BigDecimal.class } ),
1:c586481: 						new MD( "setBinaryStream", new Class[] { String.class, java.io.InputStream.class } ),
1:32f71fe: 						new MD( "setBinaryStream", new Class[] { String.class, java.io.InputStream.class, int.class } ),
1:c511410:                                                 new MD( "setBinaryStream", new Class[] { String.class, java.io.InputStream.class, long.class } ),
1:c586481: 						new MD( "setBlob", new Class[] { String.class, java.io.InputStream.class } ),
1:32f71fe: 						new MD( "setBlob", new Class[] { String.class, java.io.InputStream.class, long.class } ),
1:32f71fe: 						new MD( "setBlob", new Class[] { String.class, Blob.class } ),
1:32f71fe: 						new MD( "setBoolean", new Class[] { String.class, boolean.class } ),
1:32f71fe: 						new MD( "setByte", new Class[] { String.class, byte.class } ),
1:32f71fe: 						new MD( "setBytes", new Class[] { String.class, byte[].class } ),
1:c586481: 						new MD( "setCharacterStream", new Class[] { String.class, java.io.Reader.class } ),
1:32f71fe: 						new MD( "setCharacterStream", new Class[] { String.class, java.io.Reader.class, int.class } ),
1:c511410:                                                 new MD( "setCharacterStream", new Class[] { String.class, java.io.Reader.class, long.class } ),
1:c586481: 						new MD( "setClob", new Class[] { String.class, java.io.Reader.class } ),
1:32f71fe: 						new MD( "setClob", new Class[] { String.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "setClob", new Class[] { String.class, Clob.class } ),
1:32f71fe: 						new MD( "setDate", new Class[] { String.class, java.sql.Date.class } ),
1:32f71fe: 						new MD( "setDate", new Class[] { String.class, java.sql.Date.class, Calendar.class } ),
1:32f71fe: 						new MD( "setDouble", new Class[] { String.class, double.class} ),
1:32f71fe: 						new MD( "setFloat", new Class[] { String.class, float.class } ),
1:32f71fe: 						new MD( "setInt", new Class[] { String.class, int.class } ),
1:32f71fe: 						new MD( "setLong", new Class[] { String.class, long.class } ),
1:32f71fe: 						new MD( "setNCharacterStream", new Class[] { int.class, java.io.Reader.class, long.class } ),
1:c586481: 						new MD( "setNCharacterStream", new Class[] { String.class, java.io.Reader.class } ),
1:32f71fe: 						new MD( "setNCharacterStream", new Class[] { String.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "setNClob", new Class[] { int.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "setNClob", new Class[] { int.class, NClob.class } ),
1:c586481: 						new MD( "setNClob", new Class[] { String.class, java.io.Reader.class } ),
1:32f71fe: 						new MD( "setNClob", new Class[] { String.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "setNClob", new Class[] { String.class, NClob.class } ),
1:32f71fe: 						new MD( "setNString", new Class[] { int.class, String.class } ),
1:32f71fe: 						new MD( "setNString", new Class[] { String.class, String.class } ),
1:32f71fe: 						new MD( "setNull", new Class[] { String.class, int.class } ),
1:32f71fe: 						new MD( "setNull", new Class[] { String.class, int.class, String.class } ),
1:32f71fe: 						new MD( "setObject", new Class[] { String.class, Object.class } ),
1:32f71fe: 						new MD( "setObject", new Class[] { String.class, Object.class, int.class } ),
1:32f71fe: 						new MD( "setObject", new Class[] { String.class, Object.class, int.class, int.class } ),
1:32f71fe: 						new MD( "setRef", new Class[] { int.class, Ref.class } ),
1:32f71fe: 						new MD( "setRowId", new Class[] { int.class, RowId.class } ),
1:32f71fe: 						new MD( "setRowId", new Class[] { String.class, RowId.class } ),
1:32f71fe: 						new MD( "setSQLXML", new Class[] { int.class, SQLXML.class } ),
1:32f71fe: 						new MD( "setSQLXML", new Class[] { String.class, SQLXML.class } ),
1:32f71fe: 						new MD( "setShort", new Class[] { String.class, short.class } ),
1:32f71fe: 						new MD( "setString", new Class[] { String.class, String.class } ),
1:32f71fe: 						new MD( "setTime", new Class[] { String.class, Time.class } ),
1:32f71fe: 						new MD( "setTime", new Class[] { String.class, Time.class, Calendar.class } ),
1:32f71fe: 						new MD( "setTimestamp", new Class[] { String.class, Timestamp.class } ),
1:32f71fe: 						new MD( "setTimestamp", new Class[] { String.class, Timestamp.class, Calendar.class } ),
1:32f71fe: 						new MD( "setURL", new Class[] { int.class, URL.class } ),
1:32f71fe: 						new MD( "setURL", new Class[] { String.class, URL.class } )
1:4a47eda: 				}
1:4a47eda: 			),
1:7a1db7b: 		    new Exclusions
1:7a1db7b: 		    (
1:32f71fe: 				java.sql.ResultSet.class,
1:7a1db7b: 				new MD[]
1:32f71fe: 				{
1:7a1db7b: 					//
1:7a1db7b: 					// THE FOLLOWING METHODS ARE MANDATORY ACCORDING TO THE
1:7a1db7b: 					// JDBC SPEC. HOWEVER, DERBY DOES NOT IMPLEMENT THEM IN ONE
1:7a1db7b: 					// OR THE OTHER OF OUR CLIENTS.
1:7a1db7b: 					//
1:c511410:                                         new FD( "updateNClob",new Class[] { int.class,Reader.class,long.class}),
1:c511410:                                         new FD( "updateNClob",new Class[] { String.class,Reader.class,long.class}),
1:7a1db7b: 
1:7a1db7b: 					//
1:7a1db7b: 					// According to the JDBC4 spec and javadoc, the following
1:7a1db7b: 					// methods are optional and do not have to be implemented.
1:7a1db7b: 					//
1:7a1db7b: 					
1:32f71fe: 				    new MD( "getNCharacterStream", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getNCharacterStream", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getNString", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getNString", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getURL", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getURL", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getArray", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getArray", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getNClob", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getNClob", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getRef", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getRef", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getRowId", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getRowId", new Class[] { String.class } ),
1:32f71fe: 						new MD( "getSQLXML", new Class[] { int.class } ),
1:32f71fe: 						new MD( "getSQLXML", new Class[] { String.class } ),
1:88a2109: 						new MD( "getUnicodeStream", new Class[] { int.class } ),
1:88a2109: 						new MD( "getUnicodeStream", new Class[] { String.class } ),
1:32f71fe: 						new MD( "refreshRow", new Class[] { } ),
1:32f71fe: 						new MD( "updateArray", new Class[] { int.class, java.sql.Array.class } ),
1:32f71fe: 						new MD( "updateArray", new Class[] { String.class, java.sql.Array.class } ),
1:c586481: 						new MD( "updateNCharacterStream", new Class[] { int.class, java.io.Reader.class } ),
1:3d901b8: 						new MD( "updateNCharacterStream", new Class[] { int.class, java.io.Reader.class, long.class } ),
1:c586481: 						new MD( "updateNCharacterStream", new Class[] { String.class, java.io.Reader.class } ),
1:3d901b8: 						new MD( "updateNCharacterStream", new Class[] { String.class, java.io.Reader.class, long.class } ),
1:32f71fe: 						new MD( "updateNClob", new Class[] { int.class, NClob.class } ),
1:c586481: 						new MD( "updateNClob", new Class[] { int.class, Reader.class } ),
1:32f71fe: 						new MD( "updateNClob", new Class[] { String.class, NClob.class } ),
1:c586481: 						new MD( "updateNClob", new Class[] { String.class, Reader.class } ),
1:32f71fe: 						new MD( "updateNString", new Class[] { int.class, String.class } ),
1:32f71fe: 						new MD( "updateNString", new Class[] { String.class, String.class } ),
1:32f71fe: 						new MD( "updateRef", new Class[] { int.class, Ref.class } ),
1:32f71fe: 						new MD( "updateRef", new Class[] { String.class, Ref.class } ),
1:32f71fe: 						new MD( "updateRowId", new Class[] { int.class, RowId.class } ),
1:32f71fe: 						new MD( "updateRowId", new Class[] { String.class, RowId.class } ),
1:32f71fe: 						new MD( "updateSQLXML", new Class[] { int.class, SQLXML.class } ),
1:32f71fe: 						new MD( "updateSQLXML", new Class[] { String.class, SQLXML.class } )
1:32f71fe: 						} ),
1:32f71fe: 			//
1:32f71fe: 			// Lance Andersen, spec lead for JDBC4, says:
1:32f71fe: 			// If you support a datatype, then you have to implement
1:32f71fe: 			// all of its methods.
1:7a1db7b: 			//
1:32f71fe: 
1:4a47eda: 		};
1:4a47eda: 
1:c1ecc42:     //
1:c1ecc42:     // Make an MD if the JVM level supports the indicated classes.
1:c1ecc42:     // Returns null if the JVM doesn't.
1:c1ecc42:     //
1:c1ecc42:     private static  MD  makeMD
1:c1ecc42:         ( String methodName, String[] argClassNames, boolean requiredAtThisLevel )
1:c1ecc42:     {
1:c1ecc42:         // return null if the class names can't be resolved
1:c1ecc42:         int     count = argClassNames.length;
1:c1ecc42:         Class[] argTypes = new Class[ count ];
1:c1ecc42: 
1:c1ecc42:         try {
1:c1ecc42:             for ( int i = 0; i < count; i++ )
1:c1ecc42:             {
1:c1ecc42:                 String  className = argClassNames[ i ];
1:c1ecc42:                 if ( "int".equals( className ) ) { argTypes[ i ] = int.class; }
1:c1ecc42:                 else { argTypes[ i ] = Class.forName( argClassNames[ i ] ); }
1:c1ecc42:             }
1:c1ecc42:         }
1:c1ecc42:         catch (Exception e) { return null; }
1:c1ecc42: 
1:c1ecc42:         return new MD( methodName, argTypes, requiredAtThisLevel );
1:c1ecc42:     }
1:c1ecc42:     
1:7a1db7b: 	//
1:4a47eda: 	// This is the Hashtable where we keep the exclusions.
1:32f71fe: 	//
1:4a47eda: 	private	static	Hashtable< Class, HashSet<Method> >	excludableMap;
1:4a47eda: 	
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 	//
1:4a47eda: 	//	CONSTRUCTOR
1:4a47eda: 	//
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 
2:4a47eda:     /**
1:4a47eda:      * Creates a new instance.
1:4a47eda:      */
1:4a47eda:     public UnsupportedVetter() { super("UnsupportedVetter"); }
1:4a47eda: 
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 	//
1:4a47eda: 	//	ENTRY POINTS
1:4a47eda: 	//
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 
1:4a47eda: 	/**
1:4a47eda: 	 * <p>
1:4a47eda: 	 * Find all methods in this framework which raise SQLFeatureNotSupportedException.
1:4a47eda: 	 * </p>
1:4a47eda: 	 */
1:4a47eda: 	public	void	testSupportedMethods()
1:4a47eda: 		throws Exception
1:7a1db7b: 	{
1:a9431f5:     getTestConfiguration().setVerbosity( true );
1:9064515: 
1:a9431f5:     // do not run on java 9. it introduces classes and methods not found in java 8.
1:a9431f5:     if (vmAtLeast(1, 9)) { return; }
1:a9431f5: 
1:a9431f5:     if ( savedVerbosity ) { println( "Supports JDBC 4.2 = " + JDBC. vmSupportsJDBC42() ); }
1:4a47eda: 
1:3d901b8: 		HashSet<String>	vanishedMethodList = new HashSet<String>();
1:4a47eda: 		HashSet<String>	unsupportedList = new HashSet<String>();
1:4a47eda: 		HashSet<String>	notUnderstoodList = new HashSet<String>();
1:4a47eda: 
1:3d901b8: 		// Build map of interfaces to their methods which may raise SQLFeatureNotSupportedException.
1:3d901b8: 		initializeExcludableMap( vanishedMethodList );
1:3d901b8: 
1:4a47eda: 		vetDataSource( unsupportedList, notUnderstoodList );
1:4a47eda: 		vetConnectionPooledDataSource( unsupportedList, notUnderstoodList );
1:4a47eda: 		vetXADataSource( unsupportedList, notUnderstoodList );
1:4a47eda: 
1:4a47eda: 		//
1:4a47eda: 		// Print methods which behave unexpectedly.
1:4a47eda: 		//
1:3d901b8: 		printVanishedMethodList( vanishedMethodList );
1:4a47eda: 		printUnsupportedList( unsupportedList );
1:4a47eda: 		printNotUnderstoodList( notUnderstoodList );
1:3d901b8: 
1:a9431f5:     assertEquals( "vanishedMethodList", 0, vanishedMethodList.size() );
1:a9431f5:     assertEquals( "unsupportedList", 0, unsupportedList.size() );
1:a9431f5:     assertEquals( "notUnderstoodList", 0, notUnderstoodList.size() );
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Find all the objects inside the DataSource and vet them.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetDataSource
1:4a47eda: 		( HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:8ed08b2: 		DataSource			ds = JDBCDataSource.getDataSource();
1:4a47eda: 		Connection			conn = ds.getConnection();
1:4a47eda: 
1:4a47eda: 		vetObject( ds, unsupportedList, notUnderstoodList );
1:4a47eda: 
1:4a47eda: 		connectionWorkhorse( conn, unsupportedList, notUnderstoodList );
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Find all the objects inside the ConnectionPooledDataSource and vet them.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetConnectionPooledDataSource
1:4a47eda: 		( HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:8ed08b2: 		ConnectionPoolDataSource	ds = J2EEDataSource.getConnectionPoolDataSource();
1:4a47eda: 		PooledConnection			pc = ds.getPooledConnection
1:e0104e8: 			(getTestConfiguration().getUserName(),
1:e0104e8:                     getTestConfiguration().getUserPassword());
1:4a47eda: 		Connection					conn = pc.getConnection();
1:4a47eda: 
1:4a47eda: 		vetObject( ds, unsupportedList, notUnderstoodList );
1:4a47eda: 		vetObject( pc, unsupportedList, notUnderstoodList );
1:4a47eda: 
1:4a47eda: 		connectionWorkhorse( conn, unsupportedList, notUnderstoodList );
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Find all the objects inside the XADataSource and vet them.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetXADataSource
1:4a47eda: 		( HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:8ed08b2: 		XADataSource				ds = J2EEDataSource.getXADataSource();
1:4a47eda: 		XAConnection				xaconn = ds.getXAConnection
1:e0104e8: 			(getTestConfiguration().getUserName(),
1:e0104e8:                     getTestConfiguration().getUserPassword());
1:4a47eda: 		Connection					conn = xaconn.getConnection();
1:4a47eda: 
1:4a47eda: 		vetObject( ds, unsupportedList, notUnderstoodList );
1:4a47eda: 		vetObject( xaconn, unsupportedList, notUnderstoodList );
1:4a47eda: 
1:4a47eda: 		connectionWorkhorse( conn, unsupportedList, notUnderstoodList );
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Find all the methods for java.sql objects in the Connection which raise
1:4a47eda: 	// SQLFeatureNotSupportedException.
1:4a47eda: 	//
1:4a47eda: 	private	void	connectionWorkhorse
1:4a47eda: 		( Connection conn, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList  )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda: 		vetSavepoint( conn, unsupportedList, notUnderstoodList );
1:4a47eda: 		vetLargeObjects( conn, unsupportedList, notUnderstoodList );
1:4a47eda: 		
1:4a47eda: 		DatabaseMetaData	dbmd = conn.getMetaData();
1:4a47eda: 		PreparedStatement	ps = conn.prepareStatement
1:4a47eda: 			( "select * from sys.systables where tablename = ?" );
1:4a47eda: 
1:4a47eda: 		ps.setString( 1, "foo" );
1:4a47eda: 
1:4a47eda: 		ParameterMetaData	parameterMetaData = ps.getParameterMetaData();
1:4a47eda: 		ResultSet			rs = ps.executeQuery();
1:4a47eda: 		ResultSetMetaData	rsmd = rs.getMetaData();
1:4a47eda:         Statement			stmt = conn.createStatement();
1:4a47eda: 
1:4a47eda:         CallableStatement	cs =
1:4a47eda:             conn.prepareCall("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:4a47eda:         ParameterMetaData	csmd = cs.getParameterMetaData();
1:4a47eda: 
1:d04e05e: 		//
1:d04e05e: 		// The vetObject() method calls all of the methods in these objects
1:d04e05e: 		// in a deterministic order, calling the close() method last.
1:d04e05e: 		// Inspect these objects in an order which respects the fact that
1:d04e05e: 		// the objects are closed as a result of calling vetObject().
1:d04e05e: 		//
1:4a47eda: 		vetObject( dbmd, unsupportedList, notUnderstoodList );
1:4a47eda: 		vetObject( stmt, unsupportedList, notUnderstoodList );
1:4a47eda: 		vetObject( csmd, unsupportedList, notUnderstoodList );
1:d04e05e: 		vetObject( cs, unsupportedList, notUnderstoodList );
1:d04e05e: 		vetObject( rsmd, unsupportedList, notUnderstoodList );
1:d04e05e: 		vetObject( rs, unsupportedList, notUnderstoodList );
1:d04e05e: 		vetObject( parameterMetaData, unsupportedList, notUnderstoodList );
1:d04e05e: 		vetObject( ps, unsupportedList, notUnderstoodList );
1:d04e05e: 		vetObject( conn, unsupportedList, notUnderstoodList );
1:4a47eda: 
1:d04e05e: 		// No need to close the objects. They were closed by vetObject().
1:4a47eda: 	}
1:4a47eda: 	
1:4a47eda: 	//
1:4a47eda: 	// Examine Savepoints.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetSavepoint
1:4a47eda: 		( Connection conn, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList  )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda:         conn.setAutoCommit( false );
1:4a47eda: 
1:4a47eda:         Savepoint			sp = conn.setSavepoint();
1:4a47eda: 		
1:4a47eda: 		vetObject( sp, unsupportedList, notUnderstoodList );
1:4a47eda: 		
1:4a47eda:         conn.releaseSavepoint(sp);
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Examine BLOBs and CLOBs.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetLargeObjects
1:4a47eda: 		( Connection conn, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList  )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda:         Statement		stmt = conn.createStatement();
1:4a47eda: 
1:4a47eda:         stmt.execute("CREATE TABLE t (id INT PRIMARY KEY, " +
1:4a47eda:                      "b BLOB(10), c CLOB(10))");
1:4a47eda:         stmt.execute("INSERT INTO t (id, b, c) VALUES (1, "+
1:4a47eda:                      "CAST (" + TestUtil.stringToHexLiteral("101010001101") +
1:4a47eda:                      "AS BLOB(10)), CAST ('hello' AS CLOB(10)))");
1:4a47eda: 
1:4a47eda:         ResultSet rs = stmt.executeQuery("SELECT id, b, c FROM t");
1:4a47eda: 
1:4a47eda:         rs.next();
1:4a47eda: 
1:4a47eda:         Blob		blob = rs.getBlob(2);
1:4a47eda:         Clob		clob = rs.getClob(3);
1:4a47eda: 
1:4a47eda: 		vetObject( blob, unsupportedList, notUnderstoodList );
1:4a47eda: 		vetObject( clob, unsupportedList, notUnderstoodList );
1:4a47eda: 
2:4a47eda:         stmt.close();
1:4a47eda:         conn.rollback();
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 	//
1:4a47eda: 	//	MINIONS
1:4a47eda: 	//
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Initialize the hashtable of methods which are allowed to raise
1:4a47eda: 	// SQLFeatureNotSupportedException.
1:4a47eda: 	//
1:3d901b8: 	private	void	initializeExcludableMap( HashSet<String> vanishedMethodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda: 		excludableMap = new Hashtable< Class, HashSet<Method> >();
1:4a47eda: 		
1:4a47eda: 		int		count = rawExcludables.length;
1:4a47eda: 
1:4a47eda: 		for ( int i = 0; i < count; i++ )
1:4a47eda: 		{
1:4a47eda: 			Exclusions		exclusions = rawExcludables[ i ];
1:0f26c83: 			Class<?>		iface = exclusions.getInterface();
1:4a47eda: 			MD[]			mds = exclusions.getExcludedMethods();
1:4a47eda: 			int				exclusionCount = mds.length;
1:4a47eda: 			HashSet<Method>	excludedMethodSet = new HashSet<Method>();
1:4a47eda: 
1:4a47eda: 			for ( int j = 0; j < exclusionCount; j++ )
1:4a47eda: 			{
1:4a47eda: 				MD		md = mds[ j ];
1:4a47eda: 
1:c1ecc42:                 if ( md == null ) { continue; }
1:9c8b717:                 if ( !md.requiredAtThisLevel() ) { continue; }
1:9c8b717: 
1:7a1db7b: 				//
1:7a1db7b: 				// If we are strictly enforcing the JDBC standard,
1:7a1db7b: 				// then expose the mandatory methods which we know Derby
1:7a1db7b: 				// doesn't implement.
1:7a1db7b: 				//
1:7a1db7b: 				if ( STRICT_ENFORCEMENT && !md.isOptional()  ) { continue; }
1:7a1db7b: 
1:3d901b8: 				Method	method = null;
1:4a47eda: 
1:3d901b8: 				try {
1:3d901b8: 					method = iface.getMethod( md.getMethodName(), md.getArgTypes() );
1:3d901b8: 				} catch (NoSuchMethodException e) {}
1:3d901b8: 
1:3d901b8: 				if ( method == null )
1:3d901b8: 				{
1:3d901b8: 					vanishedMethodList.add
1:3d901b8: 						( "Method has vanished from SQL interface: " + iface.getName() + "." + md );
1:3d901b8: 				}
1:4a47eda: 
1:4a47eda: 				excludedMethodSet.add( method );
1:4a47eda: 			}
1:4a47eda: 
1:4a47eda: 			excludableMap.put( iface, excludedMethodSet );
1:4a47eda: 		}
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Find all the methods from java.sql interfaces which are implemented by an object
1:4a47eda: 	// and which raise SQLFeatureNotSupportedException.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetObject
1:4a47eda: 		( Object candidate, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda: 		Class		myClass = candidate.getClass();
1:4a47eda: 
1:4a47eda: 		vetInterfaces( candidate, myClass, unsupportedList, notUnderstoodList );
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Find all the java.sql interfaces implemented by a class and find
1:4a47eda: 	// the methods in those interfaces which raise
1:4a47eda: 	// SQLFeatureNotSupportedException when called on the passed-in candidate object.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetInterfaces
1:4a47eda: 		( Object candidate, Class myClass,
1:4a47eda: 		  HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda: 		Class		superClass = myClass.getSuperclass();
1:4a47eda: 
1:4a47eda: 		if ( superClass != null )
1:4a47eda: 		{ vetInterfaces( candidate, superClass, unsupportedList, notUnderstoodList ); }
1:4a47eda: 
1:d04e05e: 		//
1:d04e05e: 		// The contract for Class.getInterfaces() states that the interfaces
1:d04e05e: 		// come back in a deterministic order, namely, in the order that
1:d04e05e: 		// they were declared in the "extends" clause.
1:d04e05e: 		//
1:4a47eda: 		Class<?>[]	interfaces = myClass.getInterfaces();
1:4a47eda: 		int			interfaceCount = interfaces.length;
1:4a47eda: 
1:4a47eda: 		for ( int i = 0; i < interfaceCount; i++ )
1:4a47eda: 		{
1:4a47eda: 			Class<?>	iface = interfaces[ i ];
1:4a47eda: 
1:4a47eda: 			if ( iface.getPackage().getName().equals( SQL_PACKAGE_NAME ) )
1:4a47eda: 			{
1:4a47eda: 				vetInterfaceMethods( candidate, iface, unsupportedList, notUnderstoodList );
1:4a47eda: 			}
1:4a47eda: 
1:4a47eda: 			vetInterfaces( candidate, iface, unsupportedList, notUnderstoodList );
1:4a47eda: 		}
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:4a47eda: 	// Examine all the methods in an interface to determine which ones
1:4a47eda: 	// raise SQLFeatureNotSupportedException.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetInterfaceMethods
1:4a47eda: 		( Object candidate, Class iface,
1:4a47eda: 		  HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:d04e05e: 		Method[]	methods = sortMethods( iface );
1:4a47eda: 		int			methodCount = methods.length;
1:4a47eda: 
1:4a47eda: 		for ( int i = 0; i < methodCount; i++ )
1:4a47eda: 		{
1:4a47eda: 			Method	method = methods[ i ];
1:4a47eda: 
1:4a47eda: 			vetMethod( candidate, iface, method, unsupportedList, notUnderstoodList );
1:4a47eda: 		}
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:d04e05e: 	// Return the methods of an interface in a deterministic
1:d04e05e: 	// order. Class.getMethods() does not do us this favor.
1:d04e05e: 	//
1:d04e05e: 	private	Method[]	sortMethods( Class iface )
1:d04e05e: 		throws Exception
1:d04e05e: 	{
1:d04e05e: 		Method[]			raw = iface.getMethods();
1:d04e05e: 		int					count = raw.length;
1:d04e05e: 		Method[]			cooked = new Method[ count ];
1:d04e05e: 		MethodSortable[]	sortables = new MethodSortable[ count ];
1:d04e05e: 
1:d04e05e: 		for ( int i = 0; i < count; i++ ) { sortables[ i ] = new MethodSortable( raw[ i ] ); }
1:d04e05e: 
1:d04e05e: 		Arrays.sort( sortables );
1:d04e05e: 
1:d04e05e: 		for ( int i = 0; i < count; i++ ) { cooked[ i ] = sortables[ i ].getMethod(); }
1:d04e05e: 
1:d04e05e: 		return cooked;
1:d04e05e: 	}
1:d04e05e: 
1:d04e05e: 	//
1:4a47eda: 	// Examine a single method to see if it raises SQLFeatureNotSupportedException.
1:4a47eda: 	//
1:4a47eda: 	private	void	vetMethod
1:4a47eda: 		( Object candidate, Class iface, Method method,
1:4a47eda: 		  HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1:4a47eda: 		throws Exception
1:4a47eda: 	{
1:4a47eda: 		try {
1:4a47eda: 			method.invoke( candidate, getNullArguments( method.getParameterTypes() ) );
1:4a47eda: 
1:4a47eda: 			// it's ok for the method to succeed
1:4a47eda: 		}
1:4a47eda: 		catch (Throwable e)
1:4a47eda: 		{
1:3d901b8: 			if ( !( e instanceof InvocationTargetException ) )
1:3d901b8: 			{
1:3d901b8: 				recordUnexpectedError( candidate, iface, method, notUnderstoodList, e );
1:3d901b8: 			}
1:3d901b8: 			else
1:4a47eda: 			{
1:4a47eda: 				Throwable	cause = e.getCause();
1:4a47eda: 				
1:4a47eda: 				if ( cause instanceof SQLFeatureNotSupportedException )
1:4a47eda: 				{
1:b0551db: 					boolean	isExcludable = isExcludable( method );
1:4a47eda: 
1:4a47eda: 					if ( !isExcludable )
1:4a47eda: 					{
1:32f71fe: 					    StackTraceElement[] stack = 
1:32f71fe: 						cause.getStackTrace();
1:32f71fe: 						int i = 0;
1:32f71fe: 						while(i < stack.length && !stack[i].getMethodName().
1:32f71fe: 							  equals("notImplemented")){
1:32f71fe: 								++i;
1:32f71fe: 							}
1:32f71fe: 							while(i < stack.length && stack[i].getMethodName().
1:32f71fe: 								  equals("notImplemented")){
1:32f71fe: 								++i;
1:32f71fe: 							}
1:32f71fe: 							if (i == stack.length) {
1:32f71fe: 								//cause.printStackTrace();
1:32f71fe: 							}
1:32f71fe: 				     
1:32f71fe: 							unsupportedList.add( candidate.getClass().getName() + ": " + method + "@" + (i==stack.length?"no source":cause.getStackTrace()[i]));
1:32f71fe: 					} else {
1:32f71fe: 
1:4a47eda: 					}
1:4a47eda: 				}
1:4a47eda: 				else if ( cause instanceof SQLException )
1:4a47eda: 				{
1:4a47eda: 					// swallow other SQLExceptions, caused by bogus args
1:4a47eda: 				}
1:4a47eda: 				else if ( cause instanceof NullPointerException )
1:4a47eda: 				{
1:4a47eda: 					// swallow other NPEs, caused by bogus args
1:4a47eda: 				}
1:4a47eda: 				else if ( cause instanceof ArrayIndexOutOfBoundsException )
1:4a47eda: 				{
1:4a47eda: 					// swallow these, caused by bogus args
1:4a47eda: 				}
1:4a47eda: 				else
1:4a47eda: 				{
1:3d901b8: 					recordUnexpectedError( candidate, iface, method, notUnderstoodList, cause );
1:4a47eda: 				}
1:4a47eda: 				
1:4a47eda: 			}
1:4a47eda: 		}
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	//
1:3d901b8: 	// Record an unexpected error.
1:3d901b8: 	//
1:3d901b8: 	private	void	recordUnexpectedError
1:3d901b8: 		( Object candidate, Class iface, Method method,
1:3d901b8: 		  HashSet<String> notUnderstoodList, Throwable cause )
1:3d901b8: 		throws Exception
1:3d901b8: 	{
1:3d901b8: 		notUnderstoodList.add
1:3d901b8: 			( candidate.getClass().getName() + " " + method + " raises " + cause );
1:3d901b8: 	}
1:3d901b8: 	
1:3d901b8: 	//
1:b0551db: 	// Returns true if this method is allowed to raise SQLFeatureNotSupportedException.
1:4a47eda: 	//
1:b0551db: 	private	boolean	isExcludable(Method method )
1:b0551db: 		throws Exception
1:4a47eda: 	{
1:b0551db: 		Class				iface = method.getDeclaringClass();
1:4a47eda: 		HashSet<Method>		excludableMethods = excludableMap.get( iface );
1:4a47eda: 
1:b0551db: 		if ( excludableMethods == null )
1:b0551db: 		{
1:b0551db: 			return false;
1:b0551db: 		}
1:4a47eda: 
1:4a47eda: 		return excludableMethods.contains( method );
1:4a47eda: 	}
1:4a47eda: 	
1:4a47eda:     /**
1:4a47eda:      * Takes an array of classes and returns an array of objects with
1:4a47eda:      * null values compatible with the classes. Helper method for
1:4a47eda:      * converting a parameter list to an argument list.
1:4a47eda:      *
1:4a47eda:      * @param params a <code>Class[]</code> value
1:4a47eda:      * @return an <code>Object[]</code> value
1:4a47eda:      */
1:4a47eda:     private Object[] getNullArguments(Class[] params) {
1:4a47eda:         Object[] args = new Object[params.length];
1:4a47eda:         for (int i = 0; i < params.length; i++) {
1:4a47eda:             args[i] = getNullValueForType(params[i]);
1:4a47eda:         }
1:4a47eda:         return args;
1:4a47eda:     }
1:4a47eda: 
1:4a47eda:     /**
1:4a47eda:      * Returns a null value compatible with the class. For instance,
1:4a47eda:      * return <code>Boolean.FALSE</code> for primitive booleans, 0 for
1:4a47eda:      * primitive integers and <code>null</code> for non-primitive
1:4a47eda:      * types.
1:4a47eda:      *
1:4a47eda:      * @param type a <code>Class</code> value
1:4a47eda:      * @return a null value
1:4a47eda:      */
1:4a47eda:     private Object getNullValueForType(Class type)
1:4a47eda: 	{
1:4a47eda:         if (!type.isPrimitive()) {
1:4a47eda:             return null;
1:4a47eda:         }
1:4a47eda:         if (type == Boolean.TYPE) {
1:4a47eda:             return Boolean.FALSE;
1:4a47eda:         }
1:4a47eda:         if (type == Character.TYPE) {
1:39b3237:             return (char) 0;
1:4a47eda:         }
1:4a47eda:         if (type == Byte.TYPE) {
1:39b3237:             return (byte) 0;
1:4a47eda:         }
1:4a47eda:         if (type == Short.TYPE) {
1:39b3237:             return (short) 0;
1:4a47eda:         }
1:4a47eda:         if (type == Integer.TYPE) {
1:01c7f83:             // use 1 instead of 0. 0 = java.sql.Types.NULL and this causes
1:01c7f83:             // various type-aware methods to raise SQLFeatureNotSupportedException
1:39b3237:             return 1;
1:4a47eda:         }
1:4a47eda:         if (type == Long.TYPE) {
1:39b3237:             return 0L;
1:4a47eda:         }
1:4a47eda:         if (type == Float.TYPE) {
1:39b3237:             return 0f;
1:4a47eda:         }
1:4a47eda:         if (type == Double.TYPE) {
1:39b3237:             return 0d;
1:4a47eda:         }
1:4a47eda:         fail("Don't know how to handle type " + type);
1:4a47eda:         return null;            // unreachable statement
1:4a47eda:     }
1:4a47eda: 
1:4a47eda: 	// debug print the list of methods which throw SQLFeatureNotSupportedException
1:4a47eda: 	private	void	printUnsupportedList( HashSet<String> unsupportedList )
1:4a47eda: 	{
1:d04e05e: 		int			count = unsupportedList.size();
1:d04e05e: 
1:d04e05e: 		if ( count == 0 ) { return; }
1:d04e05e: 
1:4a47eda: 		println( "--------------- UNSUPPORTED METHODS ------------------" );
1:4a47eda: 		println( "--" );
1:4a47eda: 
1:4a47eda: 		String[]	result = new String[ count ];
1:4a47eda: 
1:4a47eda: 		unsupportedList.toArray( result );
1:4a47eda: 		Arrays.sort( result );
1:4a47eda: 
1:4a47eda: 		for ( int i = 0; i < count; i++ )
1:4a47eda: 		{
1:4a47eda: 			println( result[ i ] );
1:4a47eda: 		}
1:4a47eda: 	}
1:4a47eda: 
1:3d901b8: 	// debug print the list of methods which have disappeared from the SQL interface
1:3d901b8: 	private	void	printVanishedMethodList( HashSet<String> vanishedMethodList )
1:3d901b8: 	{
1:3d901b8: 		int			count = vanishedMethodList.size();
1:3d901b8: 
1:3d901b8: 		if ( count == 0 ) { return; }
1:3d901b8: 
1:3d901b8: 		println( "--------------- VANISHED METHODS ------------------" );
1:3d901b8: 		println( "--" );
1:3d901b8: 
1:3d901b8: 		String[]	result = new String[ count ];
1:3d901b8: 
1:3d901b8: 		vanishedMethodList.toArray( result );
1:3d901b8: 		Arrays.sort( result );
1:3d901b8: 
1:3d901b8: 		for ( int i = 0; i < count; i++ )
1:3d901b8: 		{
1:3d901b8: 			println( result[ i ] );
1:3d901b8: 		}
1:3d901b8: 	}
1:3d901b8: 
1:4a47eda: 	// Debug print the list of method failures which we don't understand
1:4a47eda: 	private	void	printNotUnderstoodList( HashSet<String> notUnderstoodList )
1:4a47eda: 	{
1:d04e05e: 		int			count = notUnderstoodList.size();
1:d04e05e: 
1:d04e05e: 		if ( count == 0 ) { return; }
1:d04e05e: 
1:4a47eda: 		println( "\n\n" );
1:4a47eda: 		println( "--------------- NOT UNDERSTOOD METHODS ------------------" );
1:4a47eda: 		println( "--" );
1:4a47eda: 
1:4a47eda: 		String[]	result = new String[ count ];
1:4a47eda: 
1:4a47eda: 		notUnderstoodList.toArray( result );
1:4a47eda: 		Arrays.sort( result );
1:4a47eda: 
1:4a47eda: 		for ( int i = 0; i < count; i++ )
1:4a47eda: 		{
1:4a47eda: 			println( result[ i ] );
1:4a47eda: 		}
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 	//
1:4a47eda: 	//	INNER CLASSES
1:4a47eda: 	//
1:4a47eda: 	/////////////////////////////////////////////////////////////
1:4a47eda: 
1:4a47eda: 	/**
1:4a47eda: 	 * <p>
1:7a1db7b: 	 * Method descriptor for optional methods which Derby does not have
1:7a1db7b: 	 * to implement. We abbreviate the name of this class to make
1:4a47eda: 	 * arrays of these declarations compact and readable.
1:4a47eda: 	 * </p>
1:4a47eda: 	 */
1:7a1db7b: 	public	static	class	MD
1:4a47eda: 	{
1:4a47eda: 		private	String	_methodName;
1:4a47eda: 		private	Class[]	_argTypes;
1:9c8b717:         private  boolean _requiredAtThisLevel;
1:4a47eda: 
1:4a47eda: 		/** Construct from methodName and argument types. */
1:4a47eda: 		public	MD( String methodName, Class[] argTypes )
1:4a47eda: 		{
1:9c8b717:             this( methodName, argTypes, true );
1:9c8b717: 		}
1:9c8b717: 		public	MD( String methodName, Class[] argTypes, boolean requiredAtThisLevel )
1:9c8b717: 		{
1:4a47eda: 			_methodName = methodName;
1:4a47eda: 			_argTypes = argTypes;
1:9c8b717:             _requiredAtThisLevel = requiredAtThisLevel;
1:4a47eda: 		}
1:4a47eda: 
1:4a47eda: 		/** Get the name of this method. */
1:4a47eda: 		public	String	getMethodName() { return _methodName; }
1:4a47eda: 
1:4a47eda: 		/** Get the types of the method's arguments */
1:4a47eda: 		public	Class[]	getArgTypes() { return _argTypes; }
1:7a1db7b: 
1:7a1db7b: 		/** Return whether this method is optional */
1:7a1db7b: 		public	boolean	isOptional() { return true; }
1:3d901b8: 
1:9c8b717: 		/** Return whether this method is required at the current JDBC level */
1:9c8b717: 		public	boolean	requiredAtThisLevel() { return _requiredAtThisLevel; }
1:9c8b717: 
1:3d901b8: 		public	String	toString()
1:3d901b8: 		{
1:3d901b8: 			StringBuffer	buffer = new StringBuffer();
1:3d901b8: 
1:3d901b8: 			buffer.append( _methodName );
1:3d901b8: 			buffer.append( "( " );
1:3d901b8: 
1:3d901b8: 			if ( _argTypes != null )
1:3d901b8: 			{
1:3d901b8: 				int		count = _argTypes.length;
1:3d901b8: 
1:3d901b8: 				for ( int i = 0; i < count; i++ )
1:3d901b8: 				{
1:3d901b8: 					if ( i > 0 ) { buffer.append( ", " ); }
1:3d901b8: 
1:3d901b8: 					buffer.append( _argTypes[ i ].getName() );
1:3d901b8: 				}
1:3d901b8: 			}
1:3d901b8: 
1:3d901b8: 			buffer.append( " )" );
1:3d901b8: 
1:3d901b8: 			return buffer.toString();
1:3d901b8: 		}
1:3d901b8: 
1:7a1db7b: 	}
1:7a1db7b: 
1:7a1db7b: 	/**
1:7a1db7b: 	 * <p>
1:7a1db7b: 	 * Method descriptor for mandatory methods which we know Derby does not
1:7a1db7b: 	 * implement. We abbreviate the name of this class to make
1:7a1db7b: 	 * arrays of these declarations compact and readable.
1:7a1db7b: 	 * </p>
1:7a1db7b: 	 */
1:7a1db7b: 	public	static	final	class	FD	extends	MD
1:7a1db7b: 	{
1:7a1db7b: 		private	String	_methodName;
1:7a1db7b: 		private	Class[]	_argTypes;
1:7a1db7b: 
1:7a1db7b: 		/** Construct from methodName and argument types. */
1:7a1db7b: 		public	FD( String methodName, Class[] argTypes ) { super( methodName, argTypes ); }
1:7a1db7b: 
1:7a1db7b: 		/** Return whether this method is optional */
1:7a1db7b: 		public	boolean	isOptional() { return false; }
1:4a47eda: 	}
1:4a47eda: 
1:4a47eda: 	/**
1:4a47eda: 	 * <p>
1:4a47eda: 	 * Describes all of the methods for an interface which are allowed
1:4a47eda: 	 * to raise SQLFeatureNotSupportedException.
1:4a47eda: 	 * </p>
1:4a47eda: 	 */
1:4a47eda: 	public	static	final	class	Exclusions
1:4a47eda: 	{
1:4a47eda: 		private	Class	_class;
1:4a47eda: 		private	MD[]	_excludedMethods;
1:4a47eda: 
1:4a47eda: 		/** Construct from the interface and descriptors for the methods which
1:4a47eda: 		 are allowed to raise SQLFeatureNotSupportedException */
1:4a47eda: 		public	Exclusions( Class theInterface, MD[] excludedMethods )
1:4a47eda: 		{
1:4a47eda: 			_class = theInterface;
1:4a47eda: 			_excludedMethods = excludedMethods;
1:4a47eda: 		}
1:4a47eda: 		
1:4a47eda: 		/** Get the interface. */
1:4a47eda: 		public	Class	getInterface() { return _class; }
1:4a47eda: 
1:4a47eda: 		/** Get descriptors for the methods which may raise
1:4a47eda: 			SQLFeatureNotSupportedException. */
1:4a47eda: 		public	MD[]	getExcludedMethods() { return _excludedMethods; }
1:4a47eda: 	}
1:d04e05e: 
1:d04e05e: 	/**
1:d04e05e: 	 * <p>
1:d04e05e: 	 * Used for sorting methods, which don't come back from Class.getMethods()
1:d04e05e: 	 * in a deterministic order. For extra credit, we put the close() method at
1:d04e05e: 	 * the end of the sort order so that, when we invoke the sorted methods, we
1:d04e05e: 	 * don't accidentally invalidate the receiver.
1:d04e05e: 	 * </p>
1:d04e05e: 	 */
1:d04e05e: 	public	static	final	class	MethodSortable	implements	Comparable
1:d04e05e: 	{
1:d04e05e: 		private	Method	_method;
1:d04e05e: 
1:d04e05e: 		/** Conjure out of a Method */
1:d04e05e: 		public	MethodSortable( Method method ) { _method = method; }
1:d04e05e: 
1:d04e05e: 		/** Get the wrapped Method */
1:d04e05e: 		public	Method	getMethod() { return _method; }
1:d04e05e: 
1:d04e05e: 		//////////////////////////////////////////////////
1:d04e05e: 		//
1:d04e05e: 		//	Comparable BEHAVIOR
1:d04e05e: 		//
1:d04e05e: 		//////////////////////////////////////////////////
1:d04e05e: 
1:d04e05e: 		public	int	compareTo( Object other )
1:d04e05e: 		{
1:d04e05e: 			MethodSortable	that = (MethodSortable) other;
1:d04e05e: 			boolean			thisIsClose = this.isCloseMethod();
1:d04e05e: 			boolean			thatIsClose = that.isCloseMethod();
1:d04e05e: 
1:d04e05e: 			// throw the close() method to the end of the sort order
1:d04e05e: 			if ( thisIsClose )
1:d04e05e: 			{
1:d04e05e: 				if ( thatIsClose ) { return 0; }
1:d04e05e: 				else { return 1; }
1:d04e05e: 			}
1:d04e05e: 			else if ( thatIsClose ) { return -1; }
1:d04e05e: 
1:d04e05e: 			return this.toString().compareTo( that.toString() );
1:d04e05e: 		}
1:d04e05e: 
1:d04e05e: 		//////////////////////////////////////////////////
1:d04e05e: 		//
1:d04e05e: 		//	Object OVERRIDES
1:d04e05e: 		//
1:d04e05e: 		//////////////////////////////////////////////////
1:d04e05e: 
1:d04e05e: 		public	String	toString() { return _method.toString(); }
1:d04e05e: 		
1:d04e05e: 		//////////////////////////////////////////////////
1:d04e05e: 		//
1:d04e05e: 		//	MINIONS
1:d04e05e: 		//
1:d04e05e: 		//////////////////////////////////////////////////
1:d04e05e: 
1:d04e05e: 		// Returns true if the wrapped method is close().
1:d04e05e: 		private	boolean	isCloseMethod()
1:d04e05e: 		{
1:d04e05e: 			return ( toString().startsWith( "close()" ) );
1:d04e05e: 		}
1:d04e05e: 		
1:d04e05e: 	}
1:4a47eda: 
1:e193cf8:     private boolean savedVerbosity;
1:4a47eda: 
1:e193cf8:     protected void setUp() {
1:e193cf8:         // testSupportedMethods() sets the verbosity, so we need to save the
1:e193cf8:         // original verbosity here and restore it in tearDown.
1:e193cf8:         savedVerbosity = getTestConfiguration().isVerbose();
1:4a47eda:     }
1:4a47eda: 
1:e193cf8:     protected void tearDown() throws Exception {
1:e193cf8:         getTestConfiguration().setVerbosity(savedVerbosity);
1:e193cf8:         super.tearDown();
1:dd7903b:     }
1:4a47eda: 
1:ec5ae26:     public static Test suite() {
1:8ed08b2:         return TestConfiguration.defaultSuite(UnsupportedVetter.class);
1:e193cf8:     }
1:e193cf8: }
1:4a47eda: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             return (char) 0;
1:             return (byte) 0;
1:             return (short) 0;
1:             return 1;
1:             return 0L;
1:             return 0f;
1:             return 0d;
commit:a9431f5
/////////////////////////////////////////////////////////////////////////
1:     getTestConfiguration().setVerbosity( true );
1:     // do not run on java 9. it introduces classes and methods not found in java 8.
1:     if (vmAtLeast(1, 9)) { return; }
1: 
1:     if ( savedVerbosity ) { println( "Supports JDBC 4.2 = " + JDBC. vmSupportsJDBC42() ); }
/////////////////////////////////////////////////////////////////////////
1:     assertEquals( "vanishedMethodList", 0, vanishedMethodList.size() );
1:     assertEquals( "unsupportedList", 0, unsupportedList.size() );
1:     assertEquals( "notUnderstoodList", 0, notUnderstoodList.size() );
commit:fc86bf8
/////////////////////////////////////////////////////////////////////////
0:         if ( savedVerbosity ) { println( "Supports JDBC 4.2 = " + JDBC. vmSupportsJDBC42() ); }
commit:9064515
/////////////////////////////////////////////////////////////////////////
1:                     new MD( "registerOutParameter", new Class[] { String.class, int.class } ),
1:                     new MD( "registerOutParameter", new Class[] { String.class, int.class, int.class } ),
1:                     new MD( "registerOutParameter", new Class[] { String.class, int.class, String.class } ),
1:                     new MD( "registerOutParameter", new Class[] { int.class, int.class, String.class } ),
1:                     makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType" }, JDBC.vmSupportsJDBC42() ),
1:                     makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType", "int" }, JDBC.vmSupportsJDBC42() ),
1:                     makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType", "java.lang.String" }, JDBC.vmSupportsJDBC42() ),
/////////////////////////////////////////////////////////////////////////
0:         println( "Supports JDBC 4.2 = " + JDBC. vmSupportsJDBC42() );
1: 
commit:01c7f83
/////////////////////////////////////////////////////////////////////////
1:             // use 1 instead of 0. 0 = java.sql.Types.NULL and this causes
1:             // various type-aware methods to raise SQLFeatureNotSupportedException
0:             return new Integer(1);
commit:c1ecc42
/////////////////////////////////////////////////////////////////////////
1:                         new MD( "setRowId", new Class[] { int.class, RowId.class } ),
/////////////////////////////////////////////////////////////////////////
0:                         makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType" }, true ),
0:                         makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType", "int" }, true ),
0:                         makeMD( "registerOutParameter", new String[] { "java.lang.String", "java.sql.SQLType", "java.lang.String" }, true ),
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // Make an MD if the JVM level supports the indicated classes.
1:     // Returns null if the JVM doesn't.
1:     //
1:     private static  MD  makeMD
1:         ( String methodName, String[] argClassNames, boolean requiredAtThisLevel )
1:     {
1:         // return null if the class names can't be resolved
1:         int     count = argClassNames.length;
1:         Class[] argTypes = new Class[ count ];
1: 
1:         try {
1:             for ( int i = 0; i < count; i++ )
1:             {
1:                 String  className = argClassNames[ i ];
1:                 if ( "int".equals( className ) ) { argTypes[ i ] = int.class; }
1:                 else { argTypes[ i ] = Class.forName( argClassNames[ i ] ); }
1:             }
1:         }
1:         catch (Exception e) { return null; }
1: 
1:         return new MD( methodName, argTypes, requiredAtThisLevel );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                 if ( md == null ) { continue; }
commit:9c8b717
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "getNetworkTimeout", new Class[] { }, JDBC.vmSupportsJDBC41() ),
1: 						new MD( "setNetworkTimeout", new Class[] { java.util.concurrent.Executor.class, int.class }, JDBC.vmSupportsJDBC41() ),
/////////////////////////////////////////////////////////////////////////
1: 					new MD( "getObject", new Class[] { String.class, Class.class }, JDBC.vmSupportsJDBC41() ),
/////////////////////////////////////////////////////////////////////////
0:         assertEquals( "vanishedMethodList", 0, vanishedMethodList.size() );
0:         assertEquals( "unsupportedList", 0, unsupportedList.size() );
0:         assertEquals( "notUnderstoodList", 0, notUnderstoodList.size() );
/////////////////////////////////////////////////////////////////////////
1:                 if ( !md.requiredAtThisLevel() ) { continue; }
1: 
/////////////////////////////////////////////////////////////////////////
1:         private  boolean _requiredAtThisLevel;
1:             this( methodName, argTypes, true );
1: 		}
1: 		public	MD( String methodName, Class[] argTypes, boolean requiredAtThisLevel )
1: 		{
1:             _requiredAtThisLevel = requiredAtThisLevel;
/////////////////////////////////////////////////////////////////////////
1: 		/** Return whether this method is required at the current JDBC level */
1: 		public	boolean	requiredAtThisLevel() { return _requiredAtThisLevel; }
1: 
/////////////////////////////////////////////////////////////////////////
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:3d901b8
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "updateNCharacterStream", new Class[] { int.class, java.io.Reader.class, long.class } ),
1: 						new MD( "updateNCharacterStream", new Class[] { String.class, java.io.Reader.class, long.class } ),
/////////////////////////////////////////////////////////////////////////
1: 		HashSet<String>	vanishedMethodList = new HashSet<String>();
1: 		// Build map of interfaces to their methods which may raise SQLFeatureNotSupportedException.
1: 		initializeExcludableMap( vanishedMethodList );
1: 
/////////////////////////////////////////////////////////////////////////
1: 		printVanishedMethodList( vanishedMethodList );
0: 		int		actualErrorCount =
0: 			vanishedMethodList.size() +
0: 			unsupportedList.size() +
0: 			notUnderstoodList.size();
1: 
0: 			( "Unexpected discrepancies.",
0: 			  0, actualErrorCount );
/////////////////////////////////////////////////////////////////////////
1: 	private	void	initializeExcludableMap( HashSet<String> vanishedMethodList )
/////////////////////////////////////////////////////////////////////////
1: 				Method	method = null;
1: 				try {
1: 					method = iface.getMethod( md.getMethodName(), md.getArgTypes() );
1: 				} catch (NoSuchMethodException e) {}
1: 
1: 				if ( method == null )
1: 				{
1: 					vanishedMethodList.add
1: 						( "Method has vanished from SQL interface: " + iface.getName() + "." + md );
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 			if ( !( e instanceof InvocationTargetException ) )
1: 			{
1: 				recordUnexpectedError( candidate, iface, method, notUnderstoodList, e );
1: 			}
1: 			else
/////////////////////////////////////////////////////////////////////////
1: 					recordUnexpectedError( candidate, iface, method, notUnderstoodList, cause );
/////////////////////////////////////////////////////////////////////////
1: 	// Record an unexpected error.
1: 	//
1: 	private	void	recordUnexpectedError
1: 		( Object candidate, Class iface, Method method,
1: 		  HashSet<String> notUnderstoodList, Throwable cause )
1: 		throws Exception
1: 	{
1: 		notUnderstoodList.add
1: 			( candidate.getClass().getName() + " " + method + " raises " + cause );
1: 	}
1: 	
1: 	//
/////////////////////////////////////////////////////////////////////////
1: 	// debug print the list of methods which have disappeared from the SQL interface
1: 	private	void	printVanishedMethodList( HashSet<String> vanishedMethodList )
1: 	{
1: 		int			count = vanishedMethodList.size();
1: 
1: 		if ( count == 0 ) { return; }
1: 
1: 		println( "--------------- VANISHED METHODS ------------------" );
1: 		println( "--" );
1: 
1: 		String[]	result = new String[ count ];
1: 
1: 		vanishedMethodList.toArray( result );
1: 		Arrays.sort( result );
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			println( result[ i ] );
1: 		}
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 		public	String	toString()
1: 		{
1: 			StringBuffer	buffer = new StringBuffer();
1: 
1: 			buffer.append( _methodName );
1: 			buffer.append( "( " );
1: 
1: 			if ( _argTypes != null )
1: 			{
1: 				int		count = _argTypes.length;
1: 
1: 				for ( int i = 0; i < count; i++ )
1: 				{
1: 					if ( i > 0 ) { buffer.append( ", " ); }
1: 
1: 					buffer.append( _argTypes[ i ].getName() );
1: 				}
1: 			}
1: 
1: 			buffer.append( " )" );
1: 
1: 			return buffer.toString();
1: 		}
1: 
commit:7c3b39d
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "createArrayOf", new Class[] { String.class, Object[].class } ),
commit:7a1db7b
/////////////////////////////////////////////////////////////////////////
1:  * JUnit test which checks that only expected methods throw
1:  * SQLFeatureNotSupporteException. As currently compiled, this class
1:  * does not object to a handful of mandatory LOB-supporting methods which Derby
1:  * does not implement. You can expose these methods by setting
1:  * the STRICT_ENFORCEMENT constant to true.
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
1: 	private	static	final	boolean	STRICT_ENFORCEMENT = false;
/////////////////////////////////////////////////////////////////////////
1: 					//
1: 					// THE FOLLOWING METHODS ARE MANDATORY ACCORDING TO THE
1: 					// JDBC SPEC. HOWEVER, DERBY DOES NOT IMPLEMENT THEM IN ONE
1: 					// OR THE OTHER OF OUR CLIENTS.
1: 					//
1: 					new FD( "getBlob", new Class[] { int.class } ),
1: 					new FD( "getClob", new Class[] { int.class } ),
1: 					
1: 
1: 					//
1: 					// According to the JDBC4 spec and javadoc, the following
1: 					// methods are optional and do not have to be implemented.
1: 					//
1: 					
/////////////////////////////////////////////////////////////////////////
1: 					//
1: 					// THE FOLLOWING METHODS ARE MANDATORY ACCORDING TO THE
1: 					// JDBC SPEC. HOWEVER, DERBY DOES NOT IMPLEMENT THEM IN ONE
1: 					// OR THE OTHER OF OUR CLIENTS.
1: 					//
0: 					new FD( "updateBlob", new Class[] { int.class, Blob.class } ),
0: 					new FD( "updateBlob", new Class[] { String.class, Blob.class } ),
0: 					new FD( "updateClob", new Class[] { int.class, Clob.class } ),
0: 					new FD( "updateClob", new Class[] { String.class, Clob.class } ),
1: 					
1: 
1: 					//
1: 					// According to the JDBC4 spec and javadoc, the following
1: 					// methods are optional and do not have to be implemented.
1: 					//
1: 					
/////////////////////////////////////////////////////////////////////////
1: 
1: 			new Exclusions
1: 			(
1: 			 //
0: 			 // THE FOLLOWING METHODS ARE MANDATORY ACCORDING TO THE
0: 			 // JDBC SPEC. HOWEVER, DERBY DOES NOT IMPLEMENT THEM IN ONE
0: 			 // OR THE OTHER OF OUR CLIENTS.
1: 			 //
0: 			    java.sql.Blob.class,
1: 				new MD[]
1: 				{
0: 					new FD( "getBinaryStream", new Class[] { long.class, long.class } ),
0: 					new FD( "setBinaryStream", new Class[] { long.class } ),
0: 					new FD( "setBytes", new Class[] { long.class, byte[].class } ),
0: 					new FD( "setBytes", new Class[] { long.class, byte[].class, int.class, int.class } ),
0: 					new FD( "truncate", new Class[] { long.class } )
1: 				} ),
1: 			new Exclusions
1: 			(
1: 			 //
0: 			 // THE FOLLOWING METHODS ARE MANDATORY ACCORDING TO THE
0: 			 // JDBC SPEC. HOWEVER, DERBY DOES NOT IMPLEMENT THEM IN ONE
0: 			 // OR THE OTHER OF OUR CLIENTS.
1: 			 //
0: 			    java.sql.Clob.class,
1: 				new MD[]
1: 				{
0: 					new FD( "getCharacterStream", new Class[] { long.class, long.class } ),
0: 					new FD( "setAsciiStream", new Class[] { long.class } ),
0: 					new FD( "setCharacterStream", new Class[] { long.class } ),
0: 					new FD( "setString", new Class[] { long.class, String.class } ),
0: 					new FD( "setString", new Class[] { long.class, String.class, int.class, int.class } ),
0: 					new FD( "truncate", new Class[] { long.class } )
1: 				} )
/////////////////////////////////////////////////////////////////////////
1: 				//
1: 				// If we are strictly enforcing the JDBC standard,
1: 				// then expose the mandatory methods which we know Derby
1: 				// doesn't implement.
1: 				//
1: 				if ( STRICT_ENFORCEMENT && !md.isOptional()  ) { continue; }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Method descriptor for optional methods which Derby does not have
1: 	 * to implement. We abbreviate the name of this class to make
1: 	public	static	class	MD
/////////////////////////////////////////////////////////////////////////
1: 
1: 		/** Return whether this method is optional */
1: 		public	boolean	isOptional() { return true; }
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * Method descriptor for mandatory methods which we know Derby does not
1: 	 * implement. We abbreviate the name of this class to make
1: 	 * arrays of these declarations compact and readable.
1: 	 * </p>
1: 	 */
1: 	public	static	final	class	FD	extends	MD
1: 	{
1: 		private	String	_methodName;
1: 		private	Class[]	_argTypes;
1: 
1: 		/** Construct from methodName and argument types. */
1: 		public	FD( String methodName, Class[] argTypes ) { super( methodName, argTypes ); }
1: 
1: 		/** Return whether this method is optional */
1: 		public	boolean	isOptional() { return false; }
commit:88a2109
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "cancel", new Class[] { } ),
/////////////////////////////////////////////////////////////////////////
1: 					    new MD( "setNull", new Class[] { int.class, int.class, String.class } ),
1: 					    new MD( "setUnicodeStream", new Class[] { int.class, InputStream.class, int.class } ),
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "getUnicodeStream", new Class[] { int.class } ),
1: 						new MD( "getUnicodeStream", new Class[] { String.class } ),
commit:b0551db
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "prepareStatement", new Class[] { String.class, String[].class } ),
1: 						new MD( "setTypeMap", new Class[] { Map.class } ),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					    new MD( "setURL", new Class[] { int.class, URL.class } ),
0: 						new MD( "setNull", new Class[] { int.class, int.class, String.class } )
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 						new MD( "registerOutParameter", new Class[] { int.class, int.class, String.class } ),
/////////////////////////////////////////////////////////////////////////
1: 					boolean	isExcludable = isExcludable( method );
/////////////////////////////////////////////////////////////////////////
1: 	// Returns true if this method is allowed to raise SQLFeatureNotSupportedException.
1: 	private	boolean	isExcludable(Method method )
1: 		throws Exception
1: 		Class				iface = method.getDeclaringClass();
1: 		if ( excludableMethods == null )
1: 		{
1: 			return false;
1: 		}
commit:32f71fe
/////////////////////////////////////////////////////////////////////////
1:  /**
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		    new Exclusions
1: 		    (
1: 				java.sql.Connection.class,
1: 				new MD[]
1: 				{
0: 				    new MD( "createBlob", new Class[] { } ),
0: 						new MD( "createArray", new Class[] { String.class, Object[].class } ),
0: 						new MD( "createClob", new Class[] { } ),
1: 						new MD( "createNClob", new Class[] { } ),
1: 						new MD( "createSQLXML", new Class[] { } ),
1: 						new MD( "createStruct", new Class[] { String.class, Object[].class } ),
1: 						new MD( "getTypeMap", new Class[] { } ),
1: 						new MD( "prepareStatement", new Class[] { String.class, int[].class } ),
0: 						new MD( "prepareStatement", new Class[] { String.class, String[].class } )
1: 						} ),
1: 		    new Exclusions
1: 		    (
1: 				java.sql.Statement.class,
1: 				new MD[]
1: 				{
1: 				    new MD( "execute", new Class[] { String.class, int[].class } ),
1: 						new MD( "execute", new Class[] { String.class, String[].class } ),
1: 						new MD( "executeUpdate", new Class[] { String.class, int[].class } ),
1: 						new MD( "executeUpdate", new Class[] { String.class, String[].class } )
0: 						} )
1: 		    ,
1: 
1: 		    new Exclusions 
1: 			(
1: 				java.sql.PreparedStatement.class,
1: 				new MD[]
1: 				{
1: 					new MD( "setArray", new Class[] { int.class, java.sql.Array.class } ),
0: 						new MD( "setBlob", new Class[] { int.class, java.io.InputStream.class, long.class } ),
0: 						new MD( "setClob", new Class[] { int.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNCharacterStream", new Class[] { int.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNClob", new Class[] { int.class, NClob.class } ),
1: 						new MD( "setNClob", new Class[] { int.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNString", new Class[] { int.class, String.class } ),
1: 						new MD( "setRef", new Class[] { int.class, Ref.class } ),
1: 						new MD( "setRowId", new Class[] { int.class, RowId.class } ),
1: 						new MD( "setSQLXML", new Class[] { int.class, SQLXML.class } ),
0: 						new MD( "setURL", new Class[] { int.class, URL.class } )
1: 						} ),
/////////////////////////////////////////////////////////////////////////
0: 					new MD( "getBlob", new Class[] { int.class } ),
0: 					new MD( "getClob", new Class[] { int.class } ),
1: 					new MD( "getDate", new Class[] { String.class, Calendar.class } ),
/////////////////////////////////////////////////////////////////////////
0: 						new MD( "registerOutParameter", new Class[] { String.class, int.class } ),
0: 						new MD( "registerOutParameter", new Class[] { String.class, int.class, int.class } ),
0: 						new MD( "registerOutParameter", new Class[] { String.class, int.class, String.class } ),
1: 						new MD( "setArray", new Class[] { int.class, java.sql.Array.class } ),
1: 						new MD( "setAsciiStream", new Class[] { String.class, java.io.InputStream.class, int.class } ),
1: 						new MD( "setBigDecimal", new Class[] { String.class, java.math.BigDecimal.class } ),
1: 						new MD( "setBinaryStream", new Class[] { String.class, java.io.InputStream.class, int.class } ),
1: 						new MD( "setBlob", new Class[] { String.class, java.io.InputStream.class, long.class } ),
1: 						new MD( "setBlob", new Class[] { String.class, Blob.class } ),
1: 						new MD( "setBoolean", new Class[] { String.class, boolean.class } ),
1: 						new MD( "setByte", new Class[] { String.class, byte.class } ),
1: 						new MD( "setBytes", new Class[] { String.class, byte[].class } ),
1: 						new MD( "setCharacterStream", new Class[] { String.class, java.io.Reader.class, int.class } ),
1: 						new MD( "setClob", new Class[] { String.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setClob", new Class[] { String.class, Clob.class } ),
1: 						new MD( "setDate", new Class[] { String.class, java.sql.Date.class } ),
1: 						new MD( "setDate", new Class[] { String.class, java.sql.Date.class, Calendar.class } ),
1: 						new MD( "setDouble", new Class[] { String.class, double.class} ),
1: 						new MD( "setFloat", new Class[] { String.class, float.class } ),
1: 						new MD( "setInt", new Class[] { String.class, int.class } ),
1: 						new MD( "setLong", new Class[] { String.class, long.class } ),
1: 						new MD( "setNCharacterStream", new Class[] { int.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNCharacterStream", new Class[] { String.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNClob", new Class[] { int.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNClob", new Class[] { int.class, NClob.class } ),
1: 						new MD( "setNClob", new Class[] { String.class, java.io.Reader.class, long.class } ),
1: 						new MD( "setNClob", new Class[] { String.class, NClob.class } ),
1: 						new MD( "setNString", new Class[] { int.class, String.class } ),
1: 						new MD( "setNString", new Class[] { String.class, String.class } ),
1: 						new MD( "setNull", new Class[] { String.class, int.class } ),
1: 						new MD( "setNull", new Class[] { String.class, int.class, String.class } ),
1: 						new MD( "setObject", new Class[] { String.class, Object.class } ),
1: 						new MD( "setObject", new Class[] { String.class, Object.class, int.class } ),
1: 						new MD( "setObject", new Class[] { String.class, Object.class, int.class, int.class } ),
1: 						new MD( "setRef", new Class[] { int.class, Ref.class } ),
0: 						new MD( "setRowId", new Class[] { int.class, RowId.class } ),
1: 						new MD( "setRowId", new Class[] { String.class, RowId.class } ),
1: 						new MD( "setSQLXML", new Class[] { int.class, SQLXML.class } ),
1: 						new MD( "setSQLXML", new Class[] { String.class, SQLXML.class } ),
1: 						new MD( "setShort", new Class[] { String.class, short.class } ),
1: 						new MD( "setString", new Class[] { String.class, String.class } ),
1: 						new MD( "setTime", new Class[] { String.class, Time.class } ),
1: 						new MD( "setTime", new Class[] { String.class, Time.class, Calendar.class } ),
1: 						new MD( "setTimestamp", new Class[] { String.class, Timestamp.class } ),
1: 						new MD( "setTimestamp", new Class[] { String.class, Timestamp.class, Calendar.class } ),
1: 						new MD( "setURL", new Class[] { int.class, URL.class } ),
1: 						new MD( "setURL", new Class[] { String.class, URL.class } )
0: 		    new Exclusions
0: 		    (
1: 				java.sql.ResultSet.class,
0: 				new MD[]
1: 				{
1: 				    new MD( "getNCharacterStream", new Class[] { int.class } ),
1: 						new MD( "getNCharacterStream", new Class[] { String.class } ),
1: 						new MD( "getNString", new Class[] { int.class } ),
1: 						new MD( "getNString", new Class[] { String.class } ),
1: 						new MD( "getURL", new Class[] { int.class } ),
1: 						new MD( "getURL", new Class[] { String.class } ),
1: 						new MD( "getArray", new Class[] { int.class } ),
1: 						new MD( "getArray", new Class[] { String.class } ),
1: 						new MD( "getNClob", new Class[] { int.class } ),
1: 						new MD( "getNClob", new Class[] { String.class } ),
1: 						new MD( "getRef", new Class[] { int.class } ),
1: 						new MD( "getRef", new Class[] { String.class } ),
1: 						new MD( "getRowId", new Class[] { int.class } ),
1: 						new MD( "getRowId", new Class[] { String.class } ),
1: 						new MD( "getSQLXML", new Class[] { int.class } ),
1: 						new MD( "getSQLXML", new Class[] { String.class } ),
1: 						new MD( "refreshRow", new Class[] { } ),
1: 						new MD( "updateArray", new Class[] { int.class, java.sql.Array.class } ),
1: 						new MD( "updateArray", new Class[] { String.class, java.sql.Array.class } ),
0: 						new MD( "updateNCharacterStream", new Class[] { int.class, java.io.Reader.class, int.class } ),
0: 						new MD( "updateNCharacterStream", new Class[] { String.class, java.io.Reader.class, int.class } ),
1: 						new MD( "updateNClob", new Class[] { int.class, NClob.class } ),
1: 						new MD( "updateNClob", new Class[] { String.class, NClob.class } ),
1: 						new MD( "updateNString", new Class[] { int.class, String.class } ),
1: 						new MD( "updateNString", new Class[] { String.class, String.class } ),
1: 						new MD( "updateRef", new Class[] { int.class, Ref.class } ),
1: 						new MD( "updateRef", new Class[] { String.class, Ref.class } ),
1: 						new MD( "updateRowId", new Class[] { int.class, RowId.class } ),
1: 						new MD( "updateRowId", new Class[] { String.class, RowId.class } ),
1: 						new MD( "updateSQLXML", new Class[] { int.class, SQLXML.class } ),
1: 						new MD( "updateSQLXML", new Class[] { String.class, SQLXML.class } )
0: 						} ),
1: 			//
1: 			// Lance Andersen, spec lead for JDBC4, says:
1: 			// If you support a datatype, then you have to implement
1: 			// all of its methods.
1: 			//
0: 			//		    new Exclusions
0: 			//		    (
0: 			//				java.sql.Blob.class,
0: 			//				new MD[]
0: 			//				{
0: 			//				    new MD( "getBinaryStream", new Class[] { long.class, long.class } ),
0: 			//						new MD( "setBinaryStream", new Class[] { long.class } ),
0: 			//						new MD( "setBytes", new Class[] { long.class, byte[].class } ),
0: 			//						new MD( "setBytes", new Class[] { long.class, byte[].class, int.class, int.class } ),
0: 			//						new MD( "truncate", new Class[] { long.class } )
0: 			//						} ),
0: 			//		    new Exclusions
0: 			//		    (
0: 			//				java.sql.Clob.class,
0: 			//				new MD[]
0: 			//				{
0: 			//				    new MD( "getCharacterStream", new Class[] { long.class, long.class } ),
0: 			//						new MD( "setAsciiStream", new Class[] { long.class } ),
0: 			//						new MD( "setCharacterStream", new Class[] { long.class } ),
0: 			//						new MD( "setString", new Class[] { long.class, String.class } ),
0: 			//						new MD( "setString", new Class[] { long.class, String.class, int.class, int.class } ),
0: 			//						new MD( "truncate", new Class[] { long.class } )
0: 			//						} )
/////////////////////////////////////////////////////////////////////////
1: 					    StackTraceElement[] stack = 
1: 						cause.getStackTrace();
1: 						int i = 0;
1: 						while(i < stack.length && !stack[i].getMethodName().
1: 							  equals("notImplemented")){
1: 								++i;
1: 							}
1: 							while(i < stack.length && stack[i].getMethodName().
1: 								  equals("notImplemented")){
1: 								++i;
1: 							}
1: 							if (i == stack.length) {
1: 								//cause.printStackTrace();
1: 							}
1: 				     
1: 							unsupportedList.add( candidate.getClass().getName() + ": " + method + "@" + (i==stack.length?"no source":cause.getStackTrace()[i]));
1: 					} else {
1: 
commit:d04e05e
/////////////////////////////////////////////////////////////////////////
1: /**
/////////////////////////////////////////////////////////////////////////
1: 		//
1: 		// The vetObject() method calls all of the methods in these objects
1: 		// in a deterministic order, calling the close() method last.
1: 		// Inspect these objects in an order which respects the fact that
1: 		// the objects are closed as a result of calling vetObject().
1: 		//
1: 		vetObject( cs, unsupportedList, notUnderstoodList );
1: 		vetObject( rsmd, unsupportedList, notUnderstoodList );
1: 		vetObject( rs, unsupportedList, notUnderstoodList );
1: 		vetObject( parameterMetaData, unsupportedList, notUnderstoodList );
1: 		vetObject( ps, unsupportedList, notUnderstoodList );
1: 		vetObject( conn, unsupportedList, notUnderstoodList );
1: 		// No need to close the objects. They were closed by vetObject().
/////////////////////////////////////////////////////////////////////////
1: 		//
1: 		// The contract for Class.getInterfaces() states that the interfaces
1: 		// come back in a deterministic order, namely, in the order that
1: 		// they were declared in the "extends" clause.
1: 		//
/////////////////////////////////////////////////////////////////////////
1: 		Method[]	methods = sortMethods( iface );
/////////////////////////////////////////////////////////////////////////
1: 	// Return the methods of an interface in a deterministic
1: 	// order. Class.getMethods() does not do us this favor.
1: 	//
1: 	private	Method[]	sortMethods( Class iface )
1: 		throws Exception
1: 	{
1: 		Method[]			raw = iface.getMethods();
1: 		int					count = raw.length;
1: 		Method[]			cooked = new Method[ count ];
1: 		MethodSortable[]	sortables = new MethodSortable[ count ];
1: 
1: 		for ( int i = 0; i < count; i++ ) { sortables[ i ] = new MethodSortable( raw[ i ] ); }
1: 
1: 		Arrays.sort( sortables );
1: 
1: 		for ( int i = 0; i < count; i++ ) { cooked[ i ] = sortables[ i ].getMethod(); }
1: 
1: 		return cooked;
1: 	}
1: 
1: 	//
/////////////////////////////////////////////////////////////////////////
1: 		int			count = unsupportedList.size();
1: 
1: 		if ( count == 0 ) { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		int			count = notUnderstoodList.size();
1: 
1: 		if ( count == 0 ) { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * <p>
1: 	 * Used for sorting methods, which don't come back from Class.getMethods()
1: 	 * in a deterministic order. For extra credit, we put the close() method at
1: 	 * the end of the sort order so that, when we invoke the sorted methods, we
1: 	 * don't accidentally invalidate the receiver.
1: 	 * </p>
1: 	 */
1: 	public	static	final	class	MethodSortable	implements	Comparable
1: 	{
1: 		private	Method	_method;
1: 
1: 		/** Conjure out of a Method */
1: 		public	MethodSortable( Method method ) { _method = method; }
1: 
1: 		/** Get the wrapped Method */
1: 		public	Method	getMethod() { return _method; }
1: 
1: 		//////////////////////////////////////////////////
1: 		//
1: 		//	Comparable BEHAVIOR
1: 		//
1: 		//////////////////////////////////////////////////
1: 
1: 		public	int	compareTo( Object other )
1: 		{
1: 			MethodSortable	that = (MethodSortable) other;
1: 			boolean			thisIsClose = this.isCloseMethod();
1: 			boolean			thatIsClose = that.isCloseMethod();
1: 
1: 			// throw the close() method to the end of the sort order
1: 			if ( thisIsClose )
1: 			{
1: 				if ( thatIsClose ) { return 0; }
1: 				else { return 1; }
1: 			}
1: 			else if ( thatIsClose ) { return -1; }
1: 
1: 			return this.toString().compareTo( that.toString() );
1: 		}
1: 
1: 		//////////////////////////////////////////////////
1: 		//
1: 		//	Object OVERRIDES
1: 		//
1: 		//////////////////////////////////////////////////
1: 
1: 		public	String	toString() { return _method.toString(); }
1: 		
1: 		//////////////////////////////////////////////////
1: 		//
1: 		//	MINIONS
1: 		//
1: 		//////////////////////////////////////////////////
1: 
1: 		// Returns true if the wrapped method is close().
1: 		private	boolean	isCloseMethod()
1: 		{
1: 			return ( toString().startsWith( "close()" ) );
1: 		}
1: 		
1: 	}
commit:4a47eda
/////////////////////////////////////////////////////////////////////////
0: /*
1:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbc4.UnsupportedVetter
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its licensors, as
0:  * applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you
0:  * may not use this file except in compliance with the License. You
0:  * may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
0:  * implied. See the License for the specific language governing
0:  * permissions and limitations under the License.
1:  *
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.sql.*;
1: import javax.sql.*;
1: 
1: import java.lang.reflect.*;
1: import java.util.*;
1: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
1: 
1: /**
0:  * JUnit test which checks that only expected methods throw SQLFeatureNotSupporteException.
1:  */
1: public class UnsupportedVetter	extends BaseJDBCTestCase
1: {
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTANTS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	public	static	final	String	SQL_PACKAGE_NAME = "java.sql";
1: 	
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	//
1: 	// Table of methods which are allowed to raise
1: 	// SQLFeatureNotSupportedException. Derived from the 1.6 Javadoc.
1: 	//
1: 	private	static	Exclusions[]	rawExcludables = new Exclusions[]
1: 		{
0: 			new Exclusions
0: 			(
1: 			    java.sql.CallableStatement.class,
0: 				new MD[]
1: 				{
1: 					new MD( "getArray", new Class[] { int.class } ),
1: 					new MD( "getArray", new Class[] { String.class } ),
1: 					new MD( "getBigDecimal", new Class[] { String.class } ),
1: 					new MD( "getBoolean", new Class[] { String.class } ),
1: 					new MD( "getBlob", new Class[] { String.class } ),
1: 					new MD( "getBoolean", new Class[] { String.class } ),
1: 					new MD( "getByte", new Class[] { String.class } ),
1: 					new MD( "getBytes", new Class[] { String.class } ),
1: 					new MD( "getCharacterStream", new Class[] { String.class } ),
1: 					new MD( "getClob", new Class[] { String.class } ),
1: 					new MD( "getDate", new Class[] { String.class } ),
1: 					new MD( "getDouble", new Class[] { String.class } ),
1: 					new MD( "getFloat", new Class[] { String.class } ),
1: 					new MD( "getInt", new Class[] { String.class } ),
1: 					new MD( "getLong", new Class[] { String.class } ),
1: 					new MD( "getNCharacterStream", new Class[] { int.class } ),
1: 					new MD( "getNCharacterStream", new Class[] { String.class } ),
1: 					new MD( "getNClob", new Class[] { int.class } ),
1: 					new MD( "getNClob", new Class[] { String.class } ),
1: 					new MD( "getNString", new Class[] { int.class } ),
1: 					new MD( "getNString", new Class[] { String.class } ),
1: 					new MD( "getObject", new Class[] { String.class } ),
1: 					new MD( "getRef", new Class[] { int.class } ),
1: 					new MD( "getRef", new Class[] { String.class } ),
1: 					new MD( "getRowId", new Class[] { int.class } ),
1: 					new MD( "getRowId", new Class[] { String.class } ),
1: 					new MD( "getShort", new Class[] { String.class } ),
1: 					new MD( "getSQLXML", new Class[] { int.class } ),
1: 					new MD( "getSQLXML", new Class[] { String.class } ),
1: 					new MD( "getString", new Class[] { String.class } ),
1: 					new MD( "getTime", new Class[] { String.class } ),
1: 					new MD( "getTime", new Class[] { String.class, java.util.Calendar.class } ),
1: 					new MD( "getTimestamp", new Class[] { String.class } ),
1: 					new MD( "getTimestamp", new Class[] { String.class, java.util.Calendar.class } ),
1: 					new MD( "getURL", new Class[] { int.class } ),
1: 					new MD( "getURL", new Class[] { String.class } ),
1: 				}
1: 			),
1: 
1: 
1: 		};
1: 
1: 	//
1: 	// This is the Hashtable where we keep the exclusions.
1: 	//
1: 	private	static	Hashtable< Class, HashSet<Method> >	excludableMap;
1: 	
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTOR
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Creates a new instance.
1:      */
1:     public UnsupportedVetter() { super("UnsupportedVetter"); }
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	ENTRY POINTS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * <p>
1: 	 * Find all methods in this framework which raise SQLFeatureNotSupportedException.
1: 	 * </p>
1: 	 */
1: 	public	void	testSupportedMethods()
1: 		throws Exception
1: 	{
0: 		CONFIG.setVerbosity( true );
1: 
0: 		// Build map of interfaces to their methods which may raise SQLFeatureNotSupportedException.
0: 		initializeExcludableMap();
1: 
1: 		HashSet<String>	unsupportedList = new HashSet<String>();
1: 		HashSet<String>	notUnderstoodList = new HashSet<String>();
1: 
1: 		vetDataSource( unsupportedList, notUnderstoodList );
1: 		vetConnectionPooledDataSource( unsupportedList, notUnderstoodList );
1: 		vetXADataSource( unsupportedList, notUnderstoodList );
1: 
1: 		//
1: 		// Print methods which behave unexpectedly.
1: 		//
1: 		printUnsupportedList( unsupportedList );
1: 		printNotUnderstoodList( notUnderstoodList );
1: 
0: 		assertEquals
0: 			( "These methods should not raise SQLFeatureNotSupportedException.",
0: 			  0, unsupportedList.size() );
0: 		assertEquals
0: 			( "These methods raise exceptions we don't understand.",
0: 			  0, notUnderstoodList.size() );
1: 	}
1: 
1: 	//
1: 	// Find all the objects inside the DataSource and vet them.
1: 	//
1: 	private	void	vetDataSource
1: 		( HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
0: 		DataSource			ds = getDataSource();
1: 		Connection			conn = ds.getConnection();
1: 
1: 		vetObject( ds, unsupportedList, notUnderstoodList );
1: 
1: 		connectionWorkhorse( conn, unsupportedList, notUnderstoodList );
1: 	}
1: 
1: 	//
1: 	// Find all the objects inside the ConnectionPooledDataSource and vet them.
1: 	//
1: 	private	void	vetConnectionPooledDataSource
1: 		( HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
0: 		ConnectionPoolDataSource	ds = getConnectionPoolDataSource();
1: 		PooledConnection			pc = ds.getPooledConnection
0: 			(CONFIG.getUserName(), CONFIG.getUserPassword());
1: 		Connection					conn = pc.getConnection();
1: 
1: 		vetObject( ds, unsupportedList, notUnderstoodList );
1: 		vetObject( pc, unsupportedList, notUnderstoodList );
1: 
1: 		connectionWorkhorse( conn, unsupportedList, notUnderstoodList );
1: 	}
1: 
1: 	//
1: 	// Find all the objects inside the XADataSource and vet them.
1: 	//
1: 	private	void	vetXADataSource
1: 		( HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
0: 		XADataSource				ds = getXADataSource();
1: 		XAConnection				xaconn = ds.getXAConnection
0: 			(CONFIG.getUserName(), CONFIG.getUserPassword());
1: 		Connection					conn = xaconn.getConnection();
1: 
1: 		vetObject( ds, unsupportedList, notUnderstoodList );
1: 		vetObject( xaconn, unsupportedList, notUnderstoodList );
1: 
1: 		connectionWorkhorse( conn, unsupportedList, notUnderstoodList );
1: 	}
1: 
1: 	//
1: 	// Find all the methods for java.sql objects in the Connection which raise
1: 	// SQLFeatureNotSupportedException.
1: 	//
1: 	private	void	connectionWorkhorse
1: 		( Connection conn, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList  )
1: 		throws Exception
1: 	{
1: 		vetSavepoint( conn, unsupportedList, notUnderstoodList );
1: 		vetLargeObjects( conn, unsupportedList, notUnderstoodList );
1: 		
1: 		DatabaseMetaData	dbmd = conn.getMetaData();
1: 		PreparedStatement	ps = conn.prepareStatement
1: 			( "select * from sys.systables where tablename = ?" );
1: 
1: 		ps.setString( 1, "foo" );
1: 
1: 		ParameterMetaData	parameterMetaData = ps.getParameterMetaData();
1: 		ResultSet			rs = ps.executeQuery();
1: 		ResultSetMetaData	rsmd = rs.getMetaData();
1:         Statement			stmt = conn.createStatement();
1: 
1:         CallableStatement	cs =
1:             conn.prepareCall("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:         ParameterMetaData	csmd = cs.getParameterMetaData();
1: 
0: 		vetObject( conn, unsupportedList, notUnderstoodList );
1: 		vetObject( dbmd, unsupportedList, notUnderstoodList );
0: 		vetObject( ps, unsupportedList, notUnderstoodList );
0: 		vetObject( parameterMetaData, unsupportedList, notUnderstoodList );
0: 		vetObject( rs, unsupportedList, notUnderstoodList );
0: 		vetObject( rsmd, unsupportedList, notUnderstoodList );
1: 		vetObject( stmt, unsupportedList, notUnderstoodList );
0: 		vetObject( cs, unsupportedList, notUnderstoodList );
1: 		vetObject( csmd, unsupportedList, notUnderstoodList );
1: 
0:         cs.close();
1:         stmt.close();
0: 		rs.close();
0: 		ps.close();
0: 		// conn.close();
1: 	}
1: 	
1: 	//
1: 	// Examine Savepoints.
1: 	//
1: 	private	void	vetSavepoint
1: 		( Connection conn, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList  )
1: 		throws Exception
1: 	{
1:         conn.setAutoCommit( false );
1: 
1:         Savepoint			sp = conn.setSavepoint();
1: 		
1: 		vetObject( sp, unsupportedList, notUnderstoodList );
1: 		
1:         conn.releaseSavepoint(sp);
1: 	}
1: 
1: 	//
1: 	// Examine BLOBs and CLOBs.
1: 	//
1: 	private	void	vetLargeObjects
1: 		( Connection conn, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList  )
1: 		throws Exception
1: 	{
1:         Statement		stmt = conn.createStatement();
1: 
1:         stmt.execute("CREATE TABLE t (id INT PRIMARY KEY, " +
1:                      "b BLOB(10), c CLOB(10))");
1:         stmt.execute("INSERT INTO t (id, b, c) VALUES (1, "+
1:                      "CAST (" + TestUtil.stringToHexLiteral("101010001101") +
1:                      "AS BLOB(10)), CAST ('hello' AS CLOB(10)))");
1: 
1:         ResultSet rs = stmt.executeQuery("SELECT id, b, c FROM t");
1: 
1:         rs.next();
1: 
1:         Blob		blob = rs.getBlob(2);
1:         Clob		clob = rs.getClob(3);
1: 
1: 		vetObject( blob, unsupportedList, notUnderstoodList );
1: 		vetObject( clob, unsupportedList, notUnderstoodList );
1: 
1:         stmt.close();
1:         conn.rollback();
1: 	}
1: 
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	MINIONS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	//
1: 	// Initialize the hashtable of methods which are allowed to raise
1: 	// SQLFeatureNotSupportedException.
1: 	//
0: 	private	void	initializeExcludableMap()
1: 		throws Exception
1: 	{
1: 		excludableMap = new Hashtable< Class, HashSet<Method> >();
1: 		
1: 		int		count = rawExcludables.length;
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			Exclusions		exclusions = rawExcludables[ i ];
0: 			Class			iface = exclusions.getInterface();
1: 			MD[]			mds = exclusions.getExcludedMethods();
1: 			int				exclusionCount = mds.length;
1: 			HashSet<Method>	excludedMethodSet = new HashSet<Method>();
1: 
1: 			for ( int j = 0; j < exclusionCount; j++ )
1: 			{
1: 				MD		md = mds[ j ];
1: 
0: 				Method	method = iface.getMethod( md.getMethodName(), md.getArgTypes() );
1: 
0: 				if ( method == null ) { fail( "Unknown method: " + md.getMethodName() ); }
1: 
1: 				excludedMethodSet.add( method );
1: 			}
1: 
1: 			excludableMap.put( iface, excludedMethodSet );
1: 		}
1: 	}
1: 
1: 	//
1: 	// Find all the methods from java.sql interfaces which are implemented by an object
1: 	// and which raise SQLFeatureNotSupportedException.
1: 	//
1: 	private	void	vetObject
1: 		( Object candidate, HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
1: 		Class		myClass = candidate.getClass();
1: 
1: 		vetInterfaces( candidate, myClass, unsupportedList, notUnderstoodList );
1: 	}
1: 
1: 	//
1: 	// Find all the java.sql interfaces implemented by a class and find
1: 	// the methods in those interfaces which raise
1: 	// SQLFeatureNotSupportedException when called on the passed-in candidate object.
1: 	//
1: 	private	void	vetInterfaces
1: 		( Object candidate, Class myClass,
1: 		  HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
1: 		Class		superClass = myClass.getSuperclass();
1: 
1: 		if ( superClass != null )
1: 		{ vetInterfaces( candidate, superClass, unsupportedList, notUnderstoodList ); }
1: 
1: 		Class<?>[]	interfaces = myClass.getInterfaces();
1: 		int			interfaceCount = interfaces.length;
1: 
1: 		for ( int i = 0; i < interfaceCount; i++ )
1: 		{
1: 			Class<?>	iface = interfaces[ i ];
1: 
1: 			if ( iface.getPackage().getName().equals( SQL_PACKAGE_NAME ) )
1: 			{
1: 				vetInterfaceMethods( candidate, iface, unsupportedList, notUnderstoodList );
1: 			}
1: 
1: 			vetInterfaces( candidate, iface, unsupportedList, notUnderstoodList );
1: 		}
1: 	}
1: 
1: 	//
1: 	// Examine all the methods in an interface to determine which ones
1: 	// raise SQLFeatureNotSupportedException.
1: 	//
1: 	private	void	vetInterfaceMethods
1: 		( Object candidate, Class iface,
1: 		  HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
0: 		Method[]	methods = iface.getMethods();
1: 		int			methodCount = methods.length;
1: 
1: 		for ( int i = 0; i < methodCount; i++ )
1: 		{
1: 			Method	method = methods[ i ];
1: 
1: 			vetMethod( candidate, iface, method, unsupportedList, notUnderstoodList );
1: 		}
1: 	}
1: 
1: 	//
1: 	// Examine a single method to see if it raises SQLFeatureNotSupportedException.
1: 	//
1: 	private	void	vetMethod
1: 		( Object candidate, Class iface, Method method,
1: 		  HashSet<String> unsupportedList, HashSet<String> notUnderstoodList )
1: 		throws Exception
1: 	{
1: 		try {
1: 			method.invoke( candidate, getNullArguments( method.getParameterTypes() ) );
1: 
1: 			// it's ok for the method to succeed
1: 		}
1: 		catch (Throwable e)
1: 		{
0: 			if ( e instanceof InvocationTargetException )
1: 			{
1: 				Throwable	cause = e.getCause();
1: 				
1: 				if ( cause instanceof SQLFeatureNotSupportedException )
1: 				{
0: 					boolean	isExcludable = isExcludable( iface, method );
1: 
1: 					if ( !isExcludable )
1: 					{
0: 						unsupportedList.add( candidate.getClass().getName() + ": " + method );
1: 					}
1: 				}
1: 				else if ( cause instanceof SQLException )
1: 				{
1: 					// swallow other SQLExceptions, caused by bogus args
1: 				}
1: 				else if ( cause instanceof NullPointerException )
1: 				{
1: 					// swallow other NPEs, caused by bogus args
1: 				}
1: 				else if ( cause instanceof ArrayIndexOutOfBoundsException )
1: 				{
1: 					// swallow these, caused by bogus args
1: 				}
1: 				else
1: 				{
0: 					notUnderstoodList.add
0: 						( candidate.getClass().getName() + " " + method + " raises " + cause );
1: 				}
1: 				
1: 			}
1: 		}
1: 	}
1: 
1: 	//
0: 	// Returns true if this method of this class is allowed to raise SQLFeatureNotSupportedException.
1: 	//
0: 	private	boolean	isExcludable( Class iface, Method method )
1: 	{
1: 		HashSet<Method>		excludableMethods = excludableMap.get( iface );
1: 
0: 		if ( excludableMethods == null ) { return false; }
1: 
1: 		return excludableMethods.contains( method );
1: 	}
1: 	
1:     /**
1:      * Takes an array of classes and returns an array of objects with
1:      * null values compatible with the classes. Helper method for
1:      * converting a parameter list to an argument list.
1:      *
1:      * @param params a <code>Class[]</code> value
1:      * @return an <code>Object[]</code> value
1:      */
1:     private Object[] getNullArguments(Class[] params) {
1:         Object[] args = new Object[params.length];
1:         for (int i = 0; i < params.length; i++) {
1:             args[i] = getNullValueForType(params[i]);
1:         }
1:         return args;
1:     }
1: 
1:     /**
1:      * Returns a null value compatible with the class. For instance,
1:      * return <code>Boolean.FALSE</code> for primitive booleans, 0 for
1:      * primitive integers and <code>null</code> for non-primitive
1:      * types.
1:      *
1:      * @param type a <code>Class</code> value
1:      * @return a null value
1:      */
1:     private Object getNullValueForType(Class type)
1: 	{
1:         if (!type.isPrimitive()) {
1:             return null;
1:         }
1:         if (type == Boolean.TYPE) {
1:             return Boolean.FALSE;
1:         }
1:         if (type == Character.TYPE) {
0:             return new Character((char) 0);
1:         }
1:         if (type == Byte.TYPE) {
0:             return new Byte((byte) 0);
1:         }
1:         if (type == Short.TYPE) {
0:             return new Short((short) 0);
1:         }
1:         if (type == Integer.TYPE) {
0:             return new Integer(0);
1:         }
1:         if (type == Long.TYPE) {
0:             return new Long(0L);
1:         }
1:         if (type == Float.TYPE) {
0:             return new Float(0f);
1:         }
1:         if (type == Double.TYPE) {
0:             return new Double(0d);
1:         }
1:         fail("Don't know how to handle type " + type);
1:         return null;            // unreachable statement
1:     }
1: 
1: 	// debug print the list of methods which throw SQLFeatureNotSupportedException
1: 	private	void	printUnsupportedList( HashSet<String> unsupportedList )
1: 	{
1: 		println( "--------------- UNSUPPORTED METHODS ------------------" );
1: 		println( "--" );
1: 
0: 		int			count = unsupportedList.size();
1: 		String[]	result = new String[ count ];
1: 
1: 		unsupportedList.toArray( result );
1: 		Arrays.sort( result );
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			println( result[ i ] );
1: 		}
1: 	}
1: 
1: 	// Debug print the list of method failures which we don't understand
1: 	private	void	printNotUnderstoodList( HashSet<String> notUnderstoodList )
1: 	{
1: 		println( "\n\n" );
1: 		println( "--------------- NOT UNDERSTOOD METHODS ------------------" );
1: 		println( "--" );
1: 
0: 		int			count = notUnderstoodList.size();
1: 		String[]	result = new String[ count ];
1: 
1: 		notUnderstoodList.toArray( result );
1: 		Arrays.sort( result );
1: 
1: 		for ( int i = 0; i < count; i++ )
1: 		{
1: 			println( result[ i ] );
1: 		}
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//
1: 	//	INNER CLASSES
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * <p>
0: 	 * Method descriptor. We abbreviate the name of this class to make
1: 	 * arrays of these declarations compact and readable.
1: 	 * </p>
1: 	 */
0: 	public	static	final	class	MD
1: 	{
1: 		private	String	_methodName;
1: 		private	Class[]	_argTypes;
1: 
1: 		/** Construct from methodName and argument types. */
1: 		public	MD( String methodName, Class[] argTypes )
1: 		{
1: 			_methodName = methodName;
1: 			_argTypes = argTypes;
1: 		}
1: 
1: 		/** Get the name of this method. */
1: 		public	String	getMethodName() { return _methodName; }
1: 
1: 		/** Get the types of the method's arguments */
1: 		public	Class[]	getArgTypes() { return _argTypes; }
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * Describes all of the methods for an interface which are allowed
1: 	 * to raise SQLFeatureNotSupportedException.
1: 	 * </p>
1: 	 */
1: 	public	static	final	class	Exclusions
1: 	{
1: 		private	Class	_class;
1: 		private	MD[]	_excludedMethods;
1: 
1: 		/** Construct from the interface and descriptors for the methods which
1: 		 are allowed to raise SQLFeatureNotSupportedException */
1: 		public	Exclusions( Class theInterface, MD[] excludedMethods )
1: 		{
1: 			_class = theInterface;
1: 			_excludedMethods = excludedMethods;
1: 		}
1: 		
1: 		/** Get the interface. */
1: 		public	Class	getInterface() { return _class; }
1: 
1: 		/** Get descriptors for the methods which may raise
1: 			SQLFeatureNotSupportedException. */
1: 		public	MD[]	getExcludedMethods() { return _excludedMethods; }
1: 	}
1: 	
1: }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:dd7903b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:         if (JDBC.vmSupportsJDBC41()) {
0:             // DERBY-4869: The runtime environment supports JDBC 4.1, but
0:             // our database drivers don't yet. Disable this test until the
0:             // drivers have been updated.
0:             return new TestSuite("UnsupportedVetter - Disabled");
1:         }
commit:0f26c83
/////////////////////////////////////////////////////////////////////////
1: 			Class<?>		iface = exclusions.getInterface();
commit:e193cf8
/////////////////////////////////////////////////////////////////////////
0: 
1:     private boolean savedVerbosity;
0: 
1:     protected void setUp() {
1:         // testSupportedMethods() sets the verbosity, so we need to save the
1:         // original verbosity here and restore it in tearDown.
1:         savedVerbosity = getTestConfiguration().isVerbose();
1:     }
0: 
1:     protected void tearDown() throws Exception {
1:         getTestConfiguration().setVerbosity(savedVerbosity);
1:         super.tearDown();
1:     }
0: 
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     public static Test suite() {
0:         // This test will fail in client/server mode until DERBY-2047 is fixed.
0:         //return TestConfiguration.defaultSuite(UnsupportedVetter.class);
0:         return new TestSuite(UnsupportedVetter.class, "UnsupportedVetter");
0:     }
commit:c586481
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "setNCharacterStream", new Class[] { int.class, java.io.Reader.class } ),
1: 						new MD( "setNClob", new Class[] { int.class, java.io.Reader.class } ),
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "setAsciiStream", new Class[] { String.class, java.io.InputStream.class } ),
1: 						new MD( "setBinaryStream", new Class[] { String.class, java.io.InputStream.class } ),
1: 						new MD( "setBlob", new Class[] { String.class, java.io.InputStream.class } ),
1: 						new MD( "setCharacterStream", new Class[] { String.class, java.io.Reader.class } ),
1: 						new MD( "setClob", new Class[] { String.class, java.io.Reader.class } ),
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "setNCharacterStream", new Class[] { String.class, java.io.Reader.class } ),
1: 						new MD( "setNClob", new Class[] { String.class, java.io.Reader.class } ),
/////////////////////////////////////////////////////////////////////////
1: 						new MD( "updateNCharacterStream", new Class[] { int.class, java.io.Reader.class } ),
1: 						new MD( "updateNCharacterStream", new Class[] { String.class, java.io.Reader.class } ),
1: 						new MD( "updateNClob", new Class[] { int.class, Reader.class } ),
1: 						new MD( "updateNClob", new Class[] { String.class, Reader.class } ),
commit:c511410
/////////////////////////////////////////////////////////////////////////
1:                                                 new MD( "setAsciiStream", new Class[] { String.class, java.io.InputStream.class, long.class } ),
1:                                                 new MD( "setBinaryStream", new Class[] { String.class, java.io.InputStream.class, long.class } ),
1:                                                 new MD( "setCharacterStream", new Class[] { String.class, java.io.Reader.class, long.class } ),
/////////////////////////////////////////////////////////////////////////
0:                                         new FD( "updateBlob", new Class[] { int.class, InputStream.class ,long.class } ),
0:                                         new FD( "updateBlob", new Class[] { String.class, InputStream.class ,long.class } ),
0:                                         new FD( "updateClob", new Class[] { int.class, Reader.class ,long.class } ),
0:                                         new FD( "updateClob", new Class[] { String.class, Reader.class ,long.class } ),
1:                                         new FD( "updateNClob",new Class[] { int.class,Reader.class,long.class}),
1:                                         new FD( "updateNClob",new Class[] { String.class,Reader.class,long.class}),
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestDataSourceFactory;
/////////////////////////////////////////////////////////////////////////
0: 		DataSource			ds = TestDataSourceFactory.getDataSource();
/////////////////////////////////////////////////////////////////////////
0: 		ConnectionPoolDataSource	ds = TestDataSourceFactory.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
0: 		XADataSource				ds = TestDataSourceFactory.getXADataSource();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:adf7016
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8ed08b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1: 		DataSource			ds = JDBCDataSource.getDataSource();
/////////////////////////////////////////////////////////////////////////
1: 		ConnectionPoolDataSource	ds = J2EEDataSource.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
1: 		XADataSource				ds = J2EEDataSource.getXADataSource();
/////////////////////////////////////////////////////////////////////////
1:         return TestConfiguration.defaultSuite(UnsupportedVetter.class);
commit:e0104e8
/////////////////////////////////////////////////////////////////////////
0:         getTestConfiguration().setVerbosity( true );
/////////////////////////////////////////////////////////////////////////
1: 			(getTestConfiguration().getUserName(),
1:                     getTestConfiguration().getUserPassword());
/////////////////////////////////////////////////////////////////////////
1: 			(getTestConfiguration().getUserName(),
1:                     getTestConfiguration().getUserPassword());
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
============================================================================