1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.VTIResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
17:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:f432362: import org.apache.derby.catalog.TypeDescriptor;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:d868eed: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:d868eed: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:a2d0847: import org.apache.derby.iapi.sql.ParameterValueSet; 
1:f432362: import org.apache.derby.iapi.types.TypeId;
1:f432362: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:f432362: import org.apache.derby.iapi.types.VariableSizeDataValue;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:38f02ec: import org.apache.derby.iapi.transaction.TransactionControl;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableHashtable;
1:eac0369: 
1:eac0369: import org.apache.derby.vti.DeferModification;
1:eac0369: import org.apache.derby.vti.IFastPath;
1:eac0369: import org.apache.derby.vti.VTIEnvironment;
1:29007f0: import org.apache.derby.vti.AwareVTI;
1:a2d0847: import org.apache.derby.vti.RestrictedVTI;
1:a2d0847: import org.apache.derby.vti.Restriction;
1:29007f0: import org.apache.derby.vti.VTIContext;
1:eac0369: 
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:fe1ac60: import java.sql.SQLWarning;
1:eac0369: import java.sql.ResultSetMetaData;
1:a56ecfa: import org.w3c.dom.Element;
1:eac0369: 
3:eac0369: /**
1:eac0369:  */
1:f77f36d: class VTIResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet, VTIEnvironment {
1:eac0369: 
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public int rowsReturned;
1:eac0369: 	public String javaClassName;
1:eac0369: 
1:eac0369:     private GeneratedMethod constructor;
1:eac0369: 	private PreparedStatement userPS;
1:eac0369: 	private ResultSet userVTI;
1:d868eed: 	private final ExecRow allocatedRow;
1:eac0369: 	private FormatableBitSet referencedColumns;
1:eac0369: 	private boolean version2;
1:eac0369: 	private boolean reuseablePs;
1:eac0369: 	private boolean isTarget;
1:554386c:     private final FormatableHashtable compileTimeConstants;
1:eac0369: 
1:eac0369: 	private boolean pushedProjection;
1:eac0369: 	private IFastPath	fastPath;
1:eac0369: 
1:eac0369: 	private Qualifier[][]	pushedQualifiers;
1:eac0369: 
1:eac0369: 	private boolean[] runtimeNullableColumn;
1:eac0369: 
1:4aef9b0: 	private boolean isDerbyStyleTableFunction;
1:f432362: 
1:47e1295:     private final TypeDescriptor returnType;
1:4aef9b0: 
1:f432362:     private DataTypeDescriptor[]    returnColumnTypes;
1:f432362: 
1:a2d0847:     private String[] vtiProjection;
1:a2d0847:     private Restriction vtiRestriction;
1:a2d0847: 
1:29007f0:     private String  vtiSchema;
1:29007f0:     private String  vtiName;
1:29007f0: 
1:eac0369: 	/**
1:eac0369: 		Specified isolation level of SELECT (scan). If not set or
1:38f02ec: 		not application, it will be set to TransactionControl.UNSPECIFIED_ISOLATION_LEVEL
1:eac0369: 	*/
1:38f02ec: 	private int scanIsolationLevel = TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;
1:eac0369: 
1:eac0369:     //
1:eac0369:     // class interface
1:eac0369:     //
1:d868eed:     VTIResultSet(Activation activation, int row, int resultSetNumber,
1:eac0369: 				 GeneratedMethod constructor,
1:eac0369: 				 String javaClassName,
1:eac0369: 				 Qualifier[][] pushedQualifiers,
1:eac0369: 				 int erdNumber,
1:eac0369: 				 boolean version2, boolean reuseablePs,
1:eac0369: 				 int ctcNumber,
1:eac0369: 				 boolean isTarget,
1:eac0369: 				 int scanIsolationLevel,
1:eac0369: 			     double optimizerEstimatedRowCount,
1:4aef9b0: 				 double optimizerEstimatedCost,
1:f432362: 				 boolean isDerbyStyleTableFunction,
1:a2d0847:                  int returnTypeNumber,
1:a2d0847:                  int vtiProjectionNumber,
1:29007f0:                  int vtiRestrictionNumber,
1:29007f0:                  String vtiSchema,
1:29007f0:                  String vtiName
1:4aef9b0:                  ) 
1:f432362: 		throws StandardException
4:eac0369: 	{
1:eac0369: 		super(activation, resultSetNumber, 
1:eac0369: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369: 		this.constructor = constructor;
1:eac0369: 		this.javaClassName = javaClassName;
1:eac0369: 		this.version2 = version2;
1:eac0369: 		this.reuseablePs = reuseablePs;
1:eac0369: 		this.isTarget = isTarget;
1:eac0369: 		this.pushedQualifiers = pushedQualifiers;
1:eac0369: 		this.scanIsolationLevel = scanIsolationLevel;
1:4aef9b0: 		this.isDerbyStyleTableFunction = isDerbyStyleTableFunction;
1:29007f0:         this.vtiSchema = vtiSchema;
1:29007f0:         this.vtiName = vtiName;
1:47e1295: 
1:d868eed:         ExecPreparedStatement ps = activation.getPreparedStatement();
1:d868eed: 
1:d868eed:         this.allocatedRow = ((ExecRowBuilder) ps.getSavedObject(row))
1:d868eed:                 .build(activation.getExecutionFactory());
1:d868eed: 
1:47e1295:         this.returnType = returnTypeNumber == -1 ? null :
1:47e1295:             (TypeDescriptor)
1:47e1295:             activation.getPreparedStatement().getSavedObject(returnTypeNumber);
1:eac0369: 
1:a2d0847:         this.vtiProjection = vtiProjectionNumber == -1 ? null :
1:a2d0847:             (String[])
1:a2d0847:             activation.getPreparedStatement().getSavedObject(vtiProjectionNumber);
1:a2d0847: 
1:a2d0847:         this.vtiRestriction = vtiRestrictionNumber == -1 ? null :
1:a2d0847:             (Restriction)
1:a2d0847:             activation.getPreparedStatement().getSavedObject(vtiRestrictionNumber);
1:a2d0847: 
1:eac0369: 		if (erdNumber != -1)
1:eac0369: 		{
1:eac0369: 			this.referencedColumns = (FormatableBitSet)(activation.getPreparedStatement().
1:eac0369: 								getSavedObject(erdNumber));
9:eac0369: 		}
1:f432362: 
1:eac0369: 		compileTimeConstants = (FormatableHashtable) (activation.getPreparedStatement().
1:eac0369: 								getSavedObject(ctcNumber));
1:f432362: 
1:554386c:         // compileTimeConstants cannot be null, even if there are no
1:554386c:         // constants, since VTIResultSet.setSharedState() may want to
1:554386c:         // add constants to it during execution.
1:554386c:         if (SanityManager.DEBUG) {
1:554386c:             SanityManager.ASSERT(compileTimeConstants != null,
1:554386c:                                  "compileTimeConstants is null");
1:f432362:         }
1:554386c: 
1:7008b63: 		recordConstructorTime();
1:554386c:     }
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 
1:b2fb1d5: 	/**
1:eac0369:      * Sets state to 'open'.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if activation closed.
1:f432362:      */
1:eac0369: 	public void	openCore() throws StandardException 
1:f432362: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT( ! isOpen, "VTIResultSet already open");
1:eac0369: 
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		/* We need to Instantiate the user's ResultSet on the each open since
1:eac0369: 		 * there is no way to close and then reopen a java.sql.ResultSet.
1:eac0369: 		 * For Version 2 VTIs, we may be able to skip instantiated their
1:eac0369: 		 * PreparedStatement here.
1:eac0369: 		 */
1:f432362: 		try {
1:eac0369: 			if (version2)
1:f432362: 			{
1:eac0369: 				userPS = (PreparedStatement) constructor.invoke(activation);
1:f432362: 
1:eac0369: 				if (userPS instanceof org.apache.derby.vti.Pushable) {
1:eac0369: 					org.apache.derby.vti.Pushable p = (org.apache.derby.vti.Pushable) userPS;
1:eac0369: 					if (referencedColumns != null) {
1:eac0369: 						pushedProjection = p.pushProjection(this, getProjectedColList());
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (userPS instanceof org.apache.derby.vti.IQualifyable) {
1:eac0369: 					org.apache.derby.vti.IQualifyable q = (org.apache.derby.vti.IQualifyable) userPS;
1:eac0369: 
1:eac0369: 					q.setQualifiers(this, pushedQualifiers);
1:eac0369: 				}
1:eac0369: 				fastPath = userPS instanceof IFastPath ? (IFastPath) userPS : null;
1:eac0369: 
1:eac0369:                 if( isTarget
1:eac0369:                     && userPS instanceof DeferModification
1:eac0369:                     && activation.getConstantAction() instanceof UpdatableVTIConstantAction)
1:eac0369:                 {
1:eac0369:                     UpdatableVTIConstantAction constants = (UpdatableVTIConstantAction) activation.getConstantAction();
1:eac0369:                     ((DeferModification) userPS).modificationNotify( constants.statementType, constants.deferred);
1:eac0369:                 }
1:eac0369:                 
1:eac0369: 				if ((fastPath != null) && fastPath.executeAsFastPath())
1:eac0369: 					;
1:eac0369: 				else
1:eac0369: 					userVTI = userPS.executeQuery();
1:f432362: 
1:eac0369: 				/* Save off the target VTI */
1:eac0369: 				if (isTarget)
1:eac0369: 				{
1:eac0369: 					activation.setTargetVTI(userVTI);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				userVTI = (ResultSet) constructor.invoke(activation);
1:a2d0847: 
1:a2d0847:                 if ( userVTI instanceof RestrictedVTI )
1:a2d0847:                 {
1:a2d0847:                     RestrictedVTI restrictedVTI = (RestrictedVTI) userVTI;
1:a2d0847: 
1:a2d0847:                     restrictedVTI.initScan( vtiProjection, cloneRestriction( activation ) );
1:a2d0847:                 }
1:29007f0: 
1:29007f0:                 if ( userVTI instanceof AwareVTI )
1:29007f0:                 {
1:29007f0:                     AwareVTI awareVTI = (AwareVTI) userVTI;
1:29007f0: 
1:29007f0:                     awareVTI.setContext
1:29007f0:                         (
1:29007f0:                          new VTIContext
1:29007f0:                          (
1:29007f0:                           vtiSchema,
1:29007f0:                           vtiName,
1:29007f0:                           activation.getLanguageConnectionContext().getStatementContext().getStatementText()
1:29007f0:                           )
1:29007f0:                          );
1:29007f0:                 }
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Set up the nullablity of the runtime columns, may be delayed
1:eac0369: 			setNullableColumnList();
1:eac0369: 		}
1:eac0369: 		catch (Throwable t)
1:eac0369: 		{
1:eac0369: 			throw StandardException.unexpectedUserException(t);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:a2d0847:     /**
1:a2d0847:      * Clone the restriction for a Restricted VTI, filling in parameter values
1:a2d0847:      * as necessary.
1:a2d0847:      */
1:a2d0847:     private Restriction cloneRestriction( Activation activation ) throws StandardException
1:a2d0847:     {
1:a2d0847:         if ( vtiRestriction == null ) { return null; }
1:a2d0847:         else { return cloneRestriction( activation, vtiRestriction ); }
1:a2d0847:     }
1:a2d0847:     private Restriction cloneRestriction( Activation activation, Restriction original )
1:a2d0847:         throws StandardException
1:a2d0847:     {
1:a2d0847:         if ( original instanceof Restriction.AND)
1:a2d0847:         {
1:a2d0847:             Restriction.AND and = (Restriction.AND) original;
1:a2d0847:             
1:a2d0847:             return new Restriction.AND
1:a2d0847:                 (
1:a2d0847:                  cloneRestriction( activation, and.getLeftChild() ),
1:a2d0847:                  cloneRestriction( activation, and.getRightChild() )
1:a2d0847:                  );
1:a2d0847:         }
1:a2d0847:         else if ( original instanceof Restriction.OR)
1:a2d0847:         {
1:a2d0847:             Restriction.OR or = (Restriction.OR) original;
1:a2d0847:             
1:a2d0847:             return new Restriction.OR
1:a2d0847:                 (
1:a2d0847:                  cloneRestriction( activation, or.getLeftChild() ),
1:a2d0847:                  cloneRestriction( activation, or.getRightChild() )
1:a2d0847:                  );
1:a2d0847:         }
1:a2d0847:         else if ( original instanceof Restriction.ColumnQualifier)
1:a2d0847:         {
1:a2d0847:             Restriction.ColumnQualifier cq = (Restriction.ColumnQualifier) original;
1:a2d0847:             Object originalConstant = cq.getConstantOperand();
1:a2d0847:             Object newConstant;
1:a2d0847: 
1:a2d0847:             if ( originalConstant ==  null ) { newConstant = null; }
1:a2d0847:             else if ( originalConstant instanceof int[] )
1:a2d0847:             {
1:a2d0847:                 int parameterNumber = ((int[]) originalConstant)[ 0 ];
1:a2d0847:                 ParameterValueSet pvs = activation.getParameterValueSet();
1:a2d0847: 
1:a2d0847:                 newConstant = pvs.getParameter( parameterNumber ).getObject();
1:a2d0847:             }
1:a2d0847:             else { newConstant = originalConstant; }
1:a2d0847:            
1:a2d0847:             return new Restriction.ColumnQualifier
1:a2d0847:                 (
1:a2d0847:                  cq.getColumnName(),
1:a2d0847:                  cq.getComparisonOperator(),
1:a2d0847:                  newConstant
1:a2d0847:                  );
1:a2d0847:         }
1:a2d0847:         else
1:a2d0847:         {
1:a2d0847:             throw StandardException.newException( SQLState.NOT_IMPLEMENTED, original.getClass().getName() );
1:a2d0847:         }
1:a2d0847:     }
1:a2d0847: 
1:4aef9b0: 	private boolean[] setNullableColumnList() throws SQLException, StandardException {
1:eac0369: 
1:eac0369: 		if (runtimeNullableColumn != null)
1:eac0369: 			return runtimeNullableColumn;
1:eac0369: 
1:4aef9b0: 		// Derby-style table functions return SQL rows which don't have not-null
1:4aef9b0: 		// constraints bound to them
1:4aef9b0: 		if ( isDerbyStyleTableFunction )
1:4aef9b0: 		{
1:4aef9b0: 		    int         count = getAllocatedRow().nColumns() + 1;
1:4aef9b0:             
1:4aef9b0: 		    runtimeNullableColumn = new boolean[ count ];
1:4aef9b0: 		    for ( int i = 0; i < count; i++ )   { runtimeNullableColumn[ i ] = true; }
1:4aef9b0:             
1:4aef9b0: 		    return runtimeNullableColumn;
1:4aef9b0: 		}
1:4aef9b0: 
1:eac0369: 		if (userVTI == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		ResultSetMetaData rsmd = userVTI.getMetaData();
1:eac0369: 		boolean[] nullableColumn = new boolean[rsmd.getColumnCount() + 1];
1:eac0369: 		for (int i = 1; i <  nullableColumn.length; i++) {
1:eac0369: 			nullableColumn[i] = rsmd.isNullable(i) != ResultSetMetaData.columnNoNulls;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return runtimeNullableColumn = nullableColumn;
1:eac0369: 	}
1:eac0369: 
1:f432362: 	/**
1:eac0369: 	 * If the VTI is a version2 vti that does not
1:eac0369: 	 * need to be instantiated multiple times then
1:eac0369: 	 * we simply close the current ResultSet and 
1:eac0369: 	 * create a new one via a call to 
1:eac0369: 	 * PreparedStatement.executeQuery().
1:eac0369: 	 *
1:eac0369: 	 * @see NoPutResultSet#openCore
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369: 	 */
1:eac0369: 	public void reopenCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (reuseablePs)
1:eac0369: 		{
1:eac0369: 			/* close the user ResultSet.
1:eac0369: 			 */
1:eac0369: 			if (userVTI != null)
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					userVTI.close();
1:eac0369: 					userVTI = userPS.executeQuery();
1:eac0369: 
1:eac0369: 					/* Save off the target VTI */
1:eac0369: 					if (isTarget)
1:eac0369: 					{
1:eac0369: 						activation.setTargetVTI(userVTI);
1:eac0369: 					}
1:eac0369: 				} catch (SQLException se)
1:eac0369: 				{
1:eac0369: 					throw StandardException.unexpectedUserException(se);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			close();
1:eac0369: 			openCore();	
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * If open and not returned yet, returns the row
1:eac0369:      * after plugging the parameters into the expressions.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369:      */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException 
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 	    ExecRow result = null;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		
1:eac0369: 		if ( isOpen ) 
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				if ((userVTI == null) && (fastPath != null)) {
1:eac0369: 					result = getAllocatedRow();
1:eac0369: 					int action = fastPath.nextRow(result.getRowArray());
1:eac0369: 					if (action == IFastPath.GOT_ROW)
1:eac0369: 						;
1:eac0369: 					else if (action == IFastPath.SCAN_COMPLETED)
1:eac0369: 						result = null;
1:eac0369: 					else if (action == IFastPath.NEED_RS) {
1:eac0369: 						userVTI = userPS.executeQuery();
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				if ((userVTI != null))
1:eac0369:                 {
1:eac0369:                     if( ! userVTI.next())
1:eac0369:                     {
1:eac0369:                         if( null != fastPath)
1:eac0369:                             fastPath.rowsDone();
1:eac0369:                         result = null;
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         // Get the cached row and fill it up
1:eac0369:                         result = getAllocatedRow();
1:eac0369:                         populateFromResultSet(result);
1:eac0369:                         if (fastPath != null)
1:fe1ac60:                         { fastPath.currentRow(userVTI, result.getRowArray()); }
1:fe1ac60: 
1:fe1ac60:                         SQLWarning  warnings = userVTI.getWarnings();
1:fe1ac60:                         if ( warnings != null ) { addWarning( warnings ); }
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			catch (Throwable t)
1:eac0369: 			{
1:eac0369: 				throw StandardException.unexpectedUserException(t);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		setCurrentRow(result);
1:eac0369: 		if (result != null)
1:eac0369: 		{
1:eac0369: 			rowsReturned++;
1:eac0369: 			rowsSeen++;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 	    return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * @see org.apache.derby.iapi.sql.ResultSet#close
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (isOpen) {
1:eac0369: 
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 	    	clearCurrentRow();
1:eac0369: 
1:eac0369: 			/* close the user ResultSet.  We have to eat any exception here
1:eac0369: 			 * since our close() method cannot throw an exception.
1:eac0369: 			 */
1:eac0369: 			if (userVTI != null)
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					userVTI.close();
1:eac0369: 				} catch (SQLException se)
1:eac0369: 				{
1:eac0369: 					throw StandardException.unexpectedUserException(se);
1:eac0369: 				}
1:eac0369: 				finally {
1:eac0369: 					userVTI = null;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if ((userPS != null) && !reuseablePs)
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					userPS.close();
1:eac0369: 				} catch (SQLException se)
1:eac0369: 				{
1:eac0369: 					throw StandardException.unexpectedUserException(se);
1:eac0369: 				}
1:eac0369: 				finally {
1:eac0369: 					userPS = null;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			super.close();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of VTIResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void finish() throws StandardException {
1:eac0369: 
1:eac0369: 		// for a reusablePS it will be closed by the activation
1:eac0369: 		// when it is closed.
1:eac0369: 		if ((userPS != null) && !reuseablePs)
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				userPS.close();
1:eac0369: 				userPS = null;
1:eac0369: 			} catch (SQLException se)
1:eac0369: 			{
1:eac0369: 				throw StandardException.unexpectedUserException(se);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		finishAndRTS();
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 		return totTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This is not operating against a stored table,
1:eac0369: 	 * so it has no row location to report.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return a null.
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This is not used in positioned update and delete,
1:eac0369: 	 * so just return a null.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return a null.
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// Class implementation
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the GeneratedMethod for instantiating the VTI.
1:eac0369: 	 *
1:eac0369: 	 * @return The  GeneratedMethod for instantiating the VTI.
1:eac0369: 	 */
1:eac0369: 	GeneratedMethod getVTIConstructor()
1:eac0369: 	{
1:eac0369: 		return constructor;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	boolean isReuseablePs() {
1:eac0369: 		return reuseablePs;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Cache the ExecRow for this result set.
1:eac0369: 	 *
1:eac0369: 	 * @return The cached ExecRow for this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	private ExecRow getAllocatedRow()
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return allocatedRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int[] getProjectedColList() {
1:eac0369: 
1:eac0369: 		FormatableBitSet refs = referencedColumns;
1:eac0369: 		int size = refs.size();
1:eac0369: 		int arrayLen = 0;
1:eac0369: 		for (int i = 0; i < size; i++) {
1:eac0369: 			if (refs.isSet(i))
1:eac0369: 				arrayLen++;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int[] colList = new int[arrayLen];
1:eac0369: 		int offset = 0;
1:eac0369: 		for (int i = 0; i < size; i++) {
1:eac0369: 			if (refs.isSet(i))
1:eac0369: 				colList[offset++] = i + 1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return colList;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to open
1:eac0369: 	 */
1:eac0369: 	public void populateFromResultSet(ExecRow row)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:f432362:             DataTypeDescriptor[]    columnTypes = null;
1:f432362:             if ( isDerbyStyleTableFunction )
1:f432362:             {
1:f432362:                     columnTypes = getReturnColumnTypes();
1:f432362:             }
1:f432362: 
1:eac0369: 			boolean[] nullableColumn = setNullableColumnList();
1:eac0369: 			DataValueDescriptor[] columns = row.getRowArray();
1:eac0369: 			// ExecRows are 0-based, ResultSets are 1-based
1:eac0369: 			int rsColNumber = 1;
1:eac0369: 			for (int index = 0; index < columns.length; index++)
1:eac0369: 			{
1:eac0369: 				// Skip over unreferenced columns
1:eac0369: 				if (referencedColumns != null && (! referencedColumns.get(index)))
1:eac0369: 				{
1:eac0369: 					if (!pushedProjection)
1:eac0369: 						rsColNumber++;
1:eac0369: 
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				columns[index].setValueFromResultSet(
1:eac0369: 									userVTI, rsColNumber, 
1:eac0369: 									/* last parameter is whether or
1:eac0369: 									 * not the column is nullable
1:eac0369: 									 */
1:eac0369: 									nullableColumn[rsColNumber]);
1:eac0369: 				rsColNumber++;
1:f432362: 
1:f432362:                 // for Derby-style table functions, coerce the value coming out
1:f432362:                 // of the ResultSet to the declared SQL type of the return
1:f432362:                 // column
1:f432362:                 if ( isDerbyStyleTableFunction )
1:f432362:                 {
1:f432362:                     DataTypeDescriptor  dtd = columnTypes[ index ];
1:f432362:                     DataValueDescriptor dvd = columns[ index ];
1:f432362: 
1:f432362:                     cast( dtd, dvd );
1:f432362:                 }
1:f432362: 
1:f432362:             }
1:eac0369: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 		catch (Throwable t)
1:eac0369: 		{
1:eac0369: 			throw StandardException.unexpectedUserException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final int getScanIsolationLevel() {
1:eac0369: 		return scanIsolationLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** VTIEnvironment
1:eac0369: 	*/
1:eac0369: 	public final boolean isCompileTime() {
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final String getOriginalSQL() {
1:eac0369: 		return activation.getPreparedStatement().getSource();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final int getStatementIsolationLevel() {
1:38f02ec: 		return TransactionControl.jdbcIsolationLevel( getScanIsolationLevel() );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public final void setSharedState(String key, java.io.Serializable value) {
1:eac0369: 		if (key == null)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		if (value == null)
1:eac0369: 			compileTimeConstants.remove(key);
1:eac0369: 		else
1:eac0369: 			compileTimeConstants.put(key, value);
1:eac0369: 
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object getSharedState(String key) {
1:eac0369: 		if ((key == null) || (compileTimeConstants == null))
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		return compileTimeConstants.get(key);
1:f432362: 	}
1:f432362: 
1:f432362:     /**
1:b2fb1d5:      * <p>
1:f432362:      * Get the types of the columns returned by a Derby-style table function.
2:f432362:      * </p>
1:f432362:      */
1:f432362:     private DataTypeDescriptor[]    getReturnColumnTypes()
1:f432362:         throws StandardException
1:f432362:     {
1:f432362:         if ( returnColumnTypes == null )
1:f432362:         {
1:47e1295:             TypeDescriptor[] columnTypes = returnType.getRowTypes();
1:f432362:             int                         count = columnTypes.length;
1:f432362: 
1:f432362:             returnColumnTypes = new DataTypeDescriptor[ count ];
1:f432362:             for ( int i = 0; i < count; i++ )
1:f432362:             {
1:f432362:                 returnColumnTypes[ i ] = DataTypeDescriptor.getType( columnTypes[ i ] );
1:f432362:             }
1:f432362:         }
1:f432362: 
1:f432362:         return returnColumnTypes;
1:f432362:     }
1:f432362: 
1:f432362:     /**
2:f432362:      * <p>
1:f432362:      * Cast the value coming out of the user-coded ResultSet. The
1:f432362:      * rules are described in CastNode.getDataValueConversion().
1:f432362:      * </p>
1:f432362:      */
1:f432362:     private void    cast( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:f432362:         throws StandardException
1:f432362:     {
1:f432362:         TypeId      typeID = dtd.getTypeId();
1:f432362: 
1:f432362:         if ( !typeID.isBlobTypeId() && !typeID.isClobTypeId() )
1:f432362:         {
1:f432362:             if ( typeID.isLongVarcharTypeId() ) { castLongvarchar( dtd, dvd ); }
1:f432362:             else if ( typeID.isLongVarbinaryTypeId() ) { castLongvarbinary( dtd, dvd ); }
1:b2fb1d5:             else if ( typeID.isDecimalTypeId() ) { castDecimal( dtd, dvd ); }
1:f432362:             else
1:f432362:             {
1:f432362:                 Object      o = dvd.getObject();
1:f432362: 
1:f432362:                 dvd.setObjectForCast( o, true, typeID.getCorrespondingJavaTypeName() );
1:f432362: 
1:f432362:                 if ( typeID.variableLength() )
1:f432362:                 {
1:f432362:                     VariableSizeDataValue   vsdv = (VariableSizeDataValue) dvd;
1:f432362:                     int                                 width;
1:f432362:                     if ( typeID.isNumericTypeId() ) { width = dtd.getPrecision(); }
1:f432362:                     else { width = dtd.getMaximumWidth(); }
1:f432362:             
1:f432362:                     vsdv.setWidth( width, dtd.getScale(), false );
1:f432362:                 }
1:f432362:             }
1:f432362: 
1:f432362:         }
1:f432362: 
1:f432362:     }
1:f432362: 
1:f432362:     /**
1:f432362:      * <p>
1:f432362:      * Truncate long varchars to the legal maximum.
1:f432362:      * </p>
1:f432362:      */
1:f432362:     private void    castLongvarchar( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:f432362:         throws StandardException
1:f432362:     {
1:f432362:         if ( dvd.getLength() > TypeId.LONGVARCHAR_MAXWIDTH )
1:f432362:         {
1:f432362:             dvd.setValue( dvd.getString().substring( 0, TypeId.LONGVARCHAR_MAXWIDTH ) );
1:f432362:         }
1:f432362:     }
1:f432362:     
1:f432362:     /**
1:f432362:      * <p>
1:f432362:      * Truncate long varbinary values to the legal maximum.
1:f432362:      * </p>
1:f432362:      */
1:f432362:     private void    castLongvarbinary( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:f432362:         throws StandardException
1:f432362:     {
1:f432362:         if ( dvd.getLength() > TypeId.LONGVARBIT_MAXWIDTH )
1:f432362:         {
1:f432362:             byte[]  original = dvd.getBytes();
1:f432362:             byte[]  result = new byte[ TypeId.LONGVARBIT_MAXWIDTH ];
1:f432362: 
1:f432362:             System.arraycopy( original, 0, result, 0, TypeId.LONGVARBIT_MAXWIDTH );
1:f432362:             
1:f432362:             dvd.setValue( result );
1:f432362:         }
1:f432362:     }
1:f432362:     
1:eac0369:     /**
1:f432362:      * <p>
1:b2fb1d5:      * Set the correct precision and scale for a decimal value.
1:b2fb1d5:      * </p>
1:b2fb1d5:      */
1:b2fb1d5:     private void    castDecimal( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:b2fb1d5:         throws StandardException
1:b2fb1d5:     {
1:b2fb1d5:         VariableSizeDataValue   vsdv = (VariableSizeDataValue) dvd;
1:b2fb1d5:             
1:b2fb1d5:         vsdv.setWidth( dtd.getPrecision(), dtd.getScale(), false );
1:b2fb1d5:     }
1:b2fb1d5:     
1:a56ecfa:     public Element toXML( Element parentNode, String tag ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         Element myNode = super.toXML( parentNode, tag );
1:a56ecfa:         myNode.setAttribute( "javaClassName", javaClassName );
1:a56ecfa:         
1:a56ecfa:         return myNode;
1:a56ecfa:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:29007f0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.vti.AwareVTI;
1: import org.apache.derby.vti.VTIContext;
/////////////////////////////////////////////////////////////////////////
1:     private String  vtiSchema;
1:     private String  vtiName;
1: 
/////////////////////////////////////////////////////////////////////////
1:                  int vtiRestrictionNumber,
1:                  String vtiSchema,
1:                  String vtiName
/////////////////////////////////////////////////////////////////////////
1:         this.vtiSchema = vtiSchema;
1:         this.vtiName = vtiName;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if ( userVTI instanceof AwareVTI )
1:                 {
1:                     AwareVTI awareVTI = (AwareVTI) userVTI;
1: 
1:                     awareVTI.setContext
1:                         (
1:                          new VTIContext
1:                          (
1:                           vtiSchema,
1:                           vtiName,
1:                           activation.getLanguageConnectionContext().getStatementContext().getStatementText()
1:                           )
1:                          );
1:                 }
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
1:     public Element toXML( Element parentNode, String tag ) throws Exception
1:     {
1:         Element myNode = super.toXML( parentNode, tag );
1:         myNode.setAttribute( "javaClassName", javaClassName );
1:         
1:         return myNode;
1:     }
commit:38f02ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.transaction.TransactionControl;
/////////////////////////////////////////////////////////////////////////
1: 		not application, it will be set to TransactionControl.UNSPECIFIED_ISOLATION_LEVEL
1: 	private int scanIsolationLevel = TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;
/////////////////////////////////////////////////////////////////////////
1: 		return TransactionControl.jdbcIsolationLevel( getScanIsolationLevel() );
commit:fe1ac60
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1:                         { fastPath.currentRow(userVTI, result.getRowArray()); }
1: 
1:                         SQLWarning  warnings = userVTI.getWarnings();
1:                         if ( warnings != null ) { addWarning( warnings ); }
commit:a2d0847
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ParameterValueSet; 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.vti.RestrictedVTI;
1: import org.apache.derby.vti.Restriction;
/////////////////////////////////////////////////////////////////////////
1:     private String[] vtiProjection;
1:     private Restriction vtiRestriction;
1: 
/////////////////////////////////////////////////////////////////////////
1:                  int returnTypeNumber,
1:                  int vtiProjectionNumber,
0:                  int vtiRestrictionNumber
/////////////////////////////////////////////////////////////////////////
1:         this.vtiProjection = vtiProjectionNumber == -1 ? null :
1:             (String[])
1:             activation.getPreparedStatement().getSavedObject(vtiProjectionNumber);
1: 
1:         this.vtiRestriction = vtiRestrictionNumber == -1 ? null :
1:             (Restriction)
1:             activation.getPreparedStatement().getSavedObject(vtiRestrictionNumber);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if ( userVTI instanceof RestrictedVTI )
1:                 {
1:                     RestrictedVTI restrictedVTI = (RestrictedVTI) userVTI;
1: 
1:                     restrictedVTI.initScan( vtiProjection, cloneRestriction( activation ) );
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Clone the restriction for a Restricted VTI, filling in parameter values
1:      * as necessary.
1:      */
1:     private Restriction cloneRestriction( Activation activation ) throws StandardException
1:     {
1:         if ( vtiRestriction == null ) { return null; }
1:         else { return cloneRestriction( activation, vtiRestriction ); }
1:     }
1:     private Restriction cloneRestriction( Activation activation, Restriction original )
1:         throws StandardException
1:     {
1:         if ( original instanceof Restriction.AND)
1:         {
1:             Restriction.AND and = (Restriction.AND) original;
1:             
1:             return new Restriction.AND
1:                 (
1:                  cloneRestriction( activation, and.getLeftChild() ),
1:                  cloneRestriction( activation, and.getRightChild() )
1:                  );
1:         }
1:         else if ( original instanceof Restriction.OR)
1:         {
1:             Restriction.OR or = (Restriction.OR) original;
1:             
1:             return new Restriction.OR
1:                 (
1:                  cloneRestriction( activation, or.getLeftChild() ),
1:                  cloneRestriction( activation, or.getRightChild() )
1:                  );
1:         }
1:         else if ( original instanceof Restriction.ColumnQualifier)
1:         {
1:             Restriction.ColumnQualifier cq = (Restriction.ColumnQualifier) original;
1:             Object originalConstant = cq.getConstantOperand();
1:             Object newConstant;
1: 
1:             if ( originalConstant ==  null ) { newConstant = null; }
1:             else if ( originalConstant instanceof int[] )
1:             {
1:                 int parameterNumber = ((int[]) originalConstant)[ 0 ];
1:                 ParameterValueSet pvs = activation.getParameterValueSet();
1: 
1:                 newConstant = pvs.getParameter( parameterNumber ).getObject();
1:             }
1:             else { newConstant = originalConstant; }
1:            
1:             return new Restriction.ColumnQualifier
1:                 (
1:                  cq.getColumnName(),
1:                  cq.getComparisonOperator(),
1:                  newConstant
1:                  );
1:         }
1:         else
1:         {
1:             throw StandardException.newException( SQLState.NOT_IMPLEMENTED, original.getClass().getName() );
1:         }
1:     }
1: 
commit:26d0c8e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
/////////////////////////////////////////////////////////////////////////
0:             byte[]                                          bytes = FormatIdUtil.fromString( ice );
/////////////////////////////////////////////////////////////////////////
commit:b2fb1d5
/////////////////////////////////////////////////////////////////////////
1:             else if ( typeID.isDecimalTypeId() ) { castDecimal( dtd, dvd ); }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Set the correct precision and scale for a decimal value.
1:      * </p>
1:      */
1:     private void    castDecimal( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:         throws StandardException
1:     {
1:         VariableSizeDataValue   vsdv = (VariableSizeDataValue) dvd;
1:             
1:         vsdv.setWidth( dtd.getPrecision(), dtd.getScale(), false );
1:     }
1:     
commit:f432362
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.VariableSizeDataValue;
0: import org.apache.derby.iapi.services.io.FormatIdInputStream;
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
0:     private String  returnType;
1: 
1:     private DataTypeDescriptor[]    returnColumnTypes;
1: 
/////////////////////////////////////////////////////////////////////////
1: 				 boolean isDerbyStyleTableFunction,
0:                  String returnType
/////////////////////////////////////////////////////////////////////////
0:         this.returnType = returnType;
/////////////////////////////////////////////////////////////////////////
1:             DataTypeDescriptor[]    columnTypes = null;
1:             if ( isDerbyStyleTableFunction )
1:             {
1:                     columnTypes = getReturnColumnTypes();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // for Derby-style table functions, coerce the value coming out
1:                 // of the ResultSet to the declared SQL type of the return
1:                 // column
1:                 if ( isDerbyStyleTableFunction )
1:                 {
1:                     DataTypeDescriptor  dtd = columnTypes[ index ];
1:                     DataValueDescriptor dvd = columns[ index ];
1: 
1:                     cast( dtd, dvd );
1:                 }
1: 
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Get the types of the columns returned by a Derby-style table function.
1:      * </p>
1:      */
1:     private DataTypeDescriptor[]    getReturnColumnTypes()
1:         throws StandardException
1:     {
1:         if ( returnColumnTypes == null )
1:         {
0:             TypeDescriptor      td = thawReturnType( returnType );
0:             TypeDescriptor[]    columnTypes = td.getRowTypes();
1:             int                         count = columnTypes.length;
1: 
1:             returnColumnTypes = new DataTypeDescriptor[ count ];
1:             for ( int i = 0; i < count; i++ )
1:             {
1:                 returnColumnTypes[ i ] = DataTypeDescriptor.getType( columnTypes[ i ] );
1:             }
1:         }
1: 
1:         return returnColumnTypes;
1:     }
1: 
1:     /**
1:      * <p>
0:      * Deserialize a type descriptor from a string.
1:      * </p>
1:      */
0:     private TypeDescriptor  thawReturnType( String ice )
1:         throws StandardException
1:     {
1:         try {
0:             byte[]                                          bytes = ice.getBytes();
0:             ByteArrayInputStream                    bais = new ByteArrayInputStream( bytes );
0:             FormatIdInputStream                     fiis = new FormatIdInputStream( bais );
0:             TypeDescriptor                              td = (TypeDescriptor) fiis.readObject();
1: 
0:             return td;
1:             
0:         } catch (Throwable t)
1:         {
0:             throw StandardException.unexpectedUserException( t );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Cast the value coming out of the user-coded ResultSet. The
1:      * rules are described in CastNode.getDataValueConversion().
1:      * </p>
1:      */
1:     private void    cast( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:         throws StandardException
1:     {
1:         TypeId      typeID = dtd.getTypeId();
1: 
1:         if ( !typeID.isBlobTypeId() && !typeID.isClobTypeId() )
1:         {
1:             if ( typeID.isLongVarcharTypeId() ) { castLongvarchar( dtd, dvd ); }
1:             else if ( typeID.isLongVarbinaryTypeId() ) { castLongvarbinary( dtd, dvd ); }
1:             else
1:             {
1:                 Object      o = dvd.getObject();
1: 
1:                 dvd.setObjectForCast( o, true, typeID.getCorrespondingJavaTypeName() );
1: 
1:                 if ( typeID.variableLength() )
1:                 {
1:                     VariableSizeDataValue   vsdv = (VariableSizeDataValue) dvd;
1:                     int                                 width;
1:                     if ( typeID.isNumericTypeId() ) { width = dtd.getPrecision(); }
1:                     else { width = dtd.getMaximumWidth(); }
1:             
1:                     vsdv.setWidth( width, dtd.getScale(), false );
1:                 }
1:             }
1: 
1:         }
1: 
1:     }
1: 
1:     /**
1:      * <p>
1:      * Truncate long varchars to the legal maximum.
1:      * </p>
1:      */
1:     private void    castLongvarchar( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:         throws StandardException
1:     {
1:         if ( dvd.getLength() > TypeId.LONGVARCHAR_MAXWIDTH )
1:         {
1:             dvd.setValue( dvd.getString().substring( 0, TypeId.LONGVARCHAR_MAXWIDTH ) );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Truncate long varbinary values to the legal maximum.
1:      * </p>
1:      */
1:     private void    castLongvarbinary( DataTypeDescriptor dtd, DataValueDescriptor dvd )
1:         throws StandardException
1:     {
1:         if ( dvd.getLength() > TypeId.LONGVARBIT_MAXWIDTH )
1:         {
1:             byte[]  original = dvd.getBytes();
1:             byte[]  result = new byte[ TypeId.LONGVARBIT_MAXWIDTH ];
1: 
1:             System.arraycopy( original, 0, result, 0, TypeId.LONGVARBIT_MAXWIDTH );
1:             
1:             dvd.setValue( result );
1:         }
1:     }
1:     
1:     
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1: 	private boolean isDerbyStyleTableFunction;
1: 
/////////////////////////////////////////////////////////////////////////
1: 				 double optimizerEstimatedCost,
0: 				 boolean isDerbyStyleTableFunction
1:                  ) 
/////////////////////////////////////////////////////////////////////////
1: 		this.isDerbyStyleTableFunction = isDerbyStyleTableFunction;
/////////////////////////////////////////////////////////////////////////
1: 	private boolean[] setNullableColumnList() throws SQLException, StandardException {
1: 		// Derby-style table functions return SQL rows which don't have not-null
1: 		// constraints bound to them
1: 		if ( isDerbyStyleTableFunction )
1: 		{
1: 		    int         count = getAllocatedRow().nColumns() + 1;
1:             
1: 		    runtimeNullableColumn = new boolean[ count ];
1: 		    for ( int i = 0; i < count; i++ )   { runtimeNullableColumn[ i ] = true; }
1:             
1: 		    return runtimeNullableColumn;
1: 		}
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:554386c
/////////////////////////////////////////////////////////////////////////
1:     private final FormatableHashtable compileTimeConstants;
/////////////////////////////////////////////////////////////////////////
1:         // compileTimeConstants cannot be null, even if there are no
1:         // constants, since VTIResultSet.setSharedState() may want to
1:         // add constants to it during execution.
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(compileTimeConstants != null,
1:                                  "compileTimeConstants is null");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
commit:d868eed
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
/////////////////////////////////////////////////////////////////////////
1: 	private final ExecRow allocatedRow;
/////////////////////////////////////////////////////////////////////////
1:     VTIResultSet(Activation activation, int row, int resultSetNumber,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ExecPreparedStatement ps = activation.getPreparedStatement();
1: 
1:         this.allocatedRow = ((ExecRowBuilder) ps.getSavedObject(row))
1:                 .build(activation.getExecutionFactory());
1: 
/////////////////////////////////////////////////////////////////////////
commit:a280beb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:47e1295
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final TypeDescriptor returnType;
/////////////////////////////////////////////////////////////////////////
0:                  int returnTypeNumber
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.returnType = returnTypeNumber == -1 ? null :
1:             (TypeDescriptor)
1:             activation.getPreparedStatement().getSavedObject(returnTypeNumber);
/////////////////////////////////////////////////////////////////////////
1:             TypeDescriptor[] columnTypes = returnType.getRowTypes();
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class VTIResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				 double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.VTIResultSet
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.io.FormatableHashtable;
1: 
1: import org.apache.derby.vti.DeferModification;
1: import org.apache.derby.vti.IFastPath;
1: import org.apache.derby.vti.VTIEnvironment;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.ResultSetMetaData;
1: 
1: 
1: /**
1:  */
0: public class VTIResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet, VTIEnvironment {
1: 	
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	/* Run time statistics variables */
1: 	public int rowsReturned;
1: 	public String javaClassName;
1: 
0:     private boolean next;
0: 	private ClassInspector classInspector;
0:     private GeneratedMethod row;
1:     private GeneratedMethod constructor;
0:     protected GeneratedMethod closeCleanup;
1: 	private PreparedStatement userPS;
1: 	private ResultSet userVTI;
0: 	private ExecRow allocatedRow;
1: 	private FormatableBitSet referencedColumns;
1: 	private boolean version2;
1: 	private boolean reuseablePs;
1: 	private boolean isTarget;
0: 	private FormatableHashtable compileTimeConstants;
0: 	private int ctcNumber;
1: 
1: 	private boolean pushedProjection;
1: 	private IFastPath	fastPath;
1: 
1: 	private Qualifier[][]	pushedQualifiers;
1: 
1: 	private boolean[] runtimeNullableColumn;
1: 
1: 	/**
1: 		Specified isolation level of SELECT (scan). If not set or
0: 		not application, it will be set to ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL
1: 	*/
0: 	private int scanIsolationLevel = ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
1: 
1:     //
1:     // class interface
1:     //
0:     VTIResultSet(Activation activation, GeneratedMethod row, int resultSetNumber,
1: 				 GeneratedMethod constructor,
1: 				 String javaClassName,
1: 				 Qualifier[][] pushedQualifiers,
1: 				 int erdNumber,
1: 				 boolean version2, boolean reuseablePs,
1: 				 int ctcNumber,
1: 				 boolean isTarget,
1: 				 int scanIsolationLevel,
1: 			     double optimizerEstimatedRowCount,
0: 				 double optimizerEstimatedCost,
0: 				 GeneratedMethod closeCleanup) 
1: 		throws StandardException
1: 	{
1: 		super(activation, resultSetNumber, 
1: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         this.row = row;
1: 		this.constructor = constructor;
1: 		this.javaClassName = javaClassName;
1: 		this.version2 = version2;
1: 		this.reuseablePs = reuseablePs;
1: 		this.isTarget = isTarget;
1: 		this.pushedQualifiers = pushedQualifiers;
1: 		this.scanIsolationLevel = scanIsolationLevel;
1: 
1: 		if (erdNumber != -1)
1: 		{
1: 			this.referencedColumns = (FormatableBitSet)(activation.getPreparedStatement().
1: 								getSavedObject(erdNumber));
1: 		}
1: 
0: 		this.ctcNumber = ctcNumber;
1: 		compileTimeConstants = (FormatableHashtable) (activation.getPreparedStatement().
1: 								getSavedObject(ctcNumber));
1: 
0: 		this.closeCleanup = closeCleanup;
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 
1: 	/**
1:      * Sets state to 'open'.
1: 	 *
1: 	 * @exception StandardException thrown if activation closed.
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT( ! isOpen, "VTIResultSet already open");
1: 
1: 	    isOpen = true;
1: 		numOpens++;
1: 
1: 		/* We need to Instantiate the user's ResultSet on the each open since
1: 		 * there is no way to close and then reopen a java.sql.ResultSet.
1: 		 * For Version 2 VTIs, we may be able to skip instantiated their
1: 		 * PreparedStatement here.
1: 		 */
0: 		try {
1: 			if (version2)
1: 			{
1: 				userPS = (PreparedStatement) constructor.invoke(activation);
1: 
1: 				if (userPS instanceof org.apache.derby.vti.Pushable) {
1: 					org.apache.derby.vti.Pushable p = (org.apache.derby.vti.Pushable) userPS;
1: 					if (referencedColumns != null) {
1: 						pushedProjection = p.pushProjection(this, getProjectedColList());
1: 					}
1: 				}
1: 
1: 				if (userPS instanceof org.apache.derby.vti.IQualifyable) {
1: 					org.apache.derby.vti.IQualifyable q = (org.apache.derby.vti.IQualifyable) userPS;
1: 
1: 					q.setQualifiers(this, pushedQualifiers);
1: 				}
1: 				fastPath = userPS instanceof IFastPath ? (IFastPath) userPS : null;
1: 
1:                 if( isTarget
1:                     && userPS instanceof DeferModification
1:                     && activation.getConstantAction() instanceof UpdatableVTIConstantAction)
1:                 {
1:                     UpdatableVTIConstantAction constants = (UpdatableVTIConstantAction) activation.getConstantAction();
1:                     ((DeferModification) userPS).modificationNotify( constants.statementType, constants.deferred);
1:                 }
1:                 
1: 				if ((fastPath != null) && fastPath.executeAsFastPath())
1: 					;
1: 				else
1: 					userVTI = userPS.executeQuery();
1: 
1: 				/* Save off the target VTI */
1: 				if (isTarget)
1: 				{
1: 					activation.setTargetVTI(userVTI);
1: 				}
1: 
1: 			}
1: 			else
1: 			{
1: 				userVTI = (ResultSet) constructor.invoke(activation);
1: 			}
1: 
1: 			// Set up the nullablity of the runtime columns, may be delayed
1: 			setNullableColumnList();
1: 		}
1: 		catch (Throwable t)
1: 		{
1: 			throw StandardException.unexpectedUserException(t);
1: 		}
1: 
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
0: 	private boolean[] setNullableColumnList() throws SQLException {
1: 
1: 		if (runtimeNullableColumn != null)
1: 			return runtimeNullableColumn;
1: 
1: 		if (userVTI == null)
1: 			return null;
1: 
1: 		ResultSetMetaData rsmd = userVTI.getMetaData();
1: 		boolean[] nullableColumn = new boolean[rsmd.getColumnCount() + 1];
1: 		for (int i = 1; i <  nullableColumn.length; i++) {
1: 			nullableColumn[i] = rsmd.isNullable(i) != ResultSetMetaData.columnNoNulls;
1: 		}
1: 
1: 		return runtimeNullableColumn = nullableColumn;
1: 	}
1: 
1: 	/**
1: 	 * If the VTI is a version2 vti that does not
1: 	 * need to be instantiated multiple times then
1: 	 * we simply close the current ResultSet and 
1: 	 * create a new one via a call to 
1: 	 * PreparedStatement.executeQuery().
1: 	 *
1: 	 * @see NoPutResultSet#openCore
1: 	 * @exception StandardException thrown if cursor finished.
1: 	 */
1: 	public void reopenCore() throws StandardException
1: 	{
1: 		if (reuseablePs)
1: 		{
1: 			/* close the user ResultSet.
1: 			 */
1: 			if (userVTI != null)
1: 			{
1: 				try
1: 				{
1: 					userVTI.close();
1: 					userVTI = userPS.executeQuery();
1: 
1: 					/* Save off the target VTI */
1: 					if (isTarget)
1: 					{
1: 						activation.setTargetVTI(userVTI);
1: 					}
1: 				} catch (SQLException se)
1: 				{
1: 					throw StandardException.unexpectedUserException(se);
1: 				}
1: 			}
1: 		}
1: 		else
1: 		{
1: 			close();
1: 			openCore();	
1: 		}
1: 	}
1: 
1: 	/**
1:      * If open and not returned yet, returns the row
1:      * after plugging the parameters into the expressions.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1:      */
1: 	public ExecRow	getNextRowCore() throws StandardException 
1: 	{
1: 	    ExecRow result = null;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 		
1: 		if ( isOpen ) 
1: 		{
1: 			try
1: 			{
1: 				if ((userVTI == null) && (fastPath != null)) {
1: 					result = getAllocatedRow();
1: 					int action = fastPath.nextRow(result.getRowArray());
1: 					if (action == IFastPath.GOT_ROW)
1: 						;
1: 					else if (action == IFastPath.SCAN_COMPLETED)
1: 						result = null;
1: 					else if (action == IFastPath.NEED_RS) {
1: 						userVTI = userPS.executeQuery();
1: 					}
1: 				}
1: 				if ((userVTI != null))
1:                 {
1:                     if( ! userVTI.next())
1:                     {
1:                         if( null != fastPath)
1:                             fastPath.rowsDone();
1:                         result = null;
1:                     }
1:                     else
1:                     {
1:                         // Get the cached row and fill it up
1:                         result = getAllocatedRow();
1:                         populateFromResultSet(result);
1:                         if (fastPath != null)
0:                             fastPath.currentRow(userVTI, result.getRowArray());
1:                     }
1: 				}
1: 			}
1: 			catch (Throwable t)
1: 			{
1: 				throw StandardException.unexpectedUserException(t);
1: 			}
1: 
1: 		}
1: 
1: 		setCurrentRow(result);
1: 		if (result != null)
1: 		{
1: 			rowsReturned++;
1: 			rowsSeen++;
1: 		}
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 	    return result;
1: 	}
1: 
1: 	
1: 
1: 	/**
1:      * @see org.apache.derby.iapi.sql.ResultSet#close
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (isOpen) {
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
1: 
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 	    	clearCurrentRow();
0: 	    	next = false;
1: 
1: 			/* close the user ResultSet.  We have to eat any exception here
1: 			 * since our close() method cannot throw an exception.
1: 			 */
1: 			if (userVTI != null)
1: 			{
1: 				try
1: 				{
1: 					userVTI.close();
1: 				} catch (SQLException se)
1: 				{
1: 					throw StandardException.unexpectedUserException(se);
1: 				}
1: 				finally {
1: 					userVTI = null;
1: 				}
1: 			}
1: 			if ((userPS != null) && !reuseablePs)
1: 			{
1: 				try
1: 				{
1: 					userPS.close();
1: 				} catch (SQLException se)
1: 				{
1: 					throw StandardException.unexpectedUserException(se);
1: 				}
1: 				finally {
1: 					userPS = null;
1: 				}
1: 			}
1: 			super.close();
1: 		}
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of VTIResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	public void finish() throws StandardException {
1: 
1: 		// for a reusablePS it will be closed by the activation
1: 		// when it is closed.
1: 		if ((userPS != null) && !reuseablePs)
1: 		{
1: 			try
1: 			{
1: 				userPS.close();
1: 				userPS = null;
1: 			} catch (SQLException se)
1: 			{
1: 				throw StandardException.unexpectedUserException(se);
1: 			}
1: 		}
1: 
1: 		finishAndRTS();
1: 
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 		return totTime;
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * This is not operating against a stored table,
1: 	 * so it has no row location to report.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return a null.
1: 	 */
1: 	public RowLocation getRowLocation() {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * This is not used in positioned update and delete,
1: 	 * so just return a null.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return a null.
1: 	 */
1: 	public ExecRow getCurrentRow() {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
1: 		return null;
1: 	}
1: 
1: 	// Class implementation
1: 
1: 	/**
1: 	 * Return the GeneratedMethod for instantiating the VTI.
1: 	 *
1: 	 * @return The  GeneratedMethod for instantiating the VTI.
1: 	 */
1: 	GeneratedMethod getVTIConstructor()
1: 	{
1: 		return constructor;
1: 	}
1: 
1: 	boolean isReuseablePs() {
1: 		return reuseablePs;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Cache the ExecRow for this result set.
1: 	 *
1: 	 * @return The cached ExecRow for this ResultSet
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	private ExecRow getAllocatedRow()
1: 		throws StandardException
1: 	{
0: 		if (allocatedRow == null)
1: 		{
0: 			allocatedRow = (ExecRow) row.invoke(activation);
1: 		}
1: 
1: 		return allocatedRow;
1: 	}
1: 
1: 	private int[] getProjectedColList() {
1: 
1: 		FormatableBitSet refs = referencedColumns;
1: 		int size = refs.size();
1: 		int arrayLen = 0;
1: 		for (int i = 0; i < size; i++) {
1: 			if (refs.isSet(i))
1: 				arrayLen++;
1: 		}
1: 
1: 		int[] colList = new int[arrayLen];
1: 		int offset = 0;
1: 		for (int i = 0; i < size; i++) {
1: 			if (refs.isSet(i))
1: 				colList[offset++] = i + 1;
1: 		}
1: 
1: 		return colList;
1: 	}
1: 	/**
1: 	 * @exception StandardException thrown on failure to open
1: 	 */
1: 	public void populateFromResultSet(ExecRow row)
1: 		throws StandardException
1: 	{
1: 		try
1: 		{
1: 			boolean[] nullableColumn = setNullableColumnList();
1: 			DataValueDescriptor[] columns = row.getRowArray();
1: 			// ExecRows are 0-based, ResultSets are 1-based
1: 			int rsColNumber = 1;
1: 			for (int index = 0; index < columns.length; index++)
1: 			{
1: 				// Skip over unreferenced columns
1: 				if (referencedColumns != null && (! referencedColumns.get(index)))
1: 				{
1: 					if (!pushedProjection)
1: 						rsColNumber++;
1: 
1: 					continue;
1: 				}
1: 
1: 				columns[index].setValueFromResultSet(
1: 									userVTI, rsColNumber, 
1: 									/* last parameter is whether or
1: 									 * not the column is nullable
1: 									 */
1: 									nullableColumn[rsColNumber]);
1: 				rsColNumber++;
1: 			}
1: 
1: 		} catch (StandardException se) {
1: 			throw se;
1: 		}
1: 		catch (Throwable t)
1: 		{
1: 			throw StandardException.unexpectedUserException(t);
1: 		}
1: 	}
1: 
1: 	public final int getScanIsolationLevel() {
1: 		return scanIsolationLevel;
1: 	}
1: 
1: 	/*
1: 	** VTIEnvironment
1: 	*/
1: 	public final boolean isCompileTime() {
1: 		return false;
1: 	}
1: 
1: 	public final String getOriginalSQL() {
1: 		return activation.getPreparedStatement().getSource();
1: 	}
1: 
1: 	public final int getStatementIsolationLevel() {
0: 		return ExecutionContext.CS_TO_JDBC_ISOLATION_LEVEL_MAP[getScanIsolationLevel()];
1: 	}
1: 
1: 
1: 	public final void setSharedState(String key, java.io.Serializable value) {
1: 		if (key == null)
1: 			return;
1: 
0: 		if (compileTimeConstants == null) {
1: 
0: 			Object[] savedObjects = activation.getPreparedStatement().getSavedObjects();
1: 
0: 			synchronized (savedObjects) {
1: 
0: 				compileTimeConstants = (FormatableHashtable) savedObjects[ctcNumber];
0: 				if (compileTimeConstants == null) {
0: 					compileTimeConstants = new FormatableHashtable();
0: 					savedObjects[ctcNumber] = compileTimeConstants;
1: 				}
1: 			}
1: 		}
1: 
1: 		if (value == null)
1: 			compileTimeConstants.remove(key);
1: 		else
1: 			compileTimeConstants.put(key, value);
1: 
1: 
1: 	}
1: 
1: 	public Object getSharedState(String key) {
1: 		if ((key == null) || (compileTimeConstants == null))
1: 			return null;
1: 
1: 		return compileTimeConstants.get(key);
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.FormatableHashtable;
0: 
0: import org.apache.derby.vti.DeferModification;
0: import org.apache.derby.vti.IFastPath;
0: import org.apache.derby.vti.VTIEnvironment;
0: 
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.ResultSetMetaData;
0: 
0: 
0: /**
0:  */
0: public class VTIResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet, VTIEnvironment {
0: 	
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	/* Run time statistics variables */
0: 	public int rowsReturned;
0: 	public String javaClassName;
0: 
0:     private boolean next;
0: 	private ClassInspector classInspector;
0:     private GeneratedMethod row;
0:     private GeneratedMethod constructor;
0:     protected GeneratedMethod closeCleanup;
0: 	private PreparedStatement userPS;
0: 	private ResultSet userVTI;
0: 	private ExecRow allocatedRow;
0: 	private FormatableBitSet referencedColumns;
0: 	private boolean version2;
0: 	private boolean reuseablePs;
0: 	private boolean isTarget;
0: 	private FormatableHashtable compileTimeConstants;
0: 	private int ctcNumber;
0: 
0: 	private boolean pushedProjection;
0: 	private IFastPath	fastPath;
0: 
0: 	private Qualifier[][]	pushedQualifiers;
0: 
0: 	private boolean[] runtimeNullableColumn;
0: 
0: 	/**
0: 		Specified isolation level of SELECT (scan). If not set or
0: 		not application, it will be set to ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL
0: 	*/
0: 	private int scanIsolationLevel = ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
0: 
0:     //
0:     // class interface
0:     //
0:     VTIResultSet(Activation activation, GeneratedMethod row, int resultSetNumber,
0: 				 GeneratedMethod constructor,
0: 				 String javaClassName,
0: 				 Qualifier[][] pushedQualifiers,
0: 				 int erdNumber,
0: 				 boolean version2, boolean reuseablePs,
0: 				 int ctcNumber,
0: 				 boolean isTarget,
0: 				 int scanIsolationLevel,
0: 			     double optimizerEstimatedRowCount,
0: 				 double optimizerEstimatedCost,
0: 				 GeneratedMethod closeCleanup) 
0: 		throws StandardException
0: 	{
0: 		super(activation, resultSetNumber, 
0: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         this.row = row;
0: 		this.constructor = constructor;
0: 		this.javaClassName = javaClassName;
0: 		this.version2 = version2;
0: 		this.reuseablePs = reuseablePs;
0: 		this.isTarget = isTarget;
0: 		this.pushedQualifiers = pushedQualifiers;
0: 		this.scanIsolationLevel = scanIsolationLevel;
0: 
0: 		if (erdNumber != -1)
0: 		{
0: 			this.referencedColumns = (FormatableBitSet)(activation.getPreparedStatement().
0: 								getSavedObject(erdNumber));
0: 		}
0: 
0: 		this.ctcNumber = ctcNumber;
0: 		compileTimeConstants = (FormatableHashtable) (activation.getPreparedStatement().
0: 								getSavedObject(ctcNumber));
0: 
0: 		this.closeCleanup = closeCleanup;
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 
0: 	/**
0:      * Sets state to 'open'.
0: 	 *
0: 	 * @exception StandardException thrown if activation closed.
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT( ! isOpen, "VTIResultSet already open");
0: 
0: 	    isOpen = true;
0: 		numOpens++;
0: 
0: 		/* We need to Instantiate the user's ResultSet on the each open since
0: 		 * there is no way to close and then reopen a java.sql.ResultSet.
0: 		 * For Version 2 VTIs, we may be able to skip instantiated their
0: 		 * PreparedStatement here.
0: 		 */
0: 		try {
0: 			if (version2)
0: 			{
0: 				userPS = (PreparedStatement) constructor.invoke(activation);
0: 
0: 				if (userPS instanceof org.apache.derby.vti.Pushable) {
0: 					org.apache.derby.vti.Pushable p = (org.apache.derby.vti.Pushable) userPS;
0: 					if (referencedColumns != null) {
0: 						pushedProjection = p.pushProjection(this, getProjectedColList());
0: 					}
0: 				}
0: 
0: 				if (userPS instanceof org.apache.derby.vti.IQualifyable) {
0: 					org.apache.derby.vti.IQualifyable q = (org.apache.derby.vti.IQualifyable) userPS;
0: 
0: 					q.setQualifiers(this, pushedQualifiers);
0: 				}
0: 				fastPath = userPS instanceof IFastPath ? (IFastPath) userPS : null;
0: 
0:                 if( isTarget
0:                     && userPS instanceof DeferModification
0:                     && activation.getConstantAction() instanceof UpdatableVTIConstantAction)
0:                 {
0:                     UpdatableVTIConstantAction constants = (UpdatableVTIConstantAction) activation.getConstantAction();
0:                     ((DeferModification) userPS).modificationNotify( constants.statementType, constants.deferred);
0:                 }
0:                 
0: 				if ((fastPath != null) && fastPath.executeAsFastPath())
0: 					;
0: 				else
0: 					userVTI = userPS.executeQuery();
0: 
0: 				/* Save off the target VTI */
0: 				if (isTarget)
0: 				{
0: 					activation.setTargetVTI(userVTI);
0: 				}
0: 
0: 			}
0: 			else
0: 			{
0: 				userVTI = (ResultSet) constructor.invoke(activation);
0: 			}
0: 
0: 			// Set up the nullablity of the runtime columns, may be delayed
0: 			setNullableColumnList();
0: 		}
0: 		catch (Throwable t)
0: 		{
0: 			throw StandardException.unexpectedUserException(t);
0: 		}
0: 
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	private boolean[] setNullableColumnList() throws SQLException {
0: 
0: 		if (runtimeNullableColumn != null)
0: 			return runtimeNullableColumn;
0: 
0: 		if (userVTI == null)
0: 			return null;
0: 
0: 		ResultSetMetaData rsmd = userVTI.getMetaData();
0: 		boolean[] nullableColumn = new boolean[rsmd.getColumnCount() + 1];
0: 		for (int i = 1; i <  nullableColumn.length; i++) {
0: 			nullableColumn[i] = rsmd.isNullable(i) != ResultSetMetaData.columnNoNulls;
0: 		}
0: 
0: 		return runtimeNullableColumn = nullableColumn;
0: 	}
0: 
0: 	/**
0: 	 * If the VTI is a version2 vti that does not
0: 	 * need to be instantiated multiple times then
0: 	 * we simply close the current ResultSet and 
0: 	 * create a new one via a call to 
0: 	 * PreparedStatement.executeQuery().
0: 	 *
0: 	 * @see NoPutResultSet#openCore
0: 	 * @exception StandardException thrown if cursor finished.
0: 	 */
0: 	public void reopenCore() throws StandardException
0: 	{
0: 		if (reuseablePs)
0: 		{
0: 			/* close the user ResultSet.
0: 			 */
0: 			if (userVTI != null)
0: 			{
0: 				try
0: 				{
0: 					userVTI.close();
0: 					userVTI = userPS.executeQuery();
0: 
0: 					/* Save off the target VTI */
0: 					if (isTarget)
0: 					{
0: 						activation.setTargetVTI(userVTI);
0: 					}
0: 				} catch (SQLException se)
0: 				{
0: 					throw StandardException.unexpectedUserException(se);
0: 				}
0: 			}
0: 		}
0: 		else
0: 		{
0: 			close();
0: 			openCore();	
0: 		}
0: 	}
0: 
0: 	/**
0:      * If open and not returned yet, returns the row
0:      * after plugging the parameters into the expressions.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0:      */
0: 	public ExecRow	getNextRowCore() throws StandardException 
0: 	{
0: 	    ExecRow result = null;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 		
0: 		if ( isOpen ) 
0: 		{
0: 			try
0: 			{
0: 				if ((userVTI == null) && (fastPath != null)) {
0: 					result = getAllocatedRow();
0: 					int action = fastPath.nextRow(result.getRowArray());
0: 					if (action == IFastPath.GOT_ROW)
0: 						;
0: 					else if (action == IFastPath.SCAN_COMPLETED)
0: 						result = null;
0: 					else if (action == IFastPath.NEED_RS) {
0: 						userVTI = userPS.executeQuery();
0: 					}
0: 				}
0: 				if ((userVTI != null))
0:                 {
0:                     if( ! userVTI.next())
0:                     {
0:                         if( null != fastPath)
0:                             fastPath.rowsDone();
0:                         result = null;
0:                     }
0:                     else
0:                     {
0:                         // Get the cached row and fill it up
0:                         result = getAllocatedRow();
0:                         populateFromResultSet(result);
0:                         if (fastPath != null)
0:                             fastPath.currentRow(userVTI, result.getRowArray());
0:                     }
0: 				}
0: 			}
0: 			catch (Throwable t)
0: 			{
0: 				throw StandardException.unexpectedUserException(t);
0: 			}
0: 
0: 		}
0: 
0: 		setCurrentRow(result);
0: 		if (result != null)
0: 		{
0: 			rowsReturned++;
0: 			rowsSeen++;
0: 		}
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 	    return result;
0: 	}
0: 
0: 	
0: 
0: 	/**
0:      * @see org.apache.derby.iapi.sql.ResultSet#close
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (isOpen) {
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 	    	clearCurrentRow();
0: 	    	next = false;
0: 
0: 			/* close the user ResultSet.  We have to eat any exception here
0: 			 * since our close() method cannot throw an exception.
0: 			 */
0: 			if (userVTI != null)
0: 			{
0: 				try
0: 				{
0: 					userVTI.close();
0: 				} catch (SQLException se)
0: 				{
0: 					throw StandardException.unexpectedUserException(se);
0: 				}
0: 				finally {
0: 					userVTI = null;
0: 				}
0: 			}
0: 			if ((userPS != null) && !reuseablePs)
0: 			{
0: 				try
0: 				{
0: 					userPS.close();
0: 				} catch (SQLException se)
0: 				{
0: 					throw StandardException.unexpectedUserException(se);
0: 				}
0: 				finally {
0: 					userPS = null;
0: 				}
0: 			}
0: 			super.close();
0: 		}
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of VTIResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	public void finish() throws StandardException {
0: 
0: 		// for a reusablePS it will be closed by the activation
0: 		// when it is closed.
0: 		if ((userPS != null) && !reuseablePs)
0: 		{
0: 			try
0: 			{
0: 				userPS.close();
0: 				userPS = null;
0: 			} catch (SQLException se)
0: 			{
0: 				throw StandardException.unexpectedUserException(se);
0: 			}
0: 		}
0: 
0: 		finishAndRTS();
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 		return totTime;
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * This is not operating against a stored table,
0: 	 * so it has no row location to report.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return a null.
0: 	 */
0: 	public RowLocation getRowLocation() {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * This is not used in positioned update and delete,
0: 	 * so just return a null.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return a null.
0: 	 */
0: 	public ExecRow getCurrentRow() {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
0: 		return null;
0: 	}
0: 
0: 	// Class implementation
0: 
0: 	/**
0: 	 * Return the GeneratedMethod for instantiating the VTI.
0: 	 *
0: 	 * @return The  GeneratedMethod for instantiating the VTI.
0: 	 */
0: 	GeneratedMethod getVTIConstructor()
0: 	{
0: 		return constructor;
0: 	}
0: 
0: 	boolean isReuseablePs() {
0: 		return reuseablePs;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Cache the ExecRow for this result set.
0: 	 *
0: 	 * @return The cached ExecRow for this ResultSet
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	private ExecRow getAllocatedRow()
0: 		throws StandardException
0: 	{
0: 		if (allocatedRow == null)
0: 		{
0: 			allocatedRow = (ExecRow) row.invoke(activation);
0: 		}
0: 
0: 		return allocatedRow;
0: 	}
0: 
0: 	private int[] getProjectedColList() {
0: 
0: 		FormatableBitSet refs = referencedColumns;
0: 		int size = refs.size();
0: 		int arrayLen = 0;
0: 		for (int i = 0; i < size; i++) {
0: 			if (refs.isSet(i))
0: 				arrayLen++;
0: 		}
0: 
0: 		int[] colList = new int[arrayLen];
0: 		int offset = 0;
0: 		for (int i = 0; i < size; i++) {
0: 			if (refs.isSet(i))
0: 				colList[offset++] = i + 1;
0: 		}
0: 
0: 		return colList;
0: 	}
0: 	/**
0: 	 * @exception StandardException thrown on failure to open
0: 	 */
0: 	public void populateFromResultSet(ExecRow row)
0: 		throws StandardException
0: 	{
0: 		try
0: 		{
0: 			boolean[] nullableColumn = setNullableColumnList();
0: 			DataValueDescriptor[] columns = row.getRowArray();
0: 			// ExecRows are 0-based, ResultSets are 1-based
0: 			int rsColNumber = 1;
0: 			for (int index = 0; index < columns.length; index++)
0: 			{
0: 				// Skip over unreferenced columns
0: 				if (referencedColumns != null && (! referencedColumns.get(index)))
0: 				{
0: 					if (!pushedProjection)
0: 						rsColNumber++;
0: 
0: 					continue;
0: 				}
0: 
0: 				columns[index].setValueFromResultSet(
0: 									userVTI, rsColNumber, 
0: 									/* last parameter is whether or
0: 									 * not the column is nullable
0: 									 */
0: 									nullableColumn[rsColNumber]);
0: 				rsColNumber++;
0: 			}
0: 
0: 		} catch (StandardException se) {
0: 			throw se;
0: 		}
0: 		catch (Throwable t)
0: 		{
0: 			throw StandardException.unexpectedUserException(t);
0: 		}
0: 	}
0: 
0: 	public final int getScanIsolationLevel() {
0: 		return scanIsolationLevel;
0: 	}
0: 
0: 	/*
0: 	** VTIEnvironment
0: 	*/
0: 	public final boolean isCompileTime() {
0: 		return false;
0: 	}
0: 
0: 	public final String getOriginalSQL() {
0: 		return activation.getPreparedStatement().getSource();
0: 	}
0: 
0: 	public final int getStatementIsolationLevel() {
0: 		return ExecutionContext.CS_TO_JDBC_ISOLATION_LEVEL_MAP[getScanIsolationLevel()];
0: 	}
0: 
0: 
0: 	public final void setSharedState(String key, java.io.Serializable value) {
0: 		if (key == null)
0: 			return;
0: 
0: 		if (compileTimeConstants == null) {
0: 
0: 			Object[] savedObjects = activation.getPreparedStatement().getSavedObjects();
0: 
0: 			synchronized (savedObjects) {
0: 
0: 				compileTimeConstants = (FormatableHashtable) savedObjects[ctcNumber];
0: 				if (compileTimeConstants == null) {
0: 					compileTimeConstants = new FormatableHashtable();
0: 					savedObjects[ctcNumber] = compileTimeConstants;
0: 				}
0: 			}
0: 		}
0: 
0: 		if (value == null)
0: 			compileTimeConstants.remove(key);
0: 		else
0: 			compileTimeConstants.put(key, value);
0: 
0: 
0: 	}
0: 
0: 	public Object getSharedState(String key) {
0: 		if ((key == null) || (compileTimeConstants == null))
0: 			return null;
0: 
0: 		return compileTimeConstants.get(key);
0: 	}
0: }
============================================================================