1:f7c7987: /*
1:f7c7987:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.RowLockBasicTest
1:f7c7987: 
1:f7c7987:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f7c7987:    contributor license agreements.  See the NOTICE file distributed with
1:f7c7987:    this work for additional information regarding copyright ownership.
1:f7c7987:    The ASF licenses this file to You under the Apache License, Version 2.0
1:f7c7987:    (the "License"); you may not use this file except in compliance with
1:f7c7987:    the License.  You may obtain a copy of the License at
1:f7c7987: 
1:f7c7987:       http://www.apache.org/licenses/LICENSE-2.0
1:f7c7987: 
1:f7c7987:    Unless required by applicable law or agreed to in writing, software
1:f7c7987:    distributed under the License is distributed on an "AS IS" BASIS,
1:f7c7987:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f7c7987:    See the License for the specific language governing permissions and
1:f7c7987:    limitations under the License.
1:f7c7987: 
1:f7c7987:  */
1:04d93b6: package org.apache.derbyTesting.functionTests.tests.store;
3:04d93b6: 
1:04d93b6: import java.sql.Connection;
1:04d93b6: import java.sql.ResultSet;
1:04d93b6: import java.sql.SQLException;
1:04d93b6: import java.sql.Statement;
1:04d93b6: 
1:04d93b6: import junit.framework.Test;
1:04d93b6: 
1:04d93b6: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:04d93b6: import org.apache.derbyTesting.junit.JDBC;
1:04d93b6: import org.apache.derbyTesting.junit.TestConfiguration;
1:04d93b6: 
1:f7c7987: /**
1:f7c7987:  * Very basic single user testing of row locking, verify that the right locks
1:f7c7987:  * are obtained for simple operations.  This test only looks at table and
1:f7c7987:  * row logical locks, it does not verify physical latches or lock ordering.
1:f7c7987:  * The basic methodology is:
1:f7c7987:  *       start transaction
1:f7c7987:  *       simple operation
1:f7c7987:  *       print lock table which should match the master
1:f7c7987:  *       end transation 
1:f7c7987:  *
1:f7c7987:  */
1:04d93b6: public class RowLockBasicTest extends BaseJDBCTestCase {
1:04d93b6:     public RowLockBasicTest(String name) {
1:04d93b6:         super(name);
2:04d93b6:     }
1:04d93b6:     
1:04d93b6:     public static Test suite() {
1:04d93b6:         return TestConfiguration.defaultSuite(RowLockBasicTest.class);
1:04d93b6:     }
1:04d93b6:     
1:f7c7987:     protected void setUp() throws SQLException {
1:04d93b6:             getConnection().setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:04d93b6:             Statement s = createStatement();
1:04d93b6:             s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:04d93b6:                     + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME "
1:04d93b6:                     + "'org.apache.derbyTesting.functionTests.util.Formatters"
1:04d93b6:                     + ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:04d93b6:             createLockTableQueryEntries(s);
1:04d93b6:             
1:04d93b6:             s.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY"
1:04d93b6:                     + "('derby.storage.pageSize', '4096')");
1:04d93b6:             s.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY"
1:04d93b6:                     + "('derby.storage.rowLocking', 'true')");
1:04d93b6:             
1:04d93b6:             s.close();
1:04d93b6:             
1:04d93b6:             getConnection().setAutoCommit(false);
1:04d93b6:             
1:04d93b6:             dropTable("a");
1:04d93b6:     }
1:f7c7987:     
1:04d93b6:     private void createLockTableQueryEntries(Statement s) throws SQLException {
1:04d93b6:         s.execute("create view lock_table as "
1:04d93b6:                 + "select "
1:04d93b6:                 + "cast(username as char(8)) as username,"
1:04d93b6:                 + "cast(t.type as char(8)) as trantype,"
1:04d93b6:                 + "cast(l.type as char(8)) as type,"
1:04d93b6:                 + "cast(lockcount as char(3)) as cnt,"
1:04d93b6:                 + "mode,"
1:04d93b6:                 + "cast(tablename as char(12)) as tabname,"
1:04d93b6:                 + "cast(lockname as char(10)) as lockname,"
1:04d93b6:                 + "state,"
1:04d93b6:                 + "status "
1:04d93b6:                 + "from "
1:04d93b6:                 + "syscs_diag.lock_table l  right outer join syscs_diag.transaction_table t "
1:04d93b6:                 + "on l.xid = t.xid where l.tableType <> 'S' and t.type='UserTransaction'");
1:04d93b6:         
1:04d93b6:         //lock table with system catalog locks included.
1:04d93b6:         s.execute("create view full_lock_table as "
1:04d93b6:                 + "select "
1:04d93b6:                 + "cast(username as char(8)) as username, "
1:04d93b6:                 + "cast(t.type as char(8)) as trantype,"
1:04d93b6:                 + "cast(l.type as char(8)) as type,"
1:04d93b6:                 + "cast(lockcount as char(3)) as cnt,"
1:04d93b6:                 + "mode, "
1:04d93b6:                 + "cast(tablename as char(12)) as tabname,"
1:04d93b6:                 + "cast(lockname as char(10)) as lockname,"
1:04d93b6:                 + "state,"
1:04d93b6:                 + "status "
1:04d93b6:                 + "from "
1:04d93b6:                 + "syscs_diag.lock_table l right outer join syscs_diag.transaction_table t "
1:04d93b6:                 + "on l.xid = t.xid where l.tableType <> 'S' ");
1:04d93b6:         
1:04d93b6:         //lock table with no join.
1:04d93b6:         s.execute("create view lock_table2 as "
1:04d93b6:                 + "select "
1:04d93b6:                 + "cast(l.xid as char(8)) as xid,"
1:04d93b6:                 + "cast(l.type as char(8)) as type,"
1:04d93b6:                 + "cast(lockcount as char(3)) as cnt,"
1:04d93b6:                 + "mode,"
1:04d93b6:                 + "cast(tablename as char(12)) as tabname,"
1:04d93b6:                 + "cast(lockname as char(10)) as lockname,"
1:04d93b6:                 + "state "
1:04d93b6:                 + "from "
1:04d93b6:                 + "syscs_diag.lock_table l "
1:04d93b6:                 + "where l.tableType <> 'S' ");
1:04d93b6:         
1:04d93b6:         //-- transaction table with no join.
1:04d93b6:         s.execute("create view tran_table as "
1:04d93b6:                 + "select "
1:04d93b6:                 + "* "
1:04d93b6:                 + "from "
1:04d93b6:                 + "syscs_diag.transaction_table");        
1:04d93b6:     }
1:04d93b6: 
1:f7c7987:     public void tearDown() throws Exception {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         st.executeUpdate("DROP FUNCTION PADSTRING");
1:04d93b6:         
1:04d93b6:         st.execute("drop view lock_table");
1:04d93b6:         st.execute("drop view full_lock_table");
1:04d93b6:         st.execute("drop view lock_table2");
1:04d93b6:         st.execute("drop view tran_table");
1:04d93b6:         
1:04d93b6:         st.close();
1:04d93b6:         dropTable("a");
1:04d93b6:         commit();
1:f7c7987:         
1:f7c7987:         super.tearDown();
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     public void testInsertIntoHeap() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         st.execute("create table a (a int)");
1:04d93b6:         commit();    
1:04d93b6:         
1:04d93b6:         //Test insert into empty heap, should just get row lock on row being inserted
1:04d93b6:         st.execute("insert into a values (1)");        
1:04d93b6:         ResultSet rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,7)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         //Test insert into heap with one row, just get row lock on row being inserted
1:04d93b6:         st.execute("insert into a values (2)");        
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,8)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         dropTable("a");
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "3", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();    
1:04d93b6:                 
1:04d93b6:         st.close();        
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     public void testInsertIntoBtree() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         
1:04d93b6:         st.execute("create table a (a int, b varchar(1000))");
1:04d93b6:         ResultSet rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6: 
1:04d93b6:         st.execute("create index a_idx on a (a, b)");
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "4", "S", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:  
1:04d93b6:         //Test insert into empty btree, should just get row lock on row being 
1:04d93b6:         //inserted and an instant duration lock on "first key in table" row (id 3).
1:04d93b6:         st.execute("insert into a values (1, PADSTRING('a',1000))");
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,7)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         //Test insert into non-empty btree, should get row lock on row being 
1:04d93b6:         //inserted and an instant duration lock on the one before it.
1:04d93b6:         st.execute("insert into a values (2, PADSTRING('b',1000))");
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,8)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6: 
1:04d93b6:         //Cause split and check locks that are obtained as part of inserting after
1:04d93b6:         //the split.  This causes the code to get a previous lock on a previous page.
1:04d93b6:          
1:04d93b6:         //RESOLVE (mikem) - the row lock on (1,9) is a result of raw store getting
1:04d93b6:         //a lock while it tries to fit the row on the original page record id, but
1:04d93b6:         // there is not enough room, so it eventually allocates a new page/row and 
1:04d93b6:         // locks that one - but the old lock is left around.
1:04d93b6:         //
1:04d93b6:         // btree just before commit:
1:04d93b6:         // leftmost leaf: (1,6), (1,7)
1:04d93b6:         // next leaf:     (1,8), (2,6)
1:04d93b6:         st.execute("insert into a values (3, PADSTRING('c',1000))");
1:04d93b6:         commit();        
1:04d93b6:         st.execute("insert into a values (4, PADSTRING('d',1000))");        
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 " select * from lock_table order by tabname, type "
1:04d93b6:                 + "desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,10)", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(2,6)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:     
1:04d93b6:         st.close();
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      *Cause an insert on a new page that inserts into the 1st slot on the btree 
1:04d93b6:      *page.
1:04d93b6:      * btree just before commit:
1:04d93b6:      * leftmost leaf: (1,6), (1,7)
1:04d93b6:      * next leaf:     (2,7), (2,6) 
1:04d93b6:      */
1:04d93b6:     public void testInsertOnNewPage() throws SQLException {
1:04d93b6:         Statement st = createStatement();        
1:04d93b6:         st.execute("create table a (a int, b varchar(1000))");
1:04d93b6:         st.execute("create unique index a_idx on a (a, b)");
1:04d93b6:         st.execute("insert into a values (1, PADSTRING('a',1000))");
1:04d93b6:         st.execute("insert into a values (2, PADSTRING('b',1000))");
1:04d93b6:         st.execute("insert into a values (3, PADSTRING('c',1000))");
1:04d93b6:         st.execute("insert into a values (4, PADSTRING('d',1000))");
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select a from a");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"1"},
1:04d93b6:                 {"2"},
1:04d93b6:                 {"3"},
1:04d93b6:                 {"4"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         st.execute("delete from a where a = 3");
1:04d93b6:         rs = st.executeQuery("select a from a");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"1"},
1:04d93b6:                 {"2"},
1:04d93b6:                 {"4"}
1:04d93b6:         });        
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.execute("insert into a values (3, PADSTRING('c',1000))");
1:04d93b6:         rs = st.executeQuery(
1:04d93b6:                 "select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,9)", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(2,7)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6: 
1:04d93b6:         st.close();
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      * Do full covered index scan.
1:04d93b6:      */
1:04d93b6:     public void testFullCoveredIndexScan() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         createTableAandUniqueIndex(st);
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select a from a");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"1"},
1:04d93b6:                 {"2"},
1:04d93b6:                 {"3"},
1:04d93b6:                 {"4"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "S", "A", "Tablelock", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.close();
1:04d93b6:     }
1:04d93b6: 
1:04d93b6:     private void createTableAandUniqueIndex(Statement st) throws SQLException {
1:04d93b6:         st.execute("create table a (a int, b char(200))");
1:04d93b6:         st.execute("create unique index a_idx on a (a)");
1:04d93b6:         st.execute("insert into a values (1, 'a')");
1:04d93b6:         st.execute("insert into a values (2, 'b')");
1:04d93b6:         st.execute("insert into a values (3, 'c')");
1:04d93b6:         st.execute("insert into a values (4, 'd')");
1:04d93b6:         commit();        
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      * Do single probe into covered index (first key in table).
1:04d93b6:      * 
1:04d93b6:      */
1:04d93b6:     public void testSingleProbeIntoFirstKey() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         createTableAandUniqueIndex(st);
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select a from a where a = 1");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"1"},
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,7)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.close();
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      * Do single probe into covered index (last key in table).
1:04d93b6:      */
1:04d93b6:     public void testSingleProbeIntoLastKey() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         createTableAandUniqueIndex(st);
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select a from a where a = 4");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"4"},
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,10)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.close();
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      * Do set of range scans that all return 1 row from covered index.
1:04d93b6:      */
1:04d93b6:     public void testSetOfRangeScanFor1RowReturn() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         createTableAandUniqueIndex(st);
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select a from a where a <= 1");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"1"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,3)", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,7)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select a from a where a >= 2 and a < 3");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"2"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,8)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select a from a where a > 3");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"4"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,10)", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,9)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.close();        
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      * Do set of range scans that all return 0 row from covered index.
1:04d93b6:      */
1:04d93b6:     public void testSetOfRangeScanFor0RowReturn() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         createTableAandUniqueIndex(st);
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select a from a where a < 1");
1:04d93b6:         JDBC.assertDrainResults(rs, 0);
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,3)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6: 
1:04d93b6:         rs = st.executeQuery("select a from a where a > 4");
1:04d93b6:         JDBC.assertDrainResults(rs, 0);
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,10)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select a from a where a > 2 and a < 3");
1:04d93b6:         JDBC.assertDrainResults(rs, 0);
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,8)", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.close();        
1:04d93b6:     }
1:04d93b6:     
1:04d93b6:     /**
1:04d93b6:      * Verify that create index does table level locking.
1:04d93b6:      */
1:04d93b6:     public void testCreateIndexDoesTableLevelLocking() throws SQLException {
1:04d93b6:         Statement st = createStatement();
1:04d93b6:         st.execute("create table a (a int, b char(200))");
1:04d93b6:         st.execute("create table b (a int, b char(200))");
1:04d93b6:         st.execute("insert into a values (1, 'a')");
1:04d93b6:         st.execute("insert into a values (2, 'b')");
1:04d93b6:         st.execute("insert into a values (3, 'c')");
1:04d93b6:         st.execute("insert into a values (4, 'd')");
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.execute("create unique index a_idx on a (a)");
1:04d93b6:         
1:04d93b6:         ResultSet rs = st.executeQuery("select * from lock_table "
1:04d93b6:                 + "order by tabname, type desc, mode, cnt, lockname");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"APP", "UserTran", "TABLE", "4", "S", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"},
1:04d93b6:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"}
1:04d93b6:         });
1:04d93b6:         commit();
1:04d93b6: 
1:04d93b6:         rs = st.executeQuery("select a from a");
1:04d93b6:         JDBC.assertFullResultSet(rs, new String[][]{
1:04d93b6:                 {"1"},
1:04d93b6:                 {"2"},
1:04d93b6:                 {"3"},
1:04d93b6:                 {"4"}
1:04d93b6:         });
1:04d93b6:         
1:04d93b6:         rs = st.executeQuery("select a from b");
1:04d93b6:         JDBC.assertDrainResults(rs, 0);
1:04d93b6:         
1:04d93b6:         commit();
1:04d93b6:         
1:04d93b6:         st.execute("drop index a_idx");
1:04d93b6:         dropTable("a");
1:04d93b6:         dropTable("b");
1:04d93b6:         
1:04d93b6:         
1:04d93b6:         st.close();
1:04d93b6:     }
1:04d93b6: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:f7c7987
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.RowLockBasicTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Very basic single user testing of row locking, verify that the right locks
1:  * are obtained for simple operations.  This test only looks at table and
1:  * row logical locks, it does not verify physical latches or lock ordering.
1:  * The basic methodology is:
1:  *       start transaction
1:  *       simple operation
1:  *       print lock table which should match the master
1:  *       end transation 
1:  *
1:  */
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         
1:         super.tearDown();
commit:04d93b6
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class RowLockBasicTest extends BaseJDBCTestCase {
1: 
0:     private int isolation;
1: 
1:     public RowLockBasicTest(String name) {
1:         super(name);
1:     }
1:     
1:     public static Test suite() {
1:         return TestConfiguration.defaultSuite(RowLockBasicTest.class);
1:     }
1:     
0:     protected void setUp() {
0:         try {
0:             isolation = getConnection().getTransactionIsolation();
1:             getConnection().setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:             Statement s = createStatement();
1:             s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:                     + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME "
1:                     + "'org.apache.derbyTesting.functionTests.util.Formatters"
1:                     + ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:             createLockTableQueryEntries(s);
1:             
1:             s.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY"
1:                     + "('derby.storage.pageSize', '4096')");
1:             s.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY"
1:                     + "('derby.storage.rowLocking', 'true')");
1:             
1:             s.close();
1:             
1:             getConnection().setAutoCommit(false);
1:             
1:             dropTable("a");
0:         } catch (SQLException se) {
0:             se.printStackTrace();
0:             //ignore
1:         }
1:     }
1:     private void createLockTableQueryEntries(Statement s) throws SQLException {
1:         s.execute("create view lock_table as "
1:                 + "select "
1:                 + "cast(username as char(8)) as username,"
1:                 + "cast(t.type as char(8)) as trantype,"
1:                 + "cast(l.type as char(8)) as type,"
1:                 + "cast(lockcount as char(3)) as cnt,"
1:                 + "mode,"
1:                 + "cast(tablename as char(12)) as tabname,"
1:                 + "cast(lockname as char(10)) as lockname,"
1:                 + "state,"
1:                 + "status "
1:                 + "from "
1:                 + "syscs_diag.lock_table l  right outer join syscs_diag.transaction_table t "
1:                 + "on l.xid = t.xid where l.tableType <> 'S' and t.type='UserTransaction'");
1:         
1:         //lock table with system catalog locks included.
1:         s.execute("create view full_lock_table as "
1:                 + "select "
1:                 + "cast(username as char(8)) as username, "
1:                 + "cast(t.type as char(8)) as trantype,"
1:                 + "cast(l.type as char(8)) as type,"
1:                 + "cast(lockcount as char(3)) as cnt,"
1:                 + "mode, "
1:                 + "cast(tablename as char(12)) as tabname,"
1:                 + "cast(lockname as char(10)) as lockname,"
1:                 + "state,"
1:                 + "status "
1:                 + "from "
1:                 + "syscs_diag.lock_table l right outer join syscs_diag.transaction_table t "
1:                 + "on l.xid = t.xid where l.tableType <> 'S' ");
1:         
1:         //lock table with no join.
1:         s.execute("create view lock_table2 as "
1:                 + "select "
1:                 + "cast(l.xid as char(8)) as xid,"
1:                 + "cast(l.type as char(8)) as type,"
1:                 + "cast(lockcount as char(3)) as cnt,"
1:                 + "mode,"
1:                 + "cast(tablename as char(12)) as tabname,"
1:                 + "cast(lockname as char(10)) as lockname,"
1:                 + "state "
1:                 + "from "
1:                 + "syscs_diag.lock_table l "
1:                 + "where l.tableType <> 'S' ");
1:         
1:         //-- transaction table with no join.
1:         s.execute("create view tran_table as "
1:                 + "select "
1:                 + "* "
1:                 + "from "
1:                 + "syscs_diag.transaction_table");        
1:     }
1: 
0:     public void tearDown() throws SQLException {
1:         Statement st = createStatement();
1:         st.executeUpdate("DROP FUNCTION PADSTRING");
1:         
1:         st.execute("drop view lock_table");
1:         st.execute("drop view full_lock_table");
1:         st.execute("drop view lock_table2");
1:         st.execute("drop view tran_table");
1:         
1:         st.close();
1:         dropTable("a");
1:         commit();
0:         getConnection().setTransactionIsolation(isolation);
1:     }
1:     
1:     public void testInsertIntoHeap() throws SQLException {
1:         Statement st = createStatement();
1:         st.execute("create table a (a int)");
1:         commit();    
1:         
1:         //Test insert into empty heap, should just get row lock on row being inserted
1:         st.execute("insert into a values (1)");        
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,7)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:         
1:         //Test insert into heap with one row, just get row lock on row being inserted
1:         st.execute("insert into a values (2)");        
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,8)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:         
1:         dropTable("a");
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "3", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"}
1:         });
1:         commit();    
1:                 
1:         st.close();        
1:     }
1:     
1:     public void testInsertIntoBtree() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         st.execute("create table a (a int, b varchar(1000))");
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1: 
1:         st.execute("create index a_idx on a (a, b)");
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "4", "S", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:  
1:         //Test insert into empty btree, should just get row lock on row being 
1:         //inserted and an instant duration lock on "first key in table" row (id 3).
1:         st.execute("insert into a values (1, PADSTRING('a',1000))");
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,7)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:         
1:         //Test insert into non-empty btree, should get row lock on row being 
1:         //inserted and an instant duration lock on the one before it.
1:         st.execute("insert into a values (2, PADSTRING('b',1000))");
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,8)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1: 
1:         //Cause split and check locks that are obtained as part of inserting after
1:         //the split.  This causes the code to get a previous lock on a previous page.
1:          
1:         //RESOLVE (mikem) - the row lock on (1,9) is a result of raw store getting
1:         //a lock while it tries to fit the row on the original page record id, but
1:         // there is not enough room, so it eventually allocates a new page/row and 
1:         // locks that one - but the old lock is left around.
1:         //
1:         // btree just before commit:
1:         // leftmost leaf: (1,6), (1,7)
1:         // next leaf:     (1,8), (2,6)
1:         st.execute("insert into a values (3, PADSTRING('c',1000))");
1:         commit();        
1:         st.execute("insert into a values (4, PADSTRING('d',1000))");        
1:         
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,10)", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(2,6)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:     
1:         st.close();
1:     }
1:     
1:     /**
1:      *Cause an insert on a new page that inserts into the 1st slot on the btree 
1:      *page.
1:      * btree just before commit:
1:      * leftmost leaf: (1,6), (1,7)
1:      * next leaf:     (2,7), (2,6) 
1:      */
1:     public void testInsertOnNewPage() throws SQLException {
1:         Statement st = createStatement();        
1:         st.execute("create table a (a int, b varchar(1000))");
1:         st.execute("create unique index a_idx on a (a, b)");
1:         st.execute("insert into a values (1, PADSTRING('a',1000))");
1:         st.execute("insert into a values (2, PADSTRING('b',1000))");
1:         st.execute("insert into a values (3, PADSTRING('c',1000))");
1:         st.execute("insert into a values (4, PADSTRING('d',1000))");
1:         
1:         ResultSet rs = st.executeQuery("select a from a");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:                 {"2"},
1:                 {"3"},
1:                 {"4"}
1:         });
1:         
1:         st.execute("delete from a where a = 3");
1:         rs = st.executeQuery("select a from a");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:                 {"2"},
1:                 {"4"}
1:         });        
1:         commit();
1:         
1:         st.execute("insert into a values (3, PADSTRING('c',1000))");
1:         rs = st.executeQuery(
1:                 "select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "2", "IX", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(1,9)", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "X", "A", "(2,7)", "GRANT", "ACTIVE"}
1:         });
1: 
1:         st.close();
1:     }
1:     
1:     /**
1:      * Do full covered index scan.
1:      */
1:     public void testFullCoveredIndexScan() throws SQLException {
1:         Statement st = createStatement();
1:         createTableAandUniqueIndex(st);
1:         
1:         ResultSet rs = st.executeQuery("select a from a");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:                 {"2"},
1:                 {"3"},
1:                 {"4"}
1:         });
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "S", "A", "Tablelock", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:         
1:         st.close();
1:     }
1: 
1:     private void createTableAandUniqueIndex(Statement st) throws SQLException {
1:         st.execute("create table a (a int, b char(200))");
1:         st.execute("create unique index a_idx on a (a)");
1:         st.execute("insert into a values (1, 'a')");
1:         st.execute("insert into a values (2, 'b')");
1:         st.execute("insert into a values (3, 'c')");
1:         st.execute("insert into a values (4, 'd')");
1:         commit();        
1:     }
1:     
1:     /**
1:      * Do single probe into covered index (first key in table).
1:      * 
1:      */
1:     public void testSingleProbeIntoFirstKey() throws SQLException {
1:         Statement st = createStatement();
1:         createTableAandUniqueIndex(st);
1:         
1:         ResultSet rs = st.executeQuery("select a from a where a = 1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:         });
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,7)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Do single probe into covered index (last key in table).
1:      */
1:     public void testSingleProbeIntoLastKey() throws SQLException {
1:         Statement st = createStatement();
1:         createTableAandUniqueIndex(st);
1:         
1:         ResultSet rs = st.executeQuery("select a from a where a = 4");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"4"},
1:         });
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,10)", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Do set of range scans that all return 1 row from covered index.
1:      */
1:     public void testSetOfRangeScanFor1RowReturn() throws SQLException {
1:         Statement st = createStatement();
1:         createTableAandUniqueIndex(st);
1:         
1:         ResultSet rs = st.executeQuery("select a from a where a <= 1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}
1:         });
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,3)", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,7)", "GRANT", "ACTIVE"}
1:         });
1:         
1:         commit();
1:         
1:         
1:         rs = st.executeQuery("select a from a where a >= 2 and a < 3");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"2"}
1:         });
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,8)", "GRANT", "ACTIVE"}
1:         });
1:         
1:         commit();
1:         
1:         
1:         rs = st.executeQuery("select a from a where a > 3");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"4"}
1:         });
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,10)", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,9)", "GRANT", "ACTIVE"}
1:         });
1:         
1:         commit();
1:         
1:         st.close();        
1:     }
1:     
1:     /**
1:      * Do set of range scans that all return 0 row from covered index.
1:      */
1:     public void testSetOfRangeScanFor0RowReturn() throws SQLException {
1:         Statement st = createStatement();
1:         createTableAandUniqueIndex(st);
1:         
1:         ResultSet rs = st.executeQuery("select a from a where a < 1");
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,3)", "GRANT", "ACTIVE"}
1:         });
1:         
1:         commit();
1:         
1: 
1:         rs = st.executeQuery("select a from a where a > 4");
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,10)", "GRANT", "ACTIVE"}
1:         });
1:         
1:         commit();
1:         
1:         
1:         rs = st.executeQuery("select a from a where a > 2 and a < 3");
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         rs = st.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "IS", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "ROW", "1", "S", "A", "(1,8)", "GRANT", "ACTIVE"}
1:         });
1:         
1:         commit();
1:         
1:         st.close();        
1:     }
1:     
1:     /**
1:      * Verify that create index does table level locking.
1:      */
1:     public void testCreateIndexDoesTableLevelLocking() throws SQLException {
1:         Statement st = createStatement();
1:         st.execute("create table a (a int, b char(200))");
1:         st.execute("create table b (a int, b char(200))");
1:         st.execute("insert into a values (1, 'a')");
1:         st.execute("insert into a values (2, 'b')");
1:         st.execute("insert into a values (3, 'c')");
1:         st.execute("insert into a values (4, 'd')");
1:         commit();
1:         
1:         st.execute("create unique index a_idx on a (a)");
1:         
1:         ResultSet rs = st.executeQuery("select * from lock_table "
1:                 + "order by tabname, type desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "4", "S", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "1", "X", "A", "Tablelock", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1: 
1:         rs = st.executeQuery("select a from a");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:                 {"2"},
1:                 {"3"},
1:                 {"4"}
1:         });
1:         
1:         rs = st.executeQuery("select a from b");
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         commit();
1:         
1:         st.execute("drop index a_idx");
1:         dropTable("a");
1:         dropTable("b");
1:         
1:         
1:         st.close();
1:     }
1: }
============================================================================