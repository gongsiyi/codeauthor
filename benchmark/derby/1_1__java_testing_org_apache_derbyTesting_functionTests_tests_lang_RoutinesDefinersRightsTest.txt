1:9f60172: /*
1:9f60172: 
1:9f60172:   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RoutinesDefinersRightsTest
1:9f60172: 
1:9f60172:   Licensed to the Apache Software Foundation (ASF) under one or more
1:9f60172:   contributor license agreements.  See the NOTICE file distributed with
1:9f60172:   this work for additional information regarding copyright ownership.
1:9f60172:   The ASF licenses this file to you under the Apache License, Version 2.0
1:9f60172:   (the "License"); you may not use this file except in compliance with
1:9f60172:   the License.  You may obtain a copy of the License at
1:9f60172: 
1:9f60172:   http://www.apache.org/licenses/LICENSE-2.0
1:9f60172: 
1:9f60172:   Unless required by applicable law or agreed to in writing, software
1:9f60172:   distributed under the License is distributed on an "AS IS" BASIS,
1:9f60172:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9f60172:   See the License for the specific language governing permissions and
1:9f60172:   limitations under the License.
1:9f60172: 
1:9f60172: */
1:9f60172: 
1:9f60172: package org.apache.derbyTesting.functionTests.tests.lang;
1:9f60172: 
1:9f60172: import java.sql.Connection;
1:1ae02c9: import java.sql.DriverManager;
1:9f60172: import java.sql.PreparedStatement;
1:9f60172: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:9f60172: import junit.framework.Test;
1:9f60172: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:9f60172: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:9f60172: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:9f60172: 
1:9f60172: /**
1:9f60172:  * Test that routines declared with EXTERNAL SECURITY DEFINER/INVOKER behaves
1:9f60172:  * correctly. In addition to tests found here, see also the test in
1:9f60172:  * org.apache.derbyTesting.functionTests.tests.upgradeTests.
1:9f60172:  * Changes10_7#testExternalSecuritySpecification, which checks that the feature
1:9f60172:  * will not work if SQL authorization is not enabled.
1:9f60172:  *
1:9f60172:  */
1:9f60172: public class RoutinesDefinersRightsTest extends BaseJDBCTestCase
1:9f60172: {
1:9f60172:     private final static String pwSuffix = "pwSuffix";
1:9f60172: 
1:9f60172:     /* SQL states */
1:9f60172:     private final static String NOEXECUTEPERMISSION  = "42504";
1:9f60172:     private final static String NOCOLUMNPERMISSION = "42502";
1:9f60172:     private final static String MULTIPLE_ELEMENTS = "42613";
1:9f60172: 
1:9f60172:     // job categories
1:9f60172:     private final static int BOSS = 0;
1:9f60172:     private final static int MIDDLEMANAGER = 1;
1:9f60172:     private final static int FOOTSOLDIER = 2;
1:9f60172: 
1:9f60172: 
1:9f60172:     private final static String[] users = {"test_dbo", "PHB", "Dilbert"};
1:9f60172:     private final static double[] wages = {1000.0, 500.0, 100.0};
1:9f60172:     private final static int[] categories = {BOSS, MIDDLEMANAGER, FOOTSOLDIER};
1:9f60172:     /**
1:9f60172:      * Create a new instance of RoutinesDefinersRightsTest.
1:9f60172:      *
1:9f60172:      * @param name Fixture name
1:9f60172:      */
1:9f60172:     public RoutinesDefinersRightsTest(String name)
1:9f60172:     {
1:9f60172:         super(name);
1:9f60172:     }
1:1eeea61: 
1:9f60172: 
1:1eeea61:     /**
1:9f60172:      * Construct top level suite in this JUnit test
1:9f60172:      *
1:9f60172:      * @return A suite containing embedded and client suites.
1:9f60172:      */
1:9f60172:     public static Test suite()
1:9f60172:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("RoutinesDefinersRightsTest");
1:9f60172: 
1:9f60172:         if (!JDBC.vmSupportsJSR169()) {
1:9f60172:             // JSR169 cannot run with tests with stored procedures
1:9f60172:             // that do database access - for they require a
1:9f60172:             // DriverManager connection to jdbc:default:connection;
1:9f60172:             // DriverManager is not supported with JSR169.
1:9f60172:             suite.addTest(makeSuite());
1:9f60172: 
1:1eeea61:             suite.addTest(
1:1eeea61:                 TestConfiguration.clientServerDecorator(makeSuite()));
1:9f60172:         }
1:9f60172: 
1:9f60172: 
1:9f60172:         return suite;
1:9f60172:     }
1:9f60172: 
1:9f60172:     /**
1:9f60172:      * Construct suite of tests
1:9f60172:      *
1:9f60172:      * @return A suite containing the test cases.
1:9f60172:      */
1:9f60172:     private static Test makeSuite()
1:9f60172:     {
1:9f60172:         /* Tests running with sql authorization set.  First decorate
1:9f60172:          * with clean database, then with authentication +
1:9f60172:          * sqlAuthorization.
1:9f60172:          */
1:9f60172:         Test clean = new CleanDatabaseTestSetup(
1:1ae02c9:             new BaseTestSuite(RoutinesDefinersRightsTest.class)) {
1:9f60172:                 protected void decorateSQL(Statement s)
1:9f60172:                         throws SQLException {
1:9f60172: 
1:9f60172:                     s.execute("create role middleManager");
1:9f60172:                     s.execute("create table s1.wages(employeeId int," +
1:9f60172:                               "                   category int," +
1:9f60172:                               "                   salary double," +
1:9f60172:                               "                   name VARCHAR(20))");
1:9f60172:                     PreparedStatement ps = s.getConnection().prepareStatement(
1:9f60172:                         "insert into s1.wages values (?,?,?,?)");
1:9f60172: 
1:9f60172:                     for (int i=BOSS; i <= FOOTSOLDIER; i++) {
1:9f60172:                         ps.setInt(1, 1000 + i);
1:9f60172:                         ps.setInt(2, i);
1:9f60172:                         ps.setDouble(3, wages[i]);
1:9f60172:                         ps.setString(4, users[i]);
1:9f60172:                         ps.execute();
1:9f60172:                     }
1:9f60172: 
1:9f60172:                     ps.close();
1:9f60172: 
1:9f60172:                     s.execute
1:9f60172:                         ("create function s1.lookupWageFootSoldier(int) " +
1:9f60172:                          "returns double " +
1:9f60172:                          "language java parameter style java external name " +
1:9f60172:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                          "RoutinesDefinersRightsTest.lookupWageFootSoldier' " +
1:9f60172:                          "EXTERNAL SECURITY DEFINER " +
1:9f60172:                          "reads sql data called on null input");
1:9f60172: 
1:9f60172:                     s.execute
1:1eeea61:                         ("create procedure s1.updateWage() " +
1:1eeea61:                          "language java parameter style java " +
1:1eeea61:                          "modifies sql data " +
1:1eeea61:                          "external name " +
1:1eeea61:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:1eeea61:                          "RoutinesDefinersRightsTest.updateWage' " +
1:1eeea61:                          "EXTERNAL SECURITY DEFINER ");
1:1eeea61: 
1:1eeea61:                     s.execute
1:9f60172:                         ("grant execute on function s1.lookupWageFootSoldier " +
1:9f60172:                          "   to phb");
1:9f60172: 
1:9f60172:                     s.execute
1:1eeea61:                         ("grant execute on procedure s1.updateWage " +
1:1eeea61:                          "   to phb");
1:1eeea61: 
1:1eeea61:                     s.execute
1:9f60172:                         ("create function s1.lookupWageFootSoldierI(int) " +
1:9f60172:                          "returns double " +
1:9f60172:                          "language java parameter style java external name " +
1:9f60172:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                          "RoutinesDefinersRightsTest.lookupWageFootSoldier' " +
1:9f60172:                          "EXTERNAL SECURITY INVOKER " +
1:9f60172:                          "reads sql data called on null input");
1:9f60172: 
1:9f60172:                     s.execute
1:9f60172:                         ("grant execute on function " +
1:9f60172:                          "    s1.lookupWageFootSoldierI to phb");
1:9f60172: 
1:9f60172:                     s.execute
1:9f60172:                         ("create procedure s1.spTestBuiltins() " +
1:9f60172:                          "language java parameter style java external name " +
1:9f60172:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                          "RoutinesDefinersRightsTest.spTestBuiltins' " +
1:9f60172:                          "EXTERNAL SECURITY DEFINER " +
1:9f60172:                          "reads sql data");
1:9f60172: 
1:9f60172:                     s.execute
1:9f60172:                         ("grant execute on procedure s1.spTestBuiltins " +
1:9f60172:                          "   to phb");
1:9f60172: 
1:9f60172:                     // Table function
1:9f60172:                     s.execute
1:9f60172:                         ("create function s1.selectFootSoldiers() " +
1:9f60172:                          "returns table (" +
1:9f60172:                          "    employeeId int," +
1:9f60172:                          "    category int," +
1:9f60172:                          "    salary double," +
1:9f60172:                          "    name varchar(20))" +
1:9f60172:                          "language java parameter style " +
1:9f60172:                          "    derby_jdbc_result_set " +
1:9f60172:                          "external name " +
1:9f60172:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                          "RoutinesDefinersRightsTest.selectFootSoldiers' " +
1:9f60172:                          "EXTERNAL SECURITY DEFINER " +
1:9f60172:                          "reads sql data");
1:9f60172: 
1:9f60172:                     // PHB needs to set his role to be able to use
1:9f60172:                     // s1.selectFootSoldiers. Just to vary a bit..
1:9f60172:                     s.execute
1:9f60172:                         ("grant execute on function s1.selectFootSoldiers " +
1:9f60172:                          "    to middleManager");
1:9f60172:                     s.execute
1:9f60172:                         ("grant middleManager to phb");
1:9f60172: 
1:9f60172:                     s.execute
1:9f60172:                         ("create function s1.selectFootSoldiersI() " +
1:9f60172:                          "returns table (" +
1:9f60172:                          "    employeeId int," +
1:9f60172:                          "    category int," +
1:9f60172:                          "    salary double," +
1:9f60172:                          "    name varchar(20))" +
1:9f60172:                          "language java parameter style " +
1:9f60172:                          "    derby_jdbc_result_set " +
1:9f60172:                          "external name " +
1:9f60172:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                          "RoutinesDefinersRightsTest.selectFootSoldiers' " +
1:9f60172:                          "EXTERNAL SECURITY INVOKER " +
1:9f60172:                          "reads sql data");
1:9f60172:                     s.execute
1:9f60172:                         ("grant execute on function s1.selectFootSoldiersI " +
1:9f60172:                          "    to middleManager");
1:9f60172: 
1:9f60172:                     s.execute
1:9f60172:                         ("create schema phb authorization phb");
1:9f60172:                     s.execute
1:9f60172:                         ("create function phb.lookupDilbertWage() " +
1:9f60172:                          "returns double " +
1:9f60172:                          "language java parameter style java external name " +
1:9f60172:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                          "RoutinesDefinersRightsTest.lookupDilbertWage' " +
1:9f60172:                          "EXTERNAL SECURITY DEFINER " +
1:9f60172:                          "reads sql data called on null input");
1:9f60172:                     s.execute
1:9f60172:                         ("grant execute on function phb.lookupDilbertWage " +
1:9f60172:                          "    to dilbert");
1:9f60172: 
1:9f60172:                     // Check confliciting clauses
1:9f60172:                     assertStatementError(
1:9f60172:                         new String[]{MULTIPLE_ELEMENTS},
1:9f60172:                         s,
1:9f60172:                         "create function phb.lookupDilbertWage() " +
1:9f60172:                         "returns double " +
1:9f60172:                         "language java parameter style java external name " +
1:9f60172:                         "'org.apache.derbyTesting.functionTests.tests.lang." +
1:9f60172:                         "RoutinesDefinersRightsTest.lookupDilbertWage' " +
1:9f60172:                         "EXTERNAL SECURITY DEFINER " +
1:9f60172:                         "EXTERNAL SECURITY INVOKER " +
1:9f60172:                         "reads sql data called on null input");
1:9f60172:                 }
1:9f60172:             };
1:9f60172: 
1:9f60172:         return
1:9f60172:             TestConfiguration.sqlAuthorizationDecorator(
1:9f60172:                     DatabasePropertyTestSetup.builtinAuthentication(
1:9f60172:                         clean, users, pwSuffix));
1:9f60172:     }
1:9f60172: 
1:9f60172: 
1:9f60172:     public void testDefinersRights() throws SQLException
1:9f60172:     {
1:9f60172:         Connection c = null;
1:9f60172:         ResultSet rs = null;
1:9f60172:         Statement stm = null;
1:9f60172: 
1:9f60172:         // Shut down database, just so we are sure the routine info is
1:9f60172:         // persisted into the on-disk dictionary correctly before we try to use
1:9f60172:         // it.
1:9f60172:         TestConfiguration.getCurrent().shutdownDatabase();
1:9f60172: 
1:9f60172:         // Try as vainly as dilbert to execute lookupWageFootSoldier
1:9f60172:         c = openUserConnection("Dilbert");
1:9f60172:         stm = c.createStatement();
1:9f60172:         assertStatementError(
1:9f60172:             new String[]{NOEXECUTEPERMISSION},
1:9f60172:             stm,
1:9f60172:             "values s1.lookupWageFootSoldier(1002)");
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:         // Try as PHB
1:9f60172:         c = openUserConnection("PHB");
1:9f60172:         stm = c.createStatement();
1:9f60172:         rs = stm.executeQuery("values s1.lookupWageFootSoldier(1002)");
1:9f60172:         JDBC.assertSingleValueResultSet(rs, "100.0");
1:1eeea61: 
1:1eeea61:         // Try as PHB to update, delete and insert on a result set
1:1eeea61:         stm.executeUpdate("call s1.updateWage()");
1:1eeea61: 
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:         // dbo can execute lookupWageFootSoldier, since he has select
1:9f60172:         // privileges on the wages table.
1:9f60172:         Connection dboConn = getConnection();
1:9f60172:         Statement dbos = dboConn.createStatement();
1:9f60172: 
1:9f60172:         rs = dbos.executeQuery("values s1.lookupWageFootSoldier(1002)");
1:9f60172:         JDBC.assertSingleValueResultSet(rs, "100.0");
1:9f60172: 
1:9f60172:         // We see that the method will not return wages for anything but foot
1:9f60172:         // soldiers, even for the dbo:
1:9f60172:         rs = dbos.executeQuery("values s1.lookupWageFootSoldier(1001)");
1:9f60172:         JDBC.assertSingleValueResultSet(rs, "-1.0");
1:9f60172: 
1:9f60172:         dbos.close();
1:9f60172:         dboConn.close();
1:9f60172: 
1:9f60172:         // ----------------------------------------
1:9f60172:         // Now try with a table function
1:9f60172: 
1:9f60172:         c = openUserConnection("PHB");
1:9f60172: 
1:9f60172:         stm = c.createStatement();
1:9f60172:         stm.executeUpdate("set role middlemanager");
1:9f60172:         rs = stm.executeQuery(
1:9f60172:             "select * from table (s1.selectFootSoldiers()) as t");
1:9f60172:         JDBC.assertFullResultSet(
1:9f60172:             rs,
1:9f60172:             new String[][]{{"1002", "2", "100.0", "Dilbert"}});
1:9f60172: 
1:9f60172:         // Check that user and role is unchanged after call
1:9f60172:         rs = stm.executeQuery(
1:9f60172:             "values (current_user, session_user, current_role)");
1:9f60172:         JDBC.assertFullResultSet(
1:9f60172:             rs,
1:9f60172:             new String[][]{{"PHB", "PHB", "\"MIDDLEMANAGER\""}});
1:9f60172: 
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:         // ------------------------------------
1:9f60172:         // Try with two levels of routines with different definers
1:9f60172:         c = openUserConnection("Dilbert");
1:9f60172:         stm = c.createStatement();
1:9f60172:         rs = stm.executeQuery("values phb.lookupDilbertWage()");
1:9f60172:         JDBC.assertSingleValueResultSet(rs, "100.0");
1:9f60172: 
1:9f60172:         // sanity when we return
1:9f60172:         rs = stm.executeQuery(
1:9f60172:             "values (current_user, session_user, current_role)");
1:9f60172:         JDBC.assertFullResultSet(
1:9f60172:             rs,
1:9f60172:             new String[][]{{"DILBERT", "DILBERT", null}});
1:9f60172: 
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:     }
1:9f60172: 
1:9f60172:     public void testBuiltins() throws SQLException{
1:9f60172:         Connection c = openUserConnection("PHB");
1:9f60172:         Statement stm = c.createStatement();
1:9f60172:         stm.executeUpdate("set role middlemanager");
1:9f60172:         stm.executeUpdate("call s1.spTestBuiltins()");
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172:     }
1:9f60172: 
1:9f60172: 
1:9f60172:     public void testInvokersRights() throws SQLException{
1:9f60172:         Connection c = null;
1:9f60172:         ResultSet rs = null;
1:9f60172:         Statement stm = null;
1:9f60172: 
1:9f60172:         // Try as vainly as dilbert to execute lookupWageFootSoldier
1:9f60172:         c = openUserConnection("Dilbert");
1:9f60172:         stm = c.createStatement();
1:9f60172:         assertStatementError(
1:9f60172:             new String[]{NOEXECUTEPERMISSION},
1:9f60172:             stm,
1:9f60172:             "values s1.lookupWageFootSoldierI(1002)");
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:         // Try as PHB, vainly too, since no definer's rights now.
1:9f60172:         c = openUserConnection("PHB");
1:9f60172:         stm = c.createStatement();
1:9f60172:         assertStatementError(
1:9f60172:             new String[]{NOCOLUMNPERMISSION},
1:9f60172:             stm,
1:9f60172:             "values s1.lookupWageFootSoldierI(1002)");
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:         // dbo can execute lookupWageFootSoldier, since she has select
1:9f60172:         // privileges on the wages table.
1:9f60172:         Connection dboConn = getConnection();
1:9f60172:         Statement dbos = dboConn.createStatement();
1:9f60172: 
1:9f60172:         rs = dbos.executeQuery("values s1.lookupWageFootSoldierI(1002)");
1:9f60172:         JDBC.assertSingleValueResultSet(rs, "100.0");
1:9f60172: 
1:9f60172:         dbos.close();
1:9f60172:         dboConn.close();
1:9f60172: 
1:9f60172:         // ----------------------------------------
1:9f60172:         // Now try with a table function
1:9f60172: 
1:9f60172:         c = openUserConnection("PHB");
1:9f60172: 
1:9f60172:         stm = c.createStatement();
1:9f60172:         stm.executeUpdate("set role middlemanager");
1:9f60172:         assertStatementError(
1:9f60172:             new String[]{NOCOLUMNPERMISSION},
1:9f60172:             stm,
1:9f60172:             "select * from table (s1.selectFootSoldiersI()) as t");
1:9f60172: 
1:9f60172:         // Check that user and role is unchanged after failed call
1:9f60172:         rs = stm.executeQuery(
1:9f60172:             "values (current_user, session_user, current_role)");
1:9f60172:         JDBC.assertFullResultSet(
1:9f60172:             rs,
1:9f60172:             new String[][]{{"PHB", "PHB", "\"MIDDLEMANAGER\""}});
1:9f60172: 
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:     }
1:9f60172: 
1:9f60172:     public static double lookupWageFootSoldier(int employee)
1:9f60172:             throws SQLException
1:9f60172:     {
1:9f60172:         Connection c = null;
1:9f60172: 
1:9f60172:         c = DriverManager.getConnection("jdbc:default:connection");
1:9f60172:         Statement cStmt = c.createStatement();
1:9f60172: 
1:9f60172:         // Can only look up wages of foot soldiers
1:9f60172:         ResultSet rs = cStmt.executeQuery(
1:9f60172:             "select salary from s1.wages where employeeId=" +
1:9f60172:             employee + " and category = " + FOOTSOLDIER);
1:9f60172: 
1:9f60172:         if (rs.next()) {
1:9f60172:             double result = rs.getDouble(1);
1:9f60172:             cStmt.close();
1:9f60172:             rs.close();
1:9f60172:             c.close();
1:9f60172:             return result;
1:9f60172:         } else {
1:9f60172:             cStmt.close();
1:9f60172:             rs.close();
1:9f60172:             c.close();
1:9f60172:             return -1.0;
1:9f60172:         }
1:9f60172:     }
1:9f60172: 
1:9f60172: 
1:9f60172:     /**
1:1eeea61:      * Test that PHB can actually update using {@code ResultSet.insertRow},
1:1eeea61:      * {@code ResultSet.updateRow} and {@code ResultSet.deleteRow}.
1:1eeea61:      * <p/>
1:1eeea61:      * Aside: This test is somewhat artificial here, since the middle manager
1:1eeea61:      * would not be allowed to do this, presumably; just added here to test
1:1eeea61:      * this functionality (which was initially broken by the first patch for
1:1eeea61:      * DERBY-4551).
1:1eeea61:      * <p/>
1:1eeea61:      * The problem was that the nested statement contexts used for SQL
1:1eeea61:      * substatements generated for these ResultSet operations were not
1:1eeea61:      * correctly set up, so the effective user id would not be the DEFINER
1:1eeea61:      * (DBO), and authorization would fail. Cf DERBY-4551 and DERBY-3327
1:1eeea61:      * for more detail.
1:1eeea61:      */
1:1eeea61:     public static void updateWage()
1:1eeea61:             throws SQLException
1:1eeea61:     {
1:1eeea61:         Connection c = null;
1:1eeea61: 
1:1eeea61:         c = DriverManager.getConnection("jdbc:default:connection");
1:1eeea61:         Statement cStmt = c.createStatement(
1:1eeea61:             ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1eeea61:             ResultSet.CONCUR_UPDATABLE);
1:1eeea61: 
1:1eeea61:         // Try nested statements by inserting, updating and deleting a bogus
1:1eeea61:         // row
1:1eeea61:         ResultSet rs = cStmt.executeQuery(
1:1eeea61:             "select * from s1.wages");
1:1eeea61:         assertTrue(rs.isBeforeFirst());
1:1eeea61:         rs.moveToInsertRow();
1:1eeea61:         rs.updateInt("EMPLOYEEID", 666);
1:1eeea61:         rs.updateInt("CATEGORY", 667);
1:1eeea61:         rs.updateDouble("SALARY", 666.0);
1:1eeea61:         rs.updateString("NAME", "N.N.");
1:1eeea61:         rs.insertRow();
1:1eeea61:         rs.close();
1:1eeea61: 
1:1eeea61:         rs = cStmt.executeQuery(
1:1eeea61:             "select * from s1.wages where name = 'N.N.'");
1:1eeea61:         rs.next();
1:1eeea61:         rs.updateDouble("SALARY", 666.1);
1:1eeea61:         rs.updateRow();
1:1eeea61:         rs.close();
1:1eeea61: 
1:1eeea61:         rs = cStmt.executeQuery(
1:1eeea61:             "select * from s1.wages where name = 'N.N.'");
1:1eeea61:         rs.next();
1:1eeea61:         rs.deleteRow();
1:1eeea61:         rs.close();
1:1eeea61: 
1:1eeea61:         cStmt.close();
1:1eeea61:         c.close();
1:1eeea61:     }
1:1eeea61: 
1:1eeea61: 
1:9f60172:     public static ResultSet selectFootSoldiers()
1:9f60172:             throws SQLException
1:9f60172:     {
1:9f60172:         Connection c = null;
1:9f60172: 
1:9f60172:         c = DriverManager.getConnection("jdbc:default:connection");
1:9f60172:         Statement cStmt = c.createStatement();
1:9f60172: 
1:9f60172:         // Can only look up wages of foot soldiers
1:9f60172:         ResultSet rs = cStmt.executeQuery(
1:9f60172:             "select * from s1.wages where category = " +
1:9f60172:             FOOTSOLDIER);
1:9f60172: 
1:9f60172:         return rs;
1:9f60172:     }
1:9f60172: 
1:9f60172: 
1:9f60172:     public static double lookupDilbertWage()
1:9f60172:             throws SQLException
1:9f60172:     {
1:9f60172:         Connection c = null;
1:9f60172: 
1:9f60172:         c = DriverManager.getConnection("jdbc:default:connection");
1:9f60172:         Statement stm = c.createStatement();
1:9f60172: 
1:9f60172:         // We are executing as middle manager so we can look up Dilberts wage
1:9f60172:         // for him.
1:9f60172:         c.commit(); // Need to be no transaction active when we set role
1:9f60172:         stm.executeUpdate("set role middlemanager");
1:9f60172: 
1:9f60172:         // Check that definer is PHB even though we created function as dbo.
1:9f60172:         ResultSet rs = stm.executeQuery(
1:9f60172:             "values (current_user, session_user, current_role)");
1:9f60172: 
1:9f60172:         JDBC.assertFullResultSet(
1:9f60172:             rs,
1:9f60172:             new String[][]{{"PHB", "DILBERT", "\"MIDDLEMANAGER\""}});
1:9f60172: 
1:9f60172:         rs = stm.executeQuery(
1:9f60172:             "select salary from table (s1.selectFootSoldiers()) as t " +
1:9f60172:             "    where name='Dilbert'");
1:9f60172:         rs.next();
1:9f60172:         double result = rs.getDouble(1);
1:9f60172: 
1:9f60172:         rs.close();
1:9f60172:         stm.close();
1:9f60172:         c.close();
1:9f60172: 
1:9f60172:         return result;
1:9f60172:     }
1:9f60172: 
1:9f60172: 
1:9f60172:     public static void spTestBuiltins()
1:9f60172:             throws SQLException
1:9f60172:     {
1:9f60172:         Connection c = null;
1:9f60172: 
1:9f60172:         c = DriverManager.getConnection("jdbc:default:connection");
1:9f60172:         Statement cStmt = c.createStatement();
1:9f60172: 
1:9f60172:         ResultSet rs = cStmt.executeQuery(
1:9f60172:             "values (user, current_user, current schema, " +
1:9f60172:             "        session_user, current_role)");
1:9f60172:         JDBC.assertFullResultSet(
1:9f60172:             rs,
1:9f60172:             new String[][]{{"TEST_DBO", "TEST_DBO", "TEST_DBO", "PHB", null}});
1:9f60172: 
1:9f60172:         cStmt.close();
1:9f60172:         c.close();
1:9f60172:     }
1:9f60172: }
1:9f60172: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("RoutinesDefinersRightsTest");
/////////////////////////////////////////////////////////////////////////
1:             new BaseTestSuite(RoutinesDefinersRightsTest.class)) {
commit:1eeea61
/////////////////////////////////////////////////////////////////////////
1:             suite.addTest(
1:                 TestConfiguration.clientServerDecorator(makeSuite()));
/////////////////////////////////////////////////////////////////////////
1:                         ("create procedure s1.updateWage() " +
1:                          "language java parameter style java " +
1:                          "modifies sql data " +
1:                          "external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.updateWage' " +
1:                          "EXTERNAL SECURITY DEFINER ");
1: 
1:                     s.execute
1:                         ("grant execute on procedure s1.updateWage " +
1:                          "   to phb");
1: 
1:                     s.execute
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Try as PHB to update, delete and insert on a result set
1:         stm.executeUpdate("call s1.updateWage()");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that PHB can actually update using {@code ResultSet.insertRow},
1:      * {@code ResultSet.updateRow} and {@code ResultSet.deleteRow}.
1:      * <p/>
1:      * Aside: This test is somewhat artificial here, since the middle manager
1:      * would not be allowed to do this, presumably; just added here to test
1:      * this functionality (which was initially broken by the first patch for
1:      * DERBY-4551).
1:      * <p/>
1:      * The problem was that the nested statement contexts used for SQL
1:      * substatements generated for these ResultSet operations were not
1:      * correctly set up, so the effective user id would not be the DEFINER
1:      * (DBO), and authorization would fail. Cf DERBY-4551 and DERBY-3327
1:      * for more detail.
1:      */
1:     public static void updateWage()
1:             throws SQLException
1:     {
1:         Connection c = null;
1: 
1:         c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement cStmt = c.createStatement(
1:             ResultSet.TYPE_SCROLL_INSENSITIVE,
1:             ResultSet.CONCUR_UPDATABLE);
1: 
1:         // Try nested statements by inserting, updating and deleting a bogus
1:         // row
1:         ResultSet rs = cStmt.executeQuery(
1:             "select * from s1.wages");
1:         assertTrue(rs.isBeforeFirst());
1:         rs.moveToInsertRow();
1:         rs.updateInt("EMPLOYEEID", 666);
1:         rs.updateInt("CATEGORY", 667);
1:         rs.updateDouble("SALARY", 666.0);
1:         rs.updateString("NAME", "N.N.");
1:         rs.insertRow();
1:         rs.close();
1: 
1:         rs = cStmt.executeQuery(
1:             "select * from s1.wages where name = 'N.N.'");
1:         rs.next();
1:         rs.updateDouble("SALARY", 666.1);
1:         rs.updateRow();
1:         rs.close();
1: 
1:         rs = cStmt.executeQuery(
1:             "select * from s1.wages where name = 'N.N.'");
1:         rs.next();
1:         rs.deleteRow();
1:         rs.close();
1: 
1:         cStmt.close();
1:         c.close();
1:     }
1: 
1: 
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RoutinesDefinersRightsTest
1: 
1:   Licensed to the Apache Software Foundation (ASF) under one or more
1:   contributor license agreements.  See the NOTICE file distributed with
1:   this work for additional information regarding copyright ownership.
1:   The ASF licenses this file to you under the Apache License, Version 2.0
1:   (the "License"); you may not use this file except in compliance with
1:   the License.  You may obtain a copy of the License at
1: 
1:   http://www.apache.org/licenses/LICENSE-2.0
1: 
1:   Unless required by applicable law or agreed to in writing, software
1:   distributed under the License is distributed on an "AS IS" BASIS,
1:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:   See the License for the specific language governing permissions and
1:   limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.SQLException;
1: import java.sql.Connection;
0: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.DriverManager;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
1:  * Test that routines declared with EXTERNAL SECURITY DEFINER/INVOKER behaves
1:  * correctly. In addition to tests found here, see also the test in
1:  * org.apache.derbyTesting.functionTests.tests.upgradeTests.
1:  * Changes10_7#testExternalSecuritySpecification, which checks that the feature
1:  * will not work if SQL authorization is not enabled.
1:  *
1:  */
1: public class RoutinesDefinersRightsTest extends BaseJDBCTestCase
1: {
1:     private final static String pwSuffix = "pwSuffix";
1: 
1:     /* SQL states */
1:     private final static String NOEXECUTEPERMISSION  = "42504";
1:     private final static String NOCOLUMNPERMISSION = "42502";
1:     private final static String MULTIPLE_ELEMENTS = "42613";
1: 
1:     // job categories
1:     private final static int BOSS = 0;
1:     private final static int MIDDLEMANAGER = 1;
1:     private final static int FOOTSOLDIER = 2;
1: 
1: 
1:     private final static String[] users = {"test_dbo", "PHB", "Dilbert"};
1:     private final static double[] wages = {1000.0, 500.0, 100.0};
1:     private final static int[] categories = {BOSS, MIDDLEMANAGER, FOOTSOLDIER};
1:     /**
1:      * Create a new instance of RoutinesDefinersRightsTest.
1:      *
1:      * @param name Fixture name
1:      */
1:     public RoutinesDefinersRightsTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      *
1:      * @return A suite containing embedded and client suites.
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("RoutinesDefinersRightsTest");
1: 
1:         if (!JDBC.vmSupportsJSR169()) {
1:             // JSR169 cannot run with tests with stored procedures
1:             // that do database access - for they require a
1:             // DriverManager connection to jdbc:default:connection;
1:             // DriverManager is not supported with JSR169.
1:             suite.addTest(makeSuite());
1: 
0:             // suite.addTest(
0:             //     TestConfiguration.clientServerDecorator(makeSuite()));
1:         }
1: 
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * Construct suite of tests
1:      *
1:      * @return A suite containing the test cases.
1:      */
1:     private static Test makeSuite()
1:     {
1:         /* Tests running with sql authorization set.  First decorate
1:          * with clean database, then with authentication +
1:          * sqlAuthorization.
1:          */
1:         Test clean = new CleanDatabaseTestSetup(
0:             new TestSuite(RoutinesDefinersRightsTest.class)) {
1:                 protected void decorateSQL(Statement s)
1:                         throws SQLException {
1: 
1:                     s.execute("create role middleManager");
1:                     s.execute("create table s1.wages(employeeId int," +
1:                               "                   category int," +
1:                               "                   salary double," +
1:                               "                   name VARCHAR(20))");
1:                     PreparedStatement ps = s.getConnection().prepareStatement(
1:                         "insert into s1.wages values (?,?,?,?)");
1: 
1:                     for (int i=BOSS; i <= FOOTSOLDIER; i++) {
1:                         ps.setInt(1, 1000 + i);
1:                         ps.setInt(2, i);
1:                         ps.setDouble(3, wages[i]);
1:                         ps.setString(4, users[i]);
1:                         ps.execute();
1:                     }
1: 
1:                     ps.close();
1: 
1:                     s.execute
1:                         ("create function s1.lookupWageFootSoldier(int) " +
1:                          "returns double " +
1:                          "language java parameter style java external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.lookupWageFootSoldier' " +
1:                          "EXTERNAL SECURITY DEFINER " +
1:                          "reads sql data called on null input");
1: 
1:                     s.execute
1:                         ("grant execute on function s1.lookupWageFootSoldier " +
1:                          "   to phb");
1: 
1:                     s.execute
1:                         ("create function s1.lookupWageFootSoldierI(int) " +
1:                          "returns double " +
1:                          "language java parameter style java external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.lookupWageFootSoldier' " +
1:                          "EXTERNAL SECURITY INVOKER " +
1:                          "reads sql data called on null input");
1: 
1:                     s.execute
1:                         ("grant execute on function " +
1:                          "    s1.lookupWageFootSoldierI to phb");
1: 
1:                     s.execute
1:                         ("create procedure s1.spTestBuiltins() " +
1:                          "language java parameter style java external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.spTestBuiltins' " +
1:                          "EXTERNAL SECURITY DEFINER " +
1:                          "reads sql data");
1: 
1:                     s.execute
1:                         ("grant execute on procedure s1.spTestBuiltins " +
1:                          "   to phb");
1: 
1:                     // Table function
1:                     s.execute
1:                         ("create function s1.selectFootSoldiers() " +
1:                          "returns table (" +
1:                          "    employeeId int," +
1:                          "    category int," +
1:                          "    salary double," +
1:                          "    name varchar(20))" +
1:                          "language java parameter style " +
1:                          "    derby_jdbc_result_set " +
1:                          "external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.selectFootSoldiers' " +
1:                          "EXTERNAL SECURITY DEFINER " +
1:                          "reads sql data");
1: 
1:                     // PHB needs to set his role to be able to use
1:                     // s1.selectFootSoldiers. Just to vary a bit..
1:                     s.execute
1:                         ("grant execute on function s1.selectFootSoldiers " +
1:                          "    to middleManager");
1:                     s.execute
1:                         ("grant middleManager to phb");
1: 
1:                     s.execute
1:                         ("create function s1.selectFootSoldiersI() " +
1:                          "returns table (" +
1:                          "    employeeId int," +
1:                          "    category int," +
1:                          "    salary double," +
1:                          "    name varchar(20))" +
1:                          "language java parameter style " +
1:                          "    derby_jdbc_result_set " +
1:                          "external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.selectFootSoldiers' " +
1:                          "EXTERNAL SECURITY INVOKER " +
1:                          "reads sql data");
1:                     s.execute
1:                         ("grant execute on function s1.selectFootSoldiersI " +
1:                          "    to middleManager");
1: 
1:                     s.execute
1:                         ("create schema phb authorization phb");
1:                     s.execute
1:                         ("create function phb.lookupDilbertWage() " +
1:                          "returns double " +
1:                          "language java parameter style java external name " +
1:                          "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                          "RoutinesDefinersRightsTest.lookupDilbertWage' " +
1:                          "EXTERNAL SECURITY DEFINER " +
1:                          "reads sql data called on null input");
1:                     s.execute
1:                         ("grant execute on function phb.lookupDilbertWage " +
1:                          "    to dilbert");
1: 
1:                     // Check confliciting clauses
1:                     assertStatementError(
1:                         new String[]{MULTIPLE_ELEMENTS},
1:                         s,
1:                         "create function phb.lookupDilbertWage() " +
1:                         "returns double " +
1:                         "language java parameter style java external name " +
1:                         "'org.apache.derbyTesting.functionTests.tests.lang." +
1:                         "RoutinesDefinersRightsTest.lookupDilbertWage' " +
1:                         "EXTERNAL SECURITY DEFINER " +
1:                         "EXTERNAL SECURITY INVOKER " +
1:                         "reads sql data called on null input");
1:                 }
1:             };
1: 
1:         return
1:             TestConfiguration.sqlAuthorizationDecorator(
1:                     DatabasePropertyTestSetup.builtinAuthentication(
1:                         clean, users, pwSuffix));
1:     }
1: 
1: 
1:     public void testDefinersRights() throws SQLException
1:     {
1:         Connection c = null;
1:         ResultSet rs = null;
1:         Statement stm = null;
1: 
1:         // Shut down database, just so we are sure the routine info is
1:         // persisted into the on-disk dictionary correctly before we try to use
1:         // it.
1:         TestConfiguration.getCurrent().shutdownDatabase();
1: 
1:         // Try as vainly as dilbert to execute lookupWageFootSoldier
1:         c = openUserConnection("Dilbert");
1:         stm = c.createStatement();
1:         assertStatementError(
1:             new String[]{NOEXECUTEPERMISSION},
1:             stm,
1:             "values s1.lookupWageFootSoldier(1002)");
1:         stm.close();
1:         c.close();
1: 
1:         // Try as PHB
1:         c = openUserConnection("PHB");
1:         stm = c.createStatement();
1:         rs = stm.executeQuery("values s1.lookupWageFootSoldier(1002)");
1:         JDBC.assertSingleValueResultSet(rs, "100.0");
1:         stm.close();
1:         c.close();
1: 
1:         // dbo can execute lookupWageFootSoldier, since he has select
1:         // privileges on the wages table.
1:         Connection dboConn = getConnection();
1:         Statement dbos = dboConn.createStatement();
1: 
1:         rs = dbos.executeQuery("values s1.lookupWageFootSoldier(1002)");
1:         JDBC.assertSingleValueResultSet(rs, "100.0");
1: 
1:         // We see that the method will not return wages for anything but foot
1:         // soldiers, even for the dbo:
1:         rs = dbos.executeQuery("values s1.lookupWageFootSoldier(1001)");
1:         JDBC.assertSingleValueResultSet(rs, "-1.0");
1: 
1:         dbos.close();
1:         dboConn.close();
1: 
1:         // ----------------------------------------
1:         // Now try with a table function
1: 
1:         c = openUserConnection("PHB");
1: 
1:         stm = c.createStatement();
1:         stm.executeUpdate("set role middlemanager");
1:         rs = stm.executeQuery(
1:             "select * from table (s1.selectFootSoldiers()) as t");
1:         JDBC.assertFullResultSet(
1:             rs,
1:             new String[][]{{"1002", "2", "100.0", "Dilbert"}});
1: 
1:         // Check that user and role is unchanged after call
1:         rs = stm.executeQuery(
1:             "values (current_user, session_user, current_role)");
1:         JDBC.assertFullResultSet(
1:             rs,
1:             new String[][]{{"PHB", "PHB", "\"MIDDLEMANAGER\""}});
1: 
1:         stm.close();
1:         c.close();
1: 
1:         // ------------------------------------
1:         // Try with two levels of routines with different definers
1:         c = openUserConnection("Dilbert");
1:         stm = c.createStatement();
1:         rs = stm.executeQuery("values phb.lookupDilbertWage()");
1:         JDBC.assertSingleValueResultSet(rs, "100.0");
1: 
1:         // sanity when we return
1:         rs = stm.executeQuery(
1:             "values (current_user, session_user, current_role)");
1:         JDBC.assertFullResultSet(
1:             rs,
1:             new String[][]{{"DILBERT", "DILBERT", null}});
1: 
1:         stm.close();
1:         c.close();
1: 
1:     }
1: 
1:     public void testBuiltins() throws SQLException{
1:         Connection c = openUserConnection("PHB");
1:         Statement stm = c.createStatement();
1:         stm.executeUpdate("set role middlemanager");
1:         stm.executeUpdate("call s1.spTestBuiltins()");
1:         stm.close();
1:         c.close();
1:     }
1: 
1: 
1:     public void testInvokersRights() throws SQLException{
1:         Connection c = null;
1:         ResultSet rs = null;
1:         Statement stm = null;
1: 
1:         // Try as vainly as dilbert to execute lookupWageFootSoldier
1:         c = openUserConnection("Dilbert");
1:         stm = c.createStatement();
1:         assertStatementError(
1:             new String[]{NOEXECUTEPERMISSION},
1:             stm,
1:             "values s1.lookupWageFootSoldierI(1002)");
1:         stm.close();
1:         c.close();
1: 
1:         // Try as PHB, vainly too, since no definer's rights now.
1:         c = openUserConnection("PHB");
1:         stm = c.createStatement();
1:         assertStatementError(
1:             new String[]{NOCOLUMNPERMISSION},
1:             stm,
1:             "values s1.lookupWageFootSoldierI(1002)");
1:         stm.close();
1:         c.close();
1: 
1:         // dbo can execute lookupWageFootSoldier, since she has select
1:         // privileges on the wages table.
1:         Connection dboConn = getConnection();
1:         Statement dbos = dboConn.createStatement();
1: 
1:         rs = dbos.executeQuery("values s1.lookupWageFootSoldierI(1002)");
1:         JDBC.assertSingleValueResultSet(rs, "100.0");
1: 
1:         dbos.close();
1:         dboConn.close();
1: 
1:         // ----------------------------------------
1:         // Now try with a table function
1: 
1:         c = openUserConnection("PHB");
1: 
1:         stm = c.createStatement();
1:         stm.executeUpdate("set role middlemanager");
1:         assertStatementError(
1:             new String[]{NOCOLUMNPERMISSION},
1:             stm,
1:             "select * from table (s1.selectFootSoldiersI()) as t");
1: 
1:         // Check that user and role is unchanged after failed call
1:         rs = stm.executeQuery(
1:             "values (current_user, session_user, current_role)");
1:         JDBC.assertFullResultSet(
1:             rs,
1:             new String[][]{{"PHB", "PHB", "\"MIDDLEMANAGER\""}});
1: 
1:         stm.close();
1:         c.close();
1: 
1:     }
1: 
1:     public static double lookupWageFootSoldier(int employee)
1:             throws SQLException
1:     {
1:         Connection c = null;
1: 
1:         c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement cStmt = c.createStatement();
1: 
1:         // Can only look up wages of foot soldiers
1:         ResultSet rs = cStmt.executeQuery(
1:             "select salary from s1.wages where employeeId=" +
1:             employee + " and category = " + FOOTSOLDIER);
1: 
1:         if (rs.next()) {
1:             double result = rs.getDouble(1);
1:             cStmt.close();
1:             rs.close();
1:             c.close();
1:             return result;
1:         } else {
1:             cStmt.close();
1:             rs.close();
1:             c.close();
1:             return -1.0;
1:         }
1:     }
1: 
1:     public static ResultSet selectFootSoldiers()
1:             throws SQLException
1:     {
1:         Connection c = null;
1: 
1:         c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement cStmt = c.createStatement();
1: 
1:         // Can only look up wages of foot soldiers
1:         ResultSet rs = cStmt.executeQuery(
1:             "select * from s1.wages where category = " +
1:             FOOTSOLDIER);
1: 
1:         return rs;
1:     }
1: 
1: 
1:     public static double lookupDilbertWage()
1:             throws SQLException
1:     {
1:         Connection c = null;
1: 
1:         c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement stm = c.createStatement();
1: 
1:         // We are executing as middle manager so we can look up Dilberts wage
1:         // for him.
1:         c.commit(); // Need to be no transaction active when we set role
1:         stm.executeUpdate("set role middlemanager");
1: 
1:         // Check that definer is PHB even though we created function as dbo.
1:         ResultSet rs = stm.executeQuery(
1:             "values (current_user, session_user, current_role)");
1: 
1:         JDBC.assertFullResultSet(
1:             rs,
1:             new String[][]{{"PHB", "DILBERT", "\"MIDDLEMANAGER\""}});
1: 
1:         rs = stm.executeQuery(
1:             "select salary from table (s1.selectFootSoldiers()) as t " +
1:             "    where name='Dilbert'");
1:         rs.next();
1:         double result = rs.getDouble(1);
1: 
1:         rs.close();
1:         stm.close();
1:         c.close();
1: 
1:         return result;
1:     }
1: 
1: 
1:     public static void spTestBuiltins()
1:             throws SQLException
1:     {
1:         Connection c = null;
1: 
1:         c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement cStmt = c.createStatement();
1: 
1:         ResultSet rs = cStmt.executeQuery(
1:             "values (user, current_user, current schema, " +
1:             "        session_user, current_role)");
1:         JDBC.assertFullResultSet(
1:             rs,
1:             new String[][]{{"TEST_DBO", "TEST_DBO", "TEST_DBO", "PHB", null}});
1: 
1:         cStmt.close();
1:         c.close();
1:     }
1: }
1: 
============================================================================