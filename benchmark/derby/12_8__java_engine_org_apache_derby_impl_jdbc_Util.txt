1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.Util
1:cd1db93: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:cd1db93: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:60d10e6: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
7:eac0369:  */
1:345de35: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:345de35: 
1:3bb140c: import java.io.IOException;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Types;
1:3bb140c: import org.apache.derby.iapi.error.ErrorStringBuilder;
1:3bb140c: import org.apache.derby.iapi.error.ExceptionSeverity;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:aa5c5de: import org.apache.derby.iapi.jdbc.ExceptionFactory;
1:054fa3a: import org.apache.derby.iapi.reference.JDBC40Translation;
1:3bb140c: import org.apache.derby.iapi.reference.MessageId;
1:3bb140c: import org.apache.derby.iapi.reference.Property;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.i18n.MessageService;
1:3bb140c: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:3bb140c: import org.apache.derby.iapi.services.monitor.Monitor;
1:3bb140c: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
34:eac0369: 
2:60d10e6: /**
1:eac0369: 	This class understands the message protocol and looks up
1:eac0369: 	SQLExceptions based on keys, so that the Local JDBC driver's
1:eac0369: 	messages can be localized.
1:eac0369: 
1:eac0369: 	REMIND: May want to investigate putting some of this in the protocol
1:94f158a: 	side, for the errors that any Derby JDBC driver might return.
1:eac0369: 
1:eac0369: 	The ASSERT mechanism is a wrapper of the basic services,
1:eac0369: 	to ensure that failed asserts at this level will behave
1:eac0369: 	well in a JDBC environment.
1:eac0369: 
1:60d10e6: */
1:eac0369: //In the past, this class was sent on the wire to the client and because it
1:eac0369: //has the message protcol stuff and also the detailed stack trace as one
1:eac0369: //of it's member variable, the client.jar files was really big. To get
1:eac0369: //around this problem, now we have added EmbedSQLException which is
1:eac0369: //just a java sql exception with the stack trace information variable
1:eac0369: //transient so it doesn't get transported to the client side and thus
1:eac0369: //reducing the size of client.jar The bug for this fix was 1850. The
1:eac0369: //p4 number for it will have the details of all the files impacted and
1:eac0369: //the actual changes made.
1:eac0369: public abstract class Util  {
1:50d0853: 
1:60d10e6: 	private static int logSeverityLevel = PropertyUtil.getSystemInt(Property.LOG_SEVERITY_LEVEL,
1:60d10e6: 		SanityManager.DEBUG ? 0 : ExceptionSeverity.SESSION_SEVERITY);
1:eac0369: 	/*
1:eac0369: 	** Methods of Throwable
1:eac0369: 	*/
1:50d0853: 
1:eac0369: 	// class implementation
1:60d10e6: 
1:50d0853:     /**
1:60d10e6:      * Log SQLException to the error log if the severity exceeds the 
1:60d10e6:      * logSeverityLevel  and then throw it.  This method can be used for 
1:60d10e6:      * logging JDBC exceptions to derby.log DERBY-1191.
1:60d10e6:      * 
1:60d10e6:      * @param se SQLException to log and throw
1:60d10e6:      * @throws SQLException
1:50d0853:      */
1:60d10e6:     public static void logAndThrowSQLException(SQLException se) throws SQLException {
1:60d10e6:     	if (se.getErrorCode() >= logSeverityLevel){
1:60d10e6:     	logSQLException(se);
1:60d10e6:     	}
1:60d10e6:     	throw se;
1:50d0853:     }
1:50d0853:     
1:ed0be21: 	/**
1:60d10e6: 	 * Log an SQLException to the error log or to the console if there is no
1:60d10e6: 	 * error log available.
1:60d10e6: 	 * This method could perhaps be optimized to have a static shared
1:60d10e6: 	 * ErrorStringBuilder and synchronize the method, but this works for now.
1:ed0be21: 	 * 
1:60d10e6: 	 * @param se SQLException to log
1:aaf9dfd: 	 */
1:795f705: 	public static void logSQLException(SQLException se) {
1:60d10e6:     	if (se == null)
1:60d10e6:     		return;
1:60d10e6:     	String message = se.getMessage();
1:60d10e6:     	String sqlstate = se.getSQLState();
1:60d10e6:     	if ((sqlstate != null) && (sqlstate.equals(SQLState.LOGIN_FAILED)) && 
1:60d10e6:     			(message != null) && (message.equals("Connection refused : java.lang.OutOfMemoryError")))				
1:60d10e6:     		return;
1:50d0853: 
1:b54918e:         logError( "\nERROR " +  se.getSQLState() + ": "  + se.getMessage() + "\n", se );
1:b54918e:     }
1:b54918e:     private static  void    logError( String errorMessage, Throwable t )
1:b54918e:     {
1:60d10e6:     	HeaderPrintWriter errorStream = Monitor.getStream();
1:60d10e6:     	if (errorStream == null) {
1:b54918e:     		t.printStackTrace();
1:60d10e6:     		return;
1:0b0a105:     	}
1:60d10e6:     	ErrorStringBuilder	errorStringBuilder = new ErrorStringBuilder(errorStream.getHeader());
1:b54918e:     	errorStringBuilder.append( errorMessage );
1:b54918e:     	errorStringBuilder.stackTrace( t );
1:60d10e6:     	errorStream.print(errorStringBuilder.get().toString());
1:60d10e6:     	errorStream.flush();
1:60d10e6:     	errorStringBuilder.reset();
1:60d10e6:     }
1:0b0a105: 
1:eac0369: 	// class interface
1:60d10e6: 
1:60d10e6: 
1:4088872: 	/**
1:eac0369: 		Mimic SanityManager.ASSERT in a JDBC-friendly way,
2:eac0369: 		and providing system cleanup for JDBC failures.
2:eac0369: 		We need the connection to do cleanup...
1:60d10e6: 
1:eac0369: 		@exception SQLException the exception
1:50d0853: 	 */
1:eac0369: 	public static void ASSERT(EmbedConnection conn, boolean mustBeTrue, String msg) throws SQLException {
2:eac0369: 		if (SanityManager.DEBUG) {
1:b54918e: 			try {
1:eac0369: 				SanityManager.ASSERT(mustBeTrue, msg);
2:eac0369: 			} catch (Throwable t) {
1:28dc366:                 throw conn.handleException(t);
1:b54918e: 			}
1:b54918e: 		}
1:b54918e: 	}
1:b54918e: 
1:4c2fc4a:     /**
1:4c2fc4a:      * Checks whether a data type is supported and raises a SQLException
1:4c2fc4a:      * if it isn't.
1:4c2fc4a:      */
1:4c2fc4a:     public static   void checkForSupportedDataType(int dataType) throws SQLException
1:4c2fc4a:     {
1:4c2fc4a:         if ( !isSupportedType( dataType ) )
1:4c2fc4a:         {
1:4c2fc4a:             throw generateCsSQLException( SQLState.DATA_TYPE_NOT_SUPPORTED, typeName( dataType ) );
1:4c2fc4a:         }
1:4c2fc4a:     }
1:4c2fc4a: 
1:4c2fc4a:     /**
1:4c2fc4a:      * Checks whether a data type is supported and raises a StandardException
1:4c2fc4a:      * if it isn't.
1:4c2fc4a:      */
1:4c2fc4a:     public static   void checkSupportedRaiseStandard(int dataType) throws StandardException
1:4c2fc4a:     {
1:4c2fc4a:         if ( !isSupportedType( dataType ) )
1:4c2fc4a:         {
1:4c2fc4a:             throw StandardException.newException( SQLState.DATA_TYPE_NOT_SUPPORTED, typeName( dataType ) );
1:4c2fc4a:         }
1:4c2fc4a:     }
1:4c2fc4a: 
1:4c2fc4a:     /**
1:4c2fc4a:      * Returns false if a data type is not supported for:
1:4c2fc4a:      * <code>setObject(int, Object, int)</code> and
1:4c2fc4a:      * <code>setObject(int, Object, int, int)</code>.
1:4c2fc4a:      *
1:4c2fc4a:      * @param dataType the data type to check
1:4c2fc4a:      */
1:4c2fc4a:     private static   boolean isSupportedType(int dataType)
1:4c2fc4a:     {
1:4c2fc4a:         // JDBC 4.0 javadoc for setObject() says:
1:4c2fc4a:         //
1:4c2fc4a:         // Throws: (...) SQLFeatureNotSupportedException - if
1:4c2fc4a:         // targetSqlType is a ARRAY, BLOB, CLOB, DATALINK,
1:4c2fc4a:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
1:4c2fc4a:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
1:4c2fc4a:         // not support this data type
1:4c2fc4a:         //
1:4c2fc4a:         // Of these types, we only support BLOB, CLOB and
1:4c2fc4a:         // (sort of) JAVA_OBJECT.
1:4c2fc4a: 
1:4c2fc4a:         switch (dataType) {
1:4c2fc4a:         case Types.ARRAY:
1:4c2fc4a:         case Types.DATALINK:
1:4c2fc4a:         case Types.DISTINCT:
1:e33b8d8:         case Types.NCHAR:
1:e33b8d8:         case Types.NCLOB:
1:e33b8d8:         case Types.NVARCHAR:
1:e33b8d8:         case Types.LONGNVARCHAR:
1:4c2fc4a:         case Types.NULL:
1:4c2fc4a:         case Types.OTHER:
1:4c2fc4a:         case Types.REF:
1:4c2fc4a:         case JDBC40Translation.REF_CURSOR:
1:e33b8d8:         case Types.ROWID:
1:e33b8d8:         case Types.SQLXML:
1:4c2fc4a:         case Types.STRUCT:
1:4c2fc4a:             return false;
1:4c2fc4a:         }
1:4c2fc4a: 
1:4c2fc4a:         return true;
1:4c2fc4a:     }
1:4c2fc4a: 
1:eac0369: 	/*
1:eac0369: 	** There is at least one static method for each message id.
1:eac0369: 	** Its parameters are specific to its message.
1:eac0369: 	** These will throw SQLException when the message repository
1:eac0369: 	** cannot be located.
1:63574ff:     ** Note that these methods use the SQL exception factory,
1:eac0369: 	** they don't directly do a new Util.
1:60d10e6: 	*/
1:b54918e: 
1:aa5c5de:     public static SQLException generateCsSQLException(
1:aa5c5de:             String error, Object... args) {
1:63574ff:         return generateCsSQLException(error, null, args);
1:60d10e6: 	}
1:60d10e6: 
1:1f18dc3:     static SQLException generateCsSQLException(
1:1f18dc3:                     String error, Throwable t, Object... args) {
1:63574ff:         return ExceptionFactory.getInstance().getSQLException(
1:63574ff:                 error, (SQLException) null, t, args);
1:60d10e6: 	}
1:eac0369: 
1:eac0369: 	public static SQLException generateCsSQLException(StandardException se) {
1:aa5c5de:         return ExceptionFactory.getInstance().getSQLException(
1:50d0853:                 se.getMessage(), se.getMessageId(), (SQLException) null,
1:50d0853:                 se.getSeverity(), se, se.getArguments());
1:50d0853:     }
1:eac0369: 
1:eac0369: 	public static SQLException noCurrentConnection() {
1:63574ff:         return generateCsSQLException(SQLState.NO_CURRENT_CONNECTION);
18:eac0369: 	}
1:eac0369: 
1:aaf9dfd:     /**
1:4088872:      * Generate an <code>SQLException</code> which points to another
1:4088872:      * <code>SQLException</code> nested within it with
1:4088872:      * <code>setNextException()</code>.
1:4088872:      *
1:4088872:      * @param messageId message id
1:63574ff:      * @param next the next SQLException, possibly null
1:63574ff:      * @param cause the underlying exception, possibly null
1:4088872:      * @param args the arguments to the message creation
1:4088872:      * @return an SQLException wrapping another SQLException
1:4088872:      */
1:63574ff:     static SQLException seeNextException(String messageId, SQLException next,
1:63574ff:                                          Throwable cause, Object... args) {
1:63574ff:         return ExceptionFactory.getInstance().getSQLException(
1:63574ff:                 messageId, next, cause, args);
1:4088872:     }
1:4088872: 
1:eac0369: 	public static SQLException javaException(Throwable t) {
1:eac0369: 		String name, msg;
1:eac0369: 
1:eac0369: 		msg = t.getMessage();
1:eac0369: 		if (msg == null) msg = "";
1:eac0369: 		name = t.getClass().getName();
1:de3b108:         SQLException next = null;
1:de3b108:         Throwable cause = t.getCause();
1:de3b108:         if (cause != null) {
1:de3b108:             if (cause instanceof SQLException) {
1:de3b108:                 next = (SQLException) cause;
1:de3b108:             } else if (cause instanceof StandardException) {
1:de3b108:                 next = generateCsSQLException((StandardException) cause);
1:de3b108:             } else {
1:de3b108:                 next = javaException(cause);
1:de3b108:             }
1:de3b108:         }
1:63574ff: 
1:63574ff:         SQLException result = seeNextException(
1:63574ff:                 SQLState.JAVA_EXCEPTION, next, t, name, msg);
1:c3f6b1b: 
1:c3f6b1b:     	if ( result.getErrorCode() >= logSeverityLevel ) { logSQLException( result ); }
1:c3f6b1b:         
1:c3f6b1b:         return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:59a5a70: 	public static SQLException policyNotReloaded( Throwable t ) {
1:63574ff:         return generateCsSQLException(
1:63574ff:                 SQLState.POLICY_NOT_RELOADED, t, t.getMessage());
1:59a5a70: 	}
1:59a5a70: 
1:eac0369: 	public static SQLException notImplemented() {
1:eac0369: 
1:c0b7bf9: 		return notImplemented( MessageService.getTextMessage(MessageId.CONN_NO_DETAILS) );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static SQLException notImplemented(String feature) {
1:63574ff:         return generateCsSQLException(SQLState.NOT_IMPLEMENTED, feature);
1:eac0369: 	}
1:c0b7bf9: 
1:eac0369: 	static SQLException setStreamFailure(IOException e) {
1:eac0369: 		String msg;
1:eac0369: 
1:eac0369: 		msg = e.getMessage();
1:eac0369: 		if (msg == null) 
1:eac0369: 			msg = e.getClass().getName();
1:1f18dc3:         return generateCsSQLException(SQLState.SET_STREAM_FAILURE, e, msg);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	static SQLException typeMisMatch(int targetSQLType) {
1:63574ff:         return generateCsSQLException(
1:63574ff:                 SQLState.TYPE_MISMATCH, typeName(targetSQLType));
1:eac0369: 	}
1:eac0369: 
1:0b0a105:     /** Squash an array of longs into an array of ints */
1:0b0a105:     public static  int[]   squashLongs( long[] longs )
2:b54918e:     {
1:0b0a105:         int count = (longs == null) ? 0 : longs.length;
1:0b0a105:         int[]   ints = new int[ count ];
1:0b0a105:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1:0b0a105: 
1:0b0a105:         return ints;
1:0b0a105:     }
1:0b0a105: 
1:50d0853:     /**
1:ed0be21:      * Create an {@code IOException} that wraps another {@code Throwable}.
1:60d10e6:      *
1:ed0be21:      * @param cause the underlying cause of the error
1:ed0be21:      * @return an {@code IOException} linked to {@code cause}
1:ed0be21:      */
1:ed0be21:     static IOException newIOException(Throwable cause) {
1:aa5c5de:         return new IOException(cause);
1:ed0be21:     }
1:ed0be21: 
1:aaf9dfd: 	public static String typeName(int jdbcType) {
1:eac0369: 		switch (jdbcType) {
1:054fa3a: 			case Types.ARRAY: return TypeId.ARRAY_NAME;
1:eac0369: 			case Types.BIT 		:  return TypeId.BIT_NAME;
1:1a4ea31: 			case Types.BOOLEAN  : return TypeId.BOOLEAN_NAME;
1:1a4ea31: 			case Types.DATALINK: return TypeId.DATALINK_NAME;
1:eac0369: 			case Types.TINYINT 	:  return TypeId.TINYINT_NAME;
1:eac0369: 			case Types.SMALLINT	:  return TypeId.SMALLINT_NAME;
1:eac0369: 			case Types.INTEGER 	:  return TypeId.INTEGER_NAME;
1:3bb140c:             case Types.BIGINT   :  return TypeId.BIGINT_NAME;
1:eac0369: 
1:eac0369: 			case Types.FLOAT 	:  return TypeId.FLOAT_NAME;
1:eac0369: 			case Types.REAL 	:  return TypeId.REAL_NAME;
1:eac0369: 			case Types.DOUBLE 	:  return TypeId.DOUBLE_NAME;
1:eac0369: 
1:eac0369: 			case Types.NUMERIC 	:  return TypeId.NUMERIC_NAME;
1:eac0369: 			case Types.DECIMAL	:  return TypeId.DECIMAL_NAME;
1:eac0369: 
1:eac0369: 			case Types.CHAR		:  return TypeId.CHAR_NAME;
1:eac0369: 			case Types.VARCHAR 	:  return TypeId.VARCHAR_NAME;
1:eac0369: 			case Types.LONGVARCHAR 	:  return "LONGVARCHAR";
1:eac0369:             case Types.CLOB     :  return TypeId.CLOB_NAME;
1:eac0369: 
1:eac0369: 			case Types.DATE 		:  return TypeId.DATE_NAME;
1:eac0369: 			case Types.TIME 		:  return TypeId.TIME_NAME;
1:eac0369: 			case Types.TIMESTAMP 	:  return TypeId.TIMESTAMP_NAME;
1:eac0369: 
1:eac0369: 			case Types.BINARY			:  return TypeId.BINARY_NAME;
1:eac0369: 			case Types.VARBINARY	 	:  return TypeId.VARBINARY_NAME;
1:eac0369: 			case Types.LONGVARBINARY 	:  return TypeId.LONGVARBINARY_NAME;
1:eac0369:             case Types.BLOB             :  return TypeId.BLOB_NAME;
1:eac0369: 
1:eac0369: 			case Types.OTHER		:  return "OTHER";
1:eac0369: 			case Types.JAVA_OBJECT	:  return "Types.JAVA_OBJECT";
1:054fa3a: 			case Types.REF : return TypeId.REF_NAME;
1:7cfb7e6: 			case JDBC40Translation.REF_CURSOR: return TypeId.REF_CURSOR;
1:e33b8d8:             case Types.ROWID: return TypeId.ROWID_NAME;
1:054fa3a: 			case Types.STRUCT: return TypeId.STRUCT_NAME;
1:099e28f: 			case StoredFormatIds.XML_TYPE_ID :  return TypeId.XML_NAME;
1:e33b8d8:             case Types.SQLXML: return TypeId.SQLXML_NAME;
1:eac0369: 			default : return String.valueOf(jdbcType);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0d57d84
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:63574ff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     ** Note that these methods use the SQL exception factory,
1:         return generateCsSQLException(error, null, args);
1:         return ExceptionFactory.getInstance().getSQLException(
1:                 error, (SQLException) null, t, args);
/////////////////////////////////////////////////////////////////////////
1:         return generateCsSQLException(SQLState.NO_CURRENT_CONNECTION);
/////////////////////////////////////////////////////////////////////////
1:      * @param next the next SQLException, possibly null
1:      * @param cause the underlying exception, possibly null
1:     static SQLException seeNextException(String messageId, SQLException next,
1:                                          Throwable cause, Object... args) {
1:         return ExceptionFactory.getInstance().getSQLException(
1:                 messageId, next, cause, args);
/////////////////////////////////////////////////////////////////////////
1: 
1:         SQLException result = seeNextException(
1:                 SQLState.JAVA_EXCEPTION, next, t, name, msg);
/////////////////////////////////////////////////////////////////////////
1:         return generateCsSQLException(
1:                 SQLState.POLICY_NOT_RELOADED, t, t.getMessage());
/////////////////////////////////////////////////////////////////////////
1:         return generateCsSQLException(SQLState.NOT_IMPLEMENTED, feature);
/////////////////////////////////////////////////////////////////////////
1:         return generateCsSQLException(
1:                 SQLState.TYPE_MISMATCH, typeName(targetSQLType));
commit:28dc366
/////////////////////////////////////////////////////////////////////////
1:                 throw conn.handleException(t);
commit:1f18dc3
/////////////////////////////////////////////////////////////////////////
0:         String message = MessageService.getTextMessage(messageId, args);
/////////////////////////////////////////////////////////////////////////
1:     static SQLException generateCsSQLException(
1:                     String error, Throwable t, Object... args) {
0:                 args,
/////////////////////////////////////////////////////////////////////////
1:         return generateCsSQLException(SQLState.SET_STREAM_FAILURE, e, msg);
commit:aa5c5de
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.ExceptionFactory;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return ExceptionFactory.getInstance().getSQLException(
/////////////////////////////////////////////////////////////////////////
1:     public static SQLException generateCsSQLException(
1:             String error, Object... args) {
0:                 args,
/////////////////////////////////////////////////////////////////////////
0:         return ExceptionFactory.getInstance().getSQLException(
/////////////////////////////////////////////////////////////////////////
1:         return new IOException(cause);
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         case Types.NCHAR:
1:         case Types.NCLOB:
1:         case Types.NVARCHAR:
1:         case Types.LONGNVARCHAR:
1:         case Types.ROWID:
1:         case Types.SQLXML:
/////////////////////////////////////////////////////////////////////////
1:             case Types.ROWID: return TypeId.ROWID_NAME;
1:             case Types.SQLXML: return TypeId.SQLXML_NAME;
commit:9a3581a
/////////////////////////////////////////////////////////////////////////
0:         return generateCsSQLException(SQLState.SET_STREAM_FAILURE, msg, e);
commit:ed0be21
/////////////////////////////////////////////////////////////////////////
1:      * Create an {@code IOException} that wraps another {@code Throwable}.
1:      *
1:      * @param cause the underlying cause of the error
1:      * @return an {@code IOException} linked to {@code cause}
1:      */
1:     static IOException newIOException(Throwable cause) {
0:         IOException ioe = new IOException(cause.getMessage());
0:         ioe.initCause(cause);
0:         return ioe;
1:     }
1: 
1:     /**
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1:         SQLException next = null;
1:         Throwable cause = t.getCause();
1:         if (cause != null) {
1:             if (cause instanceof SQLException) {
1:                 next = (SQLException) cause;
1:             } else if (cause instanceof StandardException) {
1:                 next = generateCsSQLException((StandardException) cause);
1:             } else {
1:                 next = javaException(cause);
1:             }
1:         }
0:                 new Object[] {name, msg}, next,
0:                 ExceptionSeverity.NO_APPLICABLE_SEVERITY, t);
commit:4088872
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Generate an <code>SQLException</code> which points to another
1:      * <code>SQLException</code> nested within it with
1:      * <code>setNextException()</code>.
1:      *
1:      * @param messageId message id
1:      * @param args the arguments to the message creation
0:      * @param next the next SQLException
1:      * @return an SQLException wrapping another SQLException
1:      */
0:     static SQLException seeNextException(String messageId, Object[] args,
0:                                          SQLException next) {
0:         return newEmbedSQLException(messageId, args, next,
0:             StandardException.getSeverityFromIdentifier(messageId), null);
1:     }
1: 
commit:054fa3a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
1: 			case Types.ARRAY: return TypeId.ARRAY_NAME;
0: 			case JDBC30Translation.DATALINK: return TypeId.DATALINK_NAME;
/////////////////////////////////////////////////////////////////////////
0: 			case JDBC40Translation.NCHAR:
0: 				return TypeId.NATIONAL_CHAR_NAME;
0: 			case JDBC40Translation.NVARCHAR:
0: 				return TypeId.NATIONAL_VARCHAR_NAME;
0: 			case JDBC40Translation.LONGNVARCHAR:
0: 				return TypeId.NATIONAL_LONGVARCHAR_NAME;
0: 			case JDBC40Translation.NCLOB: return TypeId.NCLOB_NAME;
/////////////////////////////////////////////////////////////////////////
1: 			case Types.REF : return TypeId.REF_NAME;
0: 			case JDBC40Translation.ROWID: return TypeId.ROWID_NAME;
1: 			case Types.STRUCT: return TypeId.STRUCT_NAME;
0: 			case JDBC40Translation.SQLXML: return TypeId.SQLXML_NAME;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:c3f6b1b
/////////////////////////////////////////////////////////////////////////
0: 		SQLException    result = newEmbedSQLException(SQLState.JAVA_EXCEPTION,
1: 
1:     	if ( result.getErrorCode() >= logSeverityLevel ) { logSQLException( result ); }
1:         
1:         return result;
commit:4c2fc4a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks whether a data type is supported and raises a SQLException
1:      * if it isn't.
1:      */
1:     public static   void checkForSupportedDataType(int dataType) throws SQLException
1:     {
1:         if ( !isSupportedType( dataType ) )
1:         {
1:             throw generateCsSQLException( SQLState.DATA_TYPE_NOT_SUPPORTED, typeName( dataType ) );
1:         }
1:     }
1: 
1:     /**
1:      * Checks whether a data type is supported and raises a StandardException
1:      * if it isn't.
1:      */
1:     public static   void checkSupportedRaiseStandard(int dataType) throws StandardException
1:     {
1:         if ( !isSupportedType( dataType ) )
1:         {
1:             throw StandardException.newException( SQLState.DATA_TYPE_NOT_SUPPORTED, typeName( dataType ) );
1:         }
1:     }
1: 
1:     /**
1:      * Returns false if a data type is not supported for:
1:      * <code>setObject(int, Object, int)</code> and
1:      * <code>setObject(int, Object, int, int)</code>.
1:      *
1:      * @param dataType the data type to check
1:      */
1:     private static   boolean isSupportedType(int dataType)
1:     {
1:         // JDBC 4.0 javadoc for setObject() says:
1:         //
1:         // Throws: (...) SQLFeatureNotSupportedException - if
1:         // targetSqlType is a ARRAY, BLOB, CLOB, DATALINK,
1:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
1:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
1:         // not support this data type
1:         //
1:         // Of these types, we only support BLOB, CLOB and
1:         // (sort of) JAVA_OBJECT.
1: 
1:         switch (dataType) {
1:         case Types.ARRAY:
1:         case Types.DATALINK:
1:         case Types.DISTINCT:
0:         case JDBC40Translation.NCHAR:
0:         case JDBC40Translation.NCLOB:
0:         case JDBC40Translation.NVARCHAR:
0:         case JDBC40Translation.LONGNVARCHAR:
1:         case Types.NULL:
1:         case Types.OTHER:
1:         case Types.REF:
1:         case JDBC40Translation.REF_CURSOR:
0:         case JDBC40Translation.ROWID:
0:         case JDBC40Translation.SQLXML:
1:         case Types.STRUCT:
1:             return false;
1:         }
1: 
1:         return true;
1:     }
1: 
commit:7cfb7e6
/////////////////////////////////////////////////////////////////////////
1: 			case JDBC40Translation.REF_CURSOR: return TypeId.REF_CURSOR;
commit:cd1db93
/////////////////////////////////////////////////////////////////////////
0:         ( String message, String sqlState, int errorCode, long[] updateCounts, Throwable cause )
/////////////////////////////////////////////////////////////////////////
0:                     ( new Object[] { message, sqlState, new Integer( errorCode ), updateCounts, cause } );
/////////////////////////////////////////////////////////////////////////
0:         BatchUpdateException batch = new BatchUpdateException
1:         
0:         if ( cause instanceof SQLException ) { batch.setNextException( (SQLException) cause ); }
0:         batch.initCause( cause );
1: 
0:         return batch;
commit:b54918e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Constructor;
0: import java.sql.BatchUpdateException;
/////////////////////////////////////////////////////////////////////////
1:         logError( "\nERROR " +  se.getSQLState() + ": "  + se.getMessage() + "\n", se );
1:     }
1:     private static  void    logError( String errorMessage, Throwable t )
1:     {
1:     		t.printStackTrace();
1:     	errorStringBuilder.append( errorMessage );
1:     	errorStringBuilder.stackTrace( t );
/////////////////////////////////////////////////////////////////////////
0:         if ( JVMInfo.JDK_ID >= JVMInfo.J2SE_18 )
1:         {
1:             try {
0:                 Constructor constructor = BatchUpdateException.class.getConstructor
0:                     (
0:                      new Class[] { String.class, String.class, Integer.TYPE, updateCounts.getClass(), Throwable.class }
0:                      );
1: 
0:                 return (BatchUpdateException) constructor.newInstance
0:                     ( new Object[] { message, sqlState, new Integer( errorCode ), updateCounts, (Throwable) null } );
1:             }
0:             catch (Exception e)
1:             {
0:                 // unanticipated problem. log it and return the Java 7 version of the exception
0:                 logError( "\nERROR " +  e.getMessage() + "\n", e );
1:             }
1:         }
1: 
0:         // use this constructor if we're not on Java 8 or if an error occurred
0:         // while using the Java 8 constructor
0:         return new BatchUpdateException
commit:0b0a105
/////////////////////////////////////////////////////////////////////////
0:     /** Create the correct BatchUpdateException depending on whether this is Java 8 or lower */
0:     static  SQLException    newBatchUpdateException
0:         ( String message, String sqlState, int errorCode, long[] updateCounts )
0:     {
0:         return new java.sql.BatchUpdateException
0:             ( message, sqlState, errorCode, squashLongs( updateCounts ) );
1:     }
1: 
1:     /** Squash an array of longs into an array of ints */
1:     public static  int[]   squashLongs( long[] longs )
0:     {
1:         int count = (longs == null) ? 0 : longs.length;
1:         int[]   ints = new int[ count ];
1:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1: 
1:         return ints;
1:     }
1: 
commit:795f705
/////////////////////////////////////////////////////////////////////////
1: 	public static void logSQLException(SQLException se) {
commit:59a5a70
/////////////////////////////////////////////////////////////////////////
1: 	public static SQLException policyNotReloaded( Throwable t ) {
0: 		return newEmbedSQLException(SQLState.POLICY_NOT_RELOADED, new Object[] { t.getMessage() },
0:         		StandardException.getSeverityFromIdentifier(SQLState.POLICY_NOT_RELOADED), t);
1: 	}
1: 
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:aaf9dfd
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Get the exception factory specific to the version of JDBC which
0: 	 * we are running.
1:      */
0: 	public	static	SQLExceptionFactory	getExceptionFactory() { return exceptionFactory; }
1: 	public static String typeName(int jdbcType) {
commit:c0b7bf9
/////////////////////////////////////////////////////////////////////////
1: 		return notImplemented( MessageService.getTextMessage(MessageId.CONN_NO_DETAILS) );
1: 
commit:50d0853
/////////////////////////////////////////////////////////////////////////
1: 
0:     private static SQLExceptionFactory exceptionFactory = 
0:                                     new SQLExceptionFactory ();
1: 
1:     /**
0:      * This looks up the message and sqlstate values and calls
0:      * the SQLExceptionFactory method to generate
0:      * the appropriate exception off of them.
1:      */
0:         String message = MessageService.getCompleteMessage
0:                                         (messageId, args);
0:         return exceptionFactory.getSQLException (
0: 			    message, messageId, next, severity, t, args);
/////////////////////////////////////////////////////////////////////////
0:         return exceptionFactory.getSQLException(
1:                 se.getMessage(), se.getMessageId(), (SQLException) null,
1:                 se.getSeverity(), se, se.getArguments());
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * this method is called to replace the exception factory to be 
0:      * used to generate the SQLException or the subclass
1:      */
1: 
0:     public static void setExceptionFactory (SQLExceptionFactory factory) {
0:         exceptionFactory = factory;
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.derby.iapi.error.ErrorStringBuilder;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.jdbc.ExceptionFactory;
0: import org.apache.derby.iapi.reference.JDBC40Translation;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:             case Types.BIGINT   :  return TypeId.BIGINT_NAME;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:60d10e6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.ErrorStringBuilder;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	private static int logSeverityLevel = PropertyUtil.getSystemInt(Property.LOG_SEVERITY_LEVEL,
1: 		SanityManager.DEBUG ? 0 : ExceptionSeverity.SESSION_SEVERITY);
/////////////////////////////////////////////////////////////////////////
1:      * Log SQLException to the error log if the severity exceeds the 
1:      * logSeverityLevel  and then throw it.  This method can be used for 
1:      * logging JDBC exceptions to derby.log DERBY-1191.
1:      * 
1:      * @param se SQLException to log and throw
1:      * @throws SQLException
1:      */
1:     public static void logAndThrowSQLException(SQLException se) throws SQLException {
1:     	if (se.getErrorCode() >= logSeverityLevel){
1:     	logSQLException(se);
1:     	}
1:     	throw se;
1:     }
1:     
1: 	/**
1: 	 * Log an SQLException to the error log or to the console if there is no
1: 	 * error log available.
1: 	 * This method could perhaps be optimized to have a static shared
1: 	 * ErrorStringBuilder and synchronize the method, but this works for now.
1: 	 * 
1: 	 * @param se SQLException to log
1: 	 */
0: 	private static void logSQLException(SQLException se) {
1:     	if (se == null)
1:     		return;
1:     	String message = se.getMessage();
1:     	String sqlstate = se.getSQLState();
1:     	if ((sqlstate != null) && (sqlstate.equals(SQLState.LOGIN_FAILED)) && 
1:     			(message != null) && (message.equals("Connection refused : java.lang.OutOfMemoryError")))				
1:     		return;
1: 
1:     	HeaderPrintWriter errorStream = Monitor.getStream();
1:     	if (errorStream == null) {
0:     		se.printStackTrace();
1:     		return;
1:     	}
1:     	ErrorStringBuilder	errorStringBuilder = new ErrorStringBuilder(errorStream.getHeader());
0:     	errorStringBuilder.append("\nERROR " +  se.getSQLState() + ": "  + se.getMessage() + "\n");
0:     	errorStringBuilder.stackTrace(se);
1:     	errorStream.print(errorStringBuilder.get().toString());
1:     	errorStream.flush();
1:     	errorStringBuilder.reset();
1: 
1:     }
1: 
1: 	
1: 	/**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN  : return TypeId.BOOLEAN_NAME;
1: 			case Types.DATALINK: return TypeId.DATALINK_NAME;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.Util
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.error.ExceptionSeverity;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: import java.sql.SQLException;
1: import java.sql.Types;
0: import java.io.IOException;
0: import java.io.PrintStream;
0: import java.io.PrintWriter;
1: 
0: /**
1: 	This class understands the message protocol and looks up
1: 	SQLExceptions based on keys, so that the Local JDBC driver's
1: 	messages can be localized.
1: 
1: 	REMIND: May want to investigate putting some of this in the protocol
0: 	side, for the errors that any Cloudscape JDBC driver might return.
1: 
1: 	The ASSERT mechanism is a wrapper of the basic services,
1: 	to ensure that failed asserts at this level will behave
1: 	well in a JDBC environment.
1: 
0: 	@author ames
1: */
1: //In the past, this class was sent on the wire to the client and because it
1: //has the message protcol stuff and also the detailed stack trace as one
1: //of it's member variable, the client.jar files was really big. To get
1: //around this problem, now we have added EmbedSQLException which is
1: //just a java sql exception with the stack trace information variable
1: //transient so it doesn't get transported to the client side and thus
1: //reducing the size of client.jar The bug for this fix was 1850. The
1: //p4 number for it will have the details of all the files impacted and
1: //the actual changes made.
1: public abstract class Util  {
1: 
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 	** Methods of Throwable
1: 	*/
1: 
1: 	// class implementation
1: 
0: 	/**
0: 		This looks up the message and sqlstate values and generates
0: 		the appropriate exception off of them.
1: 	 */
1: 
0: 	private static SQLException newEmbedSQLException(String messageId,
0: 			Object[] args, SQLException next, int severity, Throwable t) {
0: 		return new EmbedSQLException(
0: 			MessageService.getCompleteMessage(messageId, args),
0: 			messageId, next, severity, t, args);
1: 	}
1: 
0: 	public static SQLException newEmbedSQLException(String messageId,
0: 			Object[] args, int severity) {
0: 		return newEmbedSQLException(messageId, args, (SQLException) null, severity, (Throwable) null);
1: 	}
1: 
0: 	private static SQLException newEmbedSQLException(String messageId,
0: 			Object[] args, int severity, Throwable t) {
0: 		return newEmbedSQLException(messageId,args, (SQLException)  null, severity, t);
1: 	}
1: 
0: 	private static SQLException newEmbedSQLException(
0: 			String messageId, int severity) {
0: 		return newEmbedSQLException(messageId, (Object[]) null, (SQLException) null, severity, (Throwable) null);
1: 	}
1: 
1: 	// class interface
1: 
1: 
0: 	/**
1: 		Mimic SanityManager.ASSERT in a JDBC-friendly way,
1: 		and providing system cleanup for JDBC failures.
1: 		We need the connection to do cleanup...
1: 
1: 		@exception SQLException the exception
1: 	 */
1: 	public static void ASSERT(EmbedConnection conn, boolean mustBeTrue, String msg) throws SQLException {
1: 		if (SanityManager.DEBUG) {
0: 			try {
1: 				SanityManager.ASSERT(mustBeTrue, msg);
1: 			} catch (Throwable t) {
0: 				SQLException se = conn.handleException(t);
0: 				// get around typing constraints.
0: 				// it must be a Util, we wrapped it.
0: 				SanityManager.ASSERT(se instanceof EmbedSQLException);
0: 				throw (EmbedSQLException)se;
1: 			}
1: 		}
1: 	}
1: 
0: 	/**
0: 		Mimic SanityManager.THROWASSERT in a JDBC-friendly way,
1: 		and providing system cleanup for JDBC failures.
1: 		We need the connection to do cleanup...
1: 	 */
0: 	static void THROWASSERT(EmbedConnection conn, String msg) throws SQLException {
1: 		if (SanityManager.DEBUG) {
0: 			try {
0: 				SanityManager.THROWASSERT(msg);
1: 			} catch (Throwable t) {
0: 				SQLException se = conn.handleException(t);
0: 				// get around typing constraints.
0: 				// it must be a Util, we wrapped it.
0: 				SanityManager.ASSERT(se instanceof EmbedSQLException);
0: 				throw (EmbedSQLException)se;
1: 			}
1: 		}
1: 	}
1: 
1: 	/*
1: 	** There is at least one static method for each message id.
1: 	** Its parameters are specific to its message.
1: 	** These will throw SQLException when the message repository
1: 	** cannot be located.
0: 	** Note that these methods call the static method newEmbedSQLException,
1: 	** they don't directly do a new Util.
1: 	*/
1: 
0: 	/* 3 arguments */
0: 	static SQLException newException(String messageID, Object a1,
0: 			Object a2, Object a3) {
0: 		return newEmbedSQLException(messageID, new Object[] {a1, a2, a3},
0:         		StandardException.getSeverityFromIdentifier(messageID));
1: 	}
1: 
1: 
0: 	public static SQLException generateCsSQLException(String error) {
0: 		return newEmbedSQLException(error,
0:         		StandardException.getSeverityFromIdentifier(error));
1: 	}
1: 
0: 	public static SQLException generateCsSQLException(String error, Object arg1)     {
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1},
0:                 StandardException.getSeverityFromIdentifier(error));
1: 	}
1: 
0: 	public static SQLException generateCsSQLException(
0:                              String error, Object arg1, Object arg2){
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1, arg2},
0:                 StandardException.getSeverityFromIdentifier(error));
1: 	}
1: 
0: 	public static SQLException generateCsSQLException(
0: 		String error, Object arg1, Object arg2, Object arg3) {
1: 
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1, arg2, arg3},
0:                 StandardException.getSeverityFromIdentifier(error));
1: 	}
1: 
1: 
0: 	static SQLException generateCsSQLException(
0:                     String error, Object arg1, Throwable t) {
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1},
0:                 StandardException.getSeverityFromIdentifier(error), t);
1: 	}
1: 
1: 	public static SQLException generateCsSQLException(StandardException se) {
0: 		return new EmbedSQLException(
0:             	se.getMessage(), se.getMessageId(), null, se.getSeverity(), se, se.getArguments());
1: 	}
1: 
1: 	public static SQLException noCurrentConnection() {
0: 		return newEmbedSQLException(SQLState.NO_CURRENT_CONNECTION,
0:         		StandardException.getSeverityFromIdentifier(SQLState.NO_CURRENT_CONNECTION));
1: 	}
1: 
1: 	public static SQLException javaException(Throwable t) {
1: 		String name, msg;
1: 
1: 		msg = t.getMessage();
1: 		if (msg == null) msg = "";
1: 		name = t.getClass().getName();
0: 		return newEmbedSQLException(SQLState.JAVA_EXCEPTION,
0: 			new Object[] {name, msg}, ExceptionSeverity.NO_APPLICABLE_SEVERITY, t);
1: 	}
1: 
1: 
1: 	public static SQLException notImplemented() {
1: 
0: 		return newEmbedSQLException(SQLState.NOT_IMPLEMENTED,
0: 			new Object[] {MessageService.getTextMessage(MessageId.CONN_NO_DETAILS)},
0:                 StandardException.getSeverityFromIdentifier(SQLState.NOT_IMPLEMENTED));
1: 	}
1: 
1: 	public static SQLException notImplemented(String feature) {
0: 		return newEmbedSQLException(SQLState.NOT_IMPLEMENTED,
0: 			new Object[] {feature},
0:                 StandardException.getSeverityFromIdentifier(SQLState.NOT_IMPLEMENTED));
1: 	}
1: 
1: 	static SQLException setStreamFailure(IOException e) {
1: 		String msg;
1: 
1: 		msg = e.getMessage();
1: 		if (msg == null) 
1: 			msg = e.getClass().getName();
0: 		return newEmbedSQLException(SQLState.SET_STREAM_FAILURE,
0: 			new Object[] {msg},
0:                 StandardException.getSeverityFromIdentifier(SQLState.SET_STREAM_FAILURE));
1: 	}
1: 
1: 	static SQLException typeMisMatch(int targetSQLType) {
0: 		return newEmbedSQLException(SQLState.TYPE_MISMATCH,
0: 			new Object[] {typeName(targetSQLType)},
0:                 StandardException.getSeverityFromIdentifier(SQLState.TYPE_MISMATCH));
1: 	}
1: 
1: 
0:   public static String typeName(int jdbcType) {
1: 		switch (jdbcType) {
1: 			case Types.BIT 		:  return TypeId.BIT_NAME;
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN  : return TypeId.BOOLEAN_NAME;
1: 			case Types.TINYINT 	:  return TypeId.TINYINT_NAME;
1: 			case Types.SMALLINT	:  return TypeId.SMALLINT_NAME;
1: 			case Types.INTEGER 	:  return TypeId.INTEGER_NAME;
0: 			case Types.BIGINT 	:  return TypeId.LONGINT_NAME;
1: 
1: 			case Types.FLOAT 	:  return TypeId.FLOAT_NAME;
1: 			case Types.REAL 	:  return TypeId.REAL_NAME;
1: 			case Types.DOUBLE 	:  return TypeId.DOUBLE_NAME;
1: 
1: 			case Types.NUMERIC 	:  return TypeId.NUMERIC_NAME;
1: 			case Types.DECIMAL	:  return TypeId.DECIMAL_NAME;
1: 
1: 			case Types.CHAR		:  return TypeId.CHAR_NAME;
1: 			case Types.VARCHAR 	:  return TypeId.VARCHAR_NAME;
1: 			case Types.LONGVARCHAR 	:  return "LONGVARCHAR";
1:             case Types.CLOB     :  return TypeId.CLOB_NAME;
1: 
1: 			case Types.DATE 		:  return TypeId.DATE_NAME;
1: 			case Types.TIME 		:  return TypeId.TIME_NAME;
1: 			case Types.TIMESTAMP 	:  return TypeId.TIMESTAMP_NAME;
1: 
1: 			case Types.BINARY			:  return TypeId.BINARY_NAME;
1: 			case Types.VARBINARY	 	:  return TypeId.VARBINARY_NAME;
1: 			case Types.LONGVARBINARY 	:  return TypeId.LONGVARBINARY_NAME;
1:             case Types.BLOB             :  return TypeId.BLOB_NAME;
1: 
1: 			case Types.OTHER		:  return "OTHER";
1: 			case Types.JAVA_OBJECT	:  return "Types.JAVA_OBJECT";
1: 			default : return String.valueOf(jdbcType);
1: 		}
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	side, for the errors that any Derby JDBC driver might return.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.XML_TYPE_ID :  return TypeId.XML_NAME;
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import java.sql.SQLException;
0: import java.sql.Types;
0: import java.io.IOException;
0: import java.io.PrintStream;
0: import java.io.PrintWriter;
0: 
0: /**
0: 	This class understands the message protocol and looks up
0: 	SQLExceptions based on keys, so that the Local JDBC driver's
0: 	messages can be localized.
0: 
0: 	REMIND: May want to investigate putting some of this in the protocol
0: 	side, for the errors that any Cloudscape JDBC driver might return.
0: 
0: 	The ASSERT mechanism is a wrapper of the basic services,
0: 	to ensure that failed asserts at this level will behave
0: 	well in a JDBC environment.
0: 
0: 	@author ames
0: */
0: //In the past, this class was sent on the wire to the client and because it
0: //has the message protcol stuff and also the detailed stack trace as one
0: //of it's member variable, the client.jar files was really big. To get
0: //around this problem, now we have added EmbedSQLException which is
0: //just a java sql exception with the stack trace information variable
0: //transient so it doesn't get transported to the client side and thus
0: //reducing the size of client.jar The bug for this fix was 1850. The
0: //p4 number for it will have the details of all the files impacted and
0: //the actual changes made.
0: public abstract class Util  {
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 	** Methods of Throwable
0: 	*/
0: 
0: 	// class implementation
0: 
0: 	/**
0: 		This looks up the message and sqlstate values and generates
0: 		the appropriate exception off of them.
0: 	 */
0: 
0: 	private static SQLException newEmbedSQLException(String messageId,
0: 			Object[] args, SQLException next, int severity, Throwable t) {
0: 		return new EmbedSQLException(
0: 			MessageService.getCompleteMessage(messageId, args),
0: 			messageId, next, severity, t, args);
0: 	}
0: 
0: 	public static SQLException newEmbedSQLException(String messageId,
0: 			Object[] args, int severity) {
0: 		return newEmbedSQLException(messageId, args, (SQLException) null, severity, (Throwable) null);
0: 	}
0: 
0: 	private static SQLException newEmbedSQLException(String messageId,
0: 			Object[] args, int severity, Throwable t) {
0: 		return newEmbedSQLException(messageId,args, (SQLException)  null, severity, t);
0: 	}
0: 
0: 	private static SQLException newEmbedSQLException(
0: 			String messageId, int severity) {
0: 		return newEmbedSQLException(messageId, (Object[]) null, (SQLException) null, severity, (Throwable) null);
0: 	}
0: 
0: 	// class interface
0: 
0: 
0: 	/**
0: 		Mimic SanityManager.ASSERT in a JDBC-friendly way,
0: 		and providing system cleanup for JDBC failures.
0: 		We need the connection to do cleanup...
0: 
0: 		@exception SQLException the exception
0: 	 */
0: 	public static void ASSERT(EmbedConnection conn, boolean mustBeTrue, String msg) throws SQLException {
0: 		if (SanityManager.DEBUG) {
0: 			try {
0: 				SanityManager.ASSERT(mustBeTrue, msg);
0: 			} catch (Throwable t) {
0: 				SQLException se = conn.handleException(t);
0: 				// get around typing constraints.
0: 				// it must be a Util, we wrapped it.
0: 				SanityManager.ASSERT(se instanceof EmbedSQLException);
0: 				throw (EmbedSQLException)se;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Mimic SanityManager.THROWASSERT in a JDBC-friendly way,
0: 		and providing system cleanup for JDBC failures.
0: 		We need the connection to do cleanup...
0: 	 */
0: 	static void THROWASSERT(EmbedConnection conn, String msg) throws SQLException {
0: 		if (SanityManager.DEBUG) {
0: 			try {
0: 				SanityManager.THROWASSERT(msg);
0: 			} catch (Throwable t) {
0: 				SQLException se = conn.handleException(t);
0: 				// get around typing constraints.
0: 				// it must be a Util, we wrapped it.
0: 				SanityManager.ASSERT(se instanceof EmbedSQLException);
0: 				throw (EmbedSQLException)se;
0: 			}
0: 		}
0: 	}
0: 
0: 	/*
0: 	** There is at least one static method for each message id.
0: 	** Its parameters are specific to its message.
0: 	** These will throw SQLException when the message repository
0: 	** cannot be located.
0: 	** Note that these methods call the static method newEmbedSQLException,
0: 	** they don't directly do a new Util.
0: 	*/
0: 
0: 	/* 3 arguments */
0: 	static SQLException newException(String messageID, Object a1,
0: 			Object a2, Object a3) {
0: 		return newEmbedSQLException(messageID, new Object[] {a1, a2, a3},
0:         		StandardException.getSeverityFromIdentifier(messageID));
0: 	}
0: 
0: 
0: 	public static SQLException generateCsSQLException(String error) {
0: 		return newEmbedSQLException(error,
0:         		StandardException.getSeverityFromIdentifier(error));
0: 	}
0: 
0: 	public static SQLException generateCsSQLException(String error, Object arg1)     {
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1},
0:                 StandardException.getSeverityFromIdentifier(error));
0: 	}
0: 
0: 	public static SQLException generateCsSQLException(
0:                              String error, Object arg1, Object arg2){
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1, arg2},
0:                 StandardException.getSeverityFromIdentifier(error));
0: 	}
0: 
0: 	public static SQLException generateCsSQLException(
0: 		String error, Object arg1, Object arg2, Object arg3) {
0: 
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1, arg2, arg3},
0:                 StandardException.getSeverityFromIdentifier(error));
0: 	}
0: 
0: 
0: 	static SQLException generateCsSQLException(
0:                     String error, Object arg1, Throwable t) {
0: 		return newEmbedSQLException(error,
0: 			new Object[] {arg1},
0:                 StandardException.getSeverityFromIdentifier(error), t);
0: 	}
0: 
0: 	public static SQLException generateCsSQLException(StandardException se) {
0: 		return new EmbedSQLException(
0:             	se.getMessage(), se.getMessageId(), null, se.getSeverity(), se, se.getArguments());
0: 	}
0: 
0: 	public static SQLException noCurrentConnection() {
0: 		return newEmbedSQLException(SQLState.NO_CURRENT_CONNECTION,
0:         		StandardException.getSeverityFromIdentifier(SQLState.NO_CURRENT_CONNECTION));
0: 	}
0: 
0: 	public static SQLException javaException(Throwable t) {
0: 		String name, msg;
0: 
0: 		msg = t.getMessage();
0: 		if (msg == null) msg = "";
0: 		name = t.getClass().getName();
0: 		return newEmbedSQLException(SQLState.JAVA_EXCEPTION,
0: 			new Object[] {name, msg}, ExceptionSeverity.NO_APPLICABLE_SEVERITY, t);
0: 	}
0: 
0: 
0: 	public static SQLException notImplemented() {
0: 
0: 		return newEmbedSQLException(SQLState.NOT_IMPLEMENTED,
0: 			new Object[] {MessageService.getTextMessage(MessageId.CONN_NO_DETAILS)},
0:                 StandardException.getSeverityFromIdentifier(SQLState.NOT_IMPLEMENTED));
0: 	}
0: 
0: 	public static SQLException notImplemented(String feature) {
0: 		return newEmbedSQLException(SQLState.NOT_IMPLEMENTED,
0: 			new Object[] {feature},
0:                 StandardException.getSeverityFromIdentifier(SQLState.NOT_IMPLEMENTED));
0: 	}
0: 
0: 	static SQLException setStreamFailure(IOException e) {
0: 		String msg;
0: 
0: 		msg = e.getMessage();
0: 		if (msg == null) 
0: 			msg = e.getClass().getName();
0: 		return newEmbedSQLException(SQLState.SET_STREAM_FAILURE,
0: 			new Object[] {msg},
0:                 StandardException.getSeverityFromIdentifier(SQLState.SET_STREAM_FAILURE));
0: 	}
0: 
0: 	static SQLException typeMisMatch(int targetSQLType) {
0: 		return newEmbedSQLException(SQLState.TYPE_MISMATCH,
0: 			new Object[] {typeName(targetSQLType)},
0:                 StandardException.getSeverityFromIdentifier(SQLState.TYPE_MISMATCH));
0: 	}
0: 
0: 
0:   public static String typeName(int jdbcType) {
0: 		switch (jdbcType) {
0: 			case Types.BIT 		:  return TypeId.BIT_NAME;
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN  : return TypeId.BOOLEAN_NAME;
0: 			case Types.TINYINT 	:  return TypeId.TINYINT_NAME;
0: 			case Types.SMALLINT	:  return TypeId.SMALLINT_NAME;
0: 			case Types.INTEGER 	:  return TypeId.INTEGER_NAME;
0: 			case Types.BIGINT 	:  return TypeId.LONGINT_NAME;
0: 
0: 			case Types.FLOAT 	:  return TypeId.FLOAT_NAME;
0: 			case Types.REAL 	:  return TypeId.REAL_NAME;
0: 			case Types.DOUBLE 	:  return TypeId.DOUBLE_NAME;
0: 
0: 			case Types.NUMERIC 	:  return TypeId.NUMERIC_NAME;
0: 			case Types.DECIMAL	:  return TypeId.DECIMAL_NAME;
0: 
0: 			case Types.CHAR		:  return TypeId.CHAR_NAME;
0: 			case Types.VARCHAR 	:  return TypeId.VARCHAR_NAME;
0: 			case Types.LONGVARCHAR 	:  return "LONGVARCHAR";
0:             case Types.CLOB     :  return TypeId.CLOB_NAME;
0: 
0: 			case Types.DATE 		:  return TypeId.DATE_NAME;
0: 			case Types.TIME 		:  return TypeId.TIME_NAME;
0: 			case Types.TIMESTAMP 	:  return TypeId.TIMESTAMP_NAME;
0: 
0: 			case Types.BINARY			:  return TypeId.BINARY_NAME;
0: 			case Types.VARBINARY	 	:  return TypeId.VARBINARY_NAME;
0: 			case Types.LONGVARBINARY 	:  return TypeId.LONGVARBINARY_NAME;
0:             case Types.BLOB             :  return TypeId.BLOB_NAME;
0: 
0: 			case Types.OTHER		:  return "OTHER";
0: 			case Types.JAVA_OBJECT	:  return "Types.JAVA_OBJECT";
0: 			default : return String.valueOf(jdbcType);
0: 		}
0: 	}
0: }
============================================================================