1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.RIBulkChecker
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
9:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:4cc0287: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:4cc0287: import org.apache.derby.iapi.sql.Activation;
1:4cc0287: import org.apache.derby.iapi.sql.LanguageProperties;
1:4cc0287: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:4cc0287: import org.apache.derby.iapi.sql.execute.ExecRow;
1:4cc0287: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:4cc0287: import org.apache.derby.iapi.store.access.ConglomerateController;
1:4cc0287: import org.apache.derby.iapi.store.access.GroupFetchScanController;
2:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Do a merge run comparing all the foreign keys from the
1:eac0369:  * foreign key conglomerate against the referenced keys
1:eac0369:  * from the primary key conglomerate.  The scanControllers
1:eac0369:  * are passed in by the caller (caller controls locking on
1:eac0369:  * said conglomerates).
1:eac0369:  * <p>
1:eac0369:  * The comparision is done via a merge.  Consequently,
1:eac0369:  * it is imperative that the scans are on keyed conglomerates
1:eac0369:  * (indexes) and that the referencedKeyScan is a unique scan.
1:eac0369:  * <p>
1:eac0369:  * Performance is no worse than N + M where N is foreign key 
1:eac0369:  * rows and M is primary key rows.  
1:eac0369:  * <p>
1:eac0369:  * Bulk fetch is used to further speed performance.  The
1:eac0369:  * fetch size is LanguageProperties.BULK_FETCH_DEFAULT
1:eac0369:  *
1:eac0369:  * @see LanguageProperties
1:eac0369:  */
1:eac0369: public class RIBulkChecker 
4:eac0369: {
1:eac0369: 	private static final int EQUAL = 0;
1:eac0369: 	private static final int GREATER_THAN = 1;
1:eac0369: 	private static final int LESS_THAN = -1;
1:eac0369: 
1:4cc0287:     private final long            fkCID;
1:4cc0287:     private final long            pkCID;
1:4cc0287:     private final String          schemaName;
1:4cc0287:     private final String          tableName;
1:4cc0287:     private final UUID            constraintId;
1:4cc0287:     private BackingStoreHashtable deferredRowsHashTable; // cached value
1:4cc0287:     private final LanguageConnectionContext lcc;
1:4cc0287:     private final boolean deferred; // constraint is deferred
1:4cc0287: 
1:4cc0287:     private GroupFetchScanController    referencedKeyScan;
1:eac0369: 	private DataValueDescriptor[][]		referencedKeyRowArray;
1:eac0369: 	private GroupFetchScanController	foreignKeyScan;
1:eac0369: 	private DataValueDescriptor[][]		foreignKeyRowArray;
1:eac0369: 	private ConglomerateController	unreferencedCC;
1:eac0369: 	private int 			failedCounter;
1:eac0369: 	private boolean			quitOnFirstFailure;
1:eac0369: 	private	int				numColumns;
1:eac0369: 	private	int				currRefRowIndex;
1:eac0369: 	private	int				currFKRowIndex;
1:eac0369: 	private int				lastRefRowIndex;
1:eac0369: 	private int				lastFKRowIndex;
1:eac0369: 	private ExecRow			firstRowToFail;
1:eac0369:     /**
1:eac0369:      * Create a RIBulkChecker
1:eac0369: 	 * 
1:4cc0287:      * @param a                     the activation
1:eac0369: 	 * @param referencedKeyScan		scan of the referenced key's
1:eac0369: 	 *								backing index.  must be unique
1:eac0369: 	 * @param foreignKeyScan		scan of the foreign key's
1:eac0369: 	 *								backing index
1:eac0369: 	 * @param templateRow			a template row for the indexes.
1:eac0369: 	 *								Will be cloned when it is used.
1:eac0369: 	 *								Must be a full index row.
1:eac0369: 	 * @param quitOnFirstFailure	quit on first unreferenced key
1:6b50965: 	 * @param unreferencedCC	put unreferenced keys here
1:eac0369: 	 * @param firstRowToFail		the first row that fails the constraint
1:eac0369: 	 *								is copied to this, if non-null
1:4cc0287:      * @param schemaName            schema name of the table we insert into
1:4cc0287:      * @param tableName             table name of the table we insert into
1:4cc0287:      * @param constraintId          constraint id of the foreign constraint
1:4cc0287:      * @param deferrable            {@code true} if the constraint is deferrable
1:4cc0287:      * @param fkCID                 conglomerate id of the foreign key
1:4cc0287:      *                              supporting index
1:4cc0287:      * @param pkCID                 conglomerate id of the referenced primary
1:4cc0287:      *                              key or unique index.
1:4cc0287:      * @throws org.apache.derby.iapi.error.StandardException
1:4cc0287:      *
1:eac0369:      */
1:eac0369:     public RIBulkChecker
1:eac0369: 	(
1:4cc0287:             Activation                  a,
1:eac0369: 			GroupFetchScanController    referencedKeyScan,
1:eac0369: 			GroupFetchScanController	foreignKeyScan,
1:eac0369: 			ExecRow					    templateRow,
1:eac0369: 			boolean					    quitOnFirstFailure,
1:eac0369: 			ConglomerateController	    unreferencedCC,
1:4cc0287:             ExecRow                     firstRowToFail,
1:4cc0287:             String                      schemaName,
1:4cc0287:             String                      tableName,
1:4cc0287:             UUID                        constraintId,
1:4cc0287:             boolean                     deferrable,
1:4cc0287:             long                        fkCID,
1:4cc0287:             long                        pkCID
1:4cc0287:     ) throws StandardException
1:eac0369: 	{
1:4cc0287:         this.referencedKeyScan = referencedKeyScan;
1:eac0369: 		this.foreignKeyScan = foreignKeyScan;
1:eac0369: 		this.quitOnFirstFailure = quitOnFirstFailure;
1:eac0369: 		this.unreferencedCC = unreferencedCC;
1:eac0369: 		this.firstRowToFail = firstRowToFail;
1:4cc0287:         this.constraintId = constraintId;
1:4cc0287:         this.fkCID = fkCID;
1:4cc0287:         this.pkCID = pkCID;
1:4cc0287:         this.schemaName = schemaName;
1:4cc0287:         this.tableName = tableName;
1:eac0369: 		foreignKeyRowArray		= new DataValueDescriptor[LanguageProperties.BULK_FETCH_DEFAULT_INT][];
1:eac0369: 		foreignKeyRowArray[0]	= templateRow.getRowArrayClone();
1:eac0369: 		referencedKeyRowArray	= new DataValueDescriptor[LanguageProperties.BULK_FETCH_DEFAULT_INT][];
1:eac0369: 		referencedKeyRowArray[0]= templateRow.getRowArrayClone();
1:eac0369: 		failedCounter = 0;
1:eac0369: 		numColumns = templateRow.getRowArray().length - 1;
1:eac0369: 		currFKRowIndex = -1; 
1:eac0369: 		currRefRowIndex = -1; 
1:4cc0287: 
1:4cc0287:         this.lcc = a.getLanguageConnectionContext();
1:4cc0287:         this.deferred = deferrable && lcc.isEffectivelyDeferred(
1:4cc0287:                 lcc.getCurrentSQLSessionContext(a), constraintId);
4:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:4cc0287:      * Perform the check. If deferred constraint mode, the numbers of failed
1:4cc0287:      * rows returned will be always be 0 (but any violating keys will have been
1:4cc0287:      * saved for later checking).
1:eac0369: 	 *
1:eac0369: 	 * @return the number of failed rows
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public int doCheck()
1:92268ac: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor[] foreignKey;
1:eac0369: 		DataValueDescriptor[] referencedKey;
1:eac0369: 
1:eac0369: 		int compareResult;
1:eac0369: 
1:eac0369: 		referencedKey = getNextRef();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** 	For each foreign key
1:eac0369: 	 	**
1:eac0369: 		**		while (fk > pk)
1:eac0369: 		**			next pk
1:eac0369: 		**			if no next pk
1:eac0369: 		**				failed
1:eac0369: 		**
1:eac0369: 		**		if fk != pk
1:eac0369: 		**			failed
1:eac0369: 		*/	
1:eac0369: 		while ((foreignKey = getNextFK()) != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** If all of the foreign key is not null and there are no
1:eac0369: 			** referenced keys, then everything fails
1:eac0369: 			** ANSI standard says the referential constraint is
1:eac0369: 			** satisfied if either at least one of the values of the
1:eac0369: 			** referencing columns(i.e., foreign key) is null or the
1:eac0369: 			** value of each referencing column is equal to the 
1:eac0369: 			** corresponding referenced column in the referenced table
1:eac0369: 			*/
1:eac0369: 			if (!anyNull(foreignKey) && referencedKey == null)
1:eac0369: 			{
1:eac0369: 				do
1:eac0369: 				{
1:eac0369: 					failure(foreignKey);
1:eac0369: 					if (quitOnFirstFailure)
1:eac0369: 					{
1:4cc0287:                             return failedCounter;
1:eac0369: 					}
1:eac0369: 				} while ((foreignKey = getNextFK()) != null);
1:4cc0287: 				return failedCounter;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			while ((compareResult = greaterThan(foreignKey, referencedKey)) == GREATER_THAN)
1:eac0369: 			{
1:eac0369: 				if ((referencedKey = getNextRef()) == null)
1:eac0369: 				{
1:eac0369: 					do
1:eac0369: 					{
1:eac0369: 						failure(foreignKey);
1:eac0369: 						if (quitOnFirstFailure)
1:eac0369: 						{
1:4cc0287:                             return failedCounter;
1:eac0369: 						}
1:eac0369: 					} while ((foreignKey = getNextFK()) != null);
1:eac0369: 					return failedCounter;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (compareResult != EQUAL)
1:eac0369: 			{
1:eac0369: 				failure(foreignKey);
1:eac0369: 				if (quitOnFirstFailure)
1:eac0369: 				{
1:eac0369:                     return failedCounter;
1:eac0369: 				}
1:eac0369: 			}	
1:eac0369: 		}
1:eac0369: 		return failedCounter;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Use bulk fetch to get the next set of rows,
1:eac0369: 	 * or read the next out of our internal array.
1:eac0369: 	 */
1:eac0369: 	private DataValueDescriptor[] getNextFK()
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if ((currFKRowIndex > lastFKRowIndex) ||
1:eac0369: 			(currFKRowIndex == -1))
1:eac0369: 		{
1:eac0369: 			int rowCount = 
1:eac0369:             	foreignKeyScan.fetchNextGroup(foreignKeyRowArray, (RowLocation[]) null);
1:eac0369: 
1:eac0369: 			if (rowCount == 0)
1:eac0369: 			{
1:eac0369: 				currFKRowIndex = -1;
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			lastFKRowIndex = rowCount - 1;
1:eac0369: 			currFKRowIndex = 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return foreignKeyRowArray[currFKRowIndex++];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Use bulk fetch to get the next set of rows,
1:eac0369: 	 * or read the next out of our internal array.
1:eac0369: 	 */
1:eac0369: 	private DataValueDescriptor[] getNextRef()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if ((currRefRowIndex > lastRefRowIndex) ||
1:eac0369: 			(currRefRowIndex == -1))
1:eac0369: 		{
1:eac0369: 			int rowCount = 
1:eac0369:             	referencedKeyScan.fetchNextGroup(referencedKeyRowArray, (RowLocation[]) null);
1:eac0369: 
1:eac0369: 			if (rowCount == 0)
1:eac0369: 			{
1:eac0369: 				currRefRowIndex = -1;
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			lastRefRowIndex = rowCount - 1;
1:eac0369: 			currRefRowIndex = 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return referencedKeyRowArray[currRefRowIndex++];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void failure(DataValueDescriptor[] foreignKeyRow)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:4cc0287:         if (deferred) {
1:4cc0287:             deferredRowsHashTable =
1:4cc0287:                     DeferredConstraintsMemory.rememberFKViolation(
1:4cc0287:                             lcc,
1:4cc0287:                             deferredRowsHashTable,
1:4cc0287:                             constraintId,
1:4cc0287:                             foreignKeyRow,
1:4cc0287:                             schemaName,
1:4cc0287:                             tableName);
1:4cc0287: 
1:4cc0287:         } else {
1:4cc0287:             if (failedCounter == 0)
1:4cc0287:             {
1:4cc0287:                 if (firstRowToFail != null)
1:4cc0287:                 {
1:4cc0287:                     firstRowToFail.setRowArray(foreignKeyRow);
1:4cc0287:                     // clone it
1:4cc0287:                     firstRowToFail.setRowArray(
1:4cc0287:                         firstRowToFail.getRowArrayClone());
1:4cc0287:                 }
1:4cc0287:             }
1:4cc0287: 
1:4cc0287:             failedCounter++;
1:4cc0287:             if (unreferencedCC != null)
1:4cc0287:             {
1:4cc0287:                 unreferencedCC.insert(foreignKeyRow);
1:4cc0287:             }
1:4cc0287:         }
1:eac0369: 	}	
1:eac0369: 	/*
1:eac0369: 	** Returns true if any of the foreign keys are null
1:eac0369: 	** otherwise, false.
1:eac0369: 	*/
1:eac0369: 	private boolean anyNull(DataValueDescriptor[] fkRowArray)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor	fkCol;
1:eac0369: 	
1:eac0369: 		/*
1:eac0369: 		** Check all columns excepting the row location.
1:eac0369: 		*/	
1:eac0369: 		for (int i = 0; i < numColumns; i++)
1:eac0369: 		{
1:eac0369: 			fkCol = (DataValueDescriptor)fkRowArray[i];
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If ANY column in the fk is null, 
1:eac0369: 			** return true
1:eac0369: 			*/
1:eac0369: 			if (fkCol.isNull())
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int greaterThan(DataValueDescriptor[] fkRowArray, DataValueDescriptor[] refRowArray)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor	fkCol;
1:eac0369: 		DataValueDescriptor	refCol;
1:eac0369: 		int 				result;
1:eac0369: 	
1:eac0369: 		/*
1:eac0369: 		** If ANY column in the fk is null,
1:eac0369:  		** it is assumed to be equal
1:eac0369: 		*/	
1:eac0369:  		if (anyNull(fkRowArray))
1:eac0369:                     return EQUAL;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numColumns; i++)
1:eac0369: 		{
1:eac0369: 			fkCol = (DataValueDescriptor)fkRowArray[i];
1:eac0369: 			refCol = (DataValueDescriptor)refRowArray[i];
1:eac0369: 
1:eac0369: 			result = fkCol.compare(refCol);
1:eac0369: 
1:3235c13: 			if (result > 0)
1:eac0369: 			{
1:eac0369: 				return GREATER_THAN;
1:eac0369: 			}
1:3235c13: 			else if (result < 0)
1:eac0369: 			{
1:eac0369: 				return LESS_THAN;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If they are equal, go on to the next 
1:eac0369: 			** column.
1:eac0369: 			*/
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		** If we got here they must be equal
1:eac0369: 		*/
1:eac0369: 		return EQUAL;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.LanguageProperties;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.GroupFetchScanController;
/////////////////////////////////////////////////////////////////////////
1:     private final long            fkCID;
1:     private final long            pkCID;
1:     private final String          schemaName;
1:     private final String          tableName;
1:     private final UUID            constraintId;
1:     private BackingStoreHashtable deferredRowsHashTable; // cached value
1:     private final LanguageConnectionContext lcc;
1:     private final boolean deferred; // constraint is deferred
1: 
1:     private GroupFetchScanController    referencedKeyScan;
/////////////////////////////////////////////////////////////////////////
1:      * @param a                     the activation
/////////////////////////////////////////////////////////////////////////
1:      * @param schemaName            schema name of the table we insert into
1:      * @param tableName             table name of the table we insert into
1:      * @param constraintId          constraint id of the foreign constraint
1:      * @param deferrable            {@code true} if the constraint is deferrable
1:      * @param fkCID                 conglomerate id of the foreign key
1:      *                              supporting index
1:      * @param pkCID                 conglomerate id of the referenced primary
1:      *                              key or unique index.
1:      * @throws org.apache.derby.iapi.error.StandardException
1:      *
1:             Activation                  a,
1:             ExecRow                     firstRowToFail,
1:             String                      schemaName,
1:             String                      tableName,
1:             UUID                        constraintId,
1:             boolean                     deferrable,
1:             long                        fkCID,
1:             long                        pkCID
1:     ) throws StandardException
1:         this.referencedKeyScan = referencedKeyScan;
1:         this.constraintId = constraintId;
1:         this.fkCID = fkCID;
1:         this.pkCID = pkCID;
1:         this.schemaName = schemaName;
1:         this.tableName = tableName;
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.lcc = a.getLanguageConnectionContext();
1:         this.deferred = deferrable && lcc.isEffectivelyDeferred(
1:                 lcc.getCurrentSQLSessionContext(a), constraintId);
1:      * Perform the check. If deferred constraint mode, the numbers of failed
1:      * rows returned will be always be 0 (but any violating keys will have been
1:      * saved for later checking).
/////////////////////////////////////////////////////////////////////////
1:                             return failedCounter;
/////////////////////////////////////////////////////////////////////////
1:                             return failedCounter;
/////////////////////////////////////////////////////////////////////////
1:                     return failedCounter;
/////////////////////////////////////////////////////////////////////////
1:         if (deferred) {
1:             deferredRowsHashTable =
1:                     DeferredConstraintsMemory.rememberFKViolation(
1:                             lcc,
1:                             deferredRowsHashTable,
0:                             fkCID,
0:                             pkCID,
1:                             constraintId,
1:                             foreignKeyRow,
1:                             schemaName,
1:                             tableName);
1: 
1:         } else {
1:             if (failedCounter == 0)
1:             {
1:                 if (firstRowToFail != null)
1:                 {
1:                     firstRowToFail.setRowArray(foreignKeyRow);
1:                     // clone it
1:                     firstRowToFail.setRowArray(
1:                         firstRowToFail.getRowArrayClone());
1:                 }
1:             }
1: 
1:             failedCounter++;
1:             if (unreferencedCC != null)
1:             {
1:                 unreferencedCC.insert(foreignKeyRow);
1:             }
1:         }
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
0:             unreferencedCC.insert(foreignKeyRow);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:3235c13
/////////////////////////////////////////////////////////////////////////
1: 			if (result > 0)
1: 			else if (result < 0)
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param unreferencedCC	put unreferenced keys here
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.RIBulkChecker
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.types.BooleanDataValue;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.LanguageProperties;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.GenericScanController;
0: import org.apache.derby.iapi.store.access.GroupFetchScanController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1:  * Do a merge run comparing all the foreign keys from the
1:  * foreign key conglomerate against the referenced keys
1:  * from the primary key conglomerate.  The scanControllers
1:  * are passed in by the caller (caller controls locking on
1:  * said conglomerates).
1:  * <p>
1:  * The comparision is done via a merge.  Consequently,
1:  * it is imperative that the scans are on keyed conglomerates
1:  * (indexes) and that the referencedKeyScan is a unique scan.
1:  * <p>
1:  * Performance is no worse than N + M where N is foreign key 
1:  * rows and M is primary key rows.  
1:  * <p>
1:  * Bulk fetch is used to further speed performance.  The
1:  * fetch size is LanguageProperties.BULK_FETCH_DEFAULT
1:  *
1:  * @see LanguageProperties
1:  */
1: public class RIBulkChecker 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private static final int EQUAL = 0;
1: 	private static final int GREATER_THAN = 1;
1: 	private static final int LESS_THAN = -1;
1: 
0: 	private FKInfo			fkInfo;
0: 	private GroupFetchScanController	referencedKeyScan;
1: 	private DataValueDescriptor[][]		referencedKeyRowArray;
1: 	private GroupFetchScanController	foreignKeyScan;
1: 	private DataValueDescriptor[][]		foreignKeyRowArray;
1: 	private ConglomerateController	unreferencedCC;
1: 	private int 			failedCounter;
1: 	private boolean			quitOnFirstFailure;
1: 	private	int				numColumns;
1: 	private	int				currRefRowIndex;
1: 	private	int				currFKRowIndex;
1: 	private int				lastRefRowIndex;
1: 	private int				lastFKRowIndex;
1: 	private ExecRow			firstRowToFail;
1: 
1:     /**
1:      * Create a RIBulkChecker
1: 	 * 
1: 	 * @param referencedKeyScan		scan of the referenced key's
1: 	 *								backing index.  must be unique
1: 	 * @param foreignKeyScan		scan of the foreign key's
1: 	 *								backing index
1: 	 * @param templateRow			a template row for the indexes.
1: 	 *								Will be cloned when it is used.
1: 	 *								Must be a full index row.
1: 	 * @param quitOnFirstFailure	quit on first unreferenced key
0: 	 * @param unreferencedKeysCC	put unreferenced keys here
1: 	 * @param firstRowToFail		the first row that fails the constraint
1: 	 *								is copied to this, if non-null
1:      */
1:     public RIBulkChecker
1: 	(
1: 			GroupFetchScanController    referencedKeyScan,
1: 			GroupFetchScanController	foreignKeyScan,
1: 			ExecRow					    templateRow,
1: 			boolean					    quitOnFirstFailure,
1: 			ConglomerateController	    unreferencedCC,
0: 			ExecRow					    firstRowToFail
0: 	)
1: 	{
0: 		this.referencedKeyScan = referencedKeyScan;
1: 		this.foreignKeyScan = foreignKeyScan;
1: 		this.quitOnFirstFailure = quitOnFirstFailure;
1: 		this.unreferencedCC = unreferencedCC;
1: 		this.firstRowToFail = firstRowToFail;
1: 
1: 		foreignKeyRowArray		= new DataValueDescriptor[LanguageProperties.BULK_FETCH_DEFAULT_INT][];
1: 		foreignKeyRowArray[0]	= templateRow.getRowArrayClone();
1: 		referencedKeyRowArray	= new DataValueDescriptor[LanguageProperties.BULK_FETCH_DEFAULT_INT][];
1: 		referencedKeyRowArray[0]= templateRow.getRowArrayClone();
1: 		failedCounter = 0;
1: 		numColumns = templateRow.getRowArray().length - 1;
1: 		currFKRowIndex = -1; 
1: 		currRefRowIndex = -1; 
1: 	}
1: 
1: 	/**
0: 	 * Perform the check.
1: 	 *
1: 	 * @return the number of failed rows
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public int doCheck()
1: 		throws StandardException
1: 	{
1: 		DataValueDescriptor[] foreignKey;
1: 		DataValueDescriptor[] referencedKey;
1: 
1: 		int compareResult;
1: 
1: 		referencedKey = getNextRef();
1: 
1: 		/*
1: 		** 	For each foreign key
1: 	 	**
1: 		**		while (fk > pk)
1: 		**			next pk
1: 		**			if no next pk
1: 		**				failed
1: 		**
1: 		**		if fk != pk
1: 		**			failed
1: 		*/	
1: 		while ((foreignKey = getNextFK()) != null)
1: 		{
1: 			/*
1: 			** If all of the foreign key is not null and there are no
1: 			** referenced keys, then everything fails
1: 			** ANSI standard says the referential constraint is
1: 			** satisfied if either at least one of the values of the
1: 			** referencing columns(i.e., foreign key) is null or the
1: 			** value of each referencing column is equal to the 
1: 			** corresponding referenced column in the referenced table
1: 			*/
1: 			if (!anyNull(foreignKey) && referencedKey == null)
1: 			{
1: 				do
1: 				{
1: 					failure(foreignKey);
1: 					if (quitOnFirstFailure)
1: 					{
0: 							return 1;
1: 					}
1: 				} while ((foreignKey = getNextFK()) != null);
1: 				return failedCounter;
1: 			}
1: 
1: 			while ((compareResult = greaterThan(foreignKey, referencedKey)) == GREATER_THAN)
1: 			{
1: 				if ((referencedKey = getNextRef()) == null)
1: 				{
1: 					do
1: 					{
1: 						failure(foreignKey);
1: 						if (quitOnFirstFailure)
1: 						{
0: 							return 1;
1: 						}
1: 					} while ((foreignKey = getNextFK()) != null);
1: 					return failedCounter;
1: 				}
1: 			}
1: 
1: 			if (compareResult != EQUAL)
1: 			{
1: 				failure(foreignKey);
1: 				if (quitOnFirstFailure)
1: 				{
0: 					return 1;
1: 				}
1: 			}	
1: 		}
1: 		return failedCounter;
1: 	}
1: 
1: 
1: 	/*
1: 	 * Use bulk fetch to get the next set of rows,
1: 	 * or read the next out of our internal array.
1: 	 */
1: 	private DataValueDescriptor[] getNextFK()
1: 		throws StandardException
1: 	{
1: 		if ((currFKRowIndex > lastFKRowIndex) ||
1: 			(currFKRowIndex == -1))
1: 		{
1: 			int rowCount = 
1:             	foreignKeyScan.fetchNextGroup(foreignKeyRowArray, (RowLocation[]) null);
1: 
1: 			if (rowCount == 0)
1: 			{
1: 				currFKRowIndex = -1;
1: 				return null;
1: 			}
1: 
1: 			lastFKRowIndex = rowCount - 1;
1: 			currFKRowIndex = 0;
1: 		}
1: 
1: 		return foreignKeyRowArray[currFKRowIndex++];
1: 	}
1: 
1: 	/*
1: 	 * Use bulk fetch to get the next set of rows,
1: 	 * or read the next out of our internal array.
1: 	 */
1: 	private DataValueDescriptor[] getNextRef()
1: 		throws StandardException
1: 	{
1: 		if ((currRefRowIndex > lastRefRowIndex) ||
1: 			(currRefRowIndex == -1))
1: 		{
1: 			int rowCount = 
1:             	referencedKeyScan.fetchNextGroup(referencedKeyRowArray, (RowLocation[]) null);
1: 
1: 			if (rowCount == 0)
1: 			{
1: 				currRefRowIndex = -1;
1: 				return null;
1: 			}
1: 
1: 			lastRefRowIndex = rowCount - 1;
1: 			currRefRowIndex = 0;
1: 		}
1: 
1: 		return referencedKeyRowArray[currRefRowIndex++];
1: 	}
1: 
1: 	private void failure(DataValueDescriptor[] foreignKeyRow)
1: 		throws StandardException
1: 	{
0: 		if (failedCounter == 0)
1: 		{
0: 			if (firstRowToFail != null)
1: 			{
0: 				firstRowToFail.setRowArray(foreignKeyRow);
0: 				// clone it
0: 				firstRowToFail.setRowArray(firstRowToFail.getRowArrayClone());
1: 			}
1: 		}
1: 			
0: 		failedCounter++;
0: 		if (unreferencedCC != null)
1: 		{
0: 			unreferencedCC.insert(foreignKeyRow);
1: 		}
1: 	}	
1: 	/*
1: 	** Returns true if any of the foreign keys are null
1: 	** otherwise, false.
1: 	*/
1: 	private boolean anyNull(DataValueDescriptor[] fkRowArray)
1: 		throws StandardException
1: 	{
1: 		DataValueDescriptor	fkCol;
1: 	
1: 		/*
1: 		** Check all columns excepting the row location.
1: 		*/	
1: 		for (int i = 0; i < numColumns; i++)
1: 		{
1: 			fkCol = (DataValueDescriptor)fkRowArray[i];
1: 
1: 			/*
1: 			** If ANY column in the fk is null, 
1: 			** return true
1: 			*/
1: 			if (fkCol.isNull())
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 
1: 	}
1: 
1: 	private int greaterThan(DataValueDescriptor[] fkRowArray, DataValueDescriptor[] refRowArray)
1: 		throws StandardException
1: 	{
1: 		DataValueDescriptor	fkCol;
1: 		DataValueDescriptor	refCol;
1: 		int 				result;
1: 	
1: 		/*
1: 		** If ANY column in the fk is null,
1:  		** it is assumed to be equal
1: 		*/	
1:  		if (anyNull(fkRowArray))
1:                     return EQUAL;
1: 
1: 		for (int i = 0; i < numColumns; i++)
1: 		{
1: 			fkCol = (DataValueDescriptor)fkRowArray[i];
1: 			refCol = (DataValueDescriptor)refRowArray[i];
1: 
1: 			result = fkCol.compare(refCol);
1: 
0: 			if (result == 1)
1: 			{
1: 				return GREATER_THAN;
1: 			}
0: 			else if (result == -1)
1: 			{
1: 				return LESS_THAN;
1: 			}
1: 
1: 			/*
1: 			** If they are equal, go on to the next 
1: 			** column.
1: 			*/
1: 		}
1: 		
1: 		/*
1: 		** If we got here they must be equal
1: 		*/
1: 		return EQUAL;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.LanguageProperties;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.GenericScanController;
0: import org.apache.derby.iapi.store.access.GroupFetchScanController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * Do a merge run comparing all the foreign keys from the
0:  * foreign key conglomerate against the referenced keys
0:  * from the primary key conglomerate.  The scanControllers
0:  * are passed in by the caller (caller controls locking on
0:  * said conglomerates).
0:  * <p>
0:  * The comparision is done via a merge.  Consequently,
0:  * it is imperative that the scans are on keyed conglomerates
0:  * (indexes) and that the referencedKeyScan is a unique scan.
0:  * <p>
0:  * Performance is no worse than N + M where N is foreign key 
0:  * rows and M is primary key rows.  
0:  * <p>
0:  * Bulk fetch is used to further speed performance.  The
0:  * fetch size is LanguageProperties.BULK_FETCH_DEFAULT
0:  *
0:  * @see LanguageProperties
0:  */
0: public class RIBulkChecker 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private static final int EQUAL = 0;
0: 	private static final int GREATER_THAN = 1;
0: 	private static final int LESS_THAN = -1;
0: 
0: 	private FKInfo			fkInfo;
0: 	private GroupFetchScanController	referencedKeyScan;
0: 	private DataValueDescriptor[][]		referencedKeyRowArray;
0: 	private GroupFetchScanController	foreignKeyScan;
0: 	private DataValueDescriptor[][]		foreignKeyRowArray;
0: 	private ConglomerateController	unreferencedCC;
0: 	private int 			failedCounter;
0: 	private boolean			quitOnFirstFailure;
0: 	private	int				numColumns;
0: 	private	int				currRefRowIndex;
0: 	private	int				currFKRowIndex;
0: 	private int				lastRefRowIndex;
0: 	private int				lastFKRowIndex;
0: 	private ExecRow			firstRowToFail;
0: 
0:     /**
0:      * Create a RIBulkChecker
0: 	 * 
0: 	 * @param referencedKeyScan		scan of the referenced key's
0: 	 *								backing index.  must be unique
0: 	 * @param foreignKeyScan		scan of the foreign key's
0: 	 *								backing index
0: 	 * @param templateRow			a template row for the indexes.
0: 	 *								Will be cloned when it is used.
0: 	 *								Must be a full index row.
0: 	 * @param quitOnFirstFailure	quit on first unreferenced key
0: 	 * @param unreferencedKeysCC	put unreferenced keys here
0: 	 * @param firstRowToFail		the first row that fails the constraint
0: 	 *								is copied to this, if non-null
0:      */
0:     public RIBulkChecker
0: 	(
0: 			GroupFetchScanController    referencedKeyScan,
0: 			GroupFetchScanController	foreignKeyScan,
0: 			ExecRow					    templateRow,
0: 			boolean					    quitOnFirstFailure,
0: 			ConglomerateController	    unreferencedCC,
0: 			ExecRow					    firstRowToFail
0: 	)
0: 	{
0: 		this.referencedKeyScan = referencedKeyScan;
0: 		this.foreignKeyScan = foreignKeyScan;
0: 		this.quitOnFirstFailure = quitOnFirstFailure;
0: 		this.unreferencedCC = unreferencedCC;
0: 		this.firstRowToFail = firstRowToFail;
0: 
0: 		foreignKeyRowArray		= new DataValueDescriptor[LanguageProperties.BULK_FETCH_DEFAULT_INT][];
0: 		foreignKeyRowArray[0]	= templateRow.getRowArrayClone();
0: 		referencedKeyRowArray	= new DataValueDescriptor[LanguageProperties.BULK_FETCH_DEFAULT_INT][];
0: 		referencedKeyRowArray[0]= templateRow.getRowArrayClone();
0: 		failedCounter = 0;
0: 		numColumns = templateRow.getRowArray().length - 1;
0: 		currFKRowIndex = -1; 
0: 		currRefRowIndex = -1; 
0: 	}
0: 
0: 	/**
0: 	 * Perform the check.
0: 	 *
0: 	 * @return the number of failed rows
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public int doCheck()
0: 		throws StandardException
0: 	{
0: 		DataValueDescriptor[] foreignKey;
0: 		DataValueDescriptor[] referencedKey;
0: 
0: 		int compareResult;
0: 
0: 		referencedKey = getNextRef();
0: 
0: 		/*
0: 		** 	For each foreign key
0: 	 	**
0: 		**		while (fk > pk)
0: 		**			next pk
0: 		**			if no next pk
0: 		**				failed
0: 		**
0: 		**		if fk != pk
0: 		**			failed
0: 		*/	
0: 		while ((foreignKey = getNextFK()) != null)
0: 		{
0: 			/*
0: 			** If all of the foreign key is not null and there are no
0: 			** referenced keys, then everything fails
0: 			** ANSI standard says the referential constraint is
0: 			** satisfied if either at least one of the values of the
0: 			** referencing columns(i.e., foreign key) is null or the
0: 			** value of each referencing column is equal to the 
0: 			** corresponding referenced column in the referenced table
0: 			*/
0: 			if (!anyNull(foreignKey) && referencedKey == null)
0: 			{
0: 				do
0: 				{
0: 					failure(foreignKey);
0: 					if (quitOnFirstFailure)
0: 					{
0: 							return 1;
0: 					}
0: 				} while ((foreignKey = getNextFK()) != null);
0: 				return failedCounter;
0: 			}
0: 
0: 			while ((compareResult = greaterThan(foreignKey, referencedKey)) == GREATER_THAN)
0: 			{
0: 				if ((referencedKey = getNextRef()) == null)
0: 				{
0: 					do
0: 					{
0: 						failure(foreignKey);
0: 						if (quitOnFirstFailure)
0: 						{
0: 							return 1;
0: 						}
0: 					} while ((foreignKey = getNextFK()) != null);
0: 					return failedCounter;
0: 				}
0: 			}
0: 
0: 			if (compareResult != EQUAL)
0: 			{
0: 				failure(foreignKey);
0: 				if (quitOnFirstFailure)
0: 				{
0: 					return 1;
0: 				}
0: 			}	
0: 		}
0: 		return failedCounter;
0: 	}
0: 
0: 
0: 	/*
0: 	 * Use bulk fetch to get the next set of rows,
0: 	 * or read the next out of our internal array.
0: 	 */
0: 	private DataValueDescriptor[] getNextFK()
0: 		throws StandardException
0: 	{
0: 		if ((currFKRowIndex > lastFKRowIndex) ||
0: 			(currFKRowIndex == -1))
0: 		{
0: 			int rowCount = 
0:             	foreignKeyScan.fetchNextGroup(foreignKeyRowArray, (RowLocation[]) null);
0: 
0: 			if (rowCount == 0)
0: 			{
0: 				currFKRowIndex = -1;
0: 				return null;
0: 			}
0: 
0: 			lastFKRowIndex = rowCount - 1;
0: 			currFKRowIndex = 0;
0: 		}
0: 
0: 		return foreignKeyRowArray[currFKRowIndex++];
0: 	}
0: 
0: 	/*
0: 	 * Use bulk fetch to get the next set of rows,
0: 	 * or read the next out of our internal array.
0: 	 */
0: 	private DataValueDescriptor[] getNextRef()
0: 		throws StandardException
0: 	{
0: 		if ((currRefRowIndex > lastRefRowIndex) ||
0: 			(currRefRowIndex == -1))
0: 		{
0: 			int rowCount = 
0:             	referencedKeyScan.fetchNextGroup(referencedKeyRowArray, (RowLocation[]) null);
0: 
0: 			if (rowCount == 0)
0: 			{
0: 				currRefRowIndex = -1;
0: 				return null;
0: 			}
0: 
0: 			lastRefRowIndex = rowCount - 1;
0: 			currRefRowIndex = 0;
0: 		}
0: 
0: 		return referencedKeyRowArray[currRefRowIndex++];
0: 	}
0: 
0: 	private void failure(DataValueDescriptor[] foreignKeyRow)
0: 		throws StandardException
0: 	{
0: 		if (failedCounter == 0)
0: 		{
0: 			if (firstRowToFail != null)
0: 			{
0: 				firstRowToFail.setRowArray(foreignKeyRow);
0: 				// clone it
0: 				firstRowToFail.setRowArray(firstRowToFail.getRowArrayClone());
0: 			}
0: 		}
0: 			
0: 		failedCounter++;
0: 		if (unreferencedCC != null)
0: 		{
0: 			unreferencedCC.insert(foreignKeyRow);
0: 		}
0: 	}	
0: 	/*
0: 	** Returns true if any of the foreign keys are null
0: 	** otherwise, false.
0: 	*/
0: 	private boolean anyNull(DataValueDescriptor[] fkRowArray)
0: 		throws StandardException
0: 	{
0: 		DataValueDescriptor	fkCol;
0: 	
0: 		/*
0: 		** Check all columns excepting the row location.
0: 		*/	
0: 		for (int i = 0; i < numColumns; i++)
0: 		{
0: 			fkCol = (DataValueDescriptor)fkRowArray[i];
0: 
0: 			/*
0: 			** If ANY column in the fk is null, 
0: 			** return true
0: 			*/
0: 			if (fkCol.isNull())
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 
0: 	}
0: 
0: 	private int greaterThan(DataValueDescriptor[] fkRowArray, DataValueDescriptor[] refRowArray)
0: 		throws StandardException
0: 	{
0: 		DataValueDescriptor	fkCol;
0: 		DataValueDescriptor	refCol;
0: 		int 				result;
0: 	
0: 		/*
0: 		** If ANY column in the fk is null,
0:  		** it is assumed to be equal
0: 		*/	
0:  		if (anyNull(fkRowArray))
0:                     return EQUAL;
0: 
0: 		for (int i = 0; i < numColumns; i++)
0: 		{
0: 			fkCol = (DataValueDescriptor)fkRowArray[i];
0: 			refCol = (DataValueDescriptor)refRowArray[i];
0: 
0: 			result = fkCol.compare(refCol);
0: 
0: 			if (result == 1)
0: 			{
0: 				return GREATER_THAN;
0: 			}
0: 			else if (result == -1)
0: 			{
0: 				return LESS_THAN;
0: 			}
0: 
0: 			/*
0: 			** If they are equal, go on to the next 
0: 			** column.
0: 			*/
0: 		}
0: 		
0: 		/*
0: 		** If we got here they must be equal
0: 		*/
0: 		return EQUAL;
0: 	}
0: }
============================================================================