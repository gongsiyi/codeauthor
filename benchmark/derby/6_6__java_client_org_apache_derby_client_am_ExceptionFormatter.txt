1:33776ff: /*
13:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.ExceptionFormatter
1:70f7692: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: package org.apache.derby.client.am;
1:70f7692: 
1:69e3d06: import java.io.PrintWriter;
1:69e3d06: import java.sql.BatchUpdateException;
1:69e3d06: import java.sql.DataTruncation;
1:69e3d06: import java.sql.SQLException;
1:69e3d06: import java.sql.SQLWarning;
1:69e3d06: import javax.transaction.xa.XAException;
1:69e3d06: 
1:0326967: class ExceptionFormatter {
1:70f7692:     // returnTokensOnly is true only when exception tracing is enabled so
1:70f7692:     // that we don't try to go to the server for a message while we're in
1:70f7692:     // the middle of parsing an Sqlca reply.
1:70f7692:     // Without this, if e.getMessage() fails, we would have infinite recursion
1:70f7692:     // when TRACE_DIAGNOSTICS is on  because tracing occurs within the exception constructor.
1:0326967:     static void printTrace(SqlException e,
1:69e3d06:                                   PrintWriter printWriter,
1:d506170:                                   String messageHeader,
1:d506170:                                   boolean returnTokensOnly) {
1:d506170:         String header;
1:d506170:         synchronized (printWriter) {
1:d506170:             while (e != null) {
1:d506170:                 header = messageHeader + "[" + "SQLException@" + Integer.toHexString(e.hashCode()) + "]";
1:d506170:                 printWriter.println(header + " java.sql.SQLException");
1:d506170: 
1:69e3d06:                 Throwable throwable = e.getCause();
1:d506170:                 if (throwable != null) {
1:d506170:                     printTrace(throwable, printWriter, header);
1:d506170:                 }
1:64bc46b:                 Sqlca sqlca = e.getSqlca();
2:d506170:                 if (sqlca != null) {
1:d506170:                     printTrace(sqlca, printWriter, header);
1:d506170:                     // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
1:64bc46b:                     sqlca.returnTokensOnlyInMessageText(returnTokensOnly);
1:d506170:                 }
1:d506170: 
1:d506170:                 printWriter.println(header + " SQL state  = " + e.getSQLState());
1:d506170:                 printWriter.println(header + " Error code = " + String.valueOf(e.getErrorCode()));
1:64bc46b:                 if (e.getSqlca() == null) { // Too much has changed, so escape out here.
1:d506170:                     printWriter.println(header + " Message    = " + e.getMessage());
1:d506170:                 } else { // This is server-side error.
1:64bc46b:                     sqlca = e.getSqlca();
1:d506170:                     if (returnTokensOnly) {
1:d506170:                         // print message tokens directly.
1:d506170:                         printWriter.println(header + " Tokens     = " + sqlca.getSqlErrmc()); // a string containing error tokens only
1:d506170:                     } else {
1:d506170:                         // Try to get message text from server.
1:d506170:                         String message = e.getMessage();
1:d506170:                         if (!sqlca.messageTextRetrievedContainsTokensOnly_) { // got the message text.
1:d506170:                             printWriter.println(header + " Message    = " + message);
1:d506170:                         } else { // got only message tokens.
1:694fc08:                             SqlException mysteryException = sqlca.exceptionThrownOnStoredProcInvocation_;
1:d506170:                             if (mysteryException != null &&
1:d506170:                                     (mysteryException.getErrorCode() == -440 || mysteryException.getErrorCode() == -444)) {
1:d506170:                                 printWriter.println(header + " Unable to obtain message text from server." +
1:d506170:                                         " Only message tokens are available." +
1:d506170:                                         " The stored procedure SYSIBM.SQLCAMESSAGE is not installed on server." +
1:d506170:                                         " Contact your DBA.");
1:d506170:                             } else {
1:d506170:                                 printWriter.println(header + " Error occurred while trying to obtain message text from server. " +
1:d506170:                                         "Only message tokens are available.");
1:d506170:                             }
1:d506170:                             printWriter.println(header + " Tokens     = " + message);
1:d506170:                         }
1:d506170:                     }
1:d506170:                 }
1:d506170: 
1:d506170:                 printWriter.println(header + " Stack trace follows");
1:d506170:                 e.printStackTrace(printWriter);
1:d506170: 
1:64bc46b:                 sqlca = e.getSqlca();
1:64bc46b:                 if (sqlca != null) {
1:64bc46b:                     // JDK stack trace calls e.getMessage(), now that it is finished,
1:64bc46b:                     // we can reset the state on the sqlca that says return tokens only.
1:64bc46b:                     sqlca.returnTokensOnlyInMessageText(false);
1:d506170:                 }
1:d506170: 
1:d506170:                 e = e.getNextException();
1:d506170:             }
1:d506170: 
1:d506170:             printWriter.flush();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:0326967:     static void printTrace(SQLException e,
1:69e3d06:                                   PrintWriter printWriter,
1:70f7692:                                   String messageHeader,
1:70f7692:                                   boolean returnTokensOnly) {
1:70f7692:         String header;
1:70f7692:         synchronized (printWriter) {
1:70f7692:             while (e != null) {
1:69e3d06:                 if (e instanceof DataTruncation) {
1:70f7692:                     header = messageHeader + "[" + "DataTruncation@" + Integer.toHexString(e.hashCode()) + "]";
1:70f7692:                     printWriter.println(header + " java.sql.DataTruncation");
1:69e3d06:                 } else if (e instanceof SQLWarning) {
1:70f7692:                     header = messageHeader + "[" + "SQLWarning@" + Integer.toHexString(e.hashCode()) + "]";
1:70f7692:                     printWriter.println(header + " java.sql.SQLWarning");
1:69e3d06:                 } else if (e instanceof BatchUpdateException) {
1:70f7692:                     header = messageHeader + "[" + "BatchUpdateException@" + Integer.toHexString(e.hashCode()) + "]";
1:70f7692:                     printWriter.println(header + " java.sql.BatchUpdateException");
1:69e3d06:                 } else { // e instanceof SQLException
1:70f7692:                     header = messageHeader + "[" + "SQLException@" + Integer.toHexString(e.hashCode()) + "]";
1:70f7692:                     printWriter.println(header + " java.sql.SQLException");
1:d506170:                 }
1:70f7692: 
1:70f7692:                 printWriter.println(header + " SQL state  = " + e.getSQLState());
1:70f7692:                 printWriter.println(header + " Error code = " + String.valueOf(e.getErrorCode()));
1:d506170:                 printWriter.println(header + " Message    = " + e.getMessage());
1:70f7692: 
1:69e3d06:                 if (e instanceof DataTruncation) {
1:69e3d06:                     printWriter.println(header + " Index         = " +
1:69e3d06:                                         ((DataTruncation) e).getIndex());
1:69e3d06:                     printWriter.println(header + " Parameter     = " +
1:69e3d06:                                         ((DataTruncation) e).getParameter());
1:69e3d06:                     printWriter.println(header + " Read          = " +
1:69e3d06:                                         ((DataTruncation) e).getRead());
1:69e3d06:                     printWriter.println(header + " Data size     = " +
1:69e3d06:                                         ((DataTruncation) e).getDataSize());
1:69e3d06:                     printWriter.println(header + " Transfer size = " +
1:69e3d06:                                         ((DataTruncation) e).getTransferSize());
1:d506170:                 }
1:70f7692: 
1:69e3d06:                 if (e instanceof BatchUpdateException) {
1:69e3d06:                     printWriter.println(
1:69e3d06:                         header + " Update counts = " +
1:69e3d06:                         Utils.getStringFromInts(
1:69e3d06:                             ((BatchUpdateException)e).getUpdateCounts()));
8:70f7692:                 }
1:70f7692: 
1:70f7692:                 printWriter.println(header + " Stack trace follows");
1:70f7692:                 e.printStackTrace(printWriter);
1:70f7692: 
1:70f7692:                 e = e.getNextException();
1:70f7692:             }
1:70f7692: 
1:70f7692:             printWriter.flush();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:b565f41:     private static void printTrace(Sqlca sqlca,
1:69e3d06:                                   PrintWriter printWriter,
1:70f7692:                                   String messageHeader) {
1:70f7692:         String header = messageHeader + "[" + "Sqlca@" + Integer.toHexString(sqlca.hashCode()) + "]";
1:70f7692:         synchronized (printWriter) {
1:70f7692:             printWriter.println(header + " DERBY SQLCA from server");
1:70f7692:             printWriter.println(header + " SqlCode        = " + sqlca.getSqlCode());
1:95049cf:             printWriter.println(header + " SqlErrd        = " + sqlca.formatSqlErrd());
1:70f7692:             printWriter.println(header + " SqlErrmc       = " + sqlca.getSqlErrmc());
1:70f7692:             printWriter.println(header + " SqlErrp        = " + sqlca.getSqlErrp());
1:70f7692:             printWriter.println(header + " SqlState       = " + sqlca.getSqlState());
1:95049cf:             printWriter.println(header + " SqlWarn        = " + sqlca.getSqlWarn());
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     static void printTrace(Throwable e,
1:69e3d06:                                   PrintWriter printWriter,
1:70f7692:                                   String messageHeader) {
1:70f7692:         String header = messageHeader + "[" + "Throwable@" + Integer.toHexString(e.hashCode()) + "]";
1:70f7692:         synchronized (printWriter) {
1:70f7692:             printWriter.println(header + " " + e.getClass().getName());
1:70f7692:             printWriter.println(header + " Message = " + e.getMessage());
1:70f7692:             printWriter.println(header + " Stack trace follows");
1:70f7692:             e.printStackTrace(printWriter);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     static void printTrace(XAException e,
1:69e3d06:                                   PrintWriter printWriter,
1:70f7692:                                   String messageHeader) {
1:70f7692:         String header = messageHeader + "[" + "XAException@" + Integer.toHexString(e.hashCode()) + "]";
1:70f7692:         synchronized (printWriter) {
1:70f7692:             printWriter.println(header + " javax.transaction.xa.XAException");
1:70f7692:             printWriter.println(header + " Message = " + e.getMessage());
1:70f7692:             printWriter.println(header + " Stack trace follows");
1:33776ff: 
1:70f7692:             e.printStackTrace(printWriter);
1:70f7692:         }
1:70f7692:     }
1:70f7692: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     private static void printTrace(Sqlca sqlca,
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class ExceptionFormatter {
1:     static void printTrace(SqlException e,
/////////////////////////////////////////////////////////////////////////
1:     static void printTrace(SQLException e,
/////////////////////////////////////////////////////////////////////////
0:     static void printTrace(Sqlca sqlca,
/////////////////////////////////////////////////////////////////////////
1:     static void printTrace(Throwable e,
/////////////////////////////////////////////////////////////////////////
1:     static void printTrace(XAException e,
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import java.sql.BatchUpdateException;
1: import java.sql.DataTruncation;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import javax.transaction.xa.XAException;
1: 
/////////////////////////////////////////////////////////////////////////
1:                                   PrintWriter printWriter,
/////////////////////////////////////////////////////////////////////////
1:                 Throwable throwable = e.getCause();
/////////////////////////////////////////////////////////////////////////
0:     static public void printTrace(SQLException e,
1:                                   PrintWriter printWriter,
1:                 if (e instanceof DataTruncation) {
1:                 } else if (e instanceof SQLWarning) {
1:                 } else if (e instanceof BatchUpdateException) {
1:                 } else { // e instanceof SQLException
/////////////////////////////////////////////////////////////////////////
1:                 if (e instanceof DataTruncation) {
1:                     printWriter.println(header + " Index         = " +
1:                                         ((DataTruncation) e).getIndex());
1:                     printWriter.println(header + " Parameter     = " +
1:                                         ((DataTruncation) e).getParameter());
1:                     printWriter.println(header + " Read          = " +
1:                                         ((DataTruncation) e).getRead());
1:                     printWriter.println(header + " Data size     = " +
1:                                         ((DataTruncation) e).getDataSize());
1:                     printWriter.println(header + " Transfer size = " +
1:                                         ((DataTruncation) e).getTransferSize());
1:                 if (e instanceof BatchUpdateException) {
1:                     printWriter.println(
1:                         header + " Update counts = " +
1:                         Utils.getStringFromInts(
1:                             ((BatchUpdateException)e).getUpdateCounts()));
/////////////////////////////////////////////////////////////////////////
1:                                   PrintWriter printWriter,
/////////////////////////////////////////////////////////////////////////
0:     static public void printTrace(Throwable e,
1:                                   PrintWriter printWriter,
/////////////////////////////////////////////////////////////////////////
0:     static public void printTrace(XAException e,
1:                                   PrintWriter printWriter,
commit:95049cf
/////////////////////////////////////////////////////////////////////////
1:             printWriter.println(header + " SqlErrd        = " + sqlca.formatSqlErrd());
1:             printWriter.println(header + " SqlWarn        = " + sqlca.getSqlWarn());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:64bc46b
/////////////////////////////////////////////////////////////////////////
1:                 Sqlca sqlca = e.getSqlca();
1:                     sqlca.returnTokensOnlyInMessageText(returnTokensOnly);
1:                 if (e.getSqlca() == null) { // Too much has changed, so escape out here.
1:                     sqlca = e.getSqlca();
/////////////////////////////////////////////////////////////////////////
1:                 sqlca = e.getSqlca();
1:                 if (sqlca != null) {
1:                     // JDK stack trace calls e.getMessage(), now that it is finished,
1:                     // we can reset the state on the sqlca that says return tokens only.
1:                     sqlca.returnTokensOnlyInMessageText(false);
commit:55d4cdf
/////////////////////////////////////////////////////////////////////////
0:                 java.lang.Throwable throwable = e.getCause();
/////////////////////////////////////////////////////////////////////////
commit:96889c1
/////////////////////////////////////////////////////////////////////////
commit:694fc08
/////////////////////////////////////////////////////////////////////////
1:                             SqlException mysteryException = sqlca.exceptionThrownOnStoredProcInvocation_;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d506170
/////////////////////////////////////////////////////////////////////////
0:     static public void printTrace(SqlException e,
0:                                   java.io.PrintWriter printWriter,
1:                                   String messageHeader,
1:                                   boolean returnTokensOnly) {
1:         String header;
1:         synchronized (printWriter) {
1:             while (e != null) {
1:                 header = messageHeader + "[" + "SQLException@" + Integer.toHexString(e.hashCode()) + "]";
1:                 printWriter.println(header + " java.sql.SQLException");
1: 
0:                 java.lang.Throwable throwable = null;
0:                 try {
0:                     throwable = ((Diagnosable) e).getThrowable();
0:                 } catch (java.lang.NoSuchMethodError doNothing) {
1:                 }
1:                 if (throwable != null) {
1:                     printTrace(throwable, printWriter, header);
1:                 }
0:                 Sqlca sqlca = ((Diagnosable) e).getSqlca();
1:                 if (sqlca != null) {
1:                     printTrace(sqlca, printWriter, header);
1:                     // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
0:                     ((Sqlca) sqlca).returnTokensOnlyInMessageText(returnTokensOnly);
1:                 }
1: 
1:                 printWriter.println(header + " SQL state  = " + e.getSQLState());
1:                 printWriter.println(header + " Error code = " + String.valueOf(e.getErrorCode()));
0:                 if (((Diagnosable) e).getSqlca() == null) { // Too much has changed, so escape out here.
1:                     printWriter.println(header + " Message    = " + e.getMessage());
1:                 } else { // This is server-side error.
0:                     sqlca = ((Diagnosable) e).getSqlca();
1:                     if (returnTokensOnly) {
1:                         // print message tokens directly.
1:                         printWriter.println(header + " Tokens     = " + sqlca.getSqlErrmc()); // a string containing error tokens only
1:                     } else {
1:                         // Try to get message text from server.
1:                         String message = e.getMessage();
1:                         if (!sqlca.messageTextRetrievedContainsTokensOnly_) { // got the message text.
1:                             printWriter.println(header + " Message    = " + message);
1:                         } else { // got only message tokens.
0:                             java.sql.SQLException mysteryException = sqlca.exceptionThrownOnStoredProcInvocation_;
1:                             if (mysteryException != null &&
1:                                     (mysteryException.getErrorCode() == -440 || mysteryException.getErrorCode() == -444)) {
1:                                 printWriter.println(header + " Unable to obtain message text from server." +
1:                                         " Only message tokens are available." +
1:                                         " The stored procedure SYSIBM.SQLCAMESSAGE is not installed on server." +
1:                                         " Contact your DBA.");
1:                             } else {
1:                                 printWriter.println(header + " Error occurred while trying to obtain message text from server. " +
1:                                         "Only message tokens are available.");
1:                             }
1:                             printWriter.println(header + " Tokens     = " + message);
1:                         }
1:                     }
1:                 }
1: 
1:                 printWriter.println(header + " Stack trace follows");
1:                 e.printStackTrace(printWriter);
1: 
0:                 if (e instanceof Diagnosable) {
0:                     sqlca = (Sqlca) ((Diagnosable) e).getSqlca();
1:                     if (sqlca != null) {
0:                         // JDK stack trace calls e.getMessage(), now that it is finished,
0:                         // we can reset the state on the sqlca that says return tokens only.
0:                         sqlca.returnTokensOnlyInMessageText(false);
1:                     }
1:                 }
1: 
1:                 e = e.getNextException();
1:             }
1: 
1:             printWriter.flush();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 printWriter.println(header + " Message    = " + e.getMessage());
/////////////////////////////////////////////////////////////////////////
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class ExceptionFormatter {
1:     // returnTokensOnly is true only when exception tracing is enabled so
1:     // that we don't try to go to the server for a message while we're in
1:     // the middle of parsing an Sqlca reply.
1:     // Without this, if e.getMessage() fails, we would have infinite recursion
1:     // when TRACE_DIAGNOSTICS is on  because tracing occurs within the exception constructor.
0:     static public void printTrace(java.sql.SQLException e,
0:                                   java.io.PrintWriter printWriter,
1:                                   String messageHeader,
1:                                   boolean returnTokensOnly) {
1:         String header;
1:         synchronized (printWriter) {
1:             while (e != null) {
0:                 if (e instanceof java.sql.DataTruncation) {
1:                     header = messageHeader + "[" + "DataTruncation@" + Integer.toHexString(e.hashCode()) + "]";
1:                     printWriter.println(header + " java.sql.DataTruncation");
0:                 } else if (e instanceof java.sql.SQLWarning) {
1:                     header = messageHeader + "[" + "SQLWarning@" + Integer.toHexString(e.hashCode()) + "]";
1:                     printWriter.println(header + " java.sql.SQLWarning");
0:                 } else if (e instanceof java.sql.BatchUpdateException) {
1:                     header = messageHeader + "[" + "BatchUpdateException@" + Integer.toHexString(e.hashCode()) + "]";
1:                     printWriter.println(header + " java.sql.BatchUpdateException");
0:                 } else { // e instanceof java.sql.SQLException
1:                     header = messageHeader + "[" + "SQLException@" + Integer.toHexString(e.hashCode()) + "]";
1:                     printWriter.println(header + " java.sql.SQLException");
1: 
0:                 if (e instanceof Diagnosable) {
0:                     java.lang.Throwable throwable = null;
0:                     try {
0:                         throwable = ((Diagnosable) e).getThrowable();
0:                     } catch (java.lang.NoSuchMethodError doNothing) {
1:                     }
0:                     if (throwable != null) {
0:                         printTrace(throwable, printWriter, header);
1:                     }
0:                     Sqlca sqlca = ((Diagnosable) e).getSqlca();
0:                     if (sqlca != null) {
0:                         printTrace(sqlca, printWriter, header);
0:                         // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
0:                         ((Sqlca) sqlca).returnTokensOnlyInMessageText(returnTokensOnly);
1:                     }
1: 
1:                 printWriter.println(header + " SQL state  = " + e.getSQLState());
1:                 printWriter.println(header + " Error code = " + String.valueOf(e.getErrorCode()));
0:                 if (!(e instanceof Diagnosable)) {
0:                     printWriter.println(header + " Message    = " + e.getMessage());
0:                 } else {
0:                     if (((Diagnosable) e).getSqlca() == null) { // Too much has changed, so escape out here.
0:                         printWriter.println(header + " Message    = " + e.getMessage());
0:                     } else { // This is server-side error.
0:                         Sqlca sqlca = (Sqlca) ((Diagnosable) e).getSqlca();
0:                         if (returnTokensOnly) {
0:                             // print message tokens directly.
0:                             printWriter.println(header + " Tokens     = " + sqlca.getSqlErrmc()); // a string containing error tokens only
0:                         } else {
0:                             // Try to get message text from server.
0:                             String message = e.getMessage();
0:                             if (!sqlca.messageTextRetrievedContainsTokensOnly_) { // got the message text.
0:                                 printWriter.println(header + " Message    = " + message);
0:                             } else { // got only message tokens.
0:                                 java.sql.SQLException mysteryException = sqlca.exceptionThrownOnStoredProcInvocation_;
0:                                 if (mysteryException != null &&
0:                                         (mysteryException.getErrorCode() == -440 || mysteryException.getErrorCode() == -444)) {
0:                                     printWriter.println(header + " Unable to obtain message text from server." +
0:                                             " Only message tokens are available." +
0:                                             " The stored procedure SYSIBM.SQLCAMESSAGE is not installed on server." +
0:                                             " Contact your DBA.");
0:                                 } else {
0:                                     printWriter.println(header + " Error occurred while trying to obtain message text from server. " +
0:                                             "Only message tokens are available.");
1:                                 }
0:                                 printWriter.println(header + " Tokens     = " + message);
1:                             }
1:                         }
1:                     }
1:                 }
1: 
0:                 if (e instanceof java.sql.DataTruncation) {
0:                     printWriter.println(header + " Index         = " + ((java.sql.DataTruncation) e).getIndex());
0:                     printWriter.println(header + " Parameter     = " + ((java.sql.DataTruncation) e).getParameter());
0:                     printWriter.println(header + " Read          = " + ((java.sql.DataTruncation) e).getRead());
0:                     printWriter.println(header + " Data size     = " + ((java.sql.DataTruncation) e).getDataSize());
0:                     printWriter.println(header + " Transfer size = " + ((java.sql.DataTruncation) e).getTransferSize());
1:                 }
1: 
0:                 if (e instanceof java.sql.BatchUpdateException) {
0:                     printWriter.println(header + " Update counts = " + Utils.getStringFromInts(((java.sql.BatchUpdateException) e).getUpdateCounts()));
1:                 }
1: 
1:                 printWriter.println(header + " Stack trace follows");
1:                 e.printStackTrace(printWriter);
1: 
0:                 if (e instanceof Diagnosable) {
0:                     Sqlca sqlca = (Sqlca) ((Diagnosable) e).getSqlca();
0:                     if (sqlca != null) {
0:                         // JDK stack trace calls e.getMessage(), now that it is finished,
0:                         // we can reset the state on the sqlca that says return tokens only.
0:                         sqlca.returnTokensOnlyInMessageText(false);
1:                     }
1:                 }
1: 
1:                 e = e.getNextException();
1: 
1:             printWriter.flush();
0:     static public void printTrace(Sqlca sqlca,
0:                                   java.io.PrintWriter printWriter,
1:                                   String messageHeader) {
1:         String header = messageHeader + "[" + "Sqlca@" + Integer.toHexString(sqlca.hashCode()) + "]";
1:         synchronized (printWriter) {
1:             printWriter.println(header + " DERBY SQLCA from server");
1:             printWriter.println(header + " SqlCode        = " + sqlca.getSqlCode());
0:             printWriter.println(header + " SqlErrd        = " + Utils.getStringFromInts(sqlca.getSqlErrd()));
1:             printWriter.println(header + " SqlErrmc       = " + sqlca.getSqlErrmc());
0:             printWriter.println(header + " SqlErrmcTokens = " + Utils.getStringFromStrings(sqlca.getSqlErrmcTokens()));
1:             printWriter.println(header + " SqlErrp        = " + sqlca.getSqlErrp());
1:             printWriter.println(header + " SqlState       = " + sqlca.getSqlState());
0:             printWriter.println(header + " SqlWarn        = " + new String(sqlca.getSqlWarn()));
1:         }
0:     static public void printTrace(java.lang.Throwable e,
0:                                   java.io.PrintWriter printWriter,
1:                                   String messageHeader) {
1:         String header = messageHeader + "[" + "Throwable@" + Integer.toHexString(e.hashCode()) + "]";
1:         synchronized (printWriter) {
1:             printWriter.println(header + " " + e.getClass().getName());
1:             printWriter.println(header + " Message = " + e.getMessage());
1:             printWriter.println(header + " Stack trace follows");
1:             e.printStackTrace(printWriter);
1:         }
0:     static public void printTrace(javax.transaction.xa.XAException e,
0:                                   java.io.PrintWriter printWriter,
1:                                   String messageHeader) {
1:         String header = messageHeader + "[" + "XAException@" + Integer.toHexString(e.hashCode()) + "]";
1:         synchronized (printWriter) {
1:             printWriter.println(header + " javax.transaction.xa.XAException");
1:             printWriter.println(header + " Message = " + e.getMessage());
1:             printWriter.println(header + " Stack trace follows");
1:             e.printStackTrace(printWriter);
0:             if (!((org.apache.derby.client.am.Configuration.jreLevelMajor == 1) &&
0:                     (org.apache.derby.client.am.Configuration.jreLevelMinor >= 4)) ||
0:                     (org.apache.derby.client.am.Configuration.jreLevelMajor > 1)) { // If not jre 1.4 or above, we need to print the cause if there is one
0:                 // For jre 1.4 or above, e.printStackTrace() will print the cause automatically
0:                 if (e instanceof Diagnosable) {
0:                     java.lang.Throwable throwable = null;
0:                     try {
0:                         throwable = ((Diagnosable) e).getThrowable();
0:                     } catch (java.lang.NoSuchMethodError doNothing) {
1:                     }
0:                     if (throwable != null) {
0:                         printWriter.print("Caused by: ");
0:                         if (throwable instanceof java.sql.SQLException) {
0:                             throwable.printStackTrace(printWriter);
0:                         } else {
0:                             printTrace(throwable, printWriter, header);
1:                         }
1:                     }
1:                 }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.ExceptionFormatter
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: package org.apache.derby.client.am;
1: 
0: public class ExceptionFormatter
0: {
0:   // returnTokensOnly is true only when exception tracing is enabled so
0:   // that we don't try to go to the server for a message while we're in
0:   // the middle of parsing an Sqlca reply.
0:   // Without this, if e.getMessage() fails, we would have infinite recursion
0:   // when TRACE_DIAGNOSTICS is on  because tracing occurs within the exception constructor.
0:   static public void printTrace (java.sql.SQLException e,
0:                                  java.io.PrintWriter printWriter,
0:                                  String messageHeader,
0:                                  boolean returnTokensOnly)
0:   {
0:     String header;
0:     synchronized (printWriter) {
0:       while (e != null) {
0:         if (e instanceof java.sql.DataTruncation) {
0:           header = messageHeader + "[" + "DataTruncation@" + Integer.toHexString (e.hashCode()) + "]";
0:           printWriter.println (header + " java.sql.DataTruncation");
0:         }
0:         else if (e instanceof java.sql.SQLWarning) {
0:           header = messageHeader + "[" + "SQLWarning@" + Integer.toHexString (e.hashCode()) + "]";
0:           printWriter.println (header  + " java.sql.SQLWarning");
0:         }
0:         else if (e instanceof java.sql.BatchUpdateException) {
0:           header = messageHeader + "[" + "BatchUpdateException@" + Integer.toHexString (e.hashCode()) + "]";
0:           printWriter.println (header  + " java.sql.BatchUpdateException");
0:         }
0:         else { // e instanceof java.sql.SQLException
0:           header = messageHeader + "[" + "SQLException@" + Integer.toHexString (e.hashCode()) + "]";
0:           printWriter.println (header  + " java.sql.SQLException");
0:         }
1: 
0:         if (e instanceof Diagnosable) {
0:           java.lang.Throwable throwable = null;
0:           try {
0:             throwable = ((Diagnosable) e).getThrowable();
0:           }
0:           catch (java.lang.NoSuchMethodError doNothing) {
0:           }
0:           if (throwable != null) {
0:             printTrace (throwable, printWriter, header);
0:           }
0:           Sqlca sqlca = ((Diagnosable) e).getSqlca();
0:           if (sqlca != null) {
0:             printTrace (sqlca, printWriter, header);
0:             // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
0:            ((Sqlca) sqlca).returnTokensOnlyInMessageText (returnTokensOnly);
0:           }
0:         }
1: 
0:         printWriter.println (header +   " SQL state  = " + e.getSQLState ());
0:         printWriter.println (header +   " Error code = " + String.valueOf (e.getErrorCode ()));
0:         if (!(e instanceof Diagnosable)) {
0:           printWriter.println (header +   " Message    = " + e.getMessage());
0:         }
0:         else {
0:           if (((Diagnosable) e).getSqlca() == null)
0: 	  { // Too much has changed, so escape out here.
0:             printWriter.println (header +   " Message    = " + e.getMessage());
0:           }
0:           else { // This is server-side error.
0:             Sqlca sqlca = (Sqlca) ((Diagnosable) e).getSqlca();
0:             if (returnTokensOnly) {
0:               // print message tokens directly.
0:               printWriter.println (header + " Tokens     = " + sqlca.getSqlErrmc()); // a string containing error tokens only
0:             }
0:             else {
0:               // Try to get message text from server.
0:               String message = e.getMessage();
0:               if (!sqlca.messageTextRetrievedContainsTokensOnly_) { // got the message text.
0:                 printWriter.println (header + " Message    = " + message);
0:               }
0:               else { // got only message tokens.
0:                 java.sql.SQLException mysteryException = sqlca.exceptionThrownOnStoredProcInvocation_;
0:                 if (mysteryException != null &&
0:                     (mysteryException.getErrorCode() == -440 || mysteryException.getErrorCode() == -444)) {
0:                   printWriter.println (header + " Unable to obtain message text from server." +
0:                                                 " Only message tokens are available." +
0:                                                 " The stored procedure SYSIBM.SQLCAMESSAGE is not installed on server." +
0:                                                 " Contact your DBA.");
0:                 }
0:                 else {
0:                   printWriter.println (header + " Error occurred while trying to obtain message text from server. " +
0:                                                 "Only message tokens are available.");
0:                 }
0:                 printWriter.println (header + " Tokens     = " + message);
0:               }
0:             }
0:           }
0:         }
1: 
0:         if (e instanceof java.sql.DataTruncation) {
0:           printWriter.println (header + " Index         = " + ((java.sql.DataTruncation) e).getIndex());
0:           printWriter.println (header + " Parameter     = " + ((java.sql.DataTruncation) e).getParameter());
0:           printWriter.println (header + " Read          = " + ((java.sql.DataTruncation) e).getRead());
0:           printWriter.println (header + " Data size     = " + ((java.sql.DataTruncation) e).getDataSize());
0:           printWriter.println (header + " Transfer size = " + ((java.sql.DataTruncation) e).getTransferSize());
0:         }
1: 
0:         if (e instanceof java.sql.BatchUpdateException) {
0:           printWriter.println (header + " Update counts = " + Utils.getStringFromInts (((java.sql.BatchUpdateException) e).getUpdateCounts()));
0:         }
1: 
0:         printWriter.println (header + " Stack trace follows");
0:         e.printStackTrace (printWriter);
1: 
0:         if (e instanceof Diagnosable) {
0:           Sqlca sqlca = (Sqlca) ((Diagnosable) e).getSqlca();
0:           if (sqlca != null) {
0:             // JDK stack trace calls e.getMessage(), now that it is finished,
0:             // we can reset the state on the sqlca that says return tokens only.
0:             sqlca.returnTokensOnlyInMessageText (false);
0:           }
0:         }
1: 
0:         e = e.getNextException ();
0:       }
1: 
0:       printWriter.flush();
0:     }
0:   }
1: 
0:   static public void printTrace (Sqlca sqlca,
0:                                  java.io.PrintWriter printWriter,
0:                                  String messageHeader)
0:   {
0:     String header = messageHeader + "[" + "Sqlca@" + Integer.toHexString (sqlca.hashCode()) + "]";
0:     synchronized (printWriter) {
0:       printWriter.println (header + " DERBY SQLCA from server");
0:       printWriter.println (header + " SqlCode        = " + sqlca.getSqlCode());
0:       printWriter.println (header + " SqlErrd        = " + Utils.getStringFromInts (sqlca.getSqlErrd()));
0:       printWriter.println (header + " SqlErrmc       = " + sqlca.getSqlErrmc());
0:       printWriter.println (header + " SqlErrmcTokens = " + Utils.getStringFromStrings (sqlca.getSqlErrmcTokens()));
0:       printWriter.println (header + " SqlErrp        = " + sqlca.getSqlErrp());
0:       printWriter.println (header + " SqlState       = " + sqlca.getSqlState());
0:       printWriter.println (header + " SqlWarn        = " + new String (sqlca.getSqlWarn()));
0:     }
0:   }
1: 
0:   static public void printTrace (java.lang.Throwable e,
0:                                  java.io.PrintWriter printWriter,
0:                                  String messageHeader)
0:   {
0:     String header = messageHeader + "[" + "Throwable@" + Integer.toHexString (e.hashCode()) + "]";
0:     synchronized (printWriter) {
0:       printWriter.println (header + " " + e.getClass().getName());
0:       printWriter.println (header + " Message = " + e.getMessage ());
0:       printWriter.println (header + " Stack trace follows");
0:       e.printStackTrace (printWriter);
0:     }
0:   }
1: 
0:   static public void printTrace (javax.transaction.xa.XAException e,
0:                                  java.io.PrintWriter printWriter,
0:                                  String messageHeader)
0:   {
0:     String header = messageHeader + "[" + "XAException@" + Integer.toHexString (e.hashCode()) + "]";
0:     synchronized (printWriter) {
0:       printWriter.println (header + " javax.transaction.xa.XAException");
0:       printWriter.println (header + " Message = " + e.getMessage ());
0:       printWriter.println (header + " Stack trace follows");
1: 
0:       e.printStackTrace (printWriter);
1: 
0:       if(! ((org.apache.derby.client.am.Configuration.jreLevelMajor == 1) &&
0:            (org.apache.derby.client.am.Configuration.jreLevelMinor >= 4)) ||
0:           (org.apache.derby.client.am.Configuration.jreLevelMajor > 1) )
0:       { // If not jre 1.4 or above, we need to print the cause if there is one
0:         // For jre 1.4 or above, e.printStackTrace() will print the cause automatically
0:         if (e instanceof Diagnosable) {
0:           java.lang.Throwable throwable = null;
0:           try {
0:             throwable = ((Diagnosable) e).getThrowable();
0:           }
0:           catch (java.lang.NoSuchMethodError doNothing) {
0:           }
0:           if (throwable != null)
0:           {
0:             printWriter.print ("Caused by: ");
0:             if (throwable instanceof java.sql.SQLException)
0:             {
0:               throwable.printStackTrace (printWriter);
0:             }
0:             else
0:             {
0:               printTrace (throwable, printWriter, header);
0:             }
0:           }
0:         }
0:       }
0:     }
0:   }
0: }
============================================================================