1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.HashScanResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
28:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:bd34a3a: import java.util.List;
1:b31849d: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:b31849d: import org.apache.derby.iapi.services.i18n.MessageService;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1:b31849d: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b31849d: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:b31849d: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:b31849d: import org.apache.derby.iapi.store.access.KeyHasher;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * Takes a conglomerate and a table filter builds a hash table on the 
1:eac0369:  * specified column of the conglomerate on the 1st open.  Look up into the
1:eac0369:  * hash table is done on the hash key column.  The hash table consists of
1:bd34a3a:  * either <code>DataValueDescriptor[]</code>s or <code>List</code>s of
1:bd34a3a:  * <code>DataValueDescriptor[]</code>. The store builds the hash table. When a
1:bd34a3a:  * collision occurs, the store builds a <code>List</code> with the colliding
1:bd34a3a:  * <code>DataValueDescriptor[]</code>s.
1:eac0369:  */
1:97105d6: public class HashScanResultSet extends ScanResultSet
1:eac0369: 	implements CursorResultSet
14:eac0369: {
1:eac0369: 	private boolean		hashtableBuilt;
1:eac0369: 	private ExecIndexRow	startPosition;
1:eac0369: 	private ExecIndexRow	stopPosition;
1:eac0369: 	protected	ExecRow		compactRow;
1:eac0369: 
1:eac0369: 	// Variable for managing next() logic on hash entry
1:eac0369: 	protected boolean	firstNext = true;
1:eac0369: 	private int			numFetchedOnNext;
1:eac0369: 	private int			entryVectorSize;
1:bd34a3a: 	private List		entryVector;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369:     private long conglomId;
1:eac0369:     protected StaticCompiledOpenConglomInfo scoci;
1:eac0369: 	private GeneratedMethod startKeyGetter;
1:eac0369: 	private int startSearchOperator;
1:eac0369: 	private GeneratedMethod stopKeyGetter;
1:eac0369: 	private int stopSearchOperator;
1:eac0369: 	public Qualifier[][] scanQualifiers;
1:eac0369: 	public Qualifier[][] nextQualifiers;
1:eac0369: 	private int initialCapacity;
1:eac0369: 	private float loadFactor;
1:eac0369: 	private int maxCapacity;
1:c7248d5: 	public String userSuppliedOptimizerOverrides;
1:eac0369: 	public boolean forUpdate;
1:eac0369: 	private boolean runTimeStatisticsOn;
1:eac0369: 	public int[] keyColumns;
1:eac0369: 	private boolean sameStartStopPosition;
1:eac0369: 	private boolean skipNullKeyColumns;
1:1e762f5: 	private boolean keepAfterCommit;
1:eac0369: 
1:eac0369: 	protected BackingStoreHashtable hashtable;
1:eac0369: 	protected boolean eliminateDuplicates;		// set to true in DistinctScanResultSet
1:eac0369: 
1:eac0369: 	// Run time statistics
1:eac0369: 	public Properties scanProperties;
1:eac0369: 	public String startPositionString;
1:eac0369: 	public String stopPositionString;
1:eac0369: 	public int hashtableSize;
1:eac0369: 	public boolean isConstraint;
1:eac0369: 
1:eac0369: 	public static final	int	DEFAULT_INITIAL_CAPACITY = -1;
1:eac0369: 	public static final float DEFAULT_LOADFACTOR = (float) -1.0;
1:eac0369: 	public static final	int	DEFAULT_MAX_CAPACITY = -1;
1:eac0369: 
1:eac0369: 
1:eac0369:     //
1:eac0369:     // class interface
1:eac0369:     //
1:f77f36d:     HashScanResultSet(long conglomId,
1:eac0369: 		StaticCompiledOpenConglomInfo scoci, Activation activation, 
1:959fef2: 		int resultRowTemplate,
1:eac0369: 		int resultSetNumber,
1:eac0369: 		GeneratedMethod startKeyGetter, int startSearchOperator,
1:eac0369: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
1:eac0369: 		boolean sameStartStopPosition,
1:eac0369: 		Qualifier[][] scanQualifiers,
1:eac0369: 		Qualifier[][] nextQualifiers,
1:eac0369: 		int initialCapacity,
1:eac0369: 		float loadFactor,
1:eac0369: 		int maxCapacity,
1:eac0369: 		int hashKeyItem,
1:eac0369: 		String tableName,
1:c7248d5: 		String userSuppliedOptimizerOverrides,
1:eac0369: 		String indexName,
1:eac0369: 		boolean isConstraint,
1:eac0369: 		boolean forUpdate,
1:eac0369: 		int colRefItem,
1:eac0369: 		int lockMode,
1:eac0369: 		boolean tableLocked,
1:eac0369: 		int isolationLevel,
1:eac0369: 		boolean skipNullKeyColumns,
1:eac0369: 		double optimizerEstimatedRowCount,
1:f77f36d: 		double optimizerEstimatedCost)
1:eac0369: 			throws StandardException
1:eac0369:     {
1:eac0369: 		super(activation,
1:eac0369: 				resultSetNumber,
1:959fef2: 				resultRowTemplate,
1:97105d6: 				lockMode, tableLocked, isolationLevel,
1:2ec36d1:                 colRefItem,
1:eac0369: 				optimizerEstimatedRowCount,
1:eac0369: 				optimizerEstimatedCost);
1:eac0369:         this.scoci = scoci;
1:eac0369:         this.conglomId = conglomId;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT( activation!=null, "hash scan must get activation context");
1:eac0369: 			if (sameStartStopPosition)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(stopKeyGetter == null,
1:eac0369: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
15:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.startKeyGetter = startKeyGetter;
1:eac0369: 		this.startSearchOperator = startSearchOperator;
1:eac0369: 		this.stopKeyGetter = stopKeyGetter;
1:eac0369: 		this.stopSearchOperator = stopSearchOperator;
1:eac0369: 		this.sameStartStopPosition = sameStartStopPosition;
1:eac0369: 		this.scanQualifiers = scanQualifiers;
1:eac0369: 		this.nextQualifiers = nextQualifiers;
1:eac0369: 		this.initialCapacity = initialCapacity;
1:eac0369: 		this.loadFactor = loadFactor;
1:eac0369: 		this.maxCapacity = maxCapacity;
1:eac0369:         this.tableName = tableName;
1:c7248d5:         this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;
1:eac0369:         this.indexName = indexName;
1:eac0369: 		this.isConstraint = isConstraint;
1:eac0369: 		this.forUpdate = forUpdate;
1:eac0369: 		this.skipNullKeyColumns = skipNullKeyColumns;
1:1e762f5: 		this.keepAfterCommit = activation.getResultSetHoldability();
1:eac0369: 
1:eac0369: 		/* Retrieve the hash key columns */
1:eac0369: 		FormatableArrayHolder fah = (FormatableArrayHolder)
1:eac0369: 										(activation.getPreparedStatement().
1:eac0369: 											getSavedObject(hashKeyItem));
1:473d692:         FormatableIntHolder[] fihArray =
1:473d692:                 fah.getArray(FormatableIntHolder[].class);
1:eac0369: 		keyColumns = new int[fihArray.length];
1:eac0369: 		for (int index = 0; index < fihArray.length; index++)
1:eac0369: 		{
1:eac0369: 			keyColumns[index] = fihArray[index].getInt();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		runTimeStatisticsOn = 
1:eac0369:             getLanguageConnectionContext().getRunTimeStatisticsMode();
1:eac0369: 
1:508a010:         // determine whether we should fetch row locations
1:508a010:         setRowLocationsState();
1:508a010:         
1:eac0369: 		compactRow =
1:49f3f24: 				getCompactRow(candidate, accessedCols, false);
1:7008b63: 		recordConstructorTime();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:97105d6: 	 * Can we get instantaneous locks when getting share row
1:97105d6: 	 * locks at READ COMMITTED.
1:97105d6: 	 */
1:97105d6: 	boolean canGetInstantaneousLocks() {
1:97105d6: 		return true;
1:97105d6: 	}
1:97105d6: 
1:97105d6: 	/**
1:eac0369:      * open a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
3:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to open
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException
1:eac0369: 	{
1:eac0369: 	    TransactionController tc;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
3:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT( ! isOpen, "HashScanResultSet already open");
1:eac0369: 
1:eac0369:         // Get the current transaction controller
1:eac0369:         tc = activation.getTransactionController();
1:eac0369: 
1:97105d6: 		initIsolationLevel();
1:97105d6: 
1:eac0369: 		if (startKeyGetter != null)
1:eac0369: 		{
1:eac0369: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
1:eac0369: 			if (sameStartStopPosition)
1:eac0369: 			{
1:eac0369: 				stopPosition = startPosition;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (stopKeyGetter != null)
1:eac0369: 		{
1:eac0369: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Check whether there are any comparisons with unordered nulls
1:eac0369: 		// on either the start or stop position.  If there are, we can
1:eac0369: 		// (and must) skip the scan, because no rows can qualify
1:eac0369: 		if (skipScan(startPosition, stopPosition))
1:eac0369: 		{
1:eac0369: 			// Do nothing
1:eac0369: 			;
1:eac0369: 		}
1:eac0369: 		else if (! hashtableBuilt)
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor[] startPositionRow = 
1:eac0369:                 startPosition == null ? null : startPosition.getRowArray();
1:eac0369: 			DataValueDescriptor[] stopPositionRow = 
1:eac0369:                 stopPosition == null ? null : stopPosition.getRowArray();
1:eac0369: 
1:eac0369:             hashtable = 
1:eac0369:                 tc.createBackingStoreHashtableFromScan(
1:eac0369:                     conglomId,          // conglomerate to open
1:eac0369:                     (forUpdate ? TransactionController.OPENMODE_FORUPDATE : 0),
1:eac0369:                     lockMode,
1:eac0369:                     isolationLevel,
1:eac0369:                     accessedCols, 
1:eac0369:                     startPositionRow,   
1:eac0369:                     startSearchOperator,
1:eac0369:                     scanQualifiers,
1:eac0369:                     stopPositionRow,   
1:eac0369:                     stopSearchOperator,
1:eac0369:                     -1,                 // no limit on total rows.
1:eac0369:                     keyColumns,      
1:eac0369:                     eliminateDuplicates,// remove duplicates?
1:eac0369:                     -1,                 // RESOLVE - is there a row estimate?
1:b223f72:                     maxCapacity,
1:eac0369:                     initialCapacity,    // in memory Hashtable initial capacity
1:eac0369:                     loadFactor,         // in memory Hashtable load factor
1:eac0369:                     runTimeStatisticsOn,
1:1e762f5: 					skipNullKeyColumns,
1:e81e52c: 					keepAfterCommit,
1:508a010: 					fetchRowLocations);
1:eac0369: 
1:eac0369: 			if (runTimeStatisticsOn)
1:eac0369: 			{
1:eac0369: 				hashtableSize = hashtable.size();
1:eac0369: 
1:eac0369: 				if (scanProperties == null)
1:eac0369: 				{
1:eac0369: 					scanProperties = new Properties();
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					if (hashtable != null)
1:eac0369: 					{
1:eac0369:                         hashtable.getAllRuntimeStats(scanProperties);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				catch(StandardException se)
1:eac0369: 				{
1:eac0369: 					// ignore
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			/* Remember that we created the hash table */
1:eac0369: 			hashtableBuilt = true;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Tell the activation about the number of qualifying rows.
1:eac0369: 			** Do this only here, not in reopen, because we don't want
1:eac0369: 			** to do this costly operation too often.
1:eac0369: 			*/
1:eac0369: 			activation.informOfRowCount(this, (long) hashtableSize);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	    isOpen = true;
1:eac0369: 
1:eac0369: 		resetProbeVariables();
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * reopen this ResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369: 	 */
1:eac0369: 	public void	reopenCore() throws StandardException {
1:eac0369: 		TransactionController		tc;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isOpen,
1:eac0369: 					"HashScanResultSet already open");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		resetProbeVariables();
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void resetProbeVariables() throws StandardException
1:eac0369: 	{
1:eac0369: 		firstNext = true;
1:eac0369: 		numFetchedOnNext = 0;
1:eac0369: 		entryVector = null;
1:eac0369: 		entryVectorSize = 0;
1:eac0369: 
1:eac0369: 		if (nextQualifiers != null)
1:eac0369: 		{
1:eac0369: 			clearOrderableCache(nextQualifiers);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Return the next row (if any) from the scan (if open).
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to get next row
1:eac0369: 	 */
1:eac0369: 	public ExecRow getNextRowCore() throws StandardException
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 	    ExecRow result = null;
1:eac0369: 		DataValueDescriptor[] columns = null;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen && hashtableBuilt)
1:eac0369: 	    {
1:eac0369: 			/* We use a do/while loop to ensure that we continue down
1:eac0369: 			 * the duplicate chain, if one exists, until we find a
1:eac0369: 			 * row that matches on all probe predicates (or the
1:eac0369: 			 * duplicate chain is exhausted.)
1:eac0369: 			 */
1:eac0369: 			do 
1:eac0369: 			{
1:eac0369: 				if (firstNext)
1:eac0369: 				{			  
1:eac0369: 					firstNext = false;
1:eac0369: 
1:eac0369: 					/* Hash key could be either a single column or multiple columns.
1:eac0369: 					 * If a single column, then it is the datavalue wrapper, otherwise
1:eac0369: 					 * it is a KeyHasher.
1:eac0369: 					 */
1:eac0369: 					Object hashEntry;
1:eac0369: 					if (keyColumns.length == 1)
1:eac0369: 					{
1:eac0369: 						hashEntry = hashtable.get(nextQualifiers[0][0].getOrderable());
1:eac0369: 					}
2:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						KeyHasher mh = new KeyHasher(keyColumns.length);
1:eac0369: 
1:eac0369:                         if (SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                             SanityManager.ASSERT(nextQualifiers.length == 1);
1:eac0369:                         }
1:eac0369: 
1:eac0369: 						for (int index = 0; index < keyColumns.length; index++)
1:eac0369: 						{
1:eac0369:                             // For hashing only use the AND qualifiers 
1:eac0369:                             // located in nextQualifiers[0][0...N], OR 
1:eac0369:                             // qualifiers are checked down a bit by calling
1:eac0369:                             // qualifyRow on rows returned from hash.
1:eac0369: 
1:eac0369:                             DataValueDescriptor dvd = 
1:eac0369:                                 nextQualifiers[0][index].getOrderable();
1:eac0369: 
1:eac0369:                             if (dvd == null)
1:eac0369:                             {
1:eac0369:                                 mh = null;
1:eac0369:                                 break;
1:eac0369:                             }
1:eac0369: 							mh.setObject(
1:eac0369:                                 index, nextQualifiers[0][index].getOrderable());
1:eac0369: 						}
1:eac0369: 						hashEntry = (mh == null) ? null : hashtable.get(mh);
1:eac0369: 					}
1:eac0369: 
1:bd34a3a: 					if (hashEntry instanceof List)
1:eac0369: 					{
1:bd34a3a: 						entryVector = (List) hashEntry;
1:eac0369: 						entryVectorSize = entryVector.size();
1:e81e52c: 						columns = unpackHashValue( entryVector.get( 0 ) );
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						entryVector = null;
1:eac0369: 						entryVectorSize = 0;
1:e81e52c: 						columns = unpackHashValue( hashEntry );
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				else if (numFetchedOnNext < entryVectorSize)
1:eac0369: 				{
1:bd34a3a: 					// We are walking a list and there are more rows left.
1:e81e52c: 					columns = unpackHashValue( entryVector.get( numFetchedOnNext ) );
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (columns != null)
1:eac0369: 				{
1:eac0369: 					// See if the entry satisfies all of the other qualifiers
1:eac0369: 
1:eac0369: 					/* We've already "evaluated" the 1st keyColumns qualifiers 
1:eac0369:                      * when we probed into the hash table, but we need to 
1:eac0369:                      * evaluate them again here because of the behavior of 
1:eac0369:                      * NULLs.  NULLs are treated as equal when building and 
1:eac0369:                      * probing the hash table so that we only get a single 
1:eac0369:                      * entry.  However, NULL does not equal NULL, so the 
1:eac0369:                      * compare() method below will eliminate any row that
1:eac0369: 					 * has a key column containing a NULL.
1:eac0369:                      *
1:eac0369:                      * The following code will also evaluate any OR clauses
1:eac0369:                      * that may exist, while the above hashing does not 
1:eac0369:                      * include them.
1:eac0369: 					 */
1:eac0369: 
1:eac0369: 					if (RowUtil.qualifyRow(columns, nextQualifiers))
1:eac0369: 					{
1:eac0369: 						setCompatRow(compactRow, columns);
1:eac0369: 
1:eac0369: 						rowsSeen++;
1:eac0369: 
1:eac0369: 						result = compactRow;
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						result = null;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					numFetchedOnNext++;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					result = null;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			while (result == null && numFetchedOnNext < entryVectorSize);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		setCurrentRow(result);
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 	    return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 		    clearCurrentRow();
1:eac0369: 
1:eac0369: 			if (hashtableBuilt)
1:eac0369: 			{
1:eac0369: 				// This is where we get the scan properties for a subquery
1:eac0369: 				scanProperties = getScanProperties();
1:eac0369: 				// This is where we get the positioner info for inner tables
1:eac0369: 				if (runTimeStatisticsOn)
1:eac0369: 				{
1:eac0369: 					startPositionString = printStartPosition();
1:eac0369: 					stopPositionString = printStopPosition();
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// close the hash table, eating any exception
1:eac0369: 				hashtable.close();
1:eac0369: 				hashtable = null;
1:eac0369: 				hashtableBuilt = false;
1:eac0369: 			}
1:eac0369: 			startPosition = null;
1:eac0369: 			stopPosition = null;
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of HashScanResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		/* RESOLVE - subtract out store time later, when available */
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#requiresRelocking
1:eac0369: 	 */
1:eac0369: 	public boolean requiresRelocking()
1:eac0369: 	{
1:eac0369: 		// IndexRowToBaseRow needs to relock if we didn't keep the lock
1:eac0369: 		return(
2:eac0369:             ((isolationLevel == 
1:eac0369:                  TransactionController.ISOLATION_READ_COMMITTED)            ||
4:eac0369:              (isolationLevel == 
1:eac0369:                  TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||
1:eac0369:              (isolationLevel == 
1:eac0369:                  TransactionController.ISOLATION_READ_UNCOMMITTED)));
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row location from
1:eac0369: 	 * the last fetch done. If the cursor is closed,
1:eac0369: 	 * a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isOpen) return null;
1:eac0369: 
1:eac0369: 		if ( ! hashtableBuilt)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		/* This method should only be called if the last column
1:eac0369: 		 * in the current row is a RowLocation.
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(currentRow != null,
1:eac0369: 			  "There must be a current row when fetching the row location");
1:eac0369: 			Object rlCandidate =  currentRow.getColumn(
1:eac0369: 													currentRow.nColumns());
1:eac0369: 			if (! (rlCandidate instanceof RowLocation))
1:eac0369: 			{
2:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"rlCandidate expected to be instanceof RowLocation, not " +
1:eac0369: 					rlCandidate.getClass().getName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return (RowLocation) currentRow.getColumn(
1:eac0369: 											currentRow.nColumns());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row from the last fetch done. 
1:eac0369: 	 * If the cursor is closed, a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned;
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 		/* Doesn't make sense to call this method for this node since
1:eac0369: 		 * joins are not updatable.
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT( 
1:eac0369: 			 "getCurrentRow() not expected to be called for HSRS");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String printStartPosition()
1:eac0369: 	{
1:eac0369: 		return printPosition(startSearchOperator, startKeyGetter, startPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String printStopPosition()
1:eac0369: 	{
1:eac0369: 		if (sameStartStopPosition)
1:eac0369: 		{
1:eac0369: 			return printPosition(stopSearchOperator, startKeyGetter, startPosition);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return printPosition(stopSearchOperator, stopKeyGetter, stopPosition);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a start or stop positioner as a String.
1:eac0369: 	 */
1:eac0369: 	private String printPosition(int searchOperator,
1:eac0369: 								 GeneratedMethod positionGetter,
1:eac0369: 								 ExecIndexRow eiRow)
1:eac0369: 	{
1:eac0369: 		String idt = "";
1:eac0369: 
1:eac0369: 		String output = "";
1:eac0369: 		if (positionGetter == null)
1:eac0369: 		{
1:eac0369: 			return "\t" +
1:eac0369: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1:eac0369: 					"\n";
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ExecIndexRow	positioner = null;
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			positioner = (ExecIndexRow) positionGetter.invoke(activation);
1:eac0369: 		}
1:eac0369: 		catch (StandardException e)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			if (eiRow == null)
1:eac0369: 			{
1:eac0369: 				return "\t" + MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_POSITION_NOT_AVAIL);
1:eac0369: 			}
1:eac0369: 			return "\t" + MessageService.getTextMessage(
1:eac0369: 							SQLState.LANG_UNEXPECTED_EXC_GETTING_POSITIONER) +
1:eac0369: 							"\n";
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (positioner == null)
1:eac0369: 		{
1:eac0369: 			return "\t" +
1:eac0369: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1:eac0369: 					"\n";
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		String searchOp = null;
1:eac0369: 
1:eac0369: 		switch (searchOperator)
1:eac0369: 		{
1:eac0369: 			case ScanController.GE:
1:eac0369: 				searchOp = ">=";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case ScanController.GT:
1:eac0369: 				searchOp = ">";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("Unknown search operator " +
1:eac0369: 												searchOperator);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// This is not internationalized because we should never
1:eac0369: 				// reach here.
1:eac0369: 				searchOp = "unknown value (" + searchOperator + ")";
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		output += "\t" + MessageService.getTextMessage(
1:eac0369: 										SQLState.LANG_POSITIONER,
1:eac0369: 										searchOp,
1:eac0369: 										String.valueOf(positioner.nColumns()))
1:eac0369: 										+ "\n";
1:eac0369: 			
1:eac0369: 		output += "\t" + MessageService.getTextMessage(
1:eac0369: 										SQLState.LANG_ORDERED_NULL_SEMANTICS) +
1:eac0369: 										"\n";
1:c9a1206: 		boolean colSeen = false;
1:eac0369: 		for (int position = 0; position < positioner.nColumns(); position++)
1:eac0369: 		{
1:eac0369: 			if (positioner.areNullsOrdered(position))
1:eac0369: 			{
1:eac0369: 				output = output + position + " ";
1:c9a1206: 				colSeen = true;
1:c9a1206: 			}
1:c9a1206: 
1:c9a1206: 			if (colSeen && position == positioner.nColumns() - 1) {
1:c9a1206: 				output = output +  "\n";
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:c9a1206: 		return output;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Properties getScanProperties()
1:eac0369: 	{
1:eac0369: 		return scanProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * 
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return forUpdate;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:508a010
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // determine whether we should fetch row locations
1:         setRowLocationsState();
1:         
/////////////////////////////////////////////////////////////////////////
1: 					fetchRowLocations);
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
0:     private boolean includeRowLocations = false;
/////////////////////////////////////////////////////////////////////////
1: 					keepAfterCommit,
0: 					includeRowLocations);
/////////////////////////////////////////////////////////////////////////
1: 						columns = unpackHashValue( entryVector.get( 0 ) );
1: 						columns = unpackHashValue( hashEntry );
1: 					columns = unpackHashValue( entryVector.get( numFetchedOnNext ) );
commit:b197ffa
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:473d692
/////////////////////////////////////////////////////////////////////////
1:         FormatableIntHolder[] fihArray =
1:                 fah.getArray(FormatableIntHolder[].class);
commit:959fef2
/////////////////////////////////////////////////////////////////////////
1: 		int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 				resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
commit:a280beb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:109cb26
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				resultRowAllocator,
/////////////////////////////////////////////////////////////////////////
commit:97105d6
/////////////////////////////////////////////////////////////////////////
1: public class HashScanResultSet extends ScanResultSet
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				lockMode, tableLocked, isolationLevel,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Can we get instantaneous locks when getting share row
1: 	 * locks at READ COMMITTED.
1: 	 */
1: 	boolean canGetInstantaneousLocks() {
1: 		return true;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		initIsolationLevel();
1: 
/////////////////////////////////////////////////////////////////////////
commit:bd34a3a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1:  * either <code>DataValueDescriptor[]</code>s or <code>List</code>s of
1:  * <code>DataValueDescriptor[]</code>. The store builds the hash table. When a
1:  * collision occurs, the store builds a <code>List</code> with the colliding
1:  * <code>DataValueDescriptor[]</code>s.
/////////////////////////////////////////////////////////////////////////
1: 	private List		entryVector;
/////////////////////////////////////////////////////////////////////////
1: 					if (hashEntry instanceof List)
1: 						entryVector = (List) hashEntry;
0:                             (DataValueDescriptor[]) entryVector.get(0);
/////////////////////////////////////////////////////////////////////////
1: 					// We are walking a list and there are more rows left.
0:                         entryVector.get(numFetchedOnNext);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 		boolean colSeen = false;
1: 				colSeen = true;
1: 			}
1: 
1: 			if (colSeen && position == positioner.nColumns() - 1) {
1: 				output = output +  "\n";
1: 		return output;
commit:1e762f5
/////////////////////////////////////////////////////////////////////////
1: 	private boolean keepAfterCommit;
/////////////////////////////////////////////////////////////////////////
1: 		this.keepAfterCommit = activation.getResultSetHoldability();
/////////////////////////////////////////////////////////////////////////
1: 					skipNullKeyColumns,
0: 					keepAfterCommit);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2ec36d1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 colRefItem,
/////////////////////////////////////////////////////////////////////////
commit:4e784bb
/////////////////////////////////////////////////////////////////////////
commit:49f3f24
/////////////////////////////////////////////////////////////////////////
1: 				getCompactRow(candidate, accessedCols, false);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:e8e04bf
/////////////////////////////////////////////////////////////////////////
commit:b31849d
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
1: import java.util.Properties;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.store.access.KeyHasher;
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     HashScanResultSet(long conglomId,
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.HashScanResultSet
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.Storable;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.store.access.KeyHasher;
1: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * Takes a conglomerate and a table filter builds a hash table on the 
1:  * specified column of the conglomerate on the 1st open.  Look up into the
1:  * hash table is done on the hash key column.  The hash table consists of
0:  * either DataValueDescriptor[]s or Vectors of DataValueDescriptor[].  The store builds 
0:  * the hash table.  When a collision occurs, the store builds a Vector with
0:  * the colliding DataValueDescriptor[]s.
1:  *
0:  * @author jerry
1:  */
0: public class HashScanResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private boolean		hashtableBuilt;
1: 	private ExecIndexRow	startPosition;
1: 	private ExecIndexRow	stopPosition;
0: 	protected	ExecRow		candidate; // candidate row is sparse
1: 	protected	ExecRow		compactRow;
1: 
1: 	// Variable for managing next() logic on hash entry
1: 	protected boolean	firstNext = true;
1: 	private int			numFetchedOnNext;
1: 	private int			entryVectorSize;
0: 	private Vector		entryVector;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1:     private long conglomId;
1:     protected StaticCompiledOpenConglomInfo scoci;
0: 	private GeneratedMethod resultRowAllocator;
1: 	private GeneratedMethod startKeyGetter;
1: 	private int startSearchOperator;
1: 	private GeneratedMethod stopKeyGetter;
1: 	private int stopSearchOperator;
1: 	public Qualifier[][] scanQualifiers;
1: 	public Qualifier[][] nextQualifiers;
1: 	private int initialCapacity;
1: 	private float loadFactor;
1: 	private int maxCapacity;
0: 	private GeneratedMethod closeCleanup;
0: 	public String tableName;
0: 	public String indexName;
1: 	public boolean forUpdate;
1: 	private boolean runTimeStatisticsOn;
0: 	private FormatableBitSet accessedCols;
0: 	public int isolationLevel;
0: 	public int lockMode;
1: 	public int[] keyColumns;
1: 	private boolean sameStartStopPosition;
1: 	private boolean skipNullKeyColumns;
1: 
1: 	protected BackingStoreHashtable hashtable;
1: 	protected boolean eliminateDuplicates;		// set to true in DistinctScanResultSet
1: 
1: 	// Run time statistics
1: 	public Properties scanProperties;
1: 	public String startPositionString;
1: 	public String stopPositionString;
1: 	public int hashtableSize;
1: 	public boolean isConstraint;
1: 
1: 	public static final	int	DEFAULT_INITIAL_CAPACITY = -1;
1: 	public static final float DEFAULT_LOADFACTOR = (float) -1.0;
1: 	public static final	int	DEFAULT_MAX_CAPACITY = -1;
1: 
1: 
1:     //
1:     // class interface
1:     //
0:     public HashScanResultSet(long conglomId,
1: 		StaticCompiledOpenConglomInfo scoci, Activation activation, 
0: 		GeneratedMethod resultRowAllocator, 
1: 		int resultSetNumber,
1: 		GeneratedMethod startKeyGetter, int startSearchOperator,
1: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
1: 		boolean sameStartStopPosition,
1: 		Qualifier[][] scanQualifiers,
1: 		Qualifier[][] nextQualifiers,
1: 		int initialCapacity,
1: 		float loadFactor,
1: 		int maxCapacity,
1: 		int hashKeyItem,
1: 		String tableName,
1: 		String indexName,
1: 		boolean isConstraint,
1: 		boolean forUpdate,
1: 		int colRefItem,
1: 		int lockMode,
1: 		boolean tableLocked,
1: 		int isolationLevel,
1: 		boolean skipNullKeyColumns,
1: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
1: 			throws StandardException
1:     {
1: 		super(activation,
1: 				resultSetNumber,
1: 				optimizerEstimatedRowCount,
1: 				optimizerEstimatedCost);
1:         this.scoci = scoci;
1:         this.conglomId = conglomId;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT( activation!=null, "hash scan must get activation context");
0: 			SanityManager.ASSERT( resultRowAllocator!= null, "hash scan must get row allocator");
1: 			if (sameStartStopPosition)
1: 			{
1: 				SanityManager.ASSERT(stopKeyGetter == null,
1: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
1: 			}
1: 		}
1: 
0:         this.resultRowAllocator = resultRowAllocator;
1: 
1: 		this.startKeyGetter = startKeyGetter;
1: 		this.startSearchOperator = startSearchOperator;
1: 		this.stopKeyGetter = stopKeyGetter;
1: 		this.stopSearchOperator = stopSearchOperator;
1: 		this.sameStartStopPosition = sameStartStopPosition;
1: 		this.scanQualifiers = scanQualifiers;
1: 		this.nextQualifiers = nextQualifiers;
1: 		this.initialCapacity = initialCapacity;
1: 		this.loadFactor = loadFactor;
1: 		this.maxCapacity = maxCapacity;
1:         this.tableName = tableName;
1:         this.indexName = indexName;
1: 		this.isConstraint = isConstraint;
1: 		this.forUpdate = forUpdate;
1: 		this.skipNullKeyColumns = skipNullKeyColumns;
1: 
1: 		/* Retrieve the hash key columns */
1: 		FormatableArrayHolder fah = (FormatableArrayHolder)
1: 										(activation.getPreparedStatement().
1: 											getSavedObject(hashKeyItem));
0: 		FormatableIntHolder[] fihArray = (FormatableIntHolder[]) fah.getArray(FormatableIntHolder.class);
1: 		keyColumns = new int[fihArray.length];
1: 		for (int index = 0; index < fihArray.length; index++)
1: 		{
1: 			keyColumns[index] = fihArray[index].getInt();
1: 		}
1: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedCols = null;
0: 		if (colRefItem != -1)
1: 		{
0: 			this.accessedCols = (FormatableBitSet)(activation.getPreparedStatement().
0: 										  getSavedObject(colRefItem));
1: 		}
0: 		this.lockMode = lockMode;
1: 
0: 		/* Isolation level - translate from language to store */
0: 		// If not specified, get current isolation level
0: 		if (isolationLevel == ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
1: 		{
0: 			isolationLevel = lcc.getCurrentIsolationLevel();
1: 		}
1: 
0:         if (isolationLevel == ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)
1:         {
0:             this.isolationLevel = TransactionController.ISOLATION_SERIALIZABLE;
1:         }
1:         else
1:         {
0:             /* NOTE: always do row locking on READ COMMITTED/UNCOMMITTED 
0:              *       and repeatable read scans unless the table is marked as 
0:              *       table locked (in sys.systables).
1:              *
0:              *		 We always get instantaneous locks as we will complete
0:              *		 the scan before returning any rows and we will fully
0:              *		 requalify the row if we need to go to the heap on a next().
1:              */
1: 
0:             if (! tableLocked)
1:             {
0:                 this.lockMode = TransactionController.MODE_RECORD;
1:             }
1: 
0:             if (isolationLevel == 
0:                     ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)
1:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK;
1:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL)
1:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
1:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)
1:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_REPEATABLE_READ;
1:             }
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
0:             SanityManager.ASSERT(
1:                 ((isolationLevel == 
0:                       ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)   ||
1:                  (isolationLevel == 
0:                       ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL) ||
1:                  (isolationLevel == 
0:                       ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)  ||
1:                  (isolationLevel == 
0:                       ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)),
1: 
0:                 "Invalid isolation level - " + isolationLevel);
1:         }
1: 
0:         this.closeCleanup = closeCleanup;
1: 
1: 		runTimeStatisticsOn = 
1:             getLanguageConnectionContext().getRunTimeStatisticsMode();
1: 
0: 		/* Only call row allocators once */
0: 		candidate = (ExecRow) resultRowAllocator.invoke(activation);
1: 		compactRow =
0: 				getCompactRow(candidate, accessedCols, (FormatableBitSet) null, false);
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 	/**
1:      * open a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown on failure to open
1:      */
1: 	public void	openCore() throws StandardException
1: 	{
1: 	    TransactionController tc;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT( ! isOpen, "HashScanResultSet already open");
1: 
1:         // Get the current transaction controller
1:         tc = activation.getTransactionController();
1: 
1: 		if (startKeyGetter != null)
1: 		{
1: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
1: 			if (sameStartStopPosition)
1: 			{
1: 				stopPosition = startPosition;
1: 			}
1: 		}
1: 		if (stopKeyGetter != null)
1: 		{
1: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
1: 		}
1: 
1: 		// Check whether there are any comparisons with unordered nulls
1: 		// on either the start or stop position.  If there are, we can
1: 		// (and must) skip the scan, because no rows can qualify
1: 		if (skipScan(startPosition, stopPosition))
1: 		{
1: 			// Do nothing
1: 			;
1: 		}
1: 		else if (! hashtableBuilt)
1: 		{
1: 			DataValueDescriptor[] startPositionRow = 
1:                 startPosition == null ? null : startPosition.getRowArray();
1: 			DataValueDescriptor[] stopPositionRow = 
1:                 stopPosition == null ? null : stopPosition.getRowArray();
1: 
1:             hashtable = 
1:                 tc.createBackingStoreHashtableFromScan(
1:                     conglomId,          // conglomerate to open
1:                     (forUpdate ? TransactionController.OPENMODE_FORUPDATE : 0),
1:                     lockMode,
1:                     isolationLevel,
1:                     accessedCols, 
1:                     startPositionRow,   
1:                     startSearchOperator,
1:                     scanQualifiers,
1:                     stopPositionRow,   
1:                     stopSearchOperator,
1:                     -1,                 // no limit on total rows.
1:                     keyColumns,      
1:                     eliminateDuplicates,// remove duplicates?
1:                     -1,                 // RESOLVE - is there a row estimate?
0:                     -1,                 // RESOLVE - when should it go to disk?
1:                     initialCapacity,    // in memory Hashtable initial capacity
1:                     loadFactor,         // in memory Hashtable load factor
1:                     runTimeStatisticsOn,
0: 					skipNullKeyColumns); 
1: 
1: 
1: 			if (runTimeStatisticsOn)
1: 			{
1: 				hashtableSize = hashtable.size();
1: 
1: 				if (scanProperties == null)
1: 				{
1: 					scanProperties = new Properties();
1: 				}
1: 
1: 				try
1: 				{
1: 					if (hashtable != null)
1: 					{
1:                         hashtable.getAllRuntimeStats(scanProperties);
1: 					}
1: 				}
1: 				catch(StandardException se)
1: 				{
1: 					// ignore
1: 				}
1: 			}
1: 
1: 
1: 			/* Remember that we created the hash table */
1: 			hashtableBuilt = true;
1: 
1: 			/*
1: 			** Tell the activation about the number of qualifying rows.
1: 			** Do this only here, not in reopen, because we don't want
1: 			** to do this costly operation too often.
1: 			*/
1: 			activation.informOfRowCount(this, (long) hashtableSize);
1: 		}
1: 
1: 	    isOpen = true;
1: 
1: 		resetProbeVariables();
1: 
1: 		numOpens++;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * reopen this ResultSet.
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1: 	 */
1: 	public void	reopenCore() throws StandardException {
1: 		TransactionController		tc;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isOpen,
1: 					"HashScanResultSet already open");
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		resetProbeVariables();
1: 
1: 		numOpens++;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	private void resetProbeVariables() throws StandardException
1: 	{
1: 		firstNext = true;
1: 		numFetchedOnNext = 0;
1: 		entryVector = null;
1: 		entryVectorSize = 0;
1: 
1: 		if (nextQualifiers != null)
1: 		{
1: 			clearOrderableCache(nextQualifiers);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1:      * Return the next row (if any) from the scan (if open).
1: 	 *
1: 	 * @exception StandardException thrown on failure to get next row
1: 	 */
1: 	public ExecRow getNextRowCore() throws StandardException
1: 	{
1: 	    ExecRow result = null;
1: 		DataValueDescriptor[] columns = null;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen && hashtableBuilt)
1: 	    {
1: 			/* We use a do/while loop to ensure that we continue down
1: 			 * the duplicate chain, if one exists, until we find a
1: 			 * row that matches on all probe predicates (or the
1: 			 * duplicate chain is exhausted.)
1: 			 */
1: 			do 
1: 			{
1: 				if (firstNext)
1: 				{			  
1: 					firstNext = false;
1: 
1: 					/* Hash key could be either a single column or multiple columns.
1: 					 * If a single column, then it is the datavalue wrapper, otherwise
1: 					 * it is a KeyHasher.
1: 					 */
1: 					Object hashEntry;
1: 					if (keyColumns.length == 1)
1: 					{
1: 						hashEntry = hashtable.get(nextQualifiers[0][0].getOrderable());
1: 					}
1: 					else
1: 					{
1: 						KeyHasher mh = new KeyHasher(keyColumns.length);
1: 
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             SanityManager.ASSERT(nextQualifiers.length == 1);
1:                         }
1: 
1: 						for (int index = 0; index < keyColumns.length; index++)
1: 						{
1:                             // For hashing only use the AND qualifiers 
1:                             // located in nextQualifiers[0][0...N], OR 
1:                             // qualifiers are checked down a bit by calling
1:                             // qualifyRow on rows returned from hash.
1: 
1:                             DataValueDescriptor dvd = 
1:                                 nextQualifiers[0][index].getOrderable();
1: 
1:                             if (dvd == null)
1:                             {
1:                                 mh = null;
1:                                 break;
1:                             }
1: 							mh.setObject(
1:                                 index, nextQualifiers[0][index].getOrderable());
1: 						}
1: 						hashEntry = (mh == null) ? null : hashtable.get(mh);
1: 					}
1: 
0: 					if (hashEntry instanceof Vector)
1: 					{
0: 						entryVector = (Vector) hashEntry;
1: 						entryVectorSize = entryVector.size();
0: 						columns = 
0:                             (DataValueDescriptor[]) entryVector.firstElement();
1: 					}
1: 					else
1: 					{
1: 						entryVector = null;
1: 						entryVectorSize = 0;
0: 						columns = (DataValueDescriptor[]) hashEntry;
1: 					}
1: 				}
1: 				else if (numFetchedOnNext < entryVectorSize)
1: 				{
0: 					/* We walking a Vector and there's 
0: 					 * more rows left in the vector.
1: 					 */
0: 					columns = (DataValueDescriptor[]) 
0:                         entryVector.elementAt(numFetchedOnNext);
1: 				}
1: 
1: 				if (columns != null)
1: 				{
1: 					if (SanityManager.DEBUG)
1: 					{
0: 						// There used to be an assertion here that the columns
0: 						// array was the same size as the number of columns
0: 						// in the compact row. This assertion no longer holds
0: 						// now that we're doing sparse rows, so I deleted it.
1: 
0: 						// Columns is really a Storable[]
0: 						for (int i = 0; i < columns.length; i++)
1: 						{
0: 							if (columns[i] != null &&
0: 								! (columns[i] instanceof Storable))
1: 							{
1: 								SanityManager.THROWASSERT(
0: 								"columns[" + i + "] expected to be Storable, not " +
0: 								columns[i].getClass().getName());
1: 							}
1: 						}
1: 					}
1: 
1: 					// See if the entry satisfies all of the other qualifiers
1: 
1: 					/* We've already "evaluated" the 1st keyColumns qualifiers 
1:                      * when we probed into the hash table, but we need to 
1:                      * evaluate them again here because of the behavior of 
1:                      * NULLs.  NULLs are treated as equal when building and 
1:                      * probing the hash table so that we only get a single 
1:                      * entry.  However, NULL does not equal NULL, so the 
1:                      * compare() method below will eliminate any row that
1: 					 * has a key column containing a NULL.
1:                      *
1:                      * The following code will also evaluate any OR clauses
1:                      * that may exist, while the above hashing does not 
1:                      * include them.
1: 					 */
1: 
1: 					if (RowUtil.qualifyRow(columns, nextQualifiers))
1: 					{
1: 						setCompatRow(compactRow, columns);
1: 
1: 						rowsSeen++;
1: 
1: 						result = compactRow;
1: 					}
1: 					else
1: 					{
1: 						result = null;
1: 					}
1: 
1: 					numFetchedOnNext++;
1: 				}
1: 				else
1: 				{
1: 					result = null;
1: 				}
1: 			}
1: 			while (result == null && numFetchedOnNext < entryVectorSize);
1: 
1: 		}
1: 
0: 		currentRow = result;
1: 		setCurrentRow(result);
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 	    return result;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1:  	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if ( isOpen )
1: 	    {
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
1: 
0: 			currentRow = null;
1: 			if (hashtableBuilt)
1: 			{
1: 				// This is where we get the scan properties for a subquery
1: 				scanProperties = getScanProperties();
1: 				// This is where we get the positioner info for inner tables
1: 				if (runTimeStatisticsOn)
1: 				{
1: 					startPositionString = printStartPosition();
1: 					stopPositionString = printStopPosition();
1: 				}
1: 
1: 				// close the hash table, eating any exception
1: 				hashtable.close();
1: 				hashtable = null;
1: 				hashtableBuilt = false;
1: 			}
1: 			startPosition = null;
1: 			stopPosition = null;
1: 
1: 			super.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of HashScanResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		/* RESOLVE - subtract out store time later, when available */
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime;
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * @see NoPutResultSet#getScanIsolationLevel
1: 	 */
0: 	public int getScanIsolationLevel()
1: 	{
0: 		return isolationLevel;
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#requiresRelocking
1: 	 */
1: 	public boolean requiresRelocking()
1: 	{
1: 		// IndexRowToBaseRow needs to relock if we didn't keep the lock
1: 		return(
1:             ((isolationLevel == 
1:                  TransactionController.ISOLATION_READ_COMMITTED)            ||
1:              (isolationLevel == 
1:                  TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||
1:              (isolationLevel == 
1:                  TransactionController.ISOLATION_READ_UNCOMMITTED)));
1: 
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * This result set has its row location from
1: 	 * the last fetch done. If the cursor is closed,
1: 	 * a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException
1: 	{
1: 		if (! isOpen) return null;
1: 
1: 		if ( ! hashtableBuilt)
1: 			return null;
1: 
1: 		/* This method should only be called if the last column
1: 		 * in the current row is a RowLocation.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(currentRow != null,
1: 			  "There must be a current row when fetching the row location");
1: 			Object rlCandidate =  currentRow.getColumn(
1: 													currentRow.nColumns());
1: 			if (! (rlCandidate instanceof RowLocation))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"rlCandidate expected to be instanceof RowLocation, not " +
1: 					rlCandidate.getClass().getName());
1: 			}
1: 		}
1: 
1: 		return (RowLocation) currentRow.getColumn(
1: 											currentRow.nColumns());
1: 	}
1: 
1: 	/**
1: 	 * This result set has its row from the last fetch done. 
1: 	 * If the cursor is closed, a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned;
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException 
1: 	{
1: 		/* Doesn't make sense to call this method for this node since
1: 		 * joins are not updatable.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT( 
1: 			 "getCurrentRow() not expected to be called for HSRS");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	public String printStartPosition()
1: 	{
1: 		return printPosition(startSearchOperator, startKeyGetter, startPosition);
1: 	}
1: 
1: 	public String printStopPosition()
1: 	{
1: 		if (sameStartStopPosition)
1: 		{
1: 			return printPosition(stopSearchOperator, startKeyGetter, startPosition);
1: 		}
1: 		else
1: 		{
1: 			return printPosition(stopSearchOperator, stopKeyGetter, stopPosition);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return a start or stop positioner as a String.
1: 	 */
1: 	private String printPosition(int searchOperator,
1: 								 GeneratedMethod positionGetter,
1: 								 ExecIndexRow eiRow)
1: 	{
1: 		String idt = "";
1: 
1: 		String output = "";
1: 		if (positionGetter == null)
1: 		{
1: 			return "\t" +
1: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1: 					"\n";
1: 		}
1: 
1: 		ExecIndexRow	positioner = null;
1: 
1: 		try
1: 		{
1: 			positioner = (ExecIndexRow) positionGetter.invoke(activation);
1: 		}
1: 		catch (StandardException e)
1: 		{
1: 
1: 			if (eiRow == null)
1: 			{
1: 				return "\t" + MessageService.getTextMessage(
1: 											SQLState.LANG_POSITION_NOT_AVAIL);
1: 			}
1: 			return "\t" + MessageService.getTextMessage(
1: 							SQLState.LANG_UNEXPECTED_EXC_GETTING_POSITIONER) +
1: 							"\n";
1: 		}
1: 
1: 		if (positioner == null)
1: 		{
1: 			return "\t" +
1: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1: 					"\n";
1: 		}
1: 
1: 		String searchOp = null;
1: 
1: 		switch (searchOperator)
1: 		{
1: 			case ScanController.GE:
1: 				searchOp = ">=";
1: 				break;
1: 
1: 			case ScanController.GT:
1: 				searchOp = ">";
1: 				break;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("Unknown search operator " +
1: 												searchOperator);
1: 				}
1: 
1: 				// This is not internationalized because we should never
1: 				// reach here.
1: 				searchOp = "unknown value (" + searchOperator + ")";
1: 				break;
1: 		}
1: 
1: 		output += "\t" + MessageService.getTextMessage(
1: 										SQLState.LANG_POSITIONER,
1: 										searchOp,
1: 										String.valueOf(positioner.nColumns()))
1: 										+ "\n";
1: 			
1: 		output += "\t" + MessageService.getTextMessage(
1: 										SQLState.LANG_ORDERED_NULL_SEMANTICS) +
1: 										"\n";
1: 		for (int position = 0; position < positioner.nColumns(); position++)
1: 		{
1: 			if (positioner.areNullsOrdered(position))
1: 			{
1: 				output = output + position + " ";
1: 			}
1: 		}
1: 		
0: 		return output + "\n";
1: 	}
1: 
1: 	public Properties getScanProperties()
1: 	{
1: 		return scanProperties;
1: 	}
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * 
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return forUpdate;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 	public String userSuppliedOptimizerOverrides;
/////////////////////////////////////////////////////////////////////////
1: 		String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1:         this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1:                     maxCapacity,
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.store.access.KeyHasher;
0: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * Takes a conglomerate and a table filter builds a hash table on the 
0:  * specified column of the conglomerate on the 1st open.  Look up into the
0:  * hash table is done on the hash key column.  The hash table consists of
0:  * either DataValueDescriptor[]s or Vectors of DataValueDescriptor[].  The store builds 
0:  * the hash table.  When a collision occurs, the store builds a Vector with
0:  * the colliding DataValueDescriptor[]s.
0:  *
0:  * @author jerry
0:  */
0: public class HashScanResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private boolean		hashtableBuilt;
0: 	private ExecIndexRow	startPosition;
0: 	private ExecIndexRow	stopPosition;
0: 	protected	ExecRow		candidate; // candidate row is sparse
0: 	protected	ExecRow		compactRow;
0: 
0: 	// Variable for managing next() logic on hash entry
0: 	protected boolean	firstNext = true;
0: 	private int			numFetchedOnNext;
0: 	private int			entryVectorSize;
0: 	private Vector		entryVector;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0:     private long conglomId;
0:     protected StaticCompiledOpenConglomInfo scoci;
0: 	private GeneratedMethod resultRowAllocator;
0: 	private GeneratedMethod startKeyGetter;
0: 	private int startSearchOperator;
0: 	private GeneratedMethod stopKeyGetter;
0: 	private int stopSearchOperator;
0: 	public Qualifier[][] scanQualifiers;
0: 	public Qualifier[][] nextQualifiers;
0: 	private int initialCapacity;
0: 	private float loadFactor;
0: 	private int maxCapacity;
0: 	private GeneratedMethod closeCleanup;
0: 	public String tableName;
0: 	public String indexName;
0: 	public boolean forUpdate;
0: 	private boolean runTimeStatisticsOn;
0: 	private FormatableBitSet accessedCols;
0: 	public int isolationLevel;
0: 	public int lockMode;
0: 	public int[] keyColumns;
0: 	private boolean sameStartStopPosition;
0: 	private boolean skipNullKeyColumns;
0: 
0: 	protected BackingStoreHashtable hashtable;
0: 	protected boolean eliminateDuplicates;		// set to true in DistinctScanResultSet
0: 
0: 	// Run time statistics
0: 	public Properties scanProperties;
0: 	public String startPositionString;
0: 	public String stopPositionString;
0: 	public int hashtableSize;
0: 	public boolean isConstraint;
0: 
0: 	public static final	int	DEFAULT_INITIAL_CAPACITY = -1;
0: 	public static final float DEFAULT_LOADFACTOR = (float) -1.0;
0: 	public static final	int	DEFAULT_MAX_CAPACITY = -1;
0: 
0: 
0:     //
0:     // class interface
0:     //
0:     public HashScanResultSet(long conglomId,
0: 		StaticCompiledOpenConglomInfo scoci, Activation activation, 
0: 		GeneratedMethod resultRowAllocator, 
0: 		int resultSetNumber,
0: 		GeneratedMethod startKeyGetter, int startSearchOperator,
0: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
0: 		boolean sameStartStopPosition,
0: 		Qualifier[][] scanQualifiers,
0: 		Qualifier[][] nextQualifiers,
0: 		int initialCapacity,
0: 		float loadFactor,
0: 		int maxCapacity,
0: 		int hashKeyItem,
0: 		String tableName,
0: 		String indexName,
0: 		boolean isConstraint,
0: 		boolean forUpdate,
0: 		int colRefItem,
0: 		int lockMode,
0: 		boolean tableLocked,
0: 		int isolationLevel,
0: 		boolean skipNullKeyColumns,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
0: 			throws StandardException
0:     {
0: 		super(activation,
0: 				resultSetNumber,
0: 				optimizerEstimatedRowCount,
0: 				optimizerEstimatedCost);
0:         this.scoci = scoci;
0:         this.conglomId = conglomId;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT( activation!=null, "hash scan must get activation context");
0: 			SanityManager.ASSERT( resultRowAllocator!= null, "hash scan must get row allocator");
0: 			if (sameStartStopPosition)
0: 			{
0: 				SanityManager.ASSERT(stopKeyGetter == null,
0: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
0: 			}
0: 		}
0: 
0:         this.resultRowAllocator = resultRowAllocator;
0: 
0: 		this.startKeyGetter = startKeyGetter;
0: 		this.startSearchOperator = startSearchOperator;
0: 		this.stopKeyGetter = stopKeyGetter;
0: 		this.stopSearchOperator = stopSearchOperator;
0: 		this.sameStartStopPosition = sameStartStopPosition;
0: 		this.scanQualifiers = scanQualifiers;
0: 		this.nextQualifiers = nextQualifiers;
0: 		this.initialCapacity = initialCapacity;
0: 		this.loadFactor = loadFactor;
0: 		this.maxCapacity = maxCapacity;
0:         this.tableName = tableName;
0:         this.indexName = indexName;
0: 		this.isConstraint = isConstraint;
0: 		this.forUpdate = forUpdate;
0: 		this.skipNullKeyColumns = skipNullKeyColumns;
0: 
0: 		/* Retrieve the hash key columns */
0: 		FormatableArrayHolder fah = (FormatableArrayHolder)
0: 										(activation.getPreparedStatement().
0: 											getSavedObject(hashKeyItem));
0: 		FormatableIntHolder[] fihArray = (FormatableIntHolder[]) fah.getArray(FormatableIntHolder.class);
0: 		keyColumns = new int[fihArray.length];
0: 		for (int index = 0; index < fihArray.length; index++)
0: 		{
0: 			keyColumns[index] = fihArray[index].getInt();
0: 		}
0: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedCols = null;
0: 		if (colRefItem != -1)
0: 		{
0: 			this.accessedCols = (FormatableBitSet)(activation.getPreparedStatement().
0: 										  getSavedObject(colRefItem));
0: 		}
0: 		this.lockMode = lockMode;
0: 
0: 		/* Isolation level - translate from language to store */
0: 		// If not specified, get current isolation level
0: 		if (isolationLevel == ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
0: 		{
0: 			isolationLevel = lcc.getCurrentIsolationLevel();
0: 		}
0: 
0:         if (isolationLevel == ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)
0:         {
0:             this.isolationLevel = TransactionController.ISOLATION_SERIALIZABLE;
0:         }
0:         else
0:         {
0:             /* NOTE: always do row locking on READ COMMITTED/UNCOMMITTED 
0:              *       and repeatable read scans unless the table is marked as 
0:              *       table locked (in sys.systables).
0:              *
0:              *		 We always get instantaneous locks as we will complete
0:              *		 the scan before returning any rows and we will fully
0:              *		 requalify the row if we need to go to the heap on a next().
0:              */
0: 
0:             if (! tableLocked)
0:             {
0:                 this.lockMode = TransactionController.MODE_RECORD;
0:             }
0: 
0:             if (isolationLevel == 
0:                     ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)
0:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK;
0:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL)
0:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
0:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)
0:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_REPEATABLE_READ;
0:             }
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 ((isolationLevel == 
0:                       ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)   ||
0:                  (isolationLevel == 
0:                       ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL) ||
0:                  (isolationLevel == 
0:                       ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)  ||
0:                  (isolationLevel == 
0:                       ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)),
0: 
0:                 "Invalid isolation level - " + isolationLevel);
0:         }
0: 
0:         this.closeCleanup = closeCleanup;
0: 
0: 		runTimeStatisticsOn = 
0:             getLanguageConnectionContext().getRunTimeStatisticsMode();
0: 
0: 		/* Only call row allocators once */
0: 		candidate = (ExecRow) resultRowAllocator.invoke(activation);
0: 		compactRow =
0: 				getCompactRow(candidate, accessedCols, (FormatableBitSet) null, false);
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 	/**
0:      * open a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown on failure to open
0:      */
0: 	public void	openCore() throws StandardException
0: 	{
0: 	    TransactionController tc;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT( ! isOpen, "HashScanResultSet already open");
0: 
0:         // Get the current transaction controller
0:         tc = activation.getTransactionController();
0: 
0: 		if (startKeyGetter != null)
0: 		{
0: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
0: 			if (sameStartStopPosition)
0: 			{
0: 				stopPosition = startPosition;
0: 			}
0: 		}
0: 		if (stopKeyGetter != null)
0: 		{
0: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
0: 		}
0: 
0: 		// Check whether there are any comparisons with unordered nulls
0: 		// on either the start or stop position.  If there are, we can
0: 		// (and must) skip the scan, because no rows can qualify
0: 		if (skipScan(startPosition, stopPosition))
0: 		{
0: 			// Do nothing
0: 			;
0: 		}
0: 		else if (! hashtableBuilt)
0: 		{
0: 			DataValueDescriptor[] startPositionRow = 
0:                 startPosition == null ? null : startPosition.getRowArray();
0: 			DataValueDescriptor[] stopPositionRow = 
0:                 stopPosition == null ? null : stopPosition.getRowArray();
0: 
0:             hashtable = 
0:                 tc.createBackingStoreHashtableFromScan(
0:                     conglomId,          // conglomerate to open
0:                     (forUpdate ? TransactionController.OPENMODE_FORUPDATE : 0),
0:                     lockMode,
0:                     isolationLevel,
0:                     accessedCols, 
0:                     startPositionRow,   
0:                     startSearchOperator,
0:                     scanQualifiers,
0:                     stopPositionRow,   
0:                     stopSearchOperator,
0:                     -1,                 // no limit on total rows.
0:                     keyColumns,      
0:                     eliminateDuplicates,// remove duplicates?
0:                     -1,                 // RESOLVE - is there a row estimate?
0:                     -1,                 // RESOLVE - when should it go to disk?
0:                     initialCapacity,    // in memory Hashtable initial capacity
0:                     loadFactor,         // in memory Hashtable load factor
0:                     runTimeStatisticsOn,
0: 					skipNullKeyColumns); 
0: 
0: 
0: 			if (runTimeStatisticsOn)
0: 			{
0: 				hashtableSize = hashtable.size();
0: 
0: 				if (scanProperties == null)
0: 				{
0: 					scanProperties = new Properties();
0: 				}
0: 
0: 				try
0: 				{
0: 					if (hashtable != null)
0: 					{
0:                         hashtable.getAllRuntimeStats(scanProperties);
0: 					}
0: 				}
0: 				catch(StandardException se)
0: 				{
0: 					// ignore
0: 				}
0: 			}
0: 
0: 
0: 			/* Remember that we created the hash table */
0: 			hashtableBuilt = true;
0: 
0: 			/*
0: 			** Tell the activation about the number of qualifying rows.
0: 			** Do this only here, not in reopen, because we don't want
0: 			** to do this costly operation too often.
0: 			*/
0: 			activation.informOfRowCount(this, (long) hashtableSize);
0: 		}
0: 
0: 	    isOpen = true;
0: 
0: 		resetProbeVariables();
0: 
0: 		numOpens++;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * reopen this ResultSet.
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0: 	 */
0: 	public void	reopenCore() throws StandardException {
0: 		TransactionController		tc;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isOpen,
0: 					"HashScanResultSet already open");
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		resetProbeVariables();
0: 
0: 		numOpens++;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	private void resetProbeVariables() throws StandardException
0: 	{
0: 		firstNext = true;
0: 		numFetchedOnNext = 0;
0: 		entryVector = null;
0: 		entryVectorSize = 0;
0: 
0: 		if (nextQualifiers != null)
0: 		{
0: 			clearOrderableCache(nextQualifiers);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0:      * Return the next row (if any) from the scan (if open).
0: 	 *
0: 	 * @exception StandardException thrown on failure to get next row
0: 	 */
0: 	public ExecRow getNextRowCore() throws StandardException
0: 	{
0: 	    ExecRow result = null;
0: 		DataValueDescriptor[] columns = null;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen && hashtableBuilt)
0: 	    {
0: 			/* We use a do/while loop to ensure that we continue down
0: 			 * the duplicate chain, if one exists, until we find a
0: 			 * row that matches on all probe predicates (or the
0: 			 * duplicate chain is exhausted.)
0: 			 */
0: 			do 
0: 			{
0: 				if (firstNext)
0: 				{			  
0: 					firstNext = false;
0: 
0: 					/* Hash key could be either a single column or multiple columns.
0: 					 * If a single column, then it is the datavalue wrapper, otherwise
0: 					 * it is a KeyHasher.
0: 					 */
0: 					Object hashEntry;
0: 					if (keyColumns.length == 1)
0: 					{
0: 						hashEntry = hashtable.get(nextQualifiers[0][0].getOrderable());
0: 					}
0: 					else
0: 					{
0: 						KeyHasher mh = new KeyHasher(keyColumns.length);
0: 
0:                         if (SanityManager.DEBUG)
0:                         {
0:                             SanityManager.ASSERT(nextQualifiers.length == 1);
0:                         }
0: 
0: 						for (int index = 0; index < keyColumns.length; index++)
0: 						{
0:                             // For hashing only use the AND qualifiers 
0:                             // located in nextQualifiers[0][0...N], OR 
0:                             // qualifiers are checked down a bit by calling
0:                             // qualifyRow on rows returned from hash.
0: 
0:                             DataValueDescriptor dvd = 
0:                                 nextQualifiers[0][index].getOrderable();
0: 
0:                             if (dvd == null)
0:                             {
0:                                 mh = null;
0:                                 break;
0:                             }
0: 							mh.setObject(
0:                                 index, nextQualifiers[0][index].getOrderable());
0: 						}
0: 						hashEntry = (mh == null) ? null : hashtable.get(mh);
0: 					}
0: 
0: 					if (hashEntry instanceof Vector)
0: 					{
0: 						entryVector = (Vector) hashEntry;
0: 						entryVectorSize = entryVector.size();
0: 						columns = 
0:                             (DataValueDescriptor[]) entryVector.firstElement();
0: 					}
0: 					else
0: 					{
0: 						entryVector = null;
0: 						entryVectorSize = 0;
0: 						columns = (DataValueDescriptor[]) hashEntry;
0: 					}
0: 				}
0: 				else if (numFetchedOnNext < entryVectorSize)
0: 				{
0: 					/* We walking a Vector and there's 
0: 					 * more rows left in the vector.
0: 					 */
0: 					columns = (DataValueDescriptor[]) 
0:                         entryVector.elementAt(numFetchedOnNext);
0: 				}
0: 
0: 				if (columns != null)
0: 				{
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						// There used to be an assertion here that the columns
0: 						// array was the same size as the number of columns
0: 						// in the compact row. This assertion no longer holds
0: 						// now that we're doing sparse rows, so I deleted it.
0: 
0: 						// Columns is really a Storable[]
0: 						for (int i = 0; i < columns.length; i++)
0: 						{
0: 							if (columns[i] != null &&
0: 								! (columns[i] instanceof Storable))
0: 							{
0: 								SanityManager.THROWASSERT(
0: 								"columns[" + i + "] expected to be Storable, not " +
0: 								columns[i].getClass().getName());
0: 							}
0: 						}
0: 					}
0: 
0: 					// See if the entry satisfies all of the other qualifiers
0: 
0: 					/* We've already "evaluated" the 1st keyColumns qualifiers 
0:                      * when we probed into the hash table, but we need to 
0:                      * evaluate them again here because of the behavior of 
0:                      * NULLs.  NULLs are treated as equal when building and 
0:                      * probing the hash table so that we only get a single 
0:                      * entry.  However, NULL does not equal NULL, so the 
0:                      * compare() method below will eliminate any row that
0: 					 * has a key column containing a NULL.
0:                      *
0:                      * The following code will also evaluate any OR clauses
0:                      * that may exist, while the above hashing does not 
0:                      * include them.
0: 					 */
0: 
0: 					if (RowUtil.qualifyRow(columns, nextQualifiers))
0: 					{
0: 						setCompatRow(compactRow, columns);
0: 
0: 						rowsSeen++;
0: 
0: 						result = compactRow;
0: 					}
0: 					else
0: 					{
0: 						result = null;
0: 					}
0: 
0: 					numFetchedOnNext++;
0: 				}
0: 				else
0: 				{
0: 					result = null;
0: 				}
0: 			}
0: 			while (result == null && numFetchedOnNext < entryVectorSize);
0: 
0: 		}
0: 
0: 		currentRow = result;
0: 		setCurrentRow(result);
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 	    return result;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0:  	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if ( isOpen )
0: 	    {
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 
0: 			currentRow = null;
0: 			if (hashtableBuilt)
0: 			{
0: 				// This is where we get the scan properties for a subquery
0: 				scanProperties = getScanProperties();
0: 				// This is where we get the positioner info for inner tables
0: 				if (runTimeStatisticsOn)
0: 				{
0: 					startPositionString = printStartPosition();
0: 					stopPositionString = printStopPosition();
0: 				}
0: 
0: 				// close the hash table, eating any exception
0: 				hashtable.close();
0: 				hashtable = null;
0: 				hashtableBuilt = false;
0: 			}
0: 			startPosition = null;
0: 			stopPosition = null;
0: 
0: 			super.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of HashScanResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		/* RESOLVE - subtract out store time later, when available */
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime;
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#getScanIsolationLevel
0: 	 */
0: 	public int getScanIsolationLevel()
0: 	{
0: 		return isolationLevel;
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#requiresRelocking
0: 	 */
0: 	public boolean requiresRelocking()
0: 	{
0: 		// IndexRowToBaseRow needs to relock if we didn't keep the lock
0: 		return(
0:             ((isolationLevel == 
0:                  TransactionController.ISOLATION_READ_COMMITTED)            ||
0:              (isolationLevel == 
0:                  TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||
0:              (isolationLevel == 
0:                  TransactionController.ISOLATION_READ_UNCOMMITTED)));
0: 
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * This result set has its row location from
0: 	 * the last fetch done. If the cursor is closed,
0: 	 * a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException
0: 	{
0: 		if (! isOpen) return null;
0: 
0: 		if ( ! hashtableBuilt)
0: 			return null;
0: 
0: 		/* This method should only be called if the last column
0: 		 * in the current row is a RowLocation.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(currentRow != null,
0: 			  "There must be a current row when fetching the row location");
0: 			Object rlCandidate =  currentRow.getColumn(
0: 													currentRow.nColumns());
0: 			if (! (rlCandidate instanceof RowLocation))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"rlCandidate expected to be instanceof RowLocation, not " +
0: 					rlCandidate.getClass().getName());
0: 			}
0: 		}
0: 
0: 		return (RowLocation) currentRow.getColumn(
0: 											currentRow.nColumns());
0: 	}
0: 
0: 	/**
0: 	 * This result set has its row from the last fetch done. 
0: 	 * If the cursor is closed, a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned;
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException 
0: 	{
0: 		/* Doesn't make sense to call this method for this node since
0: 		 * joins are not updatable.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT( 
0: 			 "getCurrentRow() not expected to be called for HSRS");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	public String printStartPosition()
0: 	{
0: 		return printPosition(startSearchOperator, startKeyGetter, startPosition);
0: 	}
0: 
0: 	public String printStopPosition()
0: 	{
0: 		if (sameStartStopPosition)
0: 		{
0: 			return printPosition(stopSearchOperator, startKeyGetter, startPosition);
0: 		}
0: 		else
0: 		{
0: 			return printPosition(stopSearchOperator, stopKeyGetter, stopPosition);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return a start or stop positioner as a String.
0: 	 */
0: 	private String printPosition(int searchOperator,
0: 								 GeneratedMethod positionGetter,
0: 								 ExecIndexRow eiRow)
0: 	{
0: 		String idt = "";
0: 
0: 		String output = "";
0: 		if (positionGetter == null)
0: 		{
0: 			return "\t" +
0: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
0: 					"\n";
0: 		}
0: 
0: 		ExecIndexRow	positioner = null;
0: 
0: 		try
0: 		{
0: 			positioner = (ExecIndexRow) positionGetter.invoke(activation);
0: 		}
0: 		catch (StandardException e)
0: 		{
0: 
0: 			if (eiRow == null)
0: 			{
0: 				return "\t" + MessageService.getTextMessage(
0: 											SQLState.LANG_POSITION_NOT_AVAIL);
0: 			}
0: 			return "\t" + MessageService.getTextMessage(
0: 							SQLState.LANG_UNEXPECTED_EXC_GETTING_POSITIONER) +
0: 							"\n";
0: 		}
0: 
0: 		if (positioner == null)
0: 		{
0: 			return "\t" +
0: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
0: 					"\n";
0: 		}
0: 
0: 		String searchOp = null;
0: 
0: 		switch (searchOperator)
0: 		{
0: 			case ScanController.GE:
0: 				searchOp = ">=";
0: 				break;
0: 
0: 			case ScanController.GT:
0: 				searchOp = ">";
0: 				break;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("Unknown search operator " +
0: 												searchOperator);
0: 				}
0: 
0: 				// This is not internationalized because we should never
0: 				// reach here.
0: 				searchOp = "unknown value (" + searchOperator + ")";
0: 				break;
0: 		}
0: 
0: 		output += "\t" + MessageService.getTextMessage(
0: 										SQLState.LANG_POSITIONER,
0: 										searchOp,
0: 										String.valueOf(positioner.nColumns()))
0: 										+ "\n";
0: 			
0: 		output += "\t" + MessageService.getTextMessage(
0: 										SQLState.LANG_ORDERED_NULL_SEMANTICS) +
0: 										"\n";
0: 		for (int position = 0; position < positioner.nColumns(); position++)
0: 		{
0: 			if (positioner.areNullsOrdered(position))
0: 			{
0: 				output = output + position + " ";
0: 			}
0: 		}
0: 		
0: 		return output + "\n";
0: 	}
0: 
0: 	public Properties getScanProperties()
0: 	{
0: 		return scanProperties;
0: 	}
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * 
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return forUpdate;
0: 	}
0: }
============================================================================