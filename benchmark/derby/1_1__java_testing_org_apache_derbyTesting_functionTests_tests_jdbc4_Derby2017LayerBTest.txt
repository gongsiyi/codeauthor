1:973b326: /*
1:973b326: 
1:973b326: Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerBTest
1:973b326: 
1:973b326: Licensed to the Apache Software Foundation (ASF) under one or more
1:973b326: contributor license agreements.  See the NOTICE file distributed with
1:973b326: this work for additional information regarding copyright ownership.
1:973b326: The ASF licenses this file to You under the Apache License, Version 2.0
1:973b326: (the "License"); you may not use this file except in compliance with
1:973b326: the License.  You may obtain a copy of the License at
1:973b326: 
1:973b326: http://www.apache.org/licenses/LICENSE-2.0
1:973b326: 
1:973b326: Unless required by applicable law or agreed to in writing, software
1:973b326: distributed under the License is distributed on an "AS IS" BASIS,
1:973b326: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:973b326: See the License for the specific language governing permissions and
1:973b326: limitations under the License.
1:973b326: 
1:973b326:  */
1:973b326: 
1:973b326: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:973b326: 
1:ed6bf51: import java.io.ByteArrayInputStream;
1:973b326: import junit.framework.Test;
1:973b326: 
1:973b326: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:973b326: 
1:973b326: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:973b326: import org.apache.derbyTesting.junit.JDBC;
1:973b326: import org.apache.derbyTesting.junit.TestConfiguration;
1:973b326: 
1:973b326: import java.io.IOException;
1:ed6bf51: import java.io.InputStream;
1:973b326: import java.io.Reader;
1:973b326: import java.io.StringReader;
1:973b326: 
1:973b326: import java.sql.PreparedStatement;
1:973b326: import java.sql.ResultSet;
1:973b326: import java.sql.SQLException;
1:973b326: import java.sql.Statement;
1:973b326: 
1:ed6bf51: import static org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerATest.*;
1:ed6bf51: 
1:973b326: /**
1:973b326:  * Tests that inserts with streams that throws an {@code IOException} don't
1:973b326:  * insert data into the database when they shouldn't.
2:973b326:  * <p>
1:973b326:  * The test uses various combinations of auto-commit and rollback.
1:973b326:  */
1:973b326: public class Derby2017LayerBTest
1:973b326:         extends BaseJDBCTestCase {
1:973b326: 
1:973b326:     public Derby2017LayerBTest(String name) {
1:973b326:         super(name);
1:973b326:     }
1:ed6bf51: 
1:973b326:     /**
1:973b326:      * Returns a suite running the test with both the client driver and the
1:973b326:      * embedded driver.
1:973b326:      *
1:973b326:      * @return A suite of tests.
1:973b326:      */
1:973b326:     public static Test suite() {
1:973b326:         return TestConfiguration.defaultSuite(Derby2017LayerBTest.class);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testStreamInsertCharBufferBoundary()
1:973b326:             throws IOException, SQLException {
1:973b326:         // NOTE: Many of these lengths are implementation dependent, and the
1:973b326:         //       code paths in LayerBStreamedEXTDTAReaderInputStream may change
1:973b326:         //       if the implementation of certain points of the DRDA protocol
1:973b326:         //       changes.
1:973b326:         int[] lengths = new int[] {
1:973b326:                 1,
1:973b326:                 16383,
1:973b326:                 0,
1:973b326:                 32756,
1:973b326:                 36383,
1:973b326:                 16384,
1:973b326:                 192*1024, // Just a longer stream
1:973b326:             };
1:973b326: 
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017_len (len int, c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017_len");
1:973b326:         }
1:973b326:         commit();
1:973b326:         setAutoCommit(false);
1:973b326: 
1:973b326:         PreparedStatement ps =
1:973b326:                 prepareStatement("insert into t2017_len values (?,?)");
1:973b326:         for (int length : lengths) {
1:973b326:             ps.setInt(1, length);
1:973b326:             ps.setCharacterStream(2, new LoopingAlphabetReader(length));
1:973b326:             ps.executeUpdate();
1:973b326:         }
1:973b326: 
1:973b326:         // Verify the data, basically making sure the status flag isn't
1:973b326:         // included as part of the user data.
1:973b326:         ResultSet rs = stmt.executeQuery("select len, c from t2017_len");
1:973b326:         int rows = 0;
1:973b326:         while (rs.next()) {
1:973b326:             rows++;
1:973b326:             int length = rs.getInt(1);
1:973b326:             assertEquals(new LoopingAlphabetReader(length),
1:973b326:                          rs.getCharacterStream(2));
1:973b326:         }
1:973b326:         assertEquals(lengths.length, rows);
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Attempt to insert data with failing streams of various lengths.
1:973b326:      * <p>
1:973b326:      * None of the inserts should be successful, as an {@code IOException} is
1:973b326:      * thrown by all of the streams.
1:973b326:      */
1:ed6bf51:     public void testFailedStreamInsertCharBufferBoundariesImpl()
1:973b326:             throws IOException, SQLException {
1:973b326:         // NOTE: Many of these lengths are implementation dependent, and the
1:973b326:         //       code paths in LayerBStreamedEXTDTAReaderInputStream may change
1:973b326:         //       if the implementation of certain points of the DRDA protocol
1:973b326:         //       changes.
1:973b326:         int[] lengths = new int[] {
1:973b326:                 1,
1:973b326:                 16383,
1:973b326:                 0,
1:973b326:                 32756,
1:973b326:                 36383,
1:973b326:                 16384,
1:973b326:                 192*1024, // Just a longer stream
1:973b326:             };
1:973b326: 
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017_len (len int, c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017_len");
1:973b326:         }
1:973b326:         commit();
1:973b326:         setAutoCommit(false);
1:973b326: 
1:973b326:         PreparedStatement ps =
1:973b326:                 prepareStatement("insert into t2017_len values (?,?)");
1:973b326:         // Fail at the very beginning of the stream.
1:973b326:         for (int length : lengths) {
1:973b326:             ps.setInt(1, length);
1:973b326:             ps.setCharacterStream(2, new FailingReader(length, -1));
1:973b326:             try {
1:973b326:                 ps.executeUpdate();
1:973b326:                 fail("Should have failed (length=" + length + ")");
1:973b326:             } catch (SQLException sqle) {
1:973b326:                 // TODO: Check when exception handling has been settled.
1:973b326:                 //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         // Fail around half-way into the stream.
1:973b326:         for (int length : lengths) {
1:973b326:             ps.setInt(1, length);
1:973b326:             ps.setCharacterStream(2,
1:973b326:                     new FailingReader(length, length / 2));
1:973b326:             try {
1:973b326:                 ps.executeUpdate();
1:973b326:                 fail("Should have failed (length=" + length + ")");
1:973b326:             } catch (SQLException sqle) {
1:973b326:                 // TODO: Check when exception handling has been settled.
1:973b326:                 //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         // Fail at the very end of the stream.
1:973b326:         for (int length : lengths) {
1:973b326:             ps.setInt(1, length);
1:973b326:             ps.setCharacterStream(2,
1:973b326:                     new FailingReader(length, length -1));
1:973b326:             try {
1:973b326:                 ps.executeUpdate();
1:973b326:                 fail("Should have failed (length=" + length + ")");
1:973b326:             } catch (SQLException sqle) {
1:973b326:                 // TODO: Check when exception handling has been settled.
1:973b326:                 //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         // Verify that there is no data in the table (all failed).
1:973b326:         ResultSet rs = stmt.executeQuery("select count(*) from t2017_len");
1:973b326:         rs.next();
1:973b326:         assertEquals(0, rs.getInt(1));
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertChar()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"This is row 1"},
1:973b326:                 {"This is row 2"},
1:973b326:                 {"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, false, false);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharAutoCommit()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"This is row 1"},
1:973b326:                 {"This is row 2"},
1:973b326:                 {"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, true, false);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharRollbackOnError()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 //{"This is row 1"},
1:973b326:                 //{"This is row 2"},
1:973b326:                 //{"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, false, true);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharAutoCommitRollbackOnError()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"This is row 1"},
1:973b326:                 {"This is row 2"},
1:973b326:                 {"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, true, true);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertBinary()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, false, false);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     public void testFailedStreamInsertBinaryAutoCommit()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, true, false);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     public void testFailedStreamInsertBinaryRollbackOnError()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {0, 1, 2, 3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, false, true);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     public void testFailedStreamInsertBinaryAutoCommitRollbackOnError()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, true, true);
1:ed6bf51:     }
1:ed6bf51: 
1:973b326:     /**
1:973b326:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:973b326:      * invalid rows, insert 2 valid rows.
1:973b326:      * <p>
1:973b326:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:973b326:      * is issued when an insert fails.
1:ed6bf51:      *
1:973b326:      * @param INSERT the data to insert
1:973b326:      * @param MASTER the expected outcome
1:973b326:      * @param autoCommit the auto-commit state to use
1:973b326:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:973b326:      *      fails
1:973b326:      *
1:973b326:      * @throws IOException if something goes wrong
1:973b326:      * @throws SQLException if something goes wrong
1:973b326:      */
1:973b326:     private void doInsertTest(String[] INSERT, String[][] MASTER,
1:973b326:                               boolean autoCommit, boolean rollbackOnError)
1:973b326:             throws IOException, SQLException {
1:973b326:         // A few sanity checks.
1:973b326:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:973b326:         assertTrue(MASTER.length < INSERT.length);
1:973b326: 
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017 (c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017");
1:973b326:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         setAutoCommit(autoCommit);
1:973b326:         PreparedStatement ps = prepareStatement("insert into t2017 values (?)");
1:973b326:         // Insert the 3 first rows.
1:973b326:         for (int i=0; i < 3; i++) {
1:973b326:             ps.setCharacterStream(1, new StringReader(INSERT[i]));
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         // Insert the 4th and 5th row with a stream that throws an exception.
1:973b326:         // Partial data read shouldn't be inserted into the database.
1:973b326: 
1:973b326:         Reader r4 = new FailingReader(10, 3);
1:973b326:         ps.setCharacterStream(1, r4);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // TODO: Check when exception handling has been settled.
1:973b326:             // The states are different between client and embedded.
1:973b326:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:             if (rollbackOnError) {
1:973b326:                 rollback();
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         Reader r5 = new FailingReader(35002, 35001);
1:973b326:         ps.setCharacterStream(1, r5);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // TODO: Check when exception handling has been settled.
1:973b326:             // The states are different between client and embedded.
1:973b326:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:             if (rollbackOnError) {
1:973b326:                 rollback();
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         // The errors above should have statement severity. Insert the last
1:973b326:         // two rows and commit.
1:973b326:         for (int i=5; i < INSERT.length; i++) {
1:973b326:             ps.setCharacterStream(1, new StringReader(INSERT[i]));
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         if (!autoCommit) {
1:973b326:             commit();
1:973b326:         }
1:973b326: 
1:973b326:         // Select data in the table, compare to MASTER
1:973b326:         ResultSet rs = stmt.executeQuery("select * from t2017");
1:df9cdae:         JDBC.assertUnorderedResultSet(rs, MASTER);
1:973b326:     }
1:ed6bf51: 
1:ed6bf51:     /**
1:ed6bf51:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:ed6bf51:      * invalid rows, insert 2 valid rows.
1:ed6bf51:      * <p>
1:ed6bf51:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:ed6bf51:      * is issued when an insert fails.
1:ed6bf51:      *
1:ed6bf51:      * @param INSERT the data to insert
1:ed6bf51:      * @param MASTER the expected outcome
1:ed6bf51:      * @param autoCommit the auto-commit state to use
1:ed6bf51:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:ed6bf51:      *      fails
1:973b326:      *
1:ed6bf51:      * @throws IOException if something goes wrong
1:ed6bf51:      * @throws SQLException if something goes wrong
1:ed6bf51:      */
1:ed6bf51:     private void doInsertTest(byte[][] INSERT, String[][] MASTER,
1:ed6bf51:                               boolean autoCommit, boolean rollbackOnError)
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         // A few sanity checks.
1:ed6bf51:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:ed6bf51:         assertTrue(MASTER.length < INSERT.length);
1:ed6bf51: 
1:ed6bf51:         rollback();
1:ed6bf51:         Statement stmt = createStatement();
1:ed6bf51:         try {
1:ed6bf51:             stmt.executeUpdate("create table t2017_binary (b blob)");
1:ed6bf51:         } catch (SQLException sqle) {
1:ed6bf51:             assertSQLState("X0Y32", sqle);
1:ed6bf51:             stmt.executeUpdate("delete from t2017_binary");
1:ed6bf51:         }
1:ed6bf51:         commit();
1:ed6bf51: 
1:ed6bf51:         setAutoCommit(autoCommit);
1:ed6bf51:         PreparedStatement ps = prepareStatement(
1:ed6bf51:                 "insert into t2017_binary values (?)");
1:ed6bf51:         // Insert the 3 first rows.
1:ed6bf51:         for (int i=0; i < 3; i++) {
1:ed6bf51:             ps.setBinaryStream(1, new ByteArrayInputStream(INSERT[i]));
1:ed6bf51:             assertEquals(1, ps.executeUpdate());
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         // Insert the 4th and 5th row with a stream that throws an exception.
1:ed6bf51:         // Partial data read shouldn't be inserted into the database.
1:ed6bf51: 
1:ed6bf51:         InputStream r4 = new FailingInputStream(new FailingReader(10, 3));
1:ed6bf51:         ps.setBinaryStream(1, r4);
1:ed6bf51:         try {
1:ed6bf51:             ps.executeUpdate();
1:ed6bf51:             fail("Insert should have failed");
1:ed6bf51:         } catch (SQLException sqle) {
1:ed6bf51:             // TODO: Check when exception handling has been settled.
1:ed6bf51:             // The states are different between client and embedded.
1:ed6bf51:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:ed6bf51:             if (rollbackOnError) {
1:ed6bf51:                 rollback();
1:ed6bf51:             }
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         InputStream r5 = new FailingInputStream(
1:ed6bf51:                                     new FailingReader(35002, 35001));
1:ed6bf51:         ps.setBinaryStream(1, r5);
1:ed6bf51:         try {
1:ed6bf51:             ps.executeUpdate();
1:ed6bf51:             fail("Insert should have failed");
1:ed6bf51:         } catch (SQLException sqle) {
1:ed6bf51:             // TODO: Check when exception handling has been settled.
1:ed6bf51:             // The states are different between client and embedded.
1:ed6bf51:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:ed6bf51:             if (rollbackOnError) {
1:ed6bf51:                 rollback();
1:ed6bf51:             }
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         // The errors above should have statement severity. Insert the last
1:ed6bf51:         // two rows and commit.
1:ed6bf51:         for (int i=5; i < INSERT.length; i++) {
1:ed6bf51:             ps.setBinaryStream(1, new ByteArrayInputStream(INSERT[i]));
1:ed6bf51:             assertEquals(1, ps.executeUpdate());
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         if (!autoCommit) {
1:ed6bf51:             commit();
1:ed6bf51:         }
1:973b326: 
1:ed6bf51:         // Select data in the table, compare to MASTER
1:ed6bf51:         ResultSet rs = stmt.executeQuery("select * from t2017_binary");
1:df9cdae:         JDBC.assertUnorderedResultSet(rs, MASTER);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     /**
1:ed6bf51:      * Simple and <b>non-conforming</b> input stream that will fail after a
1:ed6bf51:      * specified number of bytes read.
1:ed6bf51:      */
1:ed6bf51:     private static class FailingInputStream
1:ed6bf51:             extends InputStream {
1:ed6bf51: 
1:ed6bf51:         private final FailingReader in;
1:ed6bf51: 
1:ed6bf51:         public FailingInputStream(FailingReader in) {
1:ed6bf51:             this.in = in;
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         public int read()
1:ed6bf51:                 throws IOException {
1:ed6bf51:             int c = in.read();
1:ed6bf51:             return (byte)c;
1:ed6bf51:         }
1:ed6bf51:     }
1:973b326: }
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:df9cdae
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertUnorderedResultSet(rs, MASTER);
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertUnorderedResultSet(rs, MASTER);
commit:ed6bf51
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerATest.*;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testStreamInsertCharBufferBoundary()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharBufferBoundariesImpl()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertChar()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharAutoCommit()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharRollbackOnError()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharAutoCommitRollbackOnError()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertBinary()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:         doInsertTest(INSERT, MASTER, false, false);
1:     }
1: 
1:     public void testFailedStreamInsertBinaryAutoCommit()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:         doInsertTest(INSERT, MASTER, true, false);
1:     }
1: 
1:     public void testFailedStreamInsertBinaryRollbackOnError()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {0, 1, 2, 3, 4});
1:         doInsertTest(INSERT, MASTER, false, true);
1:     }
1: 
1:     public void testFailedStreamInsertBinaryAutoCommitRollbackOnError()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:         doInsertTest(INSERT, MASTER, true, true);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:      * invalid rows, insert 2 valid rows.
1:      * <p>
1:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:      * is issued when an insert fails.
1:      *
1:      * @param INSERT the data to insert
1:      * @param MASTER the expected outcome
1:      * @param autoCommit the auto-commit state to use
1:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:      *      fails
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void doInsertTest(byte[][] INSERT, String[][] MASTER,
1:                               boolean autoCommit, boolean rollbackOnError)
1:             throws IOException, SQLException {
1:         // A few sanity checks.
1:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:         assertTrue(MASTER.length < INSERT.length);
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017_binary (b blob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017_binary");
1:         }
1:         commit();
1: 
1:         setAutoCommit(autoCommit);
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into t2017_binary values (?)");
1:         // Insert the 3 first rows.
1:         for (int i=0; i < 3; i++) {
1:             ps.setBinaryStream(1, new ByteArrayInputStream(INSERT[i]));
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Insert the 4th and 5th row with a stream that throws an exception.
1:         // Partial data read shouldn't be inserted into the database.
1: 
1:         InputStream r4 = new FailingInputStream(new FailingReader(10, 3));
1:         ps.setBinaryStream(1, r4);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed");
1:         } catch (SQLException sqle) {
1:             // TODO: Check when exception handling has been settled.
1:             // The states are different between client and embedded.
1:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         InputStream r5 = new FailingInputStream(
1:                                     new FailingReader(35002, 35001));
1:         ps.setBinaryStream(1, r5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed");
1:         } catch (SQLException sqle) {
1:             // TODO: Check when exception handling has been settled.
1:             // The states are different between client and embedded.
1:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         // The errors above should have statement severity. Insert the last
1:         // two rows and commit.
1:         for (int i=5; i < INSERT.length; i++) {
1:             ps.setBinaryStream(1, new ByteArrayInputStream(INSERT[i]));
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         if (!autoCommit) {
1:             commit();
1:         }
1: 
1:         // Select data in the table, compare to MASTER
1:         ResultSet rs = stmt.executeQuery("select * from t2017_binary");
0:         JDBC.assertFullResultSet(rs, MASTER);
1:     }
1: 
1:     /**
1:      * Simple and <b>non-conforming</b> input stream that will fail after a
1:      * specified number of bytes read.
1:      */
1:     private static class FailingInputStream
1:             extends InputStream {
1: 
1:         private final FailingReader in;
1: 
1:         public FailingInputStream(FailingReader in) {
1:             this.in = in;
1:         }
1: 
1:         public int read()
1:                 throws IOException {
1:             int c = in.read();
1:             return (byte)c;
1:         }
1:     }
commit:973b326
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerBTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import junit.framework.Test;
1: 
0: import org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerATest.FailingReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: import java.io.IOException;
1: import java.io.Reader;
1: import java.io.StringReader;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: /**
1:  * Tests that inserts with streams that throws an {@code IOException} don't
1:  * insert data into the database when they shouldn't.
1:  * <p>
1:  * The test uses various combinations of auto-commit and rollback.
1:  * <p>
0:  * TODO: Enable this test as part of the JDBC4 suite when DERBY-2017 is fixed.
1:  */
1: public class Derby2017LayerBTest
1:         extends BaseJDBCTestCase {
1: 
1:     public Derby2017LayerBTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Returns a suite running the test with both the client driver and the
1:      * embedded driver.
1:      *
1:      * @return A suite of tests.
1:      */
1:     public static Test suite() {
1:         return TestConfiguration.defaultSuite(Derby2017LayerBTest.class);
1:     }
1: 
0:     public void testStreamInsertBufferBoundary()
1:             throws IOException, SQLException {
1:         // NOTE: Many of these lengths are implementation dependent, and the
1:         //       code paths in LayerBStreamedEXTDTAReaderInputStream may change
1:         //       if the implementation of certain points of the DRDA protocol
1:         //       changes.
1:         int[] lengths = new int[] {
1:                 1,
1:                 16383,
1:                 0,
1:                 32756,
1:                 36383,
1:                 16384,
1:                 192*1024, // Just a longer stream
1:             };
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017_len (len int, c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017_len");
1:         }
1:         commit();
1:         setAutoCommit(false);
1: 
1:         PreparedStatement ps =
1:                 prepareStatement("insert into t2017_len values (?,?)");
1:         for (int length : lengths) {
1:             ps.setInt(1, length);
1:             ps.setCharacterStream(2, new LoopingAlphabetReader(length));
1:             ps.executeUpdate();
1:         }
1: 
1:         // Verify the data, basically making sure the status flag isn't
1:         // included as part of the user data.
1:         ResultSet rs = stmt.executeQuery("select len, c from t2017_len");
1:         int rows = 0;
1:         while (rs.next()) {
1:             rows++;
1:             int length = rs.getInt(1);
1:             assertEquals(new LoopingAlphabetReader(length),
1:                          rs.getCharacterStream(2));
1:         }
1:         assertEquals(lengths.length, rows);
1:     }
1: 
1:     /**
1:      * Attempt to insert data with failing streams of various lengths.
1:      * <p>
1:      * None of the inserts should be successful, as an {@code IOException} is
1:      * thrown by all of the streams.
1:      */
0:     public void testFailedStreamInsertBufferBoundariesImpl()
1:             throws IOException, SQLException {
1:         // NOTE: Many of these lengths are implementation dependent, and the
1:         //       code paths in LayerBStreamedEXTDTAReaderInputStream may change
1:         //       if the implementation of certain points of the DRDA protocol
1:         //       changes.
1:         int[] lengths = new int[] {
1:                 1,
1:                 16383,
1:                 0,
1:                 32756,
1:                 36383,
1:                 16384,
1:                 192*1024, // Just a longer stream
1:             };
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017_len (len int, c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017_len");
1:         }
1:         commit();
1:         setAutoCommit(false);
1: 
1:         PreparedStatement ps =
1:                 prepareStatement("insert into t2017_len values (?,?)");
1:         // Fail at the very beginning of the stream.
1:         for (int length : lengths) {
1:             ps.setInt(1, length);
1:             ps.setCharacterStream(2, new FailingReader(length, -1));
1:             try {
1:                 ps.executeUpdate();
1:                 fail("Should have failed (length=" + length + ")");
1:             } catch (SQLException sqle) {
1:                 // TODO: Check when exception handling has been settled.
1:                 //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             }
1:         }
1: 
1:         // Fail around half-way into the stream.
1:         for (int length : lengths) {
1:             ps.setInt(1, length);
1:             ps.setCharacterStream(2,
1:                     new FailingReader(length, length / 2));
1:             try {
1:                 ps.executeUpdate();
1:                 fail("Should have failed (length=" + length + ")");
1:             } catch (SQLException sqle) {
1:                 // TODO: Check when exception handling has been settled.
1:                 //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             }
1:         }
1: 
1:         // Fail at the very end of the stream.
1:         for (int length : lengths) {
1:             ps.setInt(1, length);
1:             ps.setCharacterStream(2,
1:                     new FailingReader(length, length -1));
1:             try {
1:                 ps.executeUpdate();
1:                 fail("Should have failed (length=" + length + ")");
1:             } catch (SQLException sqle) {
1:                 // TODO: Check when exception handling has been settled.
1:                 //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             }
1:         }
1: 
1:         // Verify that there is no data in the table (all failed).
1:         ResultSet rs = stmt.executeQuery("select count(*) from t2017_len");
1:         rs.next();
1:         assertEquals(0, rs.getInt(1));
1:     }
1: 
0:     public void testFailedStreamInsert()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"This is row 1"},
1:                 {"This is row 2"},
1:                 {"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, false, false);
1:     }
1: 
0:     public void testFailedStreamInsertAutoCommit()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"This is row 1"},
1:                 {"This is row 2"},
1:                 {"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, true, false);
1:     }
1: 
0:     public void testFailedStreamInsertRollbackOnError()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 //{"This is row 1"},
1:                 //{"This is row 2"},
1:                 //{"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, false, true);
1:     }
1: 
0:     public void testFailedStreamInsertAutoCommitRollbackOnError()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"This is row 1"},
1:                 {"This is row 2"},
1:                 {"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, true, true);
1:     }
1: 
1:     /**
1:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:      * invalid rows, insert 2 valid rows.
1:      * <p>
1:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:      * is issued when an insert fails.
1:      *
1:      * @param INSERT the data to insert
1:      * @param MASTER the expected outcome
1:      * @param autoCommit the auto-commit state to use
1:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:      *      fails
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void doInsertTest(String[] INSERT, String[][] MASTER,
1:                               boolean autoCommit, boolean rollbackOnError)
1:             throws IOException, SQLException {
1:         // A few sanity checks.
1:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:         assertTrue(MASTER.length < INSERT.length);
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017 (c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017");
1:         }
1:         commit();
1: 
1:         setAutoCommit(autoCommit);
1:         PreparedStatement ps = prepareStatement("insert into t2017 values (?)");
1:         // Insert the 3 first rows.
1:         for (int i=0; i < 3; i++) {
1:             ps.setCharacterStream(1, new StringReader(INSERT[i]));
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Insert the 4th and 5th row with a stream that throws an exception.
1:         // Partial data read shouldn't be inserted into the database.
1: 
1:         Reader r4 = new FailingReader(10, 3);
1:         ps.setCharacterStream(1, r4);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed");
1:         } catch (SQLException sqle) {
1:             // TODO: Check when exception handling has been settled.
1:             // The states are different between client and embedded.
1:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         Reader r5 = new FailingReader(35002, 35001);
1:         ps.setCharacterStream(1, r5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed");
1:         } catch (SQLException sqle) {
1:             // TODO: Check when exception handling has been settled.
1:             // The states are different between client and embedded.
1:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         // The errors above should have statement severity. Insert the last
1:         // two rows and commit.
1:         for (int i=5; i < INSERT.length; i++) {
1:             ps.setCharacterStream(1, new StringReader(INSERT[i]));
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         if (!autoCommit) {
1:             commit();
1:         }
1: 
1:         // Select data in the table, compare to MASTER
1:         ResultSet rs = stmt.executeQuery("select * from t2017");
0:         JDBC.assertFullResultSet(rs, MASTER);
1:     }
1: }
============================================================================