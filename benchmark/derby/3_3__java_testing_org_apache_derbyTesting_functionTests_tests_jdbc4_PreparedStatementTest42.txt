1:7cfb7e6: /*
1:7cfb7e6:  *
1:7cfb7e6:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest42
1:7cfb7e6:  *
1:7cfb7e6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7cfb7e6:  * contributor license agreements.  See the NOTICE file distributed with
1:7cfb7e6:  * this work for additional information regarding copyright ownership.
1:7cfb7e6:  * The ASF licenses this file to you under the Apache License, Version 2.0
1:7cfb7e6:  * (the "License"); you may not use this file except in compliance with
1:7cfb7e6:  * the License.  You may obtain a copy of the License at
1:7cfb7e6:  *
1:7cfb7e6:  *    http://www.apache.org/licenses/LICENSE-2.0
1:7cfb7e6:  *
1:7cfb7e6:  * Unless required by applicable law or agreed to in writing, 
1:7cfb7e6:  * software distributed under the License is distributed on an 
1:7cfb7e6:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:7cfb7e6:  * either express or implied. See the License for the specific 
1:7cfb7e6:  * language governing permissions and limitations under the License.
1:7cfb7e6:  */
1:7cfb7e6: 
1:7cfb7e6: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:7cfb7e6: 
1:7cfb7e6: import java.math.BigDecimal;
1:7cfb7e6: import java.sql.Blob;
1:9206d5b: import java.sql.CallableStatement;
1:7cfb7e6: import java.sql.Clob;
1:7cfb7e6: import java.sql.Connection;
1:7cfb7e6: import java.sql.Date;
1:7cfb7e6: import java.sql.JDBCType;
1:7cfb7e6: import java.sql.PreparedStatement;
1:7cfb7e6: import java.sql.ResultSet;
1:7cfb7e6: import java.sql.SQLException;
1:e25c098: import java.sql.SQLFeatureNotSupportedException;
1:e25c098: import java.sql.Statement;
1:7cfb7e6: import java.sql.Time;
1:7cfb7e6: import java.sql.Timestamp;
1:4c2fc4a: import java.sql.Types;
1:1ae02c9: import junit.framework.Test;
1:7cfb7e6: import org.apache.derby.iapi.types.HarmonySerialBlob;
1:7cfb7e6: import org.apache.derby.iapi.types.HarmonySerialClob;
1:7cfb7e6: import org.apache.derbyTesting.functionTests.tests.lang.Price;
1:7cfb7e6: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:e25c098: import org.apache.derbyTesting.junit.JDBC;
1:7cfb7e6: import org.apache.derbyTesting.junit.TestConfiguration;
1:7cfb7e6: 
1:7cfb7e6: /**
1:7cfb7e6:  * Tests for new methods added for PreparedStatement in JDBC 4.2.
1:7cfb7e6:  */
1:7cfb7e6: public class PreparedStatementTest42 extends BaseJDBCTestCase
11:7cfb7e6: {
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // CONSTANTS
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:9206d5b:     private static  final   String  UNIMPLEMENTED_FEATURE = "0A000";
1:9206d5b: 
1:7cfb7e6:     //
1:7cfb7e6:     // If any of these becomes a legal Derby type, remove it from this table and put a corresponding line
1:7cfb7e6:     // into _columnDescs.
1:7cfb7e6:     //
1:7cfb7e6:     private static  final   JDBCType[]  ILLEGAL_JDBC_TYPES = new JDBCType[]
1:7cfb7e6:     {
1:7cfb7e6:         JDBCType.ARRAY,
1:7cfb7e6:         JDBCType.DATALINK,
1:01c7f83:         JDBCType.DISTINCT,
1:01c7f83:         JDBCType.LONGNVARCHAR,
1:7cfb7e6:         JDBCType.NCHAR,
1:7cfb7e6:         JDBCType.NCLOB,
1:01c7f83:         JDBCType.NULL,
1:7cfb7e6:         JDBCType.NVARCHAR,
1:01c7f83:         JDBCType.OTHER,
1:7cfb7e6:         JDBCType.REF,
1:7cfb7e6:         JDBCType.REF_CURSOR,
1:7cfb7e6:         JDBCType.ROWID,
1:7cfb7e6:         JDBCType.SQLXML,
1:7cfb7e6:         JDBCType.STRUCT,
1:7cfb7e6:     };
1:7cfb7e6: 
1:4c2fc4a:     private static  final   int[]  ILLEGAL_SQL_TYPES = new int[]
1:4c2fc4a:     {
1:4c2fc4a:         Types.ARRAY,
1:4c2fc4a:         Types.DATALINK,
1:4c2fc4a:         Types.DISTINCT,
1:4c2fc4a:         Types.LONGNVARCHAR,
1:4c2fc4a:         Types.NCHAR,
1:4c2fc4a:         Types.NCLOB,
1:4c2fc4a:         Types.NVARCHAR,
1:4c2fc4a:         Types.OTHER,
1:4c2fc4a:         Types.REF,
1:4c2fc4a:         Types.REF_CURSOR,
1:4c2fc4a:         Types.ROWID,
1:4c2fc4a:         Types.SQLXML,
1:4c2fc4a:         Types.STRUCT,
1:4c2fc4a:     };
1:4c2fc4a: 
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // STATE
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:7cfb7e6:     private static  ColumnDesc[]    _columnDescs =
1:7cfb7e6:     {
1:39b3237:         new ColumnDesc( JDBCType.BIGINT, "bigint", 0L, 1L, null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.BLOB, "blob", makeBlob( "01234" ), makeBlob( "56789" ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.BOOLEAN, "boolean", Boolean.FALSE, Boolean.TRUE, null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.CHAR, "char( 5 )", "01234", "56789", null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.BINARY, "char( 5 ) for bit data", makeBinary( "01234" ), makeBinary( "56789" ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.CLOB, "clob", makeClob( "01234" ), makeClob( "56789" ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.DATE, "date", new Date( 0L ), new Date( 1L ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.DECIMAL, "decimal", new BigDecimal( 0 ), new BigDecimal( 1 ), null ),
1:39b3237:         new ColumnDesc( JDBCType.DOUBLE, "double", 0.0, 1.0, null ),
1:39b3237:         new ColumnDesc( JDBCType.FLOAT, "float", 0.0, 1.0, null ),
1:39b3237:         new ColumnDesc( JDBCType.INTEGER, "int", 0, 1, null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.LONGVARCHAR, "long varchar", "01234", "56789", null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.LONGVARBINARY, "long varchar for bit data", makeBinary( "01234" ), makeBinary( "56789" ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.NUMERIC, "numeric", new BigDecimal( 0 ), new BigDecimal( 1 ), null ),
1:39b3237:         new ColumnDesc( JDBCType.REAL, "real", 0.0F, 1F, null ),
1:39b3237:         new ColumnDesc( JDBCType.SMALLINT, "smallint", 0, 1, null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.TIME, "time", new Time( 0L ), new Time( 1L ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.TIMESTAMP, "timestamp", new Timestamp( 0L ), new Timestamp( 1L ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.JAVA_OBJECT, "Price", makePrice( 0L ), makePrice( 1L ), null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.VARCHAR, "varchar( 5 )", "01234", "56789", null ),
1:7cfb7e6:         new ColumnDesc( JDBCType.VARBINARY, "varchar( 5 ) for bit data", makeBinary( "01234" ), makeBinary( "56789" ), null ),
1:7cfb7e6:         // get/setObject on XML not supported because Derby does not support SQLXML yet
1:7cfb7e6:     };
1:7cfb7e6: 
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // NESTED CLASSES
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:7cfb7e6:     public  static  final   class   ColumnDesc
1:7cfb7e6:     {
1:7cfb7e6:         public  static  final   int VALUE_COUNT = 3;
1:7cfb7e6:         
1:7cfb7e6:         public  final   JDBCType    jdbcType;
1:7cfb7e6:         public  final   String          sqlType;
1:7cfb7e6:         public  final   Object[]    values;
1:7cfb7e6: 
1:7cfb7e6:         public  ColumnDesc
2:7cfb7e6:             (
1:7cfb7e6:              JDBCType    jdbcType,
1:7cfb7e6:              String          sqlType,
1:7cfb7e6:              Object...  values
1:7cfb7e6:              )
1:7cfb7e6:         {
1:7cfb7e6:             this.jdbcType = jdbcType;
1:7cfb7e6:             this.sqlType = sqlType;
1:7cfb7e6:             this.values = values;
1:7cfb7e6: 
1:7cfb7e6:             if ( values.length != VALUE_COUNT )
1:7cfb7e6:             {
1:7cfb7e6:                 throw new IllegalArgumentException( "Expected " + VALUE_COUNT + " values but saw " + values.length );
9:7cfb7e6:             }
1:7cfb7e6:         }
1:7cfb7e6:     }
1:7cfb7e6: 
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // CONSTRUCTOR
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:17efc16:     /**
1:7cfb7e6:      * Create a new test with the given name.
1:7cfb7e6:      */
1:7cfb7e6:     public PreparedStatementTest42( String name ) { super(name); }
1:7cfb7e6: 
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // JUnit MACHINERY
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:7cfb7e6:     public static Test suite()
1:7cfb7e6:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("PreparedStatementTest42");
1:7cfb7e6: 
1:7cfb7e6:         suite.addTest( TestConfiguration.defaultSuite( PreparedStatementTest42.class ) );
1:7cfb7e6: 
1:7cfb7e6:         return suite;
1:7cfb7e6:     }
1:7cfb7e6:     
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // TESTS
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:9206d5b:     /**
1:17efc16:      * <p>
1:7cfb7e6:      * Test the setObject() overloads added by JDBC 4.2.
1:17efc16:      * </p>
1:17efc16:      */
1:7cfb7e6:     public  void    test_01_setObject() throws Exception
1:9206d5b:     {
1:9206d5b:         Connection conn = getConnection();
1:17efc16: 
1:9206d5b:         setupPrice( conn );
1:7cfb7e6:         makeTable( conn );
1:7cfb7e6:         populateTable( conn );
1:7cfb7e6:         vetTableContents( conn );
1:fc9b418:         updateColumns( conn );
1:7cfb7e6:     }
1:7cfb7e6:     private void    makeTable( Connection conn ) throws Exception
1:9206d5b:     {        
1:7cfb7e6:         StringBuilder   buffer = new StringBuilder();
1:9206d5b: 
1:7cfb7e6:         buffer.append( "create table allTypes\n(\n" );
1:7cfb7e6:         buffer.append( "\tcol0\tint generated always as identity" );
2:7cfb7e6:         for ( int i = 0; i < _columnDescs.length; i++ )
1:9206d5b:         {
1:7cfb7e6:             ColumnDesc  cd = _columnDescs[ i ];
2:7cfb7e6:             String  columnName = "col" + (i+1);
1:7cfb7e6:             String  columnType = cd.sqlType;
1:7cfb7e6:             buffer.append( "\n\t, " + columnName + "\t" + columnType );
1:9206d5b:         }
1:7cfb7e6:         buffer.append( "\n)" );
1:7cfb7e6: 
1:7cfb7e6:         conn.prepareStatement( buffer.toString() ).execute();
1:9206d5b:     }
1:7cfb7e6:     private void    populateTable( Connection conn ) throws Exception
1:9206d5b:     {
1:fc9b418:         PreparedStatement   insert = prepareInsert( conn );
1:7cfb7e6: 
1:7cfb7e6:         for ( int rowIdx = 0; rowIdx < ColumnDesc.VALUE_COUNT; rowIdx++ )
1:9206d5b:         {
1:fc9b418:             insertRow( insert, rowIdx );
1:7cfb7e6:         }
1:7cfb7e6: 
1:7cfb7e6:         for ( int rowIdx = 0; rowIdx < ColumnDesc.VALUE_COUNT; rowIdx++ )
1:7cfb7e6:         {
2:7cfb7e6:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:7cfb7e6:             {
2:7cfb7e6:                 ColumnDesc  cd = _columnDescs[ colIdx ];
1:7cfb7e6:                 insert.setObject( colIdx + 1, cd.values[ rowIdx ], cd.jdbcType, 0 );
1:7cfb7e6:             }
2:7cfb7e6:             insert.executeUpdate();
1:7cfb7e6:         }
1:fc9b418: 
1:7cfb7e6: 
1:7cfb7e6:         // verify that certain SQLTypes are illegal
1:7cfb7e6:         for ( int i = 0; i < ILLEGAL_JDBC_TYPES.length; i++ )
1:7cfb7e6:         {
1:7cfb7e6:             try {
1:7cfb7e6:                 insert.setObject( 1, null, ILLEGAL_JDBC_TYPES[ i ] );
1:01c7f83:                 fail( "setObject() should have failed." );
1:7cfb7e6:             }
1:9f0c37a:             catch (SQLException se) { assertUnimplemented( se ); }
1:7cfb7e6:         }
1:7cfb7e6: 
1:7cfb7e6:         insert.close();
1:7cfb7e6:     }
1:9f0c37a:     private static void    assertUnimplemented( SQLException se ) throws Exception
1:9f0c37a:     {
1:9f0c37a:         assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:9f0c37a:         assertTrue( se instanceof SQLFeatureNotSupportedException );
1:9f0c37a: 
1:9f0c37a:     }
1:fc9b418:     private PreparedStatement   prepareInsert( Connection conn ) throws Exception
1:fc9b418:     {
1:fc9b418:         StringBuilder   columnBuffer = new StringBuilder();
1:fc9b418:         StringBuilder   valuesBuffer = new StringBuilder();
1:fc9b418: 
1:fc9b418:         columnBuffer.append( "( " );
1:fc9b418:         valuesBuffer.append( "( " );
1:fc9b418:         for ( int i = 0; i < _columnDescs.length; i++ )
1:fc9b418:         {
1:fc9b418:             String  columnName = "col" + (i+1);
1:fc9b418:             if ( i > 0 )
1:fc9b418:             {
1:fc9b418:                 columnBuffer.append( ", " );
1:fc9b418:                 valuesBuffer.append( ", " );
1:fc9b418:             }
1:fc9b418:             columnBuffer.append( columnName );
1:fc9b418:             valuesBuffer.append( "?" );
1:fc9b418:         }
1:fc9b418:         columnBuffer.append( " )" );
1:fc9b418:         valuesBuffer.append( " )" );
1:fc9b418: 
1:fc9b418:         PreparedStatement   insert = conn.prepareStatement
1:fc9b418:             ( "insert into allTypes " + columnBuffer.toString() + " values " + valuesBuffer.toString() );
1:fc9b418: 
1:fc9b418:         return insert;
1:fc9b418:     }
1:fc9b418:     private void    insertRow( PreparedStatement insert, int rowIdx ) throws Exception
1:fc9b418:     {
1:fc9b418:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:fc9b418:         {
1:fc9b418:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:fc9b418:             insert.setObject( colIdx + 1, cd.values[ rowIdx ], cd.jdbcType );
1:fc9b418:         }
1:fc9b418:         insert.executeUpdate();
1:fc9b418:     }
1:7cfb7e6:     private void    vetTableContents( Connection conn ) throws Exception
1:7cfb7e6:     {
1:7cfb7e6:         PreparedStatement   selectPS = conn.prepareStatement( "select * from allTypes order by col0" );
1:7cfb7e6:         ResultSet               selectRS = selectPS.executeQuery();
1:7cfb7e6:         int                     rowCount = 0;
1:7cfb7e6: 
1:7cfb7e6:         while( selectRS.next() )
1:7cfb7e6:         {
1:7cfb7e6:             int     rowIdx = rowCount % ColumnDesc.VALUE_COUNT;
1:7cfb7e6: 
1:7cfb7e6:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:7cfb7e6:             {
1:7cfb7e6:                 Object          expected = _columnDescs[ colIdx ].values[ rowIdx ];
1:7cfb7e6: 
1:7cfb7e6:                 // skip the first column, the primary key
1:7cfb7e6:                 assertObjectEquals( expected, selectRS.getObject( colIdx + 2 ) );
1:7cfb7e6:             }
1:7cfb7e6: 
1:7cfb7e6:             rowCount++;
1:7cfb7e6:         }
1:7cfb7e6:         
1:7cfb7e6:         selectRS.close();
1:7cfb7e6:         selectPS.close();
1:9206d5b:     }
1:fc9b418:     // test the behavior of the new ResultSet methods added by JDBC 4.2
1:fc9b418:     private void    updateColumns( Connection conn ) throws Exception
1:fc9b418:     {
1:fc9b418:         PreparedStatement forUpdatePS = conn.prepareStatement
1:fc9b418:             ( "select * from allTypes for update", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE );
1:fc9b418:         ResultSet   updateRS = null;
1:fc9b418: 
1:fc9b418:         // ResultSet.updateObject( int, Object, SQLType )
1:fc9b418:         prepTable( conn, 0 );
1:fc9b418:         updateRS = forUpdatePS.executeQuery();
1:fc9b418:         updateRS.next();
1:fc9b418:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:fc9b418:         {
1:fc9b418:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:fc9b418:             updateRS.updateObject( colIdx + 2, cd.values[ 1 ], cd.jdbcType );
1:fc9b418:         }
1:fc9b418:         updateRS.updateRow();
1:fc9b418:         updateRS.close();
1:fc9b418:         vetTable( conn, 1, 1 );
1:1149dc1: 
1:fc9b418:         // ResultSet.updateObject( int, Object, SQLType, int )
1:fc9b418:         prepTable( conn, 0 );
1:fc9b418:         updateRS = forUpdatePS.executeQuery();
1:fc9b418:         updateRS.next();
1:fc9b418:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:fc9b418:         {
1:fc9b418:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:fc9b418:             updateRS.updateObject( colIdx + 2, cd.values[ 1 ], cd.jdbcType, 0 );
1:fc9b418:         }
1:fc9b418:         updateRS.updateRow();
1:fc9b418:         updateRS.close();
1:fc9b418:         vetTable( conn, 1, 1 );
1:fc9b418: 
1:fc9b418:         // ResultSet.updateObject( String, Object, SQLType )
1:fc9b418:         prepTable( conn, 0 );
1:fc9b418:         updateRS = forUpdatePS.executeQuery();
1:fc9b418:         updateRS.next();
1:fc9b418:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:fc9b418:         {
1:fc9b418:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:fc9b418:             updateRS.updateObject( "col" + (colIdx+1), cd.values[ 1 ], cd.jdbcType );
1:fc9b418:         }
1:fc9b418:         updateRS.updateRow();
1:fc9b418:         updateRS.close();
1:fc9b418:         vetTable( conn, 1, 1 );
1:fc9b418: 
1:fc9b418:         // ResultSet.updateObject( String, Object, SQLType, int )
1:fc9b418:         prepTable( conn, 0 );
1:fc9b418:         updateRS = forUpdatePS.executeQuery();
1:fc9b418:         updateRS.next();
1:fc9b418:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:fc9b418:         {
1:fc9b418:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:fc9b418:             updateRS.updateObject( "col" + (colIdx+1), cd.values[ 1 ], cd.jdbcType, 0 );
1:fc9b418:         }
1:fc9b418:         updateRS.updateRow();
1:fc9b418:         updateRS.close();
1:fc9b418:         vetTable( conn, 1, 1 );
1:fc9b418: 
1:1149dc1:         // verify that ResultSet.updateObject() fails on bad SQLTypes
1:1149dc1:         prepTable( conn, 0 );
1:1149dc1:         updateRS = forUpdatePS.executeQuery();
1:1149dc1:         updateRS.next();
1:1149dc1:         println( "Testing ResultSet.updateObject() on illegal types." );
1:1149dc1:         for ( int i = 0; i < ILLEGAL_JDBC_TYPES.length; i++ )
1:1149dc1:         {
1:1149dc1:             try {
1:1149dc1:                 updateRS.updateObject( 2, _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ] );
1:1149dc1:                 fail( "updateObject() should have failed." );
1:1149dc1:             }
1:1149dc1:             catch (SQLException se) { assertUnimplemented( se ); }
1:1149dc1:             try {
1:1149dc1:                 updateRS.updateObject( 2, _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ], 0 );
1:1149dc1:                 fail( "updateObject() should have failed." );
1:1149dc1:             }
1:1149dc1:             catch (SQLException se) { assertUnimplemented( se ); }
1:1149dc1:             try {
1:1149dc1:                 updateRS.updateObject( "col2", _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ] );
1:1149dc1:                 fail( "updateObject() should have failed." );
1:1149dc1:             }
1:1149dc1:             catch (SQLException se) { assertUnimplemented( se ); }
1:1149dc1:             try {
1:1149dc1:                 updateRS.updateObject( "col2", _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ], 0 );
1:1149dc1:                 fail( "updateObject() should have failed." );
1:1149dc1:             }
1:1149dc1:             catch (SQLException se) { assertUnimplemented( se ); }
1:1149dc1:         }
1:1149dc1:         updateRS.close();
1:1149dc1:         vetTable( conn, 0, 1 );
1:fc9b418:     }
1:fc9b418:     private void    prepTable( Connection conn, int rowIdx ) throws Exception
1:fc9b418:     {
1:fc9b418:         conn.prepareStatement( "truncate table allTypes" ).execute();
1:fc9b418: 
1:fc9b418:         PreparedStatement   insert = prepareInsert( conn );
1:fc9b418: 
1:fc9b418:         insertRow( insert, rowIdx );
1:fc9b418:         vetTable( conn,rowIdx, 1 );
1:fc9b418:     }
1:fc9b418:     private void    vetTable( Connection conn, int rowIdx, int expectedRowCount ) throws Exception
1:fc9b418:     {
1:fc9b418:         PreparedStatement   selectPS = conn.prepareStatement( "select * from allTypes order by col0" );
1:fc9b418:         ResultSet               selectRS = selectPS.executeQuery();
1:fc9b418:         int                     actualRowCount = 0;
1:fc9b418: 
1:fc9b418:         while( selectRS.next() )
1:fc9b418:         {
1:fc9b418:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:fc9b418:             {
1:fc9b418:                 Object          expected = _columnDescs[ colIdx ].values[ rowIdx ];
1:fc9b418: 
1:fc9b418:                 // skip the first column, the primary key
1:fc9b418:                 assertObjectEquals( expected, selectRS.getObject( colIdx + 2 ) );
1:fc9b418:             }
1:7cfb7e6: 
1:fc9b418:             actualRowCount++;
1:fc9b418:         }
1:fc9b418: 
1:fc9b418:         assertEquals( expectedRowCount, actualRowCount );
1:fc9b418:         
1:fc9b418:         selectRS.close();
1:fc9b418:         selectPS.close();
1:fc9b418:     }
1:7cfb7e6: 
1:7cfb7e6:     /**
1:9206d5b:      * <p>
1:9206d5b:      * Test the CallableStatement.registerObject() overloads added by JDBC 4.2.
1:9206d5b:      * </p>
1:9206d5b:      */
1:9206d5b:     public  void    test_02_registerObject() throws Exception
1:9206d5b:     {
1:7cfb7e6:         Connection conn = getConnection();
1:7cfb7e6: 
1:9206d5b:         registerObjectTest( conn );
1:9206d5b:     }
1:9206d5b:     public  static  void    registerObjectTest( Connection conn ) throws Exception
1:9206d5b:     {
1:9206d5b:         createSchemaObjects( conn );
1:9206d5b:         vetProc( conn );
1:9206d5b:     }
1:9206d5b:     private static void    createSchemaObjects( Connection conn ) throws Exception
1:9206d5b:     {
1:9206d5b:         setupPrice( conn );
1:9206d5b:         createProc( conn );
1:9206d5b:     }
1:9206d5b:     private static void    createProc( Connection conn ) throws Exception
1:9206d5b:     {
1:9206d5b:         StringBuilder   buffer = new StringBuilder();
1:9206d5b: 
1:9206d5b:         buffer.append( "create procedure unpackAllTypes( in valueIdx int" );
1:9206d5b:         
1:9206d5b:         for ( int i = 0; i < _columnDescs.length; i++ )
1:9206d5b:         {
1:9206d5b:             ColumnDesc  cd = _columnDescs[ i ];
1:9206d5b:             String  parameterName = "param" + (i+1);
1:9206d5b:             String  parameterType = cd.sqlType;
1:9206d5b:             buffer.append( ", out " + parameterName + " " + parameterType );
1:9206d5b:         }
1:9206d5b:         
1:9206d5b:         buffer.append( " ) language java parameter style java no sql\n" );
1:9206d5b:         buffer.append( "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest42.unpackAllTypes'" );
1:9206d5b: 
1:9206d5b:         String  sqlText = buffer.toString();
1:9206d5b:         println( sqlText );
1:9206d5b: 
1:9206d5b:         conn.prepareStatement( sqlText ).execute();
1:9206d5b:     }
1:9206d5b:     private static void    vetProc( Connection conn ) throws Exception
1:9206d5b:     {
1:9206d5b:         StringBuilder   buffer = new StringBuilder();
1:9206d5b:         buffer.append( "call unpackAllTypes( ?" );
1:9206d5b:         for ( int i = 0; i < _columnDescs.length; i++ ) { buffer.append( ", ?" ); }
1:9206d5b:         buffer.append( " )" );
1:9206d5b:         String  sqlText = buffer.toString();
1:9206d5b:         println( sqlText );
1:9206d5b: 
1:9206d5b:         CallableStatement   cs = conn.prepareCall( sqlText );
1:9206d5b:         int     valueIdx;
1:9206d5b:         int     param;
1:9206d5b: 
1:9206d5b:         // registerOutParameter( int, SQLType )
1:9206d5b:         valueIdx = 0;
1:9206d5b:         param = 1;
1:9206d5b:         cs.setInt( param++, valueIdx );
1:9206d5b:         for ( int i = 0; i < _columnDescs.length; i++ )
1:9206d5b:         {
1:9206d5b:             cs.registerOutParameter( param++, _columnDescs[ i ].jdbcType );
1:9206d5b:         }
1:9206d5b:         cs.execute();
1:9206d5b:         vetCS( cs, valueIdx );
1:9206d5b: 
1:9206d5b:         // registerOutParameter( int, SQLType, int )
1:9206d5b:         valueIdx = 1;
1:9206d5b:         param = 1;
1:9206d5b:         cs.setInt( param++, valueIdx );
1:9206d5b:         for ( int i = 0; i < _columnDescs.length; i++ )
1:9206d5b:         {
1:9206d5b:             cs.registerOutParameter( param++, _columnDescs[ i ].jdbcType, 0 );
1:9206d5b:         }
1:9206d5b:         cs.execute();
1:9206d5b:         vetCS( cs, valueIdx );
1:9206d5b: 
1:9206d5b:         // registerOutParameter( int, SQLType, String )
1:9206d5b:         valueIdx = 0;
1:9206d5b:         param = 1;
1:9206d5b:         cs.setInt( param++, valueIdx );
1:9206d5b:         for ( int i = 0; i < _columnDescs.length; i++ )
1:9206d5b:         {
1:9206d5b:             cs.registerOutParameter( param++, _columnDescs[ i ].jdbcType, "foo" );
1:9206d5b:         }
1:9206d5b:         cs.execute();
1:9206d5b:         vetCS( cs, valueIdx );
1:9206d5b: 
1:9f0c37a:         // Negative test
1:9f0c37a:         valueIdx = 1;
1:9f0c37a:         param = 1;
1:9f0c37a:         cs.setInt( param++, valueIdx );
1:9f0c37a:         for ( int i = 0; i < ILLEGAL_JDBC_TYPES.length; i++ )
1:9f0c37a:         {
1:9f0c37a:             try {
1:9f0c37a:                 cs.registerOutParameter( param++, ILLEGAL_JDBC_TYPES[ i ], 0 );
1:9f0c37a:                 fail();
1:9f0c37a:             }
1:9f0c37a:             catch (SQLException se) { assertUnimplemented( se ); }
1:9f0c37a:         }
1:9f0c37a: 
1:9206d5b:         // registerOutParameter( String, SQLType )
1:9206d5b:         try {
1:9206d5b:             cs.registerOutParameter( "param1", _columnDescs[ 0 ].jdbcType );
1:9206d5b:             fail( "Expected unimplemented feature." );
1:9206d5b:         }
1:9f0c37a:         catch (SQLException se) { assertUnimplemented( se ); }
1:4c2fc4a: 
1:9206d5b:         // registerOutParameter( String, SQLType, int )
1:9206d5b:         try {
1:9206d5b:             cs.registerOutParameter( "param1", _columnDescs[ 0 ].jdbcType, 0 );
1:9206d5b:             fail( "Expected unimplemented feature." );
1:9206d5b:         }
1:9f0c37a:         catch (SQLException se) { assertUnimplemented( se ); }
1:9206d5b: 
1:9206d5b:         // registerOutParameter( String, SQLType, String )
1:9206d5b:         try {
1:9206d5b:             cs.registerOutParameter( "param1", _columnDescs[ 0 ].jdbcType, "foo" );
1:9206d5b:             fail( "Expected unimplemented feature." );
1:9206d5b:         }
1:9f0c37a:         catch (SQLException se) { assertUnimplemented( se ); }
1:9206d5b:  
1:4c2fc4a:         // Make sure that the pre-JDBC4.2 overloads throw the correct exception too
1:4c2fc4a:         valueIdx = 1;
1:4c2fc4a:         param = 1;
1:4c2fc4a:         cs.setInt( param++, valueIdx );
1:4c2fc4a:         for ( int i = 0; i < ILLEGAL_SQL_TYPES.length; i++ )
1:4c2fc4a:         {
1:4c2fc4a:             int     type = ILLEGAL_SQL_TYPES[ i ];
1:4c2fc4a:             try {
1:4c2fc4a:                 cs.registerOutParameter( param++, type, 0 );
1:4c2fc4a:                 fail( "Should not have been able to register parameter type " + type );
1:4c2fc4a:             } catch (SQLException se) { assertUnimplemented( se ); }
1:4c2fc4a:         }
1:9206d5b:     }
1:9206d5b:     private  static void    vetCS( CallableStatement cs, int valueIdx )
1:9206d5b:         throws Exception
1:17efc16:     {
1:9206d5b:         int     idx = 0;
1:9206d5b:         int     colIdx = 2;
1:9206d5b: 
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:9206d5b:     }
1:9206d5b: 
1:7cfb7e6:     /**
1:7cfb7e6:      * <p>
1:17efc16:      * Test the CallableStatement.setObject() overloads added by JDBC 4.2.
1:7cfb7e6:      * </p>
1:7cfb7e6:      */
1:17efc16:     public  void    test_03_setObject() throws Exception
1:17efc16:     {
1:17efc16:         Connection conn = getConnection();
1:17efc16: 
1:17efc16:         callableStatementSetObjectTest( conn );
1:17efc16:     }
1:17efc16:     public  static  void    callableStatementSetObjectTest( Connection conn ) throws Exception
1:17efc16:     {
1:17efc16:         createSetObjectSchemaObjects( conn );
1:17efc16:         vetSetObjectProc( conn );
1:17efc16:     }
1:17efc16:     private static void    createSetObjectSchemaObjects( Connection conn ) throws Exception
1:17efc16:     {
1:17efc16:         setupPrice( conn );
1:17efc16:         createSetObjectProc( conn );
1:17efc16:     }
1:17efc16:     private static void    createSetObjectProc( Connection conn ) throws Exception
1:17efc16:     {
1:17efc16:         StringBuilder   buffer = new StringBuilder();
1:17efc16: 
1:17efc16:         buffer.append( "create procedure packAllTypes( in valueIdx int" );
1:17efc16:         
1:17efc16:         for ( int i = 0; i < _columnDescs.length; i++ )
1:17efc16:         {
1:17efc16:             ColumnDesc  cd = _columnDescs[ i ];
1:17efc16:             String  parameterName = "param" + (i+1);
1:17efc16:             String  parameterType = cd.sqlType;
1:17efc16:             buffer.append( ", in " + parameterName + " " + parameterType );
1:17efc16:         }
1:17efc16:         
1:17efc16:         buffer.append( " ) language java parameter style java no sql\n" );
1:17efc16:         buffer.append( "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest42.packAllTypes'" );
1:17efc16: 
1:17efc16:         String  sqlText = buffer.toString();
1:17efc16:         println( sqlText );
1:17efc16: 
1:17efc16:         conn.prepareStatement( sqlText ).execute();
1:17efc16:     }
1:17efc16:     private static void    vetSetObjectProc( Connection conn ) throws Exception
1:17efc16:     {
1:17efc16:         StringBuilder   buffer = new StringBuilder();
1:17efc16:         buffer.append( "call packAllTypes( ?" );
1:17efc16:         for ( int i = 0; i < _columnDescs.length; i++ ) { buffer.append( ", ?" ); }
1:17efc16:         buffer.append( " )" );
1:17efc16:         String  sqlText = buffer.toString();
1:17efc16:         println( sqlText );
1:17efc16: 
1:17efc16:         CallableStatement   cs = conn.prepareCall( sqlText );
1:17efc16:         int     valueIdx;
1:17efc16:         int     param;
1:9206d5b: 
1:17efc16:         // setObject( int, Object, SQLType )
1:17efc16:         valueIdx = 0;
1:17efc16:         param = 1;
1:17efc16:         cs.setInt( param++, valueIdx );
1:17efc16:         for ( int i = 0; i < _columnDescs.length; i++ )
1:17efc16:         {
1:17efc16:             ColumnDesc  cd = _columnDescs[ i ];
1:17efc16:             cs.setObject( param++, cd.values[ valueIdx ], cd.jdbcType );
1:17efc16:         }
1:17efc16:         cs.execute();
1:17efc16: 
1:17efc16:         // setObject( int, Object, SQLType, int )
1:17efc16:         valueIdx = 1;
1:17efc16:         param = 1;
1:17efc16:         cs.setInt( param++, valueIdx );
1:17efc16:         for ( int i = 0; i < _columnDescs.length; i++ )
1:17efc16:         {
1:17efc16:             ColumnDesc  cd = _columnDescs[ i ];
1:17efc16:             cs.setObject( param++, cd.values[ valueIdx ], cd.jdbcType, 0 );
1:17efc16:         }
1:17efc16:         cs.execute();
1:17efc16: 
1:17efc16:         // setObject( String, Object, SQLType )
1:17efc16:         try {
1:17efc16:             ColumnDesc  cd = _columnDescs[ 0 ];
1:17efc16:             cs.setObject( "param1", cd.values[ 0 ], cd.jdbcType );
1:17efc16:             fail( "Expected unimplemented feature." );
1:17efc16:         }
1:9f0c37a:         catch (SQLException se) { assertUnimplemented( se ); }
1:17efc16: 
1:17efc16:         // setObject( String, Object, SQLType, int )
1:17efc16:         try {
1:17efc16:             ColumnDesc  cd = _columnDescs[ 0 ];
1:17efc16:             cs.setObject( "param1", cd.values[ 0 ], cd.jdbcType, 0 );
1:17efc16:             fail( "Expected unimplemented feature." );
1:17efc16:         }
1:9f0c37a:         catch (SQLException se) { assertUnimplemented( se ); }
1:17efc16:     }
1:7cfb7e6: 
1:e25c098:     /**
1:e25c098:      * DERBY-6081: Verify that an SQLException is raised if the supplied
1:e25c098:      * SQLType argument is null. It used to fail with a NullPointerException.
1:e25c098:      */
1:9f0c37a:     public void test_04_targetTypeIsNull() throws Exception
1:9f0c37a:     {
1:e25c098:         setAutoCommit(false);
1:7cfb7e6: 
1:e25c098:         // Test PreparedStatement.setObject() with targetType == null.
1:7cfb7e6: 
1:e25c098:         PreparedStatement ps = prepareStatement("values cast(? as int)");
1:7cfb7e6: 
1:e25c098:         try {
1:e25c098:             ps.setObject(1, 1, null);
1:e25c098:             fail("setObject should fail when type is null");
1:9f0c37a:         } catch (SQLException se) { assertUnimplemented( se ); }
1:7cfb7e6: 
1:e25c098:         try {
1:e25c098:             ps.setObject(1, 1, null, 1);
1:e25c098:             fail("setObject should fail when type is null");
1:9f0c37a:         } catch (SQLException se) { assertUnimplemented( se ); }
1:7cfb7e6: 
1:e25c098:         // Test ResultSet.updateObject() with targetType == null.
1:7cfb7e6: 
1:e25c098:         Statement s = createStatement(
1:e25c098:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:e25c098:         s.execute("create table t(x int)");
1:e25c098:         s.execute("insert into t values 1");
7:e25c098: 
1:e25c098:         ResultSet rs = s.executeQuery("select * from t");
1:e25c098:         assertTrue(rs.next());
1:e25c098: 
1:e25c098:         try {
1:e25c098:             rs.updateObject("x", 1, null);
1:e25c098:             fail("updateObject should fail when type is null");
1:9f0c37a:         } catch (SQLException se) { assertUnimplemented( se ); }
1:e25c098: 
1:e25c098:         try {
1:e25c098:             rs.updateObject(1, 1, null);
1:e25c098:             fail("updateObject should fail when type is null");
1:9f0c37a:         } catch (SQLException se) { assertUnimplemented( se ); }
1:e25c098: 
1:e25c098:         try {
1:e25c098:             rs.updateObject("x", 1, null, 1);
1:e25c098:             fail("updateObject should fail when type is null");
1:9f0c37a:         } catch (SQLException se) { assertUnimplemented( se ); }
1:e25c098: 
1:e25c098:         try {
1:e25c098:             rs.updateObject(1, 1, null, 1);
1:e25c098:             fail("updateObject should fail when type is null");
1:9f0c37a:         } catch (SQLException se) { assertUnimplemented( se ); }
1:e25c098: 
1:e25c098:         // There should be no more rows.
1:e25c098:         JDBC.assertEmpty(rs);
1:17efc16:     }
1:e25c098: 
1:9206d5b:     //////////////////////////////////////////////////////////
1:9206d5b:     //
1:9206d5b:     // SQL ROUTINES
1:9206d5b:     //
1:9206d5b:     //////////////////////////////////////////////////////////
1:9206d5b: 
1:9206d5b:     public  static  void    unpackAllTypes
1:9206d5b:         (
1:9206d5b:          int valueIdx,
1:9206d5b:          Long[]    bigintValue,
1:9206d5b:          Blob[]   blobValue,
1:9206d5b:          Boolean[] booleanValue,
1:9206d5b:          String[]  charValue,
1:9206d5b:          byte[][]  binaryValue,
1:9206d5b:          Clob[]    clobValue,
1:9206d5b:          Date[]    dateValue,
1:9206d5b:          BigDecimal[]  decimalValue,
1:9206d5b:          Double[]  doubleValue,
1:9206d5b:          Double[]  floatValue,
1:9206d5b:          Integer[] intValue,
1:9206d5b:          String[]  longVarcharValue,
1:9206d5b:          byte[][]  longVarbinaryValue,
1:9206d5b:          BigDecimal[]  numericValue,
1:9206d5b:          Float[]   realValue,
1:9206d5b:          Integer[]   smallintValue,
1:9206d5b:          Time[]    timeValue,
1:9206d5b:          Timestamp[]  timestampValue,
1:9206d5b:          Price[]   priceValue,
1:9206d5b:          String[]  varcharValue,
1:9206d5b:          byte[][]  varbinaryValue
1:9206d5b:          )
1:17efc16:     {
1:9206d5b:         int     colIdx = 0;
1:9206d5b:         
1:9206d5b:         bigintValue[ 0 ] = (Long) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         blobValue[ 0 ] = (Blob) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         booleanValue[ 0 ] = (Boolean) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         charValue[ 0 ] = (String) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         binaryValue[ 0 ] = (byte[]) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         clobValue[ 0 ] = (Clob) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         dateValue[ 0 ] = (Date) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         decimalValue[ 0 ] = (BigDecimal) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         doubleValue[ 0 ] = (Double) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         floatValue[ 0 ] = (Double) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         intValue[ 0 ] = (Integer) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         longVarcharValue[ 0 ] = (String) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         longVarbinaryValue[ 0 ] = (byte[]) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         numericValue[ 0 ] = (BigDecimal) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         realValue[ 0 ] = (Float) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         smallintValue[ 0 ] = (Integer) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         timeValue[ 0 ] = (Time) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         timestampValue[ 0 ] = (Timestamp) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         priceValue[ 0 ] = (Price) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         varcharValue[ 0 ] = (String) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:9206d5b:         varbinaryValue[ 0 ] = (byte[]) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:17efc16:     }
1:9206d5b: 
1:17efc16:     public  static  void    packAllTypes
1:17efc16:         (
1:17efc16:          int valueIdx,
1:17efc16:          Long    bigintValue,
1:17efc16:          Blob   blobValue,
1:17efc16:          Boolean booleanValue,
1:17efc16:          String  charValue,
1:17efc16:          byte[]  binaryValue,
1:17efc16:          Clob    clobValue,
1:17efc16:          Date    dateValue,
1:17efc16:          BigDecimal  decimalValue,
1:17efc16:          Double  doubleValue,
1:17efc16:          Double  floatValue,
1:17efc16:          Integer intValue,
1:17efc16:          String  longVarcharValue,
1:17efc16:          byte[]  longVarbinaryValue,
1:17efc16:          BigDecimal  numericValue,
1:17efc16:          Float   realValue,
1:17efc16:          Integer   smallintValue,
1:17efc16:          Time    timeValue,
1:17efc16:          Timestamp  timestampValue,
1:17efc16:          Price   priceValue,
1:17efc16:          String  varcharValue,
1:17efc16:          byte[]  varbinaryValue
1:17efc16:          )
1:17efc16:         throws Exception
1:17efc16:     {
1:17efc16:         int     colIdx = 0;
1:17efc16:         
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], bigintValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], blobValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], booleanValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], charValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], binaryValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], clobValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], dateValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], decimalValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], doubleValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], floatValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], intValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], longVarcharValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], longVarbinaryValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], numericValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], realValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], smallintValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], timeValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], timestampValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], priceValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], varcharValue );
1:17efc16:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], varbinaryValue );
1:17efc16:     }
1:17efc16: 
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6:     //
1:7cfb7e6:     // MINIONS
1:7cfb7e6:     //
1:7cfb7e6:     //////////////////////////////////////////////////////////
1:7cfb7e6: 
1:9206d5b:     private static void setupPrice( Connection conn ) throws Exception
1:9206d5b:     {
1:9206d5b:         if ( !aliasExists( conn, "PRICE" ) )
1:9206d5b:         {
1:9206d5b:             conn.prepareStatement
1:9206d5b:                 (
1:9206d5b:                  "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:9206d5b:                  ).execute();
1:9206d5b:         }
1:9206d5b:     }
1:9206d5b:     private static  boolean aliasExists( Connection conn, String aliasName ) throws Exception
1:9206d5b:     {
1:9206d5b:         PreparedStatement   ps = conn.prepareStatement( "select count(*) from sys.sysaliases where alias = ?" );
1:9206d5b:         ps.setString( 1, aliasName );
1:9206d5b:         ResultSet   rs = ps.executeQuery();
1:9206d5b:         rs.next();
1:9206d5b: 
1:9206d5b:         int retval = rs.getInt( 1 );
1:9206d5b: 
1:9206d5b:         rs.close();
1:9206d5b:         ps.close();
1:9206d5b: 
1:9206d5b:         return (retval > 0);
1:9206d5b:     }
1:9206d5b:     
1:7cfb7e6:     private  static  Blob    makeBlob( String contents )
1:9206d5b:     {
1:7cfb7e6:         return new HarmonySerialBlob( makeBinary( contents ) );
1:9206d5b:     }
1:7cfb7e6: 
1:7cfb7e6:     private  static  Clob    makeClob( String contents )
1:7cfb7e6:     {
1:7cfb7e6:         return new HarmonySerialClob( contents );
1:7cfb7e6:     }
1:7cfb7e6: 
1:7cfb7e6:     private  static  byte[]    makeBinary( String contents )
1:7cfb7e6:     {
1:7cfb7e6:         try {
1:7cfb7e6:             return contents.getBytes( "UTF-8" );
1:7cfb7e6:         }
1:7cfb7e6:         catch (Exception e)
1:7cfb7e6:         {
1:7cfb7e6:             e.printStackTrace();
1:7cfb7e6:             return null;
1:7cfb7e6:         }
1:7cfb7e6:     }
1:7cfb7e6: 
1:7cfb7e6:     private static  Price   makePrice( long raw )
1:7cfb7e6:     {
1:7cfb7e6:         return Price.makePrice( new BigDecimal( raw ) );
1:7cfb7e6:     }
1:7cfb7e6: 
1:9206d5b:     public static void    assertObjectEquals( Object expected, Object actual ) throws Exception
1:7cfb7e6:     {
1:7cfb7e6:         if ( expected == null )
1:7cfb7e6:         {
1:7cfb7e6:             assertNull( actual );
1:7cfb7e6:             return;
1:7cfb7e6:         }
1:7cfb7e6:         else if ( actual == null )
1:7cfb7e6:         {
1:7cfb7e6:             assertNull( expected );
1:7cfb7e6:             return;
1:7cfb7e6:         }
1:7cfb7e6:         else if ( expected instanceof Blob ) { assertEquals( (Blob) expected, (Blob) actual ); }
1:7cfb7e6:         else if ( expected instanceof Clob ) { assertEquals( (Clob) expected, (Clob) actual ); }
1:7cfb7e6:         else if ( expected instanceof byte[] ) { compareBytes( (byte[]) expected, (byte[]) actual ); }
1:7cfb7e6:         else { assertEquals( expected.toString(), actual.toString() ); }
1:7cfb7e6:     }
1:9206d5b:     private static void  compareBytes( byte[] left, byte[] right )
1:7cfb7e6:         throws Exception
1:7cfb7e6:     {
1:7cfb7e6:         int count = left.length;
1:7cfb7e6:         
1:7cfb7e6:         if ( count != right.length )
1:7cfb7e6:         {
1:7cfb7e6:             fail("left count = " + count + " but right count = " + right.length );
1:7cfb7e6:         }
1:7cfb7e6:         for ( int i = 0; i < count; i++ )
1:7cfb7e6:         {
1:7cfb7e6:             if ( left[ i ] != right[ i ] )
1:7cfb7e6:             {
1:7cfb7e6:                 fail( "left[ " + i + " ] = " + left[ i ] + " but right[ " + i + " ] = " + right[ i ] );
1:7cfb7e6:             }
1:7cfb7e6:         }
1:7cfb7e6:     }
1:7cfb7e6: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         new ColumnDesc( JDBCType.BIGINT, "bigint", 0L, 1L, null ),
/////////////////////////////////////////////////////////////////////////
1:         new ColumnDesc( JDBCType.DOUBLE, "double", 0.0, 1.0, null ),
1:         new ColumnDesc( JDBCType.FLOAT, "float", 0.0, 1.0, null ),
1:         new ColumnDesc( JDBCType.INTEGER, "int", 0, 1, null ),
1:         new ColumnDesc( JDBCType.REAL, "real", 0.0F, 1F, null ),
1:         new ColumnDesc( JDBCType.SMALLINT, "smallint", 0, 1, null ),
commit:4c2fc4a
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   int[]  ILLEGAL_SQL_TYPES = new int[]
1:     {
1:         Types.ARRAY,
1:         Types.DATALINK,
1:         Types.DISTINCT,
1:         Types.LONGNVARCHAR,
1:         Types.NCHAR,
1:         Types.NCLOB,
1:         Types.NVARCHAR,
1:         Types.OTHER,
1:         Types.REF,
1:         Types.REF_CURSOR,
1:         Types.ROWID,
1:         Types.SQLXML,
1:         Types.STRUCT,
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:  
1:         // Make sure that the pre-JDBC4.2 overloads throw the correct exception too
1:         valueIdx = 1;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < ILLEGAL_SQL_TYPES.length; i++ )
1:         {
1:             int     type = ILLEGAL_SQL_TYPES[ i ];
1:             try {
1:                 cs.registerOutParameter( param++, type, 0 );
1:                 fail( "Should not have been able to register parameter type " + type );
1:             } catch (SQLException se) { assertUnimplemented( se ); }
1:         }
commit:1149dc1
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify that ResultSet.updateObject() fails on bad SQLTypes
1:         prepTable( conn, 0 );
1:         updateRS = forUpdatePS.executeQuery();
1:         updateRS.next();
1:         println( "Testing ResultSet.updateObject() on illegal types." );
1:         for ( int i = 0; i < ILLEGAL_JDBC_TYPES.length; i++ )
1:         {
1:             try {
1:                 updateRS.updateObject( 2, _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ] );
1:                 fail( "updateObject() should have failed." );
1:             }
1:             catch (SQLException se) { assertUnimplemented( se ); }
1:             try {
1:                 updateRS.updateObject( 2, _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ], 0 );
1:                 fail( "updateObject() should have failed." );
1:             }
1:             catch (SQLException se) { assertUnimplemented( se ); }
1:             try {
1:                 updateRS.updateObject( "col2", _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ] );
1:                 fail( "updateObject() should have failed." );
1:             }
1:             catch (SQLException se) { assertUnimplemented( se ); }
1:             try {
1:                 updateRS.updateObject( "col2", _columnDescs[ 0 ].values[ 1 ], ILLEGAL_JDBC_TYPES[ i ], 0 );
1:                 fail( "updateObject() should have failed." );
1:             }
1:             catch (SQLException se) { assertUnimplemented( se ); }
1:         }
1:         updateRS.close();
1:         vetTable( conn, 0, 1 );
commit:01c7f83
/////////////////////////////////////////////////////////////////////////
1:         JDBCType.DISTINCT,
1:         JDBCType.LONGNVARCHAR,
1:         JDBCType.NULL,
1:         JDBCType.OTHER,
/////////////////////////////////////////////////////////////////////////
1:                 fail( "setObject() should have failed." );
commit:9f0c37a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             catch (SQLException se) { assertUnimplemented( se ); }
1:     private static void    assertUnimplemented( SQLException se ) throws Exception
1:     {
1:         assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:         assertTrue( se instanceof SQLFeatureNotSupportedException );
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1:         // Negative test
1:         valueIdx = 1;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < ILLEGAL_JDBC_TYPES.length; i++ )
1:         {
1:             try {
1:                 cs.registerOutParameter( param++, ILLEGAL_JDBC_TYPES[ i ], 0 );
1:                 fail();
1:             }
1:             catch (SQLException se) { assertUnimplemented( se ); }
1:         }
1: 
1:         catch (SQLException se) { assertUnimplemented( se ); }
1:         catch (SQLException se) { assertUnimplemented( se ); }
1:         catch (SQLException se) { assertUnimplemented( se ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (SQLException se) { assertUnimplemented( se ); }
/////////////////////////////////////////////////////////////////////////
1:         catch (SQLException se) { assertUnimplemented( se ); }
1:     public void test_04_targetTypeIsNull() throws Exception
1:     {
/////////////////////////////////////////////////////////////////////////
1:         } catch (SQLException se) { assertUnimplemented( se ); }
1:         } catch (SQLException se) { assertUnimplemented( se ); }
/////////////////////////////////////////////////////////////////////////
1:         } catch (SQLException se) { assertUnimplemented( se ); }
1:         } catch (SQLException se) { assertUnimplemented( se ); }
1:         } catch (SQLException se) { assertUnimplemented( se ); }
1:         } catch (SQLException se) { assertUnimplemented( se ); }
commit:17efc16
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test the CallableStatement.setObject() overloads added by JDBC 4.2.
1:      * </p>
1:      */
1:     public  void    test_03_setObject() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         callableStatementSetObjectTest( conn );
1:     }
1:     public  static  void    callableStatementSetObjectTest( Connection conn ) throws Exception
1:     {
1:         createSetObjectSchemaObjects( conn );
1:         vetSetObjectProc( conn );
1:     }
1:     private static void    createSetObjectSchemaObjects( Connection conn ) throws Exception
1:     {
1:         setupPrice( conn );
1:         createSetObjectProc( conn );
1:     }
1:     private static void    createSetObjectProc( Connection conn ) throws Exception
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1: 
1:         buffer.append( "create procedure packAllTypes( in valueIdx int" );
1:         
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ i ];
1:             String  parameterName = "param" + (i+1);
1:             String  parameterType = cd.sqlType;
1:             buffer.append( ", in " + parameterName + " " + parameterType );
1:         }
1:         
1:         buffer.append( " ) language java parameter style java no sql\n" );
1:         buffer.append( "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest42.packAllTypes'" );
1: 
1:         String  sqlText = buffer.toString();
1:         println( sqlText );
1: 
1:         conn.prepareStatement( sqlText ).execute();
1:     }
1:     private static void    vetSetObjectProc( Connection conn ) throws Exception
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1:         buffer.append( "call packAllTypes( ?" );
1:         for ( int i = 0; i < _columnDescs.length; i++ ) { buffer.append( ", ?" ); }
1:         buffer.append( " )" );
1:         String  sqlText = buffer.toString();
1:         println( sqlText );
1: 
1:         CallableStatement   cs = conn.prepareCall( sqlText );
1:         int     valueIdx;
1:         int     param;
1: 
1:         // setObject( int, Object, SQLType )
1:         valueIdx = 0;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ i ];
1:             cs.setObject( param++, cd.values[ valueIdx ], cd.jdbcType );
1:         }
1:         cs.execute();
1: 
1:         // setObject( int, Object, SQLType, int )
1:         valueIdx = 1;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ i ];
1:             cs.setObject( param++, cd.values[ valueIdx ], cd.jdbcType, 0 );
1:         }
1:         cs.execute();
1: 
1:         // setObject( String, Object, SQLType )
1:         try {
1:             ColumnDesc  cd = _columnDescs[ 0 ];
1:             cs.setObject( "param1", cd.values[ 0 ], cd.jdbcType );
1:             fail( "Expected unimplemented feature." );
1:         }
0:         catch (SQLException se)
1:         {
0:             assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:         }
1: 
1:         // setObject( String, Object, SQLType, int )
1:         try {
1:             ColumnDesc  cd = _columnDescs[ 0 ];
1:             cs.setObject( "param1", cd.values[ 0 ], cd.jdbcType, 0 );
1:             fail( "Expected unimplemented feature." );
1:         }
0:         catch (SQLException se)
1:         {
0:             assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public  static  void    packAllTypes
1:         (
1:          int valueIdx,
1:          Long    bigintValue,
1:          Blob   blobValue,
1:          Boolean booleanValue,
1:          String  charValue,
1:          byte[]  binaryValue,
1:          Clob    clobValue,
1:          Date    dateValue,
1:          BigDecimal  decimalValue,
1:          Double  doubleValue,
1:          Double  floatValue,
1:          Integer intValue,
1:          String  longVarcharValue,
1:          byte[]  longVarbinaryValue,
1:          BigDecimal  numericValue,
1:          Float   realValue,
1:          Integer   smallintValue,
1:          Time    timeValue,
1:          Timestamp  timestampValue,
1:          Price   priceValue,
1:          String  varcharValue,
1:          byte[]  varbinaryValue
1:          )
1:         throws Exception
1:     {
1:         int     colIdx = 0;
1:         
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], bigintValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], blobValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], booleanValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], charValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], binaryValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], clobValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], dateValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], decimalValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], doubleValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], floatValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], intValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], longVarcharValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], longVarbinaryValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], numericValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], realValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], smallintValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], timeValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], timestampValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], priceValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], varcharValue );
1:         assertObjectEquals( _columnDescs[ colIdx++ ].values[ valueIdx ], varbinaryValue );
1:     }
1: 
commit:9206d5b
/////////////////////////////////////////////////////////////////////////
0: import java.io.Serializable;
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  UNIMPLEMENTED_FEATURE = "0A000";
1: 
/////////////////////////////////////////////////////////////////////////
0:         new ColumnDesc( JDBCType.REAL, "real", new Float( 0.0F ), new Float( 1F ), null ),
0:         new ColumnDesc( JDBCType.SMALLINT, "smallint", new Integer( 0 ), new Integer( 1 ), null ),
/////////////////////////////////////////////////////////////////////////
1:         setupPrice( conn );
1:     {        
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test the CallableStatement.registerObject() overloads added by JDBC 4.2.
1:      * </p>
1:      */
1:     public  void    test_02_registerObject() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         registerObjectTest( conn );
1:     }
1:     public  static  void    registerObjectTest( Connection conn ) throws Exception
1:     {
1:         createSchemaObjects( conn );
1:         vetProc( conn );
1:     }
1:     private static void    createSchemaObjects( Connection conn ) throws Exception
1:     {
1:         setupPrice( conn );
1:         createProc( conn );
1:     }
1:     private static void    createProc( Connection conn ) throws Exception
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1: 
1:         buffer.append( "create procedure unpackAllTypes( in valueIdx int" );
1:         
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ i ];
1:             String  parameterName = "param" + (i+1);
1:             String  parameterType = cd.sqlType;
1:             buffer.append( ", out " + parameterName + " " + parameterType );
1:         }
1:         
1:         buffer.append( " ) language java parameter style java no sql\n" );
1:         buffer.append( "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest42.unpackAllTypes'" );
1: 
1:         String  sqlText = buffer.toString();
1:         println( sqlText );
1: 
1:         conn.prepareStatement( sqlText ).execute();
1:     }
1:     private static void    vetProc( Connection conn ) throws Exception
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1:         buffer.append( "call unpackAllTypes( ?" );
1:         for ( int i = 0; i < _columnDescs.length; i++ ) { buffer.append( ", ?" ); }
1:         buffer.append( " )" );
1:         String  sqlText = buffer.toString();
1:         println( sqlText );
1: 
1:         CallableStatement   cs = conn.prepareCall( sqlText );
1:         int     valueIdx;
1:         int     param;
1: 
1:         // registerOutParameter( int, SQLType )
1:         valueIdx = 0;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             cs.registerOutParameter( param++, _columnDescs[ i ].jdbcType );
1:         }
1:         cs.execute();
1:         vetCS( cs, valueIdx );
1: 
1:         // registerOutParameter( int, SQLType, int )
1:         valueIdx = 1;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             cs.registerOutParameter( param++, _columnDescs[ i ].jdbcType, 0 );
1:         }
1:         cs.execute();
1:         vetCS( cs, valueIdx );
1: 
1:         // registerOutParameter( int, SQLType, String )
1:         valueIdx = 0;
1:         param = 1;
1:         cs.setInt( param++, valueIdx );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             cs.registerOutParameter( param++, _columnDescs[ i ].jdbcType, "foo" );
1:         }
1:         cs.execute();
1:         vetCS( cs, valueIdx );
1: 
1:         // registerOutParameter( String, SQLType )
1:         try {
1:             cs.registerOutParameter( "param1", _columnDescs[ 0 ].jdbcType );
1:             fail( "Expected unimplemented feature." );
1:         }
0:         catch (SQLException se)
1:         {
0:             assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:         }
1: 
1:         // registerOutParameter( String, SQLType, int )
1:         try {
1:             cs.registerOutParameter( "param1", _columnDescs[ 0 ].jdbcType, 0 );
1:             fail( "Expected unimplemented feature." );
1:         }
0:         catch (SQLException se)
1:         {
0:             assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:         }
1: 
1:         // registerOutParameter( String, SQLType, String )
1:         try {
1:             cs.registerOutParameter( "param1", _columnDescs[ 0 ].jdbcType, "foo" );
1:             fail( "Expected unimplemented feature." );
1:         }
0:         catch (SQLException se)
1:         {
0:             assertSQLState( UNIMPLEMENTED_FEATURE, se );
1:         }
1:     }
1:     private  static void    vetCS( CallableStatement cs, int valueIdx )
1:         throws Exception
1:     {
1:         int     idx = 0;
1:         int     colIdx = 2;
1: 
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:         assertObjectEquals( _columnDescs[ idx++ ].values[ valueIdx ], cs.getObject( colIdx++ ) );
1:     }
1: 
1: 
1:     //////////////////////////////////////////////////////////
1:     //
1:     // SQL ROUTINES
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     public  static  void    unpackAllTypes
1:         (
1:          int valueIdx,
1:          Long[]    bigintValue,
1:          Blob[]   blobValue,
1:          Boolean[] booleanValue,
1:          String[]  charValue,
1:          byte[][]  binaryValue,
1:          Clob[]    clobValue,
1:          Date[]    dateValue,
1:          BigDecimal[]  decimalValue,
1:          Double[]  doubleValue,
1:          Double[]  floatValue,
1:          Integer[] intValue,
1:          String[]  longVarcharValue,
1:          byte[][]  longVarbinaryValue,
1:          BigDecimal[]  numericValue,
1:          Float[]   realValue,
1:          Integer[]   smallintValue,
1:          Time[]    timeValue,
1:          Timestamp[]  timestampValue,
1:          Price[]   priceValue,
1:          String[]  varcharValue,
1:          byte[][]  varbinaryValue
1:          )
1:     {
1:         int     colIdx = 0;
1:         
1:         bigintValue[ 0 ] = (Long) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         blobValue[ 0 ] = (Blob) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         booleanValue[ 0 ] = (Boolean) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         charValue[ 0 ] = (String) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         binaryValue[ 0 ] = (byte[]) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         clobValue[ 0 ] = (Clob) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         dateValue[ 0 ] = (Date) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         decimalValue[ 0 ] = (BigDecimal) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         doubleValue[ 0 ] = (Double) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         floatValue[ 0 ] = (Double) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         intValue[ 0 ] = (Integer) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         longVarcharValue[ 0 ] = (String) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         longVarbinaryValue[ 0 ] = (byte[]) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         numericValue[ 0 ] = (BigDecimal) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         realValue[ 0 ] = (Float) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         smallintValue[ 0 ] = (Integer) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         timeValue[ 0 ] = (Time) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         timestampValue[ 0 ] = (Timestamp) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         priceValue[ 0 ] = (Price) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         varcharValue[ 0 ] = (String) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:         varbinaryValue[ 0 ] = (byte[]) _columnDescs[ colIdx++ ].values[ valueIdx ];
1:     }
1: 
1:     private static void setupPrice( Connection conn ) throws Exception
1:     {
1:         if ( !aliasExists( conn, "PRICE" ) )
1:         {
1:             conn.prepareStatement
1:                 (
1:                  "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:                  ).execute();
1:         }
1:     }
1:     private static  boolean aliasExists( Connection conn, String aliasName ) throws Exception
1:     {
1:         PreparedStatement   ps = conn.prepareStatement( "select count(*) from sys.sysaliases where alias = ?" );
1:         ps.setString( 1, aliasName );
1:         ResultSet   rs = ps.executeQuery();
1:         rs.next();
1: 
1:         int retval = rs.getInt( 1 );
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return (retval > 0);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     public static void    assertObjectEquals( Object expected, Object actual ) throws Exception
/////////////////////////////////////////////////////////////////////////
1:     private static void  compareBytes( byte[] left, byte[] right )
commit:fc9b418
/////////////////////////////////////////////////////////////////////////
1:         updateColumns( conn );
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement   insert = prepareInsert( conn );
1:             insertRow( insert, rowIdx );
/////////////////////////////////////////////////////////////////////////
1:     private PreparedStatement   prepareInsert( Connection conn ) throws Exception
1:     {
1:         StringBuilder   columnBuffer = new StringBuilder();
1:         StringBuilder   valuesBuffer = new StringBuilder();
1: 
1:         columnBuffer.append( "( " );
1:         valuesBuffer.append( "( " );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             String  columnName = "col" + (i+1);
1:             if ( i > 0 )
1:             {
1:                 columnBuffer.append( ", " );
1:                 valuesBuffer.append( ", " );
1:             }
1:             columnBuffer.append( columnName );
1:             valuesBuffer.append( "?" );
1:         }
1:         columnBuffer.append( " )" );
1:         valuesBuffer.append( " )" );
1: 
1:         PreparedStatement   insert = conn.prepareStatement
1:             ( "insert into allTypes " + columnBuffer.toString() + " values " + valuesBuffer.toString() );
1: 
1:         return insert;
1:     }
1:     private void    insertRow( PreparedStatement insert, int rowIdx ) throws Exception
1:     {
1:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:             insert.setObject( colIdx + 1, cd.values[ rowIdx ], cd.jdbcType );
1:         }
1:         insert.executeUpdate();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     // test the behavior of the new ResultSet methods added by JDBC 4.2
1:     private void    updateColumns( Connection conn ) throws Exception
1:     {
1:         PreparedStatement forUpdatePS = conn.prepareStatement
1:             ( "select * from allTypes for update", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE );
1:         ResultSet   updateRS = null;
1: 
1:         // ResultSet.updateObject( int, Object, SQLType )
1:         prepTable( conn, 0 );
1:         updateRS = forUpdatePS.executeQuery();
1:         updateRS.next();
1:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:             updateRS.updateObject( colIdx + 2, cd.values[ 1 ], cd.jdbcType );
1:         }
1:         updateRS.updateRow();
1:         updateRS.close();
1:         vetTable( conn, 1, 1 );
1: 
1:         // ResultSet.updateObject( int, Object, SQLType, int )
1:         prepTable( conn, 0 );
1:         updateRS = forUpdatePS.executeQuery();
1:         updateRS.next();
1:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:             updateRS.updateObject( colIdx + 2, cd.values[ 1 ], cd.jdbcType, 0 );
1:         }
1:         updateRS.updateRow();
1:         updateRS.close();
1:         vetTable( conn, 1, 1 );
1: 
1:         // ResultSet.updateObject( String, Object, SQLType )
1:         prepTable( conn, 0 );
1:         updateRS = forUpdatePS.executeQuery();
1:         updateRS.next();
1:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:             updateRS.updateObject( "col" + (colIdx+1), cd.values[ 1 ], cd.jdbcType );
1:         }
1:         updateRS.updateRow();
1:         updateRS.close();
1:         vetTable( conn, 1, 1 );
1: 
1:         // ResultSet.updateObject( String, Object, SQLType, int )
1:         prepTable( conn, 0 );
1:         updateRS = forUpdatePS.executeQuery();
1:         updateRS.next();
1:         for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ colIdx ];
1:             updateRS.updateObject( "col" + (colIdx+1), cd.values[ 1 ], cd.jdbcType, 0 );
1:         }
1:         updateRS.updateRow();
1:         updateRS.close();
1:         vetTable( conn, 1, 1 );
1:     }
1:     private void    prepTable( Connection conn, int rowIdx ) throws Exception
1:     {
1:         conn.prepareStatement( "truncate table allTypes" ).execute();
1: 
1:         PreparedStatement   insert = prepareInsert( conn );
1: 
1:         insertRow( insert, rowIdx );
1:         vetTable( conn,rowIdx, 1 );
1:     }
1:     private void    vetTable( Connection conn, int rowIdx, int expectedRowCount ) throws Exception
1:     {
1:         PreparedStatement   selectPS = conn.prepareStatement( "select * from allTypes order by col0" );
1:         ResultSet               selectRS = selectPS.executeQuery();
1:         int                     actualRowCount = 0;
1: 
1:         while( selectRS.next() )
1:         {
1:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:             {
1:                 Object          expected = _columnDescs[ colIdx ].values[ rowIdx ];
1: 
1:                 // skip the first column, the primary key
1:                 assertObjectEquals( expected, selectRS.getObject( colIdx + 2 ) );
1:             }
1: 
1:             actualRowCount++;
1:         }
1: 
1:         assertEquals( expectedRowCount, actualRowCount );
1:         
1:         selectRS.close();
1:         selectPS.close();
1:     }
commit:7cfb7e6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest42
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to you under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.math.BigDecimal;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.Date;
1: import java.sql.JDBCType;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: 
0: import junit.framework.*;
1: 
1: import org.apache.derby.iapi.types.HarmonySerialBlob;
1: import org.apache.derby.iapi.types.HarmonySerialClob;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.functionTests.tests.lang.Price;
1: 
1: /**
1:  * Tests for new methods added for PreparedStatement in JDBC 4.2.
1:  */
1: public class PreparedStatementTest42 extends BaseJDBCTestCase
1: {
1:     //////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     //
1:     // If any of these becomes a legal Derby type, remove it from this table and put a corresponding line
1:     // into _columnDescs.
1:     //
1:     private static  final   JDBCType[]  ILLEGAL_JDBC_TYPES = new JDBCType[]
1:     {
1:         JDBCType.ARRAY,
1:         JDBCType.DATALINK,
1:         JDBCType.NCHAR,
1:         JDBCType.NCLOB,
1:         JDBCType.NVARCHAR,
1:         JDBCType.REF,
1:         JDBCType.REF_CURSOR,
1:         JDBCType.ROWID,
1:         JDBCType.SQLXML,
1:         JDBCType.STRUCT,
0:         JDBCType.TINYINT,
1:     };
1: 
1:     //////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     private static  ColumnDesc[]    _columnDescs =
1:     {
0:         new ColumnDesc( JDBCType.BIGINT, "bigint", new Long( 0L ), new Long( 1L ), null ),
1:         new ColumnDesc( JDBCType.BLOB, "blob", makeBlob( "01234" ), makeBlob( "56789" ), null ),
1:         new ColumnDesc( JDBCType.BOOLEAN, "boolean", Boolean.FALSE, Boolean.TRUE, null ),
1:         new ColumnDesc( JDBCType.CHAR, "char( 5 )", "01234", "56789", null ),
1:         new ColumnDesc( JDBCType.BINARY, "char( 5 ) for bit data", makeBinary( "01234" ), makeBinary( "56789" ), null ),
1:         new ColumnDesc( JDBCType.CLOB, "clob", makeClob( "01234" ), makeClob( "56789" ), null ),
1:         new ColumnDesc( JDBCType.DATE, "date", new Date( 0L ), new Date( 1L ), null ),
1:         new ColumnDesc( JDBCType.DECIMAL, "decimal", new BigDecimal( 0 ), new BigDecimal( 1 ), null ),
0:         new ColumnDesc( JDBCType.DOUBLE, "double", new Double( 0.0 ), new Double( 1.0 ), null ),
0:         new ColumnDesc( JDBCType.FLOAT, "float", new Double( 0.0 ), new Double( 1.0 ), null ),
0:         new ColumnDesc( JDBCType.INTEGER, "int", new Integer( 0 ), new Integer( 1 ), null ),
1:         new ColumnDesc( JDBCType.LONGVARCHAR, "long varchar", "01234", "56789", null ),
1:         new ColumnDesc( JDBCType.LONGVARBINARY, "long varchar for bit data", makeBinary( "01234" ), makeBinary( "56789" ), null ),
1:         new ColumnDesc( JDBCType.NUMERIC, "numeric", new BigDecimal( 0 ), new BigDecimal( 1 ), null ),
0:         new ColumnDesc( JDBCType.REAL, "float", new Float( 0.0F ), new Float( 1F ), null ),
0:         new ColumnDesc( JDBCType.SMALLINT, "smallint", new Short( (short) 0 ), new Short( (short) 1 ), null ),
1:         new ColumnDesc( JDBCType.TIME, "time", new Time( 0L ), new Time( 1L ), null ),
1:         new ColumnDesc( JDBCType.TIMESTAMP, "timestamp", new Timestamp( 0L ), new Timestamp( 1L ), null ),
1:         new ColumnDesc( JDBCType.JAVA_OBJECT, "Price", makePrice( 0L ), makePrice( 1L ), null ),
1:         new ColumnDesc( JDBCType.VARCHAR, "varchar( 5 )", "01234", "56789", null ),
1:         new ColumnDesc( JDBCType.VARBINARY, "varchar( 5 ) for bit data", makeBinary( "01234" ), makeBinary( "56789" ), null ),
1:         // get/setObject on XML not supported because Derby does not support SQLXML yet
1:     };
1: 
1:     //////////////////////////////////////////////////////////
1:     //
1:     // NESTED CLASSES
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     public  static  final   class   ColumnDesc
1:     {
1:         public  static  final   int VALUE_COUNT = 3;
1:         
1:         public  final   JDBCType    jdbcType;
1:         public  final   String          sqlType;
1:         public  final   Object[]    values;
1: 
1:         public  ColumnDesc
1:             (
1:              JDBCType    jdbcType,
1:              String          sqlType,
1:              Object...  values
1:              )
1:         {
1:             this.jdbcType = jdbcType;
1:             this.sqlType = sqlType;
1:             this.values = values;
1: 
1:             if ( values.length != VALUE_COUNT )
1:             {
1:                 throw new IllegalArgumentException( "Expected " + VALUE_COUNT + " values but saw " + values.length );
1:             }
1:         }
1:     }
1: 
1:     //////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a new test with the given name.
1:      */
1:     public PreparedStatementTest42( String name ) { super(name); }
1: 
1:     //////////////////////////////////////////////////////////
1:     //
1:     // JUnit MACHINERY
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("PreparedStatementTest42");
1: 
1:         suite.addTest( TestConfiguration.defaultSuite( PreparedStatementTest42.class ) );
1: 
1:         return suite;
1:     }
1:     
1:     //////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Test the setObject() overloads added by JDBC 4.2.
1:      * </p>
1:      */
1:     public  void    test_01_setObject() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         makeTable( conn );
1:         populateTable( conn );
1:         vetTableContents( conn );
1:     }
1:     private void    makeTable( Connection conn ) throws Exception
1:     {
0:         conn.prepareStatement
1:             (
0:              "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
0:              ).execute();
1:         
1:         StringBuilder   buffer = new StringBuilder();
1: 
1:         buffer.append( "create table allTypes\n(\n" );
1:         buffer.append( "\tcol0\tint generated always as identity" );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             ColumnDesc  cd = _columnDescs[ i ];
1:             String  columnName = "col" + (i+1);
1:             String  columnType = cd.sqlType;
1:             buffer.append( "\n\t, " + columnName + "\t" + columnType );
1:         }
1:         buffer.append( "\n)" );
1: 
1:         conn.prepareStatement( buffer.toString() ).execute();
1:     }
1:     private void    populateTable( Connection conn ) throws Exception
1:     {
0:         StringBuilder   columnBuffer = new StringBuilder();
0:         StringBuilder   valuesBuffer = new StringBuilder();
1: 
0:         columnBuffer.append( "( " );
0:         valuesBuffer.append( "( " );
1:         for ( int i = 0; i < _columnDescs.length; i++ )
1:         {
1:             String  columnName = "col" + (i+1);
0:             if ( i > 0 )
1:             {
0:                 columnBuffer.append( ", " );
0:                 valuesBuffer.append( ", " );
1:             }
0:             columnBuffer.append( columnName );
0:             valuesBuffer.append( "?" );
1:         }
0:         columnBuffer.append( " )" );
0:         valuesBuffer.append( " )" );
1: 
0:         PreparedStatement   insert = conn.prepareStatement
0:             ( "insert into allTypes " + columnBuffer.toString() + " values " + valuesBuffer.toString() );
1: 
1:         for ( int rowIdx = 0; rowIdx < ColumnDesc.VALUE_COUNT; rowIdx++ )
1:         {
1:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:             {
1:                 ColumnDesc  cd = _columnDescs[ colIdx ];
0:                 insert.setObject( colIdx + 1, cd.values[ rowIdx ], cd.jdbcType );
1:             }
1:             insert.executeUpdate();
1:         }
1: 
1:         for ( int rowIdx = 0; rowIdx < ColumnDesc.VALUE_COUNT; rowIdx++ )
1:         {
1:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:             {
1:                 ColumnDesc  cd = _columnDescs[ colIdx ];
1:                 insert.setObject( colIdx + 1, cd.values[ rowIdx ], cd.jdbcType, 0 );
1:             }
1:             insert.executeUpdate();
1:         }
1: 
1: 
1:         // verify that certain SQLTypes are illegal
1:         for ( int i = 0; i < ILLEGAL_JDBC_TYPES.length; i++ )
1:         {
1:             try {
1:                 insert.setObject( 1, null, ILLEGAL_JDBC_TYPES[ i ] );
1:             }
0:             catch (SQLException se)
1:             {
0:                 assertSQLState( "0A000", se );
1:             }
1:         }
1: 
1:         insert.close();
1:     }
1:     private void    vetTableContents( Connection conn ) throws Exception
1:     {
1:         PreparedStatement   selectPS = conn.prepareStatement( "select * from allTypes order by col0" );
1:         ResultSet               selectRS = selectPS.executeQuery();
1:         int                     rowCount = 0;
1: 
1:         while( selectRS.next() )
1:         {
1:             int     rowIdx = rowCount % ColumnDesc.VALUE_COUNT;
1: 
1:             for ( int colIdx = 0; colIdx < _columnDescs.length; colIdx++ )
1:             {
1:                 Object          expected = _columnDescs[ colIdx ].values[ rowIdx ];
1: 
1:                 // skip the first column, the primary key
1:                 assertObjectEquals( expected, selectRS.getObject( colIdx + 2 ) );
1:             }
1: 
1:             rowCount++;
1:         }
1:         
1:         selectRS.close();
1:         selectPS.close();
1:     }
1: 
1:     //////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     //////////////////////////////////////////////////////////
1: 
1:     private  static  Blob    makeBlob( String contents )
1:     {
1:         return new HarmonySerialBlob( makeBinary( contents ) );
1:     }
1: 
1:     private  static  Clob    makeClob( String contents )
1:     {
1:         return new HarmonySerialClob( contents );
1:     }
1: 
1:     private  static  byte[]    makeBinary( String contents )
1:     {
1:         try {
1:             return contents.getBytes( "UTF-8" );
1:         }
1:         catch (Exception e)
1:         {
1:             e.printStackTrace();
1:             return null;
1:         }
1:     }
1: 
1:     private static  Price   makePrice( long raw )
1:     {
1:         return Price.makePrice( new BigDecimal( raw ) );
1:     }
1: 
0:     private void    assertObjectEquals( Object expected, Object actual ) throws Exception
1:     {
1:         if ( expected == null )
1:         {
1:             assertNull( actual );
1:             return;
1:         }
1:         else if ( actual == null )
1:         {
1:             assertNull( expected );
1:             return;
1:         }
1:         else if ( expected instanceof Blob ) { assertEquals( (Blob) expected, (Blob) actual ); }
1:         else if ( expected instanceof Clob ) { assertEquals( (Clob) expected, (Clob) actual ); }
1:         else if ( expected instanceof byte[] ) { compareBytes( (byte[]) expected, (byte[]) actual ); }
1:         else { assertEquals( expected.toString(), actual.toString() ); }
1:     }
0:     private void  compareBytes( byte[] left, byte[] right )
1:         throws Exception
1:     {
1:         int count = left.length;
1:         
1:         if ( count != right.length )
1:         {
1:             fail("left count = " + count + " but right count = " + right.length );
1:         }
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( left[ i ] != right[ i ] )
1:             {
1:                 fail( "left[ " + i + " ] = " + left[ i ] + " but right[ " + i + " ] = " + right[ i ] );
1:             }
1:         }
1:     }
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("PreparedStatementTest42");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e25c098
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:                 assertSQLState( UNIMPLEMENTED_FEATURE, se );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-6081: Verify that an SQLException is raised if the supplied
1:      * SQLType argument is null. It used to fail with a NullPointerException.
1:      */
0:     public void test_04_targetTypeIsNull() throws SQLException {
1:         setAutoCommit(false);
1: 
1:         // Test PreparedStatement.setObject() with targetType == null.
1: 
1:         PreparedStatement ps = prepareStatement("values cast(? as int)");
1: 
1:         try {
1:             ps.setObject(1, 1, null);
1:             fail("setObject should fail when type is null");
0:         } catch (SQLFeatureNotSupportedException se) {
0:             assertSQLState(UNIMPLEMENTED_FEATURE, se);
0:         }
1: 
1:         try {
1:             ps.setObject(1, 1, null, 1);
1:             fail("setObject should fail when type is null");
0:         } catch (SQLFeatureNotSupportedException se) {
0:             assertSQLState(UNIMPLEMENTED_FEATURE, se);
0:         }
1: 
1:         // Test ResultSet.updateObject() with targetType == null.
1: 
1:         Statement s = createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:         s.execute("create table t(x int)");
1:         s.execute("insert into t values 1");
1: 
1:         ResultSet rs = s.executeQuery("select * from t");
1:         assertTrue(rs.next());
1: 
1:         try {
1:             rs.updateObject("x", 1, null);
1:             fail("updateObject should fail when type is null");
0:         } catch (SQLFeatureNotSupportedException se) {
0:             assertSQLState(UNIMPLEMENTED_FEATURE, se);
0:         }
1: 
1:         try {
1:             rs.updateObject(1, 1, null);
1:             fail("updateObject should fail when type is null");
0:         } catch (SQLFeatureNotSupportedException se) {
0:             assertSQLState(UNIMPLEMENTED_FEATURE, se);
0:         }
1: 
1:         try {
1:             rs.updateObject("x", 1, null, 1);
1:             fail("updateObject should fail when type is null");
0:         } catch (SQLFeatureNotSupportedException se) {
0:             assertSQLState(UNIMPLEMENTED_FEATURE, se);
0:         }
1: 
1:         try {
1:             rs.updateObject(1, 1, null, 1);
1:             fail("updateObject should fail when type is null");
0:         } catch (SQLFeatureNotSupportedException se) {
0:             assertSQLState(UNIMPLEMENTED_FEATURE, se);
0:         }
1: 
1:         // There should be no more rows.
1:         JDBC.assertEmpty(rs);
0:     }
1: 
============================================================================