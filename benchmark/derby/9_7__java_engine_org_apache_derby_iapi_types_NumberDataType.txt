1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.NumberDataType
1:c0a5ce1: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
16:eac0369:  */
1:d7f7457: 
1:eac0369: package org.apache.derby.iapi.types;
21:eac0369: 
1:96748ad: import java.math.BigDecimal;
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:96748ad: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:c0a5ce1: import org.apache.derby.iapi.services.context.ContextService;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:c0a5ce1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:c0a5ce1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: 
1:eac0369: 
1:2c6f0a2: /**
1:eac0369:  * NumberDataType is the superclass for all exact and approximate 
1:eac0369:  * numeric data types. It exists for the purpose of allowing classification
1:eac0369:  * of types for supported implicit conversions among them.
7:eac0369:  *
1:eac0369:  * @see DataType
1:eac0369:  */
1:eac0369: public abstract class NumberDataType extends DataType 
1:eac0369: 									 implements NumberDataValue
13:eac0369: {
1:5465561:     static final BigDecimal MAXLONG_PLUS_ONE =
1:5465561:             BigDecimal.valueOf(Long.MAX_VALUE).add(BigDecimal.ONE);
1:5465561:     static final BigDecimal MINLONG_MINUS_ONE =
1:5465561:             BigDecimal.valueOf(Long.MIN_VALUE).subtract(BigDecimal.ONE);
1:a1970a9: 
1:a1970a9:     /**
1:eac0369:      * Numbers check for isNegative first and negate it if negative.
1:eac0369:      * 
1:eac0369:      * @return this object's absolute value.  Null if object is null.
1:eac0369:      * @exception StandardException thrown on error.
1:a1970a9:      */
1:6d0a34c:     public final NumberDataValue absolute(NumberDataValue result) 
1:eac0369:                         throws StandardException
1:6d0a34c:     {   		
1:eac0369:         if(isNegative())
1:eac0369:             return minus(result);
1:eac0369: 
1:eac0369:         if(result == null)
1:7af858d:             result = (NumberDataValue)getNewNull();
1:6d0a34c:         
1:6d0a34c:         result.setValue(this);
1:eac0369:         return result;
11:eac0369:     }
1:509ccb9: 
1:c0a5ce1:     /**
1:eac0369:      * This is the sqrt method.
1:eac0369:      * 
1:eac0369:      * @return this object's sqrt value.  Null if object is null.
1:eac0369:      * Note: -0.0f and  -0.0d returns 0.0f and 0.0d.
1:eac0369:      *
1:eac0369:      * @exception StandardException thrown on a negative number.
1:a1970a9:      */
1:eac0369: 
1:eac0369:     public NumberDataValue sqrt(NumberDataValue result)
1:eac0369:                         throws StandardException
1:509ccb9:     {
1:eac0369:         if(result == null)
1:509ccb9:         {
1:eac0369:             result = (NumberDataValue)getNewNull();
1:509ccb9:         }
1:eac0369: 
1:eac0369:         if(this.isNull())
1:eac0369:         {
1:eac0369:             result.setToNull();
1:eac0369:             return result;
1:eac0369:         }
1:eac0369: 
1:eac0369:         double doubleValue = getDouble();
1:eac0369: 
1:eac0369:         if( this.isNegative() )
1:eac0369:         {
1:ce40a31:             if( doubleValue == -0.0d )
1:eac0369:             {
1:eac0369:                 doubleValue = 0.0d;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw StandardException.newException( SQLState.LANG_SQRT_OF_NEG_NUMBER, this);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         result.setValue( Math.sqrt(doubleValue) );
1:eac0369:         return result;
1:eac0369:     }
1:2c6f0a2:     
1:a1970a9: 	/**
1:2c6f0a2: 	 * This method implements the + operator for TINYINT,SMALLINT,INT.
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @param addend1	One of the addends
1:2c6f0a2: 	 * @param addend2	The other addend
1:2c6f0a2: 	 * @param result	The result of a previous call to this method, null
1:2c6f0a2: 	 *					if not called yet
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @return	A NumberDataValue containing the result of the addition
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @exception StandardException		Thrown on error
1:a1970a9: 	 */
1:2c6f0a2: 
1:2c6f0a2: 	public NumberDataValue plus(NumberDataValue addend1,
1:2c6f0a2: 							NumberDataValue addend2,
1:2c6f0a2: 							NumberDataValue result)
1:2c6f0a2: 				throws StandardException
1:2c6f0a2: 	{
1:2c6f0a2: 		if (result == null)
1:2c6f0a2: 		{
1:2c6f0a2: 			result = (NumberDataValue) getNewNull();
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		if (addend1.isNull() || addend2.isNull())
1:2c6f0a2: 		{
1:2c6f0a2: 			result.setToNull();
1:2c6f0a2: 			return result;
1:2c6f0a2: 		}
1:2c6f0a2: 		int addend1Int = addend1.getInt();
1:2c6f0a2: 		int addend2Int = addend2.getInt();
1:2c6f0a2: 
1:2c6f0a2: 		int resultValue = addend1Int + addend2Int;
1:2c6f0a2: 
1:2c6f0a2: 		/*
1:2c6f0a2: 		** Java does not check for overflow with integral types. We have to
1:2c6f0a2: 		** check the result ourselves.
1:2c6f0a2: 		**
1:2c6f0a2: 		** Overflow is possible only if the two addends have the same sign.
1:2c6f0a2: 		** Do they?  (This method of checking is approved by "The Java
1:2c6f0a2: 		** Programming Language" by Arnold and Gosling.)
1:2c6f0a2: 		*/
1:2c6f0a2: 		if ((addend1Int < 0) == (addend2Int < 0))
1:2c6f0a2: 		{
1:2c6f0a2: 			/*
1:2c6f0a2: 			** Addends have the same sign.  The result should have the same
1:2c6f0a2: 			** sign as the addends.  If not, an overflow has occurred.
1:2c6f0a2: 			*/
1:2c6f0a2: 			if ((addend1Int < 0) != (resultValue < 0))
1:2c6f0a2: 			{
1:2c6f0a2: 				throw outOfRange();
1:2c6f0a2: 			}
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		result.setValue(resultValue);
1:2c6f0a2: 
1:2c6f0a2: 		return result;
1:2c6f0a2: 	}
1:a1970a9: 	/**
1:2c6f0a2: 	 * This method implements the - operator for TINYINT, SMALLINT and INTEGER.
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @param left	The value to be subtracted from
1:2c6f0a2: 	 * @param right	The value to be subtracted
1:2c6f0a2: 	 * @param result	The result of a previous call to this method, null
1:2c6f0a2: 	 *					if not called yet
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @return	A SQLInteger containing the result of the subtraction
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @exception StandardException		Thrown on error
1:2c6f0a2: 	 */
1:2c6f0a2: 
1:2c6f0a2: 	public NumberDataValue minus(NumberDataValue left,
1:2c6f0a2: 							NumberDataValue right,
1:2c6f0a2: 							NumberDataValue result)
1:2c6f0a2: 				throws StandardException
1:2c6f0a2: 	{
1:2c6f0a2: 		if (result == null)
1:2c6f0a2: 		{
1:2c6f0a2: 			result = (NumberDataValue) getNewNull();
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		if (left.isNull() || right.isNull())
1:2c6f0a2: 		{
1:2c6f0a2: 			result.setToNull();
1:2c6f0a2: 			return result;
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		int diff = left.getInt() - right.getInt();
1:2c6f0a2: 
1:2c6f0a2: 		/*
1:2c6f0a2: 		** Java does not check for overflow with integral types. We have to
1:2c6f0a2: 		** check the result ourselves.
1:2c6f0a2: 		**
1:2c6f0a2: 		** Overflow is possible only if the left and the right side have opposite signs.
1:2c6f0a2: 		** Do they?  (This method of checking is approved by "The Java
1:2c6f0a2: 		** Programming Language" by Arnold and Gosling.)
1:2c6f0a2: 		*/
1:2c6f0a2: 		if ((left.getInt() < 0) != (right.getInt() < 0))
1:2c6f0a2: 		{
1:2c6f0a2: 			/*
1:2c6f0a2: 			** Left and right have opposite signs.  The result should have the same
1:2c6f0a2: 			** sign as the left (this).  If not, an overflow has occurred.
1:2c6f0a2: 			*/
1:2c6f0a2: 			if ((left.getInt() < 0) != (diff < 0))
1:2c6f0a2: 			{
1:2c6f0a2: 				throw outOfRange();
1:2c6f0a2: 			}
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		result.setValue(diff);
1:2c6f0a2: 
1:2c6f0a2: 		return result;
1:2c6f0a2: 	}
1:2c6f0a2: 	
1:2c6f0a2: 	/**
1:2c6f0a2: 	 * This method implements the / operator for TINYINT, SMALLINT and INTEGER.
1:2c6f0a2: 	 * Specialized methods are not required for TINYINT and SMALLINT as the Java
1:2c6f0a2: 	 * virtual machine always executes byte and int division as integer.
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @param dividend	The numerator
1:2c6f0a2: 	 * @param divisor	The denominator
1:2c6f0a2: 	 * @param result	The result of a previous call to this method, null
1:2c6f0a2: 	 *					if not called yet
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @return	A SQLInteger containing the result of the division
1:2c6f0a2: 	 *
1:2c6f0a2: 	 * @exception StandardException		Thrown on error
1:2c6f0a2: 	 */
1:2c6f0a2: 
1:2c6f0a2: 	public NumberDataValue divide(NumberDataValue dividend,
1:2c6f0a2: 							 NumberDataValue divisor,
1:2c6f0a2: 							 NumberDataValue result)
1:2c6f0a2: 				throws StandardException
1:2c6f0a2: 	{
1:2c6f0a2: 		if (result == null)
1:2c6f0a2: 		{
1:2c6f0a2: 			result = (NumberDataValue) getNewNull();
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		if (dividend.isNull() || divisor.isNull())
1:2c6f0a2: 		{
1:2c6f0a2: 			result.setToNull();
1:2c6f0a2: 			return result;
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		/* Catch divide by 0 */
1:2c6f0a2: 		int intDivisor = divisor.getInt();
1:2c6f0a2: 		if (intDivisor == 0)
1:2c6f0a2: 		{
1:2c6f0a2: 			throw StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);
1:2c6f0a2: 		}
1:2c6f0a2: 
1:2c6f0a2: 		result.setValue(dividend.getInt() / intDivisor);
1:2c6f0a2: 		return result;
1:2c6f0a2: 	}
1:eac0369: 
1:2c6f0a2: 	/**
1:2c6f0a2: 	 	Suitable for integral types that ignore scale.
1:2c6f0a2: 	 */
1:eac0369: 	public NumberDataValue divide(NumberDataValue dividend,
1:eac0369: 								  NumberDataValue divisor,
1:eac0369: 								  NumberDataValue result,
1:eac0369: 								  int scale)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:2c6f0a2: 		return divide(dividend, divisor, result);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public NumberDataValue mod(NumberDataValue dividend,
1:eac0369: 								NumberDataValue divisor,
1:eac0369: 								NumberDataValue result)
1:eac0369: 								throws StandardException {
2:eac0369: 		if (SanityManager.DEBUG)
2:eac0369: 			SanityManager.NOTREACHED();
2:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @exception StandardException		Thrown on error */
1:eac0369: 	public final int compare(DataValueDescriptor arg) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:509ccb9: 		 */
1:eac0369: 		if (typePrecedence() < arg.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (arg.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		boolean thisNull, otherNull;
1:eac0369: 
1:eac0369: 		thisNull = this.isNull();
1:eac0369: 		otherNull = arg.isNull();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * thisNull otherNull	return
1:eac0369: 		 *	T		T		 	0	(this == other)
1:eac0369: 		 *	F		T		 	-1 	(this > other)
1:eac0369: 		 *	T		F		 	1	(this < other)
1:509ccb9: 		 */
1:eac0369: 		if (thisNull || otherNull)
1:eac0369: 		{
1:eac0369: 			if (!thisNull)		// otherNull must be true
2:509ccb9: 				return -1;
1:eac0369: 			if (!otherNull)		// thisNull must be true
1:eac0369: 				return 1;
1:eac0369: 			return 0;
1:509ccb9: 		}
1:509ccb9: 
1:eac0369: 		return typeCompare(arg);
1:eac0369: 
1:eac0369: 	}
1:509ccb9: 	/**
1:eac0369: 		Compare this (not null) to a non-null value.
1:eac0369: 	
1:eac0369: 	@exception StandardException		Thrown on error
1:eac0369: 	*/
1:eac0369: 	protected abstract int typeCompare(DataValueDescriptor arg) throws StandardException;
1:eac0369: 
1:509ccb9: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public final boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (this.isNull() || other.isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369:     
13:eac0369: 	/**
1:eac0369:      * The isNegative abstract method.  Checks to see if this.value is negative.
1:eac0369:      * To be implemented by each NumberDataType.
1:eac0369:      *
1:eac0369:      * @return  A boolean.  If this.value is negative, return true.
1:eac0369:      *          For positive values or null, return false.
1:eac0369:      */
1:eac0369:     protected abstract boolean isNegative();
1:9d34086:     
1:9d34086:     /**
1:9d34086:      * Common code to handle converting a short to this value
1:9d34086:      * by using the int to this value conversion.
1:9d34086:      * Simply calls setValue(int).
1:9d34086:      * 
1:9d34086:      */
1:9d34086: 	public void setValue(short theValue)
1:9d34086: 		throws StandardException
1:9d34086: 	{
1:9d34086: 		setValue((int) theValue);
1:9d34086: 	}
1:9d34086: 
1:9d34086:     /**
1:9d34086:      * Common code to handle converting a byte to this value
1:9d34086:      * by using the int to this value conversion.
1:9d34086:      * Simply calls setValue(int).
1:9d34086:      * 
1:9d34086:      */
1:9d34086: 	public void setValue(byte theValue)
1:9d34086: 		throws StandardException
1:9d34086: 	{
1:9d34086: 		setValue((int) theValue);
1:9d34086: 	}		
1:eac0369: 	/**
1:d7f7457: 	   Common code to handle java.lang.Integer as a Number,
1:d7f7457: 	   used for TINYINT, SMALLINT, INTEGER
7:eac0369: 	 * @see NumberDataValue#setValue
1:eac0369: 	 *
1:d7f7457: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:d7f7457: 	public void setValue(Number theValue) throws StandardException
1:eac0369: 	{
1:d7f7457: 		if (objectNull(theValue))
1:d7f7457: 			return;
1:d7f7457: 		
1:d7f7457: 		if (SanityManager.ASSERT)
1:eac0369: 		{
1:d7f7457: 			if (!(theValue instanceof java.lang.Integer))
1:d7f7457: 				SanityManager.THROWASSERT("NumberDataType.setValue(Number) passed a " + theValue.getClass());
1:eac0369: 		}
1:d7f7457: 		
1:d7f7457: 		setValue(theValue.intValue());
1:eac0369: 	}
1:806114c: 	
1:806114c: 	/**
1:806114c: 	 * Set the value from a correctly typed Integer object.
1:806114c: 	 * Used for TINYINT, SMALLINT, INTEGER.
1:806114c: 	 * @throws StandardException 
1:806114c: 	 */
1:806114c: 	void setObject(Object theValue) throws StandardException
1:806114c: 	{
1:806114c: 		setValue(((Integer) theValue).intValue());
1:806114c: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		setValue for integral exact numerics. Converts the BigDecimal
1:eac0369: 		to a long to preserve precision
1:eac0369: 	*/
1:9548d38: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
1:eac0369: 	{
1:d7f7457: 		if (objectNull(bigDecimal))
1:eac0369: 			return;
1:d7f7457: 
1:eac0369: 		// See comment in SQLDecimal.getLong()
1:d7f7457: 
1:9548d38: 		if (   (bigDecimal.compareTo(NumberDataType.MINLONG_MINUS_ONE) == 1)
1:9548d38: 			&& (bigDecimal.compareTo(NumberDataType.MAXLONG_PLUS_ONE) == -1)) {
1:eac0369: 
1:d7f7457: 			setValue(bigDecimal.longValue());
1:eac0369: 		} else {
1:eac0369: 
1:eac0369: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, getTypeName());
1:2c6f0a2: 		}
1:d7f7457: 	}
1:2c6f0a2: 	
1:2c6f0a2: 	/**
1:2c6f0a2: 	 * Implementation for integral types. Convert to a BigDecimal using long
1:2c6f0a2: 	 */
1:2c6f0a2: 	public int typeToBigDecimal()
1:2c6f0a2: 	{
1:2c6f0a2: 		return java.sql.Types.BIGINT;
1:2c6f0a2: 	}
1:eac0369: 
1:eac0369: 	protected final boolean objectNull(Object o) 
1:eac0369: 	{
1:eac0369: 		if (o == null) 
1:eac0369: 		{
1:eac0369: 			restoreToNull();
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:a0dbbd7: 
1:a0dbbd7: 	/**
1:c0a5ce1:       * normalizeREAL normalizes the value, so that negative zero (-0.0) becomes
1:c0a5ce1:       * positive.
1:c0a5ce1:       * @throws StandardException if the value is not a number (NaN) or is
1:c0a5ce1:       * infinite.
1:c0a5ce1:       */
1:eac0369:     public static float normalizeREAL(float v) throws StandardException
1:eac0369: 	{
1:c0a5ce1:         boolean invalid = Float.isNaN(v) || Float.isInfinite(v);
1:c0a5ce1: 
1:c0a5ce1:         if (v < Limits.DB2_SMALLEST_REAL ||
1:c0a5ce1:             v > Limits.DB2_LARGEST_REAL ||
1:c0a5ce1:             (v > 0 && v < Limits.DB2_SMALLEST_POSITIVE_REAL) ||
1:c0a5ce1:             (v < 0 && v > Limits.DB2_LARGEST_NEGATIVE_REAL)) {
1:c0a5ce1: 
1:c0a5ce1:             if (useDB2Limits()) {
1:c0a5ce1:                 invalid = true;
1:c0a5ce1:             }
1:eac0369:         }
1:c0a5ce1: 
1:c0a5ce1:         if (invalid) {
1:c0a5ce1:             throw StandardException.newException(
1:c0a5ce1:                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
1:c0a5ce1:         }
1:c0a5ce1: 
1:eac0369:         // Normalize negative floats to be "positive" (can't detect easily without using Float object because -0.0f = 0.0f)
1:ad0c80a:         // DERBY-2447: It shouldn't matter whether we compare to 0.0f or -0.0f,
1:ad0c80a:         // both should match negative zero, but comparing to 0.0f triggered
1:ad0c80a:         // this JVM bug: http://bugs.sun.com/view_bug.do?bug_id=6833879
1:ad0c80a:         if (v == -0.0f) v = 0.0f;
1:eac0369: 
1:eac0369:         return v;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c0a5ce1:      * normalizeREAL normalizes the value, so that negative zero (-0.0)
1:c0a5ce1:      * becomes positive.
1:c0a5ce1:      * <p>
1:c0a5ce1:      * The reason for having normalizeREAL with two signatures is to
1:c0a5ce1:      * avoid that normalizeREAL is accidentally called with a casted
1:c0a5ce1:      * {@code (float)<double value>} since this can introduce an undetected
1:c0a5ce1:      * underflow values to 0.0f.
1:c0a5ce1:      * @throws StandardException if the value is not a number (NaN) or is
1:c0a5ce1:      * infinite or on underflow
1:c0a5ce1:      * (the value has magnitude too small to be represented as a float).
1:c0a5ce1:      */
1:c0a5ce1:     public static float normalizeREAL(final double v) throws StandardException
1:eac0369:     {
1:c0a5ce1:         // Can't just cast it to float and call normalizeFloat(float) since
1:c0a5ce1:         // casting can round down to 0.0
1:c0a5ce1:         float fv = (float)v;
1:c0a5ce1: 
1:c0a5ce1:         boolean invalid =
1:c0a5ce1:             Double.isNaN(v) ||
1:c0a5ce1:             Double.isInfinite(v) ||
1:c0a5ce1:             (fv == 0.0f && v != 0.0d); // too small to represent as REAL
1:c0a5ce1: 
1:c0a5ce1:         if (v < Limits.DB2_SMALLEST_REAL ||
1:c0a5ce1:             v > Limits.DB2_LARGEST_REAL ||
1:c0a5ce1:             (v > 0 && v < Limits.DB2_SMALLEST_POSITIVE_REAL) ||
1:c0a5ce1:             (v < 0 && v > Limits.DB2_LARGEST_NEGATIVE_REAL)) {
1:c0a5ce1: 
1:c0a5ce1:             if (useDB2Limits()) {
1:c0a5ce1:                 invalid = true;
1:c0a5ce1:             }
1:c0a5ce1:         }
1:c0a5ce1: 
1:c0a5ce1:         if (invalid) {
1:c0a5ce1:             throw StandardException.newException(
1:c0a5ce1:                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
1:eac0369:         }
1:c0a5ce1: 
1:eac0369:         // Normalize negative floats to be "positive" (can't detect easily without using Float object because -0.0f = 0.0f)
1:ad0c80a:         // DERBY-2447: It shouldn't matter whether we compare to 0.0d or -0.0d,
1:ad0c80a:         // both should match negative zero, but comparing to 0.0d triggered
1:ad0c80a:         // this JVM bug: http://bugs.sun.com/view_bug.do?bug_id=6833879
1:c0a5ce1:         if (fv == -0.0f) {
1:c0a5ce1:             fv = 0.0f;
1:c0a5ce1:         }
1:eac0369: 
1:c0a5ce1:         return fv;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:c0a5ce1:      * normalizeDOUBLE normalizes the value, so that negative zero (-0.0)
1:c0a5ce1:      * becomes positive.
1:c0a5ce1:      * @throws StandardException if v is not a number (NaN) or is infinite.
1:c0a5ce1:      */
1:eac0369:     public static double normalizeDOUBLE(double v) throws StandardException
1:eac0369: 	{
1:c0a5ce1:         boolean invalid = Double.isNaN(v) || Double.isInfinite(v);
1:c0a5ce1: 
1:c0a5ce1:         if (v < Limits.DB2_SMALLEST_DOUBLE ||
1:c0a5ce1:             v > Limits.DB2_LARGEST_DOUBLE ||
1:c0a5ce1:             (v > 0 && v < Limits.DB2_SMALLEST_POSITIVE_DOUBLE) ||
1:c0a5ce1:             (v < 0 && v > Limits.DB2_LARGEST_NEGATIVE_DOUBLE)) {
1:c0a5ce1: 
1:c0a5ce1:             if (useDB2Limits()) {
1:c0a5ce1:                 invalid = true;
1:c0a5ce1:             }
1:c0a5ce1:         }
1:c0a5ce1: 
1:c0a5ce1:         if (invalid) {
1:c0a5ce1:             throw StandardException.newException(
1:c0a5ce1:                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);
1:eac0369:         }
1:eac0369:         // Normalize negative doubles to be "positive" (can't detect easily without using Double object because -0.0f = 0.0f)
1:ad0c80a:         // DERBY-2447: It shouldn't matter whether we compare to 0.0d or -0.0d,
1:ad0c80a:         // both should match negative zero, but comparing to 0.0d triggered
1:ad0c80a:         // this JVM bug: http://bugs.sun.com/view_bug.do?bug_id=6833879
1:ad0c80a:         if (v == -0.0d) v = 0.0d;
1:eac0369: 
1:eac0369:         return v;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:    /**
1:c0a5ce1:      * Controls use of old DB2 limits (DERBY-3398).
1:80e4af5:      * @return false if dictionary is new enough, see DD_Version.
1:c0a5ce1:      */
1:c0a5ce1:      private static boolean useDB2Limits() throws StandardException {
1:c0a5ce1:          LanguageConnectionContext lcc =
1:a0dbbd7:              (LanguageConnectionContext)getContextOrNull(
1:c0a5ce1:                  LanguageConnectionContext.CONTEXT_ID);
1:c0a5ce1:          if (lcc != null) {
1:c0a5ce1:              return !lcc.getDataDictionary().checkVersion(
1:c0a5ce1:                      DataDictionary.DD_VERSION_DERBY_10_10, null);
1:c0a5ce1:          } else {
1:c0a5ce1:              // In PreparedStatement#setXXX and ResultSet#updateXXX contexts we
1:c0a5ce1:              // do not have LanguageConnectionContext so check is deferred to
1:c0a5ce1:              // the PreparedStatement execute time or ResultSet#updateRow time
1:c0a5ce1:              // as the case may be.
1:c0a5ce1:              return false;
1:c0a5ce1:          }
1:c0a5ce1:     }
1:eac0369:     
1:eac0369:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContextOrNull( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContextOrNull( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContextOrNull( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:             if( doubleValue == -0.0d )
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1:              (LanguageConnectionContext)getContextOrNull(
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContextOrNull( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContextOrNull( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContextOrNull( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:073b862
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
0: 		Comparable  bdc = (Comparable) bigDecimal;
commit:96748ad
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: 
/////////////////////////////////////////////////////////////////////////
0: 	static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 	static final BigDecimal ONE = BigDecimal.valueOf(1L);
0: 	static final BigDecimal MAXLONG_PLUS_ONE = BigDecimal.valueOf(Long.MAX_VALUE).add(ONE);
0: 	static final BigDecimal MINLONG_MINUS_ONE = BigDecimal.valueOf(Long.MIN_VALUE).subtract(ONE);
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
1:     static final BigDecimal MAXLONG_PLUS_ONE =
1:             BigDecimal.valueOf(Long.MAX_VALUE).add(BigDecimal.ONE);
1:     static final BigDecimal MINLONG_MINUS_ONE =
1:             BigDecimal.valueOf(Long.MIN_VALUE).subtract(BigDecimal.ONE);
/////////////////////////////////////////////////////////////////////////
commit:9548d38
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
1: 		if (   (bigDecimal.compareTo(NumberDataType.MINLONG_MINUS_ONE) == 1)
1: 			&& (bigDecimal.compareTo(NumberDataType.MAXLONG_PLUS_ONE) == -1)) {
commit:7af858d
/////////////////////////////////////////////////////////////////////////
1:             result = (NumberDataValue)getNewNull();
commit:ad0c80a
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-2447: It shouldn't matter whether we compare to 0.0f or -0.0f,
1:         // both should match negative zero, but comparing to 0.0f triggered
1:         // this JVM bug: http://bugs.sun.com/view_bug.do?bug_id=6833879
1:         if (v == -0.0f) v = 0.0f;
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-2447: It shouldn't matter whether we compare to 0.0d or -0.0d,
1:         // both should match negative zero, but comparing to 0.0d triggered
1:         // this JVM bug: http://bugs.sun.com/view_bug.do?bug_id=6833879
1:         if (v == -0.0d) v = 0.0d;
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-2447: It shouldn't matter whether we compare to 0.0d or -0.0d,
1:         // both should match negative zero, but comparing to 0.0d triggered
1:         // this JVM bug: http://bugs.sun.com/view_bug.do?bug_id=6833879
0:         if (v == -0.0d) v = 0.0d;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:80e4af5
/////////////////////////////////////////////////////////////////////////
1:      * @return false if dictionary is new enough, see DD_Version.
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:c0a5ce1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:       * normalizeREAL normalizes the value, so that negative zero (-0.0) becomes
1:       * positive.
1:       * @throws StandardException if the value is not a number (NaN) or is
1:       * infinite.
1:       */
1:         boolean invalid = Float.isNaN(v) || Float.isInfinite(v);
1: 
1:         if (v < Limits.DB2_SMALLEST_REAL ||
1:             v > Limits.DB2_LARGEST_REAL ||
1:             (v > 0 && v < Limits.DB2_SMALLEST_POSITIVE_REAL) ||
1:             (v < 0 && v > Limits.DB2_LARGEST_NEGATIVE_REAL)) {
1: 
1:             if (useDB2Limits()) {
1:                 invalid = true;
1:             }
1: 
1:         if (invalid) {
1:             throw StandardException.newException(
1:                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * normalizeREAL normalizes the value, so that negative zero (-0.0)
1:      * becomes positive.
1:      * <p>
1:      * The reason for having normalizeREAL with two signatures is to
1:      * avoid that normalizeREAL is accidentally called with a casted
1:      * {@code (float)<double value>} since this can introduce an undetected
1:      * underflow values to 0.0f.
1:      * @throws StandardException if the value is not a number (NaN) or is
1:      * infinite or on underflow
1:      * (the value has magnitude too small to be represented as a float).
1:      */
1:     public static float normalizeREAL(final double v) throws StandardException
1:         // Can't just cast it to float and call normalizeFloat(float) since
1:         // casting can round down to 0.0
1:         float fv = (float)v;
1: 
1:         boolean invalid =
1:             Double.isNaN(v) ||
1:             Double.isInfinite(v) ||
1:             (fv == 0.0f && v != 0.0d); // too small to represent as REAL
1: 
1:         if (v < Limits.DB2_SMALLEST_REAL ||
1:             v > Limits.DB2_LARGEST_REAL ||
1:             (v > 0 && v < Limits.DB2_SMALLEST_POSITIVE_REAL) ||
1:             (v < 0 && v > Limits.DB2_LARGEST_NEGATIVE_REAL)) {
1: 
1:             if (useDB2Limits()) {
1:                 invalid = true;
1:             }
1: 
1:         if (invalid) {
1:             throw StandardException.newException(
1:                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
1:         }
1: 
1:         if (fv == -0.0f) {
1:             fv = 0.0f;
1:         }
1:         return fv;
1:      * normalizeDOUBLE normalizes the value, so that negative zero (-0.0)
1:      * becomes positive.
1:      * @throws StandardException if v is not a number (NaN) or is infinite.
1:      */
1:         boolean invalid = Double.isNaN(v) || Double.isInfinite(v);
1: 
1:         if (v < Limits.DB2_SMALLEST_DOUBLE ||
1:             v > Limits.DB2_LARGEST_DOUBLE ||
1:             (v > 0 && v < Limits.DB2_SMALLEST_POSITIVE_DOUBLE) ||
1:             (v < 0 && v > Limits.DB2_LARGEST_NEGATIVE_DOUBLE)) {
1: 
1:             if (useDB2Limits()) {
1:                 invalid = true;
1:             }
1:         }
1: 
1:         if (invalid) {
1:             throw StandardException.newException(
1:                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * Controls use of old DB2 limits (DERBY-3398).
0:      * @returns false if dictionary is new enough, see DD_Version.
1:      */
1:      private static boolean useDB2Limits() throws StandardException {
1:          LanguageConnectionContext lcc =
0:              (LanguageConnectionContext)ContextService.getContextOrNull(
1:                  LanguageConnectionContext.CONTEXT_ID);
1:          if (lcc != null) {
1:              return !lcc.getDataDictionary().checkVersion(
1:                      DataDictionary.DD_VERSION_DERBY_10_10, null);
1:          } else {
1:              // In PreparedStatement#setXXX and ResultSet#updateXXX contexts we
1:              // do not have LanguageConnectionContext so check is deferred to
1:              // the PreparedStatement execute time or ResultSet#updateRow time
1:              // as the case may be.
1:              return false;
1:          }
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Set the value from a correctly typed Integer object.
1: 	 * Used for TINYINT, SMALLINT, INTEGER.
1: 	 * @throws StandardException 
1: 	 */
1: 	void setObject(Object theValue) throws StandardException
1: 	{
1: 		setValue(((Integer) theValue).intValue());
1: 	}
commit:6d0a34c
/////////////////////////////////////////////////////////////////////////
1:     public final NumberDataValue absolute(NumberDataValue result) 
1:     {   		
1:         
1:         result.setValue(this);
commit:9d34086
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Common code to handle converting a short to this value
1:      * by using the int to this value conversion.
1:      * Simply calls setValue(int).
1:      * 
1:      */
1: 	public void setValue(short theValue)
1: 		throws StandardException
1: 	{
1: 		setValue((int) theValue);
1: 	}
1: 
1:     /**
1:      * Common code to handle converting a byte to this value
1:      * by using the int to this value conversion.
1:      * Simply calls setValue(int).
1:      * 
1:      */
1: 	public void setValue(byte theValue)
1: 		throws StandardException
1: 	{
1: 		setValue((int) theValue);
1: 	}		
commit:a1970a9
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Set by the booting DataValueFactory implementation.
1: 	 */
0: 	static DataValueDescriptor ZERO_DECIMAL;
1: 	
1: 	/**
0: 	 * Set by the booting DataValueFactory implementation.
1: 	 */
0: 	static Comparable MINLONG_MINUS_ONE;
1: 	/**
0: 	 * Set by the booting DataValueFactory implementation.
1: 	 */
0: 	static Comparable MAXLONG_PLUS_ONE;
/////////////////////////////////////////////////////////////////////////
0: 		if (   (bdc.compareTo(NumberDataType.MINLONG_MINUS_ONE) == 1)
0: 			&& (bdc.compareTo(NumberDataType.MAXLONG_PLUS_ONE) == -1)) {
commit:2c6f0a2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * This method implements the + operator for TINYINT,SMALLINT,INT.
1: 	 *
1: 	 * @param addend1	One of the addends
1: 	 * @param addend2	The other addend
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A NumberDataValue containing the result of the addition
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue plus(NumberDataValue addend1,
1: 							NumberDataValue addend2,
1: 							NumberDataValue result)
1: 				throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = (NumberDataValue) getNewNull();
1: 		}
1: 
1: 		if (addend1.isNull() || addend2.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 		int addend1Int = addend1.getInt();
1: 		int addend2Int = addend2.getInt();
1: 
1: 		int resultValue = addend1Int + addend2Int;
1: 
1: 		/*
1: 		** Java does not check for overflow with integral types. We have to
1: 		** check the result ourselves.
1: 		**
1: 		** Overflow is possible only if the two addends have the same sign.
1: 		** Do they?  (This method of checking is approved by "The Java
1: 		** Programming Language" by Arnold and Gosling.)
1: 		*/
1: 		if ((addend1Int < 0) == (addend2Int < 0))
1: 		{
1: 			/*
1: 			** Addends have the same sign.  The result should have the same
1: 			** sign as the addends.  If not, an overflow has occurred.
1: 			*/
1: 			if ((addend1Int < 0) != (resultValue < 0))
1: 			{
1: 				throw outOfRange();
1: 			}
1: 		}
1: 
1: 		result.setValue(resultValue);
1: 
1: 		return result;
1: 	}
1: 	/**
1: 	 * This method implements the - operator for TINYINT, SMALLINT and INTEGER.
1: 	 *
1: 	 * @param left	The value to be subtracted from
1: 	 * @param right	The value to be subtracted
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLInteger containing the result of the subtraction
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue minus(NumberDataValue left,
1: 							NumberDataValue right,
1: 							NumberDataValue result)
1: 				throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = (NumberDataValue) getNewNull();
1: 		}
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
1: 		int diff = left.getInt() - right.getInt();
1: 
1: 		/*
1: 		** Java does not check for overflow with integral types. We have to
1: 		** check the result ourselves.
1: 		**
1: 		** Overflow is possible only if the left and the right side have opposite signs.
1: 		** Do they?  (This method of checking is approved by "The Java
1: 		** Programming Language" by Arnold and Gosling.)
1: 		*/
1: 		if ((left.getInt() < 0) != (right.getInt() < 0))
1: 		{
1: 			/*
1: 			** Left and right have opposite signs.  The result should have the same
1: 			** sign as the left (this).  If not, an overflow has occurred.
1: 			*/
1: 			if ((left.getInt() < 0) != (diff < 0))
1: 			{
1: 				throw outOfRange();
1: 			}
1: 		}
1: 
1: 		result.setValue(diff);
1: 
1: 		return result;
1: 	}
1: 	
1: 	/**
1: 	 * This method implements the / operator for TINYINT, SMALLINT and INTEGER.
1: 	 * Specialized methods are not required for TINYINT and SMALLINT as the Java
1: 	 * virtual machine always executes byte and int division as integer.
1: 	 *
1: 	 * @param dividend	The numerator
1: 	 * @param divisor	The denominator
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLInteger containing the result of the division
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue divide(NumberDataValue dividend,
1: 							 NumberDataValue divisor,
1: 							 NumberDataValue result)
1: 				throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = (NumberDataValue) getNewNull();
1: 		}
1: 
1: 		if (dividend.isNull() || divisor.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
1: 		/* Catch divide by 0 */
1: 		int intDivisor = divisor.getInt();
1: 		if (intDivisor == 0)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);
1: 		}
1: 
1: 		result.setValue(dividend.getInt() / intDivisor);
1: 		return result;
1: 	}
1: 	 	Suitable for integral types that ignore scale.
/////////////////////////////////////////////////////////////////////////
1: 		return divide(dividend, divisor, result);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	}
1: 	
1: 	/**
1: 	 * Implementation for integral types. Convert to a BigDecimal using long
1: 	 */
1: 	public int typeToBigDecimal()
1: 	{
1: 		return java.sql.Types.BIGINT;
1: 	}
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
1: 		
1: 	   Common code to handle java.lang.Integer as a Number,
1: 	   used for TINYINT, SMALLINT, INTEGER
1: 	 * @exception StandardException		Thrown on error
1: 	public void setValue(Number theValue) throws StandardException
1: 		if (objectNull(theValue))
1: 			return;
1: 		
1: 		if (SanityManager.ASSERT)
1: 			if (!(theValue instanceof java.lang.Integer))
1: 				SanityManager.THROWASSERT("NumberDataType.setValue(Number) passed a " + theValue.getClass());
1: 		
1: 		setValue(theValue.intValue());
0: 	public void setBigDecimal(Number bigDecimal) throws StandardException
1: 		if (objectNull(bigDecimal))
0: 		Comparable bdc = (Comparable) bigDecimal;
1: 
1: 
0: 		if (   (bdc.compareTo(SQLDecimal.MINLONG_MINUS_ONE) == 1)
0: 			&& (bdc.compareTo(SQLDecimal.MAXLONG_PLUS_ONE) == -1)) {
1: 			setValue(bigDecimal.longValue());
1: 	}	
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 		Return the precision of this specific DECIMAL value.
0: 		If the value does not represent a SQL DECIMAL then
0: 		the return is undefined.
1: 	*/
0: 	public int getDecimalValuePrecision()
1: 	{
1: 		return -1;
1: 	}
1: 
1: 	/**
0: 		Return the scale of this specific DECIMAL value.
0: 		If the value does not represent a SQL DECIMAL then
0: 		the return is undefined.
1: 	*/
0: 	public int getDecimalValueScale()
1:  	{
1: 		return -1;
1: 	}
1:    
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.NumberDataType
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: import org.apache.derby.iapi.types.*;
0: import java.math.BigDecimal;
1: 
1: /**
1:  * NumberDataType is the superclass for all exact and approximate 
1:  * numeric data types. It exists for the purpose of allowing classification
1:  * of types for supported implicit conversions among them.
1:  *
1:  * @see DataType
0:  * @author ames
1:  */
1: public abstract class NumberDataType extends DataType 
1: 									 implements NumberDataValue
1: {
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1: 
1:     /**
1:      * Numbers check for isNegative first and negate it if negative.
1:      * 
1:      * @return this object's absolute value.  Null if object is null.
1:      * @exception StandardException thrown on error.
1:      */
0:     public NumberDataValue absolute(NumberDataValue result) 
1:                         throws StandardException
1:     {
1:         if(isNegative())
1:             return minus(result);
1: 
1:         if(result == null)
0:             result = (NumberDataType)getNewNull();
1: 
0:         result.setValue(this.getObject());
1:         return result;
1:     }
1: 
1:     /**
1:      * This is the sqrt method.
1:      * 
1:      * @return this object's sqrt value.  Null if object is null.
1:      * Note: -0.0f and  -0.0d returns 0.0f and 0.0d.
1:      *
1:      * @exception StandardException thrown on a negative number.
1:      */
1: 
1:     public NumberDataValue sqrt(NumberDataValue result)
1:                         throws StandardException
1:     {
1:         if(result == null)
1:         {
1:             result = (NumberDataValue)getNewNull();
1:         }
1: 
1:         if(this.isNull())
1:         {
1:             result.setToNull();
1:             return result;
1:         }
1: 
1:         double doubleValue = getDouble();
1: 
1:         if( this.isNegative() )
1:         {
0:             if( (new Double(doubleValue)).equals(new Double(-0.0d)) )
1:             {
1:                 doubleValue = 0.0d;
1:             }
1:             else
1:             {
1:                 throw StandardException.newException( SQLState.LANG_SQRT_OF_NEG_NUMBER, this);
1:             }
1:         }
1: 
1:         result.setValue( Math.sqrt(doubleValue) );
1:         return result;
1:     }
1: 
1: 	/**
0: 	 * This is dummy parent divide method.  Put it here for all the children
0: 	 * that don't need this.  @see NumberDataValue#divide
1: 	 */
1: 	public NumberDataValue divide(NumberDataValue dividend,
1: 								  NumberDataValue divisor,
1: 								  NumberDataValue result,
1: 								  int scale)
1: 				throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.NOTREACHED();
1: 		return null;
1: 	}
1: 
1: 	public NumberDataValue mod(NumberDataValue dividend,
1: 								NumberDataValue divisor,
1: 								NumberDataValue result)
1: 								throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.NOTREACHED();
1: 		return null;
1: 	}
1: 
1: 
1: 	/** @exception StandardException		Thrown on error */
1: 	public final int compare(DataValueDescriptor arg) throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < arg.typePrecedence())
1: 		{
1: 			return - (arg.compare(this));
1: 		}
1: 
1: 
1: 		boolean thisNull, otherNull;
1: 
1: 		thisNull = this.isNull();
1: 		otherNull = arg.isNull();
1: 
1: 		/*
1: 		 * thisNull otherNull	return
1: 		 *	T		T		 	0	(this == other)
1: 		 *	F		T		 	-1 	(this > other)
1: 		 *	T		F		 	1	(this < other)
1: 		 */
1: 		if (thisNull || otherNull)
1: 		{
1: 			if (!thisNull)		// otherNull must be true
0: 				return -1;
1: 			if (!otherNull)		// thisNull must be true
1: 				return 1;
1: 			return 0;
1: 		}
1: 
1: 		return typeCompare(arg);
1: 
1: 	}
1: 	/**
1: 		Compare this (not null) to a non-null value.
1: 	
1: 	@exception StandardException		Thrown on error
1: 	*/
1: 	protected abstract int typeCompare(DataValueDescriptor arg) throws StandardException;
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public final boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (this.isNull() || other.isNull())
1: 				return unknownRV;
1: 		}
1: 
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1:     
1: 	/**
1:      * The isNegative abstract method.  Checks to see if this.value is negative.
1:      * To be implemented by each NumberDataType.
1:      *
1:      * @return  A boolean.  If this.value is negative, return true.
1:      *          For positive values or null, return false.
1:      */
1:     protected abstract boolean isNegative();
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
0: 	public final void setValue(Byte theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
1: 		{
0: 			setValue(theValue.byteValue());
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public final void setValue(Short theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.shortValue());
1: 	}
1: 	
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public final void setValue(Integer theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.intValue());
1: 	}
1: 	
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public final void setValue(Long theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.longValue());
1: 	}
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public final void setValue(Double theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.doubleValue());
1: 	}
1: 
1: 	/**
1: 		setValue for integral exact numerics. Converts the BigDecimal
1: 		to a long to preserve precision
1: 	*/
0: 	public  void setValue(BigDecimal theValue) throws StandardException
1: 	{
0: 		if (objectNull(theValue))
1: 			return;
1: 
1: 		// See comment in SQLDecimal.getLong()
1: 
0: 		if (   (theValue.compareTo(SQLDecimal.MINLONG_MINUS_ONE) == 1)
0: 			&& (theValue.compareTo(SQLDecimal.MAXLONG_PLUS_ONE) == -1)) {
1: 
0: 			setValue(theValue.longValue());
1: 		} else {
1: 
1: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, getTypeName());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public final void setValue(Float theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.floatValue());
1: 	}
1: 	
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
0: 	public final void setValue(Boolean theValue) throws StandardException
1: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.booleanValue());
1: 	}
1: 
1:     
1: 	protected final boolean objectNull(Object o) 
1: 	{
1: 		if (o == null) 
1: 		{
1: 			restoreToNull();
1: 			return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
0:        normalizeREAL checks the validity of the given java float that
0:        it fits within the range of DB2 REALs. In addition it
0:        normalizes the value, so that negative zero (-0.0) becomes positive.
1: 	*/
1:     public static float normalizeREAL(float v) throws StandardException
1: 	{
0:         if ( (Float.isNaN(v) || Float.isInfinite(v)) ||
0:              ((v < DB2Limit.DB2_SMALLEST_REAL) || (v > DB2Limit.DB2_LARGEST_REAL)) ||
0:              ((v > 0) && (v < DB2Limit.DB2_SMALLEST_POSITIVE_REAL)) ||
0:              ((v < 0) && (v > DB2Limit.DB2_LARGEST_NEGATIVE_REAL)) )
1:         {
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
1:         }
1:         // Normalize negative floats to be "positive" (can't detect easily without using Float object because -0.0f = 0.0f)
0:         if (v == 0.0f) v = 0.0f;
1: 
1:         return v;
1: 	}
1: 
1: 	/**
0:        normalizeREAL checks the validity of the given java double that
0:        it fits within the range of DB2 REALs. In addition it
0:        normalizes the value, so that negative zero (-0.0) becomes positive.
1: 
0:        The reason for having normalizeREAL with two signatures is to
0:        avoid that normalizeREAL is called with a casted (float)doublevalue,
0:        since this invokes an unwanted rounding (of underflow values to 0.0),
0:        in contradiction to DB2s casting semantics.
1: 	*/
0:     public static float normalizeREAL(double v) throws StandardException
1:     {
0:         // can't just cast it to float and call normalizeFloat(float) since casting can round down to 0.0
0:         if ( (Double.isNaN(v) || Double.isInfinite(v)) ||
0:              ((v < DB2Limit.DB2_SMALLEST_REAL) || (v > DB2Limit.DB2_LARGEST_REAL)) ||
0:              ((v > 0) && (v < DB2Limit.DB2_SMALLEST_POSITIVE_REAL)) ||
0:              ((v < 0) && (v > DB2Limit.DB2_LARGEST_NEGATIVE_REAL)) )
1:         {
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
1:         }
1:         // Normalize negative floats to be "positive" (can't detect easily without using Float object because -0.0f = 0.0f)
0:         if (v == 0.0d) v = 0.0d;
1: 
0:         return (float)v;
1:     }
1: 
1: 	/**
0:        normalizeDOUBLE checks the validity of the given java double that
0:        it fits within the range of DB2 DOUBLEs. In addition it
0:        normalizes the value, so that negative zero (-0.0) becomes positive.
1: 	*/
1:     public static double normalizeDOUBLE(double v) throws StandardException
1: 	{
0:         if ( (Double.isNaN(v) || Double.isInfinite(v)) ||
0:              ((v < DB2Limit.DB2_SMALLEST_DOUBLE) || (v > DB2Limit.DB2_LARGEST_DOUBLE)) ||
0:              ((v > 0) && (v < DB2Limit.DB2_SMALLEST_POSITIVE_DOUBLE)) ||
0:              ((v < 0) && (v > DB2Limit.DB2_LARGEST_NEGATIVE_DOUBLE)) )
1:         {
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);
1:         }
1:         // Normalize negative doubles to be "positive" (can't detect easily without using Double object because -0.0f = 0.0f)
0:         if (v == 0.0d) v = 0.0d;
1: 
1:         return v;
1: 	}
1: 
1: 
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0:              ((v < Limits.DB2_SMALLEST_REAL) || (v > Limits.DB2_LARGEST_REAL)) ||
0:              ((v > 0) && (v < Limits.DB2_SMALLEST_POSITIVE_REAL)) ||
0:              ((v < 0) && (v > Limits.DB2_LARGEST_NEGATIVE_REAL)) )
/////////////////////////////////////////////////////////////////////////
0:              ((v < Limits.DB2_SMALLEST_REAL) || (v > Limits.DB2_LARGEST_REAL)) ||
0:              ((v > 0) && (v < Limits.DB2_SMALLEST_POSITIVE_REAL)) ||
0:              ((v < 0) && (v > Limits.DB2_LARGEST_NEGATIVE_REAL)) )
/////////////////////////////////////////////////////////////////////////
0:              ((v < Limits.DB2_SMALLEST_DOUBLE) || (v > Limits.DB2_LARGEST_DOUBLE)) ||
0:              ((v > 0) && (v < Limits.DB2_SMALLEST_POSITIVE_DOUBLE)) ||
0:              ((v < 0) && (v > Limits.DB2_LARGEST_NEGATIVE_DOUBLE)) )
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.types.*;
0: import java.math.BigDecimal;
0: 
0: /**
0:  * NumberDataType is the superclass for all exact and approximate 
0:  * numeric data types. It exists for the purpose of allowing classification
0:  * of types for supported implicit conversions among them.
0:  *
0:  * @see DataType
0:  * @author ames
0:  */
0: public abstract class NumberDataType extends DataType 
0: 									 implements NumberDataValue
0: {
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 
0:     /**
0:      * Numbers check for isNegative first and negate it if negative.
0:      * 
0:      * @return this object's absolute value.  Null if object is null.
0:      * @exception StandardException thrown on error.
0:      */
0:     public NumberDataValue absolute(NumberDataValue result) 
0:                         throws StandardException
0:     {
0:         if(isNegative())
0:             return minus(result);
0: 
0:         if(result == null)
0:             result = (NumberDataType)getNewNull();
0: 
0:         result.setValue(this.getObject());
0:         return result;
0:     }
0: 
0:     /**
0:      * This is the sqrt method.
0:      * 
0:      * @return this object's sqrt value.  Null if object is null.
0:      * Note: -0.0f and  -0.0d returns 0.0f and 0.0d.
0:      *
0:      * @exception StandardException thrown on a negative number.
0:      */
0: 
0:     public NumberDataValue sqrt(NumberDataValue result)
0:                         throws StandardException
0:     {
0:         if(result == null)
0:         {
0:             result = (NumberDataValue)getNewNull();
0:         }
0: 
0:         if(this.isNull())
0:         {
0:             result.setToNull();
0:             return result;
0:         }
0: 
0:         double doubleValue = getDouble();
0: 
0:         if( this.isNegative() )
0:         {
0:             if( (new Double(doubleValue)).equals(new Double(-0.0d)) )
0:             {
0:                 doubleValue = 0.0d;
0:             }
0:             else
0:             {
0:                 throw StandardException.newException( SQLState.LANG_SQRT_OF_NEG_NUMBER, this);
0:             }
0:         }
0: 
0:         result.setValue( Math.sqrt(doubleValue) );
0:         return result;
0:     }
0: 
0: 	/**
0: 	 * This is dummy parent divide method.  Put it here for all the children
0: 	 * that don't need this.  @see NumberDataValue#divide
0: 	 */
0: 	public NumberDataValue divide(NumberDataValue dividend,
0: 								  NumberDataValue divisor,
0: 								  NumberDataValue result,
0: 								  int scale)
0: 				throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.NOTREACHED();
0: 		return null;
0: 	}
0: 
0: 	public NumberDataValue mod(NumberDataValue dividend,
0: 								NumberDataValue divisor,
0: 								NumberDataValue result)
0: 								throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.NOTREACHED();
0: 		return null;
0: 	}
0: 
0: 
0: 	/** @exception StandardException		Thrown on error */
0: 	public final int compare(DataValueDescriptor arg) throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < arg.typePrecedence())
0: 		{
0: 			return - (arg.compare(this));
0: 		}
0: 
0: 
0: 		boolean thisNull, otherNull;
0: 
0: 		thisNull = this.isNull();
0: 		otherNull = arg.isNull();
0: 
0: 		/*
0: 		 * thisNull otherNull	return
0: 		 *	T		T		 	0	(this == other)
0: 		 *	F		T		 	-1 	(this > other)
0: 		 *	T		F		 	1	(this < other)
0: 		 */
0: 		if (thisNull || otherNull)
0: 		{
0: 			if (!thisNull)		// otherNull must be true
0: 				return -1;
0: 			if (!otherNull)		// thisNull must be true
0: 				return 1;
0: 			return 0;
0: 		}
0: 
0: 		return typeCompare(arg);
0: 
0: 	}
0: 	/**
0: 		Compare this (not null) to a non-null value.
0: 	
0: 	@exception StandardException		Thrown on error
0: 	*/
0: 	protected abstract int typeCompare(DataValueDescriptor arg) throws StandardException;
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public final boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (this.isNull() || other.isNull())
0: 				return unknownRV;
0: 		}
0: 
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0:     
0: 	/**
0:      * The isNegative abstract method.  Checks to see if this.value is negative.
0:      * To be implemented by each NumberDataType.
0:      *
0:      * @return  A boolean.  If this.value is negative, return true.
0:      *          For positive values or null, return false.
0:      */
0:     protected abstract boolean isNegative();
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public final void setValue(Byte theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 		{
0: 			setValue(theValue.byteValue());
0: 		}
0: 	}
0: 	
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final void setValue(Short theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.shortValue());
0: 	}
0: 	
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final void setValue(Integer theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.intValue());
0: 	}
0: 	
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final void setValue(Long theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.longValue());
0: 	}
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final void setValue(Double theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.doubleValue());
0: 	}
0: 
0: 	/**
0: 		setValue for integral exact numerics. Converts the BigDecimal
0: 		to a long to preserve precision
0: 	*/
0: 	public  void setValue(BigDecimal theValue) throws StandardException
0: 	{
0: 		if (objectNull(theValue))
0: 			return;
0: 
0: 		// See comment in SQLDecimal.getLong()
0: 
0: 		if (   (theValue.compareTo(SQLDecimal.MINLONG_MINUS_ONE) == 1)
0: 			&& (theValue.compareTo(SQLDecimal.MAXLONG_PLUS_ONE) == -1)) {
0: 
0: 			setValue(theValue.longValue());
0: 		} else {
0: 
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, getTypeName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final void setValue(Float theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.floatValue());
0: 	}
0: 	
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public final void setValue(Boolean theValue) throws StandardException
0: 	{
0: 		if (!objectNull(theValue))
0: 			setValue(theValue.booleanValue());
0: 	}
0: 
0:     
0: 	protected final boolean objectNull(Object o) 
0: 	{
0: 		if (o == null) 
0: 		{
0: 			restoreToNull();
0: 			return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0:        normalizeREAL checks the validity of the given java float that
0:        it fits within the range of DB2 REALs. In addition it
0:        normalizes the value, so that negative zero (-0.0) becomes positive.
0: 	*/
0:     public static float normalizeREAL(float v) throws StandardException
0: 	{
0:         if ( (Float.isNaN(v) || Float.isInfinite(v)) ||
0:              ((v < DB2Limit.DB2_SMALLEST_REAL) || (v > DB2Limit.DB2_LARGEST_REAL)) ||
0:              ((v > 0) && (v < DB2Limit.DB2_SMALLEST_POSITIVE_REAL)) ||
0:              ((v < 0) && (v > DB2Limit.DB2_LARGEST_NEGATIVE_REAL)) )
0:         {
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
0:         }
0:         // Normalize negative floats to be "positive" (can't detect easily without using Float object because -0.0f = 0.0f)
0:         if (v == 0.0f) v = 0.0f;
0: 
0:         return v;
0: 	}
0: 
0: 	/**
0:        normalizeREAL checks the validity of the given java double that
0:        it fits within the range of DB2 REALs. In addition it
0:        normalizes the value, so that negative zero (-0.0) becomes positive.
0: 
0:        The reason for having normalizeREAL with two signatures is to
0:        avoid that normalizeREAL is called with a casted (float)doublevalue,
0:        since this invokes an unwanted rounding (of underflow values to 0.0),
0:        in contradiction to DB2s casting semantics.
0: 	*/
0:     public static float normalizeREAL(double v) throws StandardException
0:     {
0:         // can't just cast it to float and call normalizeFloat(float) since casting can round down to 0.0
0:         if ( (Double.isNaN(v) || Double.isInfinite(v)) ||
0:              ((v < DB2Limit.DB2_SMALLEST_REAL) || (v > DB2Limit.DB2_LARGEST_REAL)) ||
0:              ((v > 0) && (v < DB2Limit.DB2_SMALLEST_POSITIVE_REAL)) ||
0:              ((v < 0) && (v > DB2Limit.DB2_LARGEST_NEGATIVE_REAL)) )
0:         {
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.REAL_NAME);
0:         }
0:         // Normalize negative floats to be "positive" (can't detect easily without using Float object because -0.0f = 0.0f)
0:         if (v == 0.0d) v = 0.0d;
0: 
0:         return (float)v;
0:     }
0: 
0: 	/**
0:        normalizeDOUBLE checks the validity of the given java double that
0:        it fits within the range of DB2 DOUBLEs. In addition it
0:        normalizes the value, so that negative zero (-0.0) becomes positive.
0: 	*/
0:     public static double normalizeDOUBLE(double v) throws StandardException
0: 	{
0:         if ( (Double.isNaN(v) || Double.isInfinite(v)) ||
0:              ((v < DB2Limit.DB2_SMALLEST_DOUBLE) || (v > DB2Limit.DB2_LARGEST_DOUBLE)) ||
0:              ((v > 0) && (v < DB2Limit.DB2_SMALLEST_POSITIVE_DOUBLE)) ||
0:              ((v < 0) && (v > DB2Limit.DB2_LARGEST_NEGATIVE_DOUBLE)) )
0:         {
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);
0:         }
0:         // Normalize negative doubles to be "positive" (can't detect easily without using Double object because -0.0f = 0.0f)
0:         if (v == 0.0d) v = 0.0d;
0: 
0:         return v;
0: 	}
0: 
0: 
0: }
0: 
============================================================================