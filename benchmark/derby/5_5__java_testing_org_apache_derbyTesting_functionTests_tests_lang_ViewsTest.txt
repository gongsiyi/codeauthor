1:7eb8268: /*
1:7eb8268: 
1:7eb8268:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ViewsTest
1:7eb8268: 
1:7eb8268:    Licensed to the Apache Software Foundation (ASF) under one or more
1:7eb8268:    contributor license agreements.  See the NOTICE file distributed with
1:7eb8268:    this work for additional information regarding copyright ownership.
1:7eb8268:    The ASF licenses this file to You under the Apache License, Version 2.0
1:7eb8268:    (the "License"); you may not use this file except in compliance with
1:7eb8268:    the License.  You may obtain a copy of the License at
1:7eb8268: 
1:7eb8268:       http://www.apache.org/licenses/LICENSE-2.0
1:7eb8268: 
1:7eb8268:    Unless required by applicable law or agreed to in writing, software
1:7eb8268:    distributed under the License is distributed on an "AS IS" BASIS,
1:7eb8268:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7eb8268:    See the License for the specific language governing permissions and
1:7eb8268:    limitations under the License.
1:7eb8268: 
1:7eb8268:  */
1:4fa5de9: package org.apache.derbyTesting.functionTests.tests.lang;
5:4fa5de9: 
1:392ac57: import java.sql.Connection;
1:53cbb53: import java.sql.DatabaseMetaData;
1:4fa5de9: import java.sql.PreparedStatement;
1:4fa5de9: import java.sql.ResultSet;
1:4fa5de9: import java.sql.SQLException;
1:4fa5de9: import java.sql.Statement;
1:4fa5de9: import junit.framework.Test;
1:4fa5de9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:392ac57: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:4fa5de9: import org.apache.derbyTesting.junit.JDBC;
1:4fa5de9: import org.apache.derbyTesting.junit.TestConfiguration;
1:4fa5de9: 
1:4fa5de9: public final class ViewsTest extends BaseJDBCTestCase {
1:4fa5de9: 
1:4fa5de9:     /**
1:4fa5de9:      * Public constructor required for running test as standalone JUnit.
1:4fa5de9:      */
1:4fa5de9:     public ViewsTest(String name)
1:4fa5de9:     {
1:4fa5de9:         super(name);
1:4fa5de9:     }
1:4fa5de9: 
1:4fa5de9:     public static Test suite()
1:4fa5de9:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("views Test");
1:4fa5de9:         suite.addTest(TestConfiguration.embeddedSuite(ViewsTest.class));
1:392ac57:         return new CleanDatabaseTestSetup(suite);
1:4fa5de9:     }
1:4fa5de9: 
1:8c15184:     //DERBY-6185(Query against view  with 
1:8c15184:     // "where name LIKE 'Col1' ESCAPE '\' " failed)
1:8c15184:     //Problem was that we clone binary comparison operator node during the
1:8c15184:     // optimize phase but we did not copy the entire state of the original
1:8c15184:     // node
1:8c15184:     public void test_DERBY6185() throws Exception
1:8c15184:     {
1:8c15184:         ResultSet rs = null;
1:8c15184:         
1:8c15184:         Statement st = createStatement();
1:8c15184:         PreparedStatement ps;
1:8c15184: 
1:8c15184:         // create 2 tables and a view
1:8c15184:         st.executeUpdate(
1:8c15184:             "create table mytbl1 (name clob(10K))");
1:8c15184:         st.executeUpdate("insert into mytbl1 "+
1:8c15184:             "values ('Col1'),('Col2')");
1:8c15184:         st.executeUpdate(
1:8c15184:             "create table mytbl2 (name clob(10K))");
1:8c15184:         st.executeUpdate("insert into mytbl2 "+
1:8c15184:                 "values ('Col1'),('Col2')");
1:8c15184:         st.executeUpdate(
1:8c15184:             "create view myview (name) as select t1.name from " +
1:8c15184:             "mytbl1 t1 union all select t2.name from mytbl2 t2");
1:8c15184: 
1:8c15184:         //test base table's CLOB and LIKE clause with Statement
1:8c15184:         rs = st.executeQuery("select name from mytbl1 " +
1:8c15184:                 "where name LIKE 'Col1'");
1:8c15184:         JDBC.assertFullResultSet(rs, new String[][]{
1:8c15184:                 {"Col1"}
1:8c15184:         });
1:8c15184: 
1:8c15184:         //test base table's CLOB and LIKE clause with PreparedStatement
1:8c15184:         ps = prepareStatement("select name from mytbl1 " +
1:8c15184:                 "where name LIKE ?");
1:8c15184:         ps.setString(1, "Col1");
1:8c15184:         rs = ps.executeQuery();
1:8c15184:         JDBC.assertFullResultSet(rs, new String[][]{
1:8c15184:                 {"Col1"}
1:8c15184:         });
1:8c15184: 
1:8c15184:         //test view's CLOB and LIKE clause with Statement
1:8c15184:         rs = st.executeQuery("select name from myview " +
1:8c15184:             "where name LIKE 'Col1'");
1:8c15184:         JDBC.assertFullResultSet(rs, new String[][]{
1:8c15184:                 {"Col1"},
1:8c15184:                 {"Col1"}
1:8c15184:         });
1:8c15184: 
1:8c15184:         //test view's CLOB and LIKE clause with PreparedStatement
1:8c15184:         ps = prepareStatement("select name from myview " +
1:8c15184:                 "where name LIKE ?");
1:8c15184:         ps.setString(1, "Col1");
1:8c15184:         rs = ps.executeQuery();
1:8c15184:         JDBC.assertFullResultSet(rs, new String[][]{
1:8c15184:                 {"Col1"},
1:8c15184:                 {"Col1"}
1:8c15184:         });
1:8c15184: 
1:8c15184:         //test UNION's CLOB and LIKE clause with Statement
1:8c15184:         rs = st.executeQuery("select name from " +
1:8c15184:              "(select name from mytbl1 t1 union all " +
1:8c15184:              "select t2.name from mytbl2 t2) " +
1:8c15184:              "as s where name like 'Col1'");
1:8c15184:         JDBC.assertFullResultSet(rs, new String[][]{
1:8c15184:                 {"Col1"},
1:8c15184:                 {"Col1"}
1:8c15184:         });
1:8c15184: 
1:8c15184:         //test UNION's CLOB and LIKE clause with PreparedStatement
1:8c15184:         ps = prepareStatement("select name from " +
1:8c15184:              "(select name from mytbl1 t1 union all " +
1:8c15184:              "select t2.name from mytbl2 t2) " +
1:8c15184:              "as s where name like ?");
1:8c15184:         ps.setString(1, "Col1");
1:8c15184:         rs = ps.executeQuery();
1:8c15184:         JDBC.assertFullResultSet(rs, new String[][]{
1:8c15184:                 {"Col1"},
1:8c15184:                 {"Col1"}
1:8c15184:         });
1:8c15184:     }
1:8c15184: 
1:4fa5de9:     public void test_views() throws Exception
1:4fa5de9:     {
1:4fa5de9:         ResultSet rs = null;
1:4fa5de9:    
1:4fa5de9:         Statement st = createStatement();
1:4fa5de9: 
1:4fa5de9:         String [][] expRS;
1:4fa5de9:         String [] expColNames;
1:4fa5de9: 
1:4fa5de9: 
1:4fa5de9:         //   Licensed to the Apache Software Foundation (ASF) 
1:4fa5de9:         // under one or more   contributor license agreements.  See 
1:4fa5de9:         // the NOTICE file distributed with   this work for 
1:4fa5de9:         // additional information regarding copyright ownership.   
1:4fa5de9:         // The ASF licenses this file to You under the Apache 
1:4fa5de9:         // License, Version 2.0   (the "License"); you may not use 
1:4fa5de9:         // this file except in compliance with   the License.  You 
1:4fa5de9:         // may obtain a copy of the License at      
1:4fa5de9:         // http://www.apache.org/licenses/LICENSE-2.0   Unless 
1:4fa5de9:         // required by applicable law or agreed to in writing, 
1:4fa5de9:         // software   distributed under the License is distributed 
1:4fa5de9:         // on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS 
1:4fa5de9:         // OF ANY KIND, either express or implied.   See the 
1:4fa5de9:         // License for the specific language governing permissions 
1:4fa5de9:         // and   limitations under the License. tests for views set 
1:4fa5de9:         // autocommit off
1:4fa5de9:         
1:4fa5de9:         getConnection().setAutoCommit(false);
1:4fa5de9:         
1:4fa5de9:         // create some tables
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "create table t1(i int, s smallint, f float, dp "
1:4fa5de9:             + "double precision)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create table t2(i int, s smallint, f float, dp "
1:4fa5de9:             + "double precision)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create table insert_test (f float)");
1:4fa5de9:         
1:4fa5de9:         // create some views
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "create view sv1 (s_was_i, dp_was_s, i_was_f, "
1:4fa5de9:             + "f_was_dp) as select * from t1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view sv2 as select * from t1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view sv3 as select dp, f from t1 where i = s");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view sv4(i) as values 1, 2, 3");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view sv5 (c1) as select * from sv4");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv1 (t1_i, t2_s, t1_f, t2_dp) as "
1:4fa5de9:             + "select t1.i, t2.s, t1.f, t2.dp from t1, t2 where "
1:4fa5de9:             + "t1.i between t2.s and t2.i");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv2 as select * from sv1, sv3 where dp "
1:4fa5de9:             + "= f_was_dp");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv3(i,s,f,dp) as select i, s, f, dp "
1:4fa5de9:             + "from sv2 union select dp_was_s, s_was_i, f_was_dp, "
1:4fa5de9:             + "i_was_f from sv1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv4 (distinct_i) as select distinct i from t1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv5(i,s) as select * from (select i, s "
1:4fa5de9:             + "from cv3 where i = s) xyz");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv6 (c1, c2) as select a.c1 as x, b.c1 "
1:4fa5de9:             + "as y from sv5 a, sv5 b where a.c1 <> b.c1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv7 as select t.i, v.c1 from t1 t, cv6 "
1:4fa5de9:             + "v where t.i = v.c1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view cv8(col1, col2) as select 'Column 1',  "
1:4fa5de9:             + "'Value = ' || cast(c1 as char(5)) from cv7 where 1 "
1:4fa5de9:             + "in (select i from sv5)");
1:4fa5de9:         
1:4fa5de9:         // populate the tables
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "insert into t1 values (1, 1, 1.0, 1.0)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " insert into t1 values (1, 2, 3.0, 4.0)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " insert into t1 values (8, 7, 6.0, 5.0)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " insert into t2 values (1, 1, 1.0, 1.0)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " insert into t2 values (1, 2, 3.0, 4.0)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " insert into t2 values (8, 7, 6.0, 5.0)");
1:4fa5de9:         
1:4fa5de9:         // negative tests view with a parameter
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42X98", st,
1:4fa5de9:             "create view vneg as select * from t1 where i = ?");
1:4fa5de9:         
1:4fa5de9:         // drop view on table
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0Y16", st,
1:4fa5de9:             "drop view t1");
1:4fa5de9:         
1:4fa5de9:         // drop table on view
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42Y62", st,
1:4fa5de9:             "drop table sv1");
1:4fa5de9:         
1:4fa5de9:         // views and tables share same name space
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0Y32", st,
1:4fa5de9:             "create view sv1(i) as values 1");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0Y32", st,
1:4fa5de9:             " create table sv1 (c1 int)");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0Y32", st,
1:4fa5de9:             " create view t1(i) as values 1");
1:4fa5de9:         
1:4fa5de9:         // drop non-existant view
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0X05", st,
1:4fa5de9:             "drop view notexists");
1:4fa5de9:         
1:4fa5de9:         // duplicate column name in view's column list
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42Y13", st,
1:4fa5de9:             "create view shouldntwork (c1, c2, c1) as select i, "
1:4fa5de9:             + "s, f from t1");
1:4fa5de9:         
1:4fa5de9:         // # of columns in view's column list does not match that 
1:4fa5de9:         // in view definition
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42X56", st,
1:4fa5de9:             "create view shouldntwork (c1, c2, c3) as select i, s from t1");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42X56", st,
1:4fa5de9:             " create view shouldntwork (c1, c2, c3) as select i, "
1:4fa5de9:             + "s, f, dp from t1");
1:4fa5de9:         
1:4fa5de9:         // try to drop a table out from under a view
1:4fa5de9:         
1:4fa5de9:         assertStatementError(new String[] {"X0Y23","X0Y23","X0Y23","X0Y23","X0Y23","X0Y23",
1:4fa5de9:             "X0Y23","X0Y23","X0Y23","X0Y23"},st,
1:4fa5de9:             "drop table t1");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0Y23", st,
1:4fa5de9:             " drop table t2");
1:4fa5de9:         
1:4fa5de9:         // try to drop a view out from under another view
1:4fa5de9:         
1:4fa5de9:         assertStatementError(new String[] {"X0Y23","X0Y23","X0Y23"}, st,
1:4fa5de9:             "drop view sv1");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0Y23", st,
1:4fa5de9:             " drop view sv3");
1:4fa5de9:         
1:4fa5de9:         // try to drop a view out from under a cursor
1:4fa5de9:         
1:4fa5de9:         PreparedStatement ps_c1 = prepareStatement(
1:4fa5de9:             "select * from cv8");
1:4fa5de9:         
1:4fa5de9:         ResultSet c1 = ps_c1.executeQuery();
1:4fa5de9:         
1:4fa5de9:         assertStatementError("X0X95", st,
1:4fa5de9:             " drop view cv8");
1:7eb8268: 
1:7eb8268:         assertStatementErrorUnordered(
1:7eb8268:             new String[] {"X0Y23","X0Y23","X0Y23","X0X95"}, st,
1:4fa5de9:             " drop view sv5");
1:4fa5de9:         
1:7eb8268:         assertStatementErrorUnordered(
1:7eb8268:             new String[] {"X0Y23","X0Y23","X0Y23","X0Y23","X0X95"}, st,
1:4fa5de9:             " drop view sv4");
1:4fa5de9:         
1:4fa5de9:         c1.close();
1:4fa5de9:         ps_c1.close();
1:4fa5de9:         
1:4fa5de9:         // view updateability (No views are currently updateable)
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42Y24", st,
1:4fa5de9:             "insert into sv1 values 1");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42Y24", st,
1:4fa5de9:             " delete from sv1");
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42Y24", st,
1:4fa5de9:             " update sv1 set s_was_i = 0");
1:4fa5de9:         
1:4fa5de9:         try {
1:4fa5de9:         prepareStatement(
1:4fa5de9:                 "select * from sv1 for update of s_was_i");
1:4fa5de9:             fail("statement ps_c2 should not have succeeded");
1:4fa5de9:         } catch (SQLException se) {
1:4fa5de9:             assertSQLState("42Y90",se);
1:4fa5de9:         }
1:4fa5de9:         
1:4fa5de9:         // create index on a view
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42Y62", st,
1:4fa5de9:             "create index i1 on sv2(i)");
1:4fa5de9:         
1:4fa5de9:         // positive tests
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             "select * from sv1");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"S_WAS_I", "DP_WAS_S", "I_WAS_F", "F_WAS_DP"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1", "1.0", "1.0"},
1:4fa5de9:             {"1", "2", "3.0", "4.0"},
1:4fa5de9:             {"8", "7", "6.0", "5.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from sv2");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I", "S", "F", "DP"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1", "1.0", "1.0"},
1:4fa5de9:             {"1", "2", "3.0", "4.0"},
1:4fa5de9:             {"8", "7", "6.0", "5.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from sv3");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"DP", "F"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1.0", "1.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from sv4");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1"},
1:4fa5de9:             {"2"},
1:4fa5de9:             {"3"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from sv5");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"C1"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1"},
1:4fa5de9:             {"2"},
1:4fa5de9:             {"3"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv1");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"T1_I", "T2_S", "T1_F", "T2_DP"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1", "1.0", "1.0"},
1:4fa5de9:             {"1", "1", "3.0", "1.0"},
1:4fa5de9:             {"8", "7", "6.0", "5.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv2");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"S_WAS_I", "DP_WAS_S", "I_WAS_F", "F_WAS_DP", "DP", "F"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1", "1.0", "1.0", "1.0", "1.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv3");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I", "S", "F", "DP"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1", "1.0", "1.0"},
1:4fa5de9:             {"1", "2", "3.0", "4.0"},
1:4fa5de9:             {"2", "1", "4.0", "3.0"},
1:4fa5de9:             {"7", "8", "5.0", "6.0"},
1:4fa5de9:             {"8", "7", "6.0", "5.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv4 order by 1");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"DISTINCT_I"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1"},
1:4fa5de9:             {"8"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv5");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I", "S"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv6");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"C1", "C2"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "2"},
1:4fa5de9:             {"1", "3"},
1:4fa5de9:             {"2", "1"},
1:4fa5de9:             {"2", "3"},
1:4fa5de9:             {"3", "1"},
1:4fa5de9:             {"3", "2"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv7");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I", "C1"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1"},
1:4fa5de9:             {"1", "1"},
1:4fa5de9:             {"1", "1"},
1:4fa5de9:             {"1", "1"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from cv8");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"COL1", "COL2"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"Column 1", "Value = 1"},
1:4fa5de9:             {"Column 1", "Value = 1"},
1:4fa5de9:             {"Column 1", "Value = 1"},
1:4fa5de9:             {"Column 1", "Value = 1"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from (select * from cv3) x order by 1,2");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I", "S", "F", "DP"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1", "1.0", "1.0"},
1:4fa5de9:             {"1", "2", "3.0", "4.0"},
1:4fa5de9:             {"2", "1", "4.0", "3.0"},
1:4fa5de9:             {"7", "8", "5.0", "6.0"},
1:4fa5de9:             {"8", "7", "6.0", "5.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from (select * from cv4) x order by 1");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"DISTINCT_I"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1"},
1:4fa5de9:             {"8"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from (select * from cv5) x");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"I", "S"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1", "1"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         // verify that we can create and drop indexes on 
1:4fa5de9:         // underlying tables
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "create index i on t1(i)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop index i");
1:4fa5de9:         
1:4fa5de9:         // verify the consistency of the indexes on the system 
1:4fa5de9:         // catalogs
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             "select tablename, "
1:4fa5de9:             + "SYSCS_UTIL.SYSCS_CHECK_TABLE('SYS', tablename) from "
1:4fa5de9:             + "sys.systables where CAST(tabletype AS CHAR(1)) = "
1:aa609d5:             + "'S' and CAST(tablename AS VARCHAR(128)) != 'SYSDUMMY1' order by tablename");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"TABLENAME", "2"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"SYSALIASES", "1"},
1:4fa5de9:             {"SYSCHECKS", "1"},
1:aa609d5:             {"SYSCOLPERMS", "1"},
1:aa609d5:             {"SYSCOLUMNS", "1"},
1:aa609d5:             {"SYSCONGLOMERATES", "1"},
1:aa609d5:             {"SYSCONSTRAINTS", "1"},
1:aa609d5:             {"SYSDEPENDS", "1"},
1:4fa5de9:             {"SYSFILES", "1"},
1:aa609d5:             {"SYSFOREIGNKEYS", "1"},
1:aa609d5:             {"SYSKEYS", "1"},
1:aa609d5:             {"SYSPERMS", "1"},   
1:aa609d5:             {"SYSROLES", "1"},
1:aa609d5:             {"SYSROUTINEPERMS", "1"},
1:aa609d5:             {"SYSSCHEMAS", "1"},
1:aa609d5:             {"SYSSEQUENCES", "1"},
1:aa609d5:             {"SYSSTATEMENTS", "1"},
1:4fa5de9:             {"SYSSTATISTICS", "1"},
1:4fa5de9:             {"SYSTABLEPERMS", "1"},
1:aa609d5:             {"SYSTABLES", "1"},
1:aa609d5:             {"SYSTRIGGERS", "1"},
1:aa609d5:             {"SYSUSERS", "1"},
1:aa609d5:             {"SYSVIEWS", "1"},
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         // test inserts from a view
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "insert into insert_test select * from sv5");
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " select * from insert_test");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"F"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"1.0"},
1:4fa5de9:             {"2.0"},
1:4fa5de9:             {"3.0"}
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         // drop the views
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "drop view cv8");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv7");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv6");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv5");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv4");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv3");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv2");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view cv1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view sv5");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view sv4");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view sv3");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view sv2");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view sv1");
1:4fa5de9:         
1:4fa5de9:         // drop the tables
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "drop table t1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop table t2");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop table insert_test");
1:4fa5de9:         
1:4fa5de9:         // verify the consistency of the indexes on the system 
1:4fa5de9:         // catalogs
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             "select tablename, "
1:4fa5de9:             + "SYSCS_UTIL.SYSCS_CHECK_TABLE('SYS', tablename) from "
1:4fa5de9:             + "sys.systables where CAST(tabletype as CHAR(1)) = "
1:aa609d5:             + "'S' and CAST(tablename  as VARCHAR(128)) != 'SYSDUMMY1' order by tablename");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"TABLENAME", "2"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         
1:4fa5de9:         expRS = new String [][]
1:4fa5de9:         {
1:4fa5de9:             {"SYSALIASES", "1"},
1:4fa5de9:             {"SYSCHECKS", "1"},
1:aa609d5:             {"SYSCOLPERMS", "1"},
1:aa609d5:             {"SYSCOLUMNS", "1"},
1:aa609d5:             {"SYSCONGLOMERATES", "1"},
1:aa609d5:             {"SYSCONSTRAINTS", "1"},
1:aa609d5:             {"SYSDEPENDS", "1"},
1:4fa5de9:             {"SYSFILES", "1"},
1:aa609d5:             {"SYSFOREIGNKEYS", "1"},
1:aa609d5:             {"SYSKEYS", "1"},
1:aa609d5:             {"SYSPERMS", "1"},   
1:aa609d5:             {"SYSROLES", "1"},
1:aa609d5:             {"SYSROUTINEPERMS", "1"},
1:aa609d5:             {"SYSSCHEMAS", "1"},
1:aa609d5:             {"SYSSEQUENCES", "1"},
1:aa609d5:             {"SYSSTATEMENTS", "1"},
1:4fa5de9:             {"SYSSTATISTICS", "1"},
1:4fa5de9:             {"SYSTABLEPERMS", "1"},
1:aa609d5:             {"SYSTABLES", "1"},
1:aa609d5:             {"SYSTRIGGERS", "1"},
1:aa609d5:             {"SYSUSERS", "1"},
1:aa609d5:             {"SYSVIEWS", "1"},
1:4fa5de9:         };
1:4fa5de9:         
1:4fa5de9:         JDBC.assertFullResultSet(rs, expRS, true);
1:4fa5de9:         
1:4fa5de9:         // bug 2745
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "CREATE TABLE orgtable ( name VARCHAR(255), "
1:4fa5de9:             + "supervisorname VARCHAR(255), jobtitle VARCHAR(255) )");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " CREATE VIEW orgview AS SELECT name, "
1:4fa5de9:             + "supervisorname, jobtitle FROM orgtable");
1:4fa5de9:         
1:4fa5de9:         rs = st.executeQuery(
1:4fa5de9:             " SELECT name,jobtitle FROM orgview WHERE name IN "
1:4fa5de9:             + "(SELECT supervisorname FROM orgview WHERE name LIKE "
1:4fa5de9:             + "'WYATT%')");
1:4fa5de9:         
1:4fa5de9:         expColNames = new String [] {"NAME", "JOBTITLE"};
1:4fa5de9:         JDBC.assertColumnNames(rs, expColNames);
1:4fa5de9:         JDBC.assertDrainResults(rs, 0);
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view orgview");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop table orgtable");
1:4fa5de9:         
1:4fa5de9:         // reset autocommit
1:4fa5de9:         
1:4fa5de9:         getConnection().setAutoCommit(true);
1:4fa5de9:         
1:4fa5de9:         // DERBY-1304 view not getting dropped The second drop 
1:4fa5de9:         // view statement fails before the patch
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "CREATE SCHEMA TEST_SCHEMA");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " CREATE TABLE TEST_SCHEMA.T1 (TABLE_COLUMN LONG VARCHAR)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " CREATE VIEW TEST_SCHEMA.V1 AS SELECT TABLE_COLUMN "
1:4fa5de9:             + "AS VIEW_COLUMN FROM TEST_SCHEMA.T1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " DROP VIEW TEST_SCHEMA.V1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " DROP TABLE TEST_SCHEMA.T1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " DROP SCHEMA TEST_SCHEMA RESTRICT");
1:4fa5de9:         
1:4fa5de9:         // reiterate
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "CREATE SCHEMA TEST_SCHEMA");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " CREATE TABLE TEST_SCHEMA.T1 (TABLE_COLUMN LONG VARCHAR)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " CREATE VIEW TEST_SCHEMA.V1 AS SELECT TABLE_COLUMN "
1:4fa5de9:             + "AS VIEW_COLUMN FROM TEST_SCHEMA.T1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " DROP VIEW TEST_SCHEMA.V1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " DROP TABLE TEST_SCHEMA.T1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " DROP SCHEMA TEST_SCHEMA RESTRICT");
1:4fa5de9:         
1:4fa5de9:         // DERBY-2018 expect error
1:4fa5de9:         
1:4fa5de9:         assertStatementError("42X07", st,
1:4fa5de9:             "CREATE VIEW v1(c1) AS VALUES NULL");
1:4fa5de9:         
1:4fa5de9:         // DERBY-681
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             "create table o (name varchar(20), ord int)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create table a (ord int, amount int)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view v1 (vx, vy) as select name, sum(ord) "
1:4fa5de9:             + "from o where ord > 0 group by name, ord");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " create view v2 (vx, vy) as select name, sum(ord) "
1:4fa5de9:             + "from o where ord > 0 group by name, ord having ord "
1:4fa5de9:             + "<= ANY (select ord from a)");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view v2");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop view v1");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop table a");
1:4fa5de9:         
1:4fa5de9:         st.executeUpdate(
1:4fa5de9:             " drop table o");
1:4fa5de9:         
1:4fa5de9:         
1:4fa5de9:         
1:4fa5de9:         getConnection().rollback();
1:4fa5de9:         st.close();
1:4fa5de9:     }
1:392ac57: 
1:392ac57:    /**
1:392ac57:     * DERBY-3270 Test that we can select from a view in another schema if the
1:392ac57:     * default schema does not exist.
1:392ac57:     *
1:392ac57:     * @throws SQLException
1:392ac57:     */
1:392ac57:     public void testSelectViewFromOtherSchemaWithNoDefaultSchema()
1:392ac57:             throws SQLException {
1:392ac57:         Connection conn = openDefaultConnection("joe","joepass");
1:392ac57:         Statement st = conn.createStatement();
1:392ac57:         st.execute("create table mytable(a int)");
1:392ac57:         st.execute("insert into mytable values (99)");
1:392ac57:         st.execute("create view myview as select * from mytable");
1:392ac57:         st.close();
1:392ac57:         conn.close();
1:392ac57:         Connection conn2 = openDefaultConnection("bill","billpass");
1:392ac57:         Statement st2 = conn2.createStatement();
1:392ac57:         ResultSet rs = st2.executeQuery("SELECT * FROM JOE.MYVIEW");
1:392ac57:         JDBC.assertFullResultSet(rs,new String[][] {{"99"}});
1:392ac57:         st2.executeUpdate("drop view joe.myview");
1:392ac57:         st2.executeUpdate("drop table joe.mytable");
1:392ac57:         st2.close();
1:392ac57:         conn2.close();
1:392ac57:    }
1:392ac57: 
1:53cbb53:     /**
1:53cbb53:      * Make sure DatabaseMetaData.getColumns is correct when we have a view
1:53cbb53:      * created when there is an expression in the select list.
1:53cbb53:      * Also check the ResultSetMetaData
1:53cbb53:      * @throws SQLException
1:53cbb53:      */
1:53cbb53:     public void testViewMetaDataWithGeneratedColumnsDerby4230() throws SQLException {
1:53cbb53:         Statement s = createStatement();
1:53cbb53:         s.executeUpdate("create table A (id integer, data varchar(20), data2 integer)");
1:53cbb53:         s.executeUpdate("insert into A values (3, 'G', 5), (23, 'G', 4), (5, 'F', 1), (2, 'H', 4), (1, 'F', 5)");
1:53cbb53:         //DERBY-4230. Make sure DatabaseMetaData.getColumns does not include generated columns.
1:53cbb53:         // You need an expression in the select list.
1:53cbb53:         s.executeUpdate("create view V (data, num) as select data, data2 + 2 from A group by data, data2");
1:53cbb53:         DatabaseMetaData dmd = getConnection().getMetaData();
1:53cbb53:         ResultSet columns = dmd.getColumns(null, null, "V", null);
1:53cbb53:         String[][] expectedDBMetaRows = new String[][] {{"","APP","V","DATA","12","VARCHAR","20",null,null,null,"1","",null,null,null
1:ce664ad:             ,"40","1","YES",null,null,null,null,"NO","NO",null},
1:ce664ad:             {"","APP","V","NUM","4","INTEGER","10",null,"0","10","1","",null,null,null,null,"2","YES",null,null,null,null,"NO","NO",null}};  
1:53cbb53:         JDBC.assertFullResultSet(columns,expectedDBMetaRows);
1:53cbb53:         // Make sure ResultSetMetaData is right when selecting from view.
1:53cbb53:         // This wasn't a problem with DERBY-4230, but checking for good measure.
1:53cbb53:         ResultSet rs = s.executeQuery("SELECT * FROM V");        
1:53cbb53:         JDBC.assertColumnNames(rs, new String[] {"DATA","NUM"});
1:53cbb53:         JDBC.assertColumnTypes(rs, new int[] {java.sql.Types.VARCHAR, java.sql.Types.INTEGER});
1:53cbb53:         JDBC.assertNullability(rs,new boolean[] {true,true});
1:53cbb53:         // Finally check the results.
1:53cbb53:         String [][] expectedRows = new String[][] {{"F","3"},
1:53cbb53:             {"F","7"},
1:53cbb53:             {"G","6"},
1:53cbb53:             {"G","7"},
1:53cbb53:             {"H","6"}};
1:53cbb53:         JDBC.assertFullResultSet(rs, expectedRows);
1:53cbb53:         s.executeUpdate("DROP VIEW V");
1:53cbb53:         s.executeUpdate("DROP TABLE A");        
1:53cbb53:     }
1:edeac31: 
1:edeac31: 
1:edeac31:     /**
1:edeac31:      * DERBY-3478
1:edeac31:      * Make sure column names are correct when we select from a view and also
1:edeac31:      * give a table correation name with derived column list.
1:edeac31:      *
1:edeac31:      * E.g. SELECT * FROM V1 X(A,B)
1:edeac31:      *
1:edeac31:      * @throws SQLException
1:edeac31:      */
1:edeac31:     public void testViewMetaDataWithCorrelationNameAndDerivedColumnList_3478()
1:edeac31:             throws SQLException
1:edeac31:     {
1:edeac31:         Statement s = createStatement();
1:edeac31:         s.executeUpdate("create table t1 (i int, j int)");
1:edeac31:         s.executeUpdate("insert into t1 values (1, 1), (1, -1), " +
1:edeac31:                         "                      (2, 2), (3, -3), (4, 4)");
1:edeac31: 
1:edeac31:         s.executeUpdate("create view v1 as select j, i from t1");
1:edeac31:         s.executeUpdate("create view v2 (x,y,z) as select j, i, i+j from t1");
1:edeac31: 
1:edeac31:         DatabaseMetaData dmd = getConnection().getMetaData();
1:edeac31:         ResultSet columns = dmd.getColumns(null, null, "V1", null);
1:edeac31: 
1:edeac31:         String[][] expectedDBMetaRows = new String[][]
1:edeac31:             {{"","APP","V1","J","4","INTEGER","10",null,"0","10","1","",
1:ce664ad:               null,null,null,null,"1","YES",null,null,null,null,"NO","NO",null},
1:edeac31:              {"","APP","V1","I","4","INTEGER","10",null,"0","10","1","",
1:ce664ad:               null,null,null,null,"2","YES",null,null,null,null,"NO","NO",null}};
1:edeac31: 
1:edeac31:         JDBC.assertFullResultSet(columns,expectedDBMetaRows);
1:edeac31: 
1:edeac31:         expectedDBMetaRows = new String[][]
1:edeac31:             {{"","APP","V2","X","4","INTEGER","10",null,"0","10","1","",
1:ce664ad:               null,null,null,null,"1","YES",null,null,null,null,"NO","NO",null},
1:edeac31:              {"","APP","V2","Y","4","INTEGER","10",null,"0","10","1","",
1:ce664ad:               null,null,null,null,"2","YES",null,null,null,null,"NO","NO",null},
1:edeac31:              {"","APP","V2","Z","4","INTEGER","10",null,"0","10","1","",
1:ce664ad:               null,null,null,null,"3","YES",null,null,null,null,"NO","NO",null}};
1:edeac31: 
1:edeac31:         columns = dmd.getColumns(null, null, "V2", null);
1:edeac31:         JDBC.assertFullResultSet(columns,expectedDBMetaRows);
1:edeac31: 
1:edeac31:         // Make sure ResultSetMetaData is right when selecting from view. This
1:edeac31:         // exposes DERBY-3478 if not fixed.
1:edeac31: 
1:edeac31:         ResultSet rs = s.executeQuery("select * from v1 x(a,b)");
1:edeac31:         JDBC.assertColumnNames(rs, new String[] {"A","B"});
1:edeac31:         JDBC.assertColumnTypes(rs, new int[] {java.sql.Types.INTEGER,
1:edeac31:                                               java.sql.Types.INTEGER});
1:edeac31:         JDBC.assertNullability(rs,new boolean[] {true,true});
1:edeac31: 
1:edeac31:         // Check the results.
1:edeac31:         String [][] expectedRows = new String[][]
1:edeac31:             {{"1","1"},
1:edeac31:              {"-1","1"},
1:edeac31:              {"2","2"},
1:edeac31:              {"-3","3"},
1:edeac31:              {"4","4"}};
1:edeac31:         JDBC.assertFullResultSet(rs, expectedRows);
1:edeac31: 
1:edeac31:         rs = s.executeQuery("select * from v2 as x(a,b,d)");
1:edeac31:         JDBC.assertColumnNames(rs, new String[] {"A","B","D"});
1:edeac31:         JDBC.assertColumnTypes(rs, new int[] {java.sql.Types.INTEGER,
1:edeac31:                                               java.sql.Types.INTEGER,
1:edeac31:                                               java.sql.Types.INTEGER});
1:edeac31:         JDBC.assertNullability(rs,new boolean[] {true,true, true});
1:edeac31: 
1:edeac31:         // Check the results.
1:edeac31:         expectedRows = new String[][]
1:edeac31:             {{"1","1","2"},
1:edeac31:              {"-1","1","0"},
1:edeac31:              {"2","2","4"},
1:edeac31:              {"-3","3","0"},
1:edeac31:              {"4","4","8"}};
1:edeac31:         JDBC.assertFullResultSet(rs, expectedRows);
1:edeac31: 
1:edeac31:         s.executeUpdate("drop view v1");
1:edeac31:         s.executeUpdate("drop view v2");
1:edeac31:         s.executeUpdate("drop table t1");
1:edeac31:     }
1:4fa5de9: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("views Test");
commit:edeac31
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * DERBY-3478
1:      * Make sure column names are correct when we select from a view and also
1:      * give a table correation name with derived column list.
1:      *
1:      * E.g. SELECT * FROM V1 X(A,B)
1:      *
1:      * @throws SQLException
1:      */
1:     public void testViewMetaDataWithCorrelationNameAndDerivedColumnList_3478()
1:             throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table t1 (i int, j int)");
1:         s.executeUpdate("insert into t1 values (1, 1), (1, -1), " +
1:                         "                      (2, 2), (3, -3), (4, 4)");
1: 
1:         s.executeUpdate("create view v1 as select j, i from t1");
1:         s.executeUpdate("create view v2 (x,y,z) as select j, i, i+j from t1");
1: 
1:         DatabaseMetaData dmd = getConnection().getMetaData();
1:         ResultSet columns = dmd.getColumns(null, null, "V1", null);
1: 
1:         String[][] expectedDBMetaRows = new String[][]
1:             {{"","APP","V1","J","4","INTEGER","10",null,"0","10","1","",
0:               null,null,null,null,"1","YES",null,null,null,null,"NO"},
1:              {"","APP","V1","I","4","INTEGER","10",null,"0","10","1","",
0:               null,null,null,null,"2","YES",null,null,null,null,"NO"}};
1: 
1:         JDBC.assertFullResultSet(columns,expectedDBMetaRows);
1: 
1:         expectedDBMetaRows = new String[][]
1:             {{"","APP","V2","X","4","INTEGER","10",null,"0","10","1","",
0:               null,null,null,null,"1","YES",null,null,null,null,"NO"},
1:              {"","APP","V2","Y","4","INTEGER","10",null,"0","10","1","",
0:               null,null,null,null,"2","YES",null,null,null,null,"NO"},
1:              {"","APP","V2","Z","4","INTEGER","10",null,"0","10","1","",
0:               null,null,null,null,"3","YES",null,null,null,null,"NO"}};
1: 
1:         columns = dmd.getColumns(null, null, "V2", null);
1:         JDBC.assertFullResultSet(columns,expectedDBMetaRows);
1: 
1:         // Make sure ResultSetMetaData is right when selecting from view. This
1:         // exposes DERBY-3478 if not fixed.
1: 
1:         ResultSet rs = s.executeQuery("select * from v1 x(a,b)");
1:         JDBC.assertColumnNames(rs, new String[] {"A","B"});
1:         JDBC.assertColumnTypes(rs, new int[] {java.sql.Types.INTEGER,
1:                                               java.sql.Types.INTEGER});
1:         JDBC.assertNullability(rs,new boolean[] {true,true});
1: 
1:         // Check the results.
1:         String [][] expectedRows = new String[][]
1:             {{"1","1"},
1:              {"-1","1"},
1:              {"2","2"},
1:              {"-3","3"},
1:              {"4","4"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         rs = s.executeQuery("select * from v2 as x(a,b,d)");
1:         JDBC.assertColumnNames(rs, new String[] {"A","B","D"});
1:         JDBC.assertColumnTypes(rs, new int[] {java.sql.Types.INTEGER,
1:                                               java.sql.Types.INTEGER,
1:                                               java.sql.Types.INTEGER});
1:         JDBC.assertNullability(rs,new boolean[] {true,true, true});
1: 
1:         // Check the results.
1:         expectedRows = new String[][]
1:             {{"1","1","2"},
1:              {"-1","1","0"},
1:              {"2","2","4"},
1:              {"-3","3","0"},
1:              {"4","4","8"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         s.executeUpdate("drop view v1");
1:         s.executeUpdate("drop view v2");
1:         s.executeUpdate("drop table t1");
1:     }
commit:392ac57
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         return new CleanDatabaseTestSetup(suite);
/////////////////////////////////////////////////////////////////////////
1: 
1:    /**
1:     * DERBY-3270 Test that we can select from a view in another schema if the
1:     * default schema does not exist.
1:     *
1:     * @throws SQLException
1:     */
1:     public void testSelectViewFromOtherSchemaWithNoDefaultSchema()
1:             throws SQLException {
1:         Connection conn = openDefaultConnection("joe","joepass");
1:         Statement st = conn.createStatement();
1:         st.execute("create table mytable(a int)");
1:         st.execute("insert into mytable values (99)");
1:         st.execute("create view myview as select * from mytable");
1:         st.close();
1:         conn.close();
1:         Connection conn2 = openDefaultConnection("bill","billpass");
1:         Statement st2 = conn2.createStatement();
1:         ResultSet rs = st2.executeQuery("SELECT * FROM JOE.MYVIEW");
1:         JDBC.assertFullResultSet(rs,new String[][] {{"99"}});
1:         st2.executeUpdate("drop view joe.myview");
1:         st2.executeUpdate("drop table joe.mytable");
1:         st2.close();
1:         conn2.close();
1:    }
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
1:     //DERBY-6185(Query against view  with 
1:     // "where name LIKE 'Col1' ESCAPE '\' " failed)
1:     //Problem was that we clone binary comparison operator node during the
1:     // optimize phase but we did not copy the entire state of the original
1:     // node
1:     public void test_DERBY6185() throws Exception
1:     {
1:         ResultSet rs = null;
1:         
1:         Statement st = createStatement();
1:         PreparedStatement ps;
1: 
1:         // create 2 tables and a view
1:         st.executeUpdate(
1:             "create table mytbl1 (name clob(10K))");
1:         st.executeUpdate("insert into mytbl1 "+
1:             "values ('Col1'),('Col2')");
1:         st.executeUpdate(
1:             "create table mytbl2 (name clob(10K))");
1:         st.executeUpdate("insert into mytbl2 "+
1:                 "values ('Col1'),('Col2')");
1:         st.executeUpdate(
1:             "create view myview (name) as select t1.name from " +
1:             "mytbl1 t1 union all select t2.name from mytbl2 t2");
1: 
1:         //test base table's CLOB and LIKE clause with Statement
1:         rs = st.executeQuery("select name from mytbl1 " +
1:                 "where name LIKE 'Col1'");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Col1"}
1:         });
1: 
1:         //test base table's CLOB and LIKE clause with PreparedStatement
1:         ps = prepareStatement("select name from mytbl1 " +
1:                 "where name LIKE ?");
1:         ps.setString(1, "Col1");
1:         rs = ps.executeQuery();
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Col1"}
1:         });
1: 
1:         //test view's CLOB and LIKE clause with Statement
1:         rs = st.executeQuery("select name from myview " +
1:             "where name LIKE 'Col1'");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Col1"},
1:                 {"Col1"}
1:         });
1: 
1:         //test view's CLOB and LIKE clause with PreparedStatement
1:         ps = prepareStatement("select name from myview " +
1:                 "where name LIKE ?");
1:         ps.setString(1, "Col1");
1:         rs = ps.executeQuery();
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Col1"},
1:                 {"Col1"}
1:         });
1: 
1:         //test UNION's CLOB and LIKE clause with Statement
1:         rs = st.executeQuery("select name from " +
1:              "(select name from mytbl1 t1 union all " +
1:              "select t2.name from mytbl2 t2) " +
1:              "as s where name like 'Col1'");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Col1"},
1:                 {"Col1"}
1:         });
1: 
1:         //test UNION's CLOB and LIKE clause with PreparedStatement
1:         ps = prepareStatement("select name from " +
1:              "(select name from mytbl1 t1 union all " +
1:              "select t2.name from mytbl2 t2) " +
1:              "as s where name like ?");
1:         ps.setString(1, "Col1");
1:         rs = ps.executeQuery();
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Col1"},
1:                 {"Col1"}
1:         });
1:     }
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:aa609d5
/////////////////////////////////////////////////////////////////////////
1:             + "'S' and CAST(tablename AS VARCHAR(128)) != 'SYSDUMMY1' order by tablename");
1:             {"SYSCOLPERMS", "1"},
1:             {"SYSCOLUMNS", "1"},
1:             {"SYSCONGLOMERATES", "1"},
1:             {"SYSCONSTRAINTS", "1"},
1:             {"SYSDEPENDS", "1"},
1:             {"SYSFOREIGNKEYS", "1"},
1:             {"SYSKEYS", "1"},
1:             {"SYSPERMS", "1"},   
1:             {"SYSROLES", "1"},
1:             {"SYSROUTINEPERMS", "1"},
1:             {"SYSSCHEMAS", "1"},
1:             {"SYSSEQUENCES", "1"},
1:             {"SYSSTATEMENTS", "1"},
1:             {"SYSTABLES", "1"},
1:             {"SYSTRIGGERS", "1"},
1:             {"SYSUSERS", "1"},
1:             {"SYSVIEWS", "1"},
/////////////////////////////////////////////////////////////////////////
1:             + "'S' and CAST(tablename  as VARCHAR(128)) != 'SYSDUMMY1' order by tablename");
1:             {"SYSCOLPERMS", "1"},
1:             {"SYSCOLUMNS", "1"},
1:             {"SYSCONGLOMERATES", "1"},
1:             {"SYSCONSTRAINTS", "1"},
1:             {"SYSDEPENDS", "1"},
1:             {"SYSFOREIGNKEYS", "1"},
1:             {"SYSKEYS", "1"},
1:             {"SYSPERMS", "1"},   
1:             {"SYSROLES", "1"},
1:             {"SYSROUTINEPERMS", "1"},
1:             {"SYSSCHEMAS", "1"},
1:             {"SYSSEQUENCES", "1"},
1:             {"SYSSTATEMENTS", "1"},
1:             {"SYSTABLES", "1"},
1:             {"SYSTRIGGERS", "1"},
1:             {"SYSUSERS", "1"},
1:             {"SYSVIEWS", "1"},
commit:ce664ad
/////////////////////////////////////////////////////////////////////////
1:             ,"40","1","YES",null,null,null,null,"NO","NO",null},
1:             {"","APP","V","NUM","4","INTEGER","10",null,"0","10","1","",null,null,null,null,"2","YES",null,null,null,null,"NO","NO",null}};  
/////////////////////////////////////////////////////////////////////////
1:               null,null,null,null,"1","YES",null,null,null,null,"NO","NO",null},
1:               null,null,null,null,"2","YES",null,null,null,null,"NO","NO",null}};
1:               null,null,null,null,"1","YES",null,null,null,null,"NO","NO",null},
1:               null,null,null,null,"2","YES",null,null,null,null,"NO","NO",null},
1:               null,null,null,null,"3","YES",null,null,null,null,"NO","NO",null}};
commit:81ee700
/////////////////////////////////////////////////////////////////////////
0:             ,"40","1","YES",null,null,null,null,"NO","NO"},
0:             {"","APP","V","NUM","4","INTEGER","10",null,"0","10","1","",null,null,null,null,"2","YES",null,null,null,null,"NO","NO"}};  
/////////////////////////////////////////////////////////////////////////
0:               null,null,null,null,"1","YES",null,null,null,null,"NO","NO"},
0:               null,null,null,null,"2","YES",null,null,null,null,"NO","NO"}};
0:               null,null,null,null,"1","YES",null,null,null,null,"NO","NO"},
0:               null,null,null,null,"2","YES",null,null,null,null,"NO","NO"},
0:               null,null,null,null,"3","YES",null,null,null,null,"NO","NO"}};
commit:bb40bcb
/////////////////////////////////////////////////////////////////////////
0:             {"SYSROLES", "1"},
0:             {"SYSSEQUENCES", "1"},
0:             {"SYSPERMS", "1"}    
/////////////////////////////////////////////////////////////////////////
0:             {"SYSROLES", "1"},
0:             {"SYSSEQUENCES", "1"},
0:             {"SYSPERMS", "1"}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7eb8268
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ViewsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertStatementErrorUnordered(
1:             new String[] {"X0Y23","X0Y23","X0Y23","X0X95"}, st,
1:         assertStatementErrorUnordered(
1:             new String[] {"X0Y23","X0Y23","X0Y23","X0Y23","X0X95"}, st,
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:53cbb53
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DatabaseMetaData;
0: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.Utilities;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure DatabaseMetaData.getColumns is correct when we have a view
1:      * created when there is an expression in the select list.
1:      * Also check the ResultSetMetaData
1:      * @throws SQLException
1:      */
1:     public void testViewMetaDataWithGeneratedColumnsDerby4230() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table A (id integer, data varchar(20), data2 integer)");
1:         s.executeUpdate("insert into A values (3, 'G', 5), (23, 'G', 4), (5, 'F', 1), (2, 'H', 4), (1, 'F', 5)");
1:         //DERBY-4230. Make sure DatabaseMetaData.getColumns does not include generated columns.
1:         // You need an expression in the select list.
1:         s.executeUpdate("create view V (data, num) as select data, data2 + 2 from A group by data, data2");
1:         DatabaseMetaData dmd = getConnection().getMetaData();
1:         ResultSet columns = dmd.getColumns(null, null, "V", null);
1:         String[][] expectedDBMetaRows = new String[][] {{"","APP","V","DATA","12","VARCHAR","20",null,null,null,"1","",null,null,null
0:             ,"40","1","YES",null,null,null,null,"NO"},
0:             {"","APP","V","NUM","4","INTEGER","10",null,"0","10","1","",null,null,null,null,"2","YES",null,null,null,null,"NO"}};  
1:         JDBC.assertFullResultSet(columns,expectedDBMetaRows);
1:         // Make sure ResultSetMetaData is right when selecting from view.
1:         // This wasn't a problem with DERBY-4230, but checking for good measure.
1:         ResultSet rs = s.executeQuery("SELECT * FROM V");        
1:         JDBC.assertColumnNames(rs, new String[] {"DATA","NUM"});
1:         JDBC.assertColumnTypes(rs, new int[] {java.sql.Types.VARCHAR, java.sql.Types.INTEGER});
1:         JDBC.assertNullability(rs,new boolean[] {true,true});
1:         // Finally check the results.
1:         String [][] expectedRows = new String[][] {{"F","3"},
1:             {"F","7"},
1:             {"G","6"},
1:             {"G","7"},
1:             {"H","6"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:         s.executeUpdate("DROP VIEW V");
1:         s.executeUpdate("DROP TABLE A");        
1:     }
commit:4fa5de9
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: public final class ViewsTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public ViewsTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("views Test");
1:         suite.addTest(TestConfiguration.embeddedSuite(ViewsTest.class));
0:         return suite;
1:     }
1: 
1:     public void test_views() throws Exception
1:     {
1:         ResultSet rs = null;
1:    
1:         Statement st = createStatement();
1: 
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1: 
1:         //   Licensed to the Apache Software Foundation (ASF) 
1:         // under one or more   contributor license agreements.  See 
1:         // the NOTICE file distributed with   this work for 
1:         // additional information regarding copyright ownership.   
1:         // The ASF licenses this file to You under the Apache 
1:         // License, Version 2.0   (the "License"); you may not use 
1:         // this file except in compliance with   the License.  You 
1:         // may obtain a copy of the License at      
1:         // http://www.apache.org/licenses/LICENSE-2.0   Unless 
1:         // required by applicable law or agreed to in writing, 
1:         // software   distributed under the License is distributed 
1:         // on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS 
1:         // OF ANY KIND, either express or implied.   See the 
1:         // License for the specific language governing permissions 
1:         // and   limitations under the License. tests for views set 
1:         // autocommit off
1:         
1:         getConnection().setAutoCommit(false);
1:         
1:         // create some tables
1:         
1:         st.executeUpdate(
1:             "create table t1(i int, s smallint, f float, dp "
1:             + "double precision)");
1:         
1:         st.executeUpdate(
1:             " create table t2(i int, s smallint, f float, dp "
1:             + "double precision)");
1:         
1:         st.executeUpdate(
1:             " create table insert_test (f float)");
1:         
1:         // create some views
1:         
1:         st.executeUpdate(
1:             "create view sv1 (s_was_i, dp_was_s, i_was_f, "
1:             + "f_was_dp) as select * from t1");
1:         
1:         st.executeUpdate(
1:             " create view sv2 as select * from t1");
1:         
1:         st.executeUpdate(
1:             " create view sv3 as select dp, f from t1 where i = s");
1:         
1:         st.executeUpdate(
1:             " create view sv4(i) as values 1, 2, 3");
1:         
1:         st.executeUpdate(
1:             " create view sv5 (c1) as select * from sv4");
1:         
1:         st.executeUpdate(
1:             " create view cv1 (t1_i, t2_s, t1_f, t2_dp) as "
1:             + "select t1.i, t2.s, t1.f, t2.dp from t1, t2 where "
1:             + "t1.i between t2.s and t2.i");
1:         
1:         st.executeUpdate(
1:             " create view cv2 as select * from sv1, sv3 where dp "
1:             + "= f_was_dp");
1:         
1:         st.executeUpdate(
1:             " create view cv3(i,s,f,dp) as select i, s, f, dp "
1:             + "from sv2 union select dp_was_s, s_was_i, f_was_dp, "
1:             + "i_was_f from sv1");
1:         
1:         st.executeUpdate(
1:             " create view cv4 (distinct_i) as select distinct i from t1");
1:         
1:         st.executeUpdate(
1:             " create view cv5(i,s) as select * from (select i, s "
1:             + "from cv3 where i = s) xyz");
1:         
1:         st.executeUpdate(
1:             " create view cv6 (c1, c2) as select a.c1 as x, b.c1 "
1:             + "as y from sv5 a, sv5 b where a.c1 <> b.c1");
1:         
1:         st.executeUpdate(
1:             " create view cv7 as select t.i, v.c1 from t1 t, cv6 "
1:             + "v where t.i = v.c1");
1:         
1:         st.executeUpdate(
1:             " create view cv8(col1, col2) as select 'Column 1',  "
1:             + "'Value = ' || cast(c1 as char(5)) from cv7 where 1 "
1:             + "in (select i from sv5)");
1:         
1:         // populate the tables
1:         
1:         st.executeUpdate(
1:             "insert into t1 values (1, 1, 1.0, 1.0)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values (1, 2, 3.0, 4.0)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values (8, 7, 6.0, 5.0)");
1:         
1:         st.executeUpdate(
1:             " insert into t2 values (1, 1, 1.0, 1.0)");
1:         
1:         st.executeUpdate(
1:             " insert into t2 values (1, 2, 3.0, 4.0)");
1:         
1:         st.executeUpdate(
1:             " insert into t2 values (8, 7, 6.0, 5.0)");
1:         
1:         // negative tests view with a parameter
1:         
1:         assertStatementError("42X98", st,
1:             "create view vneg as select * from t1 where i = ?");
1:         
1:         // drop view on table
1:         
1:         assertStatementError("X0Y16", st,
1:             "drop view t1");
1:         
1:         // drop table on view
1:         
1:         assertStatementError("42Y62", st,
1:             "drop table sv1");
1:         
1:         // views and tables share same name space
1:         
1:         assertStatementError("X0Y32", st,
1:             "create view sv1(i) as values 1");
1:         
1:         assertStatementError("X0Y32", st,
1:             " create table sv1 (c1 int)");
1:         
1:         assertStatementError("X0Y32", st,
1:             " create view t1(i) as values 1");
1:         
1:         // drop non-existant view
1:         
1:         assertStatementError("X0X05", st,
1:             "drop view notexists");
1:         
1:         // duplicate column name in view's column list
1:         
1:         assertStatementError("42Y13", st,
1:             "create view shouldntwork (c1, c2, c1) as select i, "
1:             + "s, f from t1");
1:         
1:         // # of columns in view's column list does not match that 
1:         // in view definition
1:         
1:         assertStatementError("42X56", st,
1:             "create view shouldntwork (c1, c2, c3) as select i, s from t1");
1:         
1:         assertStatementError("42X56", st,
1:             " create view shouldntwork (c1, c2, c3) as select i, "
1:             + "s, f, dp from t1");
1:         
1:         // try to drop a table out from under a view
1:         
1:         assertStatementError(new String[] {"X0Y23","X0Y23","X0Y23","X0Y23","X0Y23","X0Y23",
1:             "X0Y23","X0Y23","X0Y23","X0Y23"},st,
1:             "drop table t1");
1:         
1:         assertStatementError("X0Y23", st,
1:             " drop table t2");
1:         
1:         // try to drop a view out from under another view
1:         
1:         assertStatementError(new String[] {"X0Y23","X0Y23","X0Y23"}, st,
1:             "drop view sv1");
1:         
1:         assertStatementError("X0Y23", st,
1:             " drop view sv3");
1:         
1:         // try to drop a view out from under a cursor
1:         
1:         PreparedStatement ps_c1 = prepareStatement(
1:             "select * from cv8");
1:         
1:         ResultSet c1 = ps_c1.executeQuery();
1:         
1:         assertStatementError("X0X95", st,
1:             " drop view cv8");
1:         
0:         assertStatementError(new String[] {"X0Y23","X0Y23","X0Y23","X0X95"}, st,
1:             " drop view sv5");
1:         
0:         assertStatementError(new String[] {"X0Y23","X0Y23","X0Y23","X0Y23","X0X95"}, st,
1:             " drop view sv4");
1:         
1:         c1.close();
1:         ps_c1.close();
1:         
1:         // view updateability (No views are currently updateable)
1:         
1:         assertStatementError("42Y24", st,
1:             "insert into sv1 values 1");
1:         
1:         assertStatementError("42Y24", st,
1:             " delete from sv1");
1:         
1:         assertStatementError("42Y24", st,
1:             " update sv1 set s_was_i = 0");
1:         
1:         try {
1:         prepareStatement(
1:                 "select * from sv1 for update of s_was_i");
1:             fail("statement ps_c2 should not have succeeded");
1:         } catch (SQLException se) {
1:             assertSQLState("42Y90",se);
1:         }
1:         
1:         // create index on a view
1:         
1:         assertStatementError("42Y62", st,
1:             "create index i1 on sv2(i)");
1:         
1:         // positive tests
1:         
1:         rs = st.executeQuery(
1:             "select * from sv1");
1:         
1:         expColNames = new String [] {"S_WAS_I", "DP_WAS_S", "I_WAS_F", "F_WAS_DP"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1", "1.0", "1.0"},
1:             {"1", "2", "3.0", "4.0"},
1:             {"8", "7", "6.0", "5.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from sv2");
1:         
1:         expColNames = new String [] {"I", "S", "F", "DP"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1", "1.0", "1.0"},
1:             {"1", "2", "3.0", "4.0"},
1:             {"8", "7", "6.0", "5.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from sv3");
1:         
1:         expColNames = new String [] {"DP", "F"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1.0", "1.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from sv4");
1:         
1:         expColNames = new String [] {"I"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"2"},
1:             {"3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from sv5");
1:         
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"2"},
1:             {"3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv1");
1:         
1:         expColNames = new String [] {"T1_I", "T2_S", "T1_F", "T2_DP"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1", "1.0", "1.0"},
1:             {"1", "1", "3.0", "1.0"},
1:             {"8", "7", "6.0", "5.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv2");
1:         
1:         expColNames = new String [] {"S_WAS_I", "DP_WAS_S", "I_WAS_F", "F_WAS_DP", "DP", "F"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1", "1.0", "1.0", "1.0", "1.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv3");
1:         
1:         expColNames = new String [] {"I", "S", "F", "DP"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1", "1.0", "1.0"},
1:             {"1", "2", "3.0", "4.0"},
1:             {"2", "1", "4.0", "3.0"},
1:             {"7", "8", "5.0", "6.0"},
1:             {"8", "7", "6.0", "5.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv4 order by 1");
1:         
1:         expColNames = new String [] {"DISTINCT_I"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"8"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv5");
1:         
1:         expColNames = new String [] {"I", "S"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv6");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "2"},
1:             {"1", "3"},
1:             {"2", "1"},
1:             {"2", "3"},
1:             {"3", "1"},
1:             {"3", "2"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv7");
1:         
1:         expColNames = new String [] {"I", "C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1"},
1:             {"1", "1"},
1:             {"1", "1"},
1:             {"1", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from cv8");
1:         
1:         expColNames = new String [] {"COL1", "COL2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"Column 1", "Value = 1"},
1:             {"Column 1", "Value = 1"},
1:             {"Column 1", "Value = 1"},
1:             {"Column 1", "Value = 1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from (select * from cv3) x order by 1,2");
1:         
1:         expColNames = new String [] {"I", "S", "F", "DP"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1", "1.0", "1.0"},
1:             {"1", "2", "3.0", "4.0"},
1:             {"2", "1", "4.0", "3.0"},
1:             {"7", "8", "5.0", "6.0"},
1:             {"8", "7", "6.0", "5.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from (select * from cv4) x order by 1");
1:         
1:         expColNames = new String [] {"DISTINCT_I"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"8"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from (select * from cv5) x");
1:         
1:         expColNames = new String [] {"I", "S"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // verify that we can create and drop indexes on 
1:         // underlying tables
1:         
1:         st.executeUpdate(
1:             "create index i on t1(i)");
1:         
1:         st.executeUpdate(
1:             " drop index i");
1:         
1:         // verify the consistency of the indexes on the system 
1:         // catalogs
1:         
1:         rs = st.executeQuery(
1:             "select tablename, "
1:             + "SYSCS_UTIL.SYSCS_CHECK_TABLE('SYS', tablename) from "
1:             + "sys.systables where CAST(tabletype AS CHAR(1)) = "
0:             + "'S' and CAST(tablename AS VARCHAR(128)) != 'SYSDUMMY1'");
1:         
1:         expColNames = new String [] {"TABLENAME", "2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"SYSCONGLOMERATES", "1"},
0:             {"SYSTABLES", "1"},
0:             {"SYSCOLUMNS", "1"},
0:             {"SYSSCHEMAS", "1"},
0:             {"SYSCONSTRAINTS", "1"},
0:             {"SYSKEYS", "1"},
0:             {"SYSDEPENDS", "1"},
1:             {"SYSALIASES", "1"},
0:             {"SYSVIEWS", "1"},
1:             {"SYSCHECKS", "1"},
0:             {"SYSFOREIGNKEYS", "1"},
0:             {"SYSSTATEMENTS", "1"},
1:             {"SYSFILES", "1"},
0:             {"SYSTRIGGERS", "1"},
1:             {"SYSSTATISTICS", "1"},
1:             {"SYSTABLEPERMS", "1"},
0:             {"SYSCOLPERMS", "1"},
0:             {"SYSROUTINEPERMS", "1"},
0:             {"SYSROLES", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // test inserts from a view
1:         
1:         st.executeUpdate(
1:             "insert into insert_test select * from sv5");
1:         
1:         rs = st.executeQuery(
1:             " select * from insert_test");
1:         
1:         expColNames = new String [] {"F"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1.0"},
1:             {"2.0"},
1:             {"3.0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // drop the views
1:         
1:         st.executeUpdate(
1:             "drop view cv8");
1:         
1:         st.executeUpdate(
1:             " drop view cv7");
1:         
1:         st.executeUpdate(
1:             " drop view cv6");
1:         
1:         st.executeUpdate(
1:             " drop view cv5");
1:         
1:         st.executeUpdate(
1:             " drop view cv4");
1:         
1:         st.executeUpdate(
1:             " drop view cv3");
1:         
1:         st.executeUpdate(
1:             " drop view cv2");
1:         
1:         st.executeUpdate(
1:             " drop view cv1");
1:         
1:         st.executeUpdate(
1:             " drop view sv5");
1:         
1:         st.executeUpdate(
1:             " drop view sv4");
1:         
1:         st.executeUpdate(
1:             " drop view sv3");
1:         
1:         st.executeUpdate(
1:             " drop view sv2");
1:         
1:         st.executeUpdate(
1:             " drop view sv1");
1:         
1:         // drop the tables
1:         
1:         st.executeUpdate(
1:             "drop table t1");
1:         
1:         st.executeUpdate(
1:             " drop table t2");
1:         
1:         st.executeUpdate(
1:             " drop table insert_test");
1:         
1:         // verify the consistency of the indexes on the system 
1:         // catalogs
1:         
1:         rs = st.executeQuery(
1:             "select tablename, "
1:             + "SYSCS_UTIL.SYSCS_CHECK_TABLE('SYS', tablename) from "
1:             + "sys.systables where CAST(tabletype as CHAR(1)) = "
0:             + "'S' and CAST(tablename  as VARCHAR(128)) != 'SYSDUMMY1'");
1:         
1:         expColNames = new String [] {"TABLENAME", "2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"SYSCONGLOMERATES", "1"},
0:             {"SYSTABLES", "1"},
0:             {"SYSCOLUMNS", "1"},
0:             {"SYSSCHEMAS", "1"},
0:             {"SYSCONSTRAINTS", "1"},
0:             {"SYSKEYS", "1"},
0:             {"SYSDEPENDS", "1"},
1:             {"SYSALIASES", "1"},
0:             {"SYSVIEWS", "1"},
1:             {"SYSCHECKS", "1"},
0:             {"SYSFOREIGNKEYS", "1"},
0:             {"SYSSTATEMENTS", "1"},
1:             {"SYSFILES", "1"},
0:             {"SYSTRIGGERS", "1"},
1:             {"SYSSTATISTICS", "1"},
1:             {"SYSTABLEPERMS", "1"},
0:             {"SYSCOLPERMS", "1"},
0:             {"SYSROUTINEPERMS", "1"},
0:             {"SYSROLES", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // bug 2745
1:         
1:         st.executeUpdate(
1:             "CREATE TABLE orgtable ( name VARCHAR(255), "
1:             + "supervisorname VARCHAR(255), jobtitle VARCHAR(255) )");
1:         
1:         st.executeUpdate(
1:             " CREATE VIEW orgview AS SELECT name, "
1:             + "supervisorname, jobtitle FROM orgtable");
1:         
1:         rs = st.executeQuery(
1:             " SELECT name,jobtitle FROM orgview WHERE name IN "
1:             + "(SELECT supervisorname FROM orgview WHERE name LIKE "
1:             + "'WYATT%')");
1:         
1:         expColNames = new String [] {"NAME", "JOBTITLE"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         st.executeUpdate(
1:             " drop view orgview");
1:         
1:         st.executeUpdate(
1:             " drop table orgtable");
1:         
1:         // reset autocommit
1:         
1:         getConnection().setAutoCommit(true);
1:         
1:         // DERBY-1304 view not getting dropped The second drop 
1:         // view statement fails before the patch
1:         
1:         st.executeUpdate(
1:             "CREATE SCHEMA TEST_SCHEMA");
1:         
1:         st.executeUpdate(
1:             " CREATE TABLE TEST_SCHEMA.T1 (TABLE_COLUMN LONG VARCHAR)");
1:         
1:         st.executeUpdate(
1:             " CREATE VIEW TEST_SCHEMA.V1 AS SELECT TABLE_COLUMN "
1:             + "AS VIEW_COLUMN FROM TEST_SCHEMA.T1");
1:         
1:         st.executeUpdate(
1:             " DROP VIEW TEST_SCHEMA.V1");
1:         
1:         st.executeUpdate(
1:             " DROP TABLE TEST_SCHEMA.T1");
1:         
1:         st.executeUpdate(
1:             " DROP SCHEMA TEST_SCHEMA RESTRICT");
1:         
1:         // reiterate
1:         
1:         st.executeUpdate(
1:             "CREATE SCHEMA TEST_SCHEMA");
1:         
1:         st.executeUpdate(
1:             " CREATE TABLE TEST_SCHEMA.T1 (TABLE_COLUMN LONG VARCHAR)");
1:         
1:         st.executeUpdate(
1:             " CREATE VIEW TEST_SCHEMA.V1 AS SELECT TABLE_COLUMN "
1:             + "AS VIEW_COLUMN FROM TEST_SCHEMA.T1");
1:         
1:         st.executeUpdate(
1:             " DROP VIEW TEST_SCHEMA.V1");
1:         
1:         st.executeUpdate(
1:             " DROP TABLE TEST_SCHEMA.T1");
1:         
1:         st.executeUpdate(
1:             " DROP SCHEMA TEST_SCHEMA RESTRICT");
1:         
1:         // DERBY-2018 expect error
1:         
1:         assertStatementError("42X07", st,
1:             "CREATE VIEW v1(c1) AS VALUES NULL");
1:         
1:         // DERBY-681
1:         
1:         st.executeUpdate(
1:             "create table o (name varchar(20), ord int)");
1:         
1:         st.executeUpdate(
1:             " create table a (ord int, amount int)");
1:         
1:         st.executeUpdate(
1:             " create view v1 (vx, vy) as select name, sum(ord) "
1:             + "from o where ord > 0 group by name, ord");
1:         
1:         st.executeUpdate(
1:             " create view v2 (vx, vy) as select name, sum(ord) "
1:             + "from o where ord > 0 group by name, ord having ord "
1:             + "<= ANY (select ord from a)");
1:         
1:         st.executeUpdate(
1:             " drop view v2");
1:         
1:         st.executeUpdate(
1:             " drop view v1");
1:         
1:         st.executeUpdate(
1:             " drop table a");
1:         
1:         st.executeUpdate(
1:             " drop table o");
1:         
1:         
1:         
1:         getConnection().rollback();
1:         st.close();
1:     }
1: }
============================================================================