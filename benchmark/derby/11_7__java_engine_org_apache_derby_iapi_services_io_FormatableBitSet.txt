11:eac0369: /*
95:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.io.FormatableBitSet
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
16:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.io;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
6:eac0369: /**
1:eac0369:  * FormatableBitSet is implemented as a packed array of bytes.
10:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class FormatableBitSet implements Formatable, Cloneable
62:eac0369: {
1:eac0369: 
1:eac0369: 	/********************************************************
1:eac0369: 	**
1:eac0369: 	**	This class implements Formatable. That means that it
1:eac0369: 	**	can write itself to and from a formatted stream. If
1:eac0369: 	**	you add more fields to this class, make sure that you
1:eac0369: 	**	also write/read them with the writeExternal()/readExternal()
1:eac0369: 	**	methods.
1:eac0369: 	**
1:eac0369: 	**	If, inbetween releases, you add more fields to this class,
1:eac0369: 	**	then you should bump the version number emitted by the getTypeFormatId()
1:eac0369: 	**	method.
1:eac0369: 	**
1:eac0369: 	********************************************************/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	** Bits are stored as an array of bytes.
1:eac0369: 	** Bits are numbered starting at 0.  Bits
1:eac0369: 	** 0..7 go in byte[0], 8..15 in byte[1] and so on.
1:eac0369: 	** The number of bytes is tracked as part
1:eac0369: 	** of the byte array.  The number of bits
1:eac0369: 	** being used is derived by the number of
1:eac0369: 	** bytes being used and the number of bits
1:eac0369: 	** being used by the last byte.  The partially
1:eac0369: 	** unused byte is always byte[byte.length] with the
1:eac0369: 	** lowest bits being unused.
1:eac0369: 	**
1:eac0369: 	** Zero length bits are stored using a
1:eac0369: 	** zero length byte array, with all bits
1:eac0369: 	** marked as unused.
1:eac0369: 	*/
1:8bb781c: 	// value is never null. An empty bitset is represented by a
1:8bb781c: 	// zero-length array.
1:eac0369: 	private byte[]	value;
1:65a2bbd: 	private	byte	bitsInLastByte;
1:eac0369: 
1:eac0369: 	private transient int	lengthAsBits;
1:eac0369: 
1:65a2bbd: 	private final void checkPosition(int p) {
1:aa13c70: 		if (p < 0 || lengthAsBits <= p) {
1:65a2bbd: 			throw new
1:aa13c70: 				IllegalArgumentException("Bit position "+p+
1:aa13c70: 										 " is outside the legal range");
1:aa13c70: 		}
1:aa13c70: 	}
1:aa13c70: 
1:65a2bbd: 	// Division, multiplication and remainder calcuation of a positive
1:65a2bbd: 	// number with a power of two can be done using shifts and bit
1:65a2bbd: 	// masking. The compiler attempts this optimization but since Java
1:65a2bbd: 	// does not have unsigned ints it will also have to create code to
1:65a2bbd: 	// handle negative values. In this class the argument is
1:65a2bbd: 	// frequently an array index or array length, which is known not
1:65a2bbd: 	// to be negative. These utility methods allow us to perform
1:65a2bbd: 	// "unsigned" operations with 8. Hopefully the extra function call
1:65a2bbd: 	// will be inlined by the compiler.
1:65a2bbd: 	private static int udiv8(int i) { return (i>>3); }
1:65a2bbd: 	private static byte umod8(int i) { return (byte)(i&0x7); }
1:17711ec: 	private static int umul8(int i) { return (i<<3); }
1:65a2bbd: 
1:6b23802: 	/**
1:eac0369: 	 * Niladic Constructor
1:eac0369: 	 */
1:eac0369: 	public FormatableBitSet()
1:eac0369: 	{
1:bb5be6f: 		value = ArrayUtil.EMPTY_BYTE_ARRAY;
50:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructs a Bit with the initial number of bits
1:eac0369: 	 */
1:eac0369: 	public FormatableBitSet(int numBits)
1:eac0369: 	{
1:65a2bbd: 		if (numBits < 0) {
1:65a2bbd: 			throw new
1:65a2bbd: 			IllegalArgumentException("Bit set size "+ numBits +
1:65a2bbd: 									 " is not allowed");
1:65a2bbd: 		}
1:eac0369: 		initializeBits(numBits);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void initializeBits(int numBits)
1:eac0369: 	{
1:eac0369: 		int numBytes = numBytesFromBits(numBits);
1:eac0369: 
1:eac0369: 		// the byte array is zero'ed out by the new operator
1:eac0369: 		value = new byte[numBytes];
2:eac0369: 		bitsInLastByte = numBitsInLastByte(numBits);
2:eac0369: 		lengthAsBits = numBits;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructs a Bit from an array of bytes.  Assume
1:eac0369: 	 * bytes are all being used.
1:eac0369: 	 *
2:eac0369: 	 * @param newValue	The array of bytes to make up the new Bit
1:eac0369: 	 */
1:eac0369: 	public FormatableBitSet(byte[] newValue)
1:eac0369: 	{
1:6b23802: 		value = ArrayUtil.copy( newValue );
1:eac0369: 		bitsInLastByte = 8;
1:eac0369: 		lengthAsBits = calculateLength(newValue.length);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Copy constructor
1:eac0369: 	 *
1:eac0369: 	 * @param original the FormatableBitSet to make a copy from
1:eac0369: 	 */
1:eac0369: 	public FormatableBitSet (FormatableBitSet original)
1:eac0369: 	{
10:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 original != null, "cannot make copy from a null FormatableBitSet");
1:eac0369: 
1:eac0369: 		bitsInLastByte = original.bitsInLastByte;
1:eac0369: 		lengthAsBits = original.lengthAsBits;
1:eac0369: 
1:eac0369: 		int lenInBytes = FormatableBitSet.numBytesFromBits(original.lengthAsBits);
3:eac0369: 		value = new byte[lenInBytes];
1:eac0369: 		if (lenInBytes > 0)
1:eac0369: 			System.arraycopy(original.value, 0, value, 0, lenInBytes);
1:eac0369: 	}
1:eac0369: 			
1:eac0369: 	/*
1:eac0369: 	 * Cloneable
1:eac0369: 	 */
1:eac0369: 	public Object clone()
1:eac0369: 	{
1:eac0369: 		return new FormatableBitSet(this);
1:eac0369: 	}
1:eac0369: 
1:c7205c1: 	/**
1:c7205c1: 	 * This method returns true if the following conditions hold:
1:c7205c1: 	 * 1. The number of bits in the bitset will fit into the allocated
1:c7205c1: 	 * byte array. 2. 'lengthAsBits' and 'bitsInLastByte' are
1:c7205c1: 	 * consistent. 3. All unused bits in the byte array are
1:c7205c1: 	 * unset. This represents an invariant for the class, so this
1:c7205c1: 	 * method should always return true.
1:c7205c1: 	 *
1:c7205c1: 	 * The method is public, but is primarily intended for testing and
1:c7205c1: 	 * ASSERTS.
1:01bb780: 	 * @return true if invariant holds, false otherwise
1:c7205c1: 	 */
1:c7205c1: 	public boolean invariantHolds() {
1:c7205c1: 		// Check that all bits will fit in byte array
1:c7205c1: 		final int arrayLengthAsBits = value.length*8;
1:c7205c1: 		if (lengthAsBits > arrayLengthAsBits) { return false; }
1:c7205c1: 
1:c7205c1: 		// Check consistency of 'lengthAsBits' and 'bitsInLastByte'
1:c7205c1: 		final int partialByteIndex = (lengthAsBits-1)/8;
1:c7205c1: 		if (bitsInLastByte != (lengthAsBits - (8*partialByteIndex))) {
1:c7205c1: 			return false;
1:c7205c1: 		}
1:c7205c1: 		// Special case for empty bitsets since they will have
1:c7205c1: 		// 'partialByteIndex'==0, but this isn't a legal index into
1:c7205c1: 		// the byte array
1:c7205c1: 		if (value.length==0) { return true; }
1:c7205c1: 
1:c7205c1: 		// Check that the last used (possibly partial) byte doesn't
1:c7205c1: 		// contain any unused bit positions that are set.
1:c7205c1: 		byte partialByte = value[partialByteIndex];
1:c7205c1: 		partialByte <<= bitsInLastByte;  // must be zero after shift
1:c7205c1: 
1:c7205c1: 		// Check the remaining completely unused bytes (if any)
1:c7205c1: 		for (int i = partialByteIndex+1; i < value.length; ++i) {
1:c7205c1: 			partialByte |= value[i];
1:c7205c1: 		}
1:c7205c1: 		return (partialByte==0);
1:c7205c1: 	}
1:c7205c1: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the length in bytes of a Bit value
1:eac0369: 	 *
1:eac0369: 	 * @return	The length in bytes of this value
1:eac0369: 	 */
1:eac0369: 	public int getLengthInBytes()
1:eac0369: 	{
1:eac0369: 		return FormatableBitSet.numBytesFromBits(lengthAsBits);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	** Get the length in bits
1:eac0369: 	**
1:eac0369: 	** @return The length in bits for this value
1:eac0369: 	**
1:eac0369: 	** NOTE: could possibly be changed to a long.  As is
1:dbed020: 	** we are restricted to 2^(31-3) -&gt; 256meg instead
1:eac0369: 	** of 2^31 (Integer.MAX_VALUE) like other datatypes
1:eac0369: 	** (or 2 gig).  If it is ever changed to a long
1:eac0369: 	** be sure to change read/writeExternal which write
1:eac0369: 	** out the length in bits.
1:eac0369: 	*/
1:eac0369: 	public int getLength() {
1:eac0369: 		return lengthAsBits;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int calculateLength(int realByteLength)
1:eac0369: 	{
1:eac0369: 		if (realByteLength == 0)
1:eac0369: 		{
3:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ((realByteLength - 1) * 8) + bitsInLastByte;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the length in bits -- alias for getLength()
1:eac0369: 	 *
1:eac0369: 	 * @return The length in bits for this value
1:eac0369: 	 */
1:eac0369: 	public int size()
1:eac0369: 	{
1:eac0369: 		return getLength();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the value of the byte array
1:eac0369: 	 *
2:eac0369: 	 * @return	The value of the byte array
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public byte[] getByteArray()
1:eac0369: 	{
1:eac0369: 		// In some cases the array is bigger than the actual number
1:eac0369: 		// of valid bytes.
1:eac0369: 		int realByteLength = getLengthInBytes();
1:eac0369: 
1:eac0369: 		// Currently the case is that the return from this
1:eac0369: 		// call only includes the valid bytes.
1:eac0369: 		if (value.length != realByteLength) {
1:eac0369: 			byte[] data = new byte[realByteLength];
1:eac0369: 			System.arraycopy(value, 0, data, 0, realByteLength);
1:eac0369: 
1:eac0369: 			value = data;
1:eac0369: 		}
1:eac0369: 
1:6b23802: 		return ArrayUtil.copy( value );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:8a6ea6d: 	 * Grow (widen) a FormatableBitSet so that it contains at least N
1:8a6ea6d: 	 * bits. If the bitset already has more than n bits, this is a
1:8a6ea6d: 	 * noop. Negative values of n are not allowed.
1:8a6ea6d: 	 * ASSUMPTIONS: that all extra bits in the last byte are
1:8a6ea6d: 	 * zero.
1:eac0369: 	 *
1:eac0369: 	 * @param n	The number of bits you want.  The bits are
1:eac0369: 	 *			always added as 0 and are appended to the
1:eac0369: 	 *			least significant end of the bit array.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void grow(int n)
1:eac0369: 	{
1:3f2dd5c: 		if (SanityManager.DEBUG) {
1:3f2dd5c: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1:3f2dd5c: 		}
1:3f2dd5c: 
1:8a6ea6d:  		if (n < 0) {
1:8a6ea6d:  			throw new IllegalArgumentException("Bit set cannot grow from "+
1:8a6ea6d:  											   lengthAsBits+" to "+n+" bits");
1:8a6ea6d:  		}
1:8a6ea6d: 		if (n <= lengthAsBits) {
1:8a6ea6d:  			return;
1:8a6ea6d:  		}
1:eac0369: 
1:eac0369: 		int newNumBytes = FormatableBitSet.numBytesFromBits(n);
1:eac0369: 
1:eac0369: 		// is there enough room in the existing array
1:3f2dd5c: 		if (newNumBytes > value.length) {
1:eac0369: 			/*
1:eac0369: 			** We didn't have enough bytes in value, so we need
1:eac0369: 			** to create a bigger byte array and use that.
1:eac0369: 			*/
1:eac0369: 			byte[] newValue = new byte[newNumBytes];
1:eac0369: 
1:3f2dd5c: 			int oldNumBytes = getLengthInBytes();
1:eac0369: 			System.arraycopy(value, 0, newValue, 0, oldNumBytes);
1:eac0369: 
3:eac0369: 			value = newValue;
1:65a2bbd: 		}
1:eac0369: 		bitsInLastByte = numBitsInLastByte(n);
2:eac0369: 		lengthAsBits = n;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:8a6ea6d: 	 * Shrink (narrow) a FormatableBitSet to N bits. N may not be
1:8a6ea6d: 	 * larger than the current bitset size, or negative.
1:eac0369: 	 *
1:eac0369: 	 * @param n	The number of bits the caller wants.  The
1:eac0369: 	 * 			bits are always removed from the
1:eac0369: 	 *			least significant end of the bit array.
1:eac0369: 	 */
1:8a6ea6d: 	public void shrink(int n)
1:eac0369: 	{
1:3f2dd5c: 		if (SanityManager.DEBUG) {
1:3f2dd5c: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1:3f2dd5c: 		}
1:3f2dd5c: 
1:8a6ea6d: 		if (n < 0 || n > lengthAsBits) {
1:aa13c70: 			throw new
1:8a6ea6d: 				IllegalArgumentException("Bit set cannot shrink from "+
1:8a6ea6d: 										 lengthAsBits+" to "+n+" bits");
1:eac0369: 		}
1:eac0369: 
1:8a6ea6d: 		final int firstUnusedByte = numBytesFromBits(n);
1:eac0369: 		bitsInLastByte = numBitsInLastByte(n);
1:eac0369: 		lengthAsBits = n;
1:eac0369: 
1:8a6ea6d: 		for (int i = firstUnusedByte; i < value.length; ++i) {
1:8a6ea6d: 			value[i] = 0;
1:eac0369: 		}
1:8a6ea6d: 		if (firstUnusedByte > 0) {
1:8a6ea6d: 			// Mask out any left over bits in the
1:8a6ea6d: 			// last byte.  Retain the highest bits.
1:8a6ea6d: 			value[firstUnusedByte-1] &= 0xff00 >> bitsInLastByte;
1:8a6ea6d: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Some of the operators required by SQL.  These could alternatively
1:eac0369: 	** be in SQLBit, but since they are so tightly bound to the implementation
1:eac0369: 	** rather than return something that undermines the encapsulation
1:eac0369: 	** of this type, i have chosen to put them in here.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bit equivalence.  Compare this with other.
1:eac0369: 	 * If the length is different, then cannot be
1:eac0369: 	 * equal so short circuit.  Otherwise, rely on
1:eac0369: 	 * compare().  Note that two zero length bits are
1:eac0369: 	 * considered equal.
1:eac0369: 	 *
1:eac0369: 	 * @param other	the other bit to compare to
1:eac0369: 	 *
1:eac0369: 	 * @return TRUE|FALSE
1:eac0369: 	 */
1:65014c5: 	public boolean equals(Object other)
1:eac0369: 	{
1:65014c5:         if (other instanceof FormatableBitSet) 
1:65014c5:         {
1:65014c5:             FormatableBitSet that = (FormatableBitSet) other;
1:65014c5: 		    if (this.getLength() != that.getLength())
1:65014c5: 		    {
1:65014c5: 			    return false;
1:65014c5: 		    }
1:eac0369: 
1:65014c5: 		    return (this.compare(that) == 0);
1:65014c5:         }
1:65014c5:         return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bit comparison.  Compare this with other.
1:eac0369: 	 * Will always do a byte by byte compare.
1:eac0369: 	 *
1:eac0369: 	 * Given 2 similar bits of unequal lengths (x and y),
1:dbed020: 	 * where x.getLength() &lt; y.getLength() but where:
1:eac0369: 	 *
1:eac0369: 	 *	 x[0..x.getLength()] == y[0..x.getLength()]
1:eac0369: 	 *
1:dbed020: 	 * then x &lt; y.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param other the other bit to compare to
1:eac0369: 	 *
1:dbed020: 	 * @return -1	- if other &lt;  this
1:eac0369: 	 *			0	- if other == this
1:dbed020: 	 *			1	- if other &gt;  this
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public int compare(FormatableBitSet other)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		int		otherCount, thisCount;
1:eac0369: 		int		otherLen, thisLen;
1:eac0369: 		byte[]	otherb;
1:eac0369: 
1:eac0369: 		otherb = other.value;
1:eac0369: 		otherLen = other.getLengthInBytes();
1:eac0369: 		thisLen = getLengthInBytes();
1:eac0369: 		for (otherCount = 0, thisCount = 0;
1:eac0369: 				otherCount < otherLen && thisCount < thisLen;
1:eac0369: 				otherCount++, thisCount++)
1:eac0369: 		{
1:eac0369: 			if (otherb[otherCount] != this.value[thisCount])
18:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** '==' if byte by byte comparison is identical and
1:eac0369: 		** exact same length in bits (not bytes).
1:eac0369: 		*/
1:eac0369: 		if ((otherCount == otherLen) && (thisCount == thisLen))
1:eac0369: 		{
1:eac0369: 				if (this.getLength() == other.getLength())
1:eac0369: 				{
1:eac0369: 					return 0;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If subset of bits is identical, return 1
1:eac0369: 				** if other.getLength() > this.getLength(); otherwise,
1:eac0369: 				** -1
1:eac0369: 				*/
1:eac0369: 				return (other.getLength() < this.getLength()) ? 1 : -1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (otherCount == otherLen)
1:eac0369: 		{
2:eac0369: 			return 1;
1:eac0369: 		}
1:eac0369: 		else if (thisCount == thisLen)
1:eac0369: 		{
2:eac0369: 			return -1;
1:eac0369: 		}
4:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Ok, we have a difference somewhere.  Now
1:eac0369: 			** we have to go to the trouble of converting
1:eac0369: 			** to a int and masking out the sign to get
1:eac0369: 			** a valid comparision because bytes are signed.
1:eac0369: 			*/
1:eac0369: 			int otherInt, thisInt;
1:eac0369: 
1:eac0369: 			otherInt = (int)otherb[otherCount];
1:eac0369: 			otherInt &= (0x100 - 1);
1:eac0369: 
1:eac0369: 			thisInt = (int)this.value[thisCount];
1:eac0369: 			thisInt &= (0x100 - 1);
1:eac0369: 
1:eac0369: 			return (thisInt > otherInt) ? 1 : -1;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Produce a hash code by putting the value bytes into an int, exclusive OR'ing
1:eac0369:      * if there are more than 4 bytes.
1:eac0369:      *
1:eac0369:      * @return the hash code
1:eac0369:      */
1:eac0369:     public int hashCode()
1:eac0369:     {
1:eac0369:         int code = 0;
1:eac0369:         int i;
1:eac0369:         int shift = 0;
1:eac0369: 
1:eac0369: 		int byteLength = getLengthInBytes();
1:eac0369:         for( i = 0; i < byteLength; i++)
1:eac0369:         {
1:eac0369:             code ^= (value[i] & 0xff)<<shift;
1:eac0369:             shift += 8;
1:eac0369:             if( 32 <= shift)
1:eac0369:                 shift = 0;
1:eac0369:         }
1:eac0369:         return code;
1:eac0369:     }
1:eac0369:     
1:eac0369: 	/**
1:eac0369: 	 * Bit isSet
1:eac0369: 	 *
1:eac0369: 	 * @param position	the bit to check
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public final boolean isSet(int position)
1:eac0369: 	{
1:aa13c70: 		checkPosition(position);
1:65a2bbd: 		final int byteIndex = udiv8(position);
1:65a2bbd: 		final byte bitIndex = umod8(position);
1:65a2bbd: 		return ((value[byteIndex] & (0x80>>bitIndex)) != 0);
1:eac0369: 	}
1:65a2bbd: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bit get -- alias for isSet()
1:eac0369: 	 *
1:eac0369: 	 * @param position	the bit to check
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public final boolean get(int position)
1:eac0369: 	{
1:eac0369: 		return isSet(position);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Bit set
1:eac0369: 	 *
1:eac0369: 	 * @param position	the bit to set
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void set(int position)
1:eac0369: 	{
1:aa13c70: 		checkPosition(position);
1:65a2bbd: 		final int byteIndex = udiv8(position);
1:65a2bbd: 		final byte bitIndex = umod8(position);
1:65a2bbd: 		value[byteIndex] |= (0x80>>bitIndex);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bit clear
1:eac0369: 	 *
1:eac0369: 	 * @param position	the bit to clear
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void clear(int position)
1:eac0369: 	{
1:aa13c70: 		checkPosition(position);
1:65a2bbd: 		final int byteIndex = udiv8(position);
1:65a2bbd: 		final byte bitIndex = umod8(position);
1:65a2bbd: 		value[byteIndex] &= ~(0x80>>bitIndex);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Clear all the bits in this FormatableBitSet
1:eac0369: 	  */
1:eac0369: 	public void clear()
1:eac0369: 	{
1:eac0369: 		int byteLength = getLengthInBytes();
1:eac0369: 		for (int ix=0; ix < byteLength; ix++)
1:eac0369:             value[ix] = 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	* Figure out how many bytes are needed to
1:eac0369: 	* store the input number of bits.
1:eac0369: 	*
1:eac0369: 	* @param bits	bits
1:eac0369: 	*
1:eac0369: 	* @return	the number of bytes
1:eac0369: 	*/
1:9fdfb40: 	private static int numBytesFromBits(int bits) {
1:9fdfb40: 		return (bits + 7) >> 3;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	* Figure out how many bits are in the last
1:eac0369: 	* byte from the total number of bits.
1:eac0369: 	*
1:eac0369: 	* @param	bits	bits
1:eac0369: 	*
1:eac0369: 	* @return	the number of bits
1:eac0369: 	*/
1:65a2bbd: 	private static byte
1:eac0369: 	numBitsInLastByte(int bits)
1:eac0369: 	{
1:65a2bbd: 		if (bits == 0) return 0;
1:65a2bbd: 		byte lastbits = umod8(bits);
1:65a2bbd: 		return (lastbits != 0 ? lastbits : 8);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Format the string into BitSet format: {0, 2, 4, 8} if bits 0, 2, 4, 8
1:eac0369: 	 * are set.
1:eac0369: 	 *
1:eac0369: 	 * @return A new String containing the formatted Bit value
1:eac0369: 	 */
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		{
1:eac0369: 			// give it a reasonable size
1:eac0369: 			StringBuffer str = new StringBuffer(getLength()*8*3);
1:eac0369: 			str.append("{");
1:eac0369: 			boolean first = true;
1:9fdfb40: 			for (int inPosition = 0; inPosition < getLength(); inPosition++)
1:eac0369: 			{
1:eac0369: 				if (isSet(inPosition))
1:eac0369: 				{
1:eac0369: 					if (!first)
1:eac0369: 						str.append(", ");
1:eac0369: 					first = false;
1:eac0369: 					str.append(inPosition);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			str.append("}");
1:eac0369: 			return new String(str);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Statically calculates how many bits can fit into the number of
1:eac0369: 	 * bytes if this Bit object is externalized.  Only valid for this
1:eac0369: 	 * implementation of Bit.
1:eac0369: 	 */
1:eac0369: 	public static int maxBitsForSpace(int numBytes)
1:eac0369: 	{
1:eac0369: 		return (numBytes - 4)*8;
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:17711ec: 	 * A utility method which treats the byte argument as an 8-bit
1:17711ec: 	 * bitset and finds the first set bit in that byte. Assumes that
1:17711ec: 	 * at least one bit in v is set (v!=0).
1:5f9b827: 	 * @param v a non-zero byte to check for set bits
1:17711ec: 	 * @return the zero-based index of the first set bit in the argument byte
1:eac0369: 	 */
1:17711ec: 	private static byte firstSet(byte v) {
1:17711ec: 		if ((v & 0x80) != 0) {
1:17711ec: 			return 0;
1:eac0369: 		}
1:17711ec: 		if ((v & 0x40) != 0) {
1:17711ec: 			return 1;
1:eac0369: 		}
1:17711ec: 		if ((v & 0x20) != 0) {
1:17711ec: 			return 2;
1:17711ec: 		}
1:17711ec: 		if ((v & 0x10) != 0) {
1:17711ec: 			return 3;
1:17711ec: 		}
1:17711ec: 		if ((v & 0x8) != 0) {
1:17711ec: 			return 4;
1:17711ec: 		}
1:17711ec: 		if ((v & 0x4) != 0) {
1:17711ec: 			return 5;
1:17711ec: 		}
1:17711ec: 		if ((v & 0x2) != 0) {
1:17711ec: 			return 6;
1:17711ec: 		}
1:17711ec: 		return 7;
1:17711ec: 	}
1:eac0369: 
1:17711ec: 	/**
1:17711ec: 	 * If any bit is set, return the zero-based bit index of the first
1:17711ec: 	 * bit that is set. If no bit is set, return -1. By using
1:17711ec: 	 * anySetBit() and anySetBit(beyondBit), one can quickly go thru
1:17711ec: 	 * the entire bit array to return all set bit.
1:17711ec: 	 *
1:17711ec: 	 * @return the zero-based index of the first bit that is set, or
1:17711ec: 	 * -1 if no bit is set
1:17711ec: 	 */
1:17711ec: 	public int anySetBit() {
1:17711ec: 		if (SanityManager.DEBUG) {
1:17711ec: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1:17711ec: 		}
1:17711ec: 		final int numbytes = getLengthInBytes();
1:17711ec: 		for (int i = 0; i < numbytes; ++i) {
1:17711ec: 			final byte v = value[i];
1:17711ec: 			if (v == 0) continue;
1:17711ec: 			return (umul8(i) + firstSet(v));
1:17711ec: 		}
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Like anySetBit(), but return any set bit whose number is bigger than
1:eac0369: 	 * beyondBit. If no bit is set after beyondBit, -1 is returned. 
1:eac0369: 	 * By using anySetBit() and anySetBit(beyondBit), one can quickly go
1:eac0369: 	 * thru the entire bit array to return all set bit.
1:eac0369: 	 *
1:7d0f620: 	 * @param beyondBit Only look at bit that is greater than this bit number.
1:7d0f620: 	 *                  Supplying a value of -1 makes the call equivalent to
1:7d0f620: 	 *                  anySetBit().
1:eac0369: 	 * @return the bit number of a bit that is set, or -1 if no bit after
1:eac0369: 	 * beyondBit is set
1:eac0369: 	 */
1:17711ec: 	public int anySetBit(int beyondBit) {
1:17711ec: 		if (SanityManager.DEBUG) {
1:17711ec: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1:eac0369: 		}
1:17711ec: 		if (++beyondBit >= lengthAsBits) {
1:eac0369: 			return -1;
1:eac0369: 		}
1:17711ec: 		int i = udiv8(beyondBit);
1:17711ec: 		byte v = (byte)(value[i] << umod8(beyondBit));
1:17711ec: 		if (v != 0) {
1:17711ec: 			return (beyondBit + firstSet(v));
1:eac0369: 		}
1:17711ec: 		final int numbytes = getLengthInBytes();
1:17711ec: 		for (++i; i < numbytes; ++i) {
1:17711ec: 			v = value[i];
1:17711ec: 			if (v == 0) continue;
1:17711ec: 			return (umul8(i) + firstSet(v));
1:eac0369: 		}
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c7205c1: 	 * Bitwise OR this FormatableBitSet with another
1:c7205c1: 	 * FormatableBitSet. The result is stored in this bitset. The
1:c7205c1: 	 * operand is unaffected. A null operand is treated as an empty
1:c7205c1: 	 * bitset (i.e. a noop). A bitset that is smaller than its operand
1:c7205c1: 	 * is expanded to the same size.
1:eac0369: 	 *
1:c7205c1: 	 * @param otherBit bitset operand
1:eac0369: 	 */
1:eac0369: 	public void or(FormatableBitSet otherBit)
1:eac0369: 	{
1:c7205c1: 		if (otherBit == null) {
6:eac0369: 			return;
1:c7205c1: 		}
1:eac0369: 		int otherLength = otherBit.getLength();
1:eac0369: 
1:c7205c1: 		if (otherLength > getLength()) {
1:c7205c1: 			grow(otherLength);
1:c7205c1: 		}
1:eac0369: 
1:8564463: 		int obByteLen = otherBit.getLengthInBytes();
1:c7205c1: 		for (int i = 0; i < obByteLen; ++i) {
1:8564463: 			value[i] |= otherBit.value[i];
1:c7205c1: 		}
1:c7205c1: 		if (SanityManager.DEBUG) {
1:c7205c1: 			SanityManager.ASSERT(invariantHolds(),"or() broke invariant");
1:c7205c1: 		}
1:eac0369: 	}
1:8564463: 
1:eac0369:     /**
1:6b23802:      * Copy the bytes from another FormatableBitSet. Assumes that this bit set
1:6b23802:      * is at least as large as the argument's bit set.
1:6b23802:      */
1:6b23802:     public  void    copyFrom( FormatableBitSet that )
1:6b23802:     {
1:6b23802:         System.arraycopy( that.getByteArray(), 0, value, 0, that.getLengthInBytes());
1:6b23802:     }
1:6b23802: 
1:eac0369: 	/**
1:c7205c1: 	 * Bitwise AND this FormatableBitSet with another
1:c7205c1: 	 * FormatableBitSet. The result is stored in this bitset. The
1:c7205c1: 	 * operand is unaffected. A null operand is treated as an empty
1:c7205c1: 	 * bitset (i.e. clearing this bitset). A bitset that is smaller
1:c7205c1: 	 * than its operand is expanded to the same size.
1:c7205c1: 	 * @param otherBit bitset operand
1:eac0369: 	 */
1:eac0369: 	public void and(FormatableBitSet otherBit)
1:eac0369: 	{
1:c7205c1: 		if (otherBit == null) {
1:c7205c1: 			clear();
1:c7205c1: 			return;
1:c7205c1: 		}
1:eac0369: 		int otherLength = otherBit.getLength();
1:eac0369: 
1:c7205c1: 		if (otherLength > getLength()) {
1:c7205c1: 			grow(otherLength);
1:eac0369: 		}
1:eac0369: 
1:c7205c1: 		// Since this bitset is at least as large as the other bitset,
1:c7205c1: 		// one can use the length of the other bitset in the iteration
1:c7205c1: 		int byteLength = otherBit.getLengthInBytes();
1:c7205c1: 		int i = 0;
1:c7205c1: 		for (; i < byteLength; ++i) {
1:eac0369: 			value[i] &= otherBit.value[i];
1:c7205c1: 		}
1:c7205c1: 
1:c7205c1: 		// If the other bitset is shorter the excess bytes in this
1:c7205c1: 		// bitset must be cleared
1:c7205c1: 		byteLength = getLengthInBytes();
1:c7205c1: 		for (; i < byteLength; ++i) {
1:c7205c1: 			value[i] = 0;
1:c7205c1: 		}
1:c7205c1: 		if (SanityManager.DEBUG) {
1:c7205c1: 			SanityManager.ASSERT(invariantHolds(),"and() broke invariant");
1:c7205c1: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c7205c1: 	 * Bitwise XOR this FormatableBitSet with another
1:c7205c1: 	 * FormatableBitSet. The result is stored in this bitset. The
1:c7205c1: 	 * operand is unaffected. A null operand is treated as an empty
1:c7205c1: 	 * bitset (i.e. a noop). A bitset that is smaller than its operand
1:c7205c1: 	 * is expanded to the same size.
1:c7205c1: 	 * @param otherBit bitset operand
1:eac0369: 	 */
1:c7205c1: 	public void xor(FormatableBitSet otherBit)
1:eac0369: 	{
1:c7205c1: 		if (otherBit == null) {
1:c7205c1: 			return;
1:c7205c1: 		}
1:c7205c1: 		int otherLength = otherBit.getLength();
1:c7205c1: 		if (otherLength > getLength()) {
1:c7205c1: 			grow(otherLength);
1:eac0369: 		}
1:eac0369: 
1:c7205c1: 		int obByteLen = otherBit.getLengthInBytes();
1:c7205c1: 		for (int i = 0; i < obByteLen; ++i) {
1:c7205c1: 			value[i] ^= otherBit.value[i];
1:c7205c1: 		}
1:c7205c1: 		if (SanityManager.DEBUG) {
1:c7205c1: 			SanityManager.ASSERT(invariantHolds(),"xor() broke invariant");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a count of the number of bits that are set.
1:eac0369: 	 *
1:eac0369: 	 * @return The number of bits that are set.
1:eac0369: 	 */
1:eac0369: 	public int getNumBitsSet()
1:eac0369: 	{
1:59b0bba: 		if (SanityManager.DEBUG) {
1:59b0bba: 			SanityManager.ASSERT(invariantHolds(),"broken invariant");
1:eac0369: 		}
1:59b0bba: 		int bitsSet = 0;
1:59b0bba: 		final int numbytes = getLengthInBytes();
1:59b0bba: 		for (int i = 0; i < numbytes; ++i) {
1:59b0bba: 			byte v = value[i];
1:eac0369: 
1:59b0bba: 			// "Truth table", bits set in half-nibble (2 bits):
1:59b0bba: 			//  A | A>>1 | A-=A>>1 | bits set
1:59b0bba: 			// ------------------------------
1:59b0bba: 			// 00 |  00  |    0    |    0
1:59b0bba: 			// 01 |  00  |    1    |    1
1:59b0bba: 			// 10 |  01  |    1    |    1
1:59b0bba: 			// 11 |  01  |    2    |    2
1:59b0bba: 
1:59b0bba: 			// Calculate bits set in each half-nibble in parallel
1:59b0bba: 			//   |ab|cd|ef|gh|
1:59b0bba: 			// - |>a|&c|&e|&g|>
1:59b0bba: 			// ----------------
1:59b0bba: 			// = |ij|kl|mn|op|
1:59b0bba: 			v -= ((v >> 1) & 0x55);
1:59b0bba: 
1:59b0bba: 			// Add the upper and lower half-nibbles together and store
1:59b0bba: 			// in each nibble
1:59b0bba: 			//  |&&|kl|&&|op|
1:59b0bba: 			//+ |>>|ij|&&|mn|>>
1:59b0bba: 			//-----------------
1:59b0bba: 			//= |0q|rs|0t|uv|
1:59b0bba: 			v = (byte)((v & 0x33) + ((v >> 2) & 0x33));
1:59b0bba: 
1:59b0bba: 			// Add the nibbles together
1:59b0bba: 			//  |&&&&|&tuv|
1:59b0bba: 			//+ |>>>>|0qrs|>>>>
1:59b0bba: 			//-----------------
1:59b0bba: 			//= |0000|wxyz|
1:59b0bba: 			v = (byte)((v & 0x7) + (v >> 4));
1:59b0bba: 			bitsSet += v;
1:59b0bba: 		}
1:59b0bba: 		return bitsSet;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// EXTERNALIZABLE
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Format: <UL>
1:eac0369: 	 *		<LI>int		length in bits  </LI>
1:eac0369: 	 *		<LI>byte[]					</LI></UL>
1:eac0369: 	 *
1:eac0369: 	 * @see java.io.Externalizable#writeExternal
1:eac0369: 	*/
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 		// never called when value is null
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(value != null);
1:eac0369: 
1:eac0369: 		out.writeInt(getLength());
1:eac0369: 		int byteLen = getLengthInBytes();
1:eac0369: 		if (byteLen > 0)
1:eac0369: 		{
1:eac0369: 			out.write(value, 0, byteLen);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Note: gracefully handles zero length
1:eac0369: 	 * bits -- will create a zero length array
1:eac0369: 	 * with no bits being used.  Fortunately
1:eac0369: 	 * in.read() is ok with a zero length array
1:eac0369: 	 * so no special code.
1:eac0369: 	 * <p>
1:eac0369: 	 * WARNING: this method cannot be changed w/o
1:eac0369: 	 * changing SQLBit because SQLBit calls this
1:eac0369: 	 * directly w/o calling read/writeObject(), so
1:eac0369: 	 * the format id is not stored in that case.
1:eac0369: 	 *
1:eac0369: 	 * @see java.io.Externalizable#readExternal
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException
1:eac0369: 	{
1:eac0369: 		int lenInBits;
1:eac0369: 		int lenInBytes;
1:eac0369: 
1:eac0369: 		lenInBits = in.readInt();
1:eac0369: 
1:eac0369: 		lenInBytes = FormatableBitSet.numBytesFromBits(lenInBits);
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** How can lenInBytes be zero?  The implication is
1:eac0369: 		** that lenInBits is zero.  Well, the reason this can
1:eac0369: 		** happen is that the store will reset our stream
1:eac0369: 		** out from underneath us if we are a Bit column that
1:eac0369: 		** overflows onto another page because it assumes that
1:eac0369: 		** we want to stream it in specially.  Because of this warped
1:eac0369: 		** API, our readInt() will return 0 even though our
1:eac0369: 		** writeExternal() did a writeInt(xxx).  The upshot
1:eac0369: 		** is that you should leave the following alone.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 			value = new byte[lenInBytes];
1:eac0369: 
2:eac0369: 			in.readFully(value);
1:eac0369: 
2:eac0369: 			bitsInLastByte = numBitsInLastByte(lenInBits);
1:eac0369: 
2:eac0369: 			lengthAsBits = lenInBits;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:eac0369: 	 */
1:eac0369: 	public	int	getTypeFormatId()	{ return StoredFormatIds.BITIMPL_V01_ID; }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	** we are restricted to 2^(31-3) -&gt; 256meg instead
/////////////////////////////////////////////////////////////////////////
1: 	 * where x.getLength() &lt; y.getLength() but where:
1: 	 * then x &lt; y.
1: 	 * @return -1	- if other &lt;  this
1: 	 *			1	- if other &gt;  this
commit:6b23802
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: 		value = ArrayUtil.copy( newValue );
/////////////////////////////////////////////////////////////////////////
1: 		return ArrayUtil.copy( value );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Copy the bytes from another FormatableBitSet. Assumes that this bit set
1:      * is at least as large as the argument's bit set.
1:      */
1:     public  void    copyFrom( FormatableBitSet that )
1:     {
1:         System.arraycopy( that.getByteArray(), 0, value, 0, that.getLengthInBytes());
1:     }
1: 
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		value = ArrayUtil.EMPTY_BYTE_ARRAY;
commit:3f2dd5c
/////////////////////////////////////////////////////////////////////////
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (newNumBytes > value.length) {
1: 			int oldNumBytes = getLengthInBytes();
/////////////////////////////////////////////////////////////////////////
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1: 		}
1: 
commit:8a6ea6d
/////////////////////////////////////////////////////////////////////////
1: 	 * Grow (widen) a FormatableBitSet so that it contains at least N
1: 	 * bits. If the bitset already has more than n bits, this is a
1: 	 * noop. Negative values of n are not allowed.
1: 	 * ASSUMPTIONS: that all extra bits in the last byte are
1: 	 * zero.
1:  		if (n < 0) {
1:  			throw new IllegalArgumentException("Bit set cannot grow from "+
1:  											   lengthAsBits+" to "+n+" bits");
1:  		}
1: 		if (n <= lengthAsBits) {
1:  			return;
1:  		}
0: 		int delta = n - lengthAsBits;
/////////////////////////////////////////////////////////////////////////
1: 	 * Shrink (narrow) a FormatableBitSet to N bits. N may not be
1: 	 * larger than the current bitset size, or negative.
1: 	public void shrink(int n)
1: 		if (n < 0 || n > lengthAsBits) {
1: 				IllegalArgumentException("Bit set cannot shrink from "+
1: 										 lengthAsBits+" to "+n+" bits");
1: 		final int firstUnusedByte = numBytesFromBits(n);
1: 		for (int i = firstUnusedByte; i < value.length; ++i) {
1: 			value[i] = 0;
1: 		if (firstUnusedByte > 0) {
1: 			// Mask out any left over bits in the
1: 			// last byte.  Retain the highest bits.
1: 			value[firstUnusedByte-1] &= 0xff00 >> bitsInLastByte;
1: 		}
commit:5f9b827
/////////////////////////////////////////////////////////////////////////
1: 	 * @param v a non-zero byte to check for set bits
commit:59b0bba
/////////////////////////////////////////////////////////////////////////
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(),"broken invariant");
1: 		int bitsSet = 0;
1: 		final int numbytes = getLengthInBytes();
1: 		for (int i = 0; i < numbytes; ++i) {
1: 			byte v = value[i];
1: 			// "Truth table", bits set in half-nibble (2 bits):
1: 			//  A | A>>1 | A-=A>>1 | bits set
1: 			// ------------------------------
1: 			// 00 |  00  |    0    |    0
1: 			// 01 |  00  |    1    |    1
1: 			// 10 |  01  |    1    |    1
1: 			// 11 |  01  |    2    |    2
1: 
1: 			// Calculate bits set in each half-nibble in parallel
1: 			//   |ab|cd|ef|gh|
1: 			// - |>a|&c|&e|&g|>
1: 			// ----------------
1: 			// = |ij|kl|mn|op|
1: 			v -= ((v >> 1) & 0x55);
1: 
1: 			// Add the upper and lower half-nibbles together and store
1: 			// in each nibble
1: 			//  |&&|kl|&&|op|
1: 			//+ |>>|ij|&&|mn|>>
1: 			//-----------------
1: 			//= |0q|rs|0t|uv|
1: 			v = (byte)((v & 0x33) + ((v >> 2) & 0x33));
1: 
1: 			// Add the nibbles together
1: 			//  |&&&&|&tuv|
1: 			//+ |>>>>|0qrs|>>>>
1: 			//-----------------
1: 			//= |0000|wxyz|
1: 			v = (byte)((v & 0x7) + (v >> 4));
1: 			bitsSet += v;
1: 		}
1: 		return bitsSet;
commit:17711ec
/////////////////////////////////////////////////////////////////////////
1: 	private static int umul8(int i) { return (i<<3); }
/////////////////////////////////////////////////////////////////////////
1: 	 * A utility method which treats the byte argument as an 8-bit
1: 	 * bitset and finds the first set bit in that byte. Assumes that
1: 	 * at least one bit in v is set (v!=0).
0: 	 * @param a non-zero byte to check for set bits
1: 	 * @return the zero-based index of the first set bit in the argument byte
1: 	private static byte firstSet(byte v) {
1: 		if ((v & 0x80) != 0) {
1: 			return 0;
1: 		if ((v & 0x40) != 0) {
1: 			return 1;
1: 		if ((v & 0x20) != 0) {
1: 			return 2;
1: 		}
1: 		if ((v & 0x10) != 0) {
1: 			return 3;
1: 		}
1: 		if ((v & 0x8) != 0) {
1: 			return 4;
1: 		}
1: 		if ((v & 0x4) != 0) {
1: 			return 5;
1: 		}
1: 		if ((v & 0x2) != 0) {
1: 			return 6;
1: 		}
1: 		return 7;
1: 	}
1: 	/**
1: 	 * If any bit is set, return the zero-based bit index of the first
1: 	 * bit that is set. If no bit is set, return -1. By using
1: 	 * anySetBit() and anySetBit(beyondBit), one can quickly go thru
1: 	 * the entire bit array to return all set bit.
1: 	 *
1: 	 * @return the zero-based index of the first bit that is set, or
1: 	 * -1 if no bit is set
1: 	 */
1: 	public int anySetBit() {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1: 		}
1: 		final int numbytes = getLengthInBytes();
1: 		for (int i = 0; i < numbytes; ++i) {
1: 			final byte v = value[i];
1: 			if (v == 0) continue;
1: 			return (umul8(i) + firstSet(v));
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	public int anySetBit(int beyondBit) {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(), "broken invariant");
1: 		if (++beyondBit >= lengthAsBits) {
1: 		int i = udiv8(beyondBit);
1: 		byte v = (byte)(value[i] << umod8(beyondBit));
1: 		if (v != 0) {
1: 			return (beyondBit + firstSet(v));
1: 		final int numbytes = getLengthInBytes();
1: 		for (++i; i < numbytes; ++i) {
1: 			v = value[i];
1: 			if (v == 0) continue;
1: 			return (umul8(i) + firstSet(v));
commit:65a2bbd
/////////////////////////////////////////////////////////////////////////
1: 	private	byte	bitsInLastByte;
1: 	private final void checkPosition(int p) {
/////////////////////////////////////////////////////////////////////////
1: 	// Division, multiplication and remainder calcuation of a positive
1: 	// number with a power of two can be done using shifts and bit
1: 	// masking. The compiler attempts this optimization but since Java
1: 	// does not have unsigned ints it will also have to create code to
1: 	// handle negative values. In this class the argument is
1: 	// frequently an array index or array length, which is known not
1: 	// to be negative. These utility methods allow us to perform
1: 	// "unsigned" operations with 8. Hopefully the extra function call
1: 	// will be inlined by the compiler.
1: 	private static int udiv8(int i) { return (i>>3); }
1: 	private static byte umod8(int i) { return (byte)(i&0x7); }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (numBits < 0) {
1: 			throw new
1: 			IllegalArgumentException("Bit set size "+ numBits +
1: 									 " is not allowed");
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		if (n < 0) {
1: 			throw new
0: 			IllegalArgumentException("Bit set size "+ n +
0: 									 " is not allowed");
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		final int byteIndex = udiv8(position);
1: 		final byte bitIndex = umod8(position);
1: 		return ((value[byteIndex] & (0x80>>bitIndex)) != 0);
1: 
/////////////////////////////////////////////////////////////////////////
1: 		final int byteIndex = udiv8(position);
1: 		final byte bitIndex = umod8(position);
1: 		value[byteIndex] |= (0x80>>bitIndex);
/////////////////////////////////////////////////////////////////////////
1: 		final int byteIndex = udiv8(position);
1: 		final byte bitIndex = umod8(position);
1: 		value[byteIndex] &= ~(0x80>>bitIndex);
/////////////////////////////////////////////////////////////////////////
1: 	private static byte
1: 		if (bits == 0) return 0;
1: 		byte lastbits = umod8(bits);
1: 		return (lastbits != 0 ? lastbits : 8);
commit:c7205c1
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * This method returns true if the following conditions hold:
1: 	 * 1. The number of bits in the bitset will fit into the allocated
1: 	 * byte array. 2. 'lengthAsBits' and 'bitsInLastByte' are
1: 	 * consistent. 3. All unused bits in the byte array are
1: 	 * unset. This represents an invariant for the class, so this
1: 	 * method should always return true.
1: 	 *
1: 	 * The method is public, but is primarily intended for testing and
1: 	 * ASSERTS.
0: 	 * @returns true if invariant holds, false otherwise
1: 	 */
1: 	public boolean invariantHolds() {
1: 		// Check that all bits will fit in byte array
1: 		final int arrayLengthAsBits = value.length*8;
1: 		if (lengthAsBits > arrayLengthAsBits) { return false; }
1: 
1: 		// Check consistency of 'lengthAsBits' and 'bitsInLastByte'
1: 		final int partialByteIndex = (lengthAsBits-1)/8;
1: 		if (bitsInLastByte != (lengthAsBits - (8*partialByteIndex))) {
1: 			return false;
1: 		}
1: 		// Special case for empty bitsets since they will have
1: 		// 'partialByteIndex'==0, but this isn't a legal index into
1: 		// the byte array
1: 		if (value.length==0) { return true; }
1: 
1: 		// Check that the last used (possibly partial) byte doesn't
1: 		// contain any unused bit positions that are set.
1: 		byte partialByte = value[partialByteIndex];
1: 		partialByte <<= bitsInLastByte;  // must be zero after shift
1: 
1: 		// Check the remaining completely unused bytes (if any)
1: 		for (int i = partialByteIndex+1; i < value.length; ++i) {
1: 			partialByte |= value[i];
1: 		}
1: 		return (partialByte==0);
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Bitwise OR this FormatableBitSet with another
1: 	 * FormatableBitSet. The result is stored in this bitset. The
1: 	 * operand is unaffected. A null operand is treated as an empty
1: 	 * bitset (i.e. a noop). A bitset that is smaller than its operand
1: 	 * is expanded to the same size.
1: 	 * @param otherBit bitset operand
1: 		if (otherBit == null) {
1: 		}
1: 		if (otherLength > getLength()) {
1: 			grow(otherLength);
1: 		}
1: 		for (int i = 0; i < obByteLen; ++i) {
1: 		}
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(),"or() broke invariant");
1: 		}
1: 	 * Bitwise AND this FormatableBitSet with another
1: 	 * FormatableBitSet. The result is stored in this bitset. The
1: 	 * operand is unaffected. A null operand is treated as an empty
1: 	 * bitset (i.e. clearing this bitset). A bitset that is smaller
1: 	 * than its operand is expanded to the same size.
1: 	 * @param otherBit bitset operand
1: 		if (otherBit == null) {
1: 			clear();
1: 			return;
1: 		}
1: 		if (otherLength > getLength()) {
1: 			grow(otherLength);
1: 		// Since this bitset is at least as large as the other bitset,
1: 		// one can use the length of the other bitset in the iteration
1: 		int byteLength = otherBit.getLengthInBytes();
1: 		int i = 0;
1: 		for (; i < byteLength; ++i) {
1: 		}
1: 
1: 		// If the other bitset is shorter the excess bytes in this
1: 		// bitset must be cleared
1: 		byteLength = getLengthInBytes();
1: 		for (; i < byteLength; ++i) {
1: 			value[i] = 0;
1: 		}
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(),"and() broke invariant");
1: 		}
1: 	 * Bitwise XOR this FormatableBitSet with another
1: 	 * FormatableBitSet. The result is stored in this bitset. The
1: 	 * operand is unaffected. A null operand is treated as an empty
1: 	 * bitset (i.e. a noop). A bitset that is smaller than its operand
1: 	 * is expanded to the same size.
1: 	 * @param otherBit bitset operand
1: 	public void xor(FormatableBitSet otherBit)
1: 		if (otherBit == null) {
1: 			return;
1: 		}
1: 		int otherLength = otherBit.getLength();
1: 		if (otherLength > getLength()) {
1: 			grow(otherLength);
1: 		int obByteLen = otherBit.getLengthInBytes();
1: 		for (int i = 0; i < obByteLen; ++i) {
1: 			value[i] ^= otherBit.value[i];
1: 		}
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(invariantHolds(),"xor() broke invariant");
commit:aa13c70
/////////////////////////////////////////////////////////////////////////
0: 	private void checkPosition(int p) {
1: 		if (p < 0 || lengthAsBits <= p) {
1: 			throw new
1: 				IllegalArgumentException("Bit position "+p+
1: 										 " is outside the legal range");
1: 		}
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		checkPosition(position);
0: 		int bytepos = position / 8;
0: 		int bitpos = 7 - (position % 8);
0: 		return ((value[bytepos] & (1 << bitpos)) != 0);
/////////////////////////////////////////////////////////////////////////
1: 		checkPosition(position);
/////////////////////////////////////////////////////////////////////////
1: 		checkPosition(position);
0: 		int bytepos = position / 8;
0: 		int bitpos = 7 - (position % 8);
commit:72a3df4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9fdfb40
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private static int numBytesFromBits(int bits) {
1: 		return (bits + 7) >> 3;
/////////////////////////////////////////////////////////////////////////
1: 			for (int inPosition = 0; inPosition < getLength(); inPosition++)
commit:8bb781c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
1: 	// value is never null. An empty bitset is represented by a
1: 	// zero-length array.
/////////////////////////////////////////////////////////////////////////
0: 		value = ReuseFactory.getZeroLenByteArray();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:8564463
/////////////////////////////////////////////////////////////////////////
1: 		int obByteLen = otherBit.getLengthInBytes();
0: 		for (int i = 0; i < obByteLen-1; i++)
1: 			value[i] |= otherBit.value[i];
1: 		
0: 		// do the last byte bit by bit
0: 		for (int i = (obByteLen-1)*8; i < otherLength; i++)
0: 			if (otherBit.isSet(i))
0: 				set(i);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Tiago Aurlio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:65014c5
/////////////////////////////////////////////////////////////////////////
1: 	public boolean equals(Object other)
1:         if (other instanceof FormatableBitSet) 
1:         {
1:             FormatableBitSet that = (FormatableBitSet) other;
1: 		    if (this.getLength() != that.getLength())
1: 		    {
1: 			    return false;
1: 		    }
1: 		    return (this.compare(that) == 0);
1:         }
1:         return false;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: 	 * @param beyondBit Only look at bit that is greater than this bit number.
1: 	 *                  Supplying a value of -1 makes the call equivalent to
1: 	 *                  anySetBit().
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:01bb780
/////////////////////////////////////////////////////////////////////////
1: 	 * @return true if invariant holds, false otherwise
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.io.FormatableBitSet
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.io;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import java.io.InputStream;
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: /**
1:  * FormatableBitSet is implemented as a packed array of bytes.
1:  *
0:  * @author Jamie -- originally coded by Jeff
1:  */
1: 
1: public final class FormatableBitSet implements Formatable, Cloneable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	/********************************************************
1: 	**
1: 	**	This class implements Formatable. That means that it
1: 	**	can write itself to and from a formatted stream. If
1: 	**	you add more fields to this class, make sure that you
1: 	**	also write/read them with the writeExternal()/readExternal()
1: 	**	methods.
1: 	**
1: 	**	If, inbetween releases, you add more fields to this class,
1: 	**	then you should bump the version number emitted by the getTypeFormatId()
1: 	**	method.
1: 	**
1: 	********************************************************/
1: 
1: 	/**
1: 	** Bits are stored as an array of bytes.
1: 	** Bits are numbered starting at 0.  Bits
1: 	** 0..7 go in byte[0], 8..15 in byte[1] and so on.
1: 	** The number of bytes is tracked as part
1: 	** of the byte array.  The number of bits
1: 	** being used is derived by the number of
1: 	** bytes being used and the number of bits
1: 	** being used by the last byte.  The partially
1: 	** unused byte is always byte[byte.length] with the
1: 	** lowest bits being unused.
1: 	**
1: 	** Zero length bits are stored using a
1: 	** zero length byte array, with all bits
1: 	** marked as unused.
1: 	*/
1: 	private byte[]	value;
0: 	private	short	bitsInLastByte;
1: 
1: 	private transient int	lengthAsBits;
1: 
1: 	/**
1: 	 * Niladic Constructor
1: 	 */
1: 	public FormatableBitSet()
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Constructs a Bit with the initial number of bits
1: 	 */
1: 	public FormatableBitSet(int numBits)
1: 	{
1: 		initializeBits(numBits);
1: 	}
1: 
1: 	private void initializeBits(int numBits)
1: 	{
1: 		int numBytes = numBytesFromBits(numBits);
1: 
1: 		// the byte array is zero'ed out by the new operator
1: 		value = new byte[numBytes];
1: 		bitsInLastByte = numBitsInLastByte(numBits);
1: 		lengthAsBits = numBits;
1: 	}
1: 
1: 	/**
1: 	 * Constructs a Bit from an array of bytes.  Assume
1: 	 * bytes are all being used.
1: 	 *
1: 	 * @param newValue	The array of bytes to make up the new Bit
1: 	 */
1: 	public FormatableBitSet(byte[] newValue)
1: 	{
1: 		value = newValue;
1: 		bitsInLastByte = 8;
1: 		lengthAsBits = calculateLength(newValue.length);
1: 	}
1: 
1: 	/**
0: 	 * Constructs a Bit from an array of bytes.
1: 	 *
1: 	 * @param newValue	The array of bytes to make up the new Bit
0: 	 * @param numBits	The number of bits
1: 	 */
0: 	public FormatableBitSet(byte[] newValue, int numBits)
1: 	{
1: 		bitsInLastByte = numBitsInLastByte(numBits);
1: 		lengthAsBits = numBits;
1: 
0: 		int lenInBytes = numBytesFromBits(numBits);
1: 
0: 		if (lenInBytes == newValue.length) {
1: 			value = newValue;
0: 		} else {
1: 			value = new byte[lenInBytes];
0: 			System.arraycopy(newValue, 0, value, 0, newValue.length);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Copy constructor
1: 	 *
1: 	 * @param original the FormatableBitSet to make a copy from
1: 	 */
1: 	public FormatableBitSet (FormatableBitSet original)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(
1:                 original != null, "cannot make copy from a null FormatableBitSet");
1: 
1: 		bitsInLastByte = original.bitsInLastByte;
1: 		lengthAsBits = original.lengthAsBits;
1: 
1: 		int lenInBytes = FormatableBitSet.numBytesFromBits(original.lengthAsBits);
1: 		value = new byte[lenInBytes];
1: 		if (lenInBytes > 0)
1: 			System.arraycopy(original.value, 0, value, 0, lenInBytes);
1: 	}
1: 			
1: 	/*
1: 	 * Cloneable
1: 	 */
1: 	public Object clone()
1: 	{
1: 		return new FormatableBitSet(this);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the length in bytes of a Bit value
1: 	 *
1: 	 * @return	The length in bytes of this value
1: 	 */
1: 	public int getLengthInBytes()
1: 	{
0: 		if (value == null)
1: 		{
1: 			return 0;
1: 		}
1: 
1: 		return FormatableBitSet.numBytesFromBits(lengthAsBits);
1: 	}
1: 
1: 	/**
1: 	** Get the length in bits
1: 	**
1: 	** @return The length in bits for this value
1: 	**
1: 	** NOTE: could possibly be changed to a long.  As is
0: 	** we are restricted to 2^(31-3) -> 256meg instead
1: 	** of 2^31 (Integer.MAX_VALUE) like other datatypes
1: 	** (or 2 gig).  If it is ever changed to a long
1: 	** be sure to change read/writeExternal which write
1: 	** out the length in bits.
1: 	*/
1: 	public int getLength() {
1: 		return lengthAsBits;
1: 	}
1: 
1: 	private int calculateLength(int realByteLength)
1: 	{
1: 		if (realByteLength == 0)
1: 		{
1: 			return 0;
1: 		}
1: 
1: 		return ((realByteLength - 1) * 8) + bitsInLastByte;
1: 	}
1: 
1: 	/**
1: 	 * Get the length in bits -- alias for getLength()
1: 	 *
1: 	 * @return The length in bits for this value
1: 	 */
1: 	public int size()
1: 	{
1: 		return getLength();
1: 	}
1: 
1: 	/**
1: 	 * Get the value of the byte array
1: 	 *
1: 	 * @return	The value of the byte array
1: 	 */
1: 
1: 	public byte[] getByteArray()
1: 	{
0: 		if (value == null)
0: 			return null;
1: 
1: 		// In some cases the array is bigger than the actual number
1: 		// of valid bytes.
1: 		int realByteLength = getLengthInBytes();
1: 
1: 		// Currently the case is that the return from this
1: 		// call only includes the valid bytes.
1: 		if (value.length != realByteLength) {
1: 			byte[] data = new byte[realByteLength];
1: 			System.arraycopy(value, 0, data, 0, realByteLength);
1: 
1: 			value = data;
1: 		}
1: 
0: 		return value;
1: 	}
1: 
1: 	/**
0: 	 * Set the value of the byte array
1: 	 *
1: 	 * @return	The value of the byte array
1: 	 */
0: 	public boolean isNull()
1: 	{
0: 		return this.value == null;
1: 	}
1: 
1: 	/**
0: 	 * Grow (widen) a FormatableBitSet to N bis
1: 	 *
1: 	 * @param n	The number of bits you want.  The bits are
1: 	 *			always added as 0 and are appended to the
1: 	 *			least significant end of the bit array.
1: 	 *
0: 	 * ASSUMPTIONS: that all extra bits in the last byte
0: 	 * are zero.
1: 	 */
1: 	public void grow(int n)
1: 	{
0: 		if (n <= this.getLength())
1: 			return;
1: 
0: 		if (value == null)
1: 		{
0: 			initializeBits(n);
1: 			return;
1: 		}
1: 
0: 		int delta = n - this.getLength();
1: 
1: 
0: 		int oldNumBytes = getLengthInBytes();
1: 
1: 		/*
0: 		** If we have enough space in the left over bits,
0: 		** then all we need to do is change the modulo.
1: 		*/
0: 		if ((oldNumBytes != 0) &&
0: 		    (8 - this.bitsInLastByte) >= delta)
1: 		{
0: 			this.bitsInLastByte += delta;
1: 			lengthAsBits = n;
1: 			return;
1: 		}
1: 
1: 		int newNumBytes = FormatableBitSet.numBytesFromBits(n);
1: 
1: 		// is there enough room in the existing array
0: 		if (newNumBytes <= value.length) {
0: 			// ensure the bits are zeroed
0: 			for (int i = oldNumBytes; i <  newNumBytes; i++)
0: 				value[i] = 0;
0: 		} else {
1: 
1: 
1: 			/*
1: 			** We didn't have enough bytes in value, so we need
1: 			** to create a bigger byte array and use that.
1: 			*/
1: 			byte[] newValue = new byte[newNumBytes];
1: 
1: 			System.arraycopy(value, 0, newValue, 0, oldNumBytes);
1: 
1: 			value = newValue;
1: 		}
1: 		bitsInLastByte = numBitsInLastByte(n);
1: 		lengthAsBits = n;
1: 	}
1: 
1: 	/**
0: 	 * Shrink (narrow) a FormatableBitSet to N bits
1: 	 *
1: 	 * @param n	The number of bits the caller wants.  The
1: 	 * 			bits are always removed from the
1: 	 *			least significant end of the bit array.
1: 	 */
0: 	public FormatableBitSet shrink(int n)
1: 	{
0: 		int		numBytes;
0: 		int		lastByteNum;
1: 
1: 		/*
0: 		** Sanity check: we shouldn't shrink down to
0: 		** nothing.
1: 		*/
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (value == null)
1: 			{
0: 				SanityManager.THROWASSERT("Attempt to shrink a null Bit"+
0: 						" -- caller should have known better probably");
0: 				return null;
1: 			}
1: 		}
1: 
0: 		if (n >= this.getLength())
1: 		{
0: 			return this;
1: 		}
1: 
1: 
0: 		lastByteNum = numBytesFromBits(n) - 1;
1: 		bitsInLastByte = numBitsInLastByte(n);
1: 		lengthAsBits = n;
1: 
1: 		/*
0: 		** Mask out any left over bits in the
0: 		** last byte.  Retain the highest bits.
1: 		*/
0: 		if (bitsInLastByte != 8)
1: 		{
0: 			value[lastByteNum] &= 0xFF00 >> bitsInLastByte;
1: 		}
1: 
0: 		return this;
1: 	}
1: 
1: 	/*
1: 	** Some of the operators required by SQL.  These could alternatively
1: 	** be in SQLBit, but since they are so tightly bound to the implementation
1: 	** rather than return something that undermines the encapsulation
1: 	** of this type, i have chosen to put them in here.
1: 	*/
1: 
1: 	/**
1: 	 * Bit equivalence.  Compare this with other.
1: 	 * If the length is different, then cannot be
1: 	 * equal so short circuit.  Otherwise, rely on
1: 	 * compare().  Note that two zero length bits are
1: 	 * considered equal.
1: 	 *
1: 	 * @param other	the other bit to compare to
1: 	 *
1: 	 * @return TRUE|FALSE
1: 	 */
0: 	public boolean equals(FormatableBitSet other)
1: 	{
0: 		if (this.getLength() != other.getLength())
1: 		{
0: 			return false;
1: 		}
1: 
0: 		return (this.compare(other) == 0);
1: 	}
1: 
1: 	/**
1: 	 * Bit comparison.  Compare this with other.
1: 	 * Will always do a byte by byte compare.
1: 	 *
1: 	 * Given 2 similar bits of unequal lengths (x and y),
0: 	 * where x.getLength() < y.getLength() but where:
1: 	 *
1: 	 *	 x[0..x.getLength()] == y[0..x.getLength()]
1: 	 *
0: 	 * then x < y.
1: 	 *
1: 	 *
1: 	 * @param other the other bit to compare to
1: 	 *
0: 	 * @return -1	- if other <  this
1: 	 *			0	- if other == this
0: 	 *			1	- if other >  this
1: 	 *
1: 	 */
1: 	public int compare(FormatableBitSet other)
1: 	{
1: 
1: 		int		otherCount, thisCount;
1: 		int		otherLen, thisLen;
1: 		byte[]	otherb;
1: 
1: 		otherb = other.value;
1: 		/*
0: 		** By convention, nulls sort low, and null == null
1: 		*/
0: 		if (this.value == null || otherb == null)
1: 		{
0: 			if (this.value != null)	// otherb == null
1: 				return 1;
0: 			if (otherb != null)		// this.value == null
1: 				return -1;
0: 			return 0;				// both null
1: 		}
1: 
1: 		otherLen = other.getLengthInBytes();
1: 		thisLen = getLengthInBytes();
1: 		for (otherCount = 0, thisCount = 0;
1: 				otherCount < otherLen && thisCount < thisLen;
1: 				otherCount++, thisCount++)
1: 		{
1: 			if (otherb[otherCount] != this.value[thisCount])
1: 				break;
1: 		}
1: 
1: 		/*
1: 		** '==' if byte by byte comparison is identical and
1: 		** exact same length in bits (not bytes).
1: 		*/
1: 		if ((otherCount == otherLen) && (thisCount == thisLen))
1: 		{
1: 				if (this.getLength() == other.getLength())
1: 				{
1: 					return 0;
1: 				}
1: 
1: 				/*
1: 				** If subset of bits is identical, return 1
1: 				** if other.getLength() > this.getLength(); otherwise,
1: 				** -1
1: 				*/
1: 				return (other.getLength() < this.getLength()) ? 1 : -1;
1: 		}
1: 
1: 		if (otherCount == otherLen)
1: 		{
1: 			return 1;
1: 		}
1: 		else if (thisCount == thisLen)
1: 		{
1: 			return -1;
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** Ok, we have a difference somewhere.  Now
1: 			** we have to go to the trouble of converting
1: 			** to a int and masking out the sign to get
1: 			** a valid comparision because bytes are signed.
1: 			*/
1: 			int otherInt, thisInt;
1: 
1: 			otherInt = (int)otherb[otherCount];
1: 			otherInt &= (0x100 - 1);
1: 
1: 			thisInt = (int)this.value[thisCount];
1: 			thisInt &= (0x100 - 1);
1: 
1: 			return (thisInt > otherInt) ? 1 : -1;
1: 
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Bit concatenation.
1: 	 *
0: 	 * @param other 	the other bit to append to this
1: 	 *
0: 	 * @return Bit -- the newly concatenated bit
1: 	 *
1: 	 */
0: 	public FormatableBitSet concatenate(FormatableBitSet other)
1: 	{
0: 		int		newLen;
0: 		int		otherLen;
0: 		int		prevLen;
0: 		int		prevLenBytes;
0: 		int		newLenBytes;
0: 		int     otherLenBytes;
0: 		int		i, j;
0: 		byte[]	newValue;
0: 		byte[]	otherValue;
0: 		int		shiftBits;
0: 		int		inByte;
1: 
1: 
0: 		prevLen = this.getLength();
0: 		prevLenBytes = this.getLengthInBytes();
0: 		otherLen = other.getLength();
0: 		otherValue = other.getByteArray();
0: 		otherLenBytes = other.getLengthInBytes();
0: 		newLen = prevLen + otherLen;
0: 		newLenBytes = numBytesFromBits(newLen);
0: 		newValue = new byte[newLenBytes];
1: 
1: 
1: 		/*
0: 		** Copy over the entire array in this.value
0: 		** to newLenBytes.
1: 		*/
0: 		for (i = 0; i < prevLenBytes; i++)
1: 		{
0: 			newValue[i] = this.value[i];
1: 		}
1: 
1: 		/*
0: 		** Now if we have any bits left over
0: 		** we need to shift them, and keep
0: 		** shifting everything down.  Be careful
0: 		** to handle the case where the bit
0: 		** used to have length 0.
1: 		*/
0: 		shiftBits = (prevLen == 0) ? 8 : this.bitsInLastByte;
0: 		for (j = 0; j < otherLenBytes; j++, i++)
1: 		{
0: 			if (shiftBits == 8)
1: 			{
0: 				newValue[i] = otherValue[j];
1: 			}
1: 			else
1: 			{
1: 				/*
0: 				** Convert to an int because it will get converted
0: 				** on the shift anyway.
1: 				*/
0: 				inByte = (int)otherValue[j];
1: 
1: 				/*
0: 				** Mask off the high bits in case they are now
0: 				** turned on if we had the sign bit on.
1: 				*/
0: 				inByte &= (0x100 - 1);
1: 
1: 				/*
0: 				** Use the high order bits to finish off
0: 				** the last byte
1: 				*/
0: 				newValue[i-1] |= (inByte >>> shiftBits);
1: 
1: 	            /*
0: 		        ** Start the next one with whatever is left, unless
0: 		        ** there is nothing left.
1: 	            */
0: 	            if (i < newLenBytes)
1: 				{
0: 		            newValue[i] |= (inByte << (8 - shiftBits));
1: 				}
1: 			}
1: 		}
1: 
0: 		return new FormatableBitSet(newValue, newLen);
1: 	}
1: 
1:     /**
1:      * Produce a hash code by putting the value bytes into an int, exclusive OR'ing
1:      * if there are more than 4 bytes.
1:      *
1:      * @return the hash code
1:      */
1:     public int hashCode()
1:     {
0:         if( null == value)
1:             return 0;
1:         
1:         int code = 0;
1:         int i;
1:         int shift = 0;
1: 
1: 		int byteLength = getLengthInBytes();
1:         for( i = 0; i < byteLength; i++)
1:         {
1:             code ^= (value[i] & 0xff)<<shift;
1:             shift += 8;
1:             if( 32 <= shift)
1:                 shift = 0;
1:         }
1:         return code;
1:     }
1:     
1: 	/**
1: 	 * Bit isSet
1: 	 *
1: 	 * @param position	the bit to check
1: 	 *
1: 	 */
1: 	public final boolean isSet(int position)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (position >= this.getLength())
1:             {
0:                 SanityManager.THROWASSERT(
0:                    "Attempt to get a bit position (" + position +
0:                    ")" +
0:                    "that exceeds the max length (" + this.getLength() + ")");
1:             }
1: 		}
1: 
0: 		try {
1: 
0: 			int bytepos = position / 8;
0: 			int bitpos = 7 - (position % 8);
1: 
0: 			return ((value[bytepos] & (1 << bitpos)) != 0);
1: 
0: 		} catch (ArrayIndexOutOfBoundsException e) {
0: 			// Should not happen, handle it just in case not all cases are tested
0: 			// by insane server.
0: 			return false;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bit get -- alias for isSet()
1: 	 *
1: 	 * @param position	the bit to check
1: 	 *
1: 	 */
1: 	public final boolean get(int position)
1: 	{
1: 		return isSet(position);
1: 	}
1: 	
1: 	/**
1: 	 * Bit set
1: 	 *
1: 	 * @param position	the bit to set
1: 	 *
1: 	 */
1: 	public void set(int position)
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0:             if (position >= this.getLength())
1:             {
0:                 SanityManager.THROWASSERT(
0: 				   "Attempt to set a bit position that exceeds the max length ("
0:                    + this.getLength() + ")");
1:             }
1: 		}
1: 
0: 		// Should not happen, handle it just in case not all cases are tested
0: 		// by insane server.
0: 		if (position >= getLength())
0: 			grow(position);
1: 
0: 		int bytepos = position / 8;
0: 		int bitpos = 7 - (position % 8);
1: 
0: 		value[bytepos] |= (1 << bitpos);
1: 	}
1: 
1: 	/**
1: 	 * Bit clear
1: 	 *
1: 	 * @param position	the bit to clear
1: 	 *
1: 	 */
1: 	public void clear(int position)
1: 	{
0: 		int	bytepos;
0: 		int	bitpos;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0:             if (position >= this.getLength())
1:             {
0:                 SanityManager.THROWASSERT(
0:                    "Attempt to set a bit position that exceeds the max length ("
0:                    + this.getLength() + ")");
1:             }
1: 		}
1: 
0: 		// Should not happen, handle it just in case not all cases are tested
0: 		// by insane server.
0: 		if (position >= getLength())
0: 			grow(position);
1: 
0: 		bytepos = position / 8;
0: 		bitpos = 7 - (position % 8);
1: 
0: 		value[bytepos] &= ~(1 << bitpos);
1: 	}
1: 
1: 	/**
1: 	  Clear all the bits in this FormatableBitSet
1: 	  */
1: 	public void clear()
1: 	{
0: 		if (value == null) 
1:             return;
1: 
1: 		int byteLength = getLengthInBytes();
1: 		for (int ix=0; ix < byteLength; ix++)
1:             value[ix] = 0;
1: 	}
1: 
1: 
1: 	/**
1: 	* Figure out how many bytes are needed to
1: 	* store the input number of bits.
1: 	*
1: 	* @param bits	bits
1: 	*
1: 	* @return	the number of bytes
1: 	*/
0: 	protected static int
0: 	numBytesFromBits(int bits)
1: 	{
0: 		return (bits == 0) ? 0 : ((bits - 1) / 8) + 1;
1: 	}
1: 
1: 	/**
1: 	* Figure out how many bits are in the last
1: 	* byte from the total number of bits.
1: 	*
1: 	* @param	bits	bits
1: 	*
1: 	* @return	the number of bits
1: 	*/
0: 	private static short
1: 	numBitsInLastByte(int bits)
1: 	{
0: 		int modulo = bits % 8;
0: 		return (short)((modulo == 0) ?
0: 				((bits == 0) ? 0 : 8) :
0: 				modulo);
1: 	}
1: 
1: 	/**
0: 	 * Translate a hex character to a byte.
1: 	 *
0: 	 * @param hexChar	A character with the value [0-9a-fA-F].
1: 	 *
0: 	 * @return	A byte with the numeric value corresponding to the hex character
1: 	 */
0: 	private static byte
0: 	hexCharToByte(char hexChar)
1: 	{
0: 		byte	byteValue;
1: 
0: 		switch (hexChar)
1: 		{
0: 		  case '0':
0: 			byteValue = 0;
1: 			break;
1: 
0: 		  case '1':
0: 			byteValue = 1;
1: 			break;
1: 
0: 		  case '2':
0: 			byteValue = 2;
1: 			break;
1: 
0: 		  case '3':
0: 			byteValue = 3;
1: 			break;
1: 
0: 		  case '4':
0: 			byteValue = 4;
1: 			break;
1: 
0: 		  case '5':
0: 			byteValue = 5;
1: 			break;
1: 
0: 		  case '6':
0: 			byteValue = 6;
1: 			break;
1: 
0: 		  case '7':
0: 			byteValue = 7;
1: 			break;
1: 
0: 		  case '8':
0: 			byteValue = 8;
1: 			break;
1: 
0: 		  case '9':
0: 			byteValue = 9;
1: 			break;
1: 
0: 		  case 'a':
0: 		  case 'A':
0: 			byteValue = 0xA;
1: 			break;
1: 
0: 		  case 'b':
0: 		  case 'B':
0: 			byteValue = 0xB;
1: 			break;
1: 
0: 		  case 'c':
0: 		  case 'C':
0: 			byteValue = 0xC;
1: 			break;
1: 
0: 		  case 'd':
0: 		  case 'D':
0: 			byteValue = 0xD;
1: 			break;
1: 
0: 		  case 'e':
0: 		  case 'E':
0: 			byteValue = 0xE;
1: 			break;
1: 
0: 		  case 'f':
0: 		  case 'F':
0: 			byteValue = 0xF;
1: 			break;
1: 
0: 		  default:
1: 			  if (SanityManager.DEBUG)
1: 			  {
0: 				  SanityManager.THROWASSERT("illegal char = " + hexChar);
1: 			  }
0: 		  	throw new IllegalArgumentException();
1: 		}
1: 
0: 		return byteValue;
1: 	}
1: 
0: private static char[] decodeArray = {'0', '1', '2', '3', '4', '5', '6', '7',
0: 								'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
1: 
1: 	/**
1: 	 * Format the string into BitSet format: {0, 2, 4, 8} if bits 0, 2, 4, 8
1: 	 * are set.
1: 	 *
1: 	 * @return A new String containing the formatted Bit value
1: 	 */
1: 	public String toString()
1: 	{
0: 		char[]	outChars;
0: 		int		inPosition;
0: 		int		outPosition;
0: 		int 	inByte;
1: 
0: 		if (value == null)
1: 		{
0: 			return null;
1: 		}
1: 		{
1: 			// give it a reasonable size
1: 			StringBuffer str = new StringBuffer(getLength()*8*3);
1: 			str.append("{");
1: 			boolean first = true;
0: 			for (inPosition = 0; inPosition < getLength(); inPosition++)
1: 			{
1: 				if (isSet(inPosition))
1: 				{
1: 					if (!first)
1: 						str.append(", ");
1: 					first = false;
1: 					str.append(inPosition);
1: 				}
1: 			}
1: 			str.append("}");
1: 			return new String(str);
1: 		}
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 * Statically calculates how many bits can fit into the number of
1: 	 * bytes if this Bit object is externalized.  Only valid for this
1: 	 * implementation of Bit.
1: 	 */
1: 	public static int maxBitsForSpace(int numBytes)
1: 	{
1: 		return (numBytes - 4)*8;
1: 		
1: 	}
1: 
1: 	/**
0: 	 * If any bit is set, return the bit number of a bit that is set.
0: 	 * If no bit is set, return -1; 
1: 	 *
0: 	 * @return the bit number of a bit that is set, or -1 if no bit is set
1: 	 */
0: 	public int anySetBit()
1: 	{
0: 		int numbytes = getLengthInBytes();
0: 		int bitpos;
1: 
0: 		for (int i = 0; i < numbytes-1; i++)
1: 		{
0: 			if (value[i] != 0)
1: 			{
0: 				for (int j = 0; j < 8; j++)
1: 				{
0: 					bitpos = 7-j;
0: 					if (((1 << bitpos) & value[i]) != 0)
0: 						return ((i*8)+j);
1: 				}
1: 			}
1: 		}
1: 
1: 
0: 		// only the top part of the last byte is relevant
0: 		byte mask = (byte)(0xFF << (8-bitsInLastByte));
0: 		if ((value[numbytes-1] & mask) != 0)
1: 		{
0: 			for (int j = 0; j < bitsInLastByte; j++)
1: 			{
0: 				bitpos = 7-j;
0: 				if (((1 << bitpos) & value[numbytes-1]) != 0)
0: 					return ((numbytes-1)*8)+j;
1: 			}
1: 		}
1: 
1: 		return -1;
1: 	}
1: 
1: 	/**
1: 	 * Like anySetBit(), but return any set bit whose number is bigger than
1: 	 * beyondBit. If no bit is set after beyondBit, -1 is returned. 
1: 	 * By using anySetBit() and anySetBit(beyondBit), one can quickly go
1: 	 * thru the entire bit array to return all set bit.
1: 	 *
0: 	 * @param beyondBit only look at bit that is greater than this bit number
1: 	 * @return the bit number of a bit that is set, or -1 if no bit after
1: 	 * beyondBit is set
1: 	 */
0: 	public int anySetBit(int beyondBit)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (beyondBit >= this.getLength())
0:                 SanityManager.THROWASSERT(
0:                    "Attempt to access bit position that exceeds the max length ("
0:                     + this.getLength() + ")");
1: 		}
1: 
0: 		int startingBit = (beyondBit+1);
1: 
0: 		// we have seen the last bit.
0: 		if (startingBit >= this.getLength())
1: 			return -1;
1: 
0: 		int numbytes = getLengthInBytes();
0: 		int startingByte = startingBit / 8;
0: 		int startingBitpos = startingBit % 8;
0: 		int bitpos;
0: 		byte mask;
1: 
0: 		// see if any bits in this byte is set, only the bottom part of the
0: 		// first byte is relevant
0: 		mask = (byte)(0xFF >> startingBitpos);
1: 
0: 		if (startingByte == numbytes-1)	// starting byte == last byte 
0: 			mask &= (byte)(0xFF << (8-bitsInLastByte));
1: 
0: 		if ((value[startingByte] & mask ) != 0)
1: 		{
0: 			// I know we will see the bit before bitsInLastByte even if we are
0: 			// at the last byte, no harm in going up to 8 in the loop
0: 			for (int j = startingBitpos; j < 8; j++)
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
0: 					if (startingByte == numbytes-1)
0: 						SanityManager.ASSERT(j < bitsInLastByte,
0: 								 "going beyond the last bit");
1: 				}
0: 				bitpos = 7-j;
0: 				if (((1 << bitpos) & value[startingByte]) != 0)
1: 				{
0: 					return (startingByte*8+j);
1: 				}
1: 			}	
1: 		}
1: 
0: 		for (int i = (startingByte+1); i < numbytes-1; i++)
1: 		{			
0: 			if (value[i] != 0)
1: 			{
0: 				for (int j = 0; j < 8; j++)
1: 				{
0: 					bitpos = 7-j;
0: 					if (((1 << bitpos) & value[i]) != 0)
1: 					{
0: 						return ((i*8)+j);
1: 					}
1: 				}
1: 			}
1: 		}
1: 		
0: 		// Last byte if there are more than one bytes.  Only the top part of
0: 		// the last byte is relevant 
0: 		if (startingByte != numbytes-1)
1: 		{
0: 			mask = (byte)(0xFF << (8-bitsInLastByte));
1: 
0: 			if ((value[numbytes-1] & mask) != 0)
1: 			{
0: 				for (int j = 0; j < bitsInLastByte; j++)
1: 				{
0: 					bitpos = 7-j;
0: 					if (((1 << bitpos) & value[numbytes-1]) != 0)
1: 					{
0: 						return ((numbytes-1)*8)+j;	
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		return -1;
1: 
1: 	}
1: 
1: 	/**
0: 	 * Bitwise OR this Bit with another Bit.
1: 	 *
0: 	 * @param otherBit the other Bit
0: 	 * @see Bit#or
1: 	 */
1: 	public void or(FormatableBitSet otherBit)
1: 	{
0: 		if (otherBit == null || otherBit.getLength() == 0)
1: 			return;
1: 
1: 		int otherLength = otherBit.getLength();
1: 
0: 		if (otherLength > getLength())
0: 			grow(otherLength); // expand this bit 
1: 
0: 		if (otherBit instanceof FormatableBitSet)
1: 		{
0: 			// we know the bit ordering, optimize this 
0: 			FormatableBitSet ob = (FormatableBitSet)otherBit;
0: 			int obByteLen = ob.getLengthInBytes();
0: 			for (int i = 0; i < obByteLen-1; i++)
0: 				value[i] |= ob.value[i];
1: 
0: 			// do the last byte bit by bit
0: 			for (int i = (obByteLen-1)*8; i < otherLength; i++)
0: 				if (otherBit.isSet(i))
0: 					set(i);
1: 		}
1: 		else
1: 		{
0: 			// we don't know the bit ordering, call thru the interface and go
0: 			// thru bit by bit
0: 			// this bit impl's length >= other bit's length
1: 
0: 			for (int i = 0; i < otherLength; i++)
1: 			{
0: 				if (otherBit.isSet(i))
0: 					set(i);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Bitwise AND this Bit with another Bit.
1: 	 *
0: 	 * @param otherBit the other Bit
0: 	 * @see Bit#or
1: 	 */
1: 	public void and(FormatableBitSet otherBit)
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(otherBit != null, "cannot AND null with a FormatableBitSet");
1: 
1: 		int otherLength = otherBit.getLength();
1: 
0: 		// Supposedly cannot happen, but handle it just in case.
0: 		if (otherLength > getLength())
0: 			grow(otherLength); // expand this bit 
1: 
0: 		if (otherLength < getLength())
1: 		{
0: 			// clear all bits that are not in the other bit
0: 			int startingByte = (otherLength * 8) + 1;
0: 			int len = getLengthInBytes();
0: 			for (int i = startingByte; i < len; i++)
0: 				value[i] = 0;
1: 
0: 			for (int i = otherLength; i < startingByte*8; i++)
1: 			{
0: 				if (i < getLength())
0: 					clear(i);
1: 				else
1: 					break;
1: 			}
1: 		}
1: 
0: 		if (otherLength == 0)
1: 			return;
1: 			
0: 		int length = otherBit.getLengthInBytes() < getLengthInBytes() ? 
0: 			otherBit.getLengthInBytes() : getLengthInBytes();
1: 
0: 		for (int i = 0; i < length; i++)
1: 			value[i] &= otherBit.value[i];
1: 	}
1: 
1: 	/**
0: 	 * Logically XORs this FormatableBitSet with the specified FormatableBitSet.
0: 	 * @param set	The FormatableBitSet to be XORed with.
1: 	 */
0: 	public void xor(FormatableBitSet set)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (getLength() != set.getLength())
1: 			{
0: 				SanityManager.THROWASSERT("getLength() (" + getLength() +
0: 					") and set.getLength() (" +
0: 					set.getLength() +
0: 					") expected to be the same");
1: 			}
1: 		}
1: 
0: 		int setLength = set.getLength();
0: 		for (int i = setLength; i-- > 0; )
1: 		{
0: 			if (isSet(i) && set.isSet(i))
1: 			{
0: 				clear(i);
1: 			}
0: 			else if (isSet(i) || set.isSet(i))
1: 			{
0: 				set(i);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get a count of the number of bits that are set.
1: 	 *
1: 	 * @return The number of bits that are set.
1: 	 */
1: 	public int getNumBitsSet()
1: 	{
0: 		int count = 0;
1: 
0: 		for (int index = getLength() - 1; index >= 0; index--)
1: 		{
0: 			if (isSet(index))
1: 			{
0: 				count++;
1: 			}
1: 		}
1: 
0: 		return count;
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////
1: 	//
1: 	// EXTERNALIZABLE
1: 	//
1: 	/////////////////////////////////////////////////////////
1: 	/**
1: 	 * Format: <UL>
1: 	 *		<LI>int		length in bits  </LI>
1: 	 *		<LI>byte[]					</LI></UL>
1: 	 *
1: 	 * @see java.io.Externalizable#writeExternal
1: 	*/
1: 	public void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 		// never called when value is null
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(value != null);
1: 
1: 		out.writeInt(getLength());
1: 		int byteLen = getLengthInBytes();
1: 		if (byteLen > 0)
1: 		{
1: 			out.write(value, 0, byteLen);
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Note: gracefully handles zero length
1: 	 * bits -- will create a zero length array
1: 	 * with no bits being used.  Fortunately
1: 	 * in.read() is ok with a zero length array
1: 	 * so no special code.
1: 	 * <p>
1: 	 * WARNING: this method cannot be changed w/o
1: 	 * changing SQLBit because SQLBit calls this
1: 	 * directly w/o calling read/writeObject(), so
1: 	 * the format id is not stored in that case.
1: 	 *
1: 	 * @see java.io.Externalizable#readExternal
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException
1: 	{
1: 		int lenInBits;
1: 		int lenInBytes;
1: 
1: 		lenInBits = in.readInt();
1: 
1: 		lenInBytes = FormatableBitSet.numBytesFromBits(lenInBits);
1: 
1: 
1: 		/*
1: 		** How can lenInBytes be zero?  The implication is
1: 		** that lenInBits is zero.  Well, the reason this can
1: 		** happen is that the store will reset our stream
1: 		** out from underneath us if we are a Bit column that
1: 		** overflows onto another page because it assumes that
1: 		** we want to stream it in specially.  Because of this warped
1: 		** API, our readInt() will return 0 even though our
1: 		** writeExternal() did a writeInt(xxx).  The upshot
1: 		** is that you should leave the following alone.
1: 		*/
1: 
1: 			value = new byte[lenInBytes];
1: 
1: 			in.readFully(value);
1: 
1: 			bitsInLastByte = numBitsInLastByte(lenInBits);
1: 
1: 			lengthAsBits = lenInBits;
1: 	}
1: 
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
1: 	{
0: 		int lenInBits = in.readInt();
1: 
0: 		int lenInBytes = FormatableBitSet.numBytesFromBits(lenInBits);
1: 
1: 		value = new byte[lenInBytes];
1: 
1: 		in.readFully(value);
1: 
1: 		bitsInLastByte = numBitsInLastByte(lenInBits);
1: 
1: 		lengthAsBits = lenInBits;
1: 	}
1: 
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
1: 	public	int	getTypeFormatId()	{ return StoredFormatIds.BITIMPL_V01_ID; }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.io;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.io.InputStream;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: /**
0:  * FormatableBitSet is implemented as a packed array of bytes.
0:  *
0:  * @author Jamie -- originally coded by Jeff
0:  */
0: 
0: public final class FormatableBitSet implements Formatable, Cloneable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	/********************************************************
0: 	**
0: 	**	This class implements Formatable. That means that it
0: 	**	can write itself to and from a formatted stream. If
0: 	**	you add more fields to this class, make sure that you
0: 	**	also write/read them with the writeExternal()/readExternal()
0: 	**	methods.
0: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
0: 	**	then you should bump the version number emitted by the getTypeFormatId()
0: 	**	method.
0: 	**
0: 	********************************************************/
0: 
0: 	/**
0: 	** Bits are stored as an array of bytes.
0: 	** Bits are numbered starting at 0.  Bits
0: 	** 0..7 go in byte[0], 8..15 in byte[1] and so on.
0: 	** The number of bytes is tracked as part
0: 	** of the byte array.  The number of bits
0: 	** being used is derived by the number of
0: 	** bytes being used and the number of bits
0: 	** being used by the last byte.  The partially
0: 	** unused byte is always byte[byte.length] with the
0: 	** lowest bits being unused.
0: 	**
0: 	** Zero length bits are stored using a
0: 	** zero length byte array, with all bits
0: 	** marked as unused.
0: 	*/
0: 	private byte[]	value;
0: 	private	short	bitsInLastByte;
0: 
0: 	private transient int	lengthAsBits;
0: 
0: 	/**
0: 	 * Niladic Constructor
0: 	 */
0: 	public FormatableBitSet()
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Constructs a Bit with the initial number of bits
0: 	 */
0: 	public FormatableBitSet(int numBits)
0: 	{
0: 		initializeBits(numBits);
0: 	}
0: 
0: 	private void initializeBits(int numBits)
0: 	{
0: 		int numBytes = numBytesFromBits(numBits);
0: 
0: 		// the byte array is zero'ed out by the new operator
0: 		value = new byte[numBytes];
0: 		bitsInLastByte = numBitsInLastByte(numBits);
0: 		lengthAsBits = numBits;
0: 	}
0: 
0: 	/**
0: 	 * Constructs a Bit from an array of bytes.  Assume
0: 	 * bytes are all being used.
0: 	 *
0: 	 * @param newValue	The array of bytes to make up the new Bit
0: 	 */
0: 	public FormatableBitSet(byte[] newValue)
0: 	{
0: 		value = newValue;
0: 		bitsInLastByte = 8;
0: 		lengthAsBits = calculateLength(newValue.length);
0: 	}
0: 
0: 	/**
0: 	 * Constructs a Bit from an array of bytes.
0: 	 *
0: 	 * @param newValue	The array of bytes to make up the new Bit
0: 	 * @param numBits	The number of bits
0: 	 */
0: 	public FormatableBitSet(byte[] newValue, int numBits)
0: 	{
0: 		bitsInLastByte = numBitsInLastByte(numBits);
0: 		lengthAsBits = numBits;
0: 
0: 		int lenInBytes = numBytesFromBits(numBits);
0: 
0: 		if (lenInBytes == newValue.length) {
0: 			value = newValue;
0: 		} else {
0: 			value = new byte[lenInBytes];
0: 			System.arraycopy(newValue, 0, value, 0, newValue.length);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Copy constructor
0: 	 *
0: 	 * @param original the FormatableBitSet to make a copy from
0: 	 */
0: 	public FormatableBitSet (FormatableBitSet original)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(
0:                 original != null, "cannot make copy from a null FormatableBitSet");
0: 
0: 		bitsInLastByte = original.bitsInLastByte;
0: 		lengthAsBits = original.lengthAsBits;
0: 
0: 		int lenInBytes = FormatableBitSet.numBytesFromBits(original.lengthAsBits);
0: 		value = new byte[lenInBytes];
0: 		if (lenInBytes > 0)
0: 			System.arraycopy(original.value, 0, value, 0, lenInBytes);
0: 	}
0: 			
0: 	/*
0: 	 * Cloneable
0: 	 */
0: 	public Object clone()
0: 	{
0: 		return new FormatableBitSet(this);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the length in bytes of a Bit value
0: 	 *
0: 	 * @return	The length in bytes of this value
0: 	 */
0: 	public int getLengthInBytes()
0: 	{
0: 		if (value == null)
0: 		{
0: 			return 0;
0: 		}
0: 
0: 		return FormatableBitSet.numBytesFromBits(lengthAsBits);
0: 	}
0: 
0: 	/**
0: 	** Get the length in bits
0: 	**
0: 	** @return The length in bits for this value
0: 	**
0: 	** NOTE: could possibly be changed to a long.  As is
0: 	** we are restricted to 2^(31-3) -> 256meg instead
0: 	** of 2^31 (Integer.MAX_VALUE) like other datatypes
0: 	** (or 2 gig).  If it is ever changed to a long
0: 	** be sure to change read/writeExternal which write
0: 	** out the length in bits.
0: 	*/
0: 	public int getLength() {
0: 		return lengthAsBits;
0: 	}
0: 
0: 	private int calculateLength(int realByteLength)
0: 	{
0: 		if (realByteLength == 0)
0: 		{
0: 			return 0;
0: 		}
0: 
0: 		return ((realByteLength - 1) * 8) + bitsInLastByte;
0: 	}
0: 
0: 	/**
0: 	 * Get the length in bits -- alias for getLength()
0: 	 *
0: 	 * @return The length in bits for this value
0: 	 */
0: 	public int size()
0: 	{
0: 		return getLength();
0: 	}
0: 
0: 	/**
0: 	 * Get the value of the byte array
0: 	 *
0: 	 * @return	The value of the byte array
0: 	 */
0: 
0: 	public byte[] getByteArray()
0: 	{
0: 		if (value == null)
0: 			return null;
0: 
0: 		// In some cases the array is bigger than the actual number
0: 		// of valid bytes.
0: 		int realByteLength = getLengthInBytes();
0: 
0: 		// Currently the case is that the return from this
0: 		// call only includes the valid bytes.
0: 		if (value.length != realByteLength) {
0: 			byte[] data = new byte[realByteLength];
0: 			System.arraycopy(value, 0, data, 0, realByteLength);
0: 
0: 			value = data;
0: 		}
0: 
0: 		return value;
0: 	}
0: 
0: 	/**
0: 	 * Set the value of the byte array
0: 	 *
0: 	 * @return	The value of the byte array
0: 	 */
0: 	public boolean isNull()
0: 	{
0: 		return this.value == null;
0: 	}
0: 
0: 	/**
0: 	 * Grow (widen) a FormatableBitSet to N bis
0: 	 *
0: 	 * @param n	The number of bits you want.  The bits are
0: 	 *			always added as 0 and are appended to the
0: 	 *			least significant end of the bit array.
0: 	 *
0: 	 * ASSUMPTIONS: that all extra bits in the last byte
0: 	 * are zero.
0: 	 */
0: 	public void grow(int n)
0: 	{
0: 		if (n <= this.getLength())
0: 			return;
0: 
0: 		if (value == null)
0: 		{
0: 			initializeBits(n);
0: 			return;
0: 		}
0: 
0: 		int delta = n - this.getLength();
0: 
0: 
0: 		int oldNumBytes = getLengthInBytes();
0: 
0: 		/*
0: 		** If we have enough space in the left over bits,
0: 		** then all we need to do is change the modulo.
0: 		*/
0: 		if ((oldNumBytes != 0) &&
0: 		    (8 - this.bitsInLastByte) >= delta)
0: 		{
0: 			this.bitsInLastByte += delta;
0: 			lengthAsBits = n;
0: 			return;
0: 		}
0: 
0: 		int newNumBytes = FormatableBitSet.numBytesFromBits(n);
0: 
0: 		// is there enough room in the existing array
0: 		if (newNumBytes <= value.length) {
0: 			// ensure the bits are zeroed
0: 			for (int i = oldNumBytes; i <  newNumBytes; i++)
0: 				value[i] = 0;
0: 		} else {
0: 
0: 
0: 			/*
0: 			** We didn't have enough bytes in value, so we need
0: 			** to create a bigger byte array and use that.
0: 			*/
0: 			byte[] newValue = new byte[newNumBytes];
0: 
0: 			System.arraycopy(value, 0, newValue, 0, oldNumBytes);
0: 
0: 			value = newValue;
0: 		}
0: 		bitsInLastByte = numBitsInLastByte(n);
0: 		lengthAsBits = n;
0: 	}
0: 
0: 	/**
0: 	 * Shrink (narrow) a FormatableBitSet to N bits
0: 	 *
0: 	 * @param n	The number of bits the caller wants.  The
0: 	 * 			bits are always removed from the
0: 	 *			least significant end of the bit array.
0: 	 */
0: 	public FormatableBitSet shrink(int n)
0: 	{
0: 		int		numBytes;
0: 		int		lastByteNum;
0: 
0: 		/*
0: 		** Sanity check: we shouldn't shrink down to
0: 		** nothing.
0: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (value == null)
0: 			{
0: 				SanityManager.THROWASSERT("Attempt to shrink a null Bit"+
0: 						" -- caller should have known better probably");
0: 				return null;
0: 			}
0: 		}
0: 
0: 		if (n >= this.getLength())
0: 		{
0: 			return this;
0: 		}
0: 
0: 
0: 		lastByteNum = numBytesFromBits(n) - 1;
0: 		bitsInLastByte = numBitsInLastByte(n);
0: 		lengthAsBits = n;
0: 
0: 		/*
0: 		** Mask out any left over bits in the
0: 		** last byte.  Retain the highest bits.
0: 		*/
0: 		if (bitsInLastByte != 8)
0: 		{
0: 			value[lastByteNum] &= 0xFF00 >> bitsInLastByte;
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/*
0: 	** Some of the operators required by SQL.  These could alternatively
0: 	** be in SQLBit, but since they are so tightly bound to the implementation
0: 	** rather than return something that undermines the encapsulation
0: 	** of this type, i have chosen to put them in here.
0: 	*/
0: 
0: 	/**
0: 	 * Bit equivalence.  Compare this with other.
0: 	 * If the length is different, then cannot be
0: 	 * equal so short circuit.  Otherwise, rely on
0: 	 * compare().  Note that two zero length bits are
0: 	 * considered equal.
0: 	 *
0: 	 * @param other	the other bit to compare to
0: 	 *
0: 	 * @return TRUE|FALSE
0: 	 */
0: 	public boolean equals(FormatableBitSet other)
0: 	{
0: 		if (this.getLength() != other.getLength())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		return (this.compare(other) == 0);
0: 	}
0: 
0: 	/**
0: 	 * Bit comparison.  Compare this with other.
0: 	 * Will always do a byte by byte compare.
0: 	 *
0: 	 * Given 2 similar bits of unequal lengths (x and y),
0: 	 * where x.getLength() < y.getLength() but where:
0: 	 *
0: 	 *	 x[0..x.getLength()] == y[0..x.getLength()]
0: 	 *
0: 	 * then x < y.
0: 	 *
0: 	 *
0: 	 * @param other the other bit to compare to
0: 	 *
0: 	 * @return -1	- if other <  this
0: 	 *			0	- if other == this
0: 	 *			1	- if other >  this
0: 	 *
0: 	 */
0: 	public int compare(FormatableBitSet other)
0: 	{
0: 
0: 		int		otherCount, thisCount;
0: 		int		otherLen, thisLen;
0: 		byte[]	otherb;
0: 
0: 		otherb = other.value;
0: 		/*
0: 		** By convention, nulls sort low, and null == null
0: 		*/
0: 		if (this.value == null || otherb == null)
0: 		{
0: 			if (this.value != null)	// otherb == null
0: 				return 1;
0: 			if (otherb != null)		// this.value == null
0: 				return -1;
0: 			return 0;				// both null
0: 		}
0: 
0: 		otherLen = other.getLengthInBytes();
0: 		thisLen = getLengthInBytes();
0: 		for (otherCount = 0, thisCount = 0;
0: 				otherCount < otherLen && thisCount < thisLen;
0: 				otherCount++, thisCount++)
0: 		{
0: 			if (otherb[otherCount] != this.value[thisCount])
0: 				break;
0: 		}
0: 
0: 		/*
0: 		** '==' if byte by byte comparison is identical and
0: 		** exact same length in bits (not bytes).
0: 		*/
0: 		if ((otherCount == otherLen) && (thisCount == thisLen))
0: 		{
0: 				if (this.getLength() == other.getLength())
0: 				{
0: 					return 0;
0: 				}
0: 
0: 				/*
0: 				** If subset of bits is identical, return 1
0: 				** if other.getLength() > this.getLength(); otherwise,
0: 				** -1
0: 				*/
0: 				return (other.getLength() < this.getLength()) ? 1 : -1;
0: 		}
0: 
0: 		if (otherCount == otherLen)
0: 		{
0: 			return 1;
0: 		}
0: 		else if (thisCount == thisLen)
0: 		{
0: 			return -1;
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** Ok, we have a difference somewhere.  Now
0: 			** we have to go to the trouble of converting
0: 			** to a int and masking out the sign to get
0: 			** a valid comparision because bytes are signed.
0: 			*/
0: 			int otherInt, thisInt;
0: 
0: 			otherInt = (int)otherb[otherCount];
0: 			otherInt &= (0x100 - 1);
0: 
0: 			thisInt = (int)this.value[thisCount];
0: 			thisInt &= (0x100 - 1);
0: 
0: 			return (thisInt > otherInt) ? 1 : -1;
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bit concatenation.
0: 	 *
0: 	 * @param other 	the other bit to append to this
0: 	 *
0: 	 * @return Bit -- the newly concatenated bit
0: 	 *
0: 	 */
0: 	public FormatableBitSet concatenate(FormatableBitSet other)
0: 	{
0: 		int		newLen;
0: 		int		otherLen;
0: 		int		prevLen;
0: 		int		prevLenBytes;
0: 		int		newLenBytes;
0: 		int     otherLenBytes;
0: 		int		i, j;
0: 		byte[]	newValue;
0: 		byte[]	otherValue;
0: 		int		shiftBits;
0: 		int		inByte;
0: 
0: 
0: 		prevLen = this.getLength();
0: 		prevLenBytes = this.getLengthInBytes();
0: 		otherLen = other.getLength();
0: 		otherValue = other.getByteArray();
0: 		otherLenBytes = other.getLengthInBytes();
0: 		newLen = prevLen + otherLen;
0: 		newLenBytes = numBytesFromBits(newLen);
0: 		newValue = new byte[newLenBytes];
0: 
0: 
0: 		/*
0: 		** Copy over the entire array in this.value
0: 		** to newLenBytes.
0: 		*/
0: 		for (i = 0; i < prevLenBytes; i++)
0: 		{
0: 			newValue[i] = this.value[i];
0: 		}
0: 
0: 		/*
0: 		** Now if we have any bits left over
0: 		** we need to shift them, and keep
0: 		** shifting everything down.  Be careful
0: 		** to handle the case where the bit
0: 		** used to have length 0.
0: 		*/
0: 		shiftBits = (prevLen == 0) ? 8 : this.bitsInLastByte;
0: 		for (j = 0; j < otherLenBytes; j++, i++)
0: 		{
0: 			if (shiftBits == 8)
0: 			{
0: 				newValue[i] = otherValue[j];
0: 			}
0: 			else
0: 			{
0: 				/*
0: 				** Convert to an int because it will get converted
0: 				** on the shift anyway.
0: 				*/
0: 				inByte = (int)otherValue[j];
0: 
0: 				/*
0: 				** Mask off the high bits in case they are now
0: 				** turned on if we had the sign bit on.
0: 				*/
0: 				inByte &= (0x100 - 1);
0: 
0: 				/*
0: 				** Use the high order bits to finish off
0: 				** the last byte
0: 				*/
0: 				newValue[i-1] |= (inByte >>> shiftBits);
0: 
0: 	            /*
0: 		        ** Start the next one with whatever is left, unless
0: 		        ** there is nothing left.
0: 	            */
0: 	            if (i < newLenBytes)
0: 				{
0: 		            newValue[i] |= (inByte << (8 - shiftBits));
0: 				}
0: 			}
0: 		}
0: 
0: 		return new FormatableBitSet(newValue, newLen);
0: 	}
0: 
0:     /**
0:      * Produce a hash code by putting the value bytes into an int, exclusive OR'ing
0:      * if there are more than 4 bytes.
0:      *
0:      * @return the hash code
0:      */
0:     public int hashCode()
0:     {
0:         if( null == value)
0:             return 0;
0:         
0:         int code = 0;
0:         int i;
0:         int shift = 0;
0: 
0: 		int byteLength = getLengthInBytes();
0:         for( i = 0; i < byteLength; i++)
0:         {
0:             code ^= (value[i] & 0xff)<<shift;
0:             shift += 8;
0:             if( 32 <= shift)
0:                 shift = 0;
0:         }
0:         return code;
0:     }
0:     
0: 	/**
0: 	 * Bit isSet
0: 	 *
0: 	 * @param position	the bit to check
0: 	 *
0: 	 */
0: 	public final boolean isSet(int position)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (position >= this.getLength())
0:             {
0:                 SanityManager.THROWASSERT(
0:                    "Attempt to get a bit position (" + position +
0:                    ")" +
0:                    "that exceeds the max length (" + this.getLength() + ")");
0:             }
0: 		}
0: 
0: 		try {
0: 
0: 			int bytepos = position / 8;
0: 			int bitpos = 7 - (position % 8);
0: 
0: 			return ((value[bytepos] & (1 << bitpos)) != 0);
0: 
0: 		} catch (ArrayIndexOutOfBoundsException e) {
0: 			// Should not happen, handle it just in case not all cases are tested
0: 			// by insane server.
0: 			return false;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bit get -- alias for isSet()
0: 	 *
0: 	 * @param position	the bit to check
0: 	 *
0: 	 */
0: 	public final boolean get(int position)
0: 	{
0: 		return isSet(position);
0: 	}
0: 	
0: 	/**
0: 	 * Bit set
0: 	 *
0: 	 * @param position	the bit to set
0: 	 *
0: 	 */
0: 	public void set(int position)
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0:             if (position >= this.getLength())
0:             {
0:                 SanityManager.THROWASSERT(
0: 				   "Attempt to set a bit position that exceeds the max length ("
0:                    + this.getLength() + ")");
0:             }
0: 		}
0: 
0: 		// Should not happen, handle it just in case not all cases are tested
0: 		// by insane server.
0: 		if (position >= getLength())
0: 			grow(position);
0: 
0: 		int bytepos = position / 8;
0: 		int bitpos = 7 - (position % 8);
0: 
0: 		value[bytepos] |= (1 << bitpos);
0: 	}
0: 
0: 	/**
0: 	 * Bit clear
0: 	 *
0: 	 * @param position	the bit to clear
0: 	 *
0: 	 */
0: 	public void clear(int position)
0: 	{
0: 		int	bytepos;
0: 		int	bitpos;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0:             if (position >= this.getLength())
0:             {
0:                 SanityManager.THROWASSERT(
0:                    "Attempt to set a bit position that exceeds the max length ("
0:                    + this.getLength() + ")");
0:             }
0: 		}
0: 
0: 		// Should not happen, handle it just in case not all cases are tested
0: 		// by insane server.
0: 		if (position >= getLength())
0: 			grow(position);
0: 
0: 		bytepos = position / 8;
0: 		bitpos = 7 - (position % 8);
0: 
0: 		value[bytepos] &= ~(1 << bitpos);
0: 	}
0: 
0: 	/**
0: 	  Clear all the bits in this FormatableBitSet
0: 	  */
0: 	public void clear()
0: 	{
0: 		if (value == null) 
0:             return;
0: 
0: 		int byteLength = getLengthInBytes();
0: 		for (int ix=0; ix < byteLength; ix++)
0:             value[ix] = 0;
0: 	}
0: 
0: 
0: 	/**
0: 	* Figure out how many bytes are needed to
0: 	* store the input number of bits.
0: 	*
0: 	* @param bits	bits
0: 	*
0: 	* @return	the number of bytes
0: 	*/
0: 	protected static int
0: 	numBytesFromBits(int bits)
0: 	{
0: 		return (bits == 0) ? 0 : ((bits - 1) / 8) + 1;
0: 	}
0: 
0: 	/**
0: 	* Figure out how many bits are in the last
0: 	* byte from the total number of bits.
0: 	*
0: 	* @param	bits	bits
0: 	*
0: 	* @return	the number of bits
0: 	*/
0: 	private static short
0: 	numBitsInLastByte(int bits)
0: 	{
0: 		int modulo = bits % 8;
0: 		return (short)((modulo == 0) ?
0: 				((bits == 0) ? 0 : 8) :
0: 				modulo);
0: 	}
0: 
0: 	/**
0: 	 * Translate a hex character to a byte.
0: 	 *
0: 	 * @param hexChar	A character with the value [0-9a-fA-F].
0: 	 *
0: 	 * @return	A byte with the numeric value corresponding to the hex character
0: 	 */
0: 	private static byte
0: 	hexCharToByte(char hexChar)
0: 	{
0: 		byte	byteValue;
0: 
0: 		switch (hexChar)
0: 		{
0: 		  case '0':
0: 			byteValue = 0;
0: 			break;
0: 
0: 		  case '1':
0: 			byteValue = 1;
0: 			break;
0: 
0: 		  case '2':
0: 			byteValue = 2;
0: 			break;
0: 
0: 		  case '3':
0: 			byteValue = 3;
0: 			break;
0: 
0: 		  case '4':
0: 			byteValue = 4;
0: 			break;
0: 
0: 		  case '5':
0: 			byteValue = 5;
0: 			break;
0: 
0: 		  case '6':
0: 			byteValue = 6;
0: 			break;
0: 
0: 		  case '7':
0: 			byteValue = 7;
0: 			break;
0: 
0: 		  case '8':
0: 			byteValue = 8;
0: 			break;
0: 
0: 		  case '9':
0: 			byteValue = 9;
0: 			break;
0: 
0: 		  case 'a':
0: 		  case 'A':
0: 			byteValue = 0xA;
0: 			break;
0: 
0: 		  case 'b':
0: 		  case 'B':
0: 			byteValue = 0xB;
0: 			break;
0: 
0: 		  case 'c':
0: 		  case 'C':
0: 			byteValue = 0xC;
0: 			break;
0: 
0: 		  case 'd':
0: 		  case 'D':
0: 			byteValue = 0xD;
0: 			break;
0: 
0: 		  case 'e':
0: 		  case 'E':
0: 			byteValue = 0xE;
0: 			break;
0: 
0: 		  case 'f':
0: 		  case 'F':
0: 			byteValue = 0xF;
0: 			break;
0: 
0: 		  default:
0: 			  if (SanityManager.DEBUG)
0: 			  {
0: 				  SanityManager.THROWASSERT("illegal char = " + hexChar);
0: 			  }
0: 		  	throw new IllegalArgumentException();
0: 		}
0: 
0: 		return byteValue;
0: 	}
0: 
0: private static char[] decodeArray = {'0', '1', '2', '3', '4', '5', '6', '7',
0: 								'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
0: 
0: 	/**
0: 	 * Format the string into BitSet format: {0, 2, 4, 8} if bits 0, 2, 4, 8
0: 	 * are set.
0: 	 *
0: 	 * @return A new String containing the formatted Bit value
0: 	 */
0: 	public String toString()
0: 	{
0: 		char[]	outChars;
0: 		int		inPosition;
0: 		int		outPosition;
0: 		int 	inByte;
0: 
0: 		if (value == null)
0: 		{
0: 			return null;
0: 		}
0: 		{
0: 			// give it a reasonable size
0: 			StringBuffer str = new StringBuffer(getLength()*8*3);
0: 			str.append("{");
0: 			boolean first = true;
0: 			for (inPosition = 0; inPosition < getLength(); inPosition++)
0: 			{
0: 				if (isSet(inPosition))
0: 				{
0: 					if (!first)
0: 						str.append(", ");
0: 					first = false;
0: 					str.append(inPosition);
0: 				}
0: 			}
0: 			str.append("}");
0: 			return new String(str);
0: 		}
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 * Statically calculates how many bits can fit into the number of
0: 	 * bytes if this Bit object is externalized.  Only valid for this
0: 	 * implementation of Bit.
0: 	 */
0: 	public static int maxBitsForSpace(int numBytes)
0: 	{
0: 		return (numBytes - 4)*8;
0: 		
0: 	}
0: 
0: 	/**
0: 	 * If any bit is set, return the bit number of a bit that is set.
0: 	 * If no bit is set, return -1; 
0: 	 *
0: 	 * @return the bit number of a bit that is set, or -1 if no bit is set
0: 	 */
0: 	public int anySetBit()
0: 	{
0: 		int numbytes = getLengthInBytes();
0: 		int bitpos;
0: 
0: 		for (int i = 0; i < numbytes-1; i++)
0: 		{
0: 			if (value[i] != 0)
0: 			{
0: 				for (int j = 0; j < 8; j++)
0: 				{
0: 					bitpos = 7-j;
0: 					if (((1 << bitpos) & value[i]) != 0)
0: 						return ((i*8)+j);
0: 				}
0: 			}
0: 		}
0: 
0: 
0: 		// only the top part of the last byte is relevant
0: 		byte mask = (byte)(0xFF << (8-bitsInLastByte));
0: 		if ((value[numbytes-1] & mask) != 0)
0: 		{
0: 			for (int j = 0; j < bitsInLastByte; j++)
0: 			{
0: 				bitpos = 7-j;
0: 				if (((1 << bitpos) & value[numbytes-1]) != 0)
0: 					return ((numbytes-1)*8)+j;
0: 			}
0: 		}
0: 
0: 		return -1;
0: 	}
0: 
0: 	/**
0: 	 * Like anySetBit(), but return any set bit whose number is bigger than
0: 	 * beyondBit. If no bit is set after beyondBit, -1 is returned. 
0: 	 * By using anySetBit() and anySetBit(beyondBit), one can quickly go
0: 	 * thru the entire bit array to return all set bit.
0: 	 *
0: 	 * @param beyondBit only look at bit that is greater than this bit number
0: 	 * @return the bit number of a bit that is set, or -1 if no bit after
0: 	 * beyondBit is set
0: 	 */
0: 	public int anySetBit(int beyondBit)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (beyondBit >= this.getLength())
0:                 SanityManager.THROWASSERT(
0:                    "Attempt to access bit position that exceeds the max length ("
0:                     + this.getLength() + ")");
0: 		}
0: 
0: 		int startingBit = (beyondBit+1);
0: 
0: 		// we have seen the last bit.
0: 		if (startingBit >= this.getLength())
0: 			return -1;
0: 
0: 		int numbytes = getLengthInBytes();
0: 		int startingByte = startingBit / 8;
0: 		int startingBitpos = startingBit % 8;
0: 		int bitpos;
0: 		byte mask;
0: 
0: 		// see if any bits in this byte is set, only the bottom part of the
0: 		// first byte is relevant
0: 		mask = (byte)(0xFF >> startingBitpos);
0: 
0: 		if (startingByte == numbytes-1)	// starting byte == last byte 
0: 			mask &= (byte)(0xFF << (8-bitsInLastByte));
0: 
0: 		if ((value[startingByte] & mask ) != 0)
0: 		{
0: 			// I know we will see the bit before bitsInLastByte even if we are
0: 			// at the last byte, no harm in going up to 8 in the loop
0: 			for (int j = startingBitpos; j < 8; j++)
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if (startingByte == numbytes-1)
0: 						SanityManager.ASSERT(j < bitsInLastByte,
0: 								 "going beyond the last bit");
0: 				}
0: 				bitpos = 7-j;
0: 				if (((1 << bitpos) & value[startingByte]) != 0)
0: 				{
0: 					return (startingByte*8+j);
0: 				}
0: 			}	
0: 		}
0: 
0: 		for (int i = (startingByte+1); i < numbytes-1; i++)
0: 		{			
0: 			if (value[i] != 0)
0: 			{
0: 				for (int j = 0; j < 8; j++)
0: 				{
0: 					bitpos = 7-j;
0: 					if (((1 << bitpos) & value[i]) != 0)
0: 					{
0: 						return ((i*8)+j);
0: 					}
0: 				}
0: 			}
0: 		}
0: 		
0: 		// Last byte if there are more than one bytes.  Only the top part of
0: 		// the last byte is relevant 
0: 		if (startingByte != numbytes-1)
0: 		{
0: 			mask = (byte)(0xFF << (8-bitsInLastByte));
0: 
0: 			if ((value[numbytes-1] & mask) != 0)
0: 			{
0: 				for (int j = 0; j < bitsInLastByte; j++)
0: 				{
0: 					bitpos = 7-j;
0: 					if (((1 << bitpos) & value[numbytes-1]) != 0)
0: 					{
0: 						return ((numbytes-1)*8)+j;	
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		return -1;
0: 
0: 	}
0: 
0: 	/**
0: 	 * Bitwise OR this Bit with another Bit.
0: 	 *
0: 	 * @param otherBit the other Bit
0: 	 * @see Bit#or
0: 	 */
0: 	public void or(FormatableBitSet otherBit)
0: 	{
0: 		if (otherBit == null || otherBit.getLength() == 0)
0: 			return;
0: 
0: 		int otherLength = otherBit.getLength();
0: 
0: 		if (otherLength > getLength())
0: 			grow(otherLength); // expand this bit 
0: 
0: 		if (otherBit instanceof FormatableBitSet)
0: 		{
0: 			// we know the bit ordering, optimize this 
0: 			FormatableBitSet ob = (FormatableBitSet)otherBit;
0: 			int obByteLen = ob.getLengthInBytes();
0: 			for (int i = 0; i < obByteLen-1; i++)
0: 				value[i] |= ob.value[i];
0: 
0: 			// do the last byte bit by bit
0: 			for (int i = (obByteLen-1)*8; i < otherLength; i++)
0: 				if (otherBit.isSet(i))
0: 					set(i);
0: 		}
0: 		else
0: 		{
0: 			// we don't know the bit ordering, call thru the interface and go
0: 			// thru bit by bit
0: 			// this bit impl's length >= other bit's length
0: 
0: 			for (int i = 0; i < otherLength; i++)
0: 			{
0: 				if (otherBit.isSet(i))
0: 					set(i);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bitwise AND this Bit with another Bit.
0: 	 *
0: 	 * @param otherBit the other Bit
0: 	 * @see Bit#or
0: 	 */
0: 	public void and(FormatableBitSet otherBit)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(otherBit != null, "cannot AND null with a FormatableBitSet");
0: 
0: 		int otherLength = otherBit.getLength();
0: 
0: 		// Supposedly cannot happen, but handle it just in case.
0: 		if (otherLength > getLength())
0: 			grow(otherLength); // expand this bit 
0: 
0: 		if (otherLength < getLength())
0: 		{
0: 			// clear all bits that are not in the other bit
0: 			int startingByte = (otherLength * 8) + 1;
0: 			int len = getLengthInBytes();
0: 			for (int i = startingByte; i < len; i++)
0: 				value[i] = 0;
0: 
0: 			for (int i = otherLength; i < startingByte*8; i++)
0: 			{
0: 				if (i < getLength())
0: 					clear(i);
0: 				else
0: 					break;
0: 			}
0: 		}
0: 
0: 		if (otherLength == 0)
0: 			return;
0: 			
0: 		int length = otherBit.getLengthInBytes() < getLengthInBytes() ? 
0: 			otherBit.getLengthInBytes() : getLengthInBytes();
0: 
0: 		for (int i = 0; i < length; i++)
0: 			value[i] &= otherBit.value[i];
0: 	}
0: 
0: 	/**
0: 	 * Logically XORs this FormatableBitSet with the specified FormatableBitSet.
0: 	 * @param set	The FormatableBitSet to be XORed with.
0: 	 */
0: 	public void xor(FormatableBitSet set)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (getLength() != set.getLength())
0: 			{
0: 				SanityManager.THROWASSERT("getLength() (" + getLength() +
0: 					") and set.getLength() (" +
0: 					set.getLength() +
0: 					") expected to be the same");
0: 			}
0: 		}
0: 
0: 		int setLength = set.getLength();
0: 		for (int i = setLength; i-- > 0; )
0: 		{
0: 			if (isSet(i) && set.isSet(i))
0: 			{
0: 				clear(i);
0: 			}
0: 			else if (isSet(i) || set.isSet(i))
0: 			{
0: 				set(i);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get a count of the number of bits that are set.
0: 	 *
0: 	 * @return The number of bits that are set.
0: 	 */
0: 	public int getNumBitsSet()
0: 	{
0: 		int count = 0;
0: 
0: 		for (int index = getLength() - 1; index >= 0; index--)
0: 		{
0: 			if (isSet(index))
0: 			{
0: 				count++;
0: 			}
0: 		}
0: 
0: 		return count;
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////
0: 	//
0: 	// EXTERNALIZABLE
0: 	//
0: 	/////////////////////////////////////////////////////////
0: 	/**
0: 	 * Format: <UL>
0: 	 *		<LI>int		length in bits  </LI>
0: 	 *		<LI>byte[]					</LI></UL>
0: 	 *
0: 	 * @see java.io.Externalizable#writeExternal
0: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 		// never called when value is null
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(value != null);
0: 
0: 		out.writeInt(getLength());
0: 		int byteLen = getLengthInBytes();
0: 		if (byteLen > 0)
0: 		{
0: 			out.write(value, 0, byteLen);
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Note: gracefully handles zero length
0: 	 * bits -- will create a zero length array
0: 	 * with no bits being used.  Fortunately
0: 	 * in.read() is ok with a zero length array
0: 	 * so no special code.
0: 	 * <p>
0: 	 * WARNING: this method cannot be changed w/o
0: 	 * changing SQLBit because SQLBit calls this
0: 	 * directly w/o calling read/writeObject(), so
0: 	 * the format id is not stored in that case.
0: 	 *
0: 	 * @see java.io.Externalizable#readExternal
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException
0: 	{
0: 		int lenInBits;
0: 		int lenInBytes;
0: 
0: 		lenInBits = in.readInt();
0: 
0: 		lenInBytes = FormatableBitSet.numBytesFromBits(lenInBits);
0: 
0: 
0: 		/*
0: 		** How can lenInBytes be zero?  The implication is
0: 		** that lenInBits is zero.  Well, the reason this can
0: 		** happen is that the store will reset our stream
0: 		** out from underneath us if we are a Bit column that
0: 		** overflows onto another page because it assumes that
0: 		** we want to stream it in specially.  Because of this warped
0: 		** API, our readInt() will return 0 even though our
0: 		** writeExternal() did a writeInt(xxx).  The upshot
0: 		** is that you should leave the following alone.
0: 		*/
0: 
0: 			value = new byte[lenInBytes];
0: 
0: 			in.readFully(value);
0: 
0: 			bitsInLastByte = numBitsInLastByte(lenInBits);
0: 
0: 			lengthAsBits = lenInBits;
0: 	}
0: 
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
0: 	{
0: 		int lenInBits = in.readInt();
0: 
0: 		int lenInBytes = FormatableBitSet.numBytesFromBits(lenInBits);
0: 
0: 		value = new byte[lenInBytes];
0: 
0: 		in.readFully(value);
0: 
0: 		bitsInLastByte = numBitsInLastByte(lenInBits);
0: 
0: 		lengthAsBits = lenInBits;
0: 	}
0: 
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.BITIMPL_V01_ID; }
0: }
============================================================================