1:70f7692: /*
24:70f7692: 
1:33776ff:    Derby - Class org.apache.derby.client.ClientDataSource
1:5ef7a0d: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:b3bfe12: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:70f7692: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:70f7692: 
8:70f7692: */
1:cbd0ff1: 
1:33776ff: package org.apache.derby.jdbc;
1:70f7692: 
1:7863d83: import java.util.Enumeration;
1:7863d83: import java.util.Properties;
1:7863d83: import javax.naming.NamingException;
1:7863d83: import javax.naming.Reference;
1:7863d83: import javax.naming.Referenceable;
1:7863d83: import javax.naming.StringRefAddr;
1:7863d83: import org.apache.derby.client.ClientDataSourceFactory;
1:7863d83: 
1:5ef7a0d: /**
1:7863d83:  * This data source is suitable for a client/server use of Derby,
1:fd584b0:  * running on full Java SE 6 and higher, corresponding to JDBC 4.0 and higher.
1:2913612:  * <p/>
1:54792be:  * ClientDataSource is a simple data source implementation
1:54792be:  * that can be used for establishing connections in a
1:54792be:  * non-pooling, non-distributed environment.
1:54792be:  * The class ClientConnectionPoolDataSource can be used in a connection pooling environment,
1:54792be:  * and the class ClientXADataSource can be used in a distributed, and pooling
1:2913612:  * environment.
1:54792be:  *
1:54792be:  * <p>The example below registers a DNC data source object with a JNDI naming service.
1:33776ff:  * <pre>
1:33776ff:  * org.apache.derby.client.ClientDataSource dataSource = new org.apache.derby.client.ClientDataSource ();
1:33776ff:  * dataSource.setServerName ("my_derby_database_server");
1:33776ff:  * dataSource.setDatabaseName ("my_derby_database_name");
1:33776ff:  * javax.naming.Context context = new javax.naming.InitialContext();
1:33776ff:  * context.bind ("jdbc/my_datasource_name", dataSource);
1:33776ff:  * </pre>
1:54792be:  * The first line of code in the example creates a data source object.
1:54792be:  * The next two lines initialize the data source's
1:54792be:  * properties. Then a Java object that references the initial JNDI naming
1:54792be:  * context is created by calling the
1:54792be:  * InitialContext() constructor, which is provided by JNDI.
1:54792be:  * System properties (not shown) are used to tell JNDI the
1:54792be:  * service provider to use. The JNDI name space is hierarchical,
1:54792be:  * similar to the directory structure of many file
1:54792be:  * systems. The data source object is bound to a logical JNDI name
1:54792be:  * by calling Context.bind(). In this case the JNDI name
1:54792be:  * identifies a subcontext, "jdbc", of the root naming context
1:54792be:  * and a logical name, "my_datasource_name", within the jdbc
1:54792be:  * subcontext. This is all of the code required to deploy
1:54792be:  * a data source object within JNDI. This example is provided
1:54792be:  * mainly for illustrative purposes. We expect that developers
1:54792be:  * or system administrators will normally use a GUI tool to
1:70f7692:  * deploy a data source object.
1:70f7692:  * <p/>
1:54792be:  * Once a data source has been registered with JNDI,
1:54792be:  * it can then be used by a JDBC application, as is shown in the
1:70f7692:  * following example.
1:33776ff:  * <pre>
1:33776ff:  * javax.naming.Context context = new javax.naming.InitialContext ();
1:33776ff:  * javax.sql.DataSource dataSource = (javax.sql.DataSource) context.lookup ("jdbc/my_datasource_name");
1:33776ff:  * java.sql.Connection connection = dataSource.getConnection ("user", "password");
1:33776ff:  * </pre>
1:54792be:  * The first line in the example creates a Java object
1:54792be:  * that references the initial JNDI naming context. Next, the
1:54792be:  * initial naming context is used to do a lookup operation
1:54792be:  * using the logical name of the data source. The
1:54792be:  * Context.lookup() method returns a reference to a Java Object,
1:54792be:  * which is narrowed to a javax.sql.DataSource object. In
1:54792be:  * the last line, the DataSource.getConnection() method
1:54792be:  * is called to produce a database connection.
6:70f7692:  * <p/>
1:7863d83:  * This simple data source subclass of BasicClientDataSource40 maintains
1:54792be:  * it's own private <code>password</code> property.
1:70f7692:  * <p/>
1:54792be:  * The specified password, along with the user, is validated by DERBY.
1:04fc939:  * This property can be overwritten by specifying
1:70f7692:  * the password parameter on the DataSource.getConnection() method call.
1:70f7692:  * <p/>
1:54792be:  * This password property is not declared transient, and therefore
1:54792be:  * may be serialized to a file in clear-text, or stored
1:54792be:  * to a JNDI server in clear-text when the data source is saved.
1:54792be:  * Care must taken by the user to prevent security
1:70f7692:  * breaches.
1:70f7692:  * <p/>
1:5ef7a0d:  */
1:7863d83: public class ClientDataSource extends BasicClientDataSource40 
1:7863d83:                               implements Referenceable {
1:8269b78: 
1:70f7692:     private final static long serialVersionUID = 1894299584216955553L;
1:70f7692:     public static final String className__ = "org.apache.derby.jdbc.ClientDataSource";
1:5ef7a0d: 
1:70f7692:     // If a newer version of a serialized object has to be compatible with an older version, it is important that the newer version abides
1:70f7692:     // by the rules for compatible and incompatible changes.
1:70f7692:     //
1:70f7692:     // A compatible change is one that can be made to a new version of the class, which still keeps the stream compatible with older
1:70f7692:     // versions of the class. Examples of compatible changes are:
1:70f7692:     //
1:70f7692:     // Addition of new fields or classes does not affect serialization, as any new data in the stream is simply ignored by older
1:70f7692:     // versions. When the instance of an older version of the class is deserialized, the newly added field will be set to its default
1:70f7692:     // value.
1:70f7692:     // You can field change access modifiers like private, public, protected or package as they are not reflected to the serial
1:70f7692:     // stream.
1:70f7692:     // You can change a transient or static field to a non-transient or non-static field, as it is similar to adding a field.
1:70f7692:     // You can change the access modifiers for constructors and methods of the class. For instance a previously private method
1:70f7692:     // can now be made public, an instance method can be changed to static, etc. The only exception is that you cannot change
1:70f7692:     // the default signatures for readObject() and writeObject() if you are implementing custom serialization. The serialization
1:70f7692:     // process looks at only instance data, and not the methods of a class.
1:70f7692:     //
1:70f7692:     // Changes which would render the stream incompatible are:
1:70f7692:     //
1:70f7692:     // Once a class implements the Serializable interface, you cannot later make it implement the Externalizable interface, since
1:70f7692:     // this will result in the creation of an incompatible stream.
1:70f7692:     // Deleting fields can cause a problem. Now, when the object is serialized, an earlier version of the class would set the old
1:70f7692:     // field to its default value since nothing was available within the stream. Consequently, this default data may lead the newly
1:70f7692:     // created object to assume an invalid state.
1:70f7692:     // Changing a non-static into static or non-transient into transient is not permitted as it is equivalent to deleting fields.
1:70f7692:     // You also cannot change the field types within a class, as this would cause a failure when attempting to read in the original
1:70f7692:     // field into the new field.
1:70f7692:     // You cannot alter the position of the class in the class hierarchy. Since the fully-qualified class name is written as part of
1:70f7692:     // the bytestream, this change will result in the creation of an incompatible stream.
1:70f7692:     // You cannot change the name of the class or the package it belongs to, as that information is written to the stream during
1:70f7692:     // serialization.
1:02d3427: 
1:70f7692: 
1:5ef7a0d:     /**
1:70f7692:      * Creates a simple DERBY data source with default property values for a non-pooling, non-distributed environment.
1:70f7692:      * No particular DatabaseName or other properties are associated with the data source.
1:70f7692:      * <p/>
1:70f7692:      * Every Java Bean should provide a constructor with no arguments since many beanboxes attempt to instantiate a bean
1:70f7692:      * by invoking its no-argument constructor.
1:5ef7a0d:      */
1:70f7692:     public ClientDataSource() {
1:70f7692:         super();
2:5ef7a0d:     }
1:cbd0ff1: 
1:7863d83:     //------------------------ Referenceable interface methods -----------------------------
1:5ef7a0d: 
1:7863d83:     @Override
1:7863d83:     public Reference getReference() throws NamingException {
1:7863d83: 
1:7863d83:         // This method creates a new Reference object to represent this data
1:7863d83:         // source.  The class name of the data source object is saved in the
1:7863d83:         // Reference, so that an object factory will know that it should
1:7863d83:         // create an instance of that class when a lookup operation is
1:7863d83:         // performed. The class name of the object factory,
1:7863d83:         // org.apache.derby.client.ClientBaseDataSourceFactory, is also stored
1:7863d83:         // in the reference.  This is not required by JNDI, but is recommend
1:7863d83:         // in practice.  JNDI will always use the object factory class
1:7863d83:         // specified in the reference when reconstructing an object, if a
1:7863d83:         // class name has been specified.
1:7863d83:         //
1:7863d83:         // See the JNDI SPI documentation for further details on this topic,
1:7863d83:         // and for a complete description of the Reference and StringRefAddr
1:7863d83:         // classes.
1:7863d83:         //
1:7863d83:         // This BasicClientDataSource40 class provides several standard JDBC
1:7863d83:         // properties.  The names and values of the data source properties are
1:7863d83:         // also stored in the reference using the StringRefAddr class.  This
1:7863d83:         // is all the information needed to reconstruct a ClientDataSource
1:7863d83:         // object.
1:7863d83: 
1:7863d83:         Reference ref = new Reference(this.getClass().getName(),
1:7863d83:                 ClientDataSourceFactory.class.getName(), null);
1:7863d83: 
1:7863d83:         addBeanProperties(ref);
1:7863d83:         return ref;
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Add Java Bean properties to the reference using
1:7863d83:      * StringRefAddr for each property. List of bean properties
1:7863d83:      * is defined from the public getXXX() methods on this object
1:7863d83:      * that take no arguments and return short, int, boolean or String.
1:7863d83:      * The StringRefAddr has a key of the Java bean property name,
1:7863d83:      * converted from the method name. E.g. traceDirectory for
1:7863d83:      * traceDirectory.
1:7863d83:      *
1:7863d83:      * @param ref The referenced object
1:7863d83:       */
1:7863d83:     private void addBeanProperties(Reference ref) {
1:7863d83: 
1:7863d83:         Properties p = getProperties(this);
1:7863d83:         Enumeration<?> e = p.propertyNames();
1:7863d83: 
1:7863d83:         while (e.hasMoreElements()) {
1:7863d83:             String propName = (String)e.nextElement();
1:7863d83:             Object value = p.getProperty(propName);
1:7863d83:             if (value != null) {
1:7863d83:                 ref.add(new StringRefAddr(propName, value.toString()));
1:7863d83:             }
1:7863d83:         }
1:7863d83:     }
1:5ef7a0d: }
1:5ef7a0d: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
1: import java.util.Properties;
1: import javax.naming.NamingException;
1: import javax.naming.Reference;
1: import javax.naming.Referenceable;
1: import javax.naming.StringRefAddr;
1: import org.apache.derby.client.ClientDataSourceFactory;
1: 
1:  * This data source is suitable for a client/server use of Derby,
/////////////////////////////////////////////////////////////////////////
1:  * This simple data source subclass of BasicClientDataSource40 maintains
/////////////////////////////////////////////////////////////////////////
1: public class ClientDataSource extends BasicClientDataSource40 
1:                               implements Referenceable {
/////////////////////////////////////////////////////////////////////////
1:     //------------------------ Referenceable interface methods -----------------------------
1:     @Override
1:     public Reference getReference() throws NamingException {
1: 
1:         // This method creates a new Reference object to represent this data
1:         // source.  The class name of the data source object is saved in the
1:         // Reference, so that an object factory will know that it should
1:         // create an instance of that class when a lookup operation is
1:         // performed. The class name of the object factory,
1:         // org.apache.derby.client.ClientBaseDataSourceFactory, is also stored
1:         // in the reference.  This is not required by JNDI, but is recommend
1:         // in practice.  JNDI will always use the object factory class
1:         // specified in the reference when reconstructing an object, if a
1:         // class name has been specified.
1:         //
1:         // See the JNDI SPI documentation for further details on this topic,
1:         // and for a complete description of the Reference and StringRefAddr
1:         // classes.
1:         //
1:         // This BasicClientDataSource40 class provides several standard JDBC
1:         // properties.  The names and values of the data source properties are
1:         // also stored in the reference using the StringRefAddr class.  This
1:         // is all the information needed to reconstruct a ClientDataSource
1:         // object.
1: 
1:         Reference ref = new Reference(this.getClass().getName(),
1:                 ClientDataSourceFactory.class.getName(), null);
1: 
1:         addBeanProperties(ref);
1:         return ref;
1:     }
1: 
1:     /**
1:      * Add Java Bean properties to the reference using
1:      * StringRefAddr for each property. List of bean properties
1:      * is defined from the public getXXX() methods on this object
1:      * that take no arguments and return short, int, boolean or String.
1:      * The StringRefAddr has a key of the Java bean property name,
1:      * converted from the method name. E.g. traceDirectory for
1:      * traceDirectory.
1:      *
1:      * @param ref The referenced object
1:       */
1:     private void addBeanProperties(Reference ref) {
1: 
1:         Properties p = getProperties(this);
1:         Enumeration<?> e = p.propertyNames();
1: 
1:         while (e.hasMoreElements()) {
1:             String propName = (String)e.nextElement();
1:             Object value = p.getProperty(propName);
1:             if (value != null) {
1:                 ref.add(new StringRefAddr(propName, value.toString()));
1:             }
1:         }
1:     }
commit:cb88209
/////////////////////////////////////////////////////////////////////////
0:  * If running on Java SE 7 or higher, consider a more capable data source.
commit:2913612
/////////////////////////////////////////////////////////////////////////
0:  * This datasource is suitable for a client/server use of Derby,
0:  * running on full Java SE 5 or 6, corresponding to JDBC 3.0 and 4.0.
0:  * If running on Java SE 7 og higher, consider a more capable data source.
1:  * <p/>
1:  * environment.
commit:8269b78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class ClientDataSource extends ClientBaseDataSource {
1: 
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:fd584b0
/////////////////////////////////////////////////////////////////////////
1:  * running on full Java SE 6 and higher, corresponding to JDBC 4.0 and higher.
commit:54792be
/////////////////////////////////////////////////////////////////////////
1:  * ClientDataSource is a simple data source implementation
1:  * that can be used for establishing connections in a
1:  * non-pooling, non-distributed environment.
1:  * The class ClientConnectionPoolDataSource can be used in a connection pooling environment,
1:  * and the class ClientXADataSource can be used in a distributed, and pooling
0:  * environment. Use these DataSources if your application runs under
0:  * JDBC3.0 or JDBC2.0, that is, on the following Java Virtual Machines:
0:  * <UL>
0:  * <LI> JDBC 3.0 - Java 2 - JDK 1.4, J2SE 5.0
0:  * <LI> JDBC 2.0 - Java 2 - JDK 1.2,1.3
0:  * </UL>
1:  *
1:  * <p>The example below registers a DNC data source object with a JNDI naming service.
/////////////////////////////////////////////////////////////////////////
1:  * The first line of code in the example creates a data source object.
1:  * The next two lines initialize the data source's
1:  * properties. Then a Java object that references the initial JNDI naming
1:  * context is created by calling the
1:  * InitialContext() constructor, which is provided by JNDI.
1:  * System properties (not shown) are used to tell JNDI the
1:  * service provider to use. The JNDI name space is hierarchical,
1:  * similar to the directory structure of many file
1:  * systems. The data source object is bound to a logical JNDI name
1:  * by calling Context.bind(). In this case the JNDI name
1:  * identifies a subcontext, "jdbc", of the root naming context
1:  * and a logical name, "my_datasource_name", within the jdbc
1:  * subcontext. This is all of the code required to deploy
1:  * a data source object within JNDI. This example is provided
1:  * mainly for illustrative purposes. We expect that developers
1:  * or system administrators will normally use a GUI tool to
1:  * Once a data source has been registered with JNDI,
1:  * it can then be used by a JDBC application, as is shown in the
1:  * The first line in the example creates a Java object
1:  * that references the initial JNDI naming context. Next, the
1:  * initial naming context is used to do a lookup operation
1:  * using the logical name of the data source. The
1:  * Context.lookup() method returns a reference to a Java Object,
1:  * which is narrowed to a javax.sql.DataSource object. In
1:  * the last line, the DataSource.getConnection() method
1:  * is called to produce a database connection.
0:  * This simple data source subclass of ClientBaseDataSource maintains
1:  * it's own private <code>password</code> property.
1:  * The specified password, along with the user, is validated by DERBY.
0:  * This property can be overwritten by specifing
1:  * This password property is not declared transient, and therefore
1:  * may be serialized to a file in clear-text, or stored
1:  * to a JNDI server in clear-text when the data source is saved.
1:  * Care must taken by the user to prevent security
commit:cbd0ff1
/////////////////////////////////////////////////////////////////////////
0:         // Jdbc 2 connections will write driver trace info on a
0:         // datasource-wide basis using the jdbc 2 data source log writer.
0:         // This log writer may be narrowed to the connection-level
0:         // This log writer will be passed to the agent constructor.
1:         
0:             return ClientDriver.getFactory().newNetConnection
0:                     ((NetLogWriter) dncLogWriter, user,
0:                     password, this, -1, false);
0:         catch(SqlException se)
1:         
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:04fc939
/////////////////////////////////////////////////////////////////////////
0:  * running on full Java SE 6, 7 or 8, corresponding to JDBC 4.0, 4.1 and 4.2.
/////////////////////////////////////////////////////////////////////////
1:  * This property can be overwritten by specifying
commit:5ef7a0d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.ClientMessageId;
0: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0:  * JDBC 3.0 or JDBC 4.0, that is, on the following Java Virtual Machines:
0:  * <LI> JDBC 4.0 - Java SE 6
0:  * <LI> JDBC 3.0 - J2SE 5.0
/////////////////////////////////////////////////////////////////////////
1: 
0:     // JDBC 4.0 java.sql.Wrapper interface methods
1: 
1:     /**
0:      * Check whether this instance wraps an object that implements the interface
0:      * specified by {@code iface}.
0:      *
0:      * @param iface a class defining an interface
0:      * @return {@code true} if this instance implements {@code iface}, or
0:      * {@code false} otherwise
0:      * @throws SQLException if an error occurs while determining if this
0:      * instance implements {@code iface}
1:      */
0:     public boolean isWrapperFor(Class<?> iface) throws SQLException {
0:         return iface.isInstance(this);
1:     }
1: 
1:     /**
0:      * Returns {@code this} if this class implements the specified interface.
0:      *
0:      * @param  iface a class defining an interface
0:      * @return an object that implements the interface
0:      * @throws SQLException if no object is found that implements the
0:      * interface
1:      */
0:     public <T> T unwrap(Class<T> iface) throws SQLException {
0:         try {
0:             return iface.cast(this);
0:         } catch (ClassCastException cce) {
0:             throw new SqlException(null,
0:                     new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
0:                     iface).getSQLException();
1:         }
1:     }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bfe12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         LogWriter dncLogWriter = null;
0:         try {
0:             updateDataSourceValues(
0:                     tokenizeAttributes(getConnectionAttributes(), null));
0:             dncLogWriter = super.computeDncLogWriterForNewConnection("_sds");
0:             return getConnectionX(dncLogWriter, getUser(), getPassword());
0:         } catch (SqlException se) {
0:             // The method below may throw an exception.
0:             handleConnectionException(dncLogWriter, se);
0:             // If the exception wasn't handled so far, re-throw it.
0:             throw se.getSQLException();
0:         }
/////////////////////////////////////////////////////////////////////////
0:             updateDataSourceValues(
0:                     tokenizeAttributes(getConnectionAttributes(), null));
0:             return getConnectionX(dncLogWriter, user, password);
/////////////////////////////////////////////////////////////////////////
0:     private Connection getConnectionX(LogWriter dncLogWriter,
0:                                       String user, String password)
0:             throws SqlException {
0:         return ClientDriver.getFactory().newNetConnection(
0:                 (NetLogWriter)dncLogWriter, user, password, this, -1, false);
1: 
0:     }
commit:9a82758
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.ClientMessageId;
0: import org.apache.derby.shared.common.error.ExceptionUtil;
/////////////////////////////////////////////////////////////////////////
0:         LogWriter dncLogWriter = null;
0:             dncLogWriter = super.computeDncLogWriterForNewConnection("_sds");
/////////////////////////////////////////////////////////////////////////
0:             // The method below may throw an exception.
0:             handleConnectionException(dncLogWriter, se);
0:             // If the exception wasn't handled so far, re-throw it.
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:cbc0b44
/////////////////////////////////////////////////////////////////////////
0:             updateDataSourceValues(tokenizeAttributes(getConnectionAttributes(), null));
commit:751ab71
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d506170
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.SqlException;
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             // Jdbc 2 connections will write driver trace info on a
0:             // datasource-wide basis using the jdbc 2 data source log writer.
0:             // This log writer may be narrowed to the connection-level
0:             // This log writer will be passed to the agent constructor.
0:             LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection("_sds");
0:             updateDataSourceValues(tokenizeAttributes(getConnectionAttributes(), null));
0:             return new NetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false);
0:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
0:         }
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:54d2c35
/////////////////////////////////////////////////////////////////////////
0:  * non-pooling, non-distributed environment. The class ClientConnectionPoolDataSource can be used in a connection pooling environment,
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:93ab830
/////////////////////////////////////////////////////////////////////////
0:         return getConnection(getUser(), getPassword());
/////////////////////////////////////////////////////////////////////////
0:         updateDataSourceValues(tokenizeAttributes(getConnectionAttributes(), null));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:f787cd0
/////////////////////////////////////////////////////////////////////////
commit:001d07a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:02d3427
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: import java.util.Properties;
0: import javax.sql.DataSource;
1: 
0: import org.apache.derby.client.am.LogWriter;
0: import org.apache.derby.client.net.NetConfiguration;
0: import org.apache.derby.client.net.NetConnection;
0: import org.apache.derby.client.net.NetLogWriter;
/////////////////////////////////////////////////////////////////////////
0: public class ClientDataSource extends ClientBaseDataSource implements DataSource {
/////////////////////////////////////////////////////////////////////////
0:     public Connection getConnection() throws SQLException {
0:         return getConnection(user, password);
/////////////////////////////////////////////////////////////////////////
0:     public Connection getConnection(String user, String password) throws SQLException {
0:         LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection("_sds");
0:         return new NetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false);
/////////////////////////////////////////////////////////////////////////
0:     public final static short USER_ONLY_SECURITY = (short) NetConfiguration.SECMEC_USRIDONL;
0:     public final static short CLEAR_TEXT_PASSWORD_SECURITY = (short) NetConfiguration.SECMEC_USRIDPWD;
0:     public final static short ENCRYPTED_PASSWORD_SECURITY = (short) NetConfiguration.SECMEC_USRENCPWD;
0:     public final static short ENCRYPTED_USER_AND_PASSWORD_SECURITY = (short) NetConfiguration.SECMEC_EUSRIDPWD;
0:         return getUpgradedSecurityMechanism(securityMechanism, password);
/////////////////////////////////////////////////////////////////////////
0:     private void updateDataSourceValues(Properties prop) {
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: 
0:  * ClientDataSource is a simple data source implementation that can be used for establishing connections in a
0:  * non-pooling, non-distributed environment. The class ClientDataSource can be used in a connection pooling environment,
1:  * <p/>
/////////////////////////////////////////////////////////////////////////
0:  * The first line of code in the example creates a data source object. The next two lines initialize the data source's
0:  * properties. Then a Java object that references the initial JNDI naming context is created by calling the
0:  * InitialContext() constructor, which is provided by JNDI. System properties (not shown) are used to tell JNDI the
0:  * service provider to use. The JNDI name space is hierarchical, similar to the directory structure of many file
0:  * systems. The data source object is bound to a logical JNDI name by calling Context.bind(). In this case the JNDI name
0:  * identifies a subcontext, "jdbc", of the root naming context and a logical name, "my_datasource_name", within the jdbc
0:  * subcontext. This is all of the code required to deploy a data source object within JNDI. This example is provided
0:  * mainly for illustrative purposes. We expect that developers or system administrators will normally use a GUI tool to
1:  * deploy a data source object.
1:  * <p/>
0:  * Once a data source has been registered with JNDI, it can then be used by a JDBC application, as is shown in the
1:  * following example.
0:  * The first line in the example creates a Java object that references the initial JNDI naming context. Next, the
0:  * initial naming context is used to do a lookup operation using the logical name of the data source. The
0:  * Context.lookup() method returns a reference to a Java Object, which is narrowed to a javax.sql.DataSource object. In
0:  * the last line, the DataSource.getConnection() method is called to produce a database connection.
1:  * <p/>
1:  * <p/>
0:  * The specified password, along with the user, is validated by DERBY.  This property can be overwritten by specifing
1:  * the password parameter on the DataSource.getConnection() method call.
1:  * <p/>
0:  * This password property is not declared transient, and therefore may be serialized to a file in clear-text, or stored
0:  * to a JNDI server in clear-text when the data source is saved. Care must taken by the user to prevent security
1:  * breaches.
1:  * <p/>
0:         java.io.Serializable,
0:         javax.naming.Referenceable {
1:     private final static long serialVersionUID = 1894299584216955553L;
1:     public static final String className__ = "org.apache.derby.jdbc.ClientDataSource";
1:     // If a newer version of a serialized object has to be compatible with an older version, it is important that the newer version abides
1:     // by the rules for compatible and incompatible changes.
1:     //
1:     // A compatible change is one that can be made to a new version of the class, which still keeps the stream compatible with older
1:     // versions of the class. Examples of compatible changes are:
1:     //
1:     // Addition of new fields or classes does not affect serialization, as any new data in the stream is simply ignored by older
1:     // versions. When the instance of an older version of the class is deserialized, the newly added field will be set to its default
1:     // value.
1:     // You can field change access modifiers like private, public, protected or package as they are not reflected to the serial
1:     // stream.
1:     // You can change a transient or static field to a non-transient or non-static field, as it is similar to adding a field.
1:     // You can change the access modifiers for constructors and methods of the class. For instance a previously private method
1:     // can now be made public, an instance method can be changed to static, etc. The only exception is that you cannot change
1:     // the default signatures for readObject() and writeObject() if you are implementing custom serialization. The serialization
1:     // process looks at only instance data, and not the methods of a class.
1:     //
1:     // Changes which would render the stream incompatible are:
1:     //
1:     // Once a class implements the Serializable interface, you cannot later make it implement the Externalizable interface, since
1:     // this will result in the creation of an incompatible stream.
1:     // Deleting fields can cause a problem. Now, when the object is serialized, an earlier version of the class would set the old
1:     // field to its default value since nothing was available within the stream. Consequently, this default data may lead the newly
1:     // created object to assume an invalid state.
1:     // Changing a non-static into static or non-transient into transient is not permitted as it is equivalent to deleting fields.
1:     // You also cannot change the field types within a class, as this would cause a failure when attempting to read in the original
1:     // field into the new field.
1:     // You cannot alter the position of the class in the class hierarchy. Since the fully-qualified class name is written as part of
1:     // the bytestream, this change will result in the creation of an incompatible stream.
1:     // You cannot change the name of the class or the package it belongs to, as that information is written to the stream during
1:     // serialization.
0:     private String password = null;
1: 
0:     synchronized public void setPassword(String password) {
0:         this.password = password;
0:     }
0:     /**
1:      * Creates a simple DERBY data source with default property values for a non-pooling, non-distributed environment.
1:      * No particular DatabaseName or other properties are associated with the data source.
1:      * <p/>
1:      * Every Java Bean should provide a constructor with no arguments since many beanboxes attempt to instantiate a bean
1:      * by invoking its no-argument constructor.
1:      */
1:     public ClientDataSource() {
1:         super();
0:     }
0:     // ---------------------------interface methods-------------------------------
0:     /**
0:      * Attempt to establish a database connection in a non-pooling, non-distributed environment.
0:      *
0:      * @return a Connection to the database
0:      *
0:      * @throws java.sql.SQLException if a database-access error occurs.
1:      */
0:     public java.sql.Connection getConnection() throws java.sql.SQLException {
0:         return getConnection(this.user, this.password);
0:     }
0:     /**
0:      * Attempt to establish a database connection in a non-pooling, non-distributed environment.
0:      *
0:      * @param user     the database user on whose behalf the Connection is being made
0:      * @param password the user's password
0:      *
0:      * @return a Connection to the database
0:      *
0:      * @throws java.sql.SQLException if a database-access error occurs.
1:      */
0:     public java.sql.Connection getConnection(String user, String password) throws java.sql.SQLException {
0:         // Jdbc 2 connections will write driver trace info on a
0:         // datasource-wide basis using the jdbc 2 data source log writer.
0:         // This log writer may be narrowed to the connection-level
0:         // This log writer will be passed to the agent constructor.
0:         org.apache.derby.client.am.LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection("_sds");
0:         updateDataSourceValues(tokenizeAttributes(connectionAttributes, null));
0:         return
0:                 new org.apache.derby.client.net.NetConnection((org.apache.derby.client.net.NetLogWriter) dncLogWriter,
0:                         user,
0:                         password,
0:                         this,
0:                         -1,
0:                         false);
0:     }
1:     /*
0:      * Properties to be seen by Bean - access thru reflection.
1:      */
0:     // -- Stardard JDBC DataSource Properties
1: 
0:     public synchronized void setDatabaseName(String databaseName) {
0:         this.databaseName = databaseName;
0:     }
1: 
0:     public String getDatabaseName() {
0:         return this.databaseName;
0:     }
0:     public synchronized void setDataSourceName(String dataSourceName) {
0:         this.dataSourceName = dataSourceName;
0:     }
1: 
0:     public String getDataSourceName() {
0:         return this.dataSourceName;
0:     }
1: 
0:     public synchronized void setDescription(String description) {
0:         this.description = description;
0:     }
1: 
0:     public String getDescription() {
0:         return this.description;
0:     }
0:     public synchronized void setPortNumber(int portNumber) {
0:         this.portNumber = portNumber;
0:     }
0:     public int getPortNumber() {
0:         return this.portNumber;
0:     }
0:     public synchronized void setServerName(String serverName) {
0:         this.serverName = serverName;
0:     }
0:     public String getServerName() {
0:         return this.serverName;
0:     }
0:     public synchronized void setUser(String user) {
0:         this.user = user;
0:     }
0:     public String getUser() {
0:         return this.user;
0:     }
1: 
0:     synchronized public void setRetrieveMessageText(boolean retrieveMessageText) {
0:         this.retrieveMessageText = retrieveMessageText;
0:     }
1: 
0:     public boolean getRetrieveMessageText() {
0:         return this.retrieveMessageText;
0:     }
1: 
0:     // ---------------------------- securityMechanism -----------------------------------
0:     /**
0:      * The source security mechanism to use when connecting to this data source.
1:      * <p/>
0:      * Security mechanism options are: <ul> <li> USER_ONLY_SECURITY <li> CLEAR_TEXT_PASSWORD_SECURITY <li>
0:      * ENCRYPTED_PASSWORD_SECURITY <li> ENCRYPTED_USER_AND_PASSWORD_SECURITY - both password and user are encrypted
0:      * </ul> The default security mechanism is USER_ONLY SECURITY
1:      * <p/>
0:      * If the application specifies a security mechanism then it will be the only one attempted. If the specified
0:      * security mechanism is not supported by the conversation then an exception will be thrown and there will be no
0:      * additional retries.
1:      * <p/>
0:      * This property is currently only available for the  DNC driver.
1:      * <p/>
0:      * Both user and password need to be set for all security mechanism except USER_ONLY_SECURITY
1:      */
0:     // We use the NET layer constants to avoid a mapping for the NET driver.
0:     public final static short USER_ONLY_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_USRIDONL;
0:     public final static short CLEAR_TEXT_PASSWORD_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_USRIDPWD;
0:     public final static short ENCRYPTED_PASSWORD_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_USRENCPWD;
0:     public final static short ENCRYPTED_USER_AND_PASSWORD_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_EUSRIDPWD;
1: 
0:     synchronized public void setSecurityMechanism(short securityMechanism) {
0:         this.securityMechanism = securityMechanism;
0:     }
1: 
0:     public short getSecurityMechanism() {
0:         return getUpgradedSecurityMechanism(this.securityMechanism,
0:                 this.password);
0:     }
1: 
0:     protected String connectionAttributes = "";
1: 
0:     /**
0:      * Set this property to pass in more Derby specific connection URL attributes.
0:      *
0:      * @param prop set to the list of Cloudscape connection attributes separated by semi-colons.   E.g., to specify an
0:      *             encryption bootPassword of "x8hhk2adf", and set upgrade to true, do the following: <PRE>
0:      *             ds.setConnectionAttributes("bootPassword=x8hhk2adf;upgrade=true"); </PRE> See Derby documentation for
0:      *             complete list.
1:      */
0:     public final void setConnectionAttributes(String prop) {
0:         connectionAttributes = prop;
0:     }
1: 
0:     /**
0:      * @return Derby specific connection URL attributes
1:      */
0:     public final String getConnectionAttributes() {
0:         return connectionAttributes;
0:     }
1: 
1: 
0:     public final static int TRACE_NONE = 0x0;
0:     public final static int TRACE_CONNECTION_CALLS = 0x1;
0:     public final static int TRACE_STATEMENT_CALLS = 0x2;
0:     public final static int TRACE_RESULT_SET_CALLS = 0x4;
0:     public final static int TRACE_DRIVER_CONFIGURATION = 0x10;
0:     public final static int TRACE_CONNECTS = 0x20;
0:     public final static int TRACE_PROTOCOL_FLOWS = 0x40;
0:     public final static int TRACE_RESULT_SET_META_DATA = 0x80;
0:     public final static int TRACE_PARAMETER_META_DATA = 0x100;
0:     public final static int TRACE_DIAGNOSTICS = 0x200;
0:     public final static int TRACE_XA_CALLS = 0x800;
0:     public final static int TRACE_ALL = 0xFFFFFFFF;
1: 
0:     synchronized public void setTraceLevel(int traceLevel) {
0:         this.traceLevel = traceLevel;
0:     }
1: 
0:     public int getTraceLevel() {
0:         return this.traceLevel;
0:     }
1: 
1: 
0:     public synchronized void setTraceFile(String traceFile) {
0:         this.traceFile = traceFile;
0:     }
1: 
0:     public String getTraceFile() {
0:         return this.traceFile;
0:     }
1: 
1: 
0:     public synchronized void setTraceDirectory(String traceDirectory) {
0:         this.traceDirectory = traceDirectory;
0:     }
1: 
0:     public String getTraceDirectory() {
0:         return this.traceDirectory;
0:     }
1: 
0:     synchronized public void setTraceFileAppend(boolean traceFileAppend) {
0:         this.traceFileAppend = traceFileAppend;
0:     }
1: 
0:     public boolean getTraceFileAppend() {
0:         return this.traceFileAppend;
0:     }
0:     // --- private helper methods
1: 
0:     /**
0:      * The dataSource keeps individual fields for the values that are relevant to the client. These need to be updated
0:      * when set connection attributes is called.
1:      */
0:     private void updateDataSourceValues(java.util.Properties prop) {
0:         if (prop.containsKey(propertyKey_user)) {
0:             setUser(getUser(prop));
0:         }
0:         if (prop.containsKey(propertyKey_securityMechanism)) {
0:             setSecurityMechanism(getSecurityMechanism(prop));
0:         }
0:         if (prop.containsKey(propertyKey_traceFile)) {
0:             setTraceFile(getTraceFile(prop));
0:         }
0:         if (prop.containsKey(propertyKey_traceDirectory)) {
0:             setTraceDirectory(getTraceDirectory(prop));
0:         }
0:         if (prop.containsKey(propertyKey_traceFileAppend)) {
0:             setTraceFileAppend(getTraceFileAppend(prop));
0:         }
0:         if (prop.containsKey(propertyKey_securityMechanism)) {
0:             setSecurityMechanism(getSecurityMechanism(prop));
0:         }
0:         if (prop.containsKey(propertyKey_retrieveMessageText)) {
0:             setRetrieveMessageText(getRetrieveMessageText(prop));
0:         }
0:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
1:    Derby - Class org.apache.derby.client.ClientDataSource
0: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0: */
0: 
1: package org.apache.derby.jdbc;
0: import org.apache.derby.client.ClientBaseDataSource;
0: 
0: /**
0:  * ClientDataSource is a simple data source implementation that can be used
0:  * for establishing connections in a non-pooling, non-distributed environment.
0:  * The class ClientDataSource can be used in a connection pooling environment,
0:  * and the class ClientXADataSource can be used in a distributed, and pooling environment.
0:  * <p>
0:  * The example below registers a DNC data source object with a JNDI naming service.
1:  * <pre>
1:  * org.apache.derby.client.ClientDataSource dataSource = new org.apache.derby.client.ClientDataSource ();
1:  * dataSource.setServerName ("my_derby_database_server");
1:  * dataSource.setDatabaseName ("my_derby_database_name");
1:  * javax.naming.Context context = new javax.naming.InitialContext();
1:  * context.bind ("jdbc/my_datasource_name", dataSource);
1:  * </pre>
0:  * The first line of code in the example creates a data source object.
0:  * The next two lines initialize the data source's properties.
0:  * Then a Java object that references the initial JNDI naming
0:  * context is created by calling the InitialContext() constructor, which is provided by
0:  * JNDI. System properties (not shown) are used to tell JNDI the service provider to use.
0:  * The JNDI name space is hierarchical, similar to the directory structure of many file
0:  * systems. The data source object is bound to a logical JNDI name by calling Context.bind().
0:  * In this case the JNDI name identifies a subcontext, "jdbc", of the root
0:  * naming context and a logical name, "my_datasource_name", within the jdbc subcontext. This
0:  * is all of the code required to deploy a data source object within JNDI.
0:  * This example is provided mainly for illustrative purposes. We expect
0:  * that developers or system administrators will normally use a GUI tool to deploy a data
0:  * source object.
0:  * <p>
0:  * Once a data source has been registered with JNDI, it can then be used by a JDBC application,
0:  * as is shown in the following example.
1:  * <pre>
1:  * javax.naming.Context context = new javax.naming.InitialContext ();
1:  * javax.sql.DataSource dataSource = (javax.sql.DataSource) context.lookup ("jdbc/my_datasource_name");
1:  * java.sql.Connection connection = dataSource.getConnection ("user", "password");
1:  * </pre>
0:  * The first line in the example creates a Java object that references the initial JNDI naming
0:  * context. Next, the initial naming context is used to do a lookup operation using the
0:  * logical name of the data source. The Context.lookup() method returns a reference to
0:  * a Java Object, which is narrowed to a javax.sql.DataSource object. In the last line,
0:  * the DataSource.getConnection() method is called to produce a database connection.
0:  * <p>
0:  * This simple data source subclass of ClientBaseDataSource maintains it's own private <code>password</code> property.
0:  * <p>
0:  * The specified password, along with the user,
0:  * is validated by DERBY.  This property
0:  * can be overwritten by specifing the password parameter on the
0:  * DataSource.getConnection() method call.
0:  * <p>
0:  * This password property is not declared transient, and therefore may be serialized
0:  * to a file in clear-text, or stored to a JNDI server in clear-text when the data source is saved.
0:  * Care must taken by the user to prevent security breaches.
0:  * <p>
0:  *
0:  */
0: public class ClientDataSource extends ClientBaseDataSource implements javax.sql.DataSource,
0:                                                                       java.io.Serializable,
0:                                                                       javax.naming.Referenceable
0: {
0:   private final static long serialVersionUID = 1894299584216955553L;
0:   public static final String className__ = "org.apache.derby.jdbc.ClientDataSource";
0: 
0:   // If a newer version of a serialized object has to be compatible with an older version, it is important that the newer version abides
0:   // by the rules for compatible and incompatible changes.
0:   //
0:   // A compatible change is one that can be made to a new version of the class, which still keeps the stream compatible with older
0:   // versions of the class. Examples of compatible changes are:
0:   //
0:   // Addition of new fields or classes does not affect serialization, as any new data in the stream is simply ignored by older
0:   // versions. When the instance of an older version of the class is deserialized, the newly added field will be set to its default
0:   // value.
0:   // You can field change access modifiers like private, public, protected or package as they are not reflected to the serial
0:   // stream.
0:   // You can change a transient or static field to a non-transient or non-static field, as it is similar to adding a field.
0:   // You can change the access modifiers for constructors and methods of the class. For instance a previously private method
0:   // can now be made public, an instance method can be changed to static, etc. The only exception is that you cannot change
0:   // the default signatures for readObject() and writeObject() if you are implementing custom serialization. The serialization
0:   // process looks at only instance data, and not the methods of a class.
0:   //
0:   // Changes which would render the stream incompatible are:
0:   //
0:   // Once a class implements the Serializable interface, you cannot later make it implement the Externalizable interface, since
0:   // this will result in the creation of an incompatible stream.
0:   // Deleting fields can cause a problem. Now, when the object is serialized, an earlier version of the class would set the old
0:   // field to its default value since nothing was available within the stream. Consequently, this default data may lead the newly
0:   // created object to assume an invalid state.
0:   // Changing a non-static into static or non-transient into transient is not permitted as it is equivalent to deleting fields.
0:   // You also cannot change the field types within a class, as this would cause a failure when attempting to read in the original
0:   // field into the new field.
0:   // You cannot alter the position of the class in the class hierarchy. Since the fully-qualified class name is written as part of
0:   // the bytestream, this change will result in the creation of an incompatible stream.
0:   // You cannot change the name of the class or the package it belongs to, as that information is written to the stream during
0:   // serialization.
0: 
0:   private String password = null;
0:   synchronized public void setPassword (String password) { this.password = password; }
0: 
0: 
0:   /**
0:    * Creates a simple DERBY data source with default property values
0:    * for a non-pooling, non-distributed environment.
0:    * No particular DatabaseName or other properties are associated with the data source.
0:    * <p>
0:    * Every Java Bean should provide a constructor with no arguments
0:    * since many beanboxes attempt to instantiate a bean by invoking
0:    * its no-argument constructor.
0:    *
0:    */
0:   public ClientDataSource () { super(); }
0: 
0: 
0:   // ---------------------------interface methods-------------------------------
0: 
0:   /**
0:    * Attempt to establish a database connection in a non-pooling, non-distributed environment.
0:    *
0:    * @return a Connection to the database
0:    * @throws java.sql.SQLException if a database-access error occurs.
0:    **/
0:   public java.sql.Connection getConnection () throws java.sql.SQLException
0:   { return getConnection (this.user, this.password); }
0: 
0:   /**
0:    * Attempt to establish a database connection in a non-pooling, non-distributed environment.
0:    *
0:    * @param user the database user on whose behalf the Connection is being made
0:    * @param password the user's password
0:    * @return a Connection to the database
0:    * @throws java.sql.SQLException if a database-access error occurs.
0:    **/
0:   public java.sql.Connection getConnection (String user, String password) throws java.sql.SQLException
0:   {
0:     // Jdbc 2 connections will write driver trace info on a
0:     // datasource-wide basis using the jdbc 2 data source log writer.
0:     // This log writer may be narrowed to the connection-level
0:     // This log writer will be passed to the agent constructor.
0: 
0:     org.apache.derby.client.am.LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection ("_sds");
0: 	updateDataSourceValues(tokenizeAttributes(connectionAttributes,null));
0:     return
0:         new org.apache.derby.client.net.NetConnection (
0:           (org.apache.derby.client.net.NetLogWriter) dncLogWriter,
0:           user,
0:           password,
0:           this,
0:           -1,
0:           false);
0:   }
0: 
0: 	/*
0: 	 * Properties to be seen by Bean - access thru reflection.
0: 	 */
0: 
0: 	// -- Stardard JDBC DataSource Properties
0: 	
0: 	public synchronized void setDatabaseName (String databaseName) { this.databaseName = databaseName; }
0: 	public String getDatabaseName () { return this.databaseName; }
0: 	
0: 	
0: 	public synchronized void setDataSourceName (String dataSourceName) { this.dataSourceName = dataSourceName; }
0: 	public String getDataSourceName () { return this.dataSourceName; }
0: 	
0:   public synchronized void setDescription (String description) { this.description = description; }
0:   public String getDescription () { return this.description; }
0: 
0: 
0: 	public synchronized void setPortNumber (int portNumber) { this.portNumber = portNumber; }
0: 	public int getPortNumber () { return this.portNumber; }
0: 	
0: 	public synchronized void setServerName (String serverName) { this.serverName = serverName; }
0: 	public String getServerName () { return this.serverName; }
0: 
0: 
0: 	public synchronized void setUser (String user) { this.user = user; }
0: 	public String getUser () { return this.user; }
0: 	
0: 	synchronized public void setRetrieveMessageText (boolean retrieveMessageText) { this.retrieveMessageText = retrieveMessageText; }
0: 	public boolean getRetrieveMessageText () { return this.retrieveMessageText; }
0: 
0: 	// ---------------------------- securityMechanism -----------------------------------
0: 	/**
0: 	 *The source security mechanism to use when connecting to this data source.
0:   * <p>
0:   * Security mechanism options are:
0:   * <ul>
0:   * <li> USER_ONLY_SECURITY
0:   * <li> CLEAR_TEXT_PASSWORD_SECURITY
0:   * <li> ENCRYPTED_PASSWORD_SECURITY
0:   * <li> ENCRYPTED_USER_AND_PASSWORD_SECURITY - both password and user are encrypted
0:   * </ul>
0:   * The default security mechanism is USER_ONLY SECURITY
0:   * <p>
0:   * If the application specifies a security
0:   * mechanism then it will be the only one attempted.
0:   * If the specified security mechanism is not supported by the conversation
0:   * then an exception will be thrown and there will be no additional retries.
0:   * <p>
0:   * This property is currently only available for the  DNC driver.
0:   * <p>
0:   * Both user and password need to be set for all security mechanism except USER_ONLY_SECURITY 
0:   */
0: 	// We use the NET layer constants to avoid a mapping for the NET driver.
0: 	public final static short USER_ONLY_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_USRIDONL;
0: 	public final static short CLEAR_TEXT_PASSWORD_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_USRIDPWD;
0: 	public final static short ENCRYPTED_PASSWORD_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_USRENCPWD;
0: 	public final static short ENCRYPTED_USER_AND_PASSWORD_SECURITY = (short) org.apache.derby.client.net.NetConfiguration.SECMEC_EUSRIDPWD;
0: 	
0: 	synchronized public void setSecurityMechanism (short securityMechanism) { this.securityMechanism = securityMechanism; }
0: 	public short getSecurityMechanism () { 
0: 		return getUpgradedSecurityMechanism(this.securityMechanism,
0: 											this.password);
0: 	}
0: 
0: 	protected String connectionAttributes = "";
0: 
0: 	/**
0:  		Set this property to pass in more Derby specific
0: 		connection URL attributes.
0: 
0: 		@param prop set to the list of Cloudscape connection
0: 		attributes separated by semi-colons.   E.g., to specify an encryption
0: 		bootPassword of "x8hhk2adf", and set upgrade to true, do the following: 
0: 		<PRE>
0: 			ds.setConnectionAttributes("bootPassword=x8hhk2adf;upgrade=true");
0: 		</PRE>
0: 		See Derby documentation for complete list.
0: 	 */
0: 	public final void setConnectionAttributes(String prop) {
0: 		 connectionAttributes = prop;
0: 	}
0: 
0: 	/** @return Derby specific connection URL attributes */
0: 	public final String getConnectionAttributes() {
0: 		return connectionAttributes;
0: 	}
0: 	
0: 
0: 	public final static int TRACE_NONE = 0x0;
0: 	public final static int TRACE_CONNECTION_CALLS = 0x1;
0: 	public final static int TRACE_STATEMENT_CALLS= 0x2;
0: 	public final static int TRACE_RESULT_SET_CALLS = 0x4;
0: 	public final static int TRACE_DRIVER_CONFIGURATION = 0x10;
0: 	public final static int TRACE_CONNECTS = 0x20;
0: 	public final static int TRACE_PROTOCOL_FLOWS = 0x40;
0: 	public final static int TRACE_RESULT_SET_META_DATA = 0x80;
0: 	public final static int TRACE_PARAMETER_META_DATA = 0x100;
0: 	public final static int TRACE_DIAGNOSTICS = 0x200;
0: 	public final static int TRACE_XA_CALLS = 0x800;
0:   public final static int TRACE_ALL = 0xFFFFFFFF;
0: 	synchronized public void setTraceLevel (int traceLevel) { this.traceLevel = traceLevel; }
0: 	public int getTraceLevel () { return this.traceLevel; }
0: 	
0: 
0: 	public synchronized void setTraceFile (String traceFile) { this.traceFile = traceFile; }
0: 	public String getTraceFile () { return this.traceFile; }
0: 
0: 
0: 	public synchronized void setTraceDirectory (String traceDirectory) { this.traceDirectory = traceDirectory; }
0: 	public String getTraceDirectory () { return this.traceDirectory; }
0: 
0: 	synchronized public void setTraceFileAppend (boolean traceFileAppend) { this.traceFileAppend = traceFileAppend; }
0: 	public boolean getTraceFileAppend () { return this.traceFileAppend; }
0: 
0: 
0: 
0: 
0: 	// --- private helper methods
0: 
0: 	
0: 	/**
0: 	 * The dataSource keeps individual fields for the values that are 
0: 	 * relevant to the client. These need to be updated when 
0: 	 * set connection attributes is called.
0: 	 */
0: 	private void updateDataSourceValues(java.util.Properties prop)
0: 	{
0: 		if ( prop.containsKey(propertyKey_user))
0: 			setUser(getUser(prop));
0: 		if ( prop.containsKey(propertyKey_securityMechanism))
0: 			 setSecurityMechanism(getSecurityMechanism(prop));
0: 		if ( prop.containsKey(propertyKey_traceFile))
0: 			 setTraceFile(getTraceFile(prop));
0: 		if ( prop.containsKey(propertyKey_traceDirectory))
0: 			 setTraceDirectory(getTraceDirectory(prop));
0: 		if ( prop.containsKey(propertyKey_traceFileAppend))
0: 			setTraceFileAppend(getTraceFileAppend(prop));
0: 		if ( prop.containsKey(propertyKey_securityMechanism))
0: 			setSecurityMechanism(getSecurityMechanism(prop));
0: 		if ( prop.containsKey(propertyKey_retrieveMessageText))
0: 			setRetrieveMessageText(getRetrieveMessageText(prop));
0: 	}
0: 
0: }
0: 
============================================================================