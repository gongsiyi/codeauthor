1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.UpdateNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
18:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:ca28065: 
1:eac0369: import java.lang.reflect.Modifier;
1:3bb140c: import java.sql.Types;
1:1c6c2e8: import java.util.ArrayList;
1:d4f9308: import java.util.HashSet;
1:1c6c2e8: import java.util.List;
1:3bb140c: import org.apache.derby.catalog.DefaultInfo;
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:3bb140c: import org.apache.derby.iapi.sql.StatementType;
1:070d37e: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:070d37e: import org.apache.derby.iapi.sql.compile.TagFilter;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:3bb140c: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.CheckConstraintDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:f246c9c: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:591ff9f: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:3bb140c: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:3bb140c: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:3bb140c: import org.apache.derby.iapi.store.access.TransactionController;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:591ff9f: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.vti.DeferModification;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * An UpdateNode represents an UPDATE statement.  It is the top node of the
1:eac0369:  * query tree for that statement.
1:eac0369:  * For positioned update, there may be no from table specified.
1:eac0369:  * The from table will be derived from the cursor specification of
1:eac0369:  * the named cursor.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:a826375: public final class UpdateNode extends DMLModGeneratedColumnsStatementNode
1:a6f9586: {
1:eac0369: 	//Note: These are public so they will be visible to
1:eac0369: 	//the RepUpdateNode.
1:3bb140c:     int[]               changedColumnIds;
1:3bb140c:     boolean             deferred;
1:3bb140c:     ValueNode           checkConstraints;
1:eac0369: 	
1:eac0369: 	protected FromTable			targetTable;
1:eac0369: 	protected FormatableBitSet 			readColsBitSet;
1:eac0369: 	protected boolean 			positionedUpdate;
1:661c2e6: 
1:eac0369: 	/* Column name for the RowLocation in the ResultSet */
1:3bb140c:     static final String COLUMNNAME = "###RowLocationToUpdate";
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for an UpdateNode.
1:eac0369: 	 *
1:eac0369: 	 * @param targetTableName	The name of the table to update
1:3bb140c:      * @param resultSet         The ResultSet that we will generate
1:508a010:      * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 */
1:508a010:     UpdateNode
1:508a010:         (
1:508a010:          TableName targetTableName,
1:3bb140c:          ResultSetNode resultSet,
1:508a010:          MatchingClauseNode matchingClause,
1:508a010:          ContextManager cm
1:508a010:          )
1:f246c9c: 	{
1:508a010:         super( resultSet, matchingClause, cm );
1:3bb140c:         this.targetTableName = targetTableName;
1:a6f9586: 	}
1:070d37e: 
1:070d37e: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:070d37e: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:070d37e: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:070d37e: 		{
1:eac0369: 			return targetTableName.toString() + "\n" +
1:eac0369: 				super.toString();
1:070d37e: 		}
1:6ab1083: 		else
1:070d37e: 		{
1:eac0369: 			return "";
1:070d37e: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		return "UPDATE";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (targetTableName != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "targetTableName: ");
1:eac0369: 				targetTableName.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* RESOLVE - need to print out targetTableDescriptor */
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this UpdateNode.  This means looking up tables and columns and
1:eac0369: 	 * getting their types, and figuring out the result types of all
1:eac0369: 	 * expressions, as well as doing view resolution, permissions checking,
1:eac0369: 	 * etc.
1:eac0369: 	 * <p>
1:eac0369: 	 * Binding an update will also massage the tree so that
1:eac0369: 	 * the ResultSetNode has a set of columns to contain the old row
1:eac0369: 	 * value, followed by a set of columns to contain the new row
1:eac0369: 	 * value, followed by a column to contain the RowLocation of the
1:eac0369: 	 * row to be updated.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:c45f5b1: 		// We just need select privilege on the expressions
1:c45f5b1: 		getCompilerContext().pushCurrentPrivType( Authorizer.SELECT_PRIV);
1:eac0369: 
1:3bb140c:         FromList fromList = new FromList(
1:3bb140c:                 getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                 getContextManager());
1:eac0369: 		TableName					cursorTargetTableName = null;
1:eac0369: 		CurrentOfNode       		currentOfNode = null;
1:eac0369: 		ResultColumnList			afterColumns = null;
1:eac0369: 
1:eac0369: 		DataDictionary dataDictionary = getDataDictionary();
1:eac0369: 
1:582425f: 		// check if targetTable is a synonym
1:b47c239: 		if (targetTableName != null)
1:eac0369: 		{
1:b47c239: 			TableName synonymTab = resolveTableToSynonym(this.targetTableName);
1:b47c239: 			if (synonymTab != null)
1:eac0369: 			{
1:b6c6e95: 				this.synonymTableName = targetTableName;
1:b6c6e95: 				this.targetTableName  = synonymTab;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:daffaee:         //
1:3e77b5a:         // First step in associating added columns with the TARGET table of
1:3e77b5a:         // a MERGE statement. Here we identify the columns which were NOT ADDED.
1:3e77b5a:         //
1:3e77b5a:         if ( inMatchingClause() ) { tagOriginalResultSetColumns(); }
1:3e77b5a: 
1:070d37e:         // collect lists of objects which will require privilege checks
1:070d37e:         ArrayList<String>   explicitlySetColumns = getExplicitlySetColumns();
1:ffbe813:         List<CastNode> allCastNodes = collectAllCastNodes();
1:070d37e:         tagPrivilegedNodes();
1:070d37e: 
1:070d37e:         // tell the compiler to only add privilege checks for nodes which have been tagged
1:070d37e:         TagFilter   tagFilter = new TagFilter( TagFilter.NEED_PRIVS_FOR_UPDATE_STMT );
1:070d37e:         getCompilerContext().addPrivilegeFilter( tagFilter );
1:070d37e: 		
1:eac0369: 		bindTables(dataDictionary);
1:eac0369: 
1:eac0369: 		// wait to bind named target table until the cursor
1:eac0369: 		// binding is done, so that we can get it from the
1:eac0369: 		// cursor if this is a positioned update.
1:eac0369: 
1:eac0369: 		// for positioned update, get the cursor's target table.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT((resultSet!=null && resultSet instanceof SelectNode), 
1:eac0369: 				"Update must have a select result set");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		SelectNode sel;
1:eac0369: 		sel = (SelectNode)resultSet;
1:eac0369: 		targetTable = (FromTable) sel.fromList.elementAt(0);
1:eac0369: 
1:eac0369: 		if (targetTable instanceof CurrentOfNode) 
1:eac0369: 		{	
1:eac0369: 			positionedUpdate = true;
1:eac0369: 			currentOfNode = (CurrentOfNode) targetTable;
1:eac0369: 			cursorTargetTableName = currentOfNode.getBaseCursorTargetTableName();
1:eac0369: 
1:eac0369: 			// instead of an assert, we might say the cursor is not updatable.
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(cursorTargetTableName != null);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (targetTable instanceof FromVTI)
1:eac0369: 		{
1:eac0369: 			targetVTI = (FromVTI) targetTable;
1:eac0369: 			targetVTI.setTarget();
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// positioned update can leave off the target table.
1:eac0369: 			// we get it from the cursor supplying the position.
1:eac0369: 			if (targetTableName == null)
1:eac0369: 			{
1:eac0369: 				// verify we have current of
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(cursorTargetTableName!=null);
1:eac0369: 
1:eac0369: 				targetTableName = cursorTargetTableName;
1:eac0369: 			}
1:eac0369: 			// for positioned update, we need to verify that
1:eac0369: 			// the named table is the same as the cursor's target.
1:eac0369: 			else if (cursorTargetTableName != null)
1:eac0369: 			{
1:eac0369: 				// this match requires that the named table in the update
1:eac0369: 				// be the same as a correlation name in the cursor.
1:eac0369: 				if ( !targetTableName.equals(cursorTargetTableName))
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_CURSOR_UPDATE_MISMATCH, 
1:eac0369: 						targetTableName,
2:eac0369: 						currentOfNode.getCursorName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:5a95e6b: 		
1:5a95e6b: 		// because we verified that the tables match
1:5a95e6b: 		// and we already bound the cursor or the select,
1:5a95e6b: 		// the table descriptor should always be found.
1:5a95e6b: 		verifyTargetTable();
1:070d37e: 
1:070d37e:         // add UPDATE_PRIV on all columns on the left side of SET operators
1:070d37e:         addUpdatePriv( explicitlySetColumns );
1:070d37e: 
1:eac0369: 		/* OVERVIEW - We generate a new ResultColumn, CurrentRowLocation(), and
1:eac0369: 		 * prepend it to the beginning of the source ResultColumnList.  This
1:eac0369: 		 * will tell us which row(s) to update at execution time.  However,
1:eac0369: 		 * we must defer prepending this generated column until the other
1:eac0369: 		 * ResultColumns are bound since there will be no ColumnDescriptor
1:eac0369: 		 * for the generated column.  Thus, the sequence of actions is:
1:eac0369: 		 *
1:eac0369: 		 *		o  Bind existing ResultColumnList (columns in SET clause)
1:eac0369: 		 *		o  If this is a positioned update with a FOR UPDATE OF list,
1:eac0369: 		 *		   then verify that all of the target columns are in the
1:eac0369: 		 *		   FOR UPDATE OF list.
1:eac0369: 		 *		o  Get the list of indexes that need to be updated.
1:eac0369: 		 *		o  Create a ResultColumnList of all the columns in the target
1:eac0369: 		 *		   table - this represents the old row.
1:eac0369: 		 *		o  If we don't know which columns are being updated, 
1:eac0369: 	 	 *		   expand the original ResultColumnList to include all the
1:eac0369: 		 *		   columns in the target table, and sort it to be in the
1:eac0369: 		 *		   order of the columns in the target table.  This represents
1:eac0369: 		 *		   the new row.  Append it to the ResultColumnList representing
1:eac0369: 		 *		   the old row.
1:eac0369: 		 *		o  Construct the changedColumnIds array sorted by column position.
1:eac0369: 		 *		o  Generate the read column bit map and append any columns
1:eac0369: 		 *		   needed for index maint, etc.
1:eac0369: 		 *		o  Generate a new ResultColumn for CurrentRowLocation() and 
1:eac0369: 		 *		   mark it as a generated column.
1:eac0369: 		 *		o  Append the new ResultColumn to the ResultColumnList
1:eac0369: 		 *		   (This must be done before binding the expressions, so
1:eac0369: 		 *		   that the proper type info gets propagated to the new 
1:eac0369: 		 *		   ResultColumn.)
1:eac0369: 		 *		o  Bind the expressions.
1:eac0369: 		 *		o  Bind the generated ResultColumn.
1:eac0369: 		 */
1:5a95e6b: 
1:eac0369: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(fromList.size() == 0,
1:eac0369: 				"fromList.size() is expected to be 0, not " + 
1:eac0369: 				fromList.size() +
1:eac0369: 				" on return from RS.bindExpressions()");
1:eac0369: 		}
1:eac0369: 
1:3e77b5a:         //
1:ca28065:         // Add generated columns whose generation clauses mention columns
1:ca28065:         // in the user's original update list.
1:ca28065:         //
1:ca28065:         ColumnDescriptorList    addedGeneratedColumns = new ColumnDescriptorList();
1:ca28065:         ColumnDescriptorList    affectedGeneratedColumns = new ColumnDescriptorList();
1:ca28065:         addGeneratedColumns
1:ca28065:             ( targetTableDescriptor, resultSet, affectedGeneratedColumns, addedGeneratedColumns );
1:ca28065:         
1:eac0369: 		/*
1:eac0369: 		** The current result column list is the one supplied by the user.
1:eac0369: 		** Mark these columns as "updated", so we can tell later which
1:eac0369: 		** columns are really being updated, and which have been added
1:eac0369: 		** but are not really being updated.
1:eac0369: 		*/
1:eac0369: 		resultSet.getResultColumns().markUpdated();
1:eac0369: 
1:eac0369: 		/* Prepend CurrentRowLocation() to the select's result column list. */
1:eac0369: 		if (SanityManager.DEBUG)
1:11f7ee3:             SanityManager.ASSERT((resultSet.getResultColumns() != null),	
1:eac0369: 							  "resultColumns is expected not to be null at bind time");
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the result FromTable, which should be the only table in the
1:eac0369: 	 	** from list.
1:eac0369: 		*/
1:661c2e6:         /*
1:3bb140c:         if (SanityManager.DEBUG) {
1:3bb140c:             SanityManager.ASSERT(resultSet.getFromList().size() == 1,
1:3bb140c:                     "More than one table in result from list in an update.");
1:3bb140c:         }
1:661c2e6:         */
1:b6c6e95: 		/* Normalize the SET clause's result column list for synonym */
1:b6c6e95: 		if (synonymTableName != null)
1:11f7ee3: 			normalizeSynonymColumns( resultSet.getResultColumns(), targetTable );
1:eac0369: 		
1:eac0369: 		/* Bind the original result columns by column name */
1:11f7ee3: 		normalizeCorrelatedColumns( resultSet.getResultColumns(), targetTable );
1:eac0369: 
1:11f7ee3: 		resultSet.bindResultColumns
1:11f7ee3:             (
1:11f7ee3:              targetTableDescriptor,
1:11f7ee3:              targetVTI,
1:11f7ee3:              resultSet.getResultColumns(), this,
1:11f7ee3:              fromList
1:11f7ee3:              );
1:eac0369: 
1:ca28065:         // don't allow overriding of generation clauses
1:47611b1:         forbidGenerationOverrides( resultSet.getResultColumns(),
1:47611b1: 								   addedGeneratedColumns );
1:ca28065:         
1:a826375:         //DERBY-6414(Incorrect handling when using an UPDATE to SET an 
1:a826375:         // identity column to DEFAULT)
1:a826375:         //The bug is fixed only for Derby 10.11 and higher. Starting 10.11,
1:a826375:         // we have started using sequence generator to create unique ids
1:a826375:         //If we fix this jira for prior releases, we will need to maintain
1:a826375:         // the code for old way of generating unique ids.
1:a826375:         if (dataDictionary.checkVersion( DataDictionary.DD_VERSION_DERBY_10_11, null )) {
1:a826375:             //Replace any DEFAULTs with the associated tree for the default if
1:a826375:             // allowed, otherwise throw an exception
1:a826375:             resultSet.getResultColumns().replaceOrForbidDefaults(
1:a826375:             		targetTableDescriptor, 
1:a826375:             		resultSet.getResultColumns(), true);
1:a826375:             resultSet.getResultColumns().checkForInvalidDefaults();
1:a826375:             resultSet.getResultColumns().forbidOverrides(resultSet.getResultColumns());
1:a826375:         } else {
1:a826375:     		LanguageConnectionContext lcc = getLanguageConnectionContext();
1:a826375:     		if (lcc.getAutoincrementUpdate() == false)
1:a826375:     			resultSet.getResultColumns().forbidOverrides(null);
1:a826375:         }
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Mark the columns in this UpdateNode's result column list as
1:eac0369: 		** updateable in the ResultColumnList of the table being updated.
1:eac0369: 		** only do this for FromBaseTables - if the result table is a
1:eac0369: 		** CurrentOfNode, it already knows what columns in its cursor
1:eac0369: 		** are updateable.
1:eac0369: 		*/
1:eac0369: 		boolean allColumns = false;
1:eac0369: 		if (targetTable instanceof FromBaseTable)
1:eac0369: 		{
1:eac0369: 			((FromBaseTable) targetTable).markUpdated(
1:eac0369: 												resultSet.getResultColumns());
1:eac0369: 		}
1:c2a0bdd: 		else if
1:c2a0bdd:             (
1:c2a0bdd:              (targetTable instanceof FromVTI) ||
1:c2a0bdd:              (targetTable instanceof FromSubquery)
1:c2a0bdd:              )
1:eac0369: 		{
1:eac0369:             resultColumnList = resultSet.getResultColumns();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Positioned update: WHERE CURRENT OF
1:eac0369: 			*/
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(currentOfNode != null, "currentOfNode is null");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ExecPreparedStatement	 cursorStmt = currentOfNode.getCursorStatement();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If there is no update column list, we need to build
1:eac0369: 			** out the result column list to have all columns.
1:eac0369: 			*/
1:dda453e:             if (!cursorStmt.hasUpdateColumns())
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** Get the resultColumnList representing ALL of the columns in the 
1:eac0369: 				** base table.  This is the "before" portion of the result row.
1:eac0369: 				*/
1:eac0369: 				getResultColumnList();
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Add the "after" portion of the result row.  This is the update
1:eac0369: 				** list augmented to include every column in the target table.
1:eac0369: 				** Those columns that are not being updated are set to themselves.
1:eac0369: 				** The expanded list will be in the order of the columns in the base
1:eac0369: 				** table.
1:eac0369: 				*/
1:eac0369: 				afterColumns = resultSet.getResultColumns().expandToAll(
2:eac0369: 													targetTableDescriptor,
1:eac0369: 													targetTable.getTableName());
1:eac0369: 	
1:eac0369: 				/*
1:eac0369: 				** Need to get all indexes here since we aren't calling
1:eac0369: 				** getReadMap().
1:eac0369: 				*/
1:eac0369: 				getAffectedIndexes(targetTableDescriptor, 
1:eac0369: 									(ResultColumnList)null, (FormatableBitSet)null); 
2:eac0369: 				allColumns = true;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				/* Check the updatability */
1:dda453e:                 resultSet.getResultColumns().checkColumnUpdateability(
1:dda453e:                         cursorStmt, currentOfNode.getCursorName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		changedColumnIds = getChangedColumnIds(resultSet.getResultColumns());
1:eac0369: 
1:6ab1083:         //
1:6ab1083:         // Trigger transition tables are implemented as VTIs. This short-circuits some
1:6ab1083:         // necessary steps if the source table of a MERGE statement is a trigger
1:6ab1083:         // transition table. The following boolean is meant to prevent that short-circuiting.
1:6ab1083:         //
1:6ab1083:         boolean needBaseColumns = (targetVTI == null) || inMatchingClause();
1:6ab1083:         
1:eac0369: 		/*
1:eac0369: 		** We need to add in all the columns that are needed
1:eac0369: 		** by the constraints on this table.  
1:eac0369: 		*/
1:6ab1083: 		if (!allColumns && needBaseColumns)
1:eac0369: 		{
1:c45f5b1: 			getCompilerContext().pushCurrentPrivType( Authorizer.NULL_PRIV);
1:c45f5b1: 			try
1:eac0369: 			{
1:eac0369: 				readColsBitSet = new FormatableBitSet();
1:eac0369: 				FromBaseTable fbt = getResultColumnList(resultSet.getResultColumns());
1:3e77b5a: 
1:eac0369: 				afterColumns = resultSet.getResultColumns().copyListAndObjects();
1:eac0369: 
1:eac0369: 				readColsBitSet = getReadMap(dataDictionary, 
1:eac0369: 										targetTableDescriptor, 
1:ca28065:                                         afterColumns, affectedGeneratedColumns );
1:eac0369: 
1:eac0369: 				afterColumns = fbt.addColsToList(afterColumns, readColsBitSet);
1:661c2e6:                 
1:eac0369: 				resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If all bits are set, then behave as if we chose all
1:eac0369: 				** in the first place
1:eac0369: 				*/
1:eac0369: 				int i = 1;
1:eac0369: 				int size = targetTableDescriptor.getMaxColumnID();
1:eac0369: 				for (; i <= size; i++)
1:eac0369: 				{
1:eac0369: 					if (!readColsBitSet.get(i))
1:eac0369: 					{
1:a6f9586: 						break;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (i > size)
1:eac0369: 				{
1:eac0369: 					readColsBitSet = null;
1:eac0369: 				}	
1:eac0369: 			}
1:c45f5b1: 			finally
1:eac0369: 			{
1:070d37e: 				getCompilerContext().popCurrentPrivType();
1:eac0369: 			}
1:eac0369: 		}
1:070d37e: 
1:3bb140c:         ValueNode rowLocationNode;
1:3bb140c: 
1:6ab1083: 		if (needBaseColumns)
1:eac0369: 		{
1:eac0369: 			/* Append the list of "after" columns to the list of "before" columns,
1:eac0369: 			 * preserving the afterColumns list.  (Necessary for binding
1:eac0369: 			 * check constraints.)
1:eac0369: 			 */
1:eac0369: 			resultColumnList.appendResultColumns(afterColumns, false);
1:070d37e: 
1:eac0369: 			/* Generate the RowLocation column */
1:3bb140c:             rowLocationNode = new CurrentRowLocationNode(getContextManager());
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:3bb140c:            rowLocationNode = new NumericConstantNode(
1:bb5be6f:                    TypeId.getBuiltInTypeId(Types.INTEGER), 0,
1:3bb140c:                    getContextManager());
1:eac0369:         }
1:eac0369:             
1:3bb140c:         ResultColumn rowLocationColumn = new ResultColumn(
1:3bb140c:                 COLUMNNAME, rowLocationNode, getContextManager());
1:eac0369:         rowLocationColumn.markGenerated();
1:eac0369: 
1:3e77b5a:         /* Append to the ResultColumnList */
1:eac0369:         resultColumnList.addResultColumn(rowLocationColumn);
1:eac0369: 
1:eac0369: 		/*
1:444aa52: 		 * The last thing that we do to the generated RCL is to clear
1:e2cf840: 		 * the table name out from each RC. See comment on 
1:e2cf840: 		 * checkTableNameAndScrubResultColumns().
1:eac0369: 		 */
1:e2cf840: 		checkTableNameAndScrubResultColumns(resultColumnList);
1:eac0369: 
1:eac0369: 		/* Set the new result column list in the result set */
1:eac0369: 		resultSet.setResultColumns(resultColumnList);
1:eac0369: 
1:3e77b5a:         //
1:3e77b5a:         // Second step in associating added columns with the TARGET table of
1:3e77b5a:         // a MERGE statement. Here we associate the columns which were not originally tagged.
1:3e77b5a:         //
1:3e77b5a:         if ( inMatchingClause() ) { associateAddedColumns(); }
1:3e77b5a: 
1:591ff9f:         // SQL 2011, section 6.10, SR 4b.
1:591ff9f:         SelectNode.checkNoWindowFunctions(resultSet, "<update source>");
1:591ff9f: 
1:eac0369: 		/* Bind the expressions */
1:eac0369: 		super.bindExpressions();
1:eac0369: 
1:eac0369: 		/* Bind untyped nulls directly under the result columns */
1:eac0369: 		resultSet.
1:eac0369: 			getResultColumns().
1:eac0369: 				bindUntypedNullsToResultColumns(resultColumnList);
1:eac0369: 
1:3bb140c:         /* Bind the new ResultColumn */
1:3bb140c:         rowLocationColumn.bindResultColumnToExpression();
1:eac0369: 
1:eac0369: 		resultColumnList.checkStorableExpressions();
1:eac0369: 
1:eac0369: 		/* Insert a NormalizeResultSetNode above the source if the source
1:eac0369: 		 * and target column types and lengths do not match.
1:eac0369: 		 */
1:eac0369: 		if (! resultColumnList.columnTypesAndLengthsMatch())
1:eac0369:  		{
1:3bb140c:             resultSet = new NormalizeResultSetNode(
1:3bb140c:                 resultSet, resultColumnList, null, true, getContextManager());
1:860148c: 			
1:eac0369: 								
1:ca28065:  			if (hasCheckConstraints(dataDictionary, targetTableDescriptor) || hasGenerationClauses( targetTableDescriptor ) )
1:eac0369:  			{
1:15b837e:  				/* Get and bind all check constraints and generated columns on the columns
1:15b837e: 	 			 * being updated.  We want to bind the check constraints and
1:15b837e: 	 			 * generated columns against
1:eac0369: 	 			 * the after columns.  We need to bind against the portion of the
1:eac0369: 	 			 * resultColumns in the new NormalizeResultSet that point to 
1:eac0369: 	 			 * afterColumns.  Create an RCL composed of just those RCs in
1:eac0369: 	 			 * order to bind the check constraints.
1:eac0369: 	 			 */
1:eac0369: 	 			int afterColumnsSize = afterColumns.size();
1:3bb140c:                 afterColumns = new ResultColumnList(getContextManager());
1:eac0369: 	 			ResultColumnList normalizedRCs = resultSet.getResultColumns();
1:eac0369: 	 			for (int index = 0; index < afterColumnsSize; index++)
1:eac0369: 	 			{
1:eac0369: 	 				afterColumns.addElement(normalizedRCs.elementAt(index + afterColumnsSize));
1:eac0369: 	 			}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:6ab1083:         if( null != targetVTI && !inMatchingClause() )
1:eac0369: 		{
1:eac0369:             deferred = VTIDeferModPolicy.deferIt( DeferModification.UPDATE_STATEMENT,
2:eac0369:                                                   targetVTI,
1:eac0369:                                                   resultColumnList.getColumnNames(),
1:eac0369:                                                   sel.getWhereClause());
1:eac0369: 		}
1:eac0369:         else // not VTI
1:eac0369:         {
1:eac0369:             /* we always include triggers in core language */
1:eac0369:             boolean hasTriggers = (getAllRelevantTriggers(dataDictionary, targetTableDescriptor, 
1:eac0369:                                                           changedColumnIds, true).size() > 0);
1:eac0369: 
1:ca28065: 			ResultColumnList sourceRCL = hasTriggers ? resultColumnList : afterColumns;
1:ca28065: 
1:ca28065:             /* bind all generation clauses for generated columns */
1:ca28065:             parseAndBindGenerationClauses
1:ca28065:                 ( dataDictionary, targetTableDescriptor, afterColumns, resultColumnList, true, resultSet );
1:ca28065: 
1:eac0369:             /* Get and bind all constraints on the columns being updated */
1:af1c18c:             checkConstraints = bindConstraints(
1:af1c18c:                 dataDictionary,
1:af1c18c:                 getOptimizerFactory(),
1:af1c18c:                 targetTableDescriptor,
1:af1c18c:                 null,
1:af1c18c:                 sourceRCL,
1:af1c18c:                 changedColumnIds,
1:af1c18c:                 readColsBitSet,
1:af1c18c:                 true, /* we always include triggers in core language */
1:af1c18c:                 new boolean[1]); // dummy
1:eac0369: 
1:eac0369:             /* If the target table is also a source table, then
1:eac0369:              * the update will have to be in deferred mode
1:eac0369:              * For updates, this means that the target table appears in a
1:eac0369:              * subquery.  Also, self referencing foreign keys are
1:eac0369:              * deferred.  And triggers cause an update to be deferred.
1:eac0369:              */
1:eac0369:             if (resultSet.subqueryReferencesTarget(
1:eac0369:                 targetTableDescriptor.getName(), true) ||
1:eac0369:                 requiresDeferredProcessing())
1:eac0369:             {
1:eac0369:                 deferred = true;
1:eac0369:             }
1:a826375:             TransactionController tc = 
1:a826375:                     getLanguageConnectionContext().getTransactionCompile();
1:a826375: 
1:a826375:             autoincRowLocation = 
1:a826375:                     dataDictionary.computeAutoincRowLocations(tc, targetTableDescriptor);
1:eac0369:         }
1:eac0369: 
1:a826375: 		identitySequenceUUIDString = getUUIDofSequenceGenerator();
1:a826375: 
1:c45f5b1: 		getCompilerContext().popCurrentPrivType();
1:eac0369: 
1:ffbe813:         getCompilerContext().removePrivilegeFilter( tagFilter );
1:eac0369: 
1:ca28065:         //
1:ffbe813:         // Add USAGE privilege for all CASTs to UDTs mentioned in the WHERE clause and
1:daffaee:         // on the right side of SET operators.
1:daffaee:         //
1:ffbe813:         for ( CastNode value : allCastNodes )
1:ffbe813:         {
1:ffbe813:             addUDTUsagePriv( value );
1:ffbe813:         }
1:6ab1083:     } // end of bind()
1:eac0369: 
1:3bb140c:     @Override
1:c45f5b1: 	int getPrivType()
1:eac0369: 	{
1:c45f5b1: 		return Authorizer.UPDATE_PRIV;
1:070d37e: 	}
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Get the names of the explicitly set columns, that is, the columns on the left side
1:070d37e:      * of SET operators.
1:070d37e:      */
1:070d37e:     private ArrayList<String>   getExplicitlySetColumns()
1:070d37e:         throws StandardException
1:070d37e:     {
1:070d37e:         ArrayList<String>   result = new ArrayList<String>();
1:070d37e:         ResultColumnList    rcl = resultSet.getResultColumns();
1:070d37e: 
1:070d37e:         for ( int i = 0; i < rcl.size(); i++ )
1:070d37e:         {
1:070d37e:             result.add( rcl.elementAt( i ).getName() );
1:070d37e:         }
1:070d37e: 
1:070d37e:         return result;
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:3e77b5a:      * Associate all added columns with the TARGET table of the enclosing
1:3e77b5a:      * MERGE statement.
1:3e77b5a:      */
1:3e77b5a:     private void    associateAddedColumns()
1:3e77b5a:         throws StandardException
1:3e77b5a:     {
1:3e77b5a:         for ( ColumnReference cr : collectAllResultSetColumns() )
1:3e77b5a:         {
1:3e77b5a:             if ( !cr.taggedWith( TagFilter.ORIG_UPDATE_COL ) )
1:3e77b5a:             {
1:3e77b5a:                 cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:3e77b5a:             }
1:3e77b5a:         }
1:3e77b5a:     }
1:3e77b5a: 
1:3e77b5a:     /**
1:3e77b5a:      * Tag the original columns mentioned in the result list.
1:3e77b5a:      */
1:3e77b5a:     private void    tagOriginalResultSetColumns()
1:3e77b5a:         throws StandardException
1:3e77b5a:     {
1:3e77b5a:         for ( ColumnReference cr : collectAllResultSetColumns() )
1:3e77b5a:         {
1:3e77b5a:             cr.addTag( TagFilter.ORIG_UPDATE_COL );
1:3e77b5a:         }
1:3e77b5a:     }
1:3e77b5a: 
1:3e77b5a:     /**
1:3e77b5a:      * Collect all of the result set columns.
1:3e77b5a:      */
1:3e77b5a:     private List<ColumnReference>   collectAllResultSetColumns()
1:3e77b5a:         throws StandardException
1:3e77b5a:     {
1:3e77b5a:         CollectNodesVisitor<ColumnReference> crVisitor =
1:3e77b5a:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:3e77b5a:         resultSet.getResultColumns().accept( crVisitor );
1:3e77b5a: 
1:3e77b5a:         return crVisitor.getList();
1:3e77b5a:     }
1:3e77b5a: 
1:3e77b5a:     /**
1:ffbe813:      * Collect all of the CastNodes in the WHERE clause and on the right side
1:070d37e:      * of SET operators. Later on, we will need to add permissions for all UDTs
1:070d37e:      * mentioned by these nodes.
1:070d37e:      */
1:ffbe813:     private List<CastNode>    collectAllCastNodes()
1:070d37e:         throws StandardException
1:070d37e:     {
1:ffbe813:         CollectNodesVisitor<CastNode> getCasts =
1:ffbe813:             new CollectNodesVisitor<CastNode>(CastNode.class);
1:070d37e: 
1:070d37e:         // process the WHERE clause
1:070d37e:         ValueNode   whereClause = ((SelectNode) resultSet).whereClause;
1:ffbe813:         if ( whereClause != null ) { whereClause.accept( getCasts ); }
1:070d37e: 
1:070d37e:         // process the right sides of the SET operators
1:070d37e:         ResultColumnList    rcl = resultSet.getResultColumns();
1:070d37e:         for ( int i = 0; i < rcl.size(); i++ )
1:070d37e:         {
1:ffbe813:             rcl.elementAt( i ).getExpression().accept( getCasts );
1:070d37e:         }
1:070d37e: 
1:ffbe813:         return getCasts.getList();
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Tag all of the nodes which may require privilege checks.
1:070d37e:      * These are various QueryTreeNodes in the WHERE clause and on the right
1:070d37e:      * side of SET operators.
1:070d37e:      */
1:070d37e:     private void    tagPrivilegedNodes()
1:070d37e:         throws StandardException
1:070d37e:     {
1:070d37e:         ArrayList<QueryTreeNode>    result = new ArrayList<QueryTreeNode>();
1:070d37e: 
1:070d37e:         SelectNode  selectNode = (SelectNode) resultSet;
1:070d37e: 
1:070d37e:         // add this node so that addUpdatePriv() and addUDTUsagePriv() will work
1:070d37e:         result.add( this );
1:070d37e: 
1:070d37e:         // process the WHERE clause
1:070d37e:         ValueNode   whereClause = selectNode.whereClause;
1:070d37e:         if ( whereClause !=  null ) { collectPrivilegedNodes( result, whereClause ); }
1:070d37e: 
1:070d37e:         // process the right sides of the SET operators
1:070d37e:         ResultColumnList    rcl = resultSet.getResultColumns();
1:070d37e:         for ( int i = 0; i < rcl.size(); i++ )
1:070d37e:         {
1:070d37e:             collectPrivilegedNodes( result, rcl.elementAt( i ).getExpression() );
1:070d37e:         }
1:070d37e: 
1:070d37e:         // now tag all the nodes we collected
1:070d37e:         for ( QueryTreeNode expr : result )
1:070d37e:         {
1:070d37e:             expr.addTag( TagFilter.NEED_PRIVS_FOR_UPDATE_STMT );
1:070d37e:         }
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Add to an evolving list all of the nodes under an expression which may require privilege checks.
1:070d37e:      */
1:070d37e:     private void    collectPrivilegedNodes
1:070d37e:         ( ArrayList<QueryTreeNode> result, QueryTreeNode expr )
1:070d37e:         throws StandardException
1:070d37e:     {
1:070d37e:         // get all column references
1:070d37e:         CollectNodesVisitor<ColumnReference> getCRs =
1:070d37e:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:070d37e:         expr.accept( getCRs );
1:070d37e:         result.addAll( getCRs.getList() );
1:070d37e: 
1:070d37e:         // get all function references
1:070d37e:         CollectNodesVisitor<StaticMethodCallNode> getSMCNs =
1:070d37e:             new CollectNodesVisitor<StaticMethodCallNode>(StaticMethodCallNode.class);
1:070d37e:         expr.accept( getSMCNs );
1:070d37e:         result.addAll( getSMCNs.getList() );
1:070d37e: 
1:070d37e:         // get all FromBaseTables in order to bulk-get their selected columns
1:070d37e:         CollectNodesVisitor<FromBaseTable> getFBTs =
1:070d37e:             new CollectNodesVisitor<FromBaseTable>(FromBaseTable.class);
1:070d37e:         expr.accept( getFBTs );
1:070d37e:         result.addAll( getFBTs.getList() );
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Add UPDATE_PRIV on all columns on the left side of SET operators.
1:070d37e:      */
1:070d37e:     private void    addUpdatePriv( ArrayList<String> explicitlySetColumns )
1:070d37e:         throws StandardException
1:070d37e:     {
2:070d37e:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:070d37e:         
1:070d37e:         CompilerContext cc = getCompilerContext();
1:070d37e: 
1:070d37e:         cc.pushCurrentPrivType( Authorizer.UPDATE_PRIV );
1:070d37e:         try {
1:070d37e:             for ( String columnName : explicitlySetColumns )
1:070d37e:             {
1:070d37e:                 ColumnDescriptor    cd = targetTableDescriptor.getColumnDescriptor( columnName );
1:070d37e:                 cc.addRequiredColumnPriv( cd );
1:070d37e:             }
1:070d37e:         }
1:070d37e:         finally
1:070d37e:         {
1:070d37e:             cc.popCurrentPrivType();
1:070d37e:         }
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Add privilege checks for UDTs referenced by this statement.
1:070d37e:      */
1:070d37e: 
1:070d37e:     
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public boolean referencesSessionSchema()
1:070d37e: 		throws StandardException
1:ca28065: 	{
1:eac0369: 		//If this node references a SESSION schema table, then return true. 
1:eac0369: 		return(resultSet.referencesSessionSchema());
1:d4f9308: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Compile constants that Execution will use
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Updates are also deferred if they update a column in the index
1:eac0369: 		** used to scan the table being updated.
1:eac0369: 		*/
1:6ab1083: 		if ( !deferred && !inMatchingClause() )
1:eac0369: 		{
1:eac0369: 			ConglomerateDescriptor updateCD =
1:eac0369: 										targetTable.
1:eac0369: 											getTrulyTheBestAccessPath().
1:eac0369: 												getConglomerateDescriptor();
1:eac0369: 
1:eac0369: 			if (updateCD != null && updateCD.isIndex())
1:eac0369: 			{
1:eac0369: 				int [] baseColumns =
1:eac0369: 						updateCD.getIndexDescriptor().baseColumnPositions();
1:eac0369: 
1:eac0369: 				if (resultSet.
1:eac0369: 						getResultColumns().
1:eac0369: 										updateOverlaps(baseColumns))
1:eac0369: 				{
1:eac0369: 					deferred = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if( null == targetTableDescriptor)
1:eac0369: 		{
1:eac0369: 			/* Return constant action for VTI
1:eac0369: 			 * NOTE: ConstantAction responsible for preserving instantiated
1:eac0369: 			 * VTIs for in-memory queries and for only preserving VTIs
1:eac0369: 			 * that implement Serializable for SPSs.
1:eac0369: 			 */
1:eac0369: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.UPDATE_STATEMENT,
1:eac0369: 						deferred, changedColumnIds);
1:eac0369: 		}
1:eac0369: 
1:6ab1083:         int lckMode = inMatchingClause() ?
1:6ab1083:             TransactionController.MODE_RECORD : resultSet.updateTargetLockMode();
1:eac0369: 		long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
1:eac0369: 		TransactionController tc = 
1:eac0369: 			getLanguageConnectionContext().getTransactionCompile();
1:eac0369: 		StaticCompiledOpenConglomInfo[] indexSCOCIs = 
1:eac0369: 			new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length];
1:eac0369: 
1:eac0369: 		for (int index = 0; index < indexSCOCIs.length; index++)
1:eac0369: 		{
1:eac0369: 			indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Do table locking if the table's lock granularity is
1:eac0369: 		** set to table.
1:eac0369: 		*/
1:eac0369: 		if (targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
1:eac0369: 		{
1:3bb140c:             lckMode = TransactionController.MODE_TABLE;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		return	getGenericConstantActionFactory().getUpdateConstantAction
1:af1c18c:             ( targetTableDescriptor,
1:eac0369: 			  tc.getStaticCompiledConglomInfo(heapConglomId),
1:eac0369: 			  indicesToMaintain,
1:eac0369: 			  indexConglomerateNumbers,
1:eac0369: 			  indexSCOCIs,
1:eac0369: 			  indexNames,
1:eac0369: 			  deferred,
1:eac0369: 			  targetTableDescriptor.getUUID(),
1:3bb140c:               lckMode,
2:eac0369: 			  false,
1:eac0369: 			  changedColumnIds, null, null, 
1:eac0369: 			  getFKInfo(),
1:eac0369: 			  getTriggerInfo(),
1:eac0369: 			  (readColsBitSet == null) ? (FormatableBitSet)null : new FormatableBitSet(readColsBitSet),
1:eac0369: 			  getReadColMap(targetTableDescriptor.getNumberOfColumns(),readColsBitSet),
1:eac0369: 			  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
1:eac0369: 			  (readColsBitSet == null) ? 
1:eac0369: 				  targetTableDescriptor.getNumberOfColumns() :
1:eac0369: 				  readColsBitSet.getNumBitsSet(),			
1:eac0369: 			  positionedUpdate,
1:01632c2: 			  resultSet.isOneRowResultSet(),
1:a826375: 			  autoincRowLocation,
1:a826375: 			  inMatchingClause(),
1:a826375: 			  identitySequenceUUIDString
1:eac0369: 			  );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Updates are deferred if they update a column in the index
1:eac0369: 	 * used to scan the table being updated.
1:eac0369: 	 */
1:eac0369: 	protected void setDeferredForUpdateOfIndexColumn()
1:eac0369: 	{
1:eac0369: 		/* Don't bother checking if we're already deferred */
2:eac0369: 		if (! deferred )
1:eac0369: 		{
1:eac0369: 			/* Get the conglomerate descriptor for the target table */
1:eac0369: 			ConglomerateDescriptor updateCD =
1:eac0369: 										targetTable.
1:eac0369: 											getTrulyTheBestAccessPath().
1:eac0369: 												getConglomerateDescriptor();
1:eac0369: 
1:eac0369: 			/* If it an index? */
1:eac0369: 			if (updateCD != null && updateCD.isIndex())
1:eac0369: 			{
1:eac0369: 				int [] baseColumns =
1:eac0369: 						updateCD.getIndexDescriptor().baseColumnPositions();
1:eac0369: 
1:eac0369: 				/* Are any of the index columns updated? */
1:eac0369: 				if (resultSet.
1:eac0369: 						getResultColumns().
1:eac0369: 										updateOverlaps(baseColumns))
1:eac0369: 				{
1:eac0369: 					deferred = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Code generation for update.
1:eac0369: 	 * The generated code will contain:
1:eac0369: 	 *		o  A static member for the (xxx)ResultSet with the RowLocations	and
1:eac0369: 	 *		   new update values
1:eac0369: 	 *		o  The static member will be assigned the appropriate ResultSet within
1:eac0369: 	 *		   the nested calls to get the ResultSets.  (The appropriate cast to the
1:eac0369: 	 *		   (xxx)ResultSet will be generated.)
1:eac0369: 	 *		o  The CurrentRowLocation() in SelectNode's select list will generate
1:eac0369: 	 *		   a new method for returning the RowLocation as well as a call to
1:eac0369: 	 *		   that method when generating the (xxx)ResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method for the execute() method to be built
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:ccee531: 		// If the DML is on the temporary table, generate the code to
1:ccee531: 		// mark temporary table as modified in the current UOW. After
1:ccee531: 		// DERBY-827 this must be done in execute() since
1:d11ed08: 		// createResultSet() will only be called once.
1:d11ed08: 		generateCodeForTemporaryTable(acb);
1:eac0369: 
1:eac0369: 		/* generate the parameters */
2:eac0369: 		if(!isDependentTable)
1:eac0369: 			generateParameterValueSet(acb);
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* Create the static declaration for the scan ResultSet which generates the
1:eac0369: 		 * RowLocations to be updated
1:eac0369: 		 * RESOLVE - Need to deal with the type of the static member.
1:eac0369: 		 */
1:eac0369: 		acb.newFieldDeclaration(Modifier.PRIVATE, 
1:eac0369: 								ClassName.CursorResultSet, 
1:eac0369: 								acb.newRowLocationScanResultSetName());
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Generate the update result set, giving it either the original
1:93ff8cc: 		** source or the normalize result set, the constant action.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:6ab1083:         // arg 1
1:6ab1083:         if ( inMatchingClause() )
1:6ab1083:         {
1:6ab1083:             matchingClause.generateResultSetField( acb, mb );
1:6ab1083:         }
1:47611b1:         else
1:6ab1083:         {
1:6ab1083:             resultSet.generate( acb, mb );
1:6ab1083:         }
1:6ab1083: 
1:6ab1083:         if( null != targetVTI && !inMatchingClause() )
1:eac0369:         {
1:eac0369: 			targetVTI.assignCostEstimate(resultSet.getNewCostEstimate());
1:93ff8cc:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateVTIResultSet", ClassName.ResultSet, 1);
1:eac0369: 		}
1:eac0369:         else
1:eac0369:         {
1:ca28065: 			// arg 2 generate code to evaluate generation clauses
1:0397292: 			generateGenerationClauses( resultColumnList, resultSet.getResultSetNumber(), true, acb, mb );
1:ca28065: 
1:eac0369:             // generate code to evaluate CHECK CONSTRAINTS
1:ca28065:             generateCheckConstraints( checkConstraints, acb, mb ); // arg 3
1:eac0369: 
1:eac0369:             if(isDependentTable)
1:eac0369:             {
1:eac0369:                 mb.push(acb.addItem(makeConstantAction()));
1:eac0369:                 mb.push(acb.addItem(makeResultDescription()));
1:eac0369:                 mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getDeleteCascadeUpdateResultSet",
1:ca28065:                               ClassName.ResultSet, 5);
1:eac0369:             }else
1:eac0369:             {
1:eac0369:                 mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateResultSet",
1:ca28065:                               ClassName.ResultSet, 3);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the type of statement, something from
1:eac0369: 	 * StatementType.
1:eac0369: 	 *
1:eac0369: 	 * @return the type of statement
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected final int getStatementType()
1:eac0369: 	{
1:eac0369: 		return StatementType.UPDATE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the map of all columns which must be read out of the base table.
1:eac0369: 	 * These are the columns needed to<UL>:
1:eac0369: 	 *		<LI>maintain indices</LI>
1:eac0369: 	 *		<LI>maintain foreign keys</LI>
1:ca28065: 	 *		<LI>maintain generated columns</LI>
1:eac0369: 	 *		<LI>support Replication's Delta Optimization</LI></UL>
1:eac0369: 	 * <p>
1:eac0369: 	 * The returned map is a FormatableBitSet with 1 bit for each column in the
1:eac0369: 	 * table plus an extra, unsued 0-bit. If a 1-based column id must
1:eac0369: 	 * be read from the base table, then the corresponding 1-based bit
1:eac0369: 	 * is turned ON in the returned FormatableBitSet.
1:eac0369: 	 * <p> 
1:eac0369: 	 * <B>NOTE</B>: this method is not expected to be called when
1:eac0369: 	 * all columns are being updated (i.e. updateColumnList is null).
1:eac0369: 	 *
1:eac0369: 	 * @param dd				the data dictionary to look in
1:eac0369: 	 * @param baseTable		the base table descriptor
1:eac0369: 	 * @param updateColumnList the rcl for the update. CANNOT BE NULL
1:ca28065: 	 * @param affectedGeneratedColumns columns whose generation clauses mention columns being updated
1:eac0369: 	 *
1:eac0369: 	 * @return a FormatableBitSet of columns to be read out of the base table
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     FormatableBitSet getReadMap
1:eac0369: 	(
1:d9d1bc8: 		DataDictionary		dd,
1:eac0369: 		TableDescriptor		baseTable,
1:ca28065: 		ResultColumnList	updateColumnList,
1:ca28065:         ColumnDescriptorList    affectedGeneratedColumns
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean[]	needsDeferredProcessing = new boolean[1];
1:eac0369: 		needsDeferredProcessing[0] = requiresDeferredProcessing();
1:eac0369: 
1:71c8e86:         ArrayList<ConglomerateDescriptor> conglomerates = new ArrayList<ConglomerateDescriptor>();
1:eac0369: 		relevantCdl = new ConstraintDescriptorList();
1:801cf0d:         relevantTriggers =  new TriggerDescriptorList();
1:eac0369: 
1:ca28065: 		FormatableBitSet	columnMap = getUpdateReadMap
1:ca28065:             (
1:b153b24:              dd, baseTable, updateColumnList, conglomerates, relevantCdl,
1:ca28065:              relevantTriggers, needsDeferredProcessing, affectedGeneratedColumns );
1:eac0369: 
1:b153b24:         markAffectedIndexes(conglomerates);
1:eac0369: 
1:eac0369: 		adjustDeferredFlag( needsDeferredProcessing[0] );
1:eac0369: 
1:eac0369: 		return	columnMap;
1:ca28065: 	}
1:eac0369: 
1:eac0369: 
1:ca28065: 	/**
1:eac0369: 	 * Construct the changedColumnIds array. Note we sort its entries by
1:eac0369: 	 * columnId.
1:ca28065: 	 */
1:eac0369: 	private int[] getChangedColumnIds(ResultColumnList rcl)
1:ca28065: 	{
1:eac0369: 		if (rcl == null) { return (int[])null; }
1:eac0369: 		else { return rcl.sortMe(); }
1:eac0369: 	}
1:eac0369:     /**
1:eac0369: 	  *	Builds a bitmap of all columns which should be read from the
1:eac0369: 	  *	Store in order to satisfy an UPDATE statement.
1:eac0369: 	  *
1:eac0369: 	  *	Is passed a list of updated columns. Does the following:
1:eac0369: 	  *
1:eac0369: 	  *	1)	finds all indices which overlap the updated columns
1:eac0369: 	  *	2)	adds the index columns to a bitmap of affected columns
1:eac0369: 	  *	3)	adds the index descriptors to a list of conglomerate
1:eac0369: 	  *		descriptors.
1:eac0369: 	  *	4)	finds all constraints which overlap the updated columns
1:eac0369: 	  *		and adds the constrained columns to the bitmap
1:eac0369: 	  *	5)	finds all triggers which overlap the updated columns.
1:a6f9586: 	  *	6)	Go through all those triggers from step 5 and for each one of
1:a6f9586: 	  *     those triggers, follow the rules below to decide which columns
1:a6f9586: 	  *     should be read.
1:a6f9586: 	  *       Rule1)If trigger column information is null, then read all the
1:a6f9586: 	  *       columns from trigger table into memory irrespective of whether
1:a6f9586: 	  *       there is any trigger action column information. 2 egs of such
1:a6f9586: 	  *       triggers
1:a6f9586: 	  *         create trigger tr1 after update on t1 for each row values(1);
1:a6f9586: 	  *         create trigger tr1 after update on t1 referencing old as oldt
1:a6f9586: 	  *         	for each row insert into t2 values(2,oldt.j,-2); 
1:a6f9586: 	  *       Rule2)If trigger column information is available but no trigger 
1:a6f9586: 	  *       action column information is found and no REFERENCES clause is
1:a6f9586: 	  *       used for the trigger, then read all the columns identified by 
1:a6f9586: 	  *       the trigger column. eg 
1:a6f9586: 	  *         create trigger tr1 after update of c1 on t1 
1:a6f9586: 	  *         	for each row values(1);
1:a6f9586: 	  *       Rule3)If trigger column information and trigger action column
1:a6f9586: 	  *       information both are not null, then only those columns will be
1:a6f9586: 	  *       read into memory. This is possible only for triggers created in
1:d9d1bc8: 	  *       release 10.9 or higher(with the exception of 10.7.1.1 where we
1:d9d1bc8: 	  *       did collect that information but because of corruption caused
1:d9d1bc8: 	  *       by those changes, we do not use the information collected by
1:d9d1bc8: 	  *       10.7). Starting 10.9, we are collecting trigger action column 
1:d9d1bc8: 	  *       informatoin so we can be smart about what columns get read 
1:d9d1bc8: 	  *       during trigger execution. eg
1:a6f9586: 	  *         create trigger tr1 after update of c1 on t1 
1:a6f9586: 	  *         	referencing old as oldt for each row 
1:a6f9586: 	  *         	insert into t2 values(2,oldt.j,-2);
1:a6f9586: 	  *       Rule4)If trigger column information is available but no trigger 
1:a6f9586: 	  *       action column information is found but REFERENCES clause is used
1:a6f9586: 	  *       for the trigger, then read all the columns from the trigger 
1:d9d1bc8: 	  *       table. This will cover soft-upgrade scenario for triggers created 
1:d9d1bc8: 	  *       pre-10.9. 
1:d9d1bc8: 	  *       eg trigger created prior to 10.9
1:a6f9586: 	  *         create trigger tr1 after update of c1 on t1 
1:a6f9586: 	  *         	referencing old as oldt for each row 
1:a6f9586: 	  *         	insert into t2 values(2,oldt.j,-2);
1:eac0369: 	  *	7)	adds the triggers to an evolving list of triggers
1:ca28065: 	  *	8)	finds all generated columns whose generation clauses mention
1:ca28065:       *        the updated columns and adds all of the mentioned columns
1:eac0369: 	  *
1:d9d1bc8: 	  *	@param	dd	Data Dictionary
1:d9d1bc8: 	  *	@param	baseTable	Table on which update is issued
1:eac0369: 	  *	@param	updateColumnList	a list of updated columns
1:b153b24:       * @param  conglomerates       OUT: list of affected indices
1:eac0369: 	  *	@param	relevantConstraints	IN/OUT. Empty list is passed in. We hang constraints on it as we go.
1:eac0369: 	  *	@param	relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
1:eac0369: 	  *	@param	needsDeferredProcessing	IN/OUT. true if the statement already needs
1:eac0369: 	  *									deferred processing. set while evaluating this
1:eac0369: 	  *									routine if a trigger or constraint requires
1:eac0369: 	  *									deferred processing
1:ca28065: 	  *	@param	affectedGeneratedColumns columns whose generation clauses mention updated columns
1:eac0369: 	  *
1:eac0369: 	  * @return a FormatableBitSet of columns to be read out of the base table
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on error
1:eac0369: 	  */
1:3bb140c:     static FormatableBitSet getUpdateReadMap
1:eac0369: 	(
1:eac0369: 		DataDictionary		dd,
1:eac0369: 		TableDescriptor				baseTable,
1:eac0369: 		ResultColumnList			updateColumnList,
1:71c8e86:         List<ConglomerateDescriptor>     conglomerates,
1:eac0369: 		ConstraintDescriptorList	relevantConstraints,
1:801cf0d:         TriggerDescriptorList       relevantTriggers,
1:ca28065: 		boolean[]					needsDeferredProcessing,
1:ca28065:         ColumnDescriptorList    affectedGeneratedColumns
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:ca28065: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:ca28065: 		{
1:eac0369: 			SanityManager.ASSERT(updateColumnList != null, "updateColumnList is null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int		columnCount = baseTable.getMaxColumnID();
1:eac0369: 		FormatableBitSet	columnMap = new FormatableBitSet(columnCount + 1);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Add all the changed columns.  We don't strictly
1:eac0369: 		** need the before image of the changed column in all cases,
1:eac0369: 		** but it makes life much easier since things are set
1:eac0369: 		** up around the assumption that we have the before
1:eac0369: 		** and after image of the column.
1:eac0369: 		*/
1:ca28065: 		int[]	changedColumnIds = updateColumnList.sortMe();
1:eac0369: 
1:ca28065: 		for (int ix = 0; ix < changedColumnIds.length; ix++)
1:eac0369: 		{
1:ca28065: 			columnMap.set(changedColumnIds[ix]);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* 
1:eac0369: 		** Get a list of the indexes that need to be 
1:eac0369: 		** updated.  ColumnMap contains all indexed
1:eac0369: 		** columns where 1 or more columns in the index
1:eac0369: 		** are going to be modified.
1:eac0369: 		*/
1:b153b24:         DMLModStatementNode.getXAffectedIndexes(
1:b153b24:                 baseTable, updateColumnList, columnMap, conglomerates);
1:eac0369:  
1:eac0369: 		/* 
1:eac0369: 		** Add all columns needed for constraints.  We don't
1:eac0369: 		** need to bother with foreign key/primary key constraints
1:eac0369: 		** because they are added as a side effect of adding
1:eac0369: 		** their indexes above.
1:eac0369: 		*/
1:f167762: 		baseTable.getAllRelevantConstraints(
1:f167762:             StatementType.UPDATE,
1:f167762:             changedColumnIds,
1:f167762:             needsDeferredProcessing,
1:f167762:             relevantConstraints);
1:eac0369: 
1:eac0369: 		int rclSize = relevantConstraints.size();
1:eac0369: 		for (int index = 0; index < rclSize; index++)
1:eac0369: 		{
1:eac0369: 			ConstraintDescriptor cd = relevantConstraints.elementAt(index);
1:eac0369: 			if (cd.getConstraintType() != DataDictionary.CHECK_CONSTRAINT)
1:eac0369: 			{
1:56bebbe: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			int[] refColumns = ((CheckConstraintDescriptor)cd).getReferencedColumns();
1:eac0369: 			for (int i = 0; i < refColumns.length; i++)
1:eac0369: 			{
1:eac0369: 				columnMap.set(refColumns[i]);
1:eac0369: 			}
1:b6c6e95: 		}
1:eac0369: 
1:ca28065:         //
1:ca28065:         // Add all columns mentioned by generation clauses which are affected
1:ca28065:         // by the columns being updated.
1:ca28065:         //
1:7ae50e9:         addGeneratedColumnPrecursors( baseTable, affectedGeneratedColumns, columnMap );
1:ca28065:         
1:eac0369: 		/*
1:a6f9586: 	 	* If we have any UPDATE triggers, then we will follow the 4 rules
1:a6f9586: 	 	* mentioned in the comments at the method level.
1:eac0369: 	 	*/
1:eac0369: 		baseTable.getAllRelevantTriggers( StatementType.UPDATE, changedColumnIds, relevantTriggers );
1:f246c9c: 
1:eac0369: 		if (relevantTriggers.size() > 0)
1:56bebbe: 		{
1:f246c9c: 			needsDeferredProcessing[0] = true;
1:56bebbe: 			
1:56bebbe: 			boolean needToIncludeAllColumns = false;
1:d9d1bc8: 			// If we are dealing with database created in 10.8 and prior,
1:d9d1bc8: 			// then we must be in soft upgrade mode. For such databases,
1:d9d1bc8: 			// we do not want to do any column reading optimization.
1:d9d1bc8: 			//
1:d9d1bc8: 			// For triggers created in 10.7.1.1, we kept track of trigger 
1:d9d1bc8: 			// action columns used through the REFERENCING clause. That 
1:d9d1bc8: 			// information was gathered so we could be smart about what
1:d9d1bc8: 			// columns from trigger table should be read during trigger
1:d9d1bc8: 			// execution. But those changes in code resulted in data
1:d9d1bc8: 			// corruption DERBY-5121. Because of that, we took out the
1:d9d1bc8: 			// column read optimization changes from codeline for next 
1:d9d1bc8: 			// release of 10.7 and 10.8 codeline.
1:d9d1bc8: 			// But we can still have triggers created in 10.7.1.1 with
1:d9d1bc8: 			// trigger action column information in SYSTRIGGERS. 
1:d9d1bc8: 			// In 10.9, we are reimplementing what columns should be read
1:d9d1bc8: 			// from the trigger table during trigger execution. But we do
1:d9d1bc8: 			// not want this column optimization changes to be used in soft 
1:d9d1bc8: 			// upgrade mode for a 10.8 or prior database so that we can
1:d9d1bc8: 			// go back to the older release if that's what the user chooses
1:d9d1bc8: 			// after the soft-upgrade.
1:d9d1bc8: 			boolean in10_9_orHigherVersion = dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null);
1:a6f9586: 
1:801cf0d:             for (TriggerDescriptor trd : relevantTriggers) {
1:d9d1bc8: 				if (in10_9_orHigherVersion) {
1:d9d1bc8: 					// See if we can avoid reading all the columns from the
1:d9d1bc8: 					// trigger table.
1:d9d1bc8: 	                int[] referencedColsInTriggerAction = trd.getReferencedColsInTriggerAction();
1:d9d1bc8: 	                int[] triggerCols = trd.getReferencedCols();
1:d9d1bc8: 	                if (triggerCols == null || triggerCols.length == 0) {
1:d9d1bc8: 	                        for (int i=0; i < columnCount; i++) {
1:d9d1bc8: 	                                columnMap.set(i+1);
1:d9d1bc8: 	                        }
1:d9d1bc8: 	                        //This trigger is not defined on specific columns 
1:d9d1bc8: 	                        // so we will have to read all the columns from the
1:d9d1bc8: 	                        // trigger table. Now, there is no need to go 
1:d9d1bc8: 	                        // through the rest of the triggers because we are
1:d9d1bc8: 	                        // going to read all the columns anyways.
1:d9d1bc8: 	                        break;
1:d9d1bc8: 	                } else {
1:d9d1bc8: 	                        if (referencedColsInTriggerAction == null ||
1:d9d1bc8: 	                                        referencedColsInTriggerAction.length == 0) {
1:d9d1bc8: 	                                //Does this trigger have REFERENCING clause defined on it
1:d9d1bc8: 	                                if (!trd.getReferencingNew() && !trd.getReferencingOld()) {
1:d9d1bc8: 	                                	//The trigger does not use trigger action columns through
1:d9d1bc8: 	                                	//the REFERENCING clause so we need to read just the
1:d9d1bc8: 	                                	//trigger columns
1:d9d1bc8:                                         for (int ix = 0; ix < triggerCols.length; ix++)
1:d9d1bc8:                                         {
1:d9d1bc8:                                                 columnMap.set(triggerCols[ix]);
1:d9d1bc8:                                         }
1:d9d1bc8: 	                                } else {
1:d9d1bc8: 	                                	//The trigger has REFERENCING clause defined on it
1:d9d1bc8: 	                                	// so it might be used them in trigger action.
1:d9d1bc8: 	                                	// We should just go ahead and read all the
1:d9d1bc8: 	                                	// columns from the trigger table. Now, there is 
1:d9d1bc8: 	                                	// no need to go through the rest of the triggers 
1:d9d1bc8: 	                                	// because we are going to read all the columns 
1:d9d1bc8: 	                                	// anyways.
1:d9d1bc8: 	        	                        needToIncludeAllColumns = true;
1:d9d1bc8: 	        	                        break;
1:d9d1bc8: 	                                }
1:d9d1bc8: 	                        } else {
1:d9d1bc8: 	                        	//This trigger has both trigger columns and
1:d9d1bc8: 	                        	// trigger action columns(getting used through
1:d9d1bc8: 	                        	// the REFERENCING clause). Read only those
1:d9d1bc8: 	                        	// columns because that's all we need from
1:d9d1bc8: 	                        	// trigger table for the trigger execution.
1:d9d1bc8: 	                                for (int ix = 0; ix < triggerCols.length; ix++)
1:d9d1bc8: 	                                {
1:d9d1bc8: 	                                        columnMap.set(triggerCols[ix]);
1:d9d1bc8: 	                                }
1:d9d1bc8: 	                                for (int ix = 0; ix < referencedColsInTriggerAction.length; ix++)
1:d9d1bc8: 	                                {
1:d9d1bc8: 	                                        columnMap.set(referencedColsInTriggerAction[ix]);
1:d9d1bc8: 	                                }
1:d9d1bc8: 	                        }
1:d9d1bc8: 	                }			
1:d9d1bc8: 	            } else {
1:d9d1bc8: 	            	//We are in soft upgrade mode working with 10.8 or lower 
1:d9d1bc8: 	            	// database.
1:d9d1bc8: 	                //Does this trigger have REFERENCING clause defined on it
1:d9d1bc8: 	                if (!trd.getReferencingNew() && !trd.getReferencingOld())
1:d9d1bc8: 	                        continue;
1:d9d1bc8: 	                else
1:d9d1bc8: 	                {
1:d9d1bc8: 	                        needToIncludeAllColumns = true;
1:d9d1bc8: 	                        break;
1:d9d1bc8: 	                }
1:d9d1bc8: 	            }
1:d9d1bc8:         }
1:a6f9586: 
1:d9d1bc8:         if (needToIncludeAllColumns) {
1:d9d1bc8:                 for (int i = 1; i <= columnCount; i++)
1:d9d1bc8:                 {
1:d9d1bc8:                         columnMap.set(i);
1:d9d1bc8:                 }
1:56bebbe: 			}
1:d9d1bc8: 			
1:56bebbe: 		}
1:f246c9c: 
1:eac0369: 		return	columnMap;
1:56bebbe: 	}
1:e1f49ca: 
1:eac0369:     /**
1:ca28065:      * Add all of the columns mentioned by the generation clauses of generated
1:ca28065:      * columns. The generated columns were added when we called
1:ca28065:      * addGeneratedColumns earlier on.
1:eac0369:      */
1:ca28065:     private static  void    addGeneratedColumnPrecursors
1:ca28065: 	(
1:7ae50e9:      TableDescriptor         baseTable,
1:7ae50e9:      ColumnDescriptorList    affectedGeneratedColumns,
1:7ae50e9:      FormatableBitSet        columnMap
1:ca28065: 	)
1:ca28065: 		throws StandardException
1:56bebbe: 	{
1:ca28065:         int                                 generatedColumnCount = affectedGeneratedColumns.size();
1:ca28065:         
2:ca28065:         for ( int gcIdx = 0; gcIdx < generatedColumnCount; gcIdx++ )
1:a6f9586:         {
1:ca28065:             ColumnDescriptor    gc = affectedGeneratedColumns.elementAt( gcIdx );
1:7ae50e9:             String[]                       mentionedColumnNames = gc.getDefaultInfo().getReferencedColumnNames();
1:7ae50e9:             int[]                       mentionedColumns = baseTable.getColumnIDs( mentionedColumnNames );
2:ca28065:             int                         mentionedColumnCount = mentionedColumns.length;
1:ca28065: 
2:ca28065:             for ( int mcIdx = 0; mcIdx < mentionedColumnCount; mcIdx++ )
1:a6f9586:             {
1:ca28065:                 columnMap.set( mentionedColumns[ mcIdx ] );
1:ca28065:                 
1:ca28065:             }   // done looping through mentioned columns
1:ca28065:             
1:ca28065:         }   // done looping through affected generated columns
1:ca28065: 
1:a6f9586:     }
1:ca28065:      
1:ca28065:     /**
1:ca28065:      * Add generated columns to the update list as necessary. We add
1:ca28065:      * any column whose generation clause mentions columns already
1:ca28065:      * in the update list. We fill in a list of all generated columns affected
1:ca28065:      * by this update. We also fill in a list of all generated columns which we
1:ca28065:      * added to the update list.
1:ca28065:      */
1:ca28065:     private void    addGeneratedColumns
1:ca28065: 	(
1:ca28065: 		TableDescriptor				baseTable,
1:ca28065:         ResultSetNode               updateSet,
2:ca28065:         ColumnDescriptorList    affectedGeneratedColumns,
1:ca28065:         ColumnDescriptorList    addedGeneratedColumns
1:ca28065: 	)
1:ca28065: 		throws StandardException
1:a6f9586: 	{
1:e1f49ca:         ResultColumnList     updateColumnList = updateSet.getResultColumns();
1:e1f49ca:         ColumnDescriptorList generatedColumns = baseTable.getGeneratedColumns();
1:e1f49ca:         HashSet<String>      updatedColumns = new HashSet<String>();
1:e1f49ca:         UUID                 tableID = baseTable.getObjectID();
1:ca28065:         
1:e1f49ca:         for (ResultColumn rc : updateColumnList)
1:f246c9c: 		{
1:e1f49ca:             updatedColumns.add( rc.getName() );
1:a6f9586: 		}
1:ca28065: 
1:e1f49ca:         for (ColumnDescriptor gc : generatedColumns)
1:f246c9c:         {
1:e1f49ca:             DefaultInfo defaultInfo = gc.getDefaultInfo();
1:e1f49ca:             String[] mentionedColumnNames =
1:e1f49ca:                     defaultInfo.getReferencedColumnNames();
1:e1f49ca:             int mentionedColumnCount = mentionedColumnNames.length;
1:ca28065: 
1:d4f9308:             // handle the case of setting a generated column to the DEFAULT
1:d4f9308:             // literal
1:d4f9308:             if ( updatedColumns.contains( gc.getColumnName() ) ) { affectedGeneratedColumns.add( tableID, gc ); }
1:d4f9308: 
1:ca28065:             // figure out if this generated column is affected by the
1:ca28065:             // update
1:e1f49ca:             for (String mcn : mentionedColumnNames)
1:ca28065:             {
1:e1f49ca:                 if ( updatedColumns.contains( mcn ) )
1:ca28065:                 {
1:ca28065:                     // Yes, we are updating one of the columns mentioned in
1:ca28065:                     // this generation clause.
1:ca28065:                     affectedGeneratedColumns.add( tableID, gc );
1:ca28065:                     
1:ca28065:                     // If the generated column isn't in the update list yet,
1:ca28065:                     // add it.
1:d4f9308:                     if ( !updatedColumns.contains( gc.getColumnName() ) )
1:ca28065:                     {
1:ca28065:                         addedGeneratedColumns.add( tableID, gc );
1:ca28065:                         
1:ca28065:                         // we will fill in the real value later on in parseAndBindGenerationClauses();
1:3bb140c:                         ValueNode dummy =
1:3bb140c:                             new UntypedNullConstantNode(getContextManager());
1:3bb140c:                         ResultColumn newResultColumn = new ResultColumn(
1:3bb140c:                             gc.getType(), dummy, getContextManager());
1:ca28065:                         newResultColumn.setColumnDescriptor( baseTable, gc );
1:ca28065:                         newResultColumn.setName( gc.getColumnName() );
1:ca28065: 
1:ca28065:                         updateColumnList.addResultColumn( newResultColumn );
1:a6f9586:                     }
1:ca28065:                     
1:56bebbe:                     break;
1:a6f9586:                 }
1:ca28065:             }   // done looping through mentioned columns
1:ca28065: 
1:ca28065:         }   // done looping through generated columns
1:a6f9586:     }
1:ca28065:      
1:ca28065: 
1:eac0369: 	/*
1:444aa52: 	 * Force correlated column references in the SET clause to have the
1:444aa52: 	 * name of the base table. This dances around the problem alluded to
1:444aa52: 	 * in scrubResultColumn().
1:eac0369: 	 */
1:444aa52: 	private	void	normalizeCorrelatedColumns( ResultColumnList rcl, FromTable fromTable )
1:b6c6e95: 		throws StandardException
1:ca28065: 	{
1:444aa52: 		String		correlationName = fromTable.getCorrelationName();
1:ca28065: 
1:444aa52: 		if ( correlationName == null ) { return; }
1:ca28065: 
1:444aa52: 		TableName	tableNameNode;
1:eac0369: 
1:444aa52: 		if ( fromTable instanceof CurrentOfNode )
1:444aa52: 		{ tableNameNode = ((CurrentOfNode) fromTable).getBaseCursorTargetTableName(); }
1:444aa52: 		else { tableNameNode = makeTableName( null, fromTable.getBaseTableName() ); }
1:eac0369: 		
1:e1f49ca:         for (ResultColumn column : rcl)
1:ca28065: 		{
1:444aa52: 			ColumnReference	reference = column.getReference();
1:eac0369: 
1:444aa52: 			if ( (reference != null) && correlationName.equals( reference.getTableName() ) )
1:eac0369: 			{
1:b0456a0: 				reference.setQualifiedTableName( tableNameNode );
1:a6f9586: 			}
1:a6f9586: 		}
1:eac0369: 		
1:f246c9c: 	}
1:eac0369: 
1:eac0369: 	/**
1:e2cf840: 	 * Check table name and then clear it from the result set columns.
1:eac0369: 	 * 
1:e2cf840: 	 * @exception StandardExcepion if invalid column/table is specified.
1:eac0369: 	 */
1:e2cf840: 	private void checkTableNameAndScrubResultColumns(ResultColumnList rcl) 
1:444aa52: 			throws StandardException
1:eac0369: 	{
1:e1f49ca:         for (ResultColumn column : rcl)
1:eac0369: 		{
1:e2cf840: 			boolean foundMatchingTable = false;			
1:eac0369: 
1:6b8d71b:             //
1:6b8d71b:             // The check for whether we are in the matching clause fixes
1:6b8d71b:             // the bug tracked by MergeStatementTest.test_060_transitionTableSimpleColumn().
1:6b8d71b:             // That bug was addressed by derby-3155-53-aa-transitionSimpleColumn.diff.
1:6b8d71b:             //
1:6b8d71b: 			if ( (column.getTableName() != null) && (!inMatchingClause()) ) {
1:e1f49ca:                 for (ResultSetNode rsn : ((SelectNode)resultSet).fromList) {
1:e1f49ca:                     FromTable fromTable = (FromTable)rsn;
1:e1f49ca: 
1:e2cf840: 					final String tableName;
1:e2cf840: 					if ( fromTable instanceof CurrentOfNode ) { 
1:e2cf840: 						tableName = ((CurrentOfNode)fromTable).
1:e2cf840: 								getBaseCursorTargetTableName().getTableName();
3:a6f9586: 					} else { 
1:e2cf840: 						tableName = fromTable.getBaseTableName();
1:f246c9c: 					}
1:eac0369: 
1:e2cf840: 					if (column.getTableName().equals(tableName)) {
1:e2cf840: 						foundMatchingTable = true;
1:a6f9586: 						break;
1:f246c9c: 					}
1:ca28065: 				}
1:eac0369: 
1:e2cf840: 				if (!foundMatchingTable) {
1:e2cf840: 					throw StandardException.newException(
1:e2cf840: 							SQLState.LANG_COLUMN_NOT_FOUND, 
1:e2cf840: 							column.getTableName() + "." + column.getName());
1:ca28065: 				}
1:ca28065: 			}
1:eac0369: 
1:444aa52: 			/* The table name is
1:eac0369: 			 * unnecessary for an update.  More importantly, though, it
1:eac0369: 			 * creates a problem in the degenerate case with a positioned
1:eac0369: 			 * update.  The user must specify the base table name for a
1:eac0369: 			 * positioned update.  If a correlation name was specified for
1:eac0369: 			 * the cursor, then a match for the ColumnReference would not
1:eac0369: 			 * be found if we didn't null out the name.  (Aren't you
1:eac0369: 			 * glad you asked?)
1:eac0369: 			 */
1:3e77b5a: 			column.clearTableName();
1:ca28065: 		}
1:eac0369: 	}
1:661c2e6: 
1:eac0369: 	/**
1:b6c6e95: 	 * Normalize synonym column references to have the name of the base table. 
1:661c2e6: 	 *
1:b6c6e95: 	 * @param rcl	    The result column list of the target table
1:b6c6e95: 	 * @param fromTable The table name to set the column refs to
2:b6c6e95: 	 * 
1:b6c6e95: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:b6c6e95: 	private	void normalizeSynonymColumns(
1:b6c6e95:     ResultColumnList    rcl, 
1:b6c6e95:     FromTable           fromTable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:b6c6e95: 		if (fromTable.getCorrelationName() != null) 
1:eac0369:         { 
1:b6c6e95:             return; 
1:eac0369:         }
1:eac0369: 		
1:b6c6e95: 		TableName tableNameNode;
1:b6c6e95: 		if (fromTable instanceof CurrentOfNode)
1:eac0369: 		{ 
1:b6c6e95: 			tableNameNode = 
1:b6c6e95:                 ((CurrentOfNode) fromTable).getBaseCursorTargetTableName(); 
1:eac0369: 		}
1:56bebbe: 		else 
1:eac0369: 		{ 
1:b6c6e95: 			tableNameNode = makeTableName(null, fromTable.getBaseTableName()); 
1:eac0369: 		}
1:eac0369: 		
1:b6c6e95: 		super.normalizeSynonymColumns(rcl, tableNameNode);
1:eac0369: 	}
1:ca28065:     
1:47611b1:     /**
1:47611b1:      * Do not allow generation clauses to be overriden. Throws an exception if
1:47611b1:      * the user attempts to override the value of a generated column.  The only
1:47611b1:      * value allowed in a generated column is DEFAULT. We will use
1:47611b1:      * addedGeneratedColumns list to pass through the generated columns which
1:47611b1:      * have already been added to the update list.
1:47611b1:      *
1:47611b1:      * @param targetRCL  the row in the table being UPDATEd
1:47611b1:      * @param addedGeneratedColumns generated columns which the compiler added
1:47611b1:      *        earlier on
1:47611b1:      * @throws StandardException on error
1:47611b1:      */
1:47611b1:     private void forbidGenerationOverrides(
1:47611b1:         ResultColumnList targetRCL,
1:47611b1:         ColumnDescriptorList addedGeneratedColumns)
1:47611b1:             throws StandardException
1:47611b1:     {
1:47611b1:         int  count = targetRCL.size();
1:47611b1: 
1:47611b1:         ResultColumnList    resultRCL = resultSet.getResultColumns();
1:47611b1: 
1:47611b1:         for ( int i = 0; i < count; i++ )
1:47611b1:         {
1:e1f49ca:             ResultColumn rc = targetRCL.elementAt( i );
1:47611b1: 
1:508a010:             // defaults may already have been substituted for MERGE statements
1:508a010:             if ( rc.wasDefaultColumn() ) { continue; }
1:508a010:             
1:47611b1:             if ( rc.hasGenerationClause() )
1:47611b1:             {
1:47611b1:                 ValueNode   resultExpression =
1:e1f49ca:                     resultRCL.elementAt( i ).getExpression();
1:47611b1: 
1:47611b1:                 if ( !( resultExpression instanceof DefaultNode) )
1:47611b1:                 {
1:47611b1:                     //
1:47611b1:                     // We may have added the generation clause
1:47611b1:                     // ourselves. Here we forgive ourselves for this
1:47611b1:                     // pro-active behavior.
1:47611b1:                     //
1:47611b1:                     boolean allIsForgiven = false;
1:47611b1: 
1:47611b1:                     String columnName =
1:47611b1:                         rc.getTableColumnDescriptor().getColumnName();
1:47611b1: 
1:47611b1:                     int addedCount = addedGeneratedColumns.size();
1:47611b1: 
1:47611b1:                     for ( int j = 0; j < addedCount; j++ )
1:47611b1:                     {
1:47611b1:                         String addedColumnName = addedGeneratedColumns.
1:47611b1:                             elementAt(j).getColumnName();
1:47611b1: 
1:47611b1:                         if ( columnName.equals( addedColumnName ) )
1:47611b1:                         {
1:47611b1:                             allIsForgiven = true;
1:f246c9c:                             break;
1:47611b1:                         }
1:47611b1:                     }
1:47611b1:                     if ( allIsForgiven ) { continue; }
1:47611b1: 
1:47611b1:                     throw StandardException.newException
1:47611b1:                         (SQLState.LANG_CANT_OVERRIDE_GENERATION_CLAUSE,
1:47611b1:                          rc.getName() );
1:47611b1:                 }
1:f246c9c:                 else
1:47611b1:                 {
1:47611b1:                     // Skip this step if we're working on an update
1:47611b1:                     // statement. For updates, the target list has already
1:47611b1:                     // been enhanced.
1:f246c9c:                     continue;
1:47611b1:                 }
1:47611b1:             }
1:47611b1:         }
1:47611b1:     }
1:eac0369: } // end of UpdateNode
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                    TypeId.getBuiltInTypeId(Types.INTEGER), 0,
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:dda453e
/////////////////////////////////////////////////////////////////////////
1:             if (!cursorStmt.hasUpdateColumns())
/////////////////////////////////////////////////////////////////////////
1:                 resultSet.getResultColumns().checkColumnUpdateability(
1:                         cursorStmt, currentOfNode.getCursorName());
commit:b153b24
/////////////////////////////////////////////////////////////////////////
0:         ArrayList conglomerates = new ArrayList();
1:              dd, baseTable, updateColumnList, conglomerates, relevantCdl,
1:         markAffectedIndexes(conglomerates);
/////////////////////////////////////////////////////////////////////////
1:       * @param  conglomerates       OUT: list of affected indices
/////////////////////////////////////////////////////////////////////////
0:         List                        conglomerates,
/////////////////////////////////////////////////////////////////////////
1:         DMLModStatementNode.getXAffectedIndexes(
1:                 baseTable, updateColumnList, columnMap, conglomerates);
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList conglomVector = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0: 		List						conglomVector,
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
1: 		// createResultSet() will only be called once.
1: 		generateCodeForTemporaryTable(acb);
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0: 			rowLocationNode = (ValueNode) getNodeFactory().getNode(
0: 			rowLocationNode = (ValueNode) getNodeFactory().getNode(
/////////////////////////////////////////////////////////////////////////
0: 			resultSet = (ResultSetNode) getNodeFactory().getNode(
commit:ccee531
/////////////////////////////////////////////////////////////////////////
1: 		// If the DML is on the temporary table, generate the code to
1: 		// mark temporary table as modified in the current UOW. After
1: 		// DERBY-827 this must be done in execute() since
0: 		// fillResultSet() will only be called once.
0: 		generateCodeForTemporaryTable(acb, acb.getExecuteMethod());
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a826375
/////////////////////////////////////////////////////////////////////////
1: public final class UpdateNode extends DMLModGeneratedColumnsStatementNode
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-6414(Incorrect handling when using an UPDATE to SET an 
1:         // identity column to DEFAULT)
1:         //The bug is fixed only for Derby 10.11 and higher. Starting 10.11,
1:         // we have started using sequence generator to create unique ids
1:         //If we fix this jira for prior releases, we will need to maintain
1:         // the code for old way of generating unique ids.
1:         if (dataDictionary.checkVersion( DataDictionary.DD_VERSION_DERBY_10_11, null )) {
1:             //Replace any DEFAULTs with the associated tree for the default if
1:             // allowed, otherwise throw an exception
1:             resultSet.getResultColumns().replaceOrForbidDefaults(
1:             		targetTableDescriptor, 
1:             		resultSet.getResultColumns(), true);
1:             resultSet.getResultColumns().checkForInvalidDefaults();
1:             resultSet.getResultColumns().forbidOverrides(resultSet.getResultColumns());
1:         } else {
1:     		LanguageConnectionContext lcc = getLanguageConnectionContext();
1:     		if (lcc.getAutoincrementUpdate() == false)
1:     			resultSet.getResultColumns().forbidOverrides(null);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             TransactionController tc = 
1:                     getLanguageConnectionContext().getTransactionCompile();
1: 
1:             autoincRowLocation = 
1:                     dataDictionary.computeAutoincRowLocations(tc, targetTableDescriptor);
1: 		identitySequenceUUIDString = getUUIDofSequenceGenerator();
1: 
/////////////////////////////////////////////////////////////////////////
1: 			  autoincRowLocation,
1: 			  inMatchingClause(),
1: 			  identitySequenceUUIDString
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
0:              dd, baseTable, updateColumnList, conglomVector, relevantCdl,
/////////////////////////////////////////////////////////////////////////
1: 	  *       release 10.9 or higher(with the exception of 10.7.1.1 where we
1: 	  *       did collect that information but because of corruption caused
1: 	  *       by those changes, we do not use the information collected by
1: 	  *       10.7). Starting 10.9, we are collecting trigger action column 
1: 	  *       informatoin so we can be smart about what columns get read 
1: 	  *       during trigger execution. eg
1: 	  *       table. This will cover soft-upgrade scenario for triggers created 
1: 	  *       pre-10.9. 
1: 	  *       eg trigger created prior to 10.9
1: 	  *	@param	dd	Data Dictionary
1: 	  *	@param	baseTable	Table on which update is issued
/////////////////////////////////////////////////////////////////////////
1: 		DataDictionary		dd,
/////////////////////////////////////////////////////////////////////////
1: 			// If we are dealing with database created in 10.8 and prior,
1: 			// then we must be in soft upgrade mode. For such databases,
1: 			// we do not want to do any column reading optimization.
1: 			//
1: 			// For triggers created in 10.7.1.1, we kept track of trigger 
1: 			// action columns used through the REFERENCING clause. That 
1: 			// information was gathered so we could be smart about what
1: 			// columns from trigger table should be read during trigger
1: 			// execution. But those changes in code resulted in data
1: 			// corruption DERBY-5121. Because of that, we took out the
1: 			// column read optimization changes from codeline for next 
1: 			// release of 10.7 and 10.8 codeline.
1: 			// But we can still have triggers created in 10.7.1.1 with
1: 			// trigger action column information in SYSTRIGGERS. 
1: 			// In 10.9, we are reimplementing what columns should be read
1: 			// from the trigger table during trigger execution. But we do
1: 			// not want this column optimization changes to be used in soft 
1: 			// upgrade mode for a 10.8 or prior database so that we can
1: 			// go back to the older release if that's what the user chooses
1: 			// after the soft-upgrade.
1: 			boolean in10_9_orHigherVersion = dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null);
1: 				if (in10_9_orHigherVersion) {
1: 					// See if we can avoid reading all the columns from the
1: 					// trigger table.
1: 	                int[] referencedColsInTriggerAction = trd.getReferencedColsInTriggerAction();
1: 	                int[] triggerCols = trd.getReferencedCols();
1: 	                if (triggerCols == null || triggerCols.length == 0) {
1: 	                        for (int i=0; i < columnCount; i++) {
1: 	                                columnMap.set(i+1);
1: 	                        }
1: 	                        //This trigger is not defined on specific columns 
1: 	                        // so we will have to read all the columns from the
1: 	                        // trigger table. Now, there is no need to go 
1: 	                        // through the rest of the triggers because we are
1: 	                        // going to read all the columns anyways.
1: 	                        break;
1: 	                } else {
1: 	                        if (referencedColsInTriggerAction == null ||
1: 	                                        referencedColsInTriggerAction.length == 0) {
1: 	                                //Does this trigger have REFERENCING clause defined on it
1: 	                                if (!trd.getReferencingNew() && !trd.getReferencingOld()) {
1: 	                                	//The trigger does not use trigger action columns through
1: 	                                	//the REFERENCING clause so we need to read just the
1: 	                                	//trigger columns
1:                                         for (int ix = 0; ix < triggerCols.length; ix++)
1:                                         {
1:                                                 columnMap.set(triggerCols[ix]);
1:                                         }
1: 	                                } else {
1: 	                                	//The trigger has REFERENCING clause defined on it
1: 	                                	// so it might be used them in trigger action.
1: 	                                	// We should just go ahead and read all the
1: 	                                	// columns from the trigger table. Now, there is 
1: 	                                	// no need to go through the rest of the triggers 
1: 	                                	// because we are going to read all the columns 
1: 	                                	// anyways.
1: 	        	                        needToIncludeAllColumns = true;
1: 	        	                        break;
1: 	                                }
1: 	                        } else {
1: 	                        	//This trigger has both trigger columns and
1: 	                        	// trigger action columns(getting used through
1: 	                        	// the REFERENCING clause). Read only those
1: 	                        	// columns because that's all we need from
1: 	                        	// trigger table for the trigger execution.
1: 	                                for (int ix = 0; ix < triggerCols.length; ix++)
1: 	                                {
1: 	                                        columnMap.set(triggerCols[ix]);
1: 	                                }
1: 	                                for (int ix = 0; ix < referencedColsInTriggerAction.length; ix++)
1: 	                                {
1: 	                                        columnMap.set(referencedColsInTriggerAction[ix]);
1: 	                                }
1: 	                        }
1: 	                }			
1: 	            } else {
1: 	            	//We are in soft upgrade mode working with 10.8 or lower 
1: 	            	// database.
1: 	                //Does this trigger have REFERENCING clause defined on it
1: 	                if (!trd.getReferencingNew() && !trd.getReferencingOld())
1: 	                        continue;
1: 	                else
1: 	                {
1: 	                        needToIncludeAllColumns = true;
1: 	                        break;
1: 	                }
1: 	            }
1:         }
1:         if (needToIncludeAllColumns) {
1:                 for (int i = 1; i <= columnCount; i++)
1:                 {
1:                         columnMap.set(i);
1:                 }
1: 			
commit:56bebbe
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			boolean needToIncludeAllColumns = false;
0: 				//Does this trigger have REFERENCING clause defined on it
0: 				if (!trd.getReferencingNew() && !trd.getReferencingOld())
1: 					continue;
1: 				else
1: 				{
0: 					needToIncludeAllColumns = true;
1: 					break;
1: 				}
1: 			}
0: 			if (needToIncludeAllColumns) {
0: 				for (int i = 1; i <= columnCount; i++)
1: 				{
0: 					columnMap.set(i);
1: 				}
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1: 	  *	6)	Go through all those triggers from step 5 and for each one of
1: 	  *     those triggers, follow the rules below to decide which columns
1: 	  *     should be read.
1: 	  *       Rule1)If trigger column information is null, then read all the
1: 	  *       columns from trigger table into memory irrespective of whether
1: 	  *       there is any trigger action column information. 2 egs of such
1: 	  *       triggers
1: 	  *         create trigger tr1 after update on t1 for each row values(1);
1: 	  *         create trigger tr1 after update on t1 referencing old as oldt
1: 	  *         	for each row insert into t2 values(2,oldt.j,-2); 
1: 	  *       Rule2)If trigger column information is available but no trigger 
1: 	  *       action column information is found and no REFERENCES clause is
1: 	  *       used for the trigger, then read all the columns identified by 
1: 	  *       the trigger column. eg 
1: 	  *         create trigger tr1 after update of c1 on t1 
1: 	  *         	for each row values(1);
1: 	  *       Rule3)If trigger column information and trigger action column
1: 	  *       information both are not null, then only those columns will be
1: 	  *       read into memory. This is possible only for triggers created in
0: 	  *       release 10.7 or higher. Because prior to that we did not collect
0: 	  *       trigger action column informatoin. eg
1: 	  *         create trigger tr1 after update of c1 on t1 
1: 	  *         	referencing old as oldt for each row 
1: 	  *         	insert into t2 values(2,oldt.j,-2);
1: 	  *       Rule4)If trigger column information is available but no trigger 
1: 	  *       action column information is found but REFERENCES clause is used
1: 	  *       for the trigger, then read all the columns from the trigger 
0: 	  *       table. This will cover soft-upgrade and hard-upgrade scenario
0: 	  *       for triggers created pre-10.7. This rule prevents us from having
0: 	  *       special logic for soft-upgrade. Additionally, this logic makes
0: 	  *       invalidation of existing triggers unnecessary during 
0: 	  *       hard-upgrade. The pre-10.7 created triggers will work just fine
0: 	  *       even though for some triggers, they would have trigger action
0: 	  *       columns missing. A user can choose to drop and recreate such 
0: 	  *       triggers to take advantage of Rule 3 which will avoid unnecssary
0: 	  *       column reads during trigger execution.
0: 	  *       eg trigger created prior to 10.7
1: 	  *         create trigger tr1 after update of c1 on t1 
1: 	  *         	referencing old as oldt for each row 
1: 	  *         	insert into t2 values(2,oldt.j,-2);
0: 	  *       To reiterate, Rule4) is there to cover triggers created with
0: 	  *       pre-10,7 releases but now that database has been
0: 	  *       hard/soft-upgraded to 10.7 or higher version. Prior to 10.7,
0: 	  *       we did not collect any information about trigger action columns.
0: 	  *       Rule5)The only place we will need special code for soft-upgrade
0: 	  *       is during trigger creation. If we are in soft-upgrade mode, we
0: 	  *       want to make sure that we do not save information about trigger
0: 	  *       action columns in SYSTRIGGERS because the releases prior to 10.7
0: 	  *       do not understand trigger action column information.
/////////////////////////////////////////////////////////////////////////
1: 	 	* If we have any UPDATE triggers, then we will follow the 4 rules
1: 	 	* mentioned in the comments at the method level.
1: 		{
1: 				
0: 				int[] referencedColsInTriggerAction = trd.getReferencedColsInTriggerAction();
0: 				int[] triggerCols = trd.getReferencedCols();
0: 				if (triggerCols == null || triggerCols.length == 0) {
0: 					for (int i=0; i < columnCount; i++) {
0: 						columnMap.set(i+1);
1: 					}
0: 					//no need to go through the test of the trigger because
0: 					//we have already decided to read all the columns 
0: 					//because no trigger action columns were found for the
0: 					//trigger that we are considering right now.
1: 					break; 
1: 				} else {
0: 					if (referencedColsInTriggerAction == null || 
0: 							referencedColsInTriggerAction.length == 0) {
0: 						//Does this trigger have REFERENCING clause defined on it
0: 						if (!trd.getReferencingNew() && !trd.getReferencingOld()) {
0: 							for (int ix = 0; ix < triggerCols.length; ix++)
1: 							{
0: 								columnMap.set(triggerCols[ix]);
1: 							}
1: 						} else {
0: 							for (int i=0; i < columnCount; i++) {
0: 								columnMap.set(i+1);
1: 							}							
0: 							//no need to go through the test of the trigger because
0: 							//we have already decided to read all the columns 
0: 							//because no trigger action columns were found for the
0: 							//trigger that we are considering right now.
1: 							break; 
1: 						}
1: 					} else {
0: 						for (int ix = 0; ix < triggerCols.length; ix++)
1: 						{
0: 							columnMap.set(triggerCols[ix]);
1: 						}
0: 						for (int ix = 0; ix < referencedColsInTriggerAction.length; ix++)
1: 						{
0: 							columnMap.set(referencedColsInTriggerAction[ix]);
1: 						}
1: 					}
1: 				}			
1: 
commit:f246c9c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
0: 	  *	6)	if there are any UPDATE triggers, then do one of the following
0: 	  *     a)If all of the triggers have MISSING referencing clause, then that
0: 	  *      means that the trigger actions do not have access to before and
0: 	  *      after values. In that case, there is no need to blanketly decide 
0: 	  *      to include all the columns in the read map just because there are
0: 	  *      triggers defined on the table.
0: 	  *     b)Since one/more triggers have REFERENCING clause on them, get all
0: 	  *      the columns because we don't know what the user will ultimately 
0: 	  *      reference.
/////////////////////////////////////////////////////////////////////////
0: 	 	** If we have any UPDATE triggers, then do one of the following
0: 	 	** 1)If all of the triggers have MISSING referencing clause, then that
0: 	 	** means that the trigger actions do not have access to before and 
0: 	 	** after values. In that case, there is no need to blanketly decide to
0: 	 	** include all the columns in the read map just because there are
0: 	 	** triggers defined on the table.
0: 	 	** 2)Since one/more triggers have REFERENCING clause on them, get all 
0: 	 	** the columns because we don't know what the user will ultimately reference.
1: 		{ 
1: 			needsDeferredProcessing[0] = true;
1: 			
0: 			boolean needToIncludeAllColumns = false;
0: 			Enumeration descs = relevantTriggers.elements();
0: 			while (descs.hasMoreElements())
0: 				TriggerDescriptor trd = (TriggerDescriptor) descs.nextElement();
0: 				//Does this trigger have REFERENCING clause defined on it
0: 				if (!trd.getReferencingNew() && !trd.getReferencingOld())
1: 					continue;
1: 				else
1: 				{
0: 					needToIncludeAllColumns = true;
1: 					break;
1: 				}
1: 			}
1: 
0: 			if (needToIncludeAllColumns) {
0: 				for (int i = 1; i <= columnCount; i++)
1: 				{
0: 					columnMap.set(i);
1: 				}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:591ff9f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:         // SQL 2011, section 6.10, SR 4b.
1:         SelectNode.checkNoWindowFunctions(resultSet, "<update source>");
1: 
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:             checkConstraints = bindConstraints(
1:                 dataDictionary,
1:                 getOptimizerFactory(),
1:                 targetTableDescriptor,
1:                 null,
1:                 sourceRCL,
1:                 changedColumnIds,
1:                 readColsBitSet,
1:                 true, /* we always include triggers in core language */
1:                 new boolean[1]); // dummy
/////////////////////////////////////////////////////////////////////////
1:             ( targetTableDescriptor,
commit:f167762
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		baseTable.getAllRelevantConstraints(
1:             StatementType.UPDATE,
1:             changedColumnIds,
1:             needsDeferredProcessing,
1:             relevantConstraints);
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
/////////////////////////////////////////////////////////////////////////
1:         relevantTriggers =  new TriggerDescriptorList();
/////////////////////////////////////////////////////////////////////////
1:         TriggerDescriptorList       relevantTriggers,
/////////////////////////////////////////////////////////////////////////
1:             for (TriggerDescriptor trd : relevantTriggers) {
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     FormatableBitSet getReadMap
/////////////////////////////////////////////////////////////////////////
1: 
0:             for (Iterator<?> descIter = relevantTriggers.iterator();
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList     updateColumnList = updateSet.getResultColumns();
1:         ColumnDescriptorList generatedColumns = baseTable.getGeneratedColumns();
1:         HashSet<String>      updatedColumns = new HashSet<String>();
1:         UUID                 tableID = baseTable.getObjectID();
1:         for (ResultColumn rc : updateColumnList)
1:             updatedColumns.add( rc.getName() );
1:         for (ColumnDescriptor gc : generatedColumns)
1:             DefaultInfo defaultInfo = gc.getDefaultInfo();
1:             String[] mentionedColumnNames =
1:                     defaultInfo.getReferencedColumnNames();
1:             int mentionedColumnCount = mentionedColumnNames.length;
/////////////////////////////////////////////////////////////////////////
1:             for (String mcn : mentionedColumnNames)
1:                 if ( updatedColumns.contains( mcn ) )
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn column : rcl)
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn column : rcl)
1:                 for (ResultSetNode rsn : ((SelectNode)resultSet).fromList) {
1:                     FromTable fromTable = (FromTable)rsn;
1: 
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn rc = targetRCL.elementAt( i );
1:                     resultRCL.elementAt( i ).getExpression();
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import org.apache.derby.catalog.DefaultInfo;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.CheckConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: import org.apache.derby.vti.DeferModification;
/////////////////////////////////////////////////////////////////////////
1:     int[]               changedColumnIds;
1:     boolean             deferred;
1:     ValueNode           checkConstraints;
1:     static final String COLUMNNAME = "###RowLocationToUpdate";
1:      * Constructor for an UpdateNode.
1:      * @param resultSet         The ResultSet that we will generate
1:      * @param cm                The context manager
0:     UpdateNode(TableName targetTableName,
1:                ResultSetNode resultSet,
0:                ContextManager cm)
0:         super(resultSet, cm);
0:         setNodeType(C_NodeTypes.UPDATE_NODE);
1:         this.targetTableName = targetTableName;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         FromList fromList = new FromList(
1:                 getOptimizerFactory().doJoinOrderOptimization(),
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(resultSet.getFromList().size() == 1,
1:                     "More than one table in result from list in an update.");
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ValueNode rowLocationNode;
1: 
/////////////////////////////////////////////////////////////////////////
1:             rowLocationNode = new CurrentRowLocationNode(getContextManager());
1:            rowLocationNode = new NumericConstantNode(
0:                    TypeId.getBuiltInTypeId(Types.INTEGER),
0:                    ReuseFactory.getInteger( 0),
1:                    getContextManager());
1:         ResultColumn rowLocationColumn = new ResultColumn(
1:                 COLUMNNAME, rowLocationNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         /* Bind the new ResultColumn */
1:         rowLocationColumn.bindResultColumnToExpression();
/////////////////////////////////////////////////////////////////////////
1:             resultSet = new NormalizeResultSetNode(
1:                 resultSet, resultColumnList, null, true, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 afterColumns = new ResultColumnList(getContextManager());
/////////////////////////////////////////////////////////////////////////
0:                                                 getOptimizerFactory(),
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean referencesSessionSchema()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
0:         int lckMode = resultSet.updateTargetLockMode();
/////////////////////////////////////////////////////////////////////////
1:             lckMode = TransactionController.MODE_TABLE;
/////////////////////////////////////////////////////////////////////////
1:               lckMode,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     static FormatableBitSet getUpdateReadMap
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         ValueNode dummy =
1:                             new UntypedNullConstantNode(getContextManager());
1:                         ResultColumn newResultColumn = new ResultColumn(
1:                             gc.getType(), dummy, getContextManager());
commit:47611b1
/////////////////////////////////////////////////////////////////////////
1:         forbidGenerationOverrides( resultSet.getResultColumns(),
1: 								   addedGeneratedColumns );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Do not allow generation clauses to be overriden. Throws an exception if
1:      * the user attempts to override the value of a generated column.  The only
1:      * value allowed in a generated column is DEFAULT. We will use
1:      * addedGeneratedColumns list to pass through the generated columns which
1:      * have already been added to the update list.
1:      *
1:      * @param targetRCL  the row in the table being UPDATEd
1:      * @param addedGeneratedColumns generated columns which the compiler added
1:      *        earlier on
1:      * @throws StandardException on error
1:      */
1:     private void forbidGenerationOverrides(
1:         ResultColumnList targetRCL,
1:         ColumnDescriptorList addedGeneratedColumns)
1:             throws StandardException
1:     {
1:         int  count = targetRCL.size();
1: 
1:         ResultColumnList    resultRCL = resultSet.getResultColumns();
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             ResultColumn    rc = (ResultColumn) targetRCL.elementAt( i );
1: 
1:             if ( rc.hasGenerationClause() )
1:             {
1:                 ValueNode   resultExpression =
0:                     ((ResultColumn) resultRCL.elementAt( i )).getExpression();
1: 
1:                 if ( !( resultExpression instanceof DefaultNode) )
1:                 {
1:                     //
1:                     // We may have added the generation clause
1:                     // ourselves. Here we forgive ourselves for this
1:                     // pro-active behavior.
1:                     //
1:                     boolean allIsForgiven = false;
1: 
1:                     String columnName =
1:                         rc.getTableColumnDescriptor().getColumnName();
1: 
1:                     int addedCount = addedGeneratedColumns.size();
1: 
1:                     for ( int j = 0; j < addedCount; j++ )
1:                     {
1:                         String addedColumnName = addedGeneratedColumns.
1:                             elementAt(j).getColumnName();
1: 
1:                         if ( columnName.equals( addedColumnName ) )
1:                         {
1:                             allIsForgiven = true;
0:                             break;
1:                         }
1:                     }
1:                     if ( allIsForgiven ) { continue; }
1: 
1:                     throw StandardException.newException
1:                         (SQLState.LANG_CANT_OVERRIDE_GENERATION_CLAUSE,
1:                          rc.getName() );
1:                 }
1:                 else
1:                 {
1:                     // Skip this step if we're working on an update
1:                     // statement. For updates, the target list has already
1:                     // been enhanced.
0:                     continue;
1:                 }
1:             }
1:         }
1:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6b8d71b
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // The check for whether we are in the matching clause fixes
1:             // the bug tracked by MergeStatementTest.test_060_transitionTableSimpleColumn().
1:             // That bug was addressed by derby-3155-53-aa-transitionSimpleColumn.diff.
1:             //
1: 			if ( (column.getTableName() != null) && (!inMatchingClause()) ) {
commit:ffbe813
/////////////////////////////////////////////////////////////////////////
1:         List<CastNode> allCastNodes = collectAllCastNodes();
/////////////////////////////////////////////////////////////////////////
1:         getCompilerContext().removePrivilegeFilter( tagFilter );
1:         // Add USAGE privilege for all CASTs to UDTs mentioned in the WHERE clause and
1:         for ( CastNode value : allCastNodes )
1:         {
1:             addUDTUsagePriv( value );
1:         }
/////////////////////////////////////////////////////////////////////////
1:      * Collect all of the CastNodes in the WHERE clause and on the right side
1:     private List<CastNode>    collectAllCastNodes()
1:         CollectNodesVisitor<CastNode> getCasts =
1:             new CollectNodesVisitor<CastNode>(CastNode.class);
1:         if ( whereClause != null ) { whereClause.accept( getCasts ); }
1:             rcl.elementAt( i ).getExpression().accept( getCasts );
1:         return getCasts.getList();
commit:daffaee
/////////////////////////////////////////////////////////////////////////
1:         //
0:         // Add USAGE privilege for all UDTs mentioned in the WHERE clause and
1:         // on the right side of SET operators.
1:         //
/////////////////////////////////////////////////////////////////////////
commit:3e77b5a
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // First step in associating added columns with the TARGET table of
1:         // a MERGE statement. Here we identify the columns which were NOT ADDED.
1:         //
1:         if ( inMatchingClause() ) { tagOriginalResultSetColumns(); }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         /* Append to the ResultColumnList */
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Second step in associating added columns with the TARGET table of
1:         // a MERGE statement. Here we associate the columns which were not originally tagged.
1:         //
1:         if ( inMatchingClause() ) { associateAddedColumns(); }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Associate all added columns with the TARGET table of the enclosing
1:      * MERGE statement.
1:      */
1:     private void    associateAddedColumns()
1:         throws StandardException
1:     {
1:         for ( ColumnReference cr : collectAllResultSetColumns() )
1:         {
1:             if ( !cr.taggedWith( TagFilter.ORIG_UPDATE_COL ) )
1:             {
1:                 cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Tag the original columns mentioned in the result list.
1:      */
1:     private void    tagOriginalResultSetColumns()
1:         throws StandardException
1:     {
1:         for ( ColumnReference cr : collectAllResultSetColumns() )
1:         {
1:             cr.addTag( TagFilter.ORIG_UPDATE_COL );
1:         }
1:     }
1: 
1:     /**
1:      * Collect all of the result set columns.
1:      */
1:     private List<ColumnReference>   collectAllResultSetColumns()
1:         throws StandardException
1:     {
1:         CollectNodesVisitor<ColumnReference> crVisitor =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:         resultSet.getResultColumns().accept( crVisitor );
1: 
1:         return crVisitor.getList();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 			column.clearTableName();
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT((resultSet.getResultColumns() != null),	
/////////////////////////////////////////////////////////////////////////
1: 			normalizeSynonymColumns( resultSet.getResultColumns(), targetTable );
1: 		normalizeCorrelatedColumns( resultSet.getResultColumns(), targetTable );
1: 		resultSet.bindResultColumns
1:             (
1:              targetTableDescriptor,
1:              targetVTI,
1:              resultSet.getResultColumns(), this,
1:              fromList
1:              );
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 				reference.setQualifiedTableName( tableNameNode );
commit:c2a0bdd
/////////////////////////////////////////////////////////////////////////
1: 		else if
1:             (
1:              (targetTable instanceof FromVTI) ||
1:              (targetTable instanceof FromSubquery)
1:              )
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.TagFilter;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         // collect lists of objects which will require privilege checks
1:         ArrayList<String>   explicitlySetColumns = getExplicitlySetColumns();
0:         List<ValueNode> allValueNodes = collectAllValueNodes();
1:         tagPrivilegedNodes();
1: 
1:         // tell the compiler to only add privilege checks for nodes which have been tagged
1:         TagFilter   tagFilter = new TagFilter( TagFilter.NEED_PRIVS_FOR_UPDATE_STMT );
1:         getCompilerContext().addPrivilegeFilter( tagFilter );
1: 		
/////////////////////////////////////////////////////////////////////////
1: 
1:         // add UPDATE_PRIV on all columns on the left side of SET operators
1:         addUpdatePriv( explicitlySetColumns );
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		getCompilerContext().popCurrentPrivType();
1: 
0:         // don't remove the privilege filter. additional binding may be
0:         // done during the pre-processing phase
1: 
0:         addUDTUsagePriv( allValueNodes );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the names of the explicitly set columns, that is, the columns on the left side
1:      * of SET operators.
1:      */
1:     private ArrayList<String>   getExplicitlySetColumns()
1:         throws StandardException
1:     {
1:         ArrayList<String>   result = new ArrayList<String>();
1:         ResultColumnList    rcl = resultSet.getResultColumns();
1: 
1:         for ( int i = 0; i < rcl.size(); i++ )
1:         {
1:             result.add( rcl.elementAt( i ).getName() );
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
0:      * Collect all of the ValueNodes in the WHERE clause and on the right side
1:      * of SET operators. Later on, we will need to add permissions for all UDTs
1:      * mentioned by these nodes.
1:      */
0:     private List<ValueNode>    collectAllValueNodes()
1:         throws StandardException
1:     {
0:         CollectNodesVisitor<ValueNode> getValues =
0:             new CollectNodesVisitor<ValueNode>(ValueNode.class);
1: 
1:         // process the WHERE clause
1:         ValueNode   whereClause = ((SelectNode) resultSet).whereClause;
0:         if ( whereClause != null ) { whereClause.accept( getValues ); }
1: 
1:         // process the right sides of the SET operators
1:         ResultColumnList    rcl = resultSet.getResultColumns();
1:         for ( int i = 0; i < rcl.size(); i++ )
1:         {
0:             rcl.elementAt( i ).getExpression().accept( getValues );
1:         }
1: 
0:         return getValues.getList();
1:     }
1: 
1:     /**
0:      * Add USAGE privilege for all UDTs mentioned in the WHERE clause and
0:      * on the right side of SET operators.
1:      */
0:     private void    addUDTUsagePriv( List<ValueNode> valueNodes )
1:         throws StandardException
1:     {
1:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:         
0:         for ( ValueNode val : valueNodes )
1:         {
0:             DataTypeDescriptor  dtd = val.getTypeServices();
0:             if ( (dtd != null) && dtd.getTypeId().userType() )
1:             {
0:                 AliasDescriptor ad = getUDTDesc( dtd );
0:                 getCompilerContext().addRequiredUsagePriv( ad );
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Tag all of the nodes which may require privilege checks.
1:      * These are various QueryTreeNodes in the WHERE clause and on the right
1:      * side of SET operators.
1:      */
1:     private void    tagPrivilegedNodes()
1:         throws StandardException
1:     {
1:         ArrayList<QueryTreeNode>    result = new ArrayList<QueryTreeNode>();
1: 
1:         SelectNode  selectNode = (SelectNode) resultSet;
1: 
1:         // add this node so that addUpdatePriv() and addUDTUsagePriv() will work
1:         result.add( this );
1: 
1:         // process the WHERE clause
1:         ValueNode   whereClause = selectNode.whereClause;
1:         if ( whereClause !=  null ) { collectPrivilegedNodes( result, whereClause ); }
1: 
1:         // process the right sides of the SET operators
1:         ResultColumnList    rcl = resultSet.getResultColumns();
1:         for ( int i = 0; i < rcl.size(); i++ )
1:         {
1:             collectPrivilegedNodes( result, rcl.elementAt( i ).getExpression() );
1:         }
1: 
1:         // now tag all the nodes we collected
1:         for ( QueryTreeNode expr : result )
1:         {
1:             expr.addTag( TagFilter.NEED_PRIVS_FOR_UPDATE_STMT );
1:         }
1:     }
1: 
1:     /**
1:      * Add to an evolving list all of the nodes under an expression which may require privilege checks.
1:      */
1:     private void    collectPrivilegedNodes
1:         ( ArrayList<QueryTreeNode> result, QueryTreeNode expr )
1:         throws StandardException
1:     {
1:         // get all column references
1:         CollectNodesVisitor<ColumnReference> getCRs =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:         expr.accept( getCRs );
1:         result.addAll( getCRs.getList() );
1: 
1:         // get all function references
1:         CollectNodesVisitor<StaticMethodCallNode> getSMCNs =
1:             new CollectNodesVisitor<StaticMethodCallNode>(StaticMethodCallNode.class);
1:         expr.accept( getSMCNs );
1:         result.addAll( getSMCNs.getList() );
1: 
1:         // get all FromBaseTables in order to bulk-get their selected columns
1:         CollectNodesVisitor<FromBaseTable> getFBTs =
1:             new CollectNodesVisitor<FromBaseTable>(FromBaseTable.class);
1:         expr.accept( getFBTs );
1:         result.addAll( getFBTs.getList() );
1:     }
1: 
1:     /**
1:      * Add UPDATE_PRIV on all columns on the left side of SET operators.
1:      */
1:     private void    addUpdatePriv( ArrayList<String> explicitlySetColumns )
1:         throws StandardException
1:     {
1:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:         
1:         CompilerContext cc = getCompilerContext();
1: 
1:         cc.pushCurrentPrivType( Authorizer.UPDATE_PRIV );
1:         try {
1:             for ( String columnName : explicitlySetColumns )
1:             {
1:                 ColumnDescriptor    cd = targetTableDescriptor.getColumnDescriptor( columnName );
1:                 cc.addRequiredColumnPriv( cd );
1:             }
1:         }
1:         finally
1:         {
1:             cc.popCurrentPrivType();
1:         }
1:     }
1: 
1:     /**
1:      * Add privilege checks for UDTs referenced by this statement.
1:      */
1: 
1:     
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Trigger transition tables are implemented as VTIs. This short-circuits some
1:         // necessary steps if the source table of a MERGE statement is a trigger
1:         // transition table. The following boolean is meant to prevent that short-circuiting.
1:         //
1:         boolean needBaseColumns = (targetVTI == null) || inMatchingClause();
1:         
1: 		if (!allColumns && needBaseColumns)
/////////////////////////////////////////////////////////////////////////
1: 		if (needBaseColumns)
/////////////////////////////////////////////////////////////////////////
1:         if( null != targetVTI && !inMatchingClause() )
/////////////////////////////////////////////////////////////////////////
1:     } // end of bind()
/////////////////////////////////////////////////////////////////////////
1: 		if ( !deferred && !inMatchingClause() )
/////////////////////////////////////////////////////////////////////////
1:         int lckMode = inMatchingClause() ?
1:             TransactionController.MODE_RECORD : resultSet.updateTargetLockMode();
/////////////////////////////////////////////////////////////////////////
1:         // arg 1
1:         if ( inMatchingClause() )
1:         {
1:             matchingClause.generateResultSetField( acb, mb );
1:         }
1:         else
1:         {
1:             resultSet.generate( acb, mb );
1:         }
1: 
1:         if( null != targetVTI && !inMatchingClause() )
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 			  resultSet.isOneRowResultSet(),
0: 			  inMatchingClause()
commit:508a010
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
1:     UpdateNode
1:         (
1:          TableName targetTableName,
0:          ResultSetNode resultSet,
1:          MatchingClauseNode matchingClause,
1:          ContextManager cm
1:          )
1:         super( resultSet, matchingClause, cm );
/////////////////////////////////////////////////////////////////////////
0: 			if ( !inMatchingClause() ) { column.clearTableName(); }
/////////////////////////////////////////////////////////////////////////
1:             // defaults may already have been substituted for MERGE statements
1:             if ( rc.wasDefaultColumn() ) { continue; }
1:             
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
0:     private     boolean         inMatchedClause;
1: 
/////////////////////////////////////////////////////////////////////////
0:      * @param inMatchedClause   True if this UPDATE is part of a MATCHED ... THEN UPDATE clause of a MERGE statement.
0:                boolean  inMatchedClause,
0:         this.inMatchedClause = inMatchedClause;
/////////////////////////////////////////////////////////////////////////
1:         /*
1:         */
/////////////////////////////////////////////////////////////////////////
1:                 
/////////////////////////////////////////////////////////////////////////
1:              *
0:              * However, we need the table name if this UPDATE is part of a MERGE
0:              * statement. If we clear the table name, then we will not be able to
0:              * resolve which table (target or source) holds the column.
0: 			if ( !inMatchedClause ) { column.clearTableName(); }
1: 
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ConglomerateDescriptor> conglomerates = new ArrayList<ConglomerateDescriptor>();
/////////////////////////////////////////////////////////////////////////
1:         List<ConglomerateDescriptor>     conglomerates,
/////////////////////////////////////////////////////////////////////////
0:         HashSet<String>           updatedColumns = new HashSet<String>();
commit:0397292
/////////////////////////////////////////////////////////////////////////
1: 			generateGenerationClauses( resultColumnList, resultSet.getResultSetNumber(), true, acb, mb );
commit:15b837e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  				/* Get and bind all check constraints and generated columns on the columns
1: 	 			 * being updated.  We want to bind the check constraints and
1: 	 			 * generated columns against
commit:97a8b1c
/////////////////////////////////////////////////////////////////////////
0: 			resultSet.getResultColumns().forbidOverrides(null);
commit:7ae50e9
/////////////////////////////////////////////////////////////////////////
1:         addGeneratedColumnPrecursors( baseTable, affectedGeneratedColumns, columnMap );
/////////////////////////////////////////////////////////////////////////
1:      TableDescriptor         baseTable,
1:      ColumnDescriptorList    affectedGeneratedColumns,
1:      FormatableBitSet        columnMap
/////////////////////////////////////////////////////////////////////////
1:             String[]                       mentionedColumnNames = gc.getDefaultInfo().getReferencedColumnNames();
1:             int[]                       mentionedColumns = baseTable.getColumnIDs( mentionedColumnNames );
/////////////////////////////////////////////////////////////////////////
0:             String[]                       mentionedColumnNames = defaultInfo.getReferencedColumnNames();
0:             int                         mentionedColumnCount = mentionedColumnNames.length;
/////////////////////////////////////////////////////////////////////////
0:                 String                      mentionedColumnName = mentionedColumnNames[ mcIdx ];
commit:d4f9308
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:         int                             count = updateColumnList.size();
0:         HashSet                     updatedColumns = new HashSet();
0: 		for (int ix = 0; ix < count; ix++)
0: 			String      name = ((ResultColumn)updateColumnList.elementAt( ix )).getName();
1: 
0:             updatedColumns.add( name );
/////////////////////////////////////////////////////////////////////////
1:             // handle the case of setting a generated column to the DEFAULT
1:             // literal
1:             if ( updatedColumns.contains( gc.getColumnName() ) ) { affectedGeneratedColumns.add( tableID, gc ); }
1: 
0:                 ColumnDescriptor    mentionedColumn = baseTable.getColumnDescriptor( mentionedColumns[ mcIdx ] );
0:                 String                      mentionedColumnName = mentionedColumn.getColumnName();
0:                 if ( updatedColumns.contains( mentionedColumnName ) )
/////////////////////////////////////////////////////////////////////////
1:                     if ( !updatedColumns.contains( gc.getColumnName() ) )
commit:ca28065
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Add generated columns whose generation clauses mention columns
1:         // in the user's original update list.
1:         //
1:         ColumnDescriptorList    addedGeneratedColumns = new ColumnDescriptorList();
1:         ColumnDescriptorList    affectedGeneratedColumns = new ColumnDescriptorList();
1:         addGeneratedColumns
1:             ( targetTableDescriptor, resultSet, affectedGeneratedColumns, addedGeneratedColumns );
1:         
/////////////////////////////////////////////////////////////////////////
1:         // don't allow overriding of generation clauses
0:         forbidGenerationOverrides( resultSet.getResultColumns(), true, addedGeneratedColumns );
1:         
/////////////////////////////////////////////////////////////////////////
1:                                         afterColumns, affectedGeneratedColumns );
/////////////////////////////////////////////////////////////////////////
1:  			if (hasCheckConstraints(dataDictionary, targetTableDescriptor) || hasGenerationClauses( targetTableDescriptor ) )
/////////////////////////////////////////////////////////////////////////
1: 			ResultColumnList sourceRCL = hasTriggers ? resultColumnList : afterColumns;
1: 
1:             /* bind all generation clauses for generated columns */
1:             parseAndBindGenerationClauses
1:                 ( dataDictionary, targetTableDescriptor, afterColumns, resultColumnList, true, resultSet );
1: 
0:                                                 sourceRCL,
/////////////////////////////////////////////////////////////////////////
1: 			// arg 2 generate code to evaluate generation clauses
0: 			generateGenerationClauses( resultColumnList, resultSet.getResultSetNumber(), acb, mb );
1: 
1:             generateCheckConstraints( checkConstraints, acb, mb ); // arg 3
1:                               ClassName.ResultSet, 5);
1:                               ClassName.ResultSet, 3);
/////////////////////////////////////////////////////////////////////////
1: 	 *		<LI>maintain generated columns</LI>
/////////////////////////////////////////////////////////////////////////
1: 	 * @param affectedGeneratedColumns columns whose generation clauses mention columns being updated
/////////////////////////////////////////////////////////////////////////
1: 		ResultColumnList	updateColumnList,
1:         ColumnDescriptorList    affectedGeneratedColumns
/////////////////////////////////////////////////////////////////////////
1: 		FormatableBitSet	columnMap = getUpdateReadMap
1:             (
0:              baseTable, updateColumnList, conglomVector, relevantCdl,
1:              relevantTriggers, needsDeferredProcessing, affectedGeneratedColumns );
/////////////////////////////////////////////////////////////////////////
1: 	  *	8)	finds all generated columns whose generation clauses mention
1:       *        the updated columns and adds all of the mentioned columns
/////////////////////////////////////////////////////////////////////////
1: 	  *	@param	affectedGeneratedColumns columns whose generation clauses mention updated columns
/////////////////////////////////////////////////////////////////////////
1: 		boolean[]					needsDeferredProcessing,
1:         ColumnDescriptorList    affectedGeneratedColumns
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Add all columns mentioned by generation clauses which are affected
1:         // by the columns being updated.
1:         //
0:         addGeneratedColumnPrecursors( affectedGeneratedColumns, columnMap );
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Add all of the columns mentioned by the generation clauses of generated
1:      * columns. The generated columns were added when we called
1:      * addGeneratedColumns earlier on.
1:      */
1:     private static  void    addGeneratedColumnPrecursors
1: 	(
1:         ColumnDescriptorList    affectedGeneratedColumns,
0: 		FormatableBitSet        columnMap
1: 	)
1: 		throws StandardException
1: 	{
1:         int                                 generatedColumnCount = affectedGeneratedColumns.size();
1:         
1:         for ( int gcIdx = 0; gcIdx < generatedColumnCount; gcIdx++ )
1:         {
1:             ColumnDescriptor    gc = affectedGeneratedColumns.elementAt( gcIdx );
0:             int[]                       mentionedColumns = gc.getDefaultInfo().getReferencedColumnIDs();
1:             int                         mentionedColumnCount = mentionedColumns.length;
1: 
1:             for ( int mcIdx = 0; mcIdx < mentionedColumnCount; mcIdx++ )
1:             {
1:                 columnMap.set( mentionedColumns[ mcIdx ] );
1:                 
1:             }   // done looping through mentioned columns
1:             
1:         }   // done looping through affected generated columns
1: 
1:     }
1:      
1:     /**
1:      * Add generated columns to the update list as necessary. We add
1:      * any column whose generation clause mentions columns already
1:      * in the update list. We fill in a list of all generated columns affected
1:      * by this update. We also fill in a list of all generated columns which we
1:      * added to the update list.
1:      */
1:     private void    addGeneratedColumns
1: 	(
1: 		TableDescriptor				baseTable,
1:         ResultSetNode               updateSet,
1:         ColumnDescriptorList    affectedGeneratedColumns,
1:         ColumnDescriptorList    addedGeneratedColumns
1: 	)
1: 		throws StandardException
1: 	{
0:         ResultColumnList        updateColumnList = updateSet.getResultColumns();
0:         ColumnDescriptorList    generatedColumns = baseTable.getGeneratedColumns();
0:         int                                 generatedColumnCount = generatedColumns.size();
0: 		int		                        columnCount = baseTable.getMaxColumnID();
0: 		FormatableBitSet	        columnMap = new FormatableBitSet(columnCount + 1);
0:         UUID                            tableID = baseTable.getObjectID();
1:         
1: 		int[]	changedColumnIds = updateColumnList.sortMe();
1: 
1: 		for (int ix = 0; ix < changedColumnIds.length; ix++)
1: 		{
1: 			columnMap.set(changedColumnIds[ix]);
1: 		}
1: 
1:         for ( int gcIdx = 0; gcIdx < generatedColumnCount; gcIdx++ )
1:         {
0:             ColumnDescriptor    gc = generatedColumns.elementAt( gcIdx );
0:             DefaultInfo             defaultInfo = gc.getDefaultInfo();
0:             int[]                       mentionedColumns = defaultInfo.getReferencedColumnIDs();
1:             int                         mentionedColumnCount = mentionedColumns.length;
1: 
1:             // figure out if this generated column is affected by the
1:             // update
1:             for ( int mcIdx = 0; mcIdx < mentionedColumnCount; mcIdx++ )
1:             {
0:                 int             mentionedColumnID = mentionedColumns[ mcIdx ];
1: 
0:                 if ( columnMap.isSet( mentionedColumnID ) )
1:                 {
1:                     // Yes, we are updating one of the columns mentioned in
1:                     // this generation clause.
1:                     affectedGeneratedColumns.add( tableID, gc );
1:                     
1:                     // If the generated column isn't in the update list yet,
1:                     // add it.
0:                     if ( !columnMap.isSet( gc.getPosition() ) )
1:                     {
1:                         addedGeneratedColumns.add( tableID, gc );
1:                         
1:                         // we will fill in the real value later on in parseAndBindGenerationClauses();
0:                         ValueNode       dummy = (ValueNode) getNodeFactory().getNode
0:                             ( C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE, getContextManager());
0:                        ResultColumn    newResultColumn = (ResultColumn) getNodeFactory().getNode
0:                             ( C_NodeTypes.RESULT_COLUMN, gc.getType(), dummy, getContextManager());
1:                         newResultColumn.setColumnDescriptor( baseTable, gc );
1:                         newResultColumn.setName( gc.getColumnName() );
1: 
1:                         updateColumnList.addResultColumn( newResultColumn );
1:                     }
1:                     
0:                     break;
1:                 }
1:             }   // done looping through mentioned columns
1: 
1:         }   // done looping through generated columns
1:     }
1:      
1: 
/////////////////////////////////////////////////////////////////////////
1:     
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c44e39a
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator descIter = relevantTriggers.iterator();
0:                     descIter.hasNext(); ) {
0:                 TriggerDescriptor trd = (TriggerDescriptor) descIter.next();
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:860148c
/////////////////////////////////////////////////////////////////////////
0: 			    C_NodeTypes.NORMALIZE_RESULT_SET_NODE, 
0: 			    resultSet, resultColumnList, null, Boolean.TRUE,
1: 			
commit:bfc59e5
/////////////////////////////////////////////////////////////////////////
0: 			resultSet = (NormalizeResultSetNode) getNodeFactory().getNode(
0: 			    C_NodeTypes.NORMALIZE_RESULT_SET_NODE,
0: 			    resultSet, null, Boolean.TRUE,
0: 			    getContextManager());
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:0dfa31c
/////////////////////////////////////////////////////////////////////////
0: 			resultSet = resultSet.genNormalizeResultSetNode(true);
commit:e5bbea4
/////////////////////////////////////////////////////////////////////////
0: 			emptyHeapRow = targetTableDescriptor.getEmptyExecRow();
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
1: 		** source or the normalize result set, the constant action.
/////////////////////////////////////////////////////////////////////////
1:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateVTIResultSet", ClassName.ResultSet, 1);
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
0:                               ClassName.ResultSet, 4);
0:                               ClassName.ResultSet, 2);
commit:7736829
/////////////////////////////////////////////////////////////////////////
commit:5a95e6b
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		// because we verified that the tables match
1: 		// and we already bound the cursor or the select,
1: 		// the table descriptor should always be found.
1: 		verifyTargetTable();
1: 		
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.UpdateNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.impl.sql.execute.FKInfo;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.CheckConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.StatementType;
1: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.vti.DeferModification;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: import java.lang.reflect.Modifier;
0: import java.sql.SQLException;
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * An UpdateNode represents an UPDATE statement.  It is the top node of the
1:  * query tree for that statement.
1:  * For positioned update, there may be no from table specified.
1:  * The from table will be derived from the cursor specification of
1:  * the named cursor.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public final class UpdateNode extends DMLModStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	//Note: These are public so they will be visible to
1: 	//the RepUpdateNode.
0: 	public int[]				changedColumnIds;
0: 	public ExecRow				emptyHeapRow;
0: 	public boolean				deferred;
0: 	public ValueNode			checkConstraints;
0: 	public FKInfo				fkInfo;
1: 	
1: 	protected FromTable			targetTable;
1: 	protected FormatableBitSet 			readColsBitSet;
1: 	protected boolean 			positionedUpdate;
1: 
1: 	/* Column name for the RowLocation in the ResultSet */
0: 	public static final String COLUMNNAME = "###RowLocationToUpdate";
1: 
1: 	/**
0: 	 * Initializer for an UpdateNode.
1: 	 *
1: 	 * @param targetTableName	The name of the table to update
0: 	 * @param resultSet		The ResultSet that will generate
0: 	 *				the rows to update from the given table
1: 	 */
1: 
0: 	public void init(
0: 			   Object targetTableName,
0: 			   Object resultSet)
1: 	{
0: 		super.init(resultSet);
0: 		this.targetTableName = (TableName) targetTableName;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return targetTableName.toString() + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "UPDATE";
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (targetTableName != null)
1: 			{
1: 				printLabel(depth, "targetTableName: ");
1: 				targetTableName.treePrint(depth + 1);
1: 			}
1: 
1: 			/* RESOLVE - need to print out targetTableDescriptor */
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this UpdateNode.  This means looking up tables and columns and
1: 	 * getting their types, and figuring out the result types of all
1: 	 * expressions, as well as doing view resolution, permissions checking,
1: 	 * etc.
1: 	 * <p>
1: 	 * Binding an update will also massage the tree so that
1: 	 * the ResultSetNode has a set of columns to contain the old row
1: 	 * value, followed by a set of columns to contain the new row
1: 	 * value, followed by a column to contain the RowLocation of the
1: 	 * row to be updated.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		FromList	fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 		ResultColumn				rowLocationColumn = null;
0: 		ValueNode		            rowLocationNode = null;
1: 		TableName					cursorTargetTableName = null;
1: 		CurrentOfNode       		currentOfNode = null;
0: 		FromList					resultFromList;
1: 		ResultColumnList			afterColumns = null;
1: 
1: 		DataDictionary dataDictionary = getDataDictionary();
1: 
1: 		bindTables(dataDictionary);
1: 
1: 		// wait to bind named target table until the cursor
1: 		// binding is done, so that we can get it from the
1: 		// cursor if this is a positioned update.
1: 
1: 		// for positioned update, get the cursor's target table.
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT((resultSet!=null && resultSet instanceof SelectNode), 
1: 				"Update must have a select result set");
1: 		}
1: 
1: 		SelectNode sel;
1: 		sel = (SelectNode)resultSet;
1: 		targetTable = (FromTable) sel.fromList.elementAt(0);
1: 		if (targetTable instanceof CurrentOfNode) 
1: 		{	
1: 			positionedUpdate = true;
1: 			currentOfNode = (CurrentOfNode) targetTable;
1: 			cursorTargetTableName = currentOfNode.getBaseCursorTargetTableName();
1: 
1: 			// instead of an assert, we might say the cursor is not updatable.
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(cursorTargetTableName != null);
1: 			}
1: 		}
1: 
1: 		if (targetTable instanceof FromVTI)
1: 		{
1: 			targetVTI = (FromVTI) targetTable;
1: 			targetVTI.setTarget();
1: 		}
1: 		else
1: 		{
1: 			// positioned update can leave off the target table.
1: 			// we get it from the cursor supplying the position.
1: 			if (targetTableName == null)
1: 			{
1: 				// verify we have current of
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(cursorTargetTableName!=null);
1: 
1: 				targetTableName = cursorTargetTableName;
1: 			}
1: 			// for positioned update, we need to verify that
1: 			// the named table is the same as the cursor's target.
1: 			else if (cursorTargetTableName != null)
1: 			{
1: 				// this match requires that the named table in the update
1: 				// be the same as a correlation name in the cursor.
1: 				if ( !targetTableName.equals(cursorTargetTableName))
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_CURSOR_UPDATE_MISMATCH, 
1: 						targetTableName,
1: 						currentOfNode.getCursorName());
1: 				}
1: 			}
1: 
0: 			// because we verified that the tables match
0: 			// and we already bound the cursor or the select,
0: 			// the table descriptor should always be found.
0: 			verifyTargetTable();
1: 		}
1: 
1: 
1: 		/* OVERVIEW - We generate a new ResultColumn, CurrentRowLocation(), and
1: 		 * prepend it to the beginning of the source ResultColumnList.  This
1: 		 * will tell us which row(s) to update at execution time.  However,
1: 		 * we must defer prepending this generated column until the other
1: 		 * ResultColumns are bound since there will be no ColumnDescriptor
1: 		 * for the generated column.  Thus, the sequence of actions is:
1: 		 *
1: 		 *		o  Bind existing ResultColumnList (columns in SET clause)
1: 		 *		o  If this is a positioned update with a FOR UPDATE OF list,
1: 		 *		   then verify that all of the target columns are in the
1: 		 *		   FOR UPDATE OF list.
1: 		 *		o  Get the list of indexes that need to be updated.
1: 		 *		o  Create a ResultColumnList of all the columns in the target
1: 		 *		   table - this represents the old row.
1: 		 *		o  If we don't know which columns are being updated, 
1: 	 	 *		   expand the original ResultColumnList to include all the
1: 		 *		   columns in the target table, and sort it to be in the
1: 		 *		   order of the columns in the target table.  This represents
1: 		 *		   the new row.  Append it to the ResultColumnList representing
1: 		 *		   the old row.
1: 		 *		o  Construct the changedColumnIds array sorted by column position.
1: 		 *		o  Generate the read column bit map and append any columns
1: 		 *		   needed for index maint, etc.
1: 		 *		o  Generate a new ResultColumn for CurrentRowLocation() and 
1: 		 *		   mark it as a generated column.
1: 		 *		o  Append the new ResultColumn to the ResultColumnList
1: 		 *		   (This must be done before binding the expressions, so
1: 		 *		   that the proper type info gets propagated to the new 
1: 		 *		   ResultColumn.)
1: 		 *		o  Bind the expressions.
1: 		 *		o  Bind the generated ResultColumn.
1: 		 */
1: 
1: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(fromList.size() == 0,
1: 				"fromList.size() is expected to be 0, not " + 
1: 				fromList.size() +
1: 				" on return from RS.bindExpressions()");
1: 		}
1: 
1: 		/*
1: 		** The current result column list is the one supplied by the user.
1: 		** Mark these columns as "updated", so we can tell later which
1: 		** columns are really being updated, and which have been added
1: 		** but are not really being updated.
1: 		*/
1: 		resultSet.getResultColumns().markUpdated();
1: 
1: 		/* Prepend CurrentRowLocation() to the select's result column list. */
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT((resultSet.resultColumns != null),	
1: 							  "resultColumns is expected not to be null at bind time");
1: 
1: 		/*
1: 		** Get the result FromTable, which should be the only table in the
1: 	 	** from list.
1: 		*/
0: 		resultFromList = resultSet.getFromList();
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(resultFromList.size() == 1,
0: 			"More than one table in result from list in an update.");
1: 
1: 		/* Bind the original result columns by column name */
0:  		resultSet.bindResultColumns(targetTableDescriptor,
1: 									targetVTI,
0:  									resultSet.resultColumns, this,
0:  									fromList);
1: 
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 		if (lcc.getAutoincrementUpdate() == false)
0: 			resultSet.getResultColumns().checkAutoincrement(null);
1: 
1: 		/*
1: 		** Mark the columns in this UpdateNode's result column list as
1: 		** updateable in the ResultColumnList of the table being updated.
1: 		** only do this for FromBaseTables - if the result table is a
1: 		** CurrentOfNode, it already knows what columns in its cursor
1: 		** are updateable.
1: 		*/
1: 		boolean allColumns = false;
1: 		if (targetTable instanceof FromBaseTable)
1: 		{
1: 			((FromBaseTable) targetTable).markUpdated(
1: 												resultSet.getResultColumns());
1: 		}
0: 		else if (targetTable instanceof FromVTI)
1: 		{
1:             resultColumnList = resultSet.getResultColumns();
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** Positioned update: WHERE CURRENT OF
1: 			*/
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(currentOfNode != null, "currentOfNode is null");
1: 			}
1: 
1: 			ExecPreparedStatement	 cursorStmt = currentOfNode.getCursorStatement();
0: 			String[] ucl = cursorStmt.getUpdateColumns();
1: 
1: 			/*
1: 			** If there is no update column list, we need to build
1: 			** out the result column list to have all columns.
1: 			*/
0: 			if (ucl == null || (ucl.length == 0))
1: 			{
1: 				/*
1: 				** Get the resultColumnList representing ALL of the columns in the 
1: 				** base table.  This is the "before" portion of the result row.
1: 				*/
1: 				getResultColumnList();
1: 
1: 				/*
1: 				** Add the "after" portion of the result row.  This is the update
1: 				** list augmented to include every column in the target table.
1: 				** Those columns that are not being updated are set to themselves.
1: 				** The expanded list will be in the order of the columns in the base
1: 				** table.
1: 				*/
1: 				afterColumns = resultSet.getResultColumns().expandToAll(
1: 													targetTableDescriptor,
1: 													targetTable.getTableName());
1: 	
1: 				/*
1: 				** Need to get all indexes here since we aren't calling
1: 				** getReadMap().
1: 				*/
1: 				getAffectedIndexes(targetTableDescriptor, 
1: 									(ResultColumnList)null, (FormatableBitSet)null); 
1: 				allColumns = true;
1: 			}
1: 			else
1: 			{
1: 				/* Check the updatability */
0: 				resultSet.getResultColumns().checkColumnUpdateability(ucl,
1: 								currentOfNode.getCursorName());
1: 			}
1: 		}
1: 
1: 		changedColumnIds = getChangedColumnIds(resultSet.getResultColumns());
1: 
1: 		/*
1: 		** We need to add in all the columns that are needed
1: 		** by the constraints on this table.  
1: 		*/
0: 		if (!allColumns && targetVTI == null)
1: 		{
1:  			readColsBitSet = new FormatableBitSet();
1: 			FromBaseTable fbt = getResultColumnList(resultSet.getResultColumns());
1: 			afterColumns = resultSet.getResultColumns().copyListAndObjects();
1: 
1: 			readColsBitSet = getReadMap(dataDictionary, 
1: 										targetTableDescriptor, 
0: 										afterColumns);
1: 
1: 			afterColumns = fbt.addColsToList(afterColumns, readColsBitSet);
1: 			resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
1: 
1: 			/*
1: 			** If all bits are set, then behave as if we chose all
1: 			** in the first place
1: 			*/
1: 			int i = 1;
1: 			int size = targetTableDescriptor.getMaxColumnID();
1: 			for (; i <= size; i++)
1: 			{
1: 				if (!readColsBitSet.get(i))
1: 				{
0: 					break;
1: 				}
1: 			}
1: 
1: 			if (i > size)
1: 			{
1: 				readColsBitSet = null;
1: 				allColumns = true;
1: 			}	
1: 		}
1: 
0: 		if (targetVTI == null)
1: 		{
1: 			/*
0: 			** Construct an empty heap row for use in our constant action.
1: 			*/
0: 			emptyHeapRow = targetTableDescriptor.getEmptyExecRow(getContextManager());
1: 
1: 			/* Append the list of "after" columns to the list of "before" columns,
1: 			 * preserving the afterColumns list.  (Necessary for binding
1: 			 * check constraints.)
1: 			 */
1: 			resultColumnList.appendResultColumns(afterColumns, false);
1: 
1: 			/* Generate the RowLocation column */
0: 			rowLocationNode = (CurrentRowLocationNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CURRENT_ROW_LOCATION_NODE,
0: 										getContextManager());
1:         }
1:         else
1:         {
0: 			rowLocationNode = (NumericConstantNode) getNodeFactory().getNode(
0: 										C_NodeTypes.INT_CONSTANT_NODE,
0:                                         ReuseFactory.getInteger( 0),
0: 										getContextManager());
1:         }
1:             
0:         rowLocationColumn =
0:           (ResultColumn) getNodeFactory().getNode(
0:               C_NodeTypes.RESULT_COLUMN,
0:               COLUMNNAME,
0:               rowLocationNode,
0:               getContextManager());
1:         rowLocationColumn.markGenerated();
1: 
0: 			/* Append to the ResultColumnList */
1:         resultColumnList.addResultColumn(rowLocationColumn);
1: 
0: 		/* The last thing that we do to the generated RCL is to clear
0: 		 * the table name out from each RC.  The table name is
1: 		 * unnecessary for an update.  More importantly, though, it
1: 		 * creates a problem in the degenerate case with a positioned
1: 		 * update.  The user must specify the base table name for a
1: 		 * positioned update.  If a correlation name was specified for
1: 		 * the cursor, then a match for the ColumnReference would not
1: 		 * be found if we didn't null out the name.  (Aren't you
1: 		 * glad you asked?)
1: 		 */
0: 		resultColumnList.clearTableNames();
1: 
1: 		/* Set the new result column list in the result set */
1: 		resultSet.setResultColumns(resultColumnList);
1: 
1: 		/* Bind the expressions */
1: 		super.bindExpressions();
1: 
1: 		/* Bind untyped nulls directly under the result columns */
1: 		resultSet.
1: 			getResultColumns().
1: 				bindUntypedNullsToResultColumns(resultColumnList);
1: 
0: 		if (null != rowLocationColumn)
1: 		{
0: 			/* Bind the new ResultColumn */
0: 			rowLocationColumn.bindResultColumnToExpression();
1: 		}
1: 
1: 		resultColumnList.checkStorableExpressions();
1: 
1: 		/* Insert a NormalizeResultSetNode above the source if the source
1: 		 * and target column types and lengths do not match.
1: 		 */
1: 		if (! resultColumnList.columnTypesAndLengthsMatch())
1:  		{
0: 			resultSet = resultSet.genNormalizeResultSetNode(resultSet, true);
0: 			resultColumnList.copyTypesAndLengthsToSource(resultSet.getResultColumns());
1: 								
0:  			if (hasCheckConstraints(dataDictionary, targetTableDescriptor))
1:  			{
0:  				/* Get and bind all check constraints on the columns
0: 	 			 * being updated.  We want to bind the check constraints against
1: 	 			 * the after columns.  We need to bind against the portion of the
1: 	 			 * resultColumns in the new NormalizeResultSet that point to 
1: 	 			 * afterColumns.  Create an RCL composed of just those RCs in
1: 	 			 * order to bind the check constraints.
1: 	 			 */
1: 	 			int afterColumnsSize = afterColumns.size();
0: 	 			afterColumns = (ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
1: 	 			ResultColumnList normalizedRCs = resultSet.getResultColumns();
1: 	 			for (int index = 0; index < afterColumnsSize; index++)
1: 	 			{
1: 	 				afterColumns.addElement(normalizedRCs.elementAt(index + afterColumnsSize));
1: 	 			}
1: 			}
1: 		}
1: 
0:         if( null != targetVTI)
1: 		{
1:             deferred = VTIDeferModPolicy.deferIt( DeferModification.UPDATE_STATEMENT,
1:                                                   targetVTI,
1:                                                   resultColumnList.getColumnNames(),
1:                                                   sel.getWhereClause());
1: 		}
1:         else // not VTI
1:         {
1:             /* we always include triggers in core language */
1:             boolean hasTriggers = (getAllRelevantTriggers(dataDictionary, targetTableDescriptor, 
1:                                                           changedColumnIds, true).size() > 0);
1: 
1:             /* Get and bind all constraints on the columns being updated */
0:             checkConstraints = bindConstraints( dataDictionary,
0:                                                 getNodeFactory(),
1:                                                 targetTableDescriptor,
0:                                                 null,
0:                                                 hasTriggers ? resultColumnList : afterColumns,
0:                                                 changedColumnIds,
0:                                                 readColsBitSet,
1:                                                 false,
0:                                                 true); /* we always include triggers in core language */
1: 
1:             /* If the target table is also a source table, then
1:              * the update will have to be in deferred mode
1:              * For updates, this means that the target table appears in a
1:              * subquery.  Also, self referencing foreign keys are
1:              * deferred.  And triggers cause an update to be deferred.
1:              */
1:             if (resultSet.subqueryReferencesTarget(
1:                 targetTableDescriptor.getName(), true) ||
1:                 requiresDeferredProcessing())
1:             {
1:                 deferred = true;
1:             }
1:         }
1: 
0: 		return this;
0: 	} // end of bind()
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		//If this node references a SESSION schema table, then return true. 
1: 		return(resultSet.referencesSessionSchema());
1: 
1: 	}
1: 
1: 	/**
1: 	 * Compile constants that Execution will use
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 		/*
1: 		** Updates are also deferred if they update a column in the index
1: 		** used to scan the table being updated.
1: 		*/
1: 		if (! deferred )
1: 		{
1: 			ConglomerateDescriptor updateCD =
1: 										targetTable.
1: 											getTrulyTheBestAccessPath().
1: 												getConglomerateDescriptor();
1: 
1: 			if (updateCD != null && updateCD.isIndex())
1: 			{
1: 				int [] baseColumns =
1: 						updateCD.getIndexDescriptor().baseColumnPositions();
1: 
1: 				if (resultSet.
1: 						getResultColumns().
1: 										updateOverlaps(baseColumns))
1: 				{
1: 					deferred = true;
1: 				}
1: 			}
1: 		}
1: 
1:         if( null == targetTableDescriptor)
1: 		{
1: 			/* Return constant action for VTI
1: 			 * NOTE: ConstantAction responsible for preserving instantiated
1: 			 * VTIs for in-memory queries and for only preserving VTIs
1: 			 * that implement Serializable for SPSs.
1: 			 */
1: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.UPDATE_STATEMENT,
1: 						deferred, changedColumnIds);
1: 		}
1: 
0: 		int lockMode = resultSet.updateTargetLockMode();
1: 		long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
1: 		TransactionController tc = 
1: 			getLanguageConnectionContext().getTransactionCompile();
1: 		StaticCompiledOpenConglomInfo[] indexSCOCIs = 
1: 			new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length];
1: 
1: 		for (int index = 0; index < indexSCOCIs.length; index++)
1: 		{
1: 			indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
1: 		}
1: 
1: 		/*
1: 		** Do table locking if the table's lock granularity is
1: 		** set to table.
1: 		*/
1: 		if (targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
1: 		{
0: 			lockMode = TransactionController.MODE_TABLE;
1: 		}
1: 
1: 
1: 		return	getGenericConstantActionFactory().getUpdateConstantAction
0: 			( heapConglomId,
0: 			  targetTableDescriptor.getTableType(),
1: 			  tc.getStaticCompiledConglomInfo(heapConglomId),
1: 			  indicesToMaintain,
1: 			  indexConglomerateNumbers,
1: 			  indexSCOCIs,
1: 			  indexNames,
0: 			  emptyHeapRow,
1: 			  deferred,
1: 			  targetTableDescriptor.getUUID(),
0: 			  lockMode,
1: 			  false,
1: 			  changedColumnIds, null, null, 
1: 			  getFKInfo(),
1: 			  getTriggerInfo(),
1: 			  (readColsBitSet == null) ? (FormatableBitSet)null : new FormatableBitSet(readColsBitSet),
1: 			  getReadColMap(targetTableDescriptor.getNumberOfColumns(),readColsBitSet),
1: 			  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
1: 			  (readColsBitSet == null) ? 
1: 				  targetTableDescriptor.getNumberOfColumns() :
1: 				  readColsBitSet.getNumBitsSet(),			
1: 			  positionedUpdate,
0: 			  resultSet.isOneRowResultSet()
1: 			  );
1: 	}
1: 
1: 	/**
1: 	 * Updates are deferred if they update a column in the index
1: 	 * used to scan the table being updated.
1: 	 */
1: 	protected void setDeferredForUpdateOfIndexColumn()
1: 	{
1: 		/* Don't bother checking if we're already deferred */
1: 		if (! deferred )
1: 		{
1: 			/* Get the conglomerate descriptor for the target table */
1: 			ConglomerateDescriptor updateCD =
1: 										targetTable.
1: 											getTrulyTheBestAccessPath().
1: 												getConglomerateDescriptor();
1: 
1: 			/* If it an index? */
1: 			if (updateCD != null && updateCD.isIndex())
1: 			{
1: 				int [] baseColumns =
1: 						updateCD.getIndexDescriptor().baseColumnPositions();
1: 
1: 				/* Are any of the index columns updated? */
1: 				if (resultSet.
1: 						getResultColumns().
1: 										updateOverlaps(baseColumns))
1: 				{
1: 					deferred = true;
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Code generation for update.
1: 	 * The generated code will contain:
1: 	 *		o  A static member for the (xxx)ResultSet with the RowLocations	and
1: 	 *		   new update values
1: 	 *		o  The static member will be assigned the appropriate ResultSet within
1: 	 *		   the nested calls to get the ResultSets.  (The appropriate cast to the
1: 	 *		   (xxx)ResultSet will be generated.)
1: 	 *		o  The CurrentRowLocation() in SelectNode's select list will generate
1: 	 *		   a new method for returning the RowLocation as well as a call to
1: 	 *		   that method when generating the (xxx)ResultSet.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The method for the execute() method to be built
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
0: 		//If the DML is on the temporary table, generate the code to mark temporary table as modified in the current UOW
0: 		generateCodeForTemporaryTable(acb, mb);
1: 
1: 		/* generate the parameters */
1: 		if(!isDependentTable)
1: 			generateParameterValueSet(acb);
1: 
1: 
1: 		/* Create the static declaration for the scan ResultSet which generates the
1: 		 * RowLocations to be updated
1: 		 * RESOLVE - Need to deal with the type of the static member.
1: 		 */
1: 		acb.newFieldDeclaration(Modifier.PRIVATE, 
1: 								ClassName.CursorResultSet, 
1: 								acb.newRowLocationScanResultSetName());
1: 
1: 		/*
1: 		** Generate the update result set, giving it either the original
0: 		** source or the normalize result set, the constant action,
0: 		** and "this".
1: 		*/
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
0: 		resultSet.generate(acb, mb); // arg 1
1: 
0:         if( null != targetVTI)
1:         {
1: 			targetVTI.assignCostEstimate(resultSet.getNewCostEstimate());
0:             acb.pushThisAsActivation(mb); // arg 2
0:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateVTIResultSet", ClassName.ResultSet, 2);
1: 		}
1:         else
1:         {
1:             // generate code to evaluate CHECK CONSTRAINTS
0:             generateCheckConstraints( checkConstraints, acb, mb ); // arg 2
1: 
0:             acb.pushThisAsActivation(mb);
1: 
1:             if(isDependentTable)
1:             {
1:                 mb.push(acb.addItem(makeConstantAction()));
1:                 mb.push(acb.addItem(makeResultDescription()));
1:                 mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getDeleteCascadeUpdateResultSet",
0:                               ClassName.ResultSet, 5);
1:             }else
1:             {
1:                 mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateResultSet",
0:                               ClassName.ResultSet, 3);
1:             }
1:         }
1: 		/*
0: 		** ensure all parameters have been generated
1: 		*/
1: 		if(!isDependentTable)
0: 			generateParameterHolders(acb);
1: 
1: 	}
1: 
1: 	/**
1: 	 * Return the type of statement, something from
1: 	 * StatementType.
1: 	 *
1: 	 * @return the type of statement
1: 	 */
1: 	protected final int getStatementType()
1: 	{
1: 		return StatementType.UPDATE;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Gets the map of all columns which must be read out of the base table.
1: 	 * These are the columns needed to<UL>:
1: 	 *		<LI>maintain indices</LI>
1: 	 *		<LI>maintain foreign keys</LI>
1: 	 *		<LI>support Replication's Delta Optimization</LI></UL>
1: 	 * <p>
1: 	 * The returned map is a FormatableBitSet with 1 bit for each column in the
1: 	 * table plus an extra, unsued 0-bit. If a 1-based column id must
1: 	 * be read from the base table, then the corresponding 1-based bit
1: 	 * is turned ON in the returned FormatableBitSet.
1: 	 * <p> 
1: 	 * <B>NOTE</B>: this method is not expected to be called when
1: 	 * all columns are being updated (i.e. updateColumnList is null).
1: 	 *
1: 	 * @param dd				the data dictionary to look in
1: 	 * @param baseTable		the base table descriptor
1: 	 * @param updateColumnList the rcl for the update. CANNOT BE NULL
1: 	 *
1: 	 * @return a FormatableBitSet of columns to be read out of the base table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public	FormatableBitSet	getReadMap
1: 	(
1: 		DataDictionary		dd,
1: 		TableDescriptor		baseTable,
0: 		ResultColumnList	updateColumnList
1: 	)
1: 		throws StandardException
1: 	{
1: 		boolean[]	needsDeferredProcessing = new boolean[1];
1: 		needsDeferredProcessing[0] = requiresDeferredProcessing();
1: 
0: 		Vector		conglomVector = new Vector();
1: 		relevantCdl = new ConstraintDescriptorList();
0: 		relevantTriggers =  new GenericDescriptorList();
1: 
0: 		FormatableBitSet	columnMap = UpdateNode.getUpdateReadMap(baseTable,
0: 			updateColumnList, conglomVector, relevantCdl, relevantTriggers, needsDeferredProcessing );
1: 
0: 		markAffectedIndexes( conglomVector );
1: 
1: 		adjustDeferredFlag( needsDeferredProcessing[0] );
1: 
1: 		return	columnMap;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Construct the changedColumnIds array. Note we sort its entries by
1: 	 * columnId.
1: 	 */
1: 	private int[] getChangedColumnIds(ResultColumnList rcl)
1: 	{
1: 		if (rcl == null) { return (int[])null; }
1: 		else { return rcl.sortMe(); }
1: 	}
1:     /**
1: 	  *	Builds a bitmap of all columns which should be read from the
1: 	  *	Store in order to satisfy an UPDATE statement.
1: 	  *
1: 	  *	Is passed a list of updated columns. Does the following:
1: 	  *
1: 	  *	1)	finds all indices which overlap the updated columns
1: 	  *	2)	adds the index columns to a bitmap of affected columns
1: 	  *	3)	adds the index descriptors to a list of conglomerate
1: 	  *		descriptors.
1: 	  *	4)	finds all constraints which overlap the updated columns
1: 	  *		and adds the constrained columns to the bitmap
1: 	  *	5)	finds all triggers which overlap the updated columns.
0: 	  *	6)	if there are any triggers, marks all columns in the bitmap
1: 	  *	7)	adds the triggers to an evolving list of triggers
1: 	  *
1: 	  *	@param	updateColumnList	a list of updated columns
0: 	  *	@param	conglomVector		OUT: vector of affected indices
1: 	  *	@param	relevantConstraints	IN/OUT. Empty list is passed in. We hang constraints on it as we go.
1: 	  *	@param	relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
1: 	  *	@param	needsDeferredProcessing	IN/OUT. true if the statement already needs
1: 	  *									deferred processing. set while evaluating this
1: 	  *									routine if a trigger or constraint requires
1: 	  *									deferred processing
1: 	  *
1: 	  * @return a FormatableBitSet of columns to be read out of the base table
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
0: 	public static FormatableBitSet getUpdateReadMap
1: 	(
1: 		TableDescriptor				baseTable,
1: 		ResultColumnList			updateColumnList,
0: 		Vector						conglomVector,
1: 		ConstraintDescriptorList	relevantConstraints,
0: 		GenericDescriptorList		relevantTriggers,
0: 		boolean[]					needsDeferredProcessing
1: 	)
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(updateColumnList != null, "updateColumnList is null");
1: 		}
1: 
1: 		int		columnCount = baseTable.getMaxColumnID();
1: 		FormatableBitSet	columnMap = new FormatableBitSet(columnCount + 1);
1: 
1: 		/*
1: 		** Add all the changed columns.  We don't strictly
1: 		** need the before image of the changed column in all cases,
1: 		** but it makes life much easier since things are set
1: 		** up around the assumption that we have the before
1: 		** and after image of the column.
1: 		*/
0: 		int[]	changedColumnIds = updateColumnList.sortMe();
1: 
0: 		for (int ix = 0; ix < changedColumnIds.length; ix++)
1: 		{
0: 			columnMap.set(changedColumnIds[ix]);
1: 		}
1: 
1: 		/* 
1: 		** Get a list of the indexes that need to be 
1: 		** updated.  ColumnMap contains all indexed
1: 		** columns where 1 or more columns in the index
1: 		** are going to be modified.
1: 		*/
0: 		DMLModStatementNode.getXAffectedIndexes(baseTable, updateColumnList, columnMap, conglomVector );
1:  
1: 		/* 
1: 		** Add all columns needed for constraints.  We don't
1: 		** need to bother with foreign key/primary key constraints
1: 		** because they are added as a side effect of adding
1: 		** their indexes above.
1: 		*/
0: 		baseTable.getAllRelevantConstraints
0: 			( StatementType.UPDATE, false, changedColumnIds, needsDeferredProcessing, relevantConstraints );
1: 
1: 		int rclSize = relevantConstraints.size();
1: 		for (int index = 0; index < rclSize; index++)
1: 		{
1: 			ConstraintDescriptor cd = relevantConstraints.elementAt(index);
1: 			if (cd.getConstraintType() != DataDictionary.CHECK_CONSTRAINT)
1: 			{
0: 				continue;
1: 			}
1: 
1: 			int[] refColumns = ((CheckConstraintDescriptor)cd).getReferencedColumns();
1: 			for (int i = 0; i < refColumns.length; i++)
1: 			{
1: 				columnMap.set(refColumns[i]);
1: 			}
1: 		}
1: 
1: 		/*
0: 	 	** If we have any triggers, then get all the columns
0: 		** because we don't know what the user will ultimately
0: 		** reference.
1: 	 	*/
1: 
1: 		baseTable.getAllRelevantTriggers( StatementType.UPDATE, changedColumnIds, relevantTriggers );
0: 		if ( relevantTriggers.size() > 0 ) { needsDeferredProcessing[0] = true; }
1: 
1: 		if (relevantTriggers.size() > 0)
1: 		{
0: 			for (int i = 1; i <= columnCount; i++)
1: 			{
0: 				columnMap.set(i);
1: 			}
1: 		}
1: 
1: 		return	columnMap;
1: 	}
1: } // end of UpdateNode
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b6c6e95
/////////////////////////////////////////////////////////////////////////
0: 			{
1: 				this.synonymTableName = targetTableName;
1: 				this.targetTableName  = synonymTab;
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		/* Normalize the SET clause's result column list for synonym */
1: 		if (synonymTableName != null)
0: 			normalizeSynonymColumns( resultSet.resultColumns, targetTable );
0: 		
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Normalize synonym column references to have the name of the base table. 
1: 	 *
1: 	 * @param rcl	    The result column list of the target table
1: 	 * @param fromTable The table name to set the column refs to
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
0: 	 */
1: 	private	void normalizeSynonymColumns(
1:     ResultColumnList    rcl, 
1:     FromTable           fromTable)
1: 		throws StandardException
0: 	{
1: 		if (fromTable.getCorrelationName() != null) 
0:         { 
1:             return; 
0:         }
0: 		
1: 		TableName tableNameNode;
1: 		if (fromTable instanceof CurrentOfNode)
0: 		{ 
1: 			tableNameNode = 
1:                 ((CurrentOfNode) fromTable).getBaseCursorTargetTableName(); 
0: 		}
0: 		else 
0: 		{ 
1: 			tableNameNode = makeTableName(null, fromTable.getBaseTableName()); 
0: 		}
0: 		
1: 		super.normalizeSynonymColumns(rcl, tableNameNode);
0: 	}
0: 	
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 		normalizeCorrelatedColumns( resultSet.resultColumns, targetTable );
/////////////////////////////////////////////////////////////////////////
0: 		/*
1: 		 * The last thing that we do to the generated RCL is to clear
0: 		 * the table name out from each RC. See comment on scrubResultColumns().
0: 		scrubResultColumns( resultColumnList );
/////////////////////////////////////////////////////////////////////////
0: 
0: 	private	void	scrubResultColumns( ResultColumnList rcl )
0: 	{
1: 		/* The table name is
0: 		 * unnecessary for an update.  More importantly, though, it
0: 		 * creates a problem in the degenerate case with a positioned
0: 		 * update.  The user must specify the base table name for a
0: 		 * positioned update.  If a correlation name was specified for
0: 		 * the cursor, then a match for the ColumnReference would not
0: 		 * be found if we didn't null out the name.  (Aren't you
0: 		 * glad you asked?)
0: 		 */
0: 		rcl.clearTableNames();
0: 	}
0: 
0: 	/*
1: 	 * Force correlated column references in the SET clause to have the
1: 	 * name of the base table. This dances around the problem alluded to
1: 	 * in scrubResultColumn().
0: 	 */
1: 	private	void	normalizeCorrelatedColumns( ResultColumnList rcl, FromTable fromTable )
1: 		throws StandardException
0: 	{
1: 		String		correlationName = fromTable.getCorrelationName();
0: 
1: 		if ( correlationName == null ) { return; }
0: 
1: 		TableName	tableNameNode;
0: 
1: 		if ( fromTable instanceof CurrentOfNode )
1: 		{ tableNameNode = ((CurrentOfNode) fromTable).getBaseCursorTargetTableName(); }
1: 		else { tableNameNode = makeTableName( null, fromTable.getBaseTableName() ); }
0: 		
0: 		int			count = rcl.size();
0: 
0: 		for ( int i = 0; i < count; i++ )
0: 		{
0: 			ResultColumn	column = (ResultColumn) rcl.elementAt( i );
1: 			ColumnReference	reference = column.getReference();
0: 
1: 			if ( (reference != null) && correlationName.equals( reference.getTableName() ) )
0: 			{
0: 				reference.setTableNameNode( tableNameNode );
0: 			}
0: 		}
0: 		
0: 	}
0: 	
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:e2cf840
/////////////////////////////////////////////////////////////////////////
1: 		 * the table name out from each RC. See comment on 
1: 		 * checkTableNameAndScrubResultColumns().
1: 		checkTableNameAndScrubResultColumns(resultColumnList);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Check table name and then clear it from the result set columns.
0: 	 * 
1: 	 * @exception StandardExcepion if invalid column/table is specified.
0: 	 */
1: 	private void checkTableNameAndScrubResultColumns(ResultColumnList rcl) 
0: 			throws StandardException
0: 	{
0: 		int columnCount = rcl.size();
0: 		int tableCount = ((SelectNode)resultSet).fromList.size();
0: 
0: 		for ( int i = 0; i < columnCount; i++ )
0: 		{
1: 			boolean foundMatchingTable = false;			
0: 			ResultColumn	column = (ResultColumn) rcl.elementAt( i );
0: 
0: 			if (column.getTableName() != null) {
0: 				for (int j = 0; j < tableCount; j++) {
0: 					FromTable fromTable = (FromTable) ((SelectNode)resultSet).
0: 							fromList.elementAt(j);
1: 					final String tableName;
1: 					if ( fromTable instanceof CurrentOfNode ) { 
1: 						tableName = ((CurrentOfNode)fromTable).
1: 								getBaseCursorTargetTableName().getTableName();
0: 					} else { 
1: 						tableName = fromTable.getBaseTableName();
0: 					}
0: 
1: 					if (column.getTableName().equals(tableName)) {
1: 						foundMatchingTable = true;
0: 						break;
0: 					}
0: 				}
0: 
1: 				if (!foundMatchingTable) {
1: 					throw StandardException.newException(
1: 							SQLState.LANG_COLUMN_NOT_FOUND, 
1: 							column.getTableName() + "." + column.getName());
0: 				}
0: 			}
0: 
0: 			/* The table name is
0: 			 * unnecessary for an update.  More importantly, though, it
0: 			 * creates a problem in the degenerate case with a positioned
0: 			 * update.  The user must specify the base table name for a
0: 			 * positioned update.  If a correlation name was specified for
0: 			 * the cursor, then a match for the ColumnReference would not
0: 			 * be found if we didn't null out the name.  (Aren't you
0: 			 * glad you asked?)
0: 			 */
0: 			column.clearTableName();
0: 		}
0: 	}
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1: 		// We just need select privilege on the expressions
1: 		getCompilerContext().pushCurrentPrivType( Authorizer.SELECT_PRIV);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 		getCompilerContext().pushCurrentPrivType(getPrivType()); // Update privilege
0: 		resultSet.bindResultColumns(targetTableDescriptor,
0: 					targetVTI,
0: 					resultSet.resultColumns, this,
0: 					fromList);
1: 		getCompilerContext().popCurrentPrivType();
/////////////////////////////////////////////////////////////////////////
1: 			getCompilerContext().pushCurrentPrivType( Authorizer.NULL_PRIV);
1: 			try
0: 			{
0: 				readColsBitSet = new FormatableBitSet();
0: 				FromBaseTable fbt = getResultColumnList(resultSet.getResultColumns());
0: 				afterColumns = resultSet.getResultColumns().copyListAndObjects();
0: 				readColsBitSet = getReadMap(dataDictionary, 
0: 				afterColumns = fbt.addColsToList(afterColumns, readColsBitSet);
0: 				resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
0: 				/*
0: 				** If all bits are set, then behave as if we chose all
0: 				** in the first place
0: 				*/
0: 				int i = 1;
0: 				int size = targetTableDescriptor.getMaxColumnID();
0: 				for (; i <= size; i++)
0: 					if (!readColsBitSet.get(i))
0: 					{
0: 						break;
0: 					}
0: 				if (i > size)
0: 				{
0: 					readColsBitSet = null;
0: 					allColumns = true;
0: 				}	
0: 			}
1: 			finally
0: 				getCompilerContext().popCurrentPrivType();
0: 			}
/////////////////////////////////////////////////////////////////////////
0: 		getCompilerContext().pushCurrentPrivType(getPrivType()); // Update privilege
0: 		getCompilerContext().popCurrentPrivType();
/////////////////////////////////////////////////////////////////////////
0: 		getCompilerContext().popCurrentPrivType();		
0: 
1: 	int getPrivType()
0: 	{
1: 		return Authorizer.UPDATE_PRIV;
0: 	}
0: 
commit:b47c239
/////////////////////////////////////////////////////////////////////////
1: 		if (targetTableName != null)
0: 		{
1: 			TableName synonymTab = resolveTableToSynonym(this.targetTableName);
1: 			if (synonymTab != null)
0: 				this.targetTableName = synonymTab;
0: 		}
commit:582425f
/////////////////////////////////////////////////////////////////////////
1: 		// check if targetTable is a synonym
0: 		TableName synonymTab = resolveTableToSynonym(this.targetTableName);
0: 		if (synonymTab != null)
0: 			this.targetTableName = synonymTab;
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.impl.sql.execute.FKInfo;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.CheckConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.StatementType;
0: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.vti.DeferModification;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.lang.reflect.Modifier;
0: import java.sql.SQLException;
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * An UpdateNode represents an UPDATE statement.  It is the top node of the
0:  * query tree for that statement.
0:  * For positioned update, there may be no from table specified.
0:  * The from table will be derived from the cursor specification of
0:  * the named cursor.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public final class UpdateNode extends DMLModStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	//Note: These are public so they will be visible to
0: 	//the RepUpdateNode.
0: 	public int[]				changedColumnIds;
0: 	public ExecRow				emptyHeapRow;
0: 	public boolean				deferred;
0: 	public ValueNode			checkConstraints;
0: 	public FKInfo				fkInfo;
0: 	
0: 	protected FromTable			targetTable;
0: 	protected FormatableBitSet 			readColsBitSet;
0: 	protected boolean 			positionedUpdate;
0: 
0: 	/* Column name for the RowLocation in the ResultSet */
0: 	public static final String COLUMNNAME = "###RowLocationToUpdate";
0: 
0: 	/**
0: 	 * Initializer for an UpdateNode.
0: 	 *
0: 	 * @param targetTableName	The name of the table to update
0: 	 * @param resultSet		The ResultSet that will generate
0: 	 *				the rows to update from the given table
0: 	 */
0: 
0: 	public void init(
0: 			   Object targetTableName,
0: 			   Object resultSet)
0: 	{
0: 		super.init(resultSet);
0: 		this.targetTableName = (TableName) targetTableName;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return targetTableName.toString() + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "UPDATE";
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (targetTableName != null)
0: 			{
0: 				printLabel(depth, "targetTableName: ");
0: 				targetTableName.treePrint(depth + 1);
0: 			}
0: 
0: 			/* RESOLVE - need to print out targetTableDescriptor */
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this UpdateNode.  This means looking up tables and columns and
0: 	 * getting their types, and figuring out the result types of all
0: 	 * expressions, as well as doing view resolution, permissions checking,
0: 	 * etc.
0: 	 * <p>
0: 	 * Binding an update will also massage the tree so that
0: 	 * the ResultSetNode has a set of columns to contain the old row
0: 	 * value, followed by a set of columns to contain the new row
0: 	 * value, followed by a column to contain the RowLocation of the
0: 	 * row to be updated.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		FromList	fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 		ResultColumn				rowLocationColumn = null;
0: 		ValueNode		            rowLocationNode = null;
0: 		TableName					cursorTargetTableName = null;
0: 		CurrentOfNode       		currentOfNode = null;
0: 		FromList					resultFromList;
0: 		ResultColumnList			afterColumns = null;
0: 
0: 		DataDictionary dataDictionary = getDataDictionary();
0: 
0: 		bindTables(dataDictionary);
0: 
0: 		// wait to bind named target table until the cursor
0: 		// binding is done, so that we can get it from the
0: 		// cursor if this is a positioned update.
0: 
0: 		// for positioned update, get the cursor's target table.
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT((resultSet!=null && resultSet instanceof SelectNode), 
0: 				"Update must have a select result set");
0: 		}
0: 
0: 		SelectNode sel;
0: 		sel = (SelectNode)resultSet;
0: 		targetTable = (FromTable) sel.fromList.elementAt(0);
0: 		if (targetTable instanceof CurrentOfNode) 
0: 		{	
0: 			positionedUpdate = true;
0: 			currentOfNode = (CurrentOfNode) targetTable;
0: 			cursorTargetTableName = currentOfNode.getBaseCursorTargetTableName();
0: 
0: 			// instead of an assert, we might say the cursor is not updatable.
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(cursorTargetTableName != null);
0: 			}
0: 		}
0: 
0: 		if (targetTable instanceof FromVTI)
0: 		{
0: 			targetVTI = (FromVTI) targetTable;
0: 			targetVTI.setTarget();
0: 		}
0: 		else
0: 		{
0: 			// positioned update can leave off the target table.
0: 			// we get it from the cursor supplying the position.
0: 			if (targetTableName == null)
0: 			{
0: 				// verify we have current of
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(cursorTargetTableName!=null);
0: 
0: 				targetTableName = cursorTargetTableName;
0: 			}
0: 			// for positioned update, we need to verify that
0: 			// the named table is the same as the cursor's target.
0: 			else if (cursorTargetTableName != null)
0: 			{
0: 				// this match requires that the named table in the update
0: 				// be the same as a correlation name in the cursor.
0: 				if ( !targetTableName.equals(cursorTargetTableName))
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_CURSOR_UPDATE_MISMATCH, 
0: 						targetTableName,
0: 						currentOfNode.getCursorName());
0: 				}
0: 			}
0: 
0: 			// because we verified that the tables match
0: 			// and we already bound the cursor or the select,
0: 			// the table descriptor should always be found.
0: 			verifyTargetTable();
0: 		}
0: 
0: 
0: 		/* OVERVIEW - We generate a new ResultColumn, CurrentRowLocation(), and
0: 		 * prepend it to the beginning of the source ResultColumnList.  This
0: 		 * will tell us which row(s) to update at execution time.  However,
0: 		 * we must defer prepending this generated column until the other
0: 		 * ResultColumns are bound since there will be no ColumnDescriptor
0: 		 * for the generated column.  Thus, the sequence of actions is:
0: 		 *
0: 		 *		o  Bind existing ResultColumnList (columns in SET clause)
0: 		 *		o  If this is a positioned update with a FOR UPDATE OF list,
0: 		 *		   then verify that all of the target columns are in the
0: 		 *		   FOR UPDATE OF list.
0: 		 *		o  Get the list of indexes that need to be updated.
0: 		 *		o  Create a ResultColumnList of all the columns in the target
0: 		 *		   table - this represents the old row.
0: 		 *		o  If we don't know which columns are being updated, 
0: 	 	 *		   expand the original ResultColumnList to include all the
0: 		 *		   columns in the target table, and sort it to be in the
0: 		 *		   order of the columns in the target table.  This represents
0: 		 *		   the new row.  Append it to the ResultColumnList representing
0: 		 *		   the old row.
0: 		 *		o  Construct the changedColumnIds array sorted by column position.
0: 		 *		o  Generate the read column bit map and append any columns
0: 		 *		   needed for index maint, etc.
0: 		 *		o  Generate a new ResultColumn for CurrentRowLocation() and 
0: 		 *		   mark it as a generated column.
0: 		 *		o  Append the new ResultColumn to the ResultColumnList
0: 		 *		   (This must be done before binding the expressions, so
0: 		 *		   that the proper type info gets propagated to the new 
0: 		 *		   ResultColumn.)
0: 		 *		o  Bind the expressions.
0: 		 *		o  Bind the generated ResultColumn.
0: 		 */
0: 
0: 		/* Verify that all underlying ResultSets reclaimed their FromList */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(fromList.size() == 0,
0: 				"fromList.size() is expected to be 0, not " + 
0: 				fromList.size() +
0: 				" on return from RS.bindExpressions()");
0: 		}
0: 
0: 		/*
0: 		** The current result column list is the one supplied by the user.
0: 		** Mark these columns as "updated", so we can tell later which
0: 		** columns are really being updated, and which have been added
0: 		** but are not really being updated.
0: 		*/
0: 		resultSet.getResultColumns().markUpdated();
0: 
0: 		/* Prepend CurrentRowLocation() to the select's result column list. */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT((resultSet.resultColumns != null),	
0: 							  "resultColumns is expected not to be null at bind time");
0: 
0: 		/*
0: 		** Get the result FromTable, which should be the only table in the
0: 	 	** from list.
0: 		*/
0: 		resultFromList = resultSet.getFromList();
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(resultFromList.size() == 1,
0: 			"More than one table in result from list in an update.");
0: 
0: 		/* Bind the original result columns by column name */
0:  		resultSet.bindResultColumns(targetTableDescriptor,
0: 									targetVTI,
0:  									resultSet.resultColumns, this,
0:  									fromList);
0: 
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 		if (lcc.getAutoincrementUpdate() == false)
0: 			resultSet.getResultColumns().checkAutoincrement(null);
0: 
0: 		/*
0: 		** Mark the columns in this UpdateNode's result column list as
0: 		** updateable in the ResultColumnList of the table being updated.
0: 		** only do this for FromBaseTables - if the result table is a
0: 		** CurrentOfNode, it already knows what columns in its cursor
0: 		** are updateable.
0: 		*/
0: 		boolean allColumns = false;
0: 		if (targetTable instanceof FromBaseTable)
0: 		{
0: 			((FromBaseTable) targetTable).markUpdated(
0: 												resultSet.getResultColumns());
0: 		}
0: 		else if (targetTable instanceof FromVTI)
0: 		{
0:             resultColumnList = resultSet.getResultColumns();
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** Positioned update: WHERE CURRENT OF
0: 			*/
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(currentOfNode != null, "currentOfNode is null");
0: 			}
0: 
0: 			ExecPreparedStatement	 cursorStmt = currentOfNode.getCursorStatement();
0: 			String[] ucl = cursorStmt.getUpdateColumns();
0: 
0: 			/*
0: 			** If there is no update column list, we need to build
0: 			** out the result column list to have all columns.
0: 			*/
0: 			if (ucl == null || (ucl.length == 0))
0: 			{
0: 				/*
0: 				** Get the resultColumnList representing ALL of the columns in the 
0: 				** base table.  This is the "before" portion of the result row.
0: 				*/
0: 				getResultColumnList();
0: 
0: 				/*
0: 				** Add the "after" portion of the result row.  This is the update
0: 				** list augmented to include every column in the target table.
0: 				** Those columns that are not being updated are set to themselves.
0: 				** The expanded list will be in the order of the columns in the base
0: 				** table.
0: 				*/
0: 				afterColumns = resultSet.getResultColumns().expandToAll(
0: 													targetTableDescriptor,
0: 													targetTable.getTableName());
0: 	
0: 				/*
0: 				** Need to get all indexes here since we aren't calling
0: 				** getReadMap().
0: 				*/
0: 				getAffectedIndexes(targetTableDescriptor, 
0: 									(ResultColumnList)null, (FormatableBitSet)null); 
0: 				allColumns = true;
0: 			}
0: 			else
0: 			{
0: 				/* Check the updatability */
0: 				resultSet.getResultColumns().checkColumnUpdateability(ucl,
0: 								currentOfNode.getCursorName());
0: 			}
0: 		}
0: 
0: 		changedColumnIds = getChangedColumnIds(resultSet.getResultColumns());
0: 
0: 		/*
0: 		** We need to add in all the columns that are needed
0: 		** by the constraints on this table.  
0: 		*/
0: 		if (!allColumns && targetVTI == null)
0: 		{
0:  			readColsBitSet = new FormatableBitSet();
0: 			FromBaseTable fbt = getResultColumnList(resultSet.getResultColumns());
0: 			afterColumns = resultSet.getResultColumns().copyListAndObjects();
0: 
0: 			readColsBitSet = getReadMap(dataDictionary, 
0: 										targetTableDescriptor, 
0: 										afterColumns);
0: 
0: 			afterColumns = fbt.addColsToList(afterColumns, readColsBitSet);
0: 			resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
0: 
0: 			/*
0: 			** If all bits are set, then behave as if we chose all
0: 			** in the first place
0: 			*/
0: 			int i = 1;
0: 			int size = targetTableDescriptor.getMaxColumnID();
0: 			for (; i <= size; i++)
0: 			{
0: 				if (!readColsBitSet.get(i))
0: 				{
0: 					break;
0: 				}
0: 			}
0: 
0: 			if (i > size)
0: 			{
0: 				readColsBitSet = null;
0: 				allColumns = true;
0: 			}	
0: 		}
0: 
0: 		if (targetVTI == null)
0: 		{
0: 			/*
0: 			** Construct an empty heap row for use in our constant action.
0: 			*/
0: 			emptyHeapRow = targetTableDescriptor.getEmptyExecRow(getContextManager());
0: 
0: 			/* Append the list of "after" columns to the list of "before" columns,
0: 			 * preserving the afterColumns list.  (Necessary for binding
0: 			 * check constraints.)
0: 			 */
0: 			resultColumnList.appendResultColumns(afterColumns, false);
0: 
0: 			/* Generate the RowLocation column */
0: 			rowLocationNode = (CurrentRowLocationNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CURRENT_ROW_LOCATION_NODE,
0: 										getContextManager());
0:         }
0:         else
0:         {
0: 			rowLocationNode = (NumericConstantNode) getNodeFactory().getNode(
0: 										C_NodeTypes.INT_CONSTANT_NODE,
0:                                         ReuseFactory.getInteger( 0),
0: 										getContextManager());
0:         }
0:             
0:         rowLocationColumn =
0:           (ResultColumn) getNodeFactory().getNode(
0:               C_NodeTypes.RESULT_COLUMN,
0:               COLUMNNAME,
0:               rowLocationNode,
0:               getContextManager());
0:         rowLocationColumn.markGenerated();
0: 
0: 			/* Append to the ResultColumnList */
0:         resultColumnList.addResultColumn(rowLocationColumn);
0: 
0: 		/* The last thing that we do to the generated RCL is to clear
0: 		 * the table name out from each RC.  The table name is
0: 		 * unnecessary for an update.  More importantly, though, it
0: 		 * creates a problem in the degenerate case with a positioned
0: 		 * update.  The user must specify the base table name for a
0: 		 * positioned update.  If a correlation name was specified for
0: 		 * the cursor, then a match for the ColumnReference would not
0: 		 * be found if we didn't null out the name.  (Aren't you
0: 		 * glad you asked?)
0: 		 */
0: 		resultColumnList.clearTableNames();
0: 
0: 		/* Set the new result column list in the result set */
0: 		resultSet.setResultColumns(resultColumnList);
0: 
0: 		/* Bind the expressions */
0: 		super.bindExpressions();
0: 
0: 		/* Bind untyped nulls directly under the result columns */
0: 		resultSet.
0: 			getResultColumns().
0: 				bindUntypedNullsToResultColumns(resultColumnList);
0: 
0: 		if (null != rowLocationColumn)
0: 		{
0: 			/* Bind the new ResultColumn */
0: 			rowLocationColumn.bindResultColumnToExpression();
0: 		}
0: 
0: 		resultColumnList.checkStorableExpressions();
0: 
0: 		/* Insert a NormalizeResultSetNode above the source if the source
0: 		 * and target column types and lengths do not match.
0: 		 */
0: 		if (! resultColumnList.columnTypesAndLengthsMatch())
0:  		{
0: 			resultSet = resultSet.genNormalizeResultSetNode(resultSet, true);
0: 			resultColumnList.copyTypesAndLengthsToSource(resultSet.getResultColumns());
0: 								
0:  			if (hasCheckConstraints(dataDictionary, targetTableDescriptor))
0:  			{
0:  				/* Get and bind all check constraints on the columns
0: 	 			 * being updated.  We want to bind the check constraints against
0: 	 			 * the after columns.  We need to bind against the portion of the
0: 	 			 * resultColumns in the new NormalizeResultSet that point to 
0: 	 			 * afterColumns.  Create an RCL composed of just those RCs in
0: 	 			 * order to bind the check constraints.
0: 	 			 */
0: 	 			int afterColumnsSize = afterColumns.size();
0: 	 			afterColumns = (ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 	 			ResultColumnList normalizedRCs = resultSet.getResultColumns();
0: 	 			for (int index = 0; index < afterColumnsSize; index++)
0: 	 			{
0: 	 				afterColumns.addElement(normalizedRCs.elementAt(index + afterColumnsSize));
0: 	 			}
0: 			}
0: 		}
0: 
0:         if( null != targetVTI)
0: 		{
0:             deferred = VTIDeferModPolicy.deferIt( DeferModification.UPDATE_STATEMENT,
0:                                                   targetVTI,
0:                                                   resultColumnList.getColumnNames(),
0:                                                   sel.getWhereClause());
0: 		}
0:         else // not VTI
0:         {
0:             /* we always include triggers in core language */
0:             boolean hasTriggers = (getAllRelevantTriggers(dataDictionary, targetTableDescriptor, 
0:                                                           changedColumnIds, true).size() > 0);
0: 
0:             /* Get and bind all constraints on the columns being updated */
0:             checkConstraints = bindConstraints( dataDictionary,
0:                                                 getNodeFactory(),
0:                                                 targetTableDescriptor,
0:                                                 null,
0:                                                 hasTriggers ? resultColumnList : afterColumns,
0:                                                 changedColumnIds,
0:                                                 readColsBitSet,
0:                                                 false,
0:                                                 true); /* we always include triggers in core language */
0: 
0:             /* If the target table is also a source table, then
0:              * the update will have to be in deferred mode
0:              * For updates, this means that the target table appears in a
0:              * subquery.  Also, self referencing foreign keys are
0:              * deferred.  And triggers cause an update to be deferred.
0:              */
0:             if (resultSet.subqueryReferencesTarget(
0:                 targetTableDescriptor.getName(), true) ||
0:                 requiresDeferredProcessing())
0:             {
0:                 deferred = true;
0:             }
0:         }
0: 
0: 		return this;
0: 	} // end of bind()
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		//If this node references a SESSION schema table, then return true. 
0: 		return(resultSet.referencesSessionSchema());
0: 
0: 	}
0: 
0: 	/**
0: 	 * Compile constants that Execution will use
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 		/*
0: 		** Updates are also deferred if they update a column in the index
0: 		** used to scan the table being updated.
0: 		*/
0: 		if (! deferred )
0: 		{
0: 			ConglomerateDescriptor updateCD =
0: 										targetTable.
0: 											getTrulyTheBestAccessPath().
0: 												getConglomerateDescriptor();
0: 
0: 			if (updateCD != null && updateCD.isIndex())
0: 			{
0: 				int [] baseColumns =
0: 						updateCD.getIndexDescriptor().baseColumnPositions();
0: 
0: 				if (resultSet.
0: 						getResultColumns().
0: 										updateOverlaps(baseColumns))
0: 				{
0: 					deferred = true;
0: 				}
0: 			}
0: 		}
0: 
0:         if( null == targetTableDescriptor)
0: 		{
0: 			/* Return constant action for VTI
0: 			 * NOTE: ConstantAction responsible for preserving instantiated
0: 			 * VTIs for in-memory queries and for only preserving VTIs
0: 			 * that implement Serializable for SPSs.
0: 			 */
0: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.UPDATE_STATEMENT,
0: 						deferred, changedColumnIds);
0: 		}
0: 
0: 		int lockMode = resultSet.updateTargetLockMode();
0: 		long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
0: 		TransactionController tc = 
0: 			getLanguageConnectionContext().getTransactionCompile();
0: 		StaticCompiledOpenConglomInfo[] indexSCOCIs = 
0: 			new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length];
0: 
0: 		for (int index = 0; index < indexSCOCIs.length; index++)
0: 		{
0: 			indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
0: 		}
0: 
0: 		/*
0: 		** Do table locking if the table's lock granularity is
0: 		** set to table.
0: 		*/
0: 		if (targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
0: 		{
0: 			lockMode = TransactionController.MODE_TABLE;
0: 		}
0: 
0: 
0: 		return	getGenericConstantActionFactory().getUpdateConstantAction
0: 			( heapConglomId,
0: 			  targetTableDescriptor.getTableType(),
0: 			  tc.getStaticCompiledConglomInfo(heapConglomId),
0: 			  indicesToMaintain,
0: 			  indexConglomerateNumbers,
0: 			  indexSCOCIs,
0: 			  indexNames,
0: 			  emptyHeapRow,
0: 			  deferred,
0: 			  targetTableDescriptor.getUUID(),
0: 			  lockMode,
0: 			  false,
0: 			  changedColumnIds, null, null, 
0: 			  getFKInfo(),
0: 			  getTriggerInfo(),
0: 			  (readColsBitSet == null) ? (FormatableBitSet)null : new FormatableBitSet(readColsBitSet),
0: 			  getReadColMap(targetTableDescriptor.getNumberOfColumns(),readColsBitSet),
0: 			  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
0: 			  (readColsBitSet == null) ? 
0: 				  targetTableDescriptor.getNumberOfColumns() :
0: 				  readColsBitSet.getNumBitsSet(),			
0: 			  positionedUpdate,
0: 			  resultSet.isOneRowResultSet()
0: 			  );
0: 	}
0: 
0: 	/**
0: 	 * Updates are deferred if they update a column in the index
0: 	 * used to scan the table being updated.
0: 	 */
0: 	protected void setDeferredForUpdateOfIndexColumn()
0: 	{
0: 		/* Don't bother checking if we're already deferred */
0: 		if (! deferred )
0: 		{
0: 			/* Get the conglomerate descriptor for the target table */
0: 			ConglomerateDescriptor updateCD =
0: 										targetTable.
0: 											getTrulyTheBestAccessPath().
0: 												getConglomerateDescriptor();
0: 
0: 			/* If it an index? */
0: 			if (updateCD != null && updateCD.isIndex())
0: 			{
0: 				int [] baseColumns =
0: 						updateCD.getIndexDescriptor().baseColumnPositions();
0: 
0: 				/* Are any of the index columns updated? */
0: 				if (resultSet.
0: 						getResultColumns().
0: 										updateOverlaps(baseColumns))
0: 				{
0: 					deferred = true;
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Code generation for update.
0: 	 * The generated code will contain:
0: 	 *		o  A static member for the (xxx)ResultSet with the RowLocations	and
0: 	 *		   new update values
0: 	 *		o  The static member will be assigned the appropriate ResultSet within
0: 	 *		   the nested calls to get the ResultSets.  (The appropriate cast to the
0: 	 *		   (xxx)ResultSet will be generated.)
0: 	 *		o  The CurrentRowLocation() in SelectNode's select list will generate
0: 	 *		   a new method for returning the RowLocation as well as a call to
0: 	 *		   that method when generating the (xxx)ResultSet.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The method for the execute() method to be built
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		//If the DML is on the temporary table, generate the code to mark temporary table as modified in the current UOW
0: 		generateCodeForTemporaryTable(acb, mb);
0: 
0: 		/* generate the parameters */
0: 		if(!isDependentTable)
0: 			generateParameterValueSet(acb);
0: 
0: 
0: 		/* Create the static declaration for the scan ResultSet which generates the
0: 		 * RowLocations to be updated
0: 		 * RESOLVE - Need to deal with the type of the static member.
0: 		 */
0: 		acb.newFieldDeclaration(Modifier.PRIVATE, 
0: 								ClassName.CursorResultSet, 
0: 								acb.newRowLocationScanResultSetName());
0: 
0: 		/*
0: 		** Generate the update result set, giving it either the original
0: 		** source or the normalize result set, the constant action,
0: 		** and "this".
0: 		*/
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 		resultSet.generate(acb, mb); // arg 1
0: 
0:         if( null != targetVTI)
0:         {
0: 			targetVTI.assignCostEstimate(resultSet.getNewCostEstimate());
0:             acb.pushThisAsActivation(mb); // arg 2
0:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateVTIResultSet", ClassName.ResultSet, 2);
0: 		}
0:         else
0:         {
0:             // generate code to evaluate CHECK CONSTRAINTS
0:             generateCheckConstraints( checkConstraints, acb, mb ); // arg 2
0: 
0:             acb.pushThisAsActivation(mb);
0: 
0:             if(isDependentTable)
0:             {
0:                 mb.push(acb.addItem(makeConstantAction()));
0:                 mb.push(acb.addItem(makeResultDescription()));
0:                 mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getDeleteCascadeUpdateResultSet",
0:                               ClassName.ResultSet, 5);
0:             }else
0:             {
0:                 mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUpdateResultSet",
0:                               ClassName.ResultSet, 3);
0:             }
0:         }
0: 		/*
0: 		** ensure all parameters have been generated
0: 		*/
0: 		if(!isDependentTable)
0: 			generateParameterHolders(acb);
0: 
0: 	}
0: 
0: 	/**
0: 	 * Return the type of statement, something from
0: 	 * StatementType.
0: 	 *
0: 	 * @return the type of statement
0: 	 */
0: 	protected final int getStatementType()
0: 	{
0: 		return StatementType.UPDATE;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Gets the map of all columns which must be read out of the base table.
0: 	 * These are the columns needed to<UL>:
0: 	 *		<LI>maintain indices</LI>
0: 	 *		<LI>maintain foreign keys</LI>
0: 	 *		<LI>support Replication's Delta Optimization</LI></UL>
0: 	 * <p>
0: 	 * The returned map is a FormatableBitSet with 1 bit for each column in the
0: 	 * table plus an extra, unsued 0-bit. If a 1-based column id must
0: 	 * be read from the base table, then the corresponding 1-based bit
0: 	 * is turned ON in the returned FormatableBitSet.
0: 	 * <p> 
0: 	 * <B>NOTE</B>: this method is not expected to be called when
0: 	 * all columns are being updated (i.e. updateColumnList is null).
0: 	 *
0: 	 * @param dd				the data dictionary to look in
0: 	 * @param baseTable		the base table descriptor
0: 	 * @param updateColumnList the rcl for the update. CANNOT BE NULL
0: 	 *
0: 	 * @return a FormatableBitSet of columns to be read out of the base table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public	FormatableBitSet	getReadMap
0: 	(
0: 		DataDictionary		dd,
0: 		TableDescriptor		baseTable,
0: 		ResultColumnList	updateColumnList
0: 	)
0: 		throws StandardException
0: 	{
0: 		boolean[]	needsDeferredProcessing = new boolean[1];
0: 		needsDeferredProcessing[0] = requiresDeferredProcessing();
0: 
0: 		Vector		conglomVector = new Vector();
0: 		relevantCdl = new ConstraintDescriptorList();
0: 		relevantTriggers =  new GenericDescriptorList();
0: 
0: 		FormatableBitSet	columnMap = UpdateNode.getUpdateReadMap(baseTable,
0: 			updateColumnList, conglomVector, relevantCdl, relevantTriggers, needsDeferredProcessing );
0: 
0: 		markAffectedIndexes( conglomVector );
0: 
0: 		adjustDeferredFlag( needsDeferredProcessing[0] );
0: 
0: 		return	columnMap;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Construct the changedColumnIds array. Note we sort its entries by
0: 	 * columnId.
0: 	 */
0: 	private int[] getChangedColumnIds(ResultColumnList rcl)
0: 	{
0: 		if (rcl == null) { return (int[])null; }
0: 		else { return rcl.sortMe(); }
0: 	}
0:     /**
0: 	  *	Builds a bitmap of all columns which should be read from the
0: 	  *	Store in order to satisfy an UPDATE statement.
0: 	  *
0: 	  *	Is passed a list of updated columns. Does the following:
0: 	  *
0: 	  *	1)	finds all indices which overlap the updated columns
0: 	  *	2)	adds the index columns to a bitmap of affected columns
0: 	  *	3)	adds the index descriptors to a list of conglomerate
0: 	  *		descriptors.
0: 	  *	4)	finds all constraints which overlap the updated columns
0: 	  *		and adds the constrained columns to the bitmap
0: 	  *	5)	finds all triggers which overlap the updated columns.
0: 	  *	6)	if there are any triggers, marks all columns in the bitmap
0: 	  *	7)	adds the triggers to an evolving list of triggers
0: 	  *
0: 	  *	@param	updateColumnList	a list of updated columns
0: 	  *	@param	conglomVector		OUT: vector of affected indices
0: 	  *	@param	relevantConstraints	IN/OUT. Empty list is passed in. We hang constraints on it as we go.
0: 	  *	@param	relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
0: 	  *	@param	needsDeferredProcessing	IN/OUT. true if the statement already needs
0: 	  *									deferred processing. set while evaluating this
0: 	  *									routine if a trigger or constraint requires
0: 	  *									deferred processing
0: 	  *
0: 	  * @return a FormatableBitSet of columns to be read out of the base table
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public static FormatableBitSet getUpdateReadMap
0: 	(
0: 		TableDescriptor				baseTable,
0: 		ResultColumnList			updateColumnList,
0: 		Vector						conglomVector,
0: 		ConstraintDescriptorList	relevantConstraints,
0: 		GenericDescriptorList		relevantTriggers,
0: 		boolean[]					needsDeferredProcessing
0: 	)
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(updateColumnList != null, "updateColumnList is null");
0: 		}
0: 
0: 		int		columnCount = baseTable.getMaxColumnID();
0: 		FormatableBitSet	columnMap = new FormatableBitSet(columnCount + 1);
0: 
0: 		/*
0: 		** Add all the changed columns.  We don't strictly
0: 		** need the before image of the changed column in all cases,
0: 		** but it makes life much easier since things are set
0: 		** up around the assumption that we have the before
0: 		** and after image of the column.
0: 		*/
0: 		int[]	changedColumnIds = updateColumnList.sortMe();
0: 
0: 		for (int ix = 0; ix < changedColumnIds.length; ix++)
0: 		{
0: 			columnMap.set(changedColumnIds[ix]);
0: 		}
0: 
0: 		/* 
0: 		** Get a list of the indexes that need to be 
0: 		** updated.  ColumnMap contains all indexed
0: 		** columns where 1 or more columns in the index
0: 		** are going to be modified.
0: 		*/
0: 		DMLModStatementNode.getXAffectedIndexes(baseTable, updateColumnList, columnMap, conglomVector );
0:  
0: 		/* 
0: 		** Add all columns needed for constraints.  We don't
0: 		** need to bother with foreign key/primary key constraints
0: 		** because they are added as a side effect of adding
0: 		** their indexes above.
0: 		*/
0: 		baseTable.getAllRelevantConstraints
0: 			( StatementType.UPDATE, false, changedColumnIds, needsDeferredProcessing, relevantConstraints );
0: 
0: 		int rclSize = relevantConstraints.size();
0: 		for (int index = 0; index < rclSize; index++)
0: 		{
0: 			ConstraintDescriptor cd = relevantConstraints.elementAt(index);
0: 			if (cd.getConstraintType() != DataDictionary.CHECK_CONSTRAINT)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			int[] refColumns = ((CheckConstraintDescriptor)cd).getReferencedColumns();
0: 			for (int i = 0; i < refColumns.length; i++)
0: 			{
0: 				columnMap.set(refColumns[i]);
0: 			}
0: 		}
0: 
0: 		/*
0: 	 	** If we have any triggers, then get all the columns
0: 		** because we don't know what the user will ultimately
0: 		** reference.
0: 	 	*/
0: 
0: 		baseTable.getAllRelevantTriggers( StatementType.UPDATE, changedColumnIds, relevantTriggers );
0: 		if ( relevantTriggers.size() > 0 ) { needsDeferredProcessing[0] = true; }
0: 
0: 		if (relevantTriggers.size() > 0)
0: 		{
0: 			for (int i = 1; i <= columnCount; i++)
0: 			{
0: 				columnMap.set(i);
0: 			}
0: 		}
0: 
0: 		return	columnMap;
0: 	}
0: } // end of UpdateNode
============================================================================