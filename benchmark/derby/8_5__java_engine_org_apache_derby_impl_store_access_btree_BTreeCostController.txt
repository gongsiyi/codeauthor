1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeCostController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostResult;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: The StoreCostController interface provides methods that an access client
1:eac0369: (most likely the system optimizer) can use to get store's estimated cost of
1:eac0369: various operations on the conglomerate the StoreCostController was opened
1:eac0369: for.
1:eac0369: <p>
1:eac0369: It is likely that the implementation of StoreCostController will open 
1:eac0369: the conglomerate and will leave the conglomerate open until the
1:eac0369: StoreCostController is closed.  This represents a significant amount of
1:eac0369: work, so the caller if possible should attempt to open the StoreCostController
1:eac0369: once per unit of work and rather than close and reopen the controller.  For
1:eac0369: instance if the optimizer needs to cost 2 different scans against a single
1:eac0369: conglomerate, it should use one instance of the StoreCostController.
1:eac0369: <p>
1:eac0369: The locking behavior of the implementation of a StoreCostController is
1:eac0369: undefined, it may or may not get locks on the underlying conglomerate.  It
1:eac0369: may or may not hold locks until end of transaction.  
1:eac0369: An optimal implementation will not get any locks on the underlying 
1:eac0369: conglomerate, thus allowing concurrent access to the table by a executing
1:eac0369: query while another query is optimizing.
1:eac0369: <p>
1:fa09146: @see org.apache.derby.iapi.store.access.TransactionController#openStoreCost
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class BTreeCostController extends OpenBTree 
1:eac0369:     implements StoreCostController
1:eac0369: {
1:eac0369: 
1:eac0369:     // 1.5 numbers on mikem old machine:
1:eac0369:     //
1:eac0369:     // The magic numbers are based on the following benchmark results:
1:eac0369:     //
1:eac0369:     //                                         no col   one int col  all cols
1:eac0369:     //                                         ------   -----------  --------
1:eac0369:     //100 byte heap fetch by row loc, cached   0.3625     0.5098     0.6629
1:eac0369:     //100 byte heap fetch by row loc, uncached 1.3605769  1.5168269  1.5769231
1:eac0369:     //4 byte   heap fetch by row loc, cached   0.3745     0.4016     0.3766
1:eac0369:     //4 byte   heap fetch by row loc, uncached 4.1938777  3.5714285  4.4897957
1:eac0369:     //
1:eac0369:     //                                 no col    one int col  all cols
1:eac0369:     //                                 ------    -----------  --------
1:eac0369:     //Int col one level btree
1:eac0369:     //  fetch by exact key, cached     0.781     1.012         0.42
1:eac0369:     //  fetch by exact key, sort merge 1.081     1.221         0.851
1:eac0369:     //  fetch by exact key, uncached   0.0       0.0           0.0
1:eac0369:     //Int col two level btree
1:eac0369:     //  fetch by exact key, cached     1.062     1.342         0.871
1:eac0369:     //  fetch by exact key, sort merge 1.893     2.273         1.633
1:eac0369:     //  fetch by exact key, uncached   5.7238097 5.3428574     4.7714286
1:eac0369:     //String key one level btree
1:eac0369:     //  fetch by exact key, cached     1.082     0.811         0.781
1:eac0369:     //  fetch by exact key, sort merge 1.572     1.683         1.141
1:eac0369:     //  fetch by exact key, uncached   0.0       0.0           0.0
1:eac0369:     //String key two level btree
1:eac0369:     //  fetch by exact key, cached     2.143     2.664         1.953
1:eac0369:     //  fetch by exact key, sort merge 3.775     4.116         3.505
1:eac0369:     //  fetch by exact key, uncached   4.639474  5.0052633     4.4289474
1:eac0369: 
1:eac0369:     // mikem new machine - insane, codeline, non-jit 1.1.7 numbers
1:eac0369:     //
1:eac0369:     //                                         no col   one int col  all cols
1:eac0369:     //                                         ------   -----------  --------
1:eac0369:     //100 byte heap fetch by row loc, cached   0.1662    0.4597      0.5618
1:eac0369:     //100 byte heap fetch by row loc, uncached 0.7565947 1.2601918   1.6690648
1:eac0369:     //4 byte   heap fetch by row loc, cached   0.1702    0.1983      0.1903
1:eac0369:     //4 byte   heap fetch by row loc, uncached 1.5068493 1.3013699   1.6438357
1:eac0369:     //
1:eac0369:     //                                 no col    one int col  all cols
1:eac0369:     //                                 ------    -----------  --------
1:eac0369:     // Int col one level btree
1:eac0369:     //   fetch by exact key, cached     0.271    0.511        0.33
1:eac0369:     //   fetch by exact key, sort merge 0.691    0.921        0.771
1:eac0369:     //   fetch by exact key, uncached   0.0      0.0          0.0
1:eac0369:     // Int col two level btree
1:eac0369:     //   fetch by exact key, cached     0.541    0.711        0.561
1:eac0369:     //   fetch by exact key, sort merge 1.432    1.682        1.533
1:eac0369:     //   fetch by exact key, uncached   3.142857 3.6285715    3.2380953
1:eac0369:     // String key one level btree
1:eac0369:     //   fetch by exact key, cached     0.611    0.851        0.701
1:eac0369:     //   fetch by exact key, sort merge 1.051    1.272        1.122
1:eac0369:     //   fetch by exact key, uncached   0.0      0.0          0.0
1:eac0369:     // String key two level btree
1:eac0369:     //   fetch by exact key, cached     1.532    1.843        1.622
1:eac0369:     //   fetch by exact key, sort merge 2.844    3.155        2.984
1:eac0369:     //   fetch by exact key, uncached   3.4      3.636842     3.531579
1:eac0369:     // 
1:eac0369: 
1:eac0369: 
1:eac0369:     // The following costs are search costs to find a row on a leaf, use
1:eac0369:     // the heap costs to determine scan costs, for now ignore qualifier 
1:eac0369:     // application and stop comparisons.
1:eac0369:     // I used the int key, 2 level numbers divided by 2 to get per level.
1:eac0369:     
1:eac0369:     private static final double 
1:eac0369:         BTREE_CACHED_FETCH_BY_KEY_PER_LEVEL    = (0.541 / 2);
1:eac0369: 
1:eac0369:     private static final double 
1:eac0369:         BTREE_SORTMERGE_FETCH_BY_KEY_PER_LEVEL = (1.432 / 2);
1:eac0369: 
1:eac0369:     private static final double 
1:eac0369:         BTREE_UNCACHED_FETCH_BY_KEY_PER_LEVEL  = (3.143 / 2);
1:eac0369: 
1:eac0369:     // saved values passed to init().
1:eac0369:     TransactionManager  init_xact_manager;
1:eac0369:     Transaction         init_rawtran;
1:eac0369:     Conglomerate        init_conglomerate;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Only lookup these estimates from raw store once.
1:eac0369:      **/
1:eac0369:     long    num_pages;
1:eac0369:     long    num_rows;
1:eac0369:     long    page_size;
1:eac0369:     int     tree_height;
1:eac0369: 
1:eac0369:     /* Constructors for This class: */
1:eac0369: 
1:eac0369:     public BTreeCostController()
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Initialize the cost controller.
1:eac0369:      * <p>
1:eac0369:      * Save initialize parameters away, and open the underlying container.
1:eac0369:      * <p>
2:eac0369:      *
1:eac0369:      * @param xact_manager access manager transaction.
1:eac0369:      * @param rawtran      Raw store transaction.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void init(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     BTree               conglomerate,
1:eac0369:     Transaction         rawtran)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         super.init(
1:eac0369:             xact_manager, 
1:eac0369:             xact_manager, 
1:eac0369:             (ContainerHandle) null,         // open the btree.
1:eac0369:             rawtran, 
1:eac0369:             false,
1:eac0369:             ContainerHandle.MODE_READONLY,
1:eac0369:             TransactionManager.MODE_NONE,
1:eac0369:             (BTreeLockingPolicy) null,      // RESOLVE (mikem) - this means
1:eac0369:                                             // no locks during costing - will
1:eac0369:                                             // that work?????
1:eac0369:             conglomerate, 
1:eac0369:             (LogicalUndo) null,             // read only, so no undo necessary
1:eac0369:             (DynamicCompiledOpenConglomInfo) null);
1:eac0369: 
1:eac0369:         // look up costs from raw store.  For btrees these numbers are out
1:eac0369:         // of whack as they want to be leaf specific numbers but they include
1:eac0369:         // every page branch and leafs.
1:eac0369:         num_pages = this.container.getEstimatedPageCount(/* unused flag */ 0);
1:eac0369: 
1:eac0369:         // subtract one row for every page to account for internal control row
1:eac0369:         // which exists on every page.
1:eac0369:         num_rows  = 
1:eac0369:             this.container.getEstimatedRowCount(/*unused flag*/ 0) - num_pages;
1:eac0369: 
1:eac0369:         Properties prop = new Properties();
1:eac0369:         prop.put(Property.PAGE_SIZE_PARAMETER, "");
1:eac0369:         this.container.getContainerProperties(prop);
1:eac0369:         page_size = 
1:eac0369:             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));
1:eac0369: 
1:eac0369:         tree_height = getHeight();
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Public Methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Close the controller.
1:eac0369:      * <p>
1:eac0369:      * Close the open controller.  This method always succeeds, and never 
1:eac0369:      * throws any exceptions. Callers must not use the StoreCostController 
1:eac0369:      * Cost controller after closing it; they are strongly advised to clear
1:eac0369:      * out the scan controller reference after closing.
1:eac0369:      * <p>
1:eac0369:      **/
1:eac0369:     public void close()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         super.close();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the cost of calling ConglomerateController.fetch().
1:eac0369:      * <p>
1:eac0369:      * Return the estimated cost of calling ConglomerateController.fetch()
1:eac0369:      * on the current conglomerate.  This gives the cost of finding a record
1:eac0369:      * in the conglomerate given the exact RowLocation of the record in
1:eac0369:      * question. 
1:eac0369:      * <p>
1:eac0369:      * The validColumns parameter describes what kind of row 
1:eac0369:      * is being fetched, ie. it may be cheaper to fetch a partial row than a 
1:eac0369:      * complete row.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "templateRow."  templateRow,
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369:      *
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ConglomerateController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one fetch
1:eac0369:      *                            is likely clustered "close" to the next 
1:eac0369:      *                            fetch.  For instance if the query plan were
1:eac0369:      *                            to sort the RowLocations of a heap and then
1:eac0369:      *                            use those RowLocations sequentially to 
1:eac0369:      *                            probe into the heap, then this flag should
1:eac0369:      *                            be specified.  If this flag is not set then
1:eac0369:      *                            access to the table is assumed to be
1:eac0369:      *                            random - ie. the type of access one gets 
1:eac0369:      *                            if you scan an index and probe each row
1:eac0369:      *                            in turn into the base table is "random".
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @return The cost of the fetch.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.RowUtil
1:eac0369:      **/
1:eac0369:     public double getFetchFromRowLocationCost(
1:eac0369:     FormatableBitSet      validColumns,
1:eac0369:     int         access_type)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the cost of exact key lookup.
1:eac0369:      * <p>
1:eac0369:      * Return the estimated cost of calling ScanController.fetch()
1:eac0369:      * on the current conglomerate, with start and stop positions set such
1:eac0369:      * that an exact match is expected.
1:eac0369:      * <p>
1:eac0369:      * This call returns the cost of a fetchNext() performed on a scan which
1:eac0369:      * has been positioned with a start position which specifies exact match
1:eac0369:      * on all keys in the row.
1:eac0369:      * <p>
1:eac0369:      * Example:
1:eac0369:      * <p>
1:eac0369:      * In the case of a btree this call can be used to determine the cost of
1:eac0369:      * doing an exact probe into btree, giving all key columns.  This cost
1:eac0369:      * can be used if the client knows it will be doing an exact key probe
1:eac0369:      * but does not have the key's at optimize time to use to make a call to
1:eac0369:      * getScanCost()
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "templateRow."  templateRow,
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369:      *
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ScanController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one scan
1:eac0369:      *                            is likely clustered "close" to the previous 
1:eac0369:      *                            scan.  For instance if the query plan were
1:eac0369:      *                            to used repeated "reopenScan()'s" to probe
1:eac0369:      *                            for the next key in an index, then this flag
1:eac0369:      *                            should be be specified.  If this flag is not 
1:eac0369:      *                            set then each scan will be costed independant
1:eac0369:      *                            of any other predicted scan access.
1:eac0369:      *
1:eac0369: 	 * @return The cost of the fetch.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.RowUtil
1:eac0369:      **/
1:eac0369:     public double getFetchFromFullKeyCost(
1:eac0369:     FormatableBitSet      validColumns,
1:eac0369:     int         access_type)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         double ret_cost;
1:eac0369: 
1:eac0369:         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0)
1:eac0369:         {
1:eac0369:             // uncached fetch
1:eac0369:             ret_cost = BTREE_UNCACHED_FETCH_BY_KEY_PER_LEVEL;
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             ret_cost = BTREE_SORTMERGE_FETCH_BY_KEY_PER_LEVEL;
1:eac0369:         }
1:eac0369:         ret_cost *= tree_height;
1:eac0369: 
1:eac0369:         return(ret_cost);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Calculate the cost of a scan.
1:eac0369:      * <p>
1:eac0369:      * Cause this object to calculate the cost of performing the described
1:eac0369:      * scan.  The interface is setup such that first a call is made to
1:eac0369:      * calcualteScanCost(), and then subsequent calls to accessor routines
1:eac0369:      * are made to get various pieces of information about the cost of
1:eac0369:      * the scan.
1:eac0369:      * <p>
1:eac0369:      * For the purposes of costing this routine is going to assume that 
1:eac0369:      * a page will remain in cache between the time one next()/fetchNext()
1:eac0369:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:eac0369:      * <p>
1:eac0369:      * The result of costing the scan is placed in the "cost_result".  
1:eac0369:      * The cost of the scan is stored by calling 
1:eac0369:      * cost_result.setEstimatedCost(cost).
1:eac0369:      * The estimated row count is stored by calling 
1:eac0369:      * cost_result.setEstimatedRowCount(row_count).
1:eac0369:      * <p>
1:eac0369:      * The estimated cost of the scan assumes the caller will 
1:eac0369:      * execute a fetchNext() loop for every row that qualifies between
1:eac0369:      * start and stop position.  Note that this cost is different than
1:eac0369:      * execution a next(),fetch() loop; or if the scan is going to be
1:eac0369:      * terminated by client prior to reaching the stop condition.
1:eac0369:      * <p>
1:eac0369:      * The estimated number of rows returned from the scan 
1:eac0369:      * assumes the caller will execute a fetchNext() loop for every 
1:eac0369:      * row that qualifies between start and stop position.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param scan_type       The type of scan that will be executed.  There
1:eac0369:      *                        are currently 2 types:
1:eac0369:      *                        STORECOST_SCAN_NORMAL - scans will be executed
1:eac0369:      *                        using the standard next/fetch, where each fetch
1:eac0369:      *                        can retrieve 1 or many rows (if fetchNextGroup()
1:eac0369:      *                        interface is used).
1:eac0369:      *
1:eac0369:      *                        STORECOST_SCAN_SET - The entire result set will
1:eac0369:      *                        be retrieved using the the fetchSet() interface.
1:eac0369:      *
1:eac0369:      * @param row_count       Estimated total row count of the table.  The 
1:eac0369:      *                        current system tracks row counts in heaps better
1:eac0369:      *                        than btree's (btree's have "rows" which are not
1:eac0369:      *                        user rows - branch rows, control rows), so 
1:eac0369:      *                        if available the client should
1:eac0369:      *                        pass in the base table's row count into this
1:eac0369:      *                        routine to be used as the index's row count.
1:eac0369:      *                        If the caller has no idea, pass in -1.
1:eac0369:      *
1:eac0369:      * @param group_size      The number of rows to be returned by a single
1:eac0369:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:eac0369:      *
1:eac0369: 	 * @param forUpdate       Should be true if the caller intends to update 
1:eac0369:      *                        through the scan.
1:eac0369:      * 
1:eac0369: 	 * @param scanColumnList  A description of which columns to return from 
1:eac0369:      *                        every fetch in the scan.  template, 
1:eac0369:      *                        and scanColumnList work together
1:eac0369:      *                        to describe the row to be returned by the scan - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a "row".
1:eac0369:      * 
1:eac0369:      * @param template        A prototypical row which the scan may use to
1:eac0369: 	 *                        maintain its position in the conglomerate.  Not 
1:eac0369:      *                        all access method scan types will require this, 
1:eac0369:      *                        if they don't it's ok to pass in null.
1:eac0369:      *                        In order to scan a conglomerate one must 
1:eac0369:      *                        allocate 2 separate "row" templates.  The "row" 
1:eac0369:      *                        template passed into openScan is for the private
1:eac0369:      *                        use of the scan itself, and no access to it
1:eac0369:      *                        should be made by the caller while the scan is 
1:eac0369:      *                        still open.  Because of this the scanner must 
1:eac0369:      *                        allocate another "row" template to hold the 
1:eac0369:      *                        values returned from fetch().  Note that this 
1:eac0369:      *                        template must be for the full row, whether a 
1:eac0369:      *                        partial row scan is being executed or not.
1:eac0369:      *
1:eac0369: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
1:eac0369:      *                        value which, in combination with the 
1:eac0369:      *                        startSearchOperator, defines the starting 
1:eac0369:      *                        position of the scan.  If null, the starting
1:eac0369:      *                        position of the scan is the first row of the 
1:eac0369:      *                        conglomerate.  The startKeyValue must only
1:eac0369:      *                        reference columns included in the scanColumnList.
1:eac0369:      *
1:06dbbcf: 	 * @param startSearchOperator 
1:eac0369:      *                        an operator which defines how the startKeyValue
1:eac0369:      *                        is to be searched for.  If startSearchOperation 
1:eac0369:      *                        is ScanController.GE, the scan starts on the 
1:eac0369:      *                        first row which is greater than or equal to the 
1:eac0369: 	 *                        startKeyValue.  If startSearchOperation is 
1:eac0369:      *                        ScanController.GT, the scan starts on the first
1:eac0369:      *                        row whose key is greater than startKeyValue.  The
1:eac0369:      *                        startSearchOperation parameter is ignored if the
1:eac0369:      *                        startKeyValue parameter is null.
1:eac0369:      *
1:eac0369: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
1:eac0369:      *                        value which, in combination with the 
1:eac0369:      *                        stopSearchOperator, defines the ending position
1:eac0369:      *                        of the scan.  If null, the ending position of the
1:eac0369:      *                        scan is the last row of the conglomerate.  The
1:eac0369:      *                        stopKeyValue must only reference columns included
1:eac0369:      *                        in the scanColumnList.
1:eac0369:      *
1:06dbbcf: 	 * @param stopSearchOperator
1:eac0369:      *                        an operator which defines how the stopKeyValue
1:eac0369:      *                        is used to determine the scan stopping position. 
1:eac0369:      *                        If stopSearchOperation is ScanController.GE, the
1:eac0369:      *                        scan stops just before the first row which is
1:eac0369:      *                        greater than or equal to the stopKeyValue.  If 
1:eac0369:      *                        stopSearchOperation is ScanController.GT, the 
1:eac0369:      *                        scan stops just before the first row whose key 
1:eac0369:      *                        is greater than startKeyValue.  The
1:eac0369:      *                        stopSearchOperation parameter is ignored if the
1:eac0369:      *                        stopKeyValue parameter is null.
1:eac0369:      *
1:eac0369:      *                        
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ScanController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one scan
1:eac0369:      *                            is likely clustered "close" to the previous 
1:eac0369:      *                            scan.  For instance if the query plan were
1:eac0369:      *                            to used repeated "reopenScan()'s" to probe
1:eac0369:      *                            for the next key in an index, then this flag
1:eac0369:      *                            should be be specified.  If this flag is not 
1:eac0369:      *                            set then each scan will be costed independant
1:eac0369:      *                            of any other predicted scan access.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.RowUtil
1:eac0369:      **/
1:eac0369: 	public void getScanCost(
1:eac0369:     int                     scan_type,
1:eac0369:     long                    row_count,
1:eac0369:     int                     group_size,
1:eac0369:     boolean                 forUpdate,
1:eac0369:     FormatableBitSet                 scanColumnList,
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     DataValueDescriptor[]   startKeyValue,
1:eac0369:     int                     startSearchOperator,
1:eac0369:     DataValueDescriptor[]   stopKeyValue,
1:eac0369:     int                     stopSearchOperator,
1:eac0369:     boolean                 reopen_scan,
1:eac0369:     int                     access_type,
1:eac0369:     StoreCostResult         cost_result)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         float       left_of_start;
1:eac0369:         float       left_of_stop;
1:eac0369:         ControlRow  control_row = null;
1:eac0369:         long        input_row_count = (row_count < 0 ? num_rows : row_count);
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // Find the starting page and row slot.
1:eac0369:             if (startKeyValue == null)
1:eac0369:             {
1:eac0369:                 left_of_start = 0;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // Search for the starting row.
1:eac0369: 
1:eac0369:                 SearchParameters sp = new SearchParameters(
1:eac0369:                     startKeyValue, 
1:eac0369:                     ((startSearchOperator == ScanController.GE) ? 
1:eac0369:                         SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH : 
1:eac0369:                         SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
1:eac0369:                     template, this, true);
1:eac0369: 
1:eac0369:                 control_row =
1:4a2b0d9:                     ControlRow.get(this, BTree.ROOTPAGEID).search(sp);
1:eac0369: 
1:eac0369:                 control_row.release();
1:eac0369:                 control_row = null;
1:eac0369: 
1:eac0369:                 left_of_start = sp.left_fraction;
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (stopKeyValue == null)
1:eac0369:             {
1:eac0369:                 left_of_stop = 1;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // Search for the stopping row.
1:eac0369: 
1:eac0369:                 SearchParameters sp = 
1:eac0369:                     new SearchParameters(
1:eac0369:                         stopKeyValue, 
1:eac0369:                         ((stopSearchOperator == ScanController.GE) ? 
1:eac0369:                           SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH : 
1:eac0369:                           SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
1:eac0369:                         template, this, true);
1:eac0369: 
1:eac0369:                 control_row =
1:4a2b0d9:                     ControlRow.get(this, BTree.ROOTPAGEID).search(sp);
1:eac0369: 
1:eac0369:                 control_row.release();
1:eac0369:                 control_row = null;
1:eac0369: 
1:eac0369:                 left_of_stop = sp.left_fraction;
1:eac0369:             }
1:eac0369: 
1:eac0369:             // System.out.println(
1:eac0369:               //   "\n\tleft_of_start = " + left_of_start +
1:eac0369:                 // "\n\tleft_of_stop  = " + left_of_stop);
1:eac0369: 
1:eac0369:             // what percentage of rows are between start and stop?
1:eac0369: 
1:eac0369:             float ret_fraction = left_of_stop - left_of_start;
1:eac0369: 
1:eac0369:             // If for some reason the stop position comes before the start
1:eac0369:             // position, assume 0 rows will return from query.
1:eac0369:             if (ret_fraction < 0)
1:eac0369:                 ret_fraction = 0;
1:eac0369: 
1:a8f86a1:             // Never return estimate of more rows than exist, sometimes 
1:a8f86a1:             // the recursive estimation through the btree may return a number
1:a8f86a1:             // like 1.00001.
1:a8f86a1:             if (ret_fraction > 1)
1:a8f86a1:                 ret_fraction = 1;
1:eac0369: 
1:eac0369:             float estimated_row_count = input_row_count * ret_fraction;
1:eac0369: 
1:b25e3a7:             // DERBY-6317
1:b25e3a7:             // In the case of unique indexes we always estimate a return of
1:b25e3a7:             // 1 row for a equality term. To be consistent always insure
1:b25e3a7:             // that this estimate at least returns at least 1 row, even
1:b25e3a7:             // though the reality may be that the row does not exist.  In the
1:b25e3a7:             // case of DERBY-6317 a table with 43 million rows, the existing
1:b25e3a7:             // calculation for the search which in reality was exactly 1 row 
1:b25e3a7:             // was rounding down to 0 rows.  This in turn led calling 
1:b25e3a7:             // optimizer to pick a full scan plan on the 43 million row which
1:b25e3a7:             // was discounted by multiplying the 0 row count, rather than 
1:b25e3a7:             // pick an obviously useful index.
1:b25e3a7:             if (estimated_row_count < 1)
1:b25e3a7:                 estimated_row_count = 1;
1:b25e3a7: 
1:b25e3a7: 
1:eac0369:             // first the base cost of positioning on the first row in the scan.
1:eac0369:             double cost = 
1:eac0369:                 getFetchFromFullKeyCost(scanColumnList, access_type);
1:eac0369: 
1:eac0369:             // add the base cost of bringing each page for the first time into
1:eac0369:             // the cache.  This is basically the cost of bringing each leaf
1:eac0369:             // uncached into the cache and reading the control row off of it.:
1:eac0369:             cost += 
1:eac0369:                 (num_pages * ret_fraction) * BASE_UNCACHED_ROW_FETCH_COST;
1:eac0369: 
1:eac0369:             // Now some magic to try and figure out the cost of doing a
1:eac0369:             // scan along the leaf level of the tree.  Mostly just assume
1:eac0369:             // the costs are the same as the heap, and ignore qualifier
1:eac0369:             // processing and stop row comparisons for now.
1:eac0369: 
1:eac0369:             // the base cost of getting each of the rows from a page assumed
1:eac0369:             // to already be cached (by the scan fetch) - this is only for all
1:eac0369:             // rows after the initial row on the page has been accounted for
1:eac0369:             // under the BASE_UNCACHED_ROW_FETCH_COST cost.:
1:eac0369:             long cached_row_count = ((long) estimated_row_count) - num_pages;
1:eac0369:             if (cached_row_count < 0)
1:eac0369:                 cached_row_count = 0;
1:eac0369: 
1:eac0369:             if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)
1:eac0369:                 cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;
1:eac0369:             else
1:eac0369:                 cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;
1:eac0369: 
1:eac0369:             // finally add the cost associated with the number of bytes in row:
1:eac0369:             long row_size = 
1:eac0369:                 (input_row_count == 0) ? 
1:eac0369:                     4 : (num_pages * page_size) / input_row_count;
1:eac0369: 
1:eac0369:             cost += 
1:eac0369:                 (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;
1:eac0369: 
2:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (cost < 0)
1:eac0369:                     SanityManager.THROWASSERT("cost " + cost);
1:eac0369: 
1:eac0369:                 if (estimated_row_count < 0)
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "estimated_row_count = " + estimated_row_count);
1:eac0369:             }
1:eac0369: 
1:eac0369:             // return the cost
1:eac0369:             cost_result.setEstimatedCost(cost);
1:eac0369: 
1:eac0369:             cost_result.setEstimatedRowCount(Math.round(estimated_row_count));
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (control_row != null)
1:eac0369:                 control_row.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         // System.out.println("BTreeCostController.getScanCost():" + 
1:eac0369:           //   "\n\t cost = " + cost_result.getEstimatedCost() +
1:eac0369:             // "\n\t rows = " + cost_result.getEstimatedRowCount());
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return an "empty" row location object of the correct type.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The empty Rowlocation.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public RowLocation newRowLocationTemplate()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b25e3a7
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-6317
1:             // In the case of unique indexes we always estimate a return of
1:             // 1 row for a equality term. To be consistent always insure
1:             // that this estimate at least returns at least 1 row, even
1:             // though the reality may be that the row does not exist.  In the
1:             // case of DERBY-6317 a table with 43 million rows, the existing
1:             // calculation for the search which in reality was exactly 1 row 
1:             // was rounding down to 0 rows.  This in turn led calling 
1:             // optimizer to pick a full scan plan on the 43 million row which
1:             // was discounted by multiplying the 0 row count, rather than 
1:             // pick an obviously useful index.
1:             if (estimated_row_count < 1)
1:                 estimated_row_count = 1;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
commit:a8f86a1
/////////////////////////////////////////////////////////////////////////
1:             // Never return estimate of more rows than exist, sometimes 
1:             // the recursive estimation through the btree may return a number
1:             // like 1.00001.
1:             if (ret_fraction > 1)
1:                 ret_fraction = 1;
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param startSearchOperator 
/////////////////////////////////////////////////////////////////////////
1: 	 * @param stopSearchOperator
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:                     ControlRow.get(this, BTree.ROOTPAGEID).search(sp);
/////////////////////////////////////////////////////////////////////////
1:                     ControlRow.get(this, BTree.ROOTPAGEID).search(sp);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: @see org.apache.derby.iapi.store.access.TransactionController#openStoreCost
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.RowUtil
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.RowUtil
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.RowUtil
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeCostController
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.StoreCostResult;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import java.util.Properties;
1: 
1: /**
1: 
1: The StoreCostController interface provides methods that an access client
1: (most likely the system optimizer) can use to get store's estimated cost of
1: various operations on the conglomerate the StoreCostController was opened
1: for.
1: <p>
1: It is likely that the implementation of StoreCostController will open 
1: the conglomerate and will leave the conglomerate open until the
1: StoreCostController is closed.  This represents a significant amount of
1: work, so the caller if possible should attempt to open the StoreCostController
1: once per unit of work and rather than close and reopen the controller.  For
1: instance if the optimizer needs to cost 2 different scans against a single
1: conglomerate, it should use one instance of the StoreCostController.
1: <p>
1: The locking behavior of the implementation of a StoreCostController is
1: undefined, it may or may not get locks on the underlying conglomerate.  It
1: may or may not hold locks until end of transaction.  
1: An optimal implementation will not get any locks on the underlying 
1: conglomerate, thus allowing concurrent access to the table by a executing
1: query while another query is optimizing.
1: <p>
0: @see TransactionController#openStoreCost
1: 
1: **/
1: 
1: public class BTreeCostController extends OpenBTree 
1:     implements StoreCostController
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1:     // 1.5 numbers on mikem old machine:
1:     //
1:     // The magic numbers are based on the following benchmark results:
1:     //
1:     //                                         no col   one int col  all cols
1:     //                                         ------   -----------  --------
1:     //100 byte heap fetch by row loc, cached   0.3625     0.5098     0.6629
1:     //100 byte heap fetch by row loc, uncached 1.3605769  1.5168269  1.5769231
1:     //4 byte   heap fetch by row loc, cached   0.3745     0.4016     0.3766
1:     //4 byte   heap fetch by row loc, uncached 4.1938777  3.5714285  4.4897957
1:     //
1:     //                                 no col    one int col  all cols
1:     //                                 ------    -----------  --------
1:     //Int col one level btree
1:     //  fetch by exact key, cached     0.781     1.012         0.42
1:     //  fetch by exact key, sort merge 1.081     1.221         0.851
1:     //  fetch by exact key, uncached   0.0       0.0           0.0
1:     //Int col two level btree
1:     //  fetch by exact key, cached     1.062     1.342         0.871
1:     //  fetch by exact key, sort merge 1.893     2.273         1.633
1:     //  fetch by exact key, uncached   5.7238097 5.3428574     4.7714286
1:     //String key one level btree
1:     //  fetch by exact key, cached     1.082     0.811         0.781
1:     //  fetch by exact key, sort merge 1.572     1.683         1.141
1:     //  fetch by exact key, uncached   0.0       0.0           0.0
1:     //String key two level btree
1:     //  fetch by exact key, cached     2.143     2.664         1.953
1:     //  fetch by exact key, sort merge 3.775     4.116         3.505
1:     //  fetch by exact key, uncached   4.639474  5.0052633     4.4289474
1: 
1:     // mikem new machine - insane, codeline, non-jit 1.1.7 numbers
1:     //
1:     //                                         no col   one int col  all cols
1:     //                                         ------   -----------  --------
1:     //100 byte heap fetch by row loc, cached   0.1662    0.4597      0.5618
1:     //100 byte heap fetch by row loc, uncached 0.7565947 1.2601918   1.6690648
1:     //4 byte   heap fetch by row loc, cached   0.1702    0.1983      0.1903
1:     //4 byte   heap fetch by row loc, uncached 1.5068493 1.3013699   1.6438357
1:     //
1:     //                                 no col    one int col  all cols
1:     //                                 ------    -----------  --------
1:     // Int col one level btree
1:     //   fetch by exact key, cached     0.271    0.511        0.33
1:     //   fetch by exact key, sort merge 0.691    0.921        0.771
1:     //   fetch by exact key, uncached   0.0      0.0          0.0
1:     // Int col two level btree
1:     //   fetch by exact key, cached     0.541    0.711        0.561
1:     //   fetch by exact key, sort merge 1.432    1.682        1.533
1:     //   fetch by exact key, uncached   3.142857 3.6285715    3.2380953
1:     // String key one level btree
1:     //   fetch by exact key, cached     0.611    0.851        0.701
1:     //   fetch by exact key, sort merge 1.051    1.272        1.122
1:     //   fetch by exact key, uncached   0.0      0.0          0.0
1:     // String key two level btree
1:     //   fetch by exact key, cached     1.532    1.843        1.622
1:     //   fetch by exact key, sort merge 2.844    3.155        2.984
1:     //   fetch by exact key, uncached   3.4      3.636842     3.531579
1:     // 
1: 
1: 
1:     // The following costs are search costs to find a row on a leaf, use
1:     // the heap costs to determine scan costs, for now ignore qualifier 
1:     // application and stop comparisons.
1:     // I used the int key, 2 level numbers divided by 2 to get per level.
1:     
1:     private static final double 
1:         BTREE_CACHED_FETCH_BY_KEY_PER_LEVEL    = (0.541 / 2);
1: 
1:     private static final double 
1:         BTREE_SORTMERGE_FETCH_BY_KEY_PER_LEVEL = (1.432 / 2);
1: 
1:     private static final double 
1:         BTREE_UNCACHED_FETCH_BY_KEY_PER_LEVEL  = (3.143 / 2);
1: 
1:     // saved values passed to init().
1:     TransactionManager  init_xact_manager;
1:     Transaction         init_rawtran;
1:     Conglomerate        init_conglomerate;
1: 
1:     /**
1:      * Only lookup these estimates from raw store once.
1:      **/
1:     long    num_pages;
1:     long    num_rows;
1:     long    page_size;
1:     int     tree_height;
1: 
1:     /* Constructors for This class: */
1: 
1:     public BTreeCostController()
1:     {
1:     }
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /**
1:      * Initialize the cost controller.
1:      * <p>
1:      * Save initialize parameters away, and open the underlying container.
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param xact_manager access manager transaction.
0:      * @param sementid     The id of the segment where container can be found.
1:      * @param rawtran      Raw store transaction.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void init(
1:     TransactionManager  xact_manager,
1:     BTree               conglomerate,
1:     Transaction         rawtran)
1:         throws StandardException
1:     {
1:         super.init(
1:             xact_manager, 
1:             xact_manager, 
1:             (ContainerHandle) null,         // open the btree.
1:             rawtran, 
1:             false,
1:             ContainerHandle.MODE_READONLY,
1:             TransactionManager.MODE_NONE,
1:             (BTreeLockingPolicy) null,      // RESOLVE (mikem) - this means
1:                                             // no locks during costing - will
1:                                             // that work?????
1:             conglomerate, 
1:             (LogicalUndo) null,             // read only, so no undo necessary
1:             (DynamicCompiledOpenConglomInfo) null);
1: 
1:         // look up costs from raw store.  For btrees these numbers are out
1:         // of whack as they want to be leaf specific numbers but they include
1:         // every page branch and leafs.
1:         num_pages = this.container.getEstimatedPageCount(/* unused flag */ 0);
1: 
1:         // subtract one row for every page to account for internal control row
1:         // which exists on every page.
1:         num_rows  = 
1:             this.container.getEstimatedRowCount(/*unused flag*/ 0) - num_pages;
1: 
1:         Properties prop = new Properties();
1:         prop.put(Property.PAGE_SIZE_PARAMETER, "");
1:         this.container.getContainerProperties(prop);
1:         page_size = 
1:             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));
1: 
1:         tree_height = getHeight();
1: 
1:         return;
1:     }
1: 
1:     /* Public Methods of This class: */
1: 
1:     /**
1:      * Close the controller.
1:      * <p>
1:      * Close the open controller.  This method always succeeds, and never 
1:      * throws any exceptions. Callers must not use the StoreCostController 
1:      * Cost controller after closing it; they are strongly advised to clear
1:      * out the scan controller reference after closing.
1:      * <p>
1:      **/
1:     public void close()
1:         throws StandardException
1:     {
1:         super.close();
1:     }
1: 
1:     /**
1:      * Return the cost of calling ConglomerateController.fetch().
1:      * <p>
1:      * Return the estimated cost of calling ConglomerateController.fetch()
1:      * on the current conglomerate.  This gives the cost of finding a record
1:      * in the conglomerate given the exact RowLocation of the record in
1:      * question. 
1:      * <p>
1:      * The validColumns parameter describes what kind of row 
1:      * is being fetched, ie. it may be cheaper to fetch a partial row than a 
1:      * complete row.
1:      * <p>
1:      *
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ConglomerateController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one fetch
1:      *                            is likely clustered "close" to the next 
1:      *                            fetch.  For instance if the query plan were
1:      *                            to sort the RowLocations of a heap and then
1:      *                            use those RowLocations sequentially to 
1:      *                            probe into the heap, then this flag should
1:      *                            be specified.  If this flag is not set then
1:      *                            access to the table is assumed to be
1:      *                            random - ie. the type of access one gets 
1:      *                            if you scan an index and probe each row
1:      *                            in turn into the base table is "random".
1:      *
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
1:     public double getFetchFromRowLocationCost(
1:     FormatableBitSet      validColumns,
1:     int         access_type)
1: 		throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     /**
1:      * Return the cost of exact key lookup.
1:      * <p>
1:      * Return the estimated cost of calling ScanController.fetch()
1:      * on the current conglomerate, with start and stop positions set such
1:      * that an exact match is expected.
1:      * <p>
1:      * This call returns the cost of a fetchNext() performed on a scan which
1:      * has been positioned with a start position which specifies exact match
1:      * on all keys in the row.
1:      * <p>
1:      * Example:
1:      * <p>
1:      * In the case of a btree this call can be used to determine the cost of
1:      * doing an exact probe into btree, giving all key columns.  This cost
1:      * can be used if the client knows it will be doing an exact key probe
1:      * but does not have the key's at optimize time to use to make a call to
1:      * getScanCost()
1:      * <p>
1:      *
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
1:     public double getFetchFromFullKeyCost(
1:     FormatableBitSet      validColumns,
1:     int         access_type)
1: 		throws StandardException
1:     {
1:         double ret_cost;
1: 
1:         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0)
1:         {
1:             // uncached fetch
1:             ret_cost = BTREE_UNCACHED_FETCH_BY_KEY_PER_LEVEL;
1:         }
1:         else
1:         {
1:             ret_cost = BTREE_SORTMERGE_FETCH_BY_KEY_PER_LEVEL;
1:         }
1:         ret_cost *= tree_height;
1: 
1:         return(ret_cost);
1:     }
1: 
1: 
1:     /**
1:      * Calculate the cost of a scan.
1:      * <p>
1:      * Cause this object to calculate the cost of performing the described
1:      * scan.  The interface is setup such that first a call is made to
1:      * calcualteScanCost(), and then subsequent calls to accessor routines
1:      * are made to get various pieces of information about the cost of
1:      * the scan.
1:      * <p>
1:      * For the purposes of costing this routine is going to assume that 
1:      * a page will remain in cache between the time one next()/fetchNext()
1:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:      * <p>
1:      * The result of costing the scan is placed in the "cost_result".  
1:      * The cost of the scan is stored by calling 
1:      * cost_result.setEstimatedCost(cost).
1:      * The estimated row count is stored by calling 
1:      * cost_result.setEstimatedRowCount(row_count).
1:      * <p>
1:      * The estimated cost of the scan assumes the caller will 
1:      * execute a fetchNext() loop for every row that qualifies between
1:      * start and stop position.  Note that this cost is different than
1:      * execution a next(),fetch() loop; or if the scan is going to be
1:      * terminated by client prior to reaching the stop condition.
1:      * <p>
1:      * The estimated number of rows returned from the scan 
1:      * assumes the caller will execute a fetchNext() loop for every 
1:      * row that qualifies between start and stop position.
1:      * <p>
1:      *
1:      *
1:      * @param scan_type       The type of scan that will be executed.  There
1:      *                        are currently 2 types:
1:      *                        STORECOST_SCAN_NORMAL - scans will be executed
1:      *                        using the standard next/fetch, where each fetch
1:      *                        can retrieve 1 or many rows (if fetchNextGroup()
1:      *                        interface is used).
1:      *
1:      *                        STORECOST_SCAN_SET - The entire result set will
1:      *                        be retrieved using the the fetchSet() interface.
1:      *
1:      * @param row_count       Estimated total row count of the table.  The 
1:      *                        current system tracks row counts in heaps better
1:      *                        than btree's (btree's have "rows" which are not
1:      *                        user rows - branch rows, control rows), so 
1:      *                        if available the client should
1:      *                        pass in the base table's row count into this
1:      *                        routine to be used as the index's row count.
1:      *                        If the caller has no idea, pass in -1.
1:      *
1:      * @param group_size      The number of rows to be returned by a single
1:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:      *
1: 	 * @param forUpdate       Should be true if the caller intends to update 
1:      *                        through the scan.
1:      * 
1: 	 * @param scanColumnList  A description of which columns to return from 
1:      *                        every fetch in the scan.  template, 
1:      *                        and scanColumnList work together
1:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a "row".
1:      * 
1:      * @param template        A prototypical row which the scan may use to
1: 	 *                        maintain its position in the conglomerate.  Not 
1:      *                        all access method scan types will require this, 
1:      *                        if they don't it's ok to pass in null.
1:      *                        In order to scan a conglomerate one must 
1:      *                        allocate 2 separate "row" templates.  The "row" 
1:      *                        template passed into openScan is for the private
1:      *                        use of the scan itself, and no access to it
1:      *                        should be made by the caller while the scan is 
1:      *                        still open.  Because of this the scanner must 
1:      *                        allocate another "row" template to hold the 
1:      *                        values returned from fetch().  Note that this 
1:      *                        template must be for the full row, whether a 
1:      *                        partial row scan is being executed or not.
1:      *
1: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
1:      *                        value which, in combination with the 
1:      *                        startSearchOperator, defines the starting 
1:      *                        position of the scan.  If null, the starting
1:      *                        position of the scan is the first row of the 
1:      *                        conglomerate.  The startKeyValue must only
1:      *                        reference columns included in the scanColumnList.
1:      *
0: 	 * @param startSearchOperation 
1:      *                        an operator which defines how the startKeyValue
1:      *                        is to be searched for.  If startSearchOperation 
1:      *                        is ScanController.GE, the scan starts on the 
1:      *                        first row which is greater than or equal to the 
1: 	 *                        startKeyValue.  If startSearchOperation is 
1:      *                        ScanController.GT, the scan starts on the first
1:      *                        row whose key is greater than startKeyValue.  The
1:      *                        startSearchOperation parameter is ignored if the
1:      *                        startKeyValue parameter is null.
1:      *
1: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
1:      *                        value which, in combination with the 
1:      *                        stopSearchOperator, defines the ending position
1:      *                        of the scan.  If null, the ending position of the
1:      *                        scan is the last row of the conglomerate.  The
1:      *                        stopKeyValue must only reference columns included
1:      *                        in the scanColumnList.
1:      *
0: 	 * @param stopSearchOperation
1:      *                        an operator which defines how the stopKeyValue
1:      *                        is used to determine the scan stopping position. 
1:      *                        If stopSearchOperation is ScanController.GE, the
1:      *                        scan stops just before the first row which is
1:      *                        greater than or equal to the stopKeyValue.  If 
1:      *                        stopSearchOperation is ScanController.GT, the 
1:      *                        scan stops just before the first row whose key 
1:      *                        is greater than startKeyValue.  The
1:      *                        stopSearchOperation parameter is ignored if the
1:      *                        stopKeyValue parameter is null.
1:      *
1:      *                        
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
1: 	public void getScanCost(
1:     int                     scan_type,
1:     long                    row_count,
1:     int                     group_size,
1:     boolean                 forUpdate,
1:     FormatableBitSet                 scanColumnList,
1:     DataValueDescriptor[]   template,
1:     DataValueDescriptor[]   startKeyValue,
1:     int                     startSearchOperator,
1:     DataValueDescriptor[]   stopKeyValue,
1:     int                     stopSearchOperator,
1:     boolean                 reopen_scan,
1:     int                     access_type,
1:     StoreCostResult         cost_result)
1:         throws StandardException
1:     {
1:         float       left_of_start;
1:         float       left_of_stop;
1:         ControlRow  control_row = null;
1:         long        input_row_count = (row_count < 0 ? num_rows : row_count);
1: 
1:         try
1:         {
1:             // Find the starting page and row slot.
1:             if (startKeyValue == null)
1:             {
1:                 left_of_start = 0;
1:             }
1:             else
1:             {
1:                 // Search for the starting row.
1: 
1:                 SearchParameters sp = new SearchParameters(
1:                     startKeyValue, 
1:                     ((startSearchOperator == ScanController.GE) ? 
1:                         SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH : 
1:                         SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
1:                     template, this, true);
1: 
1:                 control_row =
0:                     ControlRow.Get(this, BTree.ROOTPAGEID).search(sp);
1: 
1:                 control_row.release();
1:                 control_row = null;
1: 
1:                 left_of_start = sp.left_fraction;
1:             }
1: 
1:             if (stopKeyValue == null)
1:             {
1:                 left_of_stop = 1;
1:             }
1:             else
1:             {
1:                 // Search for the stopping row.
1: 
1:                 SearchParameters sp = 
1:                     new SearchParameters(
1:                         stopKeyValue, 
1:                         ((stopSearchOperator == ScanController.GE) ? 
1:                           SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH : 
1:                           SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
1:                         template, this, true);
1: 
1:                 control_row =
0:                     ControlRow.Get(this, BTree.ROOTPAGEID).search(sp);
1: 
1:                 control_row.release();
1:                 control_row = null;
1: 
1:                 left_of_stop = sp.left_fraction;
1:             }
1: 
1:             // System.out.println(
1:               //   "\n\tleft_of_start = " + left_of_start +
1:                 // "\n\tleft_of_stop  = " + left_of_stop);
1: 
1:             // what percentage of rows are between start and stop?
1: 
1:             float ret_fraction = left_of_stop - left_of_start;
1: 
1:             // If for some reason the stop position comes before the start
1:             // position, assume 0 rows will return from query.
1:             if (ret_fraction < 0)
1:                 ret_fraction = 0;
1: 
1:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(ret_fraction >= 0 && ret_fraction <= 1);
1: 
1:             float estimated_row_count = input_row_count * ret_fraction;
1: 
1:             // first the base cost of positioning on the first row in the scan.
1:             double cost = 
1:                 getFetchFromFullKeyCost(scanColumnList, access_type);
1: 
1:             // add the base cost of bringing each page for the first time into
1:             // the cache.  This is basically the cost of bringing each leaf
1:             // uncached into the cache and reading the control row off of it.:
1:             cost += 
1:                 (num_pages * ret_fraction) * BASE_UNCACHED_ROW_FETCH_COST;
1: 
1:             // Now some magic to try and figure out the cost of doing a
1:             // scan along the leaf level of the tree.  Mostly just assume
1:             // the costs are the same as the heap, and ignore qualifier
1:             // processing and stop row comparisons for now.
1: 
1:             // the base cost of getting each of the rows from a page assumed
1:             // to already be cached (by the scan fetch) - this is only for all
1:             // rows after the initial row on the page has been accounted for
1:             // under the BASE_UNCACHED_ROW_FETCH_COST cost.:
1:             long cached_row_count = ((long) estimated_row_count) - num_pages;
1:             if (cached_row_count < 0)
1:                 cached_row_count = 0;
1: 
1:             if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)
1:                 cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;
1:             else
1:                 cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;
1: 
1:             // finally add the cost associated with the number of bytes in row:
1:             long row_size = 
1:                 (input_row_count == 0) ? 
1:                     4 : (num_pages * page_size) / input_row_count;
1: 
1:             cost += 
1:                 (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (cost < 0)
1:                     SanityManager.THROWASSERT("cost " + cost);
1: 
1:                 if (estimated_row_count < 0)
1:                     SanityManager.THROWASSERT(
1:                         "estimated_row_count = " + estimated_row_count);
1:             }
1: 
1:             // return the cost
1:             cost_result.setEstimatedCost(cost);
1: 
0:             // RESOLVE - should we make sure this number is > 0?
1:             cost_result.setEstimatedRowCount(Math.round(estimated_row_count));
1:         }
1:         finally
1:         {
1:             if (control_row != null)
1:                 control_row.release();
1:         }
1: 
1:         // System.out.println("BTreeCostController.getScanCost():" + 
1:           //   "\n\t cost = " + cost_result.getEstimatedCost() +
1:             // "\n\t rows = " + cost_result.getEstimatedRowCount());
1: 
1:         return;
1:     }
1: 
1:     /**
1:      * Return an "empty" row location object of the correct type.
1:      * <p>
1:      *
1: 	 * @return The empty Rowlocation.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public RowLocation newRowLocationTemplate()
1: 		throws StandardException
1: 	{
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.StoreCostResult;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
0: 
0: /**
0: 
0: The StoreCostController interface provides methods that an access client
0: (most likely the system optimizer) can use to get store's estimated cost of
0: various operations on the conglomerate the StoreCostController was opened
0: for.
0: <p>
0: It is likely that the implementation of StoreCostController will open 
0: the conglomerate and will leave the conglomerate open until the
0: StoreCostController is closed.  This represents a significant amount of
0: work, so the caller if possible should attempt to open the StoreCostController
0: once per unit of work and rather than close and reopen the controller.  For
0: instance if the optimizer needs to cost 2 different scans against a single
0: conglomerate, it should use one instance of the StoreCostController.
0: <p>
0: The locking behavior of the implementation of a StoreCostController is
0: undefined, it may or may not get locks on the underlying conglomerate.  It
0: may or may not hold locks until end of transaction.  
0: An optimal implementation will not get any locks on the underlying 
0: conglomerate, thus allowing concurrent access to the table by a executing
0: query while another query is optimizing.
0: <p>
0: @see TransactionController#openStoreCost
0: 
0: **/
0: 
0: public class BTreeCostController extends OpenBTree 
0:     implements StoreCostController
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:     // 1.5 numbers on mikem old machine:
0:     //
0:     // The magic numbers are based on the following benchmark results:
0:     //
0:     //                                         no col   one int col  all cols
0:     //                                         ------   -----------  --------
0:     //100 byte heap fetch by row loc, cached   0.3625     0.5098     0.6629
0:     //100 byte heap fetch by row loc, uncached 1.3605769  1.5168269  1.5769231
0:     //4 byte   heap fetch by row loc, cached   0.3745     0.4016     0.3766
0:     //4 byte   heap fetch by row loc, uncached 4.1938777  3.5714285  4.4897957
0:     //
0:     //                                 no col    one int col  all cols
0:     //                                 ------    -----------  --------
0:     //Int col one level btree
0:     //  fetch by exact key, cached     0.781     1.012         0.42
0:     //  fetch by exact key, sort merge 1.081     1.221         0.851
0:     //  fetch by exact key, uncached   0.0       0.0           0.0
0:     //Int col two level btree
0:     //  fetch by exact key, cached     1.062     1.342         0.871
0:     //  fetch by exact key, sort merge 1.893     2.273         1.633
0:     //  fetch by exact key, uncached   5.7238097 5.3428574     4.7714286
0:     //String key one level btree
0:     //  fetch by exact key, cached     1.082     0.811         0.781
0:     //  fetch by exact key, sort merge 1.572     1.683         1.141
0:     //  fetch by exact key, uncached   0.0       0.0           0.0
0:     //String key two level btree
0:     //  fetch by exact key, cached     2.143     2.664         1.953
0:     //  fetch by exact key, sort merge 3.775     4.116         3.505
0:     //  fetch by exact key, uncached   4.639474  5.0052633     4.4289474
0: 
0:     // mikem new machine - insane, codeline, non-jit 1.1.7 numbers
0:     //
0:     //                                         no col   one int col  all cols
0:     //                                         ------   -----------  --------
0:     //100 byte heap fetch by row loc, cached   0.1662    0.4597      0.5618
0:     //100 byte heap fetch by row loc, uncached 0.7565947 1.2601918   1.6690648
0:     //4 byte   heap fetch by row loc, cached   0.1702    0.1983      0.1903
0:     //4 byte   heap fetch by row loc, uncached 1.5068493 1.3013699   1.6438357
0:     //
0:     //                                 no col    one int col  all cols
0:     //                                 ------    -----------  --------
0:     // Int col one level btree
0:     //   fetch by exact key, cached     0.271    0.511        0.33
0:     //   fetch by exact key, sort merge 0.691    0.921        0.771
0:     //   fetch by exact key, uncached   0.0      0.0          0.0
0:     // Int col two level btree
0:     //   fetch by exact key, cached     0.541    0.711        0.561
0:     //   fetch by exact key, sort merge 1.432    1.682        1.533
0:     //   fetch by exact key, uncached   3.142857 3.6285715    3.2380953
0:     // String key one level btree
0:     //   fetch by exact key, cached     0.611    0.851        0.701
0:     //   fetch by exact key, sort merge 1.051    1.272        1.122
0:     //   fetch by exact key, uncached   0.0      0.0          0.0
0:     // String key two level btree
0:     //   fetch by exact key, cached     1.532    1.843        1.622
0:     //   fetch by exact key, sort merge 2.844    3.155        2.984
0:     //   fetch by exact key, uncached   3.4      3.636842     3.531579
0:     // 
0: 
0: 
0:     // The following costs are search costs to find a row on a leaf, use
0:     // the heap costs to determine scan costs, for now ignore qualifier 
0:     // application and stop comparisons.
0:     // I used the int key, 2 level numbers divided by 2 to get per level.
0:     
0:     private static final double 
0:         BTREE_CACHED_FETCH_BY_KEY_PER_LEVEL    = (0.541 / 2);
0: 
0:     private static final double 
0:         BTREE_SORTMERGE_FETCH_BY_KEY_PER_LEVEL = (1.432 / 2);
0: 
0:     private static final double 
0:         BTREE_UNCACHED_FETCH_BY_KEY_PER_LEVEL  = (3.143 / 2);
0: 
0:     // saved values passed to init().
0:     TransactionManager  init_xact_manager;
0:     Transaction         init_rawtran;
0:     Conglomerate        init_conglomerate;
0: 
0:     /**
0:      * Only lookup these estimates from raw store once.
0:      **/
0:     long    num_pages;
0:     long    num_rows;
0:     long    page_size;
0:     int     tree_height;
0: 
0:     /* Constructors for This class: */
0: 
0:     public BTreeCostController()
0:     {
0:     }
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /**
0:      * Initialize the cost controller.
0:      * <p>
0:      * Save initialize parameters away, and open the underlying container.
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      * @param xact_manager access manager transaction.
0:      * @param sementid     The id of the segment where container can be found.
0:      * @param rawtran      Raw store transaction.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void init(
0:     TransactionManager  xact_manager,
0:     BTree               conglomerate,
0:     Transaction         rawtran)
0:         throws StandardException
0:     {
0:         super.init(
0:             xact_manager, 
0:             xact_manager, 
0:             (ContainerHandle) null,         // open the btree.
0:             rawtran, 
0:             false,
0:             ContainerHandle.MODE_READONLY,
0:             TransactionManager.MODE_NONE,
0:             (BTreeLockingPolicy) null,      // RESOLVE (mikem) - this means
0:                                             // no locks during costing - will
0:                                             // that work?????
0:             conglomerate, 
0:             (LogicalUndo) null,             // read only, so no undo necessary
0:             (DynamicCompiledOpenConglomInfo) null);
0: 
0:         // look up costs from raw store.  For btrees these numbers are out
0:         // of whack as they want to be leaf specific numbers but they include
0:         // every page branch and leafs.
0:         num_pages = this.container.getEstimatedPageCount(/* unused flag */ 0);
0: 
0:         // subtract one row for every page to account for internal control row
0:         // which exists on every page.
0:         num_rows  = 
0:             this.container.getEstimatedRowCount(/*unused flag*/ 0) - num_pages;
0: 
0:         Properties prop = new Properties();
0:         prop.put(Property.PAGE_SIZE_PARAMETER, "");
0:         this.container.getContainerProperties(prop);
0:         page_size = 
0:             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));
0: 
0:         tree_height = getHeight();
0: 
0:         return;
0:     }
0: 
0:     /* Public Methods of This class: */
0: 
0:     /**
0:      * Close the controller.
0:      * <p>
0:      * Close the open controller.  This method always succeeds, and never 
0:      * throws any exceptions. Callers must not use the StoreCostController 
0:      * Cost controller after closing it; they are strongly advised to clear
0:      * out the scan controller reference after closing.
0:      * <p>
0:      **/
0:     public void close()
0:         throws StandardException
0:     {
0:         super.close();
0:     }
0: 
0:     /**
0:      * Return the cost of calling ConglomerateController.fetch().
0:      * <p>
0:      * Return the estimated cost of calling ConglomerateController.fetch()
0:      * on the current conglomerate.  This gives the cost of finding a record
0:      * in the conglomerate given the exact RowLocation of the record in
0:      * question. 
0:      * <p>
0:      * The validColumns parameter describes what kind of row 
0:      * is being fetched, ie. it may be cheaper to fetch a partial row than a 
0:      * complete row.
0:      * <p>
0:      *
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ConglomerateController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one fetch
0:      *                            is likely clustered "close" to the next 
0:      *                            fetch.  For instance if the query plan were
0:      *                            to sort the RowLocations of a heap and then
0:      *                            use those RowLocations sequentially to 
0:      *                            probe into the heap, then this flag should
0:      *                            be specified.  If this flag is not set then
0:      *                            access to the table is assumed to be
0:      *                            random - ie. the type of access one gets 
0:      *                            if you scan an index and probe each row
0:      *                            in turn into the base table is "random".
0:      *
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromRowLocationCost(
0:     FormatableBitSet      validColumns,
0:     int         access_type)
0: 		throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     /**
0:      * Return the cost of exact key lookup.
0:      * <p>
0:      * Return the estimated cost of calling ScanController.fetch()
0:      * on the current conglomerate, with start and stop positions set such
0:      * that an exact match is expected.
0:      * <p>
0:      * This call returns the cost of a fetchNext() performed on a scan which
0:      * has been positioned with a start position which specifies exact match
0:      * on all keys in the row.
0:      * <p>
0:      * Example:
0:      * <p>
0:      * In the case of a btree this call can be used to determine the cost of
0:      * doing an exact probe into btree, giving all key columns.  This cost
0:      * can be used if the client knows it will be doing an exact key probe
0:      * but does not have the key's at optimize time to use to make a call to
0:      * getScanCost()
0:      * <p>
0:      *
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromFullKeyCost(
0:     FormatableBitSet      validColumns,
0:     int         access_type)
0: 		throws StandardException
0:     {
0:         double ret_cost;
0: 
0:         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0)
0:         {
0:             // uncached fetch
0:             ret_cost = BTREE_UNCACHED_FETCH_BY_KEY_PER_LEVEL;
0:         }
0:         else
0:         {
0:             ret_cost = BTREE_SORTMERGE_FETCH_BY_KEY_PER_LEVEL;
0:         }
0:         ret_cost *= tree_height;
0: 
0:         return(ret_cost);
0:     }
0: 
0: 
0:     /**
0:      * Calculate the cost of a scan.
0:      * <p>
0:      * Cause this object to calculate the cost of performing the described
0:      * scan.  The interface is setup such that first a call is made to
0:      * calcualteScanCost(), and then subsequent calls to accessor routines
0:      * are made to get various pieces of information about the cost of
0:      * the scan.
0:      * <p>
0:      * For the purposes of costing this routine is going to assume that 
0:      * a page will remain in cache between the time one next()/fetchNext()
0:      * call and a subsequent next()/fetchNext() call is made within a scan.
0:      * <p>
0:      * The result of costing the scan is placed in the "cost_result".  
0:      * The cost of the scan is stored by calling 
0:      * cost_result.setEstimatedCost(cost).
0:      * The estimated row count is stored by calling 
0:      * cost_result.setEstimatedRowCount(row_count).
0:      * <p>
0:      * The estimated cost of the scan assumes the caller will 
0:      * execute a fetchNext() loop for every row that qualifies between
0:      * start and stop position.  Note that this cost is different than
0:      * execution a next(),fetch() loop; or if the scan is going to be
0:      * terminated by client prior to reaching the stop condition.
0:      * <p>
0:      * The estimated number of rows returned from the scan 
0:      * assumes the caller will execute a fetchNext() loop for every 
0:      * row that qualifies between start and stop position.
0:      * <p>
0:      *
0:      *
0:      * @param scan_type       The type of scan that will be executed.  There
0:      *                        are currently 2 types:
0:      *                        STORECOST_SCAN_NORMAL - scans will be executed
0:      *                        using the standard next/fetch, where each fetch
0:      *                        can retrieve 1 or many rows (if fetchNextGroup()
0:      *                        interface is used).
0:      *
0:      *                        STORECOST_SCAN_SET - The entire result set will
0:      *                        be retrieved using the the fetchSet() interface.
0:      *
0:      * @param row_count       Estimated total row count of the table.  The 
0:      *                        current system tracks row counts in heaps better
0:      *                        than btree's (btree's have "rows" which are not
0:      *                        user rows - branch rows, control rows), so 
0:      *                        if available the client should
0:      *                        pass in the base table's row count into this
0:      *                        routine to be used as the index's row count.
0:      *                        If the caller has no idea, pass in -1.
0:      *
0:      * @param group_size      The number of rows to be returned by a single
0:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
0:      *
0: 	 * @param forUpdate       Should be true if the caller intends to update 
0:      *                        through the scan.
0:      * 
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      * 
0:      * @param template        A prototypical row which the scan may use to
0: 	 *                        maintain its position in the conglomerate.  Not 
0:      *                        all access method scan types will require this, 
0:      *                        if they don't it's ok to pass in null.
0:      *                        In order to scan a conglomerate one must 
0:      *                        allocate 2 separate "row" templates.  The "row" 
0:      *                        template passed into openScan is for the private
0:      *                        use of the scan itself, and no access to it
0:      *                        should be made by the caller while the scan is 
0:      *                        still open.  Because of this the scanner must 
0:      *                        allocate another "row" template to hold the 
0:      *                        values returned from fetch().  Note that this 
0:      *                        template must be for the full row, whether a 
0:      *                        partial row scan is being executed or not.
0:      *
0: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        startSearchOperator, defines the starting 
0:      *                        position of the scan.  If null, the starting
0:      *                        position of the scan is the first row of the 
0:      *                        conglomerate.  The startKeyValue must only
0:      *                        reference columns included in the scanColumnList.
0:      *
0: 	 * @param startSearchOperation 
0:      *                        an operator which defines how the startKeyValue
0:      *                        is to be searched for.  If startSearchOperation 
0:      *                        is ScanController.GE, the scan starts on the 
0:      *                        first row which is greater than or equal to the 
0: 	 *                        startKeyValue.  If startSearchOperation is 
0:      *                        ScanController.GT, the scan starts on the first
0:      *                        row whose key is greater than startKeyValue.  The
0:      *                        startSearchOperation parameter is ignored if the
0:      *                        startKeyValue parameter is null.
0:      *
0: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        stopSearchOperator, defines the ending position
0:      *                        of the scan.  If null, the ending position of the
0:      *                        scan is the last row of the conglomerate.  The
0:      *                        stopKeyValue must only reference columns included
0:      *                        in the scanColumnList.
0:      *
0: 	 * @param stopSearchOperation
0:      *                        an operator which defines how the stopKeyValue
0:      *                        is used to determine the scan stopping position. 
0:      *                        If stopSearchOperation is ScanController.GE, the
0:      *                        scan stops just before the first row which is
0:      *                        greater than or equal to the stopKeyValue.  If 
0:      *                        stopSearchOperation is ScanController.GT, the 
0:      *                        scan stops just before the first row whose key 
0:      *                        is greater than startKeyValue.  The
0:      *                        stopSearchOperation parameter is ignored if the
0:      *                        stopKeyValue parameter is null.
0:      *
0:      *                        
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0: 	public void getScanCost(
0:     int                     scan_type,
0:     long                    row_count,
0:     int                     group_size,
0:     boolean                 forUpdate,
0:     FormatableBitSet                 scanColumnList,
0:     DataValueDescriptor[]   template,
0:     DataValueDescriptor[]   startKeyValue,
0:     int                     startSearchOperator,
0:     DataValueDescriptor[]   stopKeyValue,
0:     int                     stopSearchOperator,
0:     boolean                 reopen_scan,
0:     int                     access_type,
0:     StoreCostResult         cost_result)
0:         throws StandardException
0:     {
0:         float       left_of_start;
0:         float       left_of_stop;
0:         ControlRow  control_row = null;
0:         long        input_row_count = (row_count < 0 ? num_rows : row_count);
0: 
0:         try
0:         {
0:             // Find the starting page and row slot.
0:             if (startKeyValue == null)
0:             {
0:                 left_of_start = 0;
0:             }
0:             else
0:             {
0:                 // Search for the starting row.
0: 
0:                 SearchParameters sp = new SearchParameters(
0:                     startKeyValue, 
0:                     ((startSearchOperator == ScanController.GE) ? 
0:                         SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH : 
0:                         SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
0:                     template, this, true);
0: 
0:                 control_row =
0:                     ControlRow.Get(this, BTree.ROOTPAGEID).search(sp);
0: 
0:                 control_row.release();
0:                 control_row = null;
0: 
0:                 left_of_start = sp.left_fraction;
0:             }
0: 
0:             if (stopKeyValue == null)
0:             {
0:                 left_of_stop = 1;
0:             }
0:             else
0:             {
0:                 // Search for the stopping row.
0: 
0:                 SearchParameters sp = 
0:                     new SearchParameters(
0:                         stopKeyValue, 
0:                         ((stopSearchOperator == ScanController.GE) ? 
0:                           SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH : 
0:                           SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
0:                         template, this, true);
0: 
0:                 control_row =
0:                     ControlRow.Get(this, BTree.ROOTPAGEID).search(sp);
0: 
0:                 control_row.release();
0:                 control_row = null;
0: 
0:                 left_of_stop = sp.left_fraction;
0:             }
0: 
0:             // System.out.println(
0:               //   "\n\tleft_of_start = " + left_of_start +
0:                 // "\n\tleft_of_stop  = " + left_of_stop);
0: 
0:             // what percentage of rows are between start and stop?
0: 
0:             float ret_fraction = left_of_stop - left_of_start;
0: 
0:             // If for some reason the stop position comes before the start
0:             // position, assume 0 rows will return from query.
0:             if (ret_fraction < 0)
0:                 ret_fraction = 0;
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(ret_fraction >= 0 && ret_fraction <= 1);
0: 
0:             float estimated_row_count = input_row_count * ret_fraction;
0: 
0:             // first the base cost of positioning on the first row in the scan.
0:             double cost = 
0:                 getFetchFromFullKeyCost(scanColumnList, access_type);
0: 
0:             // add the base cost of bringing each page for the first time into
0:             // the cache.  This is basically the cost of bringing each leaf
0:             // uncached into the cache and reading the control row off of it.:
0:             cost += 
0:                 (num_pages * ret_fraction) * BASE_UNCACHED_ROW_FETCH_COST;
0: 
0:             // Now some magic to try and figure out the cost of doing a
0:             // scan along the leaf level of the tree.  Mostly just assume
0:             // the costs are the same as the heap, and ignore qualifier
0:             // processing and stop row comparisons for now.
0: 
0:             // the base cost of getting each of the rows from a page assumed
0:             // to already be cached (by the scan fetch) - this is only for all
0:             // rows after the initial row on the page has been accounted for
0:             // under the BASE_UNCACHED_ROW_FETCH_COST cost.:
0:             long cached_row_count = ((long) estimated_row_count) - num_pages;
0:             if (cached_row_count < 0)
0:                 cached_row_count = 0;
0: 
0:             if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)
0:                 cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;
0:             else
0:                 cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;
0: 
0:             // finally add the cost associated with the number of bytes in row:
0:             long row_size = 
0:                 (input_row_count == 0) ? 
0:                     4 : (num_pages * page_size) / input_row_count;
0: 
0:             cost += 
0:                 (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (cost < 0)
0:                     SanityManager.THROWASSERT("cost " + cost);
0: 
0:                 if (estimated_row_count < 0)
0:                     SanityManager.THROWASSERT(
0:                         "estimated_row_count = " + estimated_row_count);
0:             }
0: 
0:             // return the cost
0:             cost_result.setEstimatedCost(cost);
0: 
0:             // RESOLVE - should we make sure this number is > 0?
0:             cost_result.setEstimatedRowCount(Math.round(estimated_row_count));
0:         }
0:         finally
0:         {
0:             if (control_row != null)
0:                 control_row.release();
0:         }
0: 
0:         // System.out.println("BTreeCostController.getScanCost():" + 
0:           //   "\n\t cost = " + cost_result.getEstimatedCost() +
0:             // "\n\t rows = " + cost_result.getEstimatedRowCount());
0: 
0:         return;
0:     }
0: 
0:     /**
0:      * Return an "empty" row location object of the correct type.
0:      * <p>
0:      *
0: 	 * @return The empty Rowlocation.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public RowLocation newRowLocationTemplate()
0: 		throws StandardException
0: 	{
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0: 	}
0: }
============================================================================