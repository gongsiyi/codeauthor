1:eac0369: /*
1:9d24308: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.sort.MergeSort
1:9d24308: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:345de35: 
1:eac0369: package org.apache.derby.impl.store.access.sort;
21:eac0369: 
1:0c5bc3a: import java.util.Enumeration;
1:0c5bc3a: import java.util.Properties;
1:0c5bc3a: import java.util.Vector;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:0c5bc3a: import org.apache.derby.iapi.reference.SQLState;
1:0c5bc3a: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:0c5bc3a: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:0c5bc3a: import org.apache.derby.iapi.store.access.RowUtil;
1:0c5bc3a: import org.apache.derby.iapi.store.access.SortController;
1:0c5bc3a: import org.apache.derby.iapi.store.access.SortObserver;
1:0c5bc3a: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ScanControllerRowSource;
1:7e7a589: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Sort;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:0c5bc3a: import org.apache.derby.iapi.store.raw.StreamContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:0c5bc3a: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
4:eac0369: /**
1:eac0369: 
1:eac0369:   A sort implementation which does the sort in-memory if it can,
1:eac0369:   but which can do an external merge sort so that it can sort an
1:eac0369:   arbitrary number of rows.
1:eac0369: 
3:eac0369: **/
1:9d24308: 
1:28e234d: class MergeSort implements Sort
3:eac0369: {
1:eac0369: 	/*
1:eac0369: 	 * Fields
1:eac0369: 	 */
1:cc30c0c: 
1:cc30c0c: 	/**
1:9d24308: 	**/
1:18176ce: 	private static final int STATE_CLOSED = 0;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	**/
1:18176ce: 	private static final int STATE_INITIALIZED = 1;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	**/
1:18176ce: 	private static final int STATE_INSERTING = 2;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	**/
1:18176ce: 	private static final int STATE_DONE_INSERTING = 3;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	**/
1:18176ce: 	private static final int STATE_SCANNING = 4;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	**/
1:18176ce: 	private static final int STATE_DONE_SCANNING = 5;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Maintains the current state of the sort as defined in
1:eac0369: 	the preceding values.  Sorts start off and end up closed.
1:eac0369: 	**/
1:18176ce: 	private int state = STATE_CLOSED;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The template as passed in on create.  Valid when the state
1:eac0369: 	is INITIALIZED through SCANNING, null otherwise.
1:eac0369: 	**/
1:eac0369: 	protected DataValueDescriptor[] template;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The column ordering as passed in on create.  Valid when
1:eac0369: 	the state is INITIALIZED through SCANNING, null otherwise.
1:eac0369: 	May be null if there is no column ordering - this means
1:eac0369: 	that all rows are considered to be duplicates, and the
1:eac0369: 	sort will only emit a single row.
1:eac0369: 	**/
1:eac0369: 	protected ColumnOrdering columnOrdering[];
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     A lookup table to speed up lookup of a column associated with the i'th
1:eac0369:     column to compare.  To find the column id to compare as the i'th column
1:eac0369:     look in columnOrderingMap[i].
1:eac0369: 	**/
1:28e234d: 	protected int columnOrderingMap[];
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     A lookup table to speed up lookup of Ascending state of a column, 
1:eac0369: 	**/
1:28e234d: 	protected boolean columnOrderingAscendingMap[];
1:eac0369: 
1:eac0369: 	/**
1:cc30c0c:     A lookup table to speed up lookup of nulls-low ordering of a column, 
1:cc30c0c: 	**/
1:28e234d: 	protected boolean columnOrderingNullsLowMap[];
1:9d24308: 
1:9d24308: 	/**
1:eac0369: 	The sort observer.  May be null.  Used as a callback.
1:eac0369: 	**/
1:18176ce: 	SortObserver sortObserver;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Whether the rows are expected to be in order on insert,
1:eac0369: 	as passed in on create.
1:eac0369: 	**/
1:eac0369: 	protected boolean alreadyInOrder;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The inserter that's being used to insert rows into the sort.
1:eac0369: 	This field is only valid when the state is INSERTING.
1:eac0369: 	**/
1:18176ce: 	private MergeInserter inserter = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The scan that's being used to return rows from the sort.
1:eac0369: 	This field is only valid when the state is SCANNING.
1:eac0369: 	**/
1:18176ce: 	private Scan scan = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	A vector of merge runs, produced by the MergeInserter.
1:eac0369: 	Might be null if no merge runs were produced.
1:eac0369: 	It is a vector of container ids.
1:eac0369: 	**/
1:7e7a589: 	private Vector<Long> mergeRuns = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	An ordered set of the leftover rows that didn't go
1:eac0369: 	in the last merge run (might be all the rows if there
1:eac0369: 	are no merge runs).
1:eac0369: 	**/
1:18176ce: 	private SortBuffer sortBuffer = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The maximum number of entries a sort buffer can hold.
1:eac0369: 	**/
1:18176ce: 	int sortBufferMax;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The minimum number of entries a sort buffer can hold.
1:eac0369: 	**/
1:18176ce: 	int sortBufferMin;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Properties for mergeSort
1:eac0369: 	**/
1:eac0369: 	static Properties properties = null;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Static initializer for MergeSort, to initialize once the properties
1:eac0369: 	for the sortBuffer.  
1:eac0369: 	**/
1:eac0369:     static
1:eac0369:     {
1:eac0369: 		properties = new Properties();
1:eac0369: 		properties.put(RawStoreFactory.STREAM_FILE_BUFFER_SIZE_PARAMETER, "16384");
1:9d24308:     }
1:9d24308: 
1:eac0369: 	/*
1:eac0369: 	 * Methods of Sort
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Open a sort controller.
1:eac0369: 	<p>
1:eac0369: 	This implementation only supports a single sort controller
1:eac0369: 	per sort.
1:eac0369: 	@see Sort#open
1:eac0369: 	**/
1:eac0369: 	public SortController open(TransactionManager tran)
1:eac0369: 		throws StandardException
1:eac0369: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(state == STATE_INITIALIZED);
1:eac0369: 
1:eac0369: 		// Ready to start inserting rows.
1:eac0369: 		state = STATE_INSERTING;
1:eac0369: 
1:eac0369: 		// Create and initialize an inserter.  When the caller
1:eac0369: 		// closes it, it will call back to inserterIsClosed().
1:eac0369: 		this.inserter = new MergeInserter();
1:eac0369: 		if (this.inserter.initialize(this, tran) == false)
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(SQLState.SORT_COULD_NOT_INIT);
1:9d24308:         }
1:eac0369: 
1:eac0369: 		return this.inserter;
7:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Open a scan controller.
1:eac0369: 	@see Sort#openSortScan
1:eac0369: 	**/
1:eac0369: 
1:7e7a589: 	public ScanManager openSortScan(
1:eac0369:     TransactionManager tran,
1:eac0369:     boolean            hold)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(state == STATE_DONE_INSERTING);
1:eac0369: 
1:eac0369: 		if (mergeRuns == null || mergeRuns.size() == 0)
1:eac0369: 		{
1:eac0369: 			// There were no merge runs so we can just return
1:eac0369: 			// the rows from the sort buffer.
1:eac0369: 			scan = new SortBufferScan(this, tran, sortBuffer, hold);
1:eac0369: 
1:eac0369: 			// The scan now owns the sort buffer
1:eac0369: 			sortBuffer = null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// Dump the rows in the sort buffer to a merge run.
1:eac0369: 			long containerId = createMergeRun(tran, sortBuffer);
1:ce40a31: 			mergeRuns.addElement(containerId);
1:eac0369: 
1:eac0369: 			// If there are more merge runs than we can sort
1:eac0369: 			// at once with our sort buffer, we have to reduce
1:eac0369: 			// the number of merge runs
1:eac0369: 			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
1:eac0369: 				mergeRuns.size() > sortBuffer.capacity())
1:eac0369: 					multiStageMerge(tran);
1:eac0369: 
1:eac0369: 			// There are now few enough merge runs to sort
1:eac0369: 			// at once, so create a scan for them.
1:eac0369: 			MergeScan mscan = 
1:eac0369:                 new MergeScan(
1:eac0369:                     this, tran, sortBuffer, mergeRuns, sortObserver, hold);
1:eac0369: 
1:eac0369: 			if (!mscan.init(tran))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.SORT_COULD_NOT_INIT);
1:eac0369:             }
1:eac0369: 			scan = mscan;
1:eac0369: 
1:eac0369: 			// The scan now owns the sort buffer and merge runs.
1:eac0369: 			sortBuffer = null;
1:eac0369: 			mergeRuns = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Ready to start retrieving rows.
1:eac0369: 		this.state = STATE_SCANNING;
1:eac0369: 
1:eac0369: 		return scan;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Open a row source to get rows out of the sorter.
1:eac0369: 	@see Sort#openSortRowSource
1:eac0369: 	**/
1:eac0369: 	public ScanControllerRowSource openSortRowSource(TransactionManager tran)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(state == STATE_DONE_INSERTING);
1:eac0369: 
1:eac0369: 		ScanControllerRowSource rowSource = null;
1:eac0369: 
1:eac0369: 		if (mergeRuns == null || mergeRuns.size() == 0)
1:eac0369: 		{
1:eac0369: 			// There were no merge runs so we can just return
1:eac0369: 			// the rows from the sort buffer.
1:eac0369: 			scan = new SortBufferRowSource(sortBuffer, tran, sortObserver, false, sortBufferMax);
1:eac0369: 			rowSource = (ScanControllerRowSource)scan;
1:eac0369: 
1:eac0369: 			// The scan now owns the sort buffer
1:eac0369: 			sortBuffer = null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// Dump the rows in the sort buffer to a merge run.
1:eac0369: 			long containerId = createMergeRun(tran, sortBuffer);
1:ce40a31: 			mergeRuns.addElement(containerId);
1:eac0369: 
1:eac0369: 			// If there are more merge runs than we can sort
1:eac0369: 			// at once with our sort buffer, we have to reduce
1:eac0369: 			// the number of merge runs
1:eac0369: 			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
1:eac0369: 				mergeRuns.size() > sortBuffer.capacity())	
1:eac0369: 				multiStageMerge(tran);
1:eac0369: 
1:eac0369: 			// There are now few enough merge runs to sort
1:eac0369: 			// at once, so create a rowSource for them.
1:eac0369: 			MergeScanRowSource msRowSource = 
1:eac0369: 				new MergeScanRowSource(this, tran, sortBuffer, mergeRuns, sortObserver, false);
1:eac0369: 			if (!msRowSource.init(tran))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.SORT_COULD_NOT_INIT);
1:eac0369:             }
1:eac0369: 			scan = msRowSource;
1:eac0369: 			rowSource = msRowSource;
1:eac0369: 
1:eac0369: 			// The scan now owns the sort buffer and merge runs.
1:eac0369: 			sortBuffer = null;
1:eac0369: 			mergeRuns = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Ready to start retrieving rows.
1:eac0369: 		this.state = STATE_SCANNING;
1:eac0369: 
1:eac0369: 		return rowSource;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Drop the sort.
1:eac0369: 	@see Sort#drop
1:eac0369: 	**/
1:eac0369: 	public void drop(TransactionController tran)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// Make sure the inserter is closed.  Note this
1:eac0369: 		// will cause the callback to doneInserting()
1:eac0369: 		// which will give us any in-progress merge
1:eac0369: 		// runs, if there are any.
1:eac0369: 		if (inserter != null)
1:8417890: 			inserter.completedInserts();
1:eac0369: 		inserter = null;
1:eac0369: 
1:eac0369: 		// Make sure the scan is closed, if there is one.
1:eac0369: 		// This will cause the callback to doneScanning().
1:eac0369: 		if (scan != null)
1:eac0369: 		{
1:eac0369: 			scan.close();
1:eac0369: 			scan = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// If we have a row set, get rid of it.
1:eac0369: 		if (sortBuffer != null)
1:eac0369: 		{
1:eac0369: 			sortBuffer.close();
1:eac0369: 			sortBuffer = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Clean out the rest of the objects.
1:eac0369: 		template = null;
1:eac0369: 		columnOrdering = null;
1:eac0369: 		sortObserver = null;
1:eac0369: 
1:eac0369: 		// If there are any merge runs, drop them.
1:eac0369: 		dropMergeRuns((TransactionManager)tran);
1:eac0369: 
1:eac0369: 		// Whew!
1:eac0369: 		state = STATE_CLOSED;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Methods of MergeSort.  Arranged alphabetically.
1:eac0369: 	 */
1:eac0369: 
1:7f7477d:     /**
1:7f7477d:      * Check the column ordering against the template, making sure that each
1:7f7477d:      * column is present in the template, is not mentioned more than once, and
1:7f7477d:      * that the columns isn't {@code null}.
1:7f7477d:      * <p>
1:7f7477d:      * Intended to be called as part of a sanity check. All columns are
1:7f7477d:      * orderable, since {@code DataValueDescriptor} extends {@code Orderable}.
1:7f7477d:      *
1:7f7477d:      * @return {@code true} if the ordering is valid, {@code false} if not.
1:7f7477d:      */
1:7f7477d:     private boolean checkColumnOrdering(
1:eac0369:     DataValueDescriptor[]   template, 
1:eac0369:     ColumnOrdering          columnOrdering[])
1:eac0369: 	{
1:eac0369: 		// Allocate an array to check that each column mentioned only once.
1:eac0369: 		int templateNColumns = template.length;
1:eac0369: 		boolean seen[] = new boolean[templateNColumns];
1:eac0369: 
1:eac0369: 		// Check each column ordering.
1:9d24308: 		for (int i = 0; i < columnOrdering.length; i++)
1:eac0369: 		{
1:eac0369: 			int colid = columnOrdering[i].getColumnId();
1:eac0369: 
1:eac0369: 			// Check that the column id is valid.
1:eac0369: 			if (colid < 0 || colid >= templateNColumns)
1:eac0369: 				return false;
1:eac0369: 			
1:eac0369: 			// Check that the column isn't mentioned more than once.
1:eac0369: 			if (seen[colid])
1:eac0369: 				return false;
1:eac0369: 			seen[colid] = true;
1:eac0369: 
1:eac0369: 			Object columnVal = 
1:eac0369:                 RowUtil.getColumn(template, (FormatableBitSet) null, colid);
1:eac0369: 
1:7f7477d:             if (columnVal == null)
1:eac0369: 				return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Check that the columns in the row agree with the columns
1:eac0369: 	in the template, both in number and in type.
1:eac0369: 	<p>
1:eac0369: 	XXX (nat) Currently checks that the classes implementing
1:eac0369: 	each column are the same -- is this right?
1:eac0369: 	**/
1:eac0369: 	void checkColumnTypes(DataValueDescriptor[] row)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int nCols = row.length;
1:eac0369: 		if (template.length != nCols)
1:eac0369: 		{
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
3:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "template.length (" + template.length +
1:eac0369:                     ") expected to be = to nCols (" +
1:eac0369:                     nCols + ")");
1:eac0369:             }
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.SORT_TYPE_MISMATCH);
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             for (int colid = 0; colid < nCols; colid++)
1:eac0369:             {
1:eac0369:                 Object col1 = row[colid];
1:eac0369:                 Object col2 = template[colid];
1:eac0369:                 if (col1 == null)
1:eac0369: 				{
1:e0ba78c: 					SanityManager.THROWASSERT(
1:e0ba78c: 						"col[" + colid + "]  is null");
1:eac0369: 				}
1:9d24308: 						
1:eac0369:                 if (col1.getClass() != col2.getClass())
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "col1.getClass() (" + col1.getClass() +
1:eac0369:                         ") expected to be the same as col2.getClass() (" +
1:eac0369:                         col2.getClass() + ")");
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:9d24308: 
1:28e234d: 	protected int compare(
1:eac0369:     DataValueDescriptor[] r1, 
1:eac0369:     DataValueDescriptor[] r2)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Get the number of columns we have to compare.
1:eac0369: 		int colsToCompare = this.columnOrdering.length;
1:eac0369:         int r;
1:9d24308: 
1:eac0369: 		// Compare the columns specified in the column
1:eac0369: 		// ordering array.
1:eac0369:         for (int i = 0; i < colsToCompare; i++)
1:eac0369:         {
1:0c5bc3a:             if (i == colsToCompare - 1 && sortObserver.deferrable()) {
1:0c5bc3a:                 if (sortObserver.deferred()) {
1:0c5bc3a:                     // Last column, which is RowLocation. We compared equal
1:0c5bc3a:                     // this far so duplicate: remember till end of
1:0c5bc3a:                     // transaction, but continue sorting on RowLocation, since
1:0c5bc3a:                     // the index needs to be sorted on the column, too, for
1:0c5bc3a:                     // the Btree to load.
1:0c5bc3a:                     sortObserver.rememberDuplicate(r1);
1:0c5bc3a:                 } else {
1:0c5bc3a:                     // report the duplicate
1:0c5bc3a:                     break;
1:0c5bc3a:                 }
1:0c5bc3a:             }
1:eac0369: 			// Get columns to compare.
1:eac0369:             int colid = this.columnOrderingMap[i];
1:cc30c0c:             boolean nullsLow = this.columnOrderingNullsLowMap[i];
1:eac0369: 
1:eac0369: 			// If the columns don't compare equal, we're done.
1:eac0369: 			// Return the sense of the comparison.
1:cc30c0c: 			if ((r = r1[colid].compare(r2[colid], nullsLow)) 
1:eac0369:                     != 0)
1:eac0369: 			{
1:eac0369: 				if (this.columnOrderingAscendingMap[i])
1:eac0369: 					return r;
1:eac0369: 				else
1:eac0369: 					return -r;
1:9d24308: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// We made it through all the columns, and they must have
1:eac0369: 		// all compared equal.  So return that the rows compare equal.
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Go from the CLOSED to the INITIALIZED state.
1:eac0369: 	**/
1:eac0369: 	public void initialize(
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     ColumnOrdering          columnOrdering[],
1:eac0369:     SortObserver            sortObserver,
1:eac0369:     boolean                 alreadyInOrder,
1:eac0369:     long                    estimatedRows,
1:eac0369:     int                     sortBufferMax)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:     		SanityManager.ASSERT(state == STATE_CLOSED);
1:7f7477d:             // Make sure the column ordering makes sense
1:eac0369:     		SanityManager.ASSERT(checkColumnOrdering(template, columnOrdering),
1:eac0369: 	    		"column ordering error");
1:eac0369: 	    }
1:eac0369: 
1:eac0369: 		// Set user-defined parameters.
1:eac0369: 		this.template = template;
1:eac0369: 		this.columnOrdering = columnOrdering;
1:eac0369: 		this.sortObserver = sortObserver;
1:eac0369: 		this.alreadyInOrder = alreadyInOrder;
1:eac0369: 
1:eac0369:         // Cache results of columnOrdering calls, results are not allowed
1:eac0369:         // to change throughout a sort.
1:eac0369:         columnOrderingMap          = new int[columnOrdering.length];
1:eac0369:         columnOrderingAscendingMap = new boolean[columnOrdering.length];
1:cc30c0c:         columnOrderingNullsLowMap  = new boolean[columnOrdering.length];
1:e0ba78c:         for (int i = 0; i < columnOrdering.length; i++)
1:eac0369:         {
1:eac0369:             columnOrderingMap[i] = columnOrdering[i].getColumnId();
1:eac0369:             columnOrderingAscendingMap[i] = columnOrdering[i].getIsAscending();
1:cc30c0c:             columnOrderingNullsLowMap[i] = columnOrdering[i].getIsNullsOrderedLow();
1:9d24308:         }
1:9d24308: 
1:eac0369: 		// No inserter or scan yet.
1:eac0369: 		this.inserter = null;
1:eac0369: 		this.scan = null;
1:9d24308: 
1:eac0369: 		// We don't have any merge runs.
1:eac0369: 		this.mergeRuns = null;
1:eac0369: 		this.sortBuffer = null;
1:eac0369: 		this.sortBufferMax = sortBufferMax;
1:eac0369: 
1:eac0369:         if (estimatedRows > sortBufferMax)
1:eac0369: 			sortBufferMin = sortBufferMax;
1:eac0369: 		else
1:eac0369: 			sortBufferMin = (int)estimatedRows;
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("testSort"))
1:eac0369:                 sortBufferMin = sortBufferMax;
1:eac0369:         }
1:eac0369: 
1:eac0369: 		this.state = STATE_INITIALIZED;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	An inserter is closing.
1:eac0369: 	**/
1:eac0369: 	void doneInserting(MergeInserter inserter,
1:7e7a589: 		SortBuffer sortBuffer, Vector<Long> mergeRuns)
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:     		SanityManager.ASSERT(state == STATE_INSERTING);
1:eac0369:     	}
1:eac0369: 
1:eac0369: 		this.sortBuffer = sortBuffer;
1:eac0369: 		this.mergeRuns = mergeRuns;
1:eac0369: 		this.inserter = null;
1:eac0369: 
1:eac0369: 		this.state = STATE_DONE_INSERTING;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void doneScanning(Scan scan, SortBuffer sortBuffer)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			// Make sure the scan we're getting back is the one we gave out
1:eac0369: 
1:eac0369: 			if (this.scan != scan)
1:eac0369:     			SanityManager.THROWASSERT("this.scan = " + this.scan 
1:eac0369: 										  + " scan = " + scan);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.sortBuffer = sortBuffer;
1:eac0369: 		this.scan = null;
1:eac0369: 
1:eac0369: 		this.state = STATE_DONE_SCANNING;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void doneScanning(Scan scan, SortBuffer sortBuffer,
1:7e7a589: 		Vector<Long> mergeRuns)
1:eac0369: 	{
1:eac0369: 		this.mergeRuns = mergeRuns;
1:eac0369: 
1:eac0369: 		doneScanning(scan, sortBuffer);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Get rid of the merge runs, if there are any.
1:eac0369: 	Must not cause any errors because it's called
1:eac0369: 	during error processing.
1:eac0369: 	**/
1:eac0369: 	void dropMergeRuns(TransactionManager tran)
1:eac0369: 	{
1:eac0369: 		if (mergeRuns != null)
1:eac0369: 		{
1:7e7a589: 			Enumeration<Long> e = mergeRuns.elements();
1:eac0369: 
1:eac0369: 			try 
1:eac0369: 			{
1:eac0369: 				Transaction rawTran = tran.getRawStoreXact();
1:eac0369: 				long segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
1:eac0369: 
1:eac0369: 				while (e.hasMoreElements())
1:eac0369: 				{
1:7e7a589: 					long containerId = (e.nextElement()).longValue();
1:eac0369: 					rawTran.dropStreamContainer(segmentId, containerId);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			catch (StandardException se)
1:eac0369: 			{
1:eac0369: 				// Ignore problems with dropping, worst case
1:eac0369: 				// the raw store will clean up at reboot.
1:eac0369: 			}
1:eac0369: 			mergeRuns = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* DEBUG (nat)
1:eac0369: 	void printRunInfo(TransactionController tran)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		java.util.Enumeration e = mergeRuns.elements();
1:eac0369: 		while (e.hasMoreElements())
1:eac0369: 		{
1:eac0369: 			long conglomid = ((Long) e.nextElement()).longValue();
1:eac0369: 			ScanController sc = tran.openScan(conglomid, false,
1:eac0369: 									false, null, null, 0, null,
1:eac0369: 									null, 0);
1:eac0369: 			System.out.println("Merge run: conglomid=" + conglomid);
1:eac0369: 			while (sc.next())
1:eac0369: 			{
1:eac0369: 				sc.fetch(template);
1:eac0369: 				System.out.println(template);
1:eac0369: 			}
1:eac0369: 			sc.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	private void multiStageMerge(TransactionManager tran)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:7e7a589: 		Enumeration<Long> e;
1:eac0369: 		//int iterations = 0; // DEBUG (nat)
1:eac0369: 		int maxMergeRuns = sortBuffer.capacity();
1:eac0369: 
1:eac0369: 		if (maxMergeRuns > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN)
1:eac0369: 			maxMergeRuns = ExternalSortFactory.DEFAULT_MAX_MERGE_RUN;
1:eac0369: 
1:7e7a589: 		Vector<Long> subset;
1:7e7a589: 		Vector<Long> leftovers;
1:eac0369: 
1:eac0369: 		while (mergeRuns.size() > maxMergeRuns)
1:eac0369: 		{
1:eac0369: 			// Move maxMergeRuns elements from the merge runs
1:eac0369: 			// vector into a subset, leaving the rest.
1:7e7a589: 			subset = new Vector<Long>(maxMergeRuns);
1:7e7a589: 			leftovers = new Vector<Long>(mergeRuns.size() - maxMergeRuns);
1:eac0369: 			e = mergeRuns.elements();
1:eac0369: 			while (e.hasMoreElements())
1:eac0369: 			{
1:7e7a589: 				Long containerId = e.nextElement();
1:eac0369: 				if (subset.size() < maxMergeRuns)
1:eac0369: 					subset.addElement(containerId);
1:eac0369: 				else
1:eac0369: 					leftovers.addElement(containerId);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* DEBUG (nat)
1:eac0369: 			iterations++;
1:eac0369: 				System.out.println(subset.size() + " elements in subset");
1:eac0369: 				System.out.println(leftovers.size() + " elements in leftovers");
1:eac0369: 				System.out.println(mergeRuns.size() + " elements in mergeRuns");
1:eac0369: 				System.out.println("maxMergeRuns is " + maxMergeRuns);
1:eac0369: 				System.out.println("iterations = " + iterations);
1:eac0369: 			if (subset.size() == 0)
1:eac0369: 			{
1:eac0369: 				System.exit(1);
1:eac0369: 			}
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			mergeRuns = leftovers;
1:eac0369: 
1:eac0369: 			// Open a merge scan on the subset.
1:eac0369: 			MergeScanRowSource msRowSource = 
1:eac0369: 				new MergeScanRowSource(this, tran, sortBuffer, subset, sortObserver, false);
1:eac0369: 
1:eac0369: 			if (!msRowSource.init(tran))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.SORT_COULD_NOT_INIT);
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// Create and open another temporary stream conglomerate
1:eac0369: 			// which will become
1:eac0369: 			// a merge run made up with the merged runs from the subset.
1:eac0369: 			Transaction rawTran = tran.getRawStoreXact();
1:eac0369: 			int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
1:eac0369: 			long id = rawTran.addAndLoadStreamContainer(segmentId,
1:eac0369: 				properties, msRowSource);
1:eac0369: 
1:ce40a31: 			mergeRuns.addElement(id);
1:eac0369: 
1:eac0369: 			// Drop the conglomerates in the merge subset
1:eac0369: 			e = subset.elements();
1:eac0369: 			while (e.hasMoreElements())
1:eac0369: 			{
2:eac0369: 				Long containerId = (Long) e.nextElement();
1:eac0369: 				rawTran.dropStreamContainer(segmentId, containerId.longValue());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Remove all the rows from the sort buffer and store them
1:eac0369: 	in a temporary conglomerate.  The temporary conglomerate
1:eac0369: 	is a "merge run".  Returns the container id of the
1:eac0369: 	merge run.
1:eac0369: 	**/
1:eac0369: 	long createMergeRun(TransactionManager tran, SortBuffer sortBuffer)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// this sort buffer is not a scan and is not tracked by any
1:eac0369: 		// TransactionManager. 
1:eac0369: 		SortBufferRowSource rowSource =
1:eac0369: 			new SortBufferRowSource(sortBuffer, (TransactionManager)null, sortObserver, true, sortBufferMax); 
1:eac0369: 
1:eac0369: 		// Create a temporary stream conglomerate...
1:eac0369: 		Transaction rawTran = tran.getRawStoreXact();  // get raw transaction
1:eac0369: 		int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
1:eac0369: 		long id = rawTran.addAndLoadStreamContainer(segmentId,
1:eac0369: 			properties, rowSource);
1:eac0369: 
1:eac0369: 		// Don't close the sortBuffer, we just emptied it, the caller may reuse
1:eac0369: 		// that sortBuffer for the next run.
1:eac0369: 		rowSource = null;
1:eac0369: 
1:eac0369: 		return id;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			mergeRuns.addElement(containerId);
/////////////////////////////////////////////////////////////////////////
1: 			mergeRuns.addElement(containerId);
/////////////////////////////////////////////////////////////////////////
1: 			mergeRuns.addElement(id);
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
/////////////////////////////////////////////////////////////////////////
1: 	private Vector<Long> mergeRuns = null;
/////////////////////////////////////////////////////////////////////////
1: 	public ScanManager openSortScan(
/////////////////////////////////////////////////////////////////////////
1: 		SortBuffer sortBuffer, Vector<Long> mergeRuns)
/////////////////////////////////////////////////////////////////////////
1: 		Vector<Long> mergeRuns)
/////////////////////////////////////////////////////////////////////////
1: 			Enumeration<Long> e = mergeRuns.elements();
/////////////////////////////////////////////////////////////////////////
1: 					long containerId = (e.nextElement()).longValue();
/////////////////////////////////////////////////////////////////////////
1: 		Enumeration<Long> e;
1: 		Vector<Long> subset;
1: 		Vector<Long> leftovers;
1: 			subset = new Vector<Long>(maxMergeRuns);
1: 			leftovers = new Vector<Long>(mergeRuns.size() - maxMergeRuns);
1: 				Long containerId = e.nextElement();
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
1: import java.util.Properties;
1: import java.util.Vector;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.SortController;
1: import org.apache.derby.iapi.store.access.SortObserver;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.raw.StreamContainerHandle;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:             if (i == colsToCompare - 1 && sortObserver.deferrable()) {
1:                 if (sortObserver.deferred()) {
1:                     // Last column, which is RowLocation. We compared equal
1:                     // this far so duplicate: remember till end of
1:                     // transaction, but continue sorting on RowLocation, since
1:                     // the index needs to be sorted on the column, too, for
1:                     // the Btree to load.
1:                     sortObserver.rememberDuplicate(r1);
1:                 } else {
1:                     // report the duplicate
1:                     break;
1:                 }
1:             }
commit:e0ba78c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					SanityManager.THROWASSERT(
1: 						"col[" + colid + "]  is null");
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < columnOrdering.length; i++)
commit:9d24308
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0:     Determine whether a column is used for ordering or not.
1: 	**/
0: 	private boolean isOrderingColumn[];
1: 
/////////////////////////////////////////////////////////////////////////
0: 					if (!isOrderingColumn[colid]) {
1: 
0: 						// DERBY-4413 shows that the value for a generated
0: 						// column will be null as the result set is computed as
0: 						// part of an INSERT INTO, so accept a null also.
0: 						// This column would not be part of the sort key.
1: 
0: 						continue;
1: 
0: 					} else {
0: 						SanityManager.THROWASSERT("col[" + colid + "] is null");
1: 					}
/////////////////////////////////////////////////////////////////////////
1: 
0: 		if (SanityManager.DEBUG) {
0: 			isOrderingColumn = new boolean[template.length];
1: 
0: 			for (int i = 0; i < isOrderingColumn.length; i++) {
0: 				isOrderingColumn[i] = false;
1: 			}
1: 		}
1: 
1: 		for (int i = 0; i < columnOrdering.length; i++)
1: 
0: 			if (SanityManager.DEBUG) {
0: 				isOrderingColumn[columnOrderingMap[i]] = true;
1: 			}
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1:     A lookup table to speed up lookup of nulls-low ordering of a column, 
1: 	**/
0: 	private boolean columnOrderingNullsLowMap[];
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1:             boolean nullsLow = this.columnOrderingNullsLowMap[i];
1: 			if ((r = r1[colid].compare(r2[colid], nullsLow)) 
/////////////////////////////////////////////////////////////////////////
1:         columnOrderingNullsLowMap  = new boolean[columnOrdering.length];
1:             columnOrderingNullsLowMap[i] = columnOrdering[i].getIsNullsOrderedLow();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7f7477d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check the column ordering against the template, making sure that each
1:      * column is present in the template, is not mentioned more than once, and
1:      * that the columns isn't {@code null}.
1:      * <p>
1:      * Intended to be called as part of a sanity check. All columns are
1:      * orderable, since {@code DataValueDescriptor} extends {@code Orderable}.
1:      *
1:      * @return {@code true} if the ordering is valid, {@code false} if not.
1:      */
1:     private boolean checkColumnOrdering(
/////////////////////////////////////////////////////////////////////////
1:             if (columnVal == null)
/////////////////////////////////////////////////////////////////////////
1:             // Make sure the column ordering makes sense
commit:b4e2eb7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:18176ce
/////////////////////////////////////////////////////////////////////////
1: 	private static final int STATE_CLOSED = 0;
1: 	private static final int STATE_INITIALIZED = 1;
1: 	private static final int STATE_INSERTING = 2;
1: 	private static final int STATE_DONE_INSERTING = 3;
1: 	private static final int STATE_SCANNING = 4;
1: 	private static final int STATE_DONE_SCANNING = 5;
1: 	private int state = STATE_CLOSED;
/////////////////////////////////////////////////////////////////////////
0: 	private int columnOrderingMap[];
0: 	private boolean columnOrderingAscendingMap[];
1: 	SortObserver sortObserver;
/////////////////////////////////////////////////////////////////////////
1: 	private MergeInserter inserter = null;
1: 	private Scan scan = null;
0: 	private Vector mergeRuns = null;
1: 	private SortBuffer sortBuffer = null;
1: 	int sortBufferMax;
1: 	int sortBufferMin;
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1: class MergeSort implements Sort
/////////////////////////////////////////////////////////////////////////
1: 	protected int columnOrderingMap[];
1: 	protected boolean columnOrderingAscendingMap[];
1: 	protected boolean columnOrderingNullsLowMap[];
/////////////////////////////////////////////////////////////////////////
1: 	protected int compare(
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8417890
/////////////////////////////////////////////////////////////////////////
0: final class MergeSort implements Sort
/////////////////////////////////////////////////////////////////////////
1: 			inserter.completedInserts();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.sort.MergeSort
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.sort
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.sort;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.conglomerate.ScanControllerRowSource;
1: import org.apache.derby.iapi.store.access.conglomerate.Sort;
0: import org.apache.derby.iapi.store.access.conglomerate.SortFactory;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.SortObserver;
0: import org.apache.derby.iapi.store.access.SortController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.store.raw.StreamContainerHandle;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1: 
1:   A sort implementation which does the sort in-memory if it can,
1:   but which can do an external merge sort so that it can sort an
1:   arbitrary number of rows.
1: 
1: **/
1: 
0: public final class MergeSort implements Sort
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 	 * Fields
1: 	 */
1: 
1: 	/**
1: 	**/
0: 	static final int STATE_CLOSED = 0;
1: 
1: 	/**
1: 	**/
0: 	static final int STATE_INITIALIZED = 1;
1: 
1: 	/**
1: 	**/
0: 	static final int STATE_INSERTING = 2;
1: 
1: 	/**
1: 	**/
0: 	static final int STATE_DONE_INSERTING = 3;
1: 
1: 	/**
1: 	**/
0: 	static final int STATE_SCANNING = 4;
1: 
1: 	/**
1: 	**/
0: 	static final int STATE_DONE_SCANNING = 5;
1: 
1: 	/**
1: 	Maintains the current state of the sort as defined in
1: 	the preceding values.  Sorts start off and end up closed.
1: 	**/
0: 	protected int state = STATE_CLOSED;
1: 
1: 	/**
1: 	The template as passed in on create.  Valid when the state
1: 	is INITIALIZED through SCANNING, null otherwise.
1: 	**/
1: 	protected DataValueDescriptor[] template;
1: 
1: 	/**
1: 	The column ordering as passed in on create.  Valid when
1: 	the state is INITIALIZED through SCANNING, null otherwise.
1: 	May be null if there is no column ordering - this means
1: 	that all rows are considered to be duplicates, and the
1: 	sort will only emit a single row.
1: 	**/
1: 	protected ColumnOrdering columnOrdering[];
1: 
1: 	/**
1:     A lookup table to speed up lookup of a column associated with the i'th
1:     column to compare.  To find the column id to compare as the i'th column
1:     look in columnOrderingMap[i].
1: 	**/
0: 	protected int columnOrderingMap[];
1: 
1: 	/**
1:     A lookup table to speed up lookup of Ascending state of a column, 
1: 	**/
0: 	protected boolean columnOrderingAscendingMap[];
1: 
1: 	/**
1: 	The sort observer.  May be null.  Used as a callback.
1: 	**/
0: 	protected SortObserver sortObserver;
1: 
1: 	/**
1: 	Whether the rows are expected to be in order on insert,
1: 	as passed in on create.
1: 	**/
1: 	protected boolean alreadyInOrder;
1: 
1: 	/**
1: 	The inserter that's being used to insert rows into the sort.
1: 	This field is only valid when the state is INSERTING.
1: 	**/
0: 	protected MergeInserter inserter = null;
1: 
1: 	/**
1: 	The scan that's being used to return rows from the sort.
1: 	This field is only valid when the state is SCANNING.
1: 	**/
0: 	protected Scan scan = null;
1: 
1: 	/**
1: 	A vector of merge runs, produced by the MergeInserter.
1: 	Might be null if no merge runs were produced.
1: 	It is a vector of container ids.
1: 	**/
0: 	protected Vector mergeRuns = null;
1: 
1: 	/**
1: 	An ordered set of the leftover rows that didn't go
1: 	in the last merge run (might be all the rows if there
1: 	are no merge runs).
1: 	**/
0: 	protected SortBuffer sortBuffer = null;
1: 
1: 	/**
1: 	The maximum number of entries a sort buffer can hold.
1: 	**/
0: 	protected int sortBufferMax;
1: 
1: 	/**
1: 	The minimum number of entries a sort buffer can hold.
1: 	**/
0: 	protected int sortBufferMin;
1: 
1: 	/**
1: 	Properties for mergeSort
1: 	**/
1: 	static Properties properties = null;
1: 
1:     /**
1:     Static initializer for MergeSort, to initialize once the properties
1: 	for the sortBuffer.  
1: 	**/
1:     static
1:     {
1: 		properties = new Properties();
1: 		properties.put(RawStoreFactory.STREAM_FILE_BUFFER_SIZE_PARAMETER, "16384");
1:     }
1: 
1: 	/*
1: 	 * Methods of Sort
1: 	 */
1: 
1: 	/**
1: 	Open a sort controller.
1: 	<p>
1: 	This implementation only supports a single sort controller
1: 	per sort.
1: 	@see Sort#open
1: 	**/
1: 	public SortController open(TransactionManager tran)
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(state == STATE_INITIALIZED);
1: 
1: 		// Ready to start inserting rows.
1: 		state = STATE_INSERTING;
1: 
1: 		// Create and initialize an inserter.  When the caller
1: 		// closes it, it will call back to inserterIsClosed().
1: 		this.inserter = new MergeInserter();
1: 		if (this.inserter.initialize(this, tran) == false)
1:         {
1: 			throw StandardException.newException(SQLState.SORT_COULD_NOT_INIT);
1:         }
1: 
1: 		return this.inserter;
1: 	}
1: 
1: 	/**
1: 	Open a scan controller.
1: 	@see Sort#openSortScan
1: 	**/
1: 
0: 	public ScanController openSortScan(
1:     TransactionManager tran,
1:     boolean            hold)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(state == STATE_DONE_INSERTING);
1: 
1: 		if (mergeRuns == null || mergeRuns.size() == 0)
1: 		{
1: 			// There were no merge runs so we can just return
1: 			// the rows from the sort buffer.
1: 			scan = new SortBufferScan(this, tran, sortBuffer, hold);
1: 
1: 			// The scan now owns the sort buffer
1: 			sortBuffer = null;
1: 		}
1: 		else
1: 		{
1: 			// Dump the rows in the sort buffer to a merge run.
1: 			long containerId = createMergeRun(tran, sortBuffer);
0: 			mergeRuns.addElement(new Long(containerId));
1: 
1: 			// If there are more merge runs than we can sort
1: 			// at once with our sort buffer, we have to reduce
1: 			// the number of merge runs
1: 			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
1: 				mergeRuns.size() > sortBuffer.capacity())
1: 					multiStageMerge(tran);
1: 
1: 			// There are now few enough merge runs to sort
1: 			// at once, so create a scan for them.
1: 			MergeScan mscan = 
1:                 new MergeScan(
1:                     this, tran, sortBuffer, mergeRuns, sortObserver, hold);
1: 
1: 			if (!mscan.init(tran))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.SORT_COULD_NOT_INIT);
1:             }
1: 			scan = mscan;
1: 
1: 			// The scan now owns the sort buffer and merge runs.
1: 			sortBuffer = null;
1: 			mergeRuns = null;
1: 		}
1: 
1: 		// Ready to start retrieving rows.
1: 		this.state = STATE_SCANNING;
1: 
1: 		return scan;
1: 	}
1: 
1: 	/**
1: 	Open a row source to get rows out of the sorter.
1: 	@see Sort#openSortRowSource
1: 	**/
1: 	public ScanControllerRowSource openSortRowSource(TransactionManager tran)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(state == STATE_DONE_INSERTING);
1: 
1: 		ScanControllerRowSource rowSource = null;
1: 
1: 		if (mergeRuns == null || mergeRuns.size() == 0)
1: 		{
1: 			// There were no merge runs so we can just return
1: 			// the rows from the sort buffer.
1: 			scan = new SortBufferRowSource(sortBuffer, tran, sortObserver, false, sortBufferMax);
1: 			rowSource = (ScanControllerRowSource)scan;
1: 
1: 			// The scan now owns the sort buffer
1: 			sortBuffer = null;
1: 		}
1: 		else
1: 		{
1: 			// Dump the rows in the sort buffer to a merge run.
1: 			long containerId = createMergeRun(tran, sortBuffer);
0: 			mergeRuns.addElement(new Long(containerId));
1: 
1: 			// If there are more merge runs than we can sort
1: 			// at once with our sort buffer, we have to reduce
1: 			// the number of merge runs
1: 			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
1: 				mergeRuns.size() > sortBuffer.capacity())	
1: 				multiStageMerge(tran);
1: 
1: 			// There are now few enough merge runs to sort
1: 			// at once, so create a rowSource for them.
1: 			MergeScanRowSource msRowSource = 
1: 				new MergeScanRowSource(this, tran, sortBuffer, mergeRuns, sortObserver, false);
1: 			if (!msRowSource.init(tran))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.SORT_COULD_NOT_INIT);
1:             }
1: 			scan = msRowSource;
1: 			rowSource = msRowSource;
1: 
1: 			// The scan now owns the sort buffer and merge runs.
1: 			sortBuffer = null;
1: 			mergeRuns = null;
1: 		}
1: 
1: 		// Ready to start retrieving rows.
1: 		this.state = STATE_SCANNING;
1: 
1: 		return rowSource;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	Drop the sort.
1: 	@see Sort#drop
1: 	**/
1: 	public void drop(TransactionController tran)
1:         throws StandardException
1: 	{
1: 		// Make sure the inserter is closed.  Note this
1: 		// will cause the callback to doneInserting()
1: 		// which will give us any in-progress merge
1: 		// runs, if there are any.
1: 		if (inserter != null)
0: 			inserter.close();
1: 		inserter = null;
1: 
1: 		// Make sure the scan is closed, if there is one.
1: 		// This will cause the callback to doneScanning().
1: 		if (scan != null)
1: 		{
1: 			scan.close();
1: 			scan = null;
1: 		}
1: 
1: 		// If we have a row set, get rid of it.
1: 		if (sortBuffer != null)
1: 		{
1: 			sortBuffer.close();
1: 			sortBuffer = null;
1: 		}
1: 
1: 		// Clean out the rest of the objects.
1: 		template = null;
1: 		columnOrdering = null;
1: 		sortObserver = null;
1: 
1: 		// If there are any merge runs, drop them.
1: 		dropMergeRuns((TransactionManager)tran);
1: 
1: 		// Whew!
1: 		state = STATE_CLOSED;
1: 	}
1: 
1: 
1: 	/*
1: 	 * Methods of MergeSort.  Arranged alphabetically.
1: 	 */
1: 
1: 	/**
0: 	Check the column ordering against the template, making
0: 	sure that each column is present in the template,
0: 	implements Orderable, and is not mentioned more than
0: 	once.  Intended to be called as part of a sanity check.
1: 	**/
0: 	protected boolean checkColumnOrdering(
1:     DataValueDescriptor[]   template, 
1:     ColumnOrdering          columnOrdering[])
1: 	{
1: 		// Allocate an array to check that each column mentioned only once.
1: 		int templateNColumns = template.length;
1: 		boolean seen[] = new boolean[templateNColumns];
1: 
1: 		// Check each column ordering.
0: 		for (int i = 0; i < columnOrdering.length; i++)
1: 		{
1: 			int colid = columnOrdering[i].getColumnId();
1: 
1: 			// Check that the column id is valid.
1: 			if (colid < 0 || colid >= templateNColumns)
1: 				return false;
1: 			
1: 			// Check that the column isn't mentioned more than once.
1: 			if (seen[colid])
1: 				return false;
1: 			seen[colid] = true;
1: 
1: 			Object columnVal = 
1:                 RowUtil.getColumn(template, (FormatableBitSet) null, colid);
1: 
0: 			if (!(columnVal instanceof Orderable))
1: 				return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	Check that the columns in the row agree with the columns
1: 	in the template, both in number and in type.
1: 	<p>
1: 	XXX (nat) Currently checks that the classes implementing
1: 	each column are the same -- is this right?
1: 	**/
1: 	void checkColumnTypes(DataValueDescriptor[] row)
1: 		throws StandardException
1: 	{
1: 		int nCols = row.length;
1: 		if (template.length != nCols)
1: 		{
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "template.length (" + template.length +
1:                     ") expected to be = to nCols (" +
1:                     nCols + ")");
1:             }
1:             throw StandardException.newException(
1:                     SQLState.SORT_TYPE_MISMATCH);
1: 		}
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             for (int colid = 0; colid < nCols; colid++)
1:             {
1:                 Object col1 = row[colid];
1:                 Object col2 = template[colid];
1:                 if (col1 == null)
1: 				{
1: 					SanityManager.THROWASSERT(
0: 						"col[" + colid + "]  is null");
1: 				}
1: 						
0:                 if (!(col1 instanceof CloneableObject))
1: 				{
1: 					SanityManager.THROWASSERT(
0: 						"col[" + colid + "] (" +col1.getClass().getName()+
0: 						") is not a CloneableObject.");
1: 				}
1: 
1:                 if (col1.getClass() != col2.getClass())
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "col1.getClass() (" + col1.getClass() +
1:                         ") expected to be the same as col2.getClass() (" +
1:                         col2.getClass() + ")");
1:                 }
1:             }
1:         }
1: 	}
1: 
0: 	int compare(
1:     DataValueDescriptor[] r1, 
1:     DataValueDescriptor[] r2)
1: 		throws StandardException
1: 	{
1: 		// Get the number of columns we have to compare.
1: 		int colsToCompare = this.columnOrdering.length;
1:         int r;
1: 
1: 		// Compare the columns specified in the column
1: 		// ordering array.
1:         for (int i = 0; i < colsToCompare; i++)
1:         {
1: 			// Get columns to compare.
1:             int colid = this.columnOrderingMap[i];
1: 
1: 			// If the columns don't compare equal, we're done.
1: 			// Return the sense of the comparison.
0: 			if ((r = r1[colid].compare(r2[colid])) 
1:                     != 0)
1: 			{
1: 				if (this.columnOrderingAscendingMap[i])
1: 					return r;
1: 				else
1: 					return -r;
1: 			}
1: 		}
1: 
1: 		// We made it through all the columns, and they must have
1: 		// all compared equal.  So return that the rows compare equal.
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	Go from the CLOSED to the INITIALIZED state.
1: 	**/
1: 	public void initialize(
1:     DataValueDescriptor[]   template,
1:     ColumnOrdering          columnOrdering[],
1:     SortObserver            sortObserver,
1:     boolean                 alreadyInOrder,
1:     long                    estimatedRows,
1:     int                     sortBufferMax)
1:         throws StandardException
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.ASSERT(state == STATE_CLOSED);
1:     	}
1: 
0: 		// Make sure the column ordering makes sense
1:         if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.ASSERT(checkColumnOrdering(template, columnOrdering),
1: 	    		"column ordering error");
1: 	    }
1: 
1: 		// Set user-defined parameters.
1: 		this.template = template;
1: 		this.columnOrdering = columnOrdering;
1: 		this.sortObserver = sortObserver;
1: 		this.alreadyInOrder = alreadyInOrder;
1: 
1:         // Cache results of columnOrdering calls, results are not allowed
1:         // to change throughout a sort.
1:         columnOrderingMap          = new int[columnOrdering.length];
1:         columnOrderingAscendingMap = new boolean[columnOrdering.length];
0:         for (int i = 0; i < columnOrdering.length; i++)
1:         {
1:             columnOrderingMap[i] = columnOrdering[i].getColumnId();
1:             columnOrderingAscendingMap[i] = columnOrdering[i].getIsAscending();
1:         }
1: 
1: 		// No inserter or scan yet.
1: 		this.inserter = null;
1: 		this.scan = null;
1: 
1: 		// We don't have any merge runs.
1: 		this.mergeRuns = null;
1: 		this.sortBuffer = null;
1: 		this.sortBufferMax = sortBufferMax;
1: 
1:         if (estimatedRows > sortBufferMax)
1: 			sortBufferMin = sortBufferMax;
1: 		else
1: 			sortBufferMin = (int)estimatedRows;
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("testSort"))
1:                 sortBufferMin = sortBufferMax;
1:         }
1: 
1: 		this.state = STATE_INITIALIZED;
1: 	}
1: 
1: 	/**
1: 	An inserter is closing.
1: 	**/
1: 	void doneInserting(MergeInserter inserter,
0: 		SortBuffer sortBuffer, Vector mergeRuns)
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.ASSERT(state == STATE_INSERTING);
1:     	}
1: 
1: 		this.sortBuffer = sortBuffer;
1: 		this.mergeRuns = mergeRuns;
1: 		this.inserter = null;
1: 
1: 		this.state = STATE_DONE_INSERTING;
1: 	}
1: 
1: 	void doneScanning(Scan scan, SortBuffer sortBuffer)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			// Make sure the scan we're getting back is the one we gave out
1: 
1: 			if (this.scan != scan)
1:     			SanityManager.THROWASSERT("this.scan = " + this.scan 
1: 										  + " scan = " + scan);
1: 		}
1: 
1: 		this.sortBuffer = sortBuffer;
1: 		this.scan = null;
1: 
1: 		this.state = STATE_DONE_SCANNING;
1: 	}
1: 
1: 	void doneScanning(Scan scan, SortBuffer sortBuffer,
0: 		Vector mergeRuns)
1: 	{
1: 		this.mergeRuns = mergeRuns;
1: 
1: 		doneScanning(scan, sortBuffer);
1: 	}
1: 
1: 
1: 	/**
1: 	Get rid of the merge runs, if there are any.
1: 	Must not cause any errors because it's called
1: 	during error processing.
1: 	**/
1: 	void dropMergeRuns(TransactionManager tran)
1: 	{
1: 		if (mergeRuns != null)
1: 		{
0: 			Enumeration e = mergeRuns.elements();
1: 
1: 			try 
1: 			{
1: 				Transaction rawTran = tran.getRawStoreXact();
1: 				long segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
1: 
1: 				while (e.hasMoreElements())
1: 				{
0: 					long containerId = ((Long) e.nextElement()).longValue();
1: 					rawTran.dropStreamContainer(segmentId, containerId);
1: 				}
1: 			}
1: 			catch (StandardException se)
1: 			{
1: 				// Ignore problems with dropping, worst case
1: 				// the raw store will clean up at reboot.
1: 			}
1: 			mergeRuns = null;
1: 		}
1: 	}
1: 
1: 	/* DEBUG (nat)
1: 	void printRunInfo(TransactionController tran)
1: 		throws StandardException
1: 	{
1: 		java.util.Enumeration e = mergeRuns.elements();
1: 		while (e.hasMoreElements())
1: 		{
1: 			long conglomid = ((Long) e.nextElement()).longValue();
1: 			ScanController sc = tran.openScan(conglomid, false,
1: 									false, null, null, 0, null,
1: 									null, 0);
1: 			System.out.println("Merge run: conglomid=" + conglomid);
1: 			while (sc.next())
1: 			{
1: 				sc.fetch(template);
1: 				System.out.println(template);
1: 			}
1: 			sc.close();
1: 		}
1: 	}
1: 	*/
1: 
1: 	private void multiStageMerge(TransactionManager tran)
1: 		throws StandardException
1: 	{
0: 		Enumeration e;
1: 		//int iterations = 0; // DEBUG (nat)
1: 		int maxMergeRuns = sortBuffer.capacity();
1: 
1: 		if (maxMergeRuns > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN)
1: 			maxMergeRuns = ExternalSortFactory.DEFAULT_MAX_MERGE_RUN;
1: 
0: 		Vector subset;
0: 		Vector leftovers;
1: 
1: 		while (mergeRuns.size() > maxMergeRuns)
1: 		{
1: 			// Move maxMergeRuns elements from the merge runs
1: 			// vector into a subset, leaving the rest.
0: 			subset = new Vector(maxMergeRuns);
0: 			leftovers = new Vector(mergeRuns.size() - maxMergeRuns);
1: 			e = mergeRuns.elements();
1: 			while (e.hasMoreElements())
1: 			{
1: 				Long containerId = (Long) e.nextElement();
1: 				if (subset.size() < maxMergeRuns)
1: 					subset.addElement(containerId);
1: 				else
1: 					leftovers.addElement(containerId);
1: 			}
1: 
1: 			/* DEBUG (nat)
1: 			iterations++;
1: 				System.out.println(subset.size() + " elements in subset");
1: 				System.out.println(leftovers.size() + " elements in leftovers");
1: 				System.out.println(mergeRuns.size() + " elements in mergeRuns");
1: 				System.out.println("maxMergeRuns is " + maxMergeRuns);
1: 				System.out.println("iterations = " + iterations);
1: 			if (subset.size() == 0)
1: 			{
1: 				System.exit(1);
1: 			}
1: 			*/
1: 
1: 			mergeRuns = leftovers;
1: 
1: 			// Open a merge scan on the subset.
1: 			MergeScanRowSource msRowSource = 
1: 				new MergeScanRowSource(this, tran, sortBuffer, subset, sortObserver, false);
1: 
1: 			if (!msRowSource.init(tran))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.SORT_COULD_NOT_INIT);
1:             }
1: 
1: 			// Create and open another temporary stream conglomerate
1: 			// which will become
1: 			// a merge run made up with the merged runs from the subset.
1: 			Transaction rawTran = tran.getRawStoreXact();
1: 			int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
1: 			long id = rawTran.addAndLoadStreamContainer(segmentId,
1: 				properties, msRowSource);
1: 
0: 			mergeRuns.addElement(new Long(id));
1: 
1: 			// Drop the conglomerates in the merge subset
1: 			e = subset.elements();
1: 			while (e.hasMoreElements())
1: 			{
1: 				Long containerId = (Long) e.nextElement();
1: 				rawTran.dropStreamContainer(segmentId, containerId.longValue());
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	Remove all the rows from the sort buffer and store them
1: 	in a temporary conglomerate.  The temporary conglomerate
1: 	is a "merge run".  Returns the container id of the
1: 	merge run.
1: 	**/
1: 	long createMergeRun(TransactionManager tran, SortBuffer sortBuffer)
1: 		throws StandardException
1: 	{
1: 		// this sort buffer is not a scan and is not tracked by any
1: 		// TransactionManager. 
1: 		SortBufferRowSource rowSource =
1: 			new SortBufferRowSource(sortBuffer, (TransactionManager)null, sortObserver, true, sortBufferMax); 
1: 
1: 		// Create a temporary stream conglomerate...
1: 		Transaction rawTran = tran.getRawStoreXact();  // get raw transaction
1: 		int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
1: 		long id = rawTran.addAndLoadStreamContainer(segmentId,
1: 			properties, rowSource);
1: 
1: 		// Don't close the sortBuffer, we just emptied it, the caller may reuse
1: 		// that sortBuffer for the next run.
1: 		rowSource = null;
1: 
1: 		return id;
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.sort
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.sort;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanControllerRowSource;
0: import org.apache.derby.iapi.store.access.conglomerate.Sort;
0: import org.apache.derby.iapi.store.access.conglomerate.SortFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.SortObserver;
0: import org.apache.derby.iapi.store.access.SortController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.StreamContainerHandle;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0: 
0:   A sort implementation which does the sort in-memory if it can,
0:   but which can do an external merge sort so that it can sort an
0:   arbitrary number of rows.
0: 
0: **/
0: 
0: public final class MergeSort implements Sort
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 	 * Fields
0: 	 */
0: 
0: 	/**
0: 	**/
0: 	static final int STATE_CLOSED = 0;
0: 
0: 	/**
0: 	**/
0: 	static final int STATE_INITIALIZED = 1;
0: 
0: 	/**
0: 	**/
0: 	static final int STATE_INSERTING = 2;
0: 
0: 	/**
0: 	**/
0: 	static final int STATE_DONE_INSERTING = 3;
0: 
0: 	/**
0: 	**/
0: 	static final int STATE_SCANNING = 4;
0: 
0: 	/**
0: 	**/
0: 	static final int STATE_DONE_SCANNING = 5;
0: 
0: 	/**
0: 	Maintains the current state of the sort as defined in
0: 	the preceding values.  Sorts start off and end up closed.
0: 	**/
0: 	protected int state = STATE_CLOSED;
0: 
0: 	/**
0: 	The template as passed in on create.  Valid when the state
0: 	is INITIALIZED through SCANNING, null otherwise.
0: 	**/
0: 	protected DataValueDescriptor[] template;
0: 
0: 	/**
0: 	The column ordering as passed in on create.  Valid when
0: 	the state is INITIALIZED through SCANNING, null otherwise.
0: 	May be null if there is no column ordering - this means
0: 	that all rows are considered to be duplicates, and the
0: 	sort will only emit a single row.
0: 	**/
0: 	protected ColumnOrdering columnOrdering[];
0: 
0: 	/**
0:     A lookup table to speed up lookup of a column associated with the i'th
0:     column to compare.  To find the column id to compare as the i'th column
0:     look in columnOrderingMap[i].
0: 	**/
0: 	protected int columnOrderingMap[];
0: 
0: 	/**
0:     A lookup table to speed up lookup of Ascending state of a column, 
0: 	**/
0: 	protected boolean columnOrderingAscendingMap[];
0: 
0: 	/**
0: 	The sort observer.  May be null.  Used as a callback.
0: 	**/
0: 	protected SortObserver sortObserver;
0: 
0: 	/**
0: 	Whether the rows are expected to be in order on insert,
0: 	as passed in on create.
0: 	**/
0: 	protected boolean alreadyInOrder;
0: 
0: 	/**
0: 	The inserter that's being used to insert rows into the sort.
0: 	This field is only valid when the state is INSERTING.
0: 	**/
0: 	protected MergeInserter inserter = null;
0: 
0: 	/**
0: 	The scan that's being used to return rows from the sort.
0: 	This field is only valid when the state is SCANNING.
0: 	**/
0: 	protected Scan scan = null;
0: 
0: 	/**
0: 	A vector of merge runs, produced by the MergeInserter.
0: 	Might be null if no merge runs were produced.
0: 	It is a vector of container ids.
0: 	**/
0: 	protected Vector mergeRuns = null;
0: 
0: 	/**
0: 	An ordered set of the leftover rows that didn't go
0: 	in the last merge run (might be all the rows if there
0: 	are no merge runs).
0: 	**/
0: 	protected SortBuffer sortBuffer = null;
0: 
0: 	/**
0: 	The maximum number of entries a sort buffer can hold.
0: 	**/
0: 	protected int sortBufferMax;
0: 
0: 	/**
0: 	The minimum number of entries a sort buffer can hold.
0: 	**/
0: 	protected int sortBufferMin;
0: 
0: 	/**
0: 	Properties for mergeSort
0: 	**/
0: 	static Properties properties = null;
0: 
0:     /**
0:     Static initializer for MergeSort, to initialize once the properties
0: 	for the sortBuffer.  
0: 	**/
0:     static
0:     {
0: 		properties = new Properties();
0: 		properties.put(RawStoreFactory.STREAM_FILE_BUFFER_SIZE_PARAMETER, "16384");
0:     }
0: 
0: 	/*
0: 	 * Methods of Sort
0: 	 */
0: 
0: 	/**
0: 	Open a sort controller.
0: 	<p>
0: 	This implementation only supports a single sort controller
0: 	per sort.
0: 	@see Sort#open
0: 	**/
0: 	public SortController open(TransactionManager tran)
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(state == STATE_INITIALIZED);
0: 
0: 		// Ready to start inserting rows.
0: 		state = STATE_INSERTING;
0: 
0: 		// Create and initialize an inserter.  When the caller
0: 		// closes it, it will call back to inserterIsClosed().
0: 		this.inserter = new MergeInserter();
0: 		if (this.inserter.initialize(this, tran) == false)
0:         {
0: 			throw StandardException.newException(SQLState.SORT_COULD_NOT_INIT);
0:         }
0: 
0: 		return this.inserter;
0: 	}
0: 
0: 	/**
0: 	Open a scan controller.
0: 	@see Sort#openSortScan
0: 	**/
0: 
0: 	public ScanController openSortScan(
0:     TransactionManager tran,
0:     boolean            hold)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(state == STATE_DONE_INSERTING);
0: 
0: 		if (mergeRuns == null || mergeRuns.size() == 0)
0: 		{
0: 			// There were no merge runs so we can just return
0: 			// the rows from the sort buffer.
0: 			scan = new SortBufferScan(this, tran, sortBuffer, hold);
0: 
0: 			// The scan now owns the sort buffer
0: 			sortBuffer = null;
0: 		}
0: 		else
0: 		{
0: 			// Dump the rows in the sort buffer to a merge run.
0: 			long containerId = createMergeRun(tran, sortBuffer);
0: 			mergeRuns.addElement(new Long(containerId));
0: 
0: 			// If there are more merge runs than we can sort
0: 			// at once with our sort buffer, we have to reduce
0: 			// the number of merge runs
0: 			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
0: 				mergeRuns.size() > sortBuffer.capacity())
0: 					multiStageMerge(tran);
0: 
0: 			// There are now few enough merge runs to sort
0: 			// at once, so create a scan for them.
0: 			MergeScan mscan = 
0:                 new MergeScan(
0:                     this, tran, sortBuffer, mergeRuns, sortObserver, hold);
0: 
0: 			if (!mscan.init(tran))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.SORT_COULD_NOT_INIT);
0:             }
0: 			scan = mscan;
0: 
0: 			// The scan now owns the sort buffer and merge runs.
0: 			sortBuffer = null;
0: 			mergeRuns = null;
0: 		}
0: 
0: 		// Ready to start retrieving rows.
0: 		this.state = STATE_SCANNING;
0: 
0: 		return scan;
0: 	}
0: 
0: 	/**
0: 	Open a row source to get rows out of the sorter.
0: 	@see Sort#openSortRowSource
0: 	**/
0: 	public ScanControllerRowSource openSortRowSource(TransactionManager tran)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(state == STATE_DONE_INSERTING);
0: 
0: 		ScanControllerRowSource rowSource = null;
0: 
0: 		if (mergeRuns == null || mergeRuns.size() == 0)
0: 		{
0: 			// There were no merge runs so we can just return
0: 			// the rows from the sort buffer.
0: 			scan = new SortBufferRowSource(sortBuffer, tran, sortObserver, false, sortBufferMax);
0: 			rowSource = (ScanControllerRowSource)scan;
0: 
0: 			// The scan now owns the sort buffer
0: 			sortBuffer = null;
0: 		}
0: 		else
0: 		{
0: 			// Dump the rows in the sort buffer to a merge run.
0: 			long containerId = createMergeRun(tran, sortBuffer);
0: 			mergeRuns.addElement(new Long(containerId));
0: 
0: 			// If there are more merge runs than we can sort
0: 			// at once with our sort buffer, we have to reduce
0: 			// the number of merge runs
0: 			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
0: 				mergeRuns.size() > sortBuffer.capacity())	
0: 				multiStageMerge(tran);
0: 
0: 			// There are now few enough merge runs to sort
0: 			// at once, so create a rowSource for them.
0: 			MergeScanRowSource msRowSource = 
0: 				new MergeScanRowSource(this, tran, sortBuffer, mergeRuns, sortObserver, false);
0: 			if (!msRowSource.init(tran))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.SORT_COULD_NOT_INIT);
0:             }
0: 			scan = msRowSource;
0: 			rowSource = msRowSource;
0: 
0: 			// The scan now owns the sort buffer and merge runs.
0: 			sortBuffer = null;
0: 			mergeRuns = null;
0: 		}
0: 
0: 		// Ready to start retrieving rows.
0: 		this.state = STATE_SCANNING;
0: 
0: 		return rowSource;
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	Drop the sort.
0: 	@see Sort#drop
0: 	**/
0: 	public void drop(TransactionController tran)
0:         throws StandardException
0: 	{
0: 		// Make sure the inserter is closed.  Note this
0: 		// will cause the callback to doneInserting()
0: 		// which will give us any in-progress merge
0: 		// runs, if there are any.
0: 		if (inserter != null)
0: 			inserter.close();
0: 		inserter = null;
0: 
0: 		// Make sure the scan is closed, if there is one.
0: 		// This will cause the callback to doneScanning().
0: 		if (scan != null)
0: 		{
0: 			scan.close();
0: 			scan = null;
0: 		}
0: 
0: 		// If we have a row set, get rid of it.
0: 		if (sortBuffer != null)
0: 		{
0: 			sortBuffer.close();
0: 			sortBuffer = null;
0: 		}
0: 
0: 		// Clean out the rest of the objects.
0: 		template = null;
0: 		columnOrdering = null;
0: 		sortObserver = null;
0: 
0: 		// If there are any merge runs, drop them.
0: 		dropMergeRuns((TransactionManager)tran);
0: 
0: 		// Whew!
0: 		state = STATE_CLOSED;
0: 	}
0: 
0: 
0: 	/*
0: 	 * Methods of MergeSort.  Arranged alphabetically.
0: 	 */
0: 
0: 	/**
0: 	Check the column ordering against the template, making
0: 	sure that each column is present in the template,
0: 	implements Orderable, and is not mentioned more than
0: 	once.  Intended to be called as part of a sanity check.
0: 	**/
0: 	protected boolean checkColumnOrdering(
0:     DataValueDescriptor[]   template, 
0:     ColumnOrdering          columnOrdering[])
0: 	{
0: 		// Allocate an array to check that each column mentioned only once.
0: 		int templateNColumns = template.length;
0: 		boolean seen[] = new boolean[templateNColumns];
0: 
0: 		// Check each column ordering.
0: 		for (int i = 0; i < columnOrdering.length; i++)
0: 		{
0: 			int colid = columnOrdering[i].getColumnId();
0: 
0: 			// Check that the column id is valid.
0: 			if (colid < 0 || colid >= templateNColumns)
0: 				return false;
0: 			
0: 			// Check that the column isn't mentioned more than once.
0: 			if (seen[colid])
0: 				return false;
0: 			seen[colid] = true;
0: 
0: 			Object columnVal = 
0:                 RowUtil.getColumn(template, (FormatableBitSet) null, colid);
0: 
0: 			if (!(columnVal instanceof Orderable))
0: 				return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	Check that the columns in the row agree with the columns
0: 	in the template, both in number and in type.
0: 	<p>
0: 	XXX (nat) Currently checks that the classes implementing
0: 	each column are the same -- is this right?
0: 	**/
0: 	void checkColumnTypes(DataValueDescriptor[] row)
0: 		throws StandardException
0: 	{
0: 		int nCols = row.length;
0: 		if (template.length != nCols)
0: 		{
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "template.length (" + template.length +
0:                     ") expected to be = to nCols (" +
0:                     nCols + ")");
0:             }
0:             throw StandardException.newException(
0:                     SQLState.SORT_TYPE_MISMATCH);
0: 		}
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             for (int colid = 0; colid < nCols; colid++)
0:             {
0:                 Object col1 = row[colid];
0:                 Object col2 = template[colid];
0:                 if (col1 == null)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"col[" + colid + "]  is null");
0: 				}
0: 						
0:                 if (!(col1 instanceof CloneableObject))
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"col[" + colid + "] (" +col1.getClass().getName()+
0: 						") is not a CloneableObject.");
0: 				}
0: 
0:                 if (col1.getClass() != col2.getClass())
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "col1.getClass() (" + col1.getClass() +
0:                         ") expected to be the same as col2.getClass() (" +
0:                         col2.getClass() + ")");
0:                 }
0:             }
0:         }
0: 	}
0: 
0: 	int compare(
0:     DataValueDescriptor[] r1, 
0:     DataValueDescriptor[] r2)
0: 		throws StandardException
0: 	{
0: 		// Get the number of columns we have to compare.
0: 		int colsToCompare = this.columnOrdering.length;
0:         int r;
0: 
0: 		// Compare the columns specified in the column
0: 		// ordering array.
0:         for (int i = 0; i < colsToCompare; i++)
0:         {
0: 			// Get columns to compare.
0:             int colid = this.columnOrderingMap[i];
0: 
0: 			// If the columns don't compare equal, we're done.
0: 			// Return the sense of the comparison.
0: 			if ((r = r1[colid].compare(r2[colid])) 
0:                     != 0)
0: 			{
0: 				if (this.columnOrderingAscendingMap[i])
0: 					return r;
0: 				else
0: 					return -r;
0: 			}
0: 		}
0: 
0: 		// We made it through all the columns, and they must have
0: 		// all compared equal.  So return that the rows compare equal.
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	Go from the CLOSED to the INITIALIZED state.
0: 	**/
0: 	public void initialize(
0:     DataValueDescriptor[]   template,
0:     ColumnOrdering          columnOrdering[],
0:     SortObserver            sortObserver,
0:     boolean                 alreadyInOrder,
0:     long                    estimatedRows,
0:     int                     sortBufferMax)
0:         throws StandardException
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.ASSERT(state == STATE_CLOSED);
0:     	}
0: 
0: 		// Make sure the column ordering makes sense
0:         if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.ASSERT(checkColumnOrdering(template, columnOrdering),
0: 	    		"column ordering error");
0: 	    }
0: 
0: 		// Set user-defined parameters.
0: 		this.template = template;
0: 		this.columnOrdering = columnOrdering;
0: 		this.sortObserver = sortObserver;
0: 		this.alreadyInOrder = alreadyInOrder;
0: 
0:         // Cache results of columnOrdering calls, results are not allowed
0:         // to change throughout a sort.
0:         columnOrderingMap          = new int[columnOrdering.length];
0:         columnOrderingAscendingMap = new boolean[columnOrdering.length];
0:         for (int i = 0; i < columnOrdering.length; i++)
0:         {
0:             columnOrderingMap[i] = columnOrdering[i].getColumnId();
0:             columnOrderingAscendingMap[i] = columnOrdering[i].getIsAscending();
0:         }
0: 
0: 		// No inserter or scan yet.
0: 		this.inserter = null;
0: 		this.scan = null;
0: 
0: 		// We don't have any merge runs.
0: 		this.mergeRuns = null;
0: 		this.sortBuffer = null;
0: 		this.sortBufferMax = sortBufferMax;
0: 
0:         if (estimatedRows > sortBufferMax)
0: 			sortBufferMin = sortBufferMax;
0: 		else
0: 			sortBufferMin = (int)estimatedRows;
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("testSort"))
0:                 sortBufferMin = sortBufferMax;
0:         }
0: 
0: 		this.state = STATE_INITIALIZED;
0: 	}
0: 
0: 	/**
0: 	An inserter is closing.
0: 	**/
0: 	void doneInserting(MergeInserter inserter,
0: 		SortBuffer sortBuffer, Vector mergeRuns)
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.ASSERT(state == STATE_INSERTING);
0:     	}
0: 
0: 		this.sortBuffer = sortBuffer;
0: 		this.mergeRuns = mergeRuns;
0: 		this.inserter = null;
0: 
0: 		this.state = STATE_DONE_INSERTING;
0: 	}
0: 
0: 	void doneScanning(Scan scan, SortBuffer sortBuffer)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			// Make sure the scan we're getting back is the one we gave out
0: 
0: 			if (this.scan != scan)
0:     			SanityManager.THROWASSERT("this.scan = " + this.scan 
0: 										  + " scan = " + scan);
0: 		}
0: 
0: 		this.sortBuffer = sortBuffer;
0: 		this.scan = null;
0: 
0: 		this.state = STATE_DONE_SCANNING;
0: 	}
0: 
0: 	void doneScanning(Scan scan, SortBuffer sortBuffer,
0: 		Vector mergeRuns)
0: 	{
0: 		this.mergeRuns = mergeRuns;
0: 
0: 		doneScanning(scan, sortBuffer);
0: 	}
0: 
0: 
0: 	/**
0: 	Get rid of the merge runs, if there are any.
0: 	Must not cause any errors because it's called
0: 	during error processing.
0: 	**/
0: 	void dropMergeRuns(TransactionManager tran)
0: 	{
0: 		if (mergeRuns != null)
0: 		{
0: 			Enumeration e = mergeRuns.elements();
0: 
0: 			try 
0: 			{
0: 				Transaction rawTran = tran.getRawStoreXact();
0: 				long segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
0: 
0: 				while (e.hasMoreElements())
0: 				{
0: 					long containerId = ((Long) e.nextElement()).longValue();
0: 					rawTran.dropStreamContainer(segmentId, containerId);
0: 				}
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				// Ignore problems with dropping, worst case
0: 				// the raw store will clean up at reboot.
0: 			}
0: 			mergeRuns = null;
0: 		}
0: 	}
0: 
0: 	/* DEBUG (nat)
0: 	void printRunInfo(TransactionController tran)
0: 		throws StandardException
0: 	{
0: 		java.util.Enumeration e = mergeRuns.elements();
0: 		while (e.hasMoreElements())
0: 		{
0: 			long conglomid = ((Long) e.nextElement()).longValue();
0: 			ScanController sc = tran.openScan(conglomid, false,
0: 									false, null, null, 0, null,
0: 									null, 0);
0: 			System.out.println("Merge run: conglomid=" + conglomid);
0: 			while (sc.next())
0: 			{
0: 				sc.fetch(template);
0: 				System.out.println(template);
0: 			}
0: 			sc.close();
0: 		}
0: 	}
0: 	*/
0: 
0: 	private void multiStageMerge(TransactionManager tran)
0: 		throws StandardException
0: 	{
0: 		Enumeration e;
0: 		//int iterations = 0; // DEBUG (nat)
0: 		int maxMergeRuns = sortBuffer.capacity();
0: 
0: 		if (maxMergeRuns > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN)
0: 			maxMergeRuns = ExternalSortFactory.DEFAULT_MAX_MERGE_RUN;
0: 
0: 		Vector subset;
0: 		Vector leftovers;
0: 
0: 		while (mergeRuns.size() > maxMergeRuns)
0: 		{
0: 			// Move maxMergeRuns elements from the merge runs
0: 			// vector into a subset, leaving the rest.
0: 			subset = new Vector(maxMergeRuns);
0: 			leftovers = new Vector(mergeRuns.size() - maxMergeRuns);
0: 			e = mergeRuns.elements();
0: 			while (e.hasMoreElements())
0: 			{
0: 				Long containerId = (Long) e.nextElement();
0: 				if (subset.size() < maxMergeRuns)
0: 					subset.addElement(containerId);
0: 				else
0: 					leftovers.addElement(containerId);
0: 			}
0: 
0: 			/* DEBUG (nat)
0: 			iterations++;
0: 				System.out.println(subset.size() + " elements in subset");
0: 				System.out.println(leftovers.size() + " elements in leftovers");
0: 				System.out.println(mergeRuns.size() + " elements in mergeRuns");
0: 				System.out.println("maxMergeRuns is " + maxMergeRuns);
0: 				System.out.println("iterations = " + iterations);
0: 			if (subset.size() == 0)
0: 			{
0: 				System.exit(1);
0: 			}
0: 			*/
0: 
0: 			mergeRuns = leftovers;
0: 
0: 			// Open a merge scan on the subset.
0: 			MergeScanRowSource msRowSource = 
0: 				new MergeScanRowSource(this, tran, sortBuffer, subset, sortObserver, false);
0: 
0: 			if (!msRowSource.init(tran))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.SORT_COULD_NOT_INIT);
0:             }
0: 
0: 			// Create and open another temporary stream conglomerate
0: 			// which will become
0: 			// a merge run made up with the merged runs from the subset.
0: 			Transaction rawTran = tran.getRawStoreXact();
0: 			int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
0: 			long id = rawTran.addAndLoadStreamContainer(segmentId,
0: 				properties, msRowSource);
0: 
0: 			mergeRuns.addElement(new Long(id));
0: 
0: 			// Drop the conglomerates in the merge subset
0: 			e = subset.elements();
0: 			while (e.hasMoreElements())
0: 			{
0: 				Long containerId = (Long) e.nextElement();
0: 				rawTran.dropStreamContainer(segmentId, containerId.longValue());
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	Remove all the rows from the sort buffer and store them
0: 	in a temporary conglomerate.  The temporary conglomerate
0: 	is a "merge run".  Returns the container id of the
0: 	merge run.
0: 	**/
0: 	long createMergeRun(TransactionManager tran, SortBuffer sortBuffer)
0: 		throws StandardException
0: 	{
0: 		// this sort buffer is not a scan and is not tracked by any
0: 		// TransactionManager. 
0: 		SortBufferRowSource rowSource =
0: 			new SortBufferRowSource(sortBuffer, (TransactionManager)null, sortObserver, true, sortBufferMax); 
0: 
0: 		// Create a temporary stream conglomerate...
0: 		Transaction rawTran = tran.getRawStoreXact();  // get raw transaction
0: 		int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
0: 		long id = rawTran.addAndLoadStreamContainer(segmentId,
0: 			properties, rowSource);
0: 
0: 		// Don't close the sortBuffer, we just emptied it, the caller may reuse
0: 		// that sortBuffer for the next run.
0: 		rowSource = null;
0: 
0: 		return id;
0: 	}
0: }
============================================================================