1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.log.Scan
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
6:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.log;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.raw.log.LogCounter;
1:eac0369: import org.apache.derby.impl.store.raw.log.LogRecord;
1:eac0369: import org.apache.derby.impl.store.raw.log.StreamLogScan;
1:eac0369: 
1:eac0369: import org.apache.derby.io.StorageRandomAccessFile;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:d609ee3: import org.apache.derby.iapi.store.raw.Loggable;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: 		Scan the the log which is implemented by a series of log files.n
1:eac0369: 		This log scan knows how to move across log file if it is positioned at
1:eac0369: 		the boundary of a log file and needs to getNextRecord.
1:eac0369: 
1:eac0369: 	<PRE>
1:eac0369: 	4 bytes - length of user data, i.e. N
1:eac0369: 	8 bytes - long representing log instant
1:eac0369: 	N bytes of supplied data
1:eac0369: 	4 bytes - length of user data, i.e. N
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369: */
1:eac0369: 
1:eac0369: public class Scan implements StreamLogScan {
1:eac0369: 
1:eac0369: 	// value for scanDirection
1:eac0369: 	public static final byte FORWARD = 1;
1:eac0369: 	public static final byte BACKWARD = 2;
1:eac0369: 	public static final byte BACKWARD_FROM_LOG_END = 4;
1:eac0369: 
1:eac0369: 	private StorageRandomAccessFile scan;		// an output stream to the log file
1:eac0369: 	private LogToFile logFactory; 		// log factory knows how to to skip
1:eac0369: 										// from log file to log file
1:eac0369: 
1:eac0369: 	private long currentLogFileNumber; 	// the log file the scan is currently on
1:eac0369: 
1:eac0369: 	private long currentLogFileLength;	// the size of the current log file
1:eac0369: 										// used only for FORWARD scan to determine when
1:eac0369: 										// to switch the next log file
1:eac0369: 
1:eac0369: 	private long knownGoodLogEnd; // For FORWARD scan only
1:eac0369: 								// during recovery, we need to determine the end
1:eac0369: 								// of the log.  Everytime a complete log record
1:eac0369: 								// is read in, knownGoodLogEnd is set to the
1:eac0369: 								// log instant of the next log record if it is
1:eac0369: 								// on the same log file.
1:eac0369: 								// 
1:eac0369: 								// only valid afer a successfull getNextRecord
1:eac0369: 								// on a FOWARD scan. 
1:eac0369: 
1:eac0369: 
1:eac0369: 	private long currentInstant;		// the log instant the scan is
1:eac0369: 										// currently on - only valid after a
1:eac0369: 										// successful getNextRecord
1:eac0369: 
1:eac0369: 	private long stopAt;				// scan until we find a log record whose 
1:eac0369: 										// log instance < stopAt if we scan BACKWARD
1:eac0369: 										// log instance > stopAt if we scan FORWARD
1:eac0369: 										// log instance >= stopAt if we scan FORWARD_FLUSHED
1:eac0369: 
1:eac0369: 
1:eac0369: 	private byte scanDirection; 		// BACKWARD or FORWARD
1:eac0369: 
1:eac0369: 	private boolean fuzzyLogEnd = false;   //get sets to true during forward scan
1:eac0369:  	                                      //for recovery, if there were
1:eac0369: 	                                      //partial writes at the end of the log before crash;
1:eac0369: 	                                      //during forward scan for recovery.
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    For backward scan, we expect a scan positioned at the end of the next log record.
1:eac0369: 		For forward scan, we expect a scan positioned at the beginning of the next log record.
1:eac0369: 
1:eac0369: 		For forward flushed scan, we expect stopAt to be the instant for the
1:eac0369: 		   first not-flushed log record. Like any forward scan, we expect a scan
1:eac0369: 		   positioned at the beginning of the next log record.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 		@exception IOException cannot access the log at the new position.
1:eac0369: 	*/
1:eac0369: 	public Scan(LogToFile logFactory, long startAt, LogInstant stopAt, byte direction)
1:eac0369: 		 throws IOException, StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(startAt != LogCounter.INVALID_LOG_INSTANT, 
1:eac0369: 								 "cannot start scan on an invalid log instant");
1:eac0369: 
1:eac0369: 		this.logFactory = logFactory;
1:eac0369: 		currentLogFileNumber = LogCounter.getLogFileNumber(startAt);
1:eac0369: 		currentLogFileLength = -1;
1:eac0369: 		knownGoodLogEnd = LogCounter.INVALID_LOG_INSTANT;// set at getNextRecord for FORWARD scan
1:eac0369: 		currentInstant = LogCounter.INVALID_LOG_INSTANT; // set at getNextRecord
1:eac0369: 		if (stopAt != null)
1:eac0369: 			this.stopAt = ((LogCounter) stopAt).getValueAsLong();
1:eac0369: 		else
1:eac0369: 			this.stopAt = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 
1:eac0369: 		switch(direction)
1:eac0369: 		{
1:eac0369: 		case FORWARD:
1:eac0369: 			scan =  logFactory.getLogFileAtPosition(startAt);
1:eac0369: 			scanDirection = FORWARD;
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				if (scan == null)
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"scan null at " + LogCounter.toDebugString(startAt));
1:eac0369: 
1:eac0369: 			// NOTE: just get the length of the file without syncing.
1:eac0369: 			// this only works because the only place forward scan is used
1:eac0369: 			// right now is on recovery redo and nothing is being added to 
1:eac0369: 			// the current log file.  When the forward scan is used for some
1:eac0369: 			// other purpose, need to sync access to the end of the log
1:eac0369: 			currentLogFileLength = scan.length();
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		case BACKWARD:
1:eac0369: 			// startAt is at the front of the log record, for backward
1:eac0369: 			// scan we need to be positioned at the end of the log record
1:eac0369: 			scan =  logFactory.getLogFileAtPosition(startAt);
1:eac0369: 			int logsize = scan.readInt();
1:eac0369: 
1:eac0369: 			// skip forward over the log record and all the overhead, but remember
1:eac0369: 			// we just read an int off the overhead
1:eac0369: 			scan.seek(scan.getFilePointer() + logsize + LogToFile.LOG_RECORD_OVERHEAD - 4);
1:eac0369: 			scanDirection = BACKWARD;
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		case BACKWARD_FROM_LOG_END:
1:eac0369: 			// startAt is at the end of the log, no need to skip the log record
1:eac0369: 			scan =  logFactory.getLogFileAtPosition(startAt);
1:eac0369: 			scanDirection = BACKWARD;
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of StreamLogScan
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read the next log record.
1:eac0369: 		Switching log to a previous log file if necessary, 
1:eac0369: 		Resize the input stream byte array if necessary.  
1:eac0369: 		@see StreamLogScan#getNextRecord
1:eac0369: 
1:eac0369: 		@return the next LogRecord, or null if the end of the
1:eac0369: 		scan has been reached.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public LogRecord getNextRecord(ArrayInputStream input, 
1:eac0369: 							 TransactionId tranId, 
1:eac0369: 							 int groupmask)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (scan == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(scanDirection != 0, "scan has been secretly closed!");
1:eac0369: 
1:eac0369: 		LogRecord lr = null;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (scanDirection == BACKWARD)
1:eac0369: 				lr = getNextRecordBackward(input, tranId, groupmask);
1:eac0369: 			else if (scanDirection == FORWARD)
1:eac0369: 				lr = getNextRecordForward(input, tranId, groupmask);
1:eac0369: 
1:eac0369: 			return lr;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				ioe.printStackTrace();
1:eac0369: 
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_CORRUPTED, ioe));
1:eac0369: 		}
1:eac0369: 		catch (ClassNotFoundException cnfe)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				cnfe.printStackTrace();
1:eac0369: 
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (lr == null)
1:eac0369: 				close();		// no more log record, close the scan
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read the previous log record.
1:eac0369: 		Switching log to a previous log file if necessary, 
1:eac0369: 		Resize the input stream byte array if necessary.  
1:eac0369: 		@see StreamLogScan#getNextRecord
1:eac0369: 
1:eac0369: 		Side effects include: 
1:eac0369: 				on a successful read, setting currentInstant.
1:eac0369: 				on a log file switch, setting currentLogFileNumber.
1:eac0369: 
1:eac0369: 		@return the previous LogRecord, or null if the end of the
1:eac0369: 		scan has been reached.
1:eac0369: 	*/
1:eac0369: 	private LogRecord getNextRecordBackward(ArrayInputStream input, 
1:eac0369: 									  TransactionId tranId,  
1:eac0369: 									  int groupmask) 
1:eac0369: 		 throws StandardException, IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(scanDirection == BACKWARD, "can only called by backward scan");
1:eac0369: 
1:eac0369: 		// scan is positioned just past the last byte of the record, or
1:eac0369: 		// right at the beginning of the file (end of the file header)
1:eac0369: 		// may need to switch log file
1:eac0369: 
1:eac0369: 		boolean candidate;
1:eac0369: 		// if we have filtering, peek at the group and/or the transaction id,
1:eac0369: 		// do them in one read rather than 2 reads.
1:eac0369: 		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
1:eac0369: 		if (tranId != null)
1:eac0369: 			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
1:eac0369: 
1:eac0369: 		int readAmount;			// the number of bytes actually read
1:eac0369: 
1:eac0369: 		LogRecord lr;
1:eac0369: 		long curpos = scan.getFilePointer();
1:eac0369: 
1:eac0369: 		do
1:eac0369: 		{
1:eac0369: 			// this log record is a candidate unless proven otherwise
1:eac0369: 			candidate = true; 
1:eac0369: 			lr = null;
1:eac0369: 			readAmount = -1;
1:eac0369: 
1:eac0369: 			if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
1:eac0369: 			{
1:eac0369: 				// don't go thru the trouble of switching log file if we
1:eac0369: 				// will have gone past stopAt
1:eac0369: 				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
1:eac0369: 					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                                 "stopping at " + currentLogFileNumber);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					return null;  // no more log record
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				// figure out where the last log record is in the previous
1:eac0369: 				// log file
1:eac0369: 				scan.seek(LogToFile.LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
1:eac0369: 				long previousLogInstant = scan.readLong();
1:eac0369: 				scan.close();
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(previousLogInstant != LogCounter.INVALID_LOG_INSTANT,
1:eac0369: 									 "scanning backward beyond the first log file");
1:eac0369: 					if (currentLogFileNumber != 
1:eac0369: 							LogCounter.getLogFileNumber(previousLogInstant) + 1)
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 						"scanning backward but get incorrect log file number " + 
1:eac0369: 						 "expected " + (currentLogFileNumber -1) + 
1:eac0369: 						 "get " +
1:eac0369: 						 LogCounter.getLogFileNumber(previousLogInstant));
1:eac0369: 
1:eac0369: 					SanityManager.ASSERT(LogCounter.getLogFilePosition(previousLogInstant) > 
1:eac0369: 									 LogToFile.LOG_FILE_HEADER_SIZE,
1:eac0369: 									 "scanning backward encounter completely empty log file");
1:eac0369: 
1:eac0369: 					SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369: 									"scanning backwards from log file " +
1:eac0369: 									currentLogFileNumber + ", switch to (" + 
1:eac0369: 									LogCounter.getLogFileNumber(previousLogInstant) + "," +
1:eac0369: 									LogCounter.getLogFilePosition(previousLogInstant) + ")"
1:eac0369: 									);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// log file switch, set this.currentLogFileNumber
1:eac0369: 				currentLogFileNumber = LogCounter.getLogFileNumber(previousLogInstant);
1:eac0369: 
1:eac0369: 				scan = logFactory.getLogFileAtPosition(previousLogInstant);
1:eac0369: 
1:eac0369: 				// scan is located right past the last byte of the last log
1:eac0369: 				// record in the previous log file.  currentLogFileNumber is
1:eac0369: 				// set.  We asserted that the scan is not located right at the
1:eac0369: 				// end of the file header, in other words, there is at least
1:eac0369: 				// one log record in this log file.
1:eac0369: 				curpos = scan.getFilePointer();
1:688dd0b: 
1:688dd0b: 				// if the log file happens to be empty skip and proceed. 
1:688dd0b: 				// ideally this case should never occur because log switch is
1:688dd0b: 				// not suppose to happen on an empty log file. 
1:688dd0b: 				// But it is safer to put following check incase if it ever
1:688dd0b: 				// happens to avoid any recovery issues. 
1:688dd0b: 				if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
1:688dd0b: 					continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			scan.seek(curpos - 4);
1:eac0369: 			int recordLength = scan.readInt(); // get the length after the log record
1:eac0369: 
1:eac0369: 			// calculate where this log record started.
1:eac0369: 			// include the eight bytes for the long log instant at the front
1:eac0369: 			// the four bytes of length in the front and the four bytes we just read
1:eac0369: 			long recordStartPosition = curpos - recordLength -
1:eac0369: 				LogToFile.LOG_RECORD_OVERHEAD; 
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (recordStartPosition < LogToFile.LOG_FILE_HEADER_SIZE)
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 								 "next position " + recordStartPosition +
1:eac0369: 								 " recordLength " + recordLength + 
1:eac0369: 								 " current file position " + scan.getFilePointer());
1:eac0369: 
1:eac0369: 				scan.seek(recordStartPosition);
1:eac0369: 
1:eac0369: 				// read the length before the log record and check it against the
1:eac0369: 				// length after the log record
1:eac0369: 				int checkLength = scan.readInt();
1:eac0369: 
1:eac0369: 				if (checkLength != recordLength)
1:eac0369: 				{
1:eac0369: 					long inst = LogCounter.makeLogInstantAsLong(currentLogFileNumber, recordStartPosition);
1:eac0369: 
1:eac0369: 					throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_RECORD_CORRUPTED, 
1:ce40a31:                             checkLength,
1:ce40a31:                             recordLength,
1:ce40a31:                             inst,
1:ce40a31:                             currentLogFileNumber));
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// skip over the length in insane
1:eac0369: 				scan.seek(recordStartPosition+4);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// scan is positioned just before the log instant
1:eac0369: 			// read the current log instant - this is the currentInstant if we have not
1:eac0369: 			// exceeded the scan limit
1:eac0369: 			currentInstant = scan.readLong();
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				// sanity check the current instant against the scan position
1:eac0369: 				if (LogCounter.getLogFileNumber(currentInstant) !=
1:eac0369: 					currentLogFileNumber ||
1:eac0369: 					LogCounter.getLogFilePosition(currentInstant) !=
1:eac0369: 					recordStartPosition)
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 								 "Wrong LogInstant on log record " +
1:eac0369: 								LogCounter.toDebugString(currentInstant) + 
1:eac0369: 								 " version real position (" +
1:eac0369: 								 currentLogFileNumber + "," +
1:eac0369: 								 recordStartPosition + ")");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
1:eac0369: 			// nothing more can be read.  Else check scan limit
1:eac0369: 			if (currentInstant < stopAt && stopAt != LogCounter.INVALID_LOG_INSTANT)
1:eac0369: 			{
1:eac0369: 				currentInstant = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 				return null;	// we went past the stopAt
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			byte[] data = input.getData();
1:eac0369: 
1:eac0369: 			if (data.length < recordLength)
1:eac0369: 			{
1:eac0369: 				// make a new array of sufficient size and reset the arrary
1:eac0369: 				// in the input stream
1:eac0369: 				data = new byte[recordLength];
1:eac0369: 				input.setData(data);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// If the log is encrypted, we must do the filtering after reading
1:eac0369: 			// and decrypting the record.
1:eac0369: 			if (logFactory.databaseEncrypted())
1:eac0369: 			{
1:eac0369: 				scan.readFully(data, 0, recordLength);
1:eac0369: 				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(len == recordLength);
1:eac0369: 				input.setLimit(0, recordLength);
1:eac0369: 			}
1:eac0369: 			else // no need to decrypt, only get the group and tid if we filter 
1:eac0369: 			{
1:eac0369: 				if (groupmask == 0 && tranId == null)
1:eac0369: 				{
1:eac0369: 					// no filter, get the whole thing
1:eac0369: 					scan.readFully(data, 0, recordLength);
1:eac0369: 					input.setLimit(0, recordLength);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					// Read only enough so that group and the tran id is in
1:eac0369: 					// the data buffer.  Group is stored as compressed int
1:eac0369: 					// and tran id is stored as who knows what.  read min
1:eac0369: 					// of peekAmount or recordLength
1:eac0369: 					readAmount = (recordLength > peekAmount) ?
1:eac0369: 						peekAmount : recordLength; 
1:eac0369: 
1:eac0369: 					// in the data buffer, we now have enough to peek
1:eac0369: 					scan.readFully(data, 0, readAmount);
1:eac0369: 					input.setLimit(0, readAmount);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			lr = (LogRecord) input.readObject();
1:d609ee3: 
1:d609ee3: 			// skip the checksum log records, there is no need to look at them 
1:d609ee3: 			// during backward scans. They are used only in forwardscan during recovery. 
1:d609ee3: 			if(lr.isChecksum())
1:eac0369: 			{
1:d609ee3: 				candidate = false; 
1:d609ee3: 			}else if (groupmask != 0 || tranId != null)
1:d609ee3: 			{
1:d609ee3: 
1:d609ee3: 				// skip the checksum log records  
1:d609ee3: 				if(lr.isChecksum())
1:d609ee3: 					candidate = false; 
1:d609ee3: 
1:d609ee3: 				if (candidate && groupmask != 0 && (groupmask & lr.group()) == 0)
1:eac0369: 					candidate = false; // no match, throw this log record out 
1:eac0369: 
1:eac0369: 				if (candidate && tranId != null)
1:eac0369: 				{
1:eac0369: 					TransactionId tid = lr.getTransactionId();
1:eac0369: 					if (!tid.equals(tranId)) // nomatch
1:eac0369: 						candidate = false; // throw this log record out
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// if this log record is not filtered out, we need to read
1:eac0369: 				// in the rest of the log record to the input buffer.
1:eac0369: 				// Except if it is an encrypted database, in which case the
1:eac0369: 				// entire log record have already be read in for
1:eac0369: 				// decryption.
1:eac0369: 				if (candidate && !logFactory.databaseEncrypted())
1:eac0369: 				{
1:eac0369: 					// read the rest of the log into the buffer
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(readAmount > 0);
1:eac0369: 
1:eac0369: 					if (readAmount < recordLength)
1:eac0369: 					{
1:eac0369: 						// Need to remember where we are because the log
1:eac0369: 						// record may have read part of it off the input
1:eac0369: 						// stream already and that position is lost when we
1:eac0369: 						// set limit again.
1:eac0369: 						int inputPosition = input.getPosition();
1:eac0369: 
1:eac0369: 						scan.readFully(data, readAmount,
1:eac0369: 									   recordLength-readAmount); 
1:eac0369: 
1:eac0369: 						input.setLimit(0, recordLength);
1:eac0369: 						input.setPosition(inputPosition);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// go back to the start of the log record so that the next time
1:eac0369: 			// this method is called, it is positioned right past the last byte
1:eac0369: 			// of the record.
1:eac0369: 			curpos = recordStartPosition;
1:eac0369: 			scan.seek(curpos);
1:eac0369: 
1:eac0369: 		} while (candidate == false);
1:eac0369: 
1:eac0369: 		return lr;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read the next log record.
1:eac0369: 		Switching log to a previous log file if necessary, 
1:eac0369: 		Resize the input stream byte array if necessary.  
1:eac0369: 		@see StreamLogScan#getNextRecord
1:eac0369: 
1:eac0369: 		Side effects include: 
1:eac0369: 				on a successful read, setting currentInstant, knownGoodLogEnd
1:eac0369: 				on a log file switch, setting currentLogFileNumber, currentLogFileLength.
1:eac0369: 				on detecting a fuzzy log end that needs clearing, it will call
1:eac0369: 				logFactory to clear the fuzzy log end.
1:eac0369: 
1:eac0369: 		@return the next LogRecord, or null if the end of the
1:eac0369: 		scan has been reached.
1:eac0369: 	*/
1:eac0369: 	private LogRecord getNextRecordForward(ArrayInputStream input, 
1:eac0369: 									 TransactionId tranId,  
1:eac0369: 									 int groupmask)
1:eac0369: 		 throws StandardException,  IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(scanDirection == FORWARD, "can only called by forward scan");
1:eac0369: 
1:eac0369: 		// NOTE:
1:eac0369: 		//
1:eac0369: 		// if forward scan, scan is positioned at the first byte of the
1:eac0369: 		// next record, or the end of file - note the the 'end of file'
1:eac0369: 		// is defined at the time the scan is initialized.  If we are
1:eac0369: 		// on the current log file, it may well have grown by now...
1:eac0369: 		//
1:eac0369: 		// This is not a problem in reality because the only forward
1:eac0369: 		// scan on the log now is recovery redo and the log does not
1:eac0369: 		// grow.  If in the future, a foward scan of the log is used
1:eac0369: 		// for some other reasons, need to keep this in mind.
1:eac0369: 		//
1:eac0369: 
1:eac0369: 		// first we need to make sure the entire log record is on the
1:eac0369: 		// log, or else this is a fuzzy log end.
1:eac0369: 
1:eac0369: 		// RESOLVE: can get this from knownGoodLogEnd if this is not the first
1:eac0369: 		// time getNext is called.  Probably just as fast to call
1:eac0369: 		// scan.getFilePointer though...
1:eac0369: 		long recordStartPosition = scan.getFilePointer();
1:eac0369: 
1:eac0369: 		boolean candidate;
1:eac0369: 
1:eac0369: 		// if we have filtering, peek at the group and/or the transaction id,
1:eac0369: 		// do them in one read rather than 2 reads.
1:eac0369: 		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
1:eac0369: 		if (tranId != null)
1:eac0369: 			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
1:eac0369: 
1:eac0369: 		int readAmount;			// the number of bytes actually read
1:eac0369: 
1:eac0369: 		LogRecord lr;
1:eac0369: 
1:eac0369: 		do
1:eac0369: 		{
1:eac0369: 			// this log record is a candidate unless proven otherwise
1:eac0369: 			candidate = true;
1:eac0369: 			lr = null;
1:eac0369: 			readAmount = -1;
1:eac0369: 
1:eac0369: 			// if we are not right at the end but this position + 4 is at
1:eac0369: 			// or exceeds the end, we know we don't have a complete log
1:eac0369: 			// record.  This is the log file and chalk it up as the fuzzy
1:eac0369: 			// end.
1:eac0369: 			if (recordStartPosition + 4 > currentLogFileLength)
1:eac0369: 			{
1:eac0369: 				// since there is no end of log file marker, we are at the
1:eac0369: 				// end of the log.
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                             "detected fuzzy log end on log file " + 
1:eac0369:                                 currentLogFileNumber + 
1:eac0369:                             " record start position " + recordStartPosition + 
1:eac0369:                             " file length " + currentLogFileLength);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 				
1:eac0369: 				//if  recordStartPosition == currentLogFileLength
1:eac0369: 				//there is NO fuzz, it just a properly ended log 
1:eac0369: 				//without the end marker. 
1:eac0369: 				if(recordStartPosition != currentLogFileLength)
1:eac0369: 					fuzzyLogEnd = true ;
1:eac0369: 
1:eac0369: 				// don't bother to write the end of log file marker because
1:eac0369: 				// if it is not overwritten by the next log record then
1:eac0369: 				// the next time the database is recovered it will come
1:eac0369: 				// back right here
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// read in the length before the log record
1:eac0369: 			int recordLength = scan.readInt();
1:eac0369: 
1:eac0369: 			while (recordLength == 0 || recordStartPosition + recordLength +
1:eac0369: 				   LogToFile.LOG_RECORD_OVERHEAD > currentLogFileLength) 
1:eac0369: 			{
1:eac0369: 				// if recordLength is zero or the log record goes beyond the
1:eac0369: 				// current file, then we have detected the end of a log file.
1:eac0369: 				//
1:eac0369: 				// If recordLength == 0 then we know that this log file has either
1:eac0369: 				// been properly switched or it had a 1/2 written log record which 
1:eac0369: 				// was subsequently cleared by clearFuzzyEnd.
1:eac0369: 				//
1:eac0369: 				// If recordLength != 0 but log record goes beyond the current log
1:eac0369: 				// file, we have detected a fuzzy end.  This is the last log file
1:eac0369: 				// since we will clear it by clearFuzzyEnd.
1:eac0369: 
1:eac0369: 				if (recordLength != 0) // this is a fuzzy log end
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "detected fuzzy log end on log file " + 
1:eac0369:                                     currentLogFileNumber + 
1:eac0369:                                 " record start position " + 
1:eac0369:                                     recordStartPosition + 
1:eac0369:                                 " file length " + currentLogFileLength + 
1:eac0369: 								" recordLength=" + recordLength );
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					fuzzyLogEnd = true;
1:eac0369: 					scan.close();
1:eac0369: 					scan = null;
1:eac0369: 
1:eac0369: 					return null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// recordLength == 0
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG) 
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                     {
1:eac0369:                         if (recordStartPosition + 4 == currentLogFileLength)
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                                 "detected proper log end on log file " + 
1:eac0369:                                 currentLogFileNumber);
1:eac0369:                         }
1:eac0369:                         else
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                                     "detected zapped log end on log file " + 
1:eac0369:                                         currentLogFileNumber +
1:eac0369:                                     " end marker at " + 
1:eac0369:                                         recordStartPosition + 
1:eac0369:                                     " real end at " + currentLogFileLength);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				// don't go thru the trouble of switching log file if we
1:eac0369: 				// have will have gone past stopAt if we want to stop here
1:eac0369: 				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
1:eac0369: 					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
1:eac0369: 				{
1:eac0369: 					return null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				//
1:eac0369: 				// we have a log end marker and we don't want to stop yet, switch
1:eac0369: 				// log file
1:eac0369: 				//
1:eac0369: 				scan.close();
1:eac0369: 
1:eac0369: 				// set this.currentLogFileNumber
1:eac0369: 				scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
1:eac0369: 				if (scan == null) // we have seen the last log file
1:eac0369: 				{
1:eac0369: 					return null;
1:eac0369: 				}
1:eac0369: 
1:2fb9556: 				// scan is position just past the log header
1:2fb9556: 				recordStartPosition = scan.getFilePointer();
1:2fb9556: 
1:2fb9556:                 // Verify that the header of the new log file refers
1:2fb9556:                 // to the end of the log record of the previous file
1:2fb9556:                 // (Rest of header has been verified by getLogFileAtBeginning)
1:2fb9556: 				scan.seek(LogToFile
1:2fb9556:                           .LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
1:2fb9556:                 long previousLogInstant = scan.readLong();
1:2fb9556:                 if (previousLogInstant != knownGoodLogEnd) {
1:2fb9556:                     // If there is a mismatch, something is wrong and
1:2fb9556:                     // we return null to stop the scan.  The same
1:2fb9556:                     // behavior occurs when getLogFileAtBeginning
1:2fb9556:                     // detects an error in the other fields of the header.
1:2fb9556:                     if (SanityManager.DEBUG) {
1:2fb9556:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG)) {
1:2fb9556:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:2fb9556:                                                 "log file " 
1:2fb9556:                                                 + currentLogFileNumber  
1:2fb9556:                                                 + ": previous log record: "
1:2fb9556:                                                 + previousLogInstant
1:2fb9556:                                                 + " known previous log record: "
1:2fb9556:                                                 + knownGoodLogEnd);
1:2fb9556:                         }
1:2fb9556:                     }
1:2fb9556:                     return null;
1:2fb9556: 				}
1:2fb9556: 
1:2fb9556: 
1:2fb9556: 				scan.seek(recordStartPosition);
1:2fb9556: 
1:eac0369: 				if (SanityManager.DEBUG) 
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                             "switched to next log file " + 
1:eac0369:                             currentLogFileNumber);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:2fb9556:                 // Advance knownGoodLogEnd to make sure that if this
1:2fb9556:                 // log file is the last log file and empty, logging
1:2fb9556:                 // continues in this file, not the old file.
1:2fb9556:                 knownGoodLogEnd = LogCounter.makeLogInstantAsLong
1:2fb9556:                     (currentLogFileNumber, recordStartPosition);
1:eac0369: 
1:eac0369: 				// set this.currentLogFileLength
1:eac0369: 				currentLogFileLength = scan.length();
1:eac0369: 
1:eac0369: 				if (recordStartPosition+4 >= currentLogFileLength) // empty log file
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                                 "log file " + currentLogFileNumber + 
1:eac0369:                                 " is empty");
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					return null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// we have successfully switched to the next log file.
1:eac0369: 				// scan is positioned just before the next log record
1:eac0369: 				// see if this one is written in entirety
1:eac0369: 				recordLength = scan.readInt();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// we know the entire log record is on this log file
1:eac0369: 
1:eac0369: 			// read the current log instant
1:eac0369: 			currentInstant = scan.readLong();
1:2fb9556: 
1:eac0369: 			/*check if the current instant happens is less than the last one. 
1:eac0369: 			 *This can happen if system crashed before writing the log instant
1:eac0369: 			 *completely. If the instant is partially written it will be less
1:eac0369: 			 *than the last one and should be the last record that was suppose to
1:eac0369: 			 *get written. Currentlt preallocated files are filled with zeros,
1:eac0369: 			 *this should hold good.
1:eac0369: 			 *Note: In case of Non-preallocated files earlier check with log
1:eac0369: 			 * file lengths should have found the end. But in prellocated files, log file
1:eac0369: 			 *length is not sufficiant to find the log end. This check 
1:eac0369: 			 *is must to find the end in preallocated log files. 
1:eac0369: 			 */
1:eac0369: 			if(currentInstant < knownGoodLogEnd)
1:eac0369: 			{
1:eac0369: 				fuzzyLogEnd = true ;
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// sanity check it 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (LogCounter.getLogFileNumber(currentInstant) !=
1:eac0369: 					currentLogFileNumber ||
1:eac0369: 					LogCounter.getLogFilePosition(currentInstant) !=
1:eac0369: 					recordStartPosition)
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 							  "Wrong LogInstant on log record " +
1:eac0369: 								LogCounter.toDebugString(currentInstant) + 
1:eac0369: 								 " version real position (" +
1:eac0369: 								 currentLogFileNumber + "," +
1:eac0369: 								 recordStartPosition + ")");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
1:eac0369: 			// nothing more can be read.  Else check scan limit
1:eac0369: 			if (stopAt != LogCounter.INVALID_LOG_INSTANT && currentInstant > stopAt)
1:eac0369: 			{
1:eac0369: 				currentInstant = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 				return null;			// we went past the stopAt
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// read in the log record
1:eac0369: 			byte[] data = input.getData();
1:eac0369: 
1:eac0369: 			if (data.length < recordLength)
1:eac0369: 			{
1:eac0369: 				// make a new array of sufficient size and reset the arrary
1:eac0369: 				// in the input stream
1:eac0369: 				data = new byte[recordLength];
1:eac0369: 				input.setData(data);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// If the log is encrypted, we must do the filtering after
1:eac0369: 			// reading and decryptiong the record.
1:eac0369: 
1:eac0369: 			if (logFactory.databaseEncrypted())
1:eac0369: 			{
1:eac0369: 				scan.readFully(data, 0, recordLength);
1:eac0369: 				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(len == recordLength);
1:eac0369: 
1:eac0369: 				input.setLimit(0, len);
1:eac0369: 			}
1:eac0369: 			else // no need to decrypt, only get the group and tid if we filter 
1:eac0369: 			{
1:eac0369: 				if (groupmask == 0 && tranId == null)
1:eac0369: 				{
1:eac0369: 					// no filter, get the whole thing
1:eac0369: 					scan.readFully(data, 0, recordLength);
1:eac0369: 					input.setLimit(0, recordLength);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					// Read only enough so that group and the tran id is in
1:eac0369: 					// the data buffer.  Group is stored as compressed int
1:eac0369: 					// and tran id is stored as who knows what.  read min
1:eac0369: 					// of peekAmount or recordLength
1:eac0369: 					readAmount = (recordLength > peekAmount) ?
1:eac0369: 						peekAmount : recordLength; 
1:eac0369: 
1:eac0369: 					// in the data buffer, we now have enough to peek
1:eac0369: 					scan.readFully(data, 0, readAmount);
1:eac0369: 					input.setLimit(0, readAmount);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			lr = (LogRecord) input.readObject();
2:eac0369: 			if (groupmask != 0 || tranId != null)
1:eac0369: 			{
2:eac0369: 				if (groupmask != 0 && (groupmask & lr.group()) == 0)
1:eac0369: 					candidate = false; // no match, throw this log record out 
1:eac0369: 
1:eac0369: 				if (candidate && tranId != null)
1:eac0369: 				{
1:eac0369: 					TransactionId tid = lr.getTransactionId();
1:eac0369: 					if (!tid.equals(tranId)) // nomatch
1:eac0369: 						candidate = false; // throw this log record out
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// if this log record is not filtered out, we need to read
1:eac0369: 				// in the rest of the log record to the input buffer.
1:eac0369: 				// Except if it is an encrypted database, in which case the
1:eac0369: 				// entire log record have already be read in for
1:eac0369: 				// decryption.
1:eac0369: 				if (candidate && !logFactory.databaseEncrypted())
1:eac0369: 				{
1:eac0369: 					// read the rest of the log into the buffer
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(readAmount > 0);
1:eac0369: 
1:eac0369: 					if (readAmount < recordLength)
1:eac0369: 					{
1:eac0369: 						// Need to remember where we are because the log
1:eac0369: 						// record may have read part of it off the input
1:eac0369: 						// stream already and that position is lost when we
1:eac0369: 						// set limit again.
1:eac0369: 						int inputPosition = input.getPosition();
1:eac0369: 
1:eac0369: 						scan.readFully(data, readAmount,
1:eac0369: 									   recordLength-readAmount); 
1:eac0369: 
1:eac0369: 						input.setLimit(0, recordLength);
1:eac0369: 						input.setPosition(inputPosition);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*check if the logrecord length written before and after the 
1:eac0369: 			 *log record are equal, if not the end of of the log is reached.
1:eac0369: 			 *This can happen if system crashed before writing the length field 
1:eac0369: 			 *in the end of the records completely. If the length is partially
1:eac0369: 			 *written or not written at all  it will not match with length written 
1:eac0369: 			 *in the beginning of the log record. Currentlt preallocated files
1:eac0369: 			 *are filled with zeros, log record length can never be zero; 
1:eac0369: 			 *if the lengths are not matching, end of the properly written log
1:eac0369: 			 *is reached.
1:eac0369: 			 *Note: In case of Non-preallocated files earlier fuzzy case check with log
1:eac0369: 			 * file lengths should have found the end. But in prellocated files, log file
1:eac0369: 			 *length is not sufficiant to find the log end. This check 
1:eac0369: 			 *is must to find the end in preallocated log files. 
1:eac0369: 			 */
1:eac0369: 			// read the length after the log record and check it against the
1:eac0369: 			// length before the log record, make sure we go to the correct
1:eac0369: 			// place for skipped log record.
1:eac0369: 			if (!candidate)
1:eac0369: 				scan.seek(recordStartPosition - 4);
1:eac0369: 			int checkLength = scan.readInt();
1:eac0369: 			if (checkLength != recordLength && checkLength < recordLength)
1:eac0369: 			{
1:eac0369: 
1:eac0369: 
1:eac0369: 				//lengh written in the end of the log record should be always
1:eac0369: 				//less then the length written in the beginning if the log
1:eac0369: 				//record was half written before the crash.
1:eac0369: 				if(checkLength < recordLength)
1:eac0369: 				{
1:eac0369: 					fuzzyLogEnd = true ;
1:eac0369: 					return null;
1:eac0369: 				}else
1:eac0369: 				{
1:eac0369: 				
1:eac0369: 					//If checklength > recordLength then it can be not be a partial write
1:eac0369: 					//probablly it is corrupted for some reason , this should never
1:eac0369: 					//happen throw error in debug mode. In non debug case , let's
1:eac0369: 					//hope it's only is wrong and system can proceed. 
1:eac0369: 						
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{	
1:eac0369: 						throw logFactory.markCorrupt
1:eac0369: 						(StandardException.newException(
1:eac0369: 							SQLState.LOG_RECORD_CORRUPTED, 
1:ce40a31:                             checkLength,
1:ce40a31:                             recordLength,
1:ce40a31:                             currentInstant,
1:ce40a31:                             currentLogFileNumber));
1:eac0369: 
1:eac0369: 					}
1:eac0369: 					
1:eac0369: 					//In non debug case, do nothing , let's hope it's only
1:eac0369: 					//length part that is incorrect and system can proceed. 
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// next record start position is right after this record
1:eac0369: 			recordStartPosition += recordLength + LogToFile.LOG_RECORD_OVERHEAD;
1:eac0369: 			knownGoodLogEnd = LogCounter.makeLogInstantAsLong
1:eac0369: 								(currentLogFileNumber, recordStartPosition);
1:2fb9556: 
1:2fb9556: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (recordStartPosition != scan.getFilePointer())
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 									 "calculated end " + recordStartPosition + 
1:eac0369: 									 " != real end " + scan.getFilePointer());
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// seek to the start of the next log record
1:eac0369: 				scan.seek(recordStartPosition);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// the scan is now positioned just past this log record and right
1:eac0369: 			// at the beginning of the next log record
1:d609ee3: 
1:d609ee3: 
1:d609ee3: 			/** if the current log record is a checksum log record then
1:d609ee3: 			 * using the information available in this record validate
1:d609ee3: 			 * that data in the log file by matching the checksum in 
1:d609ee3: 			 * checksum log record and by recalculating the checksum for the 
1:d609ee3: 			 * specified length of the data in the log file. cheksum values
1:d609ee3: 			 * should match unless the right was incomplete before the crash.
1:d609ee3: 			 */
1:d609ee3: 			if(lr.isChecksum())
1:d609ee3: 			{
1:d609ee3: 				// checksum log record should not be returned to the logger recovery redo
1:d609ee3: 				// routines, it is just used to identify the incomplete log writes.
1:d609ee3: 
1:d609ee3: 				candidate = false;
1:d609ee3: 				Loggable op = lr.getLoggable(); 
1:d609ee3: 				if (SanityManager.DEBUG)
1:d609ee3:                 {
1:d609ee3:                     if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY) ||
1:d609ee3:                         SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:d609ee3: 
1:d609ee3: 						SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:d609ee3: 											"scanned " + "Null" + " : " + op + 
1:d609ee3: 											" instant = " + 
1:d609ee3: 											LogCounter.toDebugString(currentInstant) + 
1:d609ee3: 											" logEnd = " +  LogCounter.toDebugString(knownGoodLogEnd));
1:d609ee3: 				}
1:d609ee3: 
1:d609ee3: 				ChecksumOperation clop = (ChecksumOperation) op;
1:d609ee3: 				int ckDataLength =  clop.getDataLength(); 
1:d609ee3: 				// resize the buffer to be size of checksum data length if required.
1:d609ee3: 				if (data.length < ckDataLength)
1:d609ee3: 				{
1:d609ee3: 					// make a new array of sufficient size and reset the arrary
1:d609ee3: 					// in the input stream
1:d609ee3: 					data = new byte[ckDataLength];
1:d609ee3: 					input.setData(data);
1:d609ee3: 					input.setLimit(0, ckDataLength);
1:d609ee3: 				}
1:d609ee3: 				
1:d609ee3: 				boolean validChecksum = false;
1:d609ee3: 				// check if the expected number of bytes by the checksum log
1:d609ee3: 				// record actually exist in the file and then verify if checksum
1:d609ee3: 				// is valid to identify any incomplete out of order writes.
1:d609ee3: 				if((recordStartPosition + ckDataLength) <= currentLogFileLength)
1:d609ee3: 				{
1:d609ee3: 					// read the data into the buffer
1:d609ee3: 					scan.readFully(data, 0, ckDataLength);
1:d609ee3: 					// verify the checksum 
1:d609ee3: 					if(clop.isChecksumValid(data, 0 , ckDataLength))
1:d609ee3: 						validChecksum = true;
1:d609ee3: 				}
1:d609ee3: 
1:d609ee3: 
1:d609ee3: 				if(!validChecksum)
1:d609ee3: 				{
1:d609ee3: 					// declare that the end of the transaction log is fuzzy, checksum is invalid
1:d609ee3: 					// only when the writes are incomplete; this can happen
1:d609ee3: 					// only when writes at the end of the log were partially
1:d609ee3: 					// written before the crash. 
1:d609ee3: 
1:d609ee3: 					if (SanityManager.DEBUG)
1:d609ee3:                     {
1:d609ee3:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:d609ee3:                         {
1:d609ee3:                             SanityManager.DEBUG(
1:d609ee3:                                 LogToFile.DBG_FLAG, 
1:d609ee3:                                 "detected fuzzy log end on log file while doing checksum checks " + 
1:d609ee3: 								currentLogFileNumber + 
1:d609ee3:                                 " checksum record start position " + recordStartPosition + 
1:d609ee3:                                 " file length " + currentLogFileLength + 
1:d609ee3: 								" checksumDataLength=" + ckDataLength);
1:d609ee3:                         }
1:d609ee3: 						
1:d609ee3: 					}
1:d609ee3: 					
1:d609ee3: 					fuzzyLogEnd = true;
1:d609ee3: 					scan.close();
1:d609ee3: 					scan = null;
1:d609ee3: 					return null;
1:d609ee3: 				}
1:d609ee3: 
1:d609ee3: 				// reset the scan to the start of the next log record
1:d609ee3: 				scan.seek(recordStartPosition);
1:d609ee3: 			}
1:d609ee3: 
1:d609ee3: 
1:eac0369: 		} while (candidate == false) ;
1:eac0369: 
1:eac0369: 		return lr;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Reset the scan to the given LogInstant.
1:eac0369: 
1:eac0369: 		@param instant the position to reset to
1:eac0369: 		@exception IOException scan cannot access the log at the new position.
1:94f158a: 		@exception StandardException standard Derby error policy
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void resetPosition(LogInstant instant) 
1:eac0369: 		 throws IOException, StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(instant != null);
1:eac0369: 
1:eac0369: 		long instant_long = ((LogCounter)instant).getValueAsLong();
1:eac0369: 
1:eac0369: 		if ((instant_long == LogCounter.INVALID_LOG_INSTANT) ||
1:eac0369: 			(stopAt != LogCounter.INVALID_LOG_INSTANT &&
1:eac0369: 			 (scanDirection == FORWARD && instant_long > stopAt) ||
1:eac0369: 			 (scanDirection == FORWARD && instant_long < stopAt)))
1:eac0369: 		{
1:eac0369: 			close();
1:eac0369: 
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.LOG_RESET_BEYOND_SCAN_LIMIT, 
1:eac0369:                     instant, new LogCounter(stopAt));
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			long fnum = ((LogCounter)instant).getLogFileNumber();
1:eac0369: 
1:eac0369: 			if (fnum != currentLogFileNumber)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG) 
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369: 										"Scan " + scanDirection +
1:eac0369: 										" resetting to " + instant + 
1:eac0369: 										" need to switch log from " + 
1:eac0369: 										currentLogFileNumber + " to " + fnum);
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				scan.close();
1:eac0369: 				scan = logFactory.getLogFileAtPosition(instant_long);
1:eac0369: 
1:eac0369: 				currentLogFileNumber= fnum;
1:eac0369: 
1:eac0369: 				if (scanDirection == FORWARD)
1:eac0369: 				{
1:eac0369: 					// NOTE: 
1:eac0369: 					//
1:eac0369: 					// just get the length of the file without syncing.
1:eac0369: 					// this only works because the only place forward scan is used
1:eac0369: 					// right now is on recovery redo and nothing is being added to 
1:eac0369: 					// the current log file.  When the forward scan is used for some
1:eac0369: 					// other purpose, need to sync access to the end of the log
1:eac0369: 					//
1:eac0369: 					currentLogFileLength = scan.length();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 
1:eac0369: 			{
1:eac0369: 				long fpos = ((LogCounter)instant).getLogFilePosition();
1:eac0369: 				scan.seek(fpos);
1:eac0369: 
1:eac0369: 				//
1:eac0369: 				//RESOLVE: Can this be optimized? Does it belong here.
1:eac0369: 				currentLogFileLength = scan.length();
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369: 										"Scan reset to " + instant);
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			currentInstant = instant_long;
1:eac0369: 
1:eac0369: 			//scan is being reset, it is possibly that, scan is doing a random 
1:eac0369: 			//access of the log file. set the knownGoodLogEnd to  the instant
1:eac0369: 			//scan 	is being reset to.
1:eac0369: 			//Note: reset gets called with undo forward scan for CLR processing during 
1:eac0369: 			//recovery, if this value is not reset checks to find the end of log 
1:eac0369: 			//getNextRecordForward() will fail because undoscan scans log file
1:eac0369: 			//back & forth to redo CLR's.
1:eac0369: 			knownGoodLogEnd = currentInstant;
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:eac0369:                         "Scan.getInstant reset to " + currentInstant + 
1:eac0369:                         LogCounter.toDebugString(currentInstant));
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the log instant (as an integer) the scan is currently on - this is the log
1:eac0369: 		instant of the log record that was returned by getNextRecord.
1:eac0369: 	*/
1:eac0369: 	public long getInstant()
1:eac0369: 	{
1:eac0369: 		return currentInstant;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the log instant at the end of the log record on the current
1:2fb9556: 		LogFile in the form of a log instant.
1:2fb9556:         After the scan has been closed, the end of the last log record will be
1:2fb9556:         returned except when the scan ended in an empty log file.  In that
1:2fb9556:         case, the start of this empty log file will be returned.  (This is
1:2fb9556:         done to make sure new log records are inserted into the newest log
1:2fb9556:         file.)
1:eac0369: 	*/
1:eac0369: 	public long getLogRecordEnd()
1:eac0369: 	{
1:eac0369: 		return knownGoodLogEnd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	   returns true if there is partially writen log records before the crash 
1:eac0369: 	   in the last log file. Partiall wrires are identified during forward 
1:eac0369: 	   redo scans for log recovery.
1:eac0369: 	*/
1:eac0369: 	public boolean isLogEndFuzzy()
1:eac0369: 	{
1:eac0369: 		return fuzzyLogEnd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the log instant the scan is currently on - this is the log
1:eac0369: 		instant of the log record that was returned by getNextRecord.
1:eac0369: 	*/
1:eac0369: 	public LogInstant getLogInstant()
1:eac0369: 	{
1:eac0369: 		if (currentInstant == LogCounter.INVALID_LOG_INSTANT)
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 			return new LogCounter(currentInstant);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close the scan.
1:eac0369: 	*/
1:eac0369: 	public void close()
1:eac0369: 	{
1:eac0369: 		if (scan != null)
1:eac0369: 		{
1:eac0369: 			try 
1:eac0369: 			{
1:eac0369: 				scan.close();
1:eac0369: 			}
1:eac0369: 			catch (IOException ioe)
1:eac0369: 			{}
1:eac0369: 
1:eac0369: 			scan = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		logFactory = null;
1:eac0369: 		currentLogFileNumber = -1;
1:eac0369: 		currentLogFileLength = -1;
1:2fb9556:         // Do not reset knownGoodLogEnd, it needs to be available after the
1:2fb9556:         // scan has closed.
1:eac0369: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 		stopAt = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 		scanDirection = 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                             checkLength,
1:                             recordLength,
1:                             inst,
1:                             currentLogFileNumber));
/////////////////////////////////////////////////////////////////////////
1:                             checkLength,
1:                             recordLength,
1:                             currentInstant,
1:                             currentLogFileNumber));
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException standard Derby error policy
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2fb9556
/////////////////////////////////////////////////////////////////////////
1: 				// scan is position just past the log header
1: 				recordStartPosition = scan.getFilePointer();
1: 
1:                 // Verify that the header of the new log file refers
1:                 // to the end of the log record of the previous file
1:                 // (Rest of header has been verified by getLogFileAtBeginning)
1: 				scan.seek(LogToFile
1:                           .LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
1:                 long previousLogInstant = scan.readLong();
1:                 if (previousLogInstant != knownGoodLogEnd) {
1:                     // If there is a mismatch, something is wrong and
1:                     // we return null to stop the scan.  The same
1:                     // behavior occurs when getLogFileAtBeginning
1:                     // detects an error in the other fields of the header.
1:                     if (SanityManager.DEBUG) {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG)) {
1:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                                                 "log file " 
1:                                                 + currentLogFileNumber  
1:                                                 + ": previous log record: "
1:                                                 + previousLogInstant
1:                                                 + " known previous log record: "
1:                                                 + knownGoodLogEnd);
1:                         }
1:                     }
1:                     return null;
1: 				}
1: 
1: 
1: 				scan.seek(recordStartPosition);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 // Advance knownGoodLogEnd to make sure that if this
1:                 // log file is the last log file and empty, logging
1:                 // continues in this file, not the old file.
1:                 knownGoodLogEnd = LogCounter.makeLogInstantAsLong
1:                     (currentLogFileNumber, recordStartPosition);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 		LogFile in the form of a log instant.
1:         After the scan has been closed, the end of the last log record will be
1:         returned except when the scan ended in an empty log file.  In that
1:         case, the start of this empty log file will be returned.  (This is
1:         done to make sure new log records are inserted into the newest log
1:         file.)
/////////////////////////////////////////////////////////////////////////
1:         // Do not reset knownGoodLogEnd, it needs to be available after the
1:         // scan has closed.
commit:d609ee3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.Loggable;
/////////////////////////////////////////////////////////////////////////
1: 
1: 			// skip the checksum log records, there is no need to look at them 
1: 			// during backward scans. They are used only in forwardscan during recovery. 
1: 			if(lr.isChecksum())
1: 				candidate = false; 
1: 			}else if (groupmask != 0 || tranId != null)
1: 			{
1: 
1: 				// skip the checksum log records  
1: 				if(lr.isChecksum())
1: 					candidate = false; 
1: 
1: 				if (candidate && groupmask != 0 && (groupmask & lr.group()) == 0)
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 			/** if the current log record is a checksum log record then
1: 			 * using the information available in this record validate
1: 			 * that data in the log file by matching the checksum in 
1: 			 * checksum log record and by recalculating the checksum for the 
1: 			 * specified length of the data in the log file. cheksum values
1: 			 * should match unless the right was incomplete before the crash.
1: 			 */
1: 			if(lr.isChecksum())
1: 			{
1: 				// checksum log record should not be returned to the logger recovery redo
1: 				// routines, it is just used to identify the incomplete log writes.
1: 
1: 				candidate = false;
1: 				Loggable op = lr.getLoggable(); 
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY) ||
1:                         SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1: 
1: 						SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1: 											"scanned " + "Null" + " : " + op + 
1: 											" instant = " + 
1: 											LogCounter.toDebugString(currentInstant) + 
1: 											" logEnd = " +  LogCounter.toDebugString(knownGoodLogEnd));
1: 				}
1: 
1: 				ChecksumOperation clop = (ChecksumOperation) op;
1: 				int ckDataLength =  clop.getDataLength(); 
1: 				// resize the buffer to be size of checksum data length if required.
1: 				if (data.length < ckDataLength)
1: 				{
1: 					// make a new array of sufficient size and reset the arrary
1: 					// in the input stream
1: 					data = new byte[ckDataLength];
1: 					input.setData(data);
1: 					input.setLimit(0, ckDataLength);
1: 				}
1: 				
1: 				boolean validChecksum = false;
1: 				// check if the expected number of bytes by the checksum log
1: 				// record actually exist in the file and then verify if checksum
1: 				// is valid to identify any incomplete out of order writes.
1: 				if((recordStartPosition + ckDataLength) <= currentLogFileLength)
1: 				{
1: 					// read the data into the buffer
1: 					scan.readFully(data, 0, ckDataLength);
1: 					// verify the checksum 
1: 					if(clop.isChecksumValid(data, 0 , ckDataLength))
1: 						validChecksum = true;
1: 				}
1: 
1: 
1: 				if(!validChecksum)
1: 				{
1: 					// declare that the end of the transaction log is fuzzy, checksum is invalid
1: 					// only when the writes are incomplete; this can happen
1: 					// only when writes at the end of the log were partially
1: 					// written before the crash. 
1: 
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "detected fuzzy log end on log file while doing checksum checks " + 
1: 								currentLogFileNumber + 
1:                                 " checksum record start position " + recordStartPosition + 
1:                                 " file length " + currentLogFileLength + 
1: 								" checksumDataLength=" + ckDataLength);
1:                         }
1: 						
1: 					}
1: 					
1: 					fuzzyLogEnd = true;
1: 					scan.close();
1: 					scan = null;
1: 					return null;
1: 				}
1: 
1: 				// reset the scan to the start of the next log record
1: 				scan.seek(recordStartPosition);
1: 			}
1: 
1: 
commit:688dd0b
/////////////////////////////////////////////////////////////////////////
1: 
1: 				// if the log file happens to be empty skip and proceed. 
1: 				// ideally this case should never occur because log switch is
1: 				// not suppose to happen on an empty log file. 
1: 				// But it is safer to put following check incase if it ever
1: 				// happens to avoid any recovery issues. 
1: 				if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
1: 					continue;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.log.Scan
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.log;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: 
1: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1: 
1: import org.apache.derby.impl.store.raw.log.LogCounter;
1: import org.apache.derby.impl.store.raw.log.LogRecord;
1: import org.apache.derby.impl.store.raw.log.StreamLogScan;
1: 
1: import org.apache.derby.io.StorageRandomAccessFile;
1: 
1: import java.io.IOException;
1: 
1: /**
1: 
1: 		Scan the the log which is implemented by a series of log files.n
1: 		This log scan knows how to move across log file if it is positioned at
1: 		the boundary of a log file and needs to getNextRecord.
1: 
1: 	<PRE>
1: 	4 bytes - length of user data, i.e. N
1: 	8 bytes - long representing log instant
1: 	N bytes of supplied data
1: 	4 bytes - length of user data, i.e. N
1: 	</PRE>
1: 
1: */
1: 
1: public class Scan implements StreamLogScan {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	// value for scanDirection
1: 	public static final byte FORWARD = 1;
1: 	public static final byte BACKWARD = 2;
1: 	public static final byte BACKWARD_FROM_LOG_END = 4;
1: 
1: 	private StorageRandomAccessFile scan;		// an output stream to the log file
1: 	private LogToFile logFactory; 		// log factory knows how to to skip
1: 										// from log file to log file
1: 
1: 	private long currentLogFileNumber; 	// the log file the scan is currently on
1: 
1: 	private long currentLogFileLength;	// the size of the current log file
1: 										// used only for FORWARD scan to determine when
1: 										// to switch the next log file
1: 
1: 	private long knownGoodLogEnd; // For FORWARD scan only
1: 								// during recovery, we need to determine the end
1: 								// of the log.  Everytime a complete log record
1: 								// is read in, knownGoodLogEnd is set to the
1: 								// log instant of the next log record if it is
1: 								// on the same log file.
1: 								// 
1: 								// only valid afer a successfull getNextRecord
1: 								// on a FOWARD scan. 
1: 
1: 
1: 	private long currentInstant;		// the log instant the scan is
1: 										// currently on - only valid after a
1: 										// successful getNextRecord
1: 
1: 	private long stopAt;				// scan until we find a log record whose 
1: 										// log instance < stopAt if we scan BACKWARD
1: 										// log instance > stopAt if we scan FORWARD
1: 										// log instance >= stopAt if we scan FORWARD_FLUSHED
1: 
1: 
1: 	private byte scanDirection; 		// BACKWARD or FORWARD
1: 
1: 	private boolean fuzzyLogEnd = false;   //get sets to true during forward scan
1:  	                                      //for recovery, if there were
1: 	                                      //partial writes at the end of the log before crash;
1: 	                                      //during forward scan for recovery.
1: 
1: 
1: 	/**
1: 	    For backward scan, we expect a scan positioned at the end of the next log record.
1: 		For forward scan, we expect a scan positioned at the beginning of the next log record.
1: 
1: 		For forward flushed scan, we expect stopAt to be the instant for the
1: 		   first not-flushed log record. Like any forward scan, we expect a scan
1: 		   positioned at the beginning of the next log record.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 		@exception IOException cannot access the log at the new position.
1: 	*/
1: 	public Scan(LogToFile logFactory, long startAt, LogInstant stopAt, byte direction)
1: 		 throws IOException, StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(startAt != LogCounter.INVALID_LOG_INSTANT, 
1: 								 "cannot start scan on an invalid log instant");
1: 
1: 		this.logFactory = logFactory;
1: 		currentLogFileNumber = LogCounter.getLogFileNumber(startAt);
1: 		currentLogFileLength = -1;
1: 		knownGoodLogEnd = LogCounter.INVALID_LOG_INSTANT;// set at getNextRecord for FORWARD scan
1: 		currentInstant = LogCounter.INVALID_LOG_INSTANT; // set at getNextRecord
1: 		if (stopAt != null)
1: 			this.stopAt = ((LogCounter) stopAt).getValueAsLong();
1: 		else
1: 			this.stopAt = LogCounter.INVALID_LOG_INSTANT;
1: 
1: 		switch(direction)
1: 		{
1: 		case FORWARD:
1: 			scan =  logFactory.getLogFileAtPosition(startAt);
1: 			scanDirection = FORWARD;
1: 
1: 			if (SanityManager.DEBUG)
1: 				if (scan == null)
1: 					SanityManager.THROWASSERT(
1: 						"scan null at " + LogCounter.toDebugString(startAt));
1: 
1: 			// NOTE: just get the length of the file without syncing.
1: 			// this only works because the only place forward scan is used
1: 			// right now is on recovery redo and nothing is being added to 
1: 			// the current log file.  When the forward scan is used for some
1: 			// other purpose, need to sync access to the end of the log
1: 			currentLogFileLength = scan.length();
1: 			break;
1: 
1: 		case BACKWARD:
1: 			// startAt is at the front of the log record, for backward
1: 			// scan we need to be positioned at the end of the log record
1: 			scan =  logFactory.getLogFileAtPosition(startAt);
1: 			int logsize = scan.readInt();
1: 
1: 			// skip forward over the log record and all the overhead, but remember
1: 			// we just read an int off the overhead
1: 			scan.seek(scan.getFilePointer() + logsize + LogToFile.LOG_RECORD_OVERHEAD - 4);
1: 			scanDirection = BACKWARD;
1: 			break;
1: 
1: 		case BACKWARD_FROM_LOG_END:
1: 			// startAt is at the end of the log, no need to skip the log record
1: 			scan =  logFactory.getLogFileAtPosition(startAt);
1: 			scanDirection = BACKWARD;
1: 			break;
1: 
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Methods of StreamLogScan
1: 	*/
1: 
1: 	/**
1: 		Read the next log record.
1: 		Switching log to a previous log file if necessary, 
1: 		Resize the input stream byte array if necessary.  
1: 		@see StreamLogScan#getNextRecord
1: 
1: 		@return the next LogRecord, or null if the end of the
1: 		scan has been reached.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public LogRecord getNextRecord(ArrayInputStream input, 
1: 							 TransactionId tranId, 
1: 							 int groupmask)
1: 		 throws StandardException
1: 	{
1: 		if (scan == null)
1: 			return null;
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(scanDirection != 0, "scan has been secretly closed!");
1: 
1: 		LogRecord lr = null;
1: 		try
1: 		{
1: 			if (scanDirection == BACKWARD)
1: 				lr = getNextRecordBackward(input, tranId, groupmask);
1: 			else if (scanDirection == FORWARD)
1: 				lr = getNextRecordForward(input, tranId, groupmask);
1: 
1: 			return lr;
1: 
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 				ioe.printStackTrace();
1: 
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_CORRUPTED, ioe));
1: 		}
1: 		catch (ClassNotFoundException cnfe)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 				cnfe.printStackTrace();
1: 
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1: 		}
1: 		finally
1: 		{
1: 			if (lr == null)
1: 				close();		// no more log record, close the scan
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 		Read the previous log record.
1: 		Switching log to a previous log file if necessary, 
1: 		Resize the input stream byte array if necessary.  
1: 		@see StreamLogScan#getNextRecord
1: 
1: 		Side effects include: 
1: 				on a successful read, setting currentInstant.
1: 				on a log file switch, setting currentLogFileNumber.
1: 
1: 		@return the previous LogRecord, or null if the end of the
1: 		scan has been reached.
1: 	*/
1: 	private LogRecord getNextRecordBackward(ArrayInputStream input, 
1: 									  TransactionId tranId,  
1: 									  int groupmask) 
1: 		 throws StandardException, IOException, ClassNotFoundException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(scanDirection == BACKWARD, "can only called by backward scan");
1: 
1: 		// scan is positioned just past the last byte of the record, or
1: 		// right at the beginning of the file (end of the file header)
1: 		// may need to switch log file
1: 
1: 		boolean candidate;
1: 		// if we have filtering, peek at the group and/or the transaction id,
1: 		// do them in one read rather than 2 reads.
1: 		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
1: 		if (tranId != null)
1: 			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
1: 
1: 		int readAmount;			// the number of bytes actually read
1: 
1: 		LogRecord lr;
1: 		long curpos = scan.getFilePointer();
1: 
1: 		do
1: 		{
1: 			// this log record is a candidate unless proven otherwise
1: 			candidate = true; 
1: 			lr = null;
1: 			readAmount = -1;
1: 
1: 			if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
1: 			{
1: 				// don't go thru the trouble of switching log file if we
1: 				// will have gone past stopAt
1: 				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
1: 					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
1: 				{
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                                 "stopping at " + currentLogFileNumber);
1:                         }
1:                     }
1: 
1: 					return null;  // no more log record
1: 				}
1: 				
1: 				// figure out where the last log record is in the previous
1: 				// log file
1: 				scan.seek(LogToFile.LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
1: 				long previousLogInstant = scan.readLong();
1: 				scan.close();
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(previousLogInstant != LogCounter.INVALID_LOG_INSTANT,
1: 									 "scanning backward beyond the first log file");
1: 					if (currentLogFileNumber != 
1: 							LogCounter.getLogFileNumber(previousLogInstant) + 1)
1: 						SanityManager.THROWASSERT(
1: 						"scanning backward but get incorrect log file number " + 
1: 						 "expected " + (currentLogFileNumber -1) + 
1: 						 "get " +
1: 						 LogCounter.getLogFileNumber(previousLogInstant));
1: 
1: 					SanityManager.ASSERT(LogCounter.getLogFilePosition(previousLogInstant) > 
1: 									 LogToFile.LOG_FILE_HEADER_SIZE,
1: 									 "scanning backward encounter completely empty log file");
1: 
1: 					SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1: 									"scanning backwards from log file " +
1: 									currentLogFileNumber + ", switch to (" + 
1: 									LogCounter.getLogFileNumber(previousLogInstant) + "," +
1: 									LogCounter.getLogFilePosition(previousLogInstant) + ")"
1: 									);
1: 				}
1: 
1: 				// log file switch, set this.currentLogFileNumber
1: 				currentLogFileNumber = LogCounter.getLogFileNumber(previousLogInstant);
1: 
1: 				scan = logFactory.getLogFileAtPosition(previousLogInstant);
1: 
1: 				// scan is located right past the last byte of the last log
1: 				// record in the previous log file.  currentLogFileNumber is
1: 				// set.  We asserted that the scan is not located right at the
1: 				// end of the file header, in other words, there is at least
1: 				// one log record in this log file.
1: 				curpos = scan.getFilePointer();
1: 			}
1: 
1: 			scan.seek(curpos - 4);
1: 			int recordLength = scan.readInt(); // get the length after the log record
1: 
1: 			// calculate where this log record started.
1: 			// include the eight bytes for the long log instant at the front
1: 			// the four bytes of length in the front and the four bytes we just read
1: 			long recordStartPosition = curpos - recordLength -
1: 				LogToFile.LOG_RECORD_OVERHEAD; 
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (recordStartPosition < LogToFile.LOG_FILE_HEADER_SIZE)
1: 					SanityManager.THROWASSERT(
1: 								 "next position " + recordStartPosition +
1: 								 " recordLength " + recordLength + 
1: 								 " current file position " + scan.getFilePointer());
1: 
1: 				scan.seek(recordStartPosition);
1: 
1: 				// read the length before the log record and check it against the
1: 				// length after the log record
1: 				int checkLength = scan.readInt();
1: 
1: 				if (checkLength != recordLength)
1: 				{
1: 					long inst = LogCounter.makeLogInstantAsLong(currentLogFileNumber, recordStartPosition);
1: 
1: 					throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_RECORD_CORRUPTED, 
0:                             new Long(checkLength),
0:                             new Long(recordLength),
0:                             new Long(inst),
0:                             new Long(currentLogFileNumber)));
1: 				}
1: 			}
1: 			else
1: 			{
1: 				// skip over the length in insane
1: 				scan.seek(recordStartPosition+4);
1: 			}
1: 
1: 			// scan is positioned just before the log instant
1: 			// read the current log instant - this is the currentInstant if we have not
1: 			// exceeded the scan limit
1: 			currentInstant = scan.readLong();
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				// sanity check the current instant against the scan position
1: 				if (LogCounter.getLogFileNumber(currentInstant) !=
1: 					currentLogFileNumber ||
1: 					LogCounter.getLogFilePosition(currentInstant) !=
1: 					recordStartPosition)
1: 					SanityManager.THROWASSERT(
1: 								 "Wrong LogInstant on log record " +
1: 								LogCounter.toDebugString(currentInstant) + 
1: 								 " version real position (" +
1: 								 currentLogFileNumber + "," +
1: 								 recordStartPosition + ")");
1: 			}
1: 
1: 
1: 			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
1: 			// nothing more can be read.  Else check scan limit
1: 			if (currentInstant < stopAt && stopAt != LogCounter.INVALID_LOG_INSTANT)
1: 			{
1: 				currentInstant = LogCounter.INVALID_LOG_INSTANT;
1: 				return null;	// we went past the stopAt
1: 			}
1: 
1: 
1: 			byte[] data = input.getData();
1: 
1: 			if (data.length < recordLength)
1: 			{
1: 				// make a new array of sufficient size and reset the arrary
1: 				// in the input stream
1: 				data = new byte[recordLength];
1: 				input.setData(data);
1: 			}
1: 
1: 			// If the log is encrypted, we must do the filtering after reading
1: 			// and decrypting the record.
1: 			if (logFactory.databaseEncrypted())
1: 			{
1: 				scan.readFully(data, 0, recordLength);
1: 				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(len == recordLength);
1: 				input.setLimit(0, recordLength);
1: 			}
1: 			else // no need to decrypt, only get the group and tid if we filter 
1: 			{
1: 				if (groupmask == 0 && tranId == null)
1: 				{
1: 					// no filter, get the whole thing
1: 					scan.readFully(data, 0, recordLength);
1: 					input.setLimit(0, recordLength);
1: 				}
1: 				else
1: 				{
1: 					// Read only enough so that group and the tran id is in
1: 					// the data buffer.  Group is stored as compressed int
1: 					// and tran id is stored as who knows what.  read min
1: 					// of peekAmount or recordLength
1: 					readAmount = (recordLength > peekAmount) ?
1: 						peekAmount : recordLength; 
1: 
1: 					// in the data buffer, we now have enough to peek
1: 					scan.readFully(data, 0, readAmount);
1: 					input.setLimit(0, readAmount);
1: 				}
1: 			}
1: 
1: 			lr = (LogRecord) input.readObject();
1: 			if (groupmask != 0 || tranId != null)
1: 			{
1: 				if (groupmask != 0 && (groupmask & lr.group()) == 0)
1: 					candidate = false; // no match, throw this log record out 
1: 
1: 				if (candidate && tranId != null)
1: 				{
1: 					TransactionId tid = lr.getTransactionId();
1: 					if (!tid.equals(tranId)) // nomatch
1: 						candidate = false; // throw this log record out
1: 				}
1: 
1: 				// if this log record is not filtered out, we need to read
1: 				// in the rest of the log record to the input buffer.
1: 				// Except if it is an encrypted database, in which case the
1: 				// entire log record have already be read in for
1: 				// decryption.
1: 				if (candidate && !logFactory.databaseEncrypted())
1: 				{
1: 					// read the rest of the log into the buffer
1: 					if (SanityManager.DEBUG)
1: 						SanityManager.ASSERT(readAmount > 0);
1: 
1: 					if (readAmount < recordLength)
1: 					{
1: 						// Need to remember where we are because the log
1: 						// record may have read part of it off the input
1: 						// stream already and that position is lost when we
1: 						// set limit again.
1: 						int inputPosition = input.getPosition();
1: 
1: 						scan.readFully(data, readAmount,
1: 									   recordLength-readAmount); 
1: 
1: 						input.setLimit(0, recordLength);
1: 						input.setPosition(inputPosition);
1: 					}
1: 				}
1: 			}
1: 
1: 			// go back to the start of the log record so that the next time
1: 			// this method is called, it is positioned right past the last byte
1: 			// of the record.
1: 			curpos = recordStartPosition;
1: 			scan.seek(curpos);
1: 
1: 		} while (candidate == false);
1: 
1: 		return lr;
1: 
1: 	}
1: 
1: 	/**
1: 		Read the next log record.
1: 		Switching log to a previous log file if necessary, 
1: 		Resize the input stream byte array if necessary.  
1: 		@see StreamLogScan#getNextRecord
1: 
1: 		Side effects include: 
1: 				on a successful read, setting currentInstant, knownGoodLogEnd
1: 				on a log file switch, setting currentLogFileNumber, currentLogFileLength.
1: 				on detecting a fuzzy log end that needs clearing, it will call
1: 				logFactory to clear the fuzzy log end.
1: 
1: 		@return the next LogRecord, or null if the end of the
1: 		scan has been reached.
1: 	*/
1: 	private LogRecord getNextRecordForward(ArrayInputStream input, 
1: 									 TransactionId tranId,  
1: 									 int groupmask)
1: 		 throws StandardException,  IOException, ClassNotFoundException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(scanDirection == FORWARD, "can only called by forward scan");
1: 
1: 		// NOTE:
1: 		//
1: 		// if forward scan, scan is positioned at the first byte of the
1: 		// next record, or the end of file - note the the 'end of file'
1: 		// is defined at the time the scan is initialized.  If we are
1: 		// on the current log file, it may well have grown by now...
1: 		//
1: 		// This is not a problem in reality because the only forward
1: 		// scan on the log now is recovery redo and the log does not
1: 		// grow.  If in the future, a foward scan of the log is used
1: 		// for some other reasons, need to keep this in mind.
1: 		//
1: 
1: 		// first we need to make sure the entire log record is on the
1: 		// log, or else this is a fuzzy log end.
1: 
1: 		// RESOLVE: can get this from knownGoodLogEnd if this is not the first
1: 		// time getNext is called.  Probably just as fast to call
1: 		// scan.getFilePointer though...
1: 		long recordStartPosition = scan.getFilePointer();
1: 
1: 		boolean candidate;
1: 
1: 		// if we have filtering, peek at the group and/or the transaction id,
1: 		// do them in one read rather than 2 reads.
1: 		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
1: 		if (tranId != null)
1: 			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
1: 
1: 		int readAmount;			// the number of bytes actually read
1: 
1: 		LogRecord lr;
1: 
1: 		do
1: 		{
1: 			// this log record is a candidate unless proven otherwise
1: 			candidate = true;
1: 			lr = null;
1: 			readAmount = -1;
1: 
1: 			// if we are not right at the end but this position + 4 is at
1: 			// or exceeds the end, we know we don't have a complete log
1: 			// record.  This is the log file and chalk it up as the fuzzy
1: 			// end.
1: 			if (recordStartPosition + 4 > currentLogFileLength)
1: 			{
1: 				// since there is no end of log file marker, we are at the
1: 				// end of the log.
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                     {
1:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                             "detected fuzzy log end on log file " + 
1:                                 currentLogFileNumber + 
1:                             " record start position " + recordStartPosition + 
1:                             " file length " + currentLogFileLength);
1:                     }
1:                 }
1: 				
1: 				//if  recordStartPosition == currentLogFileLength
1: 				//there is NO fuzz, it just a properly ended log 
1: 				//without the end marker. 
1: 				if(recordStartPosition != currentLogFileLength)
1: 					fuzzyLogEnd = true ;
1: 
1: 				// don't bother to write the end of log file marker because
1: 				// if it is not overwritten by the next log record then
1: 				// the next time the database is recovered it will come
1: 				// back right here
1: 				return null;
1: 			}
1: 
1: 			// read in the length before the log record
1: 			int recordLength = scan.readInt();
1: 
1: 			while (recordLength == 0 || recordStartPosition + recordLength +
1: 				   LogToFile.LOG_RECORD_OVERHEAD > currentLogFileLength) 
1: 			{
1: 				// if recordLength is zero or the log record goes beyond the
1: 				// current file, then we have detected the end of a log file.
1: 				//
1: 				// If recordLength == 0 then we know that this log file has either
1: 				// been properly switched or it had a 1/2 written log record which 
1: 				// was subsequently cleared by clearFuzzyEnd.
1: 				//
1: 				// If recordLength != 0 but log record goes beyond the current log
1: 				// file, we have detected a fuzzy end.  This is the last log file
1: 				// since we will clear it by clearFuzzyEnd.
1: 
1: 				if (recordLength != 0) // this is a fuzzy log end
1: 				{
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "detected fuzzy log end on log file " + 
1:                                     currentLogFileNumber + 
1:                                 " record start position " + 
1:                                     recordStartPosition + 
1:                                 " file length " + currentLogFileLength + 
1: 								" recordLength=" + recordLength );
1:                         }
1:                     }
1: 
1: 					fuzzyLogEnd = true;
1: 					scan.close();
1: 					scan = null;
1: 
1: 					return null;
1: 				}
1: 
1: 				// recordLength == 0
1: 
1: 				if (SanityManager.DEBUG) 
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                     {
1:                         if (recordStartPosition + 4 == currentLogFileLength)
1:                         {
1:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                                 "detected proper log end on log file " + 
1:                                 currentLogFileNumber);
1:                         }
1:                         else
1:                         {
1:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                                     "detected zapped log end on log file " + 
1:                                         currentLogFileNumber +
1:                                     " end marker at " + 
1:                                         recordStartPosition + 
1:                                     " real end at " + currentLogFileLength);
1:                         }
1:                     }
1: 				}
1: 				
1: 				// don't go thru the trouble of switching log file if we
1: 				// have will have gone past stopAt if we want to stop here
1: 				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
1: 					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
1: 				{
1: 					return null;
1: 				}
1: 
1: 				//
1: 				// we have a log end marker and we don't want to stop yet, switch
1: 				// log file
1: 				//
1: 				scan.close();
1: 
1: 				// set this.currentLogFileNumber
1: 				scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
1: 				if (scan == null) // we have seen the last log file
1: 				{
1: 					return null;
1: 				}
1: 
1: 				if (SanityManager.DEBUG) 
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                     {
1:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                             "switched to next log file " + 
1:                             currentLogFileNumber);
1:                     }
1:                 }
1: 
0: 				// scan is position just past the log header
0: 				recordStartPosition = scan.getFilePointer();
1: 
1: 				// set this.currentLogFileLength
1: 				currentLogFileLength = scan.length();
1: 
1: 				if (recordStartPosition+4 >= currentLogFileLength) // empty log file
1: 				{
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                                 "log file " + currentLogFileNumber + 
1:                                 " is empty");
1:                         }
1:                     }
1: 
0: 					// ideally, we would want to start writing on this new
0: 					// empty log file, but the scan is closed and there is
0: 					// no way to tell the difference between an empty log
0: 					// file and a log file which is not there.  We will be
0: 					// writing to the end of the previous log file instead
0: 					// but when we next switch the log, the empty log file
0: 					// will be written over.
1: 
1: 					return null;
1: 				}
1: 
1: 				// we have successfully switched to the next log file.
1: 				// scan is positioned just before the next log record
1: 				// see if this one is written in entirety
1: 				recordLength = scan.readInt();
1: 			}
1: 
1: 			// we know the entire log record is on this log file
1: 
1: 			// read the current log instant
1: 			currentInstant = scan.readLong();
1: 			
1: 			/*check if the current instant happens is less than the last one. 
1: 			 *This can happen if system crashed before writing the log instant
1: 			 *completely. If the instant is partially written it will be less
1: 			 *than the last one and should be the last record that was suppose to
1: 			 *get written. Currentlt preallocated files are filled with zeros,
1: 			 *this should hold good.
1: 			 *Note: In case of Non-preallocated files earlier check with log
1: 			 * file lengths should have found the end. But in prellocated files, log file
1: 			 *length is not sufficiant to find the log end. This check 
1: 			 *is must to find the end in preallocated log files. 
1: 			 */
1: 			if(currentInstant < knownGoodLogEnd)
1: 			{
1: 				fuzzyLogEnd = true ;
1: 				return null;
1: 			}
1: 
1: 			// sanity check it 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (LogCounter.getLogFileNumber(currentInstant) !=
1: 					currentLogFileNumber ||
1: 					LogCounter.getLogFilePosition(currentInstant) !=
1: 					recordStartPosition)
1: 					SanityManager.THROWASSERT(
1: 							  "Wrong LogInstant on log record " +
1: 								LogCounter.toDebugString(currentInstant) + 
1: 								 " version real position (" +
1: 								 currentLogFileNumber + "," +
1: 								 recordStartPosition + ")");
1: 			}
1: 
1: 
1: 			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
1: 			// nothing more can be read.  Else check scan limit
1: 			if (stopAt != LogCounter.INVALID_LOG_INSTANT && currentInstant > stopAt)
1: 			{
1: 				currentInstant = LogCounter.INVALID_LOG_INSTANT;
1: 				return null;			// we went past the stopAt
1: 			}
1: 
1: 			// read in the log record
1: 			byte[] data = input.getData();
1: 
1: 			if (data.length < recordLength)
1: 			{
1: 				// make a new array of sufficient size and reset the arrary
1: 				// in the input stream
1: 				data = new byte[recordLength];
1: 				input.setData(data);
1: 			}
1: 
1: 			// If the log is encrypted, we must do the filtering after
1: 			// reading and decryptiong the record.
1: 
1: 			if (logFactory.databaseEncrypted())
1: 			{
1: 				scan.readFully(data, 0, recordLength);
1: 				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(len == recordLength);
1: 
1: 				input.setLimit(0, len);
1: 			}
1: 			else // no need to decrypt, only get the group and tid if we filter 
1: 			{
1: 				if (groupmask == 0 && tranId == null)
1: 				{
1: 					// no filter, get the whole thing
1: 					scan.readFully(data, 0, recordLength);
1: 					input.setLimit(0, recordLength);
1: 				}
1: 				else
1: 				{
1: 					// Read only enough so that group and the tran id is in
1: 					// the data buffer.  Group is stored as compressed int
1: 					// and tran id is stored as who knows what.  read min
1: 					// of peekAmount or recordLength
1: 					readAmount = (recordLength > peekAmount) ?
1: 						peekAmount : recordLength; 
1: 
1: 					// in the data buffer, we now have enough to peek
1: 					scan.readFully(data, 0, readAmount);
1: 					input.setLimit(0, readAmount);
1: 				}
1: 			}
1: 
1: 			lr = (LogRecord) input.readObject();
1: 			if (groupmask != 0 || tranId != null)
1: 			{
1: 				if (groupmask != 0 && (groupmask & lr.group()) == 0)
1: 					candidate = false; // no match, throw this log record out 
1: 
1: 				if (candidate && tranId != null)
1: 				{
1: 					TransactionId tid = lr.getTransactionId();
1: 					if (!tid.equals(tranId)) // nomatch
1: 						candidate = false; // throw this log record out
1: 				}
1: 
1: 				// if this log record is not filtered out, we need to read
1: 				// in the rest of the log record to the input buffer.
1: 				// Except if it is an encrypted database, in which case the
1: 				// entire log record have already be read in for
1: 				// decryption.
1: 				if (candidate && !logFactory.databaseEncrypted())
1: 				{
1: 					// read the rest of the log into the buffer
1: 					if (SanityManager.DEBUG)
1: 						SanityManager.ASSERT(readAmount > 0);
1: 
1: 					if (readAmount < recordLength)
1: 					{
1: 						// Need to remember where we are because the log
1: 						// record may have read part of it off the input
1: 						// stream already and that position is lost when we
1: 						// set limit again.
1: 						int inputPosition = input.getPosition();
1: 
1: 						scan.readFully(data, readAmount,
1: 									   recordLength-readAmount); 
1: 
1: 						input.setLimit(0, recordLength);
1: 						input.setPosition(inputPosition);
1: 					}
1: 				}
1: 			}
1: 
1: 			/*check if the logrecord length written before and after the 
1: 			 *log record are equal, if not the end of of the log is reached.
1: 			 *This can happen if system crashed before writing the length field 
1: 			 *in the end of the records completely. If the length is partially
1: 			 *written or not written at all  it will not match with length written 
1: 			 *in the beginning of the log record. Currentlt preallocated files
1: 			 *are filled with zeros, log record length can never be zero; 
1: 			 *if the lengths are not matching, end of the properly written log
1: 			 *is reached.
1: 			 *Note: In case of Non-preallocated files earlier fuzzy case check with log
1: 			 * file lengths should have found the end. But in prellocated files, log file
1: 			 *length is not sufficiant to find the log end. This check 
1: 			 *is must to find the end in preallocated log files. 
1: 			 */
1: 			// read the length after the log record and check it against the
1: 			// length before the log record, make sure we go to the correct
1: 			// place for skipped log record.
1: 			if (!candidate)
1: 				scan.seek(recordStartPosition - 4);
1: 			int checkLength = scan.readInt();
1: 			if (checkLength != recordLength && checkLength < recordLength)
1: 			{
1: 
1: 
1: 				//lengh written in the end of the log record should be always
1: 				//less then the length written in the beginning if the log
1: 				//record was half written before the crash.
1: 				if(checkLength < recordLength)
1: 				{
1: 					fuzzyLogEnd = true ;
1: 					return null;
1: 				}else
1: 				{
1: 				
1: 					//If checklength > recordLength then it can be not be a partial write
1: 					//probablly it is corrupted for some reason , this should never
1: 					//happen throw error in debug mode. In non debug case , let's
1: 					//hope it's only is wrong and system can proceed. 
1: 						
1: 					if (SanityManager.DEBUG)
1: 					{	
1: 						throw logFactory.markCorrupt
1: 						(StandardException.newException(
1: 							SQLState.LOG_RECORD_CORRUPTED, 
0:                             new Long(checkLength),
0:                             new Long(recordLength),
0:                             new Long(currentInstant),
0:                             new Long(currentLogFileNumber)));
1: 
1: 					}
1: 					
1: 					//In non debug case, do nothing , let's hope it's only
1: 					//length part that is incorrect and system can proceed. 
1: 				}
1: 
1: 			}
1: 
1: 			// next record start position is right after this record
1: 			recordStartPosition += recordLength + LogToFile.LOG_RECORD_OVERHEAD;
1: 			knownGoodLogEnd = LogCounter.makeLogInstantAsLong
1: 								(currentLogFileNumber, recordStartPosition);
1: 			
1: 			
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (recordStartPosition != scan.getFilePointer())
1: 					SanityManager.THROWASSERT(
1: 									 "calculated end " + recordStartPosition + 
1: 									 " != real end " + scan.getFilePointer());
1: 			}
1: 			else
1: 			{
1: 				// seek to the start of the next log record
1: 				scan.seek(recordStartPosition);
1: 			}
1: 
1: 			// the scan is now positioned just past this log record and right
1: 			// at the beginning of the next log record
1: 		} while (candidate == false) ;
1: 
1: 		return lr;
1: 	}
1: 
1: 
1: 	/**
1: 		Reset the scan to the given LogInstant.
1: 
1: 		@param instant the position to reset to
1: 		@exception IOException scan cannot access the log at the new position.
0: 		@exception StandardException cloudscape standard error policy
1: 	*/
1: 
1: 	public void resetPosition(LogInstant instant) 
1: 		 throws IOException, StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(instant != null);
1: 
1: 		long instant_long = ((LogCounter)instant).getValueAsLong();
1: 
1: 		if ((instant_long == LogCounter.INVALID_LOG_INSTANT) ||
1: 			(stopAt != LogCounter.INVALID_LOG_INSTANT &&
1: 			 (scanDirection == FORWARD && instant_long > stopAt) ||
1: 			 (scanDirection == FORWARD && instant_long < stopAt)))
1: 		{
1: 			close();
1: 
1: 			throw StandardException.newException(
1:                     SQLState.LOG_RESET_BEYOND_SCAN_LIMIT, 
1:                     instant, new LogCounter(stopAt));
1: 		}
1: 		else
1: 		{
1: 			long fnum = ((LogCounter)instant).getLogFileNumber();
1: 
1: 			if (fnum != currentLogFileNumber)
1: 			{
1: 				if (SanityManager.DEBUG) 
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                     {
1:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1: 										"Scan " + scanDirection +
1: 										" resetting to " + instant + 
1: 										" need to switch log from " + 
1: 										currentLogFileNumber + " to " + fnum);
1:                     }
1: 				}
1: 
1: 				scan.close();
1: 				scan = logFactory.getLogFileAtPosition(instant_long);
1: 
1: 				currentLogFileNumber= fnum;
1: 
1: 				if (scanDirection == FORWARD)
1: 				{
1: 					// NOTE: 
1: 					//
1: 					// just get the length of the file without syncing.
1: 					// this only works because the only place forward scan is used
1: 					// right now is on recovery redo and nothing is being added to 
1: 					// the current log file.  When the forward scan is used for some
1: 					// other purpose, need to sync access to the end of the log
1: 					//
1: 					currentLogFileLength = scan.length();
1: 				}
1: 			}
1: 			else
1: 
1: 			{
1: 				long fpos = ((LogCounter)instant).getLogFilePosition();
1: 				scan.seek(fpos);
1: 
1: 				//
1: 				//RESOLVE: Can this be optimized? Does it belong here.
1: 				currentLogFileLength = scan.length();
1: 
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                     {
1:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1: 										"Scan reset to " + instant);
1:                     }
1: 				}
1: 			}
1: 
1: 
1: 			currentInstant = instant_long;
1: 
1: 			//scan is being reset, it is possibly that, scan is doing a random 
1: 			//access of the log file. set the knownGoodLogEnd to  the instant
1: 			//scan 	is being reset to.
1: 			//Note: reset gets called with undo forward scan for CLR processing during 
1: 			//recovery, if this value is not reset checks to find the end of log 
1: 			//getNextRecordForward() will fail because undoscan scans log file
1: 			//back & forth to redo CLR's.
1: 			knownGoodLogEnd = currentInstant;
1: 
1: 			if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                 {
1:                     SanityManager.DEBUG(LogToFile.DBG_FLAG, 
1:                         "Scan.getInstant reset to " + currentInstant + 
1:                         LogCounter.toDebugString(currentInstant));
1:                 }
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		Return the log instant (as an integer) the scan is currently on - this is the log
1: 		instant of the log record that was returned by getNextRecord.
1: 	*/
1: 	public long getInstant()
1: 	{
1: 		return currentInstant;
1: 	}
1: 
1: 	/**
1: 		Return the log instant at the end of the log record on the current
0: 		LogFile in the form of a log instant
1: 	*/
1: 	public long getLogRecordEnd()
1: 	{
1: 		return knownGoodLogEnd;
1: 	}
1: 
1: 	/**
1: 	   returns true if there is partially writen log records before the crash 
1: 	   in the last log file. Partiall wrires are identified during forward 
1: 	   redo scans for log recovery.
1: 	*/
1: 	public boolean isLogEndFuzzy()
1: 	{
1: 		return fuzzyLogEnd;
1: 	}
1: 
1: 	/**
1: 		Return the log instant the scan is currently on - this is the log
1: 		instant of the log record that was returned by getNextRecord.
1: 	*/
1: 	public LogInstant getLogInstant()
1: 	{
1: 		if (currentInstant == LogCounter.INVALID_LOG_INSTANT)
1: 			return null;
1: 		else
1: 			return new LogCounter(currentInstant);
1: 	}
1: 
1: 	/**
1: 		Close the scan.
1: 	*/
1: 	public void close()
1: 	{
1: 		if (scan != null)
1: 		{
1: 			try 
1: 			{
1: 				scan.close();
1: 			}
1: 			catch (IOException ioe)
1: 			{}
1: 
1: 			scan = null;
1: 		}
1: 
1: 		logFactory = null;
1: 		currentLogFileNumber = -1;
1: 		currentLogFileLength = -1;
0: 		knownGoodLogEnd = LogCounter.INVALID_LOG_INSTANT;
1: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
1: 		stopAt = LogCounter.INVALID_LOG_INSTANT;
1: 		scanDirection = 0;
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.log;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: 
0: import org.apache.derby.iapi.store.raw.xact.TransactionId;
0: 
0: import org.apache.derby.impl.store.raw.log.LogCounter;
0: import org.apache.derby.impl.store.raw.log.LogRecord;
0: import org.apache.derby.impl.store.raw.log.StreamLogScan;
0: 
0: import org.apache.derby.io.StorageRandomAccessFile;
0: 
0: import java.io.IOException;
0: 
0: /**
0: 
0: 		Scan the the log which is implemented by a series of log files.n
0: 		This log scan knows how to move across log file if it is positioned at
0: 		the boundary of a log file and needs to getNextRecord.
0: 
0: 	<PRE>
0: 	4 bytes - length of user data, i.e. N
0: 	8 bytes - long representing log instant
0: 	N bytes of supplied data
0: 	4 bytes - length of user data, i.e. N
0: 	</PRE>
0: 
0: */
0: 
0: public class Scan implements StreamLogScan {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	// value for scanDirection
0: 	public static final byte FORWARD = 1;
0: 	public static final byte BACKWARD = 2;
0: 	public static final byte BACKWARD_FROM_LOG_END = 4;
0: 
0: 	private StorageRandomAccessFile scan;		// an output stream to the log file
0: 	private LogToFile logFactory; 		// log factory knows how to to skip
0: 										// from log file to log file
0: 
0: 	private long currentLogFileNumber; 	// the log file the scan is currently on
0: 
0: 	private long currentLogFileLength;	// the size of the current log file
0: 										// used only for FORWARD scan to determine when
0: 										// to switch the next log file
0: 
0: 	private long knownGoodLogEnd; // For FORWARD scan only
0: 								// during recovery, we need to determine the end
0: 								// of the log.  Everytime a complete log record
0: 								// is read in, knownGoodLogEnd is set to the
0: 								// log instant of the next log record if it is
0: 								// on the same log file.
0: 								// 
0: 								// only valid afer a successfull getNextRecord
0: 								// on a FOWARD scan. 
0: 
0: 
0: 	private long currentInstant;		// the log instant the scan is
0: 										// currently on - only valid after a
0: 										// successful getNextRecord
0: 
0: 	private long stopAt;				// scan until we find a log record whose 
0: 										// log instance < stopAt if we scan BACKWARD
0: 										// log instance > stopAt if we scan FORWARD
0: 										// log instance >= stopAt if we scan FORWARD_FLUSHED
0: 
0: 
0: 	private byte scanDirection; 		// BACKWARD or FORWARD
0: 
0: 	private boolean fuzzyLogEnd = false;   //get sets to true during forward scan
0:  	                                      //for recovery, if there were
0: 	                                      //partial writes at the end of the log before crash;
0: 	                                      //during forward scan for recovery.
0: 
0: 
0: 	/**
0: 	    For backward scan, we expect a scan positioned at the end of the next log record.
0: 		For forward scan, we expect a scan positioned at the beginning of the next log record.
0: 
0: 		For forward flushed scan, we expect stopAt to be the instant for the
0: 		   first not-flushed log record. Like any forward scan, we expect a scan
0: 		   positioned at the beginning of the next log record.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 		@exception IOException cannot access the log at the new position.
0: 	*/
0: 	public Scan(LogToFile logFactory, long startAt, LogInstant stopAt, byte direction)
0: 		 throws IOException, StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(startAt != LogCounter.INVALID_LOG_INSTANT, 
0: 								 "cannot start scan on an invalid log instant");
0: 
0: 		this.logFactory = logFactory;
0: 		currentLogFileNumber = LogCounter.getLogFileNumber(startAt);
0: 		currentLogFileLength = -1;
0: 		knownGoodLogEnd = LogCounter.INVALID_LOG_INSTANT;// set at getNextRecord for FORWARD scan
0: 		currentInstant = LogCounter.INVALID_LOG_INSTANT; // set at getNextRecord
0: 		if (stopAt != null)
0: 			this.stopAt = ((LogCounter) stopAt).getValueAsLong();
0: 		else
0: 			this.stopAt = LogCounter.INVALID_LOG_INSTANT;
0: 
0: 		switch(direction)
0: 		{
0: 		case FORWARD:
0: 			scan =  logFactory.getLogFileAtPosition(startAt);
0: 			scanDirection = FORWARD;
0: 
0: 			if (SanityManager.DEBUG)
0: 				if (scan == null)
0: 					SanityManager.THROWASSERT(
0: 						"scan null at " + LogCounter.toDebugString(startAt));
0: 
0: 			// NOTE: just get the length of the file without syncing.
0: 			// this only works because the only place forward scan is used
0: 			// right now is on recovery redo and nothing is being added to 
0: 			// the current log file.  When the forward scan is used for some
0: 			// other purpose, need to sync access to the end of the log
0: 			currentLogFileLength = scan.length();
0: 			break;
0: 
0: 		case BACKWARD:
0: 			// startAt is at the front of the log record, for backward
0: 			// scan we need to be positioned at the end of the log record
0: 			scan =  logFactory.getLogFileAtPosition(startAt);
0: 			int logsize = scan.readInt();
0: 
0: 			// skip forward over the log record and all the overhead, but remember
0: 			// we just read an int off the overhead
0: 			scan.seek(scan.getFilePointer() + logsize + LogToFile.LOG_RECORD_OVERHEAD - 4);
0: 			scanDirection = BACKWARD;
0: 			break;
0: 
0: 		case BACKWARD_FROM_LOG_END:
0: 			// startAt is at the end of the log, no need to skip the log record
0: 			scan =  logFactory.getLogFileAtPosition(startAt);
0: 			scanDirection = BACKWARD;
0: 			break;
0: 
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Methods of StreamLogScan
0: 	*/
0: 
0: 	/**
0: 		Read the next log record.
0: 		Switching log to a previous log file if necessary, 
0: 		Resize the input stream byte array if necessary.  
0: 		@see StreamLogScan#getNextRecord
0: 
0: 		@return the next LogRecord, or null if the end of the
0: 		scan has been reached.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public LogRecord getNextRecord(ArrayInputStream input, 
0: 							 TransactionId tranId, 
0: 							 int groupmask)
0: 		 throws StandardException
0: 	{
0: 		if (scan == null)
0: 			return null;
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(scanDirection != 0, "scan has been secretly closed!");
0: 
0: 		LogRecord lr = null;
0: 		try
0: 		{
0: 			if (scanDirection == BACKWARD)
0: 				lr = getNextRecordBackward(input, tranId, groupmask);
0: 			else if (scanDirection == FORWARD)
0: 				lr = getNextRecordForward(input, tranId, groupmask);
0: 
0: 			return lr;
0: 
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 				ioe.printStackTrace();
0: 
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_CORRUPTED, ioe));
0: 		}
0: 		catch (ClassNotFoundException cnfe)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 				cnfe.printStackTrace();
0: 
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
0: 		}
0: 		finally
0: 		{
0: 			if (lr == null)
0: 				close();		// no more log record, close the scan
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 		Read the previous log record.
0: 		Switching log to a previous log file if necessary, 
0: 		Resize the input stream byte array if necessary.  
0: 		@see StreamLogScan#getNextRecord
0: 
0: 		Side effects include: 
0: 				on a successful read, setting currentInstant.
0: 				on a log file switch, setting currentLogFileNumber.
0: 
0: 		@return the previous LogRecord, or null if the end of the
0: 		scan has been reached.
0: 	*/
0: 	private LogRecord getNextRecordBackward(ArrayInputStream input, 
0: 									  TransactionId tranId,  
0: 									  int groupmask) 
0: 		 throws StandardException, IOException, ClassNotFoundException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(scanDirection == BACKWARD, "can only called by backward scan");
0: 
0: 		// scan is positioned just past the last byte of the record, or
0: 		// right at the beginning of the file (end of the file header)
0: 		// may need to switch log file
0: 
0: 		boolean candidate;
0: 		// if we have filtering, peek at the group and/or the transaction id,
0: 		// do them in one read rather than 2 reads.
0: 		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
0: 		if (tranId != null)
0: 			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
0: 
0: 		int readAmount;			// the number of bytes actually read
0: 
0: 		LogRecord lr;
0: 		long curpos = scan.getFilePointer();
0: 
0: 		do
0: 		{
0: 			// this log record is a candidate unless proven otherwise
0: 			candidate = true; 
0: 			lr = null;
0: 			readAmount = -1;
0: 
0: 			if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
0: 			{
0: 				// don't go thru the trouble of switching log file if we
0: 				// will have gone past stopAt
0: 				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
0: 					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
0: 				{
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                                 "stopping at " + currentLogFileNumber);
0:                         }
0:                     }
0: 
0: 					return null;  // no more log record
0: 				}
0: 				
0: 				// figure out where the last log record is in the previous
0: 				// log file
0: 				scan.seek(LogToFile.LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
0: 				long previousLogInstant = scan.readLong();
0: 				scan.close();
0: 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(previousLogInstant != LogCounter.INVALID_LOG_INSTANT,
0: 									 "scanning backward beyond the first log file");
0: 					if (currentLogFileNumber != 
0: 							LogCounter.getLogFileNumber(previousLogInstant) + 1)
0: 						SanityManager.THROWASSERT(
0: 						"scanning backward but get incorrect log file number " + 
0: 						 "expected " + (currentLogFileNumber -1) + 
0: 						 "get " +
0: 						 LogCounter.getLogFileNumber(previousLogInstant));
0: 
0: 					SanityManager.ASSERT(LogCounter.getLogFilePosition(previousLogInstant) > 
0: 									 LogToFile.LOG_FILE_HEADER_SIZE,
0: 									 "scanning backward encounter completely empty log file");
0: 
0: 					SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0: 									"scanning backwards from log file " +
0: 									currentLogFileNumber + ", switch to (" + 
0: 									LogCounter.getLogFileNumber(previousLogInstant) + "," +
0: 									LogCounter.getLogFilePosition(previousLogInstant) + ")"
0: 									);
0: 				}
0: 
0: 				// log file switch, set this.currentLogFileNumber
0: 				currentLogFileNumber = LogCounter.getLogFileNumber(previousLogInstant);
0: 
0: 				scan = logFactory.getLogFileAtPosition(previousLogInstant);
0: 
0: 				// scan is located right past the last byte of the last log
0: 				// record in the previous log file.  currentLogFileNumber is
0: 				// set.  We asserted that the scan is not located right at the
0: 				// end of the file header, in other words, there is at least
0: 				// one log record in this log file.
0: 				curpos = scan.getFilePointer();
0: 			}
0: 
0: 			scan.seek(curpos - 4);
0: 			int recordLength = scan.readInt(); // get the length after the log record
0: 
0: 			// calculate where this log record started.
0: 			// include the eight bytes for the long log instant at the front
0: 			// the four bytes of length in the front and the four bytes we just read
0: 			long recordStartPosition = curpos - recordLength -
0: 				LogToFile.LOG_RECORD_OVERHEAD; 
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (recordStartPosition < LogToFile.LOG_FILE_HEADER_SIZE)
0: 					SanityManager.THROWASSERT(
0: 								 "next position " + recordStartPosition +
0: 								 " recordLength " + recordLength + 
0: 								 " current file position " + scan.getFilePointer());
0: 
0: 				scan.seek(recordStartPosition);
0: 
0: 				// read the length before the log record and check it against the
0: 				// length after the log record
0: 				int checkLength = scan.readInt();
0: 
0: 				if (checkLength != recordLength)
0: 				{
0: 					long inst = LogCounter.makeLogInstantAsLong(currentLogFileNumber, recordStartPosition);
0: 
0: 					throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_RECORD_CORRUPTED, 
0:                             new Long(checkLength),
0:                             new Long(recordLength),
0:                             new Long(inst),
0:                             new Long(currentLogFileNumber)));
0: 				}
0: 			}
0: 			else
0: 			{
0: 				// skip over the length in insane
0: 				scan.seek(recordStartPosition+4);
0: 			}
0: 
0: 			// scan is positioned just before the log instant
0: 			// read the current log instant - this is the currentInstant if we have not
0: 			// exceeded the scan limit
0: 			currentInstant = scan.readLong();
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				// sanity check the current instant against the scan position
0: 				if (LogCounter.getLogFileNumber(currentInstant) !=
0: 					currentLogFileNumber ||
0: 					LogCounter.getLogFilePosition(currentInstant) !=
0: 					recordStartPosition)
0: 					SanityManager.THROWASSERT(
0: 								 "Wrong LogInstant on log record " +
0: 								LogCounter.toDebugString(currentInstant) + 
0: 								 " version real position (" +
0: 								 currentLogFileNumber + "," +
0: 								 recordStartPosition + ")");
0: 			}
0: 
0: 
0: 			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
0: 			// nothing more can be read.  Else check scan limit
0: 			if (currentInstant < stopAt && stopAt != LogCounter.INVALID_LOG_INSTANT)
0: 			{
0: 				currentInstant = LogCounter.INVALID_LOG_INSTANT;
0: 				return null;	// we went past the stopAt
0: 			}
0: 
0: 
0: 			byte[] data = input.getData();
0: 
0: 			if (data.length < recordLength)
0: 			{
0: 				// make a new array of sufficient size and reset the arrary
0: 				// in the input stream
0: 				data = new byte[recordLength];
0: 				input.setData(data);
0: 			}
0: 
0: 			// If the log is encrypted, we must do the filtering after reading
0: 			// and decrypting the record.
0: 			if (logFactory.databaseEncrypted())
0: 			{
0: 				scan.readFully(data, 0, recordLength);
0: 				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(len == recordLength);
0: 				input.setLimit(0, recordLength);
0: 			}
0: 			else // no need to decrypt, only get the group and tid if we filter 
0: 			{
0: 				if (groupmask == 0 && tranId == null)
0: 				{
0: 					// no filter, get the whole thing
0: 					scan.readFully(data, 0, recordLength);
0: 					input.setLimit(0, recordLength);
0: 				}
0: 				else
0: 				{
0: 					// Read only enough so that group and the tran id is in
0: 					// the data buffer.  Group is stored as compressed int
0: 					// and tran id is stored as who knows what.  read min
0: 					// of peekAmount or recordLength
0: 					readAmount = (recordLength > peekAmount) ?
0: 						peekAmount : recordLength; 
0: 
0: 					// in the data buffer, we now have enough to peek
0: 					scan.readFully(data, 0, readAmount);
0: 					input.setLimit(0, readAmount);
0: 				}
0: 			}
0: 
0: 			lr = (LogRecord) input.readObject();
0: 			if (groupmask != 0 || tranId != null)
0: 			{
0: 				if (groupmask != 0 && (groupmask & lr.group()) == 0)
0: 					candidate = false; // no match, throw this log record out 
0: 
0: 				if (candidate && tranId != null)
0: 				{
0: 					TransactionId tid = lr.getTransactionId();
0: 					if (!tid.equals(tranId)) // nomatch
0: 						candidate = false; // throw this log record out
0: 				}
0: 
0: 				// if this log record is not filtered out, we need to read
0: 				// in the rest of the log record to the input buffer.
0: 				// Except if it is an encrypted database, in which case the
0: 				// entire log record have already be read in for
0: 				// decryption.
0: 				if (candidate && !logFactory.databaseEncrypted())
0: 				{
0: 					// read the rest of the log into the buffer
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(readAmount > 0);
0: 
0: 					if (readAmount < recordLength)
0: 					{
0: 						// Need to remember where we are because the log
0: 						// record may have read part of it off the input
0: 						// stream already and that position is lost when we
0: 						// set limit again.
0: 						int inputPosition = input.getPosition();
0: 
0: 						scan.readFully(data, readAmount,
0: 									   recordLength-readAmount); 
0: 
0: 						input.setLimit(0, recordLength);
0: 						input.setPosition(inputPosition);
0: 					}
0: 				}
0: 			}
0: 
0: 			// go back to the start of the log record so that the next time
0: 			// this method is called, it is positioned right past the last byte
0: 			// of the record.
0: 			curpos = recordStartPosition;
0: 			scan.seek(curpos);
0: 
0: 		} while (candidate == false);
0: 
0: 		return lr;
0: 
0: 	}
0: 
0: 	/**
0: 		Read the next log record.
0: 		Switching log to a previous log file if necessary, 
0: 		Resize the input stream byte array if necessary.  
0: 		@see StreamLogScan#getNextRecord
0: 
0: 		Side effects include: 
0: 				on a successful read, setting currentInstant, knownGoodLogEnd
0: 				on a log file switch, setting currentLogFileNumber, currentLogFileLength.
0: 				on detecting a fuzzy log end that needs clearing, it will call
0: 				logFactory to clear the fuzzy log end.
0: 
0: 		@return the next LogRecord, or null if the end of the
0: 		scan has been reached.
0: 	*/
0: 	private LogRecord getNextRecordForward(ArrayInputStream input, 
0: 									 TransactionId tranId,  
0: 									 int groupmask)
0: 		 throws StandardException,  IOException, ClassNotFoundException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(scanDirection == FORWARD, "can only called by forward scan");
0: 
0: 		// NOTE:
0: 		//
0: 		// if forward scan, scan is positioned at the first byte of the
0: 		// next record, or the end of file - note the the 'end of file'
0: 		// is defined at the time the scan is initialized.  If we are
0: 		// on the current log file, it may well have grown by now...
0: 		//
0: 		// This is not a problem in reality because the only forward
0: 		// scan on the log now is recovery redo and the log does not
0: 		// grow.  If in the future, a foward scan of the log is used
0: 		// for some other reasons, need to keep this in mind.
0: 		//
0: 
0: 		// first we need to make sure the entire log record is on the
0: 		// log, or else this is a fuzzy log end.
0: 
0: 		// RESOLVE: can get this from knownGoodLogEnd if this is not the first
0: 		// time getNext is called.  Probably just as fast to call
0: 		// scan.getFilePointer though...
0: 		long recordStartPosition = scan.getFilePointer();
0: 
0: 		boolean candidate;
0: 
0: 		// if we have filtering, peek at the group and/or the transaction id,
0: 		// do them in one read rather than 2 reads.
0: 		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
0: 		if (tranId != null)
0: 			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
0: 
0: 		int readAmount;			// the number of bytes actually read
0: 
0: 		LogRecord lr;
0: 
0: 		do
0: 		{
0: 			// this log record is a candidate unless proven otherwise
0: 			candidate = true;
0: 			lr = null;
0: 			readAmount = -1;
0: 
0: 			// if we are not right at the end but this position + 4 is at
0: 			// or exceeds the end, we know we don't have a complete log
0: 			// record.  This is the log file and chalk it up as the fuzzy
0: 			// end.
0: 			if (recordStartPosition + 4 > currentLogFileLength)
0: 			{
0: 				// since there is no end of log file marker, we are at the
0: 				// end of the log.
0: 				if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                     {
0:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                             "detected fuzzy log end on log file " + 
0:                                 currentLogFileNumber + 
0:                             " record start position " + recordStartPosition + 
0:                             " file length " + currentLogFileLength);
0:                     }
0:                 }
0: 				
0: 				//if  recordStartPosition == currentLogFileLength
0: 				//there is NO fuzz, it just a properly ended log 
0: 				//without the end marker. 
0: 				if(recordStartPosition != currentLogFileLength)
0: 					fuzzyLogEnd = true ;
0: 
0: 				// don't bother to write the end of log file marker because
0: 				// if it is not overwritten by the next log record then
0: 				// the next time the database is recovered it will come
0: 				// back right here
0: 				return null;
0: 			}
0: 
0: 			// read in the length before the log record
0: 			int recordLength = scan.readInt();
0: 
0: 			while (recordLength == 0 || recordStartPosition + recordLength +
0: 				   LogToFile.LOG_RECORD_OVERHEAD > currentLogFileLength) 
0: 			{
0: 				// if recordLength is zero or the log record goes beyond the
0: 				// current file, then we have detected the end of a log file.
0: 				//
0: 				// If recordLength == 0 then we know that this log file has either
0: 				// been properly switched or it had a 1/2 written log record which 
0: 				// was subsequently cleared by clearFuzzyEnd.
0: 				//
0: 				// If recordLength != 0 but log record goes beyond the current log
0: 				// file, we have detected a fuzzy end.  This is the last log file
0: 				// since we will clear it by clearFuzzyEnd.
0: 
0: 				if (recordLength != 0) // this is a fuzzy log end
0: 				{
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "detected fuzzy log end on log file " + 
0:                                     currentLogFileNumber + 
0:                                 " record start position " + 
0:                                     recordStartPosition + 
0:                                 " file length " + currentLogFileLength + 
0: 								" recordLength=" + recordLength );
0:                         }
0:                     }
0: 
0: 					fuzzyLogEnd = true;
0: 					scan.close();
0: 					scan = null;
0: 
0: 					return null;
0: 				}
0: 
0: 				// recordLength == 0
0: 
0: 				if (SanityManager.DEBUG) 
0:                 {
0:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                     {
0:                         if (recordStartPosition + 4 == currentLogFileLength)
0:                         {
0:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                                 "detected proper log end on log file " + 
0:                                 currentLogFileNumber);
0:                         }
0:                         else
0:                         {
0:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                                     "detected zapped log end on log file " + 
0:                                         currentLogFileNumber +
0:                                     " end marker at " + 
0:                                         recordStartPosition + 
0:                                     " real end at " + currentLogFileLength);
0:                         }
0:                     }
0: 				}
0: 				
0: 				// don't go thru the trouble of switching log file if we
0: 				// have will have gone past stopAt if we want to stop here
0: 				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
0: 					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
0: 				{
0: 					return null;
0: 				}
0: 
0: 				//
0: 				// we have a log end marker and we don't want to stop yet, switch
0: 				// log file
0: 				//
0: 				scan.close();
0: 
0: 				// set this.currentLogFileNumber
0: 				scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
0: 				if (scan == null) // we have seen the last log file
0: 				{
0: 					return null;
0: 				}
0: 
0: 				if (SanityManager.DEBUG) 
0:                 {
0:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                     {
0:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                             "switched to next log file " + 
0:                             currentLogFileNumber);
0:                     }
0:                 }
0: 
0: 				// scan is position just past the log header
0: 				recordStartPosition = scan.getFilePointer();
0: 
0: 				// set this.currentLogFileLength
0: 				currentLogFileLength = scan.length();
0: 
0: 				if (recordStartPosition+4 >= currentLogFileLength) // empty log file
0: 				{
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                                 "log file " + currentLogFileNumber + 
0:                                 " is empty");
0:                         }
0:                     }
0: 
0: 					// ideally, we would want to start writing on this new
0: 					// empty log file, but the scan is closed and there is
0: 					// no way to tell the difference between an empty log
0: 					// file and a log file which is not there.  We will be
0: 					// writing to the end of the previous log file instead
0: 					// but when we next switch the log, the empty log file
0: 					// will be written over.
0: 
0: 					return null;
0: 				}
0: 
0: 				// we have successfully switched to the next log file.
0: 				// scan is positioned just before the next log record
0: 				// see if this one is written in entirety
0: 				recordLength = scan.readInt();
0: 			}
0: 
0: 			// we know the entire log record is on this log file
0: 
0: 			// read the current log instant
0: 			currentInstant = scan.readLong();
0: 			
0: 			/*check if the current instant happens is less than the last one. 
0: 			 *This can happen if system crashed before writing the log instant
0: 			 *completely. If the instant is partially written it will be less
0: 			 *than the last one and should be the last record that was suppose to
0: 			 *get written. Currentlt preallocated files are filled with zeros,
0: 			 *this should hold good.
0: 			 *Note: In case of Non-preallocated files earlier check with log
0: 			 * file lengths should have found the end. But in prellocated files, log file
0: 			 *length is not sufficiant to find the log end. This check 
0: 			 *is must to find the end in preallocated log files. 
0: 			 */
0: 			if(currentInstant < knownGoodLogEnd)
0: 			{
0: 				fuzzyLogEnd = true ;
0: 				return null;
0: 			}
0: 
0: 			// sanity check it 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (LogCounter.getLogFileNumber(currentInstant) !=
0: 					currentLogFileNumber ||
0: 					LogCounter.getLogFilePosition(currentInstant) !=
0: 					recordStartPosition)
0: 					SanityManager.THROWASSERT(
0: 							  "Wrong LogInstant on log record " +
0: 								LogCounter.toDebugString(currentInstant) + 
0: 								 " version real position (" +
0: 								 currentLogFileNumber + "," +
0: 								 recordStartPosition + ")");
0: 			}
0: 
0: 
0: 			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
0: 			// nothing more can be read.  Else check scan limit
0: 			if (stopAt != LogCounter.INVALID_LOG_INSTANT && currentInstant > stopAt)
0: 			{
0: 				currentInstant = LogCounter.INVALID_LOG_INSTANT;
0: 				return null;			// we went past the stopAt
0: 			}
0: 
0: 			// read in the log record
0: 			byte[] data = input.getData();
0: 
0: 			if (data.length < recordLength)
0: 			{
0: 				// make a new array of sufficient size and reset the arrary
0: 				// in the input stream
0: 				data = new byte[recordLength];
0: 				input.setData(data);
0: 			}
0: 
0: 			// If the log is encrypted, we must do the filtering after
0: 			// reading and decryptiong the record.
0: 
0: 			if (logFactory.databaseEncrypted())
0: 			{
0: 				scan.readFully(data, 0, recordLength);
0: 				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(len == recordLength);
0: 
0: 				input.setLimit(0, len);
0: 			}
0: 			else // no need to decrypt, only get the group and tid if we filter 
0: 			{
0: 				if (groupmask == 0 && tranId == null)
0: 				{
0: 					// no filter, get the whole thing
0: 					scan.readFully(data, 0, recordLength);
0: 					input.setLimit(0, recordLength);
0: 				}
0: 				else
0: 				{
0: 					// Read only enough so that group and the tran id is in
0: 					// the data buffer.  Group is stored as compressed int
0: 					// and tran id is stored as who knows what.  read min
0: 					// of peekAmount or recordLength
0: 					readAmount = (recordLength > peekAmount) ?
0: 						peekAmount : recordLength; 
0: 
0: 					// in the data buffer, we now have enough to peek
0: 					scan.readFully(data, 0, readAmount);
0: 					input.setLimit(0, readAmount);
0: 				}
0: 			}
0: 
0: 			lr = (LogRecord) input.readObject();
0: 			if (groupmask != 0 || tranId != null)
0: 			{
0: 				if (groupmask != 0 && (groupmask & lr.group()) == 0)
0: 					candidate = false; // no match, throw this log record out 
0: 
0: 				if (candidate && tranId != null)
0: 				{
0: 					TransactionId tid = lr.getTransactionId();
0: 					if (!tid.equals(tranId)) // nomatch
0: 						candidate = false; // throw this log record out
0: 				}
0: 
0: 				// if this log record is not filtered out, we need to read
0: 				// in the rest of the log record to the input buffer.
0: 				// Except if it is an encrypted database, in which case the
0: 				// entire log record have already be read in for
0: 				// decryption.
0: 				if (candidate && !logFactory.databaseEncrypted())
0: 				{
0: 					// read the rest of the log into the buffer
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(readAmount > 0);
0: 
0: 					if (readAmount < recordLength)
0: 					{
0: 						// Need to remember where we are because the log
0: 						// record may have read part of it off the input
0: 						// stream already and that position is lost when we
0: 						// set limit again.
0: 						int inputPosition = input.getPosition();
0: 
0: 						scan.readFully(data, readAmount,
0: 									   recordLength-readAmount); 
0: 
0: 						input.setLimit(0, recordLength);
0: 						input.setPosition(inputPosition);
0: 					}
0: 				}
0: 			}
0: 
0: 			/*check if the logrecord length written before and after the 
0: 			 *log record are equal, if not the end of of the log is reached.
0: 			 *This can happen if system crashed before writing the length field 
0: 			 *in the end of the records completely. If the length is partially
0: 			 *written or not written at all  it will not match with length written 
0: 			 *in the beginning of the log record. Currentlt preallocated files
0: 			 *are filled with zeros, log record length can never be zero; 
0: 			 *if the lengths are not matching, end of the properly written log
0: 			 *is reached.
0: 			 *Note: In case of Non-preallocated files earlier fuzzy case check with log
0: 			 * file lengths should have found the end. But in prellocated files, log file
0: 			 *length is not sufficiant to find the log end. This check 
0: 			 *is must to find the end in preallocated log files. 
0: 			 */
0: 			// read the length after the log record and check it against the
0: 			// length before the log record, make sure we go to the correct
0: 			// place for skipped log record.
0: 			if (!candidate)
0: 				scan.seek(recordStartPosition - 4);
0: 			int checkLength = scan.readInt();
0: 			if (checkLength != recordLength && checkLength < recordLength)
0: 			{
0: 
0: 
0: 				//lengh written in the end of the log record should be always
0: 				//less then the length written in the beginning if the log
0: 				//record was half written before the crash.
0: 				if(checkLength < recordLength)
0: 				{
0: 					fuzzyLogEnd = true ;
0: 					return null;
0: 				}else
0: 				{
0: 				
0: 					//If checklength > recordLength then it can be not be a partial write
0: 					//probablly it is corrupted for some reason , this should never
0: 					//happen throw error in debug mode. In non debug case , let's
0: 					//hope it's only is wrong and system can proceed. 
0: 						
0: 					if (SanityManager.DEBUG)
0: 					{	
0: 						throw logFactory.markCorrupt
0: 						(StandardException.newException(
0: 							SQLState.LOG_RECORD_CORRUPTED, 
0:                             new Long(checkLength),
0:                             new Long(recordLength),
0:                             new Long(currentInstant),
0:                             new Long(currentLogFileNumber)));
0: 
0: 					}
0: 					
0: 					//In non debug case, do nothing , let's hope it's only
0: 					//length part that is incorrect and system can proceed. 
0: 				}
0: 
0: 			}
0: 
0: 			// next record start position is right after this record
0: 			recordStartPosition += recordLength + LogToFile.LOG_RECORD_OVERHEAD;
0: 			knownGoodLogEnd = LogCounter.makeLogInstantAsLong
0: 								(currentLogFileNumber, recordStartPosition);
0: 			
0: 			
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (recordStartPosition != scan.getFilePointer())
0: 					SanityManager.THROWASSERT(
0: 									 "calculated end " + recordStartPosition + 
0: 									 " != real end " + scan.getFilePointer());
0: 			}
0: 			else
0: 			{
0: 				// seek to the start of the next log record
0: 				scan.seek(recordStartPosition);
0: 			}
0: 
0: 			// the scan is now positioned just past this log record and right
0: 			// at the beginning of the next log record
0: 		} while (candidate == false) ;
0: 
0: 		return lr;
0: 	}
0: 
0: 
0: 	/**
0: 		Reset the scan to the given LogInstant.
0: 
0: 		@param instant the position to reset to
0: 		@exception IOException scan cannot access the log at the new position.
0: 		@exception StandardException cloudscape standard error policy
0: 	*/
0: 
0: 	public void resetPosition(LogInstant instant) 
0: 		 throws IOException, StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(instant != null);
0: 
0: 		long instant_long = ((LogCounter)instant).getValueAsLong();
0: 
0: 		if ((instant_long == LogCounter.INVALID_LOG_INSTANT) ||
0: 			(stopAt != LogCounter.INVALID_LOG_INSTANT &&
0: 			 (scanDirection == FORWARD && instant_long > stopAt) ||
0: 			 (scanDirection == FORWARD && instant_long < stopAt)))
0: 		{
0: 			close();
0: 
0: 			throw StandardException.newException(
0:                     SQLState.LOG_RESET_BEYOND_SCAN_LIMIT, 
0:                     instant, new LogCounter(stopAt));
0: 		}
0: 		else
0: 		{
0: 			long fnum = ((LogCounter)instant).getLogFileNumber();
0: 
0: 			if (fnum != currentLogFileNumber)
0: 			{
0: 				if (SanityManager.DEBUG) 
0:                 {
0:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                     {
0:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0: 										"Scan " + scanDirection +
0: 										" resetting to " + instant + 
0: 										" need to switch log from " + 
0: 										currentLogFileNumber + " to " + fnum);
0:                     }
0: 				}
0: 
0: 				scan.close();
0: 				scan = logFactory.getLogFileAtPosition(instant_long);
0: 
0: 				currentLogFileNumber= fnum;
0: 
0: 				if (scanDirection == FORWARD)
0: 				{
0: 					// NOTE: 
0: 					//
0: 					// just get the length of the file without syncing.
0: 					// this only works because the only place forward scan is used
0: 					// right now is on recovery redo and nothing is being added to 
0: 					// the current log file.  When the forward scan is used for some
0: 					// other purpose, need to sync access to the end of the log
0: 					//
0: 					currentLogFileLength = scan.length();
0: 				}
0: 			}
0: 			else
0: 
0: 			{
0: 				long fpos = ((LogCounter)instant).getLogFilePosition();
0: 				scan.seek(fpos);
0: 
0: 				//
0: 				//RESOLVE: Can this be optimized? Does it belong here.
0: 				currentLogFileLength = scan.length();
0: 
0: 				if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                     {
0:                         SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0: 										"Scan reset to " + instant);
0:                     }
0: 				}
0: 			}
0: 
0: 
0: 			currentInstant = instant_long;
0: 
0: 			//scan is being reset, it is possibly that, scan is doing a random 
0: 			//access of the log file. set the knownGoodLogEnd to  the instant
0: 			//scan 	is being reset to.
0: 			//Note: reset gets called with undo forward scan for CLR processing during 
0: 			//recovery, if this value is not reset checks to find the end of log 
0: 			//getNextRecordForward() will fail because undoscan scans log file
0: 			//back & forth to redo CLR's.
0: 			knownGoodLogEnd = currentInstant;
0: 
0: 			if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                 {
0:                     SanityManager.DEBUG(LogToFile.DBG_FLAG, 
0:                         "Scan.getInstant reset to " + currentInstant + 
0:                         LogCounter.toDebugString(currentInstant));
0:                 }
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Return the log instant (as an integer) the scan is currently on - this is the log
0: 		instant of the log record that was returned by getNextRecord.
0: 	*/
0: 	public long getInstant()
0: 	{
0: 		return currentInstant;
0: 	}
0: 
0: 	/**
0: 		Return the log instant at the end of the log record on the current
0: 		LogFile in the form of a log instant
0: 	*/
0: 	public long getLogRecordEnd()
0: 	{
0: 		return knownGoodLogEnd;
0: 	}
0: 
0: 	/**
0: 	   returns true if there is partially writen log records before the crash 
0: 	   in the last log file. Partiall wrires are identified during forward 
0: 	   redo scans for log recovery.
0: 	*/
0: 	public boolean isLogEndFuzzy()
0: 	{
0: 		return fuzzyLogEnd;
0: 	}
0: 
0: 	/**
0: 		Return the log instant the scan is currently on - this is the log
0: 		instant of the log record that was returned by getNextRecord.
0: 	*/
0: 	public LogInstant getLogInstant()
0: 	{
0: 		if (currentInstant == LogCounter.INVALID_LOG_INSTANT)
0: 			return null;
0: 		else
0: 			return new LogCounter(currentInstant);
0: 	}
0: 
0: 	/**
0: 		Close the scan.
0: 	*/
0: 	public void close()
0: 	{
0: 		if (scan != null)
0: 		{
0: 			try 
0: 			{
0: 				scan.close();
0: 			}
0: 			catch (IOException ioe)
0: 			{}
0: 
0: 			scan = null;
0: 		}
0: 
0: 		logFactory = null;
0: 		currentLogFileNumber = -1;
0: 		currentLogFileLength = -1;
0: 		knownGoodLogEnd = LogCounter.INVALID_LOG_INSTANT;
0: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
0: 		stopAt = LogCounter.INVALID_LOG_INSTANT;
0: 		scanDirection = 0;
0: 	}
0: 
0: }
============================================================================