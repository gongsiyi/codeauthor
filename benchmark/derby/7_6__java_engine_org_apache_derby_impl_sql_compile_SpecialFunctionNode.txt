1:03b7b8d: /*
14:03b7b8d: 
1:03b7b8d:    Derby - Class org.apache.derby.impl.sql.compile.SpecialFunctionNode
1:03b7b8d: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:03b7b8d: 
1:03b7b8d:       http://www.apache.org/licenses/LICENSE-2.0
1:03b7b8d: 
1:03b7b8d:    Unless required by applicable law or agreed to in writing, software
1:03b7b8d:    distributed under the License is distributed on an "AS IS" BASIS,
1:03b7b8d:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:03b7b8d:    See the License for the specific language governing permissions and
1:03b7b8d:    limitations under the License.
1:03b7b8d: 
2:03b7b8d:  */
1:03b7b8d: 
1:03b7b8d: package	org.apache.derby.impl.sql.compile;
1:03b7b8d: 
1:03b7b8d: import java.lang.reflect.Modifier;
1:3bb140c: import java.sql.Types;
1:3bb140c: import java.util.List;
1:03b7b8d: import org.apache.derby.iapi.error.StandardException;
1:03b7b8d: import org.apache.derby.iapi.reference.ClassName;
1:03b7b8d: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:9ed7c4d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:3bb140c: import org.apache.derby.iapi.store.access.Qualifier;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:03b7b8d: 
2:03b7b8d: /**
1:03b7b8d:      SpecialFunctionNode handles system SQL functions.
1:03b7b8d: 	 A function value is either obtained by a method
1:03b7b8d: 	 call off the LanguageConnectionContext or Activation.
1:03b7b8d: 	 LanguageConnectionContext functions are state related to the connection.
1:03b7b8d: 	 Activation functions are those related to the statement execution.
1:03b7b8d: 
1:03b7b8d:      Each SQL function takes no arguments and returns a SQLvalue.
1:03b7b8d: 	 <P>
1:03b7b8d: 	 Functions supported:
1:03b7b8d: 	 <UL>
1:03b7b8d: 	 <LI> USER
1:03b7b8d: 	 <LI> CURRENT_USER
1:ee59de8: 	 <LI> CURRENT_ROLE
1:03b7b8d: 	 <LI> SESSION_USER
1:03b7b8d: 	 <LI> SYSTEM_USER
1:03b7b8d: 	 <LI> CURRENT SCHEMA
1:03b7b8d: 	 <LI> CURRENT ISOLATION
1:03b7b8d: 	 <LI> IDENTITY_VAL_LOCAL
1:03b7b8d: 
1:03b7b8d: 	 </UL>
1:03b7b8d: 
1:03b7b8d: 
1:03b7b8d: 	<P>
1:03b7b8d: 
1:03b7b8d: 	 This node is used rather than some use of MethodCallNode for
1:03b7b8d: 	 runtime performance. MethodCallNode does not provide a fast access
1:3bb140c:      to the current language connection or activation, since it is geared
1:03b7b8d: 	 towards user defined routines.
1:03b7b8d: 
1:03b7b8d: 
1:03b7b8d: */
1:3bb140c: class SpecialFunctionNode extends ValueNode
5:03b7b8d: {
1:03b7b8d: 	/**
1:03b7b8d: 		Name of SQL function
1:03b7b8d: 	*/
1:03b7b8d: 	String sqlName;
1:03b7b8d: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_IDENTITY_VAL = 0;
1:2706d1f:     final static int K_CURRENT_ISOLATION = 1;
1:2706d1f:     final static int K_CURRENT_SCHEMA = 2;
1:2706d1f:     final static int K_USER = 3;
1:2706d1f:     final static int K_CURRENT_USER = 4;
1:2706d1f:     final static int K_SESSION_USER = 5;
1:2706d1f:     final static int K_SYSTEM_USER = 6; // currently not in use
1:2706d1f:     final static int K_CURRENT_ROLE = 7;
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:2706d1f: 
1:03b7b8d: 	/**
1:03b7b8d: 		Java method name
1:03b7b8d: 	*/
1:03b7b8d: 	private String methodName;
1:03b7b8d: 
1:03b7b8d: 	/**
1:03b7b8d: 		Return type of Java method.
1:03b7b8d: 	*/
1:03b7b8d: 	private String methodType;
1:03b7b8d: 
1:2706d1f:     SpecialFunctionNode(int kind, ContextManager cm) {
1:3bb140c:         super(cm);
1:2706d1f:         this.kind = kind;
1:2706d1f: 
1:2706d1f:         if (SanityManager.DEBUG) {
1:2706d1f:             if (kind == K_SYSTEM_USER) {
1:2706d1f:                 SanityManager.THROWASSERT("SYSTEM_USER not expected");
1:2706d1f:             }
1:2706d1f:         }
1:3bb140c:     }
1:03b7b8d: 	/**
1:03b7b8d: 	 * Binding this special function means setting the result DataTypeServices.
1:03b7b8d: 	 * In this case, the result type is based on the operation requested.
1:03b7b8d: 	 *
1:03b7b8d: 	 * @param fromList			The FROM list for the statement.  This parameter
1:03b7b8d: 	 *							is not used in this case.
1:03b7b8d: 	 * @param subqueryList		The subquery list being built as we find 
1:03b7b8d: 	 *							SubqueryNodes. Not used in this case.
1:09c2697:      * @param aggregates        The aggregate list being built as we find
1:03b7b8d: 	 *							AggregateNodes. Not used in this case.
1:03b7b8d: 	 *
1:03b7b8d: 	 * @return	The new top of the expression tree.
1:03b7b8d: 	 *
1:03b7b8d: 	 * @exception StandardException		Thrown on error
1:03b7b8d: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode bindExpression(FromList fromList,
1:3bb140c:                              SubqueryList subqueryList,
1:3bb140c:                              List<AggregateNode> aggregates)
1:3bb140c:             throws StandardException
1:3bb140c:     {
1:3bb140c:         DataTypeDescriptor dtd;
1:2706d1f: 
1:2706d1f:         switch (kind) {
1:2706d1f:         case K_USER:
1:2706d1f:         case K_CURRENT_USER:
1:2706d1f:         case K_SYSTEM_USER:
1:2706d1f:             switch (kind) {
1:2706d1f:                 case K_USER:
1:2706d1f:                     sqlName = "USER";
1:2706d1f:                     break;
1:2706d1f:                 case K_CURRENT_USER:
1:2706d1f:                     sqlName = "CURRENT_USER";
1:2706d1f:                     break;
1:2706d1f:                 case K_SYSTEM_USER:
1:2706d1f:                     sqlName = "SYSTEM_USER";
1:2706d1f:                     break;
3:03b7b8d: 			}
1:9f60172:             methodName = "getCurrentUserId";
1:ee59de8: 			methodType = "java.lang.String";
1:3bb140c:             
1:2706d1f:             // SQL spec Section 6.4 Syntax Rule 4 says that the collation type
1:2706d1f:             // of these functions will be the collation of character set
1:2706d1f:             // SQL_IDENTIFIER. In Derby's case, that will mean, the collation of
1:2706d1f:             // these functions will be UCS_BASIC. The collation derivation will
1:ee59de8: 			//be implicit. 
1:9ed7c4d:             dtd = DataDictionary.TYPE_SYSTEM_IDENTIFIER;
1:03b7b8d: 			break;
1:9ed7c4d: 
1:2706d1f:         case K_SESSION_USER:
1:9f60172:             methodName = "getSessionUserId";
1:9f60172:             methodType = "java.lang.String";
1:9f60172:             sqlName = "SESSION_USER";
1:9f60172:             dtd = DataDictionary.TYPE_SYSTEM_IDENTIFIER;
1:9f60172:             break;
1:9f60172: 
1:2706d1f:         case K_CURRENT_SCHEMA:
1:03b7b8d: 			sqlName = "CURRENT SCHEMA";
1:03b7b8d: 			methodName = "getCurrentSchemaName";
1:03b7b8d: 			methodType = "java.lang.String";
1:03b7b8d: 			
1:9ed7c4d: 			//This is a Derby specific function but its collation type will
1:353feee: 			//be based on the same rules as for SESSION_USER/CURRENT_USER etc. 
1:353feee: 			//ie there collation type will be UCS_BASIC. The collation 
1:353feee: 			//derivation will be implicit. 
1:9ed7c4d:             dtd = DataDictionary.TYPE_SYSTEM_IDENTIFIER;
1:03b7b8d: 			break;
1:03b7b8d: 
1:2706d1f:         case K_CURRENT_ROLE:
1:ee59de8: 			sqlName = "CURRENT_ROLE";
1:44ea4f0: 			methodName = "getCurrentRoleIdDelimited";
1:03b7b8d: 			methodType = "java.lang.String";
1:ee59de8: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1:78997ab: 				// size: 2+(2*128) start and end text quote plus max # of
1:78997ab: 				// escapes
1:78997ab: 				Types.VARCHAR, true, 2+(2*128)); 
1:ee59de8: 			//SQL spec Section 6.4 Syntax Rule 4 says that the collation type
1:ee59de8: 			//of these functions will be the collation of character set
1:ee59de8: 			//SQL_IDENTIFIER. In Derby's case, that will mean, the collation of
1:ee59de8: 			//these functions will be UCS_BASIC. The collation derivation will
1:9ed7c4d: 			//be implicit. (set by default)
1:ee59de8: 			break;
1:ee59de8: 
1:2706d1f:         case K_IDENTITY_VAL:
1:03b7b8d: 			sqlName = "IDENTITY_VAL_LOCAL";
1:03b7b8d: 			methodName = "getIdentityValue";
1:03b7b8d: 			methodType = "java.lang.Long";
1:03b7b8d: 			dtd = DataTypeDescriptor.getSQLDataTypeDescriptor("java.math.BigDecimal", 31, 0, true, 31);
1:03b7b8d: 			break;
1:9ed7c4d: 
1:2706d1f:         case K_CURRENT_ISOLATION:
1:03b7b8d: 			sqlName = "CURRENT ISOLATION";
1:03b7b8d: 			methodName = "getCurrentIsolationLevelStr";
1:03b7b8d: 			methodType = "java.lang.String";
1:03b7b8d: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 2);
1:353feee: 			//This is a Derby specific function but it's collation type will
1:353feee: 			//be based on the same rules as for SESSION_USER/CURRENT_USER etc. 
1:353feee: 			//ie there collation type will be UCS_BASIC. The collation 
1:9ed7c4d: 			//derivation will be implicit. (set by default).
1:03b7b8d: 			break;
1:03b7b8d: 		default:
1:2706d1f:             if (SanityManager.DEBUG) {
1:2706d1f:                 SanityManager.THROWASSERT(
1:2706d1f:                         "Invalid type for SpecialFunctionNode " + kind);
1:2706d1f:             }
1:03b7b8d: 			dtd = null;
1:03b7b8d: 			break;
1:2706d1f:         }
1:03b7b8d: 
1:03b7b8d: 		checkReliability(sqlName, CompilerContext.USER_ILLEGAL );
1:03b7b8d: 		setType(dtd);
1:03b7b8d: 
1:03b7b8d: 		return this;
1:03b7b8d: 	}
1:03b7b8d: 
1:03b7b8d: 	/**
1:03b7b8d: 	 * Return the variant type for the underlying expression.
1:03b7b8d: 	   All supported special functions are QUERY_INVARIANT
1:03b7b8d: 
1:03b7b8d: 	 *
1:03b7b8d: 	 * @return	The variant type for the underlying expression.
1:03b7b8d: 	 */
1:3bb140c:     @Override
1:03b7b8d: 	protected int getOrderableVariantType()
1:01217c2: 	{
1:03b7b8d: 		return Qualifier.QUERY_INVARIANT;
1:03b7b8d: 	}
1:03b7b8d: 
1:03b7b8d: 	/**
1:03b7b8d: 		Generate an expression that returns a DataValueDescriptor and
1:03b7b8d: 		calls a method off the language connection or the activation.
1:03b7b8d: 	 *
1:03b7b8d: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:03b7b8d: 	 * @param mb	The method the code to place the code
1:03b7b8d: 	 *
1:03b7b8d: 	 *
1:03b7b8d: 	 * @exception StandardException		Thrown on error
1:03b7b8d: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
2:03b7b8d: 									throws StandardException
1:03b7b8d: 	{
1:03b7b8d: 		mb.pushThis();
1:03b7b8d: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext",
1:03b7b8d: 											 ClassName.LanguageConnectionContext, 0);
1:99d7d8b: 		int argCount = 0;
1:6950a39: 
1:44ea4f0: 		if (methodName.equals("getCurrentRoleIdDelimited") ||
1:9f60172:                 methodName.equals("getCurrentSchemaName") ||
1:9f60172:                 methodName.equals("getCurrentUserId")) {
1:03b7b8d: 
1:99d7d8b: 			acb.pushThisAsActivation(mb);
1:99d7d8b: 			argCount++;
1:99d7d8b: 		}
1:99d7d8b: 
1:99d7d8b: 		mb.callMethod(VMOpcode.INVOKEINTERFACE,
1:99d7d8b: 					  (String) null, methodName, methodType, argCount);
1:03b7b8d: 
1:03b7b8d: 		String fieldType = getTypeCompiler().interfaceName();
1:03b7b8d: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, fieldType);
1:03b7b8d: 
1:ba7683c: 		acb.generateDataValue(mb, getTypeCompiler(), 
1:ba7683c: 				getTypeServices().getCollationType(), field);
1:03b7b8d: 	}
1:03b7b8d: 
1:03b7b8d: 	/*
1:03b7b8d: 		print the non-node subfields
1:03b7b8d: 	 */
1:3bb140c:     @Override
1:03b7b8d: 	public String toString() {
2:03b7b8d: 		if (SanityManager.DEBUG)
1:03b7b8d: 		{
1:c9a1206: 			return "sqlName: " + sqlName + "\n" +
1:c9a1206: 				super.toString();
1:03b7b8d: 		}
1:03b7b8d: 		else
1:03b7b8d: 		{
1:03b7b8d: 			return "";
1:03b7b8d: 		}
1:03b7b8d: 	}
1:2706d1f: 
1:2706d1f:     @Override
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) &&
1:2706d1f:                 ((SpecialFunctionNode)o).kind == this.kind;
1:2706d1f:     }
1:01217c2:         
1:2706d1f:     boolean isEquivalent(ValueNode o)
1:01217c2: 	{
1:2706d1f:         if (isSameNodeKind(o)) {
1:01217c2: 			SpecialFunctionNode other = (SpecialFunctionNode)o;
1:01217c2: 			return methodName.equals(other.methodName);
1:01217c2: 		}
1:2706d1f: 
1:01217c2: 		return false;
1:01217c2: 	}
1:03b7b8d: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Allowed kinds
1:     final static int K_IDENTITY_VAL = 0;
1:     final static int K_CURRENT_ISOLATION = 1;
1:     final static int K_CURRENT_SCHEMA = 2;
1:     final static int K_USER = 3;
1:     final static int K_CURRENT_USER = 4;
1:     final static int K_SESSION_USER = 5;
1:     final static int K_SYSTEM_USER = 6; // currently not in use
1:     final static int K_CURRENT_ROLE = 7;
1: 
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
1: 
/////////////////////////////////////////////////////////////////////////
1:     SpecialFunctionNode(int kind, ContextManager cm) {
1:         this.kind = kind;
1: 
1:         if (SanityManager.DEBUG) {
1:             if (kind == K_SYSTEM_USER) {
1:                 SanityManager.THROWASSERT("SYSTEM_USER not expected");
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         switch (kind) {
1:         case K_USER:
1:         case K_CURRENT_USER:
1:         case K_SYSTEM_USER:
1:             switch (kind) {
1:                 case K_USER:
1:                     sqlName = "USER";
1:                     break;
1:                 case K_CURRENT_USER:
1:                     sqlName = "CURRENT_USER";
1:                     break;
1:                 case K_SYSTEM_USER:
1:                     sqlName = "SYSTEM_USER";
1:                     break;
1:             // SQL spec Section 6.4 Syntax Rule 4 says that the collation type
1:             // of these functions will be the collation of character set
1:             // SQL_IDENTIFIER. In Derby's case, that will mean, the collation of
1:             // these functions will be UCS_BASIC. The collation derivation will
1:         case K_SESSION_USER:
1:         case K_CURRENT_SCHEMA:
/////////////////////////////////////////////////////////////////////////
1:         case K_CURRENT_ROLE:
/////////////////////////////////////////////////////////////////////////
1:         case K_IDENTITY_VAL:
1:         case K_CURRENT_ISOLATION:
/////////////////////////////////////////////////////////////////////////
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.THROWASSERT(
1:                         "Invalid type for SpecialFunctionNode " + kind);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) &&
1:                 ((SpecialFunctionNode)o).kind == this.kind;
1:     }
1:     boolean isEquivalent(ValueNode o)
1:         if (isSameNodeKind(o)) {
1: 
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import java.util.List;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:      to the current language connection or activation, since it is geared
1: class SpecialFunctionNode extends ValueNode
/////////////////////////////////////////////////////////////////////////
0:     SpecialFunctionNode(int nodeType, ContextManager cm) {
1:         super(cm);
0:         setNodeType(nodeType); // valid nodeType checked below in bindExpression
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode bindExpression(FromList fromList,
1:                              SubqueryList subqueryList,
1:                              List<AggregateNode> aggregates)
1:             throws StandardException
1:     {
1:         DataTypeDescriptor dtd;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:             methodName = "getCurrentUserId";
/////////////////////////////////////////////////////////////////////////
0:         case C_NodeTypes.SESSION_USER_NODE:
1:             methodName = "getSessionUserId";
1:             methodType = "java.lang.String";
1:             sqlName = "SESSION_USER";
1:             dtd = DataDictionary.TYPE_SYSTEM_IDENTIFIER;
1:             break;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 methodName.equals("getCurrentSchemaName") ||
1:                 methodName.equals("getCurrentUserId")) {
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 			return "sqlName: " + sqlName + "\n" +
1: 				super.toString();
commit:78997ab
/////////////////////////////////////////////////////////////////////////
1: 				// size: 2+(2*128) start and end text quote plus max # of
1: 				// escapes
1: 				Types.VARCHAR, true, 2+(2*128)); 
commit:44ea4f0
/////////////////////////////////////////////////////////////////////////
1: 			methodName = "getCurrentRoleIdDelimited";
/////////////////////////////////////////////////////////////////////////
1: 		if (methodName.equals("getCurrentRoleIdDelimited") ||
commit:34b59c6
/////////////////////////////////////////////////////////////////////////
0: 			methodName = "getCurrentRoleIdChecked";
0: 				Types.VARCHAR, true, 128);
/////////////////////////////////////////////////////////////////////////
0: 		if (methodName.equals("getCurrentRoleIdChecked") ||
commit:6950a39
/////////////////////////////////////////////////////////////////////////
0: 		if (methodName.equals("getCurrentRoleId") ||
0: 			methodName.equals("getCurrentSchemaName")) {
1: 
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
1: 		int argCount = 0;
0: 		if (methodName.equals("getCurrentRoleId")) {
1: 			acb.pushThisAsActivation(mb);
1: 			argCount++;
1: 		}
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE,
1: 					  (String) null, methodName, methodType, argCount);
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
1: 	 <LI> CURRENT_ROLE
/////////////////////////////////////////////////////////////////////////
0: 		case C_NodeTypes.CURRENT_ROLE_NODE:
1: 			sqlName = "CURRENT_ROLE";
0: 			methodName = "getCurrentRoleId";
1: 			methodType = "java.lang.String";
1: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
0: 				Types.VARCHAR, false, 128);
1: 			//SQL spec Section 6.4 Syntax Rule 4 says that the collation type
1: 			//of these functions will be the collation of character set
1: 			//SQL_IDENTIFIER. In Derby's case, that will mean, the collation of
1: 			//these functions will be UCS_BASIC. The collation derivation will
1: 			//be implicit.
0: 			dtd.setCollationDerivation(
0: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			dtd.setCollationType(StringDataValue.COLLATION_TYPE_UCS_BASIC);
1: 			break;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 							List aggregateVector)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
/////////////////////////////////////////////////////////////////////////
1:             
1:             dtd = DataDictionary.TYPE_SYSTEM_IDENTIFIER;
1: 			
1: 			//This is a Derby specific function but its collation type will
1:             dtd = DataDictionary.TYPE_SYSTEM_IDENTIFIER;
/////////////////////////////////////////////////////////////////////////
1: 			//be implicit. (set by default)
/////////////////////////////////////////////////////////////////////////
1: 			//derivation will be implicit. (set by default).
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:         
0: 	protected boolean isEquivalent(ValueNode o)
1: 	{
0: 		if (isSameNodeType(o))
1: 		{
1: 			SpecialFunctionNode other = (SpecialFunctionNode)o;
1: 			return methodName.equals(other.methodName);
1: 		}
1: 		return false;
1: 	}
commit:03b7b8d
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.SpecialFunctionNode
1: 
0:    Copyright 1999, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
1: import java.lang.reflect.Modifier;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: 
0: import java.sql.Types;
1: 
0: import java.util.Vector;
1: 
1: /**
1:      SpecialFunctionNode handles system SQL functions.
1: 	 A function value is either obtained by a method
1: 	 call off the LanguageConnectionContext or Activation.
1: 	 LanguageConnectionContext functions are state related to the connection.
1: 	 Activation functions are those related to the statement execution.
1: 
1:      Each SQL function takes no arguments and returns a SQLvalue.
1: 	 <P>
1: 	 Functions supported:
1: 	 <UL>
1: 	 <LI> USER
1: 	 <LI> CURRENT_USER
1: 	 <LI> SESSION_USER
1: 	 <LI> SYSTEM_USER
1: 	 <LI> CURRENT SCHEMA
1: 	 <LI> CURRENT ISOLATION
1: 	 <LI> IDENTITY_VAL_LOCAL
1: 
1: 	 </UL>
1: 
1: 
1: 	<P>
1: 
1: 	 This node is used rather than some use of MethodCallNode for
1: 	 runtime performance. MethodCallNode does not provide a fast access
0: 	 to the current language connection or activatation, since it is geared
1: 	 towards user defined routines.
1: 
1: 
1: */
0: public class SpecialFunctionNode extends ValueNode 
1: {
1: 	/**
1: 		Name of SQL function
1: 	*/
1: 	String sqlName;
1: 
1: 	/**
1: 		Java method name
1: 	*/
1: 	private String methodName;
1: 
1: 	/**
1: 		Return type of Java method.
1: 	*/
1: 	private String methodType;
1: 
1: 	/**
1: 	*/
0: 	//private boolean isActivationCall;
1: 
1: 	/**
1: 	 * Binding this special function means setting the result DataTypeServices.
1: 	 * In this case, the result type is based on the operation requested.
1: 	 *
1: 	 * @param fromList			The FROM list for the statement.  This parameter
1: 	 *							is not used in this case.
1: 	 * @param subqueryList		The subquery list being built as we find 
1: 	 *							SubqueryNodes. Not used in this case.
0: 	 * @param aggregateVector	The aggregate vector being built as we find 
1: 	 *							AggregateNodes. Not used in this case.
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 							Vector	aggregateVector)
1: 					throws StandardException
0: 	{		DataTypeDescriptor dtd;
0: 		int nodeType = getNodeType();
0: 		switch (nodeType)
1: 		{
0: 		case C_NodeTypes.USER_NODE:
0: 		case C_NodeTypes.CURRENT_USER_NODE:
0: 		case C_NodeTypes.SESSION_USER_NODE:
0: 		case C_NodeTypes.SYSTEM_USER_NODE:
0: 			switch (nodeType)
1: 			{
0: 				case C_NodeTypes.USER_NODE: sqlName = "USER"; break;
0: 				case C_NodeTypes.CURRENT_USER_NODE: sqlName = "CURRENT_USER"; break;
0: 				case C_NodeTypes.SESSION_USER_NODE: sqlName = "SESSION_USER"; break;
0: 				case C_NodeTypes.SYSTEM_USER_NODE: sqlName = "SYSTEM_USER"; break;
1: 			}
0: 			methodName = "getAuthorizationId";
1: 			methodType = "java.lang.String";
0: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128);
1: 			break;
1: 
0: 		case C_NodeTypes.CURRENT_SCHEMA_NODE:
1: 			sqlName = "CURRENT SCHEMA";
1: 			methodName = "getCurrentSchemaName";
1: 			methodType = "java.lang.String";
0: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128);
1: 			break;
1: 
0: 		case C_NodeTypes.IDENTITY_VAL_NODE:
1: 			sqlName = "IDENTITY_VAL_LOCAL";
1: 			methodName = "getIdentityValue";
1: 			methodType = "java.lang.Long";
1: 			dtd = DataTypeDescriptor.getSQLDataTypeDescriptor("java.math.BigDecimal", 31, 0, true, 31);
1: 			break;
1: 
0: 		case C_NodeTypes.CURRENT_ISOLATION_NODE:
1: 			sqlName = "CURRENT ISOLATION";
1: 			methodName = "getCurrentIsolationLevelStr";
1: 			methodType = "java.lang.String";
1: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 2);
1: 			break;
1: 		default:
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				SanityManager.THROWASSERT("Invalid type for SpecialFunctionNode " + nodeType);
1: 			}
1: 			dtd = null;
1: 			break;
1: 		}
1: 
1: 		checkReliability(sqlName, CompilerContext.USER_ILLEGAL );
1: 		setType(dtd);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	   All supported special functions are QUERY_INVARIANT
1: 
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 */
1: 	protected int getOrderableVariantType()
1: 	{
1: 		return Qualifier.QUERY_INVARIANT;
1: 	}
1: 
1: 	/**
1: 		Generate an expression that returns a DataValueDescriptor and
1: 		calls a method off the language connection or the activation.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the code to place the code
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		mb.pushThis();
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext",
1: 											 ClassName.LanguageConnectionContext, 0);
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, methodType, 0);
1: 
1: 		String fieldType = getTypeCompiler().interfaceName();
1: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, fieldType);
1: 
0: 		acb.generateDataValue(mb, getTypeCompiler(), field);
1: 	}
1: 
1: 	/*
1: 		print the non-node subfields
1: 	 */
1: 	public String toString() {
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return super.toString()+ sqlName;
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:353feee
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			//SQL spec Section 6.4 Syntax Rule 4 says that the collation type 
0: 			//of these functions will be the collation of character set 
0: 			//SQL_IDENTIFIER. In Derby's case, that will mean, the collation of
0: 			//these functions will be UCS_BASIC. The collation derivation will 
0: 			//be implicit. 
0: 			dtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			dtd.setCollationType(StringDataValue.COLLATION_TYPE_UCS_BASIC);
/////////////////////////////////////////////////////////////////////////
1: 			//This is a Derby specific function but it's collation type will
1: 			//be based on the same rules as for SESSION_USER/CURRENT_USER etc. 
1: 			//ie there collation type will be UCS_BASIC. The collation 
1: 			//derivation will be implicit. 
0: 			dtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			dtd.setCollationType(StringDataValue.COLLATION_TYPE_UCS_BASIC);
/////////////////////////////////////////////////////////////////////////
0: 			//This is a Derby specific function but it's collation type will
1: 			//be based on the same rules as for SESSION_USER/CURRENT_USER etc. 
1: 			//ie there collation type will be UCS_BASIC. The collation 
0: 			//derivation will be implicit. 
0: 			dtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			dtd.setCollationType(StringDataValue.COLLATION_TYPE_UCS_BASIC);
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
1: 		acb.generateDataValue(mb, getTypeCompiler(), 
1: 				getTypeServices().getCollationType(), field);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.impl.sql.compile.SpecialFunctionNode
0: 
0:    Copyright 1999, 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: 
0: import java.sql.Types;
0: 
0: import java.util.Vector;
0: 
0: /**
0:      SpecialFunctionNode handles system SQL functions.
0: 	 A function value is either obtained by a method
0: 	 call off the LanguageConnectionContext or Activation.
0: 	 LanguageConnectionContext functions are state related to the connection.
0: 	 Activation functions are those related to the statement execution.
0: 
0:      Each SQL function takes no arguments and returns a SQLvalue.
0: 	 <P>
0: 	 Functions supported:
0: 	 <UL>
0: 	 <LI> USER
0: 	 <LI> CURRENT_USER
0: 	 <LI> SESSION_USER
0: 	 <LI> SYSTEM_USER
0: 	 <LI> CURRENT SCHEMA
0: 	 <LI> CURRENT ISOLATION
0: 	 <LI> IDENTITY_VAL_LOCAL
0: 
0: 	 </UL>
0: 
0: 
0: 	<P>
0: 
0: 	 This node is used rather than some use of MethodCallNode for
0: 	 runtime performance. MethodCallNode does not provide a fast access
0: 	 to the current language connection or activatation, since it is geared
0: 	 towards user defined routines.
0: 
0: 
0: */
0: public class SpecialFunctionNode extends ValueNode 
0: {
0: 	/**
0: 		Name of SQL function
0: 	*/
0: 	String sqlName;
0: 
0: 	/**
0: 		Java method name
0: 	*/
0: 	private String methodName;
0: 
0: 	/**
0: 		Return type of Java method.
0: 	*/
0: 	private String methodType;
0: 
0: 	/**
0: 	*/
0: 	//private boolean isActivationCall;
0: 
0: 	/**
0: 	 * Binding this special function means setting the result DataTypeServices.
0: 	 * In this case, the result type is based on the operation requested.
0: 	 *
0: 	 * @param fromList			The FROM list for the statement.  This parameter
0: 	 *							is not used in this case.
0: 	 * @param subqueryList		The subquery list being built as we find 
0: 	 *							SubqueryNodes. Not used in this case.
0: 	 * @param aggregateVector	The aggregate vector being built as we find 
0: 	 *							AggregateNodes. Not used in this case.
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 							Vector	aggregateVector)
0: 					throws StandardException
0: 	{		DataTypeDescriptor dtd;
0: 		int nodeType = getNodeType();
0: 		switch (nodeType)
0: 		{
0: 		case C_NodeTypes.USER_NODE:
0: 		case C_NodeTypes.CURRENT_USER_NODE:
0: 		case C_NodeTypes.SESSION_USER_NODE:
0: 		case C_NodeTypes.SYSTEM_USER_NODE:
0: 			switch (nodeType)
0: 			{
0: 				case C_NodeTypes.USER_NODE: sqlName = "USER"; break;
0: 				case C_NodeTypes.CURRENT_USER_NODE: sqlName = "CURRENT_USER"; break;
0: 				case C_NodeTypes.SESSION_USER_NODE: sqlName = "SESSION_USER"; break;
0: 				case C_NodeTypes.SYSTEM_USER_NODE: sqlName = "SYSTEM_USER"; break;
0: 			}
0: 			methodName = "getAuthorizationId";
0: 			methodType = "java.lang.String";
0: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128);
0: 			break;
0: 
0: 		case C_NodeTypes.CURRENT_SCHEMA_NODE:
0: 			sqlName = "CURRENT SCHEMA";
0: 			methodName = "getCurrentSchemaName";
0: 			methodType = "java.lang.String";
0: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128);
0: 			break;
0: 
0: 		case C_NodeTypes.IDENTITY_VAL_NODE:
0: 			sqlName = "IDENTITY_VAL_LOCAL";
0: 			methodName = "getIdentityValue";
0: 			methodType = "java.lang.Long";
0: 			dtd = DataTypeDescriptor.getSQLDataTypeDescriptor("java.math.BigDecimal", 31, 0, true, 31);
0: 			break;
0: 
0: 		case C_NodeTypes.CURRENT_ISOLATION_NODE:
0: 			sqlName = "CURRENT ISOLATION";
0: 			methodName = "getCurrentIsolationLevelStr";
0: 			methodType = "java.lang.String";
0: 			dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 2);
0: 			break;
0: 		default:
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.THROWASSERT("Invalid type for SpecialFunctionNode " + nodeType);
0: 			}
0: 			dtd = null;
0: 			break;
0: 		}
0: 
0: 		checkReliability(sqlName, CompilerContext.USER_ILLEGAL );
0: 		setType(dtd);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	   All supported special functions are QUERY_INVARIANT
0: 
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 */
0: 	protected int getOrderableVariantType()
0: 	{
0: 		return Qualifier.QUERY_INVARIANT;
0: 	}
0: 
0: 	/**
0: 		Generate an expression that returns a DataValueDescriptor and
0: 		calls a method off the language connection or the activation.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the code to place the code
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		mb.pushThis();
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Activation, "getLanguageConnectionContext",
0: 											 ClassName.LanguageConnectionContext, 0);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, methodType, 0);
0: 
0: 		String fieldType = getTypeCompiler().interfaceName();
0: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, fieldType);
0: 
0: 		acb.generateDataValue(mb, getTypeCompiler(), field);
0: 	}
0: 
0: 	/*
0: 		print the non-node subfields
0: 	 */
0: 	public String toString() {
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return super.toString()+ sqlName;
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: }
============================================================================