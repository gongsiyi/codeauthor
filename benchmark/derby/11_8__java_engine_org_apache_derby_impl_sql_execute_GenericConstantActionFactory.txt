1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.GenericConstantActionFactory
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
15:eac0369: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.Authorizer;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:bb21983: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.catalog.AliasInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:80eb35f: import org.apache.derby.impl.sql.compile.TableName;
1:eac0369: 
1:b7730e4: import java.util.List;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:eac0369: import java.sql.Timestamp;
1:eac0369: 
9:eac0369: /**
1:eac0369:  * Factory for creating ConstantActions.
8:eac0369:  *
1:eac0369:  * <P>Implemetation note: For most operations, the ResultSetFactory
1:eac0369:  *    determines if the operation is allowed in a readonly/target database.
1:eac0369:  *    Because we perform JAR add/drop/replace with a utility rather than
1:eac0369:  *    using normal language processing we never get a result set for these
1:eac0369:  *    operations. For this reason, the ConstantActionFactory rather than
1:eac0369:  *    the ResultSetFactory checks if the these operations are allowed.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public class GenericConstantActionFactory
7:eac0369: {
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369:     public	GenericConstantActionFactory()
1:eac0369: 	{
6:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTANT ACTION MANUFACTORIES
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get ConstantAction for SET CONSTRAINTS statement.
1:eac0369: 	 *
1:09bee7d:      *  @param constraints  The constraints to set, if null,
1:09bee7d:      *                      set them ALL.
1:09bee7d:      *  @param initiallyDeferred   ncodes IMMEDIATE (false), DEFERRED (true)
1:eac0369: 	 */
1:09bee7d:     public  ConstantAction getSetConstraintsConstantAction(
1:09bee7d:             List<TableName> constraints,
1:09bee7d:             boolean         initiallyDeferred) {
1:09bee7d:         return new SetConstraintsConstantAction(constraints, initiallyDeferred);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the AlterAction for an ALTER TABLE statement.
1:eac0369: 	 *
2:eac0369: 	 *  @param sd			descriptor for the schema that table lives in.
1:eac0369: 	 *  @param tableName	Name of table.
2:eac0369: 	 *	@param tableId		UUID of table.
1:eac0369: 	 *	@param tableConglomerateId	heap conglomerate id of table
2:eac0369: 	 *  @param tableType	Type of table (e.g., BASE).
1:eac0369: 	 *  @param columnInfo	Information on all the columns in the table.
1:eac0369: 	 *  @param constraintActions	ConstraintConstantAction[] for constraints
1:eac0369: 	 * @param lockGranularity	The lock granularity.
1:eac0369: 	 *	@param compressTable	Whether or not this is a compress table
1:eac0369: 	 *	@param behavior			drop behavior of dropping column
1:eac0369: 	 *	@param sequential	If compress table/drop column, whether or not sequential
1:818fd27: 	 *  @param truncateTable	    Whether or not this is a truncate table
1:818fd27: 	 *  @param purge				PURGE during INPLACE COMPRESS?
1:818fd27: 	 *  @param defragment			DEFRAGMENT during INPLACE COMPRESS?
1:818fd27: 	 *  @param truncateEndOfTable	TRUNCATE END during INPLACE COMPRESS?
1:963d9f4: 	 *  @param updateStatistics		TRUE means we are here to update statistics
1:963d9f4: 	 *  @param updateStatisticsAll	TRUE means we are here to update statistics
1:963d9f4: 	 *  	of all the indexes. False means we are here to update statistics of
1:963d9f4: 	 *  	only one index.
1:a6a0733: 	 *  @param dropStatistics		TRUE means we are here to drop statistics
1:a6a0733: 	 *  @param dropStatisticsAll	TRUE means we are here to drop statistics
1:a6a0733: 	 *  	of all the indexes. False means we are here to drop statistics of
1:a6a0733: 	 *  	only one index.
1:a6a0733: 	 *  @param indexNameForStatistics	Will name the index whose statistics
1:a6a0733: 	 *  	will be updated/dropped. This param is looked at only if 
1:a6a0733: 	 *  	updateStatisticsAll/dropStatisticsAll is set to false and
1:a6a0733: 	 *  	updateStatistics/dropStatistics is set to true.
1:a6a0733: 	 *  .
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getAlterTableConstantAction
6:eac0369: 	(
1:eac0369: 		SchemaDescriptor			sd,
1:eac0369: 		String						tableName,
1:eac0369: 		UUID						tableId,
1:eac0369: 		long						tableConglomerateId,
1:eac0369: 		int							tableType,
1:eac0369: 		ColumnInfo[]				columnInfo,
1:eac0369: 		ConstraintConstantAction[] 	constraintActions,
1:eac0369: 
1:eac0369: 		char						lockGranularity,
1:eac0369: 		boolean						compressTable,
1:eac0369: 		int							behavior,
1:eac0369: 		boolean						sequential,
1:818fd27: 		boolean                     truncateTable,
1:818fd27: 		boolean						purge,
1:818fd27: 		boolean						defragment,
1:963d9f4: 		boolean						truncateEndOfTable,
1:963d9f4: 		boolean						updateStatistics,
1:963d9f4: 		boolean						updateStatisticsAll,
1:a6a0733: 		boolean						dropStatistics,
1:a6a0733: 		boolean						dropStatisticsAll,
1:a6a0733: 		String						indexNameForStatistics
6:eac0369:     )
1:eac0369: 	{
1:eac0369: 		return new	AlterTableConstantAction( sd, tableName, tableId, tableConglomerateId, 
1:eac0369: 											  tableType, columnInfo, constraintActions, 
1:eac0369: 											  lockGranularity, compressTable,
1:818fd27: 											  behavior, sequential, truncateTable,
1:963d9f4: 											  purge, defragment, truncateEndOfTable,
1:963d9f4: 											  updateStatistics, 
1:963d9f4: 											  updateStatisticsAll,
1:a6a0733: 											  dropStatistics, 
1:a6a0733: 											  dropStatisticsAll,
1:a6a0733: 											  indexNameForStatistics);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make a ConstantAction for a constraint.
1:eac0369: 	 *
1:eac0369: 	 *  @param constraintName	Constraint name.
1:eac0369: 	 *  @param constraintType	Constraint type.
1:09bee7d:      *  @param constraintCharacteristics
1:09bee7d:      *                          Constraint characteristics, see {@link
1:09bee7d:      *  org.apache.derby.impl.sql.compile.ConstraintDefinitionNode#characteristics}
1:68db840:      *  @param forCreateTable   True if for a CREATE TABLE
1:eac0369: 	 *  @param tableName		Table name.
1:eac0369: 	 *	@param tableId			UUID of table.
1:eac0369: 	 *  @param schemaName		Schema that table lives in.
1:eac0369: 	 *  @param columnNames		String[] for column names
1:eac0369: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1:eac0369: 	 *  @param constraintText	Text for check constraint
1:6b50965: 	 *	@param otherConstraint	The referenced constraint, if a foreign key constraint
1:eac0369: 	 *  @param providerInfo Information on all the Providers
1:eac0369: 	 */
1:eac0369: 	public	CreateConstraintConstantAction	getCreateConstraintConstantAction
1:eac0369: 	(
1:eac0369: 		String				constraintName,
1:eac0369: 		int					constraintType,
1:09bee7d:         boolean[]           constraintCharacteristics,
1:68db840:         boolean             forCreateTable,
1:eac0369: 		String				tableName,
1:eac0369: 		UUID				tableId,
2:eac0369: 		String				schemaName,
1:eac0369: 		String[]			columnNames,
1:eac0369: 		IndexConstantAction indexAction,
1:eac0369: 		String				constraintText,
1:eac0369: 		ConstraintInfo		otherConstraint,
1:eac0369: 		ProviderInfo[]		providerInfo
1:eac0369: 	)
1:eac0369: 	{
1:09bee7d:         return new CreateConstraintConstantAction(
1:09bee7d:                 constraintName,
1:09bee7d:                 constraintType,
1:09bee7d:                 constraintCharacteristics,
1:09bee7d:                 forCreateTable,
1:09bee7d:                 tableName,
1:09bee7d:                 tableId,
1:09bee7d:                 schemaName,
1:09bee7d:                 columnNames,
1:09bee7d:                 indexAction,
1:09bee7d:                 constraintText,
1:09bee7d:                 otherConstraint,
1:09bee7d:                 providerInfo );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:28e234d:      * 	Make the ConstantAction for a CREATE INDEX statement.
1:28e234d:      * 
1:28e234d:      * @param forCreateTable Executed as part of a CREATE TABLE
1:28e234d:      * @param unique		True means it will be a unique index
1:28e234d:      * @param uniqueWithDuplicateNulls  True means index check and disallow
1:28e234d:      *                                  any duplicate key if key has no 
1:28e234d:      *                                  column with a null value.  If any 
1:28e234d:      *                                  column in the key has a null value,
1:28e234d:      *                                  no checking is done and insert will
1:28e234d:      *                                  always succeed.
1:0c5bc3a:      * @param hasDeferrableChecking True if the index is used to back a
1:0c5bc3a:      *                              deferrable constraint
1:0c5bc3a:      * @param initiallyDeferred  True means the deferrable constraint has
1:0c5bc3a:      *                           deferred mode initially.
1:2db96c5:      * @param constraintType  The constraint type
1:28e234d:      * @param indexType	The type of index (BTREE, for example)
1:28e234d:      * @param schemaName			the schema that table (and index) lives in.
1:28e234d:      * @param indexName	Name of the index
1:28e234d:      * @param tableName	Name of table the index will be on
1:28e234d:      * @param tableId		UUID of table.
1:28e234d:      * @param columnNames	Names of the columns in the index, in order
1:28e234d:      * @param isAscending	Array of booleans telling asc/desc on each column
1:28e234d:      * @param isConstraint	TRUE if index is backing up a constraint, else FALSE
1:28e234d:      * @param conglomerateUUID	ID of conglomerate
1:28e234d:      * @param properties	The optional properties list associated with the index.
1:28e234d:      */
1:05623b6:     public IndexConstantAction getCreateIndexConstantAction
1:eac0369: 	(
1:1b41764:         boolean forCreateTable,
1:eac0369: 		boolean			unique,
1:28e234d: 		boolean			uniqueWithDuplicateNulls,
1:0c5bc3a:         boolean         hasDeferrableChecking,
1:0c5bc3a:         boolean         initiallyDeferred,
1:2db96c5:         int             constraintType,
1:eac0369: 		String			indexType,
1:eac0369: 		String			schemaName,
1:eac0369: 		String			indexName,
1:eac0369: 		String			tableName,
1:eac0369: 		UUID			tableId,
1:eac0369: 		String[]		columnNames,
1:eac0369: 		boolean[]		isAscending,
1:eac0369: 		boolean			isConstraint,
1:eac0369: 		UUID			conglomerateUUID,
1:eac0369: 		Properties		properties
1:eac0369:     )
1:eac0369: 	{
1:0c5bc3a:         return new CreateIndexConstantAction(
1:0c5bc3a:             forCreateTable,
1:0c5bc3a:             unique,
1:0c5bc3a:             uniqueWithDuplicateNulls,
1:0c5bc3a:             hasDeferrableChecking,
1:0c5bc3a:             initiallyDeferred,
1:2db96c5:             constraintType,
1:0c5bc3a:             indexType,
1:0c5bc3a:             schemaName,
1:0c5bc3a:             indexName,
1:0c5bc3a:             tableName,
1:0c5bc3a:             tableId,
1:0c5bc3a:             columnNames,
1:0c5bc3a:             isAscending,
1:0c5bc3a:             isConstraint,
1:0c5bc3a:             conglomerateUUID,
1:0c5bc3a:             properties);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a CREATE ALIAS statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param aliasName		Name of alias.
1:eac0369: 	 *  @param schemaName		Alias's schema. 
1:eac0369: 	 *  @param javaClassName	Name of java class.
1:eac0369: 	 *  @param aliasType		The alias type
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getCreateAliasConstantAction
1:eac0369: 	(
1:eac0369: 		String	aliasName,
1:eac0369: 		String	schemaName,
1:eac0369: 		String	javaClassName,
1:eac0369: 		AliasInfo	aliasInfo,
1:eac0369: 		char	aliasType)
1:eac0369: 	{
1:eac0369: 		return new CreateAliasConstantAction
1:eac0369: 			(aliasName, schemaName, javaClassName, aliasInfo, aliasType );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make the ConstantAction for a CREATE SCHEMA statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param schemaName	Name of table.
1:eac0369: 	 *  @param aid			Authorizaton id
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getCreateSchemaConstantAction
1:eac0369: 	(
1:eac0369: 		String			schemaName,
1:eac0369: 		String			aid)
1:eac0369: 	{
1:eac0369: 		return new CreateSchemaConstantAction(schemaName, aid);
1:eac0369: 	}
1:ee59de8: 
1:eac0369: 
1:ee59de8:     /**
1:ee59de8: 	 * Make the ConstantAction for a CREATE ROLE statement.
1:ee59de8: 	 *
1:ee59de8: 	 * @param roleName	Name of role.
1:ee59de8: 	 */
1:ee59de8: 	public	ConstantAction	getCreateRoleConstantAction(String roleName)
1:ee59de8: 	{
1:ee59de8: 		return new CreateRoleConstantAction(roleName);
1:ee59de8: 	}
1:ee59de8: 
1:ee59de8: 
1:ee59de8: 	/**
1:ee59de8: 	 * Make the ConstantAction for a SET ROLE statement.
1:ee59de8: 	 *
1:ee59de8: 	 * @param roleName  Name of role
1:ee59de8: 	 * @param type      Literal (== 0)
1:ee59de8: 	 *                  or ?    (== StatementType.SET_ROLE_DYNAMIC)
1:ee59de8: 	 */
1:ee59de8: 	public ConstantAction getSetRoleConstantAction(String roleName,
1:ee59de8: 												   int type)
1:ee59de8: 	{
1:ee59de8: 		return new SetRoleConstantAction(roleName, type);
1:ee59de8: 	}
1:ee59de8: 
1:80eb35f:     /**
1:80eb35f: 	 * Make the ConstantAction for a CREATE SEQUENCE statement.
1:80eb35f: 	 *
1:80eb35f: 	 * @param sequenceName	Name of sequence.
1:bb21983:      * @param dataType
1:bb21983:      * @param initialValue
1:bb21983:      * @param stepValue
1:bb21983:      * @param maxValue
1:bb21983:      * @param minValue
1:bb21983:      * @param cycle
1:80eb35f: 	 */
1:bb21983: 	public	ConstantAction	getCreateSequenceConstantAction
1:bb21983:     (
1:bb21983:             TableName   sequenceName,
1:bb21983:             DataTypeDescriptor dataType,
1:bb21983:             long        initialValue,
1:bb21983:             long        stepValue,
1:bb21983:             long        maxValue,
1:bb21983:             long        minValue,
1:bb21983:             boolean     cycle
1:bb21983:     )
1:80eb35f: 	{
1:bb21983:         return new CreateSequenceConstantAction(sequenceName.getSchemaName(),
1:bb21983:                 sequenceName.getTableName(),
1:bb21983:                 dataType,
1:bb21983:                 initialValue,
1:bb21983:                 stepValue,
1:bb21983:                 maxValue,
1:bb21983:                 minValue,
1:bb21983:                 cycle);
1:80eb35f: 	}
1:ee59de8: 
1:80eb35f:     /**
1:eac0369: 	 *	Make the ConstantAction for a CREATE TABLE statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param schemaName	name for the schema that table lives in.
1:eac0369: 	 *  @param tableName	Name of table.
1:eac0369: 	 *  @param tableType	Type of table (e.g., BASE, global temporary table).
1:eac0369: 	 *  @param columnInfo	Information on all the columns in the table.
1:eac0369: 	 *		 (REMIND tableDescriptor ignored)
1:eac0369: 	 *  @param constraintActions	CreateConstraintConstantAction[] for constraints
1:eac0369: 	 *  @param properties	Optional table properties
1:eac0369: 	 * @param lockGranularity	The lock granularity.
1:eac0369: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1:eac0369: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getCreateTableConstantAction
1:eac0369: 	(
1:eac0369: 		String			schemaName,
1:eac0369: 		String			tableName,
1:eac0369: 		int				tableType,
1:eac0369: 		ColumnInfo[]	columnInfo,
1:eac0369: 		CreateConstraintConstantAction[] constraintActions,
1:eac0369: 		Properties		properties,
1:eac0369: 		char			lockGranularity,
1:eac0369: 		boolean			onCommitDeleteRows,
1:eac0369: 		boolean			onRollbackDeleteRows)
1:eac0369: 	{
1:eac0369: 		return new CreateTableConstantAction( schemaName, tableName, tableType, columnInfo,
1:eac0369: 											  constraintActions, properties,
1:eac0369: 											  lockGranularity, onCommitDeleteRows, onRollbackDeleteRows);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a savepoint statement (ROLLBACK savepoint, RELASE savepoint and SAVEPOINT).
1:eac0369: 	 *
1:eac0369: 	 *  @param savepointName	name for the savepoint.
1:eac0369: 	 *  @param statementType	Type of savepoint statement ie rollback, release or set savepoint
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getSavepointConstantAction
1:eac0369: 	(
1:eac0369: 		String			savepointName,
1:eac0369: 		int				statementType)
1:eac0369: 	{
1:eac0369: 		return new SavepointConstantAction( savepointName, statementType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a CREATE VIEW statement.
1:eac0369: 	 *
1:6b50965: 	 *  @param schemaName	Name of the schema that table lives in.
1:eac0369: 	 *  @param tableName	Name of table.
1:9213b42: 	 *  @param tableType	Type of table (in this case TableDescriptor.VIEW_TYPE).
1:eac0369: 	 *	@param viewText		Text of query expression for view definition
1:eac0369: 	 *  @param checkOption	Check option type
1:eac0369: 	 *  @param columnInfo	Information on all the columns in the table.
1:eac0369: 	 *  @param providerInfo Information on all the Providers
1:eac0369: 	 *	@param compSchemaId	ID of schema in which the view is to be bound
1:eac0369: 	 *						when accessed in the future.
1:eac0369: 	 *		 (REMIND tableDescriptor ignored)
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getCreateViewConstantAction
1:eac0369: 	(
1:eac0369: 		String	schemaName,
1:eac0369: 		String			tableName,
1:eac0369: 		int				tableType,
1:eac0369: 		String			viewText,
1:eac0369: 		int				checkOption,
1:eac0369: 		ColumnInfo[]	columnInfo,
1:eac0369: 		ProviderInfo[]  providerInfo,
1:eac0369: 		UUID			compSchemaId)
1:eac0369: 	{
1:eac0369: 		return new CreateViewConstantAction( schemaName, tableName, tableType, 
1:eac0369: 											 viewText, checkOption, columnInfo,
1:eac0369: 											 providerInfo, compSchemaId );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 *	Make the ConstantAction for a Replicated DELETE statement.
1:eac0369: 	 *
2:eac0369: 	 *  @param conglomId			Conglomerate ID.
2:eac0369: 	 *  @param tableType			type of this table
1:eac0369: 	 *	@param heapSCOCI			StaticCompiledOpenConglomInfo for heap.
1:eac0369: 	 *  @param irgs					Index descriptors
1:eac0369: 	 *  @param indexCIDS			Conglomerate IDs of indices
2:eac0369: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
1:eac0369: 	 *	@param deferred				True means deferred delete
1:eac0369: 	 *  @param tableIsPublished		true if table is published
1:eac0369: 	 *  @param tableID				table id
1:eac0369: 	 *	@param lockMode				The lock mode to use
1:eac0369: 	 *								  (row or table, see TransactionController)
1:eac0369: 	 *  @param keySignature     	signature for the key(null for source)
1:eac0369: 	 *  @param keyPositions     	positions of primary key columns in base row
1:eac0369: 	 *  @param keyConglomId  		conglomerate id for the key
1:eac0369: 	 *								(-1 for the souce)
1:eac0369: 	 *  @param schemaName    		schemaName(null for source)
1:eac0369: 	 *  @param tableName        	tableName(null for source)
1:eac0369: 	 *  @param resultDescription	A description of the columns in the row
1:eac0369: 	 *			to be deleted.  Only set in replication or during cascade Delete.
1:eac0369: 	 *	@param fkInfo				Array of structures containing foreign key 
1:eac0369: 	 *								info, if any (may be null)
1:eac0369: 	 *	@param triggerInfo			Array of structures containing trigger
1:eac0369: 	 *								info, if any (may be null)
1:eac0369: 
1:eac0369: 	 *  @param numColumns			Number of columns to read
1:eac0369: 	 *  @param dependencyId			UUID for dependency system
2:eac0369: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
1:dbed020: 	 *	@param baseRowReadMap		BaseRowReadMap[heapColId]-&gt;ReadRowColumnId.
2:eac0369:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1:eac0369: 	 *  @param singleRowSource		Whether or not source is a single row source
1:01632c2: 	 *  @param underMerge   True if this is an action of a MERGE statement.
1:eac0369: 	 *
1:eac0369: 	 *  @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getDeleteConstantAction
1:eac0369: 	(
2:eac0369: 								long				conglomId,
2:eac0369: 								int					tableType,
1:eac0369: 								StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 								IndexRowGenerator[]	irgs,
1:eac0369: 								long[]				indexCIDS,
1:eac0369: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 								boolean				deferred,
2:eac0369: 								boolean				tableIsPublished,
1:eac0369: 								UUID				tableID,
1:eac0369: 								int					lockMode,
1:eac0369: 								Object         		deleteToken,
1:eac0369: 								Object		     	keySignature,
1:eac0369: 								int[]				keyPositions,
1:eac0369: 								long                keyConglomId,
1:eac0369: 								String				schemaName,
1:eac0369: 								String				tableName,
1:eac0369: 								ResultDescription	resultDescription,
1:eac0369: 								FKInfo[]			fkInfo,
1:eac0369: 								TriggerInfo			triggerInfo,
2:eac0369: 								FormatableBitSet				baseRowReadList,
1:eac0369: 								int[]				baseRowReadMap,
1:eac0369: 								int[]               streamStorableHeapColIds,
1:eac0369: 								int					numColumns,
1:eac0369: 								UUID				dependencyId,
1:eac0369: 								boolean				singleRowSource,
1:01632c2: 								ConstantAction[]	dependentConstantActions,
1:01632c2: 								boolean				underMerge
1:eac0369: 	)
4:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		// ignore replication args, which should be null
1:eac0369: 		return new DeleteConstantAction(
2:eac0369: 										conglomId,
1:eac0369: 										heapSCOCI,
1:eac0369: 										irgs,
1:eac0369: 										indexCIDS,
1:eac0369: 										indexSCOCIs,
1:eac0369: 										deferred,
1:eac0369: 										tableID,
1:eac0369: 										lockMode,
1:eac0369: 										fkInfo,
1:eac0369: 										triggerInfo,
1:eac0369: 										baseRowReadList,
1:eac0369: 										baseRowReadMap,
1:eac0369: 										streamStorableHeapColIds,
1:eac0369: 										numColumns,
1:01632c2: 										singleRowSource,
1:eac0369: 										resultDescription,
1:01632c2: 										dependentConstantActions,
1:01632c2: 										underMerge
1:eac0369: 										);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make ConstantAction to drop a constraint.
1:eac0369: 	 *
1:eac0369: 	 *  @param constraintName	Constraint name.
1:eac0369: 	 *	@param constraintSchemaName		Constraint Schema Name
1:eac0369: 	 *  @param tableName		Table name.
1:eac0369: 	 *	@param tableId			UUID of table.
1:eac0369: 	 *  @param tableSchemaName				the schema that table lives in.
1:eac0369: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1:eac0369: 	 *	@param behavior			The drop behavior (e.g. StatementType.RESTRICT)
1:eac0369:      *  @param verifyType       Verify that the constraint is of this type.
1:eac0369: 	 */
1:eac0369: 	public	ConstraintConstantAction	getDropConstraintConstantAction
1:eac0369: 	(
1:eac0369: 		String					constraintName,
1:eac0369: 		String					constraintSchemaName,
1:eac0369: 		String					tableName,
1:eac0369: 		UUID					tableId,
1:eac0369: 		String					tableSchemaName,
1:eac0369: 		IndexConstantAction indexAction,
1:eac0369: 		int						behavior,
1:eac0369:         int                     verifyType
1:eac0369:     )
1:eac0369: 	{
1:eac0369: 		return	new DropConstraintConstantAction( constraintName, constraintSchemaName, tableName, 
1:eac0369: 												  tableId, tableSchemaName, indexAction, behavior, verifyType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      *  Make ConstantAction to drop a constraint.
1:09bee7d:      *
1:09bee7d:      *  @param constraintName   Constraint name.
1:09bee7d:      *  @param constraintSchemaName     Constraint Schema Name
1:09bee7d:      *  @param characteristics  The presumably altered characteristics
1:09bee7d:      *  @param tableName        Table name.
1:09bee7d:      *  @param tableId          UUID of table.
1:09bee7d:      *  @param tableSchemaName  The schema that table lives in.
1:09bee7d:      *  @param indexAction      IndexConstantAction for constraint (if necessary)
1:09bee7d:      */
1:09bee7d:     public  ConstraintConstantAction    getAlterConstraintConstantAction
1:09bee7d:     (
1:09bee7d:         String                  constraintName,
1:09bee7d:         String                  constraintSchemaName,
1:09bee7d:         boolean[]               characteristics,
1:09bee7d:         String                  tableName,
1:09bee7d:         UUID                    tableId,
1:09bee7d:         String                  tableSchemaName,
1:09bee7d:         IndexConstantAction     indexAction
1:09bee7d:     )
1:09bee7d:     {
1:09bee7d:         return  new AlterConstraintConstantAction(
1:09bee7d:                 constraintName,
1:09bee7d:                 constraintSchemaName,
1:09bee7d:                 characteristics,
1:09bee7d:                 tableName,
1:09bee7d:                 tableId,
1:09bee7d:                 tableSchemaName,
1:09bee7d:                 indexAction);
1:09bee7d:     }
1:09bee7d: 
1:09bee7d: 
1:09bee7d:     /**
1:eac0369: 	 *	Make the ConstantAction for a DROP INDEX statement.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 *	@param	fullIndexName		Fully qualified index name
1:eac0369: 	 *	@param	indexName			Index name.
1:eac0369: 	 *	@param	tableName			The table name
1:eac0369: 	 *	@param	schemaName					Schema that index lives in.
1:eac0369: 	 *  @param  tableId				UUID for table
1:eac0369: 	 *  @param  tableConglomerateId	heap conglomerate ID for table
1:eac0369: 	 *
1:eac0369: 	 */
1:05623b6:     public IndexConstantAction getDropIndexConstantAction
1:eac0369: 	(
1:eac0369: 		String				fullIndexName,
1:eac0369: 		String				indexName,
1:eac0369: 		String				tableName,
1:eac0369: 		String				schemaName,
1:eac0369: 		UUID				tableId,
1:eac0369: 		long				tableConglomerateId
1:eac0369:     )
1:eac0369: 	{
1:eac0369: 		return	new DropIndexConstantAction( fullIndexName, indexName, tableName, schemaName,
1:eac0369: 											 tableId, tableConglomerateId );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a DROP ALIAS statement.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 *	@param	aliasName			Alias name.
1:eac0369: 	 *	@param	aliasType			Alias type.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getDropAliasConstantAction(SchemaDescriptor	sd, String aliasName, char aliasType)
1:eac0369: 	{
1:eac0369: 		return	new DropAliasConstantAction(sd, aliasName, aliasType );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:ee59de8: 	 *	Make the ConstantAction for a DROP ROLE statement.
1:ee59de8: 	 *
1:ee59de8: 	 *	@param	roleName			role name to be dropped
1:ee59de8: 	 *
1:ee59de8: 	 */
1:ee59de8: 	public ConstantAction getDropRoleConstantAction(String roleName)
1:ee59de8: 	{
1:ee59de8: 		return new DropRoleConstantAction(roleName);
1:ee59de8: 	}
1:ee59de8: 
1:80eb35f:     /**
1:80eb35f: 	 *	Make the ConstantAction for a DROP SEQUENCE statement.
1:80eb35f: 	 *
1:80eb35f:      *  @param sd the schema the sequence object belongs to
1:80eb35f: 	 *	@param	seqName	name of sequence to be dropped
1:80eb35f: 	 *
1:80eb35f: 	 */
1:80eb35f: 	public ConstantAction getDropSequenceConstantAction(SchemaDescriptor sd, String seqName)
1:80eb35f: 	{
1:80eb35f: 		return new DropSequenceConstantAction(sd, seqName);
1:80eb35f: 	}
1:80eb35f: 
1:ee59de8: 
1:80eb35f:     /**
1:ee59de8: 	 *	Make the ConstantAction for a DROP SCHEMA statement.
1:eac0369: 	 *
1:eac0369: 	 *	@param	schemaName			Table name.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getDropSchemaConstantAction(String	schemaName)
1:eac0369: 	{
1:eac0369: 		return	new DropSchemaConstantAction( schemaName );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:ee59de8: 	/**
2:eac0369: 	 *	Make the ConstantAction for a DROP TABLE statement.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 *	@param	fullTableName		Fully qualified table name
1:eac0369: 	 *	@param	tableName			Table name.
1:eac0369: 	 *	@param	sd					Schema that table lives in.
1:6b50965: 	 *  @param  conglomerateNumber	Conglomerate number for heap
1:eac0369: 	 *  @param  tableId				UUID for table
1:eac0369: 	 *  @param  behavior			drop behavior, CASCADE, RESTRICT or DEFAULT
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getDropTableConstantAction
1:eac0369: 	(
1:eac0369: 		String				fullTableName,
1:eac0369: 		String				tableName,
3:eac0369: 		SchemaDescriptor	sd,
1:eac0369: 		long				conglomerateNumber,
1:eac0369: 		UUID				tableId,
1:eac0369: 		int					behavior
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return	new DropTableConstantAction( fullTableName, tableName, sd, conglomerateNumber, tableId, behavior );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a DROP VIEW statement.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 *	@param	fullTableName		Fully qualified table name
1:eac0369: 	 *	@param	tableName			Table name.
1:eac0369: 	 *	@param	sd					Schema that view lives in.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getDropViewConstantAction
1:eac0369: 	(
1:eac0369: 		String				fullTableName,
1:eac0369: 		String				tableName,
1:eac0369: 		SchemaDescriptor	sd
1:eac0369:     )
1:eac0369: 	{
1:eac0369: 		return new DropViewConstantAction( fullTableName, tableName, sd );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a RENAME TABLE/COLUMN/INDEX statement.
1:eac0369: 	 *
1:eac0369: 	 *	@param	fullTableName Fully qualified table name
1:eac0369: 	 *	@param	tableName   Table name.
1:eac0369: 	 *	@param	oldObjectName   Old object name
1:eac0369: 	 *	@param	newObjectName   New object name.
1:eac0369: 	 *	@param	sd    Schema that table lives in.
1:eac0369: 	 *	@param	tableId   UUID for table
1:eac0369: 	 *  @param	usedAlterTable	True if used Alter Table command, false if used Rename
1:eac0369: 	 *  @param	renamingWhat	Value indicates if Rename Column/Index.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getRenameConstantAction
1:eac0369: 	(
1:eac0369: 		String				fullTableName,
1:eac0369: 		String				tableName,
1:eac0369: 		String				oldObjectName,
1:eac0369: 		String				newObjectName,
1:eac0369: 		SchemaDescriptor	sd,
1:eac0369: 		UUID				tableId,
1:eac0369: 		boolean				usedAlterTable,
1:eac0369: 		int				renamingWhat
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return	new RenameConstantAction( fullTableName, tableName, oldObjectName, newObjectName,
1:eac0369: 		sd, tableId, usedAlterTable, renamingWhat );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:af1c18c:      *  Make the ConstantAction for a INSERT statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param conglomId		Conglomerate ID.
1:eac0369: 	 *  @param heapSCOCI		StaticCompiledOpenConglomInfo for target heap.
1:eac0369: 	 *  @param irgs				Index descriptors
1:eac0369: 	 *  @param indexCIDS		Conglomerate IDs of indices
1:eac0369: 	 *	@param indexSCOCIs		StaticCompiledOpenConglomInfos for indexes.
1:eac0369: 	 *  @param indexNames		Names of indices on this table for error 
1:eac0369: 	 *							reporting.
1:eac0369: 	 *	@param deferred			True means deferred insert
1:eac0369: 	 *  @param tableIsPublished	true if table is published, false otherwise
1:eac0369: 	 *  @param tableID			table id
1:af1c18c:      *  @param hasDeferrableChecks
1:af1c18c:      *                          The target table has deferrable CHECK
1:af1c18c:      *                          constraints
1:af1c18c:      *  @param targetProperties Properties on the target table
1:eac0369: 	 *	@param fkInfo			Array of structures containing foreign key info, 
1:eac0369: 	 *							if any (may be null)
1:eac0369: 	 *	@param triggerInfo		Array of structures containing trigger info, 
1:eac0369:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1:eac0369: 	 *							if any (may be null)
1:eac0369: 	 *  @param indexedCols		boolean[] of which (0-based) columns are indexed.
1:eac0369: 	 *  @param dependencyId		UUID for dependency system
1:eac0369: 	 *	@param stageControl		Stage Control Tokens
1:eac0369: 	 *	@param ddlList			List of DDL to log. This is for BULK INSERT into a published table at the Source.
1:eac0369: 	 *  @param singleRowSource	Whether or not source is a single row source
1:eac0369: 	 *  @param autoincRowLocation array of row locations into syscolumns for
1:eac0369: 	                              autoincrement columns
1:01632c2: 	 *  @param underMerge   True if this is an INSERT action of a MERGE statement.
1:a180287: 	 *  @param identitySequenceUUIDString   For 10.11 and higher, the handle on the sequence for the identity column
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction getInsertConstantAction(
1:eac0369: 								TableDescriptor		tableDescriptor,
1:eac0369: 								long				conglomId,
1:eac0369: 								StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 								IndexRowGenerator[]	irgs,
1:eac0369: 								long[]				indexCIDS,
1:eac0369: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 								String[]			indexNames,
1:eac0369: 								boolean				deferred,
1:af1c18c:                                 boolean             tableIsPublished,
1:af1c18c:                                 boolean             hasDeferrableChecks,
1:eac0369: 								UUID				tableID,
1:eac0369: 								int					lockMode,
1:eac0369: 								Object         		insertToken,
1:eac0369: 								Object				rowSignature,
1:eac0369: 								Properties			targetProperties,
1:eac0369: 								FKInfo[]			fkInfo,
1:eac0369: 								TriggerInfo			triggerInfo,
1:eac0369: 								int[]               streamStorableHeapColIds,
1:eac0369: 								boolean[]			indexedCols,
1:eac0369: 								UUID				dependencyId,
1:eac0369: 								Object[]			stageControl,
1:eac0369: 								Object[]			ddlList,
1:eac0369: 								boolean				singleRowSource,
1:01632c2: 								RowLocation[]		autoincRowLocation,
1:a180287: 								boolean		underMerge,
1:a180287: 								String		identitySequenceUUIDString
1:eac0369: 							)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new InsertConstantAction(tableDescriptor,
1:eac0369: 										conglomId,
1:eac0369: 										heapSCOCI,
1:eac0369: 										irgs,
1:eac0369: 										indexCIDS,
1:eac0369: 										indexSCOCIs,
1:eac0369: 										indexNames,
1:eac0369: 										deferred,
1:af1c18c:                                         hasDeferrableChecks,
1:eac0369: 										targetProperties,
1:eac0369: 										tableID,
1:eac0369: 										lockMode,
1:eac0369: 										fkInfo,
1:eac0369: 										triggerInfo,
1:eac0369: 										streamStorableHeapColIds,
1:eac0369: 										indexedCols,
1:eac0369: 										singleRowSource,
1:01632c2: 										autoincRowLocation,
1:a180287: 										underMerge,
1:a180287: 										identitySequenceUUIDString
1:eac0369: 										);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for an updatable VTI statement.
1:eac0369: 	 *
1:09bee7d:      * @param statementType             Statement type, cf.
1:09bee7d:      * {@link org.apache.derby.vti.DeferModification#INSERT_STATEMENT} etc.
1:09bee7d:      * @param deferred                  Deferred processing mode?
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public ConstantAction getUpdatableVTIConstantAction( int statementType, boolean deferred)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new UpdatableVTIConstantAction( statementType, deferred, null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for an updatable VTI statement.
1:eac0369: 	 *
1:09bee7d:      * @param statementType    Statement type, cf.
1:09bee7d:      * {@link org.apache.derby.vti.DeferModification#INSERT_STATEMENT} etc.
1:09bee7d:      * @param deferred         Deferred processing mode?
1:eac0369:      * @param changedColumnIds Array of ids of changed columns
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public ConstantAction getUpdatableVTIConstantAction( int statementType,
1:eac0369:                                                          boolean deferred,
1:eac0369:                                                          int[] changedColumnIds)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new UpdatableVTIConstantAction( statementType, deferred, changedColumnIds);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make the ConstantAction for a LOCK TABLE statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param fullTableName		Full name of the table.
1:eac0369: 	 *  @param conglomerateNumber	Conglomerate number for the heap
1:eac0369: 	 *  @param exclusiveMode		Whether or not to get an exclusive lock.
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getLockTableConstantAction(
1:eac0369: 					String fullTableName,
1:eac0369: 					long conglomerateNumber, boolean exclusiveMode)
1:eac0369: 	{
1:eac0369: 		return new LockTableConstantAction( 
1:eac0369: 						fullTableName, conglomerateNumber, exclusiveMode );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make the ConstantAction for a SET SCHEMA statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param schemaName	Name of schema.
1:eac0369: 	 *  @param type			Literal, USER or ?
1:eac0369: 	 */
1:eac0369: 	public	ConstantAction	getSetSchemaConstantAction(String schemaName, int type)
1:eac0369: 	{
1:eac0369: 		return new SetSchemaConstantAction( schemaName , type );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make the ConstantAction for a SET TRANSACTION ISOLATION statement.
1:eac0369: 	 *
1:eac0369: 	 * @param isolationLevel	The new isolation level.
1:eac0369: 	 */
1:eac0369: 	public ConstantAction getSetTransactionIsolationConstantAction(int isolationLevel)
1:eac0369: 	{
1:eac0369: 		return new SetTransactionIsolationConstantAction(isolationLevel);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:af1c18c:      *  Make the ConstantAction for an UPDATE statement.
1:eac0369: 	 *
1:af1c18c:      *  @param targetTableDesc      Descriptor for the updated table
1:eac0369: 	 *	@param heapSCOCI			StaticCompiledOpenConglomInfo for heap.
1:eac0369: 	 *  @param irgs					Index descriptors
1:eac0369: 	 *  @param indexCIDS			Conglomerate IDs of indices
1:af1c18c:      *  @param indexSCOCIs          StaticCompiledOpenConglomInfos for indexes.
1:af1c18c:      *  @param indexNames
1:eac0369: 	 *	@param deferred				True means deferred update
1:eac0369: 	 *	@param targetUUID			UUID of target table
1:eac0369: 	 *	@param lockMode				The lock mode to use
1:eac0369: 	 *								  (row or table, see TransactionController)
1:eac0369: 	 *  @param tableIsPublished		true if table is published, false otherwise
1:eac0369: 	 *	@param changedColumnIds		Array of ids of changes columns
1:eac0369: 	 *  @param keyPositions     	positions of primary key columns in base row
1:af1c18c:      *  @param updateToken
1:eac0369: 	 *	@param fkInfo				Array of structures containing foreign key info, 
2:eac0369: 	 *								if any (may be null)
1:eac0369: 	 *	@param triggerInfo			Array of structures containing trigger info, 
1:eac0369: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
1:eac0369: 	 *  @param baseRowReadMap		map of columns to be selected from the base row
1:eac0369: 	 *								(partial row). 1 based.
1:eac0369:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1:eac0369: 	 *  @param numColumns			The number of columns being read.
1:eac0369: 	 *	@param positionedUpdate		is this a positioned update
1:eac0369: 	 *  @param singleRowSource		Whether or not source is a single row source
1:a826375: 	 *  @param autoincRowLocation array of row locations into syscolumns for
1:a826375: 	                              autoincrement columns
1:01632c2: 	 *  @param underMerge   True if this is an action of a MERGE statement.
1:a826375: 	 *  @param identitySequenceUUIDString   For 10.11 and higher, the handle on the sequence for the identity column
1:af1c18c:      *  @return                     The constant action constructed
1:eac0369: 	 *
1:eac0369: 	 *  @exception StandardException Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public	UpdateConstantAction	getUpdateConstantAction(
1:af1c18c:                                 TableDescriptor     targetTableDesc,
1:eac0369: 								StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 								IndexRowGenerator[]	irgs,
1:eac0369: 								long[]				indexCIDS,
1:eac0369: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 								String[]			indexNames,	
1:eac0369: 								boolean				deferred,
1:eac0369: 								UUID				targetUUID,
1:eac0369: 								int					lockMode,
1:eac0369: 								boolean				tableIsPublished,
1:eac0369: 								int[]				changedColumnIds,
1:eac0369: 								int[]				keyPositions,
1:eac0369: 								Object         		updateToken,
1:eac0369: 								FKInfo[]			fkInfo,
1:eac0369: 								TriggerInfo			triggerInfo,
1:af1c18c:                                 FormatableBitSet    baseRowReadList,
1:eac0369: 								int[]				baseRowReadMap,
1:eac0369: 								int[]				streamStorableHeapColIds,
1:eac0369: 								int					numColumns,
1:eac0369: 								boolean				positionedUpdate,
1:01632c2: 								boolean				singleRowSource,
1:a826375: 								RowLocation[]		autoincRowLocation,
1:a826375: 								boolean				underMerge,
1:a826375: 								String		identitySequenceUUIDString
1:eac0369: 							)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return new UpdateConstantAction(
1:af1c18c:                                         targetTableDesc,
1:eac0369: 										heapSCOCI,
1:eac0369: 										irgs,
1:eac0369: 										indexCIDS,
1:eac0369: 										indexSCOCIs,
1:eac0369: 										indexNames,
1:eac0369: 										deferred,
1:eac0369: 										targetUUID,
1:eac0369: 										lockMode,
1:eac0369: 										changedColumnIds,
1:eac0369: 										fkInfo,
1:eac0369: 										triggerInfo,
1:eac0369: 										baseRowReadList,
1:eac0369: 										baseRowReadMap,
1:eac0369: 										streamStorableHeapColIds,
1:eac0369: 										numColumns,
1:eac0369: 										positionedUpdate,
1:eac0369: 										singleRowSource,
1:a826375: 										autoincRowLocation,
1:a826375: 										underMerge,
1:a826375: 										identitySequenceUUIDString
1:eac0369: 										);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	static protected Authorizer getAuthorizer()
1:eac0369: 	{
1:eac0369: 		LanguageConnectionContext lcc = (LanguageConnectionContext)
1:a0dbbd7: 			getContext(LanguageConnectionContext.CONTEXT_ID);
1:eac0369: 		return lcc.getAuthorizer();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a CREATE TRIGGER statement.
1:eac0369: 	 *
1:6b50965: 	 * @param triggerSchemaName		Name of the schema that trigger lives in.
1:eac0369: 	 * @param triggerName	Name of trigger
1:eac0369: 	 * @param eventMask		TriggerDescriptor.TRIGGER_EVENT_XXXX
1:eac0369: 	 * @param isBefore		is this a before (as opposed to after) trigger 
1:eac0369: 	 * @param isRow			is this a row trigger or statement trigger
1:eac0369: 	 * @param isEnabled		is this trigger enabled or disabled
1:eac0369: 	 * @param triggerTable	the table upon which this trigger is defined
1:eac0369: 	 * @param whenSPSId		the sps id for the when clause (may be null)
1:eac0369: 	 * @param whenText		the text of the when clause (may be null)
1:eac0369: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1:eac0369: 	 * @param actionText	the text of the trigger action (may be null)
1:eac0369: 	 * @param spsCompSchemaId	the compilation schema for the action and when
1:eac0369: 	 *							spses.   If null, will be set to the current default
1:eac0369: 	 *							schema
1:eac0369: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1:a6f9586: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1:a6f9586: 	 *						action reference through old/new transition variables
1:a6f9586: 	 *						(may be null)
1:d9878ca:      * @param originalWhenText The original user text of the WHEN clause (may be null)
1:eac0369: 	 * @param originalActionText The original user text of the trigger action
1:eac0369: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1:eac0369: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1:eac0369: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
1:eac0369: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
1:cc67949:      * @param providerInfo array of providers that the trigger depends on
1:eac0369: 	 */
1:eac0369: 	public ConstantAction getCreateTriggerConstantAction
1:eac0369: 	(
1:eac0369: 		String				triggerSchemaName,
1:eac0369: 		String				triggerName,
1:eac0369: 		int					eventMask,
1:eac0369: 		boolean				isBefore,
1:eac0369: 		boolean 			isRow,
1:eac0369: 		boolean 			isEnabled,
1:eac0369: 		TableDescriptor		triggerTable,
1:eac0369: 		UUID				whenSPSId,
1:eac0369: 		String				whenText,
1:eac0369: 		UUID				actionSPSId,
1:eac0369: 		String				actionText,
1:eac0369: 		UUID				spsCompSchemaId,
1:eac0369: 		int[]				referencedCols,
1:a6f9586: 		int[]				referencedColsInTriggerAction,
1:d9878ca:         String              originalWhenText,
1:eac0369: 		String				originalActionText,
1:eac0369: 		boolean				referencingOld,
1:eac0369: 		boolean				referencingNew,
1:eac0369: 		String				oldReferencingName,
1:cc67949:         String              newReferencingName,
1:cc67949:         ProviderInfo[]      providerInfo
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return new CreateTriggerConstantAction(triggerSchemaName, triggerName, 
1:eac0369: 				eventMask, isBefore, isRow, isEnabled, triggerTable, whenSPSId,
1:6bd3847:                 whenText, actionSPSId, actionText, spsCompSchemaId,
1:d9878ca:                 referencedCols, referencedColsInTriggerAction,
1:d9878ca:                 originalWhenText, originalActionText,
1:cc67949:                 referencingOld, referencingNew,
1:cc67949:                 oldReferencingName, newReferencingName, providerInfo);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make the ConstantAction for a DROP TRIGGER statement.
1:eac0369: 	 *
1:eac0369: 	 * @param	sd					Schema that stored prepared statement lives in.
1:eac0369: 	 * @param	triggerName			Name of the Trigger
1:eac0369: 	 * @param	tableId				The table this trigger is defined upon
1:eac0369: 	 */
1:eac0369: 	public ConstantAction getDropTriggerConstantAction
1:eac0369: 	(
1:eac0369: 		SchemaDescriptor	sd,
1:eac0369: 		String				triggerName,
1:eac0369: 		UUID				tableId
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return new DropTriggerConstantAction(sd, triggerName, tableId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make the constant action for Drop Statistics statement.
1:eac0369: 	 *
1:eac0369: 	 * @param sd			Schema Descriptor of the schema in which the object 
1:eac0369: 	 * resides. 
1:eac0369: 	 * @param fullTableName full name of the object for which statistics are
1:eac0369: 	 * being dropped.
1:eac0369: 	 * @param objectName	 object name for which statistics are being dropped.
1:eac0369: 	 * @param forTable 		 is it an index or table whose statistics aer being
1:eac0369: 	 * consigned to the garbage heap?
1:eac0369: 	 */
1:eac0369: 	public ConstantAction getDropStatisticsConstantAction
1:eac0369: 		(SchemaDescriptor sd, String fullTableName, String objectName, boolean forTable)
1:eac0369: 	{
1:eac0369: 		return new DropStatisticsConstantAction(sd, fullTableName, objectName, forTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Make the constant action for a Grant statement
1:eac0369: 	 *
1:b7730e4: 	 * @param privileges The list of privileges to be granted
1:b7730e4: 	 * @param grantees The list of grantees
1:eac0369: 	 */
1:b7730e4: 	public ConstantAction getGrantConstantAction( PrivilegeInfo privileges,
1:b7730e4: 								List grantees)
1:eac0369: 	{
1:b7730e4: 		return new GrantRevokeConstantAction( true, privileges, grantees);
1:eac0369: 	}
1:ee59de8: 
1:eac0369: 
1:ee59de8:     /**
1:ee59de8: 	 * Make the ConstantAction for a GRANT role statement.
1:ee59de8: 	 *
1:ee59de8: 	 * @param roleNames list of roles to be granted
1:ee59de8: 	 * @param grantees  list of authentication ids (user or roles) to
1:ee59de8: 	 *                  which roles(s) are to be granted
1:ee59de8: 	 */
1:ee59de8: 	public ConstantAction getGrantRoleConstantAction(List roleNames,
1:ee59de8: 													 List grantees)
1:ee59de8: 	{
1:ee59de8: 		return new GrantRoleConstantAction(roleNames, grantees);
1:ee59de8: 	}
1:ee59de8: 
1:ee59de8: 
1:eac0369: 	/**
1:b7730e4: 	 * Make the constant action for a Revoke statement
1:eac0369: 	 * 
1:b7730e4: 	 * @param privileges The list of privileges to be revokeed
1:b7730e4: 	 * @param grantees The list of grantees
1:eac0369: 	 */
1:b7730e4: 	public ConstantAction getRevokeConstantAction( PrivilegeInfo privileges,
1:b7730e4: 								List grantees)
1:eac0369: 	{
1:b7730e4: 		return new GrantRevokeConstantAction( false, privileges, grantees);
1:eac0369: 	}
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     /**
1:ee59de8: 	 * Make the ConstantAction for a REVOKE role statement.
1:ee59de8: 	 *
1:ee59de8: 	 * @param roleNames list of roles to be revoked
1:ee59de8: 	 * @param grantees  list of authentication ids (user or roles) for whom
1:ee59de8: 	 *                  roles are to be revoked
1:ee59de8: 	 */
1:ee59de8: 	public ConstantAction getRevokeRoleConstantAction(List roleNames,
1:ee59de8: 													  List grantees)
1:ee59de8: 	{
1:ee59de8: 		return new RevokeRoleConstantAction(roleNames, grantees);
1:ee59de8: 	}
1:508a010: 
1:508a010: 	/**
1:508a010: 	 * Make the ConstantAction for a WHEN [ NOT ] MATCHED clause.
1:508a010: 	 */
1:508a010: 	public	ConstantAction	getMatchingClauseConstantAction
1:508a010: 	(
1:508a010:          int    clauseType,
1:508a010:          String matchRefinementName,
1:01632c2:          ResultDescription  thenColumnSignature,
1:01632c2:          String rowMakingMethodName,
1:508a010:          String resultSetFieldName,
1:508a010:          String actionMethodName,
1:508a010:          ConstantAction thenAction
1:508a010:      )
1:508a010: 	{
1:508a010: 		return new MatchingClauseConstantAction
1:01632c2:             (
1:01632c2:              clauseType,
1:01632c2:              matchRefinementName,
1:01632c2:              thenColumnSignature,
1:01632c2:              rowMakingMethodName,
1:01632c2:              resultSetFieldName,
1:01632c2:              actionMethodName,
1:01632c2:              thenAction
1:01632c2:              );
1:508a010: 	}
1:508a010: 
1:508a010: 	/**
1:508a010: 	 * Make the ConstantAction for a MERGE statement.
1:508a010: 	 */
1:508a010: 	public	MergeConstantAction	getMergeConstantAction
1:508a010:         (
1:508a010:          ConstantAction[] matchingClauses
1:508a010:          )
1:508a010: 	{
1:508a010: 		return new MergeConstantAction( matchingClauses );
1:508a010: 	}
1:508a010: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContext( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContext( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *	@param baseRowReadMap		BaseRowReadMap[heapColId]-&gt;ReadRowColumnId.
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 			getContext(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContext( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:a180287
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param identitySequenceUUIDString   For 10.11 and higher, the handle on the sequence for the identity column
/////////////////////////////////////////////////////////////////////////
1: 								boolean		underMerge,
1: 								String		identitySequenceUUIDString
/////////////////////////////////////////////////////////////////////////
1: 										underMerge,
1: 										identitySequenceUUIDString
commit:0ae3b6d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param underMerge   True if this is an action of a MERGE statement.
/////////////////////////////////////////////////////////////////////////
1: 								ConstantAction[]	dependentConstantActions,
1: 								boolean				underMerge
/////////////////////////////////////////////////////////////////////////
1: 										dependentConstantActions,
1: 										underMerge
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param underMerge   True if this is an INSERT action of a MERGE statement.
/////////////////////////////////////////////////////////////////////////
1: 								RowLocation[]		autoincRowLocation,
0: 								boolean		underMerge
/////////////////////////////////////////////////////////////////////////
1: 										autoincRowLocation,
0: 										underMerge
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param underMerge   True if this is an action of a MERGE statement.
/////////////////////////////////////////////////////////////////////////
1: 								boolean				singleRowSource,
0: 								boolean				underMerge
/////////////////////////////////////////////////////////////////////////
1: 										singleRowSource,
0: 										underMerge
/////////////////////////////////////////////////////////////////////////
1:          ResultDescription  thenColumnSignature,
1:          String rowMakingMethodName,
/////////////////////////////////////////////////////////////////////////
1:             (
1:              clauseType,
1:              matchRefinementName,
1:              thenColumnSignature,
1:              rowMakingMethodName,
0:              thenColumns,
1:              resultSetFieldName,
1:              actionMethodName,
1:              thenAction
1:              );
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Make the ConstantAction for a WHEN [ NOT ] MATCHED clause.
1: 	 */
1: 	public	ConstantAction	getMatchingClauseConstantAction
1: 	(
1:          int    clauseType,
1:          String matchRefinementName,
0:          int[]  thenColumns,
1:          String resultSetFieldName,
1:          String actionMethodName,
1:          ConstantAction thenAction
1:      )
1: 	{
1: 		return new MatchingClauseConstantAction
0:             ( clauseType, matchRefinementName, thenColumns, resultSetFieldName, actionMethodName, thenAction );
1: 	}
1: 
1: 	/**
1: 	 * Make the ConstantAction for a MERGE statement.
1: 	 */
1: 	public	MergeConstantAction	getMergeConstantAction
1:         (
1:          ConstantAction[] matchingClauses
1:          )
1: 	{
1: 		return new MergeConstantAction( matchingClauses );
1: 	}
1: 
commit:bb21983
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:      * @param dataType
1:      * @param initialValue
1:      * @param stepValue
1:      * @param maxValue
1:      * @param minValue
1:      * @param cycle
1: 	public	ConstantAction	getCreateSequenceConstantAction
1:     (
1:             TableName   sequenceName,
1:             DataTypeDescriptor dataType,
1:             long        initialValue,
1:             long        stepValue,
1:             long        maxValue,
1:             long        minValue,
1:             boolean     cycle
1:     )
1:         return new CreateSequenceConstantAction(sequenceName.getSchemaName(),
1:                 sequenceName.getTableName(),
1:                 dataType,
1:                 initialValue,
1:                 stepValue,
1:                 maxValue,
1:                 minValue,
1:                 cycle);
commit:80eb35f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.compile.TableName;
/////////////////////////////////////////////////////////////////////////
1:     /**
1: 	 * Make the ConstantAction for a CREATE SEQUENCE statement.
1: 	 *
1: 	 * @param sequenceName	Name of sequence.
1: 	 */
0: 	public	ConstantAction	getCreateSequenceConstantAction(TableName sequenceName)
1: 	{
0:         return new CreateSequenceConstantAction(sequenceName.getSchemaName(), sequenceName.getTableName());
1: 	}
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
1: 	 *	Make the ConstantAction for a DROP SEQUENCE statement.
1: 	 *
1:      *  @param sd the schema the sequence object belongs to
1: 	 *	@param	seqName	name of sequence to be dropped
1: 	 *
1: 	 */
1: 	public ConstantAction getDropSequenceConstantAction(SchemaDescriptor sd, String seqName)
1: 	{
1: 		return new DropSequenceConstantAction(sd, seqName);
1: 	}
1: 
1:     /**
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a826375
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param autoincRowLocation array of row locations into syscolumns for
1: 	                              autoincrement columns
1: 	 *  @param identitySequenceUUIDString   For 10.11 and higher, the handle on the sequence for the identity column
/////////////////////////////////////////////////////////////////////////
1: 								RowLocation[]		autoincRowLocation,
1: 								boolean				underMerge,
1: 								String		identitySequenceUUIDString
/////////////////////////////////////////////////////////////////////////
1: 										autoincRowLocation,
1: 										underMerge,
1: 										identitySequenceUUIDString
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param dropStatistics		TRUE means we are here to drop statistics
1: 	 *  @param dropStatisticsAll	TRUE means we are here to drop statistics
1: 	 *  	of all the indexes. False means we are here to drop statistics of
1: 	 *  	only one index.
1: 	 *  @param indexNameForStatistics	Will name the index whose statistics
1: 	 *  	will be updated/dropped. This param is looked at only if 
1: 	 *  	updateStatisticsAll/dropStatisticsAll is set to false and
1: 	 *  	updateStatistics/dropStatistics is set to true.
1: 	 *  .
/////////////////////////////////////////////////////////////////////////
1: 		boolean						dropStatistics,
1: 		boolean						dropStatisticsAll,
1: 		String						indexNameForStatistics
/////////////////////////////////////////////////////////////////////////
1: 											  dropStatistics, 
1: 											  dropStatisticsAll,
1: 											  indexNameForStatistics);
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1: 	 *						action reference through old/new transition variables
1: 	 *						(may be null)
/////////////////////////////////////////////////////////////////////////
1: 		int[]				referencedColsInTriggerAction,
/////////////////////////////////////////////////////////////////////////
0: 				referencedCols, referencedColsInTriggerAction, originalActionText,
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param updateStatistics		TRUE means we are here to update statistics
1: 	 *  @param updateStatisticsAll	TRUE means we are here to update statistics
1: 	 *  	of all the indexes. False means we are here to update statistics of
1: 	 *  	only one index.
0: 	 *  @param indexNameForUpdateStatistics	Will name the index whose statistics
0: 	 *  	will be updated. This param is looked at only if updateStatisticsAll
0: 	 *  	is set to false.
/////////////////////////////////////////////////////////////////////////
1: 		boolean						truncateEndOfTable,
1: 		boolean						updateStatistics,
1: 		boolean						updateStatisticsAll,
0: 		String						indexNameForUpdateStatistics
1: 											  purge, defragment, truncateEndOfTable,
1: 											  updateStatistics, 
1: 											  updateStatisticsAll,
0: 											  indexNameForUpdateStatistics);
/////////////////////////////////////////////////////////////////////////
commit:818fd27
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param truncateTable	    Whether or not this is a truncate table
1: 	 *  @param purge				PURGE during INPLACE COMPRESS?
1: 	 *  @param defragment			DEFRAGMENT during INPLACE COMPRESS?
1: 	 *  @param truncateEndOfTable	TRUNCATE END during INPLACE COMPRESS?
/////////////////////////////////////////////////////////////////////////
1: 		boolean                     truncateTable,
1: 		boolean						purge,
1: 		boolean						defragment,
0: 		boolean						truncateEndOfTable 
1: 											  behavior, sequential, truncateTable,
0: 											  purge, defragment, truncateEndOfTable);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2db96c5
/////////////////////////////////////////////////////////////////////////
1:      * @param constraintType  The constraint type
/////////////////////////////////////////////////////////////////////////
1:         int             constraintType,
/////////////////////////////////////////////////////////////////////////
1:             constraintType,
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:      *  Make the ConstantAction for a INSERT statement.
/////////////////////////////////////////////////////////////////////////
1:      *  @param hasDeferrableChecks
1:      *                          The target table has deferrable CHECK
1:      *                          constraints
1:      *  @param targetProperties Properties on the target table
/////////////////////////////////////////////////////////////////////////
1:                                 boolean             tableIsPublished,
1:                                 boolean             hasDeferrableChecks,
/////////////////////////////////////////////////////////////////////////
1:                                         hasDeferrableChecks,
/////////////////////////////////////////////////////////////////////////
1:      *  Make the ConstantAction for an UPDATE statement.
1:      *  @param targetTableDesc      Descriptor for the updated table
1:      *  @param indexSCOCIs          StaticCompiledOpenConglomInfos for indexes.
1:      *  @param indexNames
/////////////////////////////////////////////////////////////////////////
1:      *  @param updateToken
/////////////////////////////////////////////////////////////////////////
1:      *  @return                     The constant action constructed
1:                                 TableDescriptor     targetTableDesc,
/////////////////////////////////////////////////////////////////////////
1:                                 FormatableBitSet    baseRowReadList,
/////////////////////////////////////////////////////////////////////////
1:                                         targetTableDesc,
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:      * @param hasDeferrableChecking True if the index is used to back a
1:      *                              deferrable constraint
1:      * @param initiallyDeferred  True means the deferrable constraint has
1:      *                           deferred mode initially.
/////////////////////////////////////////////////////////////////////////
1:         boolean         hasDeferrableChecking,
1:         boolean         initiallyDeferred,
/////////////////////////////////////////////////////////////////////////
1:         return new CreateIndexConstantAction(
1:             forCreateTable,
1:             unique,
1:             uniqueWithDuplicateNulls,
1:             hasDeferrableChecking,
1:             initiallyDeferred,
1:             indexType,
1:             schemaName,
1:             indexName,
1:             tableName,
1:             tableId,
1:             columnNames,
1:             isAscending,
1:             isConstraint,
1:             conglomerateUUID,
1:             properties);
commit:09bee7d
/////////////////////////////////////////////////////////////////////////
1:      *  @param constraints  The constraints to set, if null,
1:      *                      set them ALL.
1:      *  @param initiallyDeferred   ncodes IMMEDIATE (false), DEFERRED (true)
1:     public  ConstantAction getSetConstraintsConstantAction(
1:             List<TableName> constraints,
1:             boolean         initiallyDeferred) {
1:         return new SetConstraintsConstantAction(constraints, initiallyDeferred);
/////////////////////////////////////////////////////////////////////////
1:      *  @param constraintCharacteristics
1:      *                          Constraint characteristics, see {@link
1:      *  org.apache.derby.impl.sql.compile.ConstraintDefinitionNode#characteristics}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         boolean[]           constraintCharacteristics,
/////////////////////////////////////////////////////////////////////////
1:         return new CreateConstraintConstantAction(
1:                 constraintName,
1:                 constraintType,
1:                 constraintCharacteristics,
1:                 forCreateTable,
1:                 tableName,
1:                 tableId,
1:                 schemaName,
1:                 columnNames,
1:                 indexAction,
1:                 constraintText,
1:                 otherConstraint,
1:                 providerInfo );
/////////////////////////////////////////////////////////////////////////
1:      *  Make ConstantAction to drop a constraint.
1:      *
1:      *  @param constraintName   Constraint name.
1:      *  @param constraintSchemaName     Constraint Schema Name
1:      *  @param characteristics  The presumably altered characteristics
1:      *  @param tableName        Table name.
1:      *  @param tableId          UUID of table.
1:      *  @param tableSchemaName  The schema that table lives in.
1:      *  @param indexAction      IndexConstantAction for constraint (if necessary)
1:      */
1:     public  ConstraintConstantAction    getAlterConstraintConstantAction
1:     (
1:         String                  constraintName,
1:         String                  constraintSchemaName,
1:         boolean[]               characteristics,
1:         String                  tableName,
1:         UUID                    tableId,
1:         String                  tableSchemaName,
1:         IndexConstantAction     indexAction
1:     )
1:     {
1:         return  new AlterConstraintConstantAction(
1:                 constraintName,
1:                 constraintSchemaName,
1:                 characteristics,
1:                 tableName,
1:                 tableId,
1:                 tableSchemaName,
1:                 indexAction);
1:     }
1: 
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * @param statementType             Statement type, cf.
1:      * {@link org.apache.derby.vti.DeferModification#INSERT_STATEMENT} etc.
1:      * @param deferred                  Deferred processing mode?
/////////////////////////////////////////////////////////////////////////
1:      * @param statementType    Statement type, cf.
1:      * {@link org.apache.derby.vti.DeferModification#INSERT_STATEMENT} etc.
1:      * @param deferred         Deferred processing mode?
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1: 	 * Make the ConstantAction for a CREATE ROLE statement.
1: 	 *
1: 	 * @param roleName	Name of role.
1: 	 */
1: 	public	ConstantAction	getCreateRoleConstantAction(String roleName)
1: 	{
1: 		return new CreateRoleConstantAction(roleName);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Make the ConstantAction for a SET ROLE statement.
1: 	 *
1: 	 * @param roleName  Name of role
1: 	 * @param type      Literal (== 0)
1: 	 *                  or ?    (== StatementType.SET_ROLE_DYNAMIC)
1: 	 */
1: 	public ConstantAction getSetRoleConstantAction(String roleName,
1: 												   int type)
1: 	{
1: 		return new SetRoleConstantAction(roleName, type);
1: 	}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 *	Make the ConstantAction for a DROP ROLE statement.
1: 	 *
1: 	 *	@param	roleName			role name to be dropped
1: 	 *
1: 	 */
1: 	public ConstantAction getDropRoleConstantAction(String roleName)
1: 	{
1: 		return new DropRoleConstantAction(roleName);
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DROP SCHEMA statement.
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1: 	 * Make the ConstantAction for a GRANT role statement.
1: 	 *
1: 	 * @param roleNames list of roles to be granted
1: 	 * @param grantees  list of authentication ids (user or roles) to
1: 	 *                  which roles(s) are to be granted
1: 	 */
1: 	public ConstantAction getGrantRoleConstantAction(List roleNames,
1: 													 List grantees)
1: 	{
1: 		return new GrantRoleConstantAction(roleNames, grantees);
1: 	}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1: 	 * Make the ConstantAction for a REVOKE role statement.
1: 	 *
1: 	 * @param roleNames list of roles to be revoked
1: 	 * @param grantees  list of authentication ids (user or roles) for whom
1: 	 *                  roles are to be revoked
1: 	 */
1: 	public ConstantAction getRevokeRoleConstantAction(List roleNames,
1: 													  List grantees)
1: 	{
1: 		return new RevokeRoleConstantAction(roleNames, grantees);
1: 	}
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6bd3847
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 whenText, actionSPSId, actionText, spsCompSchemaId,
commit:cc67949
/////////////////////////////////////////////////////////////////////////
1:      * @param providerInfo array of providers that the trigger depends on
/////////////////////////////////////////////////////////////////////////
1:         String              newReferencingName,
1:         ProviderInfo[]      providerInfo
/////////////////////////////////////////////////////////////////////////
1:                 referencingOld, referencingNew,
1:                 oldReferencingName, newReferencingName, providerInfo);
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:      * @param originalWhenText The original user text of the WHEN clause (may be null)
/////////////////////////////////////////////////////////////////////////
1:         String              originalWhenText,
/////////////////////////////////////////////////////////////////////////
1:                 referencedCols, referencedColsInTriggerAction,
1:                 originalWhenText, originalActionText,
commit:05623b6
/////////////////////////////////////////////////////////////////////////
1:     public IndexConstantAction getCreateIndexConstantAction
/////////////////////////////////////////////////////////////////////////
1:     public IndexConstantAction getDropIndexConstantAction
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1:      * 	Make the ConstantAction for a CREATE INDEX statement.
1:      * 
1:      * @param forCreateTable Executed as part of a CREATE TABLE
1:      * @param unique		True means it will be a unique index
1:      * @param uniqueWithDuplicateNulls  True means index check and disallow
1:      *                                  any duplicate key if key has no 
1:      *                                  column with a null value.  If any 
1:      *                                  column in the key has a null value,
1:      *                                  no checking is done and insert will
1:      *                                  always succeed.
1:      * @param indexType	The type of index (BTREE, for example)
1:      * @param schemaName			the schema that table (and index) lives in.
1:      * @param indexName	Name of the index
1:      * @param tableName	Name of table the index will be on
1:      * @param tableId		UUID of table.
1:      * @param columnNames	Names of the columns in the index, in order
1:      * @param isAscending	Array of booleans telling asc/desc on each column
1:      * @param isConstraint	TRUE if index is backing up a constraint, else FALSE
1:      * @param conglomerateUUID	ID of conglomerate
1:      * @param properties	The optional properties list associated with the index.
1:      */
1: 		boolean			uniqueWithDuplicateNulls,
/////////////////////////////////////////////////////////////////////////
0: 			( forCreateTable, unique, uniqueWithDuplicateNulls, indexType, 
0: 				schemaName, indexName, tableName, tableId,
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1b41764
/////////////////////////////////////////////////////////////////////////
0:      *  @param forCreateTable Executed as part of a CREATE TABLE
/////////////////////////////////////////////////////////////////////////
1:         boolean forCreateTable,
/////////////////////////////////////////////////////////////////////////
0: 			( forCreateTable, unique, indexType, schemaName, indexName, tableName, tableId,
commit:68db840
/////////////////////////////////////////////////////////////////////////
1:      *  @param forCreateTable   True if for a CREATE TABLE
/////////////////////////////////////////////////////////////////////////
1:         boolean             forCreateTable,
/////////////////////////////////////////////////////////////////////////
0: 			( constraintName, constraintType, forCreateTable, tableName, 
commit:1429957
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			  columnNames, isAscending, isConstraint,
commit:c2a8161
/////////////////////////////////////////////////////////////////////////
commit:9213b42
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param tableType	Type of table (in this case TableDescriptor.VIEW_TYPE).
commit:609999f
/////////////////////////////////////////////////////////////////////////
0: 	public	ConstantAction getAddJarConstantAction(
0: 		return new AddJarConstantAction(schemaName,sqlName,externalPath);
0: 	public	ConstantAction getReplaceJarConstantAction(
0: 		return new ReplaceJarConstantAction(schemaName,sqlName,externalPath);
0: 	public	ConstantAction getDropJarConstantAction(
0: 		return new DropJarConstantAction(schemaName,sqlName);
commit:1260b94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6d698f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.GenericConstantActionFactory
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.sql.depend.DependableList;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.sql.ResultDescription;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.ListOfRowLists;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: 
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.catalog.AliasInfo;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import java.util.Properties;
1: 
1: import java.sql.Timestamp;
1: 
1: /**
1:  * Factory for creating ConstantActions.
1:  *
1:  * <P>Implemetation note: For most operations, the ResultSetFactory
1:  *    determines if the operation is allowed in a readonly/target database.
1:  *    Because we perform JAR add/drop/replace with a utility rather than
1:  *    using normal language processing we never get a result set for these
1:  *    operations. For this reason, the ConstantActionFactory rather than
1:  *    the ResultSetFactory checks if the these operations are allowed.
1:  *
0:  * @author Rick
1:  */
1: public class GenericConstantActionFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1:     public	GenericConstantActionFactory()
1: 	{
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTANT ACTION MANUFACTORIES
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 	/**
0: 	 * Get ConstantAction for ALTER STATEMENT statement.
1: 	 *
0: 	 *  @param sd			descriptor of the schema in which
0: 	 *						our beloved stmt resides
0: 	 *  @param spsName		Name of sps.  if null, all statements
0: 	 *						are recompiled
0: 	 *	@param usingText	the text of the USING clause	
0: 	 *	@param invalidOnly	only recompile if invalid.  Only used
0: 	 *						for the case where all statements are
0: 	 *						recompiled.
1: 	 */
0: 	public	ConstantAction	getAlterSPSConstantAction
1: 	(
1: 		SchemaDescriptor	sd,
0: 		String				spsName,
0: 		String				usingText,
0: 		boolean				invalidOnly
1:     )
1: 	{
0: 		return	new AlterSPSConstantAction(sd, spsName, usingText, invalidOnly);
1: 	}
1: 	
1: 	/**
1: 	 * Get ConstantAction for SET CONSTRAINTS statement.
1: 	 *
0: 	 *  @param cdl			the constraints to set, if null,
0: 	 *						we'll go ahead and set them all
0: 	 *  @param enable		if true, turn them on, if false
0: 	 *						disable them
0: 	 *  @param unconditionallyEnforce	Replication sets this to true at
0: 	 *									the end of REFRESH. This forces us
0: 	 *									to run the included foreign key constraints even
0: 	 *									if they're already marked ENABLED.
0: 	 *	@param ddlList		Replication list of actions to propagate,
0: 	 *						null unless a replication source
1: 	 */
0: 	public	ConstantAction getSetConstraintsConstantAction
1: 	(
0: 		ConstraintDescriptorList	cdl,
0: 		boolean						enable,
0: 		boolean						unconditionallyEnforce,
0: 		Object[]					ddlList
1:     )
1: 	{
0: 		// ignore rep arg
0: 		return new SetConstraintsConstantAction(cdl, enable, unconditionallyEnforce);
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the AlterAction for an ALTER TABLE statement.
1: 	 *
1: 	 *  @param sd			descriptor for the schema that table lives in.
1: 	 *  @param tableName	Name of table.
1: 	 *	@param tableId		UUID of table.
1: 	 *	@param tableConglomerateId	heap conglomerate id of table
1: 	 *  @param tableType	Type of table (e.g., BASE).
1: 	 *  @param columnInfo	Information on all the columns in the table.
1: 	 *  @param constraintActions	ConstraintConstantAction[] for constraints
0: 	 *	@param stageTokens			Compiled array of versioned metadata tokens.
0: 	 *	@param deleteRowLists	lists of tuples to be deleted from Publication catalogs.
0: 	 *	@param insertRowLists	lists of tuples to be inserted into Publication catalogs.
0: 	 *  @param publicationIDs	IDs of publications which must be altered
0: 	 *	@param dependableLists	List, per publication, of objects that this publication depends on.
1: 	 * @param lockGranularity	The lock granularity.
1: 	 *	@param compressTable	Whether or not this is a compress table
1: 	 *	@param behavior			drop behavior of dropping column
1: 	 *	@param sequential	If compress table/drop column, whether or not sequential
0: 	 *	@param compressTable	Whether or not this is a truncate table
1: 	 */
1: 	public	ConstantAction	getAlterTableConstantAction
1: 	(
1: 		SchemaDescriptor			sd,
1: 		String						tableName,
1: 		UUID						tableId,
1: 		long						tableConglomerateId,
1: 		int							tableType,
1: 		ColumnInfo[]				columnInfo,
1: 		ConstraintConstantAction[] 	constraintActions,
1: 
0: 		Object[]					stageControl,
0: 		Object[]					ddlList,
0: 		ListOfRowLists				deleteRowLists,
0: 		ListOfRowLists				insertRowLists,
1: 
0: 		UUID[]						publicationIDs,
0: 		DependableList[]			dependableLists,
1: 		char						lockGranularity,
1: 		boolean						compressTable,
1: 		int							behavior,
1: 		boolean						sequential,
0: 		boolean                     truncateTable
1:     )
1: 	{
0: 		// the replication arguments should be null
1: 		return new	AlterTableConstantAction( sd, tableName, tableId, tableConglomerateId, 
1: 											  tableType, columnInfo, constraintActions, 
1: 											  lockGranularity, compressTable,
0: 											  behavior, sequential, truncateTable);
1: 	}
1: 
1: 	/**
1: 	 *	Make a ConstantAction for a constraint.
1: 	 *
1: 	 *  @param constraintName	Constraint name.
1: 	 *  @param constraintType	Constraint type.
1: 	 *  @param tableName		Table name.
1: 	 *	@param tableId			UUID of table.
1: 	 *  @param schemaName		Schema that table lives in.
1: 	 *  @param columnNames		String[] for column names
1: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1: 	 *  @param constraintText	Text for check constraint
0: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
0: 	 *			  (Generated constraint names will be based off of uuids)
0: 	 *	@param constraintId		UUID of constraint. null => we should generate one.
0: 	 *	@param enabled			Should the constraint be created as enabled 
0: 	 *							(enabled == true), or disabled (enabled == false).
0: 	 *	@param ConstraintInfo	The referenced constraint, if a foreign key constraint
1: 	 *  @param providerInfo Information on all the Providers
1: 	 */
1: 	public	CreateConstraintConstantAction	getCreateConstraintConstantAction
1: 	(
1: 		String				constraintName,
1: 		int					constraintType,
1: 		String				tableName,
1: 		UUID				tableId,
1: 		String				schemaName,
1: 		String[]			columnNames,
1: 		IndexConstantAction indexAction,
1: 		String				constraintText,
0: 		boolean				enabled,
1: 		ConstraintInfo		otherConstraint,
1: 		ProviderInfo[]		providerInfo
1: 	)
1: 	{
0: 		return new CreateConstraintConstantAction
0: 			( constraintName, constraintType, tableName, 
0: 			  tableId, schemaName, columnNames, indexAction, constraintText, 
0: 			  enabled, otherConstraint, providerInfo );
1: 	}
1: 
1: 
1: 	/**
0: 	 *	Make the ConstantAction for a CREATE INDEX statement.
1: 	 *
0: 	 *  @param unique		True means it will be a unique index
0: 	 *  @param indexType	The type of index (BTREE, for example)
0: 	 *  @param schemaName			the schema that table (and index) lives in.
0: 	 *  @param indexName	Name of the index
0: 	 *  @param tableName	Name of table the index will be on
1: 	 *	@param tableId		UUID of table.
0: 	 *  @param conglomId	Conglomerate ID of the index, if known in advance
0: 	 *  @param columnNames	Names of the columns in the index, in order
0: 	 *  @param isAscending	Array of booleans telling asc/desc on each column
0: 	 *  @param isConstraint	TRUE if index is backing up a constraint, else FALSE
0: 	 *  @param conglomerateUUID	ID of conglomerate
0: 	 *  @param properties	The optional properties list associated with the index.
1: 	 */
0: 	public	CreateIndexConstantAction	getCreateIndexConstantAction
1: 	(
1: 		boolean			unique,
1: 		String			indexType,
1: 		String			schemaName,
1: 		String			indexName,
1: 		String			tableName,
1: 		UUID			tableId,
0: 		long			conglomId,
1: 		String[]		columnNames,
1: 		boolean[]		isAscending,
1: 		boolean			isConstraint,
1: 		UUID			conglomerateUUID,
1: 		Properties		properties
1:     )
1: 	{
0: 		return	new CreateIndexConstantAction
0: 			( unique, indexType, schemaName, indexName, tableName, tableId,
0: 			  conglomId, columnNames, isAscending, isConstraint,
0: 			  conglomerateUUID, properties );
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a CREATE ALIAS statement.
1: 	 *
1: 	 *  @param aliasName		Name of alias.
1: 	 *  @param schemaName		Alias's schema. 
1: 	 *  @param javaClassName	Name of java class.
0: 	 *  @param methodName		Name of method.
0: 	 *  @param targetClassName	Name of java class at Target database.
0: 	 *  @param targetMethodName	Name of method at Target database.
1: 	 *  @param aliasType		The alias type
1: 	 */
1: 	public	ConstantAction	getCreateAliasConstantAction
1: 	(
1: 		String	aliasName,
1: 		String	schemaName,
1: 		String	javaClassName,
1: 		AliasInfo	aliasInfo,
1: 		char	aliasType)
1: 	{
1: 		return new CreateAliasConstantAction
1: 			(aliasName, schemaName, javaClassName, aliasInfo, aliasType );
1: 	}
1: 
1: 
1: 	/**
0: 	 * Make the ConstantAction for a CREATE STORED PREPARED STATEMENT statement.
0: 	 * Adds an extra parameter that allows the user to designate whether
0: 	 * this sps can be created in the SYS schema.
1: 	 *
0: 	 *  @param schemaName			name for the schema that table lives in.
0: 	 *  @param spsName		Name of statement
0: 	 *	@param spsText		Text of query expression for sps definition
0: 	 *	@param usingText	the text of the USING clause
0: 	 *	@param okInSys		ok to create in sys schema
0: 	 *	@param nocompile	don't try to compile the sps when it is created
0: 	 *	@param compSchemaId	the compilation schema id
1: 	 */
0: 	public	ConstantAction	getCreateSPSConstantAction
1: 	(
1: 		String				schemaName,
0: 		String				spsName,
0: 		String				spsText,
0: 		String				usingText,
0: 		boolean				okInSys,
0: 		boolean				nocompile,
0: 		UUID				compSchemaId
1: 	)
1: 	{
0: 		return	new CreateSPSConstantAction(schemaName, spsName, spsText, 
0: 						usingText, compSchemaId, okInSys, nocompile);
1: 	}
1: 
1: 	/**
1: 	 * Make the ConstantAction for a CREATE SCHEMA statement.
1: 	 *
1: 	 *  @param schemaName	Name of table.
1: 	 *  @param aid			Authorizaton id
0: 	 *  @param schemaId		ID of table. If null, we allocate one.
0: 	 *	@param setToDefault	if true, set the default schema to
0: 	 *			the new schema once it is created.
1: 	 */
1: 	public	ConstantAction	getCreateSchemaConstantAction
1: 	(
1: 		String			schemaName,
1: 		String			aid)
1: 	{
1: 		return new CreateSchemaConstantAction(schemaName, aid);
1: 	}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a CREATE TABLE statement.
1: 	 *
1: 	 *  @param schemaName	name for the schema that table lives in.
1: 	 *  @param tableName	Name of table.
1: 	 *  @param tableType	Type of table (e.g., BASE, global temporary table).
1: 	 *  @param columnInfo	Information on all the columns in the table.
1: 	 *		 (REMIND tableDescriptor ignored)
1: 	 *  @param constraintActions	CreateConstraintConstantAction[] for constraints
1: 	 *  @param properties	Optional table properties
1: 	 * @param lockGranularity	The lock granularity.
1: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1: 	 */
1: 	public	ConstantAction	getCreateTableConstantAction
1: 	(
1: 		String			schemaName,
1: 		String			tableName,
1: 		int				tableType,
1: 		ColumnInfo[]	columnInfo,
1: 		CreateConstraintConstantAction[] constraintActions,
1: 		Properties		properties,
1: 		char			lockGranularity,
1: 		boolean			onCommitDeleteRows,
1: 		boolean			onRollbackDeleteRows)
1: 	{
1: 		return new CreateTableConstantAction( schemaName, tableName, tableType, columnInfo,
1: 											  constraintActions, properties,
1: 											  lockGranularity, onCommitDeleteRows, onRollbackDeleteRows);
1: 	}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a savepoint statement (ROLLBACK savepoint, RELASE savepoint and SAVEPOINT).
1: 	 *
1: 	 *  @param savepointName	name for the savepoint.
1: 	 *  @param statementType	Type of savepoint statement ie rollback, release or set savepoint
1: 	 */
1: 	public	ConstantAction	getSavepointConstantAction
1: 	(
1: 		String			savepointName,
1: 		int				statementType)
1: 	{
1: 		return new SavepointConstantAction( savepointName, statementType);
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a CREATE VIEW statement.
1: 	 *
1: 	 *  @param sd			descriptor for the schema that table lives in.
1: 	 *  @param tableName	Name of table.
1: 	 *  @param tableType	Type of table (e.g., BASE).
1: 	 *	@param viewText		Text of query expression for view definition
1: 	 *  @param checkOption	Check option type
1: 	 *  @param columnInfo	Information on all the columns in the table.
1: 	 *  @param providerInfo Information on all the Providers
1: 	 *	@param compSchemaId	ID of schema in which the view is to be bound
1: 	 *						when accessed in the future.
1: 	 *		 (REMIND tableDescriptor ignored)
1: 	 */
1: 	public	ConstantAction	getCreateViewConstantAction
1: 	(
1: 		String	schemaName,
1: 		String			tableName,
1: 		int				tableType,
1: 		String			viewText,
1: 		int				checkOption,
1: 		ColumnInfo[]	columnInfo,
1: 		ProviderInfo[]  providerInfo,
1: 		UUID			compSchemaId)
1: 	{
1: 		return new CreateViewConstantAction( schemaName, tableName, tableType, 
1: 											 viewText, checkOption, columnInfo,
1: 											 providerInfo, compSchemaId );
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a Replicated DELETE statement.
1: 	 *
1: 	 *  @param conglomId			Conglomerate ID.
1: 	 *  @param tableType			type of this table
1: 	 *	@param heapSCOCI			StaticCompiledOpenConglomInfo for heap.
1: 	 *  @param irgs					Index descriptors
1: 	 *  @param indexCIDS			Conglomerate IDs of indices
1: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
0: 	 *  @param emptyHeapRow			Template for heap row.
1: 	 *	@param deferred				True means deferred delete
1: 	 *  @param tableIsPublished		true if table is published
1: 	 *  @param tableID				table id
1: 	 *	@param lockMode				The lock mode to use
1: 	 *								  (row or table, see TransactionController)
0: 	 *  @param deleteUndoable   	undoable for the delete
0: 	 *  @param endRowsUndoable  	undoable for the end rows token
0: 	 *  @param endStatementUndoable undoable for the end statement token
1: 	 *  @param keySignature     	signature for the key(null for source)
1: 	 *  @param keyPositions     	positions of primary key columns in base row
1: 	 *  @param keyConglomId  		conglomerate id for the key
1: 	 *								(-1 for the souce)
1: 	 *  @param schemaName    		schemaName(null for source)
1: 	 *  @param tableName        	tableName(null for source)
1: 	 *  @param resultDescription	A description of the columns in the row
1: 	 *			to be deleted.  Only set in replication or during cascade Delete.
1: 	 *	@param fkInfo				Array of structures containing foreign key 
1: 	 *								info, if any (may be null)
1: 	 *	@param triggerInfo			Array of structures containing trigger
1: 	 *								info, if any (may be null)
1: 
1: 	 *  @param numColumns			Number of columns to read
1: 	 *  @param dependencyId			UUID for dependency system
1: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
0: 	 *	@param baseRowReadMap		BaseRowReadMap[heapColId]->ReadRowColumnId.
1:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1: 	 *  @param singleRowSource		Whether or not source is a single row source
1: 	 *
1: 	 *  @exception StandardException		Thrown on failure
1: 	 */
1: 	public	ConstantAction	getDeleteConstantAction
1: 	(
1: 								long				conglomId,
1: 								int					tableType,
1: 								StaticCompiledOpenConglomInfo heapSCOCI,
1: 								IndexRowGenerator[]	irgs,
1: 								long[]				indexCIDS,
1: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 								ExecRow				emptyHeapRow,
1: 								boolean				deferred,
1: 								boolean				tableIsPublished,
1: 								UUID				tableID,
1: 								int					lockMode,
1: 								Object         		deleteToken,
1: 								Object		     	keySignature,
1: 								int[]				keyPositions,
1: 								long                keyConglomId,
1: 								String				schemaName,
1: 								String				tableName,
1: 								ResultDescription	resultDescription,
1: 								FKInfo[]			fkInfo,
1: 								TriggerInfo			triggerInfo,
1: 								FormatableBitSet				baseRowReadList,
1: 								int[]				baseRowReadMap,
1: 								int[]               streamStorableHeapColIds,
1: 								int					numColumns,
1: 								UUID				dependencyId,
1: 								boolean				singleRowSource,
0: 								ConstantAction[]	dependentConstantActions
1: 	)
1: 			throws StandardException
1: 	{
1: 		// ignore replication args, which should be null
1: 		return new DeleteConstantAction(
1: 										conglomId,
1: 										heapSCOCI,
1: 										irgs,
1: 										indexCIDS,
1: 										indexSCOCIs,
0: 										emptyHeapRow,
1: 										deferred,
1: 										tableID,
1: 										lockMode,
1: 										fkInfo,
1: 										triggerInfo,
1: 										baseRowReadList,
1: 										baseRowReadMap,
1: 										streamStorableHeapColIds,
1: 										numColumns,
1: 										singleRowSource,
1: 										resultDescription,
0: 										dependentConstantActions
1: 										);
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make ConstantAction to drop a constraint.
1: 	 *
1: 	 *  @param constraintName	Constraint name.
1: 	 *	@param constraintSchemaName		Constraint Schema Name
1: 	 *  @param tableName		Table name.
1: 	 *	@param tableId			UUID of table.
1: 	 *  @param tableSchemaName				the schema that table lives in.
1: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1: 	 *	@param behavior			The drop behavior (e.g. StatementType.RESTRICT)
1:      *  @param verifyType       Verify that the constraint is of this type.
1: 	 */
1: 	public	ConstraintConstantAction	getDropConstraintConstantAction
1: 	(
1: 		String					constraintName,
1: 		String					constraintSchemaName,
1: 		String					tableName,
1: 		UUID					tableId,
1: 		String					tableSchemaName,
1: 		IndexConstantAction indexAction,
1: 		int						behavior,
1:         int                     verifyType
1:     )
1: 	{
1: 		return	new DropConstraintConstantAction( constraintName, constraintSchemaName, tableName, 
1: 												  tableId, tableSchemaName, indexAction, behavior, verifyType);
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DROP INDEX statement.
1: 	 *
1: 	 *
1: 	 *	@param	fullIndexName		Fully qualified index name
1: 	 *	@param	indexName			Index name.
1: 	 *	@param	tableName			The table name
1: 	 *	@param	schemaName					Schema that index lives in.
1: 	 *  @param  tableId				UUID for table
1: 	 *  @param  tableConglomerateId	heap conglomerate ID for table
1: 	 *
1: 	 */
0: 	public	DropIndexConstantAction	getDropIndexConstantAction
1: 	(
1: 		String				fullIndexName,
1: 		String				indexName,
1: 		String				tableName,
1: 		String				schemaName,
1: 		UUID				tableId,
1: 		long				tableConglomerateId
1:     )
1: 	{
1: 		return	new DropIndexConstantAction( fullIndexName, indexName, tableName, schemaName,
1: 											 tableId, tableConglomerateId );
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DROP ALIAS statement.
1: 	 *
1: 	 *
1: 	 *	@param	aliasName			Alias name.
1: 	 *	@param	aliasType			Alias type.
1: 	 *
1: 	 */
1: 	public	ConstantAction	getDropAliasConstantAction(SchemaDescriptor	sd, String aliasName, char aliasType)
1: 	{
1: 		return	new DropAliasConstantAction(sd, aliasName, aliasType );
1: 	}
1: 
1: 
1: 	/**
0: 	 *	Make the ConstantAction for a DROP STATEMENT statement.
1: 	 *
0: 	 *	@param	sd					Schema that stored prepared statement lives in.
0: 	 *	@param	spsName				Name of the SPS
1: 	 *
1: 	 */
0: 	public	ConstantAction	getDropSPSConstantAction
1: 	(
1: 		SchemaDescriptor	sd,
0: 		String				spsName
1:     )
1: 	{
0: 		return	new DropSPSConstantAction( sd, spsName );
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DROP TABLE statement.
1: 	 *
1: 	 *	@param	schemaName			Table name.
1: 	 *
1: 	 */
1: 	public	ConstantAction	getDropSchemaConstantAction(String	schemaName)
1: 	{
1: 		return	new DropSchemaConstantAction( schemaName );
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DROP TABLE statement.
1: 	 *
1: 	 *
1: 	 *	@param	fullTableName		Fully qualified table name
1: 	 *	@param	tableName			Table name.
1: 	 *	@param	sd					Schema that table lives in.
0: 	 *  @param  conglomerateNubmer	Conglomerate number for heap
1: 	 *  @param  tableId				UUID for table
1: 	 *  @param  behavior			drop behavior, CASCADE, RESTRICT or DEFAULT
1: 	 *
1: 	 */
1: 	public	ConstantAction	getDropTableConstantAction
1: 	(
1: 		String				fullTableName,
1: 		String				tableName,
1: 		SchemaDescriptor	sd,
1: 		long				conglomerateNumber,
1: 		UUID				tableId,
1: 		int					behavior
1: 	)
1: 	{
1: 		return	new DropTableConstantAction( fullTableName, tableName, sd, conglomerateNumber, tableId, behavior );
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DROP VIEW statement.
1: 	 *
1: 	 *
1: 	 *	@param	fullTableName		Fully qualified table name
1: 	 *	@param	tableName			Table name.
1: 	 *	@param	sd					Schema that view lives in.
1: 	 *
1: 	 */
1: 	public	ConstantAction	getDropViewConstantAction
1: 	(
1: 		String				fullTableName,
1: 		String				tableName,
1: 		SchemaDescriptor	sd
1:     )
1: 	{
1: 		return new DropViewConstantAction( fullTableName, tableName, sd );
1: 	}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a RENAME TABLE/COLUMN/INDEX statement.
1: 	 *
1: 	 *	@param	fullTableName Fully qualified table name
1: 	 *	@param	tableName   Table name.
1: 	 *	@param	oldObjectName   Old object name
1: 	 *	@param	newObjectName   New object name.
1: 	 *	@param	sd    Schema that table lives in.
1: 	 *	@param	tableId   UUID for table
1: 	 *  @param	usedAlterTable	True if used Alter Table command, false if used Rename
1: 	 *  @param	renamingWhat	Value indicates if Rename Column/Index.
1: 	 *
1: 	 */
1: 	public	ConstantAction	getRenameConstantAction
1: 	(
1: 		String				fullTableName,
1: 		String				tableName,
1: 		String				oldObjectName,
1: 		String				newObjectName,
1: 		SchemaDescriptor	sd,
1: 		UUID				tableId,
1: 		boolean				usedAlterTable,
1: 		int				renamingWhat
1: 	)
1: 	{
1: 		return	new RenameConstantAction( fullTableName, tableName, oldObjectName, newObjectName,
1: 		sd, tableId, usedAlterTable, renamingWhat );
1: 	}
1: 
1: 	/**
0: 	 *	Make the ConstantAction for a Replicated INSERT statement.
1: 	 *
1: 	 *  @param conglomId		Conglomerate ID.
0: 	 *  @param tableType		type of this table
1: 	 *  @param heapSCOCI		StaticCompiledOpenConglomInfo for target heap.
1: 	 *  @param irgs				Index descriptors
1: 	 *  @param indexCIDS		Conglomerate IDs of indices
1: 	 *	@param indexSCOCIs		StaticCompiledOpenConglomInfos for indexes.
1: 	 *  @param indexNames		Names of indices on this table for error 
1: 	 *							reporting.
1: 	 *	@param deferred			True means deferred insert
1: 	 *  @param tableIsPublished	true if table is published, false otherwise
1: 	 *  @param tableID			table id
0: 	 *  @param targetProperties	Properties on the target table
1: 	 *	@param fkInfo			Array of structures containing foreign key info, 
1: 	 *							if any (may be null)
1: 	 *	@param triggerInfo		Array of structures containing trigger info, 
1: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
1:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1: 	 *							if any (may be null)
1: 	 *  @param indexedCols		boolean[] of which (0-based) columns are indexed.
1: 	 *  @param dependencyId		UUID for dependency system
1: 	 *	@param stageControl		Stage Control Tokens
1: 	 *	@param ddlList			List of DDL to log. This is for BULK INSERT into a published table at the Source.
1: 	 *  @param singleRowSource	Whether or not source is a single row source
1: 	 *  @param autoincRowLocation array of row locations into syscolumns for
1: 	                              autoincrement columns
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public	ConstantAction getInsertConstantAction(
1: 								TableDescriptor		tableDescriptor,
1: 								long				conglomId,
1: 								StaticCompiledOpenConglomInfo heapSCOCI,
1: 								IndexRowGenerator[]	irgs,
1: 								long[]				indexCIDS,
1: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1: 								String[]			indexNames,
1: 								boolean				deferred,
1: 								boolean				tableIsPublished,
1: 								UUID				tableID,
1: 								int					lockMode,
1: 								Object         		insertToken,
1: 								Object				rowSignature,
1: 								Properties			targetProperties,
1: 								FKInfo[]			fkInfo,
1: 								TriggerInfo			triggerInfo,
1: 								int[]               streamStorableHeapColIds,
1: 								boolean[]			indexedCols,
1: 								UUID				dependencyId,
1: 								Object[]			stageControl,
1: 								Object[]			ddlList,
1: 								boolean				singleRowSource,
0: 								RowLocation[]		autoincRowLocation
1: 							)
1: 			throws StandardException
1: 	{
1: 		return new InsertConstantAction(tableDescriptor,
1: 										conglomId,
1: 										heapSCOCI,
1: 										irgs,
1: 										indexCIDS,
1: 										indexSCOCIs,
1: 										indexNames,
1: 										deferred,
1: 										targetProperties,
1: 										tableID,
1: 										lockMode,
1: 										fkInfo,
1: 										triggerInfo,
1: 										streamStorableHeapColIds,
1: 										indexedCols,
1: 										singleRowSource,
0: 										autoincRowLocation
1: 										);
1: 	}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for an updatable VTI statement.
1: 	 *
0: 	 * @param deferred					Deferred mode?
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public ConstantAction getUpdatableVTIConstantAction( int statementType, boolean deferred)
1: 			throws StandardException
1: 	{
1: 		return new UpdatableVTIConstantAction( statementType, deferred, null);
1: 	}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for an updatable VTI statement.
1: 	 *
0: 	 * @param deferred					Deferred mode?
1:      * @param changedColumnIds Array of ids of changed columns
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public ConstantAction getUpdatableVTIConstantAction( int statementType,
1:                                                          boolean deferred,
1:                                                          int[] changedColumnIds)
1: 			throws StandardException
1: 	{
1: 		return new UpdatableVTIConstantAction( statementType, deferred, changedColumnIds);
1: 	}
1: 
1: 	/**
1: 	 * Make the ConstantAction for a LOCK TABLE statement.
1: 	 *
1: 	 *  @param fullTableName		Full name of the table.
1: 	 *  @param conglomerateNumber	Conglomerate number for the heap
1: 	 *  @param exclusiveMode		Whether or not to get an exclusive lock.
1: 	 */
1: 	public	ConstantAction	getLockTableConstantAction(
1: 					String fullTableName,
1: 					long conglomerateNumber, boolean exclusiveMode)
1: 	{
1: 		return new LockTableConstantAction( 
1: 						fullTableName, conglomerateNumber, exclusiveMode );
1: 	}
1: 
1: 
1: 	/**
1: 	 * Make the ConstantAction for a SET SCHEMA statement.
1: 	 *
1: 	 *  @param schemaName	Name of schema.
1: 	 *  @param type			Literal, USER or ?
1: 	 */
1: 	public	ConstantAction	getSetSchemaConstantAction(String schemaName, int type)
1: 	{
1: 		return new SetSchemaConstantAction( schemaName , type );
1: 	}
1: 
1: 	/**
1: 	 * Make the ConstantAction for a SET TRANSACTION ISOLATION statement.
1: 	 *
1: 	 * @param isolationLevel	The new isolation level.
1: 	 */
1: 	public ConstantAction getSetTransactionIsolationConstantAction(int isolationLevel)
1: 	{
1: 		return new SetTransactionIsolationConstantAction(isolationLevel);
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a Replicated DELETE statement.
1: 	 *
1: 	 *  @param conglomId			Conglomerate ID.
1: 	 *  @param tableType			type of this table
1: 	 *	@param heapSCOCI			StaticCompiledOpenConglomInfo for heap.
1: 	 *  @param irgs					Index descriptors
1: 	 *  @param indexCIDS			Conglomerate IDs of indices
1: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
0: 	 *  @param emptyHeapRow			Template for heap row.
1: 	 *	@param deferred				True means deferred update
1: 	 *	@param targetUUID			UUID of target table
1: 	 *	@param lockMode				The lock mode to use
1: 	 *								  (row or table, see TransactionController)
1: 	 *  @param tableIsPublished		true if table is published, false otherwise
1: 	 *	@param changedColumnIds		Array of ids of changes columns
1: 	 *  @param keyPositions     	positions of primary key columns in base row
0: 	 *  @param updateUndoable		an update token
0: 	 *  @param endRowsUndoable		an end rows token
0: 	 *  @param endStatementUndoable an end statement token
1: 	 *	@param fkInfo				Array of structures containing foreign key info, 
1: 	 *								if any (may be null)
1: 	 *	@param triggerInfo			Array of structures containing trigger info, 
1: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
1:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1: 	 *								if any (may be null)
1: 	 *  @param baseRowReadMap		map of columns to be selected from the base row
1: 	 *								(partial row). 1 based.
1:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1: 	 *  @param numColumns			The number of columns being read.
1: 	 *	@param positionedUpdate		is this a positioned update
1: 	 *  @param singleRowSource		Whether or not source is a single row source
1: 	 *
1: 	 *  @exception StandardException Thrown on failure
1: 	 */
1: 	public	UpdateConstantAction	getUpdateConstantAction(
1: 								long				conglomId,
1: 								int					tableType,
1: 								StaticCompiledOpenConglomInfo heapSCOCI,
1: 								IndexRowGenerator[]	irgs,
1: 								long[]				indexCIDS,
1: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1: 								String[]			indexNames,	
0: 								ExecRow				emptyHeapRow,
1: 								boolean				deferred,
1: 								UUID				targetUUID,
1: 								int					lockMode,
1: 								boolean				tableIsPublished,
1: 								int[]				changedColumnIds,
1: 								int[]				keyPositions,
1: 								Object         		updateToken,
1: 								FKInfo[]			fkInfo,
1: 								TriggerInfo			triggerInfo,
1: 								FormatableBitSet				baseRowReadList,
1: 								int[]				baseRowReadMap,
1: 								int[]				streamStorableHeapColIds,
1: 								int					numColumns,
1: 								boolean				positionedUpdate,
0: 								boolean				singleRowSource
1: 							)
1: 			throws StandardException
1: 	{
1: 		return new UpdateConstantAction(
1: 										conglomId,
1: 										heapSCOCI,
1: 										irgs,
1: 										indexCIDS,
1: 										indexSCOCIs,
1: 										indexNames,
0: 										emptyHeapRow,
1: 										deferred,
1: 										targetUUID,
1: 										lockMode,
1: 										changedColumnIds,
1: 										fkInfo,
1: 										triggerInfo,
1: 										baseRowReadList,
1: 										baseRowReadMap,
1: 										streamStorableHeapColIds,
1: 										numColumns,
1: 										positionedUpdate,
0: 										singleRowSource
1: 										);
1: 	}
1: 
1: 	/**
0: 	 * Make the ConstantAction to Add a jar file to a database.
1: 	 *
0: 	 *	@param	id					The id for the jar file -
0: 	 *                              (null means create one)
0: 	 *	@param	schemaName			The SchemaName for the jar file.
0: 	 *	@param	sqlName			    The sqlName for the jar file.
0: 	 *  @param  fileName            The name of the file that holds the jar.
0: 	 *  @exception StandardException Ooops
1: 	 */
0: 	public	ConstantAction getAddJarConstantAction(UUID id,
0: 														 String schemaName,
0: 														 String sqlName,
0: 														 String externalPath)
1: 		 throws StandardException
1: 	{
0: 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
0: 		return new AddJarConstantAction(id,schemaName,sqlName,externalPath);
1: 	}
1: 	/**
0: 	 * Make the ConstantAction to replace a jar file in a database.
1: 	 *
0: 	 *	@param	id					The id for the jar file -
0: 	 *                              (Ignored if null)
0: 	 *	@param	schemaName			The SchemaName for the jar file.
0: 	 *	@param	sqlName			    The sqlName for the jar file.
0: 	 *  @param  fileName            The name of the file that holds the new jar.
0: 	 *  @exception StandardException Ooops
1: 	 */
0: 	public	ConstantAction getReplaceJarConstantAction(UUID id,
0: 														 String schemaName,
0: 														 String sqlName,
0: 														 String externalPath)
1: 		 throws StandardException
1: 	{
0: 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
0: 		return new ReplaceJarConstantAction(id,schemaName,sqlName,externalPath);
1: 	}
1: 	/**
0: 	 * Make the ConstantAction to drop a jar file from a database.
1: 	 *
0: 	 *	@param	id					The id for the jar file -
0: 	 *                              (Ignored if null)
0: 	 *	@param	schemaName			The SchemaName for the jar file.
0: 	 *	@param	sqlName			    The sqlName for the jar file.
0: 	 *  @exception StandardException Ooops
1: 	 */
0: 	public	ConstantAction getDropJarConstantAction(UUID id,
0: 														  String schemaName,
0: 														  String sqlName)
1: 		 throws StandardException
1: 	{
0: 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
0: 		return new DropJarConstantAction(id,schemaName,sqlName);
1: 	}
1: 
1: 	static protected Authorizer getAuthorizer()
1: 	{
1: 		LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1: 		return lcc.getAuthorizer();
1: 	}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a CREATE TRIGGER statement.
1: 	 *
0: 	 * @param triggerSd		descriptor for the schema that trigger lives in.
1: 	 * @param triggerName	Name of trigger
1: 	 * @param eventMask		TriggerDescriptor.TRIGGER_EVENT_XXXX
1: 	 * @param isBefore		is this a before (as opposed to after) trigger 
1: 	 * @param isRow			is this a row trigger or statement trigger
1: 	 * @param isEnabled		is this trigger enabled or disabled
1: 	 * @param triggerTable	the table upon which this trigger is defined
1: 	 * @param whenSPSId		the sps id for the when clause (may be null)
1: 	 * @param whenText		the text of the when clause (may be null)
1: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1: 	 * @param actionText	the text of the trigger action (may be null)
1: 	 * @param spsCompSchemaId	the compilation schema for the action and when
1: 	 *							spses.   If null, will be set to the current default
1: 	 *							schema
0: 	 * @param creationTimestamp	when was this trigger created?  if null, will be
0: 	 *						set to the time that executeConstantAction() is invoked
1: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1: 	 * @param originalActionText The original user text of the trigger action
1: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
1: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
1: 	 */
1: 	public ConstantAction getCreateTriggerConstantAction
1: 	(
1: 		String				triggerSchemaName,
1: 		String				triggerName,
1: 		int					eventMask,
1: 		boolean				isBefore,
1: 		boolean 			isRow,
1: 		boolean 			isEnabled,
1: 		TableDescriptor		triggerTable,
1: 		UUID				whenSPSId,
1: 		String				whenText,
1: 		UUID				actionSPSId,
1: 		String				actionText,
1: 		UUID				spsCompSchemaId,
0: 		Timestamp			creationTimestamp,
1: 		int[]				referencedCols,
1: 		String				originalActionText,
1: 		boolean				referencingOld,
1: 		boolean				referencingNew,
1: 		String				oldReferencingName,
0: 		String				newReferencingName
1: 	)
1: 	{
1: 		return new CreateTriggerConstantAction(triggerSchemaName, triggerName, 
1: 				eventMask, isBefore, isRow, isEnabled, triggerTable, whenSPSId,
0: 				whenText, actionSPSId, actionText, spsCompSchemaId, creationTimestamp,
0: 				referencedCols, originalActionText,
0: 				referencingOld, referencingNew, oldReferencingName, newReferencingName);
1: 	}
1: 
1: 	/**
1: 	 * Make the ConstantAction for a DROP TRIGGER statement.
1: 	 *
1: 	 * @param	sd					Schema that stored prepared statement lives in.
1: 	 * @param	triggerName			Name of the Trigger
1: 	 * @param	tableId				The table this trigger is defined upon
1: 	 */
1: 	public ConstantAction getDropTriggerConstantAction
1: 	(
1: 		SchemaDescriptor	sd,
1: 		String				triggerName,
1: 		UUID				tableId
1: 	)
1: 	{
1: 		return new DropTriggerConstantAction(sd, triggerName, tableId);
1: 	}
1: 	
1: 	/**
0: 	 * Make the constant action for a UPDATE STATISTICS statement.
1: 	 *
0: 	 * @param forTable		whether for an index or table.
0: 	 * @param objectName	name of the object (either table or index) for which
0: 	 * this statistic is being created.
0: 	 * @param tableUUID		UUID of the table for which statistics are being
0: 	 * created.
0: 	 * @param objectUUID    array of UUID's, one for each index conglomerate for
0: 	 * which statistics are being created. 
0: 	 * @param conglomerateNumber array of conglomerate numbers, one for each
0: 	 * index conglomerate for which statistics are being created.
0: 	 * @param indexRow		array of index rows, one for each index. This row is
0: 	 * used by the constant action to read data from the indices.
1: 	 */
0: 	public ConstantAction getUpdateStatisticsConstantAction
1: 	(
0: 	 boolean forTable,
0: 	 String objectName,
0: 	 UUID tableUUID,
0: 	 UUID[] objectUUID,
0: 	 long[] conglomerateNumber,
0: 	 ExecIndexRow[] indexRow
1: 	)
1: 	{
0: 		return new UpdateStatisticsConstantAction(forTable, 
0: 												  objectName,
0: 												  tableUUID,
0: 												  objectUUID,
0: 												  conglomerateNumber,
0: 												  indexRow);
1: 	}
1: 
1: 	/**
1: 	 * Make the constant action for Drop Statistics statement.
1: 	 *
1: 	 * @param sd			Schema Descriptor of the schema in which the object 
1: 	 * resides. 
1: 	 * @param fullTableName full name of the object for which statistics are
1: 	 * being dropped.
1: 	 * @param objectName	 object name for which statistics are being dropped.
1: 	 * @param forTable 		 is it an index or table whose statistics aer being
1: 	 * consigned to the garbage heap?
1: 	 */
1: 	public ConstantAction getDropStatisticsConstantAction
1: 		(SchemaDescriptor sd, String fullTableName, String objectName, boolean forTable)
1: 	{
1: 		return new DropStatisticsConstantAction(sd, fullTableName, objectName, forTable);
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 *	@param otherConstraint	The referenced constraint, if a foreign key constraint
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param schemaName	Name of the schema that table lives in.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param  conglomerateNumber	Conglomerate number for heap
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 *  @param  externalPath            The name of the file that holds the jar.
/////////////////////////////////////////////////////////////////////////
0: 	 *  @param  externalPath            The name of the file that holds the new jar.
/////////////////////////////////////////////////////////////////////////
1: 	 * @param triggerSchemaName		Name of the schema that trigger lives in.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Make the constant action for a Grant statement
0: 	 *
1: 	 * @param privileges The list of privileges to be granted
1: 	 * @param grantees The list of grantees
0: 	 * @param withGrantOption true if WITH GRANT OPTION, false if not.
0: 	 */
1: 	public ConstantAction getGrantConstantAction( PrivilegeInfo privileges,
1: 								List grantees)
0: 	{
1: 		return new GrantRevokeConstantAction( true, privileges, grantees);
0: 	}
0: 
0: 	/**
1: 	 * Make the constant action for a Revoke statement
0: 	 * 
1: 	 * @param privileges The list of privileges to be revokeed
1: 	 * @param grantees The list of grantees
0: 	 * @param withGrantOption true if WITH GRANT OPTION, false if not.
0: 	 */
1: 	public ConstantAction getRevokeConstantAction( PrivilegeInfo privileges,
1: 								List grantees)
0: 	{
1: 		return new GrantRevokeConstantAction( false, privileges, grantees);
0: 	}
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.sql.depend.DependableList;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.ResultDescription;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.ListOfRowLists;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.AliasInfo;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.util.Properties;
0: 
0: import java.sql.Timestamp;
0: 
0: /**
0:  * Factory for creating ConstantActions.
0:  *
0:  * <P>Implemetation note: For most operations, the ResultSetFactory
0:  *    determines if the operation is allowed in a readonly/target database.
0:  *    Because we perform JAR add/drop/replace with a utility rather than
0:  *    using normal language processing we never get a result set for these
0:  *    operations. For this reason, the ConstantActionFactory rather than
0:  *    the ResultSetFactory checks if the these operations are allowed.
0:  *
0:  * @author Rick
0:  */
0: public class GenericConstantActionFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0:     public	GenericConstantActionFactory()
0: 	{
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTANT ACTION MANUFACTORIES
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 	/**
0: 	 * Get ConstantAction for ALTER STATEMENT statement.
0: 	 *
0: 	 *  @param sd			descriptor of the schema in which
0: 	 *						our beloved stmt resides
0: 	 *  @param spsName		Name of sps.  if null, all statements
0: 	 *						are recompiled
0: 	 *	@param usingText	the text of the USING clause	
0: 	 *	@param invalidOnly	only recompile if invalid.  Only used
0: 	 *						for the case where all statements are
0: 	 *						recompiled.
0: 	 */
0: 	public	ConstantAction	getAlterSPSConstantAction
0: 	(
0: 		SchemaDescriptor	sd,
0: 		String				spsName,
0: 		String				usingText,
0: 		boolean				invalidOnly
0:     )
0: 	{
0: 		return	new AlterSPSConstantAction(sd, spsName, usingText, invalidOnly);
0: 	}
0: 	
0: 	/**
0: 	 * Get ConstantAction for SET CONSTRAINTS statement.
0: 	 *
0: 	 *  @param cdl			the constraints to set, if null,
0: 	 *						we'll go ahead and set them all
0: 	 *  @param enable		if true, turn them on, if false
0: 	 *						disable them
0: 	 *  @param unconditionallyEnforce	Replication sets this to true at
0: 	 *									the end of REFRESH. This forces us
0: 	 *									to run the included foreign key constraints even
0: 	 *									if they're already marked ENABLED.
0: 	 *	@param ddlList		Replication list of actions to propagate,
0: 	 *						null unless a replication source
0: 	 */
0: 	public	ConstantAction getSetConstraintsConstantAction
0: 	(
0: 		ConstraintDescriptorList	cdl,
0: 		boolean						enable,
0: 		boolean						unconditionallyEnforce,
0: 		Object[]					ddlList
0:     )
0: 	{
0: 		// ignore rep arg
0: 		return new SetConstraintsConstantAction(cdl, enable, unconditionallyEnforce);
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the AlterAction for an ALTER TABLE statement.
0: 	 *
0: 	 *  @param sd			descriptor for the schema that table lives in.
0: 	 *  @param tableName	Name of table.
0: 	 *	@param tableId		UUID of table.
0: 	 *	@param tableConglomerateId	heap conglomerate id of table
0: 	 *  @param tableType	Type of table (e.g., BASE).
0: 	 *  @param columnInfo	Information on all the columns in the table.
0: 	 *  @param constraintActions	ConstraintConstantAction[] for constraints
0: 	 *	@param stageTokens			Compiled array of versioned metadata tokens.
0: 	 *	@param deleteRowLists	lists of tuples to be deleted from Publication catalogs.
0: 	 *	@param insertRowLists	lists of tuples to be inserted into Publication catalogs.
0: 	 *  @param publicationIDs	IDs of publications which must be altered
0: 	 *	@param dependableLists	List, per publication, of objects that this publication depends on.
0: 	 * @param lockGranularity	The lock granularity.
0: 	 *	@param compressTable	Whether or not this is a compress table
0: 	 *	@param behavior			drop behavior of dropping column
0: 	 *	@param sequential	If compress table/drop column, whether or not sequential
0: 	 *	@param compressTable	Whether or not this is a truncate table
0: 	 */
0: 	public	ConstantAction	getAlterTableConstantAction
0: 	(
0: 		SchemaDescriptor			sd,
0: 		String						tableName,
0: 		UUID						tableId,
0: 		long						tableConglomerateId,
0: 		int							tableType,
0: 		ColumnInfo[]				columnInfo,
0: 		ConstraintConstantAction[] 	constraintActions,
0: 
0: 		Object[]					stageControl,
0: 		Object[]					ddlList,
0: 		ListOfRowLists				deleteRowLists,
0: 		ListOfRowLists				insertRowLists,
0: 
0: 		UUID[]						publicationIDs,
0: 		DependableList[]			dependableLists,
0: 		char						lockGranularity,
0: 		boolean						compressTable,
0: 		int							behavior,
0: 		boolean						sequential,
0: 		boolean                     truncateTable
0:     )
0: 	{
0: 		// the replication arguments should be null
0: 		return new	AlterTableConstantAction( sd, tableName, tableId, tableConglomerateId, 
0: 											  tableType, columnInfo, constraintActions, 
0: 											  lockGranularity, compressTable,
0: 											  behavior, sequential, truncateTable);
0: 	}
0: 
0: 	/**
0: 	 *	Make a ConstantAction for a constraint.
0: 	 *
0: 	 *  @param constraintName	Constraint name.
0: 	 *  @param constraintType	Constraint type.
0: 	 *  @param tableName		Table name.
0: 	 *	@param tableId			UUID of table.
0: 	 *  @param schemaName		Schema that table lives in.
0: 	 *  @param columnNames		String[] for column names
0: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
0: 	 *  @param constraintText	Text for check constraint
0: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
0: 	 *			  (Generated constraint names will be based off of uuids)
0: 	 *	@param constraintId		UUID of constraint. null => we should generate one.
0: 	 *	@param enabled			Should the constraint be created as enabled 
0: 	 *							(enabled == true), or disabled (enabled == false).
0: 	 *	@param ConstraintInfo	The referenced constraint, if a foreign key constraint
0: 	 *  @param providerInfo Information on all the Providers
0: 	 */
0: 	public	CreateConstraintConstantAction	getCreateConstraintConstantAction
0: 	(
0: 		String				constraintName,
0: 		int					constraintType,
0: 		String				tableName,
0: 		UUID				tableId,
0: 		String				schemaName,
0: 		String[]			columnNames,
0: 		IndexConstantAction indexAction,
0: 		String				constraintText,
0: 		boolean				enabled,
0: 		ConstraintInfo		otherConstraint,
0: 		ProviderInfo[]		providerInfo
0: 	)
0: 	{
0: 		return new CreateConstraintConstantAction
0: 			( constraintName, constraintType, tableName, 
0: 			  tableId, schemaName, columnNames, indexAction, constraintText, 
0: 			  enabled, otherConstraint, providerInfo );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE INDEX statement.
0: 	 *
0: 	 *  @param unique		True means it will be a unique index
0: 	 *  @param indexType	The type of index (BTREE, for example)
0: 	 *  @param schemaName			the schema that table (and index) lives in.
0: 	 *  @param indexName	Name of the index
0: 	 *  @param tableName	Name of table the index will be on
0: 	 *	@param tableId		UUID of table.
0: 	 *  @param conglomId	Conglomerate ID of the index, if known in advance
0: 	 *  @param columnNames	Names of the columns in the index, in order
0: 	 *  @param isAscending	Array of booleans telling asc/desc on each column
0: 	 *  @param isConstraint	TRUE if index is backing up a constraint, else FALSE
0: 	 *  @param conglomerateUUID	ID of conglomerate
0: 	 *  @param properties	The optional properties list associated with the index.
0: 	 */
0: 	public	CreateIndexConstantAction	getCreateIndexConstantAction
0: 	(
0: 		boolean			unique,
0: 		String			indexType,
0: 		String			schemaName,
0: 		String			indexName,
0: 		String			tableName,
0: 		UUID			tableId,
0: 		long			conglomId,
0: 		String[]		columnNames,
0: 		boolean[]		isAscending,
0: 		boolean			isConstraint,
0: 		UUID			conglomerateUUID,
0: 		Properties		properties
0:     )
0: 	{
0: 		return	new CreateIndexConstantAction
0: 			( unique, indexType, schemaName, indexName, tableName, tableId,
0: 			  conglomId, columnNames, isAscending, isConstraint,
0: 			  conglomerateUUID, properties );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE ALIAS statement.
0: 	 *
0: 	 *  @param aliasName		Name of alias.
0: 	 *  @param schemaName		Alias's schema. 
0: 	 *  @param javaClassName	Name of java class.
0: 	 *  @param methodName		Name of method.
0: 	 *  @param targetClassName	Name of java class at Target database.
0: 	 *  @param targetMethodName	Name of method at Target database.
0: 	 *  @param aliasType		The alias type
0: 	 */
0: 	public	ConstantAction	getCreateAliasConstantAction
0: 	(
0: 		String	aliasName,
0: 		String	schemaName,
0: 		String	javaClassName,
0: 		AliasInfo	aliasInfo,
0: 		char	aliasType)
0: 	{
0: 		return new CreateAliasConstantAction
0: 			(aliasName, schemaName, javaClassName, aliasInfo, aliasType );
0: 	}
0: 
0: 
0: 	/**
0: 	 * Make the ConstantAction for a CREATE STORED PREPARED STATEMENT statement.
0: 	 * Adds an extra parameter that allows the user to designate whether
0: 	 * this sps can be created in the SYS schema.
0: 	 *
0: 	 *  @param schemaName			name for the schema that table lives in.
0: 	 *  @param spsName		Name of statement
0: 	 *	@param spsText		Text of query expression for sps definition
0: 	 *	@param usingText	the text of the USING clause
0: 	 *	@param okInSys		ok to create in sys schema
0: 	 *	@param nocompile	don't try to compile the sps when it is created
0: 	 *	@param compSchemaId	the compilation schema id
0: 	 */
0: 	public	ConstantAction	getCreateSPSConstantAction
0: 	(
0: 		String				schemaName,
0: 		String				spsName,
0: 		String				spsText,
0: 		String				usingText,
0: 		boolean				okInSys,
0: 		boolean				nocompile,
0: 		UUID				compSchemaId
0: 	)
0: 	{
0: 		return	new CreateSPSConstantAction(schemaName, spsName, spsText, 
0: 						usingText, compSchemaId, okInSys, nocompile);
0: 	}
0: 
0: 	/**
0: 	 * Make the ConstantAction for a CREATE SCHEMA statement.
0: 	 *
0: 	 *  @param schemaName	Name of table.
0: 	 *  @param aid			Authorizaton id
0: 	 *  @param schemaId		ID of table. If null, we allocate one.
0: 	 *	@param setToDefault	if true, set the default schema to
0: 	 *			the new schema once it is created.
0: 	 */
0: 	public	ConstantAction	getCreateSchemaConstantAction
0: 	(
0: 		String			schemaName,
0: 		String			aid)
0: 	{
0: 		return new CreateSchemaConstantAction(schemaName, aid);
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE TABLE statement.
0: 	 *
0: 	 *  @param schemaName	name for the schema that table lives in.
0: 	 *  @param tableName	Name of table.
0: 	 *  @param tableType	Type of table (e.g., BASE, global temporary table).
0: 	 *  @param columnInfo	Information on all the columns in the table.
0: 	 *		 (REMIND tableDescriptor ignored)
0: 	 *  @param constraintActions	CreateConstraintConstantAction[] for constraints
0: 	 *  @param properties	Optional table properties
0: 	 * @param lockGranularity	The lock granularity.
0: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
0: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
0: 	 */
0: 	public	ConstantAction	getCreateTableConstantAction
0: 	(
0: 		String			schemaName,
0: 		String			tableName,
0: 		int				tableType,
0: 		ColumnInfo[]	columnInfo,
0: 		CreateConstraintConstantAction[] constraintActions,
0: 		Properties		properties,
0: 		char			lockGranularity,
0: 		boolean			onCommitDeleteRows,
0: 		boolean			onRollbackDeleteRows)
0: 	{
0: 		return new CreateTableConstantAction( schemaName, tableName, tableType, columnInfo,
0: 											  constraintActions, properties,
0: 											  lockGranularity, onCommitDeleteRows, onRollbackDeleteRows);
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a savepoint statement (ROLLBACK savepoint, RELASE savepoint and SAVEPOINT).
0: 	 *
0: 	 *  @param savepointName	name for the savepoint.
0: 	 *  @param statementType	Type of savepoint statement ie rollback, release or set savepoint
0: 	 */
0: 	public	ConstantAction	getSavepointConstantAction
0: 	(
0: 		String			savepointName,
0: 		int				statementType)
0: 	{
0: 		return new SavepointConstantAction( savepointName, statementType);
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE VIEW statement.
0: 	 *
0: 	 *  @param sd			descriptor for the schema that table lives in.
0: 	 *  @param tableName	Name of table.
0: 	 *  @param tableType	Type of table (e.g., BASE).
0: 	 *	@param viewText		Text of query expression for view definition
0: 	 *  @param checkOption	Check option type
0: 	 *  @param columnInfo	Information on all the columns in the table.
0: 	 *  @param providerInfo Information on all the Providers
0: 	 *	@param compSchemaId	ID of schema in which the view is to be bound
0: 	 *						when accessed in the future.
0: 	 *		 (REMIND tableDescriptor ignored)
0: 	 */
0: 	public	ConstantAction	getCreateViewConstantAction
0: 	(
0: 		String	schemaName,
0: 		String			tableName,
0: 		int				tableType,
0: 		String			viewText,
0: 		int				checkOption,
0: 		ColumnInfo[]	columnInfo,
0: 		ProviderInfo[]  providerInfo,
0: 		UUID			compSchemaId)
0: 	{
0: 		return new CreateViewConstantAction( schemaName, tableName, tableType, 
0: 											 viewText, checkOption, columnInfo,
0: 											 providerInfo, compSchemaId );
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a Replicated DELETE statement.
0: 	 *
0: 	 *  @param conglomId			Conglomerate ID.
0: 	 *  @param tableType			type of this table
0: 	 *	@param heapSCOCI			StaticCompiledOpenConglomInfo for heap.
0: 	 *  @param irgs					Index descriptors
0: 	 *  @param indexCIDS			Conglomerate IDs of indices
0: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
0: 	 *  @param emptyHeapRow			Template for heap row.
0: 	 *	@param deferred				True means deferred delete
0: 	 *  @param tableIsPublished		true if table is published
0: 	 *  @param tableID				table id
0: 	 *	@param lockMode				The lock mode to use
0: 	 *								  (row or table, see TransactionController)
0: 	 *  @param deleteUndoable   	undoable for the delete
0: 	 *  @param endRowsUndoable  	undoable for the end rows token
0: 	 *  @param endStatementUndoable undoable for the end statement token
0: 	 *  @param keySignature     	signature for the key(null for source)
0: 	 *  @param keyPositions     	positions of primary key columns in base row
0: 	 *  @param keyConglomId  		conglomerate id for the key
0: 	 *								(-1 for the souce)
0: 	 *  @param schemaName    		schemaName(null for source)
0: 	 *  @param tableName        	tableName(null for source)
0: 	 *  @param resultDescription	A description of the columns in the row
0: 	 *			to be deleted.  Only set in replication or during cascade Delete.
0: 	 *	@param fkInfo				Array of structures containing foreign key 
0: 	 *								info, if any (may be null)
0: 	 *	@param triggerInfo			Array of structures containing trigger
0: 	 *								info, if any (may be null)
0: 
0: 	 *  @param numColumns			Number of columns to read
0: 	 *  @param dependencyId			UUID for dependency system
0: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
0: 	 *	@param baseRowReadMap		BaseRowReadMap[heapColId]->ReadRowColumnId.
0:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
0: 	 *  @param singleRowSource		Whether or not source is a single row source
0: 	 *
0: 	 *  @exception StandardException		Thrown on failure
0: 	 */
0: 	public	ConstantAction	getDeleteConstantAction
0: 	(
0: 								long				conglomId,
0: 								int					tableType,
0: 								StaticCompiledOpenConglomInfo heapSCOCI,
0: 								IndexRowGenerator[]	irgs,
0: 								long[]				indexCIDS,
0: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 								ExecRow				emptyHeapRow,
0: 								boolean				deferred,
0: 								boolean				tableIsPublished,
0: 								UUID				tableID,
0: 								int					lockMode,
0: 								Object         		deleteToken,
0: 								Object		     	keySignature,
0: 								int[]				keyPositions,
0: 								long                keyConglomId,
0: 								String				schemaName,
0: 								String				tableName,
0: 								ResultDescription	resultDescription,
0: 								FKInfo[]			fkInfo,
0: 								TriggerInfo			triggerInfo,
0: 								FormatableBitSet				baseRowReadList,
0: 								int[]				baseRowReadMap,
0: 								int[]               streamStorableHeapColIds,
0: 								int					numColumns,
0: 								UUID				dependencyId,
0: 								boolean				singleRowSource,
0: 								ConstantAction[]	dependentConstantActions
0: 	)
0: 			throws StandardException
0: 	{
0: 		// ignore replication args, which should be null
0: 		return new DeleteConstantAction(
0: 										conglomId,
0: 										heapSCOCI,
0: 										irgs,
0: 										indexCIDS,
0: 										indexSCOCIs,
0: 										emptyHeapRow,
0: 										deferred,
0: 										tableID,
0: 										lockMode,
0: 										fkInfo,
0: 										triggerInfo,
0: 										baseRowReadList,
0: 										baseRowReadMap,
0: 										streamStorableHeapColIds,
0: 										numColumns,
0: 										singleRowSource,
0: 										resultDescription,
0: 										dependentConstantActions
0: 										);
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make ConstantAction to drop a constraint.
0: 	 *
0: 	 *  @param constraintName	Constraint name.
0: 	 *	@param constraintSchemaName		Constraint Schema Name
0: 	 *  @param tableName		Table name.
0: 	 *	@param tableId			UUID of table.
0: 	 *  @param tableSchemaName				the schema that table lives in.
0: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
0: 	 *	@param behavior			The drop behavior (e.g. StatementType.RESTRICT)
0:      *  @param verifyType       Verify that the constraint is of this type.
0: 	 */
0: 	public	ConstraintConstantAction	getDropConstraintConstantAction
0: 	(
0: 		String					constraintName,
0: 		String					constraintSchemaName,
0: 		String					tableName,
0: 		UUID					tableId,
0: 		String					tableSchemaName,
0: 		IndexConstantAction indexAction,
0: 		int						behavior,
0:         int                     verifyType
0:     )
0: 	{
0: 		return	new DropConstraintConstantAction( constraintName, constraintSchemaName, tableName, 
0: 												  tableId, tableSchemaName, indexAction, behavior, verifyType);
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DROP INDEX statement.
0: 	 *
0: 	 *
0: 	 *	@param	fullIndexName		Fully qualified index name
0: 	 *	@param	indexName			Index name.
0: 	 *	@param	tableName			The table name
0: 	 *	@param	schemaName					Schema that index lives in.
0: 	 *  @param  tableId				UUID for table
0: 	 *  @param  tableConglomerateId	heap conglomerate ID for table
0: 	 *
0: 	 */
0: 	public	DropIndexConstantAction	getDropIndexConstantAction
0: 	(
0: 		String				fullIndexName,
0: 		String				indexName,
0: 		String				tableName,
0: 		String				schemaName,
0: 		UUID				tableId,
0: 		long				tableConglomerateId
0:     )
0: 	{
0: 		return	new DropIndexConstantAction( fullIndexName, indexName, tableName, schemaName,
0: 											 tableId, tableConglomerateId );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DROP ALIAS statement.
0: 	 *
0: 	 *
0: 	 *	@param	aliasName			Alias name.
0: 	 *	@param	aliasType			Alias type.
0: 	 *
0: 	 */
0: 	public	ConstantAction	getDropAliasConstantAction(SchemaDescriptor	sd, String aliasName, char aliasType)
0: 	{
0: 		return	new DropAliasConstantAction(sd, aliasName, aliasType );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DROP STATEMENT statement.
0: 	 *
0: 	 *	@param	sd					Schema that stored prepared statement lives in.
0: 	 *	@param	spsName				Name of the SPS
0: 	 *
0: 	 */
0: 	public	ConstantAction	getDropSPSConstantAction
0: 	(
0: 		SchemaDescriptor	sd,
0: 		String				spsName
0:     )
0: 	{
0: 		return	new DropSPSConstantAction( sd, spsName );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DROP TABLE statement.
0: 	 *
0: 	 *	@param	schemaName			Table name.
0: 	 *
0: 	 */
0: 	public	ConstantAction	getDropSchemaConstantAction(String	schemaName)
0: 	{
0: 		return	new DropSchemaConstantAction( schemaName );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DROP TABLE statement.
0: 	 *
0: 	 *
0: 	 *	@param	fullTableName		Fully qualified table name
0: 	 *	@param	tableName			Table name.
0: 	 *	@param	sd					Schema that table lives in.
0: 	 *  @param  conglomerateNubmer	Conglomerate number for heap
0: 	 *  @param  tableId				UUID for table
0: 	 *  @param  behavior			drop behavior, CASCADE, RESTRICT or DEFAULT
0: 	 *
0: 	 */
0: 	public	ConstantAction	getDropTableConstantAction
0: 	(
0: 		String				fullTableName,
0: 		String				tableName,
0: 		SchemaDescriptor	sd,
0: 		long				conglomerateNumber,
0: 		UUID				tableId,
0: 		int					behavior
0: 	)
0: 	{
0: 		return	new DropTableConstantAction( fullTableName, tableName, sd, conglomerateNumber, tableId, behavior );
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DROP VIEW statement.
0: 	 *
0: 	 *
0: 	 *	@param	fullTableName		Fully qualified table name
0: 	 *	@param	tableName			Table name.
0: 	 *	@param	sd					Schema that view lives in.
0: 	 *
0: 	 */
0: 	public	ConstantAction	getDropViewConstantAction
0: 	(
0: 		String				fullTableName,
0: 		String				tableName,
0: 		SchemaDescriptor	sd
0:     )
0: 	{
0: 		return new DropViewConstantAction( fullTableName, tableName, sd );
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a RENAME TABLE/COLUMN/INDEX statement.
0: 	 *
0: 	 *	@param	fullTableName Fully qualified table name
0: 	 *	@param	tableName   Table name.
0: 	 *	@param	oldObjectName   Old object name
0: 	 *	@param	newObjectName   New object name.
0: 	 *	@param	sd    Schema that table lives in.
0: 	 *	@param	tableId   UUID for table
0: 	 *  @param	usedAlterTable	True if used Alter Table command, false if used Rename
0: 	 *  @param	renamingWhat	Value indicates if Rename Column/Index.
0: 	 *
0: 	 */
0: 	public	ConstantAction	getRenameConstantAction
0: 	(
0: 		String				fullTableName,
0: 		String				tableName,
0: 		String				oldObjectName,
0: 		String				newObjectName,
0: 		SchemaDescriptor	sd,
0: 		UUID				tableId,
0: 		boolean				usedAlterTable,
0: 		int				renamingWhat
0: 	)
0: 	{
0: 		return	new RenameConstantAction( fullTableName, tableName, oldObjectName, newObjectName,
0: 		sd, tableId, usedAlterTable, renamingWhat );
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a Replicated INSERT statement.
0: 	 *
0: 	 *  @param conglomId		Conglomerate ID.
0: 	 *  @param tableType		type of this table
0: 	 *  @param heapSCOCI		StaticCompiledOpenConglomInfo for target heap.
0: 	 *  @param irgs				Index descriptors
0: 	 *  @param indexCIDS		Conglomerate IDs of indices
0: 	 *	@param indexSCOCIs		StaticCompiledOpenConglomInfos for indexes.
0: 	 *  @param indexNames		Names of indices on this table for error 
0: 	 *							reporting.
0: 	 *	@param deferred			True means deferred insert
0: 	 *  @param tableIsPublished	true if table is published, false otherwise
0: 	 *  @param tableID			table id
0: 	 *  @param targetProperties	Properties on the target table
0: 	 *	@param fkInfo			Array of structures containing foreign key info, 
0: 	 *							if any (may be null)
0: 	 *	@param triggerInfo		Array of structures containing trigger info, 
0: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
0:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
0: 	 *							if any (may be null)
0: 	 *  @param indexedCols		boolean[] of which (0-based) columns are indexed.
0: 	 *  @param dependencyId		UUID for dependency system
0: 	 *	@param stageControl		Stage Control Tokens
0: 	 *	@param ddlList			List of DDL to log. This is for BULK INSERT into a published table at the Source.
0: 	 *  @param singleRowSource	Whether or not source is a single row source
0: 	 *  @param autoincRowLocation array of row locations into syscolumns for
0: 	                              autoincrement columns
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public	ConstantAction getInsertConstantAction(
0: 								TableDescriptor		tableDescriptor,
0: 								long				conglomId,
0: 								StaticCompiledOpenConglomInfo heapSCOCI,
0: 								IndexRowGenerator[]	irgs,
0: 								long[]				indexCIDS,
0: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 								String[]			indexNames,
0: 								boolean				deferred,
0: 								boolean				tableIsPublished,
0: 								UUID				tableID,
0: 								int					lockMode,
0: 								Object         		insertToken,
0: 								Object				rowSignature,
0: 								Properties			targetProperties,
0: 								FKInfo[]			fkInfo,
0: 								TriggerInfo			triggerInfo,
0: 								int[]               streamStorableHeapColIds,
0: 								boolean[]			indexedCols,
0: 								UUID				dependencyId,
0: 								Object[]			stageControl,
0: 								Object[]			ddlList,
0: 								boolean				singleRowSource,
0: 								RowLocation[]		autoincRowLocation
0: 							)
0: 			throws StandardException
0: 	{
0: 		return new InsertConstantAction(tableDescriptor,
0: 										conglomId,
0: 										heapSCOCI,
0: 										irgs,
0: 										indexCIDS,
0: 										indexSCOCIs,
0: 										indexNames,
0: 										deferred,
0: 										targetProperties,
0: 										tableID,
0: 										lockMode,
0: 										fkInfo,
0: 										triggerInfo,
0: 										streamStorableHeapColIds,
0: 										indexedCols,
0: 										singleRowSource,
0: 										autoincRowLocation
0: 										);
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for an updatable VTI statement.
0: 	 *
0: 	 * @param deferred					Deferred mode?
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction getUpdatableVTIConstantAction( int statementType, boolean deferred)
0: 			throws StandardException
0: 	{
0: 		return new UpdatableVTIConstantAction( statementType, deferred, null);
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for an updatable VTI statement.
0: 	 *
0: 	 * @param deferred					Deferred mode?
0:      * @param changedColumnIds Array of ids of changed columns
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction getUpdatableVTIConstantAction( int statementType,
0:                                                          boolean deferred,
0:                                                          int[] changedColumnIds)
0: 			throws StandardException
0: 	{
0: 		return new UpdatableVTIConstantAction( statementType, deferred, changedColumnIds);
0: 	}
0: 
0: 	/**
0: 	 * Make the ConstantAction for a LOCK TABLE statement.
0: 	 *
0: 	 *  @param fullTableName		Full name of the table.
0: 	 *  @param conglomerateNumber	Conglomerate number for the heap
0: 	 *  @param exclusiveMode		Whether or not to get an exclusive lock.
0: 	 */
0: 	public	ConstantAction	getLockTableConstantAction(
0: 					String fullTableName,
0: 					long conglomerateNumber, boolean exclusiveMode)
0: 	{
0: 		return new LockTableConstantAction( 
0: 						fullTableName, conglomerateNumber, exclusiveMode );
0: 	}
0: 
0: 
0: 	/**
0: 	 * Make the ConstantAction for a SET SCHEMA statement.
0: 	 *
0: 	 *  @param schemaName	Name of schema.
0: 	 *  @param type			Literal, USER or ?
0: 	 */
0: 	public	ConstantAction	getSetSchemaConstantAction(String schemaName, int type)
0: 	{
0: 		return new SetSchemaConstantAction( schemaName , type );
0: 	}
0: 
0: 	/**
0: 	 * Make the ConstantAction for a SET TRANSACTION ISOLATION statement.
0: 	 *
0: 	 * @param isolationLevel	The new isolation level.
0: 	 */
0: 	public ConstantAction getSetTransactionIsolationConstantAction(int isolationLevel)
0: 	{
0: 		return new SetTransactionIsolationConstantAction(isolationLevel);
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a Replicated DELETE statement.
0: 	 *
0: 	 *  @param conglomId			Conglomerate ID.
0: 	 *  @param tableType			type of this table
0: 	 *	@param heapSCOCI			StaticCompiledOpenConglomInfo for heap.
0: 	 *  @param irgs					Index descriptors
0: 	 *  @param indexCIDS			Conglomerate IDs of indices
0: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
0: 	 *  @param emptyHeapRow			Template for heap row.
0: 	 *	@param deferred				True means deferred update
0: 	 *	@param targetUUID			UUID of target table
0: 	 *	@param lockMode				The lock mode to use
0: 	 *								  (row or table, see TransactionController)
0: 	 *  @param tableIsPublished		true if table is published, false otherwise
0: 	 *	@param changedColumnIds		Array of ids of changes columns
0: 	 *  @param keyPositions     	positions of primary key columns in base row
0: 	 *  @param updateUndoable		an update token
0: 	 *  @param endRowsUndoable		an end rows token
0: 	 *  @param endStatementUndoable an end statement token
0: 	 *	@param fkInfo				Array of structures containing foreign key info, 
0: 	 *								if any (may be null)
0: 	 *	@param triggerInfo			Array of structures containing trigger info, 
0: 	 *  @param baseRowReadList      Map of columns read in.  1 based.
0:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
0: 	 *								if any (may be null)
0: 	 *  @param baseRowReadMap		map of columns to be selected from the base row
0: 	 *								(partial row). 1 based.
0:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
0: 	 *  @param numColumns			The number of columns being read.
0: 	 *	@param positionedUpdate		is this a positioned update
0: 	 *  @param singleRowSource		Whether or not source is a single row source
0: 	 *
0: 	 *  @exception StandardException Thrown on failure
0: 	 */
0: 	public	UpdateConstantAction	getUpdateConstantAction(
0: 								long				conglomId,
0: 								int					tableType,
0: 								StaticCompiledOpenConglomInfo heapSCOCI,
0: 								IndexRowGenerator[]	irgs,
0: 								long[]				indexCIDS,
0: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 								String[]			indexNames,	
0: 								ExecRow				emptyHeapRow,
0: 								boolean				deferred,
0: 								UUID				targetUUID,
0: 								int					lockMode,
0: 								boolean				tableIsPublished,
0: 								int[]				changedColumnIds,
0: 								int[]				keyPositions,
0: 								Object         		updateToken,
0: 								FKInfo[]			fkInfo,
0: 								TriggerInfo			triggerInfo,
0: 								FormatableBitSet				baseRowReadList,
0: 								int[]				baseRowReadMap,
0: 								int[]				streamStorableHeapColIds,
0: 								int					numColumns,
0: 								boolean				positionedUpdate,
0: 								boolean				singleRowSource
0: 							)
0: 			throws StandardException
0: 	{
0: 		return new UpdateConstantAction(
0: 										conglomId,
0: 										heapSCOCI,
0: 										irgs,
0: 										indexCIDS,
0: 										indexSCOCIs,
0: 										indexNames,
0: 										emptyHeapRow,
0: 										deferred,
0: 										targetUUID,
0: 										lockMode,
0: 										changedColumnIds,
0: 										fkInfo,
0: 										triggerInfo,
0: 										baseRowReadList,
0: 										baseRowReadMap,
0: 										streamStorableHeapColIds,
0: 										numColumns,
0: 										positionedUpdate,
0: 										singleRowSource
0: 										);
0: 	}
0: 
0: 	/**
0: 	 * Make the ConstantAction to Add a jar file to a database.
0: 	 *
0: 	 *	@param	id					The id for the jar file -
0: 	 *                              (null means create one)
0: 	 *	@param	schemaName			The SchemaName for the jar file.
0: 	 *	@param	sqlName			    The sqlName for the jar file.
0: 	 *  @param  fileName            The name of the file that holds the jar.
0: 	 *  @exception StandardException Ooops
0: 	 */
0: 	public	ConstantAction getAddJarConstantAction(UUID id,
0: 														 String schemaName,
0: 														 String sqlName,
0: 														 String externalPath)
0: 		 throws StandardException
0: 	{
0: 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
0: 		return new AddJarConstantAction(id,schemaName,sqlName,externalPath);
0: 	}
0: 	/**
0: 	 * Make the ConstantAction to replace a jar file in a database.
0: 	 *
0: 	 *	@param	id					The id for the jar file -
0: 	 *                              (Ignored if null)
0: 	 *	@param	schemaName			The SchemaName for the jar file.
0: 	 *	@param	sqlName			    The sqlName for the jar file.
0: 	 *  @param  fileName            The name of the file that holds the new jar.
0: 	 *  @exception StandardException Ooops
0: 	 */
0: 	public	ConstantAction getReplaceJarConstantAction(UUID id,
0: 														 String schemaName,
0: 														 String sqlName,
0: 														 String externalPath)
0: 		 throws StandardException
0: 	{
0: 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
0: 		return new ReplaceJarConstantAction(id,schemaName,sqlName,externalPath);
0: 	}
0: 	/**
0: 	 * Make the ConstantAction to drop a jar file from a database.
0: 	 *
0: 	 *	@param	id					The id for the jar file -
0: 	 *                              (Ignored if null)
0: 	 *	@param	schemaName			The SchemaName for the jar file.
0: 	 *	@param	sqlName			    The sqlName for the jar file.
0: 	 *  @exception StandardException Ooops
0: 	 */
0: 	public	ConstantAction getDropJarConstantAction(UUID id,
0: 														  String schemaName,
0: 														  String sqlName)
0: 		 throws StandardException
0: 	{
0: 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
0: 		return new DropJarConstantAction(id,schemaName,sqlName);
0: 	}
0: 
0: 	static protected Authorizer getAuthorizer()
0: 	{
0: 		LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		return lcc.getAuthorizer();
0: 	}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE TRIGGER statement.
0: 	 *
0: 	 * @param triggerSd		descriptor for the schema that trigger lives in.
0: 	 * @param triggerName	Name of trigger
0: 	 * @param eventMask		TriggerDescriptor.TRIGGER_EVENT_XXXX
0: 	 * @param isBefore		is this a before (as opposed to after) trigger 
0: 	 * @param isRow			is this a row trigger or statement trigger
0: 	 * @param isEnabled		is this trigger enabled or disabled
0: 	 * @param triggerTable	the table upon which this trigger is defined
0: 	 * @param whenSPSId		the sps id for the when clause (may be null)
0: 	 * @param whenText		the text of the when clause (may be null)
0: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
0: 	 * @param actionText	the text of the trigger action (may be null)
0: 	 * @param spsCompSchemaId	the compilation schema for the action and when
0: 	 *							spses.   If null, will be set to the current default
0: 	 *							schema
0: 	 * @param creationTimestamp	when was this trigger created?  if null, will be
0: 	 *						set to the time that executeConstantAction() is invoked
0: 	 * @param referencedCols	what columns does this trigger reference (may be null)
0: 	 * @param originalActionText The original user text of the trigger action
0: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
0: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
0: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
0: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
0: 	 */
0: 	public ConstantAction getCreateTriggerConstantAction
0: 	(
0: 		String				triggerSchemaName,
0: 		String				triggerName,
0: 		int					eventMask,
0: 		boolean				isBefore,
0: 		boolean 			isRow,
0: 		boolean 			isEnabled,
0: 		TableDescriptor		triggerTable,
0: 		UUID				whenSPSId,
0: 		String				whenText,
0: 		UUID				actionSPSId,
0: 		String				actionText,
0: 		UUID				spsCompSchemaId,
0: 		Timestamp			creationTimestamp,
0: 		int[]				referencedCols,
0: 		String				originalActionText,
0: 		boolean				referencingOld,
0: 		boolean				referencingNew,
0: 		String				oldReferencingName,
0: 		String				newReferencingName
0: 	)
0: 	{
0: 		return new CreateTriggerConstantAction(triggerSchemaName, triggerName, 
0: 				eventMask, isBefore, isRow, isEnabled, triggerTable, whenSPSId,
0: 				whenText, actionSPSId, actionText, spsCompSchemaId, creationTimestamp,
0: 				referencedCols, originalActionText,
0: 				referencingOld, referencingNew, oldReferencingName, newReferencingName);
0: 	}
0: 
0: 	/**
0: 	 * Make the ConstantAction for a DROP TRIGGER statement.
0: 	 *
0: 	 * @param	sd					Schema that stored prepared statement lives in.
0: 	 * @param	triggerName			Name of the Trigger
0: 	 * @param	tableId				The table this trigger is defined upon
0: 	 */
0: 	public ConstantAction getDropTriggerConstantAction
0: 	(
0: 		SchemaDescriptor	sd,
0: 		String				triggerName,
0: 		UUID				tableId
0: 	)
0: 	{
0: 		return new DropTriggerConstantAction(sd, triggerName, tableId);
0: 	}
0: 	
0: 	/**
0: 	 * Make the constant action for a UPDATE STATISTICS statement.
0: 	 *
0: 	 * @param forTable		whether for an index or table.
0: 	 * @param objectName	name of the object (either table or index) for which
0: 	 * this statistic is being created.
0: 	 * @param tableUUID		UUID of the table for which statistics are being
0: 	 * created.
0: 	 * @param objectUUID    array of UUID's, one for each index conglomerate for
0: 	 * which statistics are being created. 
0: 	 * @param conglomerateNumber array of conglomerate numbers, one for each
0: 	 * index conglomerate for which statistics are being created.
0: 	 * @param indexRow		array of index rows, one for each index. This row is
0: 	 * used by the constant action to read data from the indices.
0: 	 */
0: 	public ConstantAction getUpdateStatisticsConstantAction
0: 	(
0: 	 boolean forTable,
0: 	 String objectName,
0: 	 UUID tableUUID,
0: 	 UUID[] objectUUID,
0: 	 long[] conglomerateNumber,
0: 	 ExecIndexRow[] indexRow
0: 	)
0: 	{
0: 		return new UpdateStatisticsConstantAction(forTable, 
0: 												  objectName,
0: 												  tableUUID,
0: 												  objectUUID,
0: 												  conglomerateNumber,
0: 												  indexRow);
0: 	}
0: 
0: 	/**
0: 	 * Make the constant action for Drop Statistics statement.
0: 	 *
0: 	 * @param sd			Schema Descriptor of the schema in which the object 
0: 	 * resides. 
0: 	 * @param fullTableName full name of the object for which statistics are
0: 	 * being dropped.
0: 	 * @param objectName	 object name for which statistics are being dropped.
0: 	 * @param forTable 		 is it an index or table whose statistics aer being
0: 	 * consigned to the garbage heap?
0: 	 */
0: 	public ConstantAction getDropStatisticsConstantAction
0: 		(SchemaDescriptor sd, String fullTableName, String objectName, boolean forTable)
0: 	{
0: 		return new DropStatisticsConstantAction(sd, fullTableName, objectName, forTable);
0: 	}
0: }
============================================================================