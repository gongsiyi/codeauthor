1:04f8e95: /*
3:04f8e95:  
1:04f8e95:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.Wrapper41Test
1:04f8e95:  
1:04f8e95:    Licensed to the Apache Software Foundation (ASF) under one or more
1:04f8e95:    contributor license agreements.  See the NOTICE file distributed with
1:04f8e95:    this work for additional information regarding copyright ownership.
1:04f8e95:    The ASF licenses this file to you under the Apache License, Version 2.0
1:04f8e95:    (the "License"); you may not use this file except in compliance with
1:04f8e95:    the License.  You may obtain a copy of the License at
1:04f8e95:  
1:04f8e95:       http://www.apache.org/licenses/LICENSE-2.0
1:04f8e95:  
1:04f8e95:    Unless required by applicable law or agreed to in writing, software
1:04f8e95:    distributed under the License is distributed on an "AS IS" BASIS,
1:04f8e95:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:04f8e95:    See the License for the specific language governing permissions and
1:04f8e95:    limitations under the License.
1:04f8e95:  
1:04f8e95:  */
1:04f8e95: 
1:04f8e95: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:04f8e95: 
1:04f8e95: import java.math.BigDecimal;
1:04f8e95: import java.sql.Connection;
1:04f8e95: import java.sql.PreparedStatement;
1:04f8e95: import java.sql.CallableStatement;
1:04f8e95: import java.sql.Blob;
1:04f8e95: import java.sql.Clob;
1:04f8e95: import java.sql.Date;
1:04f8e95: import java.sql.SQLException;
1:04f8e95: import java.sql.Time;
1:04f8e95: import java.sql.Timestamp;
1:4f2e50d: import java.util.Calendar;
1:04f8e95: 
1:04f8e95: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:04f8e95: 
1:04f8e95: /**
1:04f8e95:  * <p>
1:04f8e95:  * Machinery shared by the JDBC 4.1 tests for ResultSets and CallableStatements.
1:04f8e95:  * </p>
1:04f8e95:  */
1:04f8e95: public  class   Wrapper41Test   extends BaseJDBCTestCase
1:04f8e95: {
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95:     //
1:04f8e95:     // CONSTANTS
1:04f8e95:     //
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95: 
1:04f8e95:     private static  final   String  UNSUPPORTED_COERCION = "22005";
1:04f8e95:     private static  final   String  BAD_FORMAT = "22018";
1:04f8e95:     private static  final   String  BAD_DATETIME = "22007";
1:04f8e95: 
1:04f8e95:     private static  final   String  VARIABLE_STRING = "XXXXX";
1:04f8e95: 
1:1447862:     public  static  final   byte[]  BINARY_VALUE = new byte[] { (byte) 0xde };
1:1447862: 
1:4f2e50d:     static final long TIME_VALUE = 83342000L;
1:4f2e50d:     static final long TIMESTAMP_VALUE = -229527385766L;
1:1447862: 
1:1447862: 
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95:     //
1:04f8e95:     // STATE
1:04f8e95:     //
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95: 
1:16bb01f:     private Class       _byteArrayClass;
1:16bb01f:     private boolean _rowOfNulls;
1:04f8e95: 
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95:     //
1:04f8e95:     // CONSTRUCTOR
1:04f8e95:     //
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95: 
1:04f8e95:     /**
1:04f8e95:      * Create test with given name.
1:04f8e95:      *
1:04f8e95:      * @param name name of the test.
1:04f8e95:      */
1:16bb01f:     public Wrapper41Test( String name ) { super( name ); }
1:04f8e95: 
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95:     //
1:04f8e95:     // BEHAVIOR
1:04f8e95:     //
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95: 
1:16bb01f:     protected void examineJDBC4_1extensions( Wrapper41 wrapper, boolean rowOfNulls ) throws Exception
1:04f8e95:     {
1:16bb01f:         println( "Vetting a " + wrapper.getWrappedObject().getClass().getName() + ". rowOfNulls = " + rowOfNulls );
1:04f8e95: 
1:16bb01f:         _byteArrayClass = Class.forName( "[B" );
1:16bb01f:         _rowOfNulls = rowOfNulls;
1:04f8e95: 
1:04f8e95:         vetWrappedNull( wrapper );
1:04f8e95:         vetWrappedInteger( wrapper, 1, "BIGINTCOL" );
1:04f8e95:         vetWrappedBlob( wrapper );
1:04f8e95:         vetWrappedBoolean( wrapper );
1:04f8e95:         vetWrappedString( wrapper, 4, "CHARCOL" );
1:04f8e95:         vetWrappedBinary( wrapper, 5, "CHARFORBITDATACOL" );
1:04f8e95:         vetWrappedClob( wrapper );
1:04f8e95:         vetWrappedDate( wrapper );
1:04f8e95:         vetWrappedFloatingPoint( wrapper, 8, "DOUBLECOL" );
1:04f8e95:         vetWrappedFloatingPoint( wrapper, 9, "FLOATCOL" );
1:04f8e95:         vetWrappedInteger( wrapper, 10, "INTCOL" );
1:04f8e95:         vetWrappedString( wrapper, 11, "LONGVARCHARCOL" );
1:04f8e95:         vetWrappedBinary( wrapper, 12, "LONGVARCHARFORBITDATACOL" );
1:04f8e95:         vetWrappedInteger( wrapper, 13, "NUMERICCOL" );
1:04f8e95:         vetWrappedFloatingPoint( wrapper, 14, "REALCOL" );
1:04f8e95:         vetWrappedInteger( wrapper, 15, "SMALLINTCOL" );
1:04f8e95:         vetWrappedTime( wrapper );
1:04f8e95:         vetWrappedTimestamp( wrapper );
1:04f8e95:         vetWrappedString( wrapper, 18, "VARCHARCOL" );
1:04f8e95:         vetWrappedBinary( wrapper, 19, "VARCHARFORBITDATACOL" );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedNull( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:04f8e95:             try {
1:a784994:                 wrapper.getObject( 1, (Class<?>) null );
1:04f8e95:                 fail( "Did not expect to get a result for a null class type." );
1:04f8e95:             }
1:04f8e95:             catch (SQLException e)
1:04f8e95:             {
1:04f8e95:                 assertSQLState( "Null type", UNSUPPORTED_COERCION, e );
1:04f8e95:             }
1:04f8e95: 
1:04f8e95:             // String overloads not implemented for CallableStatements
1:04f8e95:             if ( wrapper.getWrappedObject() instanceof CallableStatement ) { return; }
1:04f8e95:             
1:04f8e95:             try {
1:a784994:                 wrapper.getObject( "BIGINTCOL", (Class<?>) null );
1:04f8e95:                 fail( "Did not expect to get a result for a null class type." );
1:04f8e95:             }
1:04f8e95:             catch (SQLException e)
1:04f8e95:             {
1:04f8e95:                 assertSQLState( "Null type", UNSUPPORTED_COERCION, e );
1:04f8e95:             }
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedInteger( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "1",
1:04f8e95:              new Class[] { String.class, BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class, Number.class, Object.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "1.0",
1:04f8e95:              new Class[] { Float.class, Double.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "true",
1:04f8e95:              new Class[] { Boolean.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, _byteArrayClass, getClass() }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedBlob( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              2,
1:04f8e95:              "BLOBCOL",
1:16bb01f:              _rowOfNulls ? null : BINARY_VALUE,
1:16bb01f:              new Class[] { Blob.class, Object.class, _byteArrayClass, String.class,  }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              2,
1:04f8e95:              "BLOBCOL",
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  BigDecimal.class, Boolean.class,
1:04f8e95:                  Byte.class, Short.class, Integer.class, Long.class, Float.class, Double.class,
1:04f8e95:                  Date.class, Time.class, Timestamp.class
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         //
1:04f8e95:         // We don't try to get a Clob value because we have already gotten a LOB value.
1:04f8e95:         // Trying to open another LOB stream raises an error. Using a random class type
1:04f8e95:         // also takes us down that code path, so we don't verify against getClass() either.
1:04f8e95:         //
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedBoolean( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              3,
1:04f8e95:              "BOOLEANCOL",
1:16bb01f:              _rowOfNulls ? null : "true",
1:04f8e95:              new Class[] { String.class, Boolean.class, Object.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              3,
1:04f8e95:              "BOOLEANCOL",
1:16bb01f:              _rowOfNulls ? null : "1",
1:04f8e95:              new Class[] { BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              3,
1:04f8e95:              "BOOLEANCOL",
1:16bb01f:              _rowOfNulls ? null : "1.0",
1:04f8e95:              new Class[] { Float.class, Double.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              3,
1:04f8e95:              "BOOLEANCOL",
1:16bb01f:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, _byteArrayClass, getClass() }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedString( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "a",
1:04f8e95:              new Class[] { String.class, Object.class }
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "true",
1:04f8e95:              new Class[] { Boolean.class }
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         vetCoercionError
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:04f8e95:                  Float.class, Double.class,
1:04f8e95:              },
1:04f8e95:              BAD_FORMAT
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         vetCoercionError
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  Date.class, Time.class, Timestamp.class
1:04f8e95:              },
1:04f8e95:              BAD_DATETIME
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:04f8e95:              new Class[]
1:04f8e95:              {
1:16bb01f:                  Blob.class, Clob.class, _byteArrayClass, getClass()
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedBinary( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "de",
1:04f8e95:              new Class[] { String.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : BINARY_VALUE,
1:16bb01f:              new Class[] { _byteArrayClass, Object.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  Boolean.class, BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:04f8e95:                  Float.class, Double.class,
1:04f8e95:                  Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, getClass()
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedClob( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              6,
1:04f8e95:              "CLOBCOL",
1:16bb01f:              _rowOfNulls ? null : "abc",
1:04f8e95:              new Class[] { String.class, Clob.class, Object.class }
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              6,
1:04f8e95:              "CLOBCOL",
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  Boolean.class,
1:04f8e95:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:04f8e95:                  Float.class, Double.class,
1:04f8e95:                  Date.class, Time.class, Timestamp.class,
1:16bb01f:                  _byteArrayClass
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95: 
1:04f8e95:         //
1:04f8e95:         // We don't test getting a BLOB because we are only allowed one attempt
1:04f8e95:         // to get a LOB from the column. Using a random class type
1:04f8e95:         // also takes us down that code path, so we don't verify against getClass() either.
1:04f8e95:         //
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedDate( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              7,
1:04f8e95:              "DATECOL",
1:16bb01f:              _rowOfNulls ? null : "1994-02-23",
1:04f8e95:              new Class[] { String.class, Date.class, Object.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              7,
1:04f8e95:              "DATECOL",
1:16bb01f:              _rowOfNulls ? null : "1994-02-23 00:00:00.0",
1:04f8e95:              new Class[] { Timestamp.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              7,
1:04f8e95:              "DATECOL",
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  Boolean.class,
1:04f8e95:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:04f8e95:                  Float.class, Double.class,
1:04f8e95:                  Time.class,
1:16bb01f:                  Blob.class, Clob.class, _byteArrayClass, getClass()
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedFloatingPoint( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:04f8e95:     {
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "1.0",
1:04f8e95:              new Class[] { String.class, Float.class, Double.class, BigDecimal.class, Number.class, Object.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "1",
1:04f8e95:              new Class[] { Byte.class, Short.class, Integer.class, Long.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              _rowOfNulls ? null : "true",
1:04f8e95:              new Class[] { Boolean.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              colID,
1:04f8e95:              colName,
1:16bb01f:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, _byteArrayClass, getClass() }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedTime( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:4f2e50d:         Time expectedTime = new Time(TIME_VALUE);
1:4f2e50d: 
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              16,
1:04f8e95:              "TIMECOL",
1:16bb01f:              _rowOfNulls ? null : expectedTime.toString(),
1:04f8e95:              new Class[] { String.class, Time.class, Object.class }
1:04f8e95:              );
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              16,
1:04f8e95:              "TIMECOL",
1:16bb01f:              _rowOfNulls ? null : timeToTimestamp(expectedTime).toString(),
1:04f8e95:              new Class[] { Timestamp.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              16,
1:04f8e95:              "TIMECOL",
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  Boolean.class,
1:04f8e95:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:04f8e95:                  Float.class, Double.class,
1:04f8e95:                  Date.class,
1:16bb01f:                  Blob.class, Clob.class, _byteArrayClass, getClass()
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95:     private void    vetWrappedTimestamp( Wrapper41 wrapper ) throws Exception
1:04f8e95:     {
1:4f2e50d:         String expectedTimestamp = new Timestamp(TIMESTAMP_VALUE).toString();
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              17,
1:04f8e95:              "TIMESTAMPCOL",
1:16bb01f:              _rowOfNulls ? null : expectedTimestamp,
1:04f8e95:              new Class[] { String.class, Timestamp.class, Object.class }
1:04f8e95:              );
1:4f2e50d: 
1:4f2e50d:         String expectedTime = new Time(TIMESTAMP_VALUE).toString();
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              17,
1:04f8e95:              "TIMESTAMPCOL",
1:16bb01f:              _rowOfNulls ? null : expectedTime,
1:04f8e95:              new Class[] { Time.class }
1:04f8e95:              );
1:4f2e50d: 
1:4f2e50d:         String expectedDate = new Date(TIMESTAMP_VALUE).toString();
1:04f8e95:         vetWrapperOK
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              17,
1:04f8e95:              "TIMESTAMPCOL",
1:16bb01f:              _rowOfNulls ? null : expectedDate,
1:04f8e95:              new Class[] { Date.class }
1:04f8e95:              );
1:04f8e95:         
1:04f8e95:         vetNoWrapper
1:04f8e95:             (
1:04f8e95:              wrapper,
1:04f8e95:              17,
1:04f8e95:              "TIMESTAMPCOL",
1:04f8e95:              new Class[]
1:04f8e95:              {
1:04f8e95:                  Boolean.class,
1:04f8e95:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:04f8e95:                  Float.class, Double.class,
1:16bb01f:                  Blob.class, Clob.class, _byteArrayClass, getClass()
1:04f8e95:              }
1:04f8e95:              );
1:04f8e95:     }
1:04f8e95: 
1:04f8e95:     private void    vetWrapperOK
1:1447862:         ( Wrapper41 wrapper, int colID, String colName, Object expectedValue, Class[] supportedCoercions )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:04f8e95:         int coercionCount = supportedCoercions.length;
1:04f8e95:         for ( int i = 0; i < coercionCount; i++ )
1:04f8e95:         {
1:a784994:             Class<?> candidate = supportedCoercions[ i ];
1:04f8e95:             vetCandidate( candidate, expectedValue, wrapper.getObject( colID, candidate ) );
1:04f8e95:             
1:04f8e95:             // you can only retrieve a LOB once
1:04f8e95:             if ( (candidate == Blob.class) || (candidate == Clob.class) ) { return; }
1:04f8e95: 
1:04f8e95:             // String overloads not implemented for CallableStatement
1:04f8e95:             if ( !(wrapper.getWrappedObject() instanceof CallableStatement) )
1:04f8e95:             { vetCandidate( candidate, expectedValue, wrapper.getObject( colName, candidate ) ); }
1:04f8e95:         }
1:04f8e95:     }
1:a784994:     private void vetCandidate( Class<?> candidate, Object expectedValue, Object actualValue )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:16bb01f:         if ( actualValue != null ) { assertTrue( candidate.getName(), candidate.isAssignableFrom( actualValue.getClass( ) ) ); }
1:16bb01f: 
1:16bb01f:         if ( expectedValue == null )
1:16bb01f:         {
1:16bb01f:             assertNull( actualValue );
1:16bb01f:             return;
1:16bb01f:         }
1:04f8e95: 
1:04f8e95:         if ( VARIABLE_STRING.equals( expectedValue ) ) { return; }
1:1447862: 
1:04f8e95:         String  actualString;
1:04f8e95:         if ( actualValue instanceof Blob )
1:04f8e95:         {
1:04f8e95:             Blob    blob = (Blob) actualValue;
1:1447862:             vetBytes( (byte[]) expectedValue, blob.getBytes( 1L, (int) blob.length() ) );
1:1447862:             return;
1:04f8e95:         }
1:04f8e95:         else if ( actualValue instanceof byte[] )
1:04f8e95:         {
1:1447862:             vetBytes( (byte[]) expectedValue, (byte[]) actualValue );
1:1447862:             return;
1:04f8e95:         }
1:04f8e95:         else if ( actualValue instanceof Clob )
1:04f8e95:         {
1:04f8e95:             Clob    clob = (Clob) actualValue;
1:04f8e95:             actualString = clob.getSubString( 1L, (int) clob.length() );
1:04f8e95:         }
1:04f8e95:         else { actualString = actualValue.toString(); }
1:04f8e95:         
1:1447862:         assertEquals( candidate.getName(), (String) expectedValue, actualString );
1:04f8e95:     }
1:1447862:     private void    vetBytes( byte[] expected, byte[] actual ) throws Exception
1:04f8e95:     {
1:1447862:         int count = expected.length;
1:04f8e95: 
1:1447862:         assertEquals( count, actual.length );
1:1447862:         for ( int i = 0; i < count; i++ )
1:1447862:         {
1:1447862:             assertEquals( expected[ i ], actual[ i ] );
1:1447862:         }
1:04f8e95:     }
1:04f8e95:     private void    vetNoWrapper
1:04f8e95:         ( Wrapper41 wrapper, int colID, String colName, Class[] unsupportedCoercions )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:04f8e95:         vetCoercionError( wrapper, colID, colName, unsupportedCoercions, UNSUPPORTED_COERCION );
1:04f8e95:     }
1:04f8e95:     private void    vetCoercionError
1:04f8e95:         ( Wrapper41 wrapper, int colID, String colName, Class[] unsupportedCoercions, String expectedSQLState )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:16bb01f:         // null can be coerced to anything
1:16bb01f:         if ( _rowOfNulls ) { return; }
1:16bb01f:         
1:04f8e95:         int coercionCount = unsupportedCoercions.length;
1:04f8e95:         for ( int i = 0; i < coercionCount; i++ )
1:04f8e95:         {
1:a784994:             Class<?> candidate = unsupportedCoercions[ i ];
1:04f8e95: 
1:04f8e95:             try {
1:04f8e95:                 wrapper.getObject( colID, candidate );
1:04f8e95:                 fail( "Did not expect to get a " + candidate.getName() );
1:04f8e95:             }
1:04f8e95:             catch (SQLException e)
1:04f8e95:             {
1:04f8e95:                 assertSQLState( candidate.getName(), expectedSQLState, e );
1:04f8e95:             }
1:04f8e95: 
1:04f8e95:             // you can only retrieve a LOB once
1:04f8e95:             if ( (candidate == Blob.class) || (candidate == Clob.class) ) { return; }
1:04f8e95: 
1:04f8e95:             // String overloads not implemented for CallableStatements
1:04f8e95:             if ( wrapper.getWrappedObject() instanceof CallableStatement ) { return; }
1:04f8e95:             
1:04f8e95:             try {
1:04f8e95:                 wrapper.getObject( colName, candidate );
1:04f8e95:                 fail( "Did not expect to get a " + candidate.getName() );
1:04f8e95:             }
1:04f8e95:             catch (SQLException e)
1:04f8e95:             {
1:04f8e95:                 assertSQLState( candidate.getName(), expectedSQLState, e );
1:04f8e95:             }
1:04f8e95:         }
1:04f8e95:     }
1:04f8e95:     
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95:     //
1:04f8e95:     // MINIONS
1:04f8e95:     //
1:04f8e95:     ///////////////////////////////////////////////////////////////////////
1:04f8e95: 
1:04f8e95:     protected PreparedStatement    prepareStatement( Connection conn, String text )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:04f8e95:         println( text );
1:04f8e95:         
1:04f8e95:         PreparedStatement   ps = conn.prepareStatement( text );
1:04f8e95: 
1:04f8e95:         return ps;
1:04f8e95:     }
1:04f8e95: 
1:04f8e95:     protected CallableStatement    prepareCall( Connection conn, String text )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:04f8e95:         println( text );
1:04f8e95:         
1:04f8e95:         CallableStatement cs = conn.prepareCall( text );
1:04f8e95: 
1:04f8e95:         return cs;
1:04f8e95:     }
1:04f8e95: 
1:4f2e50d:     /**
1:4f2e50d:      * Convert a Time value to a Timestamp value the same way as when we call
1:4f2e50d:      * getTimestamp() on a TIME column. That is, construct a Timestamp value
1:4f2e50d:      * with the date component set to the current date and the time component
1:4f2e50d:      * set to the specified time of day.
1:4f2e50d:      *
1:4f2e50d:      * @param time the Time value to convert
1:4f2e50d:      * @return a Timestamp value representing the specified time on the
1:4f2e50d:      * current date
1:4f2e50d:      */
1:4f2e50d:     private static Timestamp timeToTimestamp(Time time) {
1:4f2e50d:         // Create a calendar object representing the time value
1:4f2e50d:         Calendar timeCal = Calendar.getInstance();
1:4f2e50d:         timeCal.setTime(time);
1:4f2e50d: 
1:4f2e50d:         // Create a calendar object for the timestamp, initialized with
1:4f2e50d:         // the current time value
1:4f2e50d:         Calendar tsCal = Calendar.getInstance();
1:4f2e50d: 
1:4f2e50d:         // Copy all fields, except the date fields, from the time calendar
1:4f2e50d:         // to the timestamp calendar
1:4f2e50d:         int[] timeFields = {
1:4f2e50d:             Calendar.HOUR_OF_DAY,
1:4f2e50d:             Calendar.MINUTE,
1:4f2e50d:             Calendar.SECOND,
1:4f2e50d:             Calendar.MILLISECOND
1:4f2e50d:         };
1:4f2e50d: 
1:4f2e50d:         for (int field : timeFields) {
1:4f2e50d:             tsCal.set(field, timeCal.get(field));
1:4f2e50d:         }
1:4f2e50d: 
1:4f2e50d:         // Return a timestamp based on the current date and the specified time
1:4f2e50d:         return new Timestamp(tsCal.getTimeInMillis());
1:4f2e50d:     }
1:4f2e50d: 
1:04f8e95: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a784994
/////////////////////////////////////////////////////////////////////////
1:                 wrapper.getObject( 1, (Class<?>) null );
/////////////////////////////////////////////////////////////////////////
1:                 wrapper.getObject( "BIGINTCOL", (Class<?>) null );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Class<?> candidate = supportedCoercions[ i ];
/////////////////////////////////////////////////////////////////////////
1:     private void vetCandidate( Class<?> candidate, Object expectedValue, Object actualValue )
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Class<?> candidate = unsupportedCoercions[ i ];
commit:4f2e50d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1:     static final long TIME_VALUE = 83342000L;
1:     static final long TIMESTAMP_VALUE = -229527385766L;
/////////////////////////////////////////////////////////////////////////
1:         Time expectedTime = new Time(TIME_VALUE);
1: 
0:              expectedTime.toString(),
/////////////////////////////////////////////////////////////////////////
0:              timeToTimestamp(expectedTime).toString(),
/////////////////////////////////////////////////////////////////////////
1:         String expectedTimestamp = new Timestamp(TIMESTAMP_VALUE).toString();
0:              expectedTimestamp,
1: 
1:         String expectedTime = new Time(TIMESTAMP_VALUE).toString();
0:              expectedTime,
1: 
1:         String expectedDate = new Date(TIMESTAMP_VALUE).toString();
0:              expectedDate,
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Convert a Time value to a Timestamp value the same way as when we call
1:      * getTimestamp() on a TIME column. That is, construct a Timestamp value
1:      * with the date component set to the current date and the time component
1:      * set to the specified time of day.
1:      *
1:      * @param time the Time value to convert
1:      * @return a Timestamp value representing the specified time on the
1:      * current date
1:      */
1:     private static Timestamp timeToTimestamp(Time time) {
1:         // Create a calendar object representing the time value
1:         Calendar timeCal = Calendar.getInstance();
1:         timeCal.setTime(time);
1: 
1:         // Create a calendar object for the timestamp, initialized with
1:         // the current time value
1:         Calendar tsCal = Calendar.getInstance();
1: 
1:         // Copy all fields, except the date fields, from the time calendar
1:         // to the timestamp calendar
1:         int[] timeFields = {
1:             Calendar.HOUR_OF_DAY,
1:             Calendar.MINUTE,
1:             Calendar.SECOND,
1:             Calendar.MILLISECOND
1:         };
1: 
1:         for (int field : timeFields) {
1:             tsCal.set(field, timeCal.get(field));
1:         }
1: 
1:         // Return a timestamp based on the current date and the specified time
1:         return new Timestamp(tsCal.getTimeInMillis());
1:     }
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:16bb01f
/////////////////////////////////////////////////////////////////////////
1:     private Class       _byteArrayClass;
1:     private boolean _rowOfNulls;
/////////////////////////////////////////////////////////////////////////
1:     public Wrapper41Test( String name ) { super( name ); }
/////////////////////////////////////////////////////////////////////////
1:     protected void examineJDBC4_1extensions( Wrapper41 wrapper, boolean rowOfNulls ) throws Exception
1:         println( "Vetting a " + wrapper.getWrappedObject().getClass().getName() + ". rowOfNulls = " + rowOfNulls );
1:         _byteArrayClass = Class.forName( "[B" );
1:         _rowOfNulls = rowOfNulls;
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1.0",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "true",
/////////////////////////////////////////////////////////////////////////
1:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, _byteArrayClass, getClass() }
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : BINARY_VALUE,
1:              new Class[] { Blob.class, Object.class, _byteArrayClass, String.class,  }
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "true",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1.0",
/////////////////////////////////////////////////////////////////////////
1:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, _byteArrayClass, getClass() }
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "a",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "true",
/////////////////////////////////////////////////////////////////////////
1:                  Blob.class, Clob.class, _byteArrayClass, getClass()
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "de",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : BINARY_VALUE,
1:              new Class[] { _byteArrayClass, Object.class }
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "abc",
/////////////////////////////////////////////////////////////////////////
1:                  _byteArrayClass
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1994-02-23",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1994-02-23 00:00:00.0",
/////////////////////////////////////////////////////////////////////////
1:                  Blob.class, Clob.class, _byteArrayClass, getClass()
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1.0",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "1",
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : "true",
/////////////////////////////////////////////////////////////////////////
1:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, _byteArrayClass, getClass() }
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : expectedTime.toString(),
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : timeToTimestamp(expectedTime).toString(),
/////////////////////////////////////////////////////////////////////////
1:                  Blob.class, Clob.class, _byteArrayClass, getClass()
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : expectedTimestamp,
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : expectedTime,
/////////////////////////////////////////////////////////////////////////
1:              _rowOfNulls ? null : expectedDate,
/////////////////////////////////////////////////////////////////////////
1:                  Blob.class, Clob.class, _byteArrayClass, getClass()
/////////////////////////////////////////////////////////////////////////
1:         if ( actualValue != null ) { assertTrue( candidate.getName(), candidate.isAssignableFrom( actualValue.getClass( ) ) ); }
1: 
1:         if ( expectedValue == null )
1:         {
1:             assertNull( actualValue );
1:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // null can be coerced to anything
1:         if ( _rowOfNulls ) { return; }
1:         
commit:c244a31
/////////////////////////////////////////////////////////////////////////
0:              VARIABLE_STRING,
commit:1447862
/////////////////////////////////////////////////////////////////////////
1:     public  static  final   byte[]  BINARY_VALUE = new byte[] { (byte) 0xde };
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:              BINARY_VALUE,
/////////////////////////////////////////////////////////////////////////
0:              BINARY_VALUE,
/////////////////////////////////////////////////////////////////////////
1:         ( Wrapper41 wrapper, int colID, String colName, Object expectedValue, Class[] supportedCoercions )
/////////////////////////////////////////////////////////////////////////
0:     private void    vetCandidate( Class candidate, Object expectedValue, Object actualValue )
1: 
1:             vetBytes( (byte[]) expectedValue, blob.getBytes( 1L, (int) blob.length() ) );
1:             return;
1:             vetBytes( (byte[]) expectedValue, (byte[]) actualValue );
1:             return;
/////////////////////////////////////////////////////////////////////////
1:         assertEquals( candidate.getName(), (String) expectedValue, actualString );
1:     private void    vetBytes( byte[] expected, byte[] actual ) throws Exception
1:         int count = expected.length;
1:         assertEquals( count, actual.length );
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             assertEquals( expected[ i ], actual[ i ] );
1:         }
commit:04f8e95
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.Wrapper41Test
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.math.BigDecimal;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.CallableStatement;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Date;
0: import java.sql.NClob;
0: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.SQLException;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import junit.framework.*;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * <p>
1:  * Machinery shared by the JDBC 4.1 tests for ResultSets and CallableStatements.
1:  * </p>
1:  */
1: public  class   Wrapper41Test   extends BaseJDBCTestCase
1: {
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  UNSUPPORTED_COERCION = "22005";
1:     private static  final   String  BAD_FORMAT = "22018";
1:     private static  final   String  BAD_DATETIME = "22007";
1: 
1:     private static  final   String  VARIABLE_STRING = "XXXXX";
1: 
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
0:     private Class   byteArrayClass;
1: 
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create test with given name.
1:      *
1:      * @param name name of the test.
1:      */
0:     public Wrapper41Test(String name) { super(name); }
1: 
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
0:     protected void examineJDBC4_1extensions( Wrapper41 wrapper ) throws Exception
1:     {
0:         println( "Vetting a " + wrapper.getWrappedObject().getClass().getName() );
1: 
0:         byteArrayClass = Class.forName( "[B" );
1: 
1:         vetWrappedNull( wrapper );
1:         vetWrappedInteger( wrapper, 1, "BIGINTCOL" );
1:         vetWrappedBlob( wrapper );
1:         vetWrappedBoolean( wrapper );
1:         vetWrappedString( wrapper, 4, "CHARCOL" );
1:         vetWrappedBinary( wrapper, 5, "CHARFORBITDATACOL" );
1:         vetWrappedClob( wrapper );
1:         vetWrappedDate( wrapper );
1:         vetWrappedFloatingPoint( wrapper, 8, "DOUBLECOL" );
1:         vetWrappedFloatingPoint( wrapper, 9, "FLOATCOL" );
1:         vetWrappedInteger( wrapper, 10, "INTCOL" );
1:         vetWrappedString( wrapper, 11, "LONGVARCHARCOL" );
1:         vetWrappedBinary( wrapper, 12, "LONGVARCHARFORBITDATACOL" );
1:         vetWrappedInteger( wrapper, 13, "NUMERICCOL" );
1:         vetWrappedFloatingPoint( wrapper, 14, "REALCOL" );
1:         vetWrappedInteger( wrapper, 15, "SMALLINTCOL" );
1:         vetWrappedTime( wrapper );
1:         vetWrappedTimestamp( wrapper );
1:         vetWrappedString( wrapper, 18, "VARCHARCOL" );
1:         vetWrappedBinary( wrapper, 19, "VARCHARFORBITDATACOL" );
1:     }
0:     @SuppressWarnings("unchecked")
1:     private void    vetWrappedNull( Wrapper41 wrapper ) throws Exception
1:     {
1:             try {
0:                 wrapper.getObject( 1, (Class) null );
1:                 fail( "Did not expect to get a result for a null class type." );
1:             }
1:             catch (SQLException e)
1:             {
1:                 assertSQLState( "Null type", UNSUPPORTED_COERCION, e );
1:             }
1: 
1:             // String overloads not implemented for CallableStatements
1:             if ( wrapper.getWrappedObject() instanceof CallableStatement ) { return; }
1:             
1:             try {
0:                 wrapper.getObject( "BIGINTCOL", (Class) null );
1:                 fail( "Did not expect to get a result for a null class type." );
1:             }
1:             catch (SQLException e)
1:             {
1:                 assertSQLState( "Null type", UNSUPPORTED_COERCION, e );
1:             }
1:     }
1:     private void    vetWrappedInteger( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "1",
1:              new Class[] { String.class, BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class, Number.class, Object.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "1.0",
1:              new Class[] { Float.class, Double.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "true",
1:              new Class[] { Boolean.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, byteArrayClass, getClass() }
1:              );
1:     }
1:     private void    vetWrappedBlob( Wrapper41 wrapper ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              2,
1:              "BLOBCOL",
0:              "abc",
0:              new Class[] { Blob.class, Object.class, byteArrayClass, String.class,  }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              2,
1:              "BLOBCOL",
1:              new Class[]
1:              {
1:                  BigDecimal.class, Boolean.class,
1:                  Byte.class, Short.class, Integer.class, Long.class, Float.class, Double.class,
1:                  Date.class, Time.class, Timestamp.class
1:              }
1:              );
1: 
1:         //
1:         // We don't try to get a Clob value because we have already gotten a LOB value.
1:         // Trying to open another LOB stream raises an error. Using a random class type
1:         // also takes us down that code path, so we don't verify against getClass() either.
1:         //
1:     }
1:     private void    vetWrappedBoolean( Wrapper41 wrapper ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              3,
1:              "BOOLEANCOL",
0:              "true",
1:              new Class[] { String.class, Boolean.class, Object.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              3,
1:              "BOOLEANCOL",
0:              "1",
1:              new Class[] { BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              3,
1:              "BOOLEANCOL",
0:              "1.0",
1:              new Class[] { Float.class, Double.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              3,
1:              "BOOLEANCOL",
0:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, byteArrayClass, getClass() }
1:              );
1:     }
1:     private void    vetWrappedString( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "a",
1:              new Class[] { String.class, Object.class }
1:              );
1: 
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "true",
1:              new Class[] { Boolean.class }
1:              );
1: 
1:         vetCoercionError
1:             (
1:              wrapper,
1:              colID,
1:              colName,
1:              new Class[]
1:              {
1:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:                  Float.class, Double.class,
1:              },
1:              BAD_FORMAT
1:              );
1: 
1:         vetCoercionError
1:             (
1:              wrapper,
1:              colID,
1:              colName,
1:              new Class[]
1:              {
1:                  Date.class, Time.class, Timestamp.class
1:              },
1:              BAD_DATETIME
1:              );
1: 
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              colID,
1:              colName,
1:              new Class[]
1:              {
0:                  Blob.class, Clob.class, byteArrayClass, getClass()
1:              }
1:              );
1:     }
1:     private void    vetWrappedBinary( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "de",
1:              new Class[] { String.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "\ufffd",
0:              new Class[] { byteArrayClass, Object.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              colID,
1:              colName,
1:              new Class[]
1:              {
1:                  Boolean.class, BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:                  Float.class, Double.class,
1:                  Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, getClass()
1:              }
1:              );
1:     }
1:     private void    vetWrappedClob( Wrapper41 wrapper ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              6,
1:              "CLOBCOL",
0:              "abc",
1:              new Class[] { String.class, Clob.class, Object.class }
1:              );
1: 
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              6,
1:              "CLOBCOL",
1:              new Class[]
1:              {
1:                  Boolean.class,
1:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:                  Float.class, Double.class,
1:                  Date.class, Time.class, Timestamp.class,
0:                  byteArrayClass
1:              }
1:              );
1: 
1:         //
1:         // We don't test getting a BLOB because we are only allowed one attempt
1:         // to get a LOB from the column. Using a random class type
1:         // also takes us down that code path, so we don't verify against getClass() either.
1:         //
1:     }
1:     private void    vetWrappedDate( Wrapper41 wrapper ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              7,
1:              "DATECOL",
0:              "1994-02-23",
1:              new Class[] { String.class, Date.class, Object.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              7,
1:              "DATECOL",
0:              "1994-02-23 00:00:00.0",
1:              new Class[] { Timestamp.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              7,
1:              "DATECOL",
1:              new Class[]
1:              {
1:                  Boolean.class,
1:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:                  Float.class, Double.class,
1:                  Time.class,
0:                  Blob.class, Clob.class, byteArrayClass, getClass()
1:              }
1:              );
1:     }
1:     private void    vetWrappedFloatingPoint( Wrapper41 wrapper, int colID, String colName ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "1.0",
1:              new Class[] { String.class, Float.class, Double.class, BigDecimal.class, Number.class, Object.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "1",
1:              new Class[] { Byte.class, Short.class, Integer.class, Long.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              "true",
1:              new Class[] { Boolean.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              colID,
1:              colName,
0:              new Class[] { Date.class, Time.class, Timestamp.class, Blob.class, Clob.class, byteArrayClass, getClass() }
1:              );
1:     }
1:     private void    vetWrappedTime( Wrapper41 wrapper ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              16,
1:              "TIMECOL",
0:              "15:09:02",
1:              new Class[] { String.class, Time.class, Object.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              16,
1:              "TIMECOL",
0:              VARIABLE_STRING,
1:              new Class[] { Timestamp.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              16,
1:              "TIMECOL",
1:              new Class[]
1:              {
1:                  Boolean.class,
1:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:                  Float.class, Double.class,
1:                  Date.class,
0:                  Blob.class, Clob.class, byteArrayClass, getClass()
1:              }
1:              );
1:     }
1:     private void    vetWrappedTimestamp( Wrapper41 wrapper ) throws Exception
1:     {
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              17,
1:              "TIMESTAMPCOL",
0:              "1962-09-23 03:23:34.234",
1:              new Class[] { String.class, Timestamp.class, Object.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              17,
1:              "TIMESTAMPCOL",
0:              "03:23:34",
1:              new Class[] { Time.class }
1:              );
1:         vetWrapperOK
1:             (
1:              wrapper,
1:              17,
1:              "TIMESTAMPCOL",
0:              "1962-09-23",
1:              new Class[] { Date.class }
1:              );
1:         
1:         vetNoWrapper
1:             (
1:              wrapper,
1:              17,
1:              "TIMESTAMPCOL",
1:              new Class[]
1:              {
1:                  Boolean.class,
1:                  BigDecimal.class, Byte.class, Short.class, Integer.class, Long.class,
1:                  Float.class, Double.class,
0:                  Blob.class, Clob.class, byteArrayClass, getClass()
1:              }
1:              );
1:     }
1: 
0:     @SuppressWarnings("unchecked")
1:     private void    vetWrapperOK
0:         ( Wrapper41 wrapper, int colID, String colName, String expectedValue, Class[] supportedCoercions )
1:         throws Exception
1:     {
1:         int coercionCount = supportedCoercions.length;
1:         for ( int i = 0; i < coercionCount; i++ )
1:         {
0:             Class   candidate = supportedCoercions[ i ];
1:             vetCandidate( candidate, expectedValue, wrapper.getObject( colID, candidate ) );
1:             
1:             // you can only retrieve a LOB once
1:             if ( (candidate == Blob.class) || (candidate == Clob.class) ) { return; }
1: 
1:             // String overloads not implemented for CallableStatement
1:             if ( !(wrapper.getWrappedObject() instanceof CallableStatement) )
1:             { vetCandidate( candidate, expectedValue, wrapper.getObject( colName, candidate ) ); }
1:         }
1:     }
0:     @SuppressWarnings("unchecked")
0:     private void    vetCandidate( Class candidate, String expectedValue, Object actualValue )
1:         throws Exception
1:     {
0:         assertTrue( candidate.getName(), candidate.isAssignableFrom( actualValue.getClass( ) ) );
1: 
1:         if ( VARIABLE_STRING.equals( expectedValue ) ) { return; }
1:         
1:         String  actualString;
1:         if ( actualValue instanceof Blob )
1:         {
1:             Blob    blob = (Blob) actualValue;
0:             actualString = squeezeString( blob.getBytes( 1L, (int) blob.length() ) );
1:         }
1:         else if ( actualValue instanceof byte[] )
1:         {
0:             actualString = squeezeString( (byte[]) actualValue );
1:         }
1:         else if ( actualValue instanceof Clob )
1:         {
1:             Clob    clob = (Clob) actualValue;
1:             actualString = clob.getSubString( 1L, (int) clob.length() );
1:         }
1:         else { actualString = actualValue.toString(); }
1:         
0:         assertEquals( candidate.getName(), expectedValue, actualString );
1:     }
0:     private String  squeezeString( byte[] bytes ) throws Exception
1:     {
1:         
0:         String result = new String( bytes, "UTF-8" );
1: 
0:         return result;
1:     }
1:     private void    vetNoWrapper
1:         ( Wrapper41 wrapper, int colID, String colName, Class[] unsupportedCoercions )
1:         throws Exception
1:     {
1:         vetCoercionError( wrapper, colID, colName, unsupportedCoercions, UNSUPPORTED_COERCION );
1:     }
0:     @SuppressWarnings("unchecked")
1:     private void    vetCoercionError
1:         ( Wrapper41 wrapper, int colID, String colName, Class[] unsupportedCoercions, String expectedSQLState )
1:         throws Exception
1:     {
1:         int coercionCount = unsupportedCoercions.length;
1:         for ( int i = 0; i < coercionCount; i++ )
1:         {
0:             Class   candidate = unsupportedCoercions[ i ];
1: 
1:             try {
1:                 wrapper.getObject( colID, candidate );
1:                 fail( "Did not expect to get a " + candidate.getName() );
1:             }
1:             catch (SQLException e)
1:             {
1:                 assertSQLState( candidate.getName(), expectedSQLState, e );
1:             }
1: 
1:             // you can only retrieve a LOB once
1:             if ( (candidate == Blob.class) || (candidate == Clob.class) ) { return; }
1: 
1:             // String overloads not implemented for CallableStatements
1:             if ( wrapper.getWrappedObject() instanceof CallableStatement ) { return; }
1:             
1:             try {
1:                 wrapper.getObject( colName, candidate );
1:                 fail( "Did not expect to get a " + candidate.getName() );
1:             }
1:             catch (SQLException e)
1:             {
1:                 assertSQLState( candidate.getName(), expectedSQLState, e );
1:             }
1:         }
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
1:     protected PreparedStatement    prepareStatement( Connection conn, String text )
1:         throws Exception
1:     {
1:         println( text );
1:         
1:         PreparedStatement   ps = conn.prepareStatement( text );
1: 
1:         return ps;
1:     }
1: 
1:     protected CallableStatement    prepareCall( Connection conn, String text )
1:         throws Exception
1:     {
1:         println( text );
1:         
1:         CallableStatement cs = conn.prepareCall( text );
1: 
1:         return cs;
1:     }
1: 
1: }
============================================================================