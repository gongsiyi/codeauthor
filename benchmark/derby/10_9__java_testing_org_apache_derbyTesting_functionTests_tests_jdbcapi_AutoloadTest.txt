1:9f608bd: /*
1:45cb2df: 
1:9f608bd:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.AutoloadTest
1:f2e3e69: 
1:9f608bd:    Licensed to the Apache Software Foundation (ASF) under one or more
1:9f608bd:    contributor license agreements.  See the NOTICE file distributed with
1:9f608bd:    this work for additional information regarding copyright ownership.
1:9f608bd:    The ASF licenses this file to you under the Apache License, Version 2.0
1:9f608bd:    (the "License"); you may not use this file except in compliance with
1:9f608bd:    the License.  You may obtain a copy of the License at
23:9f608bd: 
1:9f608bd:       http://www.apache.org/licenses/LICENSE-2.0
1:9f608bd: 
1:9f608bd:    Unless required by applicable law or agreed to in writing, software
1:9f608bd:    distributed under the License is distributed on an "AS IS" BASIS,
1:9f608bd:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9f608bd:    See the License for the specific language governing permissions and
1:9f608bd:    limitations under the License.
1:9f608bd: 
2:9f608bd:  */
1:9f608bd: 
1:9f608bd: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:9f608bd: 
1:b5468e9: import java.net.InetAddress;
1:45cb2df: import java.sql.Connection;
1:1ae02c9: import java.sql.Driver;
1:9f608bd: import java.sql.DriverManager;
1:9f608bd: import java.sql.SQLException;
1:57af2a5: import java.sql.Statement;
1:bc39f0e: import java.util.ArrayList;
1:987f4fd: import java.util.Enumeration;
1:bc39f0e: import java.util.List;
1:1ae02c9: import javax.sql.DataSource;
1:47bae99: import junit.extensions.TestSetup;
1:9f608bd: import junit.framework.Test;
1:76da2f3: import org.apache.derby.drda.NetworkServerControl;
1:9f608bd: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:76da2f3: import org.apache.derbyTesting.junit.Derby;
1:9f608bd: import org.apache.derbyTesting.junit.JDBC;
1:45cb2df: import org.apache.derbyTesting.junit.JDBCDataSource;
1:76da2f3: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1:987f4fd: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:47bae99: import org.apache.derbyTesting.junit.SpawnedProcess;
1:9f608bd: import org.apache.derbyTesting.junit.TestConfiguration;
1:57af2a5: 
1:9f608bd: /**
1:9f608bd:  * This JUnit test verifies the autoloading of the jdbc driver.
1:9f608bd:  * A driver may be autoloaded due to JDBC 4 autoloading from
1:9f608bd:  * jar files or the driver's name is listed in the system
1:9f608bd:  * property jdbc.drivers when DriverManager is first loaded.
1:9f608bd:  * 
1:9f608bd:  * This test must be run in its own VM because we want to verify that the
1:9f608bd:  * driver was not accidentally loaded by some other test.
1:9f608bd:  */
1:9f608bd: public class AutoloadTest extends BaseJDBCTestCase
1:47bae99: {
1:8ad67d3:     private Class<?> spawnedTestClass;
1:47bae99: 
1:9f608bd: 	public	AutoloadTest( String name ) { super( name ); }
1:9b362a6: 
1:47bae99:     /**
1:47bae99:      * Create a test case that runs this test in a separate JVM.
1:47bae99:      *
1:47bae99:      * @param wrapper a test class that decorates {@code AutoloadTest} with the
1:47bae99:      * desired configuration
1:47bae99:      */
1:8ad67d3:     private AutoloadTest(Class<?> wrapper) {
1:47bae99:         this("spawnProcess");
1:47bae99:         spawnedTestClass = wrapper;
1:47bae99:     }
1:47bae99: 
1:47bae99:     /**
1:47bae99:      * Get the name of the test case.
1:dff2bf5:      * @return the test name
1:47bae99:      */
1:8ad67d3:     @Override
1:47bae99:     public String getName() {
1:47bae99:         String name = super.getName();
1:47bae99:         if (spawnedTestClass != null) {
1:47bae99:             // Append the name of the class that decorates the test case to
1:47bae99:             // make it easier to see which configuration it runs under.
1:47bae99:             name += ":" + spawnedTestClass.getSimpleName();
1:47bae99:         }
1:47bae99:         return name;
1:47bae99:     }
1:9b362a6:     
1:f2e3e69:     /**
1:9f608bd:      * Only run a test if the driver will be auto-loaded.
1:9f608bd:      * See class desciption for details.
1:8ad67d3:      * @return the test
1:9f608bd:      */
1:9f608bd:     public static Test suite() {
1:7a5b1d0:         if (!JDBC.vmSupportsJDBC3())
1:1ae02c9:             return new BaseTestSuite("empty: no java.sql.DriverManager");
1:9b362a6: 
1:45cb2df: 
1:f2e3e69:         boolean embeddedAutoLoad = false;
1:f2e3e69:         boolean clientAutoLoad = false;
1:987f4fd:         boolean jdbc4Autoload = false;
1:45cb2df:         
1:f2e3e69:         if (JDBC.vmSupportsJDBC4() && TestConfiguration.loadingFromJars())
1:9b362a6:         {
1:987f4fd:             // test client & embedded,but the JDBC 4 auto boot is not
1:987f4fd:             // a full boot of the engine. Thus while there is no
1:987f4fd:             // need to explicitly load the driver, the embedded engine
1:987f4fd:             // does not start up. Unlike when the embedded driver is
1:987f4fd:             // put in jdbc.drivers.
1:90e70fe:             
1:987f4fd:             jdbc4Autoload = true;
1:9b362a6:         }
1:90e70fe: 
1:987f4fd: 
1:987f4fd:         // Simple test to see if the driver class is
1:987f4fd:         // in the value. Could get fancy and see if it is
1:987f4fd:         // correctly formatted but not worth it.
1:987f4fd: 
1:987f4fd:         try {
1:987f4fd:             String jdbcDrivers = getSystemProperty("jdbc.drivers");
1:987f4fd:             if (jdbcDrivers == null)
1:987f4fd:                 jdbcDrivers = "";
1:987f4fd: 
1:987f4fd:             embeddedAutoLoad = jdbcDrivers
1:8ad67d3:                     .contains("org.apache.derby.jdbc.EmbeddedDriver");
1:987f4fd: 
1:987f4fd:             clientAutoLoad = jdbcDrivers
1:8ad67d3:                     .contains("org.apache.derby.jdbc.ClientDriver");
1:987f4fd: 
1:987f4fd:         } catch (SecurityException se) {
1:987f4fd:             // assume there is no autoloading if
1:987f4fd:             // we can't read the value of jdbc.drivers.
1:90e70fe:         }
1:987f4fd: 
1:987f4fd:         
1:987f4fd:         if (jdbc4Autoload || embeddedAutoLoad || clientAutoLoad)
1:f2e3e69:         {
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite("AutoloadTest");
1:987f4fd:             
1:987f4fd:             if (jdbc4Autoload && !embeddedAutoLoad)
1:987f4fd:             {
1:987f4fd:                 suite.addTest(SecurityManagerSetup.noSecurityManager(
1:987f4fd:                         new AutoloadTest("testEmbeddedNotStarted")));
1:987f4fd:             }
1:987f4fd:             
1:987f4fd:             if (jdbc4Autoload || embeddedAutoLoad)
1:f2e3e69:                 suite.addTest(baseAutoLoadSuite("embedded"));
1:987f4fd:             if (jdbc4Autoload || clientAutoLoad)
1:f2e3e69:                 suite.addTest(
1:f2e3e69:                   TestConfiguration.clientServerDecorator(
1:f2e3e69:                           baseAutoLoadSuite("client")));
1:90e70fe:             
1:90e70fe:             if (jdbc4Autoload || embeddedAutoLoad)
1:90e70fe:             {
1:90e70fe:                 // DERBY-2905 related testing.
1:90e70fe:                 // Ensure that after a shutdown no Derby code is
1:90e70fe:                 // left registered in the driver manager
1:90e70fe:                 // and that after a shutdown, an explicit load
1:90e70fe:                 // can restart the engine.
1:57af2a5:                 suite.addTest(new AutoloadTest("testAssertShutdownOK"));
1:90e70fe:                 suite.addTest(new AutoloadTest("testShutdownDeRegister"));
1:90e70fe:                 suite.addTest(new AutoloadTest("testExplicitReload"));
1:90e70fe:             }
1:f2e3e69:                 
1:f2e3e69:             return suite;
1:f2e3e69:         }
1:f2e3e69: 
1:9f608bd:         // Run a single test that ensures that the driver is
1:9f608bd:         // not loaded implicitly by some other means.
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("AutoloadTest: no autoloading expected");
1:f2e3e69:         
1:9663037:         suite.addTest(SecurityManagerSetup.noSecurityManager(new AutoloadTest("testEmbeddedNotStarted")));
1:9f608bd:         suite.addTest(new AutoloadTest("noloadTestNodriverLoaded"));
1:9f608bd:         suite.addTest(TestConfiguration.clientServerDecorator(
1:9f608bd:                 new AutoloadTest("noloadTestNodriverLoaded")));
1:f2e3e69:         
1:9f608bd:         return suite;
1:f2e3e69:     }
1:9f608bd:     
1:47bae99:     /**
1:f2e3e69:      * Return the ordered set of tests when autoloading is enabled.
1:8ad67d3:      *
1:8ad67d3:      * @param which embedded or client
1:8ad67d3:      * @return the constructed test suite
1:f2e3e69:      */
1:f2e3e69:     private static Test baseAutoLoadSuite(String which)
1:f2e3e69:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("AutoloadTest: " + which);
1:f2e3e69:         
1:f2e3e69:         suite.addTest(new AutoloadTest("testRegisteredDriver"));
1:76da2f3:         if ("embedded".equals(which))
1:76da2f3:         {
1:76da2f3:             // Tests to see if the full engine is booted correctly
1:76da2f3:             // when the embedded driver is autoloading
1:76da2f3:             if (Derby.hasServer())
1:76da2f3:                 suite.addTest(new AutoloadTest("testAutoNetworkServerBoot"));
1:987f4fd: 
1:76da2f3:         }
1:987f4fd:         
1:f2e3e69:         suite.addTest(new AutoloadTest("testSuccessfulConnect"));
1:45cb2df:       	
1:987f4fd:         if ("embedded".equals(which)) {
1:987f4fd:             suite.addTest(SecurityManagerSetup.noSecurityManager(
1:987f4fd:                 new AutoloadTest("testEmbeddedStarted")));
1:987f4fd:         }
1:987f4fd: 
1:f2e3e69:         suite.addTest(new AutoloadTest("testUnsuccessfulConnect"));
1:f2e3e69:         suite.addTest(new AutoloadTest("testExplicitLoad"));
1:45cb2df: 
1:45cb2df: 	 if ("embedded".equals(which)) {
1:45cb2df:             suite.addTest(new AutoloadTest("testAutoloadDriverUnregister"));
1:45cb2df:         }
1:f2e3e69:         return suite;
1:f2e3e69:     }
1:76da2f3: 
1:987f4fd:     /**
1:47bae99:      * <p>
1:47bae99:      * Generate the full suite of autoload tests. Each test will be started
1:47bae99:      * in its own JVM so that we know that the driver hasn't been loaded
1:47bae99:      * accidentally by another test.
1:47bae99:      * </p>
1:47bae99:      *
1:47bae99:      * <p>
1:47bae99:      * The test suite runs {@code AutoloadTest} in the following
1:47bae99:      * configurations:
1:47bae99:      * </p>
1:47bae99:      *
1:47bae99:      * <ul>
1:47bae99:      * <li>No jdbc.drivers property</li>
1:47bae99:      * <li>jdbc.drivers property specifying embedded driver</li>
1:47bae99:      * <li>jdbc.drivers property specifying client driver</li>
1:47bae99:      * <li>jdbc.drivers property specifying both drivers</li>
1:47bae99:      * </ul>
1:8ad67d3:      * @return the test constructed
1:47bae99:      */
1:47bae99:     static Test fullAutoloadSuite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("AutoloadTest:All");
1:47bae99:         suite.addTest(new AutoloadTest(AutoloadTest.class));
1:47bae99:         suite.addTest(new AutoloadTest(JDBCDriversEmbeddedTest.class));
1:47bae99:         suite.addTest(new AutoloadTest(JDBCDriversClientTest.class));
1:47bae99:         suite.addTest(new AutoloadTest(JDBCDriversAllTest.class));
1:7d6c180:         suite.addTest(new AutoloadTest(ConcurrentAutoloadTest.class));
1:47bae99: 
1:47bae99:         // The forked test processes will access the default test database, so
1:47bae99:         // stop the engine in the main test process to prevent attempts to
1:47bae99:         // double-boot the database.
1:47bae99:         return new TestSetup(suite) {
1:8ad67d3:             @Override
1:47bae99:             protected void setUp() {
1:47bae99:                 TestConfiguration.getCurrent().shutdownEngine();
1:47bae99:             }
2:47bae99:         };
1:47bae99:     }
1:47bae99: 
1:47bae99:     /**
1:47bae99:      * Run {@code AutoloadTest} in a separate JVM.
1:8ad67d3:      *
1:8ad67d3:      * @throws java.lang.Exception something went wrong
1:47bae99:      */
1:47bae99:     public void spawnProcess() throws Exception {
1:8ad67d3:         final List<String> args = new ArrayList<String>();
1:8ad67d3:         args.add("-Dderby.system.durability=" +
1:8ad67d3:                 getSystemProperty("derby.system.durability"));
1:8ad67d3:         args.add("-Dderby.tests.trace=" +
1:8ad67d3:                 getSystemProperty("derby.tests.trace"));
1:8ad67d3:         args.add("-Dderby.system.debug=" +
1:8ad67d3:                 getSystemProperty("derby.tests.debug"));
1:bc39f0e: 
1:8ad67d3:         if (!TestConfiguration.isDefaultBasePort()) {
1:8ad67d3:             args.add("-Dderby.tests.basePort=" + TestConfiguration.getBasePort());
1:47bae99:         }
1:8ad67d3: 
1:8ad67d3:         args.add("junit.textui.TestRunner");
1:8ad67d3:         args.add(spawnedTestClass.getName());
1:8ad67d3:         final String[] cmd = args.toArray(new String[0]);
1:8ad67d3: 
1:8ad67d3:         final SpawnedProcess proc = new SpawnedProcess
1:8ad67d3:                             (execJavaCmd(cmd), spawnedTestClass.getName());
1:8ad67d3:         // Close stdin of the process so that it stops
1:8ad67d3:         // any waiting for it and exits (shoudln't matter for this test)
1:8ad67d3:         proc.suppressOutputOnComplete(); // we want to read it ourselves
1:8ad67d3: 
1:8ad67d3:         final boolean completed = proc.waitForExit(120000L /* 2m */, 1000L);
1:8ad67d3: 
1:8ad67d3:         final StringBuilder jstackReport = new StringBuilder();
1:8ad67d3:         if (!completed) {
1:8ad67d3:             jstackReport.append("\n\n\n[Subprocess ");
1:8ad67d3:             jstackReport.append(proc.getPid());
1:8ad67d3:             jstackReport.append(" hanging, jstack result:");
1:8ad67d3:             jstackReport.append(proc.jstack());
1:8ad67d3:             jstackReport.append("End of jstack output]\n\n");
1:8ad67d3:         }
1:8ad67d3: 
1:8ad67d3:         final int exitCode = proc.complete(0); // kill right away if not done
1:8ad67d3: 
1:8ad67d3:         final String output = proc.getFullServerOutput();
1:8ad67d3:         final String err    = proc.getFullServerError();
1:8ad67d3: 
1:8ad67d3:         final String headerOut = "\n[ (stdout subprocess) ";
1:8ad67d3:         final String headerErr = headerOut.replace("out", "err");
1:8ad67d3:         final String contLineOut = headerOut.replace('[', ' ');
1:8ad67d3:         final String contLineErr = contLineOut.replace("out", "err");
1:8ad67d3: 
1:8ad67d3:         if (exitCode != 0) {
1:8ad67d3:             final StringBuilder errMsg = new StringBuilder();
1:8ad67d3:             
1:8ad67d3:             errMsg.append("subprocess run failed: exit code==");
1:8ad67d3:             errMsg.append(exitCode);
1:8ad67d3:             errMsg.append("\n");
1:8ad67d3:             errMsg.append(headerOut);
1:8ad67d3:             errMsg.append(output.replaceAll("\n", contLineOut));
1:8ad67d3:             errMsg.append("]\n");
1:8ad67d3:             errMsg.append(headerErr);
1:8ad67d3:             errMsg.append(err.replaceAll("\n", contLineErr));
1:8ad67d3:             errMsg.append("]\n");
1:8ad67d3: 
1:8ad67d3:             errMsg.append(jstackReport);
1:8ad67d3: 
1:8ad67d3:             fail(errMsg.toString());
1:8ad67d3:         }
1:8ad67d3: 
1:8ad67d3: 
1:8ad67d3:         // Print sub process' outputs if this test specifies any such
1:8ad67d3:         if (Boolean.parseBoolean(
1:8ad67d3:                 getSystemProperty("derby.tests.trace")) ||
1:8ad67d3:                 Boolean.parseBoolean(
1:8ad67d3:                         getSystemProperty("derby.tests.debug"))) {
1:8ad67d3: 
1:8ad67d3:             System.out.println(
1:8ad67d3:                     headerOut + output.replace("\n", contLineOut) + "]\n");
1:8ad67d3:             System.out.println(
1:8ad67d3:                     headerErr + err.replace("\n", contLineErr) + "]\n");
1:47bae99:         }
1:b5468e9:     }
1:bc39f0e: 
1:9f608bd: 	// ///////////////////////////////////////////////////////////
1:9f608bd: 	//
1:9f608bd: 	// TEST ENTRY POINTS
1:9f608bd: 	//
1:9f608bd: 	// ///////////////////////////////////////////////////////////
1:bc39f0e: 
1:45cb2df:     /**
1:57af2a5:      * Test DERBY-2905:Shutting down embedded Derby does remove all code,
1:c341df0:      * the AutoloadDriver is deregistered from DriverManager.
1:45cb2df:      * 
1:45cb2df:      * @throws Exception
1:45cb2df:      */
1:45cb2df:     public void testAutoloadDriverUnregister() throws Exception {
1:45cb2df:         if (usingEmbedded()) {
1:62a7082:             String AutoloadedDriver = getAutoloadedDriverName();
1:45cb2df:             String Driver40 = "org.apache.derby.jdbc.Driver40";
1:45cb2df:             String Driver30 = "org.apache.derby.jdbc.Driver30";
1:45cb2df:             String Driver20 = "org.apache.derby.jdbc.Driver20";
1:bc39f0e: 
1:45cb2df:             // Test whether the Autoload driver successfully unregister after
1:45cb2df:             // DB shutdown.
1:45cb2df:             String url = getTestConfiguration().getJDBCUrl();
1:45cb2df:             url = url.concat(";create=true");
1:45cb2df:             String user = getTestConfiguration().getUserName();
1:45cb2df:             String password = getTestConfiguration().getUserPassword();
1:45cb2df:             DriverManager.getConnection(url, user, password);
1:bc39f0e: 
1:45cb2df:             assertTrue(getRegisteredDrivers(AutoloadedDriver));
1:47bae99: 
1:45cb2df:             // shut down engine
1:45cb2df:             TestConfiguration.getCurrent().shutdownEngine();
1:47bae99: 
1:45cb2df:             assertFalse(getRegisteredDrivers(AutoloadedDriver));
1:47bae99: 
1:45cb2df:             // Test explicit loading of Embedded driver after Autoload driver
1:45cb2df:             // is un-registered.
1:45cb2df:             String driverClass = getTestConfiguration().getJDBCClient()
1:45cb2df:                     .getJDBCDriverName();
1:45cb2df: 
1:57af2a5:             //Derby should be able to get a connection if AutoloaderDriver is
1:57af2a5:             //not in DriverManager. Make a connection to test it. Derby-2905
1:4469400:             Class<?> clazz = Class.forName(driverClass);
1:4469400:             clazz.getConstructor().newInstance();
1:45cb2df:             url = getTestConfiguration().getJDBCUrl();
1:45cb2df:             user = getTestConfiguration().getUserName();
1:45cb2df:             password = getTestConfiguration().getUserPassword();
1:45cb2df:             DriverManager.getConnection(url, user, password);
1:57af2a5:             assertTrue(getRegisteredDrivers(AutoloadedDriver));
1:45cb2df: 
1:45cb2df:             // shut down engine
1:45cb2df:             TestConfiguration.getCurrent().shutdownEngine();
1:45cb2df: 
1:57af2a5:             assertFalse(getRegisteredDrivers(AutoloadedDriver));
1:45cb2df:             assertFalse(getRegisteredDrivers(Driver40));
1:45cb2df:             assertFalse(getRegisteredDrivers(Driver30));
1:45cb2df:             assertFalse(getRegisteredDrivers(Driver20));
1:b5468e9:         }
1:b5468e9:     }
1:62a7082:     private String  getAutoloadedDriverName()
1:62a7082:     {
1:595307e:         return "org.apache.derby.jdbc.AutoloadedDriver";
1:62a7082:     }
1:62a7082:     private String  getClientDriverName()
1:62a7082:     {
1:9a0cdf1:         return "org.apache.derby.jdbc.ClientDriver";
1:62a7082:     }
1:45cb2df:     
1:9f608bd:     /**
1:9f608bd:      * @throws SQLException
1:f2e3e69:      * 
1:f2e3e69:      */
1:9f608bd:     public void testRegisteredDriver() throws SQLException
1:b5468e9:     {
1:9f608bd:         String protocol =
1:9f608bd:             getTestConfiguration().getJDBCClient().getUrlBase();
1:45cb2df:                          
1:9f608bd:         Driver driver = DriverManager.getDriver(protocol);
1:9f608bd:         assertNotNull("Expected registered driver", driver);
1:45cb2df:     }
1:45cb2df:     
1:90e70fe:     /**
1:90e70fe:      * Test that after a shutdown that no Derby embedded driver
1:90e70fe:      * is left registered in the DriverManager. See DERBY-2905.
1:90e70fe:      * @throws SQLException failure
1:90e70fe:      */
1:90e70fe:     public void testShutdownDeRegister() throws SQLException
1:90e70fe:     {
1:90e70fe:         assertTrue(isEmbeddedDriverRegistered());
1:90e70fe:         TestConfiguration.getCurrent().shutdownEngine();
1:45cb2df:         
1:45cb2df:         // DERBY-2905 - Autoload driver is [not] left around.
1:45cb2df:         assertFalse(isEmbeddedDriverRegistered());   
1:45cb2df:     }
1:90e70fe:     
1:90e70fe:     /**
1:90e70fe:      * Return true if there appears to be a Derby embedded
1:90e70fe:      * driver registered with the DriverManager.
1:d5376da:      * @return true if there appears to be a Derby embedded driver registered
1:90e70fe:      */
1:90e70fe:     private boolean isEmbeddedDriverRegistered()
1:90e70fe:     {
1:62a7082:         String  clientDriverName = getClientDriverName();
1:62a7082:         
1:8ad67d3:         for (Enumeration<Driver> e = DriverManager.getDrivers();
1:90e70fe:                 e.hasMoreElements(); )
1:90e70fe:         {
1:8ad67d3:             Driver d = e.nextElement();
1:90e70fe:             String driverClass = d.getClass().getName();
1:90e70fe:             if (!driverClass.startsWith("org.apache.derby."))
1:90e70fe:                 continue;
1:62a7082:             if (driverClass.equals( clientDriverName ))
1:90e70fe:                 continue;
1:62a7082: 
1:62a7082:             println( "Found " + driverClass );
1:90e70fe:             
1:90e70fe:             // Some form of Derby embedded driver seems to be registered.
1:90e70fe:             return true;
1:90e70fe:         }
1:90e70fe:         return false;
1:90e70fe:     }
1:76da2f3: 
1:9f608bd: 	/**
1:8ad67d3:      * Test we can connect successfully to a database.
1:8ad67d3:      * @throws SQLException test error
1:8ad67d3:      */
1:9f608bd: 	public void testSuccessfulConnect()
2:9f608bd:        throws SQLException
1:f2e3e69: 	{
1:9f608bd: 		println( "We ARE autoloading..." );
1:9f608bd:        
1:9f608bd:         // Test we can connect successfully to a database!
1:9f608bd:         String url = getTestConfiguration().getJDBCUrl();
1:9f608bd:         url = url.concat(";create=true");
1:9f608bd:         String user = getTestConfiguration().getUserName();
1:9f608bd:         String password = getTestConfiguration().getUserPassword();
1:9f608bd:         DriverManager.getConnection(url, user, password).close();
5:9f608bd: 	}
1:9f608bd:     /**
1:9f608bd:      * Test the error code on an unsuccessful connect
1:9f608bd:      * to ensure it is not one returned by DriverManager.
1:8ad67d3:      * @throws SQLException test error
1:9f608bd:      */
1:8ad67d3:     public void testUnsuccessfulConnect() throws SQLException
1:f2e3e69:     {     
1:9f608bd:         // Test we can connect successfully to a database!
1:9f608bd:         String url = getTestConfiguration().getJDBCUrl("nonexistentDatabase");
1:9f608bd:         String user = getTestConfiguration().getUserName();
1:9f608bd:         String password = getTestConfiguration().getUserPassword();
1:f2e3e69:         try {
1:9f608bd:             DriverManager.getConnection(url, user, password).close();
1:9f608bd:             fail("connected to nonexistentDatabase");
1:9f608bd:         } catch (SQLException e) {
1:9f608bd:             String expectedError = usingEmbedded() ? "XJ004" : "08004";
1:76da2f3:             
1:9f608bd:             assertSQLState(expectedError, e);
1:9f608bd:         }
1:9f608bd:     }
1:9f608bd:     
1:76da2f3:     /**
1:8ad67d3:      * Test an explicit load of the driver works as well
1:90e70fe:      * even though the drivers were loaded automatically.
1:f2e3e69:      * @throws Exception 
1:9f608bd:      *
1:9f608bd:      */
1:f2e3e69:     public void testExplicitLoad() throws Exception
1:f2e3e69:     {
1:90e70fe:         explicitLoad(false);
1:90e70fe:     }
1:90e70fe:     
1:90e70fe:     /**
1:90e70fe:      * Test that an explicit reload of the driver works,
1:90e70fe:      * typically after a shutdown. Note that just loading
1:90e70fe:      * the driver class here cannot reload the driver
1:90e70fe:      * as the driver class is already loaded and thus
1:90e70fe:      * its static initializer will not be re-executed.
1:90e70fe:      * @throws Exception
1:90e70fe:      */
1:90e70fe:     public void testExplicitReload() throws Exception
1:90e70fe:     {
1:90e70fe:         explicitLoad(true);
1:90e70fe:     }
1:90e70fe:     
1:90e70fe:     private void explicitLoad(boolean instanceOnly) throws Exception
1:90e70fe:     {
1:f2e3e69:         String driverClass =
1:f2e3e69:             getTestConfiguration().getJDBCClient().getJDBCDriverName();
1:90e70fe:         
1:f2e3e69:         
1:f2e3e69:         // With and without a new instance
1:90e70fe:         if (!instanceOnly) {
1:90e70fe:             Class.forName(driverClass);
1:90e70fe:             testSuccessfulConnect();
1:90e70fe:             testUnsuccessfulConnect();
1:90e70fe:         }
1:45cb2df: 
1:4469400:         Class<?> clazz = Class.forName(driverClass);
1:4469400:         clazz.getConstructor().newInstance();
2:f2e3e69:         testSuccessfulConnect();
2:f2e3e69:         testUnsuccessfulConnect();
1:f2e3e69:     }
1:f2e3e69:     
1:f2e3e69:     /**
1:9f608bd:      * Simple test when auto-loading is not expected.
1:9f608bd:      * This is to basically test that the junit setup code
1:9f608bd:      * itself does not load the driver, thus defeating the
1:9f608bd:      * real auto-loading testing.
1:9f608bd:      */
1:9f608bd:     public void noloadTestNodriverLoaded() {
3:9f608bd:         try {
1:9f608bd:             testRegisteredDriver();
1:9f608bd:             fail("Derby junit setup code is loading driver!");
1:9f608bd:         } catch (SQLException e) {
1:9f608bd:         }
1:9f608bd:     }
1:f2e3e69: 
1:9f608bd:     /**
1:76da2f3:      * Test that the auto-load of the network server is as expected.
1:76da2f3:      * <P>
1:76da2f3:      * derby.drda.startNetworkServer=false or not set
1:76da2f3:      * <BR>
1:76da2f3:      *     network server should not auto boot.
1:76da2f3:      * <P>
1:76da2f3:      * derby.drda.startNetworkServer=true
1:76da2f3:      * <BR>
1:76da2f3:      * If jdbc.drivers contains the name of the embedded driver
1:76da2f3:      * then the server must be booted.
1:76da2f3:      * <BR>
1:76da2f3:      * Otherwise even if auto-loading the embedded driver due to JDBC 4
1:76da2f3:      * auto-loading the network server must not boot. This is because
1:76da2f3:      * the auto-loaded driver for JDBC 4 is a proxy driver that registers
1:76da2f3:      * a driver but does not boot the complete embedded engine.
1:76da2f3:      * @throws Exception 
1:76da2f3:      * 
1:76da2f3:      *
1:76da2f3:      */
1:76da2f3:     public void testAutoNetworkServerBoot() throws Exception
1:76da2f3:     {
1:76da2f3:         boolean nsAutoBoot = "true".equalsIgnoreCase(
1:76da2f3:                 getSystemProperty("derby.drda.startNetworkServer"));
1:76da2f3:         
1:76da2f3:         boolean serverShouldBeUp =
1:76da2f3:             nsAutoBoot && fullEngineAutoBoot();
1:76da2f3:         
1:204c040:         String user = getTestConfiguration().getUserName();
1:204c040:         String pw = getTestConfiguration().getUserPassword();
1:b5468e9:         int port = TestConfiguration.getBasePort();
1:b5468e9:         final InetAddress host = InetAddress.getByName(TestConfiguration.getCurrent().getHostName());
1:b5468e9:         NetworkServerControl control = new NetworkServerControl(host, port, user, pw);
1:6a53c94: 
1:6a53c94:         if (!serverShouldBeUp) {
1:6a53c94:             // If we expect the server not to come up, wait a little before
1:6a53c94:             // checking if the server is up. If the server is (unexpectedly)
1:6a53c94:             // coming up and we ping before it has come up, we will conclude
1:6a53c94:             // (incorrectly) that it did not come up.
1:6a53c94:             Thread.sleep(5000L);
1:6a53c94:         }
1:6a53c94: 
1:6a53c94:         boolean isServerUp = NetworkServerTestSetup.pingForServerUp(
1:6a53c94:                 control, null, serverShouldBeUp);
1:76da2f3:         
1:76da2f3:         assertEquals("Network Server state incorrect",
1:76da2f3:                 serverShouldBeUp, isServerUp);
1:76da2f3:         
1:76da2f3:         if (isServerUp)
1:76da2f3:             control.shutdown();
1:76da2f3:     }
1:76da2f3:     
1:76da2f3:     /**
1:8ad67d3:      * @return {@code true} if a full auto-boot of the engine is expected
1:76da2f3:      * due to jdbc.drivers containing the name of the embedded driver.
1:76da2f3:      */
1:76da2f3:     private boolean fullEngineAutoBoot()
1:76da2f3:     {
1:76da2f3:         String jdbcDrivers = getSystemProperty("jdbc.drivers");
1:8ad67d3:         return jdbcDrivers.contains("org.apache.derby.jdbc.EmbeddedDriver");
1:76da2f3:     }
1:76da2f3:     
1:9f608bd:     /**
1:8ad67d3:      * Test indirect artifacts through public apis that
1:987f4fd:      * the embedded engine has not been started.
1:987f4fd:      */
1:987f4fd:     
1:987f4fd:     public void testEmbeddedNotStarted()
1:987f4fd:     {
1:987f4fd:         assertFalse(hasDerbyThreadGroup());
1:987f4fd:     }
1:987f4fd:     
1:987f4fd:     /**
1:987f4fd:      * Check the test(s) we use to determine if the embedded driver
1:987f4fd:      * is not up indicate the opposite once the driver has been
1:987f4fd:      * fully booted.
1:987f4fd:      *
1:987f4fd:      */
1:987f4fd:     public void testEmbeddedStarted()
1:987f4fd:     {
1:987f4fd:         assertTrue(hasDerbyThreadGroup());
1:987f4fd:     }
1:45cb2df: 
1:45cb2df:     private boolean getRegisteredDrivers(String driver) {
1:45cb2df: 
1:8ad67d3:     Enumeration<Driver> e = DriverManager.getDrivers();
1:45cb2df: 
1:45cb2df:         while(e.hasMoreElements())
1:45cb2df:         {
1:8ad67d3:                 Driver drv = e.nextElement();
1:45cb2df:                 if(drv.getClass().getName().equals(driver))	
1:45cb2df: 			return true;
1:45cb2df:         }
1:45cb2df: 
1:45cb2df: 	return false;
1:45cb2df:     }
1:45cb2df: 
1:57af2a5:     public void testAssertShutdownOK() throws SQLException {
1:57af2a5:         String AutoloadedDriver = getAutoloadedDriverName();
1:45cb2df:         Connection conn = getConnection();
1:45cb2df: 
1:45cb2df:         if (usingEmbedded()) {
1:45cb2df:             DataSource ds = JDBCDataSource.getDataSource();
1:45cb2df:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:45cb2df:             try {
1:45cb2df:                 ds.getConnection();
1:45cb2df:                 fail("expected shutdown to fail");
1:45cb2df:             } catch (SQLException e) {
1:45cb2df:                 // expect 08006 on successful shutdown
1:45cb2df:                 assertSQLState("08006", e);
1:45cb2df:             }
1:45cb2df:             assertTrue(conn.isClosed());
1:45cb2df:         } else if (usingDerbyNetClient()) {
1:45cb2df:             DataSource ds = JDBCDataSource.getDataSource();
1:57af2a5:             //Case 1: Test the deregister attribute error
1:57af2a5:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:57af2a5:                     "shutdown=true;deregiste=false");
1:45cb2df:             try {
1:45cb2df:                 ds.getConnection();
1:45cb2df:                 fail("expected shutdown to fail");
1:45cb2df:             } catch (SQLException e) {
1:45cb2df:                 // expect 08006 on successful shutdown
1:45cb2df:                 assertSQLState("08006", e);
1:45cb2df:             }
1:57af2a5:             //Case 2: Test with deregister=false, AutoloadedDriver should
1:57af2a5:             //still be in DriverManager
1:57af2a5:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:c341df0:                     "shutdown=true;deregister=false");
1:57af2a5:             try {
1:57af2a5:                 ds.getConnection();
1:57af2a5:                 fail("expected shutdown to fail");
1:57af2a5:             } catch (SQLException e) {
1:57af2a5:                 // expect 08006 on successful shutdown
1:57af2a5:                 assertSQLState("08006", e);
1:57af2a5:             }
1:57af2a5:             //DERBY-2905 deregister=false should keep AutoloadedDriver in
1:57af2a5:             //DriverManager
1:57af2a5:             assertTrue(getRegisteredDrivers(AutoloadedDriver));
1:57af2a5:             //Test getting a connection just right after the shutdown.
1:57af2a5:             String url = getTestConfiguration().getJDBCUrl();
1:57af2a5:             conn = DriverManager.getConnection(url);
1:57af2a5:             Statement stmt = conn.createStatement();
1:57af2a5:             stmt.executeUpdate("values 1");
1:57af2a5:             JDBCDataSource.setBeanProperty(ds, "connectonAttributes",
1:57af2a5:                     "shutdown=true;deregister=true");
1:57af2a5:             try {
1:57af2a5:                 ds.getConnection();
1:57af2a5:                 fail("expected shutdown to fail");
1:57af2a5:             } catch (SQLException e) {
1:57af2a5:                 // expect 08006 on successful shutdown
1:57af2a5:                 assertSQLState("08006", e);
1:57af2a5:             }
1:57af2a5:             //DERBY-2905 deregister=true should deregister AutoloadedDriver in
1:57af2a5:             //DriverManager
1:57af2a5:             assertFalse(getRegisteredDrivers(AutoloadedDriver));
1:45cb2df:         }
1:45cb2df:     }
1:45cb2df: 
1:987f4fd:     /**
1:987f4fd:      * Return true if a ThreadGroup exists that has a name
1:9663037:      * starting with 'derby.'. This needs to run without a security
1:9663037:      * manager as it requires permissions to see all active
1:9663037:      * thread groups. Since this not testing Derby functionality
1:9663037:      * there's harm to not having a security manager, since
1:9663037:      * no code is executed against Derby.
1:8ad67d3:      * @return see above
1:987f4fd:      */
1:987f4fd:     private boolean hasDerbyThreadGroup() {
1:987f4fd:         ThreadGroup tg = Thread.currentThread().getThreadGroup();
1:987f4fd:         
1:987f4fd:         while (tg.getParent() != null)
1:987f4fd:         {
1:987f4fd:             tg = tg.getParent();
1:987f4fd:         }
1:987f4fd:         
1:987f4fd:         // estimate of groups        
1:987f4fd:         ThreadGroup[] allGroups = new ThreadGroup[tg.activeGroupCount()];
1:987f4fd:         int actual;
1:987f4fd:         for (;;)
1:987f4fd:         {
1:987f4fd:             actual = tg.enumerate(allGroups, true);
1:987f4fd:             if (actual < allGroups.length)
1:987f4fd:                 break;
1:987f4fd:             // just double the size
1:987f4fd:             allGroups = new ThreadGroup[allGroups.length * 2];
1:987f4fd:         }
1:987f4fd: 
1:987f4fd:         for (int i = 0; i < actual; i++)
1:987f4fd:         {
1:987f4fd:             if (allGroups[i].getName().startsWith("derby."))
1:987f4fd:                 return true;
1:987f4fd:         }
1:987f4fd:         return false;
1:987f4fd:     }
1:9f608bd: }
1:9f608bd: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName(driverClass);
1:             clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName(driverClass);
1:         clazz.getConstructor().newInstance();
commit:dff2bf5
/////////////////////////////////////////////////////////////////////////
1:      * @return the test name
commit:62a7082
/////////////////////////////////////////////////////////////////////////
1:             String AutoloadedDriver = getAutoloadedDriverName();
/////////////////////////////////////////////////////////////////////////
1:     private String  getAutoloadedDriverName()
1:     {
0:         if ( JDBC.vmSupportsJDBC4() ) { return "org.apache.derby.jdbc.AutoloadedDriver40"; }
0:         else { return "org.apache.derby.jdbc.AutoloadedDriver"; }
1:     }
1:     private String  getClientDriverName()
1:     {
0:         if ( JDBC.vmSupportsJDBC4() ) { return "org.apache.derby.jdbc.ClientDriver40"; }
0:         else { return "org.apache.derby.jdbc.ClientDriver"; }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         String  clientDriverName = getClientDriverName();
1:         
/////////////////////////////////////////////////////////////////////////
1:             if (driverClass.equals( clientDriverName ))
1: 
1:             println( "Found " + driverClass );
commit:77b824b
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:8ad67d3
/////////////////////////////////////////////////////////////////////////
1:     private Class<?> spawnedTestClass;
/////////////////////////////////////////////////////////////////////////
1:     private AutoloadTest(Class<?> wrapper) {
0:      * @return
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      * @return the test
/////////////////////////////////////////////////////////////////////////
1:                     .contains("org.apache.derby.jdbc.EmbeddedDriver");
1:                     .contains("org.apache.derby.jdbc.ClientDriver");
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param which embedded or client
1:      * @return the constructed test suite
/////////////////////////////////////////////////////////////////////////
1:      * @return the test constructed
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.lang.Exception something went wrong
1:         final List<String> args = new ArrayList<String>();
1:         args.add("-Dderby.system.durability=" +
1:                 getSystemProperty("derby.system.durability"));
1:         args.add("-Dderby.tests.trace=" +
1:                 getSystemProperty("derby.tests.trace"));
1:         args.add("-Dderby.system.debug=" +
1:                 getSystemProperty("derby.tests.debug"));
1:         if (!TestConfiguration.isDefaultBasePort()) {
1:             args.add("-Dderby.tests.basePort=" + TestConfiguration.getBasePort());
1: 
1:         args.add("junit.textui.TestRunner");
1:         args.add(spawnedTestClass.getName());
1:         final String[] cmd = args.toArray(new String[0]);
1: 
1:         final SpawnedProcess proc = new SpawnedProcess
1:                             (execJavaCmd(cmd), spawnedTestClass.getName());
1:         // Close stdin of the process so that it stops
1:         // any waiting for it and exits (shoudln't matter for this test)
1:         proc.suppressOutputOnComplete(); // we want to read it ourselves
1: 
1:         final boolean completed = proc.waitForExit(120000L /* 2m */, 1000L);
1: 
1:         final StringBuilder jstackReport = new StringBuilder();
1:         if (!completed) {
1:             jstackReport.append("\n\n\n[Subprocess ");
1:             jstackReport.append(proc.getPid());
1:             jstackReport.append(" hanging, jstack result:");
1:             jstackReport.append(proc.jstack());
1:             jstackReport.append("End of jstack output]\n\n");
1:         }
1: 
1:         final int exitCode = proc.complete(0); // kill right away if not done
1: 
1:         final String output = proc.getFullServerOutput();
1:         final String err    = proc.getFullServerError();
1: 
1:         final String headerOut = "\n[ (stdout subprocess) ";
1:         final String headerErr = headerOut.replace("out", "err");
1:         final String contLineOut = headerOut.replace('[', ' ');
1:         final String contLineErr = contLineOut.replace("out", "err");
1: 
1:         if (exitCode != 0) {
1:             final StringBuilder errMsg = new StringBuilder();
1:             
1:             errMsg.append("subprocess run failed: exit code==");
1:             errMsg.append(exitCode);
1:             errMsg.append("\n");
1:             errMsg.append(headerOut);
1:             errMsg.append(output.replaceAll("\n", contLineOut));
1:             errMsg.append("]\n");
1:             errMsg.append(headerErr);
1:             errMsg.append(err.replaceAll("\n", contLineErr));
1:             errMsg.append("]\n");
1: 
1:             errMsg.append(jstackReport);
1: 
1:             fail(errMsg.toString());
1:         }
1: 
1: 
1:         // Print sub process' outputs if this test specifies any such
1:         if (Boolean.parseBoolean(
1:                 getSystemProperty("derby.tests.trace")) ||
1:                 Boolean.parseBoolean(
1:                         getSystemProperty("derby.tests.debug"))) {
1: 
1:             System.out.println(
1:                     headerOut + output.replace("\n", contLineOut) + "]\n");
1:             System.out.println(
1:                     headerErr + err.replace("\n", contLineErr) + "]\n");
/////////////////////////////////////////////////////////////////////////
1:         for (Enumeration<Driver> e = DriverManager.getDrivers();
1:             Driver d = e.nextElement();
/////////////////////////////////////////////////////////////////////////
1:      * Test we can connect successfully to a database.
1:      * @throws SQLException test error
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException test error
1:     public void testUnsuccessfulConnect() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * Test an explicit load of the driver works as well
/////////////////////////////////////////////////////////////////////////
1:      * @return {@code true} if a full auto-boot of the engine is expected
1:         return jdbcDrivers.contains("org.apache.derby.jdbc.EmbeddedDriver");
1:      * Test indirect artifacts through public apis that
/////////////////////////////////////////////////////////////////////////
1:     Enumeration<Driver> e = DriverManager.getDrivers();
1:                 Driver drv = e.nextElement();
/////////////////////////////////////////////////////////////////////////
1:      * @return see above
commit:bc39f0e
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:             final List<String> args = new ArrayList<String>();
0:             args.add("-Dderby.system.durability=" +
0:                      getSystemProperty("derby.system.durability"));
0:             args.add("-Dderby.tests.trace=" +
0:                      getSystemProperty("derby.tests.trace"));
0:             args.add("-Dderby.system.debug=" +
0:                      getSystemProperty("derby.tests.debug"));
0:             args.add("junit.textui.TestRunner");
0:             args.add(spawnedTestClass.getName());
0:             final String[] cmd = args.toArray(new String[0]);
1:             
0:             proc.suppressOutputOnComplete(); // we want to read it ourselves
0:             final int exitCode = proc.complete(180000L); // 3 minutes
1: 
0:             assertTrue(proc.getFailMessage("subprocess run failed: "),
0:                     exitCode == 0);
1:             
0:             final String output = proc.getFullServerOutput(); // ignore
0:             final String err    = proc.getFullServerError();
1: 
0:             // Print sub process' outputs if this test specifies any such
0:             if (Boolean.parseBoolean(
0:                         getSystemProperty("derby.tests.trace")) ||
0:                 Boolean.parseBoolean(
0:                     getSystemProperty("derby.tests.debug"))) {
1: 
0:                 System.out.println("\n[ (stdout subprocess) " +
0:                         output.replace("\n", "\n  (stdout subprocess) ") + "]\n");
0:                 System.out.println("\n[ (stderr subprocess) " +
0:                         err.replace("\n", "\n  (stderr subprocess) ") + "]\n");
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Driver;
1: import javax.sql.DataSource;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             return new BaseTestSuite("empty: no java.sql.DriverManager");
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite suite = new BaseTestSuite("AutoloadTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("AutoloadTest: no autoloading expected");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("AutoloadTest: " + which);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("AutoloadTest:All");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:595307e
/////////////////////////////////////////////////////////////////////////
1:         return "org.apache.derby.jdbc.AutoloadedDriver";
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1:         return "org.apache.derby.jdbc.ClientDriver";
commit:7d6c180
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(new AutoloadTest(ConcurrentAutoloadTest.class));
commit:47bae99
/////////////////////////////////////////////////////////////////////////
1: import junit.extensions.TestSetup;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SpawnedProcess;
/////////////////////////////////////////////////////////////////////////
1: {
0:     private Class spawnedTestClass;
1: 
1:     /**
1:      * Create a test case that runs this test in a separate JVM.
1:      *
1:      * @param wrapper a test class that decorates {@code AutoloadTest} with the
1:      * desired configuration
1:      */
0:     private AutoloadTest(Class wrapper) {
1:         this("spawnProcess");
1:         spawnedTestClass = wrapper;
1:     }
1: 
1:     /**
1:      * Get the name of the test case.
1:      */
1:     public String getName() {
1:         String name = super.getName();
1:         if (spawnedTestClass != null) {
1:             // Append the name of the class that decorates the test case to
1:             // make it easier to see which configuration it runs under.
1:             name += ":" + spawnedTestClass.getSimpleName();
1:         }
1:         return name;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Generate the full suite of autoload tests. Each test will be started
1:      * in its own JVM so that we know that the driver hasn't been loaded
1:      * accidentally by another test.
1:      * </p>
1:      *
1:      * <p>
1:      * The test suite runs {@code AutoloadTest} in the following
1:      * configurations:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>No jdbc.drivers property</li>
1:      * <li>jdbc.drivers property specifying embedded driver</li>
1:      * <li>jdbc.drivers property specifying client driver</li>
1:      * <li>jdbc.drivers property specifying both drivers</li>
1:      * </ul>
1:      */
1:     static Test fullAutoloadSuite() {
0:         TestSuite suite = new TestSuite("AutoloadTest:All");
1:         suite.addTest(new AutoloadTest(AutoloadTest.class));
1:         suite.addTest(new AutoloadTest(JDBCDriversEmbeddedTest.class));
1:         suite.addTest(new AutoloadTest(JDBCDriversClientTest.class));
1:         suite.addTest(new AutoloadTest(JDBCDriversAllTest.class));
1: 
1:         // The forked test processes will access the default test database, so
1:         // stop the engine in the main test process to prevent attempts to
1:         // double-boot the database.
1:         return new TestSetup(suite) {
1:             protected void setUp() {
1:                 TestConfiguration.getCurrent().shutdownEngine();
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * Run {@code AutoloadTest} in a separate JVM.
1:      */
1:     public void spawnProcess() throws Exception {
0:         String[] cmd = {
0:             "junit.textui.TestRunner", spawnedTestClass.getName()
1:         };
1: 
0:         SpawnedProcess proc =
0:             new SpawnedProcess(execJavaCmd(cmd), spawnedTestClass.getName());
1: 
0:         if (proc.complete() != 0) {
0:             fail(proc.getFailMessage("Test process failed"));
1:         }
1:     }
1: 
commit:6a53c94
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (!serverShouldBeUp) {
1:             // If we expect the server not to come up, wait a little before
1:             // checking if the server is up. If the server is (unexpectedly)
1:             // coming up and we ping before it has come up, we will conclude
1:             // (incorrectly) that it did not come up.
1:             Thread.sleep(5000L);
1:         }
1: 
1:         boolean isServerUp = NetworkServerTestSetup.pingForServerUp(
1:                 control, null, serverShouldBeUp);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:b5468e9
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (TestConfiguration.isDefaultBasePort()) {
0:             String[] cmd = {
0:                     "junit.textui.TestRunner", spawnedTestClass.getName()
0:                            };
0:             SpawnedProcess proc = new SpawnedProcess
0:                     (execJavaCmd(cmd), spawnedTestClass.getName());
0:             if (proc.complete() != 0) {
0:                 fail(proc.getFailMessage("Test process failed"));
1:             }
1:         }
0:         else 
1:         {
0:             // if we're not using the default port of 1527, ensure we're
0:             // passing on the baseport value to the spawned process.
0:             String[] cmd = {
0:                     "-Dderby.tests.basePort=" + TestConfiguration.getBasePort(),
0:                     "junit.textui.TestRunner", spawnedTestClass.getName()
0:             };            
0:             SpawnedProcess proc = new SpawnedProcess
0:                     (execJavaCmd(cmd), spawnedTestClass.getName());
0:             if (proc.complete() != 0) {
0:                 fail(proc.getFailMessage("Test process failed"));
1:             }
/////////////////////////////////////////////////////////////////////////
1:         int port = TestConfiguration.getBasePort();
1:         final InetAddress host = InetAddress.getByName(TestConfiguration.getCurrent().getHostName());
1:         NetworkServerControl control = new NetworkServerControl(host, port, user, pw);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:9b362a6
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (!TestConfiguration.getCurrent().isDefaultBasePort())
1:         {
0:             // DERBY-6178
0:             //     test is not currently coded to work properly when calling
0:             //     system is depending on setting -Dderby.tests.basePort=3500
0:             //     to avoid conflict on concurrent tests starting and stopping
0:             //     network server.
1: 
0:             // for now just skip this test if tests are setting a non-default
0:             // base port.
0:             return new TestSuite(
0:                     "empty: test not supported with non-default base port: " + 
0:                     TestConfiguration.getCurrent().getBasePort());
1:         }
1: 
author:Lily Wei
-------------------------------------------------------------------------------
commit:c341df0
/////////////////////////////////////////////////////////////////////////
1:      * the AutoloadDriver is deregistered from DriverManager.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     "shutdown=true;deregister=false");
commit:57af2a5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 suite.addTest(new AutoloadTest("testAssertShutdownOK"));
/////////////////////////////////////////////////////////////////////////
1:      * Test DERBY-2905:Shutting down embedded Derby does remove all code,
0:      * the AutoloadDriver is dergistered from DriverManager.
/////////////////////////////////////////////////////////////////////////
1:             //Derby should be able to get a connection if AutoloaderDriver is
1:             //not in DriverManager. Make a connection to test it. Derby-2905
0:             //newInstance is gettin AutoloadedDriver
0:             AutoloadedDriver = "org.apache.derby.jdbc.AutoloadedDriver";
1:             assertTrue(getRegisteredDrivers(AutoloadedDriver));
1:             assertFalse(getRegisteredDrivers(AutoloadedDriver));
/////////////////////////////////////////////////////////////////////////
1:     public void testAssertShutdownOK() throws SQLException {
1:         String AutoloadedDriver = getAutoloadedDriverName();
/////////////////////////////////////////////////////////////////////////
1:             //Case 1: Test the deregister attribute error
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                     "shutdown=true;deregiste=false");
/////////////////////////////////////////////////////////////////////////
1:             //Case 2: Test with deregister=false, AutoloadedDriver should
1:             //still be in DriverManager
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
0:                     "shutdown=tru e;deregister=false");
1:             try {
1:                 ds.getConnection();
1:                 fail("expected shutdown to fail");
1:             } catch (SQLException e) {
1:                 // expect 08006 on successful shutdown
1:                 assertSQLState("08006", e);
1:             }
1:             //DERBY-2905 deregister=false should keep AutoloadedDriver in
1:             //DriverManager
1:             assertTrue(getRegisteredDrivers(AutoloadedDriver));
1:             //Test getting a connection just right after the shutdown.
1:             String url = getTestConfiguration().getJDBCUrl();
1:             conn = DriverManager.getConnection(url);
1:             Statement stmt = conn.createStatement();
1:             stmt.executeUpdate("values 1");
1:             JDBCDataSource.setBeanProperty(ds, "connectonAttributes",
1:                     "shutdown=true;deregister=true");
1:             try {
1:                 ds.getConnection();
1:                 fail("expected shutdown to fail");
1:             } catch (SQLException e) {
1:                 // expect 08006 on successful shutdown
1:                 assertSQLState("08006", e);
1:             }
1:             //DERBY-2905 deregister=true should deregister AutoloadedDriver in
1:             //DriverManager
1:             assertFalse(getRegisteredDrivers(AutoloadedDriver));
commit:45cb2df
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
0: import javax.sql.DataSource;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1:       	
/////////////////////////////////////////////////////////////////////////
1: 
1: 	 if ("embedded".equals(which)) {
1:             suite.addTest(new AutoloadTest("testAutoloadDriverUnregister"));
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Test DERBY-2905:Shutting down embedded Derby does not remove all code,
0:      * the AutoloadDriver is left registered in the DriverManager.
1:      * 
1:      * @throws Exception
1:      */
1:     public void testAutoloadDriverUnregister() throws Exception {
1:         if (usingEmbedded()) {
0:             String AutoloadedDriver = "org.apache.derby.jdbc.AutoloadedDriver";
1:             String Driver40 = "org.apache.derby.jdbc.Driver40";
1:             String Driver30 = "org.apache.derby.jdbc.Driver30";
1:             String Driver20 = "org.apache.derby.jdbc.Driver20";
1: 
1:             // Test whether the Autoload driver successfully unregister after
1:             // DB shutdown.
1:             String url = getTestConfiguration().getJDBCUrl();
1:             url = url.concat(";create=true");
1:             String user = getTestConfiguration().getUserName();
1:             String password = getTestConfiguration().getUserPassword();
1:             DriverManager.getConnection(url, user, password);
1: 
1:             assertTrue(getRegisteredDrivers(AutoloadedDriver));
1: 
1:             // shut down engine
1:             TestConfiguration.getCurrent().shutdownEngine();
1: 
1:             assertFalse(getRegisteredDrivers(AutoloadedDriver));
1: 
1:             // Test explicit loading of Embedded driver after Autoload driver
1:             // is un-registered.
1:             String driverClass = getTestConfiguration().getJDBCClient()
1:                     .getJDBCDriverName();
1: 
0:             Class.forName(driverClass).newInstance();
1:             url = getTestConfiguration().getJDBCUrl();
1:             user = getTestConfiguration().getUserName();
1:             password = getTestConfiguration().getUserPassword();
1:             DriverManager.getConnection(url, user, password);
1: 
1:             // shut down engine
1:             TestConfiguration.getCurrent().shutdownEngine();
1: 
1:             assertFalse(getRegisteredDrivers(Driver40));
1:             assertFalse(getRegisteredDrivers(Driver30));
1:             assertFalse(getRegisteredDrivers(Driver20));
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-2905 - Autoload driver is [not] left around.
1:         assertFalse(isEmbeddedDriverRegistered());   
/////////////////////////////////////////////////////////////////////////
0:      	 * Test we can connect successfully to a database.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     private boolean getRegisteredDrivers(String driver) {
1: 
0: 	Enumeration e = DriverManager.getDrivers();
1: 
1:         while(e.hasMoreElements())
1:         {
0:                 Driver drv = (Driver)e.nextElement();
1:                 if(drv.getClass().getName().equals(driver))	
1: 			return true;
1:         }
1: 
1: 	return false;
1:     }
1: 
0:     private void assertShutdownOK() throws SQLException {
1: 
1:         Connection conn = getConnection();
1: 
1:         if (usingEmbedded()) {
1:             DataSource ds = JDBCDataSource.getDataSource();
1:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             try {
1:                 ds.getConnection();
1:                 fail("expected shutdown to fail");
1:             } catch (SQLException e) {
1:                 // expect 08006 on successful shutdown
1:                 assertSQLState("08006", e);
1:             }
1:             assertTrue(conn.isClosed());
1:         } else if (usingDerbyNetClient()) {
1:             DataSource ds = JDBCDataSource.getDataSource();
0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes","shutdown=true");
1:             try {
1:                 ds.getConnection();
1:                 fail("expected shutdown to fail");
1:             } catch (SQLException e) {
1:                 // expect 08006 on successful shutdown
1:                 assertSQLState("08006", e);
1:             }
1:         }
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7a5b1d0
/////////////////////////////////////////////////////////////////////////
1:         if (!JDBC.vmSupportsJDBC3())
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:204c040
/////////////////////////////////////////////////////////////////////////
1:         String user = getTestConfiguration().getUserName();
1:         String pw = getTestConfiguration().getUserPassword();
0:         NetworkServerControl control = new NetworkServerControl(user, pw);
commit:90e70fe
/////////////////////////////////////////////////////////////////////////
1:             
1:             if (jdbc4Autoload || embeddedAutoLoad)
1:             {
1:                 // DERBY-2905 related testing.
1:                 // Ensure that after a shutdown no Derby code is
1:                 // left registered in the driver manager
1:                 // and that after a shutdown, an explicit load
1:                 // can restart the engine.
1:                 suite.addTest(new AutoloadTest("testShutdownDeRegister"));
1:                 suite.addTest(new AutoloadTest("testExplicitReload"));
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test that after a shutdown that no Derby embedded driver
1:      * is left registered in the DriverManager. See DERBY-2905.
1:      * @throws SQLException failure
1:      */
1:     public void testShutdownDeRegister() throws SQLException
1:     {
1:         assertTrue(isEmbeddedDriverRegistered());
1:         TestConfiguration.getCurrent().shutdownEngine();
1:         
0:         // DERBY-2905 - Autoload driver is left around.
0:         // assertFalse(isEmbeddedDriverRegistered());   
1:     }
1:     
1:     /**
1:      * Return true if there appears to be a Derby embedded
1:      * driver registered with the DriverManager.
0:      * @return
1:      */
1:     private boolean isEmbeddedDriverRegistered()
1:     {
0:         for (Enumeration e = DriverManager.getDrivers();
1:                 e.hasMoreElements(); )
1:         {
0:             Driver d = (Driver) e.nextElement();
1:             String driverClass = d.getClass().getName();
1:             if (!driverClass.startsWith("org.apache.derby."))
1:                 continue;
0:             if (driverClass.equals("org.apache.derby.jdbc.ClientDriver"))
1:                 continue;
1:             
1:             // Some form of Derby embedded driver seems to be registered.
1:             return true;
1:         }
1:         return false;
1:     }
/////////////////////////////////////////////////////////////////////////
0:      * Test an explict load of the driver works as well
1:      * even though the drivers were loaded automatically.
1:         explicitLoad(false);
1:     }
1:     
1:     /**
1:      * Test that an explicit reload of the driver works,
1:      * typically after a shutdown. Note that just loading
1:      * the driver class here cannot reload the driver
1:      * as the driver class is already loaded and thus
1:      * its static initializer will not be re-executed.
1:      * @throws Exception
1:      */
1:     public void testExplicitReload() throws Exception
1:     {
1:         explicitLoad(true);
1:     }
1:     
1:     private void explicitLoad(boolean instanceOnly) throws Exception
1:     {
1:         
1:         if (!instanceOnly) {
1:             Class.forName(driverClass);
1:             testSuccessfulConnect();
1:             testUnsuccessfulConnect();
1:         }
commit:9663037
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(SecurityManagerSetup.noSecurityManager(new AutoloadTest("testEmbeddedNotStarted")));
/////////////////////////////////////////////////////////////////////////
1:      * starting with 'derby.'. This needs to run without a security
1:      * manager as it requires permissions to see all active
1:      * thread groups. Since this not testing Derby functionality
1:      * there's harm to not having a security manager, since
1:      * no code is executed against Derby.
commit:987f4fd
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
/////////////////////////////////////////////////////////////////////////
1:         boolean jdbc4Autoload = false;
1:             // test client & embedded,but the JDBC 4 auto boot is not
1:             // a full boot of the engine. Thus while there is no
1:             // need to explicitly load the driver, the embedded engine
1:             // does not start up. Unlike when the embedded driver is
1:             // put in jdbc.drivers.
1:             
1:             jdbc4Autoload = true;
1:         // Simple test to see if the driver class is
1:         // in the value. Could get fancy and see if it is
1:         // correctly formatted but not worth it.
1:         try {
1:             String jdbcDrivers = getSystemProperty("jdbc.drivers");
1:             if (jdbcDrivers == null)
1:                 jdbcDrivers = "";
1:             embeddedAutoLoad = jdbcDrivers
0:                     .indexOf("org.apache.derby.jdbc.EmbeddedDriver") != -1;
1: 
1:             clientAutoLoad = jdbcDrivers
0:                     .indexOf("org.apache.derby.jdbc.ClientDriver") != -1;
1: 
1:         } catch (SecurityException se) {
1:             // assume there is no autoloading if
1:             // we can't read the value of jdbc.drivers.
1: 
1:         if (jdbc4Autoload || embeddedAutoLoad || clientAutoLoad)
1:             
1:             if (jdbc4Autoload && !embeddedAutoLoad)
1:             {
1:                 suite.addTest(SecurityManagerSetup.noSecurityManager(
1:                         new AutoloadTest("testEmbeddedNotStarted")));
1:             }
1:             
1:             if (jdbc4Autoload || embeddedAutoLoad)
1:             if (jdbc4Autoload || clientAutoLoad)
/////////////////////////////////////////////////////////////////////////
0:         suite.addTest(new AutoloadTest("testEmbeddedNotStarted"));
/////////////////////////////////////////////////////////////////////////
1:         
1:         
1:         if ("embedded".equals(which)) {
1:             suite.addTest(SecurityManagerSetup.noSecurityManager(
1:                 new AutoloadTest("testEmbeddedStarted")));
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                          
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Test indirect artifiacts through public apis that
1:      * the embedded engine has not been started.
1:      */
1:     
1:     public void testEmbeddedNotStarted()
1:     {
1:         assertFalse(hasDerbyThreadGroup());
1:     }
1:     
1:     /**
1:      * Check the test(s) we use to determine if the embedded driver
1:      * is not up indicate the opposite once the driver has been
1:      * fully booted.
1:      *
1:      */
1:     public void testEmbeddedStarted()
1:     {
1:         assertTrue(hasDerbyThreadGroup());
1:     }
1:     
1:     /**
1:      * Return true if a ThreadGroup exists that has a name
0:      * starting with derby.
0:      * @return
1:      */
1:     private boolean hasDerbyThreadGroup() {
1:         ThreadGroup tg = Thread.currentThread().getThreadGroup();
1:         
1:         while (tg.getParent() != null)
1:         {
1:             tg = tg.getParent();
1:         }
1:         
1:         // estimate of groups        
1:         ThreadGroup[] allGroups = new ThreadGroup[tg.activeGroupCount()];
1:         int actual;
1:         for (;;)
1:         {
1:             actual = tg.enumerate(allGroups, true);
1:             if (actual < allGroups.length)
1:                 break;
1:             // just double the size
1:             allGroups = new ThreadGroup[allGroups.length * 2];
1:         }
1: 
1:         for (int i = 0; i < actual; i++)
1:         {
1:             if (allGroups[i].getName().startsWith("derby."))
1:                 return true;
1:         }
1:         return false;
1:     }
commit:76da2f3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.drda.NetworkServerControl;
1: import org.apache.derbyTesting.junit.Derby;
1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         if ("embedded".equals(which))
1:         {
1:             // Tests to see if the full engine is booted correctly
1:             // when the embedded driver is autoloading
1:             if (Derby.hasServer())
1:                 suite.addTest(new AutoloadTest("testAutoNetworkServerBoot"));
1: 
1:         }
1:             
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that the auto-load of the network server is as expected.
1:      * <P>
1:      * derby.drda.startNetworkServer=false or not set
1:      * <BR>
1:      *     network server should not auto boot.
1:      * <P>
1:      * derby.drda.startNetworkServer=true
1:      * <BR>
1:      * If jdbc.drivers contains the name of the embedded driver
1:      * then the server must be booted.
1:      * <BR>
1:      * Otherwise even if auto-loading the embedded driver due to JDBC 4
1:      * auto-loading the network server must not boot. This is because
1:      * the auto-loaded driver for JDBC 4 is a proxy driver that registers
1:      * a driver but does not boot the complete embedded engine.
1:      * @throws Exception 
1:      * 
1:      *
1:      */
1:     public void testAutoNetworkServerBoot() throws Exception
1:     {
1:         boolean nsAutoBoot = "true".equalsIgnoreCase(
1:                 getSystemProperty("derby.drda.startNetworkServer"));
1:         
1:         boolean serverShouldBeUp =
1:             nsAutoBoot && fullEngineAutoBoot();
1:         
0:         NetworkServerControl control = new NetworkServerControl();
1:         
0:         boolean isServerUp = NetworkServerTestSetup.pingForServerStart(control);
1:         
1:         assertEquals("Network Server state incorrect",
1:                 serverShouldBeUp, isServerUp);
1:         
1:         if (isServerUp)
1:             control.shutdown();
1:     }
1:     
1:     /**
0:      * Return true if a full auto-boot of the engine is expected
1:      * due to jdbc.drivers containing the name of the embedded driver.
1:      */
1:     private boolean fullEngineAutoBoot()
1:     {
1:         String jdbcDrivers = getSystemProperty("jdbc.drivers");
0:         return jdbcDrivers.indexOf("org.apache.derby.jdbc.EmbeddedDriver") != -1;
1:     }
commit:f2e3e69
/////////////////////////////////////////////////////////////////////////
1:         boolean embeddedAutoLoad = false;
1:         boolean clientAutoLoad = false;
1:         
1:         if (JDBC.vmSupportsJDBC4() && TestConfiguration.loadingFromJars())
1:         {
0:             embeddedAutoLoad = true;
0:             clientAutoLoad = true;
0:         else
1:         {
0:             // Simple test to see if the driver class is
0:             // in the value. Could get fancy and see if it is
0:             // correctly formatted but not worth it.
1:             try {
0:                 String jdbcDrivers = getSystemProperty("jdbc.drivers");
0:                 if (jdbcDrivers == null)
0:                     jdbcDrivers = "";
0:                 embeddedAutoLoad = jdbcDrivers
0:                         .indexOf("org.apache.derby.jdbc.EmbeddedDriver") != -1;
0:                 clientAutoLoad = jdbcDrivers
0:                         .indexOf("org.apache.derby.jdbc.ClientDriver") != -1;
0:             } catch (SecurityException se) {
0:                 // assume there is no autoloading if
0:                 // we can't read the value of jdbc.drivers.
1:             }
1:         }
1:         
0:         if (embeddedAutoLoad || clientAutoLoad)
1:         {
0:             TestSuite suite = new TestSuite("AutoloadTest");
0:             if (embeddedAutoLoad)
1:                 suite.addTest(baseAutoLoadSuite("embedded"));
0:             if (clientAutoLoad)
1:                 suite.addTest(
1:                   TestConfiguration.clientServerDecorator(
1:                           baseAutoLoadSuite("client")));
1:                 
1:             return suite;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return the ordered set of tests when autoloading is enabled.
0:      * @return
1:      */
1:     private static Test baseAutoLoadSuite(String which)
1:     {
0:         TestSuite suite = new TestSuite("AutoloadTest: " + which);
1:         
1:         suite.addTest(new AutoloadTest("testRegisteredDriver"));
1:         suite.addTest(new AutoloadTest("testSuccessfulConnect"));
1:         suite.addTest(new AutoloadTest("testUnsuccessfulConnect"));
1:         suite.addTest(new AutoloadTest("testExplicitLoad"));
1:         return suite;
1:     }
/////////////////////////////////////////////////////////////////////////
1:                     
/////////////////////////////////////////////////////////////////////////
0:      * Test an explict load of the driver works as well.
1:      * @throws Exception 
1:      *
1:      */
1:     public void testExplicitLoad() throws Exception
1:     {
1:         String driverClass =
1:             getTestConfiguration().getJDBCClient().getJDBCDriverName();
1:         
1:         // With and without a new instance
0:         Class.forName(driverClass);
1:         testSuccessfulConnect();
1:         testUnsuccessfulConnect();
1:         
0:         Class.forName(driverClass).newInstance();
1:         testSuccessfulConnect();
1:         testUnsuccessfulConnect();
1:     }
1:     
1:     /**
commit:9f608bd
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.AutoloadTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
0: import java.sql.Driver;
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * This JUnit test verifies the autoloading of the jdbc driver.
1:  * A driver may be autoloaded due to JDBC 4 autoloading from
1:  * jar files or the driver's name is listed in the system
1:  * property jdbc.drivers when DriverManager is first loaded.
1:  * 
1:  * This test must be run in its own VM because we want to verify that the
1:  * driver was not accidentally loaded by some other test.
1:  */
1: public class AutoloadTest extends BaseJDBCTestCase
0: {		
1: 	public	AutoloadTest( String name ) { super( name ); }
1: 
1:     
1:     /**
1:      * Only run a test if the driver will be auto-loaded.
1:      * See class desciption for details.
1:      */
1:     public static Test suite() {
0:         if (!JDBC.vmSupportsJDBC2())
0:             return new TestSuite("empty: no java.sql.DriverManager");
1: 
0:         if (JDBC.vmSupportsJDBC4() && TestConfiguration.loadingFromJars()) {
0:             // test client & embedded
0:             return TestConfiguration.defaultSuite(AutoloadTest.class);
1:         }
0:         // Simple test to see if the driver class is
0:         // in the value. Could get fancy and see if it is
0:         // correctly formatted but not worth it.
1: 
1:         try {
0:             String jdbcDrivers = getSystemProperty("jdbc.drivers");
0:             if (jdbcDrivers == null)
0:                 jdbcDrivers = "";
1: 
0:             boolean embedded = jdbcDrivers
0:                     .indexOf("org.apache.derby.jdbc.EmbeddedDriver") != -1;
1: 
0:             boolean clientServer = jdbcDrivers
0:                     .indexOf("org.apache.derby.jdbc.ClientDriver") != -1;
1: 
0:             if (embedded && clientServer)
0:                 return TestConfiguration.defaultSuite(AutoloadTest.class);
1: 
0:             if (embedded)
0:                 return TestConfiguration.embeddedSuite(AutoloadTest.class);
1: 
0:             if (clientServer)
0:                 return TestConfiguration.clientServerSuite(AutoloadTest.class);
0:         } catch (SecurityException se) {
0:             // assume there is no autoloading if
0:             // we can't read the value of jdbc.drivers.
1:         }
1: 
1:         // Run a single test that ensures that the driver is
1:         // not loaded implicitly by some other means.
0:         TestSuite suite = new TestSuite("AutoloadTest: no autoloading expected");
1:         
1:         suite.addTest(new AutoloadTest("noloadTestNodriverLoaded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:                 new AutoloadTest("noloadTestNodriverLoaded")));
1:         
1:         return suite;
1:     }
1: 
1: 	// ///////////////////////////////////////////////////////////
1: 	//
1: 	// TEST ENTRY POINTS
1: 	//
1: 	// ///////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @throws SQLException
1:      * 
1:      */
1:     public void testRegisteredDriver() throws SQLException
0:     {
1:         String protocol =
1:             getTestConfiguration().getJDBCClient().getUrlBase();
1:         
0:         System.out.println("PROTOCOL " + protocol);
1:             
1:         Driver driver = DriverManager.getDriver(protocol);
1:         assertNotNull("Expected registered driver", driver);
1:     }
1: 
1: 	/**
0:      * Test we can connect successfully to a database.
1: 	 */
1: 	public void testSuccessfulConnect()
1:        throws SQLException
0: 	{
1: 		println( "We ARE autoloading..." );
1:        
1:         // Test we can connect successfully to a database!
1:         String url = getTestConfiguration().getJDBCUrl();
1:         url = url.concat(";create=true");
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1:         DriverManager.getConnection(url, user, password).close();
1: 	}
1:     /**
1:      * Test the error code on an unsuccessful connect
1:      * to ensure it is not one returned by DriverManager.
1:      */
0:     public void testUnsuccessfulConnect()
1:        throws SQLException
0:     {     
1:         // Test we can connect successfully to a database!
1:         String url = getTestConfiguration().getJDBCUrl("nonexistentDatabase");
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1:         try {
1:             DriverManager.getConnection(url, user, password).close();
1:             fail("connected to nonexistentDatabase");
1:         } catch (SQLException e) {
1:             String expectedError = usingEmbedded() ? "XJ004" : "08004";
1:             
1:             assertSQLState(expectedError, e);
1:         }
1:     }
1:     
1:     /**
1:      * Simple test when auto-loading is not expected.
1:      * This is to basically test that the junit setup code
1:      * itself does not load the driver, thus defeating the
1:      * real auto-loading testing.
1:      */
1:     public void noloadTestNodriverLoaded() {
1:         try {
1:             testRegisteredDriver();
1:             fail("Derby junit setup code is loading driver!");
1:         } catch (SQLException e) {
1:         }
1:     }
1: }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:d5376da
/////////////////////////////////////////////////////////////////////////
1:      * @return true if there appears to be a Derby embedded driver registered
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
============================================================================