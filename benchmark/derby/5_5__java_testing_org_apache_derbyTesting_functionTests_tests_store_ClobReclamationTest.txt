1:8f33dfd: /*
1:8f33dfd:  *
1:8f33dfd:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.ClobReclamationTest
1:8f33dfd:  *
1:8f33dfd:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8f33dfd:  * contributor license agreements.  See the NOTICE file distributed with
1:8f33dfd:  * this work for additional information regarding copyright ownership.
1:8f33dfd:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8f33dfd:  * (the "License"); you may not use this file except in compliance with
1:8f33dfd:  * the License.  You may obtain a copy of the License at
1:8f33dfd:  *
1:8f33dfd:  *    http://www.apache.org/licenses/LICENSE-2.0
1:8f33dfd:  *
1:8f33dfd:  * Unless required by applicable law or agreed to in writing,
1:8f33dfd:  * software distributed under the License is distributed on an
1:8f33dfd:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:8f33dfd:  * either express or implied. See the License for the specific
1:8f33dfd:  * language governing permissions and limitations under the License.
1:8f33dfd:  */
1:8f33dfd: package org.apache.derbyTesting.functionTests.tests.store;
4:8f33dfd: 
1:2cd0cc1: import java.lang.Integer;
1:2cd0cc1: 
1:8b553f1: import java.sql.CallableStatement;
1:8f33dfd: import java.sql.Connection;
1:8f33dfd: import java.sql.PreparedStatement;
1:8f33dfd: import java.sql.ResultSet;
1:8f33dfd: import java.sql.SQLException;
1:8f33dfd: import java.sql.Statement;
1:8b553f1: 
1:8f33dfd: import junit.framework.Test;
1:8f33dfd: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:8f33dfd: import org.apache.derbyTesting.functionTests.util.Formatters;
1:8f33dfd: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:8f33dfd: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:8f33dfd: import org.apache.derbyTesting.junit.JDBC;
1:8f33dfd: import org.apache.derbyTesting.junit.TestConfiguration;
1:8f33dfd: 
1:8f33dfd: /**
1:8f33dfd:  * Verify that space gets reclaimed for multi-threaded Clob updates
1:8f33dfd:  * 
1:8f33dfd:  */
1:8f33dfd: public class ClobReclamationTest extends BaseJDBCTestCase {
1:8f33dfd: 
1:8f33dfd:     // Need to adjust NUM_THREADS and expectedNumAllocated.
1:8f33dfd:     // For 2 threads expectedNumAllocated is 5
1:8f33dfd:     // For 100 threads expectedNumAllocated is 201
1:8f33dfd:     private static final int NUM_THREADS = 2;
1:8f33dfd: 
1:8f33dfd:     private static int expectedNumAllocated = 5;
1:8f33dfd: 
1:8f33dfd:     public ClobReclamationTest(String name) {
1:8f33dfd:         super(name);
1:8f33dfd: 
1:8f33dfd:     }
1:8b553f1: 
1:8b553f1:     /**
1:f56c601:      * Two threads simultaneously updating a table. Threads each
1:dbed020:      * update a separate row with a long value (&gt;32K). NUMALLOCATED
1:f56c601:      * pages should not grow past expected value after 500 updates
1:f56c601:      * by each thread.
1:8f33dfd:      * 
1:ad8fd16:      * @param lockTable true if we should get an exclusive lock on the table
1:ad8fd16:      * before update
1:ad8fd16:      * @param updateSingleRow true if we should try updating a single row 
1:ad8fd16:      * instead of different rows
1:ad8fd16:      * 
1:8f33dfd:      * @throws SQLException
1:8f33dfd:      * @throws InterruptedException
1:8f33dfd:      */
1:ad8fd16:     public void testMultiThreadedUpdate(final boolean lockTable, boolean updateSingleRow) throws SQLException,
1:8f33dfd:             InterruptedException {
1:8f33dfd:         // need to do a getConnection or we get a
1:8f33dfd:         // junit assertion that driver is not registered.
1:8f33dfd:         Connection conn = getConnection();
1:8f33dfd:         final String updateString = Formatters.repeatChar("a", 33000);
1:8f33dfd:         Thread[] threads = new Thread[NUM_THREADS];
1:8f33dfd:         for (int i = 0; i < NUM_THREADS; i++) {
1:ad8fd16:             final int key = updateSingleRow ? 1 : i + 1;
1:8f33dfd:             threads[i] = new Thread() {
1:8f33dfd:                 public void run() {
1:8f33dfd:                     try {
1:8f33dfd:                         Connection conn = openDefaultConnection();
1:b514f88:                         conn.setAutoCommit(false);
1:8f33dfd:                         ClobReclamationTest.fiveHundredUpdates(conn,
1:b514f88:                                 updateString, key, lockTable);                      
1:8f33dfd:                     } catch (SQLException e) {
1:8f33dfd:                         fail(e.getMessage());
1:8f33dfd:                     }
1:8f33dfd:                 }
1:8f33dfd:             };
1:8f33dfd:         }
1:8f33dfd:         for (int i = 0; i < NUM_THREADS; i++) {
1:8f33dfd:             threads[i].start();
1:8f33dfd:         }
1:8f33dfd:         for (int i = 0; i < NUM_THREADS; i++) {
1:8f33dfd:             threads[i].join();
1:f56c601:         }
1:2cd0cc1:         checkNumAllocatedPages("CLOBTAB",expectedNumAllocated, false);
1:8f33dfd:     }
1:8f33dfd: 
1:8b553f1:     /**
1:f56c601:      * Check that table has specified number of allocated pages.
1:f56c601:      * 
1:f56c601:      * @param table
1:f56c601:      * @param expectedAlloc
1:f56c601:      * @throws SQLException
1:f56c601:      */
1:2cd0cc1:     private void checkNumAllocatedPages(
1:2cd0cc1:     String  table, 
1:2cd0cc1:     int     expectedAlloc,
1:2cd0cc1:     boolean retry_with_sleeps) 
1:2cd0cc1:         throws SQLException {        
1:8f33dfd:         // Check the space table 
1:8f33dfd:         // Should not have grown.
1:f56c601: 
1:f56c601:         PreparedStatement ps = prepareStatement("SELECT NUMALLOCATEDPAGES FROM "
1:f56c601:                 + " new org.apache.derby.diag.SpaceTable('APP',?) t"
1:f56c601:                 + " WHERE CONGLOMERATENAME = ?");
1:2cd0cc1:         ps.setString(1, table);
1:f56c601:         ps.setString(2, table);
1:2cd0cc1: 
1:2cd0cc1:         // initialize previous_alloc_count such that we will always try 
1:2cd0cc1:         // at least one sleep/retry.
1:2cd0cc1:         int previous_alloc_count = Integer.MAX_VALUE;
1:2cd0cc1: 
1:2540da6:         int num_retries = 0;
1:2540da6: 
1:2cd0cc1:         for(;;)
1:2cd0cc1:         {
1:2cd0cc1:             // loop until success, or until sleep/retry does not result
1:2cd0cc1:             // in less allocated pages.
1:2cd0cc1: 
1:2cd0cc1:             // get 1 row, it has the num allocated page count.
1:2cd0cc1:             ResultSet rs = ps.executeQuery();
1:2cd0cc1: 
1:2cd0cc1:             rs.next();
1:2cd0cc1: 
1:2cd0cc1:             int num_allocated_pages = rs.getInt(1);
1:2cd0cc1: 
1:2cd0cc1:             // first check if count is the expected value, if so done.
1:2cd0cc1:             if (num_allocated_pages == expectedAlloc)
1:2cd0cc1:             {
1:2cd0cc1:                 // expected result is met, success
1:2cd0cc1:                 break;
1:2cd0cc1:             }
1:2cd0cc1:             else if (retry_with_sleeps)
1:2cd0cc1:             {
1:2cd0cc1:                 if (num_allocated_pages < previous_alloc_count)
1:2cd0cc1:                 {
1:2cd0cc1:                     num_retries++;
1:2cd0cc1: 
1:2cd0cc1:                     // background thread made progress in last sleep,
1:c802b18:                     // try sleeping again, wait longer as this machine
1:c802b18:                     // seems to take longer to process the post
1:a48aa44:                     // commit work.  Most environments just need one
1:a48aa44:                     // short retry, while enviroments where this does 
1:a48aa44:                     // not work need much more time.  Make second retry
1:a48aa44:                     // much longer.
1:2cd0cc1:                     try 
1:2cd0cc1:                     {
1:a48aa44:                         if (num_retries <= 1)
1:a48aa44:                             Thread.sleep(10000);
1:a48aa44:                         else
1:a48aa44:                             Thread.sleep(60000 * num_retries);
1:a48aa44: 
1:2cd0cc1:                     }
1:2cd0cc1:                     catch (Exception ex)
1:2cd0cc1:                     {
1:2cd0cc1:                         // just ignore interrupted sleep
1:2cd0cc1:                     }
1:2cd0cc1:                 }
1:2cd0cc1:                 else
1:2cd0cc1:                 {
1:2cd0cc1:                     // sleep has not found less alloc rows let the assert fail.
1:2cd0cc1:                     assertTrue(
1:2cd0cc1:                         "Fail with retries -- num_allocated_pages:" + 
1:2cd0cc1:                         num_allocated_pages + 
1:2cd0cc1:                         " == expectedAlloc: " + expectedAlloc +
1:2540da6:                         " previous_alloc_count: " + previous_alloc_count +
1:2cd0cc1:                         " num_retries: " + num_retries, 
1:2cd0cc1:                         num_allocated_pages == expectedAlloc); 
1:2cd0cc1:                 }
1:2cd0cc1: 
1:a48aa44:                 // force at least 2 retries
1:a48aa44:                 if (num_retries > 1)
1:a48aa44:                     previous_alloc_count = num_allocated_pages;
1:2cd0cc1:             }
1:2cd0cc1:             else
1:2cd0cc1:             {
1:2cd0cc1:                 // no retries allowed, let assert fail.
1:2cd0cc1:                 assertTrue(
1:d4d0972:                     "Fail, no retries -- num_allocated_pages:" + 
1:d4d0972:                     num_allocated_pages + 
1:2cd0cc1:                     " > expectedAlloc: " + expectedAlloc, 
1:2cd0cc1:                     num_allocated_pages == expectedAlloc); 
1:8f33dfd:             }
1:2540da6: 
1:2540da6:             rs.close();
1:8f33dfd:         } 
1:8f33dfd:     }
1:8f33dfd: 
1:f56c601:     /**
1:8b553f1:      * Check that table has specified number of free pages.
1:8b553f1:      *
1:8b553f1:      * @param table
1:8b553f1:      * @param expectedFree  expected number of free pages.
1:8b553f1:      * @throws SQLException
1:8b553f1:      */
1:8b553f1:     private void checkNumFreePages(
1:8b553f1:     String  table, 
1:8b553f1:     int     expectedFree) throws SQLException {        
1:8b553f1: 
1:8b553f1:         // Check the space table 
1:8b553f1:         // Should not have grown.
1:8b553f1: 
1:8b553f1:         PreparedStatement ps = 
1:8b553f1:             prepareStatement(
1:8b553f1:                   "SELECT NUMFREEPAGES FROM "
1:8b553f1:                 + " new org.apache.derby.diag.SpaceTable('APP',?) t"
1:8b553f1:                 + " WHERE CONGLOMERATENAME = ?");
1:8b553f1: 
1:8b553f1:         ps.setString(1, table);
1:8b553f1:         ps.setString(2, table);
1:8b553f1:         ResultSet rs = ps.executeQuery();
1:8b553f1:         JDBC.assertFullResultSet(rs, new String[][] { { "" + expectedFree } });
1:8b553f1:     }
1:888d12e: 
1:888d12e:     private void checkNumFreePagesMax(
1:888d12e:     String  table, 
1:888d12e:     int     expectedFreeMax) throws SQLException {        
1:888d12e: 
1:888d12e:         // Check the space table 
1:888d12e:         // Should not have grown.
1:888d12e: 
1:888d12e:         PreparedStatement ps = 
1:888d12e:             prepareStatement(
1:888d12e:                   "SELECT NUMFREEPAGES FROM "
1:888d12e:                 + " new org.apache.derby.diag.SpaceTable('APP',?) t"
1:888d12e:                 + " WHERE CONGLOMERATENAME = ?");
1:888d12e: 
1:888d12e:         ps.setString(1, table);
1:888d12e:         ps.setString(2, table);
1:888d12e:         ResultSet rs = ps.executeQuery();
1:8b553f1: 
1:888d12e:         // get 1 row, it has the num free page count and make sure it is
1:888d12e:         // lower than the passed in maximum.
1:888d12e:         rs.next();
1:888d12e: 
1:888d12e:         int numfreerows = rs.getInt(1);
1:888d12e: 
1:888d12e:         assertTrue(
1:888d12e:             "Fail -- numfreerows:" + numfreerows + 
1:888d12e:             " > expectedFreeMax: " + expectedFreeMax, 
1:888d12e:             numfreerows < expectedFreeMax); 
1:888d12e:         rs.close();
1:888d12e:         ps.close();
1:888d12e:     }
1:888d12e: 
1:8f33dfd:     private static void fiveHundredUpdates(Connection conn,
1:b514f88:             String updateString, int key, boolean lockTable) throws SQLException {
1:8f33dfd:         PreparedStatement ps = conn
1:8f33dfd:                 .prepareStatement("UPDATE CLOBTAB SET C = ? WHERE I = ?");
1:8f33dfd:         for (int i = 0; i < 500; i++) {
1:b514f88:             if (lockTable) {
1:b514f88:                 Statement s = conn.createStatement();
1:b514f88:                 s.executeUpdate("LOCK TABLE CLOBTAB IN EXCLUSIVE MODE");
1:b514f88:              }
1:8f33dfd:             ps.setString(1, updateString);
1:8f33dfd:             ps.setInt(2, key);
1:8f33dfd:             ps.executeUpdate();
1:b514f88:             conn.commit();
1:8f33dfd:         }
1:8f33dfd:     }
1:8f33dfd: 
1:b514f88:     /**
1:b514f88:      * Test multithreaded clob update using standard row locking
1:b514f88:      * @throws SQLException
1:b514f88:      * @throws InterruptedException
1:b514f88:      */
1:b514f88:     public void testMultiThreadedUpdateRowLocking() throws SQLException, InterruptedException {
1:ad8fd16:         testMultiThreadedUpdate(false /* don't lock table */, false /*don't update single row*/);
1:b514f88:     }
1:b514f88:     
1:b514f88:     /**
1:b514f88:      * Test multithreaded clob update but get an exclusive lock on the
1:b514f88:      * table for each update. We can't enable this teset until DERBY-4054 
1:b514f88:      * is fixed.
1:b514f88:      * 
1:b514f88:      * @throws SQLException
1:b514f88:      * @throws InterruptedException
1:b514f88:      */
1:b514f88:     public void xtestMultiThreadedUpdateTableLocking() throws SQLException, InterruptedException {
1:ad8fd16:         testMultiThreadedUpdate(true /*lock table */, false /* don't update single row */ );
1:ad8fd16:     }
1:ad8fd16:     
1:ad8fd16:     /**
1:ad8fd16:      * Test multiThreaded update of single row to cause lock contention
1:ad8fd16:      * This will trigger the row lock retry case of DERBY-4055
1:ad8fd16:      * 
1:ad8fd16:      * @throws SQLException
1:ad8fd16:      * @throws InterruptedException
1:ad8fd16:      */
1:ad8fd16:     public void xtestMultiThreadUpdateSingleRow() throws SQLException, InterruptedException {
1:ad8fd16:         testMultiThreadedUpdate(false /*don't lock table */, true /* update single row */ );
1:b514f88:     }
1:b514f88:     
1:f56c601:     /**
1:f56c601:      * Make sure we reclaim space on rollback. Cannot enable this test 
1:f56c601:      * until DERBY-4057 is fixed.
1:f56c601:      * 
1:f56c601:      * @throws SQLException
1:f56c601:      */
1:888d12e:     public void testReclamationOnRollback() throws SQLException {
1:f56c601:         setAutoCommit(false);
1:f56c601:         String insertString = Formatters.repeatChar("a", 33000);
1:f56c601:         PreparedStatement ps = prepareStatement("INSERT INTO CLOBTAB2 VALUES(?,?)");
1:f56c601:         for (int i = 0; i < 500; i++) {            
1:f56c601:             ps.setInt(1, i);
1:f56c601:             ps.setString(2, insertString);   
1:f56c601:             ps.executeUpdate();
1:f56c601:             rollback();
1:1bd9cd2:         }
1:1bd9cd2: 
1:1bd9cd2:         // sleep 5 seconds to give background space reclamation worker thread 
1:1bd9cd2:         // a chance to reclaim all the aborted insert space.
1:1bd9cd2:         
1:1bd9cd2:         try 
1:1bd9cd2:         {
1:2cd0cc1:             Thread.sleep(5000);
1:2cd0cc1:         }
1:1bd9cd2:         catch (Exception ex)
1:1bd9cd2:         {
1:1bd9cd2:             // just ignore interrupted sleep
1:2cd0cc1:         }
1:1bd9cd2: 
1:2cd0cc1:         checkNumAllocatedPages("CLOBTAB2",1,true);
1:1bd9cd2:     }
1:8b553f1: 
1:8f33dfd:     /**
1:8b553f1:      * Test for DERBY-4182.  
1:8b553f1:      *
1:8b553f1:      * This test just exercises the abort specific part of DERBY-4182.  After
1:8b553f1:      * the fix abort of an insert containing a blob will leave the head row, 
1:8b553f1:      * plus the first page of the overflow chain.  The rest of the chain
1:8b553f1:      * will be moved to free pages.
1:8b553f1:      *
1:8b553f1:      * @throws SQLException
1:8b553f1:      */
1:8b553f1:     public void testBlobLinkedListReclamationOnRollback() throws SQLException {
1:8b553f1:         setAutoCommit(false);
1:8b553f1: 
1:8b553f1:         int clob_length = 200000;
1:8b553f1: 
1:8b553f1:         // pick a clob bigger than 2*max page size
1:8b553f1:         String insertString = Formatters.repeatChar("a", 200000);
1:8b553f1:         PreparedStatement ps = 
1:8b553f1:             prepareStatement("INSERT INTO CLOBTAB3 VALUES(?,?)");
1:8b553f1: 
1:8b553f1:         int numrows = 500;
1:8b553f1: 
1:8b553f1:         for (int i = 0; i < numrows; i++) {            
1:8b553f1:             ps.setInt(1, i);
1:8b553f1:             ps.setString(2, insertString);   
1:8b553f1:             ps.executeUpdate();
1:8b553f1:             rollback();
1:8b553f1:         }
1:8b553f1:         ps.close();
1:8b553f1: 
1:8b553f1:         // until DERBY-4057 fixed expect space to be 2 pages per row plus
1:888d12e:         // 1 head page per container.  DERBY-4057 has been fixed so allocated
1:888d12e:         // pages is showing up as 1 in my runs.  Am a bit worried that because
1:888d12e:         // this is thread and post commit dependent that we may have to play
1:888d12e:         // with the "expected" allocated a little to allow for post commit
1:888d12e:         // on some machines not running fast enough.  For now just setting
1:888d12e:         // to 1 as the head page will remain allocated, all the rest should
1:888d12e:         // be free after post commit reclaim.
1:2cd0cc1:         checkNumAllocatedPages("CLOBTAB3", 1, true);
1:8b553f1: 
1:8b553f1:         // expect most free pages to get used by subsequent inserts.  Only 
1:8b553f1:         // free pages should be from the last remaining aborted insert of
1:8b553f1:         // the last clob chain.  It should include all of the clob except the
1:8b553f1:         // head page of the chain: (sizeof(clob) / page size) - 1
1:8b553f1:         // Derby should default to 32k page size for any table with a clob in
1:8b553f1:         // it.
1:888d12e: 
1:888d12e:         // after fix for DERBY-4057 work gets queued immediately after the 
1:888d12e:         // rollback, but also the next insert happens at same time.  On
1:888d12e:         // my machine I am getting 12 pages free which looks like space from
1:888d12e:         // the first abort  gets used for the 3rd insert, space from second
1:888d12e:         // abort gets used for the 4th insert ...  Running full test suite
1:888d12e:         // on my machine got 14 free pages which is still very good considering
1:888d12e:         // before change there were 1000 allocated pages and now there is 1
1:888d12e:         // allocated and 14 free.  There is a timing 
1:888d12e:         // issue with test and maybe a sleep of some sort is necessary after
1:888d12e:         // the rollback.  
1:888d12e: 
1:1606397:         // declaring correct run if only max of free pages from 20 rows worth
1:888d12e:         // of free space remains.
1:1606397:         // ((clob length / page size ) * 20) + 
1:8b553f1:         //     1 page for int divide round off - 1 for the head page.
1:2678c36: 
1:2678c36:         // The above check that there is 1 allocated page shows that we
1:2678c36:         // are reclaiming space.  The number of free pages left is very
1:2678c36:         // machine dependent as it depends on speed of background thread 
1:2678c36:         // reclaiming space and the above user loop doing the inserts 
1:2678c36:         // concurrent with the background threads reclaiming the aborted
1:2678c36:         // inserted space.
1:2678c36: 
1:2678c36:         // See DERBY-6775 for better test
1:2678c36:         /*
1:1606397:         checkNumFreePagesMax("CLOBTAB3", ((clob_length / 32000) * 20) + 1 - 1);
1:8b553f1:         commit();
1:2678c36:         */
1:8b553f1: 
1:8b553f1:         // running inplace compress should reclaim all the remaining aborted
1:8b553f1:         // insert space, previous to fix inplace compress would leave stranded
1:8b553f1:         // allocated pages that were part of the clob overflow chains.
1:8b553f1:         CallableStatement call_compress =
1:8b553f1:             prepareCall(
1:8b553f1:                 "CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, 1, 1, 1)");
1:8b553f1: 
1:8b553f1:         call_compress.setString(1, "APP");
1:8b553f1:         call_compress.setString(2, "CLOBTAB3");
1:8b553f1:         call_compress.executeUpdate();
1:8b553f1: 
1:8b553f1:         // all space except for head page should be reclaimed.
1:2cd0cc1:         checkNumAllocatedPages("CLOBTAB3", 1, false);
1:8b553f1: 
1:8b553f1:         // should be no free pages after the inplace compress of a table with
1:8b553f1:         // all deleted rows.
1:8b553f1:         checkNumFreePages("CLOBTAB3", 0);
1:8b553f1:         commit();
1:8b553f1:     }
1:f56c601:     
1:8f33dfd:     public static Test suite() {
1:8f33dfd:         Test suite = TestConfiguration.embeddedSuite(ClobReclamationTest.class);
1:4068b52:         return new CleanDatabaseTestSetup(suite) {
1:8f33dfd:             /**
1:8f33dfd:              * Creates the table used in the test cases.
1:8f33dfd:              * 
1:8f33dfd:              */
1:8f33dfd:             protected void decorateSQL(Statement s) throws SQLException {
1:4068b52:                 if (SanityManager.DEBUG) {
1:4068b52:                     SanityManager.DEBUG_SET("DaemonTrace");
1:888d12e:                     SanityManager.DEBUG_SET("verbose_heap_post_commit");
1:4068b52:                 }
1:4068b52: 
1:8f33dfd:                 Connection conn = s.getConnection();
1:8f33dfd:                 s
1:8f33dfd:                         .executeUpdate("CREATE TABLE CLOBTAB (I INT  PRIMARY KEY NOT NULL, c CLOB)");
1:8f33dfd:                 PreparedStatement ps = conn
1:8f33dfd:                         .prepareStatement("INSERT INTO CLOBTAB VALUES(?,?)");
1:8f33dfd:                 String insertString = "hello";
1:8f33dfd:                 for (int i = 1; i <= NUM_THREADS; i++) {
1:8f33dfd:                     ps.setInt(1, i);
1:8f33dfd:                     ps.setString(2, insertString);
1:8f33dfd:                     ps.executeUpdate();
1:f56c601:                 }
1:f56c601:                 s.executeUpdate("CREATE TABLE CLOBTAB2 (I INT, C CLOB)");                
1:8b553f1:                 s.executeUpdate("CREATE TABLE CLOBTAB3 (I INT, C CLOB)");                
1:f56c601:             }
1:8f33dfd: 
1:4068b52:             protected void tearDown() throws Exception {
1:4068b52:                 if (SanityManager.DEBUG) {
1:4068b52:                     SanityManager.DEBUG_CLEAR("DaemonTrace");
1:4068b52:                 }
1:4068b52:                 super.tearDown();
1:4068b52:             }
1:4068b52: 
1:8f33dfd:         };
1:8f33dfd: 
1:8f33dfd:     }
1:8f33dfd: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * update a separate row with a long value (&gt;32K). NUMALLOCATED
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:d4d0972
/////////////////////////////////////////////////////////////////////////
1:                     "Fail, no retries -- num_allocated_pages:" + 
1:                     num_allocated_pages + 
commit:a48aa44
/////////////////////////////////////////////////////////////////////////
1:                     // commit work.  Most environments just need one
1:                     // short retry, while enviroments where this does 
1:                     // not work need much more time.  Make second retry
1:                     // much longer.
1:                         if (num_retries <= 1)
1:                             Thread.sleep(10000);
1:                         else
1:                             Thread.sleep(60000 * num_retries);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 // force at least 2 retries
1:                 if (num_retries > 1)
1:                     previous_alloc_count = num_allocated_pages;
commit:c802b18
/////////////////////////////////////////////////////////////////////////
1:                     // try sleeping again, wait longer as this machine
1:                     // seems to take longer to process the post
0:                     // commit work.
0:                         Thread.sleep(10000 * num_retries);
commit:2540da6
/////////////////////////////////////////////////////////////////////////
1:         int num_retries = 0;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         " previous_alloc_count: " + previous_alloc_count +
/////////////////////////////////////////////////////////////////////////
1: 
1:             rs.close();
commit:2cd0cc1
/////////////////////////////////////////////////////////////////////////
1: import java.lang.Integer;
1: 
/////////////////////////////////////////////////////////////////////////
1:         checkNumAllocatedPages("CLOBTAB",expectedNumAllocated, false);
/////////////////////////////////////////////////////////////////////////
1:     private void checkNumAllocatedPages(
1:     String  table, 
1:     int     expectedAlloc,
1:     boolean retry_with_sleeps) 
1:         throws SQLException {        
1:         ps.setString(1, table);
1: 
1:         // initialize previous_alloc_count such that we will always try 
1:         // at least one sleep/retry.
1:         int previous_alloc_count = Integer.MAX_VALUE;
1: 
1:         for(;;)
1:         {
1:             // loop until success, or until sleep/retry does not result
1:             // in less allocated pages.
1: 
1:             // get 1 row, it has the num allocated page count.
1:             ResultSet rs = ps.executeQuery();
1: 
1:             rs.next();
1: 
1:             int num_allocated_pages = rs.getInt(1);
0:             int num_retries = 0;
1: 
1:             // first check if count is the expected value, if so done.
1:             if (num_allocated_pages == expectedAlloc)
1:             {
1:                 // expected result is met, success
1:                 break;
1:             }
1:             else if (retry_with_sleeps)
1:             {
1:                 if (num_allocated_pages < previous_alloc_count)
1:                 {
1:                     num_retries++;
1: 
1:                     // background thread made progress in last sleep,
0:                     // try sleeping again.
1:                     try 
1:                     {
1:                         Thread.sleep(5000);
1:                     }
1:                     catch (Exception ex)
1:                     {
1:                         // just ignore interrupted sleep
1:                     }
1:                 }
1:                 else
1:                 {
1:                     // sleep has not found less alloc rows let the assert fail.
1:                     assertTrue(
1:                         "Fail with retries -- num_allocated_pages:" + 
1:                         num_allocated_pages + 
1:                         " == expectedAlloc: " + expectedAlloc +
1:                         " num_retries: " + num_retries, 
1:                         num_allocated_pages == expectedAlloc); 
1:                 }
1: 
0:                 previous_alloc_count = num_allocated_pages;
1:             }
1:             else
1:             {
1:                 // no retries allowed, let assert fail.
1:                 assertTrue(
0:                     "Fail -- num_allocated_pages:" + num_allocated_pages + 
1:                     " > expectedAlloc: " + expectedAlloc, 
1:                     num_allocated_pages == expectedAlloc); 
1:             }
1:         } 
/////////////////////////////////////////////////////////////////////////
1:         checkNumAllocatedPages("CLOBTAB2",1,true);
/////////////////////////////////////////////////////////////////////////
1:         checkNumAllocatedPages("CLOBTAB3", 1, true);
/////////////////////////////////////////////////////////////////////////
1:         checkNumAllocatedPages("CLOBTAB3", 1, false);
commit:2678c36
/////////////////////////////////////////////////////////////////////////
1: 
1:         // The above check that there is 1 allocated page shows that we
1:         // are reclaiming space.  The number of free pages left is very
1:         // machine dependent as it depends on speed of background thread 
1:         // reclaiming space and the above user loop doing the inserts 
1:         // concurrent with the background threads reclaiming the aborted
1:         // inserted space.
1: 
1:         // See DERBY-6775 for better test
1:         /*
1:         */
commit:1606397
/////////////////////////////////////////////////////////////////////////
1:         // declaring correct run if only max of free pages from 20 rows worth
1:         // ((clob length / page size ) * 20) + 
1:         checkNumFreePagesMax("CLOBTAB3", ((clob_length / 32000) * 20) + 1 - 1);
commit:1bd9cd2
/////////////////////////////////////////////////////////////////////////
1: 
1:         // sleep 5 seconds to give background space reclamation worker thread 
1:         // a chance to reclaim all the aborted insert space.
1:         
1:         try 
1:         {
0:             Thread.sleep(5000);
1:         }
1:         catch (Exception ex)
1:         {
1:             // just ignore interrupted sleep
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         // declaring correct run if only max if free pages from 10 pages worth
0:         checkNumFreePagesMax("CLOBTAB3", ((clob_length / 32000) * 10) + 1 - 1);
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1:     private void checkNumFreePagesMax(
1:     String  table, 
1:     int     expectedFreeMax) throws SQLException {        
1: 
1:         // Check the space table 
1:         // Should not have grown.
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(
1:                   "SELECT NUMFREEPAGES FROM "
1:                 + " new org.apache.derby.diag.SpaceTable('APP',?) t"
1:                 + " WHERE CONGLOMERATENAME = ?");
1: 
1:         ps.setString(1, table);
1:         ps.setString(2, table);
1:         ResultSet rs = ps.executeQuery();
1: 
1:         // get 1 row, it has the num free page count and make sure it is
1:         // lower than the passed in maximum.
1:         rs.next();
1: 
1:         int numfreerows = rs.getInt(1);
1: 
1:         assertTrue(
1:             "Fail -- numfreerows:" + numfreerows + 
1:             " > expectedFreeMax: " + expectedFreeMax, 
1:             numfreerows < expectedFreeMax); 
1:         rs.close();
1:         ps.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testReclamationOnRollback() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         // 1 head page per container.  DERBY-4057 has been fixed so allocated
1:         // pages is showing up as 1 in my runs.  Am a bit worried that because
1:         // this is thread and post commit dependent that we may have to play
1:         // with the "expected" allocated a little to allow for post commit
1:         // on some machines not running fast enough.  For now just setting
1:         // to 1 as the head page will remain allocated, all the rest should
1:         // be free after post commit reclaim.
0:         checkNumAllocatedPages("CLOBTAB3", 1);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // after fix for DERBY-4057 work gets queued immediately after the 
1:         // rollback, but also the next insert happens at same time.  On
1:         // my machine I am getting 12 pages free which looks like space from
1:         // the first abort  gets used for the 3rd insert, space from second
1:         // abort gets used for the 4th insert ...  Running full test suite
1:         // on my machine got 14 free pages which is still very good considering
1:         // before change there were 1000 allocated pages and now there is 1
1:         // allocated and 14 free.  There is a timing 
1:         // issue with test and maybe a sleep of some sort is necessary after
1:         // the rollback.  
1: 
0:         // declaring correct run if only max if free pages from 5 pages worth
1:         // of free space remains.
0:         // ((clob length / page size ) * 5) + 
0:         checkNumFreePagesMax("CLOBTAB3", ((clob_length / 32000) * 5) + 1 - 1);
/////////////////////////////////////////////////////////////////////////
1:                     SanityManager.DEBUG_SET("verbose_heap_post_commit");
commit:8b553f1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check that table has specified number of free pages.
1:      *
1:      * @param table
1:      * @param expectedFree  expected number of free pages.
1:      * @throws SQLException
1:      */
1:     private void checkNumFreePages(
1:     String  table, 
1:     int     expectedFree) throws SQLException {        
1: 
1:         // Check the space table 
1:         // Should not have grown.
1: 
1:         PreparedStatement ps = 
1:             prepareStatement(
1:                   "SELECT NUMFREEPAGES FROM "
1:                 + " new org.apache.derby.diag.SpaceTable('APP',?) t"
1:                 + " WHERE CONGLOMERATENAME = ?");
1: 
1:         ps.setString(1, table);
1:         ps.setString(2, table);
1:         ResultSet rs = ps.executeQuery();
1:         JDBC.assertFullResultSet(rs, new String[][] { { "" + expectedFree } });
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test for DERBY-4182.  
1:      *
1:      * This test just exercises the abort specific part of DERBY-4182.  After
1:      * the fix abort of an insert containing a blob will leave the head row, 
1:      * plus the first page of the overflow chain.  The rest of the chain
1:      * will be moved to free pages.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testBlobLinkedListReclamationOnRollback() throws SQLException {
1:         setAutoCommit(false);
1: 
1:         int clob_length = 200000;
1: 
1:         // pick a clob bigger than 2*max page size
1:         String insertString = Formatters.repeatChar("a", 200000);
1:         PreparedStatement ps = 
1:             prepareStatement("INSERT INTO CLOBTAB3 VALUES(?,?)");
1: 
1:         int numrows = 500;
1: 
1:         for (int i = 0; i < numrows; i++) {            
1:             ps.setInt(1, i);
1:             ps.setString(2, insertString);   
1:             ps.executeUpdate();
1:             rollback();
1:         }
1:         ps.close();
1: 
1:         // until DERBY-4057 fixed expect space to be 2 pages per row plus
0:         // 1 head page per container.
0:         checkNumAllocatedPages("CLOBTAB3", (numrows * 2) + 1);
1: 
1:         // expect most free pages to get used by subsequent inserts.  Only 
1:         // free pages should be from the last remaining aborted insert of
1:         // the last clob chain.  It should include all of the clob except the
1:         // head page of the chain: (sizeof(clob) / page size) - 1
1:         // Derby should default to 32k page size for any table with a clob in
1:         // it.
1:  
0:         // (clob length / page size ) + 
1:         //     1 page for int divide round off - 1 for the head page.
0:         checkNumFreePages("CLOBTAB3", (clob_length / 32000) + 1 - 1);
1:         commit();
1: 
1:         // running inplace compress should reclaim all the remaining aborted
1:         // insert space, previous to fix inplace compress would leave stranded
1:         // allocated pages that were part of the clob overflow chains.
1:         CallableStatement call_compress =
1:             prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, 1, 1, 1)");
1: 
1:         call_compress.setString(1, "APP");
1:         call_compress.setString(2, "CLOBTAB3");
1:         call_compress.executeUpdate();
1: 
1:         // all space except for head page should be reclaimed.
0:         checkNumAllocatedPages("CLOBTAB3", 1);
1: 
1:         // should be no free pages after the inplace compress of a table with
1:         // all deleted rows.
1:         checkNumFreePages("CLOBTAB3", 0);
1:         commit();
1:     }
/////////////////////////////////////////////////////////////////////////
1:                 s.executeUpdate("CREATE TABLE CLOBTAB3 (I INT, C CLOB)");                
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4068b52
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:         return new CleanDatabaseTestSetup(suite) {
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.DEBUG_SET("DaemonTrace");
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:             protected void tearDown() throws Exception {
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.DEBUG_CLEAR("DaemonTrace");
1:                 }
1:                 super.tearDown();
1:             }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:f56c601
/////////////////////////////////////////////////////////////////////////
1:      * Two threads simultaneously updating a table. Threads each
0:      * update a separate row with a long value (>32K). NUMALLOCATED
1:      * pages should not grow past expected value after 500 updates
1:      * by each thread.
/////////////////////////////////////////////////////////////////////////
0:         checkNumAllocatedPages("CLOBTAB",expectedNumAllocated);
1:     }
1:     /**
1:      * Check that table has specified number of allocated pages.
1:      * 
1:      * @param table
1:      * @param expectedAlloc
1:      * @throws SQLException
1:      */
0:     private void checkNumAllocatedPages(String table, int expectedAlloc) throws SQLException {        
1: 
1:         PreparedStatement ps = prepareStatement("SELECT NUMALLOCATEDPAGES FROM "
1:                 + " new org.apache.derby.diag.SpaceTable('APP',?) t"
1:                 + " WHERE CONGLOMERATENAME = ?");
0:         ps.setString(1,table);
1:         ps.setString(2, table);
0:         ResultSet rs = ps.executeQuery();
0:                 + expectedAlloc } });
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure we reclaim space on rollback. Cannot enable this test 
1:      * until DERBY-4057 is fixed.
1:      * 
1:      * @throws SQLException
1:      */
0:     public void xtestReclamationOnRollback() throws SQLException {
1:         setAutoCommit(false);
1:         String insertString = Formatters.repeatChar("a", 33000);
1:         PreparedStatement ps = prepareStatement("INSERT INTO CLOBTAB2 VALUES(?,?)");
1:         for (int i = 0; i < 500; i++) {            
1:             ps.setInt(1, i);
1:             ps.setString(2, insertString);   
1:             ps.executeUpdate();
1:             rollback();
1:         }
0:         checkNumAllocatedPages("CLOBTAB2",1);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                 s.executeUpdate("CREATE TABLE CLOBTAB2 (I INT, C CLOB)");                
commit:ad8fd16
/////////////////////////////////////////////////////////////////////////
1:      * @param lockTable true if we should get an exclusive lock on the table
1:      * before update
1:      * @param updateSingleRow true if we should try updating a single row 
1:      * instead of different rows
1:      * 
1:     public void testMultiThreadedUpdate(final boolean lockTable, boolean updateSingleRow) throws SQLException,
/////////////////////////////////////////////////////////////////////////
1:             final int key = updateSingleRow ? 1 : i + 1;
/////////////////////////////////////////////////////////////////////////
1:         testMultiThreadedUpdate(false /* don't lock table */, false /*don't update single row*/);
/////////////////////////////////////////////////////////////////////////
1:         testMultiThreadedUpdate(true /*lock table */, false /* don't update single row */ );
1:     }
1:     
1:     /**
1:      * Test multiThreaded update of single row to cause lock contention
1:      * This will trigger the row lock retry case of DERBY-4055
1:      * 
1:      * @throws SQLException
1:      * @throws InterruptedException
1:      */
1:     public void xtestMultiThreadUpdateSingleRow() throws SQLException, InterruptedException {
1:         testMultiThreadedUpdate(false /*don't lock table */, true /* update single row */ );
commit:b514f88
/////////////////////////////////////////////////////////////////////////
0:     public void testMultiThreadedUpdate(final boolean lockTable) throws SQLException,
/////////////////////////////////////////////////////////////////////////
1:                         conn.setAutoCommit(false);
1:                                 updateString, key, lockTable);                      
/////////////////////////////////////////////////////////////////////////
1:             String updateString, int key, boolean lockTable) throws SQLException {
1:             if (lockTable) {
1:                 Statement s = conn.createStatement();
1:                 s.executeUpdate("LOCK TABLE CLOBTAB IN EXCLUSIVE MODE");
1:              }
1:             conn.commit();
1:     /**
1:      * Test multithreaded clob update using standard row locking
1:      * @throws SQLException
1:      * @throws InterruptedException
1:      */
1:     public void testMultiThreadedUpdateRowLocking() throws SQLException, InterruptedException {
0:         testMultiThreadedUpdate(false);
1:     }
1:     
1:     /**
1:      * Test multithreaded clob update but get an exclusive lock on the
1:      * table for each update. We can't enable this teset until DERBY-4054 
1:      * is fixed.
1:      * 
1:      * @throws SQLException
1:      * @throws InterruptedException
1:      */
1:     public void xtestMultiThreadedUpdateTableLocking() throws SQLException, InterruptedException {
0:         testMultiThreadedUpdate(true);
1:     }
1:     
commit:8f33dfd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.ClobReclamationTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.Properties;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Verify that space gets reclaimed for multi-threaded Clob updates
1:  * 
1:  */
1: public class ClobReclamationTest extends BaseJDBCTestCase {
1: 
1:     // Need to adjust NUM_THREADS and expectedNumAllocated.
1:     // For 2 threads expectedNumAllocated is 5
1:     // For 100 threads expectedNumAllocated is 201
1:     private static final int NUM_THREADS = 2;
1: 
1:     private static int expectedNumAllocated = 5;
1: 
1:     public ClobReclamationTest(String name) {
1:         super(name);
1: 
1:     }
1: 
1:     /**
0:      * Two threads simultaneously updating a table. Thread 1 updates row 1 with
0:      * a long value (>32K) Thread 2 updates row with a short clob ("hello");
0:      * NUMALLOCATEDPAGES should be only 3 after each does 500 updates
1:      * 
1:      * @throws SQLException
1:      * @throws InterruptedException
1:      */
0:     public void testMultiThreadedUpdate() throws SQLException,
1:             InterruptedException {
1:         // need to do a getConnection or we get a
1:         // junit assertion that driver is not registered.
1:         Connection conn = getConnection();
1:         final String updateString = Formatters.repeatChar("a", 33000);
1:         Thread[] threads = new Thread[NUM_THREADS];
1:         for (int i = 0; i < NUM_THREADS; i++) {
0:             final int key = i + 1;
1:             threads[i] = new Thread() {
1:                 public void run() {
1:                     try {
1:                         Connection conn = openDefaultConnection();
1:                         ClobReclamationTest.fiveHundredUpdates(conn,
0:                                 updateString, key);
1:                     } catch (SQLException e) {
1:                         fail(e.getMessage());
1:                     }
1:                 }
1:             };
1:         }
1:         for (int i = 0; i < NUM_THREADS; i++) {
1:             threads[i].start();
1:         }
1:         for (int i = 0; i < NUM_THREADS; i++) {
1:             threads[i].join();
1:         }
1: 
0:         Statement s = createStatement();
1:         // Check the space table 
1:         // Should not have grown.
0:         ResultSet rs = s.executeQuery("SELECT NUMALLOCATEDPAGES FROM "
0:                 + " new org.apache.derby.diag.SpaceTable('APP','CLOBTAB') t"
0:                 + " WHERE CONGLOMERATENAME = 'CLOBTAB'");
0:         JDBC.assertFullResultSet(rs, new String[][] { { ""
0:                 + expectedNumAllocated } });
1:     }
1: 
1:     private static void fiveHundredUpdates(Connection conn,
0:             String updateString, int key) throws SQLException {
1:         PreparedStatement ps = conn
1:                 .prepareStatement("UPDATE CLOBTAB SET C = ? WHERE I = ?");
1:         for (int i = 0; i < 500; i++) {
1:             ps.setString(1, updateString);
1:             ps.setInt(2, key);
1:             ps.executeUpdate();
1:         }
1:     }
1: 
1:     public static Test suite() {
1: 
0:         Properties sysProps = new Properties();
0:         sysProps.put("derby.debug.true", "DaemonTrace");
1:         Test suite = TestConfiguration.embeddedSuite(ClobReclamationTest.class);
0:         return new CleanDatabaseTestSetup(new SystemPropertyTestSetup(suite,
0:                 sysProps, true)) {
1:             /**
1:              * Creates the table used in the test cases.
1:              * 
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 Connection conn = s.getConnection();
1:                 s
1:                         .executeUpdate("CREATE TABLE CLOBTAB (I INT  PRIMARY KEY NOT NULL, c CLOB)");
1:                 PreparedStatement ps = conn
1:                         .prepareStatement("INSERT INTO CLOBTAB VALUES(?,?)");
1:                 String insertString = "hello";
1:                 for (int i = 1; i <= NUM_THREADS; i++) {
1:                     ps.setInt(1, i);
1:                     ps.setString(2, insertString);
1:                     ps.executeUpdate();
1:                 }
1:             }
1: 
1:         };
1: 
1:     }
1: }
============================================================================