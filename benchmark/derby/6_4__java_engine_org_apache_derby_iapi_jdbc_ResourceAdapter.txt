1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.jdbc.ResourceAdapter
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.jdbc;
1:eac0369: 
1:bb9f97a: import javax.transaction.xa.XAException;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1:eac0369: import org.apache.derby.iapi.store.access.xa.XAXactId;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
3:eac0369: /**
1:eac0369: 	The resource adapter is the clearing house for managing connections,
1:eac0369: 	transactions, and XAResources in a JDBC based resource manager living in
1:eac0369: 	the distributed transaction processing environment.  
1:eac0369: 
1:eac0369: 	<P> There is one instance of ResourceAdapter per Resource Manager (database).
1:eac0369: 	The ResourceAdapter is responsible for keeping track of all run time global
1:eac0369: 	transactions and their state.   The resource adapter only knows of run time
1:eac0369: 	global transactions, i.e., it does not know of in-doubt global transactions
1:eac0369: 	re-created by recovery.
1:eac0369: 
1:3fd26f3: 	<P>	The following is an overall design of the JTA implementation in Derby,
1:eac0369: 	most of it has little to do with the ResourceAdapter interface itself.
1:eac0369: 	<P><B>Design Overview </B>
1:eac0369: 
1:eac0369: 	<P>The overriding design principle is that existing code should be disturbed
1:eac0369: 	as little as possible.  This is so that DTP code will not add to the bloat
1:eac0369: 	and drag of a normal, local, embbeded system.  The second design principle
1:eac0369: 	is that as much of the JDBC 2.0 extension functionality is to be
1:eac0369: 	implemented in the Connectivity layer and not in the underlying storage
1:eac0369: 	system as possible.  Ideally, the additional storage interface will
1:eac0369: 	implement no more than what is necessary to support the XAResource
1:eac0369: 	interface.
1:eac0369: 
1:eac0369: 	<P>Language and replication code should not be touched, or have very
1:eac0369: 	minimal API changes.  The API changes are confined to passing XA calls down
1:eac0369: 	to the store.
1:eac0369: 
1:eac0369: 	<P>Some change will be made to existing Connectivity code and new XA
1:eac0369: 	modules will be added.  This collection of code is hereby referred to as
1:eac0369: 	the "blob of mysterious connectivity code", or the "resource adapter", or
1:eac0369: 	"RA" for short.  In the JTA doc, the resource adapter is considered to be
1:eac0369: 	part of the JDBC driver.  This RA means "some connectivity code", it
1:eac0369: 	doesn't mean the object that implements the ResourceAdapter interface.
1:eac0369: 
1:eac0369: 	<P>The most important difference, in terms of implementation, between a
1:eac0369: 	Connection that deals with a local transaction and a Connection that deals
1:eac0369: 	with a global transaction is that in a global transaction, 2 or more
1:eac0369: 	objects and threads can influence it - maybe concurrently.  The normal JDBC
1:eac0369: 	interaction goes thru the Connection, but transaction demarcation comes
1:eac0369: 	from an XAResource object(s).  The RA will channel all XAResource calls
1:eac0369: 	that deal with a run time XA transaction (i.e., commit, end, forget,
1:eac0369: 	prepare, start) thru the TransactionController that represents the real
1:eac0369: 	transaction underneath.   Furthermore, the RA will make sure that all calls
1:eac0369: 	thru a Connection or thru any XAResource objects must pass thru some sort
1:eac0369: 	of synchronized object before it can get to the underlying transaction
1:eac0369: 	object.  This is so that there is only one path to change the state of a
1:eac0369: 	run time transaction and the transaction object and the context manager can
1:eac0369: 	remain single thread access.
1:eac0369: 
1:eac0369: 	<P>In-doubt transaction (i.e., transactions re-created by recovery)
1:eac0369: 	management and concurrency control is the responsibiliy of store. Moreover,
1:eac0369: 	since the RA does not know the identities of the list of in-doubt
1:eac0369: 	transactions, store must deal with (throw exception) when someone wants to
1:eac0369: 	start a transaction with the same Xid as an existing in-doubt transaction.
1:eac0369: 
1:eac0369: 	<P>In terms of what this means to the app server that is calling us: if the
1:eac0369: 	Connection and the XAResource that represents a global transaction is being
1:eac0369: 	accessed by 2 different threads, they will access the database serially and
1:eac0369: 	not concurrently. An in-doubt transaction gotten thru recovery has no
1:eac0369: 	transaction object that is ever visible to the RA - because there is no
1:eac0369: 	connection that was ever made to it.  Therefore it is safe to influence the
1:eac0369: 	state of an in-doubt transaction directly thru some store factory interface
1:eac0369: 	- and have that go thru the transaction table underneath to find the actual
1:eac0369: 	transaction object and context manager etc.
1:eac0369: 
1:eac0369: 	<P>One new functionality of a Connection is the ability to switch around
1:eac0369: 	with different transactions.  Before JTA, the lifetime of a transaction is
1:eac0369: 	bounded by a connection, and a transaction cannot migrate from one
1:eac0369: 	connection to another.  In JTA, a global transaction can be detached from a
1:eac0369: 	Connection.  A transaction can move around and be attached to different
1:eac0369: 	connections and its lifetime is not confine to the connection that started
1:eac0369: 	it.  From the Connection's point of view, before JTA, a (local) transaction
1:eac0369: 	is always started and ended in the same connection. With JTA, it needs to
1:eac0369: 	"take on" existing global transactions that was started by some other
1:eac0369: 	connections.
1:eac0369: 
1:eac0369: 	<P>The RA will have the responsibility of 
1:eac0369: 	<OL>
1:eac0369: 	<LI>setting up a Context with the appropriate transaction before calling
1:eac0369: 	store to do work.</LI>
1:eac0369: 	<LI>handling error on the context.</LI>
1:eac0369: 	<LI>restoring a previous context if it was switched out due to an XAResouce
1:eac0369: 	call to commit a transaction that is not what the XAResoruce is currently
1:eac0369: 	attached to. </LI>
1:eac0369: 	</OL>
1:eac0369: 
1:eac0369: 	<P>Because of all these switching around, a Connection may be in a
1:eac0369: 	transaction-less state.  This happens between an XAResource.end call that
1:eac0369: 	detached the current global transaction from the Connection, and the next
1:eac0369: 	XAResource.start call that attach the next global transaction with the
1:eac0369: 	Connection.
1:eac0369: 
1:eac0369: 	<BR>An (inferior) implementation is for the Connection object to start a
1:eac0369: 	local connection once it is detached from a global transaction.  If the
1:eac0369: 	user then uses the Connection immediately without a XAResource.start call,
1:eac0369: 	then this Connection behaves just like it did before JTA, i.e., with a
1:eac0369: 	local transaction.  If, on the other hand, an XAResource.start call happens
1:eac0369: 	next, then either the local transaction is "morphed" into a global
1:eac0369: 	transaction, or, if the start call is to attach the connection to a
1:eac0369: 	pre-existing global transaction, then the local transaction is thrown away
1:eac0369: 	and the Connection will take on the pre-exising global transaction.
1:eac0369: 
1:eac0369: 	<BR>Another (superior) implementation is to make it possible for a
1:eac0369: 	Connection to be transaction-less.  When a Connection is first created by
1:eac0369: 	XAConnection.getConnection, or when a XAResource.end call detached a global
1:eac0369: 	transaction from the Connection, it is left in a transaction-less state.
1:eac0369: 	If a XAResource.start call happens next, then the Connection either start a
1:eac0369: 	new global transaction or it takes on an existing one.  If a call is made
1:eac0369: 	directly on the Connection before XAResource.start call happens, then the
1:eac0369: 	Connection starts a new local transaction.  This only affects Connections
1:eac0369: 	that was gotten thru the XAConnection.getConnection().  Connections gotten
1:eac0369: 	thru the DriverManager or a DataSource will have a local transaction
1:eac0369: 	automatically started, as is the behavior today.  When a Connection with a
1:eac0369: 	local transaction commits, the transaction is still around but it is chain
1:eac0369: 	to the next one - this is the current behavior.  This behavior is very
1:eac0369: 	desirable from a performance point of view, so it should be retained.
1:eac0369: 	However, a local transaction cannot "morph" into a global transaction,
1:eac0369: 	therefore when this Connection is attached to a global transaction, the
1:eac0369: 	local transaction is thrown away and a global one started
1:eac0369: 
1:eac0369: 	<P>The RA will need to keep track of all global transactions.  This is done
1:eac0369: 	by (yet another) transaction table that lives in the RA.  This transaction
1:eac0369: 	table maps Xid to the ContextManager of the global transaction and whatever
1:eac0369: 	else a connection needs to talk to the transaction - I assume the
1:eac0369: 	Connection object currently have tendrils into various contexts and objects
1:eac0369: 	and these are things that need to be detached and attached when a
1:eac0369: 	Connection is hooked up with another transaction.  The reason for yet
1:eac0369: 	another transaction table instead of the one in store is because the one in
1:eac0369: 	store keeps track of local and internal transactions and is really quite
1:eac0369: 	overworked already.
1:eac0369: 
1:eac0369: 	<P><B>Detailed design</B>
1:eac0369: 
1:eac0369: 	<BR> First some ugly pictures.  Some links are not shown to reduce
1:eac0369: 	clutter.  Externally visible object is in <B>bold</B>.
1:eac0369:   
1:eac0369: 	<P><PRE>
1:eac0369: * 
1:eac0369: * When user ask for an XAConnection via a XADataSource, the following objects
1:eac0369: * exists 
1:eac0369: * <BR>
1:eac0369: *
1:eac0369: *                                                     |-------------|
1:dbed020: *                                  |======= produces=&gt;| <B>XAResource</B>  |
1:eac0369: *                                  ||                 |-------------|
1:eac0369: *                                  ||                       |
1:eac0369: *                                  ||                     has A
1:eac0369: *                                  ||                       |
1:eac0369: *                                  ||  |---------------------
1:eac0369: *                                  ||  V
1:eac0369: * |--------------| produces |--------------| 
1:dbed020: * | <B>XADataSource</B> |=========&gt;| <B>XAConnection</B>
1:eac0369: * |--------------|          |--------------| 
1:eac0369: *       |                          | 
1:eac0369: *     extends                    extends
1:eac0369: *       |                          | 
1:eac0369: *       |                |-----------------------|   |----------------------|
1:dbed020: *       |                | DB2jPooledConnection |==&gt;| BrokeredConnection |
1:eac0369: *       |                |-----------------------|   |----------------------|
1:eac0369: *       |                          |       ^                  |
1:eac0369: *       |                        has A     |               has A
1:eac0369: *       |                          |       |                  |
1:eac0369: * |-----------------|              |       --------------------
1:eac0369: * | EmbeddedDataSource |              |
1:eac0369: * |-----------------|              |
1:eac0369: *       |                          |
1:eac0369: *     has A                        |
1:eac0369: *       |                          |
1:eac0369: *       V                          V
1:eac0369: * |------------|           |----------------------|   |-----------------------|
1:dbed020: * | JDBCDriver |=produces=&gt;| DetachableConnection |==&gt;| XATransactionResource |
1:eac0369: * | LocalDriver|           |----------------------|   |                       |
1:eac0369: * |------------|                   |                  |   points to :         |
1:eac0369: *                                  |                  |XATransactionController|
1:eac0369: *                                  |                  | ContextManager        |
1:eac0369: *                                  |                  | LCC                   |
1:eac0369: *                                  |                  | .. etc ..             |
1:eac0369: *                                  |                  |-----------------------| 
1:eac0369: *                                  |                            |
1:eac0369: *                                extends                     extends
1:eac0369: *                                  |                            |
1:eac0369: *                           |-----------------|       |-----------------------|
1:dbed020: *                           | EmbedConnection |-- ?--&gt;|  TransactionResource  |
1:eac0369: *                           |-----------------|       |-----------------------|
1:eac0369: *
1:eac0369: * 
1:eac0369: * <BR><BR>
1:eac0369: * When user ask for a PooledConnection via a PooledDataSource, the following
1:eac0369: * objects exists 
1:eac0369: * <BR>
1:eac0369: * |-------------------------------|
1:eac0369: * | <B>EmbeddedConnectionPoolDataSource</B> |
1:eac0369: * |-------------------------------|
1:eac0369: *       |                  ||
1:eac0369: *       |                  ||
1:eac0369: *     extends             produces
1:eac0369: *       |                  ||
1:eac0369: *       |                  \/
1:eac0369: *       |                |-----------------------|   |----------------------|
1:dbed020: *       |                | <B>DB2jPooledConnection</B> |==&gt;| <B>BrokeredConnection</B> |
1:eac0369: *       |                |-----------------------|   |----------------------|
1:eac0369: *       |                          |       ^                  |
1:eac0369: *       |                        has A     |               has A
1:eac0369: *       |                          |       |                  |
1:eac0369: * |-----------------|              |       --------------------
1:eac0369: * | EmbeddedDataSource |              |
1:eac0369: * |-----------------|              |
1:eac0369: *       |                          |
1:eac0369: *     has A                        |
1:eac0369: *       |                          |
1:eac0369: *       V                          V
1:eac0369: * |------------|           |----------------------|   |-----------------------|
1:dbed020: * | JDBCDriver |=produces=&gt;| EmbedConnection |==&gt;|  TransactionResource  |
1:eac0369: * | LocalDriver|           |----------------------|   |-----------------------|
1:eac0369: * |------------| 
1:eac0369: * 
1:eac0369: * 
1:eac0369: * 
1:eac0369: * <BR><BR>
1:eac0369: * When user ask for a (normal) Connection via a DataSource, the following
1:eac0369: * objects exists. The EmbeddedDataSource is just a wrapper for the JDBCDriver.
1:eac0369: * <BR>
1:eac0369: * |-----------------|
1:eac0369: * | <B>EmbeddedDataSource</B> |
1:eac0369: * |-----------------|
1:eac0369: *       |
1:eac0369: *     has A
1:eac0369: *       |
1:eac0369: *       V
1:eac0369: * |------------|            |-----------------|     |-----------------------|
1:dbed020: * | JDBCDriver |==produces=&gt;| <B>EmbedConnection</B> |- ?-&gt;| TransactionResource   |
1:eac0369: * | LocalDriver|            |-----------------|     |-----------------------|
1:eac0369: * |------------|
1:eac0369: 
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369: 	<P>XADataSource inherits DataSource methods from EmbeddedDataSource.  It also
1:eac0369: 	implements ResourceAdapter, whose main job is to keep track of run time
1:eac0369: 	global transactions.  A global transaction table maps XIDs to
1:eac0369: 	XATransactionResource.  XADataSource also has a XAResourceManager, which 
1:eac0369: 	implements XAResource functionality in the Store.
1:eac0369: 	
1:eac0369: 	<P>XAConnection is the one thing that unites a global connection and the
1:eac0369: 	XAResource that delineates the global transaction.  This is where the real
1:eac0369: 	XAResource functionality is implemented.  All XAResource calls to the
1:eac0369: 	XAResource object as well as Connection call to the BrokeredConnection
1:eac0369: 	channels thrus the XAConnection, which makes sure only one thread can be
1:eac0369: 	accessing the DB2jPooledConnection at any given time.
1:eac0369: 
1:eac0369: 	<P>XAResource and BrokeredConnection[23]0 are the two objects we give back
1:eac0369: 	to the TM and the user application respectively to control a distributed
1:eac0369: 	transaction.  According to the XA spec, the app server is supposed to make
1:eac0369: 	sure that these objects are not used the same time by multiple threads, but
1:eac0369: 	we don't trust the app server.  Therefore, we channel everthing back to the
1:eac0369: 	XAConnection.
1:eac0369: 
1:eac0369: 	<P>The MT consideration is actually more complicated than this,
1:eac0369: 	because a XAResource is allowed to control any transaction, not just the
1:eac0369: 	one its XAConnection is current attached to.  So it is not sufficient to
1:eac0369: 	just synchronized on XAConnection to guarentee single thread access to the
1:eac0369: 	underlying transaction context.  To control some arbitrary global
1:eac0369: 	transaction, the TM can call XAResource to prepare any Xid.  To do that,
1:eac0369: 	the XAResource pass the request to the XAConnection, the XAConnection ask
1:eac0369: 	the XADataSource to find the XATransactionResource, sets up the thread's
1:eac0369: 	context, and call ask the XATransactionResource to prepare.  The
1:eac0369: 	XATransactionResource is synchronized to prevent some other thread from
1:eac0369: 	attaching, commiting, and in any way calling on the the same transaction
1:eac0369: 	context.  If any error is thrown, it is handled with the context of the
1:eac0369: 	transaction being prepared.  After the error is handled, the old context
1:eac0369: 	(the one where the XAResource is really attached to), is restored.  While
1:eac0369: 	this monkey business is going on, the thread that holds the connection the
1:eac0369: 	XAConnection is supposed to be attached to is blocked out.  It can resume
1:eac0369: 	after its XAConnection restored its context.  (Here is where I am not
1:eac0369: 	really sure what happens since that thread obviously doesn't know about all
1:eac0369: 	these hanky panky caused by the thread holding the XAResource commiting,
1:eac0369: 	preparing and rolling back some other irrelavant transactions, so how would
1:eac0369: 	its context be affected in any way?).
1:eac0369: 
1:eac0369: 	<P>DB2jPooledConnection implements PooledConnection, is hands out these
1:eac0369: 	connection handles which allows some app server to do connection pooling.
1:eac0369: 	This is a very thin layer.  A connection handle implements a Connection by
1:eac0369: 	passing thru all calls to the underlaying connection.  In this case, it
1:eac0369: 	passes Connection call thru the DB2jPooledConnection to the
1:eac0369: 	DetachableConnection underneath.
1:eac0369: 
1:eac0369: 	<P>EmbeddedDataSource implements JNDI and is a replacement for Driver.
1:eac0369: 
1:eac0369: 	<P>The LocalDriver can now produce a DetachableConnection as well as a
1:eac0369: 	EmbedConnection (which is the pre-JTA Connection that cannot detach and
1:eac0369: 	attach to different transactions).  The way the LocalDriver knows to create
1:eac0369: 	a DetachableConnection versus a EmbedConnection is thru some extremely
1:eac0369: 	hackish URL settings.  This thing is very ugly and a more elegant way can
1:eac0369: 	(and should) no doubt be found.
1:eac0369: 
1:eac0369: 	<P>DetachableConnection is a connection which can detach and attach to
1:eac0369: 	different XATransactionResource, and can be totally unattached to any
1:eac0369: 	transaction.
1:eac0369: 
1:eac0369: 	<P>XATransactionResource is a bundle of things that sets up a connection
1:eac0369: 	with all the stuff it needs to actually talk to the database, do error
1:eac0369: 	handling, etc.  It is also the object that lives in the transaction table
1:eac0369: 	managed by the ResourceAdapter (XADataSource).  A XAResource (which may or
1:eac0369: 	may not be attached to a transaction) can commit, prepare, or rollback any
1:eac0369: 	global transaction that is not attached to an XAConnection.  To do that,
1:eac0369: 	the ResourceAdapter fishes out the XATransactionResource, set up the
1:eac0369: 	context, and do the commit processing/error handling on the current
1:eac0369: 	thread.
1:eac0369: 
1:eac0369: 	<P>Local Connection is the same old local Connection except one
1:eac0369: 	difference.  Pre-JTA, a localConnection uses itself (or a root Connection)
1:eac0369: 	as the object to synchronized upon so that multiple threads getting hold of
1:eac0369: 	the same Connection object cannot simultaneously issue calls to the
1:eac0369: 	underlying transaction or context (since those things must be single thread
1:eac0369: 	access).  With JTA, the object of synchronization is the
1:eac0369: 	TransactionResource itself.  This part has not been well thought through
1:eac0369: 	and is probably wrong.
1:eac0369: 
1:eac0369: 	<P>TransactionResource is a base class for XATransactionResource.  For a
1:eac0369: 	local transaction which cannot be detached from a connection, there is no
1:eac0369: 	need to encapsulate a bundle of things to set up a connection, so a
1:eac0369: 	TransactionResource (probably misnamed) has nothing and is used only for
1:eac0369: 	synchronization purposes.  This part has not been well thought throught and
1:eac0369: 	is probably wrong. 
1:eac0369: 
1:eac0369: 	<P>The non-XA PooledConnection is just a thin veneer over the normal
1:eac0369: 	connection.  I now have it over a Detachable connection just to simplify
1:eac0369: 	the inheritence (XAConnection need to extend PooledConnection and XAConnect
1:eac0369: 	needs to be detachable.  However, PooledConnection itself need not be
1:eac0369: 	detachable).  It could be changed around to have LocalDriver producing
1:eac0369: 	either EmbedConnection or XAConnection, and have the XAConnection
1:eac0369: 	implements detachable.  But the current way is simpler.
1:eac0369: 
1:eac0369:  */
1:eac0369: public interface ResourceAdapter {
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		If a run time global transaction exists, the resource adapter will find
1:eac0369: 		it and return a capsule of information so that a Connection can be
1:eac0369: 		attached to the transaction. 
1:eac0369: 
1:eac0369: 		@param xid the global transaction id
1:eac0369: 		@return the transaction resource if the xid correspond to a run
1:eac0369: 		time transaction, otherwise return null
1:eac0369: 	 */
1:eac0369: 	//XATransactionResource findTransaction(XAXactId xid);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Start a run time global transaction.  Add this to the list of
1:eac0369: 		transactions managed by this resource adapter.
1:eac0369: 
1:eac0369: 		@return true if transaction can be added, otherwise false (dupid).
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	//boolean addTransaction(XATransactionResource tr);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Terminates a run time global transction.  Remove this from the list of
1:eac0369: 		transactions managed by this resource adapter.
1:eac0369: 	 */
1:eac0369: 	//void removeTransaction(XATransactionResource tr);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Let a xaResource get the XAResourceManager to commit or rollback an
1:eac0369: 		in-doubt transaction.
1:eac0369: 	 */
1:eac0369: 	XAResourceManager getXAResourceManager();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the context service factory.
1:eac0369: 	 */
1:eac0369: 	//ContextService getContextServiceFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Is the Resource Manager active
1:eac0369: 	 */
1:eac0369: 	boolean isActive();
1:eac0369: 
1:eac0369: 	public Object findConnection(XAXactId xid);
1:eac0369: 
1:eac0369: 	public boolean addConnection(XAXactId xid, Object conn);
1:eac0369: 
1:eac0369: 	public Object removeConnection(XAXactId xid);
1:eac0369: 
1:bb9f97a: 	/**
1:bb9f97a: 	 * Cancel the XA transaction identified by the specified xid.  The
1:bb9f97a: 	 * method will atomically cancel any running statement on behalf
1:bb9f97a: 	 * of the transaction, end the transaction association with the
1:bb9f97a: 	 * XAResource instance, and rollback of the global transaction.
1:bb9f97a: 	 * @param xid tranaction id to cancel
1:bb9f97a: 	 * @param messageId error to report when canceling
1:bb9f97a: 	 */
1:bb9f97a: 	public void cancelXATransaction(XAXactId xid, String messageId) 
1:bb9f97a: 		throws XAException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: *                                  |======= produces=&gt;| <B>XAResource</B>  |
/////////////////////////////////////////////////////////////////////////
1: * | <B>XADataSource</B> |=========&gt;| <B>XAConnection</B>
1: *       |                | DB2jPooledConnection |==&gt;| BrokeredConnection |
/////////////////////////////////////////////////////////////////////////
1: * | JDBCDriver |=produces=&gt;| DetachableConnection |==&gt;| XATransactionResource |
/////////////////////////////////////////////////////////////////////////
1: *                           | EmbedConnection |-- ?--&gt;|  TransactionResource  |
/////////////////////////////////////////////////////////////////////////
1: *       |                | <B>DB2jPooledConnection</B> |==&gt;| <B>BrokeredConnection</B> |
/////////////////////////////////////////////////////////////////////////
1: * | JDBCDriver |=produces=&gt;| EmbedConnection |==&gt;|  TransactionResource  |
/////////////////////////////////////////////////////////////////////////
1: * | JDBCDriver |==produces=&gt;| <B>EmbedConnection</B> |- ?-&gt;| TransactionResource   |
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:bb9f97a
/////////////////////////////////////////////////////////////////////////
1: import javax.transaction.xa.XAException;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Cancel the XA transaction identified by the specified xid.  The
1: 	 * method will atomically cancel any running statement on behalf
1: 	 * of the transaction, end the transaction association with the
1: 	 * XAResource instance, and rollback of the global transaction.
1: 	 * @param xid tranaction id to cancel
1: 	 * @param messageId error to report when canceling
1: 	 */
1: 	public void cancelXATransaction(XAXactId xid, String messageId) 
1: 		throws XAException;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 	<P>	The following is an overall design of the JTA implementation in Derby,
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.jdbc.ResourceAdapter
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:217667e
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.jdbc;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1: import org.apache.derby.iapi.store.access.xa.XAXactId;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: /**
1: 	The resource adapter is the clearing house for managing connections,
1: 	transactions, and XAResources in a JDBC based resource manager living in
1: 	the distributed transaction processing environment.  
1: 
1: 	<P> There is one instance of ResourceAdapter per Resource Manager (database).
1: 	The ResourceAdapter is responsible for keeping track of all run time global
1: 	transactions and their state.   The resource adapter only knows of run time
1: 	global transactions, i.e., it does not know of in-doubt global transactions
1: 	re-created by recovery.
1: 
0: 	<P>	The following is an overall design of the JTA implementation in cloudscape,
1: 	most of it has little to do with the ResourceAdapter interface itself.
1: 	<P><B>Design Overview </B>
1: 
1: 	<P>The overriding design principle is that existing code should be disturbed
1: 	as little as possible.  This is so that DTP code will not add to the bloat
1: 	and drag of a normal, local, embbeded system.  The second design principle
1: 	is that as much of the JDBC 2.0 extension functionality is to be
1: 	implemented in the Connectivity layer and not in the underlying storage
1: 	system as possible.  Ideally, the additional storage interface will
1: 	implement no more than what is necessary to support the XAResource
1: 	interface.
1: 
1: 	<P>Language and replication code should not be touched, or have very
1: 	minimal API changes.  The API changes are confined to passing XA calls down
1: 	to the store.
1: 
1: 	<P>Some change will be made to existing Connectivity code and new XA
1: 	modules will be added.  This collection of code is hereby referred to as
1: 	the "blob of mysterious connectivity code", or the "resource adapter", or
1: 	"RA" for short.  In the JTA doc, the resource adapter is considered to be
1: 	part of the JDBC driver.  This RA means "some connectivity code", it
1: 	doesn't mean the object that implements the ResourceAdapter interface.
1: 
1: 	<P>The most important difference, in terms of implementation, between a
1: 	Connection that deals with a local transaction and a Connection that deals
1: 	with a global transaction is that in a global transaction, 2 or more
1: 	objects and threads can influence it - maybe concurrently.  The normal JDBC
1: 	interaction goes thru the Connection, but transaction demarcation comes
1: 	from an XAResource object(s).  The RA will channel all XAResource calls
1: 	that deal with a run time XA transaction (i.e., commit, end, forget,
1: 	prepare, start) thru the TransactionController that represents the real
1: 	transaction underneath.   Furthermore, the RA will make sure that all calls
1: 	thru a Connection or thru any XAResource objects must pass thru some sort
1: 	of synchronized object before it can get to the underlying transaction
1: 	object.  This is so that there is only one path to change the state of a
1: 	run time transaction and the transaction object and the context manager can
1: 	remain single thread access.
1: 
1: 	<P>In-doubt transaction (i.e., transactions re-created by recovery)
1: 	management and concurrency control is the responsibiliy of store. Moreover,
1: 	since the RA does not know the identities of the list of in-doubt
1: 	transactions, store must deal with (throw exception) when someone wants to
1: 	start a transaction with the same Xid as an existing in-doubt transaction.
1: 
1: 	<P>In terms of what this means to the app server that is calling us: if the
1: 	Connection and the XAResource that represents a global transaction is being
1: 	accessed by 2 different threads, they will access the database serially and
1: 	not concurrently. An in-doubt transaction gotten thru recovery has no
1: 	transaction object that is ever visible to the RA - because there is no
1: 	connection that was ever made to it.  Therefore it is safe to influence the
1: 	state of an in-doubt transaction directly thru some store factory interface
1: 	- and have that go thru the transaction table underneath to find the actual
1: 	transaction object and context manager etc.
1: 
1: 	<P>One new functionality of a Connection is the ability to switch around
1: 	with different transactions.  Before JTA, the lifetime of a transaction is
1: 	bounded by a connection, and a transaction cannot migrate from one
1: 	connection to another.  In JTA, a global transaction can be detached from a
1: 	Connection.  A transaction can move around and be attached to different
1: 	connections and its lifetime is not confine to the connection that started
1: 	it.  From the Connection's point of view, before JTA, a (local) transaction
1: 	is always started and ended in the same connection. With JTA, it needs to
1: 	"take on" existing global transactions that was started by some other
1: 	connections.
1: 
1: 	<P>The RA will have the responsibility of 
1: 	<OL>
1: 	<LI>setting up a Context with the appropriate transaction before calling
1: 	store to do work.</LI>
1: 	<LI>handling error on the context.</LI>
1: 	<LI>restoring a previous context if it was switched out due to an XAResouce
1: 	call to commit a transaction that is not what the XAResoruce is currently
1: 	attached to. </LI>
1: 	</OL>
1: 
1: 	<P>Because of all these switching around, a Connection may be in a
1: 	transaction-less state.  This happens between an XAResource.end call that
1: 	detached the current global transaction from the Connection, and the next
1: 	XAResource.start call that attach the next global transaction with the
1: 	Connection.
1: 
1: 	<BR>An (inferior) implementation is for the Connection object to start a
1: 	local connection once it is detached from a global transaction.  If the
1: 	user then uses the Connection immediately without a XAResource.start call,
1: 	then this Connection behaves just like it did before JTA, i.e., with a
1: 	local transaction.  If, on the other hand, an XAResource.start call happens
1: 	next, then either the local transaction is "morphed" into a global
1: 	transaction, or, if the start call is to attach the connection to a
1: 	pre-existing global transaction, then the local transaction is thrown away
1: 	and the Connection will take on the pre-exising global transaction.
1: 
1: 	<BR>Another (superior) implementation is to make it possible for a
1: 	Connection to be transaction-less.  When a Connection is first created by
1: 	XAConnection.getConnection, or when a XAResource.end call detached a global
1: 	transaction from the Connection, it is left in a transaction-less state.
1: 	If a XAResource.start call happens next, then the Connection either start a
1: 	new global transaction or it takes on an existing one.  If a call is made
1: 	directly on the Connection before XAResource.start call happens, then the
1: 	Connection starts a new local transaction.  This only affects Connections
1: 	that was gotten thru the XAConnection.getConnection().  Connections gotten
1: 	thru the DriverManager or a DataSource will have a local transaction
1: 	automatically started, as is the behavior today.  When a Connection with a
1: 	local transaction commits, the transaction is still around but it is chain
1: 	to the next one - this is the current behavior.  This behavior is very
1: 	desirable from a performance point of view, so it should be retained.
1: 	However, a local transaction cannot "morph" into a global transaction,
1: 	therefore when this Connection is attached to a global transaction, the
1: 	local transaction is thrown away and a global one started
1: 
1: 	<P>The RA will need to keep track of all global transactions.  This is done
1: 	by (yet another) transaction table that lives in the RA.  This transaction
1: 	table maps Xid to the ContextManager of the global transaction and whatever
1: 	else a connection needs to talk to the transaction - I assume the
1: 	Connection object currently have tendrils into various contexts and objects
1: 	and these are things that need to be detached and attached when a
1: 	Connection is hooked up with another transaction.  The reason for yet
1: 	another transaction table instead of the one in store is because the one in
1: 	store keeps track of local and internal transactions and is really quite
1: 	overworked already.
1: 
1: 	<P><B>Detailed design</B>
1: 
1: 	<BR> First some ugly pictures.  Some links are not shown to reduce
1: 	clutter.  Externally visible object is in <B>bold</B>.
1:   
1: 	<P><PRE>
1: * 
1: * When user ask for an XAConnection via a XADataSource, the following objects
1: * exists 
1: * <BR>
1: *
1: *                                                     |-------------|
0: *                                  |======= produces=>| <B>XAResource</B>  |
1: *                                  ||                 |-------------|
1: *                                  ||                       |
1: *                                  ||                     has A
1: *                                  ||                       |
1: *                                  ||  |---------------------
1: *                                  ||  V
1: * |--------------| produces |--------------| 
0: * | <B>XADataSource</B> |=========>| <B>XAConnection</B>
1: * |--------------|          |--------------| 
1: *       |                          | 
1: *     extends                    extends
1: *       |                          | 
1: *       |                |-----------------------|   |----------------------|
0: *       |                | DB2jPooledConnection |==>| BrokeredConnection |
1: *       |                |-----------------------|   |----------------------|
1: *       |                          |       ^                  |
1: *       |                        has A     |               has A
1: *       |                          |       |                  |
1: * |-----------------|              |       --------------------
1: * | EmbeddedDataSource |              |
1: * |-----------------|              |
1: *       |                          |
1: *     has A                        |
1: *       |                          |
1: *       V                          V
1: * |------------|           |----------------------|   |-----------------------|
0: * | JDBCDriver |=produces=>| DetachableConnection |==>| XATransactionResource |
1: * | LocalDriver|           |----------------------|   |                       |
1: * |------------|                   |                  |   points to :         |
1: *                                  |                  |XATransactionController|
1: *                                  |                  | ContextManager        |
1: *                                  |                  | LCC                   |
1: *                                  |                  | .. etc ..             |
1: *                                  |                  |-----------------------| 
1: *                                  |                            |
1: *                                extends                     extends
1: *                                  |                            |
1: *                           |-----------------|       |-----------------------|
0: *                           | EmbedConnection |-- ?-->|  TransactionResource  |
1: *                           |-----------------|       |-----------------------|
1: *
1: * 
1: * <BR><BR>
1: * When user ask for a PooledConnection via a PooledDataSource, the following
1: * objects exists 
1: * <BR>
1: * |-------------------------------|
1: * | <B>EmbeddedConnectionPoolDataSource</B> |
1: * |-------------------------------|
1: *       |                  ||
1: *       |                  ||
1: *     extends             produces
1: *       |                  ||
1: *       |                  \/
1: *       |                |-----------------------|   |----------------------|
0: *       |                | <B>DB2jPooledConnection</B> |==>| <B>BrokeredConnection</B> |
1: *       |                |-----------------------|   |----------------------|
1: *       |                          |       ^                  |
1: *       |                        has A     |               has A
1: *       |                          |       |                  |
1: * |-----------------|              |       --------------------
1: * | EmbeddedDataSource |              |
1: * |-----------------|              |
1: *       |                          |
1: *     has A                        |
1: *       |                          |
1: *       V                          V
1: * |------------|           |----------------------|   |-----------------------|
0: * | JDBCDriver |=produces=>| EmbedConnection |==>|  TransactionResource  |
1: * | LocalDriver|           |----------------------|   |-----------------------|
1: * |------------| 
1: * 
1: * 
1: * 
1: * <BR><BR>
1: * When user ask for a (normal) Connection via a DataSource, the following
1: * objects exists. The EmbeddedDataSource is just a wrapper for the JDBCDriver.
1: * <BR>
1: * |-----------------|
1: * | <B>EmbeddedDataSource</B> |
1: * |-----------------|
1: *       |
1: *     has A
1: *       |
1: *       V
1: * |------------|            |-----------------|     |-----------------------|
0: * | JDBCDriver |==produces=>| <B>EmbedConnection</B> |- ?->| TransactionResource   |
1: * | LocalDriver|            |-----------------|     |-----------------------|
1: * |------------|
1: 
1: 	</PRE>
1: 
1: 	<P>XADataSource inherits DataSource methods from EmbeddedDataSource.  It also
1: 	implements ResourceAdapter, whose main job is to keep track of run time
1: 	global transactions.  A global transaction table maps XIDs to
1: 	XATransactionResource.  XADataSource also has a XAResourceManager, which 
1: 	implements XAResource functionality in the Store.
1: 	
1: 	<P>XAConnection is the one thing that unites a global connection and the
1: 	XAResource that delineates the global transaction.  This is where the real
1: 	XAResource functionality is implemented.  All XAResource calls to the
1: 	XAResource object as well as Connection call to the BrokeredConnection
1: 	channels thrus the XAConnection, which makes sure only one thread can be
1: 	accessing the DB2jPooledConnection at any given time.
1: 
1: 	<P>XAResource and BrokeredConnection[23]0 are the two objects we give back
1: 	to the TM and the user application respectively to control a distributed
1: 	transaction.  According to the XA spec, the app server is supposed to make
1: 	sure that these objects are not used the same time by multiple threads, but
1: 	we don't trust the app server.  Therefore, we channel everthing back to the
1: 	XAConnection.
1: 
1: 	<P>The MT consideration is actually more complicated than this,
1: 	because a XAResource is allowed to control any transaction, not just the
1: 	one its XAConnection is current attached to.  So it is not sufficient to
1: 	just synchronized on XAConnection to guarentee single thread access to the
1: 	underlying transaction context.  To control some arbitrary global
1: 	transaction, the TM can call XAResource to prepare any Xid.  To do that,
1: 	the XAResource pass the request to the XAConnection, the XAConnection ask
1: 	the XADataSource to find the XATransactionResource, sets up the thread's
1: 	context, and call ask the XATransactionResource to prepare.  The
1: 	XATransactionResource is synchronized to prevent some other thread from
1: 	attaching, commiting, and in any way calling on the the same transaction
1: 	context.  If any error is thrown, it is handled with the context of the
1: 	transaction being prepared.  After the error is handled, the old context
1: 	(the one where the XAResource is really attached to), is restored.  While
1: 	this monkey business is going on, the thread that holds the connection the
1: 	XAConnection is supposed to be attached to is blocked out.  It can resume
1: 	after its XAConnection restored its context.  (Here is where I am not
1: 	really sure what happens since that thread obviously doesn't know about all
1: 	these hanky panky caused by the thread holding the XAResource commiting,
1: 	preparing and rolling back some other irrelavant transactions, so how would
1: 	its context be affected in any way?).
1: 
1: 	<P>DB2jPooledConnection implements PooledConnection, is hands out these
1: 	connection handles which allows some app server to do connection pooling.
1: 	This is a very thin layer.  A connection handle implements a Connection by
1: 	passing thru all calls to the underlaying connection.  In this case, it
1: 	passes Connection call thru the DB2jPooledConnection to the
1: 	DetachableConnection underneath.
1: 
1: 	<P>EmbeddedDataSource implements JNDI and is a replacement for Driver.
1: 
1: 	<P>The LocalDriver can now produce a DetachableConnection as well as a
1: 	EmbedConnection (which is the pre-JTA Connection that cannot detach and
1: 	attach to different transactions).  The way the LocalDriver knows to create
1: 	a DetachableConnection versus a EmbedConnection is thru some extremely
1: 	hackish URL settings.  This thing is very ugly and a more elegant way can
1: 	(and should) no doubt be found.
1: 
1: 	<P>DetachableConnection is a connection which can detach and attach to
1: 	different XATransactionResource, and can be totally unattached to any
1: 	transaction.
1: 
1: 	<P>XATransactionResource is a bundle of things that sets up a connection
1: 	with all the stuff it needs to actually talk to the database, do error
1: 	handling, etc.  It is also the object that lives in the transaction table
1: 	managed by the ResourceAdapter (XADataSource).  A XAResource (which may or
1: 	may not be attached to a transaction) can commit, prepare, or rollback any
1: 	global transaction that is not attached to an XAConnection.  To do that,
1: 	the ResourceAdapter fishes out the XATransactionResource, set up the
1: 	context, and do the commit processing/error handling on the current
1: 	thread.
1: 
1: 	<P>Local Connection is the same old local Connection except one
1: 	difference.  Pre-JTA, a localConnection uses itself (or a root Connection)
1: 	as the object to synchronized upon so that multiple threads getting hold of
1: 	the same Connection object cannot simultaneously issue calls to the
1: 	underlying transaction or context (since those things must be single thread
1: 	access).  With JTA, the object of synchronization is the
1: 	TransactionResource itself.  This part has not been well thought through
1: 	and is probably wrong.
1: 
1: 	<P>TransactionResource is a base class for XATransactionResource.  For a
1: 	local transaction which cannot be detached from a connection, there is no
1: 	need to encapsulate a bundle of things to set up a connection, so a
1: 	TransactionResource (probably misnamed) has nothing and is used only for
1: 	synchronization purposes.  This part has not been well thought throught and
1: 	is probably wrong. 
1: 
1: 	<P>The non-XA PooledConnection is just a thin veneer over the normal
1: 	connection.  I now have it over a Detachable connection just to simplify
1: 	the inheritence (XAConnection need to extend PooledConnection and XAConnect
1: 	needs to be detachable.  However, PooledConnection itself need not be
1: 	detachable).  It could be changed around to have LocalDriver producing
1: 	either EmbedConnection or XAConnection, and have the XAConnection
1: 	implements detachable.  But the current way is simpler.
1: 
1:  */
1: public interface ResourceAdapter {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1: 	/**
0: 	 * Used to identify this interface when finding it with the Monitor.
0:      **/
0: 	public static final String MODULE = 
0:         "org.apache.derby.iapi.jdbc.ResourceAdapter";
1: 
1: 
1: 	/**
1: 		If a run time global transaction exists, the resource adapter will find
1: 		it and return a capsule of information so that a Connection can be
1: 		attached to the transaction. 
1: 
1: 		@param xid the global transaction id
1: 		@return the transaction resource if the xid correspond to a run
1: 		time transaction, otherwise return null
1: 	 */
1: 	//XATransactionResource findTransaction(XAXactId xid);
1: 
1: 	/**
1: 		Start a run time global transaction.  Add this to the list of
1: 		transactions managed by this resource adapter.
1: 
1: 		@return true if transaction can be added, otherwise false (dupid).
1: 
1: 	 */
1: 	//boolean addTransaction(XATransactionResource tr);
1: 
1: 	/**
1: 		Terminates a run time global transction.  Remove this from the list of
1: 		transactions managed by this resource adapter.
1: 	 */
1: 	//void removeTransaction(XATransactionResource tr);
1: 
1: 	/**
1: 		Let a xaResource get the XAResourceManager to commit or rollback an
1: 		in-doubt transaction.
1: 	 */
1: 	XAResourceManager getXAResourceManager();
1: 
1: 	/**
1: 		Get the context service factory.
1: 	 */
1: 	//ContextService getContextServiceFactory();
1: 
1: 	/**
1: 		Is the Resource Manager active
1: 	 */
1: 	boolean isActive();
1: 
1: 	public Object findConnection(XAXactId xid);
1: 
1: 	public boolean addConnection(XAXactId xid, Object conn);
1: 
1: 	public Object removeConnection(XAXactId xid);
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.jdbc;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
0: import org.apache.derby.iapi.store.access.xa.XAXactId;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: /**
0: 	The resource adapter is the clearing house for managing connections,
0: 	transactions, and XAResources in a JDBC based resource manager living in
0: 	the distributed transaction processing environment.  
0: 
0: 	<P> There is one instance of ResourceAdapter per Resource Manager (database).
0: 	The ResourceAdapter is responsible for keeping track of all run time global
0: 	transactions and their state.   The resource adapter only knows of run time
0: 	global transactions, i.e., it does not know of in-doubt global transactions
0: 	re-created by recovery.
0: 
0: 	<P>	The following is an overall design of the JTA implementation in cloudscape,
0: 	most of it has little to do with the ResourceAdapter interface itself.
0: 	<P><B>Design Overview </B>
0: 
0: 	<P>The overriding design principle is that existing code should be disturbed
0: 	as little as possible.  This is so that DTP code will not add to the bloat
0: 	and drag of a normal, local, embbeded system.  The second design principle
0: 	is that as much of the JDBC 2.0 extension functionality is to be
0: 	implemented in the Connectivity layer and not in the underlying storage
0: 	system as possible.  Ideally, the additional storage interface will
0: 	implement no more than what is necessary to support the XAResource
0: 	interface.
0: 
0: 	<P>Language and replication code should not be touched, or have very
0: 	minimal API changes.  The API changes are confined to passing XA calls down
0: 	to the store.
0: 
0: 	<P>Some change will be made to existing Connectivity code and new XA
0: 	modules will be added.  This collection of code is hereby referred to as
0: 	the "blob of mysterious connectivity code", or the "resource adapter", or
0: 	"RA" for short.  In the JTA doc, the resource adapter is considered to be
0: 	part of the JDBC driver.  This RA means "some connectivity code", it
0: 	doesn't mean the object that implements the ResourceAdapter interface.
0: 
0: 	<P>The most important difference, in terms of implementation, between a
0: 	Connection that deals with a local transaction and a Connection that deals
0: 	with a global transaction is that in a global transaction, 2 or more
0: 	objects and threads can influence it - maybe concurrently.  The normal JDBC
0: 	interaction goes thru the Connection, but transaction demarcation comes
0: 	from an XAResource object(s).  The RA will channel all XAResource calls
0: 	that deal with a run time XA transaction (i.e., commit, end, forget,
0: 	prepare, start) thru the TransactionController that represents the real
0: 	transaction underneath.   Furthermore, the RA will make sure that all calls
0: 	thru a Connection or thru any XAResource objects must pass thru some sort
0: 	of synchronized object before it can get to the underlying transaction
0: 	object.  This is so that there is only one path to change the state of a
0: 	run time transaction and the transaction object and the context manager can
0: 	remain single thread access.
0: 
0: 	<P>In-doubt transaction (i.e., transactions re-created by recovery)
0: 	management and concurrency control is the responsibiliy of store. Moreover,
0: 	since the RA does not know the identities of the list of in-doubt
0: 	transactions, store must deal with (throw exception) when someone wants to
0: 	start a transaction with the same Xid as an existing in-doubt transaction.
0: 
0: 	<P>In terms of what this means to the app server that is calling us: if the
0: 	Connection and the XAResource that represents a global transaction is being
0: 	accessed by 2 different threads, they will access the database serially and
0: 	not concurrently. An in-doubt transaction gotten thru recovery has no
0: 	transaction object that is ever visible to the RA - because there is no
0: 	connection that was ever made to it.  Therefore it is safe to influence the
0: 	state of an in-doubt transaction directly thru some store factory interface
0: 	- and have that go thru the transaction table underneath to find the actual
0: 	transaction object and context manager etc.
0: 
0: 	<P>One new functionality of a Connection is the ability to switch around
0: 	with different transactions.  Before JTA, the lifetime of a transaction is
0: 	bounded by a connection, and a transaction cannot migrate from one
0: 	connection to another.  In JTA, a global transaction can be detached from a
0: 	Connection.  A transaction can move around and be attached to different
0: 	connections and its lifetime is not confine to the connection that started
0: 	it.  From the Connection's point of view, before JTA, a (local) transaction
0: 	is always started and ended in the same connection. With JTA, it needs to
0: 	"take on" existing global transactions that was started by some other
0: 	connections.
0: 
0: 	<P>The RA will have the responsibility of 
0: 	<OL>
0: 	<LI>setting up a Context with the appropriate transaction before calling
0: 	store to do work.</LI>
0: 	<LI>handling error on the context.</LI>
0: 	<LI>restoring a previous context if it was switched out due to an XAResouce
0: 	call to commit a transaction that is not what the XAResoruce is currently
0: 	attached to. </LI>
0: 	</OL>
0: 
0: 	<P>Because of all these switching around, a Connection may be in a
0: 	transaction-less state.  This happens between an XAResource.end call that
0: 	detached the current global transaction from the Connection, and the next
0: 	XAResource.start call that attach the next global transaction with the
0: 	Connection.
0: 
0: 	<BR>An (inferior) implementation is for the Connection object to start a
0: 	local connection once it is detached from a global transaction.  If the
0: 	user then uses the Connection immediately without a XAResource.start call,
0: 	then this Connection behaves just like it did before JTA, i.e., with a
0: 	local transaction.  If, on the other hand, an XAResource.start call happens
0: 	next, then either the local transaction is "morphed" into a global
0: 	transaction, or, if the start call is to attach the connection to a
0: 	pre-existing global transaction, then the local transaction is thrown away
0: 	and the Connection will take on the pre-exising global transaction.
0: 
0: 	<BR>Another (superior) implementation is to make it possible for a
0: 	Connection to be transaction-less.  When a Connection is first created by
0: 	XAConnection.getConnection, or when a XAResource.end call detached a global
0: 	transaction from the Connection, it is left in a transaction-less state.
0: 	If a XAResource.start call happens next, then the Connection either start a
0: 	new global transaction or it takes on an existing one.  If a call is made
0: 	directly on the Connection before XAResource.start call happens, then the
0: 	Connection starts a new local transaction.  This only affects Connections
0: 	that was gotten thru the XAConnection.getConnection().  Connections gotten
0: 	thru the DriverManager or a DataSource will have a local transaction
0: 	automatically started, as is the behavior today.  When a Connection with a
0: 	local transaction commits, the transaction is still around but it is chain
0: 	to the next one - this is the current behavior.  This behavior is very
0: 	desirable from a performance point of view, so it should be retained.
0: 	However, a local transaction cannot "morph" into a global transaction,
0: 	therefore when this Connection is attached to a global transaction, the
0: 	local transaction is thrown away and a global one started
0: 
0: 	<P>The RA will need to keep track of all global transactions.  This is done
0: 	by (yet another) transaction table that lives in the RA.  This transaction
0: 	table maps Xid to the ContextManager of the global transaction and whatever
0: 	else a connection needs to talk to the transaction - I assume the
0: 	Connection object currently have tendrils into various contexts and objects
0: 	and these are things that need to be detached and attached when a
0: 	Connection is hooked up with another transaction.  The reason for yet
0: 	another transaction table instead of the one in store is because the one in
0: 	store keeps track of local and internal transactions and is really quite
0: 	overworked already.
0: 
0: 	<P><B>Detailed design</B>
0: 
0: 	<BR> First some ugly pictures.  Some links are not shown to reduce
0: 	clutter.  Externally visible object is in <B>bold</B>.
0:   
0: 	<P><PRE>
0: * 
0: * When user ask for an XAConnection via a XADataSource, the following objects
0: * exists 
0: * <BR>
0: *
0: *                                                     |-------------|
0: *                                  |======= produces=>| <B>XAResource</B>  |
0: *                                  ||                 |-------------|
0: *                                  ||                       |
0: *                                  ||                     has A
0: *                                  ||                       |
0: *                                  ||  |---------------------
0: *                                  ||  V
0: * |--------------| produces |--------------| 
0: * | <B>XADataSource</B> |=========>| <B>XAConnection</B>
0: * |--------------|          |--------------| 
0: *       |                          | 
0: *     extends                    extends
0: *       |                          | 
0: *       |                |-----------------------|   |----------------------|
0: *       |                | DB2jPooledConnection |==>| BrokeredConnection |
0: *       |                |-----------------------|   |----------------------|
0: *       |                          |       ^                  |
0: *       |                        has A     |               has A
0: *       |                          |       |                  |
0: * |-----------------|              |       --------------------
0: * | EmbeddedDataSource |              |
0: * |-----------------|              |
0: *       |                          |
0: *     has A                        |
0: *       |                          |
0: *       V                          V
0: * |------------|           |----------------------|   |-----------------------|
0: * | JDBCDriver |=produces=>| DetachableConnection |==>| XATransactionResource |
0: * | LocalDriver|           |----------------------|   |                       |
0: * |------------|                   |                  |   points to :         |
0: *                                  |                  |XATransactionController|
0: *                                  |                  | ContextManager        |
0: *                                  |                  | LCC                   |
0: *                                  |                  | .. etc ..             |
0: *                                  |                  |-----------------------| 
0: *                                  |                            |
0: *                                extends                     extends
0: *                                  |                            |
0: *                           |-----------------|       |-----------------------|
0: *                           | EmbedConnection |-- ?-->|  TransactionResource  |
0: *                           |-----------------|       |-----------------------|
0: *
0: * 
0: * <BR><BR>
0: * When user ask for a PooledConnection via a PooledDataSource, the following
0: * objects exists 
0: * <BR>
0: * |-------------------------------|
0: * | <B>EmbeddedConnectionPoolDataSource</B> |
0: * |-------------------------------|
0: *       |                  ||
0: *       |                  ||
0: *     extends             produces
0: *       |                  ||
0: *       |                  \/
0: *       |                |-----------------------|   |----------------------|
0: *       |                | <B>DB2jPooledConnection</B> |==>| <B>BrokeredConnection</B> |
0: *       |                |-----------------------|   |----------------------|
0: *       |                          |       ^                  |
0: *       |                        has A     |               has A
0: *       |                          |       |                  |
0: * |-----------------|              |       --------------------
0: * | EmbeddedDataSource |              |
0: * |-----------------|              |
0: *       |                          |
0: *     has A                        |
0: *       |                          |
0: *       V                          V
0: * |------------|           |----------------------|   |-----------------------|
0: * | JDBCDriver |=produces=>| EmbedConnection |==>|  TransactionResource  |
0: * | LocalDriver|           |----------------------|   |-----------------------|
0: * |------------| 
0: * 
0: * 
0: * 
0: * <BR><BR>
0: * When user ask for a (normal) Connection via a DataSource, the following
0: * objects exists. The EmbeddedDataSource is just a wrapper for the JDBCDriver.
0: * <BR>
0: * |-----------------|
0: * | <B>EmbeddedDataSource</B> |
0: * |-----------------|
0: *       |
0: *     has A
0: *       |
0: *       V
0: * |------------|            |-----------------|     |-----------------------|
0: * | JDBCDriver |==produces=>| <B>EmbedConnection</B> |- ?->| TransactionResource   |
0: * | LocalDriver|            |-----------------|     |-----------------------|
0: * |------------|
0: 
0: 	</PRE>
0: 
0: 	<P>XADataSource inherits DataSource methods from EmbeddedDataSource.  It also
0: 	implements ResourceAdapter, whose main job is to keep track of run time
0: 	global transactions.  A global transaction table maps XIDs to
0: 	XATransactionResource.  XADataSource also has a XAResourceManager, which 
0: 	implements XAResource functionality in the Store.
0: 	
0: 	<P>XAConnection is the one thing that unites a global connection and the
0: 	XAResource that delineates the global transaction.  This is where the real
0: 	XAResource functionality is implemented.  All XAResource calls to the
0: 	XAResource object as well as Connection call to the BrokeredConnection
0: 	channels thrus the XAConnection, which makes sure only one thread can be
0: 	accessing the DB2jPooledConnection at any given time.
0: 
0: 	<P>XAResource and BrokeredConnection[23]0 are the two objects we give back
0: 	to the TM and the user application respectively to control a distributed
0: 	transaction.  According to the XA spec, the app server is supposed to make
0: 	sure that these objects are not used the same time by multiple threads, but
0: 	we don't trust the app server.  Therefore, we channel everthing back to the
0: 	XAConnection.
0: 
0: 	<P>The MT consideration is actually more complicated than this,
0: 	because a XAResource is allowed to control any transaction, not just the
0: 	one its XAConnection is current attached to.  So it is not sufficient to
0: 	just synchronized on XAConnection to guarentee single thread access to the
0: 	underlying transaction context.  To control some arbitrary global
0: 	transaction, the TM can call XAResource to prepare any Xid.  To do that,
0: 	the XAResource pass the request to the XAConnection, the XAConnection ask
0: 	the XADataSource to find the XATransactionResource, sets up the thread's
0: 	context, and call ask the XATransactionResource to prepare.  The
0: 	XATransactionResource is synchronized to prevent some other thread from
0: 	attaching, commiting, and in any way calling on the the same transaction
0: 	context.  If any error is thrown, it is handled with the context of the
0: 	transaction being prepared.  After the error is handled, the old context
0: 	(the one where the XAResource is really attached to), is restored.  While
0: 	this monkey business is going on, the thread that holds the connection the
0: 	XAConnection is supposed to be attached to is blocked out.  It can resume
0: 	after its XAConnection restored its context.  (Here is where I am not
0: 	really sure what happens since that thread obviously doesn't know about all
0: 	these hanky panky caused by the thread holding the XAResource commiting,
0: 	preparing and rolling back some other irrelavant transactions, so how would
0: 	its context be affected in any way?).
0: 
0: 	<P>DB2jPooledConnection implements PooledConnection, is hands out these
0: 	connection handles which allows some app server to do connection pooling.
0: 	This is a very thin layer.  A connection handle implements a Connection by
0: 	passing thru all calls to the underlaying connection.  In this case, it
0: 	passes Connection call thru the DB2jPooledConnection to the
0: 	DetachableConnection underneath.
0: 
0: 	<P>EmbeddedDataSource implements JNDI and is a replacement for Driver.
0: 
0: 	<P>The LocalDriver can now produce a DetachableConnection as well as a
0: 	EmbedConnection (which is the pre-JTA Connection that cannot detach and
0: 	attach to different transactions).  The way the LocalDriver knows to create
0: 	a DetachableConnection versus a EmbedConnection is thru some extremely
0: 	hackish URL settings.  This thing is very ugly and a more elegant way can
0: 	(and should) no doubt be found.
0: 
0: 	<P>DetachableConnection is a connection which can detach and attach to
0: 	different XATransactionResource, and can be totally unattached to any
0: 	transaction.
0: 
0: 	<P>XATransactionResource is a bundle of things that sets up a connection
0: 	with all the stuff it needs to actually talk to the database, do error
0: 	handling, etc.  It is also the object that lives in the transaction table
0: 	managed by the ResourceAdapter (XADataSource).  A XAResource (which may or
0: 	may not be attached to a transaction) can commit, prepare, or rollback any
0: 	global transaction that is not attached to an XAConnection.  To do that,
0: 	the ResourceAdapter fishes out the XATransactionResource, set up the
0: 	context, and do the commit processing/error handling on the current
0: 	thread.
0: 
0: 	<P>Local Connection is the same old local Connection except one
0: 	difference.  Pre-JTA, a localConnection uses itself (or a root Connection)
0: 	as the object to synchronized upon so that multiple threads getting hold of
0: 	the same Connection object cannot simultaneously issue calls to the
0: 	underlying transaction or context (since those things must be single thread
0: 	access).  With JTA, the object of synchronization is the
0: 	TransactionResource itself.  This part has not been well thought through
0: 	and is probably wrong.
0: 
0: 	<P>TransactionResource is a base class for XATransactionResource.  For a
0: 	local transaction which cannot be detached from a connection, there is no
0: 	need to encapsulate a bundle of things to set up a connection, so a
0: 	TransactionResource (probably misnamed) has nothing and is used only for
0: 	synchronization purposes.  This part has not been well thought throught and
0: 	is probably wrong. 
0: 
0: 	<P>The non-XA PooledConnection is just a thin veneer over the normal
0: 	connection.  I now have it over a Detachable connection just to simplify
0: 	the inheritence (XAConnection need to extend PooledConnection and XAConnect
0: 	needs to be detachable.  However, PooledConnection itself need not be
0: 	detachable).  It could be changed around to have LocalDriver producing
0: 	either EmbedConnection or XAConnection, and have the XAConnection
0: 	implements detachable.  But the current way is simpler.
0: 
0:  */
0: public interface ResourceAdapter {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 	/**
0: 	 * Used to identify this interface when finding it with the Monitor.
0:      **/
0: 	public static final String MODULE = 
0:         "org.apache.derby.iapi.jdbc.ResourceAdapter";
0: 
0: 
0: 	/**
0: 		If a run time global transaction exists, the resource adapter will find
0: 		it and return a capsule of information so that a Connection can be
0: 		attached to the transaction. 
0: 
0: 		@param xid the global transaction id
0: 		@return the transaction resource if the xid correspond to a run
0: 		time transaction, otherwise return null
0: 	 */
0: 	//XATransactionResource findTransaction(XAXactId xid);
0: 
0: 	/**
0: 		Start a run time global transaction.  Add this to the list of
0: 		transactions managed by this resource adapter.
0: 
0: 		@return true if transaction can be added, otherwise false (dupid).
0: 
0: 	 */
0: 	//boolean addTransaction(XATransactionResource tr);
0: 
0: 	/**
0: 		Terminates a run time global transction.  Remove this from the list of
0: 		transactions managed by this resource adapter.
0: 	 */
0: 	//void removeTransaction(XATransactionResource tr);
0: 
0: 	/**
0: 		Let a xaResource get the XAResourceManager to commit or rollback an
0: 		in-doubt transaction.
0: 	 */
0: 	XAResourceManager getXAResourceManager();
0: 
0: 	/**
0: 		Get the context service factory.
0: 	 */
0: 	//ContextService getContextServiceFactory();
0: 
0: 	/**
0: 		Is the Resource Manager active
0: 	 */
0: 	boolean isActive();
0: 
0: 	public Object findConnection(XAXactId xid);
0: 
0: 	public boolean addConnection(XAXactId xid, Object conn);
0: 
0: 	public Object removeConnection(XAXactId xid);
0: 
0: }
============================================================================