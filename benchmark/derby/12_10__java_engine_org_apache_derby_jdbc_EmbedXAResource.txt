1:0076dfb: /*
6:0076dfb: 
1:0076dfb:    Derby - Class org.apache.derby.jdbc.EmbedXAResource
1:0076dfb: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:0076dfb: 
1:0076dfb:       http://www.apache.org/licenses/LICENSE-2.0
1:0076dfb: 
1:0076dfb:    Unless required by applicable law or agreed to in writing, software
1:0076dfb:    distributed under the License is distributed on an "AS IS" BASIS,
1:0076dfb:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0076dfb:    See the License for the specific language governing permissions and
1:0076dfb:    limitations under the License.
1:0076dfb: 
1:0076dfb:  */
1:0076dfb: 
1:0076dfb: package org.apache.derby.jdbc;
1:0076dfb: 
1:1ae0d7d: import java.security.PrivilegedExceptionAction;
1:1ae0d7d: import java.security.PrivilegedActionException;
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:1e8a20f: import java.sql.ResultSet;
1:0076dfb: import java.sql.SQLException;
1:cccf5dd: 
1:cccf5dd: 
1:0076dfb: import javax.transaction.xa.XAResource;
1:0076dfb: import javax.transaction.xa.Xid;
1:0076dfb: import javax.transaction.xa.XAException;
1:0076dfb: 
1:31ba8d0: import org.apache.derby.iapi.error.ExceptionSeverity;
1:0c5bc3a: import org.apache.derby.iapi.error.ExceptionUtil;
1:0076dfb: import org.apache.derby.iapi.error.StandardException;
1:0076dfb: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1:0076dfb: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1:0076dfb: import org.apache.derby.iapi.reference.SQLState;
1:0076dfb: import org.apache.derby.iapi.services.context.ContextManager;
1:0076dfb: import org.apache.derby.iapi.services.context.ContextService;
1:cccf5dd: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:cccf5dd: import org.apache.derby.iapi.store.access.TransactionController;
1:0076dfb: import org.apache.derby.iapi.store.access.XATransactionController;
1:0076dfb: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1:0076dfb: import org.apache.derby.iapi.store.access.xa.XAXactId;
1:0076dfb: import org.apache.derby.impl.jdbc.EmbedConnection;
1:0076dfb: import org.apache.derby.impl.jdbc.TransactionResourceImpl;
1:1ae0d7d: import org.apache.derby.impl.jdbc.Util;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:cccf5dd: import org.apache.derby.iapi.services.property.PropertyUtil;
1:cccf5dd: import org.apache.derby.iapi.reference.Property;
1:0076dfb: 
1:0076dfb: /**
1:0076dfb:  * Implements XAResource
1:0076dfb:  */
1:0076dfb: class EmbedXAResource implements XAResource {
1:0076dfb: 
1:0076dfb:     private EmbedPooledConnection con;
1:0076dfb:     private ResourceAdapter ra;
1:0076dfb:     private XAXactId currentXid;    
1:cccf5dd:     /** The value of the transaction timeout on this resource. */
1:cccf5dd:     private int timeoutSeconds;
1:a57220c: 
1:a57220c:     private LanguageConnectionContext   lcc;
1:0076dfb:     
1:0076dfb:     EmbedXAResource (EmbedPooledConnection con, ResourceAdapter ra) {
1:0076dfb:         this.con = con;
1:0076dfb:         this.ra = ra;
1:cccf5dd:         // Setup the default value for the transaction timeout.
1:cccf5dd:         this.timeoutSeconds = 0;
5:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Commit the global transaction specified by xid.
1:0076dfb:      * @param xid A global transaction identifier
1:0076dfb:      * @param onePhase If true, the resource manager should use a one-phase
1:0076dfb:      * commit protocol to commit the work done on behalf of xid.
1:cccf5dd:      *
1:0076dfb:      * @exception XAException An error has occurred. Possible XAExceptions are
1:0076dfb:      * XA_HEURHAZ, XA_HEURCOM, XA_HEURRB, XA_HEURMIX, XAER_RMERR,
1:0076dfb:      * XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.  
1:0076dfb:      * <P>If the resource manager did not commit the transaction and
1:0076dfb:      * the paramether onePhase is set to true, the resource manager 
1:0076dfb:      * may throw one of the XA_RB* exceptions. Upon return, the
1:0076dfb:      * resource manager has rolled back the branch's work and has 
1:0076dfb:      * released all held resources.
1:0076dfb:      */    
1:0076dfb:     public final synchronized void commit(Xid xid, boolean onePhase) 
1:0076dfb:                                             throws XAException {
1:0076dfb:         checkXAActive();
1:0076dfb:         // ensure immtable and correct equals method.
1:0076dfb:         XAXactId xid_im = new XAXactId(xid);
1:0076dfb:         XATransactionState tranState = getTransactionState(xid_im);
1:0076dfb:         
1:0076dfb:         if (tranState == null) {
1:0076dfb:             XAResourceManager rm = ra.getXAResourceManager();
1:0076dfb:             ContextManager inDoubtCM = rm.find(xid);
1:0076dfb:             // RM also does not know about this xid.
1:0076dfb:             if (inDoubtCM == null)
1:0076dfb:                 throw new XAException(XAException.XAER_NOTA);
1:a0dbbd7:             ContextService csf = getContextService();
1:0076dfb:             csf.setCurrentContextManager(inDoubtCM);
2:0076dfb:             try {
1:0076dfb:                 rm.commit(inDoubtCM, xid_im, onePhase);
1:0076dfb:                 
1:0076dfb:                 // close the connection/transaction since it can never
1:4c5c16b:                 // be used again. DERBY-4856 No extended diagnostic information needed.
1:4c5c16b:                 inDoubtCM.cleanupOnError(StandardException.closeException(),
1:4c5c16b:                         false);
1:0076dfb:                 return;
1:0076dfb:             } catch (StandardException se) {
1:0076dfb:                 // The rm threw an exception, clean it up in the approprate
1:0076dfb:                 // context.  There is no transactionResource to handle the
1:0076dfb:                 // exception for us.
1:4c5c16b:                 inDoubtCM.cleanupOnError(se, con.isActive());
1:0076dfb:                 throw wrapInXAException(se);
1:0076dfb:             } finally {
1:0076dfb:                 csf.resetCurrentContextManager(inDoubtCM);
1:a0dbbd7:             }
1:0076dfb:             
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         synchronized (tranState) {
1:0076dfb:             checkUserCredentials(tranState.creatingResource);
1:0076dfb:             
1:0076dfb:             // Check the transaction is no associated with
1:0076dfb:             // any XAResource.
1:0076dfb:             switch (tranState.associationState) {
1:0076dfb:                 case XATransactionState.T0_NOT_ASSOCIATED:
1:0076dfb:                     break;
1:0076dfb:                     
1:0076dfb:                 case XATransactionState.TRO_FAIL:
1:0076dfb:                     throw new XAException(tranState.rollbackOnlyCode);
1:0076dfb:                     
1:0076dfb:                 default:
1:0076dfb:                     throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             }
1:0076dfb:             
1:0076dfb:             if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
1:0076dfb:                 throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             
1:0076dfb:             if (tranState.isPrepared == onePhase)
1:0076dfb:                 throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             
1:0076dfb:             try {
1:cccf5dd:                 tranState.xa_commit(onePhase);
1:0076dfb:             } catch (SQLException sqle) {
2:0076dfb:                 throw wrapInXAException(sqle);
1:0076dfb:             } finally {
1:0076dfb:                 returnConnectionToResource(tranState, xid_im);
1:0076dfb:             }
1:0076dfb:         }
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Ends the work performed on behalf of a transaction branch. The resource
1:0076dfb:      * manager disassociates the XA resource from the transaction branch
1:0076dfb:      * specified and let the transaction be completed.
2:0076dfb:      *
1:0076dfb:      * <p> If TMSUSPEND is specified in flags, the transaction branch is
1:0076dfb:      * temporarily suspended in incomplete state. The transaction context
1:0076dfb:      * is in suspened state and must be resumed via start with TMRESUME
1:0076dfb:      * specified.
1:0076dfb:      *
1:0076dfb:      * <p> If TMFAIL is specified, the portion of work has failed. The
1:0076dfb:      * resource manager may mark the transaction as rollback-only
1:0076dfb:      *
1:0076dfb:      * <p> If TMSUCCESS is specified, the portion of work has completed
1:0076dfb:      * successfully.
1:0076dfb:      *
1:0076dfb:      * @param xid A global transaction identifier that is the same as what was
1:0076dfb:      * used previously in the start method.
1:0076dfb:      * @param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
1:0076dfb:      *
1:0076dfb:      * @exception XAException An error has occurred.
1:0076dfb:      * Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA,
1:0076dfb:      * XAER_INVAL, XAER_PROTO, or XA_RB*.
1:0076dfb:      */
1:0076dfb:     public final synchronized void end(Xid xid, int flags) throws XAException {
1:0076dfb:         checkXAActive();
1:0076dfb:         
1:0076dfb:         try {
1:0076dfb:             // It is possible that the isolation level state in connection
1:0076dfb:             // handle has gotten out of sync with the real isolation level.
1:0076dfb:             // This can happen if SLQ instead of JDBC api has been used to
1:0076dfb:             // set the isolation level. The code below will check if isolation
1:0076dfb:             // was set using JDBC or SQL and if yes, then it will update the
1:0076dfb:             // isolation state in BrokeredConnection with EmbedConnection's
1:0076dfb:             // isolation level.
1:0076dfb:             if (con.currentConnectionHandle != null)
1:0076dfb:                 con.currentConnectionHandle.getIsolationUptoDate();
1:0076dfb:         } catch (SQLException sqle) {
1:0076dfb:             throw wrapInXAException(sqle);
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         // ensure immtable and correct equals method.
1:0076dfb:         XAXactId xid_im = new XAXactId(xid);
1:0076dfb:         
1:0076dfb:         boolean endingCurrentXid = false;
1:0076dfb:         
1:0076dfb:         // must match the Xid from start()
1:0076dfb:         if (currentXid != null) {
1:0076dfb:             if (!currentXid.equals(xid_im))
1:0076dfb:                 throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             endingCurrentXid = true;
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         XATransactionState tranState = getTransactionState(xid_im);
1:0076dfb:         if (tranState == null)
1:0076dfb:             throw new XAException(XAException.XAER_NOTA);
1:0076dfb:         
1:0076dfb:         boolean rollbackOnly = tranState.end(this, flags, endingCurrentXid);
1:0076dfb:         
1:0076dfb:         // RESOLVE - what happens to the connection on a fail
1:0076dfb:         // where we are not ending the current XID.
1:0076dfb:         if (endingCurrentXid) {
1:0076dfb:             currentXid = null;            
1:0076dfb:             con.realConnection = null;
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         if (rollbackOnly)
1:0076dfb:             throw new XAException(tranState.rollbackOnlyCode);        
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Ask the resource manager to prepare for a transaction commit of the
1:0076dfb:      * transaction specified in xid.
1:0076dfb:      *
1:0076dfb:      * @param xid A global transaction identifier
1:0076dfb:      *
1:0076dfb:      * @return A value indicating the resource manager's vote on the outcome
1:0076dfb:      * of the transaction. The possible values are: XA_RDONLY or XA_OK. If the
1:0076dfb:      * resource manager wants to roll back the transaction, it should do so by
1:0076dfb:      * raising an appropriate XAException in the prepare method.
1:0076dfb:      *
1:0076dfb:      * @exception XAException An error has occurred. Possible exception values
1:0076dfb:      * are: XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or
1:0076dfb:      * XAER_PROTO.
1:0076dfb:      *
1:0076dfb:      */
1:0076dfb:     public final synchronized int prepare(Xid xid) throws XAException {
1:0076dfb:         checkXAActive();
1:0076dfb:         
1:0076dfb:         // ensure immtable and correct equals method.
1:0076dfb:         XAXactId xid_im = new XAXactId(xid);
1:0076dfb:         
1:0076dfb:         XATransactionState tranState = getTransactionState(xid_im);
1:0076dfb:         
1:0076dfb:         if (tranState == null) {
1:0076dfb:             XAResourceManager rm = ra.getXAResourceManager();
1:0076dfb:             
1:0076dfb:             ContextManager inDoubtCM = rm.find(xid);
1:0076dfb:             
1:0076dfb:             // RM also does not know about this xid.
1:0076dfb:             if (inDoubtCM == null)
1:0076dfb:                 throw new XAException(XAException.XAER_NOTA);
1:0076dfb:             
1:0076dfb:             // cannot prepare in doubt transactions
1:0076dfb:             throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         synchronized (tranState) {
1:0076dfb:             
1:0076dfb:             checkUserCredentials(tranState.creatingResource);
1:0076dfb:             
1:0076dfb:             // Check the transaction is no associated with
1:0076dfb:             // any XAResource.
1:0076dfb:             switch (tranState.associationState) {
1:0076dfb:                 case XATransactionState.T0_NOT_ASSOCIATED:
1:0076dfb:                     break;
1:0076dfb:                     
1:0076dfb:                 case XATransactionState.TRO_FAIL:
1:0076dfb:                     throw new XAException(tranState.rollbackOnlyCode);
1:0076dfb:                     
1:0076dfb:                 default:
1:0076dfb:                     throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             }
1:0076dfb:             
1:0076dfb:             if (tranState.suspendedList != null 
1:0076dfb:                     && tranState.suspendedList.size() != 0)
1:0076dfb:                 throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             
1:0076dfb:             if (tranState.isPrepared)
1:0076dfb:                 throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             
1:0076dfb:             try {
1:0076dfb:                 
1:cccf5dd:                 int ret = tranState.xa_prepare();
1:0076dfb:                 
1:0076dfb:                 if (ret == XATransactionController.XA_OK) {
1:0076dfb:                     tranState.isPrepared = true;
1:0076dfb:                     
1:0076dfb:                     return XAResource.XA_OK;
1:0076dfb:                 } else {
1:2c70a31:                     
1:0076dfb:                     returnConnectionToResource(tranState, xid_im);
1:0076dfb: 
1:cccf5dd: 					if (SanityManager.DEBUG) {
1:2c70a31: 						if (con.realConnection != null) {
1:2c70a31: 							SanityManager.ASSERT(
1:2c70a31:                                 con.realConnection.transactionIsIdle(),
1:2c70a31:                                 "real connection should have been idle." +
1:2c70a31:                                 "tranState = " + tranState +
1:2c70a31:                                 "ret = " + ret +
1:2c70a31:                                 "con.realConnection = " + con.realConnection);
1:2c70a31:                         }
1:0076dfb: 					}
1:0076dfb:                     return XAResource.XA_RDONLY;
1:0076dfb:                 }
1:0076dfb:             } catch (SQLException sqle) {
1:0c5bc3a:                 XAException xe = wrapInXAException(sqle);
1:0c5bc3a: 
1:af1c18c:                 if (ExceptionUtil.
1:af1c18c:                         isDeferredConstraintViolation(sqle.getSQLState())) {
1:0c5bc3a:                     // We are rolling back
1:0c5bc3a:                     returnConnectionToResource(tranState, xid_im);
1:0c5bc3a:                 }
1:0c5bc3a: 
1:0c5bc3a:                 throw xe;
1:0076dfb:             }
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Obtain the current transaction timeout value set for this XAResource
1:0076dfb:      * instance. If XAResource.setTransactionTimeout was not use prior to
1:cccf5dd:      * invoking this method, the return value is 0; otherwise, the value
1:cccf5dd:      * used in the previous setTransactionTimeout call is returned.
1:0076dfb:      *
1:cccf5dd:      * @return the transaction timeout value in seconds. If the returned value
1:cccf5dd:      * is equal to Integer.MAX_VALUE it means no timeout.
1:0076dfb:      */
1:cccf5dd:     public synchronized int getTransactionTimeout() {
1:cccf5dd:         return timeoutSeconds;
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * This method is called to determine if the resource manager instance
1:0076dfb:      * represented by the target object is the same as the resouce manager
1:0076dfb:      * instance represented by the parameter xares.
1:0076dfb:      *
1:0076dfb:      * @param xares An XAResource object whose resource manager instance is to
1:0076dfb:      * be compared with the resource manager instance of the target object.
1:0076dfb:      *
1:0076dfb:      * @return true if it's the same RM instance; otherwise false.
1:0076dfb:      * @exception XAException An error has occurred. Possible exception values
1:0076dfb:      * are XAER_RMERR, XAER_RMFAIL.
1:0076dfb:      */
1:0076dfb:     public final synchronized boolean isSameRM(XAResource xares) 
1:0076dfb:                                                         throws XAException {
1:0076dfb:         checkXAActive();        
1:0076dfb:         if (xares instanceof EmbedXAResource) {            
1:0076dfb:             return ra == ((EmbedXAResource) xares).ra;
1:0076dfb:         }        
2:0076dfb:         return false;
1:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Obtain a list of prepared transaction branches from a resource
1:0076dfb:      * manager. The transaction manager calls this method during recovery to
1:0076dfb:      * obtain the list of transaction branches that are currently in prepared
1:0076dfb:      * or heuristically completed states.
1:0076dfb:      *
1:0076dfb:      * @param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS must
1:0076dfb:      * be used when no other flags are set in flags.
1:0076dfb:      *
1:0076dfb:      * @return The resource manager returns zero or more XIDs for the
1:0076dfb:      * transaction branches that are currently in a prepared or heuristically
1:0076dfb:      * completed state. If an error occurs during the operation, the resource
1:0076dfb:      * manager should throw the appropriate XAException.
1:0076dfb:      *
1:0076dfb:      * @exception XAException An error has occurred. Possible values are
1:0076dfb:      * XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and XAER_PROTO.
1:0076dfb:      *
1:0076dfb:      */
1:0076dfb:     public final synchronized Xid[] recover(int flag) throws XAException {
1:0076dfb:         checkXAActive();
1:0076dfb:         
1:0076dfb:         try {
1:0076dfb:             return ra.getXAResourceManager().recover(flag);
1:0076dfb:         } catch (StandardException se) {
1:0076dfb:             throw wrapInXAException(se);
1:0076dfb:         }
1:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Tell the resource manager to forget about a heuristically completed
1:0076dfb:      * transaction branch.
1:0076dfb:      *
1:0076dfb:      * @param xid A global transaction identifier
1:0076dfb:      * @exception XAException An error has occurred. Possible exception values
1:0076dfb:      * are XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:0076dfb:      */
1:0076dfb:     public final synchronized void forget(Xid xid) throws XAException {
1:0076dfb:         
1:0076dfb:         checkXAActive();
1:0076dfb:         
1:0076dfb:         // ensure immtable and correct equals method.
1:0076dfb:         XAXactId xid_im = new XAXactId(xid);
1:0076dfb:         
1:0076dfb:         XATransactionState tranState = getTransactionState(xid_im);
1:0076dfb:         if (tranState == null) {
1:0076dfb:             XAResourceManager rm = ra.getXAResourceManager();
1:0076dfb:             
1:0076dfb:             ContextManager inDoubtCM = rm.find(xid);
1:0076dfb:             
1:0076dfb:             // RM also does not know about this xid.
1:0076dfb:             if (inDoubtCM == null)
1:0076dfb:                 throw new XAException(XAException.XAER_NOTA);
1:0076dfb:             
1:a0dbbd7:             ContextService csf = getContextService();
1:0076dfb:             
1:0076dfb:             csf.setCurrentContextManager(inDoubtCM);
1:0076dfb:             try {
1:0076dfb:                 rm.forget(inDoubtCM, xid_im);
1:0076dfb:                 
1:0076dfb:                 // close the connection/transaction since it can never be used again.
1:4c5c16b:                 inDoubtCM.cleanupOnError(StandardException.closeException(),
1:4c5c16b:                         false);
1:0076dfb:                 return;
1:0076dfb:             } catch (StandardException se) {
1:0076dfb:                 // The rm threw an exception, clean it up in the approprate
1:0076dfb:                 // context.  There is no transactionResource to handle the
1:0076dfb:                 // exception for us.
1:4c5c16b:                 inDoubtCM.cleanupOnError(se, con.isActive());
1:0076dfb:                 throw wrapInXAException(se);
1:0076dfb:             } finally {
1:0076dfb:                 csf.resetCurrentContextManager(inDoubtCM);
1:0076dfb:             }
1:0076dfb:             
1:0076dfb:         }
1:0076dfb:         
1:418e135:         // DERBY-1016; if the transaction exists throw XAER_PROTO on forget
1:418e135:         throw new XAException(XAException.XAER_PROTO);
1:0076dfb:     }    
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Inform the resource manager to roll back work done on behalf of a
1:0076dfb:      * transaction branch
1:0076dfb:      *
1:0076dfb:      * @param xid A global transaction identifier
1:0076dfb:      * @exception XAException - An error has occurred
1:0076dfb:      */
1:0076dfb:     public final synchronized void rollback(Xid xid) throws XAException {
1:0076dfb:         checkXAActive();
1:0076dfb:         
1:0076dfb:         // ensure immtable and correct equals method.
1:0076dfb:         XAXactId xid_im = new XAXactId(xid);
1:0076dfb:         
1:0076dfb:         XATransactionState tranState = getTransactionState(xid_im);
1:0076dfb:         
1:0076dfb:         if (tranState == null) {
1:0076dfb:             XAResourceManager rm = ra.getXAResourceManager();
1:0076dfb:             
1:0076dfb:             ContextManager inDoubtCM = rm.find(xid);
1:0076dfb:             
1:0076dfb:             // RM also does not know about this xid.
1:0076dfb:             if (inDoubtCM == null)
1:0076dfb:                 throw new XAException(XAException.XAER_NOTA);
1:0076dfb:             
1:a0dbbd7:             ContextService csf = getContextService();
1:0076dfb:             
1:0076dfb:             csf.setCurrentContextManager(inDoubtCM);
1:0076dfb:             try {
1:0076dfb:                 rm.rollback(inDoubtCM, xid_im);
1:0076dfb:                 
1:0076dfb:                 // close the connection/transaction since it can never be used again.
1:4c5c16b:                 inDoubtCM.cleanupOnError(StandardException.closeException(),
1:4c5c16b:                         false);
1:0076dfb:                 return;
1:0076dfb:             } catch (StandardException se) {
1:0076dfb:                 // The rm threw an exception, clean it up in the approprate
1:0076dfb:                 // context.  There is no transactionResource to handle the
1:0076dfb:                 // exception for us.
1:4c5c16b:                 inDoubtCM.cleanupOnError(se, con.isActive());
1:0076dfb:                 throw wrapInXAException(se);
1:0076dfb:             } finally {
1:0076dfb:                 csf.resetCurrentContextManager(inDoubtCM);
1:0076dfb:             }
1:0076dfb:             
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         synchronized (tranState) {
1:0076dfb:             
1:0076dfb:             // Check the transaction is no associated with
1:0076dfb:             // any XAResource.
1:0076dfb:             switch (tranState.associationState) {
1:0076dfb:                 case XATransactionState.T0_NOT_ASSOCIATED:
1:0076dfb:                 case XATransactionState.TRO_FAIL:
1:0076dfb:                     break;
1:0076dfb:                     
1:0076dfb:                 default:
1:0076dfb:                     throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             }
1:0076dfb:             
1:0076dfb:             if (tranState.suspendedList != null 
1:0076dfb:                     && tranState.suspendedList.size() != 0)
1:0076dfb:                 throw new XAException(XAException.XAER_PROTO);
1:0076dfb:             
1:0076dfb:             checkUserCredentials(tranState.creatingResource);
1:0076dfb:             
1:0076dfb:             try {
1:0076dfb:                 
1:cccf5dd:                 tranState.xa_rollback();
1:0076dfb:             } catch (SQLException sqle) {
1:0076dfb:                 throw wrapInXAException(sqle);
1:0076dfb:             } finally {
1:0076dfb:                 returnConnectionToResource(tranState, xid_im);
1:0076dfb:             }
1:0076dfb:         }
1:0076dfb:     }
1:0076dfb: 
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Set the current transaction timeout value for this XAResource
1:0076dfb:      * instance. Once set, this timeout value is effective until
1:0076dfb:      * setTransactionTimeout is invoked again with a different value. To reset
1:0076dfb:      * the timeout value to the default value used by the resource manager,
1:0076dfb:      * set the value to zero. If the timeout operation is performed
1:0076dfb:      * successfully, the method returns true; otherwise false. If a resource
1:0076dfb:      * manager does not support transaction timeout value to be set
1:0076dfb:      * explicitly, this method returns false.
1:0076dfb:      *
1:0076dfb:      * @param seconds the transaction timeout value in seconds.
1:cccf5dd:      *                Value of 0 means the reasource manager's default value.
1:cccf5dd:      *                Value of Integer.MAX_VALUE means no timeout.
1:0076dfb:      * @return true if transaction timeout value is set successfully;
1:0076dfb:      * otherwise false.
1:0076dfb:      *
1:0076dfb:      * @exception XAException - An error has occurred. Possible exception
1:0076dfb:      * values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
1:0076dfb:      */
1:cccf5dd:     public synchronized boolean setTransactionTimeout(int seconds)
1:cccf5dd:     throws XAException {
1:cccf5dd:         if (seconds < 0) {
1:cccf5dd:             // throw an exception if invalid value was specified
1:cccf5dd:             throw new XAException(XAException.XAER_INVAL);
1:cccf5dd:         }
1:cccf5dd:         timeoutSeconds = seconds;
1:cccf5dd:         return true;
1:cccf5dd:     }
1:cccf5dd: 
1:cccf5dd:     /** Returns the default value for the transaction timeout in milliseconds
1:cccf5dd:      *  setted up by the system properties.
1:cccf5dd:      */
1:cccf5dd:     private long getDefaultXATransactionTimeout() throws XAException {
1:cccf5dd:         try {
1:1ae0d7d:             LanguageConnectionContext lcc = getLanguageConnectionContext( con );
1:cccf5dd:             TransactionController tc = lcc.getTransactionExecute();
1:cccf5dd: 
1:cccf5dd:             long timeoutMillis = 1000 * (long) PropertyUtil.getServiceInt(
1:cccf5dd:                 tc,
1:cccf5dd:                 Property.PROP_XA_TRANSACTION_TIMEOUT,
1:cccf5dd:                 0,
1:cccf5dd:                 Integer.MAX_VALUE,
1:cccf5dd:                 Property.DEFAULT_XA_TRANSACTION_TIMEOUT
1:b6a45f5:                 );
1:cccf5dd: 
1:cccf5dd:             return timeoutMillis;
1:cccf5dd:         } catch (SQLException sqle) {
1:cccf5dd:             throw wrapInXAException(sqle);
1:cccf5dd:         } catch (StandardException se) {
1:cccf5dd:             throw wrapInXAException(se);
1:cccf5dd:         }
1:0076dfb:     }
1:0076dfb: 
1:1ae0d7d:     /**
1:0076dfb:      * Start work on behalf of a transaction branch specified in xid If TMJOIN
1:0076dfb:      * is specified, the start is for joining a transaction previously seen by
1:0076dfb:      * the resource manager. If TMRESUME is specified, the start is to resume
1:0076dfb:      * a suspended transaction specified in the parameter xid. If neither
1:0076dfb:      * TMJOIN nor TMRESUME is specified and the transaction specified by xid
1:0076dfb:      * has previously been seen by the resource manager, the resource manager
1:0076dfb:      * throws the XAException exception with XAER_DUPID error code.
1:cccf5dd:      *
1:0076dfb:      * @param xid A global transaction identifier to be associated with the
1:0076dfb:      * resource
1:0076dfb:      * @param flags One of TMNOFLAGS, TMJOIN, or TMRESUME
1:0076dfb:      *
1:0076dfb:      * @exception XAException An error has occurred. Possible exceptions are
1:0076dfb:      * XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_DUPID, XAER_OUTSIDE, XAER_NOTA,
1:0076dfb:      * XAER_INVAL, or XAER_PROTO.
1:0076dfb:      */
1:0076dfb:     public final synchronized void start(Xid xid, 
1:0076dfb:                                         int flags) throws XAException {
1:0076dfb:         checkXAActive();
1:0076dfb:         
1:0076dfb:         // JDBC 3.0 section 12.3 - One transaction associated with a XAConnection
1:0076dfb:         if (currentXid != null)
1:0076dfb:             throw new XAException(XAException.XAER_PROTO);
1:0076dfb:         
1:0076dfb:         // ensure immtable and correct equals method.
1:0076dfb:         XAXactId xid_im = new XAXactId(xid);
1:0076dfb:         
1:0076dfb:         XATransactionState tranState = getTransactionState(xid_im);
1:0076dfb:         
1:0076dfb:         switch (flags) {
1:0076dfb:             case XAResource.TMNOFLAGS:
1:0076dfb:                 if (tranState != null)
1:0076dfb:                     throw new XAException(XAException.XAER_DUPID);
1:0076dfb:                 
1:0076dfb:                 try {
1:0076dfb:                     
1:0076dfb:                     if (con.realConnection == null) {
1:0076dfb:                         con.openRealConnection();
1:0076dfb:                         
1:0076dfb:                         if (con.currentConnectionHandle != null) {
1:0076dfb:                             
1:0076dfb:                             // since this is a new connection, set its complete
1:0076dfb:                             // state according to the application's Connection
1:0076dfb:                             // handle view of the world.
1:0076dfb:                             con.currentConnectionHandle.setState(true);
1:0076dfb:                             con.realConnection.setApplicationConnection
1:0076dfb:                                     (con.currentConnectionHandle);
1:0076dfb:                         }
1:0076dfb:                         
1:0076dfb:                     } else {
1:0076dfb:                         
1:0076dfb:                         // XAResource.start() auto commits in DB2 when in 
1:0076dfb:                         // auto commit mode.
1:0076dfb:                         if (con.currentConnectionHandle != null) {
1:0076dfb:                             if (con.currentConnectionHandle.getAutoCommit())
1:0076dfb:                                 con.currentConnectionHandle.rollback();
1:0076dfb:                         }
1:0076dfb:                         if (!con.realConnection.transactionIsIdle())
1:0076dfb:                             throw new XAException(XAException.XAER_OUTSIDE);
1:0076dfb:                         
1:0076dfb:                         if (con.currentConnectionHandle != null) {
1:0076dfb:                             // It is possible that the isolation level state 
1:0076dfb:                             // in connection handle has gotten out of sync 
1:0076dfb:                             // with the real isolation level. This can happen 
1:0076dfb:                             // if SLQ instead of JDBC api has been used to set 
1:0076dfb:                             // the isolation level. The code below will check 
1:0076dfb:                             // if isolation was set using JDBC or SQL and if 
1:0076dfb:                             // yes, then it will update the isolation state 
1:0076dfb:                             // in BrokeredConnection with EmbedConnection's
1:0076dfb:                             // isolation level.
1:0076dfb:                             con.currentConnectionHandle.getIsolationUptoDate();
1:0076dfb:                             // we have a current handle so we need to keep
1:0076dfb:                             // the connection state of the current connection.
1:0076dfb:                             con.currentConnectionHandle.setState(true);
1:0076dfb:                             
1:0076dfb:                             // At the local to global transition we need 
1:0076dfb:                             // to discard and close any open held result 
1:0076dfb:                             // sets, a rollback will do this.
1:0076dfb:                             con.realConnection.rollback();
1:0076dfb:                         } else {
1:0076dfb:                             con.resetRealConnection();
1:0076dfb:                         }
1:0076dfb:                         
1:0076dfb:                     }
1:0076dfb:                     
1:0076dfb:                     // Global connections are always in auto commit false mode.
1:0076dfb:                     con.realConnection.setAutoCommit(false);
1:0076dfb:                     
1:0076dfb:                     // and holdability false (cannot hold cursors across 
1:0076dfb:                     // XA transactions.
1:0076dfb:                     con.realConnection.setHoldability(
1:1e8a20f:                             ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:0076dfb:                     
1:1ae0d7d:                     getLanguageConnectionContext( con.realConnection ).
1:0076dfb:                             getTransactionExecute().
1:0076dfb:                             createXATransactionFromLocalTransaction(
1:0076dfb:                                                 xid_im.getFormatId(),
1:0076dfb:                                                 xid_im.getGlobalTransactionId(),
1:0076dfb:                                                 xid_im.getBranchQualifier());
1:0076dfb:                     
1:0076dfb:                     
1:0076dfb:                 } catch (StandardException se) {
1:0076dfb:                     throw wrapInXAException(se);
1:0076dfb:                 } catch (SQLException sqle) {
1:0076dfb:                     throw wrapInXAException(sqle);
1:0076dfb:                 }
1:0076dfb:                 
1:b6a45f5:                 tranState = new XATransactionState
1:b6a45f5:                     (
1:b6a45f5:                      getContextManager( con.realConnection ),
1:b6a45f5:                      con.realConnection, this, xid_im
1:b6a45f5:                      );
1:cccf5dd:                 if (!ra.addConnection(xid_im, tranState))
1:0076dfb:                     throw new XAException(XAException.XAER_DUPID);
1:0076dfb:                 
1:cccf5dd:                 currentXid = xid_im;
1:cccf5dd: 
1:cccf5dd:                 // If the the timeout specified is equal to Integer.MAX_VALUE
1:cccf5dd:                 // it means that transaction timeout is disabled.
1:cccf5dd:                 if (timeoutSeconds != Integer.MAX_VALUE) {
1:cccf5dd:                     // Find out the value of the transaction timeout
1:cccf5dd:                     long timeoutMillis;
1:cccf5dd:                     if (timeoutSeconds > 0) {
1:cccf5dd:                         timeoutMillis = 1000*timeoutSeconds;
1:cccf5dd:                     } else {
1:cccf5dd:                         timeoutMillis = getDefaultXATransactionTimeout();
1:a0dbbd7:                     }
1:cccf5dd:                     // If we have non-zero transaction timeout schedule a timeout task.
1:cccf5dd:                     // The only way how timeoutMillis might be equeal to 0 is that
1:cccf5dd:                     // it was specified as a default transaction timeout
1:cccf5dd:                     if (timeoutMillis > 0) {
1:cccf5dd:                         tranState.scheduleTimeoutTask(timeoutMillis);
1:a0dbbd7:                     }
1:cccf5dd:                 }
1:cccf5dd: 
1:0076dfb:                 break;
1:0076dfb:                 
1:0076dfb:             case XAResource.TMRESUME:
1:0076dfb:             case XAResource.TMJOIN:
1:0076dfb:                 if (tranState == null)
1:0076dfb:                     throw new XAException(XAException.XAER_NOTA);
1:0076dfb:                 
1:0076dfb:                 tranState.start(this, flags);
1:0076dfb:                 
1:0076dfb:                 if (tranState.conn != con.realConnection) {
1:0076dfb:                     
1:0076dfb:                     if (con.realConnection != null) {
1:0076dfb:                         
1:0076dfb:                         if (!con.realConnection.transactionIsIdle())
1:0076dfb:                             throw new XAException(XAException.XAER_OUTSIDE);
1:0076dfb:                         
1:fe8bb68:                         // We need to get the isolation level up to date same 
1:fe8bb68:                         // way as it is done at start of a transaction. Before
1:fe8bb68:                         // joining the transaction, it is possible that the 
1:fe8bb68:                         // isolation level was updated using SQL. We need to 
1:fe8bb68:                         // get this state and store in the connection handle so 
1:fe8bb68:                         // that we can restore the isolation when we are in the 
1:fe8bb68:                         // local mode.
1:1ae0d7d:                         try {
1:fe8bb68: 	                    	if (con.currentConnectionHandle != null) {
1:fe8bb68: 	                    		con.currentConnectionHandle.getIsolationUptoDate();
1:cccf5dd: 	                    	}
1:fe8bb68:                     	} catch (SQLException sqle) {
1:fe8bb68:                             throw wrapInXAException(sqle);
1:cccf5dd:                         }
1:fe8bb68:                         
1:0076dfb:                         closeUnusedConnection(con.realConnection);
1:fe8bb68:                     }
1:0076dfb:                     con.realConnection = tranState.conn;
1:0076dfb:                     
1:0076dfb:                     if (con.currentConnectionHandle != null) {
1:0076dfb:                         
1:fe8bb68:                         try {
1:0076dfb:                             // only reset the non-transaction specific 
1:0076dfb:                             // Connection state.
1:0076dfb:                             con.currentConnectionHandle.setState(false);
1:0076dfb:                             con.realConnection.setApplicationConnection(
1:0076dfb:                                     con.currentConnectionHandle);
1:0076dfb:                         } catch (SQLException sqle) {
1:0076dfb:                             throw wrapInXAException(sqle);
1:fe8bb68:                         }
1:0076dfb:                     }
1:0076dfb:                     
1:0076dfb:                 }
1:0076dfb:                 
1:0076dfb:                 
1:0076dfb:                 break;
1:0076dfb:                 
1:0076dfb:             default:
1:0076dfb:                 throw new XAException(XAException.XAER_INVAL);
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         currentXid = xid_im;
1:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Resturns currently active xid
1:0076dfb:      * @return Xid
1:0076dfb:      */
1:0076dfb:     Xid getCurrentXid () {
1:0076dfb:         return currentXid;
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Returns the XATransactionState of the the transaction
1:0076dfb:      * @param xid_im 
1:0076dfb:      * @return XATransactionState
1:0076dfb:      */
1:0076dfb:     private XATransactionState getTransactionState(XAXactId xid_im) {
1:0076dfb:         return (XATransactionState) ra.findConnection(xid_im);
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Compares the user name and password of the XAResource with
1:0076dfb:      * user name and password of this and throws XAException if there is 
1:0076dfb:      * a mismatch
1:0076dfb:      * @param original EmbedXAResource
1:0076dfb:      */
1:0076dfb:     private void checkUserCredentials(EmbedXAResource original)
1:0076dfb:                                                         throws XAException {        
1:0076dfb:         if (original == this)
1:0076dfb:             return;        
1:0076dfb:         if (original.con.getPassword().equals(con.getPassword()) && 
1:0076dfb:                 (original.con.getUsername().equals(con.getUsername())))
1:0076dfb:             return;                
1:0076dfb:         throw new XAException(XAException.XA_RBINTEGRITY);
1:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Checks if currently associated connection is active
1:0076dfb:      * throws exception if not
1:0076dfb:      */
1:0076dfb:     private void checkXAActive() throws XAException {    
1:0076dfb:         try {
1:0076dfb:             con.checkActive();
1:0076dfb:         } catch (SQLException sqle) {
1:0076dfb:             throw wrapInXAException(sqle);
1:0076dfb:         }
1:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Map a SQL exception to appropriate XAException.
1:0076dfb:      * Return the mapped XAException.
1:0076dfb:      */
1:0076dfb:     private static XAException wrapInXAException(SQLException se) {
1:0076dfb:         // Map interesting exceptions to XAException
1:0076dfb:         String sqlstate = se.getSQLState();
1:0076dfb:         String message = se.getMessage();
1:31ba8d0:         int seErrorCode = se.getErrorCode();      
1:31ba8d0:         int xaErrorCode;
1:0076dfb:         
1:0076dfb:         XAException xae;
1:0076dfb:         
1:31ba8d0:         // Determine the XAException.errorCode.  This is known for 
1:31ba8d0:         // some specific exceptions. For other exceptions, we will
1:31ba8d0:         // return XAER_RMFAIL for SESSION_SEVERITY or greater and
1:31ba8d0:         // XAER_RMERR for less severe errors. DERBY-4141.
1:31ba8d0:         if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(
1:0076dfb:                             SQLState.STORE_XA_XAER_DUPID)))
1:31ba8d0:             xaErrorCode = XAException.XAER_DUPID;
1:0076dfb:         else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(
1:0076dfb:                                 SQLState.STORE_XA_PROTOCOL_VIOLATION)))
1:31ba8d0:             xaErrorCode = XAException.XA_RBPROTO;
1:0076dfb:         else if (sqlstate.equals(SQLState.DEADLOCK))
1:31ba8d0:             xaErrorCode = XAException.XA_RBDEADLOCK;
1:0076dfb:         else if (sqlstate.equals(SQLState.LOCK_TIMEOUT))
1:31ba8d0:             xaErrorCode = XAException.XA_RBTIMEOUT;
1:31ba8d0:         else if (seErrorCode >=  ExceptionSeverity.SESSION_SEVERITY)
1:0c5bc3a:             xaErrorCode = XAException.XAER_RMFAIL;
1:af1c18c:         else if (ExceptionUtil.isDeferredConstraintViolation(sqlstate)) {
1:0c5bc3a:             xaErrorCode = XAException.XA_RBINTEGRITY;
1:af1c18c:         } else {
1:31ba8d0:             xaErrorCode = XAException.XAER_RMERR;
1:af1c18c:         }
1:0076dfb:         
1:31ba8d0:         xae = new XAException(message);
1:31ba8d0:         xae.errorCode = xaErrorCode;
1:4e1ac79:         xae.initCause(se);
1:0076dfb:         return xae;
1:0076dfb:     }
1:0076dfb: 	
1:0076dfb:     /**
1:0076dfb:      * Map a Standard exception to appropriate XAException.
1:0076dfb:      * Return the mapped XAException.
1:0076dfb:      */
1:0076dfb:     private static XAException wrapInXAException(StandardException se) {
1:0076dfb:         return wrapInXAException(
1:de3b108:                 TransactionResourceImpl.wrapInSQLException(se));
1:0076dfb:     }
1:0076dfb:     
1:0076dfb:     /**
1:0076dfb:      * Return an underlying connection object back to its XAResource
1:0076dfb:      * if possible. If not close the connection.
1:0076dfb:      * @param tranState 
1:0076dfb:      * @param xid_im 
1:0076dfb:      */
1:cccf5dd:     void returnConnectionToResource(XATransactionState tranState,
1:0076dfb:                                                             XAXactId xid_im) {
1:0076dfb:         
1:0076dfb:         removeXATransaction(xid_im);    
1:0076dfb:         synchronized (tranState) {
1:0076dfb:             // global transaction is over.
1:0076dfb:             tranState.associationState = XATransactionState.TC_COMPLETED;
1:0076dfb:             tranState.notifyAll();
1:0076dfb:             
3:0076dfb:             EmbedConnection conn = tranState.conn;
1:0076dfb:             
1:0076dfb:             // already set in its own resource
1:0076dfb:             // or can it be returned to its original resource?
1:0076dfb:             if ((tranState.creatingResource.con.realConnection == conn) ||
1:0076dfb:                     (tranState.creatingResource.con.realConnection == null)) {
1:0076dfb:                 
1:0076dfb:                 tranState.creatingResource.con.realConnection = conn;
1:0076dfb:                 
1:0076dfb:                 BrokeredConnection handle = 
1:0076dfb:                         tranState.creatingResource.con.currentConnectionHandle;
1:0076dfb:                 
1:0076dfb:                 conn.setApplicationConnection(handle);
1:0076dfb:                 
1:0076dfb:                 if (handle != null) {
1:0076dfb:                     try {
1:0076dfb:                         handle.setState(true);
1:0076dfb:                     } catch (SQLException sqle) {
1:0076dfb:                         
1:0076dfb:                         // couldn't reset the connection
1:0076dfb:                         closeUnusedConnection(tranState.conn);
1:0076dfb:                         tranState.creatingResource.con.realConnection = null;
1:0076dfb:                     }
1:0076dfb:                 }
1:0076dfb:                 return;
1:0076dfb:             }
1:0076dfb:         }
1:0076dfb:         
1:0076dfb:         // nowhere to place it, close it.
1:0076dfb:         closeUnusedConnection(tranState.conn);
1:0076dfb:     }
1:0076dfb: 
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Close  an underlying connection object when there is
1:0076dfb:      * no active XAResource to hand it to.
1:0076dfb:      * @param conn 
1:0076dfb:      */
1:0076dfb:     private static void closeUnusedConnection(EmbedConnection conn) {
1:0076dfb:         if (conn != null) {
1:0076dfb:             try {
1:0076dfb:                 conn.close();
1:0076dfb:             } catch (SQLException sqle) {
1:0076dfb:                 
1:0076dfb:             }
1:0076dfb:         }
1:0076dfb:     }
1:0076dfb: 
1:0076dfb:     /**
1:0076dfb:      * Removes the xid from currently active transactions
1:0076dfb:      * @param xid_im 
1:0076dfb:      */
1:cccf5dd:     void removeXATransaction(XAXactId xid_im) {
1:0076dfb:         XATransactionState tranState = 
1:0076dfb:                 (XATransactionState) ra.removeConnection(xid_im);
1:0076dfb:         if (tranState != null)
1:0076dfb:             tranState.popMe();
1:cccf5dd:     }
1:0076dfb:     
1:cccf5dd:     void setCurrentXid(XAXactId aCurrentXid) {
1:cccf5dd:         currentXid = aCurrentXid;
1:a0dbbd7:     }
1:a0dbbd7: 
1:cccf5dd:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:1ae0d7d:     {
2:b6a45f5:         return AccessController.doPrivileged
1:1ae0d7d:             (
1:b6a45f5:              new PrivilegedAction<ContextService>()
1:1ae0d7d:              {
1:b6a45f5:                  public ContextService run()
1:b6a45f5:                  {
1:b6a45f5:                      return ContextService.getFactory();
1:1ae0d7d:                  }
1:b6a45f5:              }
1:1ae0d7d:              );
1:b6a45f5:     }
1:b6a45f5: 
1:b6a45f5:     /**
1:b6a45f5:      * Privileged lookup of the ContextManager. Must be private so that user code
1:b6a45f5:      * can't call this entry point.
1:b6a45f5:      */
1:b6a45f5:     private  static  ContextManager    getContextManager( final EmbedConnection conn )
1:b6a45f5:     {
1:1ae0d7d:         return AccessController.doPrivileged
2:b6a45f5:             (
1:b6a45f5:              new PrivilegedAction<ContextManager>()
1:b6a45f5:              {
1:b6a45f5:                  public ContextManager run()
1:b6a45f5:                  {
1:b6a45f5:                      return conn.getContextManager();
1:b6a45f5:                  }
1:b6a45f5:              }
1:b6a45f5:              );
1:a0dbbd7:     }
1:a0dbbd7: 
1:0076dfb: 	/**
1:1ae0d7d: 	  *	Gets the LanguageConnectionContext for this connection.
1:1ae0d7d: 	  */
1:1ae0d7d: 	private	LanguageConnectionContext	getLanguageConnectionContext( final EmbedConnection conn )
1:1ae0d7d: 	{
1:1ae0d7d:         return AccessController.doPrivileged
1:1ae0d7d:             (
1:1ae0d7d:              new PrivilegedAction<LanguageConnectionContext>()
1:1ae0d7d:              {
2:1ae0d7d:                  public LanguageConnectionContext run()
1:1ae0d7d:                  {
2:1ae0d7d:                      return conn.getLanguageConnection();
1:1ae0d7d:                  }
1:1ae0d7d:              }
1:1ae0d7d:              );
1:1ae0d7d: 	}
1:1ae0d7d: 
1:1ae0d7d:     /**
1:1ae0d7d:      * Privileged LCC lookup. Must be private so that user code
1:1ae0d7d:      * can't call this entry point.
1:1ae0d7d:      */
1:1ae0d7d: 	private	LanguageConnectionContext	getLanguageConnectionContext( final EmbedPooledConnection conn )
2:1ae0d7d:         throws SQLException
1:1ae0d7d:     {
1:a57220c:         if ( lcc == null )
1:1ae0d7d:         {
1:a57220c:             try {
1:a57220c:                 lcc = AccessController.doPrivileged
1:a57220c:                     (
1:a57220c:                      new PrivilegedExceptionAction<LanguageConnectionContext>()
1:a57220c:                      {
1:a57220c:                          public LanguageConnectionContext run()
1:a57220c:                              throws SQLException
1:a57220c:                          {
1:a57220c:                              return conn.getLanguageConnection();
1:a57220c:                          }
1:a57220c:                      }
1:a57220c:                      );
1:a57220c:             } catch (PrivilegedActionException pae)
1:a57220c:             {
1:a57220c:                 throw Util.javaException( pae );
1:a57220c:             }
1:1ae0d7d:         }
1:a57220c: 
1:a57220c:         return lcc;
1:1ae0d7d:     }
1:1ae0d7d: 
1:1ae0d7d: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a57220c
/////////////////////////////////////////////////////////////////////////
1: 
1:     private LanguageConnectionContext   lcc;
/////////////////////////////////////////////////////////////////////////
1:         if ( lcc == null )
1:             try {
1:                 lcc = AccessController.doPrivileged
1:                     (
1:                      new PrivilegedExceptionAction<LanguageConnectionContext>()
1:                      {
1:                          public LanguageConnectionContext run()
1:                              throws SQLException
1:                          {
1:                              return conn.getLanguageConnection();
1:                          }
1:                      }
1:                      );
1:             } catch (PrivilegedActionException pae)
1:             {
1:                 throw Util.javaException( pae );
1:             }
1: 
1:         return lcc;
commit:1ae0d7d
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedExceptionAction;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.jdbc.Util;
/////////////////////////////////////////////////////////////////////////
1:             LanguageConnectionContext lcc = getLanguageConnectionContext( con );
/////////////////////////////////////////////////////////////////////////
1:                     getLanguageConnectionContext( con.realConnection ).
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	  *	Gets the LanguageConnectionContext for this connection.
1: 	  */
1: 	private	LanguageConnectionContext	getLanguageConnectionContext( final EmbedConnection conn )
1: 	{
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<LanguageConnectionContext>()
1:              {
1:                  public LanguageConnectionContext run()
1:                  {
1:                      return conn.getLanguageConnection();
1:                  }
1:              }
1:              );
1: 	}
1: 
1:     /**
1:      * Privileged LCC lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1: 	private	LanguageConnectionContext	getLanguageConnectionContext( final EmbedPooledConnection conn )
1:         throws SQLException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedExceptionAction<LanguageConnectionContext>()
1:                  {
1:                      public LanguageConnectionContext run()
1:                          throws SQLException
1:                      {
1:                          return conn.getLanguageConnection();
1:                      }
1:                  }
1:                  );
0:         } catch (PrivilegedActionException pae)
1:         {
0:             throw Util.javaException( pae );
1:         }
1:     }
1: 
commit:b6a45f5
/////////////////////////////////////////////////////////////////////////
1:                 tranState = new XATransactionState
1:                     (
1:                      getContextManager( con.realConnection ),
1:                      con.realConnection, this, xid_im
1:                      );
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                      return ContextService.getFactory();
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged lookup of the ContextManager. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextManager    getContextManager( final EmbedConnection conn )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextManager>()
1:              {
1:                  public ContextManager run()
1:                  {
1:                      return conn.getContextManager();
1:                  }
1:              }
1:              );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1:             ContextService csf = getContextService();
/////////////////////////////////////////////////////////////////////////
1:             ContextService csf = getContextService();
/////////////////////////////////////////////////////////////////////////
1:             ContextService csf = getContextService();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
0:     {
0:         if ( System.getSecurityManager() == null )
0:         {
0:             return ContextService.getFactory();
1:         }
0:         else
0:         {
0:             return AccessController.doPrivileged
0:                 (
0:                  new PrivilegedAction<ContextService>()
0:                  {
0:                      public ContextService run()
0:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
0:                  );
1:         }
1:     }
1: 
commit:90543a4
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:                 if (ExceptionUtil.
1:                         isDeferredConstraintViolation(sqle.getSQLState())) {
/////////////////////////////////////////////////////////////////////////
1:         else if (ExceptionUtil.isDeferredConstraintViolation(sqlstate)) {
1:         } else {
1:         }
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.ExceptionUtil;
/////////////////////////////////////////////////////////////////////////
1:                 XAException xe = wrapInXAException(sqle);
1: 
0:                 if (sqle.getSQLState().equals(
0:                       ExceptionUtil.getSQLStateFromIdentifier(
0:                         SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T))) {
1:                     // We are rolling back
1:                     returnConnectionToResource(tranState, xid_im);
1:                 }
1: 
1:                 throw xe;
/////////////////////////////////////////////////////////////////////////
1:             xaErrorCode = XAException.XAER_RMFAIL;
0:         else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T)))
1:             xaErrorCode = XAException.XA_RBINTEGRITY;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4e1ac79
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         xae.initCause(se);
commit:cccf5dd
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
1:     /** The value of the transaction timeout on this resource. */
1:     private int timeoutSeconds;
1:         // Setup the default value for the transaction timeout.
1:         this.timeoutSeconds = 0;
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                 tranState.xa_commit(onePhase);
/////////////////////////////////////////////////////////////////////////
1:                 int ret = tranState.xa_prepare();
/////////////////////////////////////////////////////////////////////////
1: 					if (SanityManager.DEBUG) {
/////////////////////////////////////////////////////////////////////////
1:      * invoking this method, the return value is 0; otherwise, the value
1:      * used in the previous setTransactionTimeout call is returned.
1:      * @return the transaction timeout value in seconds. If the returned value
1:      * is equal to Integer.MAX_VALUE it means no timeout.
1:     public synchronized int getTransactionTimeout() {
1:         return timeoutSeconds;
/////////////////////////////////////////////////////////////////////////
1:                 tranState.xa_rollback();
/////////////////////////////////////////////////////////////////////////
1:      *                Value of 0 means the reasource manager's default value.
1:      *                Value of Integer.MAX_VALUE means no timeout.
1:     public synchronized boolean setTransactionTimeout(int seconds)
1:     throws XAException {
1:         if (seconds < 0) {
1:             // throw an exception if invalid value was specified
1:             throw new XAException(XAException.XAER_INVAL);
1:         }
1:         timeoutSeconds = seconds;
1:         return true;
1:     }
1: 
1:     /** Returns the default value for the transaction timeout in milliseconds
1:      *  setted up by the system properties.
1:      *
0:      *  @see Property.PROP_XA_TRANSACTION_TIMEOUT
0:      *  @see Property.DEFAULT_XA_TRANSACTION_TIMEOUT
1:      */
1:     private long getDefaultXATransactionTimeout() throws XAException {
1:         try {
0:             LanguageConnectionContext lcc = con.getLanguageConnection();
1:             TransactionController tc = lcc.getTransactionExecute();
1: 
1:             long timeoutMillis = 1000 * (long) PropertyUtil.getServiceInt(
1:                 tc,
1:                 Property.PROP_XA_TRANSACTION_TIMEOUT,
1:                 0,
1:                 Integer.MAX_VALUE,
1:                 Property.DEFAULT_XA_TRANSACTION_TIMEOUT
0:                 );
1: 
1:             return timeoutMillis;
1:         } catch (SQLException sqle) {
1:             throw wrapInXAException(sqle);
1:         } catch (StandardException se) {
1:             throw wrapInXAException(se);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 tranState = new XATransactionState(
0:                     con.realConnection.getContextManager(),
0:                     con.realConnection, this, xid_im);
1:                 if (!ra.addConnection(xid_im, tranState))
1:                 currentXid = xid_im;
1: 
1:                 // If the the timeout specified is equal to Integer.MAX_VALUE
1:                 // it means that transaction timeout is disabled.
1:                 if (timeoutSeconds != Integer.MAX_VALUE) {
1:                     // Find out the value of the transaction timeout
1:                     long timeoutMillis;
1:                     if (timeoutSeconds > 0) {
1:                         timeoutMillis = 1000*timeoutSeconds;
1:                     } else {
1:                         timeoutMillis = getDefaultXATransactionTimeout();
1:                     }
1:                     // If we have non-zero transaction timeout schedule a timeout task.
1:                     // The only way how timeoutMillis might be equeal to 0 is that
1:                     // it was specified as a default transaction timeout
1:                     if (timeoutMillis > 0) {
1:                         tranState.scheduleTimeoutTask(timeoutMillis);
1:                     }
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:     void returnConnectionToResource(XATransactionState tranState,
/////////////////////////////////////////////////////////////////////////
1:     void removeXATransaction(XAXactId xid_im) {
1:     void setCurrentXid(XAXactId aCurrentXid) {
1:         currentXid = aCurrentXid;
1:     }
1: 
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1:                 TransactionResourceImpl.wrapInSQLException(se));
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:418e135
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-1016; if the transaction exists throw XAER_PROTO on forget
1:         throw new XAException(XAException.XAER_PROTO);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8b6fe4c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
author:Lily Wei
-------------------------------------------------------------------------------
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
1:                 // be used again. DERBY-4856 No extended diagnostic information needed.
1:                 inDoubtCM.cleanupOnError(StandardException.closeException(),
1:                         false);
1:                 inDoubtCM.cleanupOnError(se, con.isActive());
/////////////////////////////////////////////////////////////////////////
1:                 inDoubtCM.cleanupOnError(StandardException.closeException(),
1:                         false);
1:                 inDoubtCM.cleanupOnError(se, con.isActive());
/////////////////////////////////////////////////////////////////////////
1:                 inDoubtCM.cleanupOnError(StandardException.closeException(),
1:                         false);
1:                 inDoubtCM.cleanupOnError(se, con.isActive());
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2c70a31
/////////////////////////////////////////////////////////////////////////
1: 
1: 						if (con.realConnection != null) {
1: 							SanityManager.ASSERT(
1:                                 con.realConnection.transactionIsIdle(),
1:                                 "real connection should have been idle." +
1:                                 "tranState = " + tranState +
1:                                 "ret = " + ret +
1:                                 "con.realConnection = " + con.realConnection);
1:                         }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:31ba8d0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.ExceptionSeverity;
/////////////////////////////////////////////////////////////////////////
1:         int seErrorCode = se.getErrorCode();      
1:         int xaErrorCode;
1:         // Determine the XAException.errorCode.  This is known for 
1:         // some specific exceptions. For other exceptions, we will
1:         // return XAER_RMFAIL for SESSION_SEVERITY or greater and
1:         // XAER_RMERR for less severe errors. DERBY-4141.
1:         if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(
1:             xaErrorCode = XAException.XAER_DUPID;
1:             xaErrorCode = XAException.XA_RBPROTO;
1:             xaErrorCode = XAException.XA_RBDEADLOCK;
1:             xaErrorCode = XAException.XA_RBTIMEOUT;
1:         else if (seErrorCode >=  ExceptionSeverity.SESSION_SEVERITY)
0:             xaErrorCode = XAException.XAER_RMFAIL;            
1:             xaErrorCode = XAException.XAER_RMERR;
1:         xae = new XAException(message);
1:         xae.errorCode = xaErrorCode;
commit:fe8bb68
/////////////////////////////////////////////////////////////////////////
1:                         // We need to get the isolation level up to date same 
1:                         // way as it is done at start of a transaction. Before
1:                         // joining the transaction, it is possible that the 
1:                         // isolation level was updated using SQL. We need to 
1:                         // get this state and store in the connection handle so 
1:                         // that we can restore the isolation when we are in the 
1:                         // local mode.
1:                         try {
1: 	                    	if (con.currentConnectionHandle != null) {
1: 	                    		con.currentConnectionHandle.getIsolationUptoDate();
1: 	                    	}
1:                     	} catch (SQLException sqle) {
1:                             throw wrapInXAException(sqle);
1:                         }
1:                         
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             ResultSet.CLOSE_CURSORS_AT_COMMIT);
commit:0076dfb
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.jdbc.EmbedXAResource
1: 
0:    Copyright 2003, 2006 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.jdbc;
1: 
1: import java.sql.SQLException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: import javax.transaction.xa.XAException;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: import org.apache.derby.iapi.store.access.XATransactionController;
1: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1: import org.apache.derby.iapi.store.access.xa.XAXactId;
1: import org.apache.derby.impl.jdbc.EmbedConnection;
1: import org.apache.derby.impl.jdbc.TransactionResourceImpl;
1: 
1: /**
1:  * Implements XAResource
1:  */
1: class EmbedXAResource implements XAResource {
1: 
1:     private EmbedPooledConnection con;
1:     private ResourceAdapter ra;
1:     private XAXactId currentXid;    
1:     
1:     EmbedXAResource (EmbedPooledConnection con, ResourceAdapter ra) {
1:         this.con = con;
1:         this.ra = ra;
1:     }
1:     
1:     /**
1:      * Commit the global transaction specified by xid.
1:      * @param xid A global transaction identifier
1:      * @param onePhase If true, the resource manager should use a one-phase
1:      * commit protocol to commit the work done on behalf of xid.
1: 
1:      * @exception XAException An error has occurred. Possible XAExceptions are
1:      * XA_HEURHAZ, XA_HEURCOM, XA_HEURRB, XA_HEURMIX, XAER_RMERR,
1:      * XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.  
1:      * <P>If the resource manager did not commit the transaction and
1:      * the paramether onePhase is set to true, the resource manager 
1:      * may throw one of the XA_RB* exceptions. Upon return, the
1:      * resource manager has rolled back the branch's work and has 
1:      * released all held resources.
1:      */    
1:     public final synchronized void commit(Xid xid, boolean onePhase) 
1:                                             throws XAException {
1:         checkXAActive();
1:         // ensure immtable and correct equals method.
1:         XAXactId xid_im = new XAXactId(xid);
1:         XATransactionState tranState = getTransactionState(xid_im);
1:         
1:         if (tranState == null) {
1:             XAResourceManager rm = ra.getXAResourceManager();
1:             ContextManager inDoubtCM = rm.find(xid);
1:             // RM also does not know about this xid.
1:             if (inDoubtCM == null)
1:                 throw new XAException(XAException.XAER_NOTA);
0:             ContextService csf = ContextService.getFactory();
1:             csf.setCurrentContextManager(inDoubtCM);
1:             try {
1:                 rm.commit(inDoubtCM, xid_im, onePhase);
1:                 
1:                 // close the connection/transaction since it can never
0:                 // be used again.
0:                 inDoubtCM.cleanupOnError(StandardException.closeException());
1:                 return;
1:             } catch (StandardException se) {
1:                 // The rm threw an exception, clean it up in the approprate
1:                 // context.  There is no transactionResource to handle the
1:                 // exception for us.
0:                 inDoubtCM.cleanupOnError(se);
1:                 throw wrapInXAException(se);
1:             } finally {
1:                 csf.resetCurrentContextManager(inDoubtCM);
1:             }
1:             
1:         }
1:         
1:         synchronized (tranState) {
1:             checkUserCredentials(tranState.creatingResource);
1:             
1:             // Check the transaction is no associated with
1:             // any XAResource.
1:             switch (tranState.associationState) {
1:                 case XATransactionState.T0_NOT_ASSOCIATED:
1:                     break;
1:                     
1:                 case XATransactionState.TRO_FAIL:
1:                     throw new XAException(tranState.rollbackOnlyCode);
1:                     
1:                 default:
1:                     throw new XAException(XAException.XAER_PROTO);
1:             }
1:             
1:             if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
1:                 throw new XAException(XAException.XAER_PROTO);
1:             
1:             if (tranState.isPrepared == onePhase)
1:                 throw new XAException(XAException.XAER_PROTO);
1:             
1:             EmbedConnection conn = tranState.conn;
1:             
1:             try {
0:                 conn.xa_commit(onePhase);
1:             } catch (SQLException sqle) {
1:                 throw wrapInXAException(sqle);
1:             } finally {
1:                 returnConnectionToResource(tranState, xid_im);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Ends the work performed on behalf of a transaction branch. The resource
1:      * manager disassociates the XA resource from the transaction branch
1:      * specified and let the transaction be completed.
1:      *
1:      * <p> If TMSUSPEND is specified in flags, the transaction branch is
1:      * temporarily suspended in incomplete state. The transaction context
1:      * is in suspened state and must be resumed via start with TMRESUME
1:      * specified.
1:      *
1:      * <p> If TMFAIL is specified, the portion of work has failed. The
1:      * resource manager may mark the transaction as rollback-only
1:      *
1:      * <p> If TMSUCCESS is specified, the portion of work has completed
1:      * successfully.
1:      *
1:      * @param xid A global transaction identifier that is the same as what was
1:      * used previously in the start method.
1:      * @param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
1:      *
1:      * @exception XAException An error has occurred.
1:      * Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA,
1:      * XAER_INVAL, XAER_PROTO, or XA_RB*.
1:      */
1:     public final synchronized void end(Xid xid, int flags) throws XAException {
1:         checkXAActive();
1:         
1:         try {
1:             // It is possible that the isolation level state in connection
1:             // handle has gotten out of sync with the real isolation level.
1:             // This can happen if SLQ instead of JDBC api has been used to
1:             // set the isolation level. The code below will check if isolation
1:             // was set using JDBC or SQL and if yes, then it will update the
1:             // isolation state in BrokeredConnection with EmbedConnection's
1:             // isolation level.
1:             if (con.currentConnectionHandle != null)
1:                 con.currentConnectionHandle.getIsolationUptoDate();
1:         } catch (SQLException sqle) {
1:             throw wrapInXAException(sqle);
1:         }
1:         
1:         // ensure immtable and correct equals method.
1:         XAXactId xid_im = new XAXactId(xid);
1:         
1:         boolean endingCurrentXid = false;
1:         
1:         // must match the Xid from start()
1:         if (currentXid != null) {
1:             if (!currentXid.equals(xid_im))
1:                 throw new XAException(XAException.XAER_PROTO);
1:             endingCurrentXid = true;
1:         }
1:         
1:         XATransactionState tranState = getTransactionState(xid_im);
1:         if (tranState == null)
1:             throw new XAException(XAException.XAER_NOTA);
1:         
1:         boolean rollbackOnly = tranState.end(this, flags, endingCurrentXid);
1:         
1:         // RESOLVE - what happens to the connection on a fail
1:         // where we are not ending the current XID.
1:         if (endingCurrentXid) {
1:             currentXid = null;            
1:             con.realConnection = null;
1:         }
1:         
1:         if (rollbackOnly)
1:             throw new XAException(tranState.rollbackOnlyCode);        
1:     }
1: 
1:     /**
1:      * Ask the resource manager to prepare for a transaction commit of the
1:      * transaction specified in xid.
1:      *
1:      * @param xid A global transaction identifier
1:      *
1:      * @return A value indicating the resource manager's vote on the outcome
1:      * of the transaction. The possible values are: XA_RDONLY or XA_OK. If the
1:      * resource manager wants to roll back the transaction, it should do so by
1:      * raising an appropriate XAException in the prepare method.
1:      *
1:      * @exception XAException An error has occurred. Possible exception values
1:      * are: XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or
1:      * XAER_PROTO.
1:      *
1:      */
1:     public final synchronized int prepare(Xid xid) throws XAException {
1:         checkXAActive();
1:         
1:         // ensure immtable and correct equals method.
1:         XAXactId xid_im = new XAXactId(xid);
1:         
1:         XATransactionState tranState = getTransactionState(xid_im);
1:         
1:         if (tranState == null) {
1:             XAResourceManager rm = ra.getXAResourceManager();
1:             
1:             ContextManager inDoubtCM = rm.find(xid);
1:             
1:             // RM also does not know about this xid.
1:             if (inDoubtCM == null)
1:                 throw new XAException(XAException.XAER_NOTA);
1:             
1:             // cannot prepare in doubt transactions
1:             throw new XAException(XAException.XAER_PROTO);
1:             
1:         }
1:         
1:         synchronized (tranState) {
1:             
1:             checkUserCredentials(tranState.creatingResource);
1:             
1:             // Check the transaction is no associated with
1:             // any XAResource.
1:             switch (tranState.associationState) {
1:                 case XATransactionState.T0_NOT_ASSOCIATED:
1:                     break;
1:                     
1:                 case XATransactionState.TRO_FAIL:
1:                     throw new XAException(tranState.rollbackOnlyCode);
1:                     
1:                 default:
1:                     throw new XAException(XAException.XAER_PROTO);
1:             }
1:             
1:             if (tranState.suspendedList != null 
1:                     && tranState.suspendedList.size() != 0)
1:                 throw new XAException(XAException.XAER_PROTO);
1:             
1:             if (tranState.isPrepared)
1:                 throw new XAException(XAException.XAER_PROTO);
1:             
1:             EmbedConnection conn = tranState.conn;
1:             
1:             try {
1:                 
0:                 int ret = conn.xa_prepare();
1:                 
1:                 if (ret == XATransactionController.XA_OK) {
1:                     tranState.isPrepared = true;
1:                     
1:                     return XAResource.XA_OK;
1:                 } else {
1:                     
1:                     returnConnectionToResource(tranState, xid_im);
1:                     return XAResource.XA_RDONLY;
1:                 }
1:             } catch (SQLException sqle) {
1:                 throw wrapInXAException(sqle);
1:             }
1:         }
1:         
1:     }
1: 
1:     /**
1:      * Obtain the current transaction timeout value set for this XAResource
1:      * instance. If XAResource.setTransactionTimeout was not use prior to
0:      * invoking this method, the return value is the default timeout set for
0:      * the resource manager; otherwise, the value used in the previous
0:      * setTransactionTimeout call is returned.
1:      *
0:      * @return the transaction timeout value in seconds.
1:      */
0:     public int getTransactionTimeout() {
0:         return 0;
1:     }
1: 
1:     /**
1:      * This method is called to determine if the resource manager instance
1:      * represented by the target object is the same as the resouce manager
1:      * instance represented by the parameter xares.
1:      *
1:      * @param xares An XAResource object whose resource manager instance is to
1:      * be compared with the resource manager instance of the target object.
1:      *
1:      * @return true if it's the same RM instance; otherwise false.
1:      * @exception XAException An error has occurred. Possible exception values
1:      * are XAER_RMERR, XAER_RMFAIL.
1:      */
1:     public final synchronized boolean isSameRM(XAResource xares) 
1:                                                         throws XAException {
1:         checkXAActive();        
1:         if (xares instanceof EmbedXAResource) {            
1:             return ra == ((EmbedXAResource) xares).ra;
1:         }        
1:         return false;
1:     }
1:     
1:     /**
1:      * Obtain a list of prepared transaction branches from a resource
1:      * manager. The transaction manager calls this method during recovery to
1:      * obtain the list of transaction branches that are currently in prepared
1:      * or heuristically completed states.
1:      *
1:      * @param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS must
1:      * be used when no other flags are set in flags.
1:      *
1:      * @return The resource manager returns zero or more XIDs for the
1:      * transaction branches that are currently in a prepared or heuristically
1:      * completed state. If an error occurs during the operation, the resource
1:      * manager should throw the appropriate XAException.
1:      *
1:      * @exception XAException An error has occurred. Possible values are
1:      * XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and XAER_PROTO.
1:      *
1:      */
1:     public final synchronized Xid[] recover(int flag) throws XAException {
1:         checkXAActive();
1:         
1:         try {
1:             return ra.getXAResourceManager().recover(flag);
1:         } catch (StandardException se) {
1:             throw wrapInXAException(se);
1:         }
1:     }
1:     
1:     /**
1:      * Tell the resource manager to forget about a heuristically completed
1:      * transaction branch.
1:      *
1:      * @param xid A global transaction identifier
1:      * @exception XAException An error has occurred. Possible exception values
1:      * are XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1:      */
1:     public final synchronized void forget(Xid xid) throws XAException {
1:         
1:         checkXAActive();
1:         
1:         // ensure immtable and correct equals method.
1:         XAXactId xid_im = new XAXactId(xid);
1:         
1:         XATransactionState tranState = getTransactionState(xid_im);
1:         if (tranState == null) {
1:             XAResourceManager rm = ra.getXAResourceManager();
1:             
1:             ContextManager inDoubtCM = rm.find(xid);
1:             
1:             // RM also does not know about this xid.
1:             if (inDoubtCM == null)
1:                 throw new XAException(XAException.XAER_NOTA);
1:             
0:             ContextService csf = ContextService.getFactory();
1:             
1:             csf.setCurrentContextManager(inDoubtCM);
1:             try {
1:                 rm.forget(inDoubtCM, xid_im);
1:                 
1:                 // close the connection/transaction since it can never be used again.
0:                 inDoubtCM.cleanupOnError(StandardException.closeException());
1:                 return;
1:             } catch (StandardException se) {
1:                 // The rm threw an exception, clean it up in the approprate
1:                 // context.  There is no transactionResource to handle the
1:                 // exception for us.
0:                 inDoubtCM.cleanupOnError(se);
1:                 throw wrapInXAException(se);
1:             } finally {
1:                 csf.resetCurrentContextManager(inDoubtCM);
1:             }
1:             
1:         }
1:         
0:         throw new XAException(tranState.isPrepared
0:             ? XAException.XAER_NOTA 
0:             : XAException.XAER_PROTO);
1:     }    
1: 
1:     /**
1:      * Inform the resource manager to roll back work done on behalf of a
1:      * transaction branch
1:      *
1:      * @param xid A global transaction identifier
1:      * @exception XAException - An error has occurred
1:      */
1:     public final synchronized void rollback(Xid xid) throws XAException {
1:         checkXAActive();
1:         
1:         // ensure immtable and correct equals method.
1:         XAXactId xid_im = new XAXactId(xid);
1:         
1:         XATransactionState tranState = getTransactionState(xid_im);
1:         
1:         if (tranState == null) {
1:             XAResourceManager rm = ra.getXAResourceManager();
1:             
1:             ContextManager inDoubtCM = rm.find(xid);
1:             
1:             // RM also does not know about this xid.
1:             if (inDoubtCM == null)
1:                 throw new XAException(XAException.XAER_NOTA);
1:             
0:             ContextService csf = ContextService.getFactory();
1:             
1:             csf.setCurrentContextManager(inDoubtCM);
1:             try {
1:                 rm.rollback(inDoubtCM, xid_im);
1:                 
1:                 // close the connection/transaction since it can never be used again.
0:                 inDoubtCM.cleanupOnError(StandardException.closeException());
1:                 return;
1:             } catch (StandardException se) {
1:                 // The rm threw an exception, clean it up in the approprate
1:                 // context.  There is no transactionResource to handle the
1:                 // exception for us.
0:                 inDoubtCM.cleanupOnError(se);
1:                 throw wrapInXAException(se);
1:             } finally {
1:                 csf.resetCurrentContextManager(inDoubtCM);
1:             }
1:             
1:         }
1:         
1:         synchronized (tranState) {
1:             
1:             // Check the transaction is no associated with
1:             // any XAResource.
1:             switch (tranState.associationState) {
1:                 case XATransactionState.T0_NOT_ASSOCIATED:
1:                 case XATransactionState.TRO_FAIL:
1:                     break;
1:                     
1:                 default:
1:                     throw new XAException(XAException.XAER_PROTO);
1:             }
1:             
1:             if (tranState.suspendedList != null 
1:                     && tranState.suspendedList.size() != 0)
1:                 throw new XAException(XAException.XAER_PROTO);
1:             
1:             checkUserCredentials(tranState.creatingResource);
1:             
1:             try {
1:                 
0:                 tranState.conn.xa_rollback();
1:             } catch (SQLException sqle) {
1:                 throw wrapInXAException(sqle);
1:             } finally {
1:                 returnConnectionToResource(tranState, xid_im);
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Set the current transaction timeout value for this XAResource
1:      * instance. Once set, this timeout value is effective until
1:      * setTransactionTimeout is invoked again with a different value. To reset
1:      * the timeout value to the default value used by the resource manager,
1:      * set the value to zero. If the timeout operation is performed
1:      * successfully, the method returns true; otherwise false. If a resource
1:      * manager does not support transaction timeout value to be set
1:      * explicitly, this method returns false.
1:      *
1:      * @param seconds the transaction timeout value in seconds.
1:      * @return true if transaction timeout value is set successfully;
1:      * otherwise false.
1:      *
1:      * @exception XAException - An error has occurred. Possible exception
1:      * values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
1:      */
0:     public boolean setTransactionTimeout(int seconds) {
1:         return false;
1:     }
1: 
1:     /**
1:      * Start work on behalf of a transaction branch specified in xid If TMJOIN
1:      * is specified, the start is for joining a transaction previously seen by
1:      * the resource manager. If TMRESUME is specified, the start is to resume
1:      * a suspended transaction specified in the parameter xid. If neither
1:      * TMJOIN nor TMRESUME is specified and the transaction specified by xid
1:      * has previously been seen by the resource manager, the resource manager
1:      * throws the XAException exception with XAER_DUPID error code.
1:      *
1:      * @param xid A global transaction identifier to be associated with the
1:      * resource
1:      * @param flags One of TMNOFLAGS, TMJOIN, or TMRESUME
1:      *
1:      * @exception XAException An error has occurred. Possible exceptions are
1:      * XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_DUPID, XAER_OUTSIDE, XAER_NOTA,
1:      * XAER_INVAL, or XAER_PROTO.
1:      */
1:     public final synchronized void start(Xid xid, 
1:                                         int flags) throws XAException {
1:         checkXAActive();
1:         
1:         // JDBC 3.0 section 12.3 - One transaction associated with a XAConnection
1:         if (currentXid != null)
1:             throw new XAException(XAException.XAER_PROTO);
1:         
1:         // ensure immtable and correct equals method.
1:         XAXactId xid_im = new XAXactId(xid);
1:         
1:         XATransactionState tranState = getTransactionState(xid_im);
1:         
1:         switch (flags) {
1:             case XAResource.TMNOFLAGS:
1:                 if (tranState != null)
1:                     throw new XAException(XAException.XAER_DUPID);
1:                 
1:                 try {
1:                     
1:                     if (con.realConnection == null) {
1:                         con.openRealConnection();
1:                         
1:                         if (con.currentConnectionHandle != null) {
1:                             
1:                             // since this is a new connection, set its complete
1:                             // state according to the application's Connection
1:                             // handle view of the world.
1:                             con.currentConnectionHandle.setState(true);
1:                             con.realConnection.setApplicationConnection
1:                                     (con.currentConnectionHandle);
1:                         }
1:                         
1:                     } else {
1:                         
1:                         // XAResource.start() auto commits in DB2 when in 
1:                         // auto commit mode.
1:                         if (con.currentConnectionHandle != null) {
1:                             if (con.currentConnectionHandle.getAutoCommit())
1:                                 con.currentConnectionHandle.rollback();
1:                         }
1:                         if (!con.realConnection.transactionIsIdle())
1:                             throw new XAException(XAException.XAER_OUTSIDE);
1:                         
1:                         if (con.currentConnectionHandle != null) {
1:                             // It is possible that the isolation level state 
1:                             // in connection handle has gotten out of sync 
1:                             // with the real isolation level. This can happen 
1:                             // if SLQ instead of JDBC api has been used to set 
1:                             // the isolation level. The code below will check 
1:                             // if isolation was set using JDBC or SQL and if 
1:                             // yes, then it will update the isolation state 
1:                             // in BrokeredConnection with EmbedConnection's
1:                             // isolation level.
1:                             con.currentConnectionHandle.getIsolationUptoDate();
1:                             // we have a current handle so we need to keep
1:                             // the connection state of the current connection.
1:                             con.currentConnectionHandle.setState(true);
1:                             
1:                             // At the local to global transition we need 
1:                             // to discard and close any open held result 
1:                             // sets, a rollback will do this.
1:                             con.realConnection.rollback();
1:                         } else {
1:                             con.resetRealConnection();
1:                         }
1:                         
1:                     }
1:                     
1:                     // Global connections are always in auto commit false mode.
1:                     con.realConnection.setAutoCommit(false);
1:                     
1:                     // and holdability false (cannot hold cursors across 
1:                     // XA transactions.
1:                     con.realConnection.setHoldability(
0:                             JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);
1:                     
0:                     con.realConnection.getLanguageConnection().
1:                             getTransactionExecute().
1:                             createXATransactionFromLocalTransaction(
1:                                                 xid_im.getFormatId(),
1:                                                 xid_im.getGlobalTransactionId(),
1:                                                 xid_im.getBranchQualifier());
1:                     
1:                     
1:                 } catch (StandardException se) {
1:                     throw wrapInXAException(se);
1:                 } catch (SQLException sqle) {
1:                     throw wrapInXAException(sqle);
1:                 }
1:                 
1:                 
0:                 if (!ra.addConnection(xid_im, 
0:                         new XATransactionState(
0:                         con.realConnection.getContextManager(), 
0:                         con.realConnection, this, xid_im)))
1:                     throw new XAException(XAException.XAER_DUPID);
1:                 
1:                 break;
1:                 
1:             case XAResource.TMRESUME:
1:             case XAResource.TMJOIN:
1:                 if (tranState == null)
1:                     throw new XAException(XAException.XAER_NOTA);
1:                 
1:                 tranState.start(this, flags);
1:                 
1:                 if (tranState.conn != con.realConnection) {
1:                     
1:                     if (con.realConnection != null) {
1:                         
1:                         if (!con.realConnection.transactionIsIdle())
1:                             throw new XAException(XAException.XAER_OUTSIDE);
1:                         
1:                         closeUnusedConnection(con.realConnection);
1:                     }
1:                     con.realConnection = tranState.conn;
1:                     
1:                     if (con.currentConnectionHandle != null) {
1:                         
1:                         try {
1:                             // only reset the non-transaction specific 
1:                             // Connection state.
1:                             con.currentConnectionHandle.setState(false);
1:                             con.realConnection.setApplicationConnection(
1:                                     con.currentConnectionHandle);
1:                         } catch (SQLException sqle) {
1:                             throw wrapInXAException(sqle);
1:                         }
1:                     }
1:                     
1:                 }
1:                 
1:                 
1:                 break;
1:                 
1:             default:
1:                 throw new XAException(XAException.XAER_INVAL);
1:         }
1:         
1:         currentXid = xid_im;
1:     }
1:     
1:     /**
1:      * Resturns currently active xid
1:      * @return Xid
1:      */
1:     Xid getCurrentXid () {
1:         return currentXid;
1:     }
1: 
1:     /**
1:      * Returns the XATransactionState of the the transaction
1:      * @param xid_im 
1:      * @return XATransactionState
1:      */
1:     private XATransactionState getTransactionState(XAXactId xid_im) {
1:         return (XATransactionState) ra.findConnection(xid_im);
1:     }
1: 
1:     /**
1:      * Compares the user name and password of the XAResource with
1:      * user name and password of this and throws XAException if there is 
1:      * a mismatch
1:      * @param original EmbedXAResource
1:      */
1:     private void checkUserCredentials(EmbedXAResource original)
1:                                                         throws XAException {        
1:         if (original == this)
1:             return;        
1:         if (original.con.getPassword().equals(con.getPassword()) && 
1:                 (original.con.getUsername().equals(con.getUsername())))
1:             return;                
1:         throw new XAException(XAException.XA_RBINTEGRITY);
1:     }
1:     
1:     /**
1:      * Checks if currently associated connection is active
1:      * throws exception if not
1:      */
1:     private void checkXAActive() throws XAException {    
1:         try {
1:             con.checkActive();
1:         } catch (SQLException sqle) {
1:             throw wrapInXAException(sqle);
1:         }
1:     }
1:     
1:     /**
1:      * Map a SQL exception to appropriate XAException.
1:      * Return the mapped XAException.
1:      */
1:     private static XAException wrapInXAException(SQLException se) {
1:         // Map interesting exceptions to XAException
1:         String sqlstate = se.getSQLState();
1:         String message = se.getMessage();
1:         
1:         XAException xae;
1:         
0:         if (sqlstate == null) {
0:             // no idea what was wrong, throw non-descript error.
0:             if (message != null)
0:                 xae = new XAException(message);
0:             else
0:                 xae = new XAException(XAException.XAER_RMERR);
0:         } else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(
1:                             SQLState.STORE_XA_XAER_DUPID)))
0:             xae = new XAException(XAException.XAER_DUPID);
1:         else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(
1:                                 SQLState.STORE_XA_PROTOCOL_VIOLATION)))
0:             xae = new XAException(XAException.XA_RBPROTO);
1:         else if (sqlstate.equals(SQLState.DEADLOCK))
0:             xae = new XAException(XAException.XA_RBDEADLOCK);
1:         else if (sqlstate.equals(SQLState.LOCK_TIMEOUT))
0:             xae = new XAException(XAException.XA_RBTIMEOUT);
0:         else if (message != null)
0:             xae = new XAException(message);
0:         else
0:             xae = new XAException(XAException.XAER_RMERR);
1:         
0:         if (JVMInfo.JDK_ID >= JVMInfo.J2SE_14)
0:             xae.initCause(se);
1:         return xae;
1:     }
1: 	
1:     /**
1:      * Map a Standard exception to appropriate XAException.
1:      * Return the mapped XAException.
1:      */
1:     private static XAException wrapInXAException(StandardException se) {
1:         return wrapInXAException(
0:                 TransactionResourceImpl.wrapInSQLException(
0:                 (SQLException) null, se));
1:     }
1:     
1:     /**
1:      * Return an underlying connection object back to its XAResource
1:      * if possible. If not close the connection.
1:      * @param tranState 
1:      * @param xid_im 
1:      */
0:     private void returnConnectionToResource(XATransactionState tranState, 
1:                                                             XAXactId xid_im) {
1:         
1:         removeXATransaction(xid_im);    
1:         synchronized (tranState) {
1:             // global transaction is over.
1:             tranState.associationState = XATransactionState.TC_COMPLETED;
1:             tranState.notifyAll();
1:             
1:             EmbedConnection conn = tranState.conn;
1:             
1:             // already set in its own resource
1:             // or can it be returned to its original resource?
1:             if ((tranState.creatingResource.con.realConnection == conn) ||
1:                     (tranState.creatingResource.con.realConnection == null)) {
1:                 
1:                 tranState.creatingResource.con.realConnection = conn;
1:                 
1:                 BrokeredConnection handle = 
1:                         tranState.creatingResource.con.currentConnectionHandle;
1:                 
1:                 conn.setApplicationConnection(handle);
1:                 
1:                 if (handle != null) {
1:                     try {
1:                         handle.setState(true);
1:                     } catch (SQLException sqle) {
1:                         
1:                         // couldn't reset the connection
1:                         closeUnusedConnection(tranState.conn);
1:                         tranState.creatingResource.con.realConnection = null;
1:                     }
1:                 }
1:                 return;
1:             }
1:         }
1:         
1:         // nowhere to place it, close it.
1:         closeUnusedConnection(tranState.conn);
1:     }
1: 
1: 
1:     /**
1:      * Close  an underlying connection object when there is
1:      * no active XAResource to hand it to.
1:      * @param conn 
1:      */
1:     private static void closeUnusedConnection(EmbedConnection conn) {
1:         if (conn != null) {
1:             try {
1:                 conn.close();
1:             } catch (SQLException sqle) {
1:                 
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Removes the xid from currently active transactions
1:      * @param xid_im 
1:      */
0:     private void removeXATransaction(XAXactId xid_im) {
1:         XATransactionState tranState = 
1:                 (XATransactionState) ra.removeConnection(xid_im);
1:         if (tranState != null)
1:             tranState.popMe();
1:     }
1:     
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:7de7ab4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
0: 						if (con.realConnection != null)
0: 							SanityManager.ASSERT(con.realConnection.transactionIsIdle(),
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:9897546
/////////////////////////////////////////////////////////////////////////
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (realConnection != null)
0: 							SanityManager.ASSERT(realConnection.transactionIsIdle(),
0: 									"real connection should have been idle at this point"); 			
0: 					}
============================================================================