1:dc43cf8: /*
1:dc43cf8:    Derby - Class org.apache.derbyTesting.functionTests.tests.engine.RestrictiveFilePermissionsTest
31:dc43cf8: 
1:dc43cf8:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dc43cf8:    contributor license agreements.  See the NOTICE file distributed with
1:dc43cf8:    this work for additional information regarding copyright ownership.
1:dc43cf8:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dc43cf8:    (the "License"); you may not use this file except in compliance with
1:dc43cf8:    the License.  You may obtain a copy of the License at
1:dc43cf8: 
1:dc43cf8:       http://www.apache.org/licenses/LICENSE-2.0
1:dc43cf8: 
1:dc43cf8:    Unless required by applicable law or agreed to in writing, software
1:dc43cf8:    distributed under the License is distributed on an "AS IS" BASIS,
1:dc43cf8:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:dc43cf8:    See the License for the specific language governing permissions and
1:dc43cf8:    limitations under the License.
1:dc43cf8: 
1:dc43cf8:  */
1:dc43cf8: 
1:dc43cf8: package org.apache.derbyTesting.functionTests.tests.engine;
1:dc43cf8: 
1:dc43cf8: import java.io.File;
1:dc43cf8: import java.net.URL;
1:8aa8deb: import java.nio.file.Files;
1:8aa8deb: import java.nio.file.Path;
1:8aa8deb: import java.nio.file.Paths;
1:8aa8deb: import java.nio.file.attribute.AclEntry;
1:8aa8deb: import java.nio.file.attribute.AclFileAttributeView;
1:8aa8deb: import java.nio.file.attribute.PosixFileAttributeView;
1:8aa8deb: import java.nio.file.attribute.PosixFilePermission;
1:8aa8deb: import java.nio.file.attribute.UserPrincipal;
1:dc43cf8: import java.security.AccessController;
1:dc43cf8: import java.security.PrivilegedExceptionAction;
1:dc43cf8: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:8aa8deb: import java.util.Collections;
1:14248ac: import java.util.EnumSet;
1:dc43cf8: import java.util.Properties;
1:dc43cf8: import java.util.Set;
1:dc43cf8: import javax.sql.DataSource;
1:dc43cf8: import junit.framework.Test;
1:dc43cf8: import org.apache.derby.drda.NetworkServerControl;
1:1ae02c9: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:dc43cf8: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:dc43cf8: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.Derby;
1:dc43cf8: import org.apache.derbyTesting.junit.JDBCDataSource;
1:dc43cf8: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1:dc43cf8: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:dc43cf8: 
1:dc43cf8: /**
1:dc43cf8:  * Tests related to use of restrictive file permissions (DERBY-5363).
1:dc43cf8:  */
1:dc43cf8: public class RestrictiveFilePermissionsTest extends BaseJDBCTestCase {
1:dc43cf8: 
1:dc43cf8:     final static String dbName = "RFPT_db";
1:dc43cf8:     final static String dbName2 = dbName + "2";
1:dc43cf8:     final static String exportFileName = "ourExport.txt";
1:dc43cf8:     final static String exportFileName2 = "ourExport2.txt";
1:dc43cf8:     final static String exportLobFileName = "ourExport.lob";
1:dc43cf8:     final static String backupDir = "RFPT_backup";
1:dc43cf8:     final static String derbyDotLog = dbName + ".log";
1:dc43cf8: 
1:dc43cf8:     static String home = null; // derby.system.home
1:dc43cf8: 
1:dc43cf8:     // Perhaps the test user is already running with umask 0077, if so we have
1:dc43cf8:     // no way of discerning if Derby really does anything..
1:dc43cf8:     static boolean supportsLaxTesting = false;
1:dc43cf8: 
1:dc43cf8:     public RestrictiveFilePermissionsTest(String name) {
1:dc43cf8:         super(name);
1:a6026ca:     }
1:a6026ca: 
1:a6026ca: 
1:dc43cf8:     public static Test suite() throws Exception {
1:dc43cf8:         File f = new File("system/testPermissions");
1:dc43cf8:         assertTrue(f.mkdirs());
1:a6026ca: 
1:dc43cf8:         supportsLaxTesting =
10:dc43cf8:             checkAccessToOwner(
1:dc43cf8:                 f,
1:dc43cf8:                 false,
1:dc43cf8:                 UNKNOWN);
1:dc43cf8: 
1:dc43cf8:         if (!supportsLaxTesting) {
1:dc43cf8:             println("warning: testing of lax file permissions in" +
2:dc43cf8:                     "RestrictiveFilePermissionsTest can not take place, " +
1:dc43cf8:                     "use a more liberal runtime default (umask) for the tests");
1:a6026ca:         }
1:dc43cf8: 
1:dc43cf8:         assertDirectoryDeleted(f);
1:dc43cf8: 
1:dc43cf8:         // First collect the tests that check that, if we actually do restrict
1:dc43cf8:         // permissions, the files created by Derby actually *are*
1:dc43cf8:         // restricted. We test that with an embedded Derby with explicit
1:dc43cf8:         // setting of the property derby.storage.useDefaultFilePermissions.
1:dc43cf8:         // The extra setup file is for testJarFiles.
1:dc43cf8: 
1:1ae02c9:         BaseTestSuite totalSuite =
1:1ae02c9:             new BaseTestSuite("RestrictiveFilePermissionsTest");
1:dc43cf8: 
1:dc43cf8:         Properties p = new Properties();
1:dc43cf8:         p.put("derby.storage.useDefaultFilePermissions", "false");
1:dc43cf8:         p.put("derby.stream.error.file", derbyDotLog);
1:dc43cf8: 
2:dc43cf8:         totalSuite.addTest(
1:dc43cf8:             new SystemPropertyTestSetup(
1:dc43cf8:                 TestConfiguration.singleUseDatabaseDecorator(
1:dc43cf8:                     new SupportFilesSetup(
1:1ae02c9:                         new BaseTestSuite(
1:dc43cf8:                             RestrictiveFilePermissionsTest.class,
1:dc43cf8:                             "haveWeGotAllCreatedFilesSuite"),
1:dc43cf8:                         new String[] {"functionTests/tests/lang/dcl_id.jar"}),
1:dc43cf8:                     dbName),
1:dc43cf8:                 p,
2:dc43cf8:                 true));
1:dc43cf8: 
1:dc43cf8:         // Next, test deployment modes, since default settings depend on them
1:dc43cf8: 
1:dc43cf8:         // For server started from command line, we should still get secure
1:dc43cf8:         // permissions.
1:c1192c0:         if (Derby.hasServer()) {
1:c1192c0:             totalSuite.addTest(
1:c1192c0:                 new NetworkServerTestSetup(
1:c1192c0:                     new RestrictiveFilePermissionsTest(
1:c1192c0:                         "doTestCliServerIsRestrictive"),
1:c1192c0:                     new String[]{}, // system properties
1:c1192c0:                     new String[]{}, // non-default start up arguments
1:c1192c0:                     true));
1:c1192c0:         }
1:dc43cf8: 
1:dc43cf8:         // For server started from API, we should see lax permissions.
1:dc43cf8:         //
1:dc43cf8:         if (supportsLaxTesting) {
1:dc43cf8:             totalSuite.addTest(
1:dc43cf8:                 TestConfiguration.clientServerDecorator(
2:dc43cf8:                     new RestrictiveFilePermissionsTest(
1:dc43cf8:                         "doTestNonCliServerIsLax")));
1:dc43cf8: 
1:dc43cf8:             // For embedded, we should see lax permissions also.
1:dc43cf8:             //
1:dc43cf8:             p = new Properties();
1:dc43cf8:             p.put("derby.stream.error.file", derbyDotLog + ".lax");
1:dc43cf8: 
1:dc43cf8:             totalSuite.addTest(
1:dc43cf8:                 new SystemPropertyTestSetup(
1:dc43cf8:                     new RestrictiveFilePermissionsTest("dotestEmbeddedIsLax"),
1:dc43cf8:                     p,
1:dc43cf8:                     true));
1:a6026ca:         }
1:dc43cf8: 
1:dc43cf8:         return totalSuite;
22:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void setUp() throws Exception {
1:dc43cf8:         getConnection();
1:dc43cf8:         home = getSystemProperty("derby.system.home");
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     // Tests that check that check that files and directories actually have got
1:dc43cf8:     // restricted permissions.
1:dc43cf8:     //
1:dc43cf8:     public void testDerbyDotLog() throws Exception {
1:dc43cf8:         File derbydotlog = new File(home, derbyDotLog);
1:dc43cf8: 
1:a6026ca:         checkAccessToOwner(derbydotlog, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testDbDirectory() throws Exception {
1:dc43cf8:         File derbyDbDir = new File(home, dbName);
1:dc43cf8: 
1:a6026ca:         checkAccessToOwner(derbyDbDir, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testServiceProperties() throws Exception {
1:dc43cf8:         File servProp = new File(home, dbName + "/" + "service.properties");
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             servProp, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testTmpDirectory() throws Exception {
1:dc43cf8:         File tmp = new File(home, dbName + "/" + "tmp");
1:dc43cf8: 
1:dc43cf8:         // create a temporary table so we get a file inside the tmp dir
1:dc43cf8:         prepareStatement("declare global temporary table foo(i int) " +
1:dc43cf8:                          "on commit preserve rows not logged").executeUpdate();
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             tmp, true, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testLockFiles() throws Exception {
1:dc43cf8:         File dbLck = new File(home, dbName + "/" + "db.lck");
1:dc43cf8:         File dbexLck = new File(home, dbName + "/" + "dbex.lck");
1:dc43cf8: 
1:a6026ca:         checkAccessToOwner(dbLck, POSITIVE);
1:dc43cf8: 
1:dc43cf8:         if (PrivilegedFileOpsForTests.exists(dbexLck)) {
1:a6026ca:             checkAccessToOwner(dbexLck, POSITIVE);
1:dc43cf8:         }
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testSeg0AndConglomerates() throws Exception {
1:dc43cf8:         File seg0 = new File(home, dbName + "/" + "seg0");
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             seg0, true, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testLogDirAndLogFiles() throws Exception {
1:dc43cf8:         File seg0 = new File(home, dbName + "/" + "log");
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             seg0, true, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testExportedFiles() throws Exception {
1:dc43cf8: 
1:dc43cf8:         Statement s = createStatement();
1:dc43cf8: 
1:dc43cf8:         // Simple exported table file
1:dc43cf8:         s.executeUpdate("call SYSCS_UTIL.SYSCS_EXPORT_TABLE(" +
1:dc43cf8:                         "    'SYS'," +
1:dc43cf8:                         "    'SYSTABLES'," +
1:dc43cf8:                         "    '" + home + "/" + dbName + "/" +
1:dc43cf8:                         exportFileName + "'," +
1:dc43cf8:                         "    NULL," + // column delimiter
1:dc43cf8:                         "    NULL," + // character delimiter
1:dc43cf8:                         "    NULL)"); // code set
1:dc43cf8:         File exp = new File(home, dbName + "/" + exportFileName);
1:dc43cf8: 
1:a6026ca:         checkAccessToOwner(exp, POSITIVE);
1:dc43cf8: 
1:dc43cf8:         // Make a lob table and insert one row
1:dc43cf8:         s.executeUpdate("create table lobtable(i int, c clob)");
1:dc43cf8:         PreparedStatement ps = prepareStatement(
1:dc43cf8:             "insert into lobtable values (1,?)");
1:dc43cf8:         ps.setCharacterStream(
1:dc43cf8:             1, new LoopingAlphabetReader(1000), 1000);
1:dc43cf8:         ps.executeUpdate();
1:dc43cf8: 
1:dc43cf8:         // Export the lob table
1:dc43cf8:         s.executeUpdate("call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE(" +
1:dc43cf8:                         "    'SYS'," +
1:dc43cf8:                         "    'SYSTABLES'," +
1:dc43cf8:                         "    '" + home + "/" + dbName + "/" +
1:dc43cf8:                         exportFileName2 + "'," +
1:dc43cf8:                         "    NULL," + // column delimiter
1:dc43cf8:                         "    NULL," + // character delimiter
1:dc43cf8:                         "    NULL," + // code set
1:dc43cf8:                         "    '" + home + "/" + dbName + "/" +
1:dc43cf8:                         exportLobFileName + "')");
1:dc43cf8: 
1:dc43cf8:         File exp2 = new File(home, dbName + "/" + exportFileName2);
1:dc43cf8:         File expLob = new File(home, dbName + "/" + exportLobFileName);
1:dc43cf8: 
1:dc43cf8:         // Check resuling exported files
1:a6026ca:         checkAccessToOwner(exp2, POSITIVE);
1:dc43cf8: 
1:a6026ca:         checkAccessToOwner(expLob, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testConglomsAfterCompress() throws Exception {
1:dc43cf8:         Statement s = createStatement();
1:dc43cf8:         s.executeUpdate("create table comptable(i int primary key, j int)");
1:dc43cf8:         s.executeUpdate("create index secondary on comptable(j)");
1:dc43cf8: 
1:dc43cf8:         // insert some rows
1:dc43cf8:         PreparedStatement ps = prepareStatement(
1:dc43cf8:             "insert into comptable values (?,?)");
1:dc43cf8:         setAutoCommit(false);
1:dc43cf8:         for (int i=0; i < 10000; i++) {
1:dc43cf8:             ps.setInt(1,i); ps.setInt(2,i);
1:dc43cf8:             ps.executeUpdate();
1:dc43cf8:         }
1:dc43cf8:         commit();
1:dc43cf8: 
1:dc43cf8:         // delete helf the rows
1:dc43cf8:         s.executeUpdate("delete from comptable where MOD(i, 2) = 0");
1:dc43cf8:         commit();
1:dc43cf8: 
1:dc43cf8:         // compress
1:dc43cf8:         setAutoCommit(true);
1:dc43cf8:         s.executeUpdate("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(" +
1:dc43cf8:                         "'APP', 'COMPTABLE', 0)");
1:dc43cf8: 
1:dc43cf8:         // easiest: just check all conglomerates over again..
1:dc43cf8:         File seg0 = new File(home, dbName + "/" + "seg0");
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             seg0, true, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testTruncateTable() throws Exception {
1:dc43cf8: 
1:dc43cf8:         Statement s = createStatement();
1:dc43cf8:         s.executeUpdate("create table trunctable(i int)");
1:dc43cf8:         PreparedStatement ps = prepareStatement(
1:dc43cf8:             "insert into trunctable values (?)");
1:dc43cf8: 
1:dc43cf8:         // insert some data
1:dc43cf8:         setAutoCommit(false);
1:dc43cf8:         for (int i=0; i < 1000; i++) {
1:dc43cf8:             ps.setInt(1,i);
1:dc43cf8:             ps.executeUpdate();
1:dc43cf8:         }
1:dc43cf8:         commit();
1:dc43cf8:         setAutoCommit(true);
1:dc43cf8: 
1:dc43cf8:         // truncate the table
1:dc43cf8:         s.executeUpdate("truncate table trunctable");
1:dc43cf8: 
1:dc43cf8:         // easiest: just check all conglomerates over again..
1:dc43cf8:         File seg0 = new File(home, dbName + "/" + "seg0");
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             seg0, true, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testBackupRestoreFiles() throws Exception {
1:dc43cf8: 
1:dc43cf8:         // First fill the db with a jar and a temporary file, so it's
1:dc43cf8:         // not trivially looking inside
1:dc43cf8: 
1:dc43cf8:         URL jar = SupportFilesSetup.getReadOnlyURL("dcl_id.jar");
1:dc43cf8:         assertNotNull("dcl_id.jar", jar);
1:dc43cf8: 
1:dc43cf8:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:dc43cf8:         cs.setString(1, jar.toExternalForm());
1:dc43cf8:         cs.setString(2, "testBackupFiles");
1:dc43cf8:         cs.executeUpdate();
1:dc43cf8: 
1:dc43cf8:         // create a temporary table so we get a file inside the tmp dir
1:dc43cf8:         prepareStatement("declare global temporary table foo(i int) " +
1:dc43cf8:                          "on commit preserve rows not logged").executeUpdate();
1:dc43cf8: 
1:dc43cf8:         cs = prepareCall
1:dc43cf8:             ("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:dc43cf8:         String fullBackupDir = home + "/" + backupDir;
1:dc43cf8:         cs.setString(1, fullBackupDir);
1:dc43cf8:         cs.execute();
1:dc43cf8: 
1:dc43cf8:         File fbd = new File(fullBackupDir);
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             fbd, true, POSITIVE);
1:dc43cf8: 
1:29435de:         // DERBY-6258: When taking a backup, a file called BACKUP.HISTORY
1:29435de:         // is created in the original database directory. Verify that its
1:29435de:         // permissions are restricted.
1:29435de:         final File db = new File(home, dbName);
1:29435de:         checkAccessToOwner(db, true, POSITIVE);
1:29435de: 
1:dc43cf8:         // Prepare to restore
1:dc43cf8:         TestConfiguration.getCurrent().shutdownDatabase();
1:dc43cf8: 
1:dc43cf8:         // Restore to same db (should replace existing)
1:dc43cf8:         final DataSource ds = JDBCDataSource.getDataSource();
1:dc43cf8:         final String fullRestoreDir =
1:dc43cf8:             home + "/" + backupDir + "/" + dbName;
1:dc43cf8: 
1:dc43cf8:         JDBCDataSource.setBeanProperty(
1:dc43cf8:             ds, "connectionAttributes", "restoreFrom=" + fullRestoreDir);
1:dc43cf8:         final Connection con = ds.getConnection();
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             db, true, POSITIVE);
1:dc43cf8: 
1:dc43cf8:         con.close();
1:dc43cf8: 
1:dc43cf8:         // Restore to another db than current default
1:dc43cf8:         final DataSource ds2 = JDBCDataSource.getDataSource(dbName2);
1:dc43cf8:         JDBCDataSource.setBeanProperty(
1:dc43cf8:             ds2, "connectionAttributes", "restoreFrom=" + fullRestoreDir);
1:dc43cf8:         final Connection con2 = ds2.getConnection();
1:dc43cf8: 
1:dc43cf8:         final File newDb = new File(home, dbName2);
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             newDb, true, POSITIVE);
1:dc43cf8:         con2.close();
1:dc43cf8: 
1:dc43cf8:         // close down both
1:dc43cf8:         final DataSource[] srcs =
1:dc43cf8:                 new DataSource[] {JDBCDataSource.getDataSource(),
1:dc43cf8:                     JDBCDataSource.getDataSource(dbName2)};
1:dc43cf8: 
1:dc43cf8:         for (int i=0; i < srcs.length; i++) {
1:dc43cf8:             JDBCDataSource.setBeanProperty(
1:dc43cf8:                     srcs[i], "connectionAttributes", "shutdown=true");
1:dc43cf8: 
1:a6026ca:             try {
1:dc43cf8:                 srcs[i].getConnection();
1:dc43cf8:                 fail("shutdown failed: expected exception");
1:dc43cf8:             } catch (SQLException e) {
1:dc43cf8:                 assertSQLState(
1:dc43cf8:                     "database shutdown",
1:dc43cf8:                     SQLStateConstants.CONNECTION_EXCEPTION_CONNECTION_FAILURE,
1:dc43cf8:                     e);
1:dc43cf8:             }
1:dc43cf8:         }
1:dc43cf8: 
1:dc43cf8:         assertDirectoryDeleted(newDb);
1:dc43cf8:         assertDirectoryDeleted(new File(home + "/" + backupDir));
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void testJarFiles() throws Exception {
1:dc43cf8:         URL jar = SupportFilesSetup.getReadOnlyURL("dcl_id.jar");
1:dc43cf8:         assertNotNull("dcl_id.jar", jar);
1:dc43cf8: 
1:dc43cf8:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:dc43cf8:         cs.setString(1, jar.toExternalForm());
1:dc43cf8:         cs.setString(2, "anyName");
1:dc43cf8:         cs.executeUpdate();
1:dc43cf8:         File jarsDir = new File(home, dbName + "/" + "jar");
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             jarsDir, true, POSITIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     // Derby deployment mode tests: defaults for permissions differ.
1:dc43cf8:     //
1:dc43cf8: 
1:dc43cf8:     public void doTestCliServerIsRestrictive() throws Exception {
1:dc43cf8:         NetworkServerControl nsctrl =
1:dc43cf8:                 NetworkServerTestSetup.getNetworkServerControl();
1:dc43cf8:         String traceDir = home + "/" + dbName + "_tracefiles_restr";
1:dc43cf8:         nsctrl.setTraceDirectory(traceDir);
1:dc43cf8:         nsctrl.trace(true);
1:dc43cf8:         nsctrl.ping();
1:dc43cf8:         nsctrl.trace(false);
1:dc43cf8: 
1:dc43cf8:         File traceDirF = new File(traceDir);
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             traceDirF, true, POSITIVE);
1:dc43cf8:         nsctrl.shutdown();
1:dc43cf8:         assertDirectoryDeleted(traceDirF);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void doTestNonCliServerIsLax() throws Exception {
1:dc43cf8:         NetworkServerControl nsctrl =
1:dc43cf8:                 NetworkServerTestSetup.getNetworkServerControl();
1:dc43cf8:         String traceDir = home + "/" + dbName + "_tracefiles_lax";
1:dc43cf8:         nsctrl.setTraceDirectory(traceDir);
1:dc43cf8:         nsctrl.trace(true);
1:dc43cf8:         nsctrl.ping();
1:dc43cf8:         nsctrl.trace(false);
1:dc43cf8: 
1:dc43cf8:         File traceDirF = new File(traceDir);
1:dc43cf8: 
1:dc43cf8:         checkAccessToOwner(
1:a6026ca:             traceDirF, true, NEGATIVE);
1:dc43cf8: 
1:dc43cf8:         nsctrl.shutdown();
1:dc43cf8:         assertDirectoryDeleted(traceDirF);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     public void dotestEmbeddedIsLax() throws Exception {
1:dc43cf8:         File derbydotlogF = new File(home, derbyDotLog + ".lax");
1:a6026ca:         checkAccessToOwner(derbydotlogF, NEGATIVE);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     // Auxiliary methods
1:dc43cf8:     //
1:dc43cf8: 
1:dc43cf8:     final public static int NEGATIVE = 0; // expected check outcome set
1:dc43cf8:     final public static int POSITIVE = 1;
1:dc43cf8:     final public static int UNKNOWN = 2;
1:dc43cf8: 
1:dc43cf8:     // Members used by limitAccessToOwner
1:8aa8deb:     private static final Set<PosixFilePermission> UNWANTED_PERMISSIONS =
1:14248ac:             Collections.unmodifiableSet(EnumSet.of(
1:8aa8deb:                     PosixFilePermission.GROUP_EXECUTE,
1:8aa8deb:                     PosixFilePermission.GROUP_READ,
1:8aa8deb:                     PosixFilePermission.GROUP_WRITE,
1:8aa8deb:                     PosixFilePermission.OTHERS_EXECUTE,
1:8aa8deb:                     PosixFilePermission.OTHERS_READ,
1:14248ac:                     PosixFilePermission.OTHERS_WRITE));
1:dc43cf8: 
1:dc43cf8:     /**
1:dc43cf8:      * Check that the file has access only for the owner. Will throw (JUnit
1:dc43cf8:      * failure) if permissions are not strict.
1:dc43cf8:      *
1:dc43cf8:      * @param file (or directory) for which we want to check permissions
1:94ebd3b:      * @param expectedOutcome NEGATIVE or POSITIVE
1:c2f2981:      * @see #checkAccessToOwner(File, boolean, int)
1:dc43cf8:      */
1:dc43cf8: 
1:dc43cf8:     public static void checkAccessToOwner(
1:dc43cf8:             final File file,
1:dc43cf8:             int expectedOutcome) throws Exception {
1:dc43cf8: 
1:a6026ca:         checkAccessToOwner(file, false, expectedOutcome);
1:dc43cf8:     }
1:dc43cf8: 
1:dc43cf8: 
1:dc43cf8:     /**
1:c2f2981:      * Same as {@link #checkAccessToOwner(File, int) checkAccessToOwner}, but
1:c2f2981:      * if {@code doContents} is true, also check files directly contained in
1:c2f2981:      * this file qua directory (not recursively).
1:dc43cf8:      *
1:dc43cf8:      * @param file ((or directory) for which we want to check permissions
1:dc43cf8:      * @param doContents if a directory, an error to call with true if not
1:dc43cf8:      * @param expectedOutcome NEGATIVE, POSITIVE or UNKNOWN
1:dc43cf8:      * @return true if accesses exist for others that owner (expectedOutcome ==
1:dc43cf8:      *              UNKNOWN)
1:dc43cf8:      */
1:dc43cf8:     private static boolean checkAccessToOwner(
1:dc43cf8:             final File file,
1:dc43cf8:             final boolean doContents,
1:dc43cf8:             final int expectedOutcome) throws Exception {
1:dc43cf8:         // Needs to be called in security context since tests run with security
1:dc43cf8:         // manager.
1:dc43cf8:         if (doContents) {
1:dc43cf8:             // visit immediately contained file in this directory also
1:a6026ca:             checkAccessToOwner(file, false, expectedOutcome);
1:8aa8deb:             for (File f : PrivilegedFileOpsForTests.listFiles(file)) {
1:8aa8deb:                 checkAccessToOwner(f, false, expectedOutcome);
1:8aa8deb:             }
1:dc43cf8:         }
1:dc43cf8: 
1:c393694:         return AccessController.
1:8aa8deb:             doPrivileged((PrivilegedExceptionAction<Boolean>) () -> {
1:8aa8deb:                 // Only used with expectedOutcome == UNKNOWN, otherwise
1:8aa8deb:                 // we throw:
1:8aa8deb:                 boolean someThingBeyondOwnerFound = false;
1:dc43cf8: 
1:8aa8deb:                 Path fileP = Paths.get(file.getPath());
1:dc43cf8: 
1:8aa8deb:                 // ACLs supported on this platform? Check the current
1:8aa8deb:                 // file system:
1:8aa8deb:                 AclFileAttributeView aclView = Files.getFileAttributeView(
1:8aa8deb:                         fileP, AclFileAttributeView.class);
1:ff24958: 
1:8aa8deb:                 PosixFileAttributeView posixView = Files.getFileAttributeView(
1:8aa8deb:                         fileP, PosixFileAttributeView.class);
1:ff24958: 
1:8aa8deb:                 if (posixView != null) {
1:8aa8deb:                     // Unixen
1:8aa8deb:                     for (PosixFilePermission perm :
1:8aa8deb:                             posixView.readAttributes().permissions()) {
1:8aa8deb:                         if (UNWANTED_PERMISSIONS.contains(perm)) {
1:8aa8deb:                             if (expectedOutcome == POSITIVE) {
1:8aa8deb:                                 fail("unwanted permission " + perm +
1:8aa8deb:                                      " for file " + file);
1:29435de:                             }
1:8aa8deb:                             someThingBeyondOwnerFound = true;
1:8aa8deb:                             break;
1:8aa8deb:                         }
1:8aa8deb:                     }
1:8aa8deb:                 } else if (aclView != null) {
1:8aa8deb:                     // Windows
1:8aa8deb:                     UserPrincipal owner = Files.getOwner(fileP);
1:8aa8deb:                     for (AclEntry ace : aclView.getAcl()) {
1:8aa8deb:                         UserPrincipal princ = ace.principal();
1:8aa8deb:                         // NTFS, hopefully
1:8aa8deb:                         if (!princ.equals(owner)) {
1:8aa8deb:                             if (expectedOutcome == POSITIVE) {
1:8aa8deb:                                 fail("unexpected uid " + princ.getName() +
1:8aa8deb:                                         " can access file " + file);
1:a6026ca:                             }
1:8aa8deb:                             someThingBeyondOwnerFound = true;
1:8aa8deb:                             break;
1:a6026ca:                         }
1:a6026ca:                     }
1:8aa8deb:                 } else {
1:8aa8deb:                     fail();
1:8aa8deb:                 }
1:a6026ca: 
1:8aa8deb:                 if (expectedOutcome == NEGATIVE && !someThingBeyondOwnerFound) {
1:8aa8deb:                     fail("unexpected restrictive access: " + file);
1:8aa8deb:                 }
1:a6026ca: 
1:8aa8deb:                 if (expectedOutcome != UNKNOWN) {
1:8aa8deb:                     println("checked perms on: " + file);
1:8aa8deb:                 }
1:8aa8deb: 
1:8aa8deb:                 return expectedOutcome == UNKNOWN && someThingBeyondOwnerFound;
1:8aa8deb:         });
1:a6026ca:     }
1:a6026ca: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:14248ac
/////////////////////////////////////////////////////////////////////////
1: import java.util.EnumSet;
/////////////////////////////////////////////////////////////////////////
1:             Collections.unmodifiableSet(EnumSet.of(
1:                     PosixFilePermission.OTHERS_WRITE));
commit:8aa8deb
/////////////////////////////////////////////////////////////////////////
1: import java.nio.file.Files;
1: import java.nio.file.Path;
1: import java.nio.file.Paths;
1: import java.nio.file.attribute.AclEntry;
1: import java.nio.file.attribute.AclFileAttributeView;
1: import java.nio.file.attribute.PosixFileAttributeView;
1: import java.nio.file.attribute.PosixFilePermission;
1: import java.nio.file.attribute.UserPrincipal;
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final Set<PosixFilePermission> UNWANTED_PERMISSIONS =
0:             Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
1:                     PosixFilePermission.GROUP_EXECUTE,
1:                     PosixFilePermission.GROUP_READ,
1:                     PosixFilePermission.GROUP_WRITE,
1:                     PosixFilePermission.OTHERS_EXECUTE,
1:                     PosixFilePermission.OTHERS_READ,
0:                     PosixFilePermission.OTHERS_WRITE)));
/////////////////////////////////////////////////////////////////////////
1:             for (File f : PrivilegedFileOpsForTests.listFiles(file)) {
1:                 checkAccessToOwner(f, false, expectedOutcome);
1:             }
1:             doPrivileged((PrivilegedExceptionAction<Boolean>) () -> {
1:                 // Only used with expectedOutcome == UNKNOWN, otherwise
1:                 // we throw:
1:                 boolean someThingBeyondOwnerFound = false;
1:                 Path fileP = Paths.get(file.getPath());
1:                 // ACLs supported on this platform? Check the current
1:                 // file system:
1:                 AclFileAttributeView aclView = Files.getFileAttributeView(
1:                         fileP, AclFileAttributeView.class);
1:                 PosixFileAttributeView posixView = Files.getFileAttributeView(
1:                         fileP, PosixFileAttributeView.class);
1:                 if (posixView != null) {
1:                     // Unixen
1:                     for (PosixFilePermission perm :
1:                             posixView.readAttributes().permissions()) {
1:                         if (UNWANTED_PERMISSIONS.contains(perm)) {
1:                             if (expectedOutcome == POSITIVE) {
1:                                 fail("unwanted permission " + perm +
1:                                      " for file " + file);
1:                             someThingBeyondOwnerFound = true;
1:                             break;
1:                         }
1:                     }
1:                 } else if (aclView != null) {
1:                     // Windows
1:                     UserPrincipal owner = Files.getOwner(fileP);
1:                     for (AclEntry ace : aclView.getAcl()) {
1:                         UserPrincipal princ = ace.principal();
1:                         // NTFS, hopefully
1:                         if (!princ.equals(owner)) {
1:                             if (expectedOutcome == POSITIVE) {
1:                                 fail("unexpected uid " + princ.getName() +
1:                                         " can access file " + file);
1:                             someThingBeyondOwnerFound = true;
1:                             break;
1:                 } else {
1:                     fail();
1:                 }
1:                 if (expectedOutcome == NEGATIVE && !someThingBeyondOwnerFound) {
1:                     fail("unexpected restrictive access: " + file);
1:                 }
1:                 if (expectedOutcome != UNKNOWN) {
1:                     println("checked perms on: " + file);
1:                 }
1: 
1:                 return expectedOutcome == UNKNOWN && someThingBeyondOwnerFound;
1:         });
commit:d27662d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         if (aclView != null && posixView == null) {
commit:29435de
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-6258: When taking a backup, a file called BACKUP.HISTORY
1:         // is created in the original database directory. Verify that its
1:         // permissions are restricted.
1:         final File db = new File(home, dbName);
1:         checkAccessToOwner(db, true, POSITIVE);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                                 "unexpected uid " + princName +
0:                                                 " can access file " + file);
/////////////////////////////////////////////////////////////////////////
0:                                     if (expectedOutcome == POSITIVE) {
0:                                         fail("unwanted permission " + perm +
0:                                              " for file " + file);
1:                                     }
commit:c393694
/////////////////////////////////////////////////////////////////////////
0:     private static Class<?> filesClz;
0:     private static Class<?> pathClz;
0:     private static Class<?> pathsClz;
0:     private static Class<?> aclEntryClz;
0:     private static Class<?> aclFileAttributeViewClz;
0:     private static Class<?> posixFileAttributeViewClz;
0:     private static Class<?> posixFileAttributesClz;
0:     private static Class<?> posixFilePermissionClz;
0:     private static Class<?> userPrincipalClz;
0:     private static Class<?> linkOptionArrayClz;
0:     private static Class<?> linkOptionClz;
0:     private static Class<?> stringArrayClz;
0:     private static Class<?> fileStoreClz;
/////////////////////////////////////////////////////////////////////////
0:     private static Set<Object> unwantedPermissions;
/////////////////////////////////////////////////////////////////////////
0:             AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction<Void>() {
0:                 public Void run() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.
0:             doPrivileged(new PrivilegedExceptionAction<Boolean>() {
0:                 public Boolean run() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         unwantedPermissions = new HashSet<Object>();
/////////////////////////////////////////////////////////////////////////
commit:c1192c0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.*;
/////////////////////////////////////////////////////////////////////////
1:         if (Derby.hasServer()) {
1:             totalSuite.addTest(
1:                 new NetworkServerTestSetup(
1:                     new RestrictiveFilePermissionsTest(
1:                         "doTestCliServerIsRestrictive"),
1:                     new String[]{}, // system properties
1:                     new String[]{}, // non-default start up arguments
1:                     true));
1:         }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Field;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.HashSet;
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.Derby;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:             return new BaseTestSuite();
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite totalSuite =
1:             new BaseTestSuite("RestrictiveFilePermissionsTest");
/////////////////////////////////////////////////////////////////////////
1:                         new BaseTestSuite(
commit:e8afaeb
/////////////////////////////////////////////////////////////////////////
0:                         if (aclsSupported && aclView != null &&
0:                                 posixView == null) {
0:                             // Windows
/////////////////////////////////////////////////////////////////////////
0:                             // Unixen
commit:ff24958
/////////////////////////////////////////////////////////////////////////
0:     private static Class fileStoreClz;
0:     private static Method supportsFileAttributeView;
0:     private static Method getFileStore;
/////////////////////////////////////////////////////////////////////////
0:                         fileStoreClz = Class.forName(
0:                             "java.nio.file.FileStore");
/////////////////////////////////////////////////////////////////////////
0:                         supportsFileAttributeView = fileStoreClz.getMethod(
0:                             "supportsFileAttributeView",
0:                             new Class[]{Class.class});
0:                         getFileStore = filesClz.getMethod("getFileStore",
0:                                                           new Class[]{pathClz});
/////////////////////////////////////////////////////////////////////////
0:                         // ACLs supported on this platform? Check the current
0:                         // file system:
0:                         Object fileStore = getFileStore.invoke(
0:                             null,
0:                             new Object[]{fileP});
1: 
0:                         boolean aclsSupported =
0:                             ((Boolean)supportsFileAttributeView.invoke(
0:                                 fileStore,
0:                                 new Object[]{aclFileAttributeViewClz})).
0:                             booleanValue();
1: 
/////////////////////////////////////////////////////////////////////////
0:                         if (aclsSupported && aclView != null) {
0:                             // Windows, Solaris 11
commit:c2f2981
/////////////////////////////////////////////////////////////////////////
1:      * @see #checkAccessToOwner(File, boolean, int)
/////////////////////////////////////////////////////////////////////////
1:      * Same as {@link #checkAccessToOwner(File, int) checkAccessToOwner}, but
1:      * if {@code doContents} is true, also check files directly contained in
1:      * this file qua directory (not recursively).
commit:a6026ca
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Field;
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         TestSuite totalSuite = new TestSuite("RestrictiveFilePermissionsTest");
/////////////////////////////////////////////////////////////////////////
1:         checkAccessToOwner(derbydotlog, POSITIVE);
1:         checkAccessToOwner(derbyDbDir, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             servProp, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             tmp, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:         checkAccessToOwner(dbLck, POSITIVE);
1:             checkAccessToOwner(dbexLck, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             seg0, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             seg0, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:         checkAccessToOwner(exp, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:         checkAccessToOwner(exp2, POSITIVE);
1:         checkAccessToOwner(expLob, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             seg0, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             seg0, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             fbd, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             db, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             newDb, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             jarsDir, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             traceDirF, true, POSITIVE);
/////////////////////////////////////////////////////////////////////////
1:             traceDirF, true, NEGATIVE);
/////////////////////////////////////////////////////////////////////////
1:         checkAccessToOwner(derbydotlogF, NEGATIVE);
/////////////////////////////////////////////////////////////////////////
0:     private static Class posixFileAttributesClz;
0:     private static Class posixFilePermissionClz;
/////////////////////////////////////////////////////////////////////////
0:     private static Method permissionsAcl;
0:     private static Method permissionsPosix;
0:     private static Method readAttributes;
0:     private static Field GROUP_EXECUTE;
0:     private static Field GROUP_READ;
0:     private static Field GROUP_WRITE;
0:     private static Field OTHERS_EXECUTE;
0:     private static Field OTHERS_READ;
0:     private static Field OTHERS_WRITE;
0:     private static Set unwantedPermissions;
/////////////////////////////////////////////////////////////////////////
1:         checkAccessToOwner(file, false, expectedOutcome);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             checkAccessToOwner(file, false, expectedOutcome);
0:                             files[i], false, expectedOutcome);
/////////////////////////////////////////////////////////////////////////
0:                 public Object run() throws Exception {
0:                     // lazy initialization
0:                     if (!initialized) {
0:                         initialized = true;
0:                         // If found, we have >= Java 7.
0:                         filesClz = Class.forName(
0:                             "java.nio.file.Files");
0:                         pathClz = Class.forName(
0:                             "java.nio.file.Path");
0:                         pathsClz = Class.forName(
0:                             "java.nio.file.Paths");
0:                         aclEntryClz = Class.forName(
0:                             "java.nio.file.attribute.AclEntry");
0:                         aclFileAttributeViewClz = Class.forName(
0:                             "java.nio.file.attribute." +
0:                             "AclFileAttributeView");
0:                         posixFileAttributeViewClz = Class.forName(
0:                             "java.nio.file.attribute." +
0:                             "PosixFileAttributeView");
0:                         posixFileAttributesClz = Class.forName(
0:                             "java.nio.file.attribute." +
0:                             "PosixFileAttributes");
0:                         posixFilePermissionClz = Class.forName(
0:                             "java.nio.file.attribute." +
0:                             "PosixFilePermission");
0:                         userPrincipalClz = Class.forName(
0:                             "java.nio.file.attribute.UserPrincipal");
0:                         linkOptionArrayClz = Class.forName(
0:                             "[Ljava.nio.file.LinkOption;");
0:                         linkOptionClz = Class.forName(
0:                             "java.nio.file.LinkOption");
0:                         stringArrayClz = Class.forName(
0:                             "[Ljava.lang.String;");
0:                         aclEntryBuilderClz = Class.forName(
0:                             "java.nio.file.attribute.AclEntry$Builder");
0:                         aclEntryTypeClz = Class.forName(
0:                             "java.nio.file.attribute.AclEntryType");
0:                         get = pathsClz.
0:                             getMethod("get",
0:                                       new Class[]{String.class,
0:                                                   stringArrayClz});
0:                         getFileAttributeView = filesClz.
0:                             getMethod("getFileAttributeView",
0:                                       new Class[]{pathClz,
0:                                                   Class.class,
0:                                                   linkOptionArrayClz});
0:                         getOwner = filesClz.
0:                             getMethod(
0:                                 "getOwner",
0:                                 new Class[]{pathClz,
0:                                             linkOptionArrayClz});
0:                         getAcl = aclFileAttributeViewClz.
0:                             getMethod("getAcl", new Class[]{});
0:                         principal = aclEntryClz.
0:                             getMethod("principal", new Class[]{});
0:                         getName = userPrincipalClz.
0:                             getMethod("getName", new Class[]{});
0:                         permissionsAcl = aclEntryClz.
0:                             getMethod("permissions", new Class[]{});
0:                         permissionsPosix = posixFileAttributesClz.
0:                             getMethod("permissions", new Class[]{});
0:                         readAttributes = posixFileAttributeViewClz.
0:                             getMethod("readAttributes", new Class[]{});
0:                         GROUP_EXECUTE =
0:                             posixFilePermissionClz.getField("GROUP_EXECUTE");
0:                         GROUP_READ =
0:                             posixFilePermissionClz.getField("GROUP_READ");
0:                         GROUP_WRITE =
0:                             posixFilePermissionClz.getField("GROUP_WRITE");
0:                         OTHERS_EXECUTE =
0:                             posixFilePermissionClz.getField("OTHERS_EXECUTE");
0:                         OTHERS_READ =
0:                             posixFilePermissionClz.getField("OTHERS_READ");
0:                         OTHERS_WRITE =
0:                             posixFilePermissionClz.getField("OTHERS_WRITE");
0:                         unwantedPermissions = new HashSet();
0:                         unwantedPermissions.add(GROUP_EXECUTE.get(null));
0:                         unwantedPermissions.add(GROUP_READ.get(null));
0:                         unwantedPermissions.add(GROUP_WRITE.get(null));
0:                         unwantedPermissions.add(OTHERS_EXECUTE.get(null));
0:                         unwantedPermissions.add(OTHERS_READ.get(null));
0:                         unwantedPermissions.add(OTHERS_WRITE.get(null));
1:                     }
0:                     // Only used with expectedOutcome == UNKNOWN, otherwise
0:                     // we throw:
0:                     boolean someThingBeyondOwnerFound = false;
0:                     // We have Java 7. We need to call reflectively, since
0:                     // the source level isn't yet at Java 7.
1:                     try {
0:                         Object fileP = get.invoke(
0:                             null, new Object[]{file.getPath(),
0:                                                new String[]{}});
0:                         Object aclView = getFileAttributeView.invoke(
0:                             null,
0:                             new Object[]{
0:                                 fileP,
0:                                 aclFileAttributeViewClz,
0:                                 Array.newInstance(linkOptionClz, 0)});
0:                         Object posixView = getFileAttributeView.invoke(
0:                             null,
0:                             new Object[]{
0:                                 fileP,
0:                                 posixFileAttributeViewClz,
0:                                 Array.newInstance(linkOptionClz, 0)});
0:                         if (aclView != null) { // Windows, Solaris 11
/////////////////////////////////////////////////////////////////////////
0:                                 (List)getAcl.invoke(aclView, (Object[])null);
/////////////////////////////////////////////////////////////////////////
0:                                         Set s = (Set)permissionsAcl.invoke(
/////////////////////////////////////////////////////////////////////////
0:                         } else if (posixView != null) {
0:                             Object posixFileAttributes =
0:                                 readAttributes.invoke(posixView,
0:                                                       new Object[]{});
0:                             Set permissionsSet =
0:                                 (Set)permissionsPosix.invoke(
0:                                     posixFileAttributes, new Object[]{});
0:                             for (Iterator i = permissionsSet.iterator();
0:                                  i.hasNext();) {
0:                                 Object perm = i.next();
1: 
0:                                 if (unwantedPermissions.contains(perm)) {
0:                                     someThingBeyondOwnerFound = true;
0:                                     break;
1:                                 }
0:                             fail();
1: 
0:                         if (expectedOutcome == NEGATIVE &&
0:                                 !someThingBeyondOwnerFound) {
0:                             fail(
0:                                 "unexpected restrictive access: " + file);
1:                         }
1: 
0:                     } catch (IllegalAccessException e) {
0:                         // coding error
0:                         if (SanityManager.DEBUG) {
0:                             SanityManager.THROWASSERT(e);
1:                         }
0:                     } catch (IllegalArgumentException e) {
0:                         // coding error
0:                         if (SanityManager.DEBUG) {
0:                             SanityManager.THROWASSERT(e);
1:                         }
0:                     } catch (InvocationTargetException e) {
0:                         throw e;
1:                     }
1: 
0:                     if (expectedOutcome != UNKNOWN) {
0:                         println("checked perms on: " + file);
1:                     }
1: 
0:                     if (expectedOutcome == UNKNOWN &&
0:                             someThingBeyondOwnerFound) {
0:                         return Boolean.TRUE;
0:                     } else {
0:                         return Boolean.FALSE;
1:                     }
0:                 }});
commit:94ebd3b
/////////////////////////////////////////////////////////////////////////
0:      * @param test the current test
1:      * @param expectedOutcome NEGATIVE or POSITIVE
/////////////////////////////////////////////////////////////////////////
0:      * Same as {@link #checkAccessToOwner(BaseJDBCTestCase, File, int)
commit:dc43cf8
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.engine.RestrictiveFilePermissionsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.engine;
1: 
1: import java.io.File;
0: import java.lang.reflect.Array;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
1: import java.net.URL;
1: import java.security.AccessController;
1: import java.security.PrivilegedExceptionAction;
0: import java.sql.SQLException;
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
1: import java.sql.CallableStatement;
0: import java.util.Iterator;
0: import java.util.List;
1: import java.util.Properties;
1: import java.util.Set;
1: import javax.sql.DataSource;
0: import junit.framework.Assert;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derby.drda.NetworkServerControl;
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: import org.apache.derby.shared.common.sanity.SanityManager;
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
0: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: 
1: /**
1:  * Tests related to use of restrictive file permissions (DERBY-5363).
1:  */
1: public class RestrictiveFilePermissionsTest extends BaseJDBCTestCase {
1: 
1:     final static String dbName = "RFPT_db";
1:     final static String dbName2 = dbName + "2";
1:     final static String exportFileName = "ourExport.txt";
1:     final static String exportFileName2 = "ourExport2.txt";
1:     final static String exportLobFileName = "ourExport.lob";
1:     final static String backupDir = "RFPT_backup";
1:     final static String derbyDotLog = dbName + ".log";
1: 
1:     static String home = null; // derby.system.home
1: 
1:     // Perhaps the test user is already running with umask 0077, if so we have
1:     // no way of discerning if Derby really does anything..
1:     static boolean supportsLaxTesting = false;
1: 
1:     public RestrictiveFilePermissionsTest(String name) {
1:         super(name);
1:     }
1: 
1: 
1:     public static Test suite() throws Exception {
0:         // We can not test file permissions before Java 1.7
0:         if (JVMInfo.JDK_ID < JVMInfo.J2SE_17) {
0:             println("warning: testing of strict permissions in " +
1:                     "RestrictiveFilePermissionsTest can not take place, " +
0:                     "need Java 7");
0:             return new TestSuite();
1:         }
1: 
1:         File f = new File("system/testPermissions");
1:         assertTrue(f.mkdirs());
1: 
1:         supportsLaxTesting =
1:             checkAccessToOwner(
0:                 null,
1:                 f,
1:                 false,
1:                 UNKNOWN);
1: 
1:         if (!supportsLaxTesting) {
1:             println("warning: testing of lax file permissions in" +
1:                     "RestrictiveFilePermissionsTest can not take place, " +
1:                     "use a more liberal runtime default (umask) for the tests");
1:         }
1: 
1:         assertDirectoryDeleted(f);
1: 
1:         // First collect the tests that check that, if we actually do restrict
1:         // permissions, the files created by Derby actually *are*
1:         // restricted. We test that with an embedded Derby with explicit
1:         // setting of the property derby.storage.useDefaultFilePermissions.
1:         // The extra setup file is for testJarFiles.
1: 
0:         TestSuite totalSuite = new TestSuite();
1: 
1:         Properties p = new Properties();
1:         p.put("derby.storage.useDefaultFilePermissions", "false");
1:         p.put("derby.stream.error.file", derbyDotLog);
1: 
1:         totalSuite.addTest(
1:             new SystemPropertyTestSetup(
1:                 TestConfiguration.singleUseDatabaseDecorator(
1:                     new SupportFilesSetup(
0:                         new TestSuite(
1:                             RestrictiveFilePermissionsTest.class,
1:                             "haveWeGotAllCreatedFilesSuite"),
1:                         new String[] {"functionTests/tests/lang/dcl_id.jar"}),
1:                     dbName),
1:                 p,
1:                 true));
1: 
1:         // Next, test deployment modes, since default settings depend on them
1: 
1:         // For server started from command line, we should still get secure
1:         // permissions.
1: 
1:         totalSuite.addTest(
0:             new NetworkServerTestSetup(
1:                 new RestrictiveFilePermissionsTest(
0:                     "doTestCliServerIsRestrictive"),
0:                 new String[]{}, // system properties
0:                 new String[]{}, // non-default start up arguments
1:                 true));
1: 
1:         // For server started from API, we should see lax permissions.
1:         //
1:         if (supportsLaxTesting) {
1:             totalSuite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                     new RestrictiveFilePermissionsTest(
1:                         "doTestNonCliServerIsLax")));
1: 
1:             // For embedded, we should see lax permissions also.
1:             //
1:             p = new Properties();
1:             p.put("derby.stream.error.file", derbyDotLog + ".lax");
1: 
1:             totalSuite.addTest(
1:                 new SystemPropertyTestSetup(
1:                     new RestrictiveFilePermissionsTest("dotestEmbeddedIsLax"),
1:                     p,
1:                     true));
1:         }
1: 
1:         return totalSuite;
1:     }
1: 
1: 
1:     public void setUp() throws Exception {
1:         getConnection();
1:         home = getSystemProperty("derby.system.home");
1:     }
1: 
1: 
1:     // Tests that check that check that files and directories actually have got
1:     // restricted permissions.
1:     //
1:     public void testDerbyDotLog() throws Exception {
1:         File derbydotlog = new File(home, derbyDotLog);
1: 
1:         checkAccessToOwner(
0:             this, derbydotlog, POSITIVE);
1:     }
1: 
1: 
1:     public void testDbDirectory() throws Exception {
1:         File derbyDbDir = new File(home, dbName);
1: 
1:         checkAccessToOwner(
0:             this, derbyDbDir, POSITIVE);
1:     }
1: 
1: 
1:     public void testServiceProperties() throws Exception {
1:         File servProp = new File(home, dbName + "/" + "service.properties");
1: 
1:         checkAccessToOwner(
0:             this, servProp, POSITIVE);
1:     }
1: 
1: 
1:     public void testTmpDirectory() throws Exception {
1:         File tmp = new File(home, dbName + "/" + "tmp");
1: 
1:         // create a temporary table so we get a file inside the tmp dir
1:         prepareStatement("declare global temporary table foo(i int) " +
1:                          "on commit preserve rows not logged").executeUpdate();
1: 
1:         checkAccessToOwner(
0:             this, tmp, true, POSITIVE);
1:     }
1: 
1: 
1:     public void testLockFiles() throws Exception {
1:         File dbLck = new File(home, dbName + "/" + "db.lck");
1:         File dbexLck = new File(home, dbName + "/" + "dbex.lck");
1: 
1:         checkAccessToOwner(
0:             this, dbLck, POSITIVE);
1: 
1:         if (PrivilegedFileOpsForTests.exists(dbexLck)) {
1:             checkAccessToOwner(
0:                     this, dbexLck, POSITIVE);
1:         }
1:     }
1: 
1: 
1:     public void testSeg0AndConglomerates() throws Exception {
1:         File seg0 = new File(home, dbName + "/" + "seg0");
1: 
1:         checkAccessToOwner(
0:             this, seg0, true, POSITIVE);
1:     }
1: 
1: 
1:     public void testLogDirAndLogFiles() throws Exception {
1:         File seg0 = new File(home, dbName + "/" + "log");
1: 
1:         checkAccessToOwner(
0:             this, seg0, true, POSITIVE);
1:     }
1: 
1: 
1:     public void testExportedFiles() throws Exception {
1: 
1:         Statement s = createStatement();
1: 
1:         // Simple exported table file
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_EXPORT_TABLE(" +
1:                         "    'SYS'," +
1:                         "    'SYSTABLES'," +
1:                         "    '" + home + "/" + dbName + "/" +
1:                         exportFileName + "'," +
1:                         "    NULL," + // column delimiter
1:                         "    NULL," + // character delimiter
1:                         "    NULL)"); // code set
1:         File exp = new File(home, dbName + "/" + exportFileName);
1: 
1:         checkAccessToOwner(
0:             this, exp, POSITIVE);
1: 
1:         // Make a lob table and insert one row
1:         s.executeUpdate("create table lobtable(i int, c clob)");
1:         PreparedStatement ps = prepareStatement(
1:             "insert into lobtable values (1,?)");
1:         ps.setCharacterStream(
1:             1, new LoopingAlphabetReader(1000), 1000);
1:         ps.executeUpdate();
1: 
1:         // Export the lob table
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE(" +
1:                         "    'SYS'," +
1:                         "    'SYSTABLES'," +
1:                         "    '" + home + "/" + dbName + "/" +
1:                         exportFileName2 + "'," +
1:                         "    NULL," + // column delimiter
1:                         "    NULL," + // character delimiter
1:                         "    NULL," + // code set
1:                         "    '" + home + "/" + dbName + "/" +
1:                         exportLobFileName + "')");
1: 
1:         File exp2 = new File(home, dbName + "/" + exportFileName2);
1:         File expLob = new File(home, dbName + "/" + exportLobFileName);
1: 
1:         // Check resuling exported files
1:         checkAccessToOwner(
0:             this, exp2, POSITIVE);
1: 
1:         checkAccessToOwner(
0:             this, expLob, POSITIVE);
1:     }
1: 
1: 
1:     public void testConglomsAfterCompress() throws Exception {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table comptable(i int primary key, j int)");
1:         s.executeUpdate("create index secondary on comptable(j)");
1: 
1:         // insert some rows
1:         PreparedStatement ps = prepareStatement(
1:             "insert into comptable values (?,?)");
1:         setAutoCommit(false);
1:         for (int i=0; i < 10000; i++) {
1:             ps.setInt(1,i); ps.setInt(2,i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1: 
1:         // delete helf the rows
1:         s.executeUpdate("delete from comptable where MOD(i, 2) = 0");
1:         commit();
1: 
1:         // compress
1:         setAutoCommit(true);
1:         s.executeUpdate("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(" +
1:                         "'APP', 'COMPTABLE', 0)");
1: 
1:         // easiest: just check all conglomerates over again..
1:         File seg0 = new File(home, dbName + "/" + "seg0");
1: 
1:         checkAccessToOwner(
0:             this, seg0, true, POSITIVE);
1:     }
1: 
1: 
1:     public void testTruncateTable() throws Exception {
1: 
1:         Statement s = createStatement();
1:         s.executeUpdate("create table trunctable(i int)");
1:         PreparedStatement ps = prepareStatement(
1:             "insert into trunctable values (?)");
1: 
1:         // insert some data
1:         setAutoCommit(false);
1:         for (int i=0; i < 1000; i++) {
1:             ps.setInt(1,i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1:         setAutoCommit(true);
1: 
1:         // truncate the table
1:         s.executeUpdate("truncate table trunctable");
1: 
1:         // easiest: just check all conglomerates over again..
1:         File seg0 = new File(home, dbName + "/" + "seg0");
1: 
1:         checkAccessToOwner(
0:             this, seg0, true, POSITIVE);
1:     }
1: 
1: 
1:     public void testBackupRestoreFiles() throws Exception {
1: 
1:         // First fill the db with a jar and a temporary file, so it's
1:         // not trivially looking inside
1: 
1:         URL jar = SupportFilesSetup.getReadOnlyURL("dcl_id.jar");
1:         assertNotNull("dcl_id.jar", jar);
1: 
1:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:         cs.setString(1, jar.toExternalForm());
1:         cs.setString(2, "testBackupFiles");
1:         cs.executeUpdate();
1: 
1:         // create a temporary table so we get a file inside the tmp dir
1:         prepareStatement("declare global temporary table foo(i int) " +
1:                          "on commit preserve rows not logged").executeUpdate();
1: 
1:         cs = prepareCall
1:             ("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:         String fullBackupDir = home + "/" + backupDir;
1:         cs.setString(1, fullBackupDir);
1:         cs.execute();
1: 
1:         File fbd = new File(fullBackupDir);
1:         checkAccessToOwner(
0:             this, fbd, true, POSITIVE);
1: 
1:         // Prepare to restore
1:         TestConfiguration.getCurrent().shutdownDatabase();
1: 
1:         // Restore to same db (should replace existing)
1:         final DataSource ds = JDBCDataSource.getDataSource();
1:         final String fullRestoreDir =
1:             home + "/" + backupDir + "/" + dbName;
1: 
1:         JDBCDataSource.setBeanProperty(
1:             ds, "connectionAttributes", "restoreFrom=" + fullRestoreDir);
1:         final Connection con = ds.getConnection();
1: 
0:         final File db = new File(home, dbName);
1:         checkAccessToOwner(
0:             this, db, true, POSITIVE);
1: 
1:         con.close();
1: 
1:         // Restore to another db than current default
1:         final DataSource ds2 = JDBCDataSource.getDataSource(dbName2);
1:         JDBCDataSource.setBeanProperty(
1:             ds2, "connectionAttributes", "restoreFrom=" + fullRestoreDir);
1:         final Connection con2 = ds2.getConnection();
1: 
1:         final File newDb = new File(home, dbName2);
1: 
1:         checkAccessToOwner(
0:             this, newDb, true, POSITIVE);
1:         con2.close();
1: 
1:         // close down both
1:         final DataSource[] srcs =
1:                 new DataSource[] {JDBCDataSource.getDataSource(),
1:                     JDBCDataSource.getDataSource(dbName2)};
1: 
1:         for (int i=0; i < srcs.length; i++) {
1:             JDBCDataSource.setBeanProperty(
1:                     srcs[i], "connectionAttributes", "shutdown=true");
1: 
0:             try {
1:                 srcs[i].getConnection();
1:                 fail("shutdown failed: expected exception");
1:             } catch (SQLException e) {
1:                 assertSQLState(
1:                     "database shutdown",
1:                     SQLStateConstants.CONNECTION_EXCEPTION_CONNECTION_FAILURE,
1:                     e);
1:             }
1:         }
1: 
1:         assertDirectoryDeleted(newDb);
1:         assertDirectoryDeleted(new File(home + "/" + backupDir));
1:     }
1: 
1: 
1:     public void testJarFiles() throws Exception {
1:         URL jar = SupportFilesSetup.getReadOnlyURL("dcl_id.jar");
1:         assertNotNull("dcl_id.jar", jar);
1: 
1:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:         cs.setString(1, jar.toExternalForm());
1:         cs.setString(2, "anyName");
1:         cs.executeUpdate();
1:         File jarsDir = new File(home, dbName + "/" + "jar");
1: 
1:         checkAccessToOwner(
0:             this, jarsDir, true, POSITIVE);
1:     }
1: 
1: 
1:     // Derby deployment mode tests: defaults for permissions differ.
1:     //
1: 
1:     public void doTestCliServerIsRestrictive() throws Exception {
1:         NetworkServerControl nsctrl =
1:                 NetworkServerTestSetup.getNetworkServerControl();
1:         String traceDir = home + "/" + dbName + "_tracefiles_restr";
1:         nsctrl.setTraceDirectory(traceDir);
1:         nsctrl.trace(true);
1:         nsctrl.ping();
1:         nsctrl.trace(false);
1: 
1:         File traceDirF = new File(traceDir);
1: 
1:         checkAccessToOwner(
0:             this, traceDirF, true, POSITIVE);
1:         nsctrl.shutdown();
1:         assertDirectoryDeleted(traceDirF);
1:     }
1: 
1: 
1:     public void doTestNonCliServerIsLax() throws Exception {
1:         NetworkServerControl nsctrl =
1:                 NetworkServerTestSetup.getNetworkServerControl();
1:         String traceDir = home + "/" + dbName + "_tracefiles_lax";
1:         nsctrl.setTraceDirectory(traceDir);
1:         nsctrl.trace(true);
1:         nsctrl.ping();
1:         nsctrl.trace(false);
1: 
1:         File traceDirF = new File(traceDir);
1: 
1:         checkAccessToOwner(
0:             this, traceDirF, true, NEGATIVE);
1: 
1:         nsctrl.shutdown();
1:         assertDirectoryDeleted(traceDirF);
1:     }
1: 
1: 
1:     public void dotestEmbeddedIsLax() throws Exception {
1:         File derbydotlogF = new File(home, derbyDotLog + ".lax");
1:         checkAccessToOwner(
0:             this, derbydotlogF, NEGATIVE);
1:     }
1: 
1: 
1:     // Auxiliary methods
1:     //
1: 
1:     final public static int NEGATIVE = 0; // expected check outcome set
1:     final public static int POSITIVE = 1;
1:     final public static int UNKNOWN = 2;
1: 
1:     // Members used by limitAccessToOwner
0:     private static boolean initialized = false;
1: 
0:     // Reflection helper objects for calling into Java >= 7
0:     private static Class filesClz;
0:     private static Class pathClz;
0:     private static Class pathsClz;
0:     private static Class aclEntryClz;
0:     private static Class aclFileAttributeViewClz;
0:     private static Class posixFileAttributeViewClz;
0:     private static Class userPrincipalClz;
0:     private static Class linkOptionArrayClz;
0:     private static Class linkOptionClz;
0:     private static Class stringArrayClz;
0:     private static Class aclEntryBuilderClz;
0:     private static Class aclEntryTypeClz;
1: 
0:     private static Method get;
0:     private static Method getFileAttributeView;
0:     private static Method getOwner;
0:     private static Method getAcl;
0:     private static Method principal;
0:     private static Method getName;
0:     private static Method permissions;
1: 
1:     /**
1:      * Check that the file has access only for the owner. Will throw (JUnit
1:      * failure) if permissions are not strict.
0:      * <p/>
0:      * We need Java 7 to ascertain whether we managed to restrict file
0:      * permissions: The Java 6 {@code java.io.File} API only lets us check if
0:      * this process has access.
0:      * <p/>
0:      * In this sense this testing code is asymmetric to the implementation in
0:      * Derby: Java 6 can be used to restrict accesses in Java 6 on Unix, but
0:      * we have no way in Java of checking the results in a portable way. So, if
0:      * we do not have at least Java 7, this method will be a no-op.
1:      *
0:      * @param the current test
1:      * @param file (or directory) for which we want to check permissions
0:      * @param NEGATIVE or POSITIVE
0:      * @see #checkAccessToOwner(BaseJDBCTestCase, File, boolean, int)
1:      */
1: 
1:     public static void checkAccessToOwner(
0:             BaseJDBCTestCase test,
1:             final File file,
1:             int expectedOutcome) throws Exception {
1: 
0:         checkAccessToOwner(test, file, false, expectedOutcome);
1:     }
1: 
1: 
1:     /**
0:      * Same as {@link #checkAccessToOwner(BaseJDBCTestCase, File)
0:      * checkAccessToOwner}, but if {@code doContents} is true, also check files
0:      * directly contained in this file qua directory (not recursively).
1:      *
0:      * @param test
1:      * @param file ((or directory) for which we want to check permissions
1:      * @param doContents if a directory, an error to call with true if not
1:      * @param expectedOutcome NEGATIVE, POSITIVE or UNKNOWN
1:      * @return true if accesses exist for others that owner (expectedOutcome ==
1:      *              UNKNOWN)
1:      */
1:     private static boolean checkAccessToOwner(
0:             final BaseJDBCTestCase test,
1:             final File file,
1:             final boolean doContents,
1:             final int expectedOutcome) throws Exception {
1:         // Needs to be called in security context since tests run with security
1:         // manager.
1:         if (doContents) {
1:             // visit immediately contained file in this directory also
0:             checkAccessToOwner(test, file, false, expectedOutcome);
1: 
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws Exception {
0:                     File [] files = file.listFiles();
0:                     for (int i = 0; i < files.length; i++){
1:                         checkAccessToOwner(
0:                             test, files[i], false, expectedOutcome);
1:                     }
0:                     return null;
0:                 }});
1:         }
1: 
0:         Boolean result =
0:             (Boolean)AccessController.
0:             doPrivileged(new PrivilegedExceptionAction() {
1: 
0:                     public Object run() throws Exception {
0:                         // lazy initialization
0:                         if (!initialized) {
0:                             initialized = true;
1: 
0:                             // If found, we have >= Java 7.
0:                             filesClz = Class.forName(
0:                                 "java.nio.file.Files");
0:                             pathClz = Class.forName(
0:                                 "java.nio.file.Path");
0:                             pathsClz = Class.forName(
0:                                 "java.nio.file.Paths");
0:                             aclEntryClz = Class.forName(
0:                                 "java.nio.file.attribute.AclEntry");
0:                             aclFileAttributeViewClz = Class.forName(
0:                                 "java.nio.file.attribute." +
0:                                 "AclFileAttributeView");
0:                             posixFileAttributeViewClz = Class.forName(
0:                                 "java.nio.file.attribute." +
0:                                 "PosixFileAttributeView");
0:                             userPrincipalClz = Class.forName(
0:                                 "java.nio.file.attribute.UserPrincipal");
0:                             linkOptionArrayClz = Class.forName(
0:                                 "[Ljava.nio.file.LinkOption;");
0:                             linkOptionClz = Class.forName(
0:                                 "java.nio.file.LinkOption");
0:                             stringArrayClz = Class.forName(
0:                                 "[Ljava.lang.String;");
0:                             aclEntryBuilderClz = Class.forName(
0:                                 "java.nio.file.attribute.AclEntry$Builder");
0:                             aclEntryTypeClz = Class.forName(
0:                                 "java.nio.file.attribute.AclEntryType");
1: 
0:                             get = pathsClz.
0:                                 getMethod("get",
0:                                           new Class[]{String.class,
0:                                                       stringArrayClz});
1: 
0:                             getFileAttributeView = filesClz.
0:                                 getMethod("getFileAttributeView",
0:                                           new Class[]{pathClz,
0:                                                       Class.class,
0:                                                       linkOptionArrayClz});
1: 
0:                             getOwner = filesClz.
0:                                 getMethod(
0:                                     "getOwner",
0:                                     new Class[]{pathClz,
0:                                                 linkOptionArrayClz});
0:                             getAcl = aclFileAttributeViewClz.
0:                                 getMethod("getAcl", new Class[]{});
0:                             principal = aclEntryClz.
0:                                 getMethod("principal", new Class[]{});
0:                             getName = userPrincipalClz.
0:                                 getMethod("getName", new Class[]{});
0:                             permissions = aclEntryClz.
0:                                 getMethod("permissions", new Class[]{});
1:                         }
1: 
0:                         // Only used with expectedOutcome == UNKNOWN, otherwise
0:                         // we throw:
0:                         boolean someThingBeyondOwnerFound = false;
1: 
0:                         // We have Java 7. We need to call reflectively, since
0:                         // the source level isn't yet at Java 7.
0:                         try {
0:                             Object fileP = get.invoke(
0:                                 null, new Object[]{file.getPath(),
0:                                                    new String[]{}});
1: 
0:                             Object view = getFileAttributeView.invoke(
0:                                 null,
0:                                 new Object[]{
0:                                     fileP,
0:                                     aclFileAttributeViewClz,
0:                                     Array.newInstance(linkOptionClz, 0)});
1: 
0:                             if (view == null) {
0:                                 // ACLs not supported on this platform
0:                                 fail();
1:                             }
1: 
0:                             // If we have a posix view, we can use ACLs to
0:                             // interface the usual Unix permission masks via
0:                             // the special principals OWNER@, GROUP@ and
0:                             // EVERYONE@
1: 
0:                             Object posixView = getFileAttributeView.invoke(
0:                                 null,
0:                                 new Object[]{
0:                                     fileP,
0:                                     posixFileAttributeViewClz,
0:                                     Array.newInstance(linkOptionClz, 0)});
1: 
0:                             Object owner = getOwner.invoke(
0:                                 null,
0:                                 new Object[]{
0:                                     fileP,
0:                                     Array.newInstance(linkOptionClz, 0)});
1: 
0:                             List oldAcl =
0:                                 (List)getAcl.invoke(view, (Object[])null);
1: 
0:                             for (Iterator i = oldAcl.iterator(); i.hasNext();) {
0:                                 Object ace = i.next();
0:                                 Object princ =
0:                                     principal.invoke(ace, (Object[])null);
0:                                 String princName =
0:                                     (String)getName.invoke(
0:                                         princ, (Object[])null);
1: 
0:                                 if (posixView != null) {
0:                                     if (princName.equals("OWNER@")) {
0:                                         // OK, permission for owner
1: 
0:                                     } else if (
0:                                         princName.equals("GROUP@") ||
0:                                         princName.equals("EVERYONE@")) {
1: 
0:                                         Set s = (Set)permissions.invoke(
0:                                             ace,
0:                                             (Object[])null);
1: 
0:                                         if (expectedOutcome == POSITIVE) {
0:                                             assertTrue(
0:                                                 "Non-empty set of  " +
0:                                                 "permissions for uid: " +
0:                                                 princName + " for file " + file,
0:                                                 s.isEmpty());
0:                                         } else {
0:                                             someThingBeyondOwnerFound =
0:                                                 !s.isEmpty();
1:                                         }
1:                                     }
0:                                 } else {
0:                                     // NTFS, hopefully
0:                                     if (princ.equals(owner)) {
0:                                         // OK
0:                                     } else {
0:                                         if (expectedOutcome == POSITIVE) {
0:                                             fail(
0:                                                 "unexpected uid has access: " +
0:                                                 princName);
0:                                         } else {
0:                                             someThingBeyondOwnerFound = true;
1:                                         }
1:                                     }
1: 
1:                                 }
1:                             }
1: 
0:                             if (expectedOutcome == NEGATIVE &&
0:                                     !someThingBeyondOwnerFound) {
0:                                 fail(
0:                                     "unexpected restrictive access: " + file);
1:                             }
1: 
0:                         } catch (IllegalAccessException e) {
0:                             // coding error
0:                             if (SanityManager.DEBUG) {
0:                                 SanityManager.THROWASSERT(e);
1:                             }
0:                         } catch (IllegalArgumentException e) {
0:                             // coding error
0:                             if (SanityManager.DEBUG) {
0:                                 SanityManager.THROWASSERT(e);
1:                             }
0:                         } catch (InvocationTargetException e) {
0:                             throw e;
1:                         }
1: 
0:                         if (test != null) {
0:                             test.println("checked perms on: " + file);
1:                         }
1: 
0:                         if (expectedOutcome == UNKNOWN &&
0:                                 someThingBeyondOwnerFound) {
0:                             return Boolean.TRUE;
0:                         } else {
0:                             return Boolean.FALSE;
1:                         }
0:                     }});
1: 
0:         return result.booleanValue();
1:     }
1: }
============================================================================