3:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.UnaryOperatorNode
1:6e7bbc8: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
5:eac0369:  */
4:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:099e28f: import java.sql.Types;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.store.access.Qualifier;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A UnaryOperatorNode represents a built-in unary operator as defined by
1:eac0369:  * the ANSI/ISO SQL standard.  This covers operators like +, -, NOT, and IS NULL.
1:eac0369:  * Java operators are not represented here: the JSQL language allows Java
1:eac0369:  * methods to be called from expressions, but not Java operators.
8:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class UnaryOperatorNode extends OperatorNode
1:eac0369: {
1:eac0369: 	String	operator;
1:eac0369: 	String	methodName;
1:3233189:     
1:099e28f: 	String		resultInterfaceType;
1:099e28f: 	String		receiverInterfaceType;
1:eac0369: 
1:3233189: 	/**
1:eac0369: 	 * WARNING: operand may be NULL for COUNT(*).  
1:3233189: 	 */
1:eac0369: 	ValueNode	operand;
1:eac0369: 
1:099e28f: 	// At the time of adding XML support, it was decided that
1:099e28f: 	// we should avoid creating new OperatorNodes where possible.
1:099e28f: 	// So for the XML-related unary operators we just add the
1:099e28f: 	// necessary code to _this_ class, similar to what is done in
1:099e28f: 	// TernarnyOperatorNode. Subsequent unary operators (whether
1:099e28f: 	// XML-related or not) should follow this example when
1:099e28f: 	// possible.
1:3233189:     //
1:3233189:     // This has lead to this class having somewhat of
1:3233189:     // a confused personality. In one mode it is really
1:3233189:     // a parent (abstract) class for various unary operator
1:3233189:     // node implementations, in its other mode it is a concrete
1:3233189:     // class for XMLPARSE and XMLSERIALIZE.
1:eac0369: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_XMLPARSE = 0;
1:2706d1f:     final static int K_XMLSERIALIZE = 1;
1:2706d1f:     final static int K_BASE = 2; // when UnaryOperatorNode is used as
1:2706d1f:                                  // a base class
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:eac0369: 
1:099e28f: 	// NOTE: in the following 4 arrays, order
1:099e28f: 	// IS important.
1:eac0369: 
1:099e28f: 	static final String[] UnaryOperators = {
1:099e28f: 		"xmlparse",
1:099e28f: 		"xmlserialize"
1:099e28f: 	};
1:eac0369: 
1:099e28f: 	static final String[] UnaryMethodNames = {
1:099e28f: 		"XMLParse",
1:099e28f: 		"XMLSerialize"
1:099e28f: 	};
1:eac0369: 
1:099e28f: 	static final String[] UnaryResultTypes = {
1:099e28f: 		ClassName.XMLDataValue, 		// XMLParse
1:099e28f: 		ClassName.StringDataValue		// XMLSerialize
1:099e28f: 	};
1:eac0369: 
1:099e28f: 	static final String[] UnaryArgTypes = {
1:099e28f: 		ClassName.StringDataValue,		// XMLParse
1:099e28f: 		ClassName.XMLDataValue			// XMLSerialize
1:099e28f: 	};
1:eac0369: 
1:28f9484:     /** Target type for XMLSerialize operator. */
1:28f9484:     private DataTypeDescriptor targetType;
1:28f9484: 
1:28f9484:     /** Whether or not an XMLParse operator should preserve whitespace. */
1:28f9484:     private boolean preserveWhitespace;
1:eac0369: 
1:2706d1f:     /**
1:2706d1f:      * When UnaryOperatorNode is used as an base class, this
1:2706d1f:      * constructor is used as {@code super}.
1:2706d1f:      */
1:3bb140c:     UnaryOperatorNode(ValueNode operand,
1:3bb140c:             String operator,
1:3bb140c:             String methodNameOrAddedArgs,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         this.operand = operand;
1:3bb140c:         this.operator = operator;
1:3bb140c:         this.methodName = methodNameOrAddedArgs;
1:2706d1f:         this.kind = K_BASE;
1:3bb140c:     }
1:6e7bbc8: 
1:2706d1f:     /**
1:2706d1f:      * When UnaryOperatorNode is used as an base class, this
1:2706d1f:      * constructor is used as {@code super}.
1:2706d1f:      */
1:3bb140c:     UnaryOperatorNode(ValueNode operand, ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.operand = operand;
1:2706d1f:         this.kind = K_BASE;
1:3bb140c:     }
1:6e7bbc8: 
1:3bb140c: 	/**
1:2706d1f:      * Constructor for a UnaryOperatorNode when used as a concrete class.
1:3bb140c: 	 *
1:3bb140c:      * @param operand       The operand of the node
1:2706d1f:      * @param kind          The kind of operator
1:2706d1f:      * @param targetType    The DTD of the target type
1:2706d1f:      * @param preserveWhiteSpace {@code true} if white space is to be preserved
1:2706d1f:      *                      (relevant for kind == XMLPARSE only)
1:3bb140c:      * @param cm            The context manager
1:3bb140c: 	 */
1:2706d1f:     UnaryOperatorNode(ValueNode          operand,
1:2706d1f:                       int                kind,
1:3bb140c:                       DataTypeDescriptor targetType,
1:3bb140c:                       boolean            preserveWhiteSpace,
1:3bb140c:                       ContextManager     cm)
1:01217c2: 	{
1:3bb140c:         super(cm);
1:3bb140c:         this.operand = operand;
1:2706d1f:         this.kind = kind;
1:2706d1f:         this.operator = UnaryOperators[this.kind];
1:2706d1f:         this.methodName = UnaryMethodNames[this.kind];
1:2706d1f:         this.resultInterfaceType = UnaryResultTypes[this.kind];
1:2706d1f:         this.receiverInterfaceType = UnaryArgTypes[this.kind];
1:6e7bbc8: 
1:2706d1f:         if (kind == K_XMLSERIALIZE) {
1:3bb140c:             this.targetType = targetType;
1:2706d1f:         } else if (kind == K_XMLPARSE) {
1:3bb140c:             this.preserveWhitespace = preserveWhiteSpace;
1:3bb140c:         } else if (SanityManager.DEBUG) {
1:3bb140c:             SanityManager.THROWASSERT(
1:2706d1f:                     "Don't know how to handle operator type " + kind);
1:3bb140c:         }
1:28f9484: 	}
1:6e7bbc8: 
1:eac0369: 	/**
1:eac0369: 	 * Set the operator.
1:eac0369: 	 *
1:eac0369: 	 * @param operator	The operator.
1:eac0369: 	 */
1:eac0369: 	void setOperator(String operator)
1:eac0369: 	{
1:eac0369: 		this.operator = operator;
1:eac0369: 	}
1:3bb140c: 
1:eac0369: 	/**
1:eac0369: 	 * Get the operator of this unary operator.
1:eac0369: 	 *
1:eac0369: 	 * @return	The operator of this unary operator.
1:eac0369: 	 */
1:eac0369: 	String getOperatorString()
1:eac0369: 	{
1:eac0369: 		return operator;
1:eac0369: 	}
1:3bb140c: 
1:eac0369: 	/**
1:eac0369: 	 * Set the methodName.
1:eac0369: 	 *
1:eac0369: 	 * @param methodName	The methodName.
1:eac0369: 	 */
1:eac0369: 	void setMethodName(String methodName)
1:eac0369: 	{
1:eac0369: 		this.methodName = methodName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return		This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "operator: " + operator + "\n" +
1:eac0369: 				"methodName: " + methodName + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
2:eac0369: 			if (operand != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "operand: ");
1:eac0369: 				operand.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the operand of this unary operator.
1:eac0369: 	 *
1:eac0369: 	 * @return	The operand of this unary operator.
1:eac0369: 	 */
1:3bb140c:     ValueNode getOperand()
1:eac0369: 	{
1:eac0369: 		return operand;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d5bc20f: 	 * Get the parameter operand of this unary operator.
1:d5bc20f: 	 * For the example below, for abs unary operator node, we want to get ?
1:d5bc20f: 	 * select * from t1 where -? = max_cni(abs(-?), sqrt(+?))
1:eac0369: 	 * 
1:d5bc20f: 	 * This gets called when ParameterNode is needed to get parameter
1:d5bc20f: 	 * specific information like getDefaultValue(), getParameterNumber() etc 
1:eac0369: 	 * 
1:d5bc20f: 	 * @return	The parameter operand of this unary operator else null.
1:eac0369: 	 */
1:3bb140c:     ParameterNode getParameterOperand() throws StandardException
1:eac0369: 	{
1:d5bc20f: 		if (requiresTypeFromContext() == false)
1:d5bc20f: 			return null;
1:6e7bbc8: 		else {
1:d5bc20f: 			UnaryOperatorNode tempUON = this;
1:d5bc20f: 			while (!(tempUON.getOperand() instanceof ParameterNode)) 
1:d5bc20f: 				tempUON = (UnaryOperatorNode)tempUON.getOperand();
1:d5bc20f: 			return (ParameterNode)(tempUON.getOperand());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:3233189:      * This method is the implementation for XMLPARSE and XMLSERIALIZE.
1:3233189:      * Sub-classes need to implement their own bindExpression() method
1:3233189:      * for their own specific rules.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:09c2697:     ValueNode bindExpression(
1:71c8e86:             FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:09c2697:         bindOperand(fromList, subqueryList, aggregates);
1:2706d1f: 
1:2706d1f:         if (kind == K_XMLPARSE) {
1:3233189:             bindXMLParse();
1:2706d1f:         } else if (kind == K_XMLSERIALIZE) {
1:3233189:             bindXMLSerialize();
1:2706d1f:         }
1:2706d1f: 
1:3233189:         return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:3233189: 	 * Bind the operand for this unary operator.
1:3233189:      * Binding the operator may change the operand node.
1:3233189:      * Sub-classes bindExpression() methods need to call this
1:3233189:      * method to bind the operand.
1:eac0369: 	 */
1:3233189: 	protected void bindOperand(
1:71c8e86:             FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:09c2697:         operand = operand.bindExpression(fromList, subqueryList, aggregates);
1:eac0369: 
1:e2f08d2: 		if (operand.requiresTypeFromContext()) {
1:eac0369: 			bindParameter();
1:e2f08d2:             // If not bound yet then just return.
1:e2f08d2:             // The node type will be set by either
1:e2f08d2:             // this class' bindExpression() or a by
1:e2f08d2:             // a node that contains this expression.
1:e2f08d2:             if (operand.getTypeServices() == null)
1:e2f08d2:                 return;
1:6e7bbc8:         }
1:6e7bbc8: 
1:eac0369: 		/* If the operand is not a built-in type, then generate a bound conversion
1:eac0369: 		 * tree to a built-in type.
1:eac0369: 		 */
1:eac0369: 		if (! (operand instanceof UntypedNullConstantNode) &&
1:08d6ce2: 			operand.getTypeId().userType() &&
1:eac0369: 			! (this instanceof IsNullNode))
1:eac0369: 		{
1:eac0369: 			operand = operand.genSQLJavaSQLTree();
1:e2f08d2: 		}
1:eac0369: 	}
1:6e7bbc8: 
1:eac0369:     /**
1:099e28f:      * Bind an XMLPARSE operator.  Makes sure the operand type
1:099e28f:      * is correct, and sets the result type.
1:eac0369:      *
1:099e28f:      * @exception StandardException Thrown on error
1:eac0369:      */
1:e2f08d2:     private void bindXMLParse() throws StandardException
1:eac0369:     {
1:099e28f:         // Check the type of the operand - this function is allowed only on
1:099e28f:         // string value (char) types.
1:099e28f:         TypeId operandType = operand.getTypeId();
1:099e28f:         if (operandType != null) {
1:099e28f:             switch (operandType.getJDBCTypeId())
1:eac0369:             {
1:099e28f:                 case Types.CHAR:
1:099e28f:                 case Types.VARCHAR:
1:099e28f:                 case Types.LONGVARCHAR:
1:099e28f:                 case Types.CLOB:
1:099e28f:                     break;
1:099e28f:                 default:
1:eac0369:                 {
1:099e28f:                     throw StandardException.newException(
1:099e28f:                         SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:099e28f:                         methodName,
1:099e28f:                         operandType.getSQLTypeName());
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:099e28f:         // The result type of XMLParse() is always an XML type.
1:099e28f:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1:e33b8d8:                 Types.SQLXML));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:099e28f:      * Bind an XMLSERIALIZE operator.  Makes sure the operand type
1:099e28f:      * and target type are both correct, and sets the result type.
1:eac0369:      *
1:099e28f:      * @exception StandardException Thrown on error
1:eac0369:      */
1:e2f08d2:     private void bindXMLSerialize() throws StandardException
1:eac0369:     {
1:099e28f:         TypeId operandType;
1:eac0369: 
1:099e28f:         // Check the type of the operand - this function is allowed only on
1:099e28f:         // the XML type.
1:099e28f:         operandType = operand.getTypeId();
1:099e28f:         if ((operandType != null) && !operandType.isXMLTypeId())
1:d5bc20f:         {
1:099e28f:             throw StandardException.newException(
1:099e28f:                 SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:099e28f:                 methodName,
1:099e28f:                 operandType.getSQLTypeName());
1:d5bc20f:         }
1:eac0369: 
1:099e28f:         // Check the target type.  We only allow string types to be used as
1:099e28f:         // the target type.  The targetType is stored as the first Object
1:099e28f:         // in our list of additional parameters, so we have to retrieve
1:099e28f:         // it from there.
1:099e28f:         if (SanityManager.DEBUG) {
1:099e28f:             SanityManager.ASSERT(
1:28f9484:                 (targetType != null),
1:099e28f:                 "Failed to locate target type for XMLSERIALIZE operator");
1:d5bc20f:         }
1:eac0369: 
1:099e28f:         TypeId targetTypeId = targetType.getTypeId();
1:099e28f:         switch (targetTypeId.getJDBCTypeId())
1:d5bc20f:         {
1:099e28f:             case Types.CHAR:
1:099e28f:             case Types.VARCHAR:
1:099e28f:             case Types.LONGVARCHAR:
1:099e28f:             case Types.CLOB:
1:099e28f:                 break;
1:099e28f:             default:
1:d5bc20f:             {
1:099e28f:                 throw StandardException.newException(
1:099e28f:                     SQLState.LANG_INVALID_XMLSERIALIZE_TYPE,
1:099e28f:                     targetTypeId.getSQLTypeName());
1:d5bc20f:             }
1:d5bc20f:         }
1:eac0369: 
1:099e28f:         // The result type of XMLSerialize() is always a string; which
1:099e28f:         // kind of string is determined by the targetType field.
1:099e28f:         setType(targetType);
1:649830f: 		//Set the collation type to be same as the current schema's 
1:649830f: 		//collation type. 
1:9ed7c4d:         setCollationUsingCompilationSchema();
2:099e28f:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (operand != null)
1:eac0369: 		{
1:eac0369: 			operand = operand.preprocess(numTables,
1:eac0369: 										 outerFromList, outerSubqueryList,
1:eac0369: 										 outerPredicateList);
1:eac0369: 		}
3:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level)
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return (operand == null) ? 
1:eac0369: 				false : 
1:eac0369: 				operand.categorize(referencedTabs, simplePredsOnly);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (operand != null)
1:eac0369: 		{
1:eac0369: 			operand = operand.remapColumnReferencesToExpressions();
1:eac0369: 		}
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:eac0369: 		return (operand == null) ? true: operand.isConstantExpression();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		return (operand == null) ?
1:eac0369: 					true :
1:eac0369: 					operand.constantExpression(whereClause);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * By default unary operators don't accept ? parameters as operands.
1:eac0369: 	 * This can be over-ridden for particular unary operators.
1:eac0369: 	 *
1:eac0369: 	 *	We throw an exception if the parameter doesn't have a datatype
1:eac0369: 	 *	assigned to it yet.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown if ?  parameter doesn't
1:eac0369: 	 *									have a type bound to it yet.
1:eac0369: 	 *									? parameter where it isn't allowed.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void bindParameter() throws StandardException
1:be12a80: 	{
1:2706d1f:         if (kind == K_XMLPARSE)
1:eac0369: 		{
1:be12a80: 			/* SQL/XML[2006] allows both binary and character strings for
1:be12a80: 			 * the XMLParse parameter (section 10.16:Function).  The spec
1:be12a80: 			 * also goes on to say, in section 6.15:Conformance Rules:4,
1:be12a80: 			 * that:
1:be12a80: 			 *
1:be12a80: 			 * "Without Feature X066, XMLParse: BLOB input and DOCUMENT
1:be12a80: 			 * option, in conforming SQL language, the declared type of
1:be12a80: 			 * the <string value expression> immediately contained in
1:be12a80: 			 * <XML parse> shall not be a binary string type."
1:be12a80: 			 *
1:be12a80: 			 * Thus since Derby doesn't currently support BLOB input,
1:be12a80: 			 * we have to ensure that the "declared type" of the parameter
1:be12a80: 			 * is not a binary string type; i.e. it must be a character
1:be12a80: 			 * string type.  Since there's no way to determine what the
1:be12a80: 			 * declared type is from the XMLPARSE syntax, the user must
1:be12a80: 			 * explicitly declare the type of the parameter, and it must
1:be12a80: 			 * be a character string. They way s/he does that is by
1:be12a80: 			 * specifying an explicit CAST on the parameter, such as:
1:be12a80: 			 *
1:be12a80: 			 *  insert into myXmlTable (xcol) values
1:be12a80: 			 *    XMLPARSE(DOCUMENT cast (? as CLOB) PRESERVE WHITESPACE);
1:be12a80: 			 *
1:be12a80: 			 * If that was done then we wouldn't be here; we only get
1:be12a80: 			 * here if the parameter was specified without a cast.  That
1:be12a80: 			 * means we don't know what the "declared type" is and so
1:be12a80: 			 * we throw an error.
1:be12a80: 			 */
1:be12a80: 			throw StandardException.newException(
1:be12a80: 				SQLState.LANG_XMLPARSE_UNKNOWN_PARAM_TYPE);
1:eac0369: 		}
1:2706d1f:         else if (kind == K_XMLSERIALIZE) {
1:099e28f:         // For now, since JDBC has no type defined for XML, we
1:099e28f:         // don't allow binding to an XML parameter.
1:099e28f: 	        throw StandardException.newException(
1:099e28f:  	           SQLState.LANG_ATTEMPT_TO_BIND_XML);
1:099e28f: 		}
1:099e28f: 		else if (operand.getTypeServices() == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this unary operator.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:099e28f: 		String resultTypeName = 
1:2706d1f:             (kind == K_BASE)
1:099e28f: 				? getTypeCompiler().interfaceName()
1:099e28f: 				: resultInterfaceType;
1:eac0369: 			
1:eac0369: 		// System.out.println("resultTypeName " + resultTypeName + " method " + methodName);
1:eac0369: 		// System.out.println("isBooleanTypeId() " + getTypeId().isBooleanTypeId());
1:eac0369: 
1:eac0369: 		boolean needField = !getTypeId().isBooleanTypeId();
1:eac0369: 
1:eac0369: 		String receiverType = getReceiverInterfaceName();
1:eac0369: 		operand.generateExpression(acb, mb);
1:eac0369: 		mb.cast(receiverType);
1:eac0369: 
1:eac0369: 		if (needField) {
1:eac0369: 
1:eac0369: 			/* Allocate an object for re-use to hold the result of the operator */
1:eac0369: 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1:eac0369: 			mb.getField(field);
1:6e7bbc8: 
1:d09782a:             int numArgs = 1;
1:d09782a: 
1:d09782a:             // XML operators take extra arguments.
1:d09782a:             numArgs += addXmlOpMethodParams(acb, mb, field);
1:d09782a: 
1:d09782a:             mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:d09782a:                           methodName, resultTypeName, numArgs);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Store the result of the method call in the field, so we can re-use
1:eac0369: 			** the object.
1:6e7bbc8: 			*/
1:eac0369: 			mb.putField(field);
1:eac0369: 		} else {
1:6e7bbc8: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:6e7bbc8: 				methodName, resultTypeName, 0);
1:6e7bbc8: 		}
1:6e7bbc8: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine the type the binary method is called on.
1:eac0369: 	 * By default, based on the receiver.
1:6e7bbc8: 	 *
1:eac0369: 	 * Override in nodes that use methods on super-interfaces of
1:eac0369: 	 * the receiver's interface, such as comparisons.
1:6e7bbc8: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     String getReceiverInterfaceName() throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(operand!=null,
1:eac0369: 								"cannot get interface without operand");
1:eac0369: 		}
1:eac0369: 
1:2706d1f:         if (kind != K_BASE)
1:099e28f: 			return receiverInterfaceType;
1:eac0369: 		
1:eac0369: 		return operand.getTypeCompiler().interfaceName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *		CONSTANT			- immutable
1:6e7bbc8: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** If we have nothing in the operator, then
1:eac0369: 		** it must be constant.
1:eac0369: 		*/
1:eac0369: 		return (operand != null) ?
1:eac0369: 				operand.getOrderableVariantType() :
1:eac0369: 				Qualifier.CONSTANT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (operand != null)
1:eac0369: 		{
1:eac0369: 			operand = (ValueNode)operand.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:6e7bbc8:      * Add some additional arguments to our method call for
1:6e7bbc8:      * XML related operations like XMLPARSE and XMLSERIALIZE.
1:d09782a:      *
1:d09782a:      * @param acb the builder for the class in which the method lives
1:099e28f:      * @param mb The MethodBuilder that will make the call.
1:d09782a:      * @param resultField the field that contains the previous result
1:099e28f:      * @return Number of parameters added.
1:eac0369:      */
1:9f2ed7d:     int addXmlOpMethodParams(ExpressionClassBuilder acb,
1:d09782a: 		MethodBuilder mb, LocalField resultField) throws StandardException
1:eac0369:     {
1:2706d1f:         if ((kind != K_XMLPARSE) &&
1:2706d1f:                 (kind != K_XMLSERIALIZE)) {
1:6e7bbc8:             // nothing to do.
1:6e7bbc8:             return 0;
1:2706d1f:         }
1:eac0369: 
1:2706d1f:         if (kind == K_XMLSERIALIZE) {
1:099e28f:         // We push the target type's JDBC type id as well as
1:099e28f:         // the maximum width, since both are required when
1:099e28f:         // we actually perform the operation, and both are
1:6e7bbc8:         // primitive types.  Note: we don't have to save
1:6e7bbc8:         // any objects for XMLSERIALIZE because it doesn't
1:6e7bbc8:         // require any XML-specific objects: it just returns
1:6e7bbc8:         // the serialized version of the XML value, which we
1:6e7bbc8:         // already found when the XML value was created (ex.
1:6e7bbc8:         // as part of the XMLPARSE work).
1:27f9fd6:         // We also need to pass the collation type of the current
1:27f9fd6:         // compilation schema. If the JDBC type id is of type
1:27f9fd6:         // StringDataValue, then we should use the collation to
1:27f9fd6:         // decide whether we need to generate collation sensitive
1:27f9fd6:         // StringDataValue.
1:099e28f:             mb.push(targetType.getJDBCTypeId());
1:099e28f:             mb.push(targetType.getMaximumWidth());
1:27f9fd6:             mb.push(getSchemaDescriptor(null, false).getCollationType());
1:6e7bbc8:             return 3;
1:eac0369:         }
1:01217c2: 
1:6e7bbc8:         /* Else we're here for XMLPARSE. */
1:eac0369: 
1:d09782a:         // XMLPARSE is different from other unary operators in that the method
1:d09782a:         // must be called on the result object (the XML value) and not on the
1:d09782a:         // operand (the string value). We must therefore make sure the result
1:d09782a:         // object is not null.
1:d09782a:         MethodBuilder constructor = acb.getConstructor();
1:d09782a:         acb.generateNull(constructor, getTypeCompiler(),
1:d09782a:                          getTypeServices().getCollationType());
1:d09782a:         constructor.setField(resultField);
1:d09782a: 
1:d09782a:         // Swap operand and result object so that the method will be called
1:d09782a:         // on the result object.
1:d09782a:         mb.swap();
1:eac0369: 
1:6e7bbc8:         // Push whether or not we want to preserve whitespace.
1:28f9484:         mb.push(preserveWhitespace);
1:d09782a: 
1:d09782a:         // Push the SqlXmlUtil instance as the next argument.
1:d09782a:         pushSqlXmlUtil(acb, mb, null, null);
1:d09782a: 
1:044afae:         return 2;
1:eac0369:     }
1:eac0369:     
1:01217c2:     /**
1:01217c2:      * @throws StandardException 
1:01217c2:      * {@inheritDoc}
1:01217c2:      */
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:01217c2:     {
1:2706d1f:         if (isSameNodeKind(o)) {
1:01217c2:     		UnaryOperatorNode other = (UnaryOperatorNode)o;
1:01217c2:     		return (operator.equals(other.operator) && 
1:2706d1f:                    ((operand == other.operand)||
1:2706d1f:                    ((operand != null) && operand.isEquivalent(other.operand))));
1:01217c2:     	}
1:01217c2:     	return false;
1:01217c2:     }
1:2706d1f: 
1:2706d1f:     @Override
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) && ((UnaryOperatorNode)o).kind == kind;
1:2706d1f:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:be12a80
/////////////////////////////////////////////////////////////////////////
0: 		if (operatorType == XMLPARSE_OP)
1: 		{
1: 			/* SQL/XML[2006] allows both binary and character strings for
1: 			 * the XMLParse parameter (section 10.16:Function).  The spec
1: 			 * also goes on to say, in section 6.15:Conformance Rules:4,
1: 			 * that:
1: 			 *
1: 			 * "Without Feature X066, XMLParse: BLOB input and DOCUMENT
1: 			 * option, in conforming SQL language, the declared type of
1: 			 * the <string value expression> immediately contained in
1: 			 * <XML parse> shall not be a binary string type."
1: 			 *
1: 			 * Thus since Derby doesn't currently support BLOB input,
1: 			 * we have to ensure that the "declared type" of the parameter
1: 			 * is not a binary string type; i.e. it must be a character
1: 			 * string type.  Since there's no way to determine what the
1: 			 * declared type is from the XMLPARSE syntax, the user must
1: 			 * explicitly declare the type of the parameter, and it must
1: 			 * be a character string. They way s/he does that is by
1: 			 * specifying an explicit CAST on the parameter, such as:
1: 			 *
1: 			 *  insert into myXmlTable (xcol) values
1: 			 *    XMLPARSE(DOCUMENT cast (? as CLOB) PRESERVE WHITESPACE);
1: 			 *
1: 			 * If that was done then we wouldn't be here; we only get
1: 			 * here if the parameter was specified without a cast.  That
1: 			 * means we don't know what the "declared type" is and so
1: 			 * we throw an error.
1: 			 */
1: 			throw StandardException.newException(
1: 				SQLState.LANG_XMLPARSE_UNKNOWN_PARAM_TYPE);
commit:6e7bbc8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.SqlXmlUtil;
/////////////////////////////////////////////////////////////////////////
0: 	// Class used to hold XML-specific objects required for
0: 	// parsing/serializing XML data.
0: 	private SqlXmlUtil sqlxUtil;
1: 
/////////////////////////////////////////////////////////////////////////
0:         // Create a new XML compiler object; the constructor
0:         // here automatically creates the XML-specific objects 
0:         // required for parsing/serializing XML, so all we
0:         // have to do is create an instance.
0:         sqlxUtil = new SqlXmlUtil();
1: 
/////////////////////////////////////////////////////////////////////////
0: 		// For XML operator we do some extra work.
0: 		boolean xmlGen = (operatorType == XMLPARSE_OP) ||
0: 			(operatorType == XMLSERIALIZE_OP);
1: 
0: 		if (xmlGen) {
0: 		// We create an execution-time object from which we call
0: 		// the necessary methods.  We do this for two reasons: 1) this
0: 		// level of indirection allows us to separate the XML data type
0: 		// from the required XML implementation classes (esp. JAXP and
0: 		// Xalan classes)--for more on how this works, see the comments
0: 		// in SqlXmlUtil.java; and 2) this allows us to create the
0: 		// required XML objects a single time (which we did at bind time
0: 		// when we created a new SqlXmlUtil) and then reuse those objects
0: 		// for each row in the target result set, instead of creating
0: 		// new objects every time; see SqlXmlUtil.java for more.
0: 			mb.pushNewStart(
0: 				"org.apache.derby.impl.sql.execute.SqlXmlExecutor");
0: 			mb.pushNewComplete(addXmlOpMethodParams(acb, mb));
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0: 			/* If we're calling a method on a class (SqlXmlExecutor) instead
0: 			 * of calling a method on the operand interface, then we invoke
0: 			 * VIRTUAL; we then have 2 args (the operand and the local field)
0: 			 * instead of one, i.e:
1: 			 *
0: 			 *  SqlXmlExecutor.method(operand, field)
1: 			 *
0: 			 * instead of
1: 			 *
0: 			 *  <operand>.method(field).
1: 			 */
0: 			if (xmlGen) {
0: 				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
0: 					methodName, resultTypeName, 2);
1: 			}
1: 			else {
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE,
0: 					(String) null, methodName, resultTypeName, 1);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1: 				methodName, resultTypeName, 0);
/////////////////////////////////////////////////////////////////////////
1:      * Add some additional arguments to our method call for
1:      * XML related operations like XMLPARSE and XMLSERIALIZE.
0:     protected int addXmlOpMethodParams(ExpressionClassBuilder acb,
0: 		MethodBuilder mb) throws StandardException
0:         if ((operatorType != XMLPARSE_OP) && (operatorType != XMLSERIALIZE_OP))
1:         // nothing to do.
1:             return 0;
1:         // primitive types.  Note: we don't have to save
1:         // any objects for XMLSERIALIZE because it doesn't
1:         // require any XML-specific objects: it just returns
1:         // the serialized version of the XML value, which we
1:         // already found when the XML value was created (ex.
1:         // as part of the XMLPARSE work).
/////////////////////////////////////////////////////////////////////////
1:         /* Else we're here for XMLPARSE. */
1: 
0:         // Push activation, which we use at execution time to
0:         // get our saved object (which will hold objects used
0:         // for parsing/serializing) back.
0:         acb.pushThisAsActivation(mb);
1: 
0:         // Push our XML object (used for parsing/serializing) as
0:         // a saved object, so that we can retrieve it at execution
0:         // time.  This allows us to avoid having to re-create the
0:         // objects for every row in a given result set.
0:         mb.push(getCompilerContext().addSavedObject(sqlxUtil));
1: 
1:         // Push whether or not we want to preserve whitespace.
0:         mb.push(((Boolean)additionalArgs[0]).booleanValue());
1:         return 3;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Allowed kinds
1:     final static int K_XMLPARSE = 0;
1:     final static int K_XMLSERIALIZE = 1;
1:     final static int K_BASE = 2; // when UnaryOperatorNode is used as
1:                                  // a base class
1: 
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * When UnaryOperatorNode is used as an base class, this
1:      * constructor is used as {@code super}.
1:      */
/////////////////////////////////////////////////////////////////////////
1:         this.kind = K_BASE;
1:     /**
1:      * When UnaryOperatorNode is used as an base class, this
1:      * constructor is used as {@code super}.
1:      */
1:         this.kind = K_BASE;
1:      * Constructor for a UnaryOperatorNode when used as a concrete class.
1:      * @param kind          The kind of operator
1:      * @param targetType    The DTD of the target type
1:      * @param preserveWhiteSpace {@code true} if white space is to be preserved
1:      *                      (relevant for kind == XMLPARSE only)
1:     UnaryOperatorNode(ValueNode          operand,
1:                       int                kind,
1:         this.kind = kind;
1:         this.operator = UnaryOperators[this.kind];
1:         this.methodName = UnaryMethodNames[this.kind];
1:         this.resultInterfaceType = UnaryResultTypes[this.kind];
1:         this.receiverInterfaceType = UnaryArgTypes[this.kind];
1:         if (kind == K_XMLSERIALIZE) {
1:         } else if (kind == K_XMLPARSE) {
1:                     "Don't know how to handle operator type " + kind);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (kind == K_XMLPARSE) {
1:         } else if (kind == K_XMLSERIALIZE) {
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (kind == K_XMLPARSE)
/////////////////////////////////////////////////////////////////////////
1:         else if (kind == K_XMLSERIALIZE) {
/////////////////////////////////////////////////////////////////////////
1:             (kind == K_BASE)
/////////////////////////////////////////////////////////////////////////
1:         if (kind != K_BASE)
/////////////////////////////////////////////////////////////////////////
1:         if ((kind != K_XMLPARSE) &&
1:                 (kind != K_XMLSERIALIZE)) {
0:             // nothing to do.
1:         }
1:         if (kind == K_XMLSERIALIZE) {
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:         if (isSameNodeKind(o)) {
1:                    ((operand == other.operand)||
1:                    ((operand != null) && operand.isEquivalent(other.operand))));
1: 
1:     @Override
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) && ((UnaryOperatorNode)o).kind == kind;
1:     }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1: class UnaryOperatorNode extends OperatorNode
/////////////////////////////////////////////////////////////////////////
0:     final static int XMLPARSE_OP = 0;
0:     final static int XMLSERIALIZE_OP = 1;
/////////////////////////////////////////////////////////////////////////
1:     UnaryOperatorNode(ValueNode operand,
1:             String operator,
1:             String methodNameOrAddedArgs,
1:             ContextManager cm) throws StandardException {
1:         super(cm);
1:         this.operand = operand;
1:         this.operator = operator;
1:         this.methodName = methodNameOrAddedArgs;
0:         this.operatorType = -1;
1:     }
1:     UnaryOperatorNode(ValueNode operand, ContextManager cm) {
1:         super(cm);
1:         this.operand = operand;
0:         this.operatorType = -1;
1:     }
1: 
1: 	/**
0:      * Constructor for a UnaryOperatorNode.
1: 	 *
1:      * @param operand       The operand of the node
0:      * @param operatorType  Either 1) the name of the operator,
0:      *                      OR 2) an Integer holding the operatorType
0:      *                      for this operator.
0:      * @param methodNameOrAddedArgs
0:      *                      Either 1) name of the method to call for
0:      *                      this operator, or 2) an array of Objects
0:      *                      from which primitive method parameters can
0:      *                      be retrieved.
1:      * @param cm            The context manager
1: 	 */
0:     UnaryOperatorNode(int                nodeType,
0:                       ValueNode          operand,
0:                       int                operatorType,
1:                       DataTypeDescriptor targetType,
1:                       boolean            preserveWhiteSpace,
1:                       ContextManager     cm)
1:         super(cm);
0:         setNodeType(nodeType);
1:         this.operand = operand;
0:         this.operatorType = operatorType;
0:         this.operator = UnaryOperators[this.operatorType];
0:         this.methodName = UnaryMethodNames[this.operatorType];
0:         this.resultInterfaceType = UnaryResultTypes[this.operatorType];
0:         this.receiverInterfaceType = UnaryArgTypes[this.operatorType];
1: 
0:         if (operatorType == XMLSERIALIZE_OP) {
1:             this.targetType = targetType;
0:         } else if (operatorType == XMLPARSE_OP) {
1:             this.preserveWhitespace = preserveWhiteSpace;
1:         } else if (SanityManager.DEBUG) {
1:             SanityManager.THROWASSERT(
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getOperand()
/////////////////////////////////////////////////////////////////////////
1:     ParameterNode getParameterOperand() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isConstantExpression()
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String getReceiverInterfaceName() throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:64521e8
/////////////////////////////////////////////////////////////////////////
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 Types.SQLXML));
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     int addXmlOpMethodParams(ExpressionClassBuilder acb,
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:28f9484
/////////////////////////////////////////////////////////////////////////
1:     /** Target type for XMLSerialize operator. */
1:     private DataTypeDescriptor targetType;
1: 
1:     /** Whether or not an XMLParse operator should preserve whitespace. */
1:     private boolean preserveWhitespace;
/////////////////////////////////////////////////////////////////////////
0:                       ((methodNameOrAddedArgs instanceof DataTypeDescriptor) ||
0:                        (methodNameOrAddedArgs instanceof Boolean))),
/////////////////////////////////////////////////////////////////////////
0:             if (operatorType == XMLSERIALIZE_OP) {
0:                 targetType = (DataTypeDescriptor) methodNameOrAddedArgs;
0:             } else if (operatorType == XMLPARSE_OP) {
0:                 preserveWhitespace =
0:                     ((Boolean) methodNameOrAddedArgs).booleanValue();
0:             } else if (SanityManager.DEBUG) {
0:                 SanityManager.THROWASSERT(
0:                     "Don't know how to handle operator type " + operatorType);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 (targetType != null),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         mb.push(preserveWhitespace);
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:     ValueNode bindExpression(
0:             FromList fromList, SubqueryList subqueryList, List aggregates)
1:         bindOperand(fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:             FromList fromList, SubqueryList subqueryList, List aggregates)
1:         operand = operand.bindExpression(fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 					List aggregateVector)
/////////////////////////////////////////////////////////////////////////
0:             FromList fromList, SubqueryList subqueryList, List aggregateVector)
commit:d09782a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int numArgs = 1;
1: 
1:             // XML operators take extra arguments.
1:             numArgs += addXmlOpMethodParams(acb, mb, field);
1: 
1:             mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:                           methodName, resultTypeName, numArgs);
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param acb the builder for the class in which the method lives
1:      * @param resultField the field that contains the previous result
1: 		MethodBuilder mb, LocalField resultField) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         // XMLPARSE is different from other unary operators in that the method
1:         // must be called on the result object (the XML value) and not on the
1:         // operand (the string value). We must therefore make sure the result
1:         // object is not null.
1:         MethodBuilder constructor = acb.getConstructor();
1:         acb.generateNull(constructor, getTypeCompiler(),
1:                          getTypeServices().getCollationType());
1:         constructor.setField(resultField);
1: 
1:         // Swap operand and result object so that the method will be called
1:         // on the result object.
1:         mb.swap();
1: 
1:         // Push the SqlXmlUtil instance as the next argument.
1:         pushSqlXmlUtil(acb, mb, null, null);
1: 
commit:044afae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class UnaryOperatorNode extends OperatorNode
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Push the SqlXmlUtil instance as the first argument.
0:         pushSqlXmlUtil(acb, mb, null, null);
1:         return 2;
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (operand != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:             FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
/////////////////////////////////////////////////////////////////////////
1:             FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:                 JDBC40Translation.SQLXML));
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1:         setCollationUsingCompilationSchema();
commit:ac12b1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e2f08d2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (operand.requiresTypeFromContext()) {
1:             // If not bound yet then just return.
1:             // The node type will be set by either
1:             // this class' bindExpression() or a by
1:             // a node that contains this expression.
1:             if (operand.getTypeServices() == null)
1:                 return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private void bindXMLParse() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     private void bindXMLSerialize() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:3233189
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Operator type, only valid for XMLPARSE and XMLSERIALIZE.
1:      */
0: 	private int operatorType;
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // This has lead to this class having somewhat of
1:     // a confused personality. In one mode it is really
1:     // a parent (abstract) class for various unary operator
1:     // node implementations, in its other mode it is a concrete
1:     // class for XMLPARSE and XMLSERIALIZE.
/////////////////////////////////////////////////////////////////////////
1:      * This method is the implementation for XMLPARSE and XMLSERIALIZE.
1:      * Sub-classes need to implement their own bindExpression() method
1:      * for their own specific rules.
/////////////////////////////////////////////////////////////////////////
0: 		bindOperand(fromList, subqueryList, aggregateVector);
0:         if (operatorType == XMLPARSE_OP)
1:             bindXMLParse();
0:         else if (operatorType == XMLSERIALIZE_OP)
1:             bindXMLSerialize();
1:         return this;
1: 	 * Bind the operand for this unary operator.
1:      * Binding the operator may change the operand node.
1:      * Sub-classes bindExpression() methods need to call this
1:      * method to bind the operand.
1: 	protected void bindOperand(
0: 			return;
/////////////////////////////////////////////////////////////////////////
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @throws StandardException 
1:      * {@inheritDoc}
1:      */
0:     protected boolean isEquivalent(ValueNode o) throws StandardException
1:     {
0:     	if (isSameNodeType(o)) 
1:     	{
0: 		// the first condition in the || covers the case when 
0: 	    	// both operands are null.
1:     		UnaryOperatorNode other = (UnaryOperatorNode)o;
1:     		return (operator.equals(other.operator) && 
0: 			((operand == other.operand)|| 
0: 			 ((operand != null) && operand.isEquivalent(other.operand))));
1:     	}
1:     	return false;
1:     }
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 			operand.getTypeId().userType() &&
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.UnaryOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
1: import java.lang.reflect.Modifier;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A UnaryOperatorNode represents a built-in unary operator as defined by
1:  * the ANSI/ISO SQL standard.  This covers operators like +, -, NOT, and IS NULL.
1:  * Java operators are not represented here: the JSQL language allows Java
1:  * methods to be called from expressions, but not Java operators.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public abstract class UnaryOperatorNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	String	operator;
1: 	String	methodName;
1: 
1: 	/**
1: 	 * WARNING: operand may be NULL for COUNT(*).  
1: 	 */
1: 	ValueNode	operand;
1: 
0: 	public final static int UNARY_PLUS	= 1;
0: 	public final static int UNARY_MINUS	= 2;
0: 	public final static int NOT		= 3;
0: 	public final static int IS_NULL		= 4;
1: 
1: 	/**
0: 	 * Initializer for a UnaryOperatorNode
1: 	 *
0: 	 * @param operand	The operand of the node
0: 	 * @param operator	The name of the operator
0: 	 * @param methodName	The name of the method to call for this operator
1: 	 */
1: 
0: 	public void init(
0: 					Object	operand,
0: 					Object		operator,
0: 					Object		methodName)
1: 	{
0: 		this.operand = (ValueNode) operand;
0: 		this.operator = (String) operator;
0: 		this.methodName = (String) methodName;
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a UnaryOperatorNode
1: 	 *
0: 	 * @param operand	The operand of the node
1: 	 */
0: 	public void init(Object	operand)
1: 	{
0: 		this.operand = (ValueNode) operand;
1: 	}
1: 
1: 	/**
1: 	 * Set the operator.
1: 	 *
1: 	 * @param operator	The operator.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setOperator(String operator)
1: 	{
1: 		this.operator = operator;
1: 	}
1: 
1: 	/**
1: 	 * Get the operator of this unary operator.
1: 	 *
1: 	 * @return	The operator of this unary operator.
1: 	 */
1: 	String getOperatorString()
1: 	{
1: 		return operator;
1: 	}
1: 
1: 	/**
1: 	 * Set the methodName.
1: 	 *
1: 	 * @param methodName	The methodName.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setMethodName(String methodName)
1: 	{
1: 		this.methodName = methodName;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return		This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "operator: " + operator + "\n" +
1: 				"methodName: " + methodName + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (operand != null)
1: 			{
1: 				printLabel(depth, "operand: ");
1: 				operand.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the operand of this unary operator.
1: 	 *
1: 	 * @return	The operand of this unary operator.
1: 	 */
0: 	public ValueNode getOperand()
1: 	{
1: 		return operand;
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
1: 
1: 		/*
0: 		** Operator may be null for COUNT(*)
1: 		*/
1: 		if (operand != null)
1: 		{
0: 			operand.setClause(clause);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(
0: 					FromList fromList, SubqueryList subqueryList,
0: 					Vector	aggregateVector)
1: 				throws StandardException
1: 	{
0: 		return bindUnaryOperator(fromList, subqueryList, aggregateVector);
1: 	}
1: 
1: 	/**
0: 	 * Workhorse for bindExpression. This exists so it can be called
0: 	 * by child classes.
1: 	 */
0: 	protected ValueNode bindUnaryOperator(
0: 					FromList fromList, SubqueryList subqueryList,
0: 					Vector	aggregateVector)
1: 				throws StandardException
1: 	{
1: 		/*
0: 		** Operand can be null for COUNT(*) which
0: 		** is treated like a normal aggregate.
1: 		*/
0: 		if (operand == null)
1: 		{
1: 			return this;
1: 		}
1: 
0: 		operand = operand.bindExpression(fromList, subqueryList,
0: 								aggregateVector);
1: 
0: 		if (operand.isParameterNode())
1: 			bindParameter();
1: 
1: 		/* If the operand is not a built-in type, then generate a bound conversion
1: 		 * tree to a built-in type.
1: 		 */
1: 		if (! (operand instanceof UntypedNullConstantNode) &&
0: 			! operand.getTypeId().systemBuiltIn() &&
1: 			! (this instanceof IsNullNode))
1: 		{
1: 			operand = operand.genSQLJavaSQLTree();
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		if (operand != null)
1: 		{
1: 			operand = operand.preprocess(numTables,
1: 										 outerFromList, outerSubqueryList,
1: 										 outerPredicateList);
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level)
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		return (operand == null) ? 
1: 				false : 
1: 				operand.categorize(referencedTabs, simplePredsOnly);
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		if (operand != null)
1: 		{
1: 			operand = operand.remapColumnReferencesToExpressions();
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		return (operand == null) ? true: operand.isConstantExpression();
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return (operand == null) ?
1: 					true :
1: 					operand.constantExpression(whereClause);
1: 	}
1: 
1: 	/**
1: 	 * By default unary operators don't accept ? parameters as operands.
1: 	 * This can be over-ridden for particular unary operators.
1: 	 *
1: 	 *	We throw an exception if the parameter doesn't have a datatype
1: 	 *	assigned to it yet.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown if ?  parameter doesn't
1: 	 *									have a type bound to it yet.
1: 	 *									? parameter where it isn't allowed.
1: 	 */
1: 
1: 	void bindParameter() throws StandardException
1: 	{
0: 		if (operand.getTypeServices() == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this unary operator.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
0: 		if (operand == null)
0: 			return;
1: 
0: 		String resultTypeName = getTypeCompiler().interfaceName();
1: 		// System.out.println("resultTypeName " + resultTypeName + " method " + methodName);
1: 		// System.out.println("isBooleanTypeId() " + getTypeId().isBooleanTypeId());
1: 
1: 		boolean needField = !getTypeId().isBooleanTypeId();
1: 
1: 		String receiverType = getReceiverInterfaceName();
1: 		operand.generateExpression(acb, mb);
1: 		mb.cast(receiverType);
1: 
1: 		if (needField) {
1: 
1: 			/* Allocate an object for re-use to hold the result of the operator */
1: 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1: 			mb.getField(field);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, 1);
1: 
1: 			/*
1: 			** Store the result of the method call in the field, so we can re-use
1: 			** the object.
1: 			*/
1: 			mb.putField(field);
1: 		} else {
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, 0);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Determine the type the binary method is called on.
1: 	 * By default, based on the receiver.
1: 	 *
1: 	 * Override in nodes that use methods on super-interfaces of
1: 	 * the receiver's interface, such as comparisons.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public String getReceiverInterfaceName() throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(operand!=null,
1: 								"cannot get interface without operand");
1: 		}
1: 
1: 		return operand.getTypeCompiler().interfaceName();
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *		CONSTANT			- immutable
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 * @exception StandardException	thrown on error
1: 	 */
1: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		/*
1: 		** If we have nothing in the operator, then
1: 		** it must be constant.
1: 		*/
1: 		return (operand != null) ?
1: 				operand.getOrderableVariantType() :
1: 				Qualifier.CONSTANT;
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (operand != null && !v.stopTraversal())
1: 		{
1: 			operand = (ValueNode)operand.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:27f9fd6
/////////////////////////////////////////////////////////////////////////
1:         // We also need to pass the collation type of the current
1:         // compilation schema. If the JDBC type id is of type
1:         // StringDataValue, then we should use the collation to
1:         // decide whether we need to generate collation sensitive
1:         // StringDataValue.
1:             mb.push(getSchemaDescriptor(null, false).getCollationType());
0:             return 3;
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0:         setCollationUsingCompilationSchema(
commit:649830f
/////////////////////////////////////////////////////////////////////////
1: 		//Set the collation type to be same as the current schema's 
1: 		//collation type. 
0: 		getTypeServices().setCollationType(
0: 				getLanguageConnectionContext().getDefaultSchema().getCollationType());
0: 		//Set the collation derivation to be "IMPLICIT".
0: 		getTypeServices().setCollationDerivation(
0: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 	public ParameterNode getParameterOperand() throws StandardException
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * Initializer for a UnaryOperatorNode.
0: 	 * <ul>
0: 	 * @param methodNameOrAddedArgs	Either 1) name of the method
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the parameter operand of this unary operator.
1: 	 * For the example below, for abs unary operator node, we want to get ?
1: 	 * select * from t1 where -? = max_cni(abs(-?), sqrt(+?))
0: 	 * 
1: 	 * This gets called when ParameterNode is needed to get parameter
1: 	 * specific information like getDefaultValue(), getParameterNumber() etc 
0: 	 * 
1: 	 * @return	The parameter operand of this unary operator else null.
0: 	 */
0: 	public ParameterNode getParameterOperand()
1: 	{
1: 		if (requiresTypeFromContext() == false)
1: 			return null;
0: 		else {
1: 			UnaryOperatorNode tempUON = this;
1: 			while (!(tempUON.getOperand() instanceof ParameterNode)) 
1: 				tempUON = (UnaryOperatorNode)tempUON.getOperand();
1: 			return (ParameterNode)(tempUON.getOperand());
1: 		}
1: 	}
0: 
0: 	/**
/////////////////////////////////////////////////////////////////////////
0: 		//Return with no binding, if the type of unary minus/plus parameter is not set yet.
0: 		if (operand.requiresTypeFromContext() && ((operator.equals("-") || operator.equals("+"))) && operand.getTypeServices() == null)
0: 			return this;
0: 
0: 		if (operand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 	 * @see ValueNode#requiresTypeFromContext
0: 	 */
0: 	public boolean requiresTypeFromContext()
1: 	{
0: 		if (operand == null)
0: 			return false;
0: 		else
0: 			return (operand.requiresTypeFromContext()); 
1: 	}
0: 
0: 
0: 	/**
0: 	 * Returns true if this UnaryOperatorNode is for -?/+?.
0: 	 * This is required to check -?/+? say in the following sql
0: 	 * select * from t1 where -? and c11=c11 or +?
0: 	 * 
0: 	 * @return	True if this +?/-? node
0: 	 */
0: 	public boolean isUnaryMinusOrPlusWithParameter()
1: 	{
0: 		if (operand !=null && operand instanceof ParameterNode && operand.requiresTypeFromContext() && 
0: 				(operator!= null && (operator.equals("-") || operator.equals("+"))))
0: 			return true;
0: 		else
0: 			return false;
1: 	}
0: 
0: 	/**
/////////////////////////////////////////////////////////////////////////
0: 	        operand.setType(
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
0: public class UnaryOperatorNode extends ValueNode
0: 	int operatorType;
0: 
1: 	String		resultInterfaceType;
1: 	String		receiverInterfaceType;
/////////////////////////////////////////////////////////////////////////
1: 	// At the time of adding XML support, it was decided that
1: 	// we should avoid creating new OperatorNodes where possible.
1: 	// So for the XML-related unary operators we just add the
1: 	// necessary code to _this_ class, similar to what is done in
1: 	// TernarnyOperatorNode. Subsequent unary operators (whether
1: 	// XML-related or not) should follow this example when
1: 	// possible.
0: 
0: 	public final static int XMLPARSE_OP = 0;
0: 	public final static int XMLSERIALIZE_OP = 1;
0: 
1: 	// NOTE: in the following 4 arrays, order
1: 	// IS important.
0: 
1: 	static final String[] UnaryOperators = {
1: 		"xmlparse",
1: 		"xmlserialize"
1: 	};
0: 
1: 	static final String[] UnaryMethodNames = {
1: 		"XMLParse",
1: 		"XMLSerialize"
1: 	};
0: 
1: 	static final String[] UnaryResultTypes = {
1: 		ClassName.XMLDataValue, 		// XMLParse
1: 		ClassName.StringDataValue		// XMLSerialize
1: 	};
0: 
1: 	static final String[] UnaryArgTypes = {
1: 		ClassName.StringDataValue,		// XMLParse
1: 		ClassName.XMLDataValue			// XMLSerialize
1: 	};
0: 
0: 	// Array to hold Objects that contain primitive
0: 	// args required by the operator method call.
0: 	private Object [] additionalArgs;
0: 
0: 	 * @param operatorOrOpType	Either 1) the name of the operator,
0: 	 *  OR 2) an Integer holding the operatorType for this operator.
0: 	 * @param methodNameOrParams	Either 1) name of the method
0: 	 *  to call for this operator, or 2) an array of Objects
0: 	 *  from which primitive method parameters can be
0: 	 *  retrieved.
0: 					Object		operatorOrOpType,
0: 					Object		methodNameOrAddedArgs)
0: 		if (operatorOrOpType instanceof String) {
0: 		// then 2nd and 3rd params are operator and methodName,
0: 		// respectively.
0: 			this.operator = (String) operatorOrOpType;
0: 			this.methodName = (String) methodNameOrAddedArgs;
0: 			this.operatorType = -1;
1: 		}
0: 		else {
0: 		// 2nd and 3rd params are operatorType and additional args,
0: 		// respectively.
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.ASSERT(
0: 					((operatorOrOpType instanceof Integer) &&
0: 						((methodNameOrAddedArgs == null) ||
0: 						(methodNameOrAddedArgs instanceof Object[]))),
0: 					"Init params in UnaryOperator node have the " +
0: 					"wrong type.");
1: 			}
0: 			this.operatorType = ((Integer) operatorOrOpType).intValue();
0: 			this.operator = UnaryOperators[this.operatorType];
0: 			this.methodName = UnaryMethodNames[this.operatorType];
0: 			this.resultInterfaceType = UnaryResultTypes[this.operatorType];
0: 			this.receiverInterfaceType = UnaryArgTypes[this.operatorType];
0: 			this.additionalArgs = (Object[])methodNameOrAddedArgs;
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		if (operatorType == XMLPARSE_OP)
0: 			bindXMLParse();
0: 		else if (operatorType == XMLSERIALIZE_OP)
0: 			bindXMLSerialize();
0: 
0:     /**
1:      * Bind an XMLPARSE operator.  Makes sure the operand type
1:      * is correct, and sets the result type.
0:      *
1:      * @exception StandardException Thrown on error
0:      */
0:     public void bindXMLParse() throws StandardException
0:     {
1:         // Check the type of the operand - this function is allowed only on
1:         // string value (char) types.
1:         TypeId operandType = operand.getTypeId();
1:         if (operandType != null) {
1:             switch (operandType.getJDBCTypeId())
0:             {
1:                 case Types.CHAR:
1:                 case Types.VARCHAR:
1:                 case Types.LONGVARCHAR:
1:                 case Types.CLOB:
1:                     break;
1:                 default:
0:                 {
1:                     throw StandardException.newException(
1:                         SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:                         methodName,
1:                         operandType.getSQLTypeName());
0:                 }
0:             }
0:         }
0: 
1:         // The result type of XMLParse() is always an XML type.
1:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
0:             StoredFormatIds.XML_TYPE_ID));
0:     }
0: 
0:     /**
1:      * Bind an XMLSERIALIZE operator.  Makes sure the operand type
1:      * and target type are both correct, and sets the result type.
0:      *
1:      * @exception StandardException Thrown on error
0:      */
0:     public void bindXMLSerialize() throws StandardException
0:     {
1:         TypeId operandType;
0: 
1:         // Check the type of the operand - this function is allowed only on
1:         // the XML type.
1:         operandType = operand.getTypeId();
1:         if ((operandType != null) && !operandType.isXMLTypeId())
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:                 methodName,
1:                 operandType.getSQLTypeName());
0:         }
0: 
1:         // Check the target type.  We only allow string types to be used as
1:         // the target type.  The targetType is stored as the first Object
1:         // in our list of additional parameters, so we have to retrieve
1:         // it from there.
0:         if (SanityManager.DEBUG) {
0:             SanityManager.ASSERT(
0:                 ((additionalArgs != null) && (additionalArgs.length > 0)),
1:                 "Failed to locate target type for XMLSERIALIZE operator");
0:         }
0: 
0:         DataTypeDescriptor targetType =
0:             (DataTypeDescriptor)additionalArgs[0];
0: 
1:         TypeId targetTypeId = targetType.getTypeId();
1:         switch (targetTypeId.getJDBCTypeId())
0:         {
1:             case Types.CHAR:
1:             case Types.VARCHAR:
1:             case Types.LONGVARCHAR:
1:             case Types.CLOB:
1:                 break;
1:             default:
0:             {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_XMLSERIALIZE_TYPE,
1:                     targetTypeId.getSQLTypeName());
0:             }
0:         }
0: 
1:         // The result type of XMLSerialize() is always a string; which
1:         // kind of string is determined by the targetType field.
1:         setType(targetType);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 		if (operatorType == XMLPARSE_OP) {
0:         // According to the SQL/XML standard, the XMLParse parameter
0:         // takes a string operand.  RESOLVE: We use CLOB here because
0:         // an XML string can be arbitrarily long...is this okay?
0:         // The SQL/XML spec doesn't state what the type of the param
0:         // should be; only that it "shall be a character type".
0: 	        ((ParameterNode) operand).setDescriptor(
0:  	           DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CLOB));
0: 		}
0: 		else if (operatorType == XMLSERIALIZE_OP) {
1:         // For now, since JDBC has no type defined for XML, we
1:         // don't allow binding to an XML parameter.
1: 	        throw StandardException.newException(
1:  	           SQLState.LANG_ATTEMPT_TO_BIND_XML);
0: 		}
1: 		else if (operand.getTypeServices() == null)
/////////////////////////////////////////////////////////////////////////
1: 		String resultTypeName = 
0: 			(operatorType == -1)
1: 				? getTypeCompiler().interfaceName()
1: 				: resultInterfaceType;
0: 			
/////////////////////////////////////////////////////////////////////////
0: 			int numParams = 1 + addMethodParams(mb);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, numParams);
/////////////////////////////////////////////////////////////////////////
0: 			int numParams = addMethodParams(mb);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, numParams);
/////////////////////////////////////////////////////////////////////////
0: 		if (operatorType != -1)
1: 			return receiverInterfaceType;
0: 		
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * This method allows different operators to add
0:      * primitive arguments to the generated method call,
0:      * if needed.
1:      * @param mb The MethodBuilder that will make the call.
1:      * @return Number of parameters added.
0:      */
0:     protected int addMethodParams(MethodBuilder mb)
0:     {
0:         if (operatorType == XMLPARSE_OP) {
0:         // We push whether or not we want to preserve whitespace.
0:             mb.push(((Boolean)additionalArgs[0]).booleanValue());
0:             return 1;
0:         }
0: 
0:         if (operatorType == XMLSERIALIZE_OP) {
1:         // We push the target type's JDBC type id as well as
1:         // the maximum width, since both are required when
1:         // we actually perform the operation, and both are
0:         // primitive types.
0:             DataTypeDescriptor targetType =
0:                 (DataTypeDescriptor)additionalArgs[0];
1:             mb.push(targetType.getJDBCTypeId());
1:             mb.push(targetType.getMaximumWidth());
0:             return 2;
0:         }
0: 
0:         // Default is to add zero params.
0:         return 0;
0:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A UnaryOperatorNode represents a built-in unary operator as defined by
0:  * the ANSI/ISO SQL standard.  This covers operators like +, -, NOT, and IS NULL.
0:  * Java operators are not represented here: the JSQL language allows Java
0:  * methods to be called from expressions, but not Java operators.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class UnaryOperatorNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	String	operator;
0: 	String	methodName;
0: 
0: 	/**
0: 	 * WARNING: operand may be NULL for COUNT(*).  
0: 	 */
0: 	ValueNode	operand;
0: 
0: 	public final static int UNARY_PLUS	= 1;
0: 	public final static int UNARY_MINUS	= 2;
0: 	public final static int NOT		= 3;
0: 	public final static int IS_NULL		= 4;
0: 
0: 	/**
0: 	 * Initializer for a UnaryOperatorNode
0: 	 *
0: 	 * @param operand	The operand of the node
0: 	 * @param operator	The name of the operator
0: 	 * @param methodName	The name of the method to call for this operator
0: 	 */
0: 
0: 	public void init(
0: 					Object	operand,
0: 					Object		operator,
0: 					Object		methodName)
0: 	{
0: 		this.operand = (ValueNode) operand;
0: 		this.operator = (String) operator;
0: 		this.methodName = (String) methodName;
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a UnaryOperatorNode
0: 	 *
0: 	 * @param operand	The operand of the node
0: 	 */
0: 	public void init(Object	operand)
0: 	{
0: 		this.operand = (ValueNode) operand;
0: 	}
0: 
0: 	/**
0: 	 * Set the operator.
0: 	 *
0: 	 * @param operator	The operator.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setOperator(String operator)
0: 	{
0: 		this.operator = operator;
0: 	}
0: 
0: 	/**
0: 	 * Get the operator of this unary operator.
0: 	 *
0: 	 * @return	The operator of this unary operator.
0: 	 */
0: 	String getOperatorString()
0: 	{
0: 		return operator;
0: 	}
0: 
0: 	/**
0: 	 * Set the methodName.
0: 	 *
0: 	 * @param methodName	The methodName.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setMethodName(String methodName)
0: 	{
0: 		this.methodName = methodName;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return		This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "operator: " + operator + "\n" +
0: 				"methodName: " + methodName + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (operand != null)
0: 			{
0: 				printLabel(depth, "operand: ");
0: 				operand.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the operand of this unary operator.
0: 	 *
0: 	 * @return	The operand of this unary operator.
0: 	 */
0: 	public ValueNode getOperand()
0: 	{
0: 		return operand;
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 
0: 		/*
0: 		** Operator may be null for COUNT(*)
0: 		*/
0: 		if (operand != null)
0: 		{
0: 			operand.setClause(clause);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(
0: 					FromList fromList, SubqueryList subqueryList,
0: 					Vector	aggregateVector)
0: 				throws StandardException
0: 	{
0: 		return bindUnaryOperator(fromList, subqueryList, aggregateVector);
0: 	}
0: 
0: 	/**
0: 	 * Workhorse for bindExpression. This exists so it can be called
0: 	 * by child classes.
0: 	 */
0: 	protected ValueNode bindUnaryOperator(
0: 					FromList fromList, SubqueryList subqueryList,
0: 					Vector	aggregateVector)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** Operand can be null for COUNT(*) which
0: 		** is treated like a normal aggregate.
0: 		*/
0: 		if (operand == null)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		operand = operand.bindExpression(fromList, subqueryList,
0: 								aggregateVector);
0: 
0: 		if (operand.isParameterNode())
0: 			bindParameter();
0: 
0: 		/* If the operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
0: 		 */
0: 		if (! (operand instanceof UntypedNullConstantNode) &&
0: 			! operand.getTypeId().systemBuiltIn() &&
0: 			! (this instanceof IsNullNode))
0: 		{
0: 			operand = operand.genSQLJavaSQLTree();
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		if (operand != null)
0: 		{
0: 			operand = operand.preprocess(numTables,
0: 										 outerFromList, outerSubqueryList,
0: 										 outerPredicateList);
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level)
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		return (operand == null) ? 
0: 				false : 
0: 				operand.categorize(referencedTabs, simplePredsOnly);
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		if (operand != null)
0: 		{
0: 			operand = operand.remapColumnReferencesToExpressions();
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return (operand == null) ? true: operand.isConstantExpression();
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return (operand == null) ?
0: 					true :
0: 					operand.constantExpression(whereClause);
0: 	}
0: 
0: 	/**
0: 	 * By default unary operators don't accept ? parameters as operands.
0: 	 * This can be over-ridden for particular unary operators.
0: 	 *
0: 	 *	We throw an exception if the parameter doesn't have a datatype
0: 	 *	assigned to it yet.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if ?  parameter doesn't
0: 	 *									have a type bound to it yet.
0: 	 *									? parameter where it isn't allowed.
0: 	 */
0: 
0: 	void bindParameter() throws StandardException
0: 	{
0: 		if (operand.getTypeServices() == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this unary operator.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		if (operand == null)
0: 			return;
0: 
0: 		String resultTypeName = getTypeCompiler().interfaceName();
0: 		// System.out.println("resultTypeName " + resultTypeName + " method " + methodName);
0: 		// System.out.println("isBooleanTypeId() " + getTypeId().isBooleanTypeId());
0: 
0: 		boolean needField = !getTypeId().isBooleanTypeId();
0: 
0: 		String receiverType = getReceiverInterfaceName();
0: 		operand.generateExpression(acb, mb);
0: 		mb.cast(receiverType);
0: 
0: 		if (needField) {
0: 
0: 			/* Allocate an object for re-use to hold the result of the operator */
0: 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
0: 			mb.getField(field);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, 1);
0: 
0: 			/*
0: 			** Store the result of the method call in the field, so we can re-use
0: 			** the object.
0: 			*/
0: 			mb.putField(field);
0: 		} else {
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, 0);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Determine the type the binary method is called on.
0: 	 * By default, based on the receiver.
0: 	 *
0: 	 * Override in nodes that use methods on super-interfaces of
0: 	 * the receiver's interface, such as comparisons.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public String getReceiverInterfaceName() throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(operand!=null,
0: 								"cannot get interface without operand");
0: 		}
0: 
0: 		return operand.getTypeCompiler().interfaceName();
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *		CONSTANT			- immutable
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		/*
0: 		** If we have nothing in the operator, then
0: 		** it must be constant.
0: 		*/
0: 		return (operand != null) ?
0: 				operand.getOrderableVariantType() :
0: 				Qualifier.CONSTANT;
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (operand != null && !v.stopTraversal())
0: 		{
0: 			operand = (ValueNode)operand.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: }
============================================================================