1:f68f62f: /*
1:f68f62f: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.outparams
1:f68f62f: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
1:f68f62f:  */
1:f68f62f: 
1:f68f62f: package org.apache.derbyTesting.functionTests.tests.lang;
1:f68f62f: import java.sql.*;
1:f68f62f: 
1:f68f62f: import org.apache.derby.tools.ij;
1:f68f62f: import java.io.PrintStream;
1:f68f62f: import java.math.BigInteger;
1:f68f62f: import java.math.BigDecimal;
1:b9c171c: import org.apache.derbyTesting.functionTests.util.BigDecimalHandler;
1:f68f62f: 
1:f68f62f: public class outparams
4:f68f62f: {
1:f68f62f: 	
1:b9c171c: 	private static boolean HAVE_BIG_DECIMAL;
1:b9c171c: 	private static boolean HAVE_DRIVER_CLASS;
1:b9c171c: 	private static String CLASS_NAME;
1:f68f62f: 	
1:b9c171c: 	//Get the class name to be used for the procedures
1:b9c171c: 	//outparams - J2ME; outparams30 - non-J2ME
1:b9c171c: 	static{
1:b9c171c: 		if(BigDecimalHandler.representation != BigDecimalHandler.BIGDECIMAL_REPRESENTATION)
1:b9c171c: 			HAVE_BIG_DECIMAL = false;
9:67614ad: 		else
1:b9c171c: 			HAVE_BIG_DECIMAL = true;
1:b9c171c: 		if(HAVE_BIG_DECIMAL)
1:b9c171c: 			CLASS_NAME = "org.apache.derbyTesting.functionTests.tests.lang.outparams30.";
1:67614ad: 		else
1:b9c171c: 			CLASS_NAME = "org.apache.derbyTesting.functionTests.tests.lang.outparams.";
152:67614ad: 	}
1:c1c71ef: 	
1:b9c171c: 	static{
1:b9c171c: 		try{
1:b9c171c: 			Class.forName("java.sql.Driver");
1:b9c171c: 			HAVE_DRIVER_CLASS = true;
1:67614ad: 		}
1:b9c171c: 		catch(ClassNotFoundException e){
1:b9c171c: 			//Used for JSR169
1:b9c171c: 			HAVE_DRIVER_CLASS = false;
1:67614ad: 		}
1:67614ad: 	}
1:c1c71ef: 	
1:b9c171c: 	static String[] outputMethods;
1:b9c171c: 	//Get the array to be used based on HAVE_BIG_DECIMAL
1:b9c171c: 	static{
1:b9c171c: 		if(HAVE_BIG_DECIMAL){
1:b9c171c: 			outputMethods = new String[] {
1:f68f62f: 									"takesNothing",
1:f68f62f: 							
1:f68f62f: 									null, 
1:f68f62f: 								
1:f68f62f: 									null,
1:f68f62f: 																	
1:f68f62f: 									"takesShortPrimitive",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"takesIntegerPrimitive",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"takesLongPrimitive",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"takesFloatPrimitive",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"takesDoublePrimitive",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"takesBigDecimal",
1:f68f62f: 								
1:f68f62f: 									"takesByteArray",
1:f68f62f: 									
1:f68f62f: 									"takesString",
1:f68f62f: 									
1:f68f62f: 									"takesDate",
1:f68f62f: 									
1:f68f62f: 									"takesTimestamp",
1:f68f62f: 								
1:f68f62f: 									"takesTime",
1:f68f62f: 								
1:f68f62f: 									null
1:f68f62f: 								};
1:67614ad: 		}
1:b9c171c: 		else{
1:b9c171c: 			outputMethods = new String[] {
1:67614ad: 									"takesNothing",
1:f68f62f: 							
1:f68f62f: 									null, 
1:c1c71ef: 								
1:f68f62f: 									null,
1:c1c71ef: 																	
1:67614ad: 									"takesShortPrimitive",
10:67614ad: 									null,
260:67614ad: 								
1:67614ad: 									"takesIntegerPrimitive",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"takesLongPrimitive",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"takesFloatPrimitive",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"takesDoublePrimitive",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"takesByteArray",
1:67614ad: 									
1:67614ad: 									"takesString",
1:67614ad: 									
1:67614ad: 									"takesDate",
1:67614ad: 									
1:67614ad: 									"takesTimestamp",
1:67614ad: 								
1:67614ad: 									"takesTime",
1:67614ad: 								
2:67614ad: 									null
4:67614ad: 								};			
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:f68f62f: 	// parameter types for outputMethods.
1:f68f62f: 	private static final String[] outputProcParam =
1:f68f62f: 	{
1:f68f62f: 		null, // "takesNothing",
1:f68f62f: 
1:f68f62f: 		null, 
1:f68f62f: 	
1:f68f62f: 		null,
1:f68f62f: 			
1:f68f62f: 		"SMALLINT", // "takesShortPrimitive",
1:f68f62f: 		null,
1:f68f62f: 	
1:f68f62f: 		"INT", // "takesIntegerPrimitive",
1:f68f62f: 		null,
1:f68f62f: 	
1:f68f62f: 		"BIGINT", // "takesLongPrimitive",
1:f68f62f: 		null,
1:f68f62f: 	
1:f68f62f: 		"REAL", // "takesFloatPrimitive",
1:f68f62f: 		null,
1:f68f62f: 	
1:f68f62f: 		"DOUBLE", // "takesDoublePrimitive",
1:f68f62f: 		null,
1:f68f62f: 	
1:f68f62f: 		"DECIMAL(10,4)", // "takesBigDecimal",
1:f68f62f: 	
1:f68f62f: 		"VARCHAR(40) FOR BIT DATA", // "takesByteArray",
1:f68f62f: 		
1:f68f62f: 		"VARCHAR(40)", // "takesString",
1:f68f62f: 		
1:f68f62f: 		"DATE", // "takesDate",
1:f68f62f: 		
1:f68f62f: 		"TIMESTAMP", // "takesTimestamp",
1:f68f62f: 	
1:f68f62f: 		"TIME", // "takesTime",
1:f68f62f: 	
1:f68f62f: 		null
1:f68f62f: 	};
1:f68f62f: 		
1:b9c171c: 	static String returnMethods[];
1:b9c171c: 	//Get the array to be used based on HAVE_BIG_DECIMAL
1:b9c171c: 	static{
1:b9c171c: 		if(HAVE_BIG_DECIMAL){
1:b9c171c: 			returnMethods = new String[] 	{
1:f68f62f: 									"returnsNothing",
1:f68f62f: 				
1:f68f62f: 									null,
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"returnsShortP",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"returnsIntegerP",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"returnsLongP",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"returnsFloatP",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"returnsDoubleP",
1:f68f62f: 									null,
1:f68f62f: 								
1:f68f62f: 									"returnsBigDecimal",
1:f68f62f: 								
1:f68f62f: 									"returnsByteArray",
1:f68f62f: 									
1:f68f62f: 									"returnsString",
1:f68f62f: 									
1:f68f62f: 									"returnsDate",
1:f68f62f: 									
1:f68f62f: 									"returnsTimestamp",
1:f68f62f: 								
1:f68f62f: 									"returnsTime",
1:f68f62f: 								
1:f68f62f: 									null
1:f68f62f: 								};
1:f68f62f: 		}
1:b9c171c: 		else{
1:b9c171c: 			returnMethods = new String[] 	{
1:67614ad: 									"returnsNothing",
1:f68f62f: 				
1:67614ad: 									null,
1:67614ad: 									null,
1:f68f62f: 								
1:67614ad: 									"returnsShortP",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"returnsIntegerP",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"returnsLongP",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"returnsFloatP",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"returnsDoubleP",
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									null,
1:67614ad: 								
1:67614ad: 									"returnsByteArray",
1:67614ad: 									
1:67614ad: 									"returnsString",
1:67614ad: 									
1:67614ad: 									"returnsDate",
1:67614ad: 									
1:67614ad: 									"returnsTimestamp",
1:67614ad: 								
1:67614ad: 									"returnsTime",
1:67614ad: 								
1:67614ad: 									null
1:67614ad: 								};
1:f68f62f: 		}
1:67614ad: 	}
1:67614ad: 	
1:b9c171c: 	static String[] returnMethodType =
1:f68f62f: 	{
1:f68f62f: 		null, // "returnsNothing",
1:f68f62f: 
1:f68f62f: 		null, // "returnsBytePrimitive",
1:f68f62f: 		null, // "returnsByte",
1:f68f62f: 	
1:f68f62f: 		"SMALLINT", // "returnsShortPrimitive",
1:f68f62f: 		null, // "returnsShort",
1:f68f62f: 	
1:f68f62f: 		"INT", // "returnsIntegerPrimitive",
1:f68f62f: 		null, // "returnsInteger",
1:f68f62f: 	
1:f68f62f: 		"BIGINT", // "returnsLongPrimitive",
1:f68f62f: 		null, // "returnsLong",
1:f68f62f: 	
1:f68f62f: 		"REAL", // "returnsFloatPrimitive",
1:f68f62f: 		null, // "returnsFloat",
1:f68f62f: 	
1:f68f62f: 		"DOUBLE", // "returnsDoublePrimitive",
1:f68f62f: 		null, // "returnsDouble",
1:f68f62f: 	
1:f68f62f: 		"DECIMAL(10,2)", // "returnsBigDecimal",
1:f68f62f: 	
1:f68f62f: 		"VARCHAR(40) FOR BIT DATA", // "returnsByteArray",
1:f68f62f: 		
1:f68f62f: 		"VARCHAR(40)", // "returnsString",
1:f68f62f: 		
1:f68f62f: 		"DATE", // "returnsDate",
1:f68f62f: 		
1:f68f62f: 		"TIMESTAMP", // "returnsTimestamp",
1:f68f62f: 	
1:f68f62f: 		"TIME", // "returnsTime",
1:f68f62f: 	
1:f68f62f: 		null, // "returnsBigInteger"
1:f68f62f: 	};
1:f68f62f: 	
1:b9c171c: 	//JDBC type (java.sql.Types) corresponding to the methods
1:b9c171c: 	static int[] paramJDBCType =
1:f68f62f: 	{
1:b9c171c: 		Types.NULL, // "returnsNothing",
1:f68f62f: 
1:b9c171c: 		Types.NULL, // "returnsBytePrimitive",
1:b9c171c: 		Types.NULL, // "returnsByte",
1:f68f62f: 	
1:b9c171c: 		Types.SMALLINT, // "returnsShortPrimitive",
1:b9c171c: 		Types.NULL, // "returnsShort",
1:f68f62f: 	
1:b9c171c: 		Types.INTEGER, // "returnsIntegerPrimitive",
1:b9c171c: 		Types.NULL, // "returnsInteger",
1:67614ad: 	
1:b9c171c: 		Types.BIGINT, // "returnsLongPrimitive",
1:b9c171c: 		Types.NULL, // "returnsLong",
1:67614ad: 	
1:b9c171c: 		Types.REAL, // "returnsFloatPrimitive",
1:b9c171c: 		Types.NULL, // "returnsFloat",
1:67614ad: 	
1:b9c171c: 		Types.DOUBLE, // "returnsDoublePrimitive",
1:b9c171c: 		Types.NULL, // "returnsDouble",
1:67614ad: 	
1:b9c171c: 		Types.NUMERIC, // "returnsBigDecimal",
1:67614ad: 	
1:b9c171c: 		Types.VARBINARY, // "returnsByteArray",
1:67614ad: 		
1:b9c171c: 		Types.VARCHAR, // "returnsString",
1:67614ad: 		
1:b9c171c: 		Types.DATE, // "returnsDate",
1:67614ad: 		
1:b9c171c: 		Types.TIMESTAMP, // "returnsTimestamp",
1:67614ad: 	
1:b9c171c: 		Types.TIME, // "returnsTime",
1:67614ad: 	
1:b9c171c: 		Types.NULL, // "returnsBigInteger"
1:67614ad: 	};	
1:67614ad: 	
1:f68f62f: 	static final int types[] =
1:f68f62f: 	{
1:f68f62f: 		Types.BIT,
1:1a4ea31: 		Types.BOOLEAN,
1:f68f62f: 		Types.TINYINT,
1:f68f62f: 		Types.SMALLINT,
1:f68f62f: 		Types.INTEGER,
1:f68f62f: 		Types.BIGINT,
1:f68f62f: 		Types.FLOAT,
1:f68f62f: 		Types.REAL,
1:f68f62f: 		Types.DOUBLE,
1:f68f62f: 		Types.NUMERIC,
1:f68f62f: 		Types.DECIMAL,
1:f68f62f: 		Types.CHAR,
1:f68f62f: 		Types.VARCHAR,
1:f68f62f: 		Types.LONGVARCHAR,
1:f68f62f: 		Types.DATE,
1:f68f62f: 		Types.TIME, 
1:f68f62f: 		Types.TIMESTAMP,
1:f68f62f: 		Types.BINARY,
1:f68f62f: 		Types.VARBINARY,
1:f68f62f: 		Types.LONGVARBINARY,
1:f68f62f: 		Types.OTHER
1:f68f62f: 	};
1:f68f62f: 	
1:f68f62f: 	static final String typeNames[] =
1:f68f62f: 	{
1:f68f62f: 		"BIT",
1:f68f62f: 		"BOOLEAN",
1:f68f62f: 		"TINYINT",
1:f68f62f: 		"SMALLINT",
1:f68f62f: 		"INTEGER",
1:f68f62f: 		"BIGINT",
1:f68f62f: 		"FLOAT",
1:f68f62f: 		"REAL",
1:f68f62f: 		"DOUBLE",
1:f68f62f: 		"NUMERIC",
1:f68f62f: 		"DECIMAL",
1:f68f62f: 		"CHAR",
1:f68f62f: 		"VARCHAR",
1:f68f62f: 		"LONGVARCHAR",
1:f68f62f: 		"DATE",
1:f68f62f: 		"TIME",
1:f68f62f: 		"TIMESTAMP",
1:f68f62f: 		"BINARY",
1:f68f62f: 		"VARBINARY",
1:f68f62f: 		"LONGVARBINARY",
1:f68f62f: 		"OTHER"
1:f68f62f: 	};
1:f68f62f: 
1:f68f62f: 	//public static Connection conn;
1:f68f62f: 
1:f68f62f: 	public static void main (String[] argv) throws Throwable
1:f68f62f: 	{
1:f68f62f:    		ij.getPropertyArg(argv); 
1:f68f62f:         Connection conn = ij.startJBMS();
1:f68f62f: 
1:f68f62f:         runTests( conn);
1:f68f62f:     }
1:f68f62f: 
1:f68f62f:     public static void runTests( Connection conn) throws Throwable
1:f68f62f:     {        
1:f68f62f: 		conn.setAutoCommit(false);	
1:f68f62f: 
1:f68f62f: 		testMisc(conn);
1:f68f62f: 		testNull(conn);
1:f68f62f: 		testUpdate(conn);
1:f68f62f: 		testEachOutputType(conn);
1:f68f62f: 		testReturnTypes(conn);
1:f68f62f: 		testOtherOutputType(conn);
1:f68f62f: 		testManyOut(conn);
1:b9c171c: 		//Uses a procedure with nested connection - Cannot be tested with JSR169
1:b9c171c: 		if(HAVE_DRIVER_CLASS)
1:f68f62f: 			test5116(conn);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	private static void testMisc(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================");
1:f68f62f: 		System.out.println("TESTING BOUNDARY CONDITIONS");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 
1:f68f62f: 		Statement scp = conn.createStatement();
1:f68f62f: 
1:f68f62f: 		scp.execute("CREATE PROCEDURE takesString(OUT P1 VARCHAR(40), IN P2 INT) " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "takesString'" +
1:f68f62f: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 		CallableStatement cs = conn.prepareCall("call takesString(?,?)");
1:f68f62f: 
1:f68f62f: 		// register a normal int as an output param, should fail
1:f68f62f: 		boolean failed = false;
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.registerOutParameter(2, Types.INTEGER);
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			failed = true;
1:f68f62f: 			System.out.println("Expected exception "+se);
1:f68f62f: 		}
1:f68f62f: 		if (!failed)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("registerOutParameter on non-output didn't fail");
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		// invalid param number
1:f68f62f: 		failed = false;
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.registerOutParameter(9, Types.INTEGER);
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			failed = true;
1:f68f62f: 			System.out.println("Expected exception "+se);
1:f68f62f: 		}
1:f68f62f: 		if (!failed)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("registerOutParameter on bad value didn't fail");
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		// invalid param number
1:f68f62f: 		failed = false;
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.registerOutParameter(0, Types.INTEGER);
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			failed = true;
1:f68f62f: 			System.out.println("Expected exception "+se);
1:f68f62f: 		}
1:f68f62f: 		if (!failed)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("registerOutParameter on bad value didn't fail");
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		// set before register, bad type, should fail as is output parameter.	
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.setDouble(1, 1);
1:f68f62f: 			System.out.println("FAIL setDouble() on takesString() accepted");
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("Expected exception "+se);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		// set before register, should fail as is output parameter.
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.setString(1, "hello");
1:f68f62f: 			System.out.println("FAIL setString() on takesString() accepted");
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("Expected exception "+se);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		cs.registerOutParameter(1, Types.CHAR);
1:f68f62f: 		cs.setInt(2, Types.INTEGER);
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.execute();
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("cs.execute() got unexpected exception: "+se);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		// shouldn't have to reregister the type, and shouldn't
1:f68f62f: 		// need to set the output parameters
1:f68f62f: 		cs.clearParameters();
1:f68f62f: 		cs.setInt(2, Types.INTEGER);
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs.execute();
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("cs.execute() got unexpected exception: "+se);
1:f68f62f: 		}
1:f68f62f: 		cs.close();
1:f68f62f: 		scp.execute("DROP PROCEDURE takesString");
1:f68f62f: 
1:b9c171c: 		scp.execute("CREATE FUNCTION returnsString(P2 INT) RETURNS VARCHAR(40) " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "returnsString'" +
1:f68f62f: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 		// return output params -- cannot do set on return output param
1:b9c171c: 		cs = conn.prepareCall("? = call returnsString(?)");
1:f68f62f: 		try
1:f68f62f: 		{
1:b9c171c: 			cs.setString(1, new String("test"));
1:b9c171c: 			System.out.println("ERROR: setString() on return output parameter succeeded");
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:b9c171c: 			System.out.println("Expected exception on setString() on a return output param: "+se);
1:f68f62f: 		}
1:f68f62f: 		cs.close();
1:b9c171c: 		scp.execute("DROP FUNCTION returnsString");
1:f68f62f: 
1:f68f62f: 		// lets try ? = call syntax on a call that doesn't return anything
1:f68f62f: 		
1:f68f62f: 		scp.execute("CREATE PROCEDURE returnsNothing() " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "returnsNothing'" +
1:f68f62f: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs = conn.prepareCall("? = call returnsNothing()");
1:f68f62f: 			System.out.println("ERROR: no exception on prepare of '? = call returnsNothing()");
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("Expected exception on prepare of '? = call returnsNothing()': "+se);
1:f68f62f: 		}
1:f68f62f: 		scp.execute("DROP PROCEDURE returnsNothing");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	
1:f68f62f: 	private static void testNull(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================");
1:f68f62f: 		System.out.println("TESTING NULLS");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 		System.out.println("Test for bug 4317, passing null value for a parameter");
1:f68f62f: 
1:f68f62f: 		Statement scp = conn.createStatement();
1:f68f62f: 
1:f68f62f: 		scp.execute("CREATE PROCEDURE testNullBug4317(IN P1 VARCHAR(10)) " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "testNullBug4317'" +
1:f68f62f: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		CallableStatement cs0 = conn.prepareCall("call testNullBug4317(?)");
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			cs0.setString(1, null);		// passing in null
1:f68f62f: 			cs0.execute();
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("cs0.execute() got unexpected exception: "+se);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			// BUG 5928 - setNull throws an exception - fixed.
1:f68f62f: 			cs0.setNull(1, java.sql.Types.VARCHAR);		// passing in null
1:f68f62f: 			cs0.execute();
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("cs0.execute() got unexpected exception: "+se);
1:f68f62f: 		}
1:f68f62f: 		cs0.close();
1:f68f62f: 		scp.execute("DROP PROCEDURE testNullBug4317");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	// test: do we get an appropriate update count when using ?=call?
1:f68f62f: 	private static void testUpdate(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================");
1:f68f62f: 		System.out.println("TESTING UPDATE COUNT");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 
1:f68f62f: 		Statement scp = conn.createStatement();
1:f68f62f: 
1:f68f62f: 		scp.execute("CREATE FUNCTION returnsIntegerP(P1 INT) RETURNS INTEGER " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "returnsIntegerP'" +
1:f68f62f: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		CallableStatement cs = conn.prepareCall("? = call returnsIntegerP(0)");
1:f68f62f: 		cs.registerOutParameter(1, Types.INTEGER);
1:f68f62f: 		try
1:f68f62f: 		{
1:f68f62f: 			int updCount = cs.executeUpdate();
1:f68f62f: 			System.out.println("executeUpdate on ? = call returnsIntegerP returned "+updCount);
1:f68f62f: 			System.out.println("getString(1) returned "+cs.getString(1));
1:f68f62f: 		}
1:f68f62f: 		catch (SQLException se)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("cs.execute() got unexpected exception: "+se);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		cs.close();
1:f68f62f: 		scp.execute("DROP FUNCTION returnsIntegerP");
1:f68f62f: 		scp.close();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	// should do get setString() to use a string that is appropriate for
1:f68f62f: 	//	the target type
1:f68f62f: 	private static void testEachOutputType(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================");
1:f68f62f: 		System.out.println("TESTING NORMAL OUTPUT PARAMETERS");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 		CallableStatement cs = null;
1:f68f62f: 
1:f68f62f: 		for (int doSetObject = 0; doSetObject < 3; doSetObject++)
1:f68f62f: 		{
1:f68f62f: 			switch (doSetObject)
1:f68f62f: 			{
1:f68f62f: 				case 0:
1:f68f62f: 					System.out.println("...starting doing setXXX for each type xxx");
1:f68f62f: 					break;
1:f68f62f: 				case 1:
1:f68f62f: 					System.out.println("...now doing setObject on each type xxx");
1:f68f62f: 					break;
1:f68f62f: 				case 2:
1:f68f62f: 					System.out.println("...not doing any setXXX, just OUT parameters, not IN/OUT");
1:f68f62f: 					break;
1:f68f62f: 			}
1:f68f62f: 
1:f68f62f: 			for (int method = 0; method < outputMethods.length; method++)
1:f68f62f: 			{
1:f68f62f: 				String methodName = outputMethods[method];
1:f68f62f: 				if (methodName == null)
1:f68f62f: 					continue;
1:f68f62f: 
1:f68f62f: 				System.out.println("\n------------------------------------");
1:f68f62f: 
1:f68f62f: 				Statement scp = conn.createStatement();
1:f68f62f: 				String str;
1:f68f62f: 				if (methodName.indexOf("Nothing") == -1)
1:f68f62f: 				{
1:f68f62f: 
1:f68f62f: 					scp.execute("CREATE PROCEDURE " + methodName + "(INOUT P1 " + outputProcParam[method] + ", IN P2 INT) " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
1:f68f62f: 						"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 					if (method%2 == 0)
1:f68f62f: 						str = "{call "+methodName+"(?,?)}";
1:f68f62f: 					else
1:f68f62f: 						str = "call "+methodName+"(?,?)";
1:f68f62f: 				}
1:f68f62f: 				else
1:f68f62f: 				{
1:f68f62f: 					scp.execute("CREATE PROCEDURE " + methodName + "() " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
1:f68f62f: 						"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 					str = "{call "+methodName+"()}";
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	
1:f68f62f: 				System.out.println(str);
1:f68f62f: 				try 
1:f68f62f: 				{
1:f68f62f: 					cs = conn.prepareCall(str);
1:f68f62f: 				}
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("ERROR: unexpected exception "+se);
1:f68f62f: 					throw se;
1:f68f62f: 				}
1:f68f62f: 	
1:f68f62f: 				for (int type = 0; type < types.length; type++)
1:f68f62f: 				{
1:f68f62f: 					cs.clearParameters();
1:f68f62f: 					System.out.println();
1:f68f62f: 					try
1:f68f62f: 					{
1:f68f62f: 						System.out.println("\n\tcs.registerOutParameter(1, "+typeNames[type]+")");
1:f68f62f: 						cs.registerOutParameter(1, types[type]);
1:f68f62f: 					} 
1:f68f62f: 					catch (SQLException se)
1:f68f62f: 					{
1:f68f62f: 						System.out.println("\tException "+se);
1:f68f62f: 						continue;
1:f68f62f: 					}
1:f68f62f: 	
1:f68f62f: 					StringBuffer buf = new StringBuffer();
1:f68f62f: 					try
1:f68f62f: 					{
1:f68f62f: 						if (doSetObject == 0) 
1:f68f62f: 						{
1:f68f62f: 							callSetMethod(cs, 1, types[type], buf);
1:f68f62f: 						}
1:f68f62f: 						else if (doSetObject == 1)
1:f68f62f: 						{
1:f68f62f: 							callSetObject(cs, 1, types[type], buf);
1:f68f62f: 						}
1:f68f62f: 						else
1:f68f62f: 						{
1:f68f62f: 							// only try this once
1:f68f62f: 							type = types.length-1;
1:f68f62f: 							buf.append("...no setXXX(1) at all");
1:f68f62f: 						}
1:f68f62f: 					}
1:f68f62f: 					catch (SQLException se)
1:f68f62f: 					{
1:f68f62f: 						System.out.println("\t"+buf.toString());
1:f68f62f: 						System.out.println("\tException "+se);
1:f68f62f: 						continue;
1:f68f62f: 					}
1:f68f62f: 					System.out.println("\t"+buf.toString());
1:f68f62f: 					cs.setInt(2, types[type]);
1:f68f62f: 	
1:f68f62f: 					try
1:f68f62f: 					{
1:f68f62f: 						System.out.println("\tcs.execute()");
1:f68f62f: 						boolean hasResultSet = cs.execute();
1:f68f62f: 						if (hasResultSet)
1:f68f62f: 							System.out.println("testEachOutputType HAS RESULT SET cs.execute() returned true");
1:f68f62f: 						}
1:f68f62f: 					catch (SQLException se)
1:f68f62f: 					{
1:f68f62f: 						System.out.println("\tException "+se);
1:f68f62f: 						continue;
1:f68f62f: 					}
1:f68f62f: 					for (int getType = 0; getType < types.length; getType++)
1:f68f62f: 					{
1:f68f62f: 						StringBuffer getbuf = new StringBuffer();
1:f68f62f: 						try
1:f68f62f: 						{
1:b9c171c: 							callGetMethod(cs, 1, types[getType], paramJDBCType[method], getbuf);
1:f68f62f: 						}
1:f68f62f: 						catch (SQLException se)
1:f68f62f: 						{
1:f68f62f: 							getbuf.append(se);
1:f68f62f: 						}
1:f68f62f: 						System.out.println("\t\t\t"+getbuf.toString());
1:f68f62f: 					}
1:f68f62f: 	
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 				cs.close();
1:f68f62f: 
1:f68f62f: 				scp.execute("DROP PROCEDURE " + methodName);
1:f68f62f: 				scp.close();
1:f68f62f: 			}
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		System.out.println("------------------------------------\n");
1:f68f62f: 
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	// test that everything works ok when we regsiter the param as type OTHER.
1:f68f62f: 	// should be able to get/setXXX of the appropriate type
1:f68f62f: 	private static void testOtherOutputType(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================");
1:f68f62f: 		System.out.println("TESTING OUTPUT PARAMETERS WITH register(OTHER)");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 		CallableStatement cs = null;
1:f68f62f: 
1:f68f62f: 		for (int method = 0; method < outputMethods.length; method++)
1:f68f62f: 		{
1:f68f62f: 			String methodName = outputMethods[method];
1:f68f62f: 			if (methodName == null)
1:f68f62f: 				continue;
1:f68f62f: 			System.out.println("\n------------------------------------");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 			Statement scp = conn.createStatement();
1:f68f62f: 			String str;
1:f68f62f: 			if (methodName.indexOf("Nothing") == -1)
1:f68f62f: 			{
1:f68f62f: 
1:f68f62f: 				scp.execute("CREATE PROCEDURE " + methodName + "(INOUT P1 " + outputProcParam[method] + ", IN P2 INT) " +
1:b9c171c: 					"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
1:f68f62f: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 				if (method%2 == 0)
1:f68f62f: 					str = "{call "+methodName+"(?,?)}";
1:f68f62f: 				else
1:f68f62f: 					str = "call "+methodName+"(?,?)";
1:f68f62f: 			}
1:f68f62f: 			else
1:f68f62f: 			{
1:f68f62f: 				scp.execute("CREATE PROCEDURE " + methodName + "() " +
1:b9c171c: 					"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
1:f68f62f: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 				str = "{call "+methodName+"()}";
1:f68f62f: 			}
1:f68f62f: 
1:f68f62f: 			System.out.println(str);
1:f68f62f: 			try 
1:f68f62f: 			{
1:f68f62f: 				cs = conn.prepareCall(str);
1:f68f62f: 			}
1:f68f62f: 			catch (SQLException se)
1:f68f62f: 			{
1:f68f62f: 				System.out.println("ERROR: unexpected exception "+se);
1:f68f62f: 				throw se;
1:f68f62f: 			}
1:f68f62f: 	
1:f68f62f: 			for (int type = 0; type < types.length; type++)
1:f68f62f: 			{
1:f68f62f: 				cs.clearParameters();
1:f68f62f: 				System.out.println();
1:f68f62f: 				try
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\n\tcs.registerOutParameter(1, Types.OTHER)");
1:f68f62f: 					cs.registerOutParameter(1, Types.OTHER);
1:f68f62f: 				} 
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tException "+se);
1:f68f62f: 					continue;
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 				StringBuffer buf = new StringBuffer();
1:f68f62f: 				try
1:f68f62f: 				{
1:f68f62f: 					callSetMethod(cs, 1, types[type], buf);
1:f68f62f: 				}
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\t"+buf.toString());
1:f68f62f: 					System.out.println("\tException "+se);
1:f68f62f: 					continue;
1:f68f62f: 				}
1:f68f62f: 				System.out.println("\t"+buf.toString());
1:f68f62f: 				cs.setInt(2, types[type]);
1:f68f62f: 
1:f68f62f: 				try
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tcs.execute()");
1:f68f62f: 					cs.execute();
1:f68f62f: 				}
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tException "+se);
1:f68f62f: 					continue;
1:f68f62f: 				}
1:f68f62f: 				for (int getType = 0; getType < types.length; getType++)
1:f68f62f: 				{
1:f68f62f: 					StringBuffer getbuf = new StringBuffer();
1:f68f62f: 					try
1:f68f62f: 					{
1:b9c171c: 						callGetMethod(cs, 1, types[getType], Types.OTHER , getbuf);
1:f68f62f: 					}
1:f68f62f: 					catch (SQLException se)
1:f68f62f: 					{
1:f68f62f: 						getbuf.append(se);
1:f68f62f: 					}
1:f68f62f: 					System.out.println("\t\t\t"+getbuf.toString());
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 			}
1:f68f62f: 
1:f68f62f: 			cs.close();
1:f68f62f: 
1:f68f62f: 			scp.execute("DROP PROCEDURE " + methodName);
1:f68f62f: 			scp.close();
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		System.out.println("------------------------------------\n");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	private static void testReturnTypes(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 		System.out.println("TESTING RETURN OUTPUT PARAMETERS");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 		CallableStatement cs = null;
1:f68f62f: 		for (int method = 0; method < returnMethods.length; method++)
1:f68f62f: 		{
1:f68f62f: 			String methodName = returnMethods[method];
1:f68f62f: 			if (methodName == null)
1:f68f62f: 				continue;
1:f68f62f: 
1:f68f62f: 			Statement scf = conn.createStatement();
1:f68f62f: 			String str;
1:f68f62f: 			String dropRoutine;
1:f68f62f: 			if (methodName.indexOf("Nothing") != -1)
1:f68f62f: 			{
1:f68f62f: 
1:f68f62f: 				scf.execute("CREATE PROCEDURE " + methodName + "()" +
1:b9c171c: 					" EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
1:f68f62f: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 				dropRoutine = "DROP PROCEDURE " + methodName;
1:f68f62f: 
1:f68f62f: 				str = "{call "+returnMethods[method]+"()}";
1:f68f62f: 			}
1:f68f62f: 			else
1:f68f62f: 			{
1:f68f62f: 
1:f68f62f: 				scf.execute("CREATE FUNCTION " + methodName + "(P1 INT) RETURNS " + returnMethodType[method] +
1:b9c171c: 					" EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
1:f68f62f: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 				dropRoutine = "DROP FUNCTION " + methodName;
1:f68f62f: 
1:f68f62f: 				str = "{? = call "+returnMethods[method]+"(?)}";
1:f68f62f: 			}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 				
1:f68f62f: 			System.out.println("\n------------------------------------");
1:f68f62f: 				
1:f68f62f: 
1:f68f62f: 			System.out.println(str);
1:f68f62f: 			try 
1:f68f62f: 			{
1:f68f62f: 				cs = conn.prepareCall(str);
1:f68f62f: 			}
1:f68f62f: 			catch (SQLException se)
1:f68f62f: 			{
1:f68f62f: 				System.out.println("ERROR: unexpected exception "+se);
1:f68f62f: 				throw se;
1:f68f62f: 			}
1:f68f62f: 
1:f68f62f: 			for (int type = 0; type < types.length; type++)
1:f68f62f: 			{
1:f68f62f: 				cs.clearParameters();
1:f68f62f: 				System.out.println();
1:f68f62f: 				try
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\n\tcs.registerOutParameter(1, "+typeNames[type]+")");
1:f68f62f: 					cs.registerOutParameter(1, types[type]);
1:f68f62f: 				} 
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tException "+se);
1:f68f62f: 					continue;
1:f68f62f: 				}
1:f68f62f: 				try
1:f68f62f: 				{
1:f68f62f: 					cs.setInt(2, types[type]);
1:f68f62f: 				}
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tUnexpected exception on cs.setInt(2, "+types[type]+"): "+se);
1:f68f62f: 					continue;
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 				try
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tcs.execute()");
1:f68f62f: 					boolean hasResultSet = cs.execute();
1:f68f62f: 					if (hasResultSet)
1:f68f62f: 						System.out.println("testReturnTypes HAS RESULT SET cs.execute() returned true");
1:f68f62f: 
1:f68f62f: 				}
1:f68f62f: 				catch (SQLException se)
1:f68f62f: 				{
1:f68f62f: 					System.out.println("\tException "+se);
1:f68f62f: 					continue;
1:f68f62f: 				}
1:f68f62f: 				for (int getType = 0; getType < types.length; getType++)
1:f68f62f: 				{
1:f68f62f: 					StringBuffer getbuf = new StringBuffer();
1:f68f62f: 					try
1:f68f62f: 					{
1:b9c171c: 						callGetMethod(cs, 1, types[getType], paramJDBCType[method], getbuf);
1:f68f62f: 					}
1:f68f62f: 					catch (SQLException se)
1:f68f62f: 					{
1:f68f62f: 						getbuf.append(se);
1:f68f62f: 					}
1:f68f62f: 					System.out.println("\t\t\t"+getbuf.toString());
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 			}
1:f68f62f: 
1:f68f62f: 			cs.close();
1:f68f62f: 			scf.execute(dropRoutine);
1:f68f62f: 			scf.close();
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		System.out.println("------------------------------------\n");
1:f68f62f: 
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	private static void callSetObject(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
1:f68f62f: 	{
1:f68f62f: 
1:f68f62f: 		switch (type)	
1:f68f62f: 		{
1:f68f62f: 			case Types.BIT:
1:1a4ea31: 			case Types.BOOLEAN:
1:f68f62f: 				strbuf.append("setObject("+arg+", true)");
1:39b3237: 				cs.setObject(arg, true);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TINYINT:
1:f68f62f: 				strbuf.append("setObject("+arg+", 6)");
1:39b3237: 				cs.setObject(arg, 6);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.SMALLINT:
1:f68f62f: 				strbuf.append("setObject("+arg+", 66)");
1:39b3237: 				cs.setObject(arg, 66);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.INTEGER:
1:f68f62f: 				strbuf.append("setObject("+arg+", 666)");
1:39b3237: 				cs.setObject(arg, 666);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.BIGINT:
1:f68f62f: 				strbuf.append("setObject("+arg+", 666)");
1:39b3237: 				cs.setObject(arg, 666L);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.FLOAT:
1:f68f62f: 			case Types.REAL:
1:f68f62f: 				strbuf.append("setObject("+arg+", 666)");
1:39b3237: 				cs.setObject(arg, 666f);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DOUBLE:
1:f68f62f: 				strbuf.append("setObject("+arg+", 666)");
1:39b3237: 				cs.setObject(arg, 666.0);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DECIMAL:
1:f68f62f: 			case Types.NUMERIC:
1:f68f62f: 				strbuf.append("setObject("+arg+", 666.666)");
1:b9c171c: 				BigDecimalHandler.setObjectString(cs,arg,"666.666");
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.CHAR:
1:f68f62f: 			case Types.VARCHAR:
1:f68f62f: 			case Types.LONGVARCHAR:
1:f68f62f: 				strbuf.append("setObject("+arg+", \"Set via setString()\")");
1:f68f62f: 				cs.setObject(arg, "Set via setString()");
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.BINARY:
1:f68f62f: 			case Types.VARBINARY:
1:f68f62f: 			case Types.LONGVARBINARY:
1:f68f62f: 				strbuf.append("setObject("+arg+", byte[])");
1:f68f62f: 				byte[] myarray = new byte[16];
1:f68f62f: 				myarray[0] = (byte)255;
1:f68f62f: 				cs.setObject(arg, myarray);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DATE:
1:f68f62f: 				strbuf.append("setObject("+arg+", Date.valueOf(1999-09-09))");
1:f68f62f: 				cs.setObject(arg, Date.valueOf("1999-09-09"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TIME:
1:f68f62f: 				strbuf.append("setObject("+arg+", Time.valueOf(09:09:09))");
1:f68f62f: 				cs.setObject(arg, Time.valueOf("09:09:09"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TIMESTAMP:
1:f68f62f: 				strbuf.append("setObject("+arg+", Timestamp.valueOf(1999-09-09 09:09:09.999))");
1:f68f62f: 				cs.setObject(arg, Timestamp.valueOf("1999-09-09 09:09:09.999"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.OTHER:
1:f68f62f: 				strbuf.append("setObject("+arg+", new BigInteger(666))");
1:f68f62f: 				cs.setObject(arg, new BigInteger("666"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			default:
1:f68f62f: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1:f68f62f: 		}	
1:f68f62f: 	}
1:f68f62f: 	private static void callSetMethod(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		switch (type)	
1:f68f62f: 		{
1:f68f62f: 			case Types.BIT:
1:1a4ea31: 			case Types.BOOLEAN:
1:f68f62f: 				strbuf.append("setBoolean("+arg+", true)");
1:f68f62f: 				cs.setBoolean(arg, true);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TINYINT:
1:f68f62f: 				strbuf.append("setByte("+arg+", 6)");
1:f68f62f: 				cs.setByte(arg, (byte)6);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.SMALLINT:
1:f68f62f: 				strbuf.append("setShort("+arg+", 66)");
1:f68f62f: 				cs.setShort(arg, (short)66);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.INTEGER:
1:f68f62f: 				strbuf.append("setInt("+arg+", 666)");
1:f68f62f: 				cs.setInt(arg, 666);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.BIGINT:
1:f68f62f: 				strbuf.append("setLong("+arg+", 666)");
1:f68f62f: 				cs.setLong(arg, 666);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.FLOAT:
1:f68f62f: 			case Types.REAL:
1:f68f62f: 				strbuf.append("setFLoat("+arg+", 666)");
1:f68f62f: 				cs.setFloat(arg, 666);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DOUBLE:
1:f68f62f: 				strbuf.append("setDouble("+arg+", 666)");
1:f68f62f: 				cs.setDouble(arg, 666);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DECIMAL:
1:f68f62f: 			case Types.NUMERIC:
1:f68f62f: 				strbuf.append("setBigDecimal("+arg+", 666.666)");
1:b9c171c: 				BigDecimalHandler.setBigDecimalString(cs,arg,"666.666");
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.CHAR:
1:f68f62f: 			case Types.VARCHAR:
1:f68f62f: 			case Types.LONGVARCHAR:
1:f68f62f: 				strbuf.append("setString("+arg+", \"Set via setString()\")");
1:f68f62f: 				cs.setString(arg, "Set via setString()");
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.BINARY:
1:f68f62f: 			case Types.VARBINARY:
1:f68f62f: 			case Types.LONGVARBINARY:
1:f68f62f: 				strbuf.append("setBytes("+arg+", byte[])");
1:f68f62f: 				byte[] myarray = new byte[16];
1:f68f62f: 				myarray[0] = (byte)255;
1:f68f62f: 				cs.setBytes(arg, myarray);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DATE:
1:f68f62f: 				strbuf.append("setDate("+arg+", Date.valueOf(1999-09-09))");
1:f68f62f: 				cs.setDate(arg, Date.valueOf("1999-09-09"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TIME:
1:f68f62f: 				strbuf.append("setTime("+arg+", Time.valueOf(09:09:09))");
1:f68f62f: 				cs.setTime(arg, Time.valueOf("09:09:09"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TIMESTAMP:
1:f68f62f: 				strbuf.append("setTimestamp("+arg+", Timestamp.valueOf(1999-09-09 09:09:09.999))");
1:f68f62f: 				cs.setTimestamp(arg, Timestamp.valueOf("1999-09-09 09:09:09.999"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.OTHER:
1:f68f62f: 				strbuf.append("setObject("+arg+", new BigInteger(666))");
1:f68f62f: 				cs.setObject(arg, new BigInteger("666"));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			default:
1:f68f62f: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1:f68f62f: 		}	
1:f68f62f: 	}
1:f68f62f: 
1:b9c171c: 	private static void callGetMethod(CallableStatement cs, int arg, int type, int paramType ,StringBuffer strbuf) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		switch (type)	
1:f68f62f: 		{
1:f68f62f: 			case Types.BIT:
1:1a4ea31: 			case Types.BOOLEAN:
1:f68f62f: 				strbuf.append("getBoolean("+arg+") = ");
1:f68f62f: 				strbuf.append(cs.getBoolean(arg));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TINYINT:
1:f68f62f: 				strbuf.append("getByte("+arg+") = ");
1:f68f62f: 				strbuf.append(Byte.toString(cs.getByte(arg)));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.SMALLINT:
1:f68f62f: 				strbuf.append("getShort("+arg+") = ");
1:f68f62f: 				strbuf.append(Short.toString(cs.getShort(arg)));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.INTEGER:
1:f68f62f: 				strbuf.append("getInt("+arg+") = ");
1:f68f62f: 				strbuf.append(Integer.toString(cs.getInt(arg)));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.BIGINT:
1:f68f62f: 				strbuf.append("getLong("+arg+") = ");
1:f68f62f: 				strbuf.append(Long.toString(cs.getLong(arg)));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.FLOAT:
1:f68f62f: 			case Types.REAL:
1:f68f62f: 				strbuf.append("getFloat("+arg+") = ");
1:f68f62f: 				strbuf.append(Float.toString(cs.getFloat(arg)));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DOUBLE:
1:f68f62f: 				strbuf.append("getDouble("+arg+") = ");
1:f68f62f: 				strbuf.append(Double.toString(cs.getDouble(arg)));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DECIMAL:
1:f68f62f: 			case Types.NUMERIC:
1:f68f62f: 				strbuf.append("getBigDecimal("+arg+") = ");
1:b9c171c: 				strbuf.append(BigDecimalHandler.getBigDecimalString(cs,arg,paramType));
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.CHAR:
1:f68f62f: 			case Types.VARCHAR:
1:f68f62f: 			case Types.LONGVARCHAR:
1:f68f62f: 				strbuf.append("getString("+arg+") = ");
1:f68f62f: 				String s = cs.getString(arg);
1:f68f62f: 				if (s.startsWith("[B@"))
1:f68f62f: 					s = "byte[] reference";
1:f68f62f: 				strbuf.append(s);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.BINARY:
1:f68f62f: 			case Types.VARBINARY:
1:f68f62f: 			case Types.LONGVARBINARY:
1:f68f62f: 				strbuf.append("getBytes("+arg+") = ");
1:f68f62f: 				byteArrayToString(cs.getBytes(arg), strbuf);
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.DATE:
1:f68f62f: 				strbuf.append("getDate("+arg+") = ");
1:f68f62f: 				Date date = cs.getDate(arg);
1:f68f62f: 				strbuf.append(date == null ? "null" : date.toString());
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TIME:
1:f68f62f: 				strbuf.append("getTime("+arg+") = ");
1:f68f62f: 				Time time = cs.getTime(arg);
1:f68f62f: 				strbuf.append(time == null ? "null" : time.toString());
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.TIMESTAMP:
1:f68f62f: 				strbuf.append("getTimestamp("+arg+") = ");
1:f68f62f: 				Timestamp timestamp = cs.getTimestamp(arg);
1:f68f62f: 				strbuf.append(timestamp == null ? "null" : timestamp.toString());
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			case Types.OTHER:
1:f68f62f: 				strbuf.append("getObject("+arg+") = ");
1:f68f62f: 				Object o = cs.getObject(arg);
1:f68f62f: 				if (o == null)
1:f68f62f: 				{
1:f68f62f: 					strbuf.append("null");
1:f68f62f: 				}
1:f68f62f: 				else if (o instanceof byte[])
1:f68f62f: 				{
1:f68f62f: 					byteArrayToString((byte[])o, strbuf);
1:f68f62f: 				}
1:f68f62f: 				else
1:f68f62f: 				{
1:f68f62f: 					strbuf.append(o.toString());
1:f68f62f: 				}
1:f68f62f: 
1:f68f62f: 				break;
1:f68f62f: 
1:f68f62f: 			default:
1:f68f62f: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1:f68f62f: 		}	
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	static private void byteArrayToString(byte[] barray, StringBuffer strbuf)
1:f68f62f: 	{
1:f68f62f: 		if (barray == null)
1:f68f62f: 		{
1:f68f62f: 			strbuf.append("null");
1:f68f62f: 		}
1:f68f62f: 		else
1:f68f62f: 		{
1:f68f62f: 			for (int i = 0; i<barray.length; i++)
1:f68f62f: 			{
1:f68f62f: 				strbuf.append(barray[i]);
1:f68f62f: 			}
1:f68f62f: 		}
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	private static String getStringOfType(int type) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		switch (type)
1:f68f62f: 		{
1:f68f62f: 			case Types.CHAR:
1:f68f62f: 			case Types.VARCHAR:
1:f68f62f: 			case Types.LONGVARCHAR:
1:f68f62f: 				return "I am a string";
1:f68f62f: 
1:f68f62f: 			case Types.TINYINT:
1:f68f62f: 			case Types.SMALLINT:
1:f68f62f: 			case Types.INTEGER:
1:f68f62f: 			case Types.BIGINT:
1:f68f62f: 			case Types.OTHER:		// other is bigInt
1:f68f62f: 				return "3";
1:f68f62f: 
1:f68f62f: 			case Types.FLOAT:
1:f68f62f: 			case Types.REAL:
1:f68f62f: 			case Types.DECIMAL:
1:f68f62f: 			case Types.NUMERIC:
1:f68f62f: 				return  "3.33";
1:f68f62f: 
1:f68f62f: 			case Types.DATE:		
1:f68f62f: 				return "1933-03-03";
1:f68f62f: 
1:f68f62f: 			case Types.TIME:		
1:f68f62f: 				return "03:03:03";
1:f68f62f: 
1:f68f62f: 			case Types.TIMESTAMP:		
1:f68f62f: 				return "1933-03-03 03:03:03.333";
1:f68f62f: 
1:f68f62f: 			case Types.BINARY:		
1:f68f62f: 			case Types.VARBINARY:		
1:f68f62f: 			case Types.LONGVARBINARY:
1:f68f62f: 				return "00680065006c006c006f";
1:f68f62f: 
1:f68f62f: 			case Types.BIT:
1:1a4ea31: 			case Types.BOOLEAN:
1:f68f62f: 				return "true";
1:f68f62f: 
1:f68f62f: 			default:
1:f68f62f: 				throw new Throwable("bad type "+type);
1:f68f62f: 		}	
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/////////////////////////////////////////////////////////////
1:f68f62f: 	//	
1:f68f62f: 	// OUTPUT PARAMETER METHODS
1:f68f62f: 	//
1:f68f62f: 	/////////////////////////////////////////////////////////////
1:f68f62f: 	public static void testNull(Boolean passedInNull, Boolean setToNull, Integer[] retval) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		if (passedInNull.booleanValue())
1:f68f62f: 		{
1:f68f62f: 			if (retval[0] != null)
1:f68f62f: 			{
1:f68f62f: 				throw new Throwable("testNull() got a non-null param when it should have been null");
1:f68f62f: 			}
1:f68f62f: 		}
1:f68f62f: 
1:39b3237: 		retval[0] = (setToNull.booleanValue()) ? null : 66;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void testNullBug4317(String passedInNull) throws Throwable
1:f68f62f: 	{
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesNothing()
1:f68f62f: 	{
1:f68f62f: 	}
1:f68f62f: 	public static void takesBytePrimitive(byte[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0]+=outparam[0];
1:f68f62f: 	}
1:f68f62f: 	public static void takesByte(Byte[] outparam, int type)
1:f68f62f: 	{
1:39b3237: 		outparam[0] = ((byte)(outparam[0] == null ? 33 : outparam[0].byteValue()*2));
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesShortPrimitive(short[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0]+=outparam[0];
1:f68f62f: 	}
1:f68f62f: 	public static void takesShort(Short[] outparam, int type)
1:f68f62f: 	{
1:39b3237:       outparam[0] = (short) ((byte)(outparam[0] == null ? 33 : outparam[0].shortValue()*2));
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesIntegerPrimitive(int[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0]+=outparam[0];
1:f68f62f: 	}
1:f68f62f: 	public static void takesInteger(Integer[] outparam, int type)
1:f68f62f: 	{
1:39b3237: 		outparam[0] = outparam[0] == null ? 33 : outparam[0].intValue()*2;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesLongPrimitive(long[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0]+=outparam[0];
1:f68f62f: 	}
1:f68f62f: 	public static void takesLong(Long[] outparam, int type)
1:f68f62f: 	{
1:39b3237:       outparam[0] = (long)(outparam[0] == null ? 33 : outparam[0].longValue()*2);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesDoublePrimitive(double[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0]+=outparam[0];
1:f68f62f: 	}
1:f68f62f: 	public static void takesDouble(Double[] outparam, int type)
1:f68f62f: 	{
1:39b3237:       outparam[0] = (double) (outparam[0] == null ? 33 : outparam[0].doubleValue()*2);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesFloatPrimitive(float[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0]+=outparam[0];
1:f68f62f: 	}
1:f68f62f: 	public static void takesFloat(Float[] outparam, int type)
1:f68f62f: 	{
1:39b3237:       outparam[0] = (float) (outparam[0] == null ? 33 : outparam[0].floatValue()*2);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesBooleanPrimitive(boolean[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0] = true;
1:f68f62f: 	}
1:f68f62f: 	public static void takesBoolean(Boolean[] outparam, int type)
1:f68f62f: 	{
1:39b3237: 		outparam[0] = true;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesByteArray(byte[][] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		byte[] myarray = new byte[16];
1:f68f62f: 		myarray[0] = (byte)255;
1:f68f62f: 		outparam[0] = myarray;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesDate(Date[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0] = Date.valueOf("1966-06-06");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesTime(Time[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0] = Time.valueOf("06:06:06");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesTimestamp(Timestamp[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0] = Timestamp.valueOf("1966-06-06 06:06:06.666");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesString(String[] outparam, int type) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		outparam[0] = getStringOfType(type);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void takesBigInteger(BigInteger[] outparam, int type)
1:f68f62f: 	{
1:f68f62f: 		outparam[0] = (outparam[0] == null ? new BigInteger("33") : outparam[0].add(outparam[0]));
1:f68f62f: 	}
1:f68f62f: 	
1:f68f62f: 	
1:f68f62f: 	/////////////////////////////////////////////////////////////
1:f68f62f: 	//	
1:f68f62f: 	// RETURN PARAMETER METHODS
1:f68f62f: 	//
1:f68f62f: 	/////////////////////////////////////////////////////////////
1:f68f62f: 	public static void returnsNothing()
1:f68f62f: 	{
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static byte returnsByteP(int type)
1:f68f62f: 	{
1:f68f62f: 		return 66;
1:f68f62f: 	}
1:f68f62f: 	public static Byte returnsByte(int type)
1:f68f62f: 	{
1:39b3237: 		return (byte)66;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static short returnsShortP(int type)
1:f68f62f: 	{
1:f68f62f: 		return 666;
1:f68f62f: 	}
1:f68f62f: 	public static Short returnsShort(int type)
1:f68f62f: 	{
1:39b3237: 		return (short)666;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static int returnsIntegerP(int type)
1:f68f62f: 	{
1:f68f62f: 		return 666;
1:f68f62f: 	}
1:f68f62f: 	public static Integer returnsInteger(int type)
1:f68f62f: 	{
1:39b3237: 		return 666;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static long returnsLongP(int type)
1:f68f62f: 	{
1:f68f62f: 		return 666;
1:f68f62f: 	}
1:f68f62f: 	public static Long returnsLong(int type)
1:f68f62f: 	{
1:39b3237: 		return 666L;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static float returnsFloatP(int type)
1:f68f62f: 	{
1:f68f62f: 		return 666;
1:f68f62f: 	}
1:f68f62f: 	public static Float returnsFloat(int type)
1:f68f62f: 	{
1:39b3237: 		return 666f;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static double returnsDoubleP(int type)
1:f68f62f: 	{
1:f68f62f: 		return 666;
1:f68f62f: 	}
1:f68f62f: 	public static Double returnsDouble(int type)
1:f68f62f: 	{
1:39b3237: 		return 666.0;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static byte[] returnsByteArray(int type)
1:f68f62f: 	{
1:f68f62f: 		byte[] myarray = new byte[16];
1:f68f62f: 		myarray[0] = (byte)255;
1:f68f62f: 		return myarray;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static String returnsString(int type) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		return getStringOfType(type);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static Date returnsDate(int type)
1:f68f62f: 	{
1:f68f62f: 		return Date.valueOf("1966-06-06");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static Time returnsTime(int type)
1:f68f62f: 	{
1:f68f62f: 		return Time.valueOf("06:06:06");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static Timestamp returnsTimestamp(int type)
1:f68f62f: 	{
1:f68f62f: 		return Timestamp.valueOf("1966-06-06 06:06:06.666");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static BigInteger returnsBigInteger(int type)
1:f68f62f: 	{
1:f68f62f: 		return new BigInteger("666");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	// these come from the performance test JDBC.Parameters that was failing
1:f68f62f: 	private static void testManyOut(Connection conn) throws SQLException {
1:f68f62f: 
1:f68f62f: 		System.out.println("start testManyOut");
1:f68f62f: 
1:f68f62f: 		Statement scp = conn.createStatement();
1:f68f62f: 
1:f68f62f: 		scp.execute("CREATE PROCEDURE OP_OUT " +
1:f68f62f: 			"(OUT I1 INT, OUT I2 INT, OUT I3 INT, OUT I4 INT, OUT I5 INT, "+
1:f68f62f: 			"OUT V1 VARCHAR(40), OUT V2 VARCHAR(40), OUT V3 VARCHAR(40), OUT V4 VARCHAR(40), OUT V5 VARCHAR(40)) "+
1:f68f62f: 
1:b9c171c: 			"EXTERNAL NAME '" + CLASS_NAME + "output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		scp.execute("CREATE PROCEDURE OP_INOUT " +
1:f68f62f: 			"(INOUT I1 INT, INOUT I2 INT, INOUT I3 INT, INOUT I4 INT, INOUT I5 INT, " +
1:f68f62f: 			"INOUT V1 VARCHAR(40), INOUT V2 VARCHAR(40), INOUT V3 VARCHAR(40), INOUT V4 VARCHAR(40), INOUT V5 VARCHAR(40)) " +
1:f68f62f: 
1:b9c171c: 			"EXTERNAL NAME '" + CLASS_NAME + "output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		CallableStatement csOut_cs = conn.prepareCall("CALL OP_OUT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:f68f62f: 		CallableStatement csInOut_cs = conn.prepareCall("CALL OP_INOUT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:f68f62f: 
1:f68f62f: 		System.out.println("Ten OUT parameters");
1:f68f62f: 
1:f68f62f: 		executeOutput(csOut_cs);
1:f68f62f: 		executeOutput(csOut_cs);
1:f68f62f: 
1:f68f62f: 		csOut_cs.close();
1:f68f62f: 
1:f68f62f: 		System.out.println("Ten INOUT parameters");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		setupInput(csInOut_cs);
1:f68f62f: 		executeOutput(csInOut_cs);
1:f68f62f: 
1:f68f62f: 		setupInput(csInOut_cs);
1:f68f62f: 		executeOutput(csInOut_cs);
1:f68f62f: 
1:f68f62f: 		csInOut_cs.close();
1:f68f62f: 
1:f68f62f: 		scp.execute("DROP PROCEDURE OP_OUT");
1:f68f62f: 		scp.execute("DROP PROCEDURE OP_INOUT");
1:f68f62f: 		scp.close();
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		System.out.println("end testManyOut");
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	private static void setupInput(PreparedStatement ps) throws SQLException {
1:f68f62f: 
1:f68f62f: 		ps.setInt(1, 0);
1:f68f62f: 		ps.setInt(2, 0);
1:f68f62f: 		ps.setInt(3, 99);
1:f68f62f: 		ps.setInt(4, 103);
1:f68f62f: 		ps.setInt(5, 1456);
1:f68f62f: 
1:f68f62f: 		ps.setNull(6, Types.CHAR);
1:f68f62f: 		ps.setString(7, null);
1:f68f62f: 		ps.setString(8, "hello");
1:f68f62f: 		ps.setString(9, "goodbye");
1:f68f62f: 		ps.setString(10, "welcome");
1:f68f62f: 	}
1:f68f62f: 	private static void executeOutput(CallableStatement cs) throws SQLException {
1:f68f62f: 
1:f68f62f: 		for (int p = 1; p <= 5; p++)
1:f68f62f: 			cs.registerOutParameter(p, Types.INTEGER);
1:f68f62f: 
1:f68f62f: 		for (int p = 6; p <= 10; p++)
1:f68f62f: 			cs.registerOutParameter(p, Types.VARCHAR);
1:f68f62f: 
1:f68f62f: 		cs.execute();
1:f68f62f: 
1:f68f62f: 		for (int p = 1; p <= 5; p++) {
1:f68f62f: 			System.out.println("  " + p + " = " + cs.getInt(p) + " was null " + cs.wasNull());
1:f68f62f: 	
1:f68f62f: 		}
1:f68f62f: 		for (int p = 6; p <= 10; p++) {
1:f68f62f: 			System.out.println("  " + p + " = " + cs.getString(p) + " was null " + cs.wasNull());
1:f68f62f: 		}
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	public static void output(int[] a1, int[] a2, int[] a3, int[] a4, int[] a5,
1:f68f62f: 		String[] s1, String[] s2, String[] s3, String[] s4, String[] s5) {
1:f68f62f: 
1:f68f62f: 		System.out.println("  a1 = " + a1[0]);
1:f68f62f: 		System.out.println("  a2 = " + a2[0]);
1:f68f62f: 		System.out.println("  a3 = " + a3[0]);
1:f68f62f: 		System.out.println("  a4 = " + a4[0]);
1:f68f62f: 		System.out.println("  a5 = " + a5[0]);
1:f68f62f: 
1:f68f62f: 		System.out.println("  s1 = " + s1[0]);
1:f68f62f: 		System.out.println("  s2 = " + s2[0]);
1:f68f62f: 		System.out.println("  s3 = " + s3[0]);
1:f68f62f: 		System.out.println("  s4 = " + s4[0]);
1:f68f62f: 		System.out.println("  s5 = " + s5[0]);
1:f68f62f: 
1:f68f62f: 		a1[0] = 0;
1:f68f62f: 		a2[0] = 0;
1:f68f62f: 		a3[0] = 77;
1:f68f62f: 		a4[0] = 4;
1:f68f62f: 		a5[0] = 2003;
1:f68f62f: 
1:f68f62f: 		s1[0] = null;
1:f68f62f: 		s2[0] = null;
1:f68f62f: 		s3[0] = "cloudscape";
1:f68f62f: 		s4[0] = "jbms";
1:f68f62f: 		s5[0] = "IBM CS";
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	private static void test5116(Connection conn) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		System.out.println("==============================================");
1:f68f62f: 		System.out.println("TESTING FIX OF 5116 -- VAR BIT VARYING INPUT");
1:f68f62f: 		System.out.println("==============================================\n");
1:f68f62f: 
1:f68f62f: 		Statement stmt = conn.createStatement();
1:f68f62f: 		stmt.executeUpdate("CREATE TABLE ACTIVITY_INSTANCE_T (" +
1:f68f62f:     "AIID                               char(16) for bit data              NOT NULL ," +
1:f68f62f:     "KIND                               INTEGER                            NOT NULL ," +
1:f68f62f:     "PIID                               char(16) for bit data              NOT NULL ," +
1:f68f62f:     "PTID                               char(16) for bit data              NOT NULL ," +
1:f68f62f:     "ATID                               char(16) for bit data              NOT NULL ," +
1:f68f62f:     "RUN_MODE                           INTEGER                            NOT NULL ," +
1:f68f62f:     "FINISHED                           TIMESTAMP                                   ," +
1:f68f62f:     "ACTIVATED                          TIMESTAMP                                   ," +
1:f68f62f:     "STARTED                            TIMESTAMP                                   ," +
1:f68f62f:     "LAST_MODIFIED                      TIMESTAMP                                   ," +
1:f68f62f:     "LAST_STATE_CHANGE                  TIMESTAMP                                   ," +
1:f68f62f:     "STATE                              INTEGER                            NOT NULL ," +
1:f68f62f:     "TRANS_COND_VALUES                  VARCHAR(66) FOR BIT DATA           NOT NULL ," +
1:f68f62f:     "NUM_CONN_ACT_EVA                   INTEGER                            NOT NULL ," +
1:f68f62f:     "NUMBER_OF_ITERATIONS               INTEGER                            NOT NULL ," +
1:f68f62f:     "NUMBER_OF_RETRIES                  INTEGER                            NOT NULL ," +
1:f68f62f:     "HAS_CUSTOM_ATTRIBUTES              SMALLINT                           NOT NULL ," +
1:f68f62f:     "NON_BLOCK_PTID                     char(16) for bit data              NOT NULL ," +
1:f68f62f:     "NON_BLOCK_PIID                     char(16) for bit data              NOT NULL ," +
1:f68f62f:     "EXPIRES                            TIMESTAMP                                   ," +
1:f68f62f:     "TASK_ID                            VARCHAR(254)                                ," +
1:f68f62f:     "UNHANDLED_EXCEPTION                BLOB(3993600)                       ," +
1:f68f62f:     "SUB_PROCESS_PIID                   char(16) for bit data                                    ," +
1:f68f62f:     "OWNER                              VARCHAR(32)                                 ," +
1:f68f62f:     "USER_INPUT                         VARCHAR(130) FOR BIT DATA                   ," +
1:f68f62f:     "DESCRIPTION                        VARCHAR(254)                                ," +
1:f68f62f:     "VERSION_ID                         SMALLINT                           NOT NULL ," +
1:f68f62f:     "PRIMARY KEY ( AIID ) )");
1:f68f62f: 
1:f68f62f: 		stmt.execute("CREATE PROCEDURE doInsertion(IN P1 VARCHAR(2) FOR BIT DATA) " +
1:b9c171c: 						"EXTERNAL NAME '" + CLASS_NAME + "doInsertion'" +
1:f68f62f: 						" MODIFIES SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA");
1:f68f62f: 
1:f68f62f: 		CallableStatement cs = conn.prepareCall("call doInsertion (?)");
1:f68f62f: 		cs.setNull(1, java.sql.Types.VARBINARY);
1:f68f62f: 		cs.execute();
1:f68f62f:         byte [] b = new byte[2];
1:f68f62f:         b[0]=1; b[1] = 2;
1:f68f62f:         cs.setBytes( 1, b );
1:f68f62f: 		cs.execute();
1:f68f62f: 		cs.close();
1:f68f62f: 		stmt.executeUpdate("DROP PROCEDURE doInsertion");
1:f68f62f: 		stmt.close();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void doInsertion (byte[] p25) throws Throwable
1:f68f62f: 	{
1:f68f62f: 		Connection connNested = DriverManager.getConnection("jdbc:default:connection");
1:f68f62f: 		Statement stmt = connNested.createStatement();
1:f68f62f: 		stmt.executeUpdate("delete from ACTIVITY_INSTANCE_T");
1:f68f62f: 
1:f68f62f:         String strStmt = "INSERT INTO ACTIVITY_INSTANCE_T VALUES( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? )";
1:f68f62f:         PreparedStatement pstmt = connNested.prepareStatement( strStmt );
1:f68f62f: 
1:f68f62f:         byte [] b = new byte[2];
1:f68f62f:         b[0]=1;
1:f68f62f: 		byte[] b2 = new byte[1];
1:f68f62f: 		b2[0] = 0;
1:f68f62f: 
1:f68f62f:          pstmt.setBytes( 1, b ); //ids
1:f68f62f:          pstmt.setInt( 2, 0);
1:f68f62f:          pstmt.setBytes( 3, b );
1:f68f62f:          pstmt.setBytes( 4, b );
1:f68f62f:          pstmt.setBytes( 5, b );
1:f68f62f:          pstmt.setInt( 6, 0);
1:f68f62f:          pstmt.setNull( 7, java.sql.Types.TIMESTAMP);
1:f68f62f:          pstmt.setNull( 8, java.sql.Types.TIMESTAMP);
1:f68f62f:          pstmt.setNull( 9, java.sql.Types.TIMESTAMP);
1:f68f62f:          pstmt.setNull( 10, java.sql.Types.TIMESTAMP);
1:f68f62f:          pstmt.setNull( 11, java.sql.Types.TIMESTAMP);
1:f68f62f:          pstmt.setInt( 12, 0);
1:f68f62f:          pstmt.setBytes( 13, b );
1:f68f62f: 
1:f68f62f:          pstmt.setInt( 14, 0);
1:f68f62f:          pstmt.setInt( 15, 0);
1:f68f62f:          pstmt.setInt( 16, 0);
1:f68f62f:          pstmt.setBoolean( 17, false);
1:f68f62f:          pstmt.setBytes( 18, b );
1:f68f62f:          pstmt.setBytes( 19, b );
1:f68f62f:          pstmt.setNull( 20, java.sql.Types.TIMESTAMP);
1:f68f62f:          pstmt.setNull( 21, java.sql.Types.VARCHAR);
1:f68f62f:          pstmt.setNull( 22, java.sql.Types.BLOB );
1:f68f62f:          pstmt.setNull( 23, java.sql.Types.VARBINARY );
1:f68f62f:          pstmt.setNull( 24, java.sql.Types.VARCHAR);
1:f68f62f: 		if (p25 == null)
1:f68f62f:              pstmt.setNull( 25, java.sql.Types.VARBINARY);
1:f68f62f: 		else
1:f68f62f: 			 pstmt.setBytes(25, p25);
1:f68f62f:          pstmt.setNull( 26, java.sql.Types.VARCHAR);
1:f68f62f:          pstmt.setShort( 27, (short) 0);
1:f68f62f:          pstmt.executeUpdate();
1:f68f62f:          pstmt.close();
1:f68f62f: 
1:f68f62f:          pstmt = connNested.prepareStatement( "SELECT version_id, user_input FROM activity_instance_t");
1:f68f62f:          ResultSet resultSet = pstmt.executeQuery();
1:f68f62f:          System.out.println("Executed query");
1:f68f62f:          while( resultSet.next() )
1:f68f62f:          {
1:f68f62f:             System.out.println("i= " + resultSet.getInt(1) );
1:f68f62f:             byte [] userInput = resultSet.getBytes(2);
1:f68f62f:             if( userInput == null || resultSet.wasNull() )
1:f68f62f:             {
1:f68f62f: 				if( userInput == null)
1:f68f62f:                		System.out.println("UserInput = null");
1:f68f62f: 				if (resultSet.wasNull())
1:f68f62f:                		System.out.println("resultSet wasNull");
1:f68f62f:             }
1:f68f62f:             else
1:f68f62f:             {
1:f68f62f:                System.out.println("UserInput length  = " + userInput.length + " bytes");
1:f68f62f:                for( int i=0; i<userInput.length; i++ )
1:f68f62f:                {
1:f68f62f:                   System.out.println( i + ") = " + userInput[i] );
1:f68f62f:                }
1:f68f62f:             }
1:f68f62f:          }
1:f68f62f:          System.out.println("Close result set.");
1:f68f62f:          resultSet.close();
1:f68f62f:          pstmt.close();
1:f68f62f:          stmt.close();
1:f68f62f: 		 connNested.close();
1:f68f62f:    }
1:f68f62f: }
1:f68f62f: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1: 				cs.setObject(arg, true);
1: 				cs.setObject(arg, 6);
1: 				cs.setObject(arg, 66);
1: 				cs.setObject(arg, 666);
1: 				cs.setObject(arg, 666L);
1: 				cs.setObject(arg, 666f);
1: 				cs.setObject(arg, 666.0);
/////////////////////////////////////////////////////////////////////////
1: 		retval[0] = (setToNull.booleanValue()) ? null : 66;
/////////////////////////////////////////////////////////////////////////
1: 		outparam[0] = ((byte)(outparam[0] == null ? 33 : outparam[0].byteValue()*2));
/////////////////////////////////////////////////////////////////////////
1:       outparam[0] = (short) ((byte)(outparam[0] == null ? 33 : outparam[0].shortValue()*2));
/////////////////////////////////////////////////////////////////////////
1: 		outparam[0] = outparam[0] == null ? 33 : outparam[0].intValue()*2;
/////////////////////////////////////////////////////////////////////////
1:       outparam[0] = (long)(outparam[0] == null ? 33 : outparam[0].longValue()*2);
/////////////////////////////////////////////////////////////////////////
1:       outparam[0] = (double) (outparam[0] == null ? 33 : outparam[0].doubleValue()*2);
/////////////////////////////////////////////////////////////////////////
1:       outparam[0] = (float) (outparam[0] == null ? 33 : outparam[0].floatValue()*2);
/////////////////////////////////////////////////////////////////////////
1: 		outparam[0] = true;
/////////////////////////////////////////////////////////////////////////
1: 		return (byte)66;
/////////////////////////////////////////////////////////////////////////
1: 		return (short)666;
/////////////////////////////////////////////////////////////////////////
1: 		return 666;
/////////////////////////////////////////////////////////////////////////
1: 		return 666L;
/////////////////////////////////////////////////////////////////////////
1: 		return 666f;
/////////////////////////////////////////////////////////////////////////
1: 		return 666.0;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		Types.BOOLEAN,
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN:
commit:8d91915
/////////////////////////////////////////////////////////////////////////
0: 				BigDecimal bd = cs.getBigDecimal(arg);
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.outparams
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: import java.sql.*;
1: 
1: import org.apache.derby.tools.ij;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: import java.io.PrintStream;
1: import java.math.BigInteger;
1: import java.math.BigDecimal;
1: 
1: public class outparams
1: {
1:  
0: 	static final String outputMethods[] =
1: 	{
1: 		"takesNothing",
1: 
1: 		null, 
1: 	
1: 		null,
1: 		null,
1: 	
1: 		"takesShortPrimitive",
1: 		null,
1: 	
1: 		"takesIntegerPrimitive",
1: 		null,
1: 	
1: 		"takesLongPrimitive",
1: 		null,
1: 	
1: 		"takesFloatPrimitive",
1: 		null,
1: 	
1: 		"takesDoublePrimitive",
1: 		null,
1: 	
1: 		"takesBigDecimal",
1: 	
1: 		"takesByteArray",
1: 		
1: 		"takesString",
1: 		
1: 		"takesDate",
1: 		
1: 		"takesTimestamp",
1: 	
1: 		"takesTime",
1: 	
1: 		null
1: 	};
1: 
1: 	// parameter types for outputMethods.
1: 	private static final String[] outputProcParam =
1: 	{
1: 		null, // "takesNothing",
1: 
1: 		null, 
1: 	
1: 		null,
1: 		null,
1: 	
1: 		"SMALLINT", // "takesShortPrimitive",
1: 		null,
1: 	
1: 		"INT", // "takesIntegerPrimitive",
1: 		null,
1: 	
1: 		"BIGINT", // "takesLongPrimitive",
1: 		null,
1: 	
1: 		"REAL", // "takesFloatPrimitive",
1: 		null,
1: 	
1: 		"DOUBLE", // "takesDoublePrimitive",
1: 		null,
1: 	
1: 		"DECIMAL(10,4)", // "takesBigDecimal",
1: 	
1: 		"VARCHAR(40) FOR BIT DATA", // "takesByteArray",
1: 		
1: 		"VARCHAR(40)", // "takesString",
1: 		
1: 		"DATE", // "takesDate",
1: 		
1: 		"TIMESTAMP", // "takesTimestamp",
1: 	
1: 		"TIME", // "takesTime",
1: 	
1: 		null
1: 	};
1: 
1: 	
0: 	static final String returnMethods[] =
1: 	{
1: 		"returnsNothing",
1: 
1: 		null,
1: 		null,
1: 	
1: 		"returnsShortP",
1: 		null,
1: 	
1: 		"returnsIntegerP",
1: 		null,
1: 	
1: 		"returnsLongP",
1: 		null,
1: 	
1: 		"returnsFloatP",
1: 		null,
1: 	
1: 		"returnsDoubleP",
1: 		null,
1: 	
1: 		"returnsBigDecimal",
1: 	
1: 		"returnsByteArray",
1: 		
1: 		"returnsString",
1: 		
1: 		"returnsDate",
1: 		
1: 		"returnsTimestamp",
1: 	
1: 		"returnsTime",
1: 	
1: 		null
1: 	};
1: 
0: 	static final String[] returnMethodType =
1: 	{
1: 		null, // "returnsNothing",
1: 
1: 		null, // "returnsBytePrimitive",
1: 		null, // "returnsByte",
1: 	
1: 		"SMALLINT", // "returnsShortPrimitive",
1: 		null, // "returnsShort",
1: 	
1: 		"INT", // "returnsIntegerPrimitive",
1: 		null, // "returnsInteger",
1: 	
1: 		"BIGINT", // "returnsLongPrimitive",
1: 		null, // "returnsLong",
1: 	
1: 		"REAL", // "returnsFloatPrimitive",
1: 		null, // "returnsFloat",
1: 	
1: 		"DOUBLE", // "returnsDoublePrimitive",
1: 		null, // "returnsDouble",
1: 	
1: 		"DECIMAL(10,2)", // "returnsBigDecimal",
1: 	
1: 		"VARCHAR(40) FOR BIT DATA", // "returnsByteArray",
1: 		
1: 		"VARCHAR(40)", // "returnsString",
1: 		
1: 		"DATE", // "returnsDate",
1: 		
1: 		"TIMESTAMP", // "returnsTimestamp",
1: 	
1: 		"TIME", // "returnsTime",
1: 	
1: 		null, // "returnsBigInteger"
1: 	};
1: 	
1: 	static final int types[] =
1: 	{
1: 		Types.BIT,
0: 		JDBC30Translation.SQL_TYPES_BOOLEAN,
1: 		Types.TINYINT,
1: 		Types.SMALLINT,
1: 		Types.INTEGER,
1: 		Types.BIGINT,
1: 		Types.FLOAT,
1: 		Types.REAL,
1: 		Types.DOUBLE,
1: 		Types.NUMERIC,
1: 		Types.DECIMAL,
1: 		Types.CHAR,
1: 		Types.VARCHAR,
1: 		Types.LONGVARCHAR,
1: 		Types.DATE,
1: 		Types.TIME, 
1: 		Types.TIMESTAMP,
1: 		Types.BINARY,
1: 		Types.VARBINARY,
1: 		Types.LONGVARBINARY,
1: 		Types.OTHER
1: 	};
1: 	
1: 	static final String typeNames[] =
1: 	{
1: 		"BIT",
1: 		"BOOLEAN",
1: 		"TINYINT",
1: 		"SMALLINT",
1: 		"INTEGER",
1: 		"BIGINT",
1: 		"FLOAT",
1: 		"REAL",
1: 		"DOUBLE",
1: 		"NUMERIC",
1: 		"DECIMAL",
1: 		"CHAR",
1: 		"VARCHAR",
1: 		"LONGVARCHAR",
1: 		"DATE",
1: 		"TIME",
1: 		"TIMESTAMP",
1: 		"BINARY",
1: 		"VARBINARY",
1: 		"LONGVARBINARY",
1: 		"OTHER"
1: 	};
1: 
1: 	//public static Connection conn;
1: 
1: 	public static void main (String[] argv) throws Throwable
1: 	{
1:    		ij.getPropertyArg(argv); 
1:         Connection conn = ij.startJBMS();
1: 
1:         runTests( conn);
1:     }
1: 
1:     public static void runTests( Connection conn) throws Throwable
1:     {        
1: 		conn.setAutoCommit(false);	
1: 
1: 		testMisc(conn);
1: 		testNull(conn);
1: 		testUpdate(conn);
1: 		testEachOutputType(conn);
1: 		testReturnTypes(conn);
1: 		testOtherOutputType(conn);
1: 		testManyOut(conn);
1: 		test5116(conn);
1: 	}
1: 
1: 	private static void testMisc(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================");
1: 		System.out.println("TESTING BOUNDARY CONDITIONS");
1: 		System.out.println("==============================================\n");
1: 
1: 		Statement scp = conn.createStatement();
1: 
1: 		scp.execute("CREATE PROCEDURE takesString(OUT P1 VARCHAR(40), IN P2 INT) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.takesString'" +
1: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 		CallableStatement cs = conn.prepareCall("call takesString(?,?)");
1: 
1: 		// register a normal int as an output param, should fail
1: 		boolean failed = false;
1: 		try
1: 		{
1: 			cs.registerOutParameter(2, Types.INTEGER);
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			failed = true;
1: 			System.out.println("Expected exception "+se);
1: 		}
1: 		if (!failed)
1: 		{
1: 			System.out.println("registerOutParameter on non-output didn't fail");
1: 		}
1: 
1: 		// invalid param number
1: 		failed = false;
1: 		try
1: 		{
1: 			cs.registerOutParameter(9, Types.INTEGER);
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			failed = true;
1: 			System.out.println("Expected exception "+se);
1: 		}
1: 		if (!failed)
1: 		{
1: 			System.out.println("registerOutParameter on bad value didn't fail");
1: 		}
1: 
1: 		// invalid param number
1: 		failed = false;
1: 		try
1: 		{
1: 			cs.registerOutParameter(0, Types.INTEGER);
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			failed = true;
1: 			System.out.println("Expected exception "+se);
1: 		}
1: 		if (!failed)
1: 		{
1: 			System.out.println("registerOutParameter on bad value didn't fail");
1: 		}
1: 
1: 		// set before register, bad type, should fail as is output parameter.	
1: 		try
1: 		{
1: 			cs.setDouble(1, 1);
1: 			System.out.println("FAIL setDouble() on takesString() accepted");
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("Expected exception "+se);
1: 		}
1: 
1: 		// set before register, should fail as is output parameter.
1: 		try
1: 		{
1: 			cs.setString(1, "hello");
1: 			System.out.println("FAIL setString() on takesString() accepted");
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("Expected exception "+se);
1: 		}
1: 
1: 		cs.registerOutParameter(1, Types.CHAR);
1: 		cs.setInt(2, Types.INTEGER);
1: 		try
1: 		{
1: 			cs.execute();
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("cs.execute() got unexpected exception: "+se);
1: 		}
1: 
1: 		// shouldn't have to reregister the type, and shouldn't
1: 		// need to set the output parameters
1: 		cs.clearParameters();
1: 		cs.setInt(2, Types.INTEGER);
1: 		try
1: 		{
1: 			cs.execute();
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("cs.execute() got unexpected exception: "+se);
1: 		}
1: 		cs.close();
1: 		scp.execute("DROP PROCEDURE takesString");
1: 
0: 		scp.execute("CREATE FUNCTION returnsBigDecimal(P2 INT) RETURNS DECIMAL(10,2) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.returnsBigDecimal'" +
1: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 		// return output params -- cannot do set on return output param
0: 		cs = conn.prepareCall("? = call returnsBigDecimal(?)");
1: 		try
1: 		{
0: 			cs.setBigDecimal(1, new BigDecimal(1d));
0: 			System.out.println("ERROR: setBigDecimal() on return output parameter succeeded");
1: 		}
1: 		catch (SQLException se)
1: 		{
0: 			System.out.println("Expected exception on setBigDecimal() on a return output param: "+se);
1: 		}
1: 		cs.close();
0: 		scp.execute("DROP FUNCTION returnsBigDecimal");
1: 
1: 		// lets try ? = call syntax on a call that doesn't return anything
1: 		
1: 		scp.execute("CREATE PROCEDURE returnsNothing() " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.returnsNothing'" +
1: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 		try
1: 		{
1: 			cs = conn.prepareCall("? = call returnsNothing()");
1: 			System.out.println("ERROR: no exception on prepare of '? = call returnsNothing()");
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("Expected exception on prepare of '? = call returnsNothing()': "+se);
1: 		}
1: 		scp.execute("DROP PROCEDURE returnsNothing");
1: 	}
1: 
1: 	
1: 	private static void testNull(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================");
1: 		System.out.println("TESTING NULLS");
1: 		System.out.println("==============================================\n");
1: 		System.out.println("Test for bug 4317, passing null value for a parameter");
1: 
1: 		Statement scp = conn.createStatement();
1: 
1: 		scp.execute("CREATE PROCEDURE testNullBug4317(IN P1 VARCHAR(10)) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.testNullBug4317'" +
1: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 		CallableStatement cs0 = conn.prepareCall("call testNullBug4317(?)");
1: 		try
1: 		{
1: 			cs0.setString(1, null);		// passing in null
1: 			cs0.execute();
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("cs0.execute() got unexpected exception: "+se);
1: 		}
1: 
1: 		try
1: 		{
1: 			// BUG 5928 - setNull throws an exception - fixed.
1: 			cs0.setNull(1, java.sql.Types.VARCHAR);		// passing in null
1: 			cs0.execute();
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("cs0.execute() got unexpected exception: "+se);
1: 		}
1: 		cs0.close();
1: 		scp.execute("DROP PROCEDURE testNullBug4317");
1: 
1: 
1: 	}
1: 
1: 	// test: do we get an appropriate update count when using ?=call?
1: 	private static void testUpdate(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================");
1: 		System.out.println("TESTING UPDATE COUNT");
1: 		System.out.println("==============================================\n");
1: 
1: 		Statement scp = conn.createStatement();
1: 
1: 		scp.execute("CREATE FUNCTION returnsIntegerP(P1 INT) RETURNS INTEGER " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.returnsIntegerP'" +
1: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 
1: 		CallableStatement cs = conn.prepareCall("? = call returnsIntegerP(0)");
1: 		cs.registerOutParameter(1, Types.INTEGER);
1: 		try
1: 		{
1: 			int updCount = cs.executeUpdate();
1: 			System.out.println("executeUpdate on ? = call returnsIntegerP returned "+updCount);
1: 			System.out.println("getString(1) returned "+cs.getString(1));
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			System.out.println("cs.execute() got unexpected exception: "+se);
1: 		}
1: 
1: 		cs.close();
1: 		scp.execute("DROP FUNCTION returnsIntegerP");
1: 		scp.close();
1: 	}
1: 
1: 	// should do get setString() to use a string that is appropriate for
1: 	//	the target type
1: 	private static void testEachOutputType(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================");
1: 		System.out.println("TESTING NORMAL OUTPUT PARAMETERS");
1: 		System.out.println("==============================================\n");
1: 		CallableStatement cs = null;
1: 
1: 		for (int doSetObject = 0; doSetObject < 3; doSetObject++)
1: 		{
1: 			switch (doSetObject)
1: 			{
1: 				case 0:
1: 					System.out.println("...starting doing setXXX for each type xxx");
1: 					break;
1: 				case 1:
1: 					System.out.println("...now doing setObject on each type xxx");
1: 					break;
1: 				case 2:
1: 					System.out.println("...not doing any setXXX, just OUT parameters, not IN/OUT");
1: 					break;
1: 			}
1: 
1: 			for (int method = 0; method < outputMethods.length; method++)
1: 			{
1: 				String methodName = outputMethods[method];
1: 				if (methodName == null)
1: 					continue;
1: 
1: 				System.out.println("\n------------------------------------");
1: 
1: 				Statement scp = conn.createStatement();
1: 				String str;
1: 				if (methodName.indexOf("Nothing") == -1)
1: 				{
1: 
1: 					scp.execute("CREATE PROCEDURE " + methodName + "(INOUT P1 " + outputProcParam[method] + ", IN P2 INT) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
1: 						"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 					if (method%2 == 0)
1: 						str = "call "+methodName+"(?,?)";
1: 					else
1: 						str = "{call "+methodName+"(?,?)}";
1: 				}
1: 				else
1: 				{
1: 					scp.execute("CREATE PROCEDURE " + methodName + "() " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
1: 						"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 					str = "{call "+methodName+"()}";
1: 				}
1: 
1: 
1: 	
1: 				System.out.println(str);
1: 				try 
1: 				{
1: 					cs = conn.prepareCall(str);
1: 				}
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("ERROR: unexpected exception "+se);
1: 					throw se;
1: 				}
1: 	
1: 				for (int type = 0; type < types.length; type++)
1: 				{
1: 					cs.clearParameters();
1: 					System.out.println();
1: 					try
1: 					{
1: 						System.out.println("\n\tcs.registerOutParameter(1, "+typeNames[type]+")");
1: 						cs.registerOutParameter(1, types[type]);
1: 					} 
1: 					catch (SQLException se)
1: 					{
1: 						System.out.println("\tException "+se);
1: 						continue;
1: 					}
1: 	
1: 					StringBuffer buf = new StringBuffer();
1: 					try
1: 					{
1: 						if (doSetObject == 0) 
1: 						{
1: 							callSetMethod(cs, 1, types[type], buf);
1: 						}
1: 						else if (doSetObject == 1)
1: 						{
1: 							callSetObject(cs, 1, types[type], buf);
1: 						}
1: 						else
1: 						{
1: 							// only try this once
1: 							type = types.length-1;
1: 							buf.append("...no setXXX(1) at all");
1: 						}
1: 					}
1: 					catch (SQLException se)
1: 					{
1: 						System.out.println("\t"+buf.toString());
1: 						System.out.println("\tException "+se);
1: 						continue;
1: 					}
1: 					System.out.println("\t"+buf.toString());
1: 					cs.setInt(2, types[type]);
1: 	
1: 					try
1: 					{
1: 						System.out.println("\tcs.execute()");
1: 						boolean hasResultSet = cs.execute();
1: 						if (hasResultSet)
1: 							System.out.println("testEachOutputType HAS RESULT SET cs.execute() returned true");
1: 						}
1: 					catch (SQLException se)
1: 					{
1: 						System.out.println("\tException "+se);
1: 						continue;
1: 					}
1: 					for (int getType = 0; getType < types.length; getType++)
1: 					{
1: 						StringBuffer getbuf = new StringBuffer();
1: 						try
1: 						{
0: 							callGetMethod(cs, 1, types[getType], getbuf);
1: 						}
1: 						catch (SQLException se)
1: 						{
1: 							getbuf.append(se);
1: 						}
1: 						System.out.println("\t\t\t"+getbuf.toString());
1: 					}
1: 	
1: 				}
1: 
1: 				cs.close();
1: 
1: 				scp.execute("DROP PROCEDURE " + methodName);
1: 				scp.close();
1: 			}
1: 		}
1: 
1: 		System.out.println("------------------------------------\n");
1: 
1: 	}
1: 
1: 	// test that everything works ok when we regsiter the param as type OTHER.
1: 	// should be able to get/setXXX of the appropriate type
1: 	private static void testOtherOutputType(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================");
1: 		System.out.println("TESTING OUTPUT PARAMETERS WITH register(OTHER)");
1: 		System.out.println("==============================================\n");
1: 		CallableStatement cs = null;
1: 
1: 		for (int method = 0; method < outputMethods.length; method++)
1: 		{
1: 			String methodName = outputMethods[method];
1: 			if (methodName == null)
1: 				continue;
1: 			System.out.println("\n------------------------------------");
1: 
1: 
1: 			Statement scp = conn.createStatement();
1: 			String str;
1: 			if (methodName.indexOf("Nothing") == -1)
1: 			{
1: 
1: 				scp.execute("CREATE PROCEDURE " + methodName + "(INOUT P1 " + outputProcParam[method] + ", IN P2 INT) " +
0: 					"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
1: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 				if (method%2 == 0)
1: 					str = "call "+methodName+"(?,?)";
1: 				else
1: 					str = "{call "+methodName+"(?,?)}";
1: 			}
1: 			else
1: 			{
1: 				scp.execute("CREATE PROCEDURE " + methodName + "() " +
0: 					"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
1: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 				str = "{call "+methodName+"()}";
1: 			}
1: 
1: 			System.out.println(str);
1: 			try 
1: 			{
1: 				cs = conn.prepareCall(str);
1: 			}
1: 			catch (SQLException se)
1: 			{
1: 				System.out.println("ERROR: unexpected exception "+se);
1: 				throw se;
1: 			}
1: 	
1: 			for (int type = 0; type < types.length; type++)
1: 			{
1: 				cs.clearParameters();
1: 				System.out.println();
1: 				try
1: 				{
1: 					System.out.println("\n\tcs.registerOutParameter(1, Types.OTHER)");
1: 					cs.registerOutParameter(1, Types.OTHER);
1: 				} 
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("\tException "+se);
1: 					continue;
1: 				}
1: 
1: 				StringBuffer buf = new StringBuffer();
1: 				try
1: 				{
1: 					callSetMethod(cs, 1, types[type], buf);
1: 				}
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("\t"+buf.toString());
1: 					System.out.println("\tException "+se);
1: 					continue;
1: 				}
1: 				System.out.println("\t"+buf.toString());
1: 				cs.setInt(2, types[type]);
1: 
1: 				try
1: 				{
1: 					System.out.println("\tcs.execute()");
1: 					cs.execute();
1: 				}
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("\tException "+se);
1: 					continue;
1: 				}
1: 				for (int getType = 0; getType < types.length; getType++)
1: 				{
1: 					StringBuffer getbuf = new StringBuffer();
1: 					try
1: 					{
0: 						callGetMethod(cs, 1, types[getType], getbuf);
1: 					}
1: 					catch (SQLException se)
1: 					{
1: 						getbuf.append(se);
1: 					}
1: 					System.out.println("\t\t\t"+getbuf.toString());
1: 				}
1: 
1: 			}
1: 
1: 			cs.close();
1: 
1: 			scp.execute("DROP PROCEDURE " + methodName);
1: 			scp.close();
1: 		}
1: 
1: 		System.out.println("------------------------------------\n");
1: 	}
1: 
1: 	private static void testReturnTypes(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================\n");
1: 		System.out.println("TESTING RETURN OUTPUT PARAMETERS");
1: 		System.out.println("==============================================\n");
1: 		CallableStatement cs = null;
1: 		for (int method = 0; method < returnMethods.length; method++)
1: 		{
1: 			String methodName = returnMethods[method];
1: 			if (methodName == null)
1: 				continue;
1: 
1: 			Statement scf = conn.createStatement();
1: 			String str;
1: 			String dropRoutine;
1: 			if (methodName.indexOf("Nothing") != -1)
1: 			{
1: 
1: 				scf.execute("CREATE PROCEDURE " + methodName + "()" +
0: 					" EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
1: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 				dropRoutine = "DROP PROCEDURE " + methodName;
1: 
1: 				str = "{call "+returnMethods[method]+"()}";
1: 			}
1: 			else
1: 			{
1: 
1: 				scf.execute("CREATE FUNCTION " + methodName + "(P1 INT) RETURNS " + returnMethodType[method] +
0: 					" EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
1: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 				dropRoutine = "DROP FUNCTION " + methodName;
1: 
1: 				str = "{? = call "+returnMethods[method]+"(?)}";
1: 			}
1: 
1: 
1: 				
1: 			System.out.println("\n------------------------------------");
1: 				
1: 
1: 			System.out.println(str);
1: 			try 
1: 			{
1: 				cs = conn.prepareCall(str);
1: 			}
1: 			catch (SQLException se)
1: 			{
1: 				System.out.println("ERROR: unexpected exception "+se);
1: 				throw se;
1: 			}
1: 
1: 			for (int type = 0; type < types.length; type++)
1: 			{
1: 				cs.clearParameters();
1: 				System.out.println();
1: 				try
1: 				{
1: 					System.out.println("\n\tcs.registerOutParameter(1, "+typeNames[type]+")");
1: 					cs.registerOutParameter(1, types[type]);
1: 				} 
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("\tException "+se);
1: 					continue;
1: 				}
1: 				try
1: 				{
1: 					cs.setInt(2, types[type]);
1: 				}
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("\tUnexpected exception on cs.setInt(2, "+types[type]+"): "+se);
1: 					continue;
1: 				}
1: 
1: 				try
1: 				{
1: 					System.out.println("\tcs.execute()");
1: 					boolean hasResultSet = cs.execute();
1: 					if (hasResultSet)
1: 						System.out.println("testReturnTypes HAS RESULT SET cs.execute() returned true");
1: 
1: 				}
1: 				catch (SQLException se)
1: 				{
1: 					System.out.println("\tException "+se);
1: 					continue;
1: 				}
1: 				for (int getType = 0; getType < types.length; getType++)
1: 				{
1: 					StringBuffer getbuf = new StringBuffer();
1: 					try
1: 					{
0: 						callGetMethod(cs, 1, types[getType], getbuf);
1: 					}
1: 					catch (SQLException se)
1: 					{
1: 						getbuf.append(se);
1: 					}
1: 					System.out.println("\t\t\t"+getbuf.toString());
1: 				}
1: 
1: 			}
1: 
1: 			cs.close();
1: 			scf.execute(dropRoutine);
1: 			scf.close();
1: 		}
1: 
1: 		System.out.println("------------------------------------\n");
1: 
1: 	}
1: 
1: 	private static void callSetObject(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
1: 	{
1: 
1: 		switch (type)	
1: 		{
1: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
1: 				strbuf.append("setObject("+arg+", true)");
0: 				cs.setObject(arg, new Boolean(true));
1: 				break;
1: 
1: 			case Types.TINYINT:
1: 				strbuf.append("setObject("+arg+", 6)");
0: 				cs.setObject(arg, new Integer((byte)6));
1: 				break;
1: 
1: 			case Types.SMALLINT:
1: 				strbuf.append("setObject("+arg+", 66)");
0: 				cs.setObject(arg, new Integer((short)66));
1: 				break;
1: 
1: 			case Types.INTEGER:
1: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Integer(666));
1: 				break;
1: 
1: 			case Types.BIGINT:
1: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Long(666));
1: 				break;
1: 
1: 			case Types.FLOAT:
1: 			case Types.REAL:
1: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Float(666));
1: 				break;
1: 
1: 			case Types.DOUBLE:
1: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Double(666));
1: 				break;
1: 
1: 			case Types.DECIMAL:
1: 			case Types.NUMERIC:
1: 				strbuf.append("setObject("+arg+", 666.666)");
0: 				BigDecimal bd = new BigDecimal("666.666");
0: 				cs.setObject(arg, bd);
1: 				break;
1: 
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 				strbuf.append("setObject("+arg+", \"Set via setString()\")");
1: 				cs.setObject(arg, "Set via setString()");
1: 				break;
1: 
1: 			case Types.BINARY:
1: 			case Types.VARBINARY:
1: 			case Types.LONGVARBINARY:
1: 				strbuf.append("setObject("+arg+", byte[])");
1: 				byte[] myarray = new byte[16];
1: 				myarray[0] = (byte)255;
1: 				cs.setObject(arg, myarray);
1: 				break;
1: 
1: 			case Types.DATE:
1: 				strbuf.append("setObject("+arg+", Date.valueOf(1999-09-09))");
1: 				cs.setObject(arg, Date.valueOf("1999-09-09"));
1: 				break;
1: 
1: 			case Types.TIME:
1: 				strbuf.append("setObject("+arg+", Time.valueOf(09:09:09))");
1: 				cs.setObject(arg, Time.valueOf("09:09:09"));
1: 				break;
1: 
1: 			case Types.TIMESTAMP:
1: 				strbuf.append("setObject("+arg+", Timestamp.valueOf(1999-09-09 09:09:09.999))");
1: 				cs.setObject(arg, Timestamp.valueOf("1999-09-09 09:09:09.999"));
1: 				break;
1: 
1: 			case Types.OTHER:
1: 				strbuf.append("setObject("+arg+", new BigInteger(666))");
1: 				cs.setObject(arg, new BigInteger("666"));
1: 				break;
1: 
1: 			default:
1: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1: 		}	
1: 	}
1: 	private static void callSetMethod(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
1: 	{
1: 		switch (type)	
1: 		{
1: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
1: 				strbuf.append("setBoolean("+arg+", true)");
1: 				cs.setBoolean(arg, true);
1: 				break;
1: 
1: 			case Types.TINYINT:
1: 				strbuf.append("setByte("+arg+", 6)");
1: 				cs.setByte(arg, (byte)6);
1: 				break;
1: 
1: 			case Types.SMALLINT:
1: 				strbuf.append("setShort("+arg+", 66)");
1: 				cs.setShort(arg, (short)66);
1: 				break;
1: 
1: 			case Types.INTEGER:
1: 				strbuf.append("setInt("+arg+", 666)");
1: 				cs.setInt(arg, 666);
1: 				break;
1: 
1: 			case Types.BIGINT:
1: 				strbuf.append("setLong("+arg+", 666)");
1: 				cs.setLong(arg, 666);
1: 				break;
1: 
1: 			case Types.FLOAT:
1: 			case Types.REAL:
1: 				strbuf.append("setFLoat("+arg+", 666)");
1: 				cs.setFloat(arg, 666);
1: 				break;
1: 
1: 			case Types.DOUBLE:
1: 				strbuf.append("setDouble("+arg+", 666)");
1: 				cs.setDouble(arg, 666);
1: 				break;
1: 
1: 			case Types.DECIMAL:
1: 			case Types.NUMERIC:
1: 				strbuf.append("setBigDecimal("+arg+", 666.666)");
0: 				BigDecimal bd = new BigDecimal("666.666");
0: 				cs.setBigDecimal(arg, bd);
1: 				break;
1: 
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 				strbuf.append("setString("+arg+", \"Set via setString()\")");
1: 				cs.setString(arg, "Set via setString()");
1: 				break;
1: 
1: 			case Types.BINARY:
1: 			case Types.VARBINARY:
1: 			case Types.LONGVARBINARY:
1: 				strbuf.append("setBytes("+arg+", byte[])");
1: 				byte[] myarray = new byte[16];
1: 				myarray[0] = (byte)255;
1: 				cs.setBytes(arg, myarray);
1: 				break;
1: 
1: 			case Types.DATE:
1: 				strbuf.append("setDate("+arg+", Date.valueOf(1999-09-09))");
1: 				cs.setDate(arg, Date.valueOf("1999-09-09"));
1: 				break;
1: 
1: 			case Types.TIME:
1: 				strbuf.append("setTime("+arg+", Time.valueOf(09:09:09))");
1: 				cs.setTime(arg, Time.valueOf("09:09:09"));
1: 				break;
1: 
1: 			case Types.TIMESTAMP:
1: 				strbuf.append("setTimestamp("+arg+", Timestamp.valueOf(1999-09-09 09:09:09.999))");
1: 				cs.setTimestamp(arg, Timestamp.valueOf("1999-09-09 09:09:09.999"));
1: 				break;
1: 
1: 			case Types.OTHER:
1: 				strbuf.append("setObject("+arg+", new BigInteger(666))");
1: 				cs.setObject(arg, new BigInteger("666"));
1: 				break;
1: 
1: 			default:
1: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1: 		}	
1: 	}
1: 
0: 	private static void callGetMethod(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
1: 	{
1: 		switch (type)	
1: 		{
1: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
1: 				strbuf.append("getBoolean("+arg+") = ");
1: 				strbuf.append(cs.getBoolean(arg));
1: 				break;
1: 
1: 			case Types.TINYINT:
1: 				strbuf.append("getByte("+arg+") = ");
1: 				strbuf.append(Byte.toString(cs.getByte(arg)));
1: 				break;
1: 
1: 			case Types.SMALLINT:
1: 				strbuf.append("getShort("+arg+") = ");
1: 				strbuf.append(Short.toString(cs.getShort(arg)));
1: 				break;
1: 
1: 			case Types.INTEGER:
1: 				strbuf.append("getInt("+arg+") = ");
1: 				strbuf.append(Integer.toString(cs.getInt(arg)));
1: 				break;
1: 
1: 			case Types.BIGINT:
1: 				strbuf.append("getLong("+arg+") = ");
1: 				strbuf.append(Long.toString(cs.getLong(arg)));
1: 				break;
1: 
1: 			case Types.FLOAT:
1: 			case Types.REAL:
1: 				strbuf.append("getFloat("+arg+") = ");
1: 				strbuf.append(Float.toString(cs.getFloat(arg)));
1: 				break;
1: 
1: 			case Types.DOUBLE:
1: 				strbuf.append("getDouble("+arg+") = ");
1: 				strbuf.append(Double.toString(cs.getDouble(arg)));
1: 				break;
1: 
1: 			case Types.DECIMAL:
1: 			case Types.NUMERIC:
1: 				strbuf.append("getBigDecimal("+arg+") = ");
0: 				BigDecimal bd = cs.getBigDecimal(arg, 2);
0: 				strbuf.append(bd == null ? "null" : bd.toString());
1: 				break;
1: 
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 				strbuf.append("getString("+arg+") = ");
1: 				String s = cs.getString(arg);
1: 				if (s.startsWith("[B@"))
1: 					s = "byte[] reference";
1: 				strbuf.append(s);
1: 				break;
1: 
1: 			case Types.BINARY:
1: 			case Types.VARBINARY:
1: 			case Types.LONGVARBINARY:
1: 				strbuf.append("getBytes("+arg+") = ");
1: 				byteArrayToString(cs.getBytes(arg), strbuf);
1: 				break;
1: 
1: 			case Types.DATE:
1: 				strbuf.append("getDate("+arg+") = ");
1: 				Date date = cs.getDate(arg);
1: 				strbuf.append(date == null ? "null" : date.toString());
1: 				break;
1: 
1: 			case Types.TIME:
1: 				strbuf.append("getTime("+arg+") = ");
1: 				Time time = cs.getTime(arg);
1: 				strbuf.append(time == null ? "null" : time.toString());
1: 				break;
1: 
1: 			case Types.TIMESTAMP:
1: 				strbuf.append("getTimestamp("+arg+") = ");
1: 				Timestamp timestamp = cs.getTimestamp(arg);
1: 				strbuf.append(timestamp == null ? "null" : timestamp.toString());
1: 				break;
1: 
1: 			case Types.OTHER:
1: 				strbuf.append("getObject("+arg+") = ");
1: 				Object o = cs.getObject(arg);
1: 				if (o == null)
1: 				{
1: 					strbuf.append("null");
1: 				}
1: 				else if (o instanceof byte[])
1: 				{
1: 					byteArrayToString((byte[])o, strbuf);
1: 				}
1: 				else
1: 				{
1: 					strbuf.append(o.toString());
1: 				}
1: 
1: 				break;
1: 
1: 			default:
1: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1: 		}	
1: 	}
1: 
1: 	static private void byteArrayToString(byte[] barray, StringBuffer strbuf)
1: 	{
1: 		if (barray == null)
1: 		{
1: 			strbuf.append("null");
1: 		}
1: 		else
1: 		{
1: 			for (int i = 0; i<barray.length; i++)
1: 			{
1: 				strbuf.append(barray[i]);
1: 			}
1: 		}
1: 	}
1: 
1: 	private static String getStringOfType(int type) throws Throwable
1: 	{
1: 		switch (type)
1: 		{
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 				return "I am a string";
1: 
1: 			case Types.TINYINT:
1: 			case Types.SMALLINT:
1: 			case Types.INTEGER:
1: 			case Types.BIGINT:
1: 			case Types.OTHER:		// other is bigInt
1: 				return "3";
1: 
1: 			case Types.FLOAT:
1: 			case Types.REAL:
1: 			case Types.DECIMAL:
1: 			case Types.NUMERIC:
1: 				return  "3.33";
1: 
1: 			case Types.DATE:		
1: 				return "1933-03-03";
1: 
1: 			case Types.TIME:		
1: 				return "03:03:03";
1: 
1: 			case Types.TIMESTAMP:		
1: 				return "1933-03-03 03:03:03.333";
1: 
1: 			case Types.BINARY:		
1: 			case Types.VARBINARY:		
1: 			case Types.LONGVARBINARY:
1: 				return "00680065006c006c006f";
1: 
1: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
1: 				return "true";
1: 
1: 			default:
1: 				throw new Throwable("bad type "+type);
1: 		}	
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////
1: 	//	
1: 	// OUTPUT PARAMETER METHODS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 	public static void testNull(Boolean passedInNull, Boolean setToNull, Integer[] retval) throws Throwable
1: 	{
1: 		if (passedInNull.booleanValue())
1: 		{
1: 			if (retval[0] != null)
1: 			{
1: 				throw new Throwable("testNull() got a non-null param when it should have been null");
1: 			}
1: 		}
1: 
0: 		retval[0] = (setToNull.booleanValue()) ? null : new Integer((short)66);
1: 	}
1: 
1: 	public static void testNullBug4317(String passedInNull) throws Throwable
1: 	{
1: 	}
1: 
1: 	public static void takesNothing()
1: 	{
1: 	}
1: 	public static void takesBytePrimitive(byte[] outparam, int type)
1: 	{
1: 		outparam[0]+=outparam[0];
1: 	}
1: 	public static void takesByte(Byte[] outparam, int type)
1: 	{
0: 		outparam[0] = new Byte((byte)(outparam[0] == null ? 33 : outparam[0].byteValue()*2));
1: 	}
1: 
1: 	public static void takesShortPrimitive(short[] outparam, int type)
1: 	{
1: 		outparam[0]+=outparam[0];
1: 	}
1: 	public static void takesShort(Short[] outparam, int type)
1: 	{
0: 		outparam[0] = new Short((byte)(outparam[0] == null ? 33 : outparam[0].shortValue()*2));
1: 	}
1: 
1: 	public static void takesIntegerPrimitive(int[] outparam, int type)
1: 	{
1: 		outparam[0]+=outparam[0];
1: 	}
1: 	public static void takesInteger(Integer[] outparam, int type)
1: 	{
0: 		outparam[0] = new Integer(outparam[0] == null ? 33 : outparam[0].intValue()*2);
1: 	}
1: 
1: 	public static void takesLongPrimitive(long[] outparam, int type)
1: 	{
1: 		outparam[0]+=outparam[0];
1: 	}
1: 	public static void takesLong(Long[] outparam, int type)
1: 	{
0: 		outparam[0] = new Long(outparam[0] == null ? 33 : outparam[0].longValue()*2);
1: 	}
1: 
1: 	public static void takesDoublePrimitive(double[] outparam, int type)
1: 	{
1: 		outparam[0]+=outparam[0];
1: 	}
1: 	public static void takesDouble(Double[] outparam, int type)
1: 	{
0: 		outparam[0] = new Double(outparam[0] == null ? 33 : outparam[0].doubleValue()*2);
1: 	}
1: 
1: 	public static void takesFloatPrimitive(float[] outparam, int type)
1: 	{
1: 		outparam[0]+=outparam[0];
1: 	}
1: 	public static void takesFloat(Float[] outparam, int type)
1: 	{
0: 		outparam[0] = new Float(outparam[0] == null ? 33 : outparam[0].floatValue()*2);
1: 	}
1: 
1: 	public static void takesBooleanPrimitive(boolean[] outparam, int type)
1: 	{
1: 		outparam[0] = true;
1: 	}
1: 	public static void takesBoolean(Boolean[] outparam, int type)
1: 	{
0: 		outparam[0] = new Boolean(true);
1: 	}
1: 
0: 	public static void takesBigDecimal(BigDecimal[] outparam, int type)
1: 	{
0: 		outparam[0] = (outparam[0] == null ? new BigDecimal("33") : outparam[0].add(outparam[0]));
0: 		outparam[0].setScale(4, BigDecimal.ROUND_DOWN);
1: 	}
1: 
1: 	public static void takesByteArray(byte[][] outparam, int type)
1: 	{
1: 		byte[] myarray = new byte[16];
1: 		myarray[0] = (byte)255;
1: 		outparam[0] = myarray;
1: 	}
1: 
1: 	public static void takesDate(Date[] outparam, int type)
1: 	{
1: 		outparam[0] = Date.valueOf("1966-06-06");
1: 	}
1: 
1: 	public static void takesTime(Time[] outparam, int type)
1: 	{
1: 		outparam[0] = Time.valueOf("06:06:06");
1: 	}
1: 
1: 	public static void takesTimestamp(Timestamp[] outparam, int type)
1: 	{
1: 		outparam[0] = Timestamp.valueOf("1966-06-06 06:06:06.666");
1: 	}
1: 
1: 	public static void takesString(String[] outparam, int type) throws Throwable
1: 	{
1: 		outparam[0] = getStringOfType(type);
1: 	}
1: 
1: 	public static void takesBigInteger(BigInteger[] outparam, int type)
1: 	{
1: 		outparam[0] = (outparam[0] == null ? new BigInteger("33") : outparam[0].add(outparam[0]));
1: 	}
1: 	
1: 	
1: 	/////////////////////////////////////////////////////////////
1: 	//	
1: 	// RETURN PARAMETER METHODS
1: 	//
1: 	/////////////////////////////////////////////////////////////
1: 	public static void returnsNothing()
1: 	{
1: 	}
1: 
1: 	public static byte returnsByteP(int type)
1: 	{
1: 		return 66;
1: 	}
1: 	public static Byte returnsByte(int type)
1: 	{
0: 		return new Byte((byte)66);
1: 	}
1: 
1: 	public static short returnsShortP(int type)
1: 	{
1: 		return 666;
1: 	}
1: 	public static Short returnsShort(int type)
1: 	{
0: 		return new Short((short)666);
1: 	}
1: 
1: 	public static int returnsIntegerP(int type)
1: 	{
1: 		return 666;
1: 	}
1: 	public static Integer returnsInteger(int type)
1: 	{
0: 		return new Integer(666);
1: 	}
1: 
1: 	public static long returnsLongP(int type)
1: 	{
1: 		return 666;
1: 	}
1: 	public static Long returnsLong(int type)
1: 	{
0: 		return new Long(666);
1: 	}
1: 
1: 	public static float returnsFloatP(int type)
1: 	{
1: 		return 666;
1: 	}
1: 	public static Float returnsFloat(int type)
1: 	{
0: 		return new Float(666);
1: 	}
1: 
1: 	public static double returnsDoubleP(int type)
1: 	{
1: 		return 666;
1: 	}
1: 	public static Double returnsDouble(int type)
1: 	{
0: 		return new Double(666);
1: 	}
1: 
1: 
0: 	public static BigDecimal returnsBigDecimal(int type)
1: 	{
0: 		return new BigDecimal(666d);
1: 	}
1: 
1: 	public static byte[] returnsByteArray(int type)
1: 	{
1: 		byte[] myarray = new byte[16];
1: 		myarray[0] = (byte)255;
1: 		return myarray;
1: 	}
1: 
1: 	public static String returnsString(int type) throws Throwable
1: 	{
1: 		return getStringOfType(type);
1: 	}
1: 
1: 	public static Date returnsDate(int type)
1: 	{
1: 		return Date.valueOf("1966-06-06");
1: 	}
1: 
1: 	public static Time returnsTime(int type)
1: 	{
1: 		return Time.valueOf("06:06:06");
1: 	}
1: 
1: 	public static Timestamp returnsTimestamp(int type)
1: 	{
1: 		return Timestamp.valueOf("1966-06-06 06:06:06.666");
1: 	}
1: 
1: 	public static BigInteger returnsBigInteger(int type)
1: 	{
1: 		return new BigInteger("666");
1: 	}
1: 
1: 
1: 	// these come from the performance test JDBC.Parameters that was failing
1: 	private static void testManyOut(Connection conn) throws SQLException {
1: 
1: 		System.out.println("start testManyOut");
1: 
1: 		Statement scp = conn.createStatement();
1: 
1: 		scp.execute("CREATE PROCEDURE OP_OUT " +
1: 			"(OUT I1 INT, OUT I2 INT, OUT I3 INT, OUT I4 INT, OUT I5 INT, "+
1: 			"OUT V1 VARCHAR(40), OUT V2 VARCHAR(40), OUT V3 VARCHAR(40), OUT V4 VARCHAR(40), OUT V5 VARCHAR(40)) "+
1: 
0: 			"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 		scp.execute("CREATE PROCEDURE OP_INOUT " +
1: 			"(INOUT I1 INT, INOUT I2 INT, INOUT I3 INT, INOUT I4 INT, INOUT I5 INT, " +
1: 			"INOUT V1 VARCHAR(40), INOUT V2 VARCHAR(40), INOUT V3 VARCHAR(40), INOUT V4 VARCHAR(40), INOUT V5 VARCHAR(40)) " +
1: 
0: 			"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 		CallableStatement csOut_cs = conn.prepareCall("CALL OP_OUT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1: 		CallableStatement csInOut_cs = conn.prepareCall("CALL OP_INOUT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1: 
1: 		System.out.println("Ten OUT parameters");
1: 
1: 		executeOutput(csOut_cs);
1: 		executeOutput(csOut_cs);
1: 
1: 		csOut_cs.close();
1: 
1: 		System.out.println("Ten INOUT parameters");
1: 
1: 
1: 		setupInput(csInOut_cs);
1: 		executeOutput(csInOut_cs);
1: 
1: 		setupInput(csInOut_cs);
1: 		executeOutput(csInOut_cs);
1: 
1: 		csInOut_cs.close();
1: 
1: 		scp.execute("DROP PROCEDURE OP_OUT");
1: 		scp.execute("DROP PROCEDURE OP_INOUT");
1: 		scp.close();
1: 
1: 
1: 		System.out.println("end testManyOut");
1: 
1: 
1: 	}
1: 
1: 
1: 	private static void setupInput(PreparedStatement ps) throws SQLException {
1: 
1: 		ps.setInt(1, 0);
1: 		ps.setInt(2, 0);
1: 		ps.setInt(3, 99);
1: 		ps.setInt(4, 103);
1: 		ps.setInt(5, 1456);
1: 
1: 		ps.setNull(6, Types.CHAR);
1: 		ps.setString(7, null);
1: 		ps.setString(8, "hello");
1: 		ps.setString(9, "goodbye");
1: 		ps.setString(10, "welcome");
1: 	}
1: 	private static void executeOutput(CallableStatement cs) throws SQLException {
1: 
1: 		for (int p = 1; p <= 5; p++)
1: 			cs.registerOutParameter(p, Types.INTEGER);
1: 
1: 		for (int p = 6; p <= 10; p++)
1: 			cs.registerOutParameter(p, Types.VARCHAR);
1: 
1: 		cs.execute();
1: 
1: 		for (int p = 1; p <= 5; p++) {
1: 			System.out.println("  " + p + " = " + cs.getInt(p) + " was null " + cs.wasNull());
1: 	
1: 		}
1: 		for (int p = 6; p <= 10; p++) {
1: 			System.out.println("  " + p + " = " + cs.getString(p) + " was null " + cs.wasNull());
1: 		}
1: 	}
1: 
1: 
1: 	public static void output(int[] a1, int[] a2, int[] a3, int[] a4, int[] a5,
1: 		String[] s1, String[] s2, String[] s3, String[] s4, String[] s5) {
1: 
1: 		System.out.println("  a1 = " + a1[0]);
1: 		System.out.println("  a2 = " + a2[0]);
1: 		System.out.println("  a3 = " + a3[0]);
1: 		System.out.println("  a4 = " + a4[0]);
1: 		System.out.println("  a5 = " + a5[0]);
1: 
1: 		System.out.println("  s1 = " + s1[0]);
1: 		System.out.println("  s2 = " + s2[0]);
1: 		System.out.println("  s3 = " + s3[0]);
1: 		System.out.println("  s4 = " + s4[0]);
1: 		System.out.println("  s5 = " + s5[0]);
1: 
1: 		a1[0] = 0;
1: 		a2[0] = 0;
1: 		a3[0] = 77;
1: 		a4[0] = 4;
1: 		a5[0] = 2003;
1: 
1: 		s1[0] = null;
1: 		s2[0] = null;
1: 		s3[0] = "cloudscape";
1: 		s4[0] = "jbms";
1: 		s5[0] = "IBM CS";
1: 	}
1: 
1: 	private static void test5116(Connection conn) throws Throwable
1: 	{
1: 		System.out.println("==============================================");
1: 		System.out.println("TESTING FIX OF 5116 -- VAR BIT VARYING INPUT");
1: 		System.out.println("==============================================\n");
1: 
1: 		Statement stmt = conn.createStatement();
1: 		stmt.executeUpdate("CREATE TABLE ACTIVITY_INSTANCE_T (" +
1:     "AIID                               char(16) for bit data              NOT NULL ," +
1:     "KIND                               INTEGER                            NOT NULL ," +
1:     "PIID                               char(16) for bit data              NOT NULL ," +
1:     "PTID                               char(16) for bit data              NOT NULL ," +
1:     "ATID                               char(16) for bit data              NOT NULL ," +
1:     "RUN_MODE                           INTEGER                            NOT NULL ," +
1:     "FINISHED                           TIMESTAMP                                   ," +
1:     "ACTIVATED                          TIMESTAMP                                   ," +
1:     "STARTED                            TIMESTAMP                                   ," +
1:     "LAST_MODIFIED                      TIMESTAMP                                   ," +
1:     "LAST_STATE_CHANGE                  TIMESTAMP                                   ," +
1:     "STATE                              INTEGER                            NOT NULL ," +
1:     "TRANS_COND_VALUES                  VARCHAR(66) FOR BIT DATA           NOT NULL ," +
1:     "NUM_CONN_ACT_EVA                   INTEGER                            NOT NULL ," +
1:     "NUMBER_OF_ITERATIONS               INTEGER                            NOT NULL ," +
1:     "NUMBER_OF_RETRIES                  INTEGER                            NOT NULL ," +
1:     "HAS_CUSTOM_ATTRIBUTES              SMALLINT                           NOT NULL ," +
1:     "NON_BLOCK_PTID                     char(16) for bit data              NOT NULL ," +
1:     "NON_BLOCK_PIID                     char(16) for bit data              NOT NULL ," +
1:     "EXPIRES                            TIMESTAMP                                   ," +
1:     "TASK_ID                            VARCHAR(254)                                ," +
1:     "UNHANDLED_EXCEPTION                BLOB(3993600)                       ," +
1:     "SUB_PROCESS_PIID                   char(16) for bit data                                    ," +
1:     "OWNER                              VARCHAR(32)                                 ," +
1:     "USER_INPUT                         VARCHAR(130) FOR BIT DATA                   ," +
1:     "DESCRIPTION                        VARCHAR(254)                                ," +
1:     "VERSION_ID                         SMALLINT                           NOT NULL ," +
1:     "PRIMARY KEY ( AIID ) )");
1: 
1: 		stmt.execute("CREATE PROCEDURE doInsertion(IN P1 VARCHAR(2) FOR BIT DATA) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.doInsertion'" +
1: 						" MODIFIES SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 		CallableStatement cs = conn.prepareCall("call doInsertion (?)");
1: 		cs.setNull(1, java.sql.Types.VARBINARY);
1: 		cs.execute();
1:         byte [] b = new byte[2];
1:         b[0]=1; b[1] = 2;
1:         cs.setBytes( 1, b );
1: 		cs.execute();
1: 		cs.close();
1: 		stmt.executeUpdate("DROP PROCEDURE doInsertion");
1: 		stmt.close();
1: 	}
1: 
1: 	public static void doInsertion (byte[] p25) throws Throwable
1: 	{
1: 		Connection connNested = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement stmt = connNested.createStatement();
1: 		stmt.executeUpdate("delete from ACTIVITY_INSTANCE_T");
1: 
1:         String strStmt = "INSERT INTO ACTIVITY_INSTANCE_T VALUES( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? )";
1:         PreparedStatement pstmt = connNested.prepareStatement( strStmt );
1: 
1:         byte [] b = new byte[2];
1:         b[0]=1;
1: 		byte[] b2 = new byte[1];
1: 		b2[0] = 0;
1: 
1:          pstmt.setBytes( 1, b ); //ids
1:          pstmt.setInt( 2, 0);
1:          pstmt.setBytes( 3, b );
1:          pstmt.setBytes( 4, b );
1:          pstmt.setBytes( 5, b );
1:          pstmt.setInt( 6, 0);
1:          pstmt.setNull( 7, java.sql.Types.TIMESTAMP);
1:          pstmt.setNull( 8, java.sql.Types.TIMESTAMP);
1:          pstmt.setNull( 9, java.sql.Types.TIMESTAMP);
1:          pstmt.setNull( 10, java.sql.Types.TIMESTAMP);
1:          pstmt.setNull( 11, java.sql.Types.TIMESTAMP);
1:          pstmt.setInt( 12, 0);
1:          pstmt.setBytes( 13, b );
1: 
1:          pstmt.setInt( 14, 0);
1:          pstmt.setInt( 15, 0);
1:          pstmt.setInt( 16, 0);
1:          pstmt.setBoolean( 17, false);
1:          pstmt.setBytes( 18, b );
1:          pstmt.setBytes( 19, b );
1:          pstmt.setNull( 20, java.sql.Types.TIMESTAMP);
1:          pstmt.setNull( 21, java.sql.Types.VARCHAR);
1:          pstmt.setNull( 22, java.sql.Types.BLOB );
1:          pstmt.setNull( 23, java.sql.Types.VARBINARY );
1:          pstmt.setNull( 24, java.sql.Types.VARCHAR);
1: 		if (p25 == null)
1:              pstmt.setNull( 25, java.sql.Types.VARBINARY);
1: 		else
1: 			 pstmt.setBytes(25, p25);
1:          pstmt.setNull( 26, java.sql.Types.VARCHAR);
1:          pstmt.setShort( 27, (short) 0);
1:          pstmt.executeUpdate();
1:          pstmt.close();
1: 
1:          pstmt = connNested.prepareStatement( "SELECT version_id, user_input FROM activity_instance_t");
1:          ResultSet resultSet = pstmt.executeQuery();
1:          System.out.println("Executed query");
1:          while( resultSet.next() )
1:          {
1:             System.out.println("i= " + resultSet.getInt(1) );
1:             byte [] userInput = resultSet.getBytes(2);
1:             if( userInput == null || resultSet.wasNull() )
1:             {
1: 				if( userInput == null)
1:                		System.out.println("UserInput = null");
1: 				if (resultSet.wasNull())
1:                		System.out.println("resultSet wasNull");
1:             }
1:             else
1:             {
1:                System.out.println("UserInput length  = " + userInput.length + " bytes");
1:                for( int i=0; i<userInput.length; i++ )
1:                {
1:                   System.out.println( i + ") = " + userInput[i] );
1:                }
1:             }
1:          }
1:          System.out.println("Close result set.");
1:          resultSet.close();
1:          pstmt.close();
1:          stmt.close();
1: 		 connNested.close();
1:    }
1: }
1: 
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.outparams
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
0:       http://www.apache.org/licenses/LICENSE-2.0
1: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.tests.lang
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
0: package org.apache.derbyTesting.functionTests.tests.lang;
0: import java.sql.*;
1: 
0: import org.apache.derby.tools.ij;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import java.io.PrintStream;
0: import java.math.BigInteger;
0: import java.math.BigDecimal;
1: 
0: public class outparams
0: { 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1:  
0: 	static final String outputMethods[] =
0: 	{
1: 		"takesNothing",
1: 
1: 		null, 
1: 	
1: 		null,
1: 		null,
1: 	
1: 		"takesShortPrimitive",
1: 		null,
1: 	
1: 		"takesIntegerPrimitive",
1: 		null,
1: 	
1: 		"takesLongPrimitive",
1: 		null,
1: 	
1: 		"takesFloatPrimitive",
1: 		null,
1: 	
1: 		"takesDoublePrimitive",
1: 		null,
1: 	
0: 		"takesBigDecimal",
1: 	
1: 		"takesByteArray",
1: 		
1: 		"takesString",
1: 		
1: 		"takesDate",
1: 		
1: 		"takesTimestamp",
1: 	
1: 		"takesTime",
1: 	
1: 		null
1: 	};
1: 
0: 	// parameter types for outputMethods.
0: 	private static final String[] outputProcParam =
0: 	{
0: 		null, // "takesNothing",
1: 
1: 		null, 
1: 	
1: 		null,
1: 		null,
1: 	
0: 		"SMALLINT", // "takesShortPrimitive",
1: 		null,
1: 	
0: 		"INT", // "takesIntegerPrimitive",
1: 		null,
1: 	
0: 		"BIGINT", // "takesLongPrimitive",
1: 		null,
1: 	
0: 		"REAL", // "takesFloatPrimitive",
1: 		null,
1: 	
0: 		"DOUBLE", // "takesDoublePrimitive",
1: 		null,
1: 	
0: 		"DECIMAL(10,4)", // "takesBigDecimal",
1: 	
0: 		"VARCHAR(40) FOR BIT DATA", // "takesByteArray",
1: 		
0: 		"VARCHAR(40)", // "takesString",
1: 		
0: 		"DATE", // "takesDate",
1: 		
0: 		"TIMESTAMP", // "takesTimestamp",
1: 	
0: 		"TIME", // "takesTime",
1: 	
1: 		null
1: 	};
1: 
1: 	
0: 	static final String returnMethods[] =
0: 	{
1: 		"returnsNothing",
1: 
1: 		null,
1: 		null,
1: 	
1: 		"returnsShortP",
1: 		null,
1: 	
1: 		"returnsIntegerP",
1: 		null,
1: 	
1: 		"returnsLongP",
1: 		null,
1: 	
1: 		"returnsFloatP",
1: 		null,
1: 	
1: 		"returnsDoubleP",
1: 		null,
1: 	
0: 		"returnsBigDecimal",
1: 	
1: 		"returnsByteArray",
1: 		
1: 		"returnsString",
1: 		
1: 		"returnsDate",
1: 		
1: 		"returnsTimestamp",
1: 	
1: 		"returnsTime",
1: 	
1: 		null
1: 	};
1: 
0: 	static final String[] returnMethodType =
0: 	{
0: 		null, // "returnsNothing",
1: 
0: 		null, // "returnsBytePrimitive",
0: 		null, // "returnsByte",
1: 	
0: 		"SMALLINT", // "returnsShortPrimitive",
0: 		null, // "returnsShort",
1: 	
0: 		"INT", // "returnsIntegerPrimitive",
0: 		null, // "returnsInteger",
1: 	
0: 		"BIGINT", // "returnsLongPrimitive",
0: 		null, // "returnsLong",
1: 	
0: 		"REAL", // "returnsFloatPrimitive",
0: 		null, // "returnsFloat",
1: 	
0: 		"DOUBLE", // "returnsDoublePrimitive",
0: 		null, // "returnsDouble",
1: 	
0: 		"DECIMAL(10,2)", // "returnsBigDecimal",
1: 	
0: 		"VARCHAR(40) FOR BIT DATA", // "returnsByteArray",
1: 		
0: 		"VARCHAR(40)", // "returnsString",
1: 		
0: 		"DATE", // "returnsDate",
1: 		
0: 		"TIMESTAMP", // "returnsTimestamp",
1: 	
0: 		"TIME", // "returnsTime",
1: 	
0: 		null, // "returnsBigInteger"
1: 	};
1: 	
0: 	static final int types[] =
0: 	{
0: 		Types.BIT,
0: 		JDBC30Translation.SQL_TYPES_BOOLEAN,
0: 		Types.TINYINT,
0: 		Types.SMALLINT,
0: 		Types.INTEGER,
0: 		Types.BIGINT,
0: 		Types.FLOAT,
0: 		Types.REAL,
0: 		Types.DOUBLE,
0: 		Types.NUMERIC,
0: 		Types.DECIMAL,
0: 		Types.CHAR,
0: 		Types.VARCHAR,
0: 		Types.LONGVARCHAR,
0: 		Types.DATE,
0: 		Types.TIME, 
0: 		Types.TIMESTAMP,
0: 		Types.BINARY,
0: 		Types.VARBINARY,
0: 		Types.LONGVARBINARY,
0: 		Types.OTHER
1: 	};
1: 	
0: 	static final String typeNames[] =
0: 	{
0: 		"BIT",
0: 		"BOOLEAN",
0: 		"TINYINT",
0: 		"SMALLINT",
0: 		"INTEGER",
0: 		"BIGINT",
0: 		"FLOAT",
0: 		"REAL",
0: 		"DOUBLE",
0: 		"NUMERIC",
0: 		"DECIMAL",
0: 		"CHAR",
0: 		"VARCHAR",
0: 		"LONGVARCHAR",
0: 		"DATE",
0: 		"TIME",
0: 		"TIMESTAMP",
0: 		"BINARY",
0: 		"VARBINARY",
0: 		"LONGVARBINARY",
0: 		"OTHER"
1: 	};
1: 
0: 	//public static Connection conn;
1: 
0: 	public static void main (String[] argv) throws Throwable
0: 	{
0:    		ij.getPropertyArg(argv); 
0:         Connection conn = ij.startJBMS();
1: 
0:         runTests( conn);
1:     }
1: 
0:     public static void runTests( Connection conn) throws Throwable
0:     {        
0: 		conn.setAutoCommit(false);	
1: 
0: 		testMisc(conn);
0: 		testNull(conn);
0: 		testUpdate(conn);
0: 		testEachOutputType(conn);
0: 		testReturnTypes(conn);
0: 		testOtherOutputType(conn);
0: 		testManyOut(conn);
0: 		test5116(conn);
1: 	}
1: 
0: 	private static void testMisc(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================");
0: 		System.out.println("TESTING BOUNDARY CONDITIONS");
0: 		System.out.println("==============================================\n");
1: 
0: 		Statement scp = conn.createStatement();
1: 
0: 		scp.execute("CREATE PROCEDURE takesString(OUT P1 VARCHAR(40), IN P2 INT) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.takesString'" +
0: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
0: 		CallableStatement cs = conn.prepareCall("call takesString(?,?)");
1: 
0: 		// register a normal int as an output param, should fail
0: 		boolean failed = false;
0: 		try
0: 		{
0: 			cs.registerOutParameter(2, Types.INTEGER);
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			failed = true;
0: 			System.out.println("Expected exception "+se);
1: 		}
0: 		if (!failed)
0: 		{
0: 			System.out.println("registerOutParameter on non-output didn't fail");
1: 		}
1: 
0: 		// invalid param number
0: 		failed = false;
0: 		try
0: 		{
0: 			cs.registerOutParameter(9, Types.INTEGER);
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			failed = true;
0: 			System.out.println("Expected exception "+se);
1: 		}
0: 		if (!failed)
0: 		{
0: 			System.out.println("registerOutParameter on bad value didn't fail");
1: 		}
1: 
0: 		// invalid param number
0: 		failed = false;
0: 		try
0: 		{
0: 			cs.registerOutParameter(0, Types.INTEGER);
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			failed = true;
0: 			System.out.println("Expected exception "+se);
1: 		}
0: 		if (!failed)
0: 		{
0: 			System.out.println("registerOutParameter on bad value didn't fail");
1: 		}
1: 
0: 		// set before register, bad type, should fail as is output parameter.	
0: 		try
0: 		{
0: 			cs.setDouble(1, 1);
0: 			System.out.println("FAIL setDouble() on takesString() accepted");
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("Expected exception "+se);
1: 		}
1: 
0: 		// set before register, should fail as is output parameter.
0: 		try
0: 		{
0: 			cs.setString(1, "hello");
0: 			System.out.println("FAIL setString() on takesString() accepted");
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("Expected exception "+se);
1: 		}
1: 
0: 		cs.registerOutParameter(1, Types.CHAR);
0: 		cs.setInt(2, Types.INTEGER);
0: 		try
0: 		{
0: 			cs.execute();
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("cs.execute() got unexpected exception: "+se);
1: 		}
1: 
0: 		// shouldn't have to reregister the type, and shouldn't
0: 		// need to set the output parameters
0: 		cs.clearParameters();
0: 		cs.setInt(2, Types.INTEGER);
0: 		try
0: 		{
0: 			cs.execute();
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("cs.execute() got unexpected exception: "+se);
1: 		}
0: 		cs.close();
0: 		scp.execute("DROP PROCEDURE takesString");
1: 
0: 		scp.execute("CREATE FUNCTION returnsBigDecimal(P2 INT) RETURNS DECIMAL(10,2) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.returnsBigDecimal'" +
0: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
0: 		// return output params -- cannot do set on return output param
0: 		cs = conn.prepareCall("? = call returnsBigDecimal(?)");
0: 		try
0: 		{
0: 			cs.setBigDecimal(1, new BigDecimal(1d));
0: 			System.out.println("ERROR: setBigDecimal() on return output parameter succeeded");
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("Expected exception on setBigDecimal() on a return output param: "+se);
1: 		}
0: 		cs.close();
0: 		scp.execute("DROP FUNCTION returnsBigDecimal");
1: 
0: 		// lets try ? = call syntax on a call that doesn't return anything
1: 		
0: 		scp.execute("CREATE PROCEDURE returnsNothing() " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.returnsNothing'" +
0: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
0: 		try
0: 		{
0: 			cs = conn.prepareCall("? = call returnsNothing()");
0: 			System.out.println("ERROR: no exception on prepare of '? = call returnsNothing()");
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("Expected exception on prepare of '? = call returnsNothing()': "+se);
1: 		}
0: 		scp.execute("DROP PROCEDURE returnsNothing");
1: 	}
1: 
1: 	
0: 	private static void testNull(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================");
0: 		System.out.println("TESTING NULLS");
0: 		System.out.println("==============================================\n");
0: 		System.out.println("Test for bug 4317, passing null value for a parameter");
1: 
0: 		Statement scp = conn.createStatement();
1: 
0: 		scp.execute("CREATE PROCEDURE testNullBug4317(IN P1 VARCHAR(10)) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.testNullBug4317'" +
0: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
0: 		CallableStatement cs0 = conn.prepareCall("call testNullBug4317(?)");
0: 		try
0: 		{
0: 			cs0.setString(1, null);		// passing in null
0: 			cs0.execute();
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("cs0.execute() got unexpected exception: "+se);
1: 		}
1: 
0: 		try
0: 		{
0: 			// BUG 5928 - setNull throws an exception - fixed.
0: 			cs0.setNull(1, java.sql.Types.VARCHAR);		// passing in null
0: 			cs0.execute();
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("cs0.execute() got unexpected exception: "+se);
1: 		}
0: 		cs0.close();
0: 		scp.execute("DROP PROCEDURE testNullBug4317");
1: 
1: 
1: 	}
1: 
0: 	// test: do we get an appropriate update count when using ?=call?
0: 	private static void testUpdate(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================");
0: 		System.out.println("TESTING UPDATE COUNT");
0: 		System.out.println("==============================================\n");
1: 
0: 		Statement scp = conn.createStatement();
1: 
0: 		scp.execute("CREATE FUNCTION returnsIntegerP(P1 INT) RETURNS INTEGER " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.returnsIntegerP'" +
0: 						" NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
1: 
0: 		CallableStatement cs = conn.prepareCall("? = call returnsIntegerP(0)");
0: 		cs.registerOutParameter(1, Types.INTEGER);
0: 		try
0: 		{
0: 			int updCount = cs.executeUpdate();
0: 			System.out.println("executeUpdate on ? = call returnsIntegerP returned "+updCount);
0: 			System.out.println("getString(1) returned "+cs.getString(1));
1: 		}
0: 		catch (SQLException se)
0: 		{
0: 			System.out.println("cs.execute() got unexpected exception: "+se);
1: 		}
1: 
0: 		cs.close();
0: 		scp.execute("DROP FUNCTION returnsIntegerP");
0: 		scp.close();
1: 	}
1: 
0: 	// should do get setString() to use a string that is appropriate for
0: 	//	the target type
0: 	private static void testEachOutputType(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================");
0: 		System.out.println("TESTING NORMAL OUTPUT PARAMETERS");
0: 		System.out.println("==============================================\n");
0: 		CallableStatement cs = null;
1: 
0: 		for (int doSetObject = 0; doSetObject < 3; doSetObject++)
0: 		{
0: 			switch (doSetObject)
0: 			{
0: 				case 0:
0: 					System.out.println("...starting doing setXXX for each type xxx");
0: 					break;
0: 				case 1:
0: 					System.out.println("...now doing setObject on each type xxx");
0: 					break;
0: 				case 2:
0: 					System.out.println("...not doing any setXXX, just OUT parameters, not IN/OUT");
0: 					break;
1: 			}
1: 
0: 			for (int method = 0; method < outputMethods.length; method++)
0: 			{
0: 				String methodName = outputMethods[method];
0: 				if (methodName == null)
0: 					continue;
1: 
0: 				System.out.println("\n------------------------------------");
1: 
0: 				Statement scp = conn.createStatement();
0: 				String str;
0: 				if (methodName.indexOf("Nothing") == -1)
0: 				{
1: 
0: 					scp.execute("CREATE PROCEDURE " + methodName + "(INOUT P1 " + outputProcParam[method] + ", IN P2 INT) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
0: 						"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
0: 					if (method%2 == 0)
0: 						str = "call "+methodName+"(?,?)";
1: 					else
0: 						str = "{call "+methodName+"(?,?)}";
1: 				}
1: 				else
0: 				{
0: 					scp.execute("CREATE PROCEDURE " + methodName + "() " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
0: 						"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
0: 					str = "{call "+methodName+"()}";
1: 				}
1: 
1: 
1: 	
0: 				System.out.println(str);
0: 				try 
0: 				{
0: 					cs = conn.prepareCall(str);
1: 				}
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("ERROR: unexpected exception "+se);
0: 					throw se;
1: 				}
1: 	
0: 				for (int type = 0; type < types.length; type++)
0: 				{
0: 					cs.clearParameters();
0: 					System.out.println();
0: 					try
0: 					{
0: 						System.out.println("\n\tcs.registerOutParameter(1, "+typeNames[type]+")");
0: 						cs.registerOutParameter(1, types[type]);
1: 					} 
0: 					catch (SQLException se)
0: 					{
0: 						System.out.println("\tException "+se);
0: 						continue;
1: 					}
1: 	
0: 					StringBuffer buf = new StringBuffer();
0: 					try
0: 					{
0: 						if (doSetObject == 0) 
0: 						{
0: 							callSetMethod(cs, 1, types[type], buf);
1: 						}
0: 						else if (doSetObject == 1)
0: 						{
0: 							callSetObject(cs, 1, types[type], buf);
1: 						}
1: 						else
0: 						{
0: 							// only try this once
0: 							type = types.length-1;
0: 							buf.append("...no setXXX(1) at all");
1: 						}
1: 					}
0: 					catch (SQLException se)
0: 					{
0: 						System.out.println("\t"+buf.toString());
0: 						System.out.println("\tException "+se);
0: 						continue;
1: 					}
0: 					System.out.println("\t"+buf.toString());
0: 					cs.setInt(2, types[type]);
1: 	
0: 					try
0: 					{
0: 						System.out.println("\tcs.execute()");
0: 						boolean hasResultSet = cs.execute();
0: 						if (hasResultSet)
0: 							System.out.println("testEachOutputType HAS RESULT SET cs.execute() returned true");
1: 						}
0: 					catch (SQLException se)
0: 					{
0: 						System.out.println("\tException "+se);
0: 						continue;
1: 					}
0: 					for (int getType = 0; getType < types.length; getType++)
0: 					{
0: 						StringBuffer getbuf = new StringBuffer();
0: 						try
0: 						{
0: 							callGetMethod(cs, 1, types[getType], getbuf);
1: 						}
0: 						catch (SQLException se)
0: 						{
0: 							getbuf.append(se);
1: 						}
0: 						System.out.println("\t\t\t"+getbuf.toString());
1: 					}
1: 	
1: 				}
1: 
0: 				cs.close();
1: 
0: 				scp.execute("DROP PROCEDURE " + methodName);
0: 				scp.close();
1: 			}
1: 		}
1: 
0: 		System.out.println("------------------------------------\n");
1: 
1: 	}
1: 
0: 	// test that everything works ok when we regsiter the param as type OTHER.
0: 	// should be able to get/setXXX of the appropriate type
0: 	private static void testOtherOutputType(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================");
0: 		System.out.println("TESTING OUTPUT PARAMETERS WITH register(OTHER)");
0: 		System.out.println("==============================================\n");
0: 		CallableStatement cs = null;
1: 
0: 		for (int method = 0; method < outputMethods.length; method++)
0: 		{
0: 			String methodName = outputMethods[method];
0: 			if (methodName == null)
0: 				continue;
0: 			System.out.println("\n------------------------------------");
1: 
1: 
0: 			Statement scp = conn.createStatement();
0: 			String str;
0: 			if (methodName.indexOf("Nothing") == -1)
0: 			{
1: 
0: 				scp.execute("CREATE PROCEDURE " + methodName + "(INOUT P1 " + outputProcParam[method] + ", IN P2 INT) " +
0: 					"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
0: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
0: 				if (method%2 == 0)
0: 					str = "call "+methodName+"(?,?)";
1: 				else
0: 					str = "{call "+methodName+"(?,?)}";
1: 			}
1: 			else
0: 			{
0: 				scp.execute("CREATE PROCEDURE " + methodName + "() " +
0: 					"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
0: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
0: 				str = "{call "+methodName+"()}";
1: 			}
1: 
0: 			System.out.println(str);
0: 			try 
0: 			{
0: 				cs = conn.prepareCall(str);
1: 			}
0: 			catch (SQLException se)
0: 			{
0: 				System.out.println("ERROR: unexpected exception "+se);
0: 				throw se;
1: 			}
1: 	
0: 			for (int type = 0; type < types.length; type++)
0: 			{
0: 				cs.clearParameters();
0: 				System.out.println();
0: 				try
0: 				{
0: 					System.out.println("\n\tcs.registerOutParameter(1, Types.OTHER)");
0: 					cs.registerOutParameter(1, Types.OTHER);
1: 				} 
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("\tException "+se);
0: 					continue;
1: 				}
1: 
0: 				StringBuffer buf = new StringBuffer();
0: 				try
0: 				{
0: 					callSetMethod(cs, 1, types[type], buf);
1: 				}
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("\t"+buf.toString());
0: 					System.out.println("\tException "+se);
0: 					continue;
1: 				}
0: 				System.out.println("\t"+buf.toString());
0: 				cs.setInt(2, types[type]);
1: 
0: 				try
0: 				{
0: 					System.out.println("\tcs.execute()");
0: 					cs.execute();
1: 				}
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("\tException "+se);
0: 					continue;
1: 				}
0: 				for (int getType = 0; getType < types.length; getType++)
0: 				{
0: 					StringBuffer getbuf = new StringBuffer();
0: 					try
0: 					{
0: 						callGetMethod(cs, 1, types[getType], getbuf);
1: 					}
0: 					catch (SQLException se)
0: 					{
0: 						getbuf.append(se);
1: 					}
0: 					System.out.println("\t\t\t"+getbuf.toString());
1: 				}
1: 
1: 			}
1: 
0: 			cs.close();
1: 
0: 			scp.execute("DROP PROCEDURE " + methodName);
0: 			scp.close();
1: 		}
1: 
0: 		System.out.println("------------------------------------\n");
1: 	}
1: 
0: 	private static void testReturnTypes(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================\n");
0: 		System.out.println("TESTING RETURN OUTPUT PARAMETERS");
0: 		System.out.println("==============================================\n");
0: 		CallableStatement cs = null;
0: 		for (int method = 0; method < returnMethods.length; method++)
0: 		{
0: 			String methodName = returnMethods[method];
0: 			if (methodName == null)
0: 				continue;
1: 
0: 			Statement scf = conn.createStatement();
0: 			String str;
0: 			String dropRoutine;
0: 			if (methodName.indexOf("Nothing") != -1)
0: 			{
1: 
0: 				scf.execute("CREATE PROCEDURE " + methodName + "()" +
0: 					" EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
0: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
0: 				dropRoutine = "DROP PROCEDURE " + methodName;
1: 
0: 				str = "{call "+returnMethods[method]+"()}";
1: 			}
1: 			else
0: 			{
1: 
0: 				scf.execute("CREATE FUNCTION " + methodName + "(P1 INT) RETURNS " + returnMethodType[method] +
0: 					" EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams." + methodName +
0: 					"' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
0: 				dropRoutine = "DROP FUNCTION " + methodName;
1: 
0: 				str = "{? = call "+returnMethods[method]+"(?)}";
1: 			}
1: 
1: 
1: 				
0: 			System.out.println("\n------------------------------------");
1: 				
1: 
0: 			System.out.println(str);
0: 			try 
0: 			{
0: 				cs = conn.prepareCall(str);
1: 			}
0: 			catch (SQLException se)
0: 			{
0: 				System.out.println("ERROR: unexpected exception "+se);
0: 				throw se;
1: 			}
1: 
0: 			for (int type = 0; type < types.length; type++)
0: 			{
0: 				cs.clearParameters();
0: 				System.out.println();
0: 				try
0: 				{
0: 					System.out.println("\n\tcs.registerOutParameter(1, "+typeNames[type]+")");
0: 					cs.registerOutParameter(1, types[type]);
1: 				} 
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("\tException "+se);
0: 					continue;
1: 				}
0: 				try
0: 				{
0: 					cs.setInt(2, types[type]);
1: 				}
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("\tUnexpected exception on cs.setInt(2, "+types[type]+"): "+se);
0: 					continue;
1: 				}
1: 
0: 				try
0: 				{
0: 					System.out.println("\tcs.execute()");
0: 					boolean hasResultSet = cs.execute();
0: 					if (hasResultSet)
0: 						System.out.println("testReturnTypes HAS RESULT SET cs.execute() returned true");
1: 
1: 				}
0: 				catch (SQLException se)
0: 				{
0: 					System.out.println("\tException "+se);
0: 					continue;
1: 				}
0: 				for (int getType = 0; getType < types.length; getType++)
0: 				{
0: 					StringBuffer getbuf = new StringBuffer();
0: 					try
0: 					{
0: 						callGetMethod(cs, 1, types[getType], getbuf);
1: 					}
0: 					catch (SQLException se)
0: 					{
0: 						getbuf.append(se);
1: 					}
0: 					System.out.println("\t\t\t"+getbuf.toString());
1: 				}
1: 
1: 			}
1: 
0: 			cs.close();
0: 			scf.execute(dropRoutine);
0: 			scf.close();
1: 		}
1: 
0: 		System.out.println("------------------------------------\n");
1: 
1: 	}
1: 
0: 	private static void callSetObject(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
0: 	{
1: 
0: 		switch (type)	
0: 		{
0: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 				strbuf.append("setObject("+arg+", true)");
0: 				cs.setObject(arg, new Boolean(true));
0: 				break;
1: 
0: 			case Types.TINYINT:
0: 				strbuf.append("setObject("+arg+", 6)");
0: 				cs.setObject(arg, new Integer((byte)6));
0: 				break;
1: 
0: 			case Types.SMALLINT:
0: 				strbuf.append("setObject("+arg+", 66)");
0: 				cs.setObject(arg, new Integer((short)66));
0: 				break;
1: 
0: 			case Types.INTEGER:
0: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Integer(666));
0: 				break;
1: 
0: 			case Types.BIGINT:
0: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Long(666));
0: 				break;
1: 
0: 			case Types.FLOAT:
0: 			case Types.REAL:
0: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Float(666));
0: 				break;
1: 
0: 			case Types.DOUBLE:
0: 				strbuf.append("setObject("+arg+", 666)");
0: 				cs.setObject(arg, new Double(666));
0: 				break;
1: 
0: 			case Types.DECIMAL:
0: 			case Types.NUMERIC:
0: 				strbuf.append("setObject("+arg+", 666.666)");
0: 				BigDecimal bd = new BigDecimal("666.666");
0: 				cs.setObject(arg, bd);
0: 				break;
1: 
0: 			case Types.CHAR:
0: 			case Types.VARCHAR:
0: 			case Types.LONGVARCHAR:
0: 				strbuf.append("setObject("+arg+", \"Set via setString()\")");
0: 				cs.setObject(arg, "Set via setString()");
0: 				break;
1: 
0: 			case Types.BINARY:
0: 			case Types.VARBINARY:
0: 			case Types.LONGVARBINARY:
0: 				strbuf.append("setObject("+arg+", byte[])");
0: 				byte[] myarray = new byte[16];
0: 				myarray[0] = (byte)255;
0: 				cs.setObject(arg, myarray);
0: 				break;
1: 
0: 			case Types.DATE:
0: 				strbuf.append("setObject("+arg+", Date.valueOf(1999-09-09))");
0: 				cs.setObject(arg, Date.valueOf("1999-09-09"));
0: 				break;
1: 
0: 			case Types.TIME:
0: 				strbuf.append("setObject("+arg+", Time.valueOf(09:09:09))");
0: 				cs.setObject(arg, Time.valueOf("09:09:09"));
0: 				break;
1: 
0: 			case Types.TIMESTAMP:
0: 				strbuf.append("setObject("+arg+", Timestamp.valueOf(1999-09-09 09:09:09.999))");
0: 				cs.setObject(arg, Timestamp.valueOf("1999-09-09 09:09:09.999"));
0: 				break;
1: 
0: 			case Types.OTHER:
0: 				strbuf.append("setObject("+arg+", new BigInteger(666))");
0: 				cs.setObject(arg, new BigInteger("666"));
0: 				break;
1: 
0: 			default:
0: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1: 		}	
1: 	}
0: 	private static void callSetMethod(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
0: 	{
0: 		switch (type)	
0: 		{
0: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 				strbuf.append("setBoolean("+arg+", true)");
0: 				cs.setBoolean(arg, true);
0: 				break;
1: 
0: 			case Types.TINYINT:
0: 				strbuf.append("setByte("+arg+", 6)");
0: 				cs.setByte(arg, (byte)6);
0: 				break;
1: 
0: 			case Types.SMALLINT:
0: 				strbuf.append("setShort("+arg+", 66)");
0: 				cs.setShort(arg, (short)66);
0: 				break;
1: 
0: 			case Types.INTEGER:
0: 				strbuf.append("setInt("+arg+", 666)");
0: 				cs.setInt(arg, 666);
0: 				break;
1: 
0: 			case Types.BIGINT:
0: 				strbuf.append("setLong("+arg+", 666)");
0: 				cs.setLong(arg, 666);
0: 				break;
1: 
0: 			case Types.FLOAT:
0: 			case Types.REAL:
0: 				strbuf.append("setFLoat("+arg+", 666)");
0: 				cs.setFloat(arg, 666);
0: 				break;
1: 
0: 			case Types.DOUBLE:
0: 				strbuf.append("setDouble("+arg+", 666)");
0: 				cs.setDouble(arg, 666);
0: 				break;
1: 
0: 			case Types.DECIMAL:
0: 			case Types.NUMERIC:
0: 				strbuf.append("setBigDecimal("+arg+", 666.666)");
0: 				BigDecimal bd = new BigDecimal("666.666");
0: 				cs.setBigDecimal(arg, bd);
0: 				break;
1: 
0: 			case Types.CHAR:
0: 			case Types.VARCHAR:
0: 			case Types.LONGVARCHAR:
0: 				strbuf.append("setString("+arg+", \"Set via setString()\")");
0: 				cs.setString(arg, "Set via setString()");
0: 				break;
1: 
0: 			case Types.BINARY:
0: 			case Types.VARBINARY:
0: 			case Types.LONGVARBINARY:
0: 				strbuf.append("setBytes("+arg+", byte[])");
0: 				byte[] myarray = new byte[16];
0: 				myarray[0] = (byte)255;
0: 				cs.setBytes(arg, myarray);
0: 				break;
1: 
0: 			case Types.DATE:
0: 				strbuf.append("setDate("+arg+", Date.valueOf(1999-09-09))");
0: 				cs.setDate(arg, Date.valueOf("1999-09-09"));
0: 				break;
1: 
0: 			case Types.TIME:
0: 				strbuf.append("setTime("+arg+", Time.valueOf(09:09:09))");
0: 				cs.setTime(arg, Time.valueOf("09:09:09"));
0: 				break;
1: 
0: 			case Types.TIMESTAMP:
0: 				strbuf.append("setTimestamp("+arg+", Timestamp.valueOf(1999-09-09 09:09:09.999))");
0: 				cs.setTimestamp(arg, Timestamp.valueOf("1999-09-09 09:09:09.999"));
0: 				break;
1: 
0: 			case Types.OTHER:
0: 				strbuf.append("setObject("+arg+", new BigInteger(666))");
0: 				cs.setObject(arg, new BigInteger("666"));
0: 				break;
1: 
0: 			default:
0: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1: 		}	
1: 	}
1: 
0: 	private static void callGetMethod(CallableStatement cs, int arg, int type, StringBuffer strbuf) throws Throwable
0: 	{
0: 		switch (type)	
0: 		{
0: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 				strbuf.append("getBoolean("+arg+") = ");
0: 				strbuf.append(cs.getBoolean(arg));
0: 				break;
1: 
0: 			case Types.TINYINT:
0: 				strbuf.append("getByte("+arg+") = ");
0: 				strbuf.append(Byte.toString(cs.getByte(arg)));
0: 				break;
1: 
0: 			case Types.SMALLINT:
0: 				strbuf.append("getShort("+arg+") = ");
0: 				strbuf.append(Short.toString(cs.getShort(arg)));
0: 				break;
1: 
0: 			case Types.INTEGER:
0: 				strbuf.append("getInt("+arg+") = ");
0: 				strbuf.append(Integer.toString(cs.getInt(arg)));
0: 				break;
1: 
0: 			case Types.BIGINT:
0: 				strbuf.append("getLong("+arg+") = ");
0: 				strbuf.append(Long.toString(cs.getLong(arg)));
0: 				break;
1: 
0: 			case Types.FLOAT:
0: 			case Types.REAL:
0: 				strbuf.append("getFloat("+arg+") = ");
0: 				strbuf.append(Float.toString(cs.getFloat(arg)));
0: 				break;
1: 
0: 			case Types.DOUBLE:
0: 				strbuf.append("getDouble("+arg+") = ");
0: 				strbuf.append(Double.toString(cs.getDouble(arg)));
0: 				break;
1: 
0: 			case Types.DECIMAL:
0: 			case Types.NUMERIC:
0: 				strbuf.append("getBigDecimal("+arg+") = ");
0: 				BigDecimal bd = cs.getBigDecimal(arg, 2);
0: 				strbuf.append(bd == null ? "null" : bd.toString());
0: 				break;
1: 
0: 			case Types.CHAR:
0: 			case Types.VARCHAR:
0: 			case Types.LONGVARCHAR:
0: 				strbuf.append("getString("+arg+") = ");
0: 				String s = cs.getString(arg);
0: 				if (s.startsWith("[B@"))
0: 					s = "byte[] reference";
0: 				strbuf.append(s);
0: 				break;
1: 
0: 			case Types.BINARY:
0: 			case Types.VARBINARY:
0: 			case Types.LONGVARBINARY:
0: 				strbuf.append("getBytes("+arg+") = ");
0: 				byteArrayToString(cs.getBytes(arg), strbuf);
0: 				break;
1: 
0: 			case Types.DATE:
0: 				strbuf.append("getDate("+arg+") = ");
0: 				Date date = cs.getDate(arg);
0: 				strbuf.append(date == null ? "null" : date.toString());
0: 				break;
1: 
0: 			case Types.TIME:
0: 				strbuf.append("getTime("+arg+") = ");
0: 				Time time = cs.getTime(arg);
0: 				strbuf.append(time == null ? "null" : time.toString());
0: 				break;
1: 
0: 			case Types.TIMESTAMP:
0: 				strbuf.append("getTimestamp("+arg+") = ");
0: 				Timestamp timestamp = cs.getTimestamp(arg);
0: 				strbuf.append(timestamp == null ? "null" : timestamp.toString());
0: 				break;
1: 
0: 			case Types.OTHER:
0: 				strbuf.append("getObject("+arg+") = ");
0: 				Object o = cs.getObject(arg);
0: 				if (o == null)
0: 				{
0: 					strbuf.append("null");
1: 				}
0: 				else if (o instanceof byte[])
0: 				{
0: 					byteArrayToString((byte[])o, strbuf);
1: 				}
1: 				else
0: 				{
0: 					strbuf.append(o.toString());
1: 				}
1: 
0: 				break;
1: 
0: 			default:
0: 				throw new Throwable("TEST ERROR: unexpected type "+type);
1: 		}	
1: 	}
1: 
0: 	static private void byteArrayToString(byte[] barray, StringBuffer strbuf)
0: 	{
0: 		if (barray == null)
0: 		{
0: 			strbuf.append("null");
1: 		}
1: 		else
0: 		{
0: 			for (int i = 0; i<barray.length; i++)
0: 			{
0: 				strbuf.append(barray[i]);
1: 			}
1: 		}
1: 	}
1: 
0: 	private static String getStringOfType(int type) throws Throwable
0: 	{
0: 		switch (type)
0: 		{
0: 			case Types.CHAR:
0: 			case Types.VARCHAR:
0: 			case Types.LONGVARCHAR:
0: 				return "I am a string";
1: 
0: 			case Types.TINYINT:
0: 			case Types.SMALLINT:
0: 			case Types.INTEGER:
0: 			case Types.BIGINT:
0: 			case Types.OTHER:		// other is bigInt
0: 				return "3";
1: 
0: 			case Types.FLOAT:
0: 			case Types.REAL:
0: 			case Types.DECIMAL:
0: 			case Types.NUMERIC:
0: 				return  "3.33";
1: 
0: 			case Types.DATE:		
0: 				return "1933-03-03";
1: 
0: 			case Types.TIME:		
0: 				return "03:03:03";
1: 
0: 			case Types.TIMESTAMP:		
0: 				return "1933-03-03 03:03:03.333";
1: 
0: 			case Types.BINARY:		
0: 			case Types.VARBINARY:		
0: 			case Types.LONGVARBINARY:
0: 				return "00680065006c006c006f";
1: 
0: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 				return "true";
1: 
0: 			default:
0: 				throw new Throwable("bad type "+type);
1: 		}	
1: 	}
1: 
0: 	/////////////////////////////////////////////////////////////
0: 	//	
0: 	// OUTPUT PARAMETER METHODS
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 	public static void testNull(Boolean passedInNull, Boolean setToNull, Integer[] retval) throws Throwable
0: 	{
0: 		if (passedInNull.booleanValue())
0: 		{
0: 			if (retval[0] != null)
0: 			{
0: 				throw new Throwable("testNull() got a non-null param when it should have been null");
1: 			}
1: 		}
1: 
0: 		retval[0] = (setToNull.booleanValue()) ? null : new Integer((short)66);
1: 	}
1: 
0: 	public static void testNullBug4317(String passedInNull) throws Throwable
0: 	{
1: 	}
1: 
0: 	public static void takesNothing()
0: 	{
1: 	}
0: 	public static void takesBytePrimitive(byte[] outparam, int type)
0: 	{
0: 		outparam[0]+=outparam[0];
1: 	}
0: 	public static void takesByte(Byte[] outparam, int type)
0: 	{
0: 		outparam[0] = new Byte((byte)(outparam[0] == null ? 33 : outparam[0].byteValue()*2));
1: 	}
1: 
0: 	public static void takesShortPrimitive(short[] outparam, int type)
0: 	{
0: 		outparam[0]+=outparam[0];
1: 	}
0: 	public static void takesShort(Short[] outparam, int type)
0: 	{
0: 		outparam[0] = new Short((byte)(outparam[0] == null ? 33 : outparam[0].shortValue()*2));
1: 	}
1: 
0: 	public static void takesIntegerPrimitive(int[] outparam, int type)
0: 	{
0: 		outparam[0]+=outparam[0];
1: 	}
0: 	public static void takesInteger(Integer[] outparam, int type)
0: 	{
0: 		outparam[0] = new Integer(outparam[0] == null ? 33 : outparam[0].intValue()*2);
1: 	}
1: 
0: 	public static void takesLongPrimitive(long[] outparam, int type)
0: 	{
0: 		outparam[0]+=outparam[0];
1: 	}
0: 	public static void takesLong(Long[] outparam, int type)
0: 	{
0: 		outparam[0] = new Long(outparam[0] == null ? 33 : outparam[0].longValue()*2);
1: 	}
1: 
0: 	public static void takesDoublePrimitive(double[] outparam, int type)
0: 	{
0: 		outparam[0]+=outparam[0];
1: 	}
0: 	public static void takesDouble(Double[] outparam, int type)
0: 	{
0: 		outparam[0] = new Double(outparam[0] == null ? 33 : outparam[0].doubleValue()*2);
1: 	}
1: 
0: 	public static void takesFloatPrimitive(float[] outparam, int type)
0: 	{
0: 		outparam[0]+=outparam[0];
1: 	}
0: 	public static void takesFloat(Float[] outparam, int type)
0: 	{
0: 		outparam[0] = new Float(outparam[0] == null ? 33 : outparam[0].floatValue()*2);
1: 	}
1: 
0: 	public static void takesBooleanPrimitive(boolean[] outparam, int type)
0: 	{
0: 		outparam[0] = true;
1: 	}
0: 	public static void takesBoolean(Boolean[] outparam, int type)
0: 	{
0: 		outparam[0] = new Boolean(true);
1: 	}
1: 
0: 	public static void takesBigDecimal(BigDecimal[] outparam, int type)
0: 	{
0: 		outparam[0] = (outparam[0] == null ? new BigDecimal("33") : outparam[0].add(outparam[0]));
0: 		outparam[0].setScale(4, BigDecimal.ROUND_DOWN);
1: 	}
1: 
0: 	public static void takesByteArray(byte[][] outparam, int type)
0: 	{
0: 		byte[] myarray = new byte[16];
0: 		myarray[0] = (byte)255;
0: 		outparam[0] = myarray;
1: 	}
1: 
0: 	public static void takesDate(Date[] outparam, int type)
0: 	{
0: 		outparam[0] = Date.valueOf("1966-06-06");
1: 	}
1: 
0: 	public static void takesTime(Time[] outparam, int type)
0: 	{
0: 		outparam[0] = Time.valueOf("06:06:06");
1: 	}
1: 
0: 	public static void takesTimestamp(Timestamp[] outparam, int type)
0: 	{
0: 		outparam[0] = Timestamp.valueOf("1966-06-06 06:06:06.666");
1: 	}
1: 
0: 	public static void takesString(String[] outparam, int type) throws Throwable
0: 	{
0: 		outparam[0] = getStringOfType(type);
1: 	}
1: 
0: 	public static void takesBigInteger(BigInteger[] outparam, int type)
0: 	{
0: 		outparam[0] = (outparam[0] == null ? new BigInteger("33") : outparam[0].add(outparam[0]));
1: 	}
1: 	
1: 	
0: 	/////////////////////////////////////////////////////////////
0: 	//	
0: 	// RETURN PARAMETER METHODS
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 	public static void returnsNothing()
0: 	{
1: 	}
1: 
0: 	public static byte returnsByteP(int type)
0: 	{
0: 		return 66;
1: 	}
0: 	public static Byte returnsByte(int type)
0: 	{
0: 		return new Byte((byte)66);
1: 	}
1: 
0: 	public static short returnsShortP(int type)
0: 	{
0: 		return 666;
1: 	}
0: 	public static Short returnsShort(int type)
0: 	{
0: 		return new Short((short)666);
1: 	}
1: 
0: 	public static int returnsIntegerP(int type)
0: 	{
0: 		return 666;
1: 	}
0: 	public static Integer returnsInteger(int type)
0: 	{
0: 		return new Integer(666);
1: 	}
1: 
0: 	public static long returnsLongP(int type)
0: 	{
0: 		return 666;
1: 	}
0: 	public static Long returnsLong(int type)
0: 	{
0: 		return new Long(666);
1: 	}
1: 
0: 	public static float returnsFloatP(int type)
0: 	{
0: 		return 666;
1: 	}
0: 	public static Float returnsFloat(int type)
0: 	{
0: 		return new Float(666);
1: 	}
1: 
0: 	public static double returnsDoubleP(int type)
0: 	{
0: 		return 666;
1: 	}
0: 	public static Double returnsDouble(int type)
0: 	{
0: 		return new Double(666);
1: 	}
1: 
1: 
0: 	public static BigDecimal returnsBigDecimal(int type)
0: 	{
0: 		return new BigDecimal(666d);
1: 	}
1: 
0: 	public static byte[] returnsByteArray(int type)
0: 	{
0: 		byte[] myarray = new byte[16];
0: 		myarray[0] = (byte)255;
0: 		return myarray;
1: 	}
1: 
0: 	public static String returnsString(int type) throws Throwable
0: 	{
0: 		return getStringOfType(type);
1: 	}
1: 
0: 	public static Date returnsDate(int type)
0: 	{
0: 		return Date.valueOf("1966-06-06");
1: 	}
1: 
0: 	public static Time returnsTime(int type)
0: 	{
0: 		return Time.valueOf("06:06:06");
1: 	}
1: 
0: 	public static Timestamp returnsTimestamp(int type)
0: 	{
0: 		return Timestamp.valueOf("1966-06-06 06:06:06.666");
1: 	}
1: 
0: 	public static BigInteger returnsBigInteger(int type)
0: 	{
0: 		return new BigInteger("666");
1: 	}
1: 
1: 
0: 	// these come from the performance test JDBC.Parameters that was failing
0: 	private static void testManyOut(Connection conn) throws SQLException {
1: 
0: 		System.out.println("start testManyOut");
1: 
0: 		Statement scp = conn.createStatement();
1: 
0: 		scp.execute("CREATE PROCEDURE OP_OUT " +
0: 			"(OUT I1 INT, OUT I2 INT, OUT I3 INT, OUT I4 INT, OUT I5 INT, "+
0: 			"OUT V1 VARCHAR(40), OUT V2 VARCHAR(40), OUT V3 VARCHAR(40), OUT V4 VARCHAR(40), OUT V5 VARCHAR(40)) "+
1: 
0: 			"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
0: 		scp.execute("CREATE PROCEDURE OP_INOUT " +
0: 			"(INOUT I1 INT, INOUT I2 INT, INOUT I3 INT, INOUT I4 INT, INOUT I5 INT, " +
0: 			"INOUT V1 VARCHAR(40), INOUT V2 VARCHAR(40), INOUT V3 VARCHAR(40), INOUT V4 VARCHAR(40), INOUT V5 VARCHAR(40)) " +
1: 
0: 			"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1: 
0: 		CallableStatement csOut_cs = conn.prepareCall("CALL OP_OUT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
0: 		CallableStatement csInOut_cs = conn.prepareCall("CALL OP_INOUT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1: 
0: 		System.out.println("Ten OUT parameters");
1: 
0: 		executeOutput(csOut_cs);
0: 		executeOutput(csOut_cs);
1: 
0: 		csOut_cs.close();
1: 
0: 		System.out.println("Ten INOUT parameters");
1: 
1: 
0: 		setupInput(csInOut_cs);
0: 		executeOutput(csInOut_cs);
1: 
0: 		setupInput(csInOut_cs);
0: 		executeOutput(csInOut_cs);
1: 
0: 		csInOut_cs.close();
1: 
0: 		scp.execute("DROP PROCEDURE OP_OUT");
0: 		scp.execute("DROP PROCEDURE OP_INOUT");
0: 		scp.close();
1: 
1: 
0: 		System.out.println("end testManyOut");
1: 
1: 
1: 	}
1: 
1: 
0: 	private static void setupInput(PreparedStatement ps) throws SQLException {
1: 
0: 		ps.setInt(1, 0);
0: 		ps.setInt(2, 0);
0: 		ps.setInt(3, 99);
0: 		ps.setInt(4, 103);
0: 		ps.setInt(5, 1456);
1: 
0: 		ps.setNull(6, Types.CHAR);
0: 		ps.setString(7, null);
0: 		ps.setString(8, "hello");
0: 		ps.setString(9, "goodbye");
0: 		ps.setString(10, "welcome");
1: 	}
0: 	private static void executeOutput(CallableStatement cs) throws SQLException {
1: 
0: 		for (int p = 1; p <= 5; p++)
0: 			cs.registerOutParameter(p, Types.INTEGER);
1: 
0: 		for (int p = 6; p <= 10; p++)
0: 			cs.registerOutParameter(p, Types.VARCHAR);
1: 
0: 		cs.execute();
1: 
0: 		for (int p = 1; p <= 5; p++) {
0: 			System.out.println("  " + p + " = " + cs.getInt(p) + " was null " + cs.wasNull());
1: 	
1: 		}
0: 		for (int p = 6; p <= 10; p++) {
0: 			System.out.println("  " + p + " = " + cs.getString(p) + " was null " + cs.wasNull());
1: 		}
1: 	}
1: 
1: 
0: 	public static void output(int[] a1, int[] a2, int[] a3, int[] a4, int[] a5,
0: 		String[] s1, String[] s2, String[] s3, String[] s4, String[] s5) {
1: 
0: 		System.out.println("  a1 = " + a1[0]);
0: 		System.out.println("  a2 = " + a2[0]);
0: 		System.out.println("  a3 = " + a3[0]);
0: 		System.out.println("  a4 = " + a4[0]);
0: 		System.out.println("  a5 = " + a5[0]);
1: 
0: 		System.out.println("  s1 = " + s1[0]);
0: 		System.out.println("  s2 = " + s2[0]);
0: 		System.out.println("  s3 = " + s3[0]);
0: 		System.out.println("  s4 = " + s4[0]);
0: 		System.out.println("  s5 = " + s5[0]);
1: 
0: 		a1[0] = 0;
0: 		a2[0] = 0;
0: 		a3[0] = 77;
0: 		a4[0] = 4;
0: 		a5[0] = 2003;
1: 
0: 		s1[0] = null;
0: 		s2[0] = null;
0: 		s3[0] = "cloudscape";
0: 		s4[0] = "jbms";
0: 		s5[0] = "IBM CS";
1: 	}
1: 
0: 	private static void test5116(Connection conn) throws Throwable
0: 	{
0: 		System.out.println("==============================================");
0: 		System.out.println("TESTING FIX OF 5116 -- VAR BIT VARYING INPUT");
0: 		System.out.println("==============================================\n");
1: 
0: 		Statement stmt = conn.createStatement();
0: 		stmt.executeUpdate("CREATE TABLE ACTIVITY_INSTANCE_T (" +
0:     "AIID                               char(16) for bit data              NOT NULL ," +
0:     "KIND                               INTEGER                            NOT NULL ," +
0:     "PIID                               char(16) for bit data              NOT NULL ," +
0:     "PTID                               char(16) for bit data              NOT NULL ," +
0:     "ATID                               char(16) for bit data              NOT NULL ," +
0:     "RUN_MODE                           INTEGER                            NOT NULL ," +
0:     "FINISHED                           TIMESTAMP                                   ," +
0:     "ACTIVATED                          TIMESTAMP                                   ," +
0:     "STARTED                            TIMESTAMP                                   ," +
0:     "LAST_MODIFIED                      TIMESTAMP                                   ," +
0:     "LAST_STATE_CHANGE                  TIMESTAMP                                   ," +
0:     "STATE                              INTEGER                            NOT NULL ," +
0:     "TRANS_COND_VALUES                  VARCHAR(66) FOR BIT DATA           NOT NULL ," +
0:     "NUM_CONN_ACT_EVA                   INTEGER                            NOT NULL ," +
0:     "NUMBER_OF_ITERATIONS               INTEGER                            NOT NULL ," +
0:     "NUMBER_OF_RETRIES                  INTEGER                            NOT NULL ," +
0:     "HAS_CUSTOM_ATTRIBUTES              SMALLINT                           NOT NULL ," +
0:     "NON_BLOCK_PTID                     char(16) for bit data              NOT NULL ," +
0:     "NON_BLOCK_PIID                     char(16) for bit data              NOT NULL ," +
0:     "EXPIRES                            TIMESTAMP                                   ," +
0:     "TASK_ID                            VARCHAR(254)                                ," +
0:     "UNHANDLED_EXCEPTION                BLOB(3993600)                       ," +
0:     "SUB_PROCESS_PIID                   char(16) for bit data                                    ," +
0:     "OWNER                              VARCHAR(32)                                 ," +
0:     "USER_INPUT                         VARCHAR(130) FOR BIT DATA                   ," +
0:     "DESCRIPTION                        VARCHAR(254)                                ," +
0:     "VERSION_ID                         SMALLINT                           NOT NULL ," +
0:     "PRIMARY KEY ( AIID ) )");
1: 
0: 		stmt.execute("CREATE PROCEDURE doInsertion(IN P1 VARCHAR(2) FOR BIT DATA) " +
0: 						"EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.outparams.doInsertion'" +
0: 						" MODIFIES SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
0: 		CallableStatement cs = conn.prepareCall("call doInsertion (?)");
0: 		cs.setNull(1, java.sql.Types.VARBINARY);
0: 		cs.execute();
0:         byte [] b = new byte[2];
0:         b[0]=1; b[1] = 2;
0:         cs.setBytes( 1, b );
0: 		cs.execute();
0: 		cs.close();
0: 		stmt.executeUpdate("DROP PROCEDURE doInsertion");
0: 		stmt.close();
1: 	}
1: 
0: 	public static void doInsertion (byte[] p25) throws Throwable
0: 	{
0: 		Connection connNested = DriverManager.getConnection("jdbc:default:connection");
0: 		Statement stmt = connNested.createStatement();
0: 		stmt.executeUpdate("delete from ACTIVITY_INSTANCE_T");
1: 
0:         String strStmt = "INSERT INTO ACTIVITY_INSTANCE_T VALUES( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? )";
0:         PreparedStatement pstmt = connNested.prepareStatement( strStmt );
1: 
0:         byte [] b = new byte[2];
0:         b[0]=1;
0: 		byte[] b2 = new byte[1];
0: 		b2[0] = 0;
1: 
0:          pstmt.setBytes( 1, b ); //ids
0:          pstmt.setInt( 2, 0);
0:          pstmt.setBytes( 3, b );
0:          pstmt.setBytes( 4, b );
0:          pstmt.setBytes( 5, b );
0:          pstmt.setInt( 6, 0);
0:          pstmt.setNull( 7, java.sql.Types.TIMESTAMP);
0:          pstmt.setNull( 8, java.sql.Types.TIMESTAMP);
0:          pstmt.setNull( 9, java.sql.Types.TIMESTAMP);
0:          pstmt.setNull( 10, java.sql.Types.TIMESTAMP);
0:          pstmt.setNull( 11, java.sql.Types.TIMESTAMP);
0:          pstmt.setInt( 12, 0);
0:          pstmt.setBytes( 13, b );
1: 
0:          pstmt.setInt( 14, 0);
0:          pstmt.setInt( 15, 0);
0:          pstmt.setInt( 16, 0);
0:          pstmt.setBoolean( 17, false);
0:          pstmt.setBytes( 18, b );
0:          pstmt.setBytes( 19, b );
0:          pstmt.setNull( 20, java.sql.Types.TIMESTAMP);
0:          pstmt.setNull( 21, java.sql.Types.VARCHAR);
0:          pstmt.setNull( 22, java.sql.Types.BLOB );
0:          pstmt.setNull( 23, java.sql.Types.VARBINARY );
0:          pstmt.setNull( 24, java.sql.Types.VARCHAR);
0: 		if (p25 == null)
0:              pstmt.setNull( 25, java.sql.Types.VARBINARY);
1: 		else
0: 			 pstmt.setBytes(25, p25);
0:          pstmt.setNull( 26, java.sql.Types.VARCHAR);
0:          pstmt.setShort( 27, (short) 0);
0:          pstmt.executeUpdate();
0:          pstmt.close();
1: 
0:          pstmt = connNested.prepareStatement( "SELECT version_id, user_input FROM activity_instance_t");
0:          ResultSet resultSet = pstmt.executeQuery();
0:          System.out.println("Executed query");
0:          while( resultSet.next() )
0:          {
0:             System.out.println("i= " + resultSet.getInt(1) );
0:             byte [] userInput = resultSet.getBytes(2);
0:             if( userInput == null || resultSet.wasNull() )
0:             {
0: 				if( userInput == null)
0:                		System.out.println("UserInput = null");
0: 				if (resultSet.wasNull())
0:                		System.out.println("resultSet wasNull");
1:             }
1:             else
0:             {
0:                System.out.println("UserInput length  = " + userInput.length + " bytes");
0:                for( int i=0; i<userInput.length; i++ )
0:                {
0:                   System.out.println( i + ") = " + userInput[i] );
1:                }
1:             }
1:          }
0:          System.out.println("Close result set.");
0:          resultSet.close();
0:          pstmt.close();
0:          stmt.close();
0: 		 connNested.close();
1:    }
1: }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b9c171c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.BigDecimalHandler;
1: 	private static boolean HAVE_BIG_DECIMAL;
1: 	private static boolean HAVE_DRIVER_CLASS;
1: 	private static String CLASS_NAME;
1: 	//Get the class name to be used for the procedures
1: 	//outparams - J2ME; outparams30 - non-J2ME
1: 	static{
1: 		if(BigDecimalHandler.representation != BigDecimalHandler.BIGDECIMAL_REPRESENTATION)
1: 			HAVE_BIG_DECIMAL = false;
0: 		else
1: 			HAVE_BIG_DECIMAL = true;
1: 		if(HAVE_BIG_DECIMAL)
1: 			CLASS_NAME = "org.apache.derbyTesting.functionTests.tests.lang.outparams30.";
0: 		else
1: 			CLASS_NAME = "org.apache.derbyTesting.functionTests.tests.lang.outparams.";
0: 	}
1: 	static{
1: 		try{
1: 			Class.forName("java.sql.Driver");
1: 			HAVE_DRIVER_CLASS = true;
0: 		}
1: 		catch(ClassNotFoundException e){
1: 			//Used for JSR169
1: 			HAVE_DRIVER_CLASS = false;
0: 		}
0: 	}
1: 	static String[] outputMethods;
1: 	//Get the array to be used based on HAVE_BIG_DECIMAL
1: 	static{
1: 		if(HAVE_BIG_DECIMAL){
1: 			outputMethods = new String[] {
0: 									"takesNothing",
0: 							
0: 									null, 
0: 								
0: 									null,
0: 																	
0: 									"takesShortPrimitive",
0: 									null,
0: 								
0: 									"takesIntegerPrimitive",
0: 									null,
0: 								
0: 									"takesLongPrimitive",
0: 									null,
0: 								
0: 									"takesFloatPrimitive",
0: 									null,
0: 								
0: 									"takesDoublePrimitive",
0: 									null,
0: 								
0: 									"takesBigDecimal",
0: 								
0: 									"takesByteArray",
0: 									
0: 									"takesString",
0: 									
0: 									"takesDate",
0: 									
0: 									"takesTimestamp",
0: 								
0: 									"takesTime",
0: 								
0: 									null
0: 								};
0: 		}
1: 		else{
1: 			outputMethods = new String[] {
0: 									"takesNothing",
0: 							
0: 									null, 
0: 								
0: 									null,
0: 																	
0: 									"takesShortPrimitive",
0: 									null,
0: 								
0: 									"takesIntegerPrimitive",
0: 									null,
0: 								
0: 									"takesLongPrimitive",
0: 									null,
0: 								
0: 									"takesFloatPrimitive",
0: 									null,
0: 								
0: 									"takesDoublePrimitive",
0: 									null,
0: 								
0: 									null,
0: 								
0: 									"takesByteArray",
0: 									
0: 									"takesString",
0: 									
0: 									"takesDate",
0: 									
0: 									"takesTimestamp",
0: 								
0: 									"takesTime",
0: 								
0: 									null
0: 								};			
0: 		}
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 			
/////////////////////////////////////////////////////////////////////////
1: 	static String returnMethods[];
1: 	//Get the array to be used based on HAVE_BIG_DECIMAL
1: 	static{
1: 		if(HAVE_BIG_DECIMAL){
1: 			returnMethods = new String[] 	{
0: 									"returnsNothing",
0: 				
0: 									null,
0: 									null,
0: 								
0: 									"returnsShortP",
0: 									null,
0: 								
0: 									"returnsIntegerP",
0: 									null,
0: 								
0: 									"returnsLongP",
0: 									null,
0: 								
0: 									"returnsFloatP",
0: 									null,
0: 								
0: 									"returnsDoubleP",
0: 									null,
0: 								
0: 									"returnsBigDecimal",
0: 								
0: 									"returnsByteArray",
0: 									
0: 									"returnsString",
0: 									
0: 									"returnsDate",
0: 									
0: 									"returnsTimestamp",
0: 								
0: 									"returnsTime",
0: 								
0: 									null
0: 								};
0: 		}
1: 		else{
1: 			returnMethods = new String[] 	{
0: 									"returnsNothing",
0: 				
0: 									null,
0: 									null,
0: 								
0: 									"returnsShortP",
0: 									null,
0: 								
0: 									"returnsIntegerP",
0: 									null,
0: 								
0: 									"returnsLongP",
0: 									null,
0: 								
0: 									"returnsFloatP",
0: 									null,
0: 								
0: 									"returnsDoubleP",
0: 									null,
0: 								
0: 									null,
0: 								
0: 									"returnsByteArray",
0: 									
0: 									"returnsString",
0: 									
0: 									"returnsDate",
0: 									
0: 									"returnsTimestamp",
0: 								
0: 									"returnsTime",
0: 								
0: 									null
0: 								};
0: 		}
0: 	}
1: 	static String[] returnMethodType =
/////////////////////////////////////////////////////////////////////////
1: 	//JDBC type (java.sql.Types) corresponding to the methods
1: 	static int[] paramJDBCType =
0: 	{
1: 		Types.NULL, // "returnsNothing",
0: 
1: 		Types.NULL, // "returnsBytePrimitive",
1: 		Types.NULL, // "returnsByte",
0: 	
1: 		Types.SMALLINT, // "returnsShortPrimitive",
1: 		Types.NULL, // "returnsShort",
0: 	
1: 		Types.INTEGER, // "returnsIntegerPrimitive",
1: 		Types.NULL, // "returnsInteger",
0: 	
1: 		Types.BIGINT, // "returnsLongPrimitive",
1: 		Types.NULL, // "returnsLong",
0: 	
1: 		Types.REAL, // "returnsFloatPrimitive",
1: 		Types.NULL, // "returnsFloat",
0: 	
1: 		Types.DOUBLE, // "returnsDoublePrimitive",
1: 		Types.NULL, // "returnsDouble",
0: 	
1: 		Types.NUMERIC, // "returnsBigDecimal",
0: 	
1: 		Types.VARBINARY, // "returnsByteArray",
0: 		
1: 		Types.VARCHAR, // "returnsString",
0: 		
1: 		Types.DATE, // "returnsDate",
0: 		
1: 		Types.TIMESTAMP, // "returnsTimestamp",
0: 	
1: 		Types.TIME, // "returnsTime",
0: 	
1: 		Types.NULL, // "returnsBigInteger"
0: 	};	
0: 	
/////////////////////////////////////////////////////////////////////////
1: 		//Uses a procedure with nested connection - Cannot be tested with JSR169
1: 		if(HAVE_DRIVER_CLASS)
0: 			test5116(conn);
/////////////////////////////////////////////////////////////////////////
1: 						"EXTERNAL NAME '" + CLASS_NAME + "takesString'" +
/////////////////////////////////////////////////////////////////////////
1: 		scp.execute("CREATE FUNCTION returnsString(P2 INT) RETURNS VARCHAR(40) " +
1: 						"EXTERNAL NAME '" + CLASS_NAME + "returnsString'" +
1: 		cs = conn.prepareCall("? = call returnsString(?)");
1: 			cs.setString(1, new String("test"));
1: 			System.out.println("ERROR: setString() on return output parameter succeeded");
1: 			System.out.println("Expected exception on setString() on a return output param: "+se);
1: 		scp.execute("DROP FUNCTION returnsString");
1: 						"EXTERNAL NAME '" + CLASS_NAME + "returnsNothing'" +
/////////////////////////////////////////////////////////////////////////
1: 						"EXTERNAL NAME '" + CLASS_NAME + "testNullBug4317'" +
/////////////////////////////////////////////////////////////////////////
1: 						"EXTERNAL NAME '" + CLASS_NAME + "returnsIntegerP'" +
/////////////////////////////////////////////////////////////////////////
1: 						"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
0: 					else
0: 						str = "call "+methodName+"(?,?)";
1: 						"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
/////////////////////////////////////////////////////////////////////////
1: 							callGetMethod(cs, 1, types[getType], paramJDBCType[method], getbuf);
/////////////////////////////////////////////////////////////////////////
1: 					"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
0: 				else
0: 					str = "call "+methodName+"(?,?)";
1: 					"EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
/////////////////////////////////////////////////////////////////////////
1: 						callGetMethod(cs, 1, types[getType], Types.OTHER , getbuf);
/////////////////////////////////////////////////////////////////////////
1: 					" EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
/////////////////////////////////////////////////////////////////////////
1: 					" EXTERNAL NAME '" + CLASS_NAME + "" + methodName +
/////////////////////////////////////////////////////////////////////////
1: 						callGetMethod(cs, 1, types[getType], paramJDBCType[method], getbuf);
/////////////////////////////////////////////////////////////////////////
1: 				BigDecimalHandler.setObjectString(cs,arg,"666.666");
/////////////////////////////////////////////////////////////////////////
1: 				BigDecimalHandler.setBigDecimalString(cs,arg,"666.666");
/////////////////////////////////////////////////////////////////////////
1: 	private static void callGetMethod(CallableStatement cs, int arg, int type, int paramType ,StringBuffer strbuf) throws Throwable
/////////////////////////////////////////////////////////////////////////
1: 				strbuf.append(BigDecimalHandler.getBigDecimalString(cs,arg,paramType));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			"EXTERNAL NAME '" + CLASS_NAME + "output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 			"EXTERNAL NAME '" + CLASS_NAME + "output' NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA");
/////////////////////////////////////////////////////////////////////////
1: 						"EXTERNAL NAME '" + CLASS_NAME + "doInsertion'" +
============================================================================