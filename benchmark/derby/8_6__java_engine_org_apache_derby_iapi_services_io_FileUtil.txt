1:eac0369: /*
1:e8afaeb: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.io.FileUtil
1:edd6d3c: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:ff24958: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:ff24958: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:dc43cf8: 
7:eac0369:  */
1:dc43cf8: 
1:eac0369: package org.apache.derby.iapi.services.io;
1:dc43cf8: 
1:dc43cf8: import java.io.File;
1:dc43cf8: import java.io.FileInputStream;
1:dc43cf8: import java.io.FileOutputStream;
1:dc43cf8: import java.io.IOException;
1:dc43cf8: import java.io.InputStream;
1:dc43cf8: import java.io.OutputStream;
1:eac0369: import org.apache.derby.io.StorageFactory;
1:eac0369: import org.apache.derby.io.WritableStorageFactory;
1:eac0369: import org.apache.derby.io.StorageFile;
1:dc43cf8: 
1:e23ae38: import java.net.MalformedURLException;
1:e23ae38: import java.net.URL;
1:14248ac: import java.nio.file.Files;
1:14248ac: import java.nio.file.Path;
1:14248ac: import java.nio.file.attribute.AclEntry;
1:14248ac: import java.nio.file.attribute.AclEntryPermission;
1:14248ac: import java.nio.file.attribute.AclEntryType;
1:14248ac: import java.nio.file.attribute.AclFileAttributeView;
1:14248ac: import java.nio.file.attribute.PosixFileAttributeView;
1:14248ac: import java.nio.file.attribute.PosixFilePermission;
1:14248ac: import java.util.Collections;
1:14248ac: import java.util.EnumSet;
1:dc43cf8: import org.apache.derby.iapi.reference.Property;
1:dc43cf8: import org.apache.derby.iapi.services.property.PropertyUtil;
1:dc43cf8: 
1:dc43cf8: /**
1:eac0369: 	A set of public static methods for dealing with File objects.
1:dc43cf8: */
1:eac0369: public abstract class FileUtil {
1:dc43cf8: 
1:eac0369:     private static final int BUFFER_SIZE = 4096*4;
7:eac0369: 	/**
1:eac0369: 		Remove a directory and all of its contents.
1:dc43cf8: 
1:eac0369: 		The results of executing File.delete() on a File object
1:eac0369: 		that represents a directory seems to be platform
1:eac0369: 		dependent. This method removes the directory
1:eac0369: 		and all of its contents.
1:dc43cf8: 
1:eac0369: 		@return true if the complete directory was removed, false if it could not be.
1:eac0369: 		If false is returned then some of the files in the directory may have been removed.
1:dc43cf8: 
1:eac0369: 	*/
1:eac0369: 	public static boolean removeDirectory(File directory) {
1:dc43cf8: 
1:eac0369: 		// System.out.println("removeDirectory " + directory);
1:dc43cf8: 
1:eac0369: 		if (directory == null)
1:ff24958: 			return false;
1:eac0369: 		if (!directory.exists())
3:eac0369: 			return true;
1:eac0369: 		if (!directory.isDirectory())
10:eac0369: 			return false;
1:e8afaeb: 
1:eac0369: 		String[] list = directory.list();
1:dc43cf8: 
2:eac0369: 		// Some JVMs return null for File.list() when the
2:eac0369: 		// directory is empty.
2:eac0369: 		if (list != null) {
1:eac0369: 			for (int i = 0; i < list.length; i++) {
1:eac0369: 				File entry = new File(directory, list[i]);
1:dc43cf8: 
1:eac0369: 				//				System.out.println("\tremoving entry " + entry);
1:dc43cf8: 
2:eac0369: 				if (entry.isDirectory())
7:eac0369: 				{
1:eac0369: 					if (!removeDirectory(entry))
1:eac0369: 						return false;
1:ff24958: 				}
3:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					if (!entry.delete())
1:e8afaeb: 						return false;
1:e8afaeb: 				}
1:dc43cf8: 			}
1:dc43cf8: 		}
1:edd6d3c: 
1:eac0369: 		return directory.delete();
1:dc43cf8: 	}
1:e23ae38: 
1:eac0369: 	public static boolean copyFile(File from, File to, byte[] buf)
1:eac0369: 	{
1:eac0369: 		if (buf == null)
1:eac0369: 			buf = new byte[BUFFER_SIZE];
1:e8afaeb: 
10:edd6d3c: 		//
1:eac0369: 		//		System.out.println("Copy file ("+from+","+to+")");
1:eac0369: 		FileInputStream from_s = null;
1:eac0369: 		FileOutputStream to_s = null;
1:ff24958: 
1:4f7eee8: 		try {
1:eac0369: 			from_s = new FileInputStream(from);
1:eac0369: 			to_s = new FileOutputStream(to);
1:4f7eee8:             limitAccessToOwner(to);
1:ff24958: 
1:047a763: 			for (int bytesRead = from_s.read(buf);
1:047a763: 				 bytesRead != -1;
1:eac0369: 				 bytesRead = from_s.read(buf))
1:047a763: 				to_s.write(buf,0,bytesRead);
1:ff24958: 
1:047a763: 			from_s.close();
1:047a763: 			from_s = null;
1:dc43cf8: 
1:eac0369: 			to_s.getFD().sync();  // RESOLVE: sync or no sync?
1:047a763: 			to_s.close();
1:047a763: 			to_s = null;
1:4f7eee8: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:dc43cf8: 			return false;
1:4f7eee8: 		}
1:047a763: 		finally
1:eac0369: 		{
1:eac0369: 			if (from_s != null)
1:eac0369: 			{
1:eac0369: 				try { from_s.close(); }
1:047a763: 				catch (IOException ioe) {}
1:dc43cf8: 			}
1:eac0369: 			if (to_s != null)
1:eac0369: 			{
1:eac0369: 				try { to_s.close(); }
1:047a763: 				catch (IOException ioe) {}
1:dc43cf8: 			}
1:dc43cf8: 		}
1:dc43cf8: 
1:dc43cf8: 		return true;
1:dc43cf8: 	}
1:dc43cf8: 
1:dc43cf8: 
2:eac0369:     public static boolean copyDirectory( StorageFactory storageFactory,
2:eac0369:                                          StorageFile from,
1:eac0369:                                          File to,
1:eac0369:                                          byte[] buffer,
1:c10c404:                                          String[] filter, 
1:c10c404:                                          boolean copySubDirs)
1:eac0369:     {
2:eac0369: 		if (from == null)
1:dc43cf8: 			return false;
2:eac0369: 		if (!from.exists())
1:eac0369: 			return true;
2:eac0369: 		if (!from.isDirectory())
1:eac0369: 			return false;
1:dc43cf8: 
2:eac0369: 		if (to.exists())
1:eac0369: 		{
2:eac0369: 			//			System.out.println(to + " exists");
1:eac0369: 			return false;
1:dc43cf8: 		}
2:eac0369: 		if (!to.mkdirs())
1:eac0369: 		{
2:eac0369: 			//			System.out.println("can't make" + to);
1:eac0369: 			return false;
1:dc43cf8: 		}			
1:dc43cf8: 
1:4f7eee8:         try {
1:dc43cf8:             limitAccessToOwner(to);
1:4f7eee8:         } catch (IOException ioe) {
1:4f7eee8:             return false;
1:4f7eee8:         }
1:dc43cf8: 
3:eac0369: 		String[] list = from.list();
1:dc43cf8: 
1:eac0369: 		// Some JVMs return null for File.list() when the
1:eac0369: 		// directory is empty.
1:eac0369: 		if (list != null)
1:eac0369:         {
2:eac0369: 			if (buffer == null)
2:eac0369: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1:dc43cf8: 
1:eac0369:           nextFile:
1:eac0369:             for (int i = 0; i < list.length; i++)
1:eac0369:             {
2:eac0369: 				String fileName = list[i];
1:dc43cf8: 
2:eac0369: 				if (filter != null) {
2:eac0369: 					for (int j = 0; j < filter.length; j++) {
2:eac0369: 						if (fileName.equals(filter[j]))
1:eac0369: 							continue nextFile;
1:dc43cf8: 					}
1:dc43cf8: 				}
1:dc43cf8: 
1:eac0369: 				StorageFile entry = storageFactory.newStorageFile(from, fileName);
1:dc43cf8: 
1:eac0369: 				if (entry.isDirectory())
1:eac0369: 				{
1:c10c404:                     if(copySubDirs) {
1:c10c404:                         if (!copyDirectory( storageFactory, entry, 
1:c10c404:                                             new File(to,fileName), buffer, 
1:c10c404:                                             filter, copySubDirs))
1:eac0369:                             return false;
1:dc43cf8:                     }
1:c10c404:                     else {
1:c10c404:                         // the request is to not copy the directories, continue
1:c10c404:                         // to the next file in the list.
1:eac0369:                         continue nextFile;
1:dc43cf8:                     }
1:dc43cf8: 
1:dc43cf8: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					if (!copyFile( storageFactory, entry, new File(to,fileName), buffer))
1:eac0369: 						return false;
1:dc43cf8: 				}
1:dc43cf8: 			}
1:dc43cf8: 		}
1:eac0369: 		return true;
1:eac0369: 	} // end of copyDirectory( StorageFactory sf, StorageFile from, File to, byte[] buf, String[] filter)
1:dc43cf8: 
1:eac0369:     public static boolean copyFile( StorageFactory storageFactory, StorageFile from, File to)
1:eac0369:     {
1:eac0369:         return copyFile( storageFactory, from, to, (byte[]) null);
1:dc43cf8:     }
1:dc43cf8:     
1:eac0369: 	public static boolean copyFile( StorageFactory storageFactory, StorageFile from, File to, byte[] buf)
1:eac0369: 	{
1:eac0369: 		InputStream from_s = null;
1:eac0369: 		FileOutputStream to_s = null;
1:dc43cf8: 
1:4f7eee8: 		try {
1:eac0369: 			from_s = from.getInputStream();
1:eac0369: 			to_s = new FileOutputStream( to);
1:dc43cf8:             limitAccessToOwner(to);
1:dc43cf8: 
1:eac0369: 			if (buf == null)
1:eac0369: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1:dc43cf8: 
1:eac0369: 			for (int bytesRead = from_s.read(buf);
1:eac0369: 				 bytesRead != -1;
1:eac0369: 				 bytesRead = from_s.read(buf))
1:eac0369: 				to_s.write(buf,0,bytesRead);
1:dc43cf8: 
1:eac0369: 			from_s.close();
1:eac0369: 			from_s = null;
1:dc43cf8: 
1:eac0369: 			to_s.getFD().sync();  // RESOLVE: sync or no sync?
1:eac0369: 			to_s.close();
1:eac0369: 			to_s = null;
37:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (from_s != null)
1:eac0369: 			{
1:eac0369: 				try { from_s.close(); }
1:eac0369: 				catch (IOException ioe) {}
1:eac0369: 			}
1:eac0369: 			if (to_s != null)
1:eac0369: 			{
1:eac0369: 				try { to_s.close(); }
1:eac0369: 				catch (IOException ioe) {}
1:eac0369: 			}
1:eac0369: 		}
1:dc43cf8: 
1:eac0369: 		return true;
1:eac0369: 	} // end of copyFile( StorageFactory storageFactory, StorageFile from, File to, byte[] buf)
1:dc43cf8: 
1:eac0369:     public static boolean copyDirectory( WritableStorageFactory storageFactory,
1:eac0369:                                          File from,
1:eac0369:                                          StorageFile to)
1:eac0369:     {
2:eac0369:         return copyDirectory( storageFactory, from, to, null, null);
1:eac0369:     }
1:dc43cf8:     
1:eac0369:     public static boolean copyDirectory( WritableStorageFactory storageFactory,
1:eac0369:                                          File from,
1:eac0369:                                          StorageFile to,
1:eac0369:                                          byte[] buffer,
3:eac0369:                                          String[] filter)
1:eac0369:     {
1:eac0369: 		if (from == null)
1:eac0369: 			return false;
1:eac0369: 		if (!from.exists())
1:eac0369: 			return true;
1:eac0369: 		if (!from.isDirectory())
1:eac0369: 			return false;
1:dc43cf8: 
1:eac0369: 		if (to.exists())
1:eac0369: 		{
1:eac0369: 			//			System.out.println(to + " exists");
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		if (!to.mkdirs())
1:eac0369: 		{
1:eac0369: 			//			System.out.println("can't make" + to);
1:eac0369: 			return false;
1:eac0369: 		}			
1:7ecc1f2: 
2:dc43cf8:         try {
1:4f7eee8:             to.limitAccessToOwner();
1:4f7eee8:         } catch (IOException ioe) {
1:4f7eee8:             return false;
1:4f7eee8:         }
1:dc43cf8: 
1:dc43cf8:         String[] list = from.list();
1:7ecc1f2: 
1:eac0369: 		// Some JVMs return null for File.list() when the
1:eac0369: 		// directory is empty.
1:eac0369: 		if (list != null)
1:eac0369:         {
1:eac0369: 			if (buffer == null)
1:eac0369: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1:7ecc1f2: 
1:eac0369:           nextFile:
1:eac0369:             for (int i = 0; i < list.length; i++)
1:eac0369:             {
1:eac0369: 				String fileName = list[i];
1:7ecc1f2: 
1:eac0369: 				if (filter != null) {
1:eac0369: 					for (int j = 0; j < filter.length; j++) {
1:eac0369: 						if (fileName.equals(filter[j]))
1:eac0369: 							continue nextFile;
1:eac0369: 					}
1:eac0369: 				}
66:eac0369: 
2:eac0369: 				File entry = new File(from, fileName);
1:eac0369: 
1:eac0369: 				if (entry.isDirectory())
1:eac0369: 				{
1:eac0369: 					if (!copyDirectory( storageFactory, entry, storageFactory.newStorageFile(to,fileName), buffer, filter))
1:eac0369: 						return false;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					if (!copyFile( storageFactory, entry, storageFactory.newStorageFile(to,fileName), buffer))
1:eac0369: 						return false;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	} // end of copyDirectory( StorageFactory sf, StorageFile from, File to, byte[] buf, String[] filter)
1:eac0369: 
1:eac0369:     public static boolean copyFile( WritableStorageFactory storageFactory, File from, StorageFile to)
1:eac0369:     {
1:eac0369:         return copyFile( storageFactory, from, to, (byte[]) null);
1:eac0369:     }
1:eac0369:     
1:eac0369: 	public static boolean copyFile( WritableStorageFactory storageFactory, File from, StorageFile to, byte[] buf)
1:eac0369: 	{
1:eac0369: 		InputStream from_s = null;
1:eac0369: 		OutputStream to_s = null;
1:eac0369: 
1:dc43cf8: 		try {
1:eac0369: 			from_s = new FileInputStream( from);
1:eac0369: 			to_s = to.getOutputStream();
1:eac0369: 
1:eac0369: 			if (buf == null)
1:eac0369: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1:eac0369: 
1:eac0369: 			for (int bytesRead = from_s.read(buf);
1:eac0369: 				 bytesRead != -1;
1:eac0369: 				 bytesRead = from_s.read(buf))
1:eac0369: 				to_s.write(buf,0,bytesRead);
1:eac0369: 
1:eac0369: 			from_s.close();
1:eac0369: 			from_s = null;
1:eac0369: 
1:eac0369: 			storageFactory.sync( to_s, false);  // RESOLVE: sync or no sync?
1:eac0369: 			to_s.close();
1:eac0369: 			to_s = null;
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (from_s != null)
1:eac0369: 			{
1:eac0369: 				try { from_s.close(); }
1:eac0369: 				catch (IOException ioe) {}
1:eac0369: 			}
1:eac0369: 			if (to_s != null)
1:eac0369: 			{
1:eac0369: 				try { to_s.close(); }
1:eac0369: 				catch (IOException ioe) {}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	} // end of copyFile
1:eac0369: 
1:eac0369: 
2:047a763:     public static boolean copyFile( WritableStorageFactory storageFactory, 
1:047a763:                                     StorageFile from, StorageFile to)
1:eac0369:     {
1:047a763: 		InputStream from_s = null;
1:047a763: 		OutputStream to_s = null;
1:eac0369: 
1:dc43cf8: 		try {
1:047a763: 			from_s = from.getInputStream();
1:047a763: 			to_s = to.getOutputStream();
1:eac0369: 
1:d56ee6a:             byte[] buf = new byte[BUFFER_SIZE];
1:eac0369: 
1:eac0369: 			for (int bytesRead = from_s.read(buf);
1:eac0369: 				 bytesRead != -1;
1:047a763: 				 bytesRead = from_s.read(buf))
1:eac0369: 				to_s.write(buf,0,bytesRead);
1:eac0369: 
1:eac0369: 			from_s.close();
1:eac0369: 			from_s = null;
1:eac0369: 
1:047a763: 			storageFactory.sync( to_s, false);  // RESOLVE: sync or no sync?
1:eac0369: 			to_s.close();
1:eac0369: 			to_s = null;
1:eac0369: 		}
1:047a763: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:047a763: 			if (from_s != null)
1:eac0369: 			{
1:047a763: 				try { from_s.close(); }
1:eac0369: 				catch (IOException ioe) {}
1:eac0369: 			}
1:047a763: 			if (to_s != null)
1:eac0369: 			{
1:047a763: 				try { to_s.close(); }
1:eac0369: 				catch (IOException ioe) {}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:047a763: 	} // end of copyFile
1:eac0369: 
1:e23ae38: 	/**
1:e23ae38: 		Remove the leading 'file://' protocol from a filename which has been
1:e23ae38:         expressed as an URL. If the filename is not an URL, then nothing is done.
1:e23ae38:         Otherwise, an URL like 'file:///tmp/foo.txt' is transformed into the legal
1:e23ae38:         file name '/tmp/foo.txt'.
1:e23ae38: 	*/
1:e23ae38:     public static String stripProtocolFromFileName( String originalName )
1:e23ae38:     {
1:e23ae38:         String result = originalName;
1:e23ae38:         try {
1:e23ae38:             URL url = new URL(originalName);
1:e23ae38:             result = url.getFile();
1:e23ae38:         } catch (MalformedURLException ex) {}
1:e23ae38: 
1:e23ae38:         return result;
1:e23ae38:     }
1:dc43cf8: 
1:eac0369:     /**
1:1fa09ce:      * <p>
1:edd6d3c:      * Use when creating new files. If running on Unix,
1:dc43cf8:      * limit read and write permissions on {@code file} to owner if {@code
1:dc43cf8:      * derby.storage.useDefaultFilePermissions == false}.
1:1fa09ce:      * </p>
1:1fa09ce:      *
1:1fa09ce:      * <p>
1:dc43cf8:      * If the property is not specified, we use restrictive permissions anyway
1:dc43cf8:      * iff running with the server server started from the command line.
1:1fa09ce:      * </p>
1:1fa09ce:      *
1:1fa09ce:      * <p>
1:dc43cf8:      * On Unix, this is equivalent to running with umask 0077.
1:1fa09ce:      * </p>
1:1fa09ce:      *
1:1fa09ce:      * <p>
1:dc43cf8:      * On Windows, with FAT/FAT32, we lose, since the fs does not support
1:dc43cf8:      * permissions, only a read-only flag.
1:1fa09ce:      * </p>
1:1fa09ce:      *
1:1fa09ce:      * <p>
1:14248ac:      * On Windows, with NTFS with ACLs, we limit access also for Windows
1:14248ac:      * using the new {@code java.nio.file.attribute} package.
1:1fa09ce:      * </p>
1:1fa09ce:      *
1:1fa09ce:      * <p>
1:1fa09ce:      * When restricted file access is enabled (either explicitly or by
1:1fa09ce:      * default) errors are handled like this: When running on JDK 7 or higher,
1:1fa09ce:      * and the file system can be accessed either via a PosixFileAttributeView
1:1fa09ce:      * or via an AclFileAttributeView, any IOException reported when trying
1:1fa09ce:      * to restrict the permissions will also be thrown by this method. In
1:1fa09ce:      * all other cases, it will do its best to limit the permissions using
1:1fa09ce:      * the {@code java.io.File} methods ({@code setReadable()},
1:1fa09ce:      * {@code setWritable()}, {@code setExecutable()}), but it won't throw
1:1fa09ce:      * any exceptions if the permissions cannot be set that way.
1:1fa09ce:      * </p>
1:dc43cf8:      *
1:dc43cf8:      * @param file assumed to be just created
1:4f7eee8:      * @throws IOException if an I/O error happens when trying to change the
1:4f7eee8:      *   file permissions
1:eac0369:      */
1:4f7eee8:     public static void limitAccessToOwner(File file) throws IOException {
1:dc43cf8: 
1:dc43cf8:         String value = PropertyUtil.getSystemProperty(
1:dc43cf8:             Property.STORAGE_USE_DEFAULT_FILE_PERMISSIONS);
1:dc43cf8: 
1:dc43cf8:         if (value != null) {
1:14248ac:             if (Boolean.parseBoolean(value.trim())) {
2:dc43cf8:                 return;
1:dc43cf8:             }
3:dc43cf8:         } else {
1:dc43cf8:             // The property has not been specified. Only proceed if we are
1:14248ac:             // running with the network server started from the command line.
1:14248ac:             if (PropertyUtil.getSystemBoolean(
1:14248ac:                         Property.SERVER_STARTED_FROM_CMD_LINE, false)) {
1:a65a598:                 // proceed
1:a65a598:             } else {
1:dc43cf8:                 return;
1:dc43cf8:             }
1:dc43cf8:         }
1:dc43cf8: 
1:1fa09ce:         // First attempt to limit access using the java.io.File class.
1:1fa09ce:         // If it is successful, that's it and we're done.
1:1fa09ce:         if (limitAccessToOwnerViaFile(file)) {
1:dc43cf8:             return;
1:dc43cf8:         }
1:dc43cf8: 
1:1fa09ce:         // We couldn't limit the access using the java.io.File class. Try
1:1fa09ce:         // again with a FileAttributeView if it is supported. We may have
1:1fa09ce:         // more luck with that approach. For example, with NTFS on Windows,
1:1fa09ce:         // the java.io.File class won't be able to limit access, but the
1:1fa09ce:         // FileAttributeView will.
1:1fa09ce:         limitAccessToOwnerViaFileAttributeView(file);
1:1fa09ce:     }
1:1fa09ce: 
1:1fa09ce:     /**
1:1fa09ce:      * Limit access to owner using methods in the {@code java.io.File} class.
1:1fa09ce:      * Those methods are available on all Java versions from 6 and up, but
1:1fa09ce:      * they are not fully functional on all file systems.
1:1fa09ce:      *
1:1fa09ce:      * @param file the file to limit access to
1:1fa09ce:      * @return {@code true} on success, or {@code false} if some of the
1:1fa09ce:      * permissions could not be changed
1:1fa09ce:      */
1:1fa09ce:     private static boolean limitAccessToOwnerViaFile(File file) {
1:1fa09ce: 
1:edd6d3c:         // First switch off all write access
1:1fa09ce:         boolean success = file.setWritable(false, false);
1:dc43cf8: 
1:edd6d3c:         // Next, switch on write again, but for owner only
1:1fa09ce:         success &= file.setWritable(true, true);
1:dc43cf8: 
1:edd6d3c:         // First switch off all read access
1:1fa09ce:         success &= file.setReadable(false, false);
1:edd6d3c: 
1:edd6d3c:         // Next, switch on read access again, but for owner only
1:1fa09ce:         success &= file.setReadable(true, true);
1:edd6d3c: 
1:edd6d3c:         if (file.isDirectory()) {
1:edd6d3c:             // First switch off all exec access
1:1fa09ce:             success &= file.setExecutable(false, false);
1:dc43cf8: 
1:edd6d3c:             // Next, switch on exec again, but for owner only
1:1fa09ce:             success &= file.setExecutable(true, true);
1:dc43cf8:         }
1:1fa09ce: 
1:1fa09ce:         return success;
1:dc43cf8:     }
1:dc43cf8: 
1:1fa09ce:     /**
1:1fa09ce:      * Limit access to owner using a
1:1fa09ce:      * {@code java.nio.file.attribute.FileAttributeView}.
1:1fa09ce:      * Such views are only available on Java 7 and higher, and only on
1:1fa09ce:      * file systems that support changing file permissions. Currently,
1:1fa09ce:      * this is supported on POSIX file systems and file systems that
1:1fa09ce:      * maintain access control lists (ACLs).
1:1fa09ce:      *
1:1fa09ce:      * @param file the file to limit access to
1:1fa09ce:      * @return {@code true} on success, or {@code false} if some of the
1:1fa09ce:      * permissions could not be changed
1:1fa09ce:      */
1:1fa09ce:     private static boolean limitAccessToOwnerViaFileAttributeView(File file)
1:4f7eee8:             throws IOException {
1:dc43cf8: 
1:14248ac:         Path fileP = file.toPath();
1:dc43cf8: 
1:14248ac:         PosixFileAttributeView posixView = Files.getFileAttributeView(
1:14248ac:                 fileP, PosixFileAttributeView.class);
1:14248ac:         if (posixView != null) {
1:14248ac: 
1:14248ac:             // This is a POSIX file system. Usually,
1:14248ac:             // FileUtil.limitAccessToOwnerViaFile() will successfully set
1:14248ac:             // the permissions on such file systems using the java.io.File
1:14248ac:             // class, so we don't get here. If, however, that approach failed,
1:14248ac:             // we try again here using a PosixFileAttributeView. That's likely
1:14248ac:             // to fail too, but at least now we will get an IOException that
1:14248ac:             // explains why it failed.
1:14248ac: 
1:14248ac:             EnumSet<PosixFilePermission> perms = EnumSet.of(
1:14248ac:                     PosixFilePermission.OWNER_READ,
1:14248ac:                     PosixFilePermission.OWNER_WRITE);
1:14248ac: 
1:14248ac:             if (file.isDirectory()) {
1:14248ac:                 perms.add(PosixFilePermission.OWNER_EXECUTE);
1:14248ac:             }
1:14248ac: 
1:14248ac:             posixView.setPermissions(perms);
1:14248ac: 
1:14248ac:             return true;
1:dc43cf8:         }
1:dc43cf8: 
1:14248ac:         AclFileAttributeView aclView = Files.getFileAttributeView(
1:14248ac:                 fileP, AclFileAttributeView.class);
1:14248ac:         if (aclView != null) {
1:14248ac: 
1:14248ac:             // Since we have an AclFileAttributeView which is not a
1:14248ac:             // PosixFileAttributeView, we probably have an NTFS file
1:14248ac:             // system.
1:14248ac: 
1:14248ac:             // Remove existing ACEs, build a new one which simply
1:14248ac:             // gives all possible permissions to current owner.
1:14248ac:             AclEntry ace = AclEntry.newBuilder()
1:14248ac:                     .setPrincipal(Files.getOwner(fileP))
1:14248ac:                     .setType(AclEntryType.ALLOW)
1:14248ac:                     .setPermissions(EnumSet.allOf(AclEntryPermission.class))
1:14248ac:                     .build();
1:14248ac: 
1:14248ac:             aclView.setAcl(Collections.singletonList(ace));
1:14248ac: 
1:14248ac:             return true;
1:14248ac:         }
1:14248ac: 
1:14248ac:         // We don't know how to set permissions on this file system.
1:14248ac:         return false;
1:dc43cf8:     }
1:dc43cf8: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:14248ac
/////////////////////////////////////////////////////////////////////////
1: import java.nio.file.Files;
1: import java.nio.file.Path;
1: import java.nio.file.attribute.AclEntry;
1: import java.nio.file.attribute.AclEntryPermission;
1: import java.nio.file.attribute.AclEntryType;
1: import java.nio.file.attribute.AclFileAttributeView;
1: import java.nio.file.attribute.PosixFileAttributeView;
1: import java.nio.file.attribute.PosixFilePermission;
1: import java.util.Collections;
1: import java.util.EnumSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * On Windows, with NTFS with ACLs, we limit access also for Windows
1:      * using the new {@code java.nio.file.attribute} package.
/////////////////////////////////////////////////////////////////////////
1:             if (Boolean.parseBoolean(value.trim())) {
1:             // running with the network server started from the command line.
1:             if (PropertyUtil.getSystemBoolean(
1:                         Property.SERVER_STARTED_FROM_CMD_LINE, false)) {
/////////////////////////////////////////////////////////////////////////
1:         Path fileP = file.toPath();
1:         PosixFileAttributeView posixView = Files.getFileAttributeView(
1:                 fileP, PosixFileAttributeView.class);
1:         if (posixView != null) {
1: 
1:             // This is a POSIX file system. Usually,
1:             // FileUtil.limitAccessToOwnerViaFile() will successfully set
1:             // the permissions on such file systems using the java.io.File
1:             // class, so we don't get here. If, however, that approach failed,
1:             // we try again here using a PosixFileAttributeView. That's likely
1:             // to fail too, but at least now we will get an IOException that
1:             // explains why it failed.
1: 
1:             EnumSet<PosixFilePermission> perms = EnumSet.of(
1:                     PosixFilePermission.OWNER_READ,
1:                     PosixFilePermission.OWNER_WRITE);
1: 
1:             if (file.isDirectory()) {
1:                 perms.add(PosixFilePermission.OWNER_EXECUTE);
1:             }
1: 
1:             posixView.setPermissions(perms);
1: 
1:             return true;
1:         AclFileAttributeView aclView = Files.getFileAttributeView(
1:                 fileP, AclFileAttributeView.class);
1:         if (aclView != null) {
1: 
1:             // Since we have an AclFileAttributeView which is not a
1:             // PosixFileAttributeView, we probably have an NTFS file
1:             // system.
1: 
1:             // Remove existing ACEs, build a new one which simply
1:             // gives all possible permissions to current owner.
1:             AclEntry ace = AclEntry.newBuilder()
1:                     .setPrincipal(Files.getOwner(fileP))
1:                     .setType(AclEntryType.ALLOW)
1:                     .setPermissions(EnumSet.allOf(AclEntryPermission.class))
1:                     .build();
1: 
1:             aclView.setAcl(Collections.singletonList(ace));
1: 
1:             return true;
1:         }
1: 
1:         // We don't know how to set permissions on this file system.
1:         return false;
commit:1fa09ce
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * </p>
1:      *
1:      * <p>
1:      * </p>
1:      *
1:      * <p>
1:      * </p>
1:      *
1:      * <p>
1:      * </p>
1:      *
1:      * <p>
1:      * </p>
1:      *
1:      * <p>
1:      * When restricted file access is enabled (either explicitly or by
1:      * default) errors are handled like this: When running on JDK 7 or higher,
1:      * and the file system can be accessed either via a PosixFileAttributeView
1:      * or via an AclFileAttributeView, any IOException reported when trying
1:      * to restrict the permissions will also be thrown by this method. In
1:      * all other cases, it will do its best to limit the permissions using
1:      * the {@code java.io.File} methods ({@code setReadable()},
1:      * {@code setWritable()}, {@code setExecutable()}), but it won't throw
1:      * any exceptions if the permissions cannot be set that way.
1:      * </p>
/////////////////////////////////////////////////////////////////////////
1:         // First attempt to limit access using the java.io.File class.
1:         // If it is successful, that's it and we're done.
1:         if (limitAccessToOwnerViaFile(file)) {
1:         // We couldn't limit the access using the java.io.File class. Try
1:         // again with a FileAttributeView if it is supported. We may have
1:         // more luck with that approach. For example, with NTFS on Windows,
1:         // the java.io.File class won't be able to limit access, but the
1:         // FileAttributeView will.
1:         limitAccessToOwnerViaFileAttributeView(file);
1:     }
1: 
1:     /**
1:      * Limit access to owner using methods in the {@code java.io.File} class.
1:      * Those methods are available on all Java versions from 6 and up, but
1:      * they are not fully functional on all file systems.
1:      *
1:      * @param file the file to limit access to
1:      * @return {@code true} on success, or {@code false} if some of the
1:      * permissions could not be changed
1:      */
1:     private static boolean limitAccessToOwnerViaFile(File file) {
1: 
1:         boolean success = file.setWritable(false, false);
1:         success &= file.setWritable(true, true);
1:         success &= file.setReadable(false, false);
1:         success &= file.setReadable(true, true);
1:             success &= file.setExecutable(false, false);
1:             success &= file.setExecutable(true, true);
1: 
1:         return success;
1:     /**
1:      * Limit access to owner using a
1:      * {@code java.nio.file.attribute.FileAttributeView}.
1:      * Such views are only available on Java 7 and higher, and only on
1:      * file systems that support changing file permissions. Currently,
1:      * this is supported on POSIX file systems and file systems that
1:      * maintain access control lists (ACLs).
1:      *
1:      * @param file the file to limit access to
1:      * @return {@code true} on success, or {@code false} if some of the
1:      * permissions could not be changed
1:      */
1:     private static boolean limitAccessToOwnerViaFileAttributeView(File file)
commit:9fb7cc5
/////////////////////////////////////////////////////////////////////////
0:         } catch (LinkageError e) {
commit:4f7eee8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             limitAccessToOwner(to);
1:         } catch (IOException ioe) {
1:             return false;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             to.limitAccessToOwner();
1:         } catch (IOException ioe) {
1:             return false;
1:         }
/////////////////////////////////////////////////////////////////////////
0:     private final static FilePermissionService filePermissionService =
0:             loadFilePermissionService();
0:     private static FilePermissionService loadFilePermissionService() {
1:         try {
0:             Class cl = Class.forName(
0:                     FilePermissionService.class.getName() + "Impl");
0:             return (FilePermissionService) cl.newInstance();
0:         } catch (ClassNotFoundException ex) {
0:         } catch (InstantiationException ex) {
0:         } catch (IllegalAccessException ex) {
1:         }
0:         // Could not create an instance. This most likely means we are
0:         // not on Java 7 or higher. Just return null, and let
0:         // limitAccessToOwner() choose another strategy on older platforms.
0:         return null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException if an I/O error happens when trying to change the
1:      *   file permissions
1:     public static void limitAccessToOwner(File file) throws IOException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static boolean limitAccessToOwnerViaACLs(File file)
1:             throws IOException {
0:         if (filePermissionService == null) {
0:         // We have Java 7, so call.
0:         return filePermissionService.limitAccessToOwner(file);
commit:8d4d087
/////////////////////////////////////////////////////////////////////////
commit:d56ee6a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             byte[] buf = new byte[BUFFER_SIZE];
/////////////////////////////////////////////////////////////////////////
commit:edd6d3c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Use when creating new files. If running on Unix,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // First switch off all write access
1:         //
0:         assertTrue(file.setWritable(false, false));
1:         //
1:         // Next, switch on write again, but for owner only
1:         //
0:         assertTrue(file.setWritable(true, true));
1: 
1:         //
1:         // First switch off all read access
1:         //
0:         assertTrue(file.setReadable(false, false));
1: 
1:         //
1:         // Next, switch on read access again, but for owner only
1:         //
0:         assertTrue(file.setReadable(true, true));
1: 
1:         if (file.isDirectory()) {
1:             //
1:             // First switch off all exec access
1:             //
0:             assertTrue(file.setExecutable(false, false));
1:             // Next, switch on exec again, but for owner only
0:             assertTrue(file.setExecutable(true, true));
0:     private static void assertTrue(boolean b) {
0:             if (!b) {
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:073b862
/////////////////////////////////////////////////////////////////////////
0:     private static Class<File> fileClz = File.class;
0:     private static Class<?> filesClz;
0:     private static Class<?> pathClz;
0:     private static Class<?> pathsClz;
0:     private static Class<?> aclEntryClz;
0:     private static Class<?> aclFileAttributeViewClz;
0:     private static Class<?> posixFileAttributeViewClz;
0:     private static Class<?> userPrincipalClz;
0:     private static Class<?> linkOptionArrayClz;
0:     private static Class<?> linkOptionClz;
0:     private static Class<?> stringArrayClz;
0:     private static Class<?> aclEntryBuilderClz;
0:     private static Class<?> aclEntryTypeClz;
0:     private static Class<?> fileStoreClz;
0:     private static Class<?> aclEntryPermissionClz;
/////////////////////////////////////////////////////////////////////////
0:             List<Object> newAcl = new ArrayList<Object>();
/////////////////////////////////////////////////////////////////////////
0:                 new Object[] {new HashSet<Object>(Arrays.asList(perms))});
commit:e23ae38
/////////////////////////////////////////////////////////////////////////
1: import java.net.MalformedURLException;
1: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		Remove the leading 'file://' protocol from a filename which has been
1:         expressed as an URL. If the filename is not an URL, then nothing is done.
1:         Otherwise, an URL like 'file:///tmp/foo.txt' is transformed into the legal
1:         file name '/tmp/foo.txt'.
1: 	*/
1:     public static String stripProtocolFromFileName( String originalName )
1:     {
1:         String result = originalName;
1:         try {
1:             URL url = new URL(originalName);
1:             result = url.getFile();
1:         } catch (MalformedURLException ex) {}
1: 
1:         return result;
1:     }
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e8afaeb
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: import java.util.HashSet;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     private static Class aclEntryPermissionClz;
/////////////////////////////////////////////////////////////////////////
0:     private static Method values;
0:     private static Method setPermissions;
1:     
/////////////////////////////////////////////////////////////////////////
0:             if (JVMInfo.JDK_ID >= JVMInfo.J2SE_17 &&
/////////////////////////////////////////////////////////////////////////
0:                     aclEntryPermissionClz = Class.forName(
0:                             "java.nio.file.attribute.AclEntryPermission");
/////////////////////////////////////////////////////////////////////////
0:                     values = aclEntryPermissionClz.
0:                         getMethod("values", (Class[]) null);
0:                     setPermissions = aclEntryBuilderClz.
0:                         getMethod("setPermissions", new Class[] { Set.class });
/////////////////////////////////////////////////////////////////////////
0:             // If we have a posix view, just return and fall back on
0:             // the JDK 6 approach.
0:             if (posixView != null) {
1:                 return false;
1:             }
1: 
0:             // Since we have an AclFileAttributeView which is not a
0:             // PosixFileAttributeView, we probably have a NTFS file
0:             // system.
1: 
0:             // Remove existing ACEs, build a new one which simply
0:             // gives all possible permissions to current owner.
0:             //
0:             // List<AclEntry>        newAcl = new ArrayList<>();
0:             // AclEntryPermissions[] perms = AclEntryPermission.values();
0:             // AclEntry.Builder      aceb = AclEntry.newBuilder();
0:             //
0:             // aceb.setType(AclEntryType.ALLOW);
0:             // aceb.setPermissions(new HashSet(Arrays.asList(perms);
0:             // newAcl.add(aceb);
0:             List newAcl = new ArrayList();
0:             Object[] perms = (Object[]) values.invoke(null, (Object[]) null);
0:             Object aceb = newBuilder.invoke(null, (Object[]) null);
0:             Object allowValue = allow.get(aclEntryTypeClz);
0:             aceb = setPrincipal.invoke(aceb, new Object[]{owner});
0:             aceb = setType.invoke(aceb, new Object[]{allowValue});
0:             aceb = setPermissions.invoke(
0:                 aceb,
0:                 new Object[] {new HashSet(Arrays.asList(perms))});
0:             newAcl.add(build.invoke(aceb, (Object[]) null));
commit:33ca65d
/////////////////////////////////////////////////////////////////////////
commit:ff24958
/////////////////////////////////////////////////////////////////////////
0:     private static Class fileStoreClz;
0:     private static Method supportsFileAttributeView;
0:     private static Method getFileStore;
/////////////////////////////////////////////////////////////////////////
0:                     fileStoreClz = Class.forName(
0:                         "java.nio.file.FileStore");
0:                     get = pathsClz.getMethod(
0:                         "get",
0:                         new Class[]{String.class, stringArrayClz});
0:                     getFileAttributeView = filesClz.getMethod(
0:                         "getFileAttributeView",
0:                         new Class[]{pathClz, Class.class, linkOptionArrayClz});
0:                     supportsFileAttributeView = fileStoreClz.getMethod(
0:                         "supportsFileAttributeView",
0:                         new Class[]{Class.class});
0:                     getFileStore = filesClz.getMethod("getFileStore",
0:                                                       new Class[]{pathClz});
/////////////////////////////////////////////////////////////////////////
0:                     e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
0:             // ACLs supported on this platform, now check the current file
0:             // system:
0:             Object fileStore = getFileStore.invoke(
0:                 null,
0:                 new Object[]{fileP});
1: 
0:             boolean supported =
0:                 ((Boolean)supportsFileAttributeView.invoke(
0:                     fileStore,
0:                     new Object[]{aclFileAttributeViewClz})).booleanValue();
1: 
0:             if (!supported) {
1:                 return false;
1:             }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:a65a598
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0:             // running with the network server started from the command line
0:             // *and* at Java 7 or above
0:             if (JVMInfo.JDK_ID >= JVMInfo.J2SE_17 && 
0:                     (PropertyUtil.getSystemBoolean(
0:                         Property.SERVER_STARTED_FROM_CMD_LINE, false)) ) {
1:                 // proceed
1:             } else {
commit:dc43cf8
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
0: import java.lang.reflect.Array;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.Field;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.List;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:         limitAccessToOwner(to);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             limitAccessToOwner(to);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         limitAccessToOwner(to);
1: 
/////////////////////////////////////////////////////////////////////////
0:             limitAccessToOwner(to);
/////////////////////////////////////////////////////////////////////////
0:         to.limitAccessToOwner();
1: 
1:         String[] list = from.list();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:     // Members used by limitAccessToOwner
0:     private static final Object region = new Object();
0:     private static boolean initialized = false;
1: 
0:     // Reflection helper objects for calling into Java >= 6
0:     private static Method setWrite = null;
0:     private static Method setRead = null;
0:     private static Method setExec = null;
1: 
0:     // Reflection helper objects for calling into Java >= 7
0:     private static Class fileClz = File.class;
0:     private static Class filesClz;
0:     private static Class pathClz;
0:     private static Class pathsClz;
0:     private static Class aclEntryClz;
0:     private static Class aclFileAttributeViewClz;
0:     private static Class posixFileAttributeViewClz;
0:     private static Class userPrincipalClz;
0:     private static Class linkOptionArrayClz;
0:     private static Class linkOptionClz;
0:     private static Class stringArrayClz;
0:     private static Class aclEntryBuilderClz;
0:     private static Class aclEntryTypeClz;
1: 
0:     private static Method get;
0:     private static Method getFileAttributeView;
0:     private static Method getOwner;
0:     private static Method getAcl;
0:     private static Method setAcl;
0:     private static Method principal;
0:     private static Method getName;
0:     private static Method build;
0:     private static Method newBuilder;
0:     private static Method setPrincipal;
0:     private static Method setType;
1: 
0:     private static Field allow;
1:     /**
0:      * Use when creating new files. If running with Java 6 or higher on Unix,
1:      * limit read and write permissions on {@code file} to owner if {@code
1:      * derby.storage.useDefaultFilePermissions == false}.
0:      * <p/>
1:      * If the property is not specified, we use restrictive permissions anyway
1:      * iff running with the server server started from the command line.
0:      * <p/>
1:      * On Unix, this is equivalent to running with umask 0077.
0:      * <p/>
1:      * On Windows, with FAT/FAT32, we lose, since the fs does not support
1:      * permissions, only a read-only flag.
0:      * <p/>
0:      * On Windows, with NTFS with ACLs, if running with Java 7 or higher, we
0:      * limit access also for Windows using the new {@code
0:      * java.nio.file.attribute} package.
1:      *
1:      * @param file assumed to be just created
1:      */
0:     public static void limitAccessToOwner(File file) {
1: 
1:         String value = PropertyUtil.getSystemProperty(
1:             Property.STORAGE_USE_DEFAULT_FILE_PERMISSIONS);
1: 
1:         if (value != null) {
0:             if (Boolean.valueOf(value.trim()).booleanValue()) {
1:                 return;
1:             }
1:         } else {
1:             // The property has not been specified. Only proceed if we are
0:             // running with the network server started from the command line.
0:             if ( !PropertyUtil.getSystemBoolean(
0:                     Property.SERVER_STARTED_FROM_CMD_LINE, false)) {
1:                 return;
1:             }
1:         }
1: 
0:         // lazy initialization, needs to be called in security context
0:         synchronized (region) {
0:             if (!initialized) {
0:                 initialized = true;
0:                 // >= Java 6
1:                 try {
0:                     setWrite = fileClz.getMethod(
0:                         "setWritable",
0:                         new Class[]{Boolean.TYPE, Boolean.TYPE});
0:                     setRead = fileClz.getMethod(
0:                         "setReadable",
0:                         new Class[]{Boolean.TYPE, Boolean.TYPE});
0:                     setExec = fileClz.getMethod(
0:                         "setExecutable",
0:                         new Class[]{Boolean.TYPE, Boolean.TYPE});
0:                 } catch (NoSuchMethodException e) {
0:                     // not Java 6 or higher
1:                 }
1: 
0:                 // >= Java 7
1:                 try {
0:                     // If found, we have >= Java 7.
0:                     filesClz = Class.forName(
0:                         "java.nio.file.Files");
0:                     pathClz = Class.forName(
0:                         "java.nio.file.Path");
0:                     pathsClz = Class.forName(
0:                         "java.nio.file.Paths");
0:                     aclEntryClz = Class.forName(
0:                         "java.nio.file.attribute.AclEntry");
0:                     aclFileAttributeViewClz = Class.forName(
0:                         "java.nio.file.attribute.AclFileAttributeView");
0:                     posixFileAttributeViewClz = Class.forName(
0:                         "java.nio.file.attribute.PosixFileAttributeView");
0:                     userPrincipalClz = Class.forName(
0:                         "java.nio.file.attribute.UserPrincipal");
0:                     linkOptionArrayClz = Class.forName(
0:                         "[Ljava.nio.file.LinkOption;");
0:                     linkOptionClz = Class.forName(
0:                         "java.nio.file.LinkOption");
0:                     stringArrayClz = Class.forName(
0:                         "[Ljava.lang.String;");
0:                     aclEntryBuilderClz = Class.forName(
0:                         "java.nio.file.attribute.AclEntry$Builder");
0:                     aclEntryTypeClz = Class.forName(
0:                         "java.nio.file.attribute.AclEntryType");
1: 
0:                     get = pathsClz.
0:                         getMethod("get",
0:                                   new Class[]{String.class, stringArrayClz});
1: 
0:                     getFileAttributeView = filesClz.
0:                         getMethod("getFileAttributeView",
0:                                   new Class[]{pathClz,
0:                                               Class.class,
0:                                               linkOptionArrayClz});
1: 
0:                     getOwner = filesClz.
0:                         getMethod("getOwner",
0:                                   new Class[]{pathClz, linkOptionArrayClz});
0:                     getAcl = aclFileAttributeViewClz.
0:                         getMethod("getAcl", new Class[]{});
0:                     setAcl = aclFileAttributeViewClz.
0:                         getMethod("setAcl", new Class[]{List.class});
0:                     principal = aclEntryClz.
0:                         getMethod("principal", new Class[]{});
0:                     getName = userPrincipalClz.
0:                         getMethod("getName", new Class[]{});
0:                     build = aclEntryBuilderClz.
0:                         getMethod("build", new Class[]{});
0:                     newBuilder = aclEntryClz.
0:                         getMethod("newBuilder", new Class[]{});
0:                     setPrincipal = aclEntryBuilderClz.
0:                         getMethod("setPrincipal",
0:                                   new Class[]{userPrincipalClz});
0:                     setType = aclEntryBuilderClz.
0:                         getMethod("setType", new Class[]{aclEntryTypeClz});
1: 
0:                     allow = aclEntryTypeClz.getField("ALLOW");
1: 
0:                 } catch (NoSuchMethodException e) {
0:                     // not Java 7 or higher
0:                 } catch (ClassNotFoundException e) {
0:                     // not Java 7 or higher
0:                 } catch (NoSuchFieldException e) {
0:                     // not Java 7 or higher
1:                 }
1:             }
1:         }
1: 
0:         if (setWrite == null) {
0:             // JVM level too low
1:             return;
1:         }
1: 
0:         if (limitAccessToOwnerViaACLs(file)) {
1:             return;
1:         }
1: 
1:         try {
0:             //
0:             // First switch off all write access
0:             //
0:             Object r;
1: 
0:             r = setWrite.invoke(
0:                 file,
0:                 new Object[]{Boolean.FALSE, Boolean.FALSE});
0:             assertTrue(r);
1: 
0:             //
0:             // Next, switch on write again, but for owner only
0:             //
0:             r = setWrite.invoke(
0:                 file,
0:                 new Object[]{Boolean.TRUE, Boolean.TRUE});
0:             assertTrue(r);
1: 
0:             //
0:             // First switch off all read access
0:             //
0:             r = setRead.invoke(
0:                 file,
0:                 new Object[]{Boolean.FALSE, Boolean.FALSE});
0:             assertTrue(r);
1: 
0:             //
0:             // Next, switch on read access again, but for owner only
0:             //
0:             r = setRead.invoke(
0:                 file,
0:                 new Object[]{Boolean.TRUE, Boolean.TRUE});
0:             assertTrue(r);
1: 
1: 
0:             if (file.isDirectory()) {
0:                 //
0:                 // First switch off all exec access
0:                 //
0:                 r = setExec.invoke(
0:                     file,
0:                     new Object[]{Boolean.FALSE, Boolean.FALSE});
0:                 assertTrue(r);
1: 
0:                 //
0:                 // Next, switch on read exec again, but for owner only
0:                 //
0:                 r = setExec.invoke(
0:                     file,
0:                     new Object[]{Boolean.TRUE, Boolean.TRUE});
0:                 assertTrue(r);
1:             }
0:         } catch (InvocationTargetException e) {
0:             // setWritable/setReadable can throw SecurityException
0:             throw (SecurityException)e.getCause();
0:         } catch (IllegalAccessException e) {
0:             // coding error
0:             if (SanityManager.DEBUG) {
0:                 SanityManager.THROWASSERT(e);
1:             }
1:         }
1:     }
1: 
0:     private static void assertTrue(Object r){
0:         // We should always have the permission to modify the access since have
0:         // just created the file. On some file systems, some operations will
0:         // not work, though, notably FAT/FAT32, as well as NTFS on java < 7, so
0:         // we ignore it the failure.
0:         if (SanityManager.DEBUG) {
0:             Boolean b = (Boolean)r;
1: 
0:             if (!b.booleanValue()) {
0:                 String os =
0:                     PropertyUtil.getSystemProperty("os.name").toLowerCase();
1: 
0:                 if (os.indexOf("windows") >= 0) {
0:                     // expect this to fail, Java 6 on Windows doesn't cut it,
0:                     // known not to work.
1:                 } else {
0:                     SanityManager.THROWASSERT(
0:                         "File.set{RWX} failed on this file system");
1:                 }
1:             }
1:         }
1:     }
1: 
0:     private static boolean limitAccessToOwnerViaACLs(File file) {
1: 
0:         // See if we are running on JDK 7 so we can deny access
0:         // using the new java.nio.file.attribute package.
1: 
0:         if (filesClz == null) {
0:             // nope
1:             return false;
1:         }
1: 
0:         // We have Java 7, so call. We need to call reflectively, since the
0:         // source level isn't yet at Java 7.
1:         try {
0:             // Path fileP = Paths.get(file.getPath());
0:             Object fileP = get.invoke(
0:                 null, new Object[]{file.getPath(), new String[]{}});
1: 
0:             // AclFileAttributeView view =
0:             //     Files.getFileAttributeView(fileP,
0:             //         AclFileAttributeView.class);
0:             Object view = getFileAttributeView.invoke(
0:                 null,
0:                 new Object[]{fileP,
0:                              aclFileAttributeViewClz,
0:                              Array.newInstance(linkOptionClz, 0)});
1: 
0:             if (view == null) {
0:                 // ACLs not supported on this platform
1:                 return false;
1:             }
1: 
0:             // If we have a posix view, we can use ACLs to interface
0:             // the usual Unix permission masks vi the special principals
0:             // OWNER@, GROUP@ and EVERYONE@
1: 
0:             // PosixFileAttributeView posixView =
0:             // Files.getFileAttributeView(fileP, PosixFileAttributeView.class);
0:             Object posixView = getFileAttributeView.invoke(
0:                 null,
0:                 new Object[]{fileP,
0:                              posixFileAttributeViewClz,
0:                              Array.newInstance(linkOptionClz, 0)});
1: 
0:             // UserPrincipal owner = Files.getOwner(fileP);
0:             Object owner = getOwner.invoke(
0:                 null,
0:                 new Object[]{fileP, Array.newInstance(linkOptionClz, 0)});
1: 
0:             // List<AclEntry> oldAcl = view.getAcl();
0:             // List<AclEntry> newAcl = new ArrayList<>();
1: 
0:             List oldAcl = (List)getAcl.invoke(view, null);
0:             List newAcl = new ArrayList();
1: 
0:             // for (AclEntry ace : oldAcl) {
0:             //     if (posixView != null) {
0:             //         if (ace.principal().getName().equals("OWNER@")) {
0:             //             // retain permission for owner
0:             //             newAcl.add(ace);
0:             //         } else if (
0:             //             ace.principal().getName().equals("GROUP@") ||
0:             //             ace.principal().getName().equals("EVERYONE@")) {
0:             //
0:             //             AclEntry.Builder aceb = AclEntry.newBuilder();
0:             //             aceb.setPrincipal(ace.principal())
0:             //                 .setType(AclEntryType.ALLOW);
0:             //             // add no permissions for the group and other
0:             //             newAcl.add(aceb.build());
0:             //         }
0:             //     } else {
0:             //         // NTFS, hopefully
0:             //         if (ace.principal().equals(owner)) {
0:             //             newAcl.add(ace);
0:             //         }
0:             //     }
0:             // }
1: 
0:             for (Iterator i = oldAcl.iterator(); i.hasNext();) {
0:                 Object ace = i.next();
0:                 Object princ = principal.invoke(ace, null);
0:                 String princName = (String)getName.invoke(princ, null);
1: 
0:                 if (posixView != null) {
0:                     if (princName.equals("OWNER@")) {
0:                         // retain permission for owner
0:                         newAcl.add(ace);
0:                     } else if (
0:                         princName.equals("GROUP@") ||
0:                         princName.equals("EVERYONE@")) {
1: 
0:                         // add ALLOW ACE w/no permissions for group and other
1: 
0:                         Object aceb = newBuilder.invoke(null, null);
0:                         Object allowValue = allow.get(aclEntryTypeClz);
1: 
0:                         aceb = setPrincipal.invoke(aceb, new Object[]{princ});
0:                         aceb = setType.invoke(aceb, new Object[]{allowValue});
0:                         newAcl.add(build.invoke(aceb, null));
1:                     }
1:                 } else {
0:                     // NTFS, hopefully
0:                     if (princ.equals(owner)) {
0:                         newAcl.add(ace);
1:                     }
1:                 }
1:             }
1: 
0:             // view.setAcl(newAcl);
0:             setAcl.invoke(view, new Object[]{newAcl});
1: 
0:         } catch (IllegalAccessException e) {
0:             // coding error
0:             if (SanityManager.DEBUG) {
0:                 SanityManager.THROWASSERT(e);
1:             }
0:         } catch (IllegalArgumentException e) {
0:             // coding error
0:             if (SanityManager.DEBUG) {
0:                 SanityManager.THROWASSERT(e);
1:             }
0:         } catch (InvocationTargetException e) {
0:             // java.security.AccessControlException: access denied
0:             // ("java.lang.RuntimePermission" "accessUserInformation") can
0:             // happen, so throw.
0:             //
0:             // Should we get an IOException from getOwner, the cast below
0:             // would throw which is fine, since it should not happen.
0:             throw (RuntimeException)e.getCause();
1:         }
1: 
1:         return true;
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ed1c2e3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.io.FileUtil
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.io;
1: 
1: import org.apache.derby.io.StorageFactory;
1: import org.apache.derby.io.WritableStorageFactory;
1: import org.apache.derby.io.StorageFile;
1: 
0: import java.io.*;
0: import java.net.*;
1: 
1: /**
1: 	A set of public static methods for dealing with File objects.
1: */
1: public abstract class FileUtil {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1:     private static final int BUFFER_SIZE = 4096*4;
1: 	/**
1: 		Remove a directory and all of its contents.
1: 
1: 		The results of executing File.delete() on a File object
1: 		that represents a directory seems to be platform
1: 		dependent. This method removes the directory
1: 		and all of its contents.
1: 
1: 		@return true if the complete directory was removed, false if it could not be.
1: 		If false is returned then some of the files in the directory may have been removed.
1: 
1: 	*/
1: 	public static boolean removeDirectory(File directory) {
1: 
1: 		// System.out.println("removeDirectory " + directory);
1: 
1: 		if (directory == null)
1: 			return false;
1: 		if (!directory.exists())
1: 			return true;
1: 		if (!directory.isDirectory())
1: 			return false;
1: 
1: 		String[] list = directory.list();
1: 
1: 		// Some JVMs return null for File.list() when the
1: 		// directory is empty.
1: 		if (list != null) {
1: 			for (int i = 0; i < list.length; i++) {
1: 				File entry = new File(directory, list[i]);
1: 
1: 				//				System.out.println("\tremoving entry " + entry);
1: 
1: 				if (entry.isDirectory())
1: 				{
1: 					if (!removeDirectory(entry))
1: 						return false;
1: 				}
1: 				else
1: 				{
1: 					if (!entry.delete())
1: 						return false;
1: 				}
1: 			}
1: 		}
1: 
1: 		return directory.delete();
1: 	}
1: 
0: 	public static boolean removeDirectory(String directory)
1: 	{
0: 	    return removeDirectory(new File(directory));
1: 	}
1: 
1: 	/**
0: 	  Copy a directory and all of its contents.
1: 	  */
0: 	public static boolean copyDirectory(File from, File to)
1: 	{
0: 		return copyDirectory(from, to, (byte[])null, (String[])null);
1: 	}
1: 
0: 	public static boolean copyDirectory(String from, String to)
1: 	{
0: 		return copyDirectory(new File(from), new File(to));
1: 	}
1: 
1: 	/**
0: 		@param filter - array of names to not copy.
1: 	*/
0: 	public static boolean copyDirectory(File from, File to, byte[] buffer, 
1: 										String[] filter)
1: 	{
0: 		//
0: 		// System.out.println("copyDirectory("+from+","+to+")");		
1: 
1: 		if (from == null)
1: 			return false;
1: 		if (!from.exists())
1: 			return true;
1: 		if (!from.isDirectory())
1: 			return false;
1: 
1: 		if (to.exists())
1: 		{
1: 			//			System.out.println(to + " exists");
1: 			return false;
1: 		}
1: 		if (!to.mkdirs())
1: 		{
1: 			//			System.out.println("can't make" + to);
1: 			return false;
1: 		}			
1: 
1: 		String[] list = from.list();
1: 
1: 		// Some JVMs return null for File.list() when the
1: 		// directory is empty.
1: 		if (list != null) {
1: 
1: 			if (buffer == null)
1: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1: 
0: nextFile:	for (int i = 0; i < list.length; i++) {
1: 
1: 				String fileName = list[i];
1: 
1: 				if (filter != null) {
1: 					for (int j = 0; j < filter.length; j++) {
1: 						if (fileName.equals(filter[j]))
1: 							continue nextFile;
1: 					}
1: 				}
1: 
1: 
1: 				File entry = new File(from, fileName);
1: 
0: 				//				System.out.println("\tcopying entry " + entry);
1: 
1: 				if (entry.isDirectory())
1: 				{
0: 					if (!copyDirectory(entry,new File(to,fileName),buffer,filter))
1: 						return false;
1: 				}
1: 				else
1: 				{
0: 					if (!copyFile(entry,new File(to,fileName),buffer))
1: 						return false;
1: 				}
1: 			}
1: 		}
1: 		return true;
1: 	}		
1: 
0: 	public static boolean copyFile(File from, File to)
1: 	{
0: 		return copyFile(from, to, (byte[])null);
1: 	}
1: 
1: 	public static boolean copyFile(File from, File to, byte[] buf)
1: 	{
1: 		if (buf == null)
1: 			buf = new byte[BUFFER_SIZE];
1: 
0: 		//
1: 		//		System.out.println("Copy file ("+from+","+to+")");
1: 		FileInputStream from_s = null;
1: 		FileOutputStream to_s = null;
1: 
0: 		try {
1: 			from_s = new FileInputStream(from);
1: 			to_s = new FileOutputStream(to);
1: 
1: 			for (int bytesRead = from_s.read(buf);
1: 				 bytesRead != -1;
1: 				 bytesRead = from_s.read(buf))
1: 				to_s.write(buf,0,bytesRead);
1: 
1: 			from_s.close();
1: 			from_s = null;
1: 
1: 			to_s.getFD().sync();  // RESOLVE: sync or no sync?
1: 			to_s.close();
1: 			to_s = null;
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			return false;
1: 		}
1: 		finally
1: 		{
1: 			if (from_s != null)
1: 			{
1: 				try { from_s.close(); }
1: 				catch (IOException ioe) {}
1: 			}
1: 			if (to_s != null)
1: 			{
1: 				try { to_s.close(); }
1: 				catch (IOException ioe) {}
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1:     public static boolean copyDirectory( StorageFactory storageFactory,
1:                                          StorageFile from,
0:                                          File to)
1:     {
1:         return copyDirectory( storageFactory, from, to, null, null);
1:     }
1:     
1:     public static boolean copyDirectory( StorageFactory storageFactory,
1:                                          StorageFile from,
1:                                          File to,
1:                                          byte[] buffer,
1:                                          String[] filter)
1:     {
1: 		if (from == null)
1: 			return false;
1: 		if (!from.exists())
1: 			return true;
1: 		if (!from.isDirectory())
1: 			return false;
1: 
1: 		if (to.exists())
1: 		{
1: 			//			System.out.println(to + " exists");
1: 			return false;
1: 		}
1: 		if (!to.mkdirs())
1: 		{
1: 			//			System.out.println("can't make" + to);
1: 			return false;
1: 		}			
1: 
1: 		String[] list = from.list();
1: 
1: 		// Some JVMs return null for File.list() when the
1: 		// directory is empty.
1: 		if (list != null)
1:         {
1: 			if (buffer == null)
1: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1: 
1:           nextFile:
1:             for (int i = 0; i < list.length; i++)
1:             {
1: 				String fileName = list[i];
1: 
1: 				if (filter != null) {
1: 					for (int j = 0; j < filter.length; j++) {
1: 						if (fileName.equals(filter[j]))
1: 							continue nextFile;
1: 					}
1: 				}
1: 
1: 				StorageFile entry = storageFactory.newStorageFile(from, fileName);
1: 
1: 				if (entry.isDirectory())
1: 				{
0: 					if (!copyDirectory( storageFactory, entry, new File(to,fileName), buffer, filter))
1: 						return false;
1: 				}
1: 				else
1: 				{
1: 					if (!copyFile( storageFactory, entry, new File(to,fileName), buffer))
1: 						return false;
1: 				}
1: 			}
1: 		}
1: 		return true;
1: 	} // end of copyDirectory( StorageFactory sf, StorageFile from, File to, byte[] buf, String[] filter)
1: 
1:     public static boolean copyFile( StorageFactory storageFactory, StorageFile from, File to)
1:     {
1:         return copyFile( storageFactory, from, to, (byte[]) null);
1:     }
1:     
1: 	public static boolean copyFile( StorageFactory storageFactory, StorageFile from, File to, byte[] buf)
1: 	{
1: 		InputStream from_s = null;
1: 		FileOutputStream to_s = null;
1: 
0: 		try {
1: 			from_s = from.getInputStream();
1: 			to_s = new FileOutputStream( to);
1: 
1: 			if (buf == null)
1: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1: 
1: 			for (int bytesRead = from_s.read(buf);
1: 				 bytesRead != -1;
1: 				 bytesRead = from_s.read(buf))
1: 				to_s.write(buf,0,bytesRead);
1: 
1: 			from_s.close();
1: 			from_s = null;
1: 
1: 			to_s.getFD().sync();  // RESOLVE: sync or no sync?
1: 			to_s.close();
1: 			to_s = null;
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			return false;
1: 		}
1: 		finally
1: 		{
1: 			if (from_s != null)
1: 			{
1: 				try { from_s.close(); }
1: 				catch (IOException ioe) {}
1: 			}
1: 			if (to_s != null)
1: 			{
1: 				try { to_s.close(); }
1: 				catch (IOException ioe) {}
1: 			}
1: 		}
1: 
1: 		return true;
1: 	} // end of copyFile( StorageFactory storageFactory, StorageFile from, File to, byte[] buf)
1: 
1:     public static boolean copyDirectory( WritableStorageFactory storageFactory,
1:                                          File from,
1:                                          StorageFile to)
1:     {
1:         return copyDirectory( storageFactory, from, to, null, null);
1:     }
1:     
1:     public static boolean copyDirectory( WritableStorageFactory storageFactory,
1:                                          File from,
1:                                          StorageFile to,
1:                                          byte[] buffer,
1:                                          String[] filter)
1:     {
1: 		if (from == null)
1: 			return false;
1: 		if (!from.exists())
1: 			return true;
1: 		if (!from.isDirectory())
1: 			return false;
1: 
1: 		if (to.exists())
1: 		{
1: 			//			System.out.println(to + " exists");
1: 			return false;
1: 		}
1: 		if (!to.mkdirs())
1: 		{
1: 			//			System.out.println("can't make" + to);
1: 			return false;
1: 		}			
1: 
1: 		String[] list = from.list();
1: 
1: 		// Some JVMs return null for File.list() when the
1: 		// directory is empty.
1: 		if (list != null)
1:         {
1: 			if (buffer == null)
1: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1: 
1:           nextFile:
1:             for (int i = 0; i < list.length; i++)
1:             {
1: 				String fileName = list[i];
1: 
1: 				if (filter != null) {
1: 					for (int j = 0; j < filter.length; j++) {
1: 						if (fileName.equals(filter[j]))
1: 							continue nextFile;
1: 					}
1: 				}
1: 
1: 				File entry = new File(from, fileName);
1: 
1: 				if (entry.isDirectory())
1: 				{
1: 					if (!copyDirectory( storageFactory, entry, storageFactory.newStorageFile(to,fileName), buffer, filter))
1: 						return false;
1: 				}
1: 				else
1: 				{
1: 					if (!copyFile( storageFactory, entry, storageFactory.newStorageFile(to,fileName), buffer))
1: 						return false;
1: 				}
1: 			}
1: 		}
1: 		return true;
1: 	} // end of copyDirectory( StorageFactory sf, StorageFile from, File to, byte[] buf, String[] filter)
1: 
1:     public static boolean copyFile( WritableStorageFactory storageFactory, File from, StorageFile to)
1:     {
1:         return copyFile( storageFactory, from, to, (byte[]) null);
1:     }
1:     
1: 	public static boolean copyFile( WritableStorageFactory storageFactory, File from, StorageFile to, byte[] buf)
1: 	{
1: 		InputStream from_s = null;
1: 		OutputStream to_s = null;
1: 
0: 		try {
1: 			from_s = new FileInputStream( from);
1: 			to_s = to.getOutputStream();
1: 
1: 			if (buf == null)
1: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
1: 
1: 			for (int bytesRead = from_s.read(buf);
1: 				 bytesRead != -1;
1: 				 bytesRead = from_s.read(buf))
1: 				to_s.write(buf,0,bytesRead);
1: 
1: 			from_s.close();
1: 			from_s = null;
1: 
1: 			storageFactory.sync( to_s, false);  // RESOLVE: sync or no sync?
1: 			to_s.close();
1: 			to_s = null;
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			return false;
1: 		}
1: 		finally
1: 		{
1: 			if (from_s != null)
1: 			{
1: 				try { from_s.close(); }
1: 				catch (IOException ioe) {}
1: 			}
1: 			if (to_s != null)
1: 			{
1: 				try { to_s.close(); }
1: 				catch (IOException ioe) {}
1: 			}
1: 		}
1: 
1: 		return true;
1: 	} // end of copyFile
1: 
1: 	/**
0: 		Convert a file path into a File object with an absolute path
0: 		relative to a passed in root. If path is absolute then
0: 		a file object constructed from new File(path) is returned,
0: 		otherwise a file object is returned from new File(root, path)
0: 		if root is not null, otherwise null is returned.
1: 	*/
0: 	public static File getAbsoluteFile(File root, String path) {
0: 		File file = new File(path);
0: 		if (file.isAbsolute())
0: 			return file;
1: 
0: 		if (root == null)
0: 			return null;
1: 
0: 		return new File(root, path);
1: 	}
1: 
1: 	/**
0: 		A replacement for new File(File, String) that correctly implements
0: 		the case when the first argument is null. The documentation for java.io.File
0: 		says that new File((File) null, name) is the same as new File(name).
0: 		This is not the case in pre 1.1.8 vms, a NullPointerException is thrown instead.
1: 	*/
0: 	public static File newFile(File parent, String name) {
1: 
0: 		if (parent == null)
0: 			return new File(name);
1: 		else
0: 			return new File(parent, name);
1: 	}
1: 
1: 	/**
0: 	 * Open an input stream to read a file or a URL
0: 	 * @param fileOrURL	The file or URL to open.
0: 	 * @param bufferSize 0 => no buffering.
0: 	 * @return	an InputStream
0: 	 * @exception StandardException	Thrown on failure
1: 	 */
0: 	public static InputStream getInputStream(String fileOrURL,int bufferSize)
0: 		 throws IOException
1: 	{
0: 		InputStream is;
0: 		try {
0: 			is = new FileInputStream( fileOrURL );
1: 		}
1: 
0: 		catch (FileNotFoundException fnfe){
0: 			try {
0: 				is = new URL( fileOrURL ).openStream();
0: 			} catch (MalformedURLException mfurle) {
1: 
0: 				// if it looks like an url throw this exception
0: 				// otherwise throw the file not found exception
0: 				// If there is no : or an early colon then it's
0: 				// probably a file (e.g. /foo/myjar.jar or a:/foo/myjar.jar)
0: 				if (fileOrURL.indexOf(':') > 2)
0: 					throw mfurle;
0: 				throw fnfe;
1: 			}
1: 		}
0: 		if (bufferSize > 0)
0: 			is = new BufferedInputStream(is,bufferSize);
1: 
0: 		return is;
1: 	}
1: }
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:047a763
/////////////////////////////////////////////////////////////////////////
0: 
1:     public static boolean copyFile( WritableStorageFactory storageFactory, 
1:                                     StorageFile from, StorageFile to)
0:     {
0:         return copyFile( storageFactory, from, to, (byte[]) null);
0:     }
0:     
1: 	public static boolean copyFile( WritableStorageFactory storageFactory, 
0:                                     StorageFile from, StorageFile to, 
0:                                     byte[] buf)
0: 	{
1: 		InputStream from_s = null;
1: 		OutputStream to_s = null;
0: 
0: 		try {
1: 			from_s = from.getInputStream();
1: 			to_s = to.getOutputStream();
0: 
0: 			if (buf == null)
0: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
0: 
1: 			for (int bytesRead = from_s.read(buf);
1: 				 bytesRead != -1;
1: 				 bytesRead = from_s.read(buf))
1: 				to_s.write(buf,0,bytesRead);
0: 
1: 			from_s.close();
1: 			from_s = null;
0: 
1: 			storageFactory.sync( to_s, false);  // RESOLVE: sync or no sync?
1: 			to_s.close();
1: 			to_s = null;
0: 		}
1: 		catch (IOException ioe)
0: 		{
0: 			return false;
0: 		}
1: 		finally
0: 		{
1: 			if (from_s != null)
0: 			{
1: 				try { from_s.close(); }
1: 				catch (IOException ioe) {}
0: 			}
1: 			if (to_s != null)
0: 			{
1: 				try { to_s.close(); }
1: 				catch (IOException ioe) {}
0: 			}
0: 		}
0: 
0: 		return true;
1: 	} // end of copyFile
0: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c10c404
/////////////////////////////////////////////////////////////////////////
0:         return copyDirectory( storageFactory, from, to, null, null, true);
0: 
1:                                          String[] filter, 
1:                                          boolean copySubDirs)
/////////////////////////////////////////////////////////////////////////
1:                     if(copySubDirs) {
1:                         if (!copyDirectory( storageFactory, entry, 
1:                                             new File(to,fileName), buffer, 
1:                                             filter, copySubDirs))
0:                             return false;
0:                     }
1:                     else {
1:                         // the request is to not copy the directories, continue
1:                         // to the next file in the list.
0:                         continue nextFile;
0:                     }
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.io;
0: 
0: import org.apache.derby.io.StorageFactory;
0: import org.apache.derby.io.WritableStorageFactory;
0: import org.apache.derby.io.StorageFile;
0: 
0: import java.io.*;
0: import java.net.*;
0: 
0: /**
0: 	A set of public static methods for dealing with File objects.
0: */
0: public abstract class FileUtil {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:     private static final int BUFFER_SIZE = 4096*4;
0: 	/**
0: 		Remove a directory and all of its contents.
0: 
0: 		The results of executing File.delete() on a File object
0: 		that represents a directory seems to be platform
0: 		dependent. This method removes the directory
0: 		and all of its contents.
0: 
0: 		@return true if the complete directory was removed, false if it could not be.
0: 		If false is returned then some of the files in the directory may have been removed.
0: 
0: 	*/
0: 	public static boolean removeDirectory(File directory) {
0: 
0: 		// System.out.println("removeDirectory " + directory);
0: 
0: 		if (directory == null)
0: 			return false;
0: 		if (!directory.exists())
0: 			return true;
0: 		if (!directory.isDirectory())
0: 			return false;
0: 
0: 		String[] list = directory.list();
0: 
0: 		// Some JVMs return null for File.list() when the
0: 		// directory is empty.
0: 		if (list != null) {
0: 			for (int i = 0; i < list.length; i++) {
0: 				File entry = new File(directory, list[i]);
0: 
0: 				//				System.out.println("\tremoving entry " + entry);
0: 
0: 				if (entry.isDirectory())
0: 				{
0: 					if (!removeDirectory(entry))
0: 						return false;
0: 				}
0: 				else
0: 				{
0: 					if (!entry.delete())
0: 						return false;
0: 				}
0: 			}
0: 		}
0: 
0: 		return directory.delete();
0: 	}
0: 
0: 	public static boolean removeDirectory(String directory)
0: 	{
0: 	    return removeDirectory(new File(directory));
0: 	}
0: 
0: 	/**
0: 	  Copy a directory and all of its contents.
0: 	  */
0: 	public static boolean copyDirectory(File from, File to)
0: 	{
0: 		return copyDirectory(from, to, (byte[])null, (String[])null);
0: 	}
0: 
0: 	public static boolean copyDirectory(String from, String to)
0: 	{
0: 		return copyDirectory(new File(from), new File(to));
0: 	}
0: 
0: 	/**
0: 		@param filter - array of names to not copy.
0: 	*/
0: 	public static boolean copyDirectory(File from, File to, byte[] buffer, 
0: 										String[] filter)
0: 	{
0: 		//
0: 		// System.out.println("copyDirectory("+from+","+to+")");		
0: 
0: 		if (from == null)
0: 			return false;
0: 		if (!from.exists())
0: 			return true;
0: 		if (!from.isDirectory())
0: 			return false;
0: 
0: 		if (to.exists())
0: 		{
0: 			//			System.out.println(to + " exists");
0: 			return false;
0: 		}
0: 		if (!to.mkdirs())
0: 		{
0: 			//			System.out.println("can't make" + to);
0: 			return false;
0: 		}			
0: 
0: 		String[] list = from.list();
0: 
0: 		// Some JVMs return null for File.list() when the
0: 		// directory is empty.
0: 		if (list != null) {
0: 
0: 			if (buffer == null)
0: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
0: 
0: nextFile:	for (int i = 0; i < list.length; i++) {
0: 
0: 				String fileName = list[i];
0: 
0: 				if (filter != null) {
0: 					for (int j = 0; j < filter.length; j++) {
0: 						if (fileName.equals(filter[j]))
0: 							continue nextFile;
0: 					}
0: 				}
0: 
0: 
0: 				File entry = new File(from, fileName);
0: 
0: 				//				System.out.println("\tcopying entry " + entry);
0: 
0: 				if (entry.isDirectory())
0: 				{
0: 					if (!copyDirectory(entry,new File(to,fileName),buffer,filter))
0: 						return false;
0: 				}
0: 				else
0: 				{
0: 					if (!copyFile(entry,new File(to,fileName),buffer))
0: 						return false;
0: 				}
0: 			}
0: 		}
0: 		return true;
0: 	}		
0: 
0: 	public static boolean copyFile(File from, File to)
0: 	{
0: 		return copyFile(from, to, (byte[])null);
0: 	}
0: 
0: 	public static boolean copyFile(File from, File to, byte[] buf)
0: 	{
0: 		if (buf == null)
0: 			buf = new byte[BUFFER_SIZE];
0: 
0: 		//
0: 		//		System.out.println("Copy file ("+from+","+to+")");
0: 		FileInputStream from_s = null;
0: 		FileOutputStream to_s = null;
0: 
0: 		try {
0: 			from_s = new FileInputStream(from);
0: 			to_s = new FileOutputStream(to);
0: 
0: 			for (int bytesRead = from_s.read(buf);
0: 				 bytesRead != -1;
0: 				 bytesRead = from_s.read(buf))
0: 				to_s.write(buf,0,bytesRead);
0: 
0: 			from_s.close();
0: 			from_s = null;
0: 
0: 			to_s.getFD().sync();  // RESOLVE: sync or no sync?
0: 			to_s.close();
0: 			to_s = null;
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			return false;
0: 		}
0: 		finally
0: 		{
0: 			if (from_s != null)
0: 			{
0: 				try { from_s.close(); }
0: 				catch (IOException ioe) {}
0: 			}
0: 			if (to_s != null)
0: 			{
0: 				try { to_s.close(); }
0: 				catch (IOException ioe) {}
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0:     public static boolean copyDirectory( StorageFactory storageFactory,
0:                                          StorageFile from,
0:                                          File to)
0:     {
0:         return copyDirectory( storageFactory, from, to, null, null);
0:     }
0:     
0:     public static boolean copyDirectory( StorageFactory storageFactory,
0:                                          StorageFile from,
0:                                          File to,
0:                                          byte[] buffer,
0:                                          String[] filter)
0:     {
0: 		if (from == null)
0: 			return false;
0: 		if (!from.exists())
0: 			return true;
0: 		if (!from.isDirectory())
0: 			return false;
0: 
0: 		if (to.exists())
0: 		{
0: 			//			System.out.println(to + " exists");
0: 			return false;
0: 		}
0: 		if (!to.mkdirs())
0: 		{
0: 			//			System.out.println("can't make" + to);
0: 			return false;
0: 		}			
0: 
0: 		String[] list = from.list();
0: 
0: 		// Some JVMs return null for File.list() when the
0: 		// directory is empty.
0: 		if (list != null)
0:         {
0: 			if (buffer == null)
0: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
0: 
0:           nextFile:
0:             for (int i = 0; i < list.length; i++)
0:             {
0: 				String fileName = list[i];
0: 
0: 				if (filter != null) {
0: 					for (int j = 0; j < filter.length; j++) {
0: 						if (fileName.equals(filter[j]))
0: 							continue nextFile;
0: 					}
0: 				}
0: 
0: 				StorageFile entry = storageFactory.newStorageFile(from, fileName);
0: 
0: 				if (entry.isDirectory())
0: 				{
0: 					if (!copyDirectory( storageFactory, entry, new File(to,fileName), buffer, filter))
0: 						return false;
0: 				}
0: 				else
0: 				{
0: 					if (!copyFile( storageFactory, entry, new File(to,fileName), buffer))
0: 						return false;
0: 				}
0: 			}
0: 		}
0: 		return true;
0: 	} // end of copyDirectory( StorageFactory sf, StorageFile from, File to, byte[] buf, String[] filter)
0: 
0:     public static boolean copyFile( StorageFactory storageFactory, StorageFile from, File to)
0:     {
0:         return copyFile( storageFactory, from, to, (byte[]) null);
0:     }
0:     
0: 	public static boolean copyFile( StorageFactory storageFactory, StorageFile from, File to, byte[] buf)
0: 	{
0: 		InputStream from_s = null;
0: 		FileOutputStream to_s = null;
0: 
0: 		try {
0: 			from_s = from.getInputStream();
0: 			to_s = new FileOutputStream( to);
0: 
0: 			if (buf == null)
0: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
0: 
0: 			for (int bytesRead = from_s.read(buf);
0: 				 bytesRead != -1;
0: 				 bytesRead = from_s.read(buf))
0: 				to_s.write(buf,0,bytesRead);
0: 
0: 			from_s.close();
0: 			from_s = null;
0: 
0: 			to_s.getFD().sync();  // RESOLVE: sync or no sync?
0: 			to_s.close();
0: 			to_s = null;
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			return false;
0: 		}
0: 		finally
0: 		{
0: 			if (from_s != null)
0: 			{
0: 				try { from_s.close(); }
0: 				catch (IOException ioe) {}
0: 			}
0: 			if (to_s != null)
0: 			{
0: 				try { to_s.close(); }
0: 				catch (IOException ioe) {}
0: 			}
0: 		}
0: 
0: 		return true;
0: 	} // end of copyFile( StorageFactory storageFactory, StorageFile from, File to, byte[] buf)
0: 
0:     public static boolean copyDirectory( WritableStorageFactory storageFactory,
0:                                          File from,
0:                                          StorageFile to)
0:     {
0:         return copyDirectory( storageFactory, from, to, null, null);
0:     }
0:     
0:     public static boolean copyDirectory( WritableStorageFactory storageFactory,
0:                                          File from,
0:                                          StorageFile to,
0:                                          byte[] buffer,
0:                                          String[] filter)
0:     {
0: 		if (from == null)
0: 			return false;
0: 		if (!from.exists())
0: 			return true;
0: 		if (!from.isDirectory())
0: 			return false;
0: 
0: 		if (to.exists())
0: 		{
0: 			//			System.out.println(to + " exists");
0: 			return false;
0: 		}
0: 		if (!to.mkdirs())
0: 		{
0: 			//			System.out.println("can't make" + to);
0: 			return false;
0: 		}			
0: 
0: 		String[] list = from.list();
0: 
0: 		// Some JVMs return null for File.list() when the
0: 		// directory is empty.
0: 		if (list != null)
0:         {
0: 			if (buffer == null)
0: 				buffer = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
0: 
0:           nextFile:
0:             for (int i = 0; i < list.length; i++)
0:             {
0: 				String fileName = list[i];
0: 
0: 				if (filter != null) {
0: 					for (int j = 0; j < filter.length; j++) {
0: 						if (fileName.equals(filter[j]))
0: 							continue nextFile;
0: 					}
0: 				}
0: 
0: 				File entry = new File(from, fileName);
0: 
0: 				if (entry.isDirectory())
0: 				{
0: 					if (!copyDirectory( storageFactory, entry, storageFactory.newStorageFile(to,fileName), buffer, filter))
0: 						return false;
0: 				}
0: 				else
0: 				{
0: 					if (!copyFile( storageFactory, entry, storageFactory.newStorageFile(to,fileName), buffer))
0: 						return false;
0: 				}
0: 			}
0: 		}
0: 		return true;
0: 	} // end of copyDirectory( StorageFactory sf, StorageFile from, File to, byte[] buf, String[] filter)
0: 
0:     public static boolean copyFile( WritableStorageFactory storageFactory, File from, StorageFile to)
0:     {
0:         return copyFile( storageFactory, from, to, (byte[]) null);
0:     }
0:     
0: 	public static boolean copyFile( WritableStorageFactory storageFactory, File from, StorageFile to, byte[] buf)
0: 	{
0: 		InputStream from_s = null;
0: 		OutputStream to_s = null;
0: 
0: 		try {
0: 			from_s = new FileInputStream( from);
0: 			to_s = to.getOutputStream();
0: 
0: 			if (buf == null)
0: 				buf = new byte[BUFFER_SIZE]; // reuse this buffer to copy files
0: 
0: 			for (int bytesRead = from_s.read(buf);
0: 				 bytesRead != -1;
0: 				 bytesRead = from_s.read(buf))
0: 				to_s.write(buf,0,bytesRead);
0: 
0: 			from_s.close();
0: 			from_s = null;
0: 
0: 			storageFactory.sync( to_s, false);  // RESOLVE: sync or no sync?
0: 			to_s.close();
0: 			to_s = null;
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			return false;
0: 		}
0: 		finally
0: 		{
0: 			if (from_s != null)
0: 			{
0: 				try { from_s.close(); }
0: 				catch (IOException ioe) {}
0: 			}
0: 			if (to_s != null)
0: 			{
0: 				try { to_s.close(); }
0: 				catch (IOException ioe) {}
0: 			}
0: 		}
0: 
0: 		return true;
0: 	} // end of copyFile
0: 
0: 	/**
0: 		Convert a file path into a File object with an absolute path
0: 		relative to a passed in root. If path is absolute then
0: 		a file object constructed from new File(path) is returned,
0: 		otherwise a file object is returned from new File(root, path)
0: 		if root is not null, otherwise null is returned.
0: 	*/
0: 	public static File getAbsoluteFile(File root, String path) {
0: 		File file = new File(path);
0: 		if (file.isAbsolute())
0: 			return file;
0: 
0: 		if (root == null)
0: 			return null;
0: 
0: 		return new File(root, path);
0: 	}
0: 
0: 	/**
0: 		A replacement for new File(File, String) that correctly implements
0: 		the case when the first argument is null. The documentation for java.io.File
0: 		says that new File((File) null, name) is the same as new File(name).
0: 		This is not the case in pre 1.1.8 vms, a NullPointerException is thrown instead.
0: 	*/
0: 	public static File newFile(File parent, String name) {
0: 
0: 		if (parent == null)
0: 			return new File(name);
0: 		else
0: 			return new File(parent, name);
0: 	}
0: 
0: 	/**
0: 	 * Open an input stream to read a file or a URL
0: 	 * @param fileOrURL	The file or URL to open.
0: 	 * @param bufferSize 0 => no buffering.
0: 	 * @return	an InputStream
0: 	 * @exception StandardException	Thrown on failure
0: 	 */
0: 	public static InputStream getInputStream(String fileOrURL,int bufferSize)
0: 		 throws IOException
0: 	{
0: 		InputStream is;
0: 		try {
0: 			is = new FileInputStream( fileOrURL );
0: 		}
0: 
0: 		catch (FileNotFoundException fnfe){
0: 			try {
0: 				is = new URL( fileOrURL ).openStream();
0: 			} catch (MalformedURLException mfurle) {
0: 
0: 				// if it looks like an url throw this exception
0: 				// otherwise throw the file not found exception
0: 				// If there is no : or an early colon then it's
0: 				// probably a file (e.g. /foo/myjar.jar or a:/foo/myjar.jar)
0: 				if (fileOrURL.indexOf(':') > 2)
0: 					throw mfurle;
0: 				throw fnfe;
0: 			}
0: 		}
0: 		if (bufferSize > 0)
0: 			is = new BufferedInputStream(is,bufferSize);
0: 
0: 		return is;
0: 	}
0: }
============================================================================