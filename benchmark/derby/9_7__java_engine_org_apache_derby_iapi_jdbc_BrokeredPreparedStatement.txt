1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.jdbc.BrokeredPreparedStatement
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.jdbc;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.Reader;
1:f44e479: import java.net.URL;
1:f44e479: import java.sql.*;
1:eac0369: import java.util.Calendar;
1:eac0369: 
2:eac0369: /**
1:863daa0:  * A brokered {@code PreparedStatement} that forwards calls off to a real
1:863daa0:  * {@code PreparedStatement} obtained through the
1:863daa0:  * {@link BrokeredStatementControl#getRealPreparedStatement} method.
1:863daa0:  * This class implements the JDBC 4.1 interface.
1:eac0369:  */
1:863daa0: public class BrokeredPreparedStatement extends BrokeredStatement
1:aadfd42: 	implements EnginePreparedStatement
1:eac0369: {
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		SQL used to create me.
1:eac0369: 	*/
1:e65be5b: 	final String	sql;
1:eac0369: 
1:f44e479:     /**
1:f44e479:      * An Integer, an int array or a String array that specifies generated
1:f44e479:      * key columns, or null if there are no generated key columns.
1:f44e479:      */
1:f44e479:     private final Object generatedKeys;
1:f44e479: 
1:f44e479:     public BrokeredPreparedStatement(BrokeredStatementControl control,
1:f44e479:             String sql, Object generatedKeys) throws SQLException
1:eac0369:     {
1:3be5c9d:         super(control);
1:eac0369: 		this.sql = sql;
1:f44e479:         this.generatedKeys = generatedKeys;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * A prepared SQL query is executed and its ResultSet is returned.
1:eac0369:      *
1:eac0369:      * @return a ResultSet that contains the data produced by the
1:eac0369:      * query; never null
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final ResultSet executeQuery() throws SQLException
1:eac0369:     {
1:eac0369:         return wrapResultSet(getPreparedStatement().executeQuery());
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:eac0369:      * SQL statements that return nothing such as SQL DDL statements
1:eac0369:      * can be executed.
1:eac0369:      *
1:eac0369:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:eac0369:      * for SQL statements that return nothing
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final int executeUpdate() throws SQLException
1:eac0369:     {
1:eac0369:         return getPreparedStatement().executeUpdate();
1:eac0369:     }
1:eac0369: 
1:f44e479:     @Override
1:5b78c4e: 	public void close() throws SQLException
1:5b78c4e: 	{
1:5b78c4e: 	    control.closeRealPreparedStatement();
1:5b78c4e: 	}
1:5b78c4e: 	
1:eac0369:     /**
1:eac0369:      * Set a parameter to SQL NULL.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> You must specify the parameter's SQL type.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param sqlType SQL type code defined by java.sql.Types
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setNull(int parameterIndex, int sqlType) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setNull( parameterIndex, sqlType);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to SQL NULL.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> You must specify the parameter's SQL type.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param sqlType SQL type code defined by java.sql.Types
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setNull( parameterIndex, sqlType, typeName);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java boolean value.  According to the JDBC API spec,
1:eac0369: 	 * the driver converts this to a SQL BIT value when it sends it to the
1:eac0369: 	 * database. But we don't have to do this, since the database engine
1:eac0369: 	 * supports a boolean type.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setBoolean(int parameterIndex, boolean x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setBoolean( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java byte value.  The driver converts this
1:eac0369:      * to a SQL TINYINT value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setByte(int parameterIndex, byte x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setByte( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java short value.  The driver converts this
1:eac0369:      * to a SQL SMALLINT value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setShort(int parameterIndex, short x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setShort( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java int value.  The driver converts this
1:eac0369:      * to a SQL INTEGER value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setInt(int parameterIndex, int x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setInt( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java long value.  The driver converts this
1:eac0369:      * to a SQL BIGINT value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setLong(int parameterIndex, long x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setLong( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java float value.  The driver converts this
1:eac0369:      * to a SQL FLOAT value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setFloat(int parameterIndex, float x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setFloat( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java double value.  The driver converts this
1:eac0369:      * to a SQL DOUBLE value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setDouble(int parameterIndex, double x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setDouble( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.math.BigDecimal value.  
1:eac0369:      * The driver converts this to a SQL NUMERIC value when
1:eac0369:      * it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setBigDecimal( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java String value.  The driver converts this
1:eac0369:      * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
1:eac0369:      * size relative to the driver's limits on VARCHARs) when it sends
1:eac0369:      * it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setString(int parameterIndex, String x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setString( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java array of bytes.  The driver converts
1:eac0369:      * this to a SQL VARBINARY or LONGVARBINARY (depending on the
1:eac0369:      * argument's size relative to the driver's limits on VARBINARYs)
1:eac0369:      * when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setBytes(int parameterIndex, byte[] x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setBytes( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Date value.  The driver converts this
1:eac0369:      * to a SQL DATE value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setDate(int parameterIndex, Date x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setDate( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Time value.  The driver converts this
1:eac0369:      * to a SQL TIME value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setTime(int parameterIndex, Time x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setTime( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Timestamp value.  The driver
1:eac0369:      * converts this to a SQL TIMESTAMP value when it sends it to the
1:eac0369:      * database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setTimestamp(int parameterIndex, Timestamp x) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setTimestamp( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * We do this inefficiently and read it all in here. The target type
1:eac0369: 	 * is assumed to be a String.
1:eac0369:      * 
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the java input stream which contains the ASCII parameter value
1:eac0369:      * @param length the number of bytes in the stream 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setAsciiStream( parameterIndex, x, length);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * We do this inefficiently and read it all in here. The target type
1:eac0369: 	 * is assumed to be a String. The unicode source is assumed to be
1:eac0369: 	 * in char[].  RESOLVE: might it be in UTF, instead? that'd be faster!
1:eac0369:      * 
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...  
1:eac0369:      * @param x the java input stream which contains the
1:eac0369:      * UNICODE parameter value 
1:eac0369:      * @param length the number of bytes in the stream 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:e24d8ef:      * @deprecated
1:eac0369:      */
1:eac0369:     public final void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setUnicodeStream( parameterIndex, x, length);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the java input stream which contains the binary parameter value
1:eac0369:      * @param length the number of bytes in the stream 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setBinaryStream( parameterIndex, x, length);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Add a set of parameters to the batch.
1:eac0369:      * 
1:eac0369:      * @exception SQLException if a database-access error occurs.
1:eac0369:      */
1:eac0369:     public final void addBatch() throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().addBatch( );
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * <P>In general, parameter values remain in force for repeated use of a
1:eac0369:      * Statement. Setting a parameter value automatically clears its
1:eac0369:      * previous value.  However, in some cases it is useful to immediately
1:eac0369:      * release the resources used by the current parameter values; this can
1:eac0369:      * be done by calling clearParameters.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void clearParameters() throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().clearParameters( );
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * JDBC 2.0
1:eac0369: 	 *
1:eac0369:      * The number, types and properties of a ResultSet's columns
1:eac0369:      * are provided by the getMetaData method.
1:eac0369:      *
1:eac0369:      * @return the description of a ResultSet's columns
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369: 	public final java.sql.ResultSetMetaData getMetaData() throws SQLException
1:eac0369:     {
1:eac0369:         return getPreparedStatement().getMetaData();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * The interface says that the type of the Object parameter must
1:eac0369: 	 * be compatible with the type of the targetSqlType. We check that,
1:eac0369: 	 * and if it flies, we expect the underlying engine to do the
1:eac0369: 	 * required conversion once we pass in the value using its type.
1:eac0369: 	 * So, an Integer converting to a CHAR is done via setInteger()
1:eac0369: 	 * support on the underlying CHAR type.
1:eac0369:      *
1:eac0369:      * <p>If x is null, it won't tell us its type, so we pass it on to setNull
1:eac0369:      *
1:eac0369:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:eac0369:      * @param x The object containing the input parameter value
1:eac0369:      * @param targetSqlType The SQL type (as defined in java.sql.Types) to be 
1:eac0369:      * sent to the database. The scale argument may further qualify this type.
1:eac0369:      * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
1:eac0369:      *          this is the number of digits after the decimal.  For all other
1:eac0369:      *          types this value will be ignored,
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setObject( parameterIndex, x, targetSqlType, scale);
1:eac0369:     } 
1:eac0369:         
1:eac0369:     /**
1:eac0369:       * This method is like setObject above, but assumes a scale of zero.
1:eac0369:       * @exception SQLException thrown on failure.
1:eac0369:       */
1:eac0369:     public final void setObject(int parameterIndex, Object x, int targetSqlType)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setObject( parameterIndex, x, targetSqlType);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * <p>Set the value of a parameter using an object; use the
1:eac0369:      * java.lang equivalent objects for integral values.
1:eac0369:      *
1:eac0369:      * <p>The JDBC specification specifies a standard mapping from
1:eac0369:      * Java Object types to SQL types.  The given argument java object
1:eac0369:      * will be converted to the corresponding SQL type before being
1:eac0369:      * sent to the database.
1:eac0369:      *
1:eac0369:      * <p>Note that this method may be used to pass datatabase
1:eac0369:      * specific abstract data types, by using a Driver specific Java
1:eac0369:      * type.
1:eac0369:      *
1:eac0369:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:eac0369:      * @param x The object containing the input parameter value 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setObject(int parameterIndex, Object x)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setObject( parameterIndex, x);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * @see java.sql.Statement#execute
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final boolean execute() throws SQLException
1:eac0369:     {
1:eac0369:         return getPreparedStatement().execute();
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setCharacterStream(int parameterIndex,
1:eac0369:                                    Reader reader,
1:eac0369:                                    int length)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setCharacterStream( parameterIndex, reader, length);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setRef(int i,
1:eac0369:                        Ref x)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setRef( i, x);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setBlob(int i,
1:eac0369:                        Blob x)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setBlob( i, x);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setClob(int i,
1:eac0369:                        Clob x)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setClob( i, x);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setArray(int i,
1:eac0369:                          Array x)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setArray( i, x);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setDate(int i,
1:eac0369:                         Date x,
1:eac0369:                         Calendar cal)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setDate( i, x, cal);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setTime(int i,
1:eac0369:                         Time x,
1:eac0369:                         Calendar cal)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setTime( i, x, cal);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setTimestamp(int i,
1:eac0369:                              Timestamp x,
1:eac0369:                              Calendar cal)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getPreparedStatement().setTimestamp( i, x, cal);
1:eac0369:     }
1:eac0369:     
1:20b2fd9:     // JDBC 4.1 methods exposed via the EnginePreparedStatement interface
1:20b2fd9: 
1:20b2fd9:     public long executeLargeUpdate() throws SQLException
1:20b2fd9:     {
1:20b2fd9:         final EnginePreparedStatement engnps = (EnginePreparedStatement) getPreparedStatement();  
1:20b2fd9: 
1:20b2fd9:         return engnps.executeLargeUpdate();
1:20b2fd9:     }    
1:20b2fd9:     
1:fefd864:     public void setBinaryStream(int parameterIndex, 
1:fefd864:                                 InputStream x)
1:fefd864:         throws SQLException {
1:eac0369: 
1:b5f2776:         getPreparedStatement().setBinaryStream(parameterIndex, x);
1:eac0369: 
1:fefd864:     }
1:eac0369:     
8:fefd864:     
1:fefd864:     public void setCharacterStream(int parameterIndex, 
1:fefd864:                                    Reader reader)
1:fefd864:         throws SQLException{
1:fefd864: 
1:b5f2776:         getPreparedStatement().setCharacterStream(parameterIndex, reader);
1:b5f2776: 
1:fefd864:     }
1:fefd864: 
1:f44e479:     // JDBC 3.0 methods
1:f44e479: 
1:f44e479:     public final void setURL(int i, URL x) throws SQLException {
1:f44e479:         getPreparedStatement().setURL(i, x);
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final ParameterMetaData getParameterMetaData() throws SQLException {
1:f44e479:         return getPreparedStatement().getParameterMetaData();
1:f44e479:     }
1:f44e479: 
1:863daa0:     // JDBC 4.0 methods
1:863daa0: 
1:863daa0:     public final void setRowId(int parameterIndex, RowId x)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setRowId(parameterIndex, x);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setNString(int index, String value) throws SQLException {
1:863daa0:         getPreparedStatement().setNString(index, value);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setNCharacterStream(int parameterIndex, Reader value)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setNCharacterStream(parameterIndex, value);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setNCharacterStream(int index, Reader value, long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setNCharacterStream(index, value, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setNClob(int index, NClob value) throws SQLException {
1:863daa0:         getPreparedStatement().setNClob(index, value);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setClob(int parameterIndex, Reader reader, long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setClob(parameterIndex, reader, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setBlob(int parameterIndex, InputStream inputStream,
1:863daa0:                               long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setBlob(parameterIndex, inputStream, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setNClob(int parameterIndex, Reader reader)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setNClob(parameterIndex, reader);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setNClob(int parameterIndex, Reader reader, long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setNClob(parameterIndex, reader, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final void setSQLXML(int parameterIndex, SQLXML xmlObject)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setSQLXML(parameterIndex, xmlObject);
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Sets the designated parameter to the given input stream.
1:863daa0:      *
1:863daa0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:863daa0:      * @param x the Java input stream that contains the ASCII parameter value
1:863daa0:      * @throws SQLException if a database access error occurs or this method is
1:863daa0:      * called on a closed {@code PreparedStatement}
1:863daa0:      */
1:863daa0:     public final void setAsciiStream(int parameterIndex, InputStream x)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setAsciiStream(parameterIndex, x);
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Sets the designated parameter to the given input stream, which will have
1:863daa0:      * the specified number of bytes.
1:863daa0:      *
1:863daa0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:863daa0:      * @param x the java input stream which contains the ASCII parameter value
1:863daa0:      * @param length the number of bytes in the stream
1:863daa0:      * @exception SQLException thrown on failure.
1:863daa0:      *
1:863daa0:      */
1:863daa0:     public final void setAsciiStream(int parameterIndex, InputStream x,
1:863daa0:                                      long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setAsciiStream(parameterIndex, x, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Sets the designated parameter to the given input stream, which will have
1:863daa0:      * the specified number of bytes.
1:863daa0:      *
1:863daa0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:863daa0:      * @param x the java input stream which contains the binary parameter value
1:863daa0:      * @param length the number of bytes in the stream
1:863daa0:      * @exception SQLException thrown on failure.
1:863daa0:      *
1:863daa0:      */
1:863daa0:     public final void setBinaryStream(int parameterIndex, InputStream x,
1:863daa0:                                       long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setBinaryStream(parameterIndex, x, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Sets the designated parameter to a {@code InputStream} object. This
1:863daa0:      * method differs from the {@code setBinaryStream(int, InputStream)} method
1:863daa0:      * because it informs the driver that the parameter value should be sent to
1:863daa0:      * the server as a {@code BLOB}.
1:863daa0:      *
1:863daa0:      * @param inputStream an object that contains the data to set the parameter
1:863daa0:      * value to.
1:863daa0:      * @throws SQLException if a database access error occurs, this method is
1:863daa0:      * called on a closed {@code PreparedStatement}
1:863daa0:      */
1:863daa0:     public final void setBlob(int parameterIndex, InputStream inputStream)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setBlob(parameterIndex, inputStream);
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Sets the designated parameter to the given Reader, which will have the
1:863daa0:      * specified number of bytes.
1:863daa0:      *
1:863daa0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:863daa0:      * @param x the java Reader which contains the UNICODE value
1:863daa0:      * @param length the number of bytes in the stream
1:863daa0:      * @exception SQLException thrown on failure.
1:863daa0:      *
1:863daa0:      */
1:863daa0:     public final void setCharacterStream(int parameterIndex, Reader x,
1:863daa0:                                          long length)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setCharacterStream(parameterIndex, x, length);
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Sets the designated parameter to a {@code Reader} object. This method
1:863daa0:      * differs from the {@code setCharacterStream(int,Reader)} method because
1:863daa0:      * it informs the driver that the parameter value should be sent to the
1:863daa0:      * server as a {@code CLOB}.
1:863daa0:      *
1:863daa0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:863daa0:      * @param reader an object that contains the data to set the parameter value
1:863daa0:      * to.
1:863daa0:      * @throws SQLException if a database access error occurs, this method is
1:863daa0:      * called on a closed PreparedStatement
1:863daa0:      */
1:863daa0:     public final void setClob(int parameterIndex, Reader reader)
1:863daa0:             throws SQLException {
1:863daa0:         getPreparedStatement().setClob(parameterIndex, reader);
1:863daa0:     }
1:863daa0: 
1:eac0369: 	/*
1:eac0369: 	** Control methods.
1:eac0369: 	*/
1:eac0369: 
1:e65be5b:     /**
1:e65be5b:      * Access the underlying PreparedStatement. This method
1:e65be5b:      * is package protected to restrict access to the underlying
1:e65be5b:      * object to the brokered objects. Allowing the application to
1:e65be5b:      * access the underlying object thtough a public method would
1:e65be5b:      * 
1:e65be5b:      */
1:e65be5b:     PreparedStatement getPreparedStatement() throws SQLException {
1:eac0369: 		return control.getRealPreparedStatement();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Override the BrokeredStatement's getStatement() to always return a PreparedStatement.
1:eac0369: 	*/
1:f44e479:     @Override
1:2e4a36f: 	public final Statement getStatement() throws SQLException {
1:eac0369: 		return getPreparedStatement();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Create a duplicate PreparedStatement to this, including state, from the passed in Connection.
1:eac0369: 	*/
1:eac0369: 	public PreparedStatement createDuplicateStatement(Connection conn, PreparedStatement oldStatement) throws SQLException {
1:eac0369: 
1:f44e479:         PreparedStatement newStatement;
1:f44e479: 
1:f44e479:         if (generatedKeys == null) {
1:f44e479:             newStatement = conn.prepareStatement(
1:f44e479:                 sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:f44e479:         } else {
1:f44e479:             // The prepareStatement() calls that take a generated key value do not take resultSet* type
1:f44e479:             // parameters, but since they don't return ResultSets that is OK. There are only for INSERT statements.
1:f44e479:             if (generatedKeys instanceof Integer) {
1:f44e479:                 newStatement = conn.prepareStatement(
1:f44e479:                     sql, ((Integer) generatedKeys).intValue());
1:f44e479:             } else if (generatedKeys instanceof int[]) {
1:f44e479:                 newStatement =
1:f44e479:                     conn.prepareStatement(sql, (int[]) generatedKeys);
1:f44e479:             } else {
1:f44e479:                 newStatement = conn.prepareStatement(
1:f44e479:                     sql, (String[]) generatedKeys);
1:f44e479:             }
1:f44e479:         }
1:eac0369: 
1:eac0369: 		setStatementState(oldStatement, newStatement);
1:eac0369: 
1:eac0369: 		return newStatement;
1:eac0369: 	}
1:f9a0689: 
1:f9a0689:     public final long getVersionCounter() throws SQLException {
1:f9a0689:         return ((EnginePreparedStatement)getPreparedStatement()).
1:f9a0689:                 getVersionCounter();
1:f9a0689:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:863daa0
/////////////////////////////////////////////////////////////////////////
1:  * A brokered {@code PreparedStatement} that forwards calls off to a real
1:  * {@code PreparedStatement} obtained through the
1:  * {@link BrokeredStatementControl#getRealPreparedStatement} method.
1:  * This class implements the JDBC 4.1 interface.
1: public class BrokeredPreparedStatement extends BrokeredStatement
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 4.0 methods
1: 
1:     public final void setRowId(int parameterIndex, RowId x)
1:             throws SQLException {
1:         getPreparedStatement().setRowId(parameterIndex, x);
1:     }
1: 
1:     public final void setNString(int index, String value) throws SQLException {
1:         getPreparedStatement().setNString(index, value);
1:     }
1: 
1:     public final void setNCharacterStream(int parameterIndex, Reader value)
1:             throws SQLException {
1:         getPreparedStatement().setNCharacterStream(parameterIndex, value);
1:     }
1: 
1:     public final void setNCharacterStream(int index, Reader value, long length)
1:             throws SQLException {
1:         getPreparedStatement().setNCharacterStream(index, value, length);
1:     }
1: 
1:     public final void setNClob(int index, NClob value) throws SQLException {
1:         getPreparedStatement().setNClob(index, value);
1:     }
1: 
1:     public final void setClob(int parameterIndex, Reader reader, long length)
1:             throws SQLException {
1:         getPreparedStatement().setClob(parameterIndex, reader, length);
1:     }
1: 
1:     public final void setBlob(int parameterIndex, InputStream inputStream,
1:                               long length)
1:             throws SQLException {
1:         getPreparedStatement().setBlob(parameterIndex, inputStream, length);
1:     }
1: 
1:     public final void setNClob(int parameterIndex, Reader reader)
1:             throws SQLException {
1:         getPreparedStatement().setNClob(parameterIndex, reader);
1:     }
1: 
1:     public final void setNClob(int parameterIndex, Reader reader, long length)
1:             throws SQLException {
1:         getPreparedStatement().setNClob(parameterIndex, reader, length);
1:     }
1: 
1:     public final void setSQLXML(int parameterIndex, SQLXML xmlObject)
1:             throws SQLException {
1:         getPreparedStatement().setSQLXML(parameterIndex, xmlObject);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the Java input stream that contains the ASCII parameter value
1:      * @throws SQLException if a database access error occurs or this method is
1:      * called on a closed {@code PreparedStatement}
1:      */
1:     public final void setAsciiStream(int parameterIndex, InputStream x)
1:             throws SQLException {
1:         getPreparedStatement().setAsciiStream(parameterIndex, x);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1:     public final void setAsciiStream(int parameterIndex, InputStream x,
1:                                      long length)
1:             throws SQLException {
1:         getPreparedStatement().setAsciiStream(parameterIndex, x, length);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1:     public final void setBinaryStream(int parameterIndex, InputStream x,
1:                                       long length)
1:             throws SQLException {
1:         getPreparedStatement().setBinaryStream(parameterIndex, x, length);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to a {@code InputStream} object. This
1:      * method differs from the {@code setBinaryStream(int, InputStream)} method
1:      * because it informs the driver that the parameter value should be sent to
1:      * the server as a {@code BLOB}.
1:      *
1:      * @param inputStream an object that contains the data to set the parameter
1:      * value to.
1:      * @throws SQLException if a database access error occurs, this method is
1:      * called on a closed {@code PreparedStatement}
1:      */
1:     public final void setBlob(int parameterIndex, InputStream inputStream)
1:             throws SQLException {
1:         getPreparedStatement().setBlob(parameterIndex, inputStream);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given Reader, which will have the
1:      * specified number of bytes.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java Reader which contains the UNICODE value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1:     public final void setCharacterStream(int parameterIndex, Reader x,
1:                                          long length)
1:             throws SQLException {
1:         getPreparedStatement().setCharacterStream(parameterIndex, x, length);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to a {@code Reader} object. This method
1:      * differs from the {@code setCharacterStream(int,Reader)} method because
1:      * it informs the driver that the parameter value should be sent to the
1:      * server as a {@code CLOB}.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param reader an object that contains the data to set the parameter value
1:      * to.
1:      * @throws SQLException if a database access error occurs, this method is
1:      * called on a closed PreparedStatement
1:      */
1:     public final void setClob(int parameterIndex, Reader reader)
1:             throws SQLException {
1:         getPreparedStatement().setClob(parameterIndex, reader);
1:     }
1: 
commit:b5f2776
/////////////////////////////////////////////////////////////////////////
1:         getPreparedStatement().setBinaryStream(parameterIndex, x);
/////////////////////////////////////////////////////////////////////////
1:         getPreparedStatement().setCharacterStream(parameterIndex, reader);
1: 
commit:46e89a9
/////////////////////////////////////////////////////////////////////////
0:     // JDBC 4.0 methods exposed via the EnginePreparedStatement interface
commit:f44e479
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
1: import java.sql.*;
0: 	JDBC 3 brokered PreparedStatement. Forwards calls off to a real prepared statement
0: public class BrokeredPreparedStatement extends BrokeredStatement
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * An Integer, an int array or a String array that specifies generated
1:      * key columns, or null if there are no generated key columns.
1:      */
1:     private final Object generatedKeys;
1: 
1:     public BrokeredPreparedStatement(BrokeredStatementControl control,
1:             String sql, Object generatedKeys) throws SQLException
1:         this.generatedKeys = generatedKeys;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 3.0 methods
1: 
1:     public final void setURL(int i, URL x) throws SQLException {
1:         getPreparedStatement().setURL(i, x);
1:     }
1: 
1:     public final ParameterMetaData getParameterMetaData() throws SQLException {
1:         return getPreparedStatement().getParameterMetaData();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement newStatement;
1: 
1:         if (generatedKeys == null) {
1:             newStatement = conn.prepareStatement(
1:                 sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         } else {
1:             // The prepareStatement() calls that take a generated key value do not take resultSet* type
1:             // parameters, but since they don't return ResultSets that is OK. There are only for INSERT statements.
1:             if (generatedKeys instanceof Integer) {
1:                 newStatement = conn.prepareStatement(
1:                     sql, ((Integer) generatedKeys).intValue());
1:             } else if (generatedKeys instanceof int[]) {
1:                 newStatement =
1:                     conn.prepareStatement(sql, (int[]) generatedKeys);
1:             } else {
1:                 newStatement = conn.prepareStatement(
1:                     sql, (String[]) generatedKeys);
1:             }
1:         }
commit:e24d8ef
/////////////////////////////////////////////////////////////////////////
1:      * @deprecated
commit:3634d6e
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class BrokeredPreparedStatement extends BrokeredStatement
commit:20b2fd9
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 4.1 methods exposed via the EnginePreparedStatement interface
1: 
1:     public long executeLargeUpdate() throws SQLException
1:     {
1:         final EnginePreparedStatement engnps = (EnginePreparedStatement) getPreparedStatement();  
1: 
1:         return engnps.executeLargeUpdate();
1:     }    
1:     
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f9a0689
/////////////////////////////////////////////////////////////////////////
1: 
1:     public final long getVersionCounter() throws SQLException {
1:         return ((EnginePreparedStatement)getPreparedStatement()).
1:                 getVersionCounter();
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:5b78c4e
/////////////////////////////////////////////////////////////////////////
1: 	public void close() throws SQLException
1: 	{
1: 	    control.closeRealPreparedStatement();
1: 	}
1: 	
commit:3be5c9d
/////////////////////////////////////////////////////////////////////////
0:     public BrokeredPreparedStatement(BrokeredStatementControl control, String sql) throws SQLException
1:         super(control);
commit:2e4a36f
/////////////////////////////////////////////////////////////////////////
0: 	public PreparedStatement getPreparedStatement() throws SQLException {
1: 	public final Statement getStatement() throws SQLException {
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:df380db
/////////////////////////////////////////////////////////////////////////
0: public abstract class BrokeredPreparedStatement extends BrokeredStatement
commit:175a740
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:562671e
/////////////////////////////////////////////////////////////////////////
0:         checkHoldability();
/////////////////////////////////////////////////////////////////////////
0:         checkHoldability();
commit:e65be5b
/////////////////////////////////////////////////////////////////////////
1: 	final String	sql;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Access the underlying PreparedStatement. This method
1:      * is package protected to restrict access to the underlying
1:      * object to the brokered objects. Allowing the application to
1:      * access the underlying object thtough a public method would
1:      * 
1:      */
1:     PreparedStatement getPreparedStatement() throws SQLException {
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.jdbc.BrokeredPreparedStatement
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:7827676
/////////////////////////////////////////////////////////////////////////
0: 		controlCheck().checkHoldCursors(resultSetHoldability);
/////////////////////////////////////////////////////////////////////////
0: 		controlCheck().checkHoldCursors(resultSetHoldability);
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.jdbc;
1: 
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.util.Calendar;
1: 
0: import java.sql.*;
0: import java.net.URL;
1: 
1: /**
0: 	JDBC 2 brokered PreparedStatement. Forwards calls off to a real prepared statement
0: 	obtained through the BrokeredStatementControl getRealPreparedStatement method.
1:  */
0: public class BrokeredPreparedStatement extends BrokeredStatement
0: 	implements PreparedStatement
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 	/**
1: 		SQL used to create me.
1: 	*/
0: 	protected final String	sql;
1: 
0:     public BrokeredPreparedStatement(BrokeredStatementControl control, int jdbcLevel, String sql) throws SQLException
1:     {
0:         super(control, jdbcLevel);
1: 		this.sql = sql;
1:     }
1: 
1: 	/**
1:      * A prepared SQL query is executed and its ResultSet is returned.
1:      *
1:      * @return a ResultSet that contains the data produced by the
1:      * query; never null
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final ResultSet executeQuery() throws SQLException
1:     {
0: 		control.checkHoldCursors(resultSetHoldability);
1:         return wrapResultSet(getPreparedStatement().executeQuery());
1:     } 
1: 
1:     /**
1:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:      * SQL statements that return nothing such as SQL DDL statements
1:      * can be executed.
1:      *
1:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:      * for SQL statements that return nothing
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final int executeUpdate() throws SQLException
1:     {
1:         return getPreparedStatement().executeUpdate();
1:     }
1: 
1:     /**
1:      * Set a parameter to SQL NULL.
1:      *
1:      * <P><B>Note:</B> You must specify the parameter's SQL type.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param sqlType SQL type code defined by java.sql.Types
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setNull(int parameterIndex, int sqlType) throws SQLException
1:     {
1:         getPreparedStatement().setNull( parameterIndex, sqlType);
1:     } 
1: 
1:     /**
1:      * Set a parameter to SQL NULL.
1:      *
1:      * <P><B>Note:</B> You must specify the parameter's SQL type.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param sqlType SQL type code defined by java.sql.Types
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException
1:     {
1:         getPreparedStatement().setNull( parameterIndex, sqlType, typeName);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java boolean value.  According to the JDBC API spec,
1: 	 * the driver converts this to a SQL BIT value when it sends it to the
1: 	 * database. But we don't have to do this, since the database engine
1: 	 * supports a boolean type.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setBoolean(int parameterIndex, boolean x) throws SQLException
1:     {
1:         getPreparedStatement().setBoolean( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java byte value.  The driver converts this
1:      * to a SQL TINYINT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setByte(int parameterIndex, byte x) throws SQLException
1:     {
1:         getPreparedStatement().setByte( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java short value.  The driver converts this
1:      * to a SQL SMALLINT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setShort(int parameterIndex, short x) throws SQLException
1:     {
1:         getPreparedStatement().setShort( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java int value.  The driver converts this
1:      * to a SQL INTEGER value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setInt(int parameterIndex, int x) throws SQLException
1:     {
1:         getPreparedStatement().setInt( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java long value.  The driver converts this
1:      * to a SQL BIGINT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setLong(int parameterIndex, long x) throws SQLException
1:     {
1:         getPreparedStatement().setLong( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java float value.  The driver converts this
1:      * to a SQL FLOAT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setFloat(int parameterIndex, float x) throws SQLException
1:     {
1:         getPreparedStatement().setFloat( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java double value.  The driver converts this
1:      * to a SQL DOUBLE value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setDouble(int parameterIndex, double x) throws SQLException
1:     {
1:         getPreparedStatement().setDouble( parameterIndex, x);
1:     } 
1: 
1: 
1:     /**
1:      * Set a parameter to a java.math.BigDecimal value.  
1:      * The driver converts this to a SQL NUMERIC value when
1:      * it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException
1:     {
1:         getPreparedStatement().setBigDecimal( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java String value.  The driver converts this
1:      * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
1:      * size relative to the driver's limits on VARCHARs) when it sends
1:      * it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setString(int parameterIndex, String x) throws SQLException
1:     {
1:         getPreparedStatement().setString( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a Java array of bytes.  The driver converts
1:      * this to a SQL VARBINARY or LONGVARBINARY (depending on the
1:      * argument's size relative to the driver's limits on VARBINARYs)
1:      * when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setBytes(int parameterIndex, byte[] x) throws SQLException
1:     {
1:         getPreparedStatement().setBytes( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a java.sql.Date value.  The driver converts this
1:      * to a SQL DATE value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setDate(int parameterIndex, Date x) throws SQLException
1:     {
1:         getPreparedStatement().setDate( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a java.sql.Time value.  The driver converts this
1:      * to a SQL TIME value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setTime(int parameterIndex, Time x) throws SQLException
1:     {
1:         getPreparedStatement().setTime( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * Set a parameter to a java.sql.Timestamp value.  The driver
1:      * converts this to a SQL TIMESTAMP value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setTimestamp(int parameterIndex, Timestamp x) throws SQLException
1:     {
1:         getPreparedStatement().setTimestamp( parameterIndex, x);
1:     } 
1: 
1:     /**
1: 	 * We do this inefficiently and read it all in here. The target type
1: 	 * is assumed to be a String.
1:      * 
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException
1:     {
1:         getPreparedStatement().setAsciiStream( parameterIndex, x, length);
1:     } 
1: 
1:     /**
1: 	 * We do this inefficiently and read it all in here. The target type
1: 	 * is assumed to be a String. The unicode source is assumed to be
1: 	 * in char[].  RESOLVE: might it be in UTF, instead? that'd be faster!
1:      * 
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...  
1:      * @param x the java input stream which contains the
1:      * UNICODE parameter value 
1:      * @param length the number of bytes in the stream 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
1:     {
1:         getPreparedStatement().setUnicodeStream( parameterIndex, x, length);
1:     } 
1: 
1:     /**
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException
1:     {
1:         getPreparedStatement().setBinaryStream( parameterIndex, x, length);
1:     } 
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Add a set of parameters to the batch.
1:      * 
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final void addBatch() throws SQLException
1:     {
1:         getPreparedStatement().addBatch( );
1:     } 
1: 
1:     /**
1:      * <P>In general, parameter values remain in force for repeated use of a
1:      * Statement. Setting a parameter value automatically clears its
1:      * previous value.  However, in some cases it is useful to immediately
1:      * release the resources used by the current parameter values; this can
1:      * be done by calling clearParameters.
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void clearParameters() throws SQLException
1:     {
1:         getPreparedStatement().clearParameters( );
1:     } 
1: 
1:     /**
1: 	 * JDBC 2.0
1: 	 *
1:      * The number, types and properties of a ResultSet's columns
1:      * are provided by the getMetaData method.
1:      *
1:      * @return the description of a ResultSet's columns
1:      * @exception SQLException Feature not implemented for now.
1:      */
1: 	public final java.sql.ResultSetMetaData getMetaData() throws SQLException
1:     {
1:         return getPreparedStatement().getMetaData();
1:     }
1: 
1:     /**
1: 	 * The interface says that the type of the Object parameter must
1: 	 * be compatible with the type of the targetSqlType. We check that,
1: 	 * and if it flies, we expect the underlying engine to do the
1: 	 * required conversion once we pass in the value using its type.
1: 	 * So, an Integer converting to a CHAR is done via setInteger()
1: 	 * support on the underlying CHAR type.
1:      *
1:      * <p>If x is null, it won't tell us its type, so we pass it on to setNull
1:      *
1:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:      * @param x The object containing the input parameter value
1:      * @param targetSqlType The SQL type (as defined in java.sql.Types) to be 
1:      * sent to the database. The scale argument may further qualify this type.
1:      * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
1:      *          this is the number of digits after the decimal.  For all other
1:      *          types this value will be ignored,
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setObject( parameterIndex, x, targetSqlType, scale);
1:     } 
1:         
1:     /**
1:       * This method is like setObject above, but assumes a scale of zero.
1:       * @exception SQLException thrown on failure.
1:       */
1:     public final void setObject(int parameterIndex, Object x, int targetSqlType)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setObject( parameterIndex, x, targetSqlType);
1:     } 
1: 
1:     /**
1:      * <p>Set the value of a parameter using an object; use the
1:      * java.lang equivalent objects for integral values.
1:      *
1:      * <p>The JDBC specification specifies a standard mapping from
1:      * Java Object types to SQL types.  The given argument java object
1:      * will be converted to the corresponding SQL type before being
1:      * sent to the database.
1:      *
1:      * <p>Note that this method may be used to pass datatabase
1:      * specific abstract data types, by using a Driver specific Java
1:      * type.
1:      *
1:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:      * @param x The object containing the input parameter value 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setObject(int parameterIndex, Object x)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setObject( parameterIndex, x);
1:     } 
1: 
1:     /**
1:      * @see java.sql.Statement#execute
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final boolean execute() throws SQLException
1:     {
0: 		control.checkHoldCursors(resultSetHoldability);
1:         return getPreparedStatement().execute();
1:     }
1: 
1:     public final void setCharacterStream(int parameterIndex,
1:                                    Reader reader,
1:                                    int length)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setCharacterStream( parameterIndex, reader, length);
1:     }
1: 
1:     public final void setRef(int i,
1:                        Ref x)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setRef( i, x);
1:     }
1: 
1:     public final void setBlob(int i,
1:                        Blob x)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setBlob( i, x);
1:     }
1: 
1:     public final void setClob(int i,
1:                        Clob x)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setClob( i, x);
1:     }
1: 
1:     public final void setArray(int i,
1:                          Array x)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setArray( i, x);
1:     }
1: 
1:     public final void setDate(int i,
1:                         Date x,
1:                         Calendar cal)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setDate( i, x, cal);
1:     }
1: 
1:     public final void setTime(int i,
1:                         Time x,
1:                         Calendar cal)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setTime( i, x, cal);
1:     }
1: 
1:     public final void setTimestamp(int i,
1:                              Timestamp x,
1:                              Calendar cal)
1:         throws SQLException
1:     {
1:         getPreparedStatement().setTimestamp( i, x, cal);
1:     }
1: 
1: 	/*
1: 	** Control methods.
1: 	*/
1: 
0: 	protected PreparedStatement getPreparedStatement() throws SQLException {
1: 		return control.getRealPreparedStatement();
1: 	}
1: 
1: 	/**
1: 		Override the BrokeredStatement's getStatement() to always return a PreparedStatement.
1: 	*/
0: 	protected final Statement getStatement() throws SQLException {
1: 		return getPreparedStatement();
1: 	}
1: 
1: 	/**
1: 		Create a duplicate PreparedStatement to this, including state, from the passed in Connection.
1: 	*/
1: 	public PreparedStatement createDuplicateStatement(Connection conn, PreparedStatement oldStatement) throws SQLException {
1: 
0: 		PreparedStatement newStatement = conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
1: 
1: 		setStatementState(oldStatement, newStatement);
1: 
1: 		return newStatement;
1: 	}
1: }
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     public void setBinaryStream(int parameterIndex, 
1:                                 InputStream x)
1:         throws SQLException {
1:         
0:         final EnginePreparedStatement engnps = 
0:             (EnginePreparedStatement) getPreparedStatement();  
1: 
0:         engnps.setBinaryStream(parameterIndex, x);
1: 
1:     }
1:     
1:     
1:     public void setCharacterStream(int parameterIndex, 
1:                                    Reader reader)
1:         throws SQLException{
1:         
0:         final EnginePreparedStatement engnps = 
0:             (EnginePreparedStatement) getPreparedStatement();  
1: 
0:         engnps.setCharacterStream(parameterIndex, reader);
1:         
1:     }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:aadfd42
/////////////////////////////////////////////////////////////////////////
1: 	implements EnginePreparedStatement
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Imitate the getParameterMetaData() function in JDBC 3.0
0:      *
0:      * Retrieves the number, types and properties of this PreparedStatement
0:      * object's parameters.
0:      *
0:      * @return a EngineParameterMetaData object that contains information about the
0:      * number, types and properties of this PreparedStatement object's parameters.
0:      * @exception SQLException if a database access error occurs
0:      */
0:     public EngineParameterMetaData getEmbedParameterSetMetaData()
0:     throws SQLException
0:     {
0:         return ((EnginePreparedStatement)getPreparedStatement()).getEmbedParameterSetMetaData();
0:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.jdbc;
0: 
0: import java.io.InputStream;
0: import java.io.Reader;
0: import java.util.Calendar;
0: 
0: import java.sql.*;
0: import java.net.URL;
0: 
0: /**
0: 	JDBC 2 brokered PreparedStatement. Forwards calls off to a real prepared statement
0: 	obtained through the BrokeredStatementControl getRealPreparedStatement method.
0:  */
0: public class BrokeredPreparedStatement extends BrokeredStatement
0: 	implements PreparedStatement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 	/**
0: 		SQL used to create me.
0: 	*/
0: 	protected final String	sql;
0: 
0:     public BrokeredPreparedStatement(BrokeredStatementControl control, int jdbcLevel, String sql) throws SQLException
0:     {
0:         super(control, jdbcLevel);
0: 		this.sql = sql;
0:     }
0: 
0: 	/**
0:      * A prepared SQL query is executed and its ResultSet is returned.
0:      *
0:      * @return a ResultSet that contains the data produced by the
0:      * query; never null
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final ResultSet executeQuery() throws SQLException
0:     {
0: 		control.checkHoldCursors(resultSetHoldability);
0:         return wrapResultSet(getPreparedStatement().executeQuery());
0:     } 
0: 
0:     /**
0:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
0:      * SQL statements that return nothing such as SQL DDL statements
0:      * can be executed.
0:      *
0:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
0:      * for SQL statements that return nothing
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final int executeUpdate() throws SQLException
0:     {
0:         return getPreparedStatement().executeUpdate();
0:     }
0: 
0:     /**
0:      * Set a parameter to SQL NULL.
0:      *
0:      * <P><B>Note:</B> You must specify the parameter's SQL type.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param sqlType SQL type code defined by java.sql.Types
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setNull(int parameterIndex, int sqlType) throws SQLException
0:     {
0:         getPreparedStatement().setNull( parameterIndex, sqlType);
0:     } 
0: 
0:     /**
0:      * Set a parameter to SQL NULL.
0:      *
0:      * <P><B>Note:</B> You must specify the parameter's SQL type.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param sqlType SQL type code defined by java.sql.Types
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException
0:     {
0:         getPreparedStatement().setNull( parameterIndex, sqlType, typeName);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java boolean value.  According to the JDBC API spec,
0: 	 * the driver converts this to a SQL BIT value when it sends it to the
0: 	 * database. But we don't have to do this, since the database engine
0: 	 * supports a boolean type.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setBoolean(int parameterIndex, boolean x) throws SQLException
0:     {
0:         getPreparedStatement().setBoolean( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java byte value.  The driver converts this
0:      * to a SQL TINYINT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setByte(int parameterIndex, byte x) throws SQLException
0:     {
0:         getPreparedStatement().setByte( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java short value.  The driver converts this
0:      * to a SQL SMALLINT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setShort(int parameterIndex, short x) throws SQLException
0:     {
0:         getPreparedStatement().setShort( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java int value.  The driver converts this
0:      * to a SQL INTEGER value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setInt(int parameterIndex, int x) throws SQLException
0:     {
0:         getPreparedStatement().setInt( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java long value.  The driver converts this
0:      * to a SQL BIGINT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setLong(int parameterIndex, long x) throws SQLException
0:     {
0:         getPreparedStatement().setLong( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java float value.  The driver converts this
0:      * to a SQL FLOAT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setFloat(int parameterIndex, float x) throws SQLException
0:     {
0:         getPreparedStatement().setFloat( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java double value.  The driver converts this
0:      * to a SQL DOUBLE value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setDouble(int parameterIndex, double x) throws SQLException
0:     {
0:         getPreparedStatement().setDouble( parameterIndex, x);
0:     } 
0: 
0: 
0:     /**
0:      * Set a parameter to a java.math.BigDecimal value.  
0:      * The driver converts this to a SQL NUMERIC value when
0:      * it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException
0:     {
0:         getPreparedStatement().setBigDecimal( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java String value.  The driver converts this
0:      * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
0:      * size relative to the driver's limits on VARCHARs) when it sends
0:      * it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setString(int parameterIndex, String x) throws SQLException
0:     {
0:         getPreparedStatement().setString( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a Java array of bytes.  The driver converts
0:      * this to a SQL VARBINARY or LONGVARBINARY (depending on the
0:      * argument's size relative to the driver's limits on VARBINARYs)
0:      * when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setBytes(int parameterIndex, byte[] x) throws SQLException
0:     {
0:         getPreparedStatement().setBytes( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a java.sql.Date value.  The driver converts this
0:      * to a SQL DATE value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setDate(int parameterIndex, Date x) throws SQLException
0:     {
0:         getPreparedStatement().setDate( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a java.sql.Time value.  The driver converts this
0:      * to a SQL TIME value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setTime(int parameterIndex, Time x) throws SQLException
0:     {
0:         getPreparedStatement().setTime( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * Set a parameter to a java.sql.Timestamp value.  The driver
0:      * converts this to a SQL TIMESTAMP value when it sends it to the
0:      * database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setTimestamp(int parameterIndex, Timestamp x) throws SQLException
0:     {
0:         getPreparedStatement().setTimestamp( parameterIndex, x);
0:     } 
0: 
0:     /**
0: 	 * We do this inefficiently and read it all in here. The target type
0: 	 * is assumed to be a String.
0:      * 
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java input stream which contains the ASCII parameter value
0:      * @param length the number of bytes in the stream 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException
0:     {
0:         getPreparedStatement().setAsciiStream( parameterIndex, x, length);
0:     } 
0: 
0:     /**
0: 	 * We do this inefficiently and read it all in here. The target type
0: 	 * is assumed to be a String. The unicode source is assumed to be
0: 	 * in char[].  RESOLVE: might it be in UTF, instead? that'd be faster!
0:      * 
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...  
0:      * @param x the java input stream which contains the
0:      * UNICODE parameter value 
0:      * @param length the number of bytes in the stream 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
0:     {
0:         getPreparedStatement().setUnicodeStream( parameterIndex, x, length);
0:     } 
0: 
0:     /**
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java input stream which contains the binary parameter value
0:      * @param length the number of bytes in the stream 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException
0:     {
0:         getPreparedStatement().setBinaryStream( parameterIndex, x, length);
0:     } 
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Add a set of parameters to the batch.
0:      * 
0:      * @exception SQLException if a database-access error occurs.
0:      */
0:     public final void addBatch() throws SQLException
0:     {
0:         getPreparedStatement().addBatch( );
0:     } 
0: 
0:     /**
0:      * <P>In general, parameter values remain in force for repeated use of a
0:      * Statement. Setting a parameter value automatically clears its
0:      * previous value.  However, in some cases it is useful to immediately
0:      * release the resources used by the current parameter values; this can
0:      * be done by calling clearParameters.
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void clearParameters() throws SQLException
0:     {
0:         getPreparedStatement().clearParameters( );
0:     } 
0: 
0:     /**
0: 	 * JDBC 2.0
0: 	 *
0:      * The number, types and properties of a ResultSet's columns
0:      * are provided by the getMetaData method.
0:      *
0:      * @return the description of a ResultSet's columns
0:      * @exception SQLException Feature not implemented for now.
0:      */
0: 	public final java.sql.ResultSetMetaData getMetaData() throws SQLException
0:     {
0:         return getPreparedStatement().getMetaData();
0:     }
0: 
0:     /**
0: 	 * The interface says that the type of the Object parameter must
0: 	 * be compatible with the type of the targetSqlType. We check that,
0: 	 * and if it flies, we expect the underlying engine to do the
0: 	 * required conversion once we pass in the value using its type.
0: 	 * So, an Integer converting to a CHAR is done via setInteger()
0: 	 * support on the underlying CHAR type.
0:      *
0:      * <p>If x is null, it won't tell us its type, so we pass it on to setNull
0:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @param x The object containing the input parameter value
0:      * @param targetSqlType The SQL type (as defined in java.sql.Types) to be 
0:      * sent to the database. The scale argument may further qualify this type.
0:      * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
0:      *          this is the number of digits after the decimal.  For all other
0:      *          types this value will be ignored,
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setObject( parameterIndex, x, targetSqlType, scale);
0:     } 
0:         
0:     /**
0:       * This method is like setObject above, but assumes a scale of zero.
0:       * @exception SQLException thrown on failure.
0:       */
0:     public final void setObject(int parameterIndex, Object x, int targetSqlType)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setObject( parameterIndex, x, targetSqlType);
0:     } 
0: 
0:     /**
0:      * <p>Set the value of a parameter using an object; use the
0:      * java.lang equivalent objects for integral values.
0:      *
0:      * <p>The JDBC specification specifies a standard mapping from
0:      * Java Object types to SQL types.  The given argument java object
0:      * will be converted to the corresponding SQL type before being
0:      * sent to the database.
0:      *
0:      * <p>Note that this method may be used to pass datatabase
0:      * specific abstract data types, by using a Driver specific Java
0:      * type.
0:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @param x The object containing the input parameter value 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setObject(int parameterIndex, Object x)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setObject( parameterIndex, x);
0:     } 
0: 
0:     /**
0:      * @see java.sql.Statement#execute
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final boolean execute() throws SQLException
0:     {
0: 		control.checkHoldCursors(resultSetHoldability);
0:         return getPreparedStatement().execute();
0:     }
0: 
0:     public final void setCharacterStream(int parameterIndex,
0:                                    Reader reader,
0:                                    int length)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setCharacterStream( parameterIndex, reader, length);
0:     }
0: 
0:     public final void setRef(int i,
0:                        Ref x)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setRef( i, x);
0:     }
0: 
0:     public final void setBlob(int i,
0:                        Blob x)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setBlob( i, x);
0:     }
0: 
0:     public final void setClob(int i,
0:                        Clob x)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setClob( i, x);
0:     }
0: 
0:     public final void setArray(int i,
0:                          Array x)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setArray( i, x);
0:     }
0: 
0:     public final void setDate(int i,
0:                         Date x,
0:                         Calendar cal)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setDate( i, x, cal);
0:     }
0: 
0:     public final void setTime(int i,
0:                         Time x,
0:                         Calendar cal)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setTime( i, x, cal);
0:     }
0: 
0:     public final void setTimestamp(int i,
0:                              Timestamp x,
0:                              Calendar cal)
0:         throws SQLException
0:     {
0:         getPreparedStatement().setTimestamp( i, x, cal);
0:     }
0: 
0: 	/*
0: 	** Control methods.
0: 	*/
0: 
0: 	protected PreparedStatement getPreparedStatement() throws SQLException {
0: 		return control.getRealPreparedStatement();
0: 	}
0: 
0: 	/**
0: 		Override the BrokeredStatement's getStatement() to always return a PreparedStatement.
0: 	*/
0: 	protected final Statement getStatement() throws SQLException {
0: 		return getPreparedStatement();
0: 	}
0: 
0: 	/**
0: 		Create a duplicate PreparedStatement to this, including state, from the passed in Connection.
0: 	*/
0: 	public PreparedStatement createDuplicateStatement(Connection conn, PreparedStatement oldStatement) throws SQLException {
0: 
0: 		PreparedStatement newStatement = conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
0: 
0: 		setStatementState(oldStatement, newStatement);
0: 
0: 		return newStatement;
0: 	}
0: }
============================================================================