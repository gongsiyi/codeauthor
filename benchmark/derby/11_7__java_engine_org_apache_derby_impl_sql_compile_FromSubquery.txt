1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.FromSubquery
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
25:eac0369: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:392ac57: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:392ac57: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
6:eac0369: /**
1:eac0369:  * A FromSubquery represents a subquery in the FROM list of a DML statement.
7:eac0369:  *
1:eac0369:  * The current implementation of this class is only
1:eac0369:  * sufficient for Insert's need to push a new
1:eac0369:  * select on top of the one the user specified,
1:eac0369:  * to make the selected structure match that
1:eac0369:  * of the insert target table.
1:eac0369:  *
1:eac0369:  */
1:3bb140c: class FromSubquery extends FromTable
19:eac0369: {
1:eac0369: 	ResultSetNode	subquery;
1:2060c4a: 	private OrderByList orderByList;
1:108305b:     private ValueNode offset;
1:108305b:     private ValueNode fetchFirst;
1:57c1b5c:     private boolean hasJDBClimitClause; // true if using JDBC limit/offset escape syntax
1:eac0369: 
1:eac0369: 	/**
1:392ac57: 	 * DERBY-3270: If this subquery represents an expanded view, this holds the
1:392ac57: 	 * current compilation schema at view definition time.
1:392ac57: 	 */
1:392ac57: 	private SchemaDescriptor origCompilationSchema = null;
1:392ac57: 
1:392ac57: 	/**
1:3bb140c:      * Constructor for a table in a FROM list.
1:eac0369: 	 *
1:6b50965: 	 * @param subquery		The subquery
1:2060c4a: 	 * @param orderByList   ORDER BY list if any, or null
1:108305b:      * @param offset        OFFSET if any, or null
1:108305b:      * @param fetchFirst    FETCH FIRST if any, or null
1:3bb140c:      * @param hasJDBClimitClause True if the offset/fetchFirst clauses come
1:3bb140c:      *                      from JDBC limit/offset escape syntax
1:eac0369: 	 * @param correlationName	The correlation name
1:eac0369: 	 * @param derivedRCL		The derived column list
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:3bb140c:     FromSubquery(ResultSetNode subquery,
1:3bb140c:                  OrderByList orderByList,
1:3bb140c:                  ValueNode offset,
1:3bb140c:                  ValueNode fetchFirst,
1:3bb140c:                  boolean hasJDBClimitClause,
1:3bb140c:                  String correlationName,
1:3bb140c:                  ResultColumnList derivedRCL,
1:3bb140c:                  Properties tableProperties,
1:3bb140c:                  ContextManager cm)
1:eac0369: 	{
1:3bb140c:         super(correlationName, tableProperties, cm);
1:3bb140c:         this.subquery = subquery;
1:3bb140c:         this.orderByList = orderByList;
1:3bb140c:         this.offset = offset;
1:3bb140c:         this.fetchFirst = fetchFirst;
1:3bb140c:         this.hasJDBClimitClause = hasJDBClimitClause;
1:11f7ee3:         setResultColumns( derivedRCL );
20:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:2d2e717: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:2d2e717: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (subquery != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "subquery: ");
1:eac0369: 				subquery.treePrint(depth + 1);
1:eac0369: 			}
1:2060c4a: 
1:108305b:             if (orderByList != null)
1:108305b:             {
1:108305b:                 printLabel(depth, "orderByList: ");
1:108305b:                 orderByList.treePrint(depth + 1);
1:108305b:             }
1:108305b: 
1:108305b:             if (offset != null)
1:108305b:             {
1:108305b:                 printLabel(depth, "offset: ");
1:108305b:                 offset.treePrint(depth + 1);
1:108305b:             }
1:108305b: 
1:108305b:             if (fetchFirst != null)
1:108305b:             {
1:108305b:                 printLabel(depth, "fetchFirst: ");
1:108305b:                 fetchFirst.treePrint(depth + 1);
1:108305b:             }
1:108305b:         }
1:2060c4a: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Return the "subquery" from this node.
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode	The "subquery" from this node.
1:eac0369: 	 */
1:3bb140c:     ResultSetNode getSubquery()
1:2060c4a: 	{
1:eac0369: 		return subquery;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Determine whether or not the specified name is an exposed name in
1:eac0369: 	 * the current query block.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The specified name to search for as an exposed name.
1:eac0369: 	 * @param schemaName	Schema name, if non-null.
1:eac0369: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:eac0369: 	 *						names or match on table id.
1:eac0369: 	 *
1:eac0369: 	 * @return The FromTable, if any, with the exposed name.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:74d0488:         if (schemaName != null && origTableName != null) {
1:74d0488:             // View can have schema
1:74d0488:             if (!schemaName.equals(origTableName.schemaName)) {
1:74d0488:                 return null;
1:74d0488:             }
1:74d0488:             // So far, so good, now go on to compare table name
1:74d0488:         }
1:74d0488: 
1:74d0488:         if (getExposedName().equals(name)) {
1:74d0488:             return this;
1:74d0488:         }
1:74d0488: 
1:74d0488:         return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this subquery that appears in the FROM list.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for binding
1:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode		The bound FromSubquery.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
1:eac0369: 						  FromList fromListParam) 
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Assign the tableNumber */
1:eac0369: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1:eac0369: 			tableNumber = getCompilerContext().getNextTableNumber();
1:eac0369: 
1:eac0369: 		subquery = subquery.bindNonVTITables(dataDictionary, fromListParam);
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this subquery that appears in the FROM list.
1:eac0369: 	 *
1:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode		The bound FromSubquery.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode bindVTITables(FromList fromListParam)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		subquery = subquery.bindVTITables(fromListParam);
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
1:eac0369: 	 * This is done for SELECT statements.  For FromSubquery, we
1:eac0369: 	 * simply pass the check through to the subquery.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown if a ? parameter found
1:eac0369: 	 *									directly under a ResultColumn
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void rejectParameters() throws StandardException
1:eac0369: 	{
1:eac0369: 		subquery.rejectParameters();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions in this FromSubquery.  This means 
1:eac0369: 	 * binding the sub-expressions, as well as figuring out what the return 
1:eac0369: 	 * type is for each expression.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindExpressions(FromList fromListParam)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:3bb140c:         FromList            emptyFromList = new FromList(
1:3bb140c:                 getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                 getContextManager());
1:11f7ee3: 		ResultColumnList	derivedRCL = getResultColumns();
1:eac0369: 		ResultColumnList	subqueryRCL;
1:444aa52: 		FromList			nestedFromList;
1:444aa52: 
1:eac0369: 		/* From subqueries cannot be correlated, so we pass an empty FromList
1:41943bb: 		 * to subquery.bindExpressions() and .bindResultColumns()
1:eac0369: 		 */
1:2060c4a: 		if (orderByList != null) {
1:2060c4a: 			orderByList.pullUpOrderByColumns(subquery);
1:2060c4a: 		}
1:2060c4a: 
1:41943bb: 		nestedFromList = emptyFromList;
1:392ac57: 
1:392ac57: 		CompilerContext compilerContext = getCompilerContext();
1:392ac57: 
1:392ac57: 		if (origCompilationSchema != null) {
1:392ac57: 			// View expansion needs the definition time schema
1:392ac57: 			compilerContext.pushCompilationSchema(origCompilationSchema);
1:392ac57: 		}
1:392ac57: 
1:3468143:         // Nested VTI/tableFunctions will want to know whether their arguments
1:3468143:         // reference tables in the FROM list which contains this subquery. Those
1:3468143:         // references are illegal. See DERBY-5554 and DERBY-5779.
1:a6d25cd:         CollectNodesVisitor<FromVTI> nestedVTIs =
1:a6d25cd:                 new CollectNodesVisitor<FromVTI>(FromVTI.class);
1:3468143: 		subquery.accept( nestedVTIs );
1:a6d25cd:         for (FromVTI ref : nestedVTIs.getList())
1:3468143: 		{
1:3468143:             ref.addOuterFromList( fromListParam );
1:3468143: 		}
1:3468143:         
1:392ac57: 		try {
1:392ac57: 			subquery.bindExpressions(nestedFromList);
1:392ac57: 			subquery.bindResultColumns(nestedFromList);
1:392ac57: 		} finally {
1:392ac57: 			if (origCompilationSchema != null) {
1:392ac57: 				compilerContext.popCompilationSchema();
1:392ac57: 			}
1:392ac57: 		}
1:eac0369: 
1:2060c4a: 		if (orderByList != null) {
1:2060c4a: 			orderByList.bindOrderByColumns(subquery);
1:2060c4a: 		}
1:2060c4a: 
1:108305b:         bindOffsetFetch(offset, fetchFirst);
1:108305b: 
1:7b48c50:         /* NOTE: If the size of the derived column list is less than
1:eac0369: 		 * the size of the subquery's RCL and the derived column list is marked
1:eac0369: 		 * for allowing a size mismatch, then we have a select * view
1:eac0369: 		 * on top of a table that has had columns added to it via alter table.
1:eac0369: 		 * In this case, we trim out the columns that have been added to
1:eac0369: 		 * the table since the view was created.
1:eac0369: 		 */
1:eac0369: 		subqueryRCL = subquery.getResultColumns();
1:11f7ee3: 		if (getResultColumns() != null && getResultColumns().getCountMismatchAllowed() &&
1:11f7ee3: 			getResultColumns().size() < subqueryRCL.size())
1:eac0369: 		{
1:eac0369: 			for (int index = subqueryRCL.size() - 1; 
1:11f7ee3: 				 index >= getResultColumns().size(); 
1:eac0369: 				 index--)
1:eac0369: 			{
1:eac0369: 				subqueryRCL.removeElementAt(index);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:7b48c50:         /*
1:7b48c50:          * Create RCL based on subquery, adding a level of VCNs.
1:7b48c50:          */
1:7b48c50:          ResultColumnList newRcl = subqueryRCL.copyListAndObjects();
1:7b48c50:          newRcl.genVirtualColumnNodes(subquery, subquery.getResultColumns());
1:11f7ee3:          setResultColumns( newRcl );
1:eac0369: 
1:eac0369: 		/* Propagate the name info from the derived column list */
1:eac0369: 		if (derivedRCL != null)
1:eac0369: 		{
1:11f7ee3:             getResultColumns().propagateDCLInfo(derivedRCL, correlationName);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Try to find a ResultColumn in the table represented by this FromBaseTable
1:eac0369: 	 * that matches the name in the given ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @param columnReference	The columnReference whose name we're looking
1:eac0369: 	 *				for in the given table.
1:eac0369: 	 *
1:eac0369: 	 * @return	A ResultColumn whose expression is the ColumnNode
1:eac0369: 	 *			that matches the ColumnReference.
1:eac0369: 	 *		Returns null if there is no match.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultColumn getMatchingColumn(ColumnReference columnReference)
1:3bb140c:             throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultColumn	resultColumn = null;
1:eac0369: 		String			columnsTableName;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** RESOLVE: When we add support for schemas, check to see if
1:eac0369: 		** the column name specifies a schema, and if so, if this
1:eac0369: 		** table is in that schema.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		columnsTableName = columnReference.getTableName();
1:eac0369: 
1:41943bb: 		// post 681, 1 may be no longer needed. 5 is the default case
1:41943bb: 		// now but what happens if the condition is false? Investigate.
1:eac0369: 		if (columnReference.getGeneratedToReplaceAggregate()) // 1
1:eac0369: 		{
1:11f7ee3: 			resultColumn = getResultColumns().getResultColumn(columnReference.getColumnName());
1:eac0369: 		}
1:eac0369: 		else if (columnsTableName == null || columnsTableName.equals(correlationName)) // 5?
1:eac0369: 		{
1:11f7ee3: 		    resultColumn = getResultColumns().getAtMostOneResultColumn(columnReference, correlationName, false);
1:eac0369: 		}
1:eac0369: 		    
1:eac0369: 
3:eac0369: 		if (resultColumn != null)
1:eac0369: 		{
1:eac0369: 			columnReference.setTableNumber(tableNumber);
1:ee21e7c:             columnReference.setColumnNumber(resultColumn.getColumnPosition());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return resultColumn;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess a ResultSetNode - this currently means:
1:eac0369: 	 *	o  Generating a referenced table map for each ResultSetNode.
1:eac0369: 	 *  o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF).
1:eac0369: 	 *  o  Converting the WHERE and HAVING clauses into PredicateLists and
1:eac0369: 	 *	   classifying them.
1:eac0369: 	 *  o  Ensuring that a ProjectRestrictNode is generated on top of every 
1:eac0369: 	 *     FromBaseTable and generated in place of every FromSubquery.  
1:eac0369: 	 *  o  Pushing single table predicates down to the new ProjectRestrictNodes.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 * @param fromList			The from list, if any
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode at top of preprocessed tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:eac0369: 									GroupByList gbl,
1:eac0369: 									FromList fromList)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:b4cda60:         subquery.pushQueryExpressionSuffix();
1:2060c4a: 		// Push the order by list down to the ResultSet
1:2060c4a: 		if (orderByList != null)
1:2060c4a: 		{
1:2060c4a: 			// If we have more than 1 ORDERBY columns, we may be able to
1:2060c4a: 			// remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1:2060c4a: 			if (orderByList.size() > 1)
1:2060c4a: 			{
1:2060c4a: 				orderByList.removeDupColumns();
1:2060c4a: 			}
1:2060c4a: 
1:2060c4a: 			subquery.pushOrderByList(orderByList);
1:2060c4a: 			orderByList = null;
1:2060c4a: 		}
1:108305b: 
1:57c1b5c:         subquery.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
1:2060c4a: 
1:eac0369: 		/* We want to chop out the FromSubquery from the tree and replace it 
1:eac0369: 		 * with a ProjectRestrictNode.  One complication is that there may be 
1:eac0369: 		 * ColumnReferences above us which point to the FromSubquery's RCL.
1:eac0369: 		 * What we want to return is a tree with a PRN with the
1:eac0369: 		 * FromSubquery's RCL on top.  (In addition, we don't want to be
1:eac0369: 		 * introducing any redundant ProjectRestrictNodes.)
1:2060c4a: 		 * Another complication is that we want to be able to only push
1:eac0369: 		 * projections and restrictions down to this ProjectRestrict, but
1:eac0369: 		 * we want to be able to push them through as well.
1:eac0369: 		 * So, we:
1:eac0369: 		 *		o call subquery.preprocess() which returns a tree with
1:eac0369: 		 *		  a SelectNode or a RowResultSetNode on top.  
1:eac0369: 		 *		o If the FSqry is flattenable(), then we return (so that the
1:eac0369: 		 *		  caller can then call flatten()), otherwise we:
1:eac0369: 		 *		o generate a PRN, whose RCL is the FSqry's RCL, on top of the result.
1:eac0369: 		 *		o create a referencedTableMap for the PRN which represents 
1:eac0369: 		 *		  the FSqry's tableNumber, since ColumnReferences in the outer
1:eac0369: 		 *		  query block would be referring to that one.  
1:eac0369: 		 *		  (This will allow us to push restrictions down to the PRN.)
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		subquery = subquery.preprocess(numTables, gbl, fromList);
1:eac0369: 
1:eac0369: 		/* Return if the FSqry is flattenable() 
1:eac0369: 		 * NOTE: We can't flatten a FromSubquery if there is a group by list
1:eac0369: 		 * because the group by list must be ColumnReferences.  For:
1:eac0369: 		 *	select c1 from v1 group by c1,
1:eac0369: 		 *	where v1 is select 1 from t1
1:eac0369: 		 * The expression under the last redundant ResultColumn is an IntConstantNode,
1:eac0369: 		 * not a ColumnReference.
1:eac0369: 		 * We also do not flatten a subquery if tableProperties is non-null,
1:eac0369: 		 * as the user is specifying 1 or more properties for the derived table,
1:eac0369: 		 * which could potentially be lost on the flattening.
1:eac0369: 		 * RESOLVE - this is too restrictive.
1:eac0369: 		 */
1:eac0369: 		if ((gbl == null || gbl.size() == 0) &&
1:eac0369: 			tableProperties == null &&
1:eac0369: 		    subquery.flattenableInFromSubquery(fromList))
1:eac0369: 		{
1:eac0369: 			/* Set our table map to the subquery's table map. */
1:eac0369: 			setReferencedTableMap(subquery.getReferencedTableMap());
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return extractSubquery(numTables);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Extract out and return the subquery, with a PRN on top.
1:eac0369: 	 * (See FromSubquery.preprocess() for more details.)
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the DML Statement
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode at top of extracted tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ResultSetNode extractSubquery(int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		JBitSet		  newJBS;
1:eac0369: 		ResultSetNode newPRN;
1:eac0369: 
1:3bb140c:         newPRN = new ProjectRestrictNode(
1:eac0369: 								subquery,		/* Child ResultSet */
1:11f7ee3: 								getResultColumns(),	/* Projection */
1:eac0369: 								null,			/* Restriction */
1:eac0369: 								null,			/* Restriction as PredicateList */
1:eac0369: 								null,			/* Subquerys in Projection */
1:eac0369: 								null,			/* Subquerys in Restriction */
1:eac0369: 								tableProperties,
1:eac0369: 								getContextManager()	 );
1:eac0369: 
1:eac0369: 		/* Set up the PRN's referencedTableMap */
1:eac0369: 		newJBS = new JBitSet(numTables);
1:eac0369: 		newJBS.set(tableNumber);
1:eac0369: 		newPRN.setReferencedTableMap(newJBS);
1:eac0369: 		((FromTable) newPRN).setTableNumber(tableNumber);
1:eac0369: 
1:eac0369: 		return newPRN;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Flatten this FSqry into the outer query block. The steps in
1:eac0369: 	 * flattening are:
1:eac0369: 	 *	o  Mark all ResultColumns as redundant, so that they are "skipped over"
1:eac0369: 	 *	   at generate().
1:eac0369: 	 *	o  Append the wherePredicates to the outer list.
1:eac0369: 	 *	o  Return the fromList so that the caller will merge the 2 lists 
1:eac0369: 	 *  RESOLVE - FSqrys with subqueries are currently not flattenable.  Some of
1:eac0369: 	 *  them can be flattened, however.  We need to merge the subquery list when
1:eac0369: 	 *  we relax this restriction.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: This method returns NULL when flattening RowResultSetNodes
1:eac0369: 	 * (the node for a VALUES clause).  The reason is that no reference
1:eac0369: 	 * is left to the RowResultSetNode after flattening is done - the
1:eac0369: 	 * expressions point directly to the ValueNodes in the RowResultSetNode's
1:eac0369: 	 * ResultColumnList.
1:eac0369: 	 *
1:eac0369: 	 * @param rcl				The RCL from the outer query
1:eac0369: 	 * @param outerPList	PredicateList to append wherePredicates to.
1:eac0369: 	 * @param sql				The SubqueryList from the outer query
1:eac0369: 	 * @param gbl				The group by list, if any
1:2e7e8f6:      * @param havingClause      The HAVING clause, if any
1:eac0369: 	 *
1:eac0369: 	 * @return FromList		The fromList from the underlying SelectNode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     FromList flatten(ResultColumnList rcl,
1:eac0369: 							PredicateList outerPList,
1:eac0369: 							SubqueryList sql,
1:2e7e8f6:                             GroupByList gbl,
1:2e7e8f6:                             ValueNode havingClause)
1:eac0369: 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		FromList	fromList = null;
1:eac0369: 		SelectNode	selectNode;
1:eac0369: 
1:11f7ee3: 		getResultColumns().setRedundant();
1:eac0369: 
1:eac0369: 		subquery.getResultColumns().setRedundant();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** RESOLVE: Each type of result set should know how to remap itself.
1:eac0369: 		*/
1:eac0369: 		if (subquery instanceof SelectNode)
1:eac0369: 		{
1:eac0369: 			selectNode = (SelectNode) subquery;
1:eac0369: 			fromList = selectNode.getFromList();
1:eac0369: 
1:eac0369: 			// selectNode.getResultColumns().setRedundant();
1:eac0369: 
1:eac0369: 			if (selectNode.getWherePredicates().size() > 0)
1:eac0369: 			{
1:eac0369: 				outerPList.destructiveAppend(selectNode.getWherePredicates());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (selectNode.getWhereSubquerys().size() > 0)
1:eac0369: 			{
1:eac0369: 				sql.destructiveAppend(selectNode.getWhereSubquerys());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else if ( ! (subquery instanceof RowResultSetNode))
1:eac0369: 		{
3:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("subquery expected to be either a SelectNode or a RowResultSetNode, but is a " + subquery.getClass().getName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Remap all ColumnReferences from the outer query to this node.
1:eac0369: 		 * (We replace those ColumnReferences with clones of the matching
1:eac0369: 		 * expression in the SELECT's RCL.
1:eac0369: 		 */
1:eac0369: 		rcl.remapColumnReferencesToExpressions();
1:eac0369: 		outerPList.remapColumnReferencesToExpressions();
1:eac0369: 		if (gbl != null)
1:eac0369: 		{
1:eac0369: 			gbl.remapColumnReferencesToExpressions();
1:eac0369: 		}
1:eac0369: 
1:2e7e8f6:         if (havingClause != null) {
1:2e7e8f6:             havingClause.remapColumnReferencesToExpressions();
1:2e7e8f6:         }
1:2e7e8f6: 
1:eac0369: 		return fromList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the exposed name for this table, which is the name that can
1:eac0369: 	 * be used to refer to it in the rest of the query.
1:eac0369: 	 *
1:eac0369: 	 * @return	The exposed name for this table.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     String getExposedName()
1:eac0369: 	{
1:eac0369: 		return correlationName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Expand a "*" into a ResultColumnList with all of the
1:eac0369: 	 * result columns from the subquery.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultColumnList getAllResultColumns(TableName allTableName)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		TableName		 exposedName;
1:c83a399:         TableName        toCompare;
1:eac0369: 
1:eac0369: 
1:c83a399: 		if(allTableName != null)
1:c83a399:              toCompare = makeTableName(allTableName.getSchemaName(),correlationName);
1:c83a399:         else
1:c83a399:             toCompare = makeTableName(null,correlationName);
1:c83a399:         
1:c83a399:         if ( allTableName != null &&
1:c83a399:              ! allTableName.equals(toCompare))
1:c83a399:         {
1:c83a399:             return null;
1:c83a399:         }
1:eac0369: 
1:eac0369: 		/* Cache exposed name for this table.
1:eac0369: 		 * The exposed name becomes the qualifier for each column
1:eac0369: 		 * in the expanded list.
1:eac0369: 		 */
1:eac0369: 		exposedName = makeTableName(null, correlationName);
1:eac0369: 
1:3bb140c:         ResultColumnList rcList = new ResultColumnList((getContextManager()));
1:eac0369: 
1:eac0369: 		/* Build a new result column list based off of resultColumns.
1:eac0369: 		 * NOTE: This method will capture any column renaming due to 
1:eac0369: 		 * a derived column list.
1:eac0369: 		 */
1:2060c4a: 
1:2060c4a: 		// Use visibleSize, because we don't want to propagate any order by
1:2060c4a: 		// columns not selected.
1:11f7ee3: 		int rclSize = getResultColumns().visibleSize();
1:5ae7bc1: 
1:5ae7bc1: 		for (int index = 0; index < rclSize; index++)
1:eac0369: 		{
1:11f7ee3: 			ResultColumn resultColumn = getResultColumns().elementAt(index);
1:eac0369: 			ValueNode		 valueNode;
1:eac0369: 			String			 columnName;
1:2060c4a: 
1:eac0369: 			if (resultColumn.isGenerated())
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Build a ResultColumn/ColumnReference pair for the column //
1:eac0369: 			columnName = resultColumn.getName();
1:eac0369: 			boolean isNameGenerated = resultColumn.isNameGenerated();
1:eac0369: 
1:eac0369: 			/* If this node was generated for a GROUP BY, then tablename for the CR, if any,
1:eac0369: 			 * comes from the source RC.
1:eac0369: 			 */
1:eac0369: 			TableName tableName;
1:eac0369: 
1:41943bb: 			tableName = exposedName;
1:41943bb: 
1:3bb140c:             valueNode = new ColumnReference(columnName,
1:eac0369: 											tableName,
3:eac0369: 											getContextManager());
1:801cf0d:             resultColumn = new ResultColumn(columnName,
1:eac0369: 											valueNode,
1:eac0369: 											getContextManager());
1:eac0369: 
1:eac0369: 			resultColumn.setNameGenerated(isNameGenerated);
1:eac0369: 			// Build the ResultColumnList to return //
1:eac0369: 			rcList.addResultColumn(resultColumn);
1:eac0369: 		}
1:eac0369: 		return rcList;
1:2d2e717: 	}
1:2d2e717: 
1:2d2e717: 	/**
1:eac0369: 	 * Search to see if a query references the specifed table name.
1:eac0369: 	 *
1:eac0369: 	 * @param name		Table name (String) to search for.
1:eac0369: 	 * @param baseTable	Whether or not name is for a base table
1:eac0369: 	 *
1:eac0369: 	 * @return	true if found, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean referencesTarget(String name, boolean baseTable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return subquery.referencesTarget(name, baseTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return subquery.referencesSessionSchema();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
1:eac0369: 	 *
1:eac0369: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		subquery.bindUntypedNullsToResultColumns(bindingRCL);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Decrement (query block) level (0-based) for this FromTable.
1:eac0369: 	 * This is useful when flattening a subquery.
1:eac0369: 	 *
1:eac0369: 	 * @param decrement	The amount to decrement by.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void decrementLevel(int decrement)
1:eac0369: 	{
1:eac0369: 		super.decrementLevel(decrement);
1:eac0369: 		subquery.decrementLevel(decrement);
1:eac0369: 	}
1:392ac57: 
1:392ac57: 	/**
1:392ac57: 	 * Associate this subquery with the original compilation schema of a view.
1:392ac57: 	 *
1:392ac57: 	 * @param sd schema descriptor of the original compilation schema of the
1:392ac57: 	 * view.
1:392ac57: 	 */
1:3bb140c:     void setOrigCompilationSchema(SchemaDescriptor sd) {
1:392ac57: 		origCompilationSchema = sd;
1:392ac57: 	}
1:7bfb37a: 
1:7bfb37a:     /**
1:7bfb37a:      * @see QueryTreeNode#acceptChildren
1:7bfb37a:      */
1:3bb140c:     @Override
1:7bfb37a:     void acceptChildren(Visitor v)
1:7bfb37a:         throws StandardException
1:7bfb37a:     {
1:7bfb37a:         super.acceptChildren(v);
1:7bfb37a: 
1:7bfb37a:         subquery.accept(v);
1:7bfb37a: 
1:7bfb37a:         if (orderByList != null) {
1:7bfb37a:             orderByList.accept(v);
1:7bfb37a:         }
1:7bfb37a: 
1:7bfb37a:         if (offset != null) {
1:7bfb37a:             offset.accept(v);
1:7bfb37a:         }
1:7bfb37a: 
1:7bfb37a:         if (fetchFirst != null) {
1:7bfb37a:             fetchFirst.accept(v);
1:7bfb37a:         }
1:7bfb37a:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( derivedRCL );
/////////////////////////////////////////////////////////////////////////
1: 		ResultColumnList	derivedRCL = getResultColumns();
/////////////////////////////////////////////////////////////////////////
1: 		if (getResultColumns() != null && getResultColumns().getCountMismatchAllowed() &&
1: 			getResultColumns().size() < subqueryRCL.size())
1: 				 index >= getResultColumns().size(); 
/////////////////////////////////////////////////////////////////////////
1:          setResultColumns( newRcl );
1:             getResultColumns().propagateDCLInfo(derivedRCL, correlationName);
/////////////////////////////////////////////////////////////////////////
1: 			resultColumn = getResultColumns().getResultColumn(columnReference.getColumnName());
1: 		    resultColumn = getResultColumns().getAtMostOneResultColumn(columnReference, correlationName, false);
/////////////////////////////////////////////////////////////////////////
1: 								getResultColumns(),	/* Projection */
/////////////////////////////////////////////////////////////////////////
1: 		getResultColumns().setRedundant();
/////////////////////////////////////////////////////////////////////////
1: 		int rclSize = getResultColumns().visibleSize();
1: 			ResultColumn resultColumn = getResultColumns().elementAt(index);
commit:3468143
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
0: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
1:         // Nested VTI/tableFunctions will want to know whether their arguments
1:         // reference tables in the FROM list which contains this subquery. Those
1:         // references are illegal. See DERBY-5554 and DERBY-5779.
0: 		CollectNodesVisitor nestedVTIs = new CollectNodesVisitor( FromVTI.class );
1: 		subquery.accept( nestedVTIs );
0: 		Vector vtiRefs = nestedVTIs.getList();
0: 		for (Enumeration e = vtiRefs.elements(); e.hasMoreElements(); )
1: 		{
0: 			FromVTI ref = (FromVTI) e.nextElement();
1:             ref.addOuterFromList( fromListParam );
1: 		}
1:         
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:     private boolean hasJDBClimitClause; // true if using JDBC limit/offset escape syntax
/////////////////////////////////////////////////////////////////////////
0: 	 * @param hasJDBClimitClause True if the offset/fetchFirst clauses come from JDBC limit/offset escape syntax
/////////////////////////////////////////////////////////////////////////
0:                     Object hasJDBClimitClause,
/////////////////////////////////////////////////////////////////////////
0:         this.hasJDBClimitClause = (hasJDBClimitClause == null) ? false : ((Boolean) hasJDBClimitClause).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:         subquery.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1:         subquery.pushQueryExpressionSuffix();
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:             resultColumn = new ResultColumn(columnName,
commit:5ae7bc1
/////////////////////////////////////////////////////////////////////////
0: 		int rclSize = resultColumns.visibleSize();
1: 
1: 		for (int index = 0; index < rclSize; index++)
0: 			ResultColumn resultColumn = resultColumns.elementAt(index);
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
0:         for (ResultColumn resultColumn : resultColumns)
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: class FromSubquery extends FromTable
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a table in a FROM list.
1:      * @param hasJDBClimitClause True if the offset/fetchFirst clauses come
1:      *                      from JDBC limit/offset escape syntax
1:      * @param cm            The context manager
1:     FromSubquery(ResultSetNode subquery,
1:                  OrderByList orderByList,
1:                  ValueNode offset,
1:                  ValueNode fetchFirst,
1:                  boolean hasJDBClimitClause,
1:                  String correlationName,
1:                  ResultColumnList derivedRCL,
1:                  Properties tableProperties,
1:                  ContextManager cm)
1:         super(correlationName, tableProperties, cm);
0:         setNodeType(C_NodeTypes.FROM_SUBQUERY);
1:         this.subquery = subquery;
1:         this.orderByList = orderByList;
1:         this.offset = offset;
1:         this.fetchFirst = fetchFirst;
1:         this.hasJDBClimitClause = hasJDBClimitClause;
0:         resultColumns = derivedRCL;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     ResultSetNode getSubquery()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode bindVTITables(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void rejectParameters() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindExpressions(FromList fromListParam)
1:         FromList            emptyFromList = new FromList(
1:                 getOptimizerFactory().doJoinOrderOptimization(),
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultColumn getMatchingColumn(ColumnReference columnReference)
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     ResultSetNode extractSubquery(int numTables)
1:         newPRN = new ProjectRestrictNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     FromList flatten(ResultColumnList rcl,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getExposedName()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultColumnList getAllResultColumns(TableName allTableName)
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList rcList = new ResultColumnList((getContextManager()));
/////////////////////////////////////////////////////////////////////////
1:             valueNode = new ColumnReference(columnName,
0:            resultColumn = new ResultColumn(columnName,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean referencesTarget(String name, boolean baseTable)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void setOrigCompilationSchema(SchemaDescriptor sd) {
1:     @Override
commit:7bfb37a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @see QueryTreeNode#acceptChildren
1:      */
1:     void acceptChildren(Visitor v)
1:         throws StandardException
1:     {
1:         super.acceptChildren(v);
1: 
1:         subquery.accept(v);
1: 
1:         if (orderByList != null) {
1:             orderByList.accept(v);
1:         }
1: 
1:         if (offset != null) {
1:             offset.accept(v);
1:         }
1: 
1:         if (fetchFirst != null) {
1:             fetchFirst.accept(v);
1:         }
1:     }
commit:74d0488
/////////////////////////////////////////////////////////////////////////
1:         if (schemaName != null && origTableName != null) {
1:             // View can have schema
1:             if (!schemaName.equals(origTableName.schemaName)) {
1:                 return null;
1:             }
1:             // So far, so good, now go on to compare table name
1:         }
1: 
1:         if (getExposedName().equals(name)) {
1:             return this;
1:         }
1: 
1:         return null;
commit:ee21e7c
/////////////////////////////////////////////////////////////////////////
1:             columnReference.setColumnNumber(resultColumn.getColumnPosition());
commit:2e7e8f6
/////////////////////////////////////////////////////////////////////////
1:      * @param havingClause      The HAVING clause, if any
/////////////////////////////////////////////////////////////////////////
1:                             GroupByList gbl,
1:                             ValueNode havingClause)
/////////////////////////////////////////////////////////////////////////
1:         if (havingClause != null) {
1:             havingClause.remapColumnReferencesToExpressions();
1:         }
1: 
commit:7b48c50
/////////////////////////////////////////////////////////////////////////
1:         /* NOTE: If the size of the derived column list is less than
/////////////////////////////////////////////////////////////////////////
1:         /*
1:          * Create RCL based on subquery, adding a level of VCNs.
1:          */
1:          ResultColumnList newRcl = subqueryRCL.copyListAndObjects();
1:          newRcl.genVirtualColumnNodes(subquery, subquery.getResultColumns());
0:          resultColumns = newRcl;
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:     private ValueNode offset;
1:     private ValueNode fetchFirst;
/////////////////////////////////////////////////////////////////////////
1:      * @param offset        OFFSET if any, or null
1:      * @param fetchFirst    FETCH FIRST if any, or null
/////////////////////////////////////////////////////////////////////////
0:                     Object offset,
0:                     Object fetchFirst,
/////////////////////////////////////////////////////////////////////////
0:         this.offset = (ValueNode)offset;
0:         this.fetchFirst = (ValueNode)fetchFirst;
/////////////////////////////////////////////////////////////////////////
1:             if (orderByList != null)
1:             {
1:                 printLabel(depth, "orderByList: ");
1:                 orderByList.treePrint(depth + 1);
1:             }
1: 
1:             if (offset != null)
1:             {
1:                 printLabel(depth, "offset: ");
1:                 offset.treePrint(depth + 1);
1:             }
1: 
1:             if (fetchFirst != null)
1:             {
1:                 printLabel(depth, "fetchFirst: ");
1:                 fetchFirst.treePrint(depth + 1);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         bindOffsetFetch(offset, fetchFirst);
1: 
/////////////////////////////////////////////////////////////////////////
0:         subquery.pushOffsetFetchFirst(offset, fetchFirst);
1: 
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	private OrderByList orderByList;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param orderByList   ORDER BY list if any, or null
0: 					Object orderByList,
0: 		this.orderByList = (OrderByList)orderByList;
/////////////////////////////////////////////////////////////////////////
1: 
1: 			if (orderByList != null)
1: 			{
0: 				printLabel(depth, "orderByList: ");
0: 				orderByList.treePrint(depth + 1);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		if (orderByList != null) {
1: 			orderByList.pullUpOrderByColumns(subquery);
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (orderByList != null) {
1: 			orderByList.bindOrderByColumns(subquery);
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// Push the order by list down to the ResultSet
0: 		if (orderByList != null)
1: 		{
1: 			// If we have more than 1 ORDERBY columns, we may be able to
1: 			// remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1: 			if (orderByList.size() > 1)
1: 			{
1: 				orderByList.removeDupColumns();
1: 			}
1: 
1: 			subquery.pushOrderByList(orderByList);
1: 			orderByList = null;
1: 		}
1: 
1: 		 * Another complication is that we want to be able to only push
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// Use visibleSize, because we don't want to propagate any order by
1: 		// columns not selected.
0: 		int rclSize = resultColumns.visibleSize();
1: 
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
commit:392ac57
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 	 * DERBY-3270: If this subquery represents an expanded view, this holds the
1: 	 * current compilation schema at view definition time.
1: 	 */
1: 	private SchemaDescriptor origCompilationSchema = null;
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 		CompilerContext compilerContext = getCompilerContext();
1: 
1: 		if (origCompilationSchema != null) {
1: 			// View expansion needs the definition time schema
1: 			compilerContext.pushCompilationSchema(origCompilationSchema);
1: 		}
1: 
1: 		try {
1: 			subquery.bindExpressions(nestedFromList);
1: 			subquery.bindResultColumns(nestedFromList);
1: 		} finally {
1: 			if (origCompilationSchema != null) {
1: 				compilerContext.popCompilationSchema();
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Associate this subquery with the original compilation schema of a view.
1: 	 *
1: 	 * @param sd schema descriptor of the original compilation schema of the
1: 	 * view.
1: 	 */
0: 	public void setOrigCompilationSchema(SchemaDescriptor sd) {
1: 		origCompilationSchema = sd;
1: 	}
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         CollectNodesVisitor<FromVTI> nestedVTIs =
1:                 new CollectNodesVisitor<FromVTI>(FromVTI.class);
1:         for (FromVTI ref : nestedVTIs.getList())
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
commit:c0a807c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List vtiRefs = nestedVTIs.getList();
0: 		for (Iterator it = vtiRefs.iterator(); it.hasNext(); )
0: 			FromVTI ref = (FromVTI) it.next();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:41943bb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			return  super.toString();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		return super.getFromTableByName(name, schemaName, exactMatch);
/////////////////////////////////////////////////////////////////////////
1: 		 * to subquery.bindExpressions() and .bindResultColumns()
1: 		nestedFromList = emptyFromList;
/////////////////////////////////////////////////////////////////////////
1: 		// post 681, 1 may be no longer needed. 5 is the default case
1: 		// now but what happens if the condition is false? Investigate.
/////////////////////////////////////////////////////////////////////////
1: 			tableName = exposedName;
1: 
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
0: 		    resultColumn = resultColumns.getAtMostOneResultColumn(columnReference, correlationName, false);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param subquery		The subquery
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
1: 		FromList			nestedFromList;
0: 		 * to subquery.bindExpressions() and .bindResultColumns(). However,
0: 		 * the parser rewrites queries which have GROUP BY and HAVING clauses.
0: 		 * For these rewritten pseudo-subqueries, we need to pass in the outer FromList
0: 		 * which contains correlated tables.
0: 		if ( generatedForGroupByClause || generatedForHavingClause )
0: 		{ nestedFromList = fromListParam; }
0: 		else { nestedFromList = emptyFromList; }
1: 		
0: 		subquery.bindExpressions(nestedFromList);
0: 		subquery.bindResultColumns(nestedFromList);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 	/** 
0: 	 * @see QueryTreeNode#disablePrivilegeCollection
1: 	 */
0: 	public void disablePrivilegeCollection()
1: 	{
0: 		super.disablePrivilegeCollection();
0: 		subquery.disablePrivilegeCollection();
1: 	}
1: 
commit:c83a399
/////////////////////////////////////////////////////////////////////////
0: 	public ResultColumnList getAllResultColumns(TableName allTableName)
1:         TableName        toCompare;
1: 		if(allTableName != null)
1:              toCompare = makeTableName(allTableName.getSchemaName(),correlationName);
1:         else
1:             toCompare = makeTableName(null,correlationName);
1:         
1:         if ( allTableName != null &&
1:              ! allTableName.equals(toCompare))
1:         {
1:             return null;
1:         }
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.FromSubquery
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * A FromSubquery represents a subquery in the FROM list of a DML statement.
1:  *
1:  * The current implementation of this class is only
1:  * sufficient for Insert's need to push a new
1:  * select on top of the one the user specified,
1:  * to make the selected structure match that
1:  * of the insert target table.
1:  *
0:  * @author Jeff Lichtman
1:  */
0: public class FromSubquery extends FromTable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	boolean			generatedForGroupByClause;
0: 	boolean			generatedForHavingClause;
1: 	ResultSetNode	subquery;
1: 
1: 	/**
0: 	 * Intializer for a table in a FROM list.
1: 	 *
0: 	 * @param tableName		The name of the table
1: 	 * @param correlationName	The correlation name
1: 	 * @param derivedRCL		The derived column list
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 */
0: 	public void init(
0: 					Object subquery,
0: 					Object correlationName,
0: 				 	Object derivedRCL,
0: 					Object tableProperties)
1: 	{
0: 		super.init(correlationName, tableProperties);
0: 		this.subquery = (ResultSetNode) subquery;
0: 		resultColumns = (ResultColumnList) derivedRCL;
1: 	}
1: 
1: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
1: 	 *
0: 	 * @return	This object as a String
1: 	 */
1: 
0: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return
0: 			  "generatedForGroupByClause: " + generatedForGroupByClause + "\n" +
0: 			  "generatedForHavingClause: " + generatedForHavingClause + "\n" +
0: 			  super.toString();
1: 		}
0: 		else
1: 		{
0: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			super.printSubNodes(depth);
1: 
1: 			if (subquery != null)
1: 			{
1: 				printLabel(depth, "subquery: ");
1: 				subquery.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Return the "subquery" from this node.
1: 	 *
1: 	 * @return ResultSetNode	The "subquery" from this node.
1: 	 */
0: 	public ResultSetNode getSubquery()
1: 	{
1: 		return subquery;
1: 	}
1: 
1: 	/**
0: 	 * Mark this FromSubquery as being generated for a GROUP BY clause.
0: 	 * (This node represents the SELECT thru GROUP BY clauses.  We
0: 	 * appear in the FromList of a SelectNode generated to represent
0: 	 * the result of the GROUP BY.  This allows us to add ResultColumns
0: 	 * to the SelectNode for the user's query.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void markAsForGroupByClause()
1: 	{
0: 		generatedForGroupByClause = true;
1: 	}
1: 
1: 	/**
0: 	 * Mark this FromSubquery as being generated for a HAVING clause.
0: 	 * (This node represents the SELECT thru GROUP BY clauses.  We
0: 	 * appear in the FromList of a SelectNode generated to represent
0: 	 * the actual HAVING clause.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void markAsForHavingClause()
1: 	{
0: 		generatedForHavingClause = true;
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
0: 		if (generatedForGroupByClause || generatedForHavingClause)
1: 		{
0: 			return subquery.getFromTableByName(name, schemaName, exactMatch);
1: 		}
0: 		else 
1: 		{
0: 			return super.getFromTableByName(name, schemaName, exactMatch);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this subquery that appears in the FROM list.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for binding
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
1: 	 * @return	ResultSetNode		The bound FromSubquery.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
1: 						  FromList fromListParam) 
1: 							throws StandardException
1: 	{
1: 		/* Assign the tableNumber */
1: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1: 			tableNumber = getCompilerContext().getNextTableNumber();
1: 
1: 		subquery = subquery.bindNonVTITables(dataDictionary, fromListParam);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind this subquery that appears in the FROM list.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
1: 	 * @return	ResultSetNode		The bound FromSubquery.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode bindVTITables(FromList fromListParam) 
1: 							throws StandardException
1: 	{
1: 		subquery = subquery.bindVTITables(fromListParam);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
1: 	 * This is done for SELECT statements.  For FromSubquery, we
1: 	 * simply pass the check through to the subquery.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown if a ? parameter found
1: 	 *									directly under a ResultColumn
1: 	 */
1: 
0: 	public void rejectParameters() throws StandardException
1: 	{
1: 		subquery.rejectParameters();
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in this FromSubquery.  This means 
1: 	 * binding the sub-expressions, as well as figuring out what the return 
1: 	 * type is for each expression.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindExpressions(FromList fromListParam)
1: 					throws StandardException
1: 	{
0: 		FromList			emptyFromList =
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
1: 									getContextManager());
0: 		ResultColumnList	derivedRCL = resultColumns;
1: 		ResultColumnList	subqueryRCL;
1: 
1: 		/* From subqueries cannot be correlated, so we pass an empty FromList
0: 		 * to subquery.bindExpressions() and .bindResultColumns().
1: 		 */
0: 		subquery.bindExpressions(emptyFromList);
0: 		subquery.bindResultColumns(emptyFromList);
1: 
0: 		/* Now that we've bound the expressions in the subquery, we 
0: 		 * can propagate the subquery's RCL up to the FromSubquery.
0: 		 * Get the subquery's RCL, assign shallow copy back to
0: 		 * it and create new VirtualColumnNodes for the original's
0: 		 * ResultColumn.expressions.
0: 		 * NOTE: If the size of the derived column list is less than
1: 		 * the size of the subquery's RCL and the derived column list is marked
1: 		 * for allowing a size mismatch, then we have a select * view
1: 		 * on top of a table that has had columns added to it via alter table.
1: 		 * In this case, we trim out the columns that have been added to
1: 		 * the table since the view was created.
1: 		 */
1: 		subqueryRCL = subquery.getResultColumns();
0: 		if (resultColumns != null && resultColumns.getCountMismatchAllowed() &&
0: 			resultColumns.size() < subqueryRCL.size())
1: 		{
1: 			for (int index = subqueryRCL.size() - 1; 
0: 				 index >= resultColumns.size(); 
1: 				 index--)
1: 			{
1: 				subqueryRCL.removeElementAt(index);
1: 			}
1: 		}
1: 
0: 		subquery.setResultColumns(subqueryRCL.copyListAndObjects());
0: 		subqueryRCL.genVirtualColumnNodes(subquery, subquery.getResultColumns());
0: 		resultColumns = subqueryRCL;
1: 
1: 		/* Propagate the name info from the derived column list */
1: 		if (derivedRCL != null)
1: 		{
0: 			 resultColumns.propagateDCLInfo(derivedRCL, correlationName);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Try to find a ResultColumn in the table represented by this FromBaseTable
1: 	 * that matches the name in the given ColumnReference.
1: 	 *
1: 	 * @param columnReference	The columnReference whose name we're looking
1: 	 *				for in the given table.
1: 	 *
1: 	 * @return	A ResultColumn whose expression is the ColumnNode
1: 	 *			that matches the ColumnReference.
1: 	 *		Returns null if there is no match.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultColumn getMatchingColumn(ColumnReference columnReference) throws StandardException
1: 	{
1: 		ResultColumn	resultColumn = null;
1: 		String			columnsTableName;
1: 
1: 		/*
1: 		** RESOLVE: When we add support for schemas, check to see if
1: 		** the column name specifies a schema, and if so, if this
1: 		** table is in that schema.
1: 		*/
1: 
1: 		columnsTableName = columnReference.getTableName();
1: 
0: 		/* We have 5 cases here:
0: 		 *  1.  ColumnReference was generated to replace an aggregate.
0: 		 *		(We are the wrapper for a HAVING clause and the ColumnReference
0: 		 *		was generated to reference the aggregate which was pushed down into
0: 		 *		the SELECT list in the user's query.)  
0: 		 *		Just do what you would expect.  Try to resolve the
0: 		 *		ColumnReference against our RCL if the ColumnReference is unqualified
0: 		 *		or if it is qualified with our exposed name.
0: 		 *	2.	We are the wrapper for a GROUP BY and a HAVING clause and
0: 		 *		either the ColumnReference is qualified or it is in
0: 		 *		the HAVING clause.  For example:
0: 		 *			select a from t1 group by a having t1.a = 1
0: 		 *			select a as asdf from t1 group by a having a = 1
0: 		 *		We need to match against the underlying FromList and then find
0: 		 *		the grandparent ResultColumn in our RCL so that we return a
0: 		 *		ResultColumn from the correct ResultSetNode.  It is okay not to
0: 		 *		find a matching grandparent node.  In fact, this is how we ensure
0: 		 *		the correct semantics for ColumnReferences in the HAVING clause
0: 		 *		(which must be bound against the GROUP BY list.)
0: 		 *  3.	We are the wrapper for a HAVING clause without a GROUP BY and
0: 		 *		the ColumnReference is from the HAVING clause.  ColumnReferences
0: 		 *		are invalid in this case, so we return null.
0: 		 *  4.  We are the wrapper for a GROUP BY with no HAVING.  This has
0: 		 *		to be a separate case because of #5 and the following query:
0: 		 *			select * from (select c1 from t1) t, (select c1 from t1) tt
0: 		 *			group by t1.c1, tt.c1
0: 		 *		(The correlation names are lost in the generated FromSuquery.)
0: 		 *  5.  Everything else - do what you would expect.  Try to resolve the
0: 		 *		ColumnReference against our RCL if the ColumnReference is unqualified
0: 		 *		or if it is qualified with our exposed name.
1: 		 */
1: 		if (columnReference.getGeneratedToReplaceAggregate()) // 1
1: 		{
0: 			resultColumn = resultColumns.getResultColumn(columnReference.getColumnName());
1: 		}
0: 		else if (generatedForGroupByClause && generatedForHavingClause &&
0: 			     (columnsTableName != null || 
0: 			      columnReference.getClause() != ValueNode.IN_SELECT_LIST)) // 2
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				SanityManager.ASSERT(correlationName == null,
0: 					"correlationName expected to be null");
0: 				SanityManager.ASSERT(subquery instanceof SelectNode,
0: 					"subquery expected to be instanceof SelectNode, not " +
0: 					subquery.getClass().getName());
1: 			}
1: 
0: 			SelectNode		select = (SelectNode) subquery;
1: 
0: 			resultColumn = select.getFromList().bindColumnReference(columnReference);
1: 
0: 			/* Find and return the matching RC from our RCL.
0: 			 * (Not an error if no match found.  Let ColumnReference deal with it.
1: 			 */
1: 			if (resultColumn != null)
1: 			{
0: 				/* Is there a matching resultColumn in the subquery's RCL? */
0: 				resultColumn = subquery.getResultColumns().findParentResultColumn(
0: 												resultColumn);
1: 				if (resultColumn != null)
1: 				{
0: 					/* Is there a matching resultColumn in our RCL? */
0: 					resultColumn = resultColumns.findParentResultColumn(
0: 												resultColumn);
1: 				}
1: 			}
1: 		}
0: 		else if ((generatedForHavingClause && ! generatedForGroupByClause) // 3
0: 			 && (columnReference.getClause() != ValueNode.IN_SELECT_LIST) )
1: 		{
0: 		    resultColumn = null;
1: 		}
0: 		else if (generatedForGroupByClause) // 4
1: 		{
0: 		        resultColumn = resultColumns.getResultColumn(
0: 								     columnsTableName,
0: 								     columnReference.getColumnName());
1: 		}
1: 		else if (columnsTableName == null || columnsTableName.equals(correlationName)) // 5?
1: 		{
0: 		    resultColumn = resultColumns.getAtMostOneResultColumn(columnReference, correlationName);
1: 		}
1: 		    
1: 
1: 		if (resultColumn != null)
1: 		{
1: 			columnReference.setTableNumber(tableNumber);
1: 		}
1: 
1: 		return resultColumn;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess a ResultSetNode - this currently means:
1: 	 *	o  Generating a referenced table map for each ResultSetNode.
1: 	 *  o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF).
1: 	 *  o  Converting the WHERE and HAVING clauses into PredicateLists and
1: 	 *	   classifying them.
1: 	 *  o  Ensuring that a ProjectRestrictNode is generated on top of every 
1: 	 *     FromBaseTable and generated in place of every FromSubquery.  
1: 	 *  o  Pushing single table predicates down to the new ProjectRestrictNodes.
1: 	 *
1: 	 * @param numTables			The number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return ResultSetNode at top of preprocessed tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1: 		/* We want to chop out the FromSubquery from the tree and replace it 
1: 		 * with a ProjectRestrictNode.  One complication is that there may be 
1: 		 * ColumnReferences above us which point to the FromSubquery's RCL.
1: 		 * What we want to return is a tree with a PRN with the
1: 		 * FromSubquery's RCL on top.  (In addition, we don't want to be
1: 		 * introducing any redundant ProjectRestrictNodes.)
0: 		 * Another complication is that we want to be able to only only push
1: 		 * projections and restrictions down to this ProjectRestrict, but
1: 		 * we want to be able to push them through as well.
1: 		 * So, we:
1: 		 *		o call subquery.preprocess() which returns a tree with
1: 		 *		  a SelectNode or a RowResultSetNode on top.  
1: 		 *		o If the FSqry is flattenable(), then we return (so that the
1: 		 *		  caller can then call flatten()), otherwise we:
1: 		 *		o generate a PRN, whose RCL is the FSqry's RCL, on top of the result.
1: 		 *		o create a referencedTableMap for the PRN which represents 
1: 		 *		  the FSqry's tableNumber, since ColumnReferences in the outer
1: 		 *		  query block would be referring to that one.  
1: 		 *		  (This will allow us to push restrictions down to the PRN.)
1: 		 */
1: 
1: 		subquery = subquery.preprocess(numTables, gbl, fromList);
1: 
1: 		/* Return if the FSqry is flattenable() 
1: 		 * NOTE: We can't flatten a FromSubquery if there is a group by list
1: 		 * because the group by list must be ColumnReferences.  For:
1: 		 *	select c1 from v1 group by c1,
1: 		 *	where v1 is select 1 from t1
1: 		 * The expression under the last redundant ResultColumn is an IntConstantNode,
1: 		 * not a ColumnReference.
1: 		 * We also do not flatten a subquery if tableProperties is non-null,
1: 		 * as the user is specifying 1 or more properties for the derived table,
1: 		 * which could potentially be lost on the flattening.
1: 		 * RESOLVE - this is too restrictive.
1: 		 */
1: 		if ((gbl == null || gbl.size() == 0) &&
1: 			tableProperties == null &&
1: 		    subquery.flattenableInFromSubquery(fromList))
1: 		{
1: 			/* Set our table map to the subquery's table map. */
1: 			setReferencedTableMap(subquery.getReferencedTableMap());
1: 			return this;
1: 		}
1: 
1: 		return extractSubquery(numTables);
1: 	}
1: 
1: 	/**
1: 	 * Extract out and return the subquery, with a PRN on top.
1: 	 * (See FromSubquery.preprocess() for more details.)
1: 	 *
1: 	 * @param numTables			The number of tables in the DML Statement
1: 	 *
1: 	 * @return ResultSetNode at top of extracted tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode extractSubquery(int numTables)
1: 		throws StandardException
1: 	{
1: 		JBitSet		  newJBS;
1: 		ResultSetNode newPRN;
1: 
0: 		newPRN = (ResultSetNode) getNodeFactory().getNode(
0: 								C_NodeTypes.PROJECT_RESTRICT_NODE,
1: 								subquery,		/* Child ResultSet */
0: 								resultColumns,	/* Projection */
1: 								null,			/* Restriction */
1: 								null,			/* Restriction as PredicateList */
1: 								null,			/* Subquerys in Projection */
1: 								null,			/* Subquerys in Restriction */
1: 								tableProperties,
1: 								getContextManager()	 );
1: 
1: 		/* Set up the PRN's referencedTableMap */
1: 		newJBS = new JBitSet(numTables);
1: 		newJBS.set(tableNumber);
1: 		newPRN.setReferencedTableMap(newJBS);
1: 		((FromTable) newPRN).setTableNumber(tableNumber);
1: 
1: 		return newPRN;
1: 	}
1: 
1: 	/**
1: 	 * Flatten this FSqry into the outer query block. The steps in
1: 	 * flattening are:
1: 	 *	o  Mark all ResultColumns as redundant, so that they are "skipped over"
1: 	 *	   at generate().
1: 	 *	o  Append the wherePredicates to the outer list.
1: 	 *	o  Return the fromList so that the caller will merge the 2 lists 
1: 	 *  RESOLVE - FSqrys with subqueries are currently not flattenable.  Some of
1: 	 *  them can be flattened, however.  We need to merge the subquery list when
1: 	 *  we relax this restriction.
1: 	 *
1: 	 * NOTE: This method returns NULL when flattening RowResultSetNodes
1: 	 * (the node for a VALUES clause).  The reason is that no reference
1: 	 * is left to the RowResultSetNode after flattening is done - the
1: 	 * expressions point directly to the ValueNodes in the RowResultSetNode's
1: 	 * ResultColumnList.
1: 	 *
1: 	 * @param rcl				The RCL from the outer query
1: 	 * @param outerPList	PredicateList to append wherePredicates to.
1: 	 * @param sql				The SubqueryList from the outer query
1: 	 * @param gbl				The group by list, if any
1: 	 *
1: 	 * @return FromList		The fromList from the underlying SelectNode.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public FromList flatten(ResultColumnList rcl,
1: 							PredicateList outerPList,
1: 							SubqueryList sql,
0: 							GroupByList gbl)
1: 
1: 			throws StandardException
1: 	{
1: 		FromList	fromList = null;
1: 		SelectNode	selectNode;
1: 
0: 		resultColumns.setRedundant();
1: 
1: 		subquery.getResultColumns().setRedundant();
1: 
1: 		/*
1: 		** RESOLVE: Each type of result set should know how to remap itself.
1: 		*/
1: 		if (subquery instanceof SelectNode)
1: 		{
1: 			selectNode = (SelectNode) subquery;
1: 			fromList = selectNode.getFromList();
1: 
1: 			// selectNode.getResultColumns().setRedundant();
1: 
1: 			if (selectNode.getWherePredicates().size() > 0)
1: 			{
1: 				outerPList.destructiveAppend(selectNode.getWherePredicates());
1: 			}
1: 
1: 			if (selectNode.getWhereSubquerys().size() > 0)
1: 			{
1: 				sql.destructiveAppend(selectNode.getWhereSubquerys());
1: 			}
1: 		}
1: 		else if ( ! (subquery instanceof RowResultSetNode))
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.THROWASSERT("subquery expected to be either a SelectNode or a RowResultSetNode, but is a " + subquery.getClass().getName());
1: 			}
1: 		}
1: 
1: 		/* Remap all ColumnReferences from the outer query to this node.
1: 		 * (We replace those ColumnReferences with clones of the matching
1: 		 * expression in the SELECT's RCL.
1: 		 */
1: 		rcl.remapColumnReferencesToExpressions();
1: 		outerPList.remapColumnReferencesToExpressions();
1: 		if (gbl != null)
1: 		{
1: 			gbl.remapColumnReferencesToExpressions();
1: 		}
1: 
1: 		return fromList;
1: 	}
1: 
1: 	/**
1: 	 * Get the exposed name for this table, which is the name that can
1: 	 * be used to refer to it in the rest of the query.
1: 	 *
1: 	 * @return	The exposed name for this table.
1: 	 */
1: 
0: 	public String getExposedName()
1: 	{
1: 		return correlationName;
1: 	}
1: 
1: 	/**
1: 	 * Expand a "*" into a ResultColumnList with all of the
1: 	 * result columns from the subquery.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultColumnList getAllResultColumns(String allTableName)
1: 			throws StandardException
1: 	{
0: 		ResultColumnList rcList = null;
1: 		TableName		 exposedName;
1: 
1: 
0: 		if (allTableName != null && ! allTableName.equals(getExposedName()))
1: 		{
0: 			return null;
1: 		}
1: 
1: 		/* Cache exposed name for this table.
1: 		 * The exposed name becomes the qualifier for each column
1: 		 * in the expanded list.
1: 		 */
1: 		exposedName = makeTableName(null, correlationName);
1: 
0: 		rcList = (ResultColumnList) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN_LIST,
1: 										getContextManager());
1: 
1: 		/* Build a new result column list based off of resultColumns.
1: 		 * NOTE: This method will capture any column renaming due to 
1: 		 * a derived column list.
1: 		 */
0: 		int rclSize = resultColumns.size();
0: 		for (int index = 0; index < rclSize; index++)
1: 		{
0: 			ResultColumn resultColumn = (ResultColumn) resultColumns.elementAt(index);
1: 			ValueNode		 valueNode;
1: 			String			 columnName;
1: 
1: 			if (resultColumn.isGenerated())
1: 			{
1: 				continue;
1: 			}
1: 
1: 			// Build a ResultColumn/ColumnReference pair for the column //
1: 			columnName = resultColumn.getName();
1: 			boolean isNameGenerated = resultColumn.isNameGenerated();
1: 
1: 			/* If this node was generated for a GROUP BY, then tablename for the CR, if any,
1: 			 * comes from the source RC.
1: 			 */
1: 			TableName tableName;
1: 
0: 			if (correlationName == null && generatedForGroupByClause)
1: 			{
0: 				tableName = makeTableName(null, resultColumn.getTableName());
1: 			}
0: 			else
1: 			{
0: 				tableName = exposedName;
1: 			}
0: 			valueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.COLUMN_REFERENCE,
0: 											columnName,
1: 											tableName,
1: 											getContextManager());
0: 			resultColumn = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											columnName,
1: 											valueNode,
1: 											getContextManager());
1: 
1: 			resultColumn.setNameGenerated(isNameGenerated);
1: 			// Build the ResultColumnList to return //
1: 			rcList.addResultColumn(resultColumn);
1: 		}
1: 		return rcList;
1: 	}
1: 
1: 	/**
1: 	 * Search to see if a query references the specifed table name.
1: 	 *
1: 	 * @param name		Table name (String) to search for.
1: 	 * @param baseTable	Whether or not name is for a base table
1: 	 *
1: 	 * @return	true if found, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
1: 		throws StandardException
1: 	{
1: 		return subquery.referencesTarget(name, baseTable);
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		return subquery.referencesSessionSchema();
1: 	}
1: 
1: 	/**
1: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
1: 	 *
1: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
1: 				throws StandardException
1: 	{
1: 		subquery.bindUntypedNullsToResultColumns(bindingRCL);
1: 	}
1: 
1: 	/**
1: 	 * Decrement (query block) level (0-based) for this FromTable.
1: 	 * This is useful when flattening a subquery.
1: 	 *
1: 	 * @param decrement	The amount to decrement by.
1: 	 */
1: 	void decrementLevel(int decrement)
1: 	{
1: 		super.decrementLevel(decrement);
1: 		subquery.decrementLevel(decrement);
1: 	}
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * A FromSubquery represents a subquery in the FROM list of a DML statement.
0:  *
0:  * The current implementation of this class is only
0:  * sufficient for Insert's need to push a new
0:  * select on top of the one the user specified,
0:  * to make the selected structure match that
0:  * of the insert target table.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: public class FromSubquery extends FromTable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	boolean			generatedForGroupByClause;
0: 	boolean			generatedForHavingClause;
0: 	ResultSetNode	subquery;
0: 
0: 	/**
0: 	 * Intializer for a table in a FROM list.
0: 	 *
0: 	 * @param tableName		The name of the table
0: 	 * @param correlationName	The correlation name
0: 	 * @param derivedRCL		The derived column list
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 */
0: 	public void init(
0: 					Object subquery,
0: 					Object correlationName,
0: 				 	Object derivedRCL,
0: 					Object tableProperties)
0: 	{
0: 		super.init(correlationName, tableProperties);
0: 		this.subquery = (ResultSetNode) subquery;
0: 		resultColumns = (ResultColumnList) derivedRCL;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return
0: 			  "generatedForGroupByClause: " + generatedForGroupByClause + "\n" +
0: 			  "generatedForHavingClause: " + generatedForHavingClause + "\n" +
0: 			  super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			super.printSubNodes(depth);
0: 
0: 			if (subquery != null)
0: 			{
0: 				printLabel(depth, "subquery: ");
0: 				subquery.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Return the "subquery" from this node.
0: 	 *
0: 	 * @return ResultSetNode	The "subquery" from this node.
0: 	 */
0: 	public ResultSetNode getSubquery()
0: 	{
0: 		return subquery;
0: 	}
0: 
0: 	/**
0: 	 * Mark this FromSubquery as being generated for a GROUP BY clause.
0: 	 * (This node represents the SELECT thru GROUP BY clauses.  We
0: 	 * appear in the FromList of a SelectNode generated to represent
0: 	 * the result of the GROUP BY.  This allows us to add ResultColumns
0: 	 * to the SelectNode for the user's query.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void markAsForGroupByClause()
0: 	{
0: 		generatedForGroupByClause = true;
0: 	}
0: 
0: 	/**
0: 	 * Mark this FromSubquery as being generated for a HAVING clause.
0: 	 * (This node represents the SELECT thru GROUP BY clauses.  We
0: 	 * appear in the FromList of a SelectNode generated to represent
0: 	 * the actual HAVING clause.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void markAsForHavingClause()
0: 	{
0: 		generatedForHavingClause = true;
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		if (generatedForGroupByClause || generatedForHavingClause)
0: 		{
0: 			return subquery.getFromTableByName(name, schemaName, exactMatch);
0: 		}
0: 		else 
0: 		{
0: 			return super.getFromTableByName(name, schemaName, exactMatch);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this subquery that appears in the FROM list.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for binding
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	ResultSetNode		The bound FromSubquery.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
0: 						  FromList fromListParam) 
0: 							throws StandardException
0: 	{
0: 		/* Assign the tableNumber */
0: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
0: 			tableNumber = getCompilerContext().getNextTableNumber();
0: 
0: 		subquery = subquery.bindNonVTITables(dataDictionary, fromListParam);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind this subquery that appears in the FROM list.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	ResultSetNode		The bound FromSubquery.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode bindVTITables(FromList fromListParam) 
0: 							throws StandardException
0: 	{
0: 		subquery = subquery.bindVTITables(fromListParam);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
0: 	 * This is done for SELECT statements.  For FromSubquery, we
0: 	 * simply pass the check through to the subquery.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if a ? parameter found
0: 	 *									directly under a ResultColumn
0: 	 */
0: 
0: 	public void rejectParameters() throws StandardException
0: 	{
0: 		subquery.rejectParameters();
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in this FromSubquery.  This means 
0: 	 * binding the sub-expressions, as well as figuring out what the return 
0: 	 * type is for each expression.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindExpressions(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		FromList			emptyFromList =
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 		ResultColumnList	derivedRCL = resultColumns;
0: 		ResultColumnList	subqueryRCL;
0: 
0: 		/* From subqueries cannot be correlated, so we pass an empty FromList
0: 		 * to subquery.bindExpressions() and .bindResultColumns().
0: 		 */
0: 		subquery.bindExpressions(emptyFromList);
0: 		subquery.bindResultColumns(emptyFromList);
0: 
0: 		/* Now that we've bound the expressions in the subquery, we 
0: 		 * can propagate the subquery's RCL up to the FromSubquery.
0: 		 * Get the subquery's RCL, assign shallow copy back to
0: 		 * it and create new VirtualColumnNodes for the original's
0: 		 * ResultColumn.expressions.
0: 		 * NOTE: If the size of the derived column list is less than
0: 		 * the size of the subquery's RCL and the derived column list is marked
0: 		 * for allowing a size mismatch, then we have a select * view
0: 		 * on top of a table that has had columns added to it via alter table.
0: 		 * In this case, we trim out the columns that have been added to
0: 		 * the table since the view was created.
0: 		 */
0: 		subqueryRCL = subquery.getResultColumns();
0: 		if (resultColumns != null && resultColumns.getCountMismatchAllowed() &&
0: 			resultColumns.size() < subqueryRCL.size())
0: 		{
0: 			for (int index = subqueryRCL.size() - 1; 
0: 				 index >= resultColumns.size(); 
0: 				 index--)
0: 			{
0: 				subqueryRCL.removeElementAt(index);
0: 			}
0: 		}
0: 
0: 		subquery.setResultColumns(subqueryRCL.copyListAndObjects());
0: 		subqueryRCL.genVirtualColumnNodes(subquery, subquery.getResultColumns());
0: 		resultColumns = subqueryRCL;
0: 
0: 		/* Propagate the name info from the derived column list */
0: 		if (derivedRCL != null)
0: 		{
0: 			 resultColumns.propagateDCLInfo(derivedRCL, correlationName);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Try to find a ResultColumn in the table represented by this FromBaseTable
0: 	 * that matches the name in the given ColumnReference.
0: 	 *
0: 	 * @param columnReference	The columnReference whose name we're looking
0: 	 *				for in the given table.
0: 	 *
0: 	 * @return	A ResultColumn whose expression is the ColumnNode
0: 	 *			that matches the ColumnReference.
0: 	 *		Returns null if there is no match.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultColumn getMatchingColumn(ColumnReference columnReference) throws StandardException
0: 	{
0: 		ResultColumn	resultColumn = null;
0: 		String			columnsTableName;
0: 
0: 		/*
0: 		** RESOLVE: When we add support for schemas, check to see if
0: 		** the column name specifies a schema, and if so, if this
0: 		** table is in that schema.
0: 		*/
0: 
0: 		columnsTableName = columnReference.getTableName();
0: 
0: 		/* We have 5 cases here:
0: 		 *  1.  ColumnReference was generated to replace an aggregate.
0: 		 *		(We are the wrapper for a HAVING clause and the ColumnReference
0: 		 *		was generated to reference the aggregate which was pushed down into
0: 		 *		the SELECT list in the user's query.)  
0: 		 *		Just do what you would expect.  Try to resolve the
0: 		 *		ColumnReference against our RCL if the ColumnReference is unqualified
0: 		 *		or if it is qualified with our exposed name.
0: 		 *	2.	We are the wrapper for a GROUP BY and a HAVING clause and
0: 		 *		either the ColumnReference is qualified or it is in
0: 		 *		the HAVING clause.  For example:
0: 		 *			select a from t1 group by a having t1.a = 1
0: 		 *			select a as asdf from t1 group by a having a = 1
0: 		 *		We need to match against the underlying FromList and then find
0: 		 *		the grandparent ResultColumn in our RCL so that we return a
0: 		 *		ResultColumn from the correct ResultSetNode.  It is okay not to
0: 		 *		find a matching grandparent node.  In fact, this is how we ensure
0: 		 *		the correct semantics for ColumnReferences in the HAVING clause
0: 		 *		(which must be bound against the GROUP BY list.)
0: 		 *  3.	We are the wrapper for a HAVING clause without a GROUP BY and
0: 		 *		the ColumnReference is from the HAVING clause.  ColumnReferences
0: 		 *		are invalid in this case, so we return null.
0: 		 *  4.  We are the wrapper for a GROUP BY with no HAVING.  This has
0: 		 *		to be a separate case because of #5 and the following query:
0: 		 *			select * from (select c1 from t1) t, (select c1 from t1) tt
0: 		 *			group by t1.c1, tt.c1
0: 		 *		(The correlation names are lost in the generated FromSuquery.)
0: 		 *  5.  Everything else - do what you would expect.  Try to resolve the
0: 		 *		ColumnReference against our RCL if the ColumnReference is unqualified
0: 		 *		or if it is qualified with our exposed name.
0: 		 */
0: 		if (columnReference.getGeneratedToReplaceAggregate()) // 1
0: 		{
0: 			resultColumn = resultColumns.getResultColumn(columnReference.getColumnName());
0: 		}
0: 		else if (generatedForGroupByClause && generatedForHavingClause &&
0: 			     (columnsTableName != null || 
0: 			      columnReference.getClause() != ValueNode.IN_SELECT_LIST)) // 2
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(correlationName == null,
0: 					"correlationName expected to be null");
0: 				SanityManager.ASSERT(subquery instanceof SelectNode,
0: 					"subquery expected to be instanceof SelectNode, not " +
0: 					subquery.getClass().getName());
0: 			}
0: 
0: 			SelectNode		select = (SelectNode) subquery;
0: 
0: 			resultColumn = select.getFromList().bindColumnReference(columnReference);
0: 
0: 			/* Find and return the matching RC from our RCL.
0: 			 * (Not an error if no match found.  Let ColumnReference deal with it.
0: 			 */
0: 			if (resultColumn != null)
0: 			{
0: 				/* Is there a matching resultColumn in the subquery's RCL? */
0: 				resultColumn = subquery.getResultColumns().findParentResultColumn(
0: 												resultColumn);
0: 				if (resultColumn != null)
0: 				{
0: 					/* Is there a matching resultColumn in our RCL? */
0: 					resultColumn = resultColumns.findParentResultColumn(
0: 												resultColumn);
0: 				}
0: 			}
0: 		}
0: 		else if ((generatedForHavingClause && ! generatedForGroupByClause) // 3
0: 			 && (columnReference.getClause() != ValueNode.IN_SELECT_LIST) )
0: 		{
0: 		    resultColumn = null;
0: 		}
0: 		else if (generatedForGroupByClause) // 4
0: 		{
0: 		        resultColumn = resultColumns.getResultColumn(
0: 								     columnsTableName,
0: 								     columnReference.getColumnName());
0: 		}
0: 		else if (columnsTableName == null || columnsTableName.equals(correlationName)) // 5?
0: 		{
0: 		    resultColumn = resultColumns.getAtMostOneResultColumn(columnReference, correlationName);
0: 		}
0: 		    
0: 
0: 		if (resultColumn != null)
0: 		{
0: 			columnReference.setTableNumber(tableNumber);
0: 		}
0: 
0: 		return resultColumn;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess a ResultSetNode - this currently means:
0: 	 *	o  Generating a referenced table map for each ResultSetNode.
0: 	 *  o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF).
0: 	 *  o  Converting the WHERE and HAVING clauses into PredicateLists and
0: 	 *	   classifying them.
0: 	 *  o  Ensuring that a ProjectRestrictNode is generated on top of every 
0: 	 *     FromBaseTable and generated in place of every FromSubquery.  
0: 	 *  o  Pushing single table predicates down to the new ProjectRestrictNodes.
0: 	 *
0: 	 * @param numTables			The number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return ResultSetNode at top of preprocessed tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 		/* We want to chop out the FromSubquery from the tree and replace it 
0: 		 * with a ProjectRestrictNode.  One complication is that there may be 
0: 		 * ColumnReferences above us which point to the FromSubquery's RCL.
0: 		 * What we want to return is a tree with a PRN with the
0: 		 * FromSubquery's RCL on top.  (In addition, we don't want to be
0: 		 * introducing any redundant ProjectRestrictNodes.)
0: 		 * Another complication is that we want to be able to only only push
0: 		 * projections and restrictions down to this ProjectRestrict, but
0: 		 * we want to be able to push them through as well.
0: 		 * So, we:
0: 		 *		o call subquery.preprocess() which returns a tree with
0: 		 *		  a SelectNode or a RowResultSetNode on top.  
0: 		 *		o If the FSqry is flattenable(), then we return (so that the
0: 		 *		  caller can then call flatten()), otherwise we:
0: 		 *		o generate a PRN, whose RCL is the FSqry's RCL, on top of the result.
0: 		 *		o create a referencedTableMap for the PRN which represents 
0: 		 *		  the FSqry's tableNumber, since ColumnReferences in the outer
0: 		 *		  query block would be referring to that one.  
0: 		 *		  (This will allow us to push restrictions down to the PRN.)
0: 		 */
0: 
0: 		subquery = subquery.preprocess(numTables, gbl, fromList);
0: 
0: 		/* Return if the FSqry is flattenable() 
0: 		 * NOTE: We can't flatten a FromSubquery if there is a group by list
0: 		 * because the group by list must be ColumnReferences.  For:
0: 		 *	select c1 from v1 group by c1,
0: 		 *	where v1 is select 1 from t1
0: 		 * The expression under the last redundant ResultColumn is an IntConstantNode,
0: 		 * not a ColumnReference.
0: 		 * We also do not flatten a subquery if tableProperties is non-null,
0: 		 * as the user is specifying 1 or more properties for the derived table,
0: 		 * which could potentially be lost on the flattening.
0: 		 * RESOLVE - this is too restrictive.
0: 		 */
0: 		if ((gbl == null || gbl.size() == 0) &&
0: 			tableProperties == null &&
0: 		    subquery.flattenableInFromSubquery(fromList))
0: 		{
0: 			/* Set our table map to the subquery's table map. */
0: 			setReferencedTableMap(subquery.getReferencedTableMap());
0: 			return this;
0: 		}
0: 
0: 		return extractSubquery(numTables);
0: 	}
0: 
0: 	/**
0: 	 * Extract out and return the subquery, with a PRN on top.
0: 	 * (See FromSubquery.preprocess() for more details.)
0: 	 *
0: 	 * @param numTables			The number of tables in the DML Statement
0: 	 *
0: 	 * @return ResultSetNode at top of extracted tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode extractSubquery(int numTables)
0: 		throws StandardException
0: 	{
0: 		JBitSet		  newJBS;
0: 		ResultSetNode newPRN;
0: 
0: 		newPRN = (ResultSetNode) getNodeFactory().getNode(
0: 								C_NodeTypes.PROJECT_RESTRICT_NODE,
0: 								subquery,		/* Child ResultSet */
0: 								resultColumns,	/* Projection */
0: 								null,			/* Restriction */
0: 								null,			/* Restriction as PredicateList */
0: 								null,			/* Subquerys in Projection */
0: 								null,			/* Subquerys in Restriction */
0: 								tableProperties,
0: 								getContextManager()	 );
0: 
0: 		/* Set up the PRN's referencedTableMap */
0: 		newJBS = new JBitSet(numTables);
0: 		newJBS.set(tableNumber);
0: 		newPRN.setReferencedTableMap(newJBS);
0: 		((FromTable) newPRN).setTableNumber(tableNumber);
0: 
0: 		return newPRN;
0: 	}
0: 
0: 	/**
0: 	 * Flatten this FSqry into the outer query block. The steps in
0: 	 * flattening are:
0: 	 *	o  Mark all ResultColumns as redundant, so that they are "skipped over"
0: 	 *	   at generate().
0: 	 *	o  Append the wherePredicates to the outer list.
0: 	 *	o  Return the fromList so that the caller will merge the 2 lists 
0: 	 *  RESOLVE - FSqrys with subqueries are currently not flattenable.  Some of
0: 	 *  them can be flattened, however.  We need to merge the subquery list when
0: 	 *  we relax this restriction.
0: 	 *
0: 	 * NOTE: This method returns NULL when flattening RowResultSetNodes
0: 	 * (the node for a VALUES clause).  The reason is that no reference
0: 	 * is left to the RowResultSetNode after flattening is done - the
0: 	 * expressions point directly to the ValueNodes in the RowResultSetNode's
0: 	 * ResultColumnList.
0: 	 *
0: 	 * @param rcl				The RCL from the outer query
0: 	 * @param outerPList	PredicateList to append wherePredicates to.
0: 	 * @param sql				The SubqueryList from the outer query
0: 	 * @param gbl				The group by list, if any
0: 	 *
0: 	 * @return FromList		The fromList from the underlying SelectNode.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public FromList flatten(ResultColumnList rcl,
0: 							PredicateList outerPList,
0: 							SubqueryList sql,
0: 							GroupByList gbl)
0: 
0: 			throws StandardException
0: 	{
0: 		FromList	fromList = null;
0: 		SelectNode	selectNode;
0: 
0: 		resultColumns.setRedundant();
0: 
0: 		subquery.getResultColumns().setRedundant();
0: 
0: 		/*
0: 		** RESOLVE: Each type of result set should know how to remap itself.
0: 		*/
0: 		if (subquery instanceof SelectNode)
0: 		{
0: 			selectNode = (SelectNode) subquery;
0: 			fromList = selectNode.getFromList();
0: 
0: 			// selectNode.getResultColumns().setRedundant();
0: 
0: 			if (selectNode.getWherePredicates().size() > 0)
0: 			{
0: 				outerPList.destructiveAppend(selectNode.getWherePredicates());
0: 			}
0: 
0: 			if (selectNode.getWhereSubquerys().size() > 0)
0: 			{
0: 				sql.destructiveAppend(selectNode.getWhereSubquerys());
0: 			}
0: 		}
0: 		else if ( ! (subquery instanceof RowResultSetNode))
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.THROWASSERT("subquery expected to be either a SelectNode or a RowResultSetNode, but is a " + subquery.getClass().getName());
0: 			}
0: 		}
0: 
0: 		/* Remap all ColumnReferences from the outer query to this node.
0: 		 * (We replace those ColumnReferences with clones of the matching
0: 		 * expression in the SELECT's RCL.
0: 		 */
0: 		rcl.remapColumnReferencesToExpressions();
0: 		outerPList.remapColumnReferencesToExpressions();
0: 		if (gbl != null)
0: 		{
0: 			gbl.remapColumnReferencesToExpressions();
0: 		}
0: 
0: 		return fromList;
0: 	}
0: 
0: 	/**
0: 	 * Get the exposed name for this table, which is the name that can
0: 	 * be used to refer to it in the rest of the query.
0: 	 *
0: 	 * @return	The exposed name for this table.
0: 	 */
0: 
0: 	public String getExposedName()
0: 	{
0: 		return correlationName;
0: 	}
0: 
0: 	/**
0: 	 * Expand a "*" into a ResultColumnList with all of the
0: 	 * result columns from the subquery.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultColumnList getAllResultColumns(String allTableName)
0: 			throws StandardException
0: 	{
0: 		ResultColumnList rcList = null;
0: 		TableName		 exposedName;
0: 
0: 
0: 		if (allTableName != null && ! allTableName.equals(getExposedName()))
0: 		{
0: 			return null;
0: 		}
0: 
0: 		/* Cache exposed name for this table.
0: 		 * The exposed name becomes the qualifier for each column
0: 		 * in the expanded list.
0: 		 */
0: 		exposedName = makeTableName(null, correlationName);
0: 
0: 		rcList = (ResultColumnList) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN_LIST,
0: 										getContextManager());
0: 
0: 		/* Build a new result column list based off of resultColumns.
0: 		 * NOTE: This method will capture any column renaming due to 
0: 		 * a derived column list.
0: 		 */
0: 		int rclSize = resultColumns.size();
0: 		for (int index = 0; index < rclSize; index++)
0: 		{
0: 			ResultColumn resultColumn = (ResultColumn) resultColumns.elementAt(index);
0: 			ValueNode		 valueNode;
0: 			String			 columnName;
0: 
0: 			if (resultColumn.isGenerated())
0: 			{
0: 				continue;
0: 			}
0: 
0: 			// Build a ResultColumn/ColumnReference pair for the column //
0: 			columnName = resultColumn.getName();
0: 			boolean isNameGenerated = resultColumn.isNameGenerated();
0: 
0: 			/* If this node was generated for a GROUP BY, then tablename for the CR, if any,
0: 			 * comes from the source RC.
0: 			 */
0: 			TableName tableName;
0: 
0: 			if (correlationName == null && generatedForGroupByClause)
0: 			{
0: 				tableName = makeTableName(null, resultColumn.getTableName());
0: 			}
0: 			else
0: 			{
0: 				tableName = exposedName;
0: 			}
0: 			valueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.COLUMN_REFERENCE,
0: 											columnName,
0: 											tableName,
0: 											getContextManager());
0: 			resultColumn = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											columnName,
0: 											valueNode,
0: 											getContextManager());
0: 
0: 			resultColumn.setNameGenerated(isNameGenerated);
0: 			// Build the ResultColumnList to return //
0: 			rcList.addResultColumn(resultColumn);
0: 		}
0: 		return rcList;
0: 	}
0: 
0: 	/**
0: 	 * Search to see if a query references the specifed table name.
0: 	 *
0: 	 * @param name		Table name (String) to search for.
0: 	 * @param baseTable	Whether or not name is for a base table
0: 	 *
0: 	 * @return	true if found, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
0: 		throws StandardException
0: 	{
0: 		return subquery.referencesTarget(name, baseTable);
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		return subquery.referencesSessionSchema();
0: 	}
0: 
0: 	/**
0: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
0: 	 *
0: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
0: 				throws StandardException
0: 	{
0: 		subquery.bindUntypedNullsToResultColumns(bindingRCL);
0: 	}
0: 
0: 	/**
0: 	 * Decrement (query block) level (0-based) for this FromTable.
0: 	 * This is useful when flattening a subquery.
0: 	 *
0: 	 * @param decrement	The amount to decrement by.
0: 	 */
0: 	void decrementLevel(int decrement)
0: 	{
0: 		super.decrementLevel(decrement);
0: 		subquery.decrementLevel(decrement);
0: 	}
0: }
============================================================================