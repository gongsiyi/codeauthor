1:f448bbb: /*
7:f448bbb: 
1:f448bbb: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_10
1:f448bbb: 
1:f448bbb: Licensed to the Apache Software Foundation (ASF) under one or more
1:f448bbb: contributor license agreements.  See the NOTICE file distributed with
1:f448bbb: this work for additional information regarding copyright ownership.
1:f448bbb: The ASF licenses this file to You under the Apache License, Version 2.0
1:f448bbb: (the "License"); you may not use this file except in compliance with
1:f448bbb: the License.  You may obtain a copy of the License at
1:f448bbb: 
1:f448bbb:    http://www.apache.org/licenses/LICENSE-2.0
1:f448bbb: 
1:f448bbb: Unless required by applicable law or agreed to in writing, software
1:f448bbb: distributed under the License is distributed on an "AS IS" BASIS,
1:f448bbb: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f448bbb: See the License for the specific language governing permissions and
1:f448bbb: limitations under the License.
1:f448bbb: 
1:f448bbb: */
1:f448bbb: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:f448bbb: 
1:f448bbb: import java.io.File;
1:9496f49: import java.io.IOException;
1:f448bbb: import java.sql.PreparedStatement;
1:f448bbb: import java.sql.ResultSet;
1:f448bbb: import java.sql.SQLException;
1:f448bbb: import java.sql.Statement;
1:f448bbb: import junit.framework.Test;
1:9496f49: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:f448bbb: import org.apache.derbyTesting.junit.JDBC;
1:f448bbb: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:f448bbb: import org.apache.derbyTesting.junit.TestConfiguration;
1:f448bbb: 
1:f448bbb: 
1:f448bbb: /**
1:f448bbb:  * Upgrade test cases for 10.10.
1:f448bbb:  */
1:f448bbb: public class Changes10_10 extends UpgradeChange
3:f448bbb: {
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb:     //
1:f448bbb:     // CONSTANTS
1:f448bbb:     //
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb: 
1:22d64f5:     private static  final   String  SYNTAX_ERROR = "42X01";
1:22d64f5:     private static  final   String  HARD_UPGRADE_REQUIRED = "XCL47";
1:f9596d4:     private static  final   String  NEEDS_JAVA_STYLE = "42ZCA";
1:9496f49:     /**
1:9496f49:     The readme file cautioning users against touching the files in
1:9496f49:     the database directory 
1:9496f49:     */
1:9496f49:     private static final String DB_README_FILE_NAME = "README_DO_NOT_TOUCH_FILES.txt";
1:22d64f5: 
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb:     //
1:f448bbb:     // STATE
1:f448bbb:     //
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb: 
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb:     //
1:f448bbb:     // CONSTRUCTOR
1:f448bbb:     //
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb: 
1:f448bbb:     public Changes10_10(String name)
1:f448bbb:     {
1:f448bbb:         super(name);
3:f448bbb:     }
1:c0a5ce1: 
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb:     //
1:f448bbb:     // JUnit BEHAVIOR
1:f448bbb:     //
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:22d64f5:     
1:22d64f5:     /**
1:f448bbb:      * Return the suite of tests to test the changes made in 10.10.
1:f448bbb:      * @param phase an integer that indicates the current phase in
1:f448bbb:      *              the upgrade test.
1:f448bbb:      * @return the test suite created.
1:f448bbb:      */
1:f448bbb:     public static Test suite(int phase) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.9");
1:f448bbb: 
1:f448bbb:         suite.addTestSuite(Changes10_10.class);
1:f448bbb:         
1:f448bbb:         return new SupportFilesSetup((Test) suite);
1:f448bbb:     }
1:f448bbb: 
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb:     //
1:f448bbb:     // TESTS
1:f448bbb:     //
1:f448bbb:     ///////////////////////////////////////////////////////////////////////////////////
1:f448bbb: 
1:f448bbb:     /**
1:f448bbb:      * Make sure that the following procedure(s) which are new to 10.10 are 
1:f448bbb:      *  only available after hard-upgrade
1:f448bbb:      *  1)invalidate stored statements 
1:f448bbb:      *    SYCS_UTIL.SYSCS_INVALIDATE_STORED_STATEMENTS
1:f448bbb:      */
1:f448bbb:     public  void    testProcsNewTo10_10()  throws Exception
1:f448bbb:     {
1:f448bbb:         Statement s = createStatement();
1:092cf8b:         String  iss = "call syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS()";
1:092cf8b:         String  rt = "call syscs_util.syscs_register_tool( 'foo', true )";
1:092cf8b:         String  rtGoodSQLState = "X0Y88";
1:092cf8b:         String  syntaxError = "42X01";
1:092cf8b:         boolean atLeastJava5 = JDBC.vmSupportsJDBC3();
1:092cf8b:         boolean oldSupportsBoolean = oldAtLeast( 10, 7 );
1:f448bbb: 
1:f448bbb:         switch ( getPhase() )
1:f448bbb:         {
1:f448bbb:         case PH_CREATE: // create with old version
1:f448bbb:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:092cf8b:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:092cf8b:             vetProcs( s, iss, false, null );
1:092cf8b:             if ( atLeastJava5 )
1:092cf8b:             {
1:092cf8b:                 vetProcs
1:092cf8b:                     ( s, rt, false,
1:092cf8b:                       oldSupportsBoolean || (getPhase() == PH_SOFT_UPGRADE ) ? null : syntaxError );
1:092cf8b:             }
3:f448bbb:             break;
1:f448bbb:             
1:f448bbb:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:092cf8b:             vetProcs( s, iss, true, null );
1:092cf8b:             if ( atLeastJava5 ) { vetProcs( s, rt, true, rtGoodSQLState ); }
1:f448bbb:             break;
1:f448bbb:         }
1:f448bbb:         
1:f448bbb:         s.close();
1:f448bbb:     	
1:f448bbb:     }
1:f448bbb:     
1:092cf8b:     private void    vetProcs
1:092cf8b:         (
1:092cf8b:          Statement s,
1:092cf8b:          String procCall, 
1:092cf8b:          boolean shouldExist,
1:092cf8b:          String sqlState
1:092cf8b:          ) throws Exception
1:f448bbb:     {
1:f448bbb:         try {
1:f448bbb:             s.execute( procCall );
1:f448bbb:             
1:f448bbb:             if ( !shouldExist )
1:f448bbb:             {
1:092cf8b:                 fail( "Procedure should not exist!"  );
1:092cf8b:             }
1:092cf8b:             if ( sqlState != null )
1:092cf8b:             {
1:092cf8b:                 fail( "Expected to fail with SQLState " + sqlState );
1:f448bbb:             }
1:f448bbb:         } catch (SQLException se )
1:f448bbb:         {
1:092cf8b:             if ( sqlState == null ) { sqlState = "42Y03"; }
1:092cf8b:             assertSQLState( sqlState, se );
1:f448bbb:         }
1:f448bbb:     }
1:f448bbb: 
1:f448bbb:     /**
1:22d64f5:      * Verify upgrade behavior for user-defined aggregates.
1:22d64f5:      */
1:22d64f5:     public  void    testUDAs()  throws Exception
1:22d64f5:     {
1:22d64f5:         Statement st = createStatement();
1:22d64f5: 
1:22d64f5:         String  createUDA = "create derby aggregate mode for int external name 'foo.bar.Wibble'";
1:22d64f5:         String  dropUDA = "drop derby aggregate mode restrict";
1:22d64f5: 
1:22d64f5:         switch ( getPhase() )
1:22d64f5:         {
1:22d64f5:         case PH_CREATE: // create with old version
1:22d64f5:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:22d64f5:             assertStatementError( SYNTAX_ERROR, st, createUDA );
1:22d64f5:             assertStatementError( SYNTAX_ERROR, st, dropUDA );
1:22d64f5:             break;
1:22d64f5:             
1:22d64f5:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:22d64f5:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createUDA );
1:22d64f5:             assertStatementError( HARD_UPGRADE_REQUIRED, st, dropUDA );
1:22d64f5:             break;
1:22d64f5:             
1:22d64f5:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:22d64f5:             st.execute( createUDA );
1:22d64f5:             st.execute( dropUDA );
1:22d64f5:             break;
1:22d64f5:         }
1:22d64f5:         
1:22d64f5:         st.close();
1:22d64f5:     }
1:22d64f5:     
1:f9596d4:     /**
1:f9596d4:      * Verify upgrade behavior for vararg routines.
1:f9596d4:      */
1:f9596d4:     public  void    testVarargss()  throws Exception
1:f9596d4:     {
1:f9596d4:         Statement st = createStatement();
1:f9596d4: 
1:5f587f7:         String  createVarargsProc = "create procedure vds ( a int ... ) language java parameter style derby no sql external name 'Foo.foo'";
1:5f587f7:         String  createVarargsFunc = "create function vds ( a int ... ) returns integer language java parameter style derby no sql external name 'Foo.foo'";
1:5f587f7:         String  createVarargsTableFunc = "create function vtf ( a int ... ) returns table ( b int ) language java parameter style derby_jdbc_result_set no sql external name 'Foo.foo'";
1:5f587f7:         String  createNonVarargsProcDerbyStyle = "create procedure nvds ( a int ) language java parameter style derby no sql external name 'Foo.foo'";
1:5f587f7:         String  createNonVarargsFuncDerbyStyle = "create function nvds ( a int ) returns integer language java parameter style derby no sql external name 'Foo.foo'";
1:f9596d4: 
1:f9596d4:         // table functions were introduced by 10.4
1:f9596d4:         boolean tableFunctionsOK = oldAtLeast( 10, 4 );       
1:f9596d4: 
1:f9596d4:         switch ( getPhase() )
1:f9596d4:         {
1:f9596d4:         case PH_CREATE: // create with old version
1:f9596d4:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:f9596d4:             assertStatementError( SYNTAX_ERROR, st, createVarargsProc );
1:f9596d4:             assertStatementError( SYNTAX_ERROR, st, createVarargsFunc );
1:f9596d4:             if ( tableFunctionsOK ) { assertStatementError( SYNTAX_ERROR, st, createVarargsTableFunc ); }
1:f9596d4:             assertStatementError( SYNTAX_ERROR, st, createNonVarargsProcDerbyStyle );
1:f9596d4:             assertStatementError( SYNTAX_ERROR, st, createNonVarargsFuncDerbyStyle );
1:f9596d4:             break;
1:f9596d4:             
1:f9596d4:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:f9596d4:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createVarargsProc );
1:f9596d4:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createVarargsFunc );
1:f9596d4:             if ( tableFunctionsOK ) { assertStatementError( HARD_UPGRADE_REQUIRED, st, createVarargsTableFunc ); }
1:f9596d4:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createNonVarargsProcDerbyStyle );
1:f9596d4:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createNonVarargsFuncDerbyStyle );
1:f9596d4:             break;
1:f9596d4:             
1:f9596d4:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:f9596d4:             st.execute( createVarargsProc );
1:f9596d4:             st.execute( createVarargsFunc );
1:f9596d4:             st.execute( createVarargsTableFunc );
1:f9596d4:             assertStatementError( NEEDS_JAVA_STYLE, st, createNonVarargsProcDerbyStyle );
1:f9596d4:             assertStatementError( NEEDS_JAVA_STYLE, st, createNonVarargsFuncDerbyStyle );
1:f9596d4:             break;
1:f9596d4:         }
1:f9596d4:         
1:f9596d4:         st.close();
1:f9596d4:     }
1:f9596d4:     
1:9496f49:     /**
1:9496f49:      * DERBY-5996(Create readme files (cautioning users against modifying 
1:9496f49:      *  database files) at database hard upgrade time)
1:9496f49:      * Simple test to make sure readme files are getting created
1:9496f49:      */
1:9496f49:     public void testReadMeFiles() throws SQLException, IOException
1:9496f49:     {
1:9496f49:         Statement s = createStatement();
1:9496f49:         s.close();
1:9496f49:         TestConfiguration currentConfig = TestConfiguration.getCurrent();
1:9496f49:         String dbPath = currentConfig.getDatabasePath(currentConfig.getDefaultDatabaseName());
1:9496f49:         switch (getPhase())
1:9496f49:         {
1:9496f49:         case PH_CREATE:
1:9496f49:         case PH_SOFT_UPGRADE:
1:9496f49:         case PH_POST_SOFT_UPGRADE:
1:9496f49:             // DERBY-5995 Pre 10.10 databases would not have readme files
1:9496f49:             lookForReadmeFile(dbPath, false);
1:9496f49:             lookForReadmeFile(dbPath+File.separator+"seg0", false);
1:9496f49:             lookForReadmeFile(dbPath+File.separator+"log", false);
1:9496f49:             break;
1:9496f49:         case PH_HARD_UPGRADE:
1:9496f49:         case PH_POST_HARD_UPGRADE:
1:9496f49:             // DERBY-5995 Hard upgrade to 10.10 will create readme files
1:9496f49:             lookForReadmeFile(dbPath, true);
1:9496f49:             lookForReadmeFile(dbPath+File.separator+"seg0", true);
1:9496f49:             lookForReadmeFile(dbPath+File.separator+"log", true);
1:9496f49:             break;
1:9496f49:         }
1:9496f49:     }
1:9496f49: 
1:9496f49:     /**
1:9496f49:      * For pre-10.10 database, fileShouldExist will be false. For hard upgraded
1:9496f49:      *  databases to 10.10, fileShouldExist will be true
1:9496f49:      * @param path - this can be root database directory, log or seg0 directory
1:9496f49:      * @param fileShouldExist
1:9496f49:      * @throws IOException
1:9496f49:      */
1:9496f49:     private void lookForReadmeFile(String path, boolean fileShouldExist) throws IOException {
1:9496f49:         File readmeFile = new File(path,
1:9496f49:             DB_README_FILE_NAME);
1:9496f49:         if (fileShouldExist)
1:9496f49:         {
1:9496f49:             assertTrue(readmeFile + "doesn't exist", 
1:9496f49:                 PrivilegedFileOpsForTests.exists(readmeFile));
1:9496f49:         } else 
1:9496f49:         {
1:9496f49:             assertFalse(readmeFile + "exists", 
1:9496f49:                 PrivilegedFileOpsForTests.exists(readmeFile));
1:9496f49:         
1:9496f49:         }
1:9496f49:     }
1:9496f49: 
1:c0a5ce1:     // Old DB2 constants in Limits.java:
1:c0a5ce1:     // static final float DB2_SMALLEST_REAL = -3.402E+38f;
1:c0a5ce1:     // static final float DB2_LARGEST_REAL  = +3.402E+38f;
1:c0a5ce1:     // static final float DB2_SMALLEST_POSITIVE_REAL = +1.175E-37f;
1:c0a5ce1:     // static final float DB2_LARGEST_NEGATIVE_REAL  = -1.175E-37f;
1:c0a5ce1: 
1:c0a5ce1:     // static final double DB2_SMALLEST_DOUBLE = -1.79769E+308d;
1:c0a5ce1:     // static final double DB2_LARGEST_DOUBLE  = +1.79769E+308d;
1:c0a5ce1:     // static final double DB2_SMALLEST_POSITIVE_DOUBLE = +2.225E-307d;
1:c0a5ce1:     // static final double DB2_LARGEST_NEGATIVE_DOUBLE  = -2.225E-307d;
1:c0a5ce1: 
1:c0a5ce1:     static final float[] beyondDB2Real = new float[] {
1:c0a5ce1:         Float.MIN_VALUE,
1:c0a5ce1:         Float.MAX_VALUE,
1:c0a5ce1:         +1.174E-37f,
1:c0a5ce1:         -1.174E-37f,
1:987a158:         1.17549435E-38f, // Float.MIN_NORMAL
1:c0a5ce1:         -1.17549435E-38f // -Float.MIN_NORMAL
1:c0a5ce1:     };
1:c0a5ce1: 
1:c0a5ce1:     static final double[] beyondDB2Double = new double[] {
1:c0a5ce1:         Double.MIN_VALUE,
1:c0a5ce1:         Double.MAX_VALUE,
1:c0a5ce1:         +2.224E-307d,
1:c0a5ce1:         -2.224E-307d,
1:987a158:         2.2250738585072014E-308, // Double.MIN_NORMAL
1:c0a5ce1:         -2.2250738585072014E-308 // -Double.MIN_NORMAL
1:c0a5ce1:     };
1:c0a5ce1: 
1:c0a5ce1:     /**
1:c0a5ce1:      * Verify upgrade behavior DERBY-3398: removing DB2 float limits
1:c0a5ce1:      */
1:c0a5ce1:     public  void    testFloatLimits()  throws Exception
1:c0a5ce1:     {
1:c0a5ce1:         Statement st = createStatement();
1:c0a5ce1:         st.execute("create table d3398(r real, d double)");
1:c0a5ce1: 
1:c0a5ce1:         PreparedStatement psInsertReal =
1:c0a5ce1:             prepareStatement("insert into d3398(r) values (?)");
1:c0a5ce1:         PreparedStatement psInsertDouble =
1:c0a5ce1:             prepareStatement("insert into d3398(d) values (?)");
1:c0a5ce1:         PreparedStatement psSelect =
1:c0a5ce1:             prepareStatement("select * from d3398",
1:c0a5ce1:                 ResultSet.TYPE_FORWARD_ONLY,
1:c0a5ce1:                 ResultSet.CONCUR_UPDATABLE);
1:c0a5ce1: 
1:c0a5ce1:         st.execute("insert into d3398 values (0.0, 0.0)");
1:c0a5ce1: 
1:c0a5ce1: 
1:c0a5ce1:         switch ( getPhase() )
1:c0a5ce1:         {
1:c0a5ce1:         case PH_CREATE: // create with old version
1:c0a5ce1:             verifyDB2Behavior(psSelect, psInsertReal, psInsertDouble, false);
1:c0a5ce1: 
1:c0a5ce1:             break;
1:c0a5ce1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old
1:c0a5ce1:                                    // version after soft-upgrade
1:c0a5ce1:             verifyDB2Behavior(psSelect, psInsertReal, psInsertDouble, false);
1:c0a5ce1: 
1:c0a5ce1:             break;
1:c0a5ce1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:c0a5ce1: 
1:c0a5ce1:             verifyDB2Behavior(psSelect, psInsertReal, psInsertDouble, true);
1:c0a5ce1: 
1:c0a5ce1:             break;
1:c0a5ce1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:c0a5ce1: 
1:c0a5ce1:             for (int i = 0; i < beyondDB2Real.length; i++) {
1:c0a5ce1:                 psInsertReal.setFloat(1, beyondDB2Real[i]);
1:c0a5ce1:                 psInsertReal.execute();
1:c0a5ce1: 
1:c0a5ce1:                 ResultSet rs = psSelect.executeQuery();
1:c0a5ce1:                 rs.next();
1:c0a5ce1:                 rs.updateFloat(1, beyondDB2Real[i]);
1:c0a5ce1:                 rs.updateRow();
1:c0a5ce1:                 rs.close();
1:c0a5ce1:             }
1:c0a5ce1: 
1:c0a5ce1:             for (int i = 0; i < beyondDB2Double.length; i++) {
1:c0a5ce1:                 psInsertDouble.setDouble(1, beyondDB2Double[i]);
1:c0a5ce1:                 psInsertDouble.execute();
1:c0a5ce1: 
1:c0a5ce1:                 ResultSet rs = psSelect.executeQuery();
1:c0a5ce1:                 rs.next();
1:c0a5ce1:                 rs.updateDouble(2, beyondDB2Double[i]);
1:c0a5ce1:                 rs.updateRow();
1:c0a5ce1:                 rs.close();
1:c0a5ce1:             }
1:c0a5ce1: 
1:c0a5ce1:             break;
1:c0a5ce1:         }
1:c0a5ce1: 
1:c0a5ce1:         st.executeUpdate("drop table d3398");
1:c0a5ce1:         st.close();
1:c0a5ce1:     }
1:c0a5ce1: 
1:c0a5ce1:     private void assertSetError(PreparedStatement ps, float fv, boolean defer)
1:c0a5ce1:             throws SQLException {
1:c0a5ce1:         try {
1:c0a5ce1:             ps.setFloat(1, fv);
1:c0a5ce1: 
1:c0a5ce1:             if (!defer) {
1:c0a5ce1:                 fail();
1:c0a5ce1:             }
1:c0a5ce1: 
1:c0a5ce1:             ps.executeUpdate();
1:c0a5ce1:             fail();
1:c0a5ce1:         } catch (SQLException e) {
1:c0a5ce1:             assertSQLState("22003", e);
1:c0a5ce1:         }
1:c0a5ce1:     }
1:f448bbb:     
1:c0a5ce1:     private void assertSetError(PreparedStatement ps, double dv, boolean defer)
1:c0a5ce1:             throws SQLException {
1:c0a5ce1:         try {
1:c0a5ce1:             ps.setDouble(1, dv);
1:c0a5ce1: 
1:c0a5ce1:             if (!defer) {
1:c0a5ce1:                 fail();
1:c0a5ce1:             }
1:c0a5ce1: 
1:c0a5ce1:             ps.executeUpdate();
1:c0a5ce1:             fail();
1:c0a5ce1:         } catch (SQLException e) {
1:c0a5ce1:             assertSQLState("22003", e);
1:c0a5ce1:         }
1:c0a5ce1:     }
1:c0a5ce1: 
1:c0a5ce1: 
1:c0a5ce1:     private void assertUpdateError(
1:c0a5ce1:             PreparedStatement ps,
1:c0a5ce1:             float fv,
1:c0a5ce1:             boolean defer) throws SQLException {
1:c0a5ce1: 
1:c0a5ce1:         boolean supportsForwardUpdatableResultSet = oldAtLeast( 10, 2 );
1:c0a5ce1: 
1:c0a5ce1:         if (!supportsForwardUpdatableResultSet) {
1:c0a5ce1:             return;
1:c0a5ce1:         }
1:c0a5ce1: 
1:c0a5ce1:         ResultSet rs = ps.executeQuery();
1:c0a5ce1:         rs.next();
1:c0a5ce1: 
1:c0a5ce1:         try {
1:c0a5ce1:             rs.updateFloat(1, fv);
1:c0a5ce1: 
1:c0a5ce1:             if (!defer) {
1:c0a5ce1:                 fail();
1:c0a5ce1:             }
1:c0a5ce1: 
1:c0a5ce1:             rs.updateRow();
1:c0a5ce1:             fail();
1:c0a5ce1:         } catch (SQLException e) {
1:c0a5ce1:             assertSQLState("22003", e);
1:c0a5ce1:         } finally {
1:c0a5ce1:             rs.close();
1:c0a5ce1:         }
1:c0a5ce1:     }
1:c0a5ce1: 
1:c0a5ce1:     private void assertUpdateError(
1:c0a5ce1:             PreparedStatement ps,
1:c0a5ce1:             double fv,
1:c0a5ce1:             boolean defer) throws SQLException {
1:c0a5ce1: 
1:c0a5ce1:         boolean supportsForwardUpdatableResultSet = oldAtLeast( 10, 2 );
1:c0a5ce1: 
1:c0a5ce1:         if (!supportsForwardUpdatableResultSet) {
1:c0a5ce1:             return;
1:c0a5ce1:         }
1:c0a5ce1: 
1:c0a5ce1:         ResultSet rs = ps.executeQuery();
1:c0a5ce1:         rs.next();
1:c0a5ce1: 
1:c0a5ce1:         try {
1:c0a5ce1:             rs.updateDouble(1, fv);
1:c0a5ce1: 
1:c0a5ce1:             if (!defer) {
1:c0a5ce1:                 fail();
1:c0a5ce1:             }
1:c0a5ce1: 
1:c0a5ce1:             rs.updateRow();
1:c0a5ce1:             fail();
1:c0a5ce1:         } catch (SQLException e) {
1:c0a5ce1:             assertSQLState("22003", e);
1:c0a5ce1:         } finally {
1:c0a5ce1:             rs.close();
1:c0a5ce1:         }
1:c0a5ce1:     }
1:c0a5ce1: 
1:c0a5ce1:     /**
1:c0a5ce1:      * Check that the old DB2 limits are (still) enforced.
1:c0a5ce1:      *
1:c0a5ce1:      * @param defer In soft upgrade mode, the checking if deferred after
1:c0a5ce1:      * DERBY-3398, i.e. instead of throwing on the DB2 limits when calling
1:c0a5ce1:      * {@code ResultSet#updateXXX} or {@code PreparedStatement#setXXX}, the
1:c0a5ce1:      * check throws on {@code ResultSet#updateRow}, or {#insertRow}, and
1:c0a5ce1:      * similarly on {@code PreparedStatement#execute} or {@code #executeUpdate}.
1:c0a5ce1:      *
1:c0a5ce1:      * @throws SQLException if we see some expected error.
1:c0a5ce1:      */
1:c0a5ce1:     private void verifyDB2Behavior (
1:c0a5ce1:             PreparedStatement psSelect,
1:c0a5ce1:             PreparedStatement psInsertReal,
1:c0a5ce1:             PreparedStatement psInsertDouble,
1:c0a5ce1:             boolean defer) throws SQLException {
1:c0a5ce1: 
1:c0a5ce1:         for (int i = 0; i < beyondDB2Real.length; i++) {
1:c0a5ce1:             assertSetError(psInsertReal, beyondDB2Real[i], defer);
1:c0a5ce1:             assertUpdateError(psSelect, beyondDB2Real[i], defer);
1:c0a5ce1:         }
1:c0a5ce1: 
1:c0a5ce1:         for (int i = 0; i < beyondDB2Double.length; i++) {
1:c0a5ce1:             assertSetError(psInsertDouble, beyondDB2Double[i], defer);
1:c0a5ce1:             assertUpdateError(psSelect, beyondDB2Double[i], defer);
1:c0a5ce1:         }
1:c0a5ce1:     }
1:f448bbb: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.9");
commit:987a158
/////////////////////////////////////////////////////////////////////////
1:         1.17549435E-38f, // Float.MIN_NORMAL
/////////////////////////////////////////////////////////////////////////
1:         2.2250738585072014E-308, // Double.MIN_NORMAL
commit:c0a5ce1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Old DB2 constants in Limits.java:
1:     // static final float DB2_SMALLEST_REAL = -3.402E+38f;
1:     // static final float DB2_LARGEST_REAL  = +3.402E+38f;
1:     // static final float DB2_SMALLEST_POSITIVE_REAL = +1.175E-37f;
1:     // static final float DB2_LARGEST_NEGATIVE_REAL  = -1.175E-37f;
1: 
1:     // static final double DB2_SMALLEST_DOUBLE = -1.79769E+308d;
1:     // static final double DB2_LARGEST_DOUBLE  = +1.79769E+308d;
1:     // static final double DB2_SMALLEST_POSITIVE_DOUBLE = +2.225E-307d;
1:     // static final double DB2_LARGEST_NEGATIVE_DOUBLE  = -2.225E-307d;
1: 
1:     static final float[] beyondDB2Real = new float[] {
1:         Float.MIN_VALUE,
1:         Float.MAX_VALUE,
1:         +1.174E-37f,
1:         -1.174E-37f,
0:         1.17549435E-38f // Float.MIN_NORMAL
1:         -1.17549435E-38f // -Float.MIN_NORMAL
1:     };
1: 
1:     static final double[] beyondDB2Double = new double[] {
1:         Double.MIN_VALUE,
1:         Double.MAX_VALUE,
1:         +2.224E-307d,
1:         -2.224E-307d,
0:         2.2250738585072014E-308 // Double.MIN_NORMAL
1:         -2.2250738585072014E-308 // -Double.MIN_NORMAL
1:     };
1: 
1:     /**
1:      * Verify upgrade behavior DERBY-3398: removing DB2 float limits
1:      */
1:     public  void    testFloatLimits()  throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.execute("create table d3398(r real, d double)");
1: 
1:         PreparedStatement psInsertReal =
1:             prepareStatement("insert into d3398(r) values (?)");
1:         PreparedStatement psInsertDouble =
1:             prepareStatement("insert into d3398(d) values (?)");
1:         PreparedStatement psSelect =
1:             prepareStatement("select * from d3398",
1:                 ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_UPDATABLE);
1: 
1:         st.execute("insert into d3398 values (0.0, 0.0)");
1: 
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:             verifyDB2Behavior(psSelect, psInsertReal, psInsertDouble, false);
1: 
1:             break;
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old
1:                                    // version after soft-upgrade
1:             verifyDB2Behavior(psSelect, psInsertReal, psInsertDouble, false);
1: 
1:             break;
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1: 
1:             verifyDB2Behavior(psSelect, psInsertReal, psInsertDouble, true);
1: 
1:             break;
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1: 
1:             for (int i = 0; i < beyondDB2Real.length; i++) {
1:                 psInsertReal.setFloat(1, beyondDB2Real[i]);
1:                 psInsertReal.execute();
1: 
1:                 ResultSet rs = psSelect.executeQuery();
1:                 rs.next();
1:                 rs.updateFloat(1, beyondDB2Real[i]);
1:                 rs.updateRow();
1:                 rs.close();
1:             }
1: 
1:             for (int i = 0; i < beyondDB2Double.length; i++) {
1:                 psInsertDouble.setDouble(1, beyondDB2Double[i]);
1:                 psInsertDouble.execute();
1: 
1:                 ResultSet rs = psSelect.executeQuery();
1:                 rs.next();
1:                 rs.updateDouble(2, beyondDB2Double[i]);
1:                 rs.updateRow();
1:                 rs.close();
1:             }
1: 
1:             break;
1:         }
1: 
1:         st.executeUpdate("drop table d3398");
1:         st.close();
1:     }
1: 
1:     private void assertSetError(PreparedStatement ps, float fv, boolean defer)
1:             throws SQLException {
1:         try {
1:             ps.setFloat(1, fv);
1: 
1:             if (!defer) {
1:                 fail();
1:             }
1: 
1:             ps.executeUpdate();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22003", e);
1:         }
1:     }
1:     private void assertSetError(PreparedStatement ps, double dv, boolean defer)
1:             throws SQLException {
1:         try {
1:             ps.setDouble(1, dv);
1: 
1:             if (!defer) {
1:                 fail();
1:             }
1: 
1:             ps.executeUpdate();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22003", e);
1:         }
1:     }
1: 
1: 
1:     private void assertUpdateError(
1:             PreparedStatement ps,
1:             float fv,
1:             boolean defer) throws SQLException {
1: 
1:         boolean supportsForwardUpdatableResultSet = oldAtLeast( 10, 2 );
1: 
1:         if (!supportsForwardUpdatableResultSet) {
1:             return;
1:         }
1: 
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1: 
1:         try {
1:             rs.updateFloat(1, fv);
1: 
1:             if (!defer) {
1:                 fail();
1:             }
1: 
1:             rs.updateRow();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22003", e);
1:         } finally {
1:             rs.close();
1:         }
1:     }
1: 
1:     private void assertUpdateError(
1:             PreparedStatement ps,
1:             double fv,
1:             boolean defer) throws SQLException {
1: 
1:         boolean supportsForwardUpdatableResultSet = oldAtLeast( 10, 2 );
1: 
1:         if (!supportsForwardUpdatableResultSet) {
1:             return;
1:         }
1: 
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1: 
1:         try {
1:             rs.updateDouble(1, fv);
1: 
1:             if (!defer) {
1:                 fail();
1:             }
1: 
1:             rs.updateRow();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22003", e);
1:         } finally {
1:             rs.close();
1:         }
1:     }
1: 
1:     /**
1:      * Check that the old DB2 limits are (still) enforced.
1:      *
1:      * @param defer In soft upgrade mode, the checking if deferred after
1:      * DERBY-3398, i.e. instead of throwing on the DB2 limits when calling
1:      * {@code ResultSet#updateXXX} or {@code PreparedStatement#setXXX}, the
1:      * check throws on {@code ResultSet#updateRow}, or {#insertRow}, and
1:      * similarly on {@code PreparedStatement#execute} or {@code #executeUpdate}.
1:      *
1:      * @throws SQLException if we see some expected error.
1:      */
1:     private void verifyDB2Behavior (
1:             PreparedStatement psSelect,
1:             PreparedStatement psInsertReal,
1:             PreparedStatement psInsertDouble,
1:             boolean defer) throws SQLException {
1: 
1:         for (int i = 0; i < beyondDB2Real.length; i++) {
1:             assertSetError(psInsertReal, beyondDB2Real[i], defer);
1:             assertUpdateError(psSelect, beyondDB2Real[i], defer);
1:         }
1: 
1:         for (int i = 0; i < beyondDB2Double.length; i++) {
1:             assertSetError(psInsertDouble, beyondDB2Double[i], defer);
1:             assertUpdateError(psSelect, beyondDB2Double[i], defer);
1:         }
1:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:092cf8b
/////////////////////////////////////////////////////////////////////////
1:         String  iss = "call syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS()";
1:         String  rt = "call syscs_util.syscs_register_tool( 'foo', true )";
1:         String  rtGoodSQLState = "X0Y88";
1:         String  syntaxError = "42X01";
1:         boolean atLeastJava5 = JDBC.vmSupportsJDBC3();
1:         boolean oldSupportsBoolean = oldAtLeast( 10, 7 );
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             vetProcs( s, iss, false, null );
1:             if ( atLeastJava5 )
1:             {
1:                 vetProcs
1:                     ( s, rt, false,
1:                       oldSupportsBoolean || (getPhase() == PH_SOFT_UPGRADE ) ? null : syntaxError );
1:             }
1:             vetProcs( s, iss, true, null );
1:             if ( atLeastJava5 ) { vetProcs( s, rt, true, rtGoodSQLState ); }
/////////////////////////////////////////////////////////////////////////
1:     private void    vetProcs
1:         (
1:          Statement s,
1:          String procCall, 
1:          boolean shouldExist,
1:          String sqlState
1:          ) throws Exception
1:                 fail( "Procedure should not exist!"  );
1:             }
1:             if ( sqlState != null )
1:             {
1:                 fail( "Expected to fail with SQLState " + sqlState );
1:             if ( sqlState == null ) { sqlState = "42Y03"; }
1:             assertSQLState( sqlState, se );
commit:5f587f7
/////////////////////////////////////////////////////////////////////////
1:         String  createVarargsProc = "create procedure vds ( a int ... ) language java parameter style derby no sql external name 'Foo.foo'";
1:         String  createVarargsFunc = "create function vds ( a int ... ) returns integer language java parameter style derby no sql external name 'Foo.foo'";
1:         String  createVarargsTableFunc = "create function vtf ( a int ... ) returns table ( b int ) language java parameter style derby_jdbc_result_set no sql external name 'Foo.foo'";
1:         String  createNonVarargsProcDerbyStyle = "create procedure nvds ( a int ) language java parameter style derby no sql external name 'Foo.foo'";
1:         String  createNonVarargsFuncDerbyStyle = "create function nvds ( a int ) returns integer language java parameter style derby no sql external name 'Foo.foo'";
commit:f9596d4
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  NEEDS_JAVA_STYLE = "42ZCA";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify upgrade behavior for vararg routines.
1:      */
1:     public  void    testVarargss()  throws Exception
1:     {
1:         Statement st = createStatement();
1: 
0:         String  createVarargsProc = "create procedure varargsderbystyle ( a int ... ) language java parameter style derby no sql external name 'Foo.foo'";
0:         String  createVarargsFunc = "create function varargsderbystyle ( a int ... ) returns integer language java parameter style derby no sql external name 'Foo.foo'";
0:         String  createVarargsTableFunc = "create function varargstablefunction ( a int ... ) returns table ( b int ) language java parameter style derby_jdbc_result_set no sql external name 'Foo.foo'";
0:         String  createNonVarargsProcDerbyStyle = "create procedure nonvarargsderbystyle ( a int ) language java parameter style derby no sql external name 'Foo.foo'";
0:         String  createNonVarargsFuncDerbyStyle = "create function nonvarargsderbystyle ( a int ) returns integer language java parameter style derby no sql external name 'Foo.foo'";
1: 
1:         // table functions were introduced by 10.4
1:         boolean tableFunctionsOK = oldAtLeast( 10, 4 );       
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             assertStatementError( SYNTAX_ERROR, st, createVarargsProc );
1:             assertStatementError( SYNTAX_ERROR, st, createVarargsFunc );
1:             if ( tableFunctionsOK ) { assertStatementError( SYNTAX_ERROR, st, createVarargsTableFunc ); }
1:             assertStatementError( SYNTAX_ERROR, st, createNonVarargsProcDerbyStyle );
1:             assertStatementError( SYNTAX_ERROR, st, createNonVarargsFuncDerbyStyle );
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createVarargsProc );
1:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createVarargsFunc );
1:             if ( tableFunctionsOK ) { assertStatementError( HARD_UPGRADE_REQUIRED, st, createVarargsTableFunc ); }
1:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createNonVarargsProcDerbyStyle );
1:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createNonVarargsFuncDerbyStyle );
1:             break;
1:             
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             st.execute( createVarargsProc );
1:             st.execute( createVarargsFunc );
1:             st.execute( createVarargsTableFunc );
1:             assertStatementError( NEEDS_JAVA_STYLE, st, createNonVarargsProcDerbyStyle );
1:             assertStatementError( NEEDS_JAVA_STYLE, st, createNonVarargsFuncDerbyStyle );
1:             break;
1:         }
1:         
1:         st.close();
1:     }
1:     
commit:22d64f5
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  SYNTAX_ERROR = "42X01";
1:     private static  final   String  HARD_UPGRADE_REQUIRED = "XCL47";
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verify upgrade behavior for user-defined aggregates.
1:      */
1:     public  void    testUDAs()  throws Exception
1:     {
1:         Statement st = createStatement();
1: 
1:         String  createUDA = "create derby aggregate mode for int external name 'foo.bar.Wibble'";
1:         String  dropUDA = "drop derby aggregate mode restrict";
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             assertStatementError( SYNTAX_ERROR, st, createUDA );
1:             assertStatementError( SYNTAX_ERROR, st, dropUDA );
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             assertStatementError( HARD_UPGRADE_REQUIRED, st, createUDA );
1:             assertStatementError( HARD_UPGRADE_REQUIRED, st, dropUDA );
1:             break;
1:             
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             st.execute( createUDA );
1:             st.execute( dropUDA );
1:             break;
1:         }
1:         
1:         st.close();
1:     }
1:     
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:9496f49
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:     The readme file cautioning users against touching the files in
1:     the database directory 
1:     */
1:     private static final String DB_README_FILE_NAME = "README_DO_NOT_TOUCH_FILES.txt";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-5996(Create readme files (cautioning users against modifying 
1:      *  database files) at database hard upgrade time)
1:      * Simple test to make sure readme files are getting created
1:      */
1:     public void testReadMeFiles() throws SQLException, IOException
1:     {
1:         Statement s = createStatement();
1:         s.close();
1:         TestConfiguration currentConfig = TestConfiguration.getCurrent();
1:         String dbPath = currentConfig.getDatabasePath(currentConfig.getDefaultDatabaseName());
1:         switch (getPhase())
1:         {
1:         case PH_CREATE:
1:         case PH_SOFT_UPGRADE:
1:         case PH_POST_SOFT_UPGRADE:
1:             // DERBY-5995 Pre 10.10 databases would not have readme files
1:             lookForReadmeFile(dbPath, false);
1:             lookForReadmeFile(dbPath+File.separator+"seg0", false);
1:             lookForReadmeFile(dbPath+File.separator+"log", false);
1:             break;
1:         case PH_HARD_UPGRADE:
1:         case PH_POST_HARD_UPGRADE:
1:             // DERBY-5995 Hard upgrade to 10.10 will create readme files
1:             lookForReadmeFile(dbPath, true);
1:             lookForReadmeFile(dbPath+File.separator+"seg0", true);
1:             lookForReadmeFile(dbPath+File.separator+"log", true);
1:             break;
1:         }
1:     }
1: 
1:     /**
1:      * For pre-10.10 database, fileShouldExist will be false. For hard upgraded
1:      *  databases to 10.10, fileShouldExist will be true
1:      * @param path - this can be root database directory, log or seg0 directory
1:      * @param fileShouldExist
1:      * @throws IOException
1:      */
1:     private void lookForReadmeFile(String path, boolean fileShouldExist) throws IOException {
1:         File readmeFile = new File(path,
1:             DB_README_FILE_NAME);
1:         if (fileShouldExist)
1:         {
1:             assertTrue(readmeFile + "doesn't exist", 
1:                 PrivilegedFileOpsForTests.exists(readmeFile));
1:         } else 
1:         {
1:             assertFalse(readmeFile + "exists", 
1:                 PrivilegedFileOpsForTests.exists(readmeFile));
1:         
1:         }
1:     }
1:     
commit:f448bbb
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_10
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
1: import java.io.File;
1: 
0: import java.net.MalformedURLException;
0: import java.net.URL;
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.ArrayList;
0: import java.util.List;
1: 
0: import javax.sql.DataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.functionTests.tests.upgradeTests.helpers.DisposableIndexStatistics;
0: import org.apache.derbyTesting.junit.IndexStatsUtil;
1: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: /**
1:  * Upgrade test cases for 10.10.
1:  */
1: public class Changes10_10 extends UpgradeChange
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public Changes10_10(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return the suite of tests to test the changes made in 10.10.
1:      * @param phase an integer that indicates the current phase in
1:      *              the upgrade test.
1:      * @return the test suite created.
1:      */
1:     public static Test suite(int phase) {
0:         TestSuite suite = new TestSuite("Upgrade test for 10.9");
1: 
1:         suite.addTestSuite(Changes10_10.class);
1:         
1:         return new SupportFilesSetup((Test) suite);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Make sure that the following procedure(s) which are new to 10.10 are 
1:      *  only available after hard-upgrade
1:      *  1)invalidate stored statements 
1:      *    SYCS_UTIL.SYSCS_INVALIDATE_STORED_STATEMENTS
1:      */
1:     public  void    testProcsNewTo10_10()  throws Exception
1:     {
1:         Statement s = createStatement();
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
0:             vetProcs(s, "call syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS()", 
0:             		false, 
0:             		"syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS should not exist.");
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
0:             vetProcs(s, "call syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS()", 
0:             		false, 
0:             		"syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS should not exist.");
1:             break;
1:             
0:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
0:             vetProcs(s, "call syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS()", 
0:             		false, 
0:             		"syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS should not exist.");
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
0:             vetProcs(s, "call syscs_util.SYSCS_INVALIDATE_STORED_STATEMENTS()", 
0:             		true, 
0:             		null);
1:             break;
1:         }
1:         
1:         s.close();
1:     	
1:     }
1:     
0:     private void    vetProcs( Statement s, String procCall, 
0:     		boolean shouldExist,
0:     		String errorMessage) throws Exception
1:     {
1:         try {
1:             s.execute( procCall );
1:             
1:             if ( !shouldExist )
1:             {
0:                 fail( errorMessage );
1:             }
1:         } catch (SQLException se )
1:         {
0:             if ( shouldExist )
1:             {
0:                 assertSQLState( "4251K", se );
1:             }
0:             else
1:             {
0:                 assertSQLState( "42Y03", se );
1:             }
1:         }
1:     }
1: }
============================================================================