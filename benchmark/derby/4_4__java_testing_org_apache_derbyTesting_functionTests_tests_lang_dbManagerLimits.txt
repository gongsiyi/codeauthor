1:67614ad: /*
1:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.dbManagerLimits
1:67614ad: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
73:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
2:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.tests.lang;
1:67614ad: 
1:67614ad: import java.sql.*;
1:67614ad: 
1:67614ad: import org.apache.derby.tools.ij;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:67614ad: import org.apache.derbyTesting.functionTests.util.Formatters;
1:67614ad: 
2:67614ad: /**
1:67614ad:   Test various data manager limits like in db2 here.
1:67614ad:  */
1:67614ad: public class dbManagerLimits
1:67614ad: {
1:67614ad: 
1:67614ad: 	public static void main (String[] argv) throws Throwable
1:67614ad: 	{
1:67614ad: 		ij.getPropertyArg(argv);
1:67614ad: 		Connection conn = ij.startJBMS();
1:67614ad: 
1:67614ad: 		testStringAndHexConstants(conn);
1:67614ad: 		testMostColumnsInTable(conn);
1:67614ad: 		testMostColumnsInView(conn);
1:67614ad: 		testMostElementsInSelectList(conn);
1:67614ad: 		testMostElementsInOrderBy(conn);
1:67614ad: 		testMostParametersInStoredProcedures(conn);
1:67614ad: 
1:67614ad: 		//not running Group By test because it gets out of memory error
1:67614ad: 		//testMostElementsInGroupBy(conn);
1:67614ad: 
1:67614ad: 		//not running indexes test because it doesn't finish even after running for over 2 hours
1:67614ad: 		//ALSO, IF WE EVER ENABLE THIS TEST IN FUTURE, WE NEED TO REWRITE THE TEST SO THAT WE TRY TO CREATE OVER
1:67614ad: 		//32767 *DIFFERENT* INDEXES. AS PART OF DB2 COMPATIBILITY WORK, BUG - 5685 DISALLOWS CREATION OF AN INDEX
1:67614ad: 		//ON A COLUMN THAT ALREADY HAS A PRIMARY KEY OR UNIQUE CONSTRAINT ON IT.
1:67614ad: 		//testMostIndexesOnTable(conn);
3:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testStringAndHexConstants( Connection conn) throws Throwable
1:67614ad: 	{
2:67614ad:     try {
1:67614ad: 			System.out.println("Test - maximum length of character constant is 32672 and that of hex constant is 16336");
1:67614ad: 			String stringConstant32671 = Formatters.repeatChar("a",32671);
1:67614ad: 			String hexConstant16334 = Formatters.repeatChar("a",16334);
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			s.executeUpdate("create table t1 (c11 long varchar, c12 long varchar for bit data)");
1:67614ad: 
1:67614ad: 			System.out.println("First testing less than maximum constant lengths through insert statement");
1:67614ad: 			s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "')");
1:67614ad: 			s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "')");
1:67614ad:       
1:67614ad: 			System.out.println("Next testing less than maximum constant lengths through values");
1:67614ad: 			s.execute("values ('" +  stringConstant32671 + "')");
1:67614ad: 			s.execute("values (X'" +  hexConstant16334 + "')");
1:67614ad: 
1:67614ad: 			System.out.println("Next testing maximum constant lengths through insert statement");
1:67614ad: 			s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "a')");
1:67614ad: 			s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "ab')");
1:67614ad:       
1:67614ad: 			System.out.println("Next testing maximum constant lengths through values");
1:67614ad: 			s.execute("values ('" +  stringConstant32671 + "a')");
1:67614ad: 			s.execute("values (X'" +  hexConstant16334 + "ab')");
1:67614ad: 
1:67614ad: 			System.out.println("Next testing maximum constant lengths + 1 through insert statement");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "ab')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1:67614ad: 			}
2:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
2:67614ad: 					System.out.println("expected exception " + e.getMessage());
2:67614ad: 				else
2:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "abcd')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Next testing maximum constant lengths + 1 through values");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("values ('" +  stringConstant32671 + "ab')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("values (X'" +  hexConstant16334 + "abcd')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Next testing maximum constant lengths + n through insert statement");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "bcdef')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "abcdef')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Next testing maximum constant lengths + n through values");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("values ('" +  stringConstant32671 + "bcdef')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("values (X'" +  hexConstant16334 + "abcdef')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54002"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Next testing odd number of hex digits in a hex constant through insert statement");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "a')");
1:67614ad: 				System.out.println("FAIL - should have gotten hex constant invalid string constant too long error for this values statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("42606"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			System.out.println("And finally testing odd number of hex digits in a hex constant through values statement");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("values (X'" +  hexConstant16334 + "a')");
1:67614ad: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("42606"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testMostColumnsInTable( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most columns allowed in a table");
1:67614ad: 
1:67614ad: 			StringBuffer sbTableElements = new StringBuffer();
1:67614ad: 			String tempString = new String();
1:67614ad: 			int i = 0;
1:67614ad: 			sbTableElements.append("create table t1 (");
1:b1f84c1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
1:67614ad: 				sbTableElements.append("c" + i +" int, ");
1:67614ad: 
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			System.out.println("First create a table with one column less than maximum allowed number of columns");
1:67614ad: 			tempString = (sbTableElements.toString()).concat("c" + i + " int)");
2:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 			System.out.println("  Try alter table on it to have table with maximum allowed number of columns");
1:67614ad: 			s.executeUpdate("alter table t1 add column c" + (i+1) + " int");
1:67614ad: 			System.out.println("  Try another alter table to have table with one column more than maximum allowed number of columns");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("alter table t1 add column c" + (i+2) + " int");
1:67614ad: 				System.out.println("FAIL - The alter table should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 
1:67614ad: 			System.out.println("Next create a table with maximum allowed number of columns");
1:67614ad: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int)");
1:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 			System.out.println("  Try alter table to have table with more columns than maximum allowed number of columns");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("alter table t1 add column c" + (i+2) + " int");
1:67614ad: 				System.out.println("FAIL - The alter table should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			//just some basic sanity check 
1:67614ad: 			DatabaseMetaData met = conn.getMetaData();
1:67614ad: 			getCount(met.getColumns("", "APP", "T1", null));
1:67614ad: 			s.executeUpdate("insert into t1(c1, c2) values (1,1)");
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 
1:67614ad: 			System.out.println("Next create a table with one column more than maximum allowed number of columns");
1:67614ad: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int, c" + (i+2) + " int)");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate(tempString);
1:67614ad: 				System.out.println("FAIL - The create table should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Finally, create a table with 2 columns more than maximum allowed number of columns");
1:67614ad: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int, c" + (i+2) + " int, c" + (i+3) + " int)");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate(tempString);
1:67614ad: 				System.out.println("FAIL - The create table should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	private static void getCount( ResultSet s) throws Throwable
1:67614ad: 	{
1:67614ad: 		int counter = 0; // Display data, fetching until end of the result set
1:67614ad: 		while (s.next())
1:67614ad: 			counter++;
1:67614ad: 		System.out.println("Found " + counter + " columns/parameters through meta data");
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testMostColumnsInView( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most columns allowed in a view");
1:67614ad: 
1:67614ad: 			StringBuffer sbValuesClause = new StringBuffer();
1:67614ad: 			StringBuffer sbViewColumnNames = new StringBuffer();
1:67614ad: 			String tempString = new String();
1:67614ad: 			int i = 0;
1:b1f84c1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW-2; i++) {
1:67614ad: 				sbValuesClause.append(1 + ", ");
1:67614ad: 				sbViewColumnNames.append("c" + i + ", ");
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			System.out.println("First create a view with one column less than maximum allowed number of columns");
1:67614ad: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ") as values (" + sbValuesClause.toString() + "1)";
1:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 			s.executeUpdate("drop view v1");
1:67614ad: 
1:67614ad: 			System.out.println("Next create a view with maximum allowed number of columns");
1:67614ad: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1)+ ") as values (" + sbValuesClause.toString() + "1,1)";
1:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 			//just some basic sanity check 
1:67614ad: 			DatabaseMetaData met = conn.getMetaData();
1:67614ad: 			getCount(met.getColumns("", "APP", "V1", null));
1:67614ad: 			s.executeUpdate("drop view v1");
1:67614ad: 
1:67614ad: 			System.out.println("Next create a view with one column more than that maximum allowed number of columns");
1:67614ad: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1) + ", c" + (i+2) + ") as values (" + sbValuesClause.toString() + "1,1,1)";
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate(tempString);
1:67614ad: 				System.out.println("FAIL - The create view should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("And finally create a view with 2 columns that maximum allowed number of columns");
1:67614ad: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1) + ", c" + (i+2) + ", c" + (i+3) +") as values (" + sbValuesClause.toString() + "1,1,1,1)";
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate(tempString);
1:67614ad: 				System.out.println("FAIL - The create view should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testMostElementsInSelectList( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most elements allowed in a select list");
1:67614ad: 
1:67614ad: 			StringBuffer sb = new StringBuffer();
1:67614ad: 			String tempString = new String();
1:67614ad: 			int i = 0;
1:67614ad: 			sb.append("create table t1 (");
1:b1f84c1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
1:67614ad: 				sb.append("c" + i +" int, ");
1:67614ad: 
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			tempString = (sb.toString()).concat("c" + i + " int)");
1:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 
1:67614ad: 			System.out.println("First try a select with one column less than maximum allowed number of columns");
1:67614ad: 			s.execute("select * from t1");
1:67614ad: 
1:67614ad: 			System.out.println("Next try a select with maximum allowed number of columns");
1:67614ad: 			s.execute("select t1.*,1 from t1");
1:67614ad: 
1:67614ad: 			System.out.println("Next try a select with one column more than maximum allowed number of columns");
1:67614ad: 			try {
1:67614ad: 				s.execute("select t1.*,1,2 from t1");
1:67614ad: 				System.out.println("FAIL - select should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54004"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Next try a select with 2 more columns than maximum allowed number of columns");
1:67614ad: 			try {
1:67614ad: 				s.execute("select t1.*,1,2,3 from t1");
1:67614ad: 				System.out.println("FAIL - select should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54004"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testMostElementsInOrderBy( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most columns allowed in a ORDER BY clause");
1:67614ad: 
1:67614ad: 			StringBuffer sbOrderBy = new StringBuffer();
1:67614ad: 			String tempString = new String();
1:67614ad: 			int i = 0;
1:67614ad: 			sbOrderBy.append("select * from t1 order by ");
1:b1f84c1: 			for (i = 0; i < Limits.DB2_MAX_ELEMENTS_IN_ORDER_BY-2; i++)
1:67614ad: 				sbOrderBy.append("c1, ");
1:67614ad: 
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			s.executeUpdate("create table t1 (c1 int not null, c2 int)");
1:67614ad:       
1:67614ad: 			System.out.println("First try order by with one column less than maximum allowed number of columns");
1:67614ad: 			tempString = (sbOrderBy.toString()).concat("c2");
1:67614ad: 			s.execute(tempString);
1:67614ad: 
1:67614ad: 			System.out.println("Next try an order by with maximum allowed number of columns");
1:67614ad: 			tempString = (sbOrderBy.toString()).concat("c1, c2");
1:67614ad: 			s.execute(tempString);
1:67614ad: 
1:67614ad: 			System.out.println("Next try an order by with one column more than maximum allowed number of columns");
1:67614ad: 			tempString = (sbOrderBy.toString()).concat("c1, c2, c1");
1:67614ad: 			try {
1:67614ad: 				s.execute(tempString);
1:67614ad: 				System.out.println("FAIL - order by should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54004"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("And finally try an order by with 2 more columns than maximum allowed number of columns");
1:67614ad: 			tempString = (sbOrderBy.toString()).concat("c1, c2, c1");
1:67614ad: 			try {
1:67614ad: 				s.execute(tempString);
1:67614ad: 				System.out.println("FAIL - order by should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54004"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testMostElementsInGroupBy( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most columns allowed in a GROUP BY clause");
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			StringBuffer sbGroupBy = new StringBuffer("select 1 from v1, v2, v3, v4, v5, v6, v7 group by ");
1:67614ad: 			StringBuffer sbValuesClause = new StringBuffer();
1:67614ad: 			StringBuffer sbViewColumnNames = new StringBuffer();
1:67614ad: 			String tempString = new String();
1:67614ad: 
1:67614ad: 			//first create 7 views with 5000 columns each
1:67614ad: 			int i = 0;
1:b1f84c1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW-1; i++)
1:67614ad: 				sbValuesClause.append(1 + ", ");
1:67614ad: 
1:67614ad: 			for (int j = 1; j < 8; j++) {
1:b1f84c1: 				for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW-1; i++) {
1:67614ad: 					sbViewColumnNames.append("c" + j + "" + i + ", ");
1:67614ad: 				}
1:67614ad: 				tempString = "create view v" + j + "(" + sbViewColumnNames.toString() + "c" + j + "" + i + ") as values (" + sbValuesClause.toString() + "1)";
1:67614ad: 				s.executeUpdate(tempString);
1:67614ad: 				sbViewColumnNames = new StringBuffer();
1:67614ad: 			}
1:67614ad:       
1:67614ad: 			for (int j = 1; j < 7; j++) {
1:b1f84c1: 				for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW; i++)
1:67614ad: 					sbGroupBy.append("c" + j + "" + i + ", ");
1:67614ad: 			}
1:67614ad: 			for (i = 0; i < 2675; i++)
1:67614ad: 				sbGroupBy.append("c7" + i + ", ");
1:67614ad: 
1:67614ad: 			System.out.println("First try group by with one column less than maximum allowed number of columns");
1:67614ad: 			tempString = (sbGroupBy.toString()).concat("c72675");
1:67614ad: 			s.execute(tempString);
1:67614ad: 
1:67614ad: 			System.out.println("Next try an group by with maximum allowed number of columns");
1:67614ad: 			tempString = (sbGroupBy.toString()).concat("c72675, c72675");
1:67614ad: 			s.execute(tempString);
1:67614ad: 
1:67614ad: 			System.out.println("And finally try an group by with more columns that maximum allowed number of columns");
1:67614ad: 			tempString = (sbGroupBy.toString()).concat("c72675, c72676, c72677");
1:67614ad: 			try {
1:67614ad: 				s.execute(tempString);
1:67614ad: 				System.out.println("FAIL - group by should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54004"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			s.executeUpdate("drop view v1");
1:67614ad: 			s.executeUpdate("drop view v2");
1:67614ad: 			s.executeUpdate("drop view v3");
1:67614ad: 			s.executeUpdate("drop view v4");
1:67614ad: 			s.executeUpdate("drop view v5");
1:67614ad: 			s.executeUpdate("drop view v6");
1:67614ad: 			s.executeUpdate("drop view v7");
1:67614ad: 
1:67614ad: 			s.execute("select 1 from v1 group by c1,c2");
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void testMostParametersInStoredProcedures( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most parameters allowed for a stored procedure");
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			StringBuffer sbCreateProcParams = new StringBuffer();
1:67614ad: 			StringBuffer sbExecuteProcParams = new StringBuffer();
1:67614ad: 			String tempString = new String();
1:67614ad: 			int i = 0;
1:c87505f:             int oldDB2Limits = 90;
1:67614ad: 
1:c87505f: 			for (i = 0; i < oldDB2Limits-2; i++) {
1:67614ad: 				sbCreateProcParams.append("i" + i + " int, ");
1:67614ad: 				sbExecuteProcParams.append("1, ");
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("First create a procedure with one parameter less than maximum allowed number of parameters");
1:67614ad: 			tempString = "create procedure P1(" + sbCreateProcParams.toString() + "i" + i +
1:67614ad:         " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.lessThanMaxParams\' NO SQL";
1:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 
1:67614ad: 			System.out.println("Next create a procedure with maximum allowed number of parameters");
1:67614ad: 			tempString = "create procedure P2(" + sbCreateProcParams.toString() + "i" + i +
1:67614ad:         " int, i" + (i+1) + " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.maxAllowedParams\' NO SQL";
1:67614ad: 			s.executeUpdate(tempString);
1:67614ad: 			//just some basic sanity check 
1:67614ad: 			DatabaseMetaData met = conn.getMetaData();
1:67614ad: 			getCount(met.getProcedureColumns("", "APP", "P2", null));
1:67614ad: 
1:c87505f:             // This now succeeds because of the work done on DERBY-6033.
1:67614ad: 			System.out.println("And finally create a procedure with more parameters that maximum allowed number of parameters");
1:67614ad: 			tempString = "create procedure P3(" + sbCreateProcParams.toString() + "i" + i +
1:67614ad:         " int, i" + (i+1) + " int, i" + (i+2) + " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.moreThanMaxAllowedParams\' NO SQL";
1:c87505f:             s.executeUpdate(tempString);
1:c87505f: 			getCount(met.getProcedureColumns("", "APP", "P3", null));
1:c87505f:             
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 		//not running indexes test because it doesn't finish even after running for over 2 hours
1:67614ad: 		//ALSO, IF WE EVER ENABLE THIS TEST IN FUTURE, WE NEED TO REWRITE THE TEST SO THAT WE TRY TO CREATE OVER
1:67614ad: 		//32767 *DIFFERENT* INDEXES. AS PART OF DB2 COMPATIBILITY WORK, BUG - 5685 DISALLOWS CREATION OF AN INDEX
1:67614ad: 		//ON A COLUMN THAT ALREADY HAS A PRIMARY KEY OR UNIQUE CONSTRAINT ON IT.
1:67614ad: 	public static void testMostIndexesOnTable( Connection conn) throws Throwable
1:67614ad: 	{
1:67614ad:     try {
1:67614ad: 			System.out.println("Test - most indexes allowed on a table");
1:67614ad: 			conn.setAutoCommit(false);
1:67614ad: 			Statement s = conn.createStatement();
1:67614ad: 			int i = 0;
1:67614ad: 
1:67614ad: 			s.executeUpdate("create table t1 (c1 int not null, c2 int, primary key(c1))");
1:67614ad: 			System.out.println("First create one index less than maximum allowed number of indexes");
1:b1f84c1: 			for (i = 0; i < Limits.DB2_MAX_INDEXES_ON_TABLE-2; i++) {
1:67614ad: 				s.executeUpdate("create index i" + i + " on t1(c1,c2)");
1:67614ad: 			System.out.println("   create index" + i);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("Next create maximum allowed number of indexes");
1:67614ad: 			s.executeUpdate("create index i" + (i+1) + " on t1(c1,c2)");
1:67614ad: 
1:67614ad: 			System.out.println("And finally create one index more than maximum allowed number of indexes");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("create index i" + (i+2) + " on t1(c1,c2)");
1:67614ad: 				System.out.println("FAIL - create index should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			System.out.println("And finally try maximum allowed number of indexes violation using add constraint");
1:67614ad: 			try {
1:67614ad: 				s.executeUpdate("alter table t1 add constraint i" + (i+2) + " unique (c1,c2)");
1:67614ad: 				System.out.println("FAIL - create index should have failed");
1:67614ad: 			}
1:67614ad: 			catch (SQLException e) {
1:67614ad: 				if (e.getSQLState().equals("54011"))
1:67614ad: 					System.out.println("expected exception " + e.getMessage());
1:67614ad: 				else
1:67614ad: 					dumpSQLExceptions(e);
1:67614ad: 			}
1:67614ad: 			s.executeUpdate("drop table t1");
1:67614ad: 			conn.setAutoCommit(true);
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:67614ad: 			sqle.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	static private void dumpSQLExceptions (SQLException se) {
1:67614ad: 		System.out.println("FAIL -- unexpected exception: " + se.toString());
1:67614ad: 		while (se != null) {
1:67614ad: 			System.out.print("SQLSTATE("+se.getSQLState()+"):");
1:67614ad: 			se = se.getNextException();
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:c87505f
/////////////////////////////////////////////////////////////////////////
1:             int oldDB2Limits = 90;
1: 			for (i = 0; i < oldDB2Limits-2; i++) {
/////////////////////////////////////////////////////////////////////////
1:             // This now succeeds because of the work done on DERBY-6033.
1:             s.executeUpdate(tempString);
1: 			getCount(met.getProcedureColumns("", "APP", "P3", null));
1:             
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.tests.lang
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.*;
1: 
1: import org.apache.derby.tools.ij;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: 
1: /**
1:   Test various data manager limits like in db2 here.
1:  */
1: public class dbManagerLimits
1: { 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1: 	public static void main (String[] argv) throws Throwable
1: 	{
1: 		ij.getPropertyArg(argv);
1: 		Connection conn = ij.startJBMS();
1: 
1: 		testStringAndHexConstants(conn);
1: 		testMostColumnsInTable(conn);
1: 		testMostColumnsInView(conn);
1: 		testMostElementsInSelectList(conn);
1: 		testMostElementsInOrderBy(conn);
1: 		testMostParametersInStoredProcedures(conn);
1: 
1: 		//not running Group By test because it gets out of memory error
1: 		//testMostElementsInGroupBy(conn);
1: 
1: 		//not running indexes test because it doesn't finish even after running for over 2 hours
1: 		//ALSO, IF WE EVER ENABLE THIS TEST IN FUTURE, WE NEED TO REWRITE THE TEST SO THAT WE TRY TO CREATE OVER
1: 		//32767 *DIFFERENT* INDEXES. AS PART OF DB2 COMPATIBILITY WORK, BUG - 5685 DISALLOWS CREATION OF AN INDEX
1: 		//ON A COLUMN THAT ALREADY HAS A PRIMARY KEY OR UNIQUE CONSTRAINT ON IT.
1: 		//testMostIndexesOnTable(conn);
1: 	}
1: 
1: 	public static void testStringAndHexConstants( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - maximum length of character constant is 32672 and that of hex constant is 16336");
1: 			String stringConstant32671 = Formatters.repeatChar("a",32671);
1: 			String hexConstant16334 = Formatters.repeatChar("a",16334);
1: 			Statement s = conn.createStatement();
1: 			s.executeUpdate("create table t1 (c11 long varchar, c12 long varchar for bit data)");
1: 
1: 			System.out.println("First testing less than maximum constant lengths through insert statement");
1: 			s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "')");
1: 			s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "')");
1:       
1: 			System.out.println("Next testing less than maximum constant lengths through values");
1: 			s.execute("values ('" +  stringConstant32671 + "')");
1: 			s.execute("values (X'" +  hexConstant16334 + "')");
1: 
1: 			System.out.println("Next testing maximum constant lengths through insert statement");
1: 			s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "a')");
1: 			s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "ab')");
1:       
1: 			System.out.println("Next testing maximum constant lengths through values");
1: 			s.execute("values ('" +  stringConstant32671 + "a')");
1: 			s.execute("values (X'" +  hexConstant16334 + "ab')");
1: 
1: 			System.out.println("Next testing maximum constant lengths + 1 through insert statement");
1: 			try {
1: 				s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "ab')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			try {
1: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "abcd')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("Next testing maximum constant lengths + 1 through values");
1: 			try {
1: 				s.executeUpdate("values ('" +  stringConstant32671 + "ab')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			try {
1: 				s.executeUpdate("values (X'" +  hexConstant16334 + "abcd')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("Next testing maximum constant lengths + n through insert statement");
1: 			try {
1: 				s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "bcdef')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			try {
1: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "abcdef')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("Next testing maximum constant lengths + n through values");
1: 			try {
1: 				s.executeUpdate("values ('" +  stringConstant32671 + "bcdef')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			try {
1: 				s.executeUpdate("values (X'" +  hexConstant16334 + "abcdef')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54002"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("Next testing odd number of hex digits in a hex constant through insert statement");
1: 			try {
1: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "a')");
1: 				System.out.println("FAIL - should have gotten hex constant invalid string constant too long error for this values statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("42606"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			System.out.println("And finally testing odd number of hex digits in a hex constant through values statement");
1: 			try {
1: 				s.executeUpdate("values (X'" +  hexConstant16334 + "a')");
1: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("42606"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			s.executeUpdate("drop table t1");
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	public static void testMostColumnsInTable( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most columns allowed in a table");
1: 
1: 			StringBuffer sbTableElements = new StringBuffer();
1: 			String tempString = new String();
1: 			int i = 0;
1: 			sbTableElements.append("create table t1 (");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
1: 				sbTableElements.append("c" + i +" int, ");
1: 
1: 			Statement s = conn.createStatement();
1: 			System.out.println("First create a table with one column less than maximum allowed number of columns");
1: 			tempString = (sbTableElements.toString()).concat("c" + i + " int)");
1: 			s.executeUpdate(tempString);
1: 			System.out.println("  Try alter table on it to have table with maximum allowed number of columns");
1: 			s.executeUpdate("alter table t1 add column c" + (i+1) + " int");
1: 			System.out.println("  Try another alter table to have table with one column more than maximum allowed number of columns");
1: 			try {
1: 				s.executeUpdate("alter table t1 add column c" + (i+2) + " int");
1: 				System.out.println("FAIL - The alter table should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			s.executeUpdate("drop table t1");
1: 
1: 			System.out.println("Next create a table with maximum allowed number of columns");
1: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int)");
1: 			s.executeUpdate(tempString);
1: 			System.out.println("  Try alter table to have table with more columns than maximum allowed number of columns");
1: 			try {
1: 				s.executeUpdate("alter table t1 add column c" + (i+2) + " int");
1: 				System.out.println("FAIL - The alter table should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			//just some basic sanity check 
1: 			DatabaseMetaData met = conn.getMetaData();
1: 			getCount(met.getColumns("", "APP", "T1", null));
1: 			s.executeUpdate("insert into t1(c1, c2) values (1,1)");
1: 			s.executeUpdate("drop table t1");
1: 
1: 			System.out.println("Next create a table with one column more than maximum allowed number of columns");
1: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int, c" + (i+2) + " int)");
1: 			try {
1: 				s.executeUpdate(tempString);
1: 				System.out.println("FAIL - The create table should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("Finally, create a table with 2 columns more than maximum allowed number of columns");
1: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int, c" + (i+2) + " int, c" + (i+3) + " int)");
1: 			try {
1: 				s.executeUpdate(tempString);
1: 				System.out.println("FAIL - The create table should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	private static void getCount( ResultSet s) throws Throwable
1: 	{
1: 		int counter = 0; // Display data, fetching until end of the result set
1: 		while (s.next())
1: 			counter++;
1: 		System.out.println("Found " + counter + " columns/parameters through meta data");
1: 	}
1: 
1: 	public static void testMostColumnsInView( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most columns allowed in a view");
1: 
1: 			StringBuffer sbValuesClause = new StringBuffer();
1: 			StringBuffer sbViewColumnNames = new StringBuffer();
1: 			String tempString = new String();
1: 			int i = 0;
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW-2; i++) {
1: 				sbValuesClause.append(1 + ", ");
1: 				sbViewColumnNames.append("c" + i + ", ");
1: 			}
1: 
1: 			Statement s = conn.createStatement();
1: 			System.out.println("First create a view with one column less than maximum allowed number of columns");
1: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ") as values (" + sbValuesClause.toString() + "1)";
1: 			s.executeUpdate(tempString);
1: 			s.executeUpdate("drop view v1");
1: 
1: 			System.out.println("Next create a view with maximum allowed number of columns");
1: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1)+ ") as values (" + sbValuesClause.toString() + "1,1)";
1: 			s.executeUpdate(tempString);
1: 			//just some basic sanity check 
1: 			DatabaseMetaData met = conn.getMetaData();
1: 			getCount(met.getColumns("", "APP", "V1", null));
1: 			s.executeUpdate("drop view v1");
1: 
1: 			System.out.println("Next create a view with one column more than that maximum allowed number of columns");
1: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1) + ", c" + (i+2) + ") as values (" + sbValuesClause.toString() + "1,1,1)";
1: 			try {
1: 				s.executeUpdate(tempString);
1: 				System.out.println("FAIL - The create view should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("And finally create a view with 2 columns that maximum allowed number of columns");
1: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1) + ", c" + (i+2) + ", c" + (i+3) +") as values (" + sbValuesClause.toString() + "1,1,1,1)";
1: 			try {
1: 				s.executeUpdate(tempString);
1: 				System.out.println("FAIL - The create view should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	public static void testMostElementsInSelectList( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most elements allowed in a select list");
1: 
1: 			StringBuffer sb = new StringBuffer();
1: 			String tempString = new String();
1: 			int i = 0;
1: 			sb.append("create table t1 (");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
1: 				sb.append("c" + i +" int, ");
1: 
1: 			Statement s = conn.createStatement();
1: 			tempString = (sb.toString()).concat("c" + i + " int)");
1: 			s.executeUpdate(tempString);
1: 
1: 			System.out.println("First try a select with one column less than maximum allowed number of columns");
1: 			s.execute("select * from t1");
1: 
1: 			System.out.println("Next try a select with maximum allowed number of columns");
1: 			s.execute("select t1.*,1 from t1");
1: 
1: 			System.out.println("Next try a select with one column more than maximum allowed number of columns");
1: 			try {
1: 				s.execute("select t1.*,1,2 from t1");
1: 				System.out.println("FAIL - select should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54004"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("Next try a select with 2 more columns than maximum allowed number of columns");
1: 			try {
1: 				s.execute("select t1.*,1,2,3 from t1");
1: 				System.out.println("FAIL - select should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54004"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			s.executeUpdate("drop table t1");
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	public static void testMostElementsInOrderBy( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most columns allowed in a ORDER BY clause");
1: 
1: 			StringBuffer sbOrderBy = new StringBuffer();
1: 			String tempString = new String();
1: 			int i = 0;
1: 			sbOrderBy.append("select * from t1 order by ");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_ELEMENTS_IN_ORDER_BY-2; i++)
1: 				sbOrderBy.append("c1, ");
1: 
1: 			Statement s = conn.createStatement();
1: 			s.executeUpdate("create table t1 (c1 int not null, c2 int)");
1:       
1: 			System.out.println("First try order by with one column less than maximum allowed number of columns");
1: 			tempString = (sbOrderBy.toString()).concat("c2");
1: 			s.execute(tempString);
1: 
1: 			System.out.println("Next try an order by with maximum allowed number of columns");
1: 			tempString = (sbOrderBy.toString()).concat("c1, c2");
1: 			s.execute(tempString);
1: 
1: 			System.out.println("Next try an order by with one column more than maximum allowed number of columns");
1: 			tempString = (sbOrderBy.toString()).concat("c1, c2, c1");
1: 			try {
1: 				s.execute(tempString);
1: 				System.out.println("FAIL - order by should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54004"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("And finally try an order by with 2 more columns than maximum allowed number of columns");
1: 			tempString = (sbOrderBy.toString()).concat("c1, c2, c1");
1: 			try {
1: 				s.execute(tempString);
1: 				System.out.println("FAIL - order by should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54004"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			s.executeUpdate("drop table t1");
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	public static void testMostElementsInGroupBy( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most columns allowed in a GROUP BY clause");
1: 			Statement s = conn.createStatement();
1: 			StringBuffer sbGroupBy = new StringBuffer("select 1 from v1, v2, v3, v4, v5, v6, v7 group by ");
1: 			StringBuffer sbValuesClause = new StringBuffer();
1: 			StringBuffer sbViewColumnNames = new StringBuffer();
1: 			String tempString = new String();
1: 
1: 			//first create 7 views with 5000 columns each
1: 			int i = 0;
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW-1; i++)
1: 				sbValuesClause.append(1 + ", ");
1: 
1: 			for (int j = 1; j < 8; j++) {
0: 				for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW-1; i++) {
1: 					sbViewColumnNames.append("c" + j + "" + i + ", ");
1: 				}
1: 				tempString = "create view v" + j + "(" + sbViewColumnNames.toString() + "c" + j + "" + i + ") as values (" + sbValuesClause.toString() + "1)";
1: 				s.executeUpdate(tempString);
1: 				sbViewColumnNames = new StringBuffer();
1: 			}
1:       
1: 			for (int j = 1; j < 7; j++) {
0: 				for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW; i++)
1: 					sbGroupBy.append("c" + j + "" + i + ", ");
1: 			}
1: 			for (i = 0; i < 2675; i++)
1: 				sbGroupBy.append("c7" + i + ", ");
1: 
1: 			System.out.println("First try group by with one column less than maximum allowed number of columns");
1: 			tempString = (sbGroupBy.toString()).concat("c72675");
1: 			s.execute(tempString);
1: 
1: 			System.out.println("Next try an group by with maximum allowed number of columns");
1: 			tempString = (sbGroupBy.toString()).concat("c72675, c72675");
1: 			s.execute(tempString);
1: 
1: 			System.out.println("And finally try an group by with more columns that maximum allowed number of columns");
1: 			tempString = (sbGroupBy.toString()).concat("c72675, c72676, c72677");
1: 			try {
1: 				s.execute(tempString);
1: 				System.out.println("FAIL - group by should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54004"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			s.executeUpdate("drop view v1");
1: 			s.executeUpdate("drop view v2");
1: 			s.executeUpdate("drop view v3");
1: 			s.executeUpdate("drop view v4");
1: 			s.executeUpdate("drop view v5");
1: 			s.executeUpdate("drop view v6");
1: 			s.executeUpdate("drop view v7");
1: 
1: 			s.execute("select 1 from v1 group by c1,c2");
1: 			s.executeUpdate("drop table t1");
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	public static void testMostParametersInStoredProcedures( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most parameters allowed for a stored procedure");
1: 			Statement s = conn.createStatement();
1: 			StringBuffer sbCreateProcParams = new StringBuffer();
1: 			StringBuffer sbExecuteProcParams = new StringBuffer();
1: 			String tempString = new String();
1: 			int i = 0;
1: 
0: 			for (i = 0; i < DB2Limit.DB2_MAX_PARAMS_IN_STORED_PROCEDURE-2; i++) {
1: 				sbCreateProcParams.append("i" + i + " int, ");
1: 				sbExecuteProcParams.append("1, ");
1: 			}
1: 
1: 			System.out.println("First create a procedure with one parameter less than maximum allowed number of parameters");
1: 			tempString = "create procedure P1(" + sbCreateProcParams.toString() + "i" + i +
1:         " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.lessThanMaxParams\' NO SQL";
1: 			s.executeUpdate(tempString);
1: 
1: 			System.out.println("Next create a procedure with maximum allowed number of parameters");
1: 			tempString = "create procedure P2(" + sbCreateProcParams.toString() + "i" + i +
1:         " int, i" + (i+1) + " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.maxAllowedParams\' NO SQL";
1: 			s.executeUpdate(tempString);
1: 			//just some basic sanity check 
1: 			DatabaseMetaData met = conn.getMetaData();
1: 			getCount(met.getProcedureColumns("", "APP", "P2", null));
1: 
1: 			System.out.println("And finally create a procedure with more parameters that maximum allowed number of parameters");
1: 			tempString = "create procedure P3(" + sbCreateProcParams.toString() + "i" + i +
1:         " int, i" + (i+1) + " int, i" + (i+2) + " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.moreThanMaxAllowedParams\' NO SQL";
1: 			try {
1: 				s.executeUpdate(tempString);
0: 				System.out.println("FAIL - create procedure should have failed");
1: 			}
1: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54023"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 		//not running indexes test because it doesn't finish even after running for over 2 hours
1: 		//ALSO, IF WE EVER ENABLE THIS TEST IN FUTURE, WE NEED TO REWRITE THE TEST SO THAT WE TRY TO CREATE OVER
1: 		//32767 *DIFFERENT* INDEXES. AS PART OF DB2 COMPATIBILITY WORK, BUG - 5685 DISALLOWS CREATION OF AN INDEX
1: 		//ON A COLUMN THAT ALREADY HAS A PRIMARY KEY OR UNIQUE CONSTRAINT ON IT.
1: 	public static void testMostIndexesOnTable( Connection conn) throws Throwable
1: 	{
1:     try {
1: 			System.out.println("Test - most indexes allowed on a table");
1: 			conn.setAutoCommit(false);
1: 			Statement s = conn.createStatement();
1: 			int i = 0;
1: 
1: 			s.executeUpdate("create table t1 (c1 int not null, c2 int, primary key(c1))");
1: 			System.out.println("First create one index less than maximum allowed number of indexes");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_INDEXES_ON_TABLE-2; i++) {
1: 				s.executeUpdate("create index i" + i + " on t1(c1,c2)");
1: 			System.out.println("   create index" + i);
1: 			}
1: 
1: 			System.out.println("Next create maximum allowed number of indexes");
1: 			s.executeUpdate("create index i" + (i+1) + " on t1(c1,c2)");
1: 
1: 			System.out.println("And finally create one index more than maximum allowed number of indexes");
1: 			try {
1: 				s.executeUpdate("create index i" + (i+2) + " on t1(c1,c2)");
1: 				System.out.println("FAIL - create index should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 
1: 			System.out.println("And finally try maximum allowed number of indexes violation using add constraint");
1: 			try {
1: 				s.executeUpdate("alter table t1 add constraint i" + (i+2) + " unique (c1,c2)");
1: 				System.out.println("FAIL - create index should have failed");
1: 			}
1: 			catch (SQLException e) {
1: 				if (e.getSQLState().equals("54011"))
1: 					System.out.println("expected exception " + e.getMessage());
1: 				else
1: 					dumpSQLExceptions(e);
1: 			}
1: 			s.executeUpdate("drop table t1");
1: 			conn.setAutoCommit(true);
1: 		} catch (SQLException sqle) {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1: 	}
1: 
1: 	static private void dumpSQLExceptions (SQLException se) {
1: 		System.out.println("FAIL -- unexpected exception: " + se.toString());
1: 		while (se != null) {
1: 			System.out.print("SQLSTATE("+se.getSQLState()+"):");
1: 			se = se.getNextException();
1: 		}
1: 	}
1: 
1: }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
/////////////////////////////////////////////////////////////////////////
1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW-2; i++) {
/////////////////////////////////////////////////////////////////////////
1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
/////////////////////////////////////////////////////////////////////////
1: 			for (i = 0; i < Limits.DB2_MAX_ELEMENTS_IN_ORDER_BY-2; i++)
/////////////////////////////////////////////////////////////////////////
1: 			for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW-1; i++)
1: 				for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW-1; i++) {
/////////////////////////////////////////////////////////////////////////
1: 				for (i = 0; i < Limits.DB2_MAX_COLUMNS_IN_VIEW; i++)
/////////////////////////////////////////////////////////////////////////
0: 			for (i = 0; i < Limits.DB2_MAX_PARAMS_IN_STORED_PROCEDURE-2; i++) {
/////////////////////////////////////////////////////////////////////////
1: 			for (i = 0; i < Limits.DB2_MAX_INDEXES_ON_TABLE-2; i++) {
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.dbManagerLimits
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0:  */
1: 
0: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.*;
1: 
0: import org.apache.derby.tools.ij;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: import org.apache.derbyTesting.functionTests.util.Formatters;
1: 
0: /**
0:   Test various data manager limits like in db2 here.
0:  */
0: public class dbManagerLimits
0: {
1: 
0: 	public static void main (String[] argv) throws Throwable
0: 	{
0: 		ij.getPropertyArg(argv);
0: 		Connection conn = ij.startJBMS();
1: 
0: 		testStringAndHexConstants(conn);
0: 		testMostColumnsInTable(conn);
0: 		testMostColumnsInView(conn);
0: 		testMostElementsInSelectList(conn);
0: 		testMostElementsInOrderBy(conn);
0: 		testMostParametersInStoredProcedures(conn);
1: 
0: 		//not running Group By test because it gets out of memory error
0: 		//testMostElementsInGroupBy(conn);
1: 
0: 		//not running indexes test because it doesn't finish even after running for over 2 hours
0: 		//ALSO, IF WE EVER ENABLE THIS TEST IN FUTURE, WE NEED TO REWRITE THE TEST SO THAT WE TRY TO CREATE OVER
0: 		//32767 *DIFFERENT* INDEXES. AS PART OF DB2 COMPATIBILITY WORK, BUG - 5685 DISALLOWS CREATION OF AN INDEX
0: 		//ON A COLUMN THAT ALREADY HAS A PRIMARY KEY OR UNIQUE CONSTRAINT ON IT.
0: 		//testMostIndexesOnTable(conn);
0: 	}
1: 
0: 	public static void testStringAndHexConstants( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - maximum length of character constant is 32672 and that of hex constant is 16336");
0: 			String stringConstant32671 = Formatters.repeatChar("a",32671);
0: 			String hexConstant16334 = Formatters.repeatChar("a",16334);
0: 			Statement s = conn.createStatement();
0: 			s.executeUpdate("create table t1 (c11 long varchar, c12 long varchar for bit data)");
1: 
0: 			System.out.println("First testing less than maximum constant lengths through insert statement");
0: 			s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "')");
0: 			s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "')");
1:       
0: 			System.out.println("Next testing less than maximum constant lengths through values");
0: 			s.execute("values ('" +  stringConstant32671 + "')");
0: 			s.execute("values (X'" +  hexConstant16334 + "')");
1: 
0: 			System.out.println("Next testing maximum constant lengths through insert statement");
0: 			s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "a')");
0: 			s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "ab')");
1:       
0: 			System.out.println("Next testing maximum constant lengths through values");
0: 			s.execute("values ('" +  stringConstant32671 + "a')");
0: 			s.execute("values (X'" +  hexConstant16334 + "ab')");
1: 
0: 			System.out.println("Next testing maximum constant lengths + 1 through insert statement");
0: 			try {
0: 				s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "ab')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			try {
0: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "abcd')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("Next testing maximum constant lengths + 1 through values");
0: 			try {
0: 				s.executeUpdate("values ('" +  stringConstant32671 + "ab')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			try {
0: 				s.executeUpdate("values (X'" +  hexConstant16334 + "abcd')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("Next testing maximum constant lengths + n through insert statement");
0: 			try {
0: 				s.executeUpdate("insert into t1(c11) values ('" +  stringConstant32671 + "bcdef')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			try {
0: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "abcdef')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this insert statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("Next testing maximum constant lengths + n through values");
0: 			try {
0: 				s.executeUpdate("values ('" +  stringConstant32671 + "bcdef')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			try {
0: 				s.executeUpdate("values (X'" +  hexConstant16334 + "abcdef')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54002"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("Next testing odd number of hex digits in a hex constant through insert statement");
0: 			try {
0: 				s.executeUpdate("insert into t1(c12) values (X'" +  hexConstant16334 + "a')");
0: 				System.out.println("FAIL - should have gotten hex constant invalid string constant too long error for this values statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("42606"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			System.out.println("And finally testing odd number of hex digits in a hex constant through values statement");
0: 			try {
0: 				s.executeUpdate("values (X'" +  hexConstant16334 + "a')");
0: 				System.out.println("FAIL - should have gotten string constant too long error for this values statement");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("42606"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			s.executeUpdate("drop table t1");
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	public static void testMostColumnsInTable( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most columns allowed in a table");
1: 
0: 			StringBuffer sbTableElements = new StringBuffer();
0: 			String tempString = new String();
0: 			int i = 0;
0: 			sbTableElements.append("create table t1 (");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
0: 				sbTableElements.append("c" + i +" int, ");
1: 
0: 			Statement s = conn.createStatement();
0: 			System.out.println("First create a table with one column less than maximum allowed number of columns");
0: 			tempString = (sbTableElements.toString()).concat("c" + i + " int)");
0: 			s.executeUpdate(tempString);
0: 			System.out.println("  Try alter table on it to have table with maximum allowed number of columns");
0: 			s.executeUpdate("alter table t1 add column c" + (i+1) + " int");
0: 			System.out.println("  Try another alter table to have table with one column more than maximum allowed number of columns");
0: 			try {
0: 				s.executeUpdate("alter table t1 add column c" + (i+2) + " int");
0: 				System.out.println("FAIL - The alter table should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			s.executeUpdate("drop table t1");
1: 
0: 			System.out.println("Next create a table with maximum allowed number of columns");
0: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int)");
0: 			s.executeUpdate(tempString);
0: 			System.out.println("  Try alter table to have table with more columns than maximum allowed number of columns");
0: 			try {
0: 				s.executeUpdate("alter table t1 add column c" + (i+2) + " int");
0: 				System.out.println("FAIL - The alter table should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			//just some basic sanity check 
0: 			DatabaseMetaData met = conn.getMetaData();
0: 			getCount(met.getColumns("", "APP", "T1", null));
0: 			s.executeUpdate("insert into t1(c1, c2) values (1,1)");
0: 			s.executeUpdate("drop table t1");
1: 
0: 			System.out.println("Next create a table with one column more than maximum allowed number of columns");
0: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int, c" + (i+2) + " int)");
0: 			try {
0: 				s.executeUpdate(tempString);
0: 				System.out.println("FAIL - The create table should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("Finally, create a table with 2 columns more than maximum allowed number of columns");
0: 			tempString = (sbTableElements.toString()).concat("c" + i +" int, c" + (i+1) + " int, c" + (i+2) + " int, c" + (i+3) + " int)");
0: 			try {
0: 				s.executeUpdate(tempString);
0: 				System.out.println("FAIL - The create table should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	private static void getCount( ResultSet s) throws Throwable
0: 	{
0: 		int counter = 0; // Display data, fetching until end of the result set
0: 		while (s.next())
0: 			counter++;
0: 		System.out.println("Found " + counter + " columns/parameters through meta data");
0: 	}
1: 
0: 	public static void testMostColumnsInView( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most columns allowed in a view");
1: 
0: 			StringBuffer sbValuesClause = new StringBuffer();
0: 			StringBuffer sbViewColumnNames = new StringBuffer();
0: 			String tempString = new String();
0: 			int i = 0;
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW-2; i++) {
0: 				sbValuesClause.append(1 + ", ");
0: 				sbViewColumnNames.append("c" + i + ", ");
0: 			}
1: 
0: 			Statement s = conn.createStatement();
0: 			System.out.println("First create a view with one column less than maximum allowed number of columns");
0: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ") as values (" + sbValuesClause.toString() + "1)";
0: 			s.executeUpdate(tempString);
0: 			s.executeUpdate("drop view v1");
1: 
0: 			System.out.println("Next create a view with maximum allowed number of columns");
0: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1)+ ") as values (" + sbValuesClause.toString() + "1,1)";
0: 			s.executeUpdate(tempString);
0: 			//just some basic sanity check 
0: 			DatabaseMetaData met = conn.getMetaData();
0: 			getCount(met.getColumns("", "APP", "V1", null));
0: 			s.executeUpdate("drop view v1");
1: 
0: 			System.out.println("Next create a view with one column more than that maximum allowed number of columns");
0: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1) + ", c" + (i+2) + ") as values (" + sbValuesClause.toString() + "1,1,1)";
0: 			try {
0: 				s.executeUpdate(tempString);
0: 				System.out.println("FAIL - The create view should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("And finally create a view with 2 columns that maximum allowed number of columns");
0: 			tempString = "create view v1(" + sbViewColumnNames.toString() + "c" + i + ", c" + (i+1) + ", c" + (i+2) + ", c" + (i+3) +") as values (" + sbValuesClause.toString() + "1,1,1,1)";
0: 			try {
0: 				s.executeUpdate(tempString);
0: 				System.out.println("FAIL - The create view should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	public static void testMostElementsInSelectList( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most elements allowed in a select list");
1: 
0: 			StringBuffer sb = new StringBuffer();
0: 			String tempString = new String();
0: 			int i = 0;
0: 			sb.append("create table t1 (");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_TABLE-2; i++)
0: 				sb.append("c" + i +" int, ");
1: 
0: 			Statement s = conn.createStatement();
0: 			tempString = (sb.toString()).concat("c" + i + " int)");
0: 			s.executeUpdate(tempString);
1: 
0: 			System.out.println("First try a select with one column less than maximum allowed number of columns");
0: 			s.execute("select * from t1");
1: 
0: 			System.out.println("Next try a select with maximum allowed number of columns");
0: 			s.execute("select t1.*,1 from t1");
1: 
0: 			System.out.println("Next try a select with one column more than maximum allowed number of columns");
0: 			try {
0: 				s.execute("select t1.*,1,2 from t1");
0: 				System.out.println("FAIL - select should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54004"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("Next try a select with 2 more columns than maximum allowed number of columns");
0: 			try {
0: 				s.execute("select t1.*,1,2,3 from t1");
0: 				System.out.println("FAIL - select should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54004"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			s.executeUpdate("drop table t1");
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	public static void testMostElementsInOrderBy( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most columns allowed in a ORDER BY clause");
1: 
0: 			StringBuffer sbOrderBy = new StringBuffer();
0: 			String tempString = new String();
0: 			int i = 0;
0: 			sbOrderBy.append("select * from t1 order by ");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_ELEMENTS_IN_ORDER_BY-2; i++)
0: 				sbOrderBy.append("c1, ");
1: 
0: 			Statement s = conn.createStatement();
0: 			s.executeUpdate("create table t1 (c1 int not null, c2 int)");
1:       
0: 			System.out.println("First try order by with one column less than maximum allowed number of columns");
0: 			tempString = (sbOrderBy.toString()).concat("c2");
0: 			s.execute(tempString);
1: 
0: 			System.out.println("Next try an order by with maximum allowed number of columns");
0: 			tempString = (sbOrderBy.toString()).concat("c1, c2");
0: 			s.execute(tempString);
1: 
0: 			System.out.println("Next try an order by with one column more than maximum allowed number of columns");
0: 			tempString = (sbOrderBy.toString()).concat("c1, c2, c1");
0: 			try {
0: 				s.execute(tempString);
0: 				System.out.println("FAIL - order by should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54004"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("And finally try an order by with 2 more columns than maximum allowed number of columns");
0: 			tempString = (sbOrderBy.toString()).concat("c1, c2, c1");
0: 			try {
0: 				s.execute(tempString);
0: 				System.out.println("FAIL - order by should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54004"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			s.executeUpdate("drop table t1");
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	public static void testMostElementsInGroupBy( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most columns allowed in a GROUP BY clause");
0: 			Statement s = conn.createStatement();
0: 			StringBuffer sbGroupBy = new StringBuffer("select 1 from v1, v2, v3, v4, v5, v6, v7 group by ");
0: 			StringBuffer sbValuesClause = new StringBuffer();
0: 			StringBuffer sbViewColumnNames = new StringBuffer();
0: 			String tempString = new String();
1: 
0: 			//first create 7 views with 5000 columns each
0: 			int i = 0;
0: 			for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW-1; i++)
0: 				sbValuesClause.append(1 + ", ");
1: 
0: 			for (int j = 1; j < 8; j++) {
0: 				for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW-1; i++) {
0: 					sbViewColumnNames.append("c" + j + "" + i + ", ");
0: 				}
0: 				tempString = "create view v" + j + "(" + sbViewColumnNames.toString() + "c" + j + "" + i + ") as values (" + sbValuesClause.toString() + "1)";
0: 				s.executeUpdate(tempString);
0: 				sbViewColumnNames = new StringBuffer();
0: 			}
1:       
0: 			for (int j = 1; j < 7; j++) {
0: 				for (i = 0; i < DB2Limit.DB2_MAX_COLUMNS_IN_VIEW; i++)
0: 					sbGroupBy.append("c" + j + "" + i + ", ");
0: 			}
0: 			for (i = 0; i < 2675; i++)
0: 				sbGroupBy.append("c7" + i + ", ");
1: 
0: 			System.out.println("First try group by with one column less than maximum allowed number of columns");
0: 			tempString = (sbGroupBy.toString()).concat("c72675");
0: 			s.execute(tempString);
1: 
0: 			System.out.println("Next try an group by with maximum allowed number of columns");
0: 			tempString = (sbGroupBy.toString()).concat("c72675, c72675");
0: 			s.execute(tempString);
1: 
0: 			System.out.println("And finally try an group by with more columns that maximum allowed number of columns");
0: 			tempString = (sbGroupBy.toString()).concat("c72675, c72676, c72677");
0: 			try {
0: 				s.execute(tempString);
0: 				System.out.println("FAIL - group by should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54004"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			s.executeUpdate("drop view v1");
0: 			s.executeUpdate("drop view v2");
0: 			s.executeUpdate("drop view v3");
0: 			s.executeUpdate("drop view v4");
0: 			s.executeUpdate("drop view v5");
0: 			s.executeUpdate("drop view v6");
0: 			s.executeUpdate("drop view v7");
1: 
0: 			s.execute("select 1 from v1 group by c1,c2");
0: 			s.executeUpdate("drop table t1");
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	public static void testMostParametersInStoredProcedures( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most parameters allowed for a stored procedure");
0: 			Statement s = conn.createStatement();
0: 			StringBuffer sbCreateProcParams = new StringBuffer();
0: 			StringBuffer sbExecuteProcParams = new StringBuffer();
0: 			String tempString = new String();
0: 			int i = 0;
1: 
0: 			for (i = 0; i < DB2Limit.DB2_MAX_PARAMS_IN_STORED_PROCEDURE-2; i++) {
0: 				sbCreateProcParams.append("i" + i + " int, ");
0: 				sbExecuteProcParams.append("1, ");
0: 			}
1: 
0: 			System.out.println("First create a procedure with one parameter less than maximum allowed number of parameters");
0: 			tempString = "create procedure P1(" + sbCreateProcParams.toString() + "i" + i +
0:         " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.lessThanMaxParams\' NO SQL";
0: 			s.executeUpdate(tempString);
1: 
0: 			System.out.println("Next create a procedure with maximum allowed number of parameters");
0: 			tempString = "create procedure P2(" + sbCreateProcParams.toString() + "i" + i +
0:         " int, i" + (i+1) + " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.maxAllowedParams\' NO SQL";
0: 			s.executeUpdate(tempString);
0: 			//just some basic sanity check 
0: 			DatabaseMetaData met = conn.getMetaData();
0: 			getCount(met.getProcedureColumns("", "APP", "P2", null));
1: 
0: 			System.out.println("And finally create a procedure with more parameters that maximum allowed number of parameters");
0: 			tempString = "create procedure P3(" + sbCreateProcParams.toString() + "i" + i +
0:         " int, i" + (i+1) + " int, i" + (i+2) + " int) parameter style java language java external name \'org.apache.derbyTesting.functionTests.util.ProcedureTest.moreThanMaxAllowedParams\' NO SQL";
0: 			try {
0: 				s.executeUpdate(tempString);
0: 				System.out.println("FAIL - create procedure should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54023"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 		//not running indexes test because it doesn't finish even after running for over 2 hours
0: 		//ALSO, IF WE EVER ENABLE THIS TEST IN FUTURE, WE NEED TO REWRITE THE TEST SO THAT WE TRY TO CREATE OVER
0: 		//32767 *DIFFERENT* INDEXES. AS PART OF DB2 COMPATIBILITY WORK, BUG - 5685 DISALLOWS CREATION OF AN INDEX
0: 		//ON A COLUMN THAT ALREADY HAS A PRIMARY KEY OR UNIQUE CONSTRAINT ON IT.
0: 	public static void testMostIndexesOnTable( Connection conn) throws Throwable
0: 	{
0:     try {
0: 			System.out.println("Test - most indexes allowed on a table");
0: 			conn.setAutoCommit(false);
0: 			Statement s = conn.createStatement();
0: 			int i = 0;
1: 
0: 			s.executeUpdate("create table t1 (c1 int not null, c2 int, primary key(c1))");
0: 			System.out.println("First create one index less than maximum allowed number of indexes");
0: 			for (i = 0; i < DB2Limit.DB2_MAX_INDEXES_ON_TABLE-2; i++) {
0: 				s.executeUpdate("create index i" + i + " on t1(c1,c2)");
0: 			System.out.println("   create index" + i);
0: 			}
1: 
0: 			System.out.println("Next create maximum allowed number of indexes");
0: 			s.executeUpdate("create index i" + (i+1) + " on t1(c1,c2)");
1: 
0: 			System.out.println("And finally create one index more than maximum allowed number of indexes");
0: 			try {
0: 				s.executeUpdate("create index i" + (i+2) + " on t1(c1,c2)");
0: 				System.out.println("FAIL - create index should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
1: 
0: 			System.out.println("And finally try maximum allowed number of indexes violation using add constraint");
0: 			try {
0: 				s.executeUpdate("alter table t1 add constraint i" + (i+2) + " unique (c1,c2)");
0: 				System.out.println("FAIL - create index should have failed");
0: 			}
0: 			catch (SQLException e) {
0: 				if (e.getSQLState().equals("54011"))
0: 					System.out.println("expected exception " + e.getMessage());
0: 				else
0: 					dumpSQLExceptions(e);
0: 			}
0: 			s.executeUpdate("drop table t1");
0: 			conn.setAutoCommit(true);
0: 		} catch (SQLException sqle) {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0: 	}
1: 
0: 	static private void dumpSQLExceptions (SQLException se) {
0: 		System.out.println("FAIL -- unexpected exception: " + se.toString());
0: 		while (se != null) {
0: 			System.out.print("SQLSTATE("+se.getSQLState()+"):");
0: 			se = se.getNextException();
0: 		}
0: 	}
1: 
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.dbManagerLimits
0: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
============================================================================