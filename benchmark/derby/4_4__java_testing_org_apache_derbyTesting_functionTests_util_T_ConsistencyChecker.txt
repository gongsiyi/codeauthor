1:f68f62f: /*
1:f68f62f: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.util.T_ConsistencyChecker
1:f68f62f: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
1:f68f62f:  */
1:f68f62f: 
1:f68f62f: package org.apache.derbyTesting.functionTests.util;
1:f68f62f: 
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:f68f62f: 
1:f68f62f: import org.apache.derby.iapi.error.StandardException;
1:f170100: import org.apache.derby.iapi.reference.SQLState;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:f170100: import org.apache.derby.iapi.services.context.ContextService;
1:f170100: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:f170100: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:f170100: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:f68f62f: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:f68f62f: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:f68f62f: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:f170100: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:f170100: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:f170100: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:f68f62f: import org.apache.derby.iapi.sql.execute.ExecRow;
1:f68f62f: import org.apache.derby.iapi.store.access.ConglomerateController;
1:f170100: import org.apache.derby.iapi.store.access.ScanController;
1:f170100: import org.apache.derby.iapi.store.access.TransactionController;
1:f170100: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:f170100: import org.apache.derby.iapi.types.RowLocation;
1:f68f62f: 
1:f68f62f: /**
1:f68f62f:  * This class has methods for corrupting a database. 
1:f68f62f:  * IT MUST NOT BE DISTRIBUTED WITH THE PRODUCT.
6:f68f62f:  *
1:f68f62f:  * NOTE: The entry points to this class are all static,
1:f68f62f:  * for easy access via the query language.  Each of the
1:f68f62f:  * static methods instantiates an object from the class
1:f68f62f:  * and calls methods off of that object.  This allows
1:f68f62f:  * the sharing of code across the various static methods.
1:f68f62f:  */
1:f68f62f: public class T_ConsistencyChecker
1:f68f62f: {
1:f68f62f: 	private	DataDictionary				dd;
1:f68f62f: 	private	TransactionController		tc;
1:f68f62f: 	private	LanguageConnectionContext	lcc;
1:f68f62f: 	private String						indexName;
1:f68f62f: 	private String						schemaName;
1:f68f62f: 	private String						tableName;
1:f68f62f: 	private ConglomerateDescriptor		id;
1:f68f62f: 	private SchemaDescriptor			sd;
1:f68f62f: 	private	TableDescriptor				td;
1:f68f62f: 
1:f68f62f: 	T_ConsistencyChecker(String schemaName, String tableName, String indexName)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		this.schemaName = schemaName;
1:f68f62f: 		this.tableName = tableName;
1:f68f62f: 		this.indexName = indexName;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 	 * Delete the first row from the heap, without
1:f68f62f: 	 * deleting it from the indexes on the table.
1:f68f62f: 	 *
1:f68f62f: 	 * @param schemaName	The schema name.
1:f68f62f: 	 * @param tableName		The table name.
1:f68f62f: 	 * 
1:f68f62f: 	 * @exception StandardException		Thrown on error
1:f68f62f: 	 */
1:f68f62f: 	public static void deleteFirstHeapRow(String schemaName, String tableName)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
1:f68f62f: 		t_cc.getContexts();
1:f68f62f: 		t_cc.getDescriptors();
1:f68f62f: 
1:f68f62f: 		/* Open a scan on the heap */
1:f68f62f: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1:f68f62f: 
1:f68f62f: 		// Move to the 1st row in the heap
1:f68f62f: 		heapScan.next();
1:f68f62f: 
1:f68f62f: 		// Delete the 1st row in the heap
1:f68f62f: 		heapScan.delete();
1:f68f62f: 
1:f68f62f: 		heapScan.close();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 	 * Get the first row from the heap and insert it into
1:f68f62f: 	 * the heap again, without
1:f68f62f: 	 * inserting it from the indexes on the table.
1:f68f62f: 	 *
1:f68f62f: 	 * @param schemaName	The schema name.
1:f68f62f: 	 * @param tableName		The table name.
1:f68f62f: 	 * 
1:f68f62f: 	 * @exception StandardException		Thrown on error
1:f68f62f: 	 */
1:f68f62f: 	public static void reinsertFirstHeapRow(String schemaName, String tableName)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
1:f68f62f: 		t_cc.getContexts();
1:f68f62f: 		t_cc.getDescriptors();
1:f68f62f: 
1:f68f62f: 		/* Open a scan on the heap */
1:f68f62f: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1:f68f62f: 
1:f68f62f: 		// Move to the 1st row in the heap
1:f68f62f: 		heapScan.next();
1:f68f62f: 
1:f68f62f: 		// Fetch the 1st row
1:f68f62f: 		ExecRow firstRow = t_cc.getHeapRowOfNulls();
1:f68f62f: 		heapScan.fetch(firstRow.getRowArray());
1:f68f62f: 		heapScan.close();
1:f68f62f: 
1:f68f62f: 		// Insert another copy of the 1st row into the heap
1:f68f62f: 		ConglomerateController heapCC = t_cc.openHeapCC();
1:f68f62f: 		heapCC.insert(firstRow.getRowArray());
1:f68f62f: 		heapCC.close();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 	 * Set all of the columns in the first row from 
1:f68f62f: 	 * the heap to null, without
1:f68f62f: 	 * updating the indexes on the table.
1:f68f62f: 	 *
1:f68f62f: 	 * @param schemaName	The schema name.
1:f68f62f: 	 * @param tableName		The table name.
1:f68f62f: 	 * 
1:f68f62f: 	 * @exception StandardException		Thrown on error
1:f68f62f: 	 */
1:f68f62f: 	public static void nullFirstHeapRow(String schemaName, String tableName)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
1:f68f62f: 		t_cc.getContexts();
1:f68f62f: 		t_cc.getDescriptors();
1:f68f62f: 
1:f68f62f: 		/* Open a scan on the heap */
1:f68f62f: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1:f68f62f: 
1:f68f62f: 		// Move to the 1st row in the heap
1:f68f62f: 		heapScan.next();
1:f68f62f: 
1:f68f62f: 		// Get the RowLocation
1:f68f62f: 		RowLocation baseRL = heapScan.newRowLocationTemplate();
1:f68f62f: 		heapScan.fetchLocation(baseRL);
1:f68f62f: 
1:f68f62f: 		// Replace the current row with nulls
1:f68f62f: 		heapScan.replace(
1:f68f62f: 			t_cc.getHeapRowOfNulls().getRowArray(),
1:f68f62f: 			(FormatableBitSet) null);
1:f68f62f: 
1:f68f62f: 		heapScan.close();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 	 * Get the first row from the heap and insert it into
1:f68f62f: 	 * the specified index, with a bad row location, without
1:f68f62f: 	 * inserting it into the heap or the other indexes on the table.
1:f68f62f: 	 *
1:f68f62f: 	 * @param schemaName	The schema name.
1:f68f62f: 	 * @param tableName		The table name.
1:f68f62f: 	 * @param indexName		The specified index.
1:f68f62f: 	 * 
1:f68f62f: 	 * @exception StandardException		Thrown on error
1:f68f62f: 	 */
1:f68f62f: 	public static void insertBadRowLocation(String schemaName, String tableName, String indexName)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, indexName);
1:f68f62f: 		t_cc.getContexts();
1:f68f62f: 		t_cc.getDescriptors();
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		/* Open a scan on the heap */
1:f68f62f: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1:f68f62f: 
1:f68f62f: 		// Get the RowLocation
1:f68f62f: 		RowLocation baseRL = heapScan.newRowLocationTemplate();
1:f68f62f: 		RowLocation badRL = heapScan.newRowLocationTemplate();
1:f68f62f: 		heapScan.close();
1:f68f62f: 
1:f68f62f: 		/* Open a scan on the index */
1:f68f62f: 		ExecRow		indexRow = t_cc.getIndexTemplateRow(baseRL);
1:f68f62f: 		ScanController indexScan = t_cc.openUnqualifiedIndexScan();
1:f68f62f: 
1:f68f62f: 		// Move to the 1st row in the index
1:f68f62f: 		indexScan.next();
1:f68f62f: 
1:f68f62f: 		// Fetch the 1st row
1:f68f62f: 		indexScan.fetch(indexRow.getRowArray());
1:f68f62f: 		indexScan.close();
1:f68f62f: 
1:f68f62f: 		// Insert another copy of the 1st row into the index with a bad row location
1:f68f62f: 		int keyLength = 
1:f68f62f: 				t_cc.getIndexDescriptor().getIndexDescriptor().baseColumnPositions().length;
1:f68f62f: 		indexRow.setColumn(keyLength + 1, badRL);
1:f68f62f: 
1:f68f62f: 		ConglomerateController indexCC = t_cc.openIndexCC();
1:f68f62f: 		indexCC.insert(indexRow.getRowArray());
1:f68f62f: 		indexCC.close();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 	 * Swap the values in the specified columns of the
1:f68f62f: 	 * first row from the heap, without
1:f68f62f: 	 * updating the indexes on the table.
1:f68f62f: 	 *
1:f68f62f: 	 * @param schemaName	The schema name.
1:f68f62f: 	 * @param tableName		The table name.
1:f68f62f: 	 * @param firstColumn	First column #.
1:f68f62f: 	 * @param secondColumn	Second column #.
1:f68f62f: 	 * 
1:f68f62f: 	 * @exception StandardException		Thrown on error
1:f68f62f: 	 */
1:f68f62f: 	public static void swapColumnsInFirstHeapRow(String schemaName, String tableName,
1:f68f62f: 												 int firstColumn, int secondColumn)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Get the various contexts */
1:f68f62f: 	private void getContexts()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		lcc = (LanguageConnectionContext)
1:a0dbbd7: 			getContext(LanguageConnectionContext.CONTEXT_ID);
1:f68f62f: 		tc = lcc.getTransactionExecute();
1:f68f62f: 
1:f68f62f: 		dd = lcc.getDataDictionary();
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Get the various descriptors */
1:f68f62f: 	private void getDescriptors()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		sd = dd.getSchemaDescriptor(schemaName, tc, true);
1:0978789: 		td = dd.getTableDescriptor(tableName, sd, tc);
1:f68f62f: 
1:f68f62f: 		if (td == null)
1:f68f62f: 		{
1:f68f62f: 			throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, schemaName + "." + tableName);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		if (indexName != null)
1:f68f62f: 		{
1:f68f62f: 			id = dd.getConglomerateDescriptor(indexName, sd, true);
1:f68f62f: 			if (id == null)
1:f68f62f: 			{
1:f68f62f: 				throw StandardException.newException(SQLState.LANG_INDEX_NOT_FOUND, indexName);
1:f68f62f: 			}
1:f68f62f: 		}
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Get a heap row full of nulls */
1:f68f62f: 	private ExecRow getHeapRowOfNulls()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		ConglomerateController	baseCC;
1:f68f62f: 		ExecRow					baseRow;
1:f68f62f: 
1:f68f62f: 		/* Open the heap for reading */
1:f68f62f: 		baseCC = tc.openConglomerate(
1:f68f62f: 		            td.getHeapConglomerateId(), false, 0, 
1:f68f62f: 			        TransactionController.MODE_TABLE,
1:f68f62f: 				    TransactionController.ISOLATION_SERIALIZABLE);
1:f68f62f: 
1:f68f62f: 		/* Get a row template for the base table */
1:6c000e8: 		baseRow = lcc.getLanguageConnectionFactory().getExecutionFactory().getValueRow(td.getNumberOfColumns());
1:f68f62f: 
1:f68f62f: 		/* Fill the row with nulls of the correct type */
1:f68f62f: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1:f68f62f: 		int					 cdlSize = cdl.size();
1:f68f62f: 
1:f68f62f: 		for (int index = 0; index < cdlSize; index++)
1:f68f62f: 		{
1:f68f62f: 			ColumnDescriptor cd = (ColumnDescriptor) cdl.elementAt(index);
1:f68f62f: 			DataTypeDescriptor dts = cd.getType();
1:f68f62f: 			baseRow.setColumn(cd.getPosition(),
1:f68f62f: 									dts.getNull());
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		baseCC.close();
1:f68f62f: 		return baseRow;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Open an unqualified scan on the heap for update */
1:f68f62f: 	private ScanController openUnqualifiedHeapScan()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		ScanController heapScan;
1:f68f62f: 
1:f68f62f: 		heapScan = tc.openScan(td.getHeapConglomerateId(),
1:f68f62f: 								false,	// hold
1:f68f62f: 								TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1:f68f62f: 								TransactionController.MODE_TABLE,
1:f68f62f: 						        TransactionController.ISOLATION_SERIALIZABLE,
1:f68f62f: 								(FormatableBitSet) null,
1:f68f62f: 								null,	// startKeyValue
1:f68f62f: 								0,		// not used with null start posn.
1:f68f62f: 								null,	// qualifier
1:f68f62f: 								null,	// stopKeyValue
1:f68f62f: 								0);		// not used with null stop posn.
1:f68f62f: 
1:f68f62f: 		return heapScan;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Open the heap conglomerate for update */
1:f68f62f: 	private ConglomerateController openHeapCC()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		ConglomerateController heapCC;
1:f68f62f: 
1:f68f62f: 		heapCC = tc.openConglomerate(
1:f68f62f: 			            td.getHeapConglomerateId(),
1:f68f62f:                         false,
1:f68f62f: 						TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1:f68f62f: 				        TransactionController.MODE_TABLE,
1:f68f62f: 					    TransactionController.ISOLATION_SERIALIZABLE);
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		return heapCC;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Get a template row for the specified index */
1:f68f62f: 	private ExecRow getIndexTemplateRow(RowLocation baseRL)
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		int[]					baseColumnPositions;
1:f68f62f: 		int						baseColumns = 0;
1:f68f62f: 		ExecRow					indexScanTemplate;
1:f68f62f: 
1:f68f62f: 		baseColumnPositions =
1:f68f62f: 				id.getIndexDescriptor().baseColumnPositions();
1:f68f62f: 		baseColumns = baseColumnPositions.length;
1:f68f62f: 
1:f68f62f: 		FormatableBitSet indexColsBitSet = new FormatableBitSet();
1:f68f62f: 		for (int i = 0; i < baseColumns; i++)
1:f68f62f: 		{
1:f68f62f: 			indexColsBitSet.grow(baseColumnPositions[i]);
1:f68f62f: 			indexColsBitSet.set(baseColumnPositions[i] - 1);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		/* Get a row template */
1:6c000e8: 		indexScanTemplate = lcc.getLanguageConnectionFactory().getExecutionFactory().getValueRow(baseColumns + 1);
1:f68f62f: 
1:f68f62f: 		/* Fill the row with nulls of the correct type */
1:f68f62f: 		for (int column = 0; column < baseColumns; column++)
1:f68f62f: 		{
1:f68f62f: 			/* Column positions in the data dictionary are one-based */
1:f68f62f: 			ColumnDescriptor cd = td.getColumnDescriptor(baseColumnPositions[column]);
1:f68f62f: 			DataTypeDescriptor dts = cd.getType();
1:f68f62f: 			indexScanTemplate.setColumn(column + 1,
1:f68f62f: 									dts.getNull());
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		/* Set the row location in the last column of the index row */
1:f68f62f: 		indexScanTemplate.setColumn(baseColumns + 1, baseRL);
1:f68f62f: 
1:f68f62f: 		return indexScanTemplate;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Open an unqualified scan on the index for update */
1:f68f62f: 	private ScanController openUnqualifiedIndexScan()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		ScanController indexScan;
1:f68f62f: 
1:f68f62f: 		indexScan = tc.openScan(id.getConglomerateNumber(),
1:f68f62f: 								false,	// hold
1:f68f62f: 								TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1:f68f62f: 								TransactionController.MODE_TABLE,
1:f68f62f: 						        TransactionController.ISOLATION_SERIALIZABLE,
1:f68f62f: 								(FormatableBitSet) null,
1:f68f62f: 								null,	// startKeyValue
1:f68f62f: 								0,		// not used with null start posn.
1:f68f62f: 								null,	// qualifier
1:f68f62f: 								null,	// stopKeyValue
1:f68f62f: 								0);		// not used with null stop posn.
1:f68f62f: 
1:f68f62f: 		return indexScan;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Open the index conglomerate for update */
1:f68f62f: 	private ConglomerateController openIndexCC()
1:f68f62f: 		throws StandardException
1:f68f62f: 	{
1:f68f62f: 		ConglomerateController indexCC;
1:f68f62f: 
1:f68f62f: 		indexCC = tc.openConglomerate(
1:f68f62f: 			            id.getConglomerateNumber(),
1:f68f62f:                         false,
1:f68f62f: 						TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1:f68f62f: 				        TransactionController.MODE_TABLE,
1:f68f62f: 					    TransactionController.ISOLATION_SERIALIZABLE);
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		return indexCC;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/* Return the ConglomerateDescriptor for the index */
1:f68f62f: 	private ConglomerateDescriptor getIndexDescriptor()
1:f68f62f: 	{
1:f68f62f: 		return id;
1:f68f62f: 	}
1:2bb479f:     /**
1:2bb479f:      * Run all of the consistency checkers which do not take parameters.
1:2bb479f:      * Actually, just run the ones that "make sense" to run.  Today,
1:2bb479f:      * that is:
1:2bb479f:      *      countOpens()
1:2bb479f:      *
1:2bb479f:      * @return String       If an inconsistency is found, and if DEBUG is on, 
1:2bb479f:      *                      then a string will be returned with more info.  
1:2bb479f:      *                      If DEBUG is off, then a simple string will be 
1:2bb479f:      *                      returned stating whether or not there are open scans.
1:2bb479f:      *
1:2bb479f:      * @exception StandardException     Thrown on error
1:2bb479f:      * @exception java.sql.SQLException     Thrown on error
1:2bb479f:      */
1:2bb479f:     public static String runConsistencyChecker() throws StandardException, java.sql.SQLException
1:2bb479f:     {
1:2bb479f:         return countOpens() + countDependencies();
1:2bb479f:     }
1:f68f62f: 
1:2bb479f:     /**
1:2bb479f:      * Check to make sure that there are no open conglomerates, scans or sorts.
1:2bb479f:      *
1:2bb479f:      * @return String       If an inconsistency is found, and if DEBUG is on, 
1:2bb479f:      *                      then a string will be returned with more info.  
1:2bb479f:      *                      If DEBUG is off, then a simple string will be 
1:2bb479f:      *                      returned stating whether or not there are open scans.
1:2bb479f:      *
1:2bb479f:      * @exception StandardException     Thrown on error
1:2bb479f:      */
1:2bb479f:     public static String countOpens() throws StandardException
1:2bb479f:     {
1:2bb479f:         int                     numOpens = 0;
1:2bb479f:         LanguageConnectionContext lcc;
1:2bb479f:         String                  output = "No open scans, etc.\n";
1:2bb479f:         TransactionController   tc;
1:f68f62f: 
1:2bb479f:         lcc = (LanguageConnectionContext)
1:a0dbbd7:            getContext(LanguageConnectionContext.CONTEXT_ID);
1:2bb479f:         tc = lcc.getTransactionExecute();
1:f68f62f: 
1:2bb479f:         numOpens = tc.countOpens(TransactionController.OPEN_TOTAL);
1:f68f62f: 
1:2bb479f:         if (numOpens > 0)
1:2bb479f:         {
1:6de7104:             output = numOpens + " conglomerates/scans/sorts found open\n";
1:f68f62f: 
1:2bb479f:         }
1:f68f62f: 
1:2bb479f:         return output;
1:2bb479f:     }
1:f68f62f: 
1:2bb479f:     /**
1:2bb479f:      * Check to make sure that there are no active dependencies (stored or
1:2bb479f:      * in memory).
1:2bb479f:      *
1:2bb479f:      * @return String       If an inconsistency is found, and if DEBUG is on, 
1:2bb479f:      *                      then a string will be returned with more info.  
1:2bb479f:      *                      If DEBUG is off, then a simple string will be 
1:2bb479f:      *                      returned stating whether or not there are open scans.
1:2bb479f:      *
1:2bb479f:      * @exception StandardException     Thrown on error
1:2bb479f:      * @exception java.sql.SQLException     Thrown on error
1:2bb479f:      */
1:2bb479f:     public static String countDependencies() throws StandardException, java.sql.SQLException
1:2bb479f:     {
1:2bb479f:         int                     numDependencies = 0;
1:2bb479f:         DataDictionary          dd;
1:2bb479f:         DependencyManager       dm;
1:2bb479f:         StringBuffer            debugBuf = new StringBuffer();
1:f68f62f: 
1:2bb479f:         LanguageConnectionContext lcc = (LanguageConnectionContext)
1:a0dbbd7:              getContext(LanguageConnectionContext.CONTEXT_ID);
1:f68f62f: 
1:2bb479f:         dd = lcc.getDataDictionary();
1:2bb479f:         dm = dd.getDependencyManager();
1:f68f62f: 
1:2bb479f:         numDependencies = dm.countDependencies();
1:f68f62f: 
1:2bb479f:         if (numDependencies > 0)
1:2bb479f:         {
1:2bb479f:             debugBuf.append(numDependencies + " dependencies found");
1:2bb479f:         }
1:2bb479f:         else
1:2bb479f:         {
1:2bb479f:             debugBuf.append("No outstanding dependencies.\n");
1:2bb479f:         }
1:f68f62f: 
1:2bb479f:         return debugBuf.toString();
1:2bb479f:     }
1:a0dbbd7:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContext( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContext( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:f68f62f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1: 			getContext(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:            getContext(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:              getContext(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContext( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:0978789
/////////////////////////////////////////////////////////////////////////
1: 		td = dd.getTableDescriptor(tableName, sd, tc);
commit:f170100
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6c000e8
/////////////////////////////////////////////////////////////////////////
1: 		baseRow = lcc.getLanguageConnectionFactory().getExecutionFactory().getValueRow(td.getNumberOfColumns());
/////////////////////////////////////////////////////////////////////////
1: 		indexScanTemplate = lcc.getLanguageConnectionFactory().getExecutionFactory().getValueRow(baseColumns + 1);
commit:2bb479f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Run all of the consistency checkers which do not take parameters.
1:      * Actually, just run the ones that "make sense" to run.  Today,
1:      * that is:
1:      *      countOpens()
1:      *
1:      * @return String       If an inconsistency is found, and if DEBUG is on, 
1:      *                      then a string will be returned with more info.  
1:      *                      If DEBUG is off, then a simple string will be 
1:      *                      returned stating whether or not there are open scans.
1:      *
1:      * @exception StandardException     Thrown on error
1:      * @exception java.sql.SQLException     Thrown on error
1:      */
1:     public static String runConsistencyChecker() throws StandardException, java.sql.SQLException
1:     {
1:         return countOpens() + countDependencies();
1:     }
1:     /**
1:      * Check to make sure that there are no open conglomerates, scans or sorts.
1:      *
1:      * @return String       If an inconsistency is found, and if DEBUG is on, 
1:      *                      then a string will be returned with more info.  
1:      *                      If DEBUG is off, then a simple string will be 
1:      *                      returned stating whether or not there are open scans.
1:      *
1:      * @exception StandardException     Thrown on error
1:      */
1:     public static String countOpens() throws StandardException
1:     {
1:         int                     numOpens = 0;
1:         LanguageConnectionContext lcc;
1:         String                  output = "No open scans, etc.\n";
1:         TransactionController   tc;
1:         lcc = (LanguageConnectionContext)
0:             ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1:         tc = lcc.getTransactionExecute();
1:         numOpens = tc.countOpens(TransactionController.OPEN_TOTAL);
1:         if (numOpens > 0)
1:         {
1:         }
1:         return output;
1:     }
1:     /**
1:      * Check to make sure that there are no active dependencies (stored or
1:      * in memory).
1:      *
1:      * @return String       If an inconsistency is found, and if DEBUG is on, 
1:      *                      then a string will be returned with more info.  
1:      *                      If DEBUG is off, then a simple string will be 
1:      *                      returned stating whether or not there are open scans.
1:      *
1:      * @exception StandardException     Thrown on error
1:      * @exception java.sql.SQLException     Thrown on error
1:      */
1:     public static String countDependencies() throws StandardException, java.sql.SQLException
1:     {
1:         int                     numDependencies = 0;
1:         DataDictionary          dd;
1:         DependencyManager       dm;
1:         StringBuffer            debugBuf = new StringBuffer();
1:         LanguageConnectionContext lcc = (LanguageConnectionContext)
0:              ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1:         dd = lcc.getDataDictionary();
1:         dm = dd.getDependencyManager();
1:         numDependencies = dm.countDependencies();
1:         if (numDependencies > 0)
1:         {
1:             debugBuf.append(numDependencies + " dependencies found");
1:         }
1:         else
1:         {
1:             debugBuf.append("No outstanding dependencies.\n");
1:         }
1:         return debugBuf.toString();
1:     }
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.util.T_ConsistencyChecker
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.util;
1: 
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1:  * This class has methods for corrupting a database. 
1:  * IT MUST NOT BE DISTRIBUTED WITH THE PRODUCT.
1:  *
1:  * NOTE: The entry points to this class are all static,
1:  * for easy access via the query language.  Each of the
1:  * static methods instantiates an object from the class
1:  * and calls methods off of that object.  This allows
1:  * the sharing of code across the various static methods.
1:  */
1: public class T_ConsistencyChecker
1: {
1: 	private	DataDictionary				dd;
1: 	private	TransactionController		tc;
1: 	private	LanguageConnectionContext	lcc;
0: 	private	DataValueFactory			dvf;
0: 	private	ExecutionContext			ec;
1: 	private String						indexName;
1: 	private String						schemaName;
1: 	private String						tableName;
1: 	private ConglomerateDescriptor		id;
1: 	private SchemaDescriptor			sd;
1: 	private	TableDescriptor				td;
1: 
1: 	T_ConsistencyChecker(String schemaName, String tableName, String indexName)
1: 		throws StandardException
1: 	{
1: 		this.schemaName = schemaName;
1: 		this.tableName = tableName;
1: 		this.indexName = indexName;
1: 	}
1: 
1: 	/**
1: 	 * Delete the first row from the heap, without
1: 	 * deleting it from the indexes on the table.
1: 	 *
1: 	 * @param schemaName	The schema name.
1: 	 * @param tableName		The table name.
1: 	 * 
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public static void deleteFirstHeapRow(String schemaName, String tableName)
1: 		throws StandardException
1: 	{
1: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
1: 		t_cc.getContexts();
1: 		t_cc.getDescriptors();
1: 
1: 		/* Open a scan on the heap */
1: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1: 
1: 		// Move to the 1st row in the heap
1: 		heapScan.next();
1: 
1: 		// Delete the 1st row in the heap
1: 		heapScan.delete();
1: 
1: 		heapScan.close();
1: 	}
1: 
1: 	/**
1: 	 * Get the first row from the heap and insert it into
1: 	 * the heap again, without
1: 	 * inserting it from the indexes on the table.
1: 	 *
1: 	 * @param schemaName	The schema name.
1: 	 * @param tableName		The table name.
1: 	 * 
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public static void reinsertFirstHeapRow(String schemaName, String tableName)
1: 		throws StandardException
1: 	{
1: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
1: 		t_cc.getContexts();
1: 		t_cc.getDescriptors();
1: 
1: 		/* Open a scan on the heap */
1: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1: 
1: 		// Move to the 1st row in the heap
1: 		heapScan.next();
1: 
1: 		// Fetch the 1st row
1: 		ExecRow firstRow = t_cc.getHeapRowOfNulls();
1: 		heapScan.fetch(firstRow.getRowArray());
1: 		heapScan.close();
1: 
1: 		// Insert another copy of the 1st row into the heap
1: 		ConglomerateController heapCC = t_cc.openHeapCC();
1: 		heapCC.insert(firstRow.getRowArray());
1: 		heapCC.close();
1: 	}
1: 
1: 	/**
1: 	 * Set all of the columns in the first row from 
1: 	 * the heap to null, without
1: 	 * updating the indexes on the table.
1: 	 *
1: 	 * @param schemaName	The schema name.
1: 	 * @param tableName		The table name.
1: 	 * 
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public static void nullFirstHeapRow(String schemaName, String tableName)
1: 		throws StandardException
1: 	{
1: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
1: 		t_cc.getContexts();
1: 		t_cc.getDescriptors();
1: 
1: 		/* Open a scan on the heap */
1: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1: 
1: 		// Move to the 1st row in the heap
1: 		heapScan.next();
1: 
1: 		// Get the RowLocation
1: 		RowLocation baseRL = heapScan.newRowLocationTemplate();
1: 		heapScan.fetchLocation(baseRL);
1: 
1: 		// Replace the current row with nulls
1: 		heapScan.replace(
1: 			t_cc.getHeapRowOfNulls().getRowArray(),
1: 			(FormatableBitSet) null);
1: 
1: 		heapScan.close();
1: 	}
1: 
1: 	/**
1: 	 * Get the first row from the heap and insert it into
1: 	 * the specified index, with a bad row location, without
1: 	 * inserting it into the heap or the other indexes on the table.
1: 	 *
1: 	 * @param schemaName	The schema name.
1: 	 * @param tableName		The table name.
1: 	 * @param indexName		The specified index.
1: 	 * 
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public static void insertBadRowLocation(String schemaName, String tableName, String indexName)
1: 		throws StandardException
1: 	{
1: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, indexName);
1: 		t_cc.getContexts();
1: 		t_cc.getDescriptors();
1: 
1: 
1: 		/* Open a scan on the heap */
1: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
1: 
1: 		// Get the RowLocation
1: 		RowLocation baseRL = heapScan.newRowLocationTemplate();
1: 		RowLocation badRL = heapScan.newRowLocationTemplate();
1: 		heapScan.close();
1: 
1: 		/* Open a scan on the index */
1: 		ExecRow		indexRow = t_cc.getIndexTemplateRow(baseRL);
1: 		ScanController indexScan = t_cc.openUnqualifiedIndexScan();
1: 
1: 		// Move to the 1st row in the index
1: 		indexScan.next();
1: 
1: 		// Fetch the 1st row
1: 		indexScan.fetch(indexRow.getRowArray());
1: 		indexScan.close();
1: 
1: 		// Insert another copy of the 1st row into the index with a bad row location
1: 		int keyLength = 
1: 				t_cc.getIndexDescriptor().getIndexDescriptor().baseColumnPositions().length;
1: 		indexRow.setColumn(keyLength + 1, badRL);
1: 
1: 		ConglomerateController indexCC = t_cc.openIndexCC();
1: 		indexCC.insert(indexRow.getRowArray());
1: 		indexCC.close();
1: 	}
1: 
1: 	/**
1: 	 * Swap the values in the specified columns of the
1: 	 * first row from the heap, without
1: 	 * updating the indexes on the table.
1: 	 *
1: 	 * @param schemaName	The schema name.
1: 	 * @param tableName		The table name.
1: 	 * @param firstColumn	First column #.
1: 	 * @param secondColumn	Second column #.
1: 	 * 
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public static void swapColumnsInFirstHeapRow(String schemaName, String tableName,
1: 												 int firstColumn, int secondColumn)
1: 		throws StandardException
1: 	{
1: 	}
1: 
1: 	/* Get the various contexts */
1: 	private void getContexts()
1: 		throws StandardException
1: 	{
1: 		lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1: 		tc = lcc.getTransactionExecute();
1: 
1: 		dd = lcc.getDataDictionary();
1: 
0: 		dvf = lcc.getDataValueFactory();
1: 
0: 		ec = (ExecutionContext) 
0: 				(ContextService.getContext(ExecutionContext.CONTEXT_ID));
1: 	}
1: 
1: 	/* Get the various descriptors */
1: 	private void getDescriptors()
1: 		throws StandardException
1: 	{
1: 		sd = dd.getSchemaDescriptor(schemaName, tc, true);
0: 		td = dd.getTableDescriptor(tableName, sd);
1: 
1: 		if (td == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, schemaName + "." + tableName);
1: 		}
1: 
1: 		if (indexName != null)
1: 		{
1: 			id = dd.getConglomerateDescriptor(indexName, sd, true);
1: 			if (id == null)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INDEX_NOT_FOUND, indexName);
1: 			}
1: 		}
1: 	}
1: 
1: 	/* Get a heap row full of nulls */
1: 	private ExecRow getHeapRowOfNulls()
1: 		throws StandardException
1: 	{
1: 		ConglomerateController	baseCC;
1: 		ExecRow					baseRow;
1: 
1: 		/* Open the heap for reading */
1: 		baseCC = tc.openConglomerate(
1: 		            td.getHeapConglomerateId(), false, 0, 
1: 			        TransactionController.MODE_TABLE,
1: 				    TransactionController.ISOLATION_SERIALIZABLE);
1: 
1: 		/* Get a row template for the base table */
0: 		baseRow = ec.getExecutionFactory().getValueRow(td.getNumberOfColumns());
1: 
1: 		/* Fill the row with nulls of the correct type */
1: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1: 		int					 cdlSize = cdl.size();
1: 
1: 		for (int index = 0; index < cdlSize; index++)
1: 		{
1: 			ColumnDescriptor cd = (ColumnDescriptor) cdl.elementAt(index);
1: 			DataTypeDescriptor dts = cd.getType();
1: 			baseRow.setColumn(cd.getPosition(),
1: 									dts.getNull());
1: 		}
1: 
1: 		baseCC.close();
1: 		return baseRow;
1: 	}
1: 
1: 	/* Open an unqualified scan on the heap for update */
1: 	private ScanController openUnqualifiedHeapScan()
1: 		throws StandardException
1: 	{
1: 		ScanController heapScan;
1: 
1: 		heapScan = tc.openScan(td.getHeapConglomerateId(),
1: 								false,	// hold
1: 								TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1: 								TransactionController.MODE_TABLE,
1: 						        TransactionController.ISOLATION_SERIALIZABLE,
1: 								(FormatableBitSet) null,
1: 								null,	// startKeyValue
1: 								0,		// not used with null start posn.
1: 								null,	// qualifier
1: 								null,	// stopKeyValue
1: 								0);		// not used with null stop posn.
1: 
1: 		return heapScan;
1: 	}
1: 
1: 	/* Open the heap conglomerate for update */
1: 	private ConglomerateController openHeapCC()
1: 		throws StandardException
1: 	{
1: 		ConglomerateController heapCC;
1: 
1: 		heapCC = tc.openConglomerate(
1: 			            td.getHeapConglomerateId(),
1:                         false,
1: 						TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1: 				        TransactionController.MODE_TABLE,
1: 					    TransactionController.ISOLATION_SERIALIZABLE);
1: 
1: 
1: 		return heapCC;
1: 	}
1: 
1: 	/* Get a template row for the specified index */
1: 	private ExecRow getIndexTemplateRow(RowLocation baseRL)
1: 		throws StandardException
1: 	{
1: 		int[]					baseColumnPositions;
1: 		int						baseColumns = 0;
1: 		ExecRow					indexScanTemplate;
1: 
1: 		baseColumnPositions =
1: 				id.getIndexDescriptor().baseColumnPositions();
1: 		baseColumns = baseColumnPositions.length;
1: 
1: 		FormatableBitSet indexColsBitSet = new FormatableBitSet();
1: 		for (int i = 0; i < baseColumns; i++)
1: 		{
1: 			indexColsBitSet.grow(baseColumnPositions[i]);
1: 			indexColsBitSet.set(baseColumnPositions[i] - 1);
1: 		}
1: 
1: 		/* Get a row template */
0: 		indexScanTemplate = ec.getExecutionFactory().getValueRow(baseColumns + 1);
1: 
1: 		/* Fill the row with nulls of the correct type */
1: 		for (int column = 0; column < baseColumns; column++)
1: 		{
1: 			/* Column positions in the data dictionary are one-based */
1: 			ColumnDescriptor cd = td.getColumnDescriptor(baseColumnPositions[column]);
1: 			DataTypeDescriptor dts = cd.getType();
1: 			indexScanTemplate.setColumn(column + 1,
1: 									dts.getNull());
1: 		}
1: 
1: 		/* Set the row location in the last column of the index row */
1: 		indexScanTemplate.setColumn(baseColumns + 1, baseRL);
1: 
1: 		return indexScanTemplate;
1: 	}
1: 
1: 	/* Open an unqualified scan on the index for update */
1: 	private ScanController openUnqualifiedIndexScan()
1: 		throws StandardException
1: 	{
1: 		ScanController indexScan;
1: 
1: 		indexScan = tc.openScan(id.getConglomerateNumber(),
1: 								false,	// hold
1: 								TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1: 								TransactionController.MODE_TABLE,
1: 						        TransactionController.ISOLATION_SERIALIZABLE,
1: 								(FormatableBitSet) null,
1: 								null,	// startKeyValue
1: 								0,		// not used with null start posn.
1: 								null,	// qualifier
1: 								null,	// stopKeyValue
1: 								0);		// not used with null stop posn.
1: 
1: 		return indexScan;
1: 	}
1: 
1: 	/* Open the index conglomerate for update */
1: 	private ConglomerateController openIndexCC()
1: 		throws StandardException
1: 	{
1: 		ConglomerateController indexCC;
1: 
1: 		indexCC = tc.openConglomerate(
1: 			            id.getConglomerateNumber(),
1:                         false,
1: 						TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
1: 				        TransactionController.MODE_TABLE,
1: 					    TransactionController.ISOLATION_SERIALIZABLE);
1: 
1: 
1: 		return indexCC;
1: 	}
1: 
1: 	/* Return the ConglomerateDescriptor for the index */
1: 	private ConglomerateDescriptor getIndexDescriptor()
1: 	{
1: 		return id;
1: 	}
1: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.util.T_ConsistencyChecker
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.util
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.util;
0: 
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * This class has methods for corrupting a database. 
0:  * IT MUST NOT BE DISTRIBUTED WITH THE PRODUCT.
0:  *
0:  * NOTE: The entry points to this class are all static,
0:  * for easy access via the query language.  Each of the
0:  * static methods instantiates an object from the class
0:  * and calls methods off of that object.  This allows
0:  * the sharing of code across the various static methods.
0:  */
0: public class T_ConsistencyChecker
0: { 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private	DataDictionary				dd;
0: 	private	TransactionController		tc;
0: 	private	LanguageConnectionContext	lcc;
0: 	private	DataValueFactory			dvf;
0: 	private	ExecutionContext			ec;
0: 	private String						indexName;
0: 	private String						schemaName;
0: 	private String						tableName;
0: 	private ConglomerateDescriptor		id;
0: 	private SchemaDescriptor			sd;
0: 	private	TableDescriptor				td;
0: 
0: 	T_ConsistencyChecker(String schemaName, String tableName, String indexName)
0: 		throws StandardException
0: 	{
0: 		this.schemaName = schemaName;
0: 		this.tableName = tableName;
0: 		this.indexName = indexName;
0: 	}
0: 
0: 	/**
0: 	 * Delete the first row from the heap, without
0: 	 * deleting it from the indexes on the table.
0: 	 *
0: 	 * @param schemaName	The schema name.
0: 	 * @param tableName		The table name.
0: 	 * 
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static void deleteFirstHeapRow(String schemaName, String tableName)
0: 		throws StandardException
0: 	{
0: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
0: 		t_cc.getContexts();
0: 		t_cc.getDescriptors();
0: 
0: 		/* Open a scan on the heap */
0: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
0: 
0: 		// Move to the 1st row in the heap
0: 		heapScan.next();
0: 
0: 		// Delete the 1st row in the heap
0: 		heapScan.delete();
0: 
0: 		heapScan.close();
0: 	}
0: 
0: 	/**
0: 	 * Get the first row from the heap and insert it into
0: 	 * the heap again, without
0: 	 * inserting it from the indexes on the table.
0: 	 *
0: 	 * @param schemaName	The schema name.
0: 	 * @param tableName		The table name.
0: 	 * 
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static void reinsertFirstHeapRow(String schemaName, String tableName)
0: 		throws StandardException
0: 	{
0: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
0: 		t_cc.getContexts();
0: 		t_cc.getDescriptors();
0: 
0: 		/* Open a scan on the heap */
0: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
0: 
0: 		// Move to the 1st row in the heap
0: 		heapScan.next();
0: 
0: 		// Fetch the 1st row
0: 		ExecRow firstRow = t_cc.getHeapRowOfNulls();
0: 		heapScan.fetch(firstRow.getRowArray());
0: 		heapScan.close();
0: 
0: 		// Insert another copy of the 1st row into the heap
0: 		ConglomerateController heapCC = t_cc.openHeapCC();
0: 		heapCC.insert(firstRow.getRowArray());
0: 		heapCC.close();
0: 	}
0: 
0: 	/**
0: 	 * Set all of the columns in the first row from 
0: 	 * the heap to null, without
0: 	 * updating the indexes on the table.
0: 	 *
0: 	 * @param schemaName	The schema name.
0: 	 * @param tableName		The table name.
0: 	 * 
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static void nullFirstHeapRow(String schemaName, String tableName)
0: 		throws StandardException
0: 	{
0: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, null);
0: 		t_cc.getContexts();
0: 		t_cc.getDescriptors();
0: 
0: 		/* Open a scan on the heap */
0: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
0: 
0: 		// Move to the 1st row in the heap
0: 		heapScan.next();
0: 
0: 		// Get the RowLocation
0: 		RowLocation baseRL = heapScan.newRowLocationTemplate();
0: 		heapScan.fetchLocation(baseRL);
0: 
0: 		// Replace the current row with nulls
0: 		heapScan.replace(
0: 			t_cc.getHeapRowOfNulls().getRowArray(),
0: 			(FormatableBitSet) null);
0: 
0: 		heapScan.close();
0: 	}
0: 
0: 	/**
0: 	 * Get the first row from the heap and insert it into
0: 	 * the specified index, with a bad row location, without
0: 	 * inserting it into the heap or the other indexes on the table.
0: 	 *
0: 	 * @param schemaName	The schema name.
0: 	 * @param tableName		The table name.
0: 	 * @param indexName		The specified index.
0: 	 * 
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static void insertBadRowLocation(String schemaName, String tableName, String indexName)
0: 		throws StandardException
0: 	{
0: 		T_ConsistencyChecker t_cc = new T_ConsistencyChecker(schemaName, tableName, indexName);
0: 		t_cc.getContexts();
0: 		t_cc.getDescriptors();
0: 
0: 
0: 		/* Open a scan on the heap */
0: 		ScanController heapScan = t_cc.openUnqualifiedHeapScan();
0: 
0: 		// Get the RowLocation
0: 		RowLocation baseRL = heapScan.newRowLocationTemplate();
0: 		RowLocation badRL = heapScan.newRowLocationTemplate();
0: 		heapScan.close();
0: 
0: 		/* Open a scan on the index */
0: 		ExecRow		indexRow = t_cc.getIndexTemplateRow(baseRL);
0: 		ScanController indexScan = t_cc.openUnqualifiedIndexScan();
0: 
0: 		// Move to the 1st row in the index
0: 		indexScan.next();
0: 
0: 		// Fetch the 1st row
0: 		indexScan.fetch(indexRow.getRowArray());
0: 		indexScan.close();
0: 
0: 		// Insert another copy of the 1st row into the index with a bad row location
0: 		int keyLength = 
0: 				t_cc.getIndexDescriptor().getIndexDescriptor().baseColumnPositions().length;
0: 		indexRow.setColumn(keyLength + 1, badRL);
0: 
0: 		ConglomerateController indexCC = t_cc.openIndexCC();
0: 		indexCC.insert(indexRow.getRowArray());
0: 		indexCC.close();
0: 	}
0: 
0: 	/**
0: 	 * Swap the values in the specified columns of the
0: 	 * first row from the heap, without
0: 	 * updating the indexes on the table.
0: 	 *
0: 	 * @param schemaName	The schema name.
0: 	 * @param tableName		The table name.
0: 	 * @param firstColumn	First column #.
0: 	 * @param secondColumn	Second column #.
0: 	 * 
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static void swapColumnsInFirstHeapRow(String schemaName, String tableName,
0: 												 int firstColumn, int secondColumn)
0: 		throws StandardException
0: 	{
0: 	}
0: 
0: 	/* Get the various contexts */
0: 	private void getContexts()
0: 		throws StandardException
0: 	{
0: 		lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		tc = lcc.getTransactionExecute();
0: 
0: 		dd = lcc.getDataDictionary();
0: 
0: 		dvf = lcc.getDataValueFactory();
0: 
0: 		ec = (ExecutionContext) 
0: 				(ContextService.getContext(ExecutionContext.CONTEXT_ID));
0: 	}
0: 
0: 	/* Get the various descriptors */
0: 	private void getDescriptors()
0: 		throws StandardException
0: 	{
0: 		sd = dd.getSchemaDescriptor(schemaName, tc, true);
0: 		td = dd.getTableDescriptor(tableName, sd);
0: 
0: 		if (td == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, schemaName + "." + tableName);
0: 		}
0: 
0: 		if (indexName != null)
0: 		{
0: 			id = dd.getConglomerateDescriptor(indexName, sd, true);
0: 			if (id == null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INDEX_NOT_FOUND, indexName);
0: 			}
0: 		}
0: 	}
0: 
0: 	/* Get a heap row full of nulls */
0: 	private ExecRow getHeapRowOfNulls()
0: 		throws StandardException
0: 	{
0: 		ConglomerateController	baseCC;
0: 		ExecRow					baseRow;
0: 
0: 		/* Open the heap for reading */
0: 		baseCC = tc.openConglomerate(
0: 		            td.getHeapConglomerateId(), false, 0, 
0: 			        TransactionController.MODE_TABLE,
0: 				    TransactionController.ISOLATION_SERIALIZABLE);
0: 
0: 		/* Get a row template for the base table */
0: 		baseRow = ec.getExecutionFactory().getValueRow(td.getNumberOfColumns());
0: 
0: 		/* Fill the row with nulls of the correct type */
0: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
0: 		int					 cdlSize = cdl.size();
0: 
0: 		for (int index = 0; index < cdlSize; index++)
0: 		{
0: 			ColumnDescriptor cd = (ColumnDescriptor) cdl.elementAt(index);
0: 			DataTypeDescriptor dts = cd.getType();
0: 			baseRow.setColumn(cd.getPosition(),
0: 									dts.getNull());
0: 		}
0: 
0: 		baseCC.close();
0: 		return baseRow;
0: 	}
0: 
0: 	/* Open an unqualified scan on the heap for update */
0: 	private ScanController openUnqualifiedHeapScan()
0: 		throws StandardException
0: 	{
0: 		ScanController heapScan;
0: 
0: 		heapScan = tc.openScan(td.getHeapConglomerateId(),
0: 								false,	// hold
0: 								TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
0: 								TransactionController.MODE_TABLE,
0: 						        TransactionController.ISOLATION_SERIALIZABLE,
0: 								(FormatableBitSet) null,
0: 								null,	// startKeyValue
0: 								0,		// not used with null start posn.
0: 								null,	// qualifier
0: 								null,	// stopKeyValue
0: 								0);		// not used with null stop posn.
0: 
0: 		return heapScan;
0: 	}
0: 
0: 	/* Open the heap conglomerate for update */
0: 	private ConglomerateController openHeapCC()
0: 		throws StandardException
0: 	{
0: 		ConglomerateController heapCC;
0: 
0: 		heapCC = tc.openConglomerate(
0: 			            td.getHeapConglomerateId(),
0:                         false,
0: 						TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
0: 				        TransactionController.MODE_TABLE,
0: 					    TransactionController.ISOLATION_SERIALIZABLE);
0: 
0: 
0: 		return heapCC;
0: 	}
0: 
0: 	/* Get a template row for the specified index */
0: 	private ExecRow getIndexTemplateRow(RowLocation baseRL)
0: 		throws StandardException
0: 	{
0: 		int[]					baseColumnPositions;
0: 		int						baseColumns = 0;
0: 		ExecRow					indexScanTemplate;
0: 
0: 		baseColumnPositions =
0: 				id.getIndexDescriptor().baseColumnPositions();
0: 		baseColumns = baseColumnPositions.length;
0: 
0: 		FormatableBitSet indexColsBitSet = new FormatableBitSet();
0: 		for (int i = 0; i < baseColumns; i++)
0: 		{
0: 			indexColsBitSet.grow(baseColumnPositions[i]);
0: 			indexColsBitSet.set(baseColumnPositions[i] - 1);
0: 		}
0: 
0: 		/* Get a row template */
0: 		indexScanTemplate = ec.getExecutionFactory().getValueRow(baseColumns + 1);
0: 
0: 		/* Fill the row with nulls of the correct type */
0: 		for (int column = 0; column < baseColumns; column++)
0: 		{
0: 			/* Column positions in the data dictionary are one-based */
0: 			ColumnDescriptor cd = td.getColumnDescriptor(baseColumnPositions[column]);
0: 			DataTypeDescriptor dts = cd.getType();
0: 			indexScanTemplate.setColumn(column + 1,
0: 									dts.getNull());
0: 		}
0: 
0: 		/* Set the row location in the last column of the index row */
0: 		indexScanTemplate.setColumn(baseColumns + 1, baseRL);
0: 
0: 		return indexScanTemplate;
0: 	}
0: 
0: 	/* Open an unqualified scan on the index for update */
0: 	private ScanController openUnqualifiedIndexScan()
0: 		throws StandardException
0: 	{
0: 		ScanController indexScan;
0: 
0: 		indexScan = tc.openScan(id.getConglomerateNumber(),
0: 								false,	// hold
0: 								TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
0: 								TransactionController.MODE_TABLE,
0: 						        TransactionController.ISOLATION_SERIALIZABLE,
0: 								(FormatableBitSet) null,
0: 								null,	// startKeyValue
0: 								0,		// not used with null start posn.
0: 								null,	// qualifier
0: 								null,	// stopKeyValue
0: 								0);		// not used with null stop posn.
0: 
0: 		return indexScan;
0: 	}
0: 
0: 	/* Open the index conglomerate for update */
0: 	private ConglomerateController openIndexCC()
0: 		throws StandardException
0: 	{
0: 		ConglomerateController indexCC;
0: 
0: 		indexCC = tc.openConglomerate(
0: 			            id.getConglomerateNumber(),
0:                         false,
0: 						TransactionController.OPENMODE_FORUPDATE,		//  forUpdate
0: 				        TransactionController.MODE_TABLE,
0: 					    TransactionController.ISOLATION_SERIALIZABLE);
0: 
0: 
0: 		return indexCC;
0: 	}
0: 
0: 	/* Return the ConglomerateDescriptor for the index */
0: 	private ConglomerateDescriptor getIndexDescriptor()
0: 	{
0: 		return id;
0: 	}
0: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6de7104
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	// following methods are originally from a different class - used in the test store/backupRestore1
0: 	// original comment for that class:
0: 	/**
0: 	 * This class provides static methods for checking the consistency of database
0: 	 * objects like tables.
0: 	 */
0: 
0: 	/**
0: 	 * Run all of the consistency checkers which do not take parameters.
0: 	 * Actually, just run the ones that "make sense" to run.  Today,
0: 	 * that is:
0: 	 *		countOpens()
0: 	 *
0: 	 * @return String		If an inconsistency is found, and if DEBUG is on, 
0: 	 *						then a string will be returned with more info.  
0: 	 *						If DEBUG is off, then a simple string will be 
0: 	 *						returned stating whether or not there are open scans.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 * @exception java.sql.SQLException		Thrown on error
0: 	 */
0: 	public static String runConsistencyChecker() throws StandardException, java.sql.SQLException
0: 	{
0: 		return countOpens() + countDependencies();
0: 	}
0: 
0: 	/**
0: 	 * Check to make sure that there are no open conglomerates, scans or sorts.
0: 	 *
0: 	 * @return String		If an inconsistency is found, and if DEBUG is on, 
0: 	 *						then a string will be returned with more info.  
0: 	 *						If DEBUG is off, then a simple string will be 
0: 	 *						returned stating whether or not there are open scans.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static String countOpens() throws StandardException
0: 	{
0: 		int						numOpens = 0;
0: 		LanguageConnectionContext lcc;
0: 		String					output = "No open scans, etc.\n";
0: 		TransactionController	tc;
0: 
0: 		lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		tc = lcc.getTransactionExecute();
0: 
0: 		numOpens = tc.countOpens(TransactionController.OPEN_TOTAL);
0: 
0: 		if (numOpens > 0)
0: 		{
1:             output = numOpens + " conglomerates/scans/sorts found open\n";
0: 
0: 		}
0: 
0: 		return output;
0: 	}
0: 
0: 	/**
0: 	 * Check to make sure that there are no active dependencies (stored or
0: 	 * in memory).
0: 	 *
0: 	 * @return String		If an inconsistency is found, and if DEBUG is on, 
0: 	 *						then a string will be returned with more info.  
0: 	 *						If DEBUG is off, then a simple string will be 
0: 	 *						returned stating whether or not there are open scans.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 * @exception java.sql.SQLException		Thrown on error
0: 	 */
0: 	public static String countDependencies() throws StandardException, java.sql.SQLException
0: 	{
0: 		int						numDependencies = 0;
0: 		DataDictionary			dd;
0: 		DataDictionaryContext	ddc;
0: 		DependencyManager		dm;
0: 		StringBuffer			debugBuf = new StringBuffer();
0: 
0: 		ddc = (DataDictionaryContext)
0: 				(ContextService.getContext(DataDictionaryContext.CONTEXT_ID));
0: 
0: 		dd = ddc.getDataDictionary();
0: 		dm = dd.getDependencyManager();
0: 
0: 		numDependencies = dm.countDependencies();
0: 
0: 		if (numDependencies > 0)
0: 		{
0: 			debugBuf.append(numDependencies + " dependencies found");
0: 		}
0: 		else
0: 		{
0: 			debugBuf.append("No outstanding dependencies.\n");
0: 		}
0: 
0: 		return debugBuf.toString();
0: 	}
============================================================================