1:eac0369: /*
3:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.CurrentOfResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorActivation;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:7d0f620: import org.apache.derby.iapi.sql.execute.RowChanger;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Takes a cursor name and returns the current row
1:eac0369:  * of the cursor; for use in generating the source
1:eac0369:  * row and row location for positioned update/delete operations.
1:eac0369:  * <p>
1:eac0369:  * This result set returns only one row.
1:eac0369:  *
1:eac0369:  */
1:ec08288: class CurrentOfResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet {
1:eac0369: 
1:eac0369:     private boolean next;
1:eac0369: 	private RowLocation rowLocation;
1:eac0369: 
1:eac0369: 	private CursorResultSet cursor;
1:eac0369: 	private CursorResultSet target;
1:eac0369: 	private ExecRow			sparseRow;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369: 	private final String cursorName;
1:eac0369: 
1:eac0369:     //
1:eac0369:     // class interface
1:eac0369:     //
1:ec08288:     CurrentOfResultSet(String cursorName, Activation activation, 
1:ec08288: 							  int resultSetNumber)
2:eac0369: 	{
1:eac0369: 		super(activation, resultSetNumber, 0.0d, 0.0d);
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( cursorName!=null, "current of scan must get cursor name");
1:eac0369:         this.cursorName = cursorName;
3:eac0369:     }
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:2700e3d: 	/**
1:eac0369:      * open a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to open
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen, "CurrentOfResultSet already open");
1:eac0369: 
1:eac0369: 		// get the cursor
1:eac0369: 		getCursor();
1:eac0369: 
1:eac0369: 		next = false;
1:eac0369: 	    isOpen = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * If open and not returned yet, returns the row.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369:      */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException {
1:eac0369: 
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		if ( isOpen ) {
1:eac0369: 	        if ( ! next ) {
1:eac0369: 	            next = true;
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(! cursor.isClosed(), "cursor closed");
1:eac0369: 
1:eac0369: 				ExecRow cursorRow = cursor.getCurrentRow();
1:eac0369: 
1:eac0369: 				// requalify the current row
1:eac0369: 				if (cursorRow == null) {
1:9634cd2: 					throw StandardException.newException(SQLState.NO_CURRENT_ROW);
1:eac0369: 				}
1:eac0369: 				// we know it will be requested, may as well get it now.
1:eac0369: 				rowLocation = cursor.getRowLocation();
1:eac0369: 
1:eac0369: 				// get the row from the base table, which is the real result
1:eac0369: 				// row for the CurrentOfResultSet
1:eac0369: 				currentRow = target.getCurrentRow();
1:2700e3d: 
1:2700e3d: 				// if the source result set is a ScrollInsensitiveResultSet, and
1:2700e3d: 				// the current row has been deleted (while the cursor was 
1:2700e3d: 				// opened), the cursor result set (scroll insensitive) will 
1:2700e3d: 				// return the cached row, while the target result set will 
1:2700e3d: 				// return null (row has been deleted under owr feet).
1:2700e3d: 				if (rowLocation == null  || 
1:2700e3d: 						(cursorRow != null && currentRow == null)) {
1:2700e3d: 					activation.addWarning(StandardException.
1:2700e3d: 							newWarning(SQLState.CURSOR_OPERATION_CONFLICT));
1:2700e3d: 					return null;
1:2700e3d: 				}
1:eac0369: 
1:eac0369: 				/* beetle 3865: updateable cursor using index.  If underlying is a covering
1:eac0369: 				 * index, target is a TableScanRS (instead of a IndexRow2BaseRowRS) for the
1:eac0369: 				 * index scan.  But the problem is it returns a compact row in index key order.
1:eac0369: 				 * However the ProjectRestrictRS above us that sets up the old and new column
1:eac0369: 				 * values expects us to return a sparse row in heap order.  We have to do the
1:eac0369: 				 * wiring here, since we don't have IndexRow2BaseRowRS to do this work.  This
1:eac0369: 				 * problem was not exposed before, because we never used index scan for updateable
1:eac0369: 				 * cursors.
1:eac0369: 				 */
1:eac0369: 				if (target instanceof TableScanResultSet)
1:eac0369: 				{
1:eac0369: 					TableScanResultSet scan = (TableScanResultSet) target;
1:eac0369: 					if (scan.indexCols != null && currentRow != null)
1:eac0369: 						currentRow = getSparseRow(currentRow, scan.indexCols);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// REMIND: verify the row is still there
1:eac0369: 				// at present we get an ugly exception from the store,
1:eac0369: 				// Hopefully someday we can just do this:
1:eac0369: 				//
1:eac0369: 				// if (!rowLocation.rowExists())
1:eac0369: 				//     throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW, cursorName);
1:eac0369: 			}
1:eac0369: 			else {
2:eac0369: 				currentRow = null;
1:eac0369: 				rowLocation = null;
1:eac0369: 			}
1:eac0369: 	    }
1:eac0369: 		else {
1:eac0369: 			currentRow = null;
1:eac0369: 			rowLocation = null;
1:eac0369: 		}
1:eac0369: 		setCurrentRow(currentRow);
1:eac0369: 	    return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a sparse heap row, based on a compact index row.
1:eac0369: 	 *
1:eac0369: 	 * @param row		compact referenced index row
1:eac0369: 	 * @param indexCols	base column positions of index keys, signed with asc/desc info
1:eac0369: 	 *
1:eac0369: 	 * @return			a sparse heap row with referenced columns
1:eac0369: 	 */
1:eac0369: 	private ExecRow getSparseRow(ExecRow row, int[] indexCols) throws StandardException
1:eac0369: 	{
1:eac0369: 		int colPos;
1:eac0369: 		if (sparseRow == null)
1:eac0369: 		{
1:eac0369: 			int numCols = 1;
1:eac0369: 			for (int i = 0; i < indexCols.length; i++)
1:eac0369: 			{
1:eac0369: 				colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
1:eac0369: 				if (colPos > numCols)
1:eac0369: 					numCols = colPos;
1:eac0369: 			}
1:eac0369: 			sparseRow = new ValueRow(numCols);
1:eac0369: 		}
1:eac0369: 		for (int i = 1; i <= indexCols.length; i++)
1:eac0369: 		{
1:eac0369: 			colPos = (indexCols[i-1] > 0) ? indexCols[i-1] : -indexCols[i-1];
1:eac0369: 			sparseRow.setColumn(colPos, row.getColumn(i));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return sparseRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( isOpen ) {
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 	    	clearCurrentRow();
1:eac0369: 	        next = false;
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of CurrentOfResultSet repeated");
1:eac0369: 	}
1:eac0369: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		finishAndRTS();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		/* RESOLVE - RunTimeStats not implemented yet */
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row location from
1:eac0369: 	 * the last fetch done. If it is closed,
1:eac0369: 	 * a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current row.
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation()  {
1:eac0369: 		return rowLocation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned by getNextRow.
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() {
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 		Because the positioned operation only gets one location
1:eac0369: 		per execution, and the cursor could be completely different
1:eac0369: 		for each execution (closed and reopened, perhaps), we 
1:eac0369: 		determine where caching the cursor could be applied.
1:eac0369: 		<p>
1:eac0369: 		When cached, we check if the cursor was closed'd, 
1:eac0369: 		and if so, throw it out and 
1:eac0369: 		see if there's one in the cache with our name. 
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	private void getCursor() throws StandardException {
1:eac0369: 
1:eac0369: 		// need to look again if cursor was closed
1:eac0369: 		if (cursor != null) {
1:eac0369: 			if (cursor.isClosed())
1:eac0369: 			{
1:eac0369: 				cursor = null;
1:eac0369: 				target = null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (cursor == null) {
1:eac0369: 
1:eac0369: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
1:eac0369: 
1:eac0369: 			CursorActivation cursorActivation = lcc.lookupCursorActivation(cursorName);
1:eac0369: 
1:eac0369: 			if (cursorActivation != null)
1:eac0369: 			{
1:eac0369: 				
1:eac0369: 				cursor = cursorActivation.getCursorResultSet();
1:eac0369: 				target = cursorActivation.getTargetResultSet();
1:eac0369: 				/* beetle 3865: updateable cursor using index. 2 way communication between
1:eac0369: 				 * update activation and cursor activation. Cursor passes index scan to
1:eac0369: 				 * update and update passes heap conglom controller to cursor.
1:eac0369: 				 */
1:eac0369: 				activation.setForUpdateIndexScan(cursorActivation.getForUpdateIndexScan());
1:eac0369: 				if (cursorActivation.getHeapConglomerateController() != null)
1:eac0369: 					cursorActivation.getHeapConglomerateController().close();
1:eac0369: 				cursorActivation.setHeapConglomerateController(activation.getHeapConglomerateController());				
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (cursor == null || cursor.isClosed()) {
1:4793bcc: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_FOUND, cursorName);	
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2700e3d: 	 * @see NoPutResultSet#updateRow
1:2700e3d: 	 */
1:7d0f620: 	public void updateRow (ExecRow row, RowChanger rowChanger)
1:7d0f620: 			throws StandardException {
1:7d0f620: 		((NoPutResultSet)cursor).updateRow(row, rowChanger);
1:2700e3d: 	}
1:2700e3d: 	
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#markRowAsDeleted
1:2700e3d: 	 */
1:2700e3d: 	public void markRowAsDeleted() throws StandardException {
1:2700e3d: 		((NoPutResultSet)cursor).markRowAsDeleted();
1:2700e3d: 	}
1:2700e3d: 	
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:91f376c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 
1: 				// if the source result set is a ScrollInsensitiveResultSet, and
1: 				// the current row has been deleted (while the cursor was 
1: 				// opened), the cursor result set (scroll insensitive) will 
1: 				// return the cached row, while the target result set will 
1: 				// return null (row has been deleted under owr feet).
1: 				if (rowLocation == null  || 
1: 						(cursorRow != null && currentRow == null)) {
1: 					activation.addWarning(StandardException.
1: 							newWarning(SQLState.CURSOR_OPERATION_CONFLICT));
1: 					return null;
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @see NoPutResultSet#updateRow
1: 	 */
0: 	public void updateRow (ExecRow row) throws StandardException {
0: 		((NoPutResultSet)cursor).updateRow(row);
1: 	}
1: 	
1: 	/**
1: 	 * @see NoPutResultSet#markRowAsDeleted
1: 	 */
1: 	public void markRowAsDeleted() throws StandardException {
1: 		((NoPutResultSet)cursor).markRowAsDeleted();
1: 	}
1: 	
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 	public void updateRow (ExecRow row, RowChanger rowChanger)
1: 			throws StandardException {
1: 		((NoPutResultSet)cursor).updateRow(row, rowChanger);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4793bcc
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_FOUND, cursorName);	
commit:ec08288
/////////////////////////////////////////////////////////////////////////
1: class CurrentOfResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
1:     CurrentOfResultSet(String cursorName, Activation activation, 
1: 							  int resultSetNumber)
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.CurrentOfResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorActivation;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.PreparedStatement;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
1: /**
1:  * Takes a cursor name and returns the current row
1:  * of the cursor; for use in generating the source
1:  * row and row location for positioned update/delete operations.
1:  * <p>
1:  * This result set returns only one row.
1:  *
0:  * @author ames
1:  */
0: public class CurrentOfResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:     private boolean next;
1: 	private RowLocation rowLocation;
1: 
1: 	private CursorResultSet cursor;
1: 	private CursorResultSet target;
1: 	private ExecRow			sparseRow;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1: 	private final String cursorName;
0: 	private final String psName;
1: 
1:     //
1:     // class interface
1:     //
0:     public CurrentOfResultSet(String cursorName, Activation activation, 
0: 							  int resultSetNumber, String psName)
1: 	{
1: 		super(activation, resultSetNumber, 0.0d, 0.0d);
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( cursorName!=null, "current of scan must get cursor name");
1:         this.cursorName = cursorName;
0: 		this.psName = psName;
1:     }
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 	/**
1:      * open a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown on failure to open
1:      */
1: 	public void	openCore() throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT( ! isOpen, "CurrentOfResultSet already open");
1: 
1: 		// get the cursor
1: 		getCursor();
1: 
1: 		next = false;
1: 	    isOpen = true;
1: 	}
1: 
1: 	/**
1:      * If open and not returned yet, returns the row.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1:      */
1: 	public ExecRow	getNextRowCore() throws StandardException {
1: 
1: 		if ( isOpen ) {
1: 	        if ( ! next ) {
1: 	            next = true;
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(! cursor.isClosed(), "cursor closed");
1: 
1: 				ExecRow cursorRow = cursor.getCurrentRow();
1: 
1: 				// requalify the current row
1: 				if (cursorRow == null) {
0: 				     throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW, cursorName);
1: 				}
1: 				// we know it will be requested, may as well get it now.
1: 				rowLocation = cursor.getRowLocation();
1: 
1: 				// get the row from the base table, which is the real result
1: 				// row for the CurrentOfResultSet
1: 				currentRow = target.getCurrentRow();
1: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(currentRow != null,
0: 									"No target row when there is a cursor row");
1: 
1: 				/* beetle 3865: updateable cursor using index.  If underlying is a covering
1: 				 * index, target is a TableScanRS (instead of a IndexRow2BaseRowRS) for the
1: 				 * index scan.  But the problem is it returns a compact row in index key order.
1: 				 * However the ProjectRestrictRS above us that sets up the old and new column
1: 				 * values expects us to return a sparse row in heap order.  We have to do the
1: 				 * wiring here, since we don't have IndexRow2BaseRowRS to do this work.  This
1: 				 * problem was not exposed before, because we never used index scan for updateable
1: 				 * cursors.
1: 				 */
1: 				if (target instanceof TableScanResultSet)
1: 				{
1: 					TableScanResultSet scan = (TableScanResultSet) target;
1: 					if (scan.indexCols != null && currentRow != null)
1: 						currentRow = getSparseRow(currentRow, scan.indexCols);
1: 				}
0: 				/* If we are updating rows from cached RIDs, we should compare with forward-most
0: 				 * scan key when deciding whether to add RID to hash table or not.
1: 				 */
0: 				TableScanResultSet scan = (TableScanResultSet) activation.getForUpdateIndexScan();
0: 				if (scan != null)
1: 				{
0: 					if (target instanceof IndexRowToBaseRowResultSet)
0: 						scan.compareToLastKey = ((IndexRowToBaseRowResultSet) target).currentRowPrescanned;
0: 					else if (target instanceof TableScanResultSet)
0: 						scan.compareToLastKey = ((TableScanResultSet) target).currentRowPrescanned;
1: 				}
1: 
1: 				// REMIND: verify the row is still there
1: 				// at present we get an ugly exception from the store,
1: 				// Hopefully someday we can just do this:
1: 				//
1: 				// if (!rowLocation.rowExists())
1: 				//     throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW, cursorName);
1: 			}
1: 			else {
1: 				currentRow = null;
1: 				rowLocation = null;
1: 			}
1: 	    }
1: 		else {
1: 			currentRow = null;
1: 			rowLocation = null;
1: 		}
1: 		setCurrentRow(currentRow);
1: 	    return currentRow;
1: 	}
1: 
1: 	/**
1: 	 * Return a sparse heap row, based on a compact index row.
1: 	 *
1: 	 * @param row		compact referenced index row
1: 	 * @param indexCols	base column positions of index keys, signed with asc/desc info
1: 	 *
1: 	 * @return			a sparse heap row with referenced columns
1: 	 */
1: 	private ExecRow getSparseRow(ExecRow row, int[] indexCols) throws StandardException
1: 	{
1: 		int colPos;
1: 		if (sparseRow == null)
1: 		{
1: 			int numCols = 1;
1: 			for (int i = 0; i < indexCols.length; i++)
1: 			{
1: 				colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
1: 				if (colPos > numCols)
1: 					numCols = colPos;
1: 			}
1: 			sparseRow = new ValueRow(numCols);
1: 		}
1: 		for (int i = 1; i <= indexCols.length; i++)
1: 		{
1: 			colPos = (indexCols[i-1] > 0) ? indexCols[i-1] : -indexCols[i-1];
1: 			sparseRow.setColumn(colPos, row.getColumn(i));
1: 		}
1: 
1: 		return sparseRow;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 	    if ( isOpen ) {
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 	    	clearCurrentRow();
1: 	        next = false;
1: 			currentRow = null;
1: 
1: 			super.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of CurrentOfResultSet repeated");
1: 	}
1: 	public void	finish() throws StandardException
1: 	{
1: 		finishAndRTS();
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		/* RESOLVE - RunTimeStats not implemented yet */
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * This result set has its row location from
1: 	 * the last fetch done. If it is closed,
1: 	 * a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current row.
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
1: 	public RowLocation getRowLocation()  {
1: 		return rowLocation;
1: 	}
1: 
1: 	/**
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned by getNextRow.
1: 	 */
1: 	public ExecRow getCurrentRow() {
1: 		return currentRow;
1: 	}
1: 
1: 	//
1: 	// class implementation
1: 	//
1: 	/**
1: 		Because the positioned operation only gets one location
1: 		per execution, and the cursor could be completely different
1: 		for each execution (closed and reopened, perhaps), we 
1: 		determine where caching the cursor could be applied.
1: 		<p>
1: 		When cached, we check if the cursor was closed'd, 
1: 		and if so, throw it out and 
1: 		see if there's one in the cache with our name. 
1: 
1: 	 */
1: 	private void getCursor() throws StandardException {
1: 
1: 		// need to look again if cursor was closed
1: 		if (cursor != null) {
1: 			if (cursor.isClosed())
1: 			{
1: 				cursor = null;
1: 				target = null;
1: 			}
1: 		}
1: 
1: 		if (cursor == null) {
1: 
1: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 
1: 			CursorActivation cursorActivation = lcc.lookupCursorActivation(cursorName);
1: 
1: 			if (cursorActivation != null)
1: 			{
0: 				// check we are compiled against the correct cursor
0: 				PreparedStatement cps = cursorActivation.getPreparedStatement();
1: 
0: 				if (psName.equals(cps.getObjectName())) {
1: 					cursor = cursorActivation.getCursorResultSet();
1: 					target = cursorActivation.getTargetResultSet();
1: 					/* beetle 3865: updateable cursor using index. 2 way communication between
1: 					 * update activation and cursor activation. Cursor passes index scan to
1: 					 * update and update passes heap conglom controller to cursor.
1: 					 */
1: 					activation.setForUpdateIndexScan(cursorActivation.getForUpdateIndexScan());
1: 					if (cursorActivation.getHeapConglomerateController() != null)
1: 						cursorActivation.getHeapConglomerateController().close();
1: 					cursorActivation.setHeapConglomerateController(activation.getHeapConglomerateController());
0: 				} else {
1: 
0: 					// our prepared statement is now invalid since there
0: 					// exists another cursor with the same name but a different
0: 					// statement.
0: 					activation.getPreparedStatement().makeInvalid(DependencyManager.CHANGED_CURSOR, lcc);
1: 				}
1: 			}
1: 		}
1: 
1: 		if (cursor == null || cursor.isClosed()) {
0: 			throw StandardException.newException(SQLState.LANG_CURSOR_CLOSED, cursorName);	
1: 		}
1: 	}
1: 
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:9634cd2
/////////////////////////////////////////////////////////////////////////
1: 					throw StandardException.newException(SQLState.NO_CURRENT_ROW);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:e41dc70
/////////////////////////////////////////////////////////////////////////
0: 				
0: 				cursor = cursorActivation.getCursorResultSet();
0: 				target = cursorActivation.getTargetResultSet();
0: 				/* beetle 3865: updateable cursor using index. 2 way communication between
0: 				 * update activation and cursor activation. Cursor passes index scan to
0: 				 * update and update passes heap conglom controller to cursor.
0: 				 */
0: 				activation.setForUpdateIndexScan(cursorActivation.getForUpdateIndexScan());
0: 				if (cursorActivation.getHeapConglomerateController() != null)
0: 					cursorActivation.getHeapConglomerateController().close();
0: 				cursorActivation.setHeapConglomerateController(activation.getHeapConglomerateController());				
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorActivation;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: /**
0:  * Takes a cursor name and returns the current row
0:  * of the cursor; for use in generating the source
0:  * row and row location for positioned update/delete operations.
0:  * <p>
0:  * This result set returns only one row.
0:  *
0:  * @author ames
0:  */
0: public class CurrentOfResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:     private boolean next;
0: 	private RowLocation rowLocation;
0: 
0: 	private CursorResultSet cursor;
0: 	private CursorResultSet target;
0: 	private ExecRow			sparseRow;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0: 	private final String cursorName;
0: 	private final String psName;
0: 
0:     //
0:     // class interface
0:     //
0:     public CurrentOfResultSet(String cursorName, Activation activation, 
0: 							  int resultSetNumber, String psName)
0: 	{
0: 		super(activation, resultSetNumber, 0.0d, 0.0d);
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( cursorName!=null, "current of scan must get cursor name");
0:         this.cursorName = cursorName;
0: 		this.psName = psName;
0:     }
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 	/**
0:      * open a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown on failure to open
0:      */
0: 	public void	openCore() throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "CurrentOfResultSet already open");
0: 
0: 		// get the cursor
0: 		getCursor();
0: 
0: 		next = false;
0: 	    isOpen = true;
0: 	}
0: 
0: 	/**
0:      * If open and not returned yet, returns the row.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0:      */
0: 	public ExecRow	getNextRowCore() throws StandardException {
0: 
0: 		if ( isOpen ) {
0: 	        if ( ! next ) {
0: 	            next = true;
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(! cursor.isClosed(), "cursor closed");
0: 
0: 				ExecRow cursorRow = cursor.getCurrentRow();
0: 
0: 				// requalify the current row
0: 				if (cursorRow == null) {
0: 				     throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW, cursorName);
0: 				}
0: 				// we know it will be requested, may as well get it now.
0: 				rowLocation = cursor.getRowLocation();
0: 
0: 				// get the row from the base table, which is the real result
0: 				// row for the CurrentOfResultSet
0: 				currentRow = target.getCurrentRow();
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(currentRow != null,
0: 									"No target row when there is a cursor row");
0: 
0: 				/* beetle 3865: updateable cursor using index.  If underlying is a covering
0: 				 * index, target is a TableScanRS (instead of a IndexRow2BaseRowRS) for the
0: 				 * index scan.  But the problem is it returns a compact row in index key order.
0: 				 * However the ProjectRestrictRS above us that sets up the old and new column
0: 				 * values expects us to return a sparse row in heap order.  We have to do the
0: 				 * wiring here, since we don't have IndexRow2BaseRowRS to do this work.  This
0: 				 * problem was not exposed before, because we never used index scan for updateable
0: 				 * cursors.
0: 				 */
0: 				if (target instanceof TableScanResultSet)
0: 				{
0: 					TableScanResultSet scan = (TableScanResultSet) target;
0: 					if (scan.indexCols != null && currentRow != null)
0: 						currentRow = getSparseRow(currentRow, scan.indexCols);
0: 				}
0: 				/* If we are updating rows from cached RIDs, we should compare with forward-most
0: 				 * scan key when deciding whether to add RID to hash table or not.
0: 				 */
0: 				TableScanResultSet scan = (TableScanResultSet) activation.getForUpdateIndexScan();
0: 				if (scan != null)
0: 				{
0: 					if (target instanceof IndexRowToBaseRowResultSet)
0: 						scan.compareToLastKey = ((IndexRowToBaseRowResultSet) target).currentRowPrescanned;
0: 					else if (target instanceof TableScanResultSet)
0: 						scan.compareToLastKey = ((TableScanResultSet) target).currentRowPrescanned;
0: 				}
0: 
0: 				// REMIND: verify the row is still there
0: 				// at present we get an ugly exception from the store,
0: 				// Hopefully someday we can just do this:
0: 				//
0: 				// if (!rowLocation.rowExists())
0: 				//     throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW, cursorName);
0: 			}
0: 			else {
0: 				currentRow = null;
0: 				rowLocation = null;
0: 			}
0: 	    }
0: 		else {
0: 			currentRow = null;
0: 			rowLocation = null;
0: 		}
0: 		setCurrentRow(currentRow);
0: 	    return currentRow;
0: 	}
0: 
0: 	/**
0: 	 * Return a sparse heap row, based on a compact index row.
0: 	 *
0: 	 * @param row		compact referenced index row
0: 	 * @param indexCols	base column positions of index keys, signed with asc/desc info
0: 	 *
0: 	 * @return			a sparse heap row with referenced columns
0: 	 */
0: 	private ExecRow getSparseRow(ExecRow row, int[] indexCols) throws StandardException
0: 	{
0: 		int colPos;
0: 		if (sparseRow == null)
0: 		{
0: 			int numCols = 1;
0: 			for (int i = 0; i < indexCols.length; i++)
0: 			{
0: 				colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
0: 				if (colPos > numCols)
0: 					numCols = colPos;
0: 			}
0: 			sparseRow = new ValueRow(numCols);
0: 		}
0: 		for (int i = 1; i <= indexCols.length; i++)
0: 		{
0: 			colPos = (indexCols[i-1] > 0) ? indexCols[i-1] : -indexCols[i-1];
0: 			sparseRow.setColumn(colPos, row.getColumn(i));
0: 		}
0: 
0: 		return sparseRow;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 	    if ( isOpen ) {
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 	    	clearCurrentRow();
0: 	        next = false;
0: 			currentRow = null;
0: 
0: 			super.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of CurrentOfResultSet repeated");
0: 	}
0: 	public void	finish() throws StandardException
0: 	{
0: 		finishAndRTS();
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		/* RESOLVE - RunTimeStats not implemented yet */
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * This result set has its row location from
0: 	 * the last fetch done. If it is closed,
0: 	 * a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current row.
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	public RowLocation getRowLocation()  {
0: 		return rowLocation;
0: 	}
0: 
0: 	/**
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned by getNextRow.
0: 	 */
0: 	public ExecRow getCurrentRow() {
0: 		return currentRow;
0: 	}
0: 
0: 	//
0: 	// class implementation
0: 	//
0: 	/**
0: 		Because the positioned operation only gets one location
0: 		per execution, and the cursor could be completely different
0: 		for each execution (closed and reopened, perhaps), we 
0: 		determine where caching the cursor could be applied.
0: 		<p>
0: 		When cached, we check if the cursor was closed'd, 
0: 		and if so, throw it out and 
0: 		see if there's one in the cache with our name. 
0: 
0: 	 */
0: 	private void getCursor() throws StandardException {
0: 
0: 		// need to look again if cursor was closed
0: 		if (cursor != null) {
0: 			if (cursor.isClosed())
0: 			{
0: 				cursor = null;
0: 				target = null;
0: 			}
0: 		}
0: 
0: 		if (cursor == null) {
0: 
0: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 
0: 			CursorActivation cursorActivation = lcc.lookupCursorActivation(cursorName);
0: 
0: 			if (cursorActivation != null)
0: 			{
0: 				// check we are compiled against the correct cursor
0: 				PreparedStatement cps = cursorActivation.getPreparedStatement();
0: 
0: 				if (psName.equals(cps.getObjectName())) {
0: 					cursor = cursorActivation.getCursorResultSet();
0: 					target = cursorActivation.getTargetResultSet();
0: 					/* beetle 3865: updateable cursor using index. 2 way communication between
0: 					 * update activation and cursor activation. Cursor passes index scan to
0: 					 * update and update passes heap conglom controller to cursor.
0: 					 */
0: 					activation.setForUpdateIndexScan(cursorActivation.getForUpdateIndexScan());
0: 					if (cursorActivation.getHeapConglomerateController() != null)
0: 						cursorActivation.getHeapConglomerateController().close();
0: 					cursorActivation.setHeapConglomerateController(activation.getHeapConglomerateController());
0: 				} else {
0: 
0: 					// our prepared statement is now invalid since there
0: 					// exists another cursor with the same name but a different
0: 					// statement.
0: 					activation.getPreparedStatement().makeInvalid(DependencyManager.CHANGED_CURSOR, lcc);
0: 				}
0: 			}
0: 		}
0: 
0: 		if (cursor == null || cursor.isClosed()) {
0: 			throw StandardException.newException(SQLState.LANG_CURSOR_CLOSED, cursorName);	
0: 		}
0: 	}
0: 
0: }
============================================================================