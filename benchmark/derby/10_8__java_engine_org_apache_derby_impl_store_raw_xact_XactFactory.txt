6:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.xact.XactFactory
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
12:eac0369: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.xact;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.daemon.DaemonService;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:722a889: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1:722a889: 
1:722a889: import org.apache.derby.iapi.types.DataValueFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:5d97422: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:a0dbbd7: import java.security.PrivilegedAction;
1:56c1dc2: import java.security.PrivilegedActionException;
1:a0dbbd7: import java.security.AccessController;
1:eac0369: import java.util.Properties;
1:99c48bc: import java.util.concurrent.atomic.AtomicLong;
1:eac0369: 
1:eac0369: public class XactFactory implements TransactionFactory, ModuleControl, ModuleSupportable
5:eac0369: {
1:eac0369: 	protected static final String USER_CONTEXT_ID        = "UserTransaction";
1:eac0369: 	protected static final String NESTED_READONLY_USER_CONTEXT_ID = 
1:eac0369:         "NestedRawReadOnlyUserTransaction";
1:eac0369: 	protected static final String NESTED_UPDATE_USER_CONTEXT_ID = 
1:eac0369:         "NestedRawUpdateUserTransaction";
1:eac0369: 	protected static final String INTERNAL_CONTEXT_ID    = "InternalTransaction";
1:eac0369: 	protected static final String NTT_CONTEXT_ID         = "NestedTransaction";
1:722a889: 
1:722a889:  	/*
1:eac0369: 	** Fields
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	protected DaemonService rawStoreDaemon;
1:eac0369: 
1:eac0369: 	private   UUIDFactory           uuidFactory;
1:eac0369: 	protected ContextService		contextFactory;
1:eac0369: 	protected LockFactory           lockFactory;
1:eac0369: 	protected LogFactory            logFactory;
1:eac0369: 	protected DataFactory           dataFactory;
1:722a889: 	protected DataValueFactory      dataValueFactory;
1:eac0369: 	protected RawStoreFactory       rawStoreFactory;
1:eac0369: 
1:eac0369: 	public TransactionTable ttab;
1:99c48bc:     /** The id of the next transaction to be started. */
1:99c48bc:     private final AtomicLong tranId = new AtomicLong();
1:eac0369: 	private LockingPolicy[][] lockingPolicies = new LockingPolicy[3][6];
1:eac0369: 
1:eac0369: 	private boolean inCreateNoLog = false;	// creating database, no logging
1:b4b8d3b: 
1:850aba4:     private /* XAResourceManager */ Object xa_resource;
1:eac0369: 
1:b4b8d3b: 	private Object   backupSemaphore = new Object();
1:b4b8d3b: 	private long     backupBlockingOperations = 0;
1:b4b8d3b: 	private boolean  inBackup = false;
1:5b43e6f: 
1:eac0369: 	/*
1:eac0369: 	** Constructor
1:5b43e6f: 	*/
1:b4b8d3b: 
1:eac0369: 	public XactFactory() {
1:eac0369: 		super();
9:eac0369: 	}
1:a0dbbd7: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ModuleControl
1:eac0369: 	*/
1:eac0369: 	public boolean canSupport(Properties startParams) {
1:b4b8d3b: 		return true;
1:eac0369: 	}
1:32635d2: 
1:eac0369: 	public void	boot(boolean create, Properties properties)
3:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:56c1dc2: 		uuidFactory = getMonitor().getUUIDFactory();
1:eac0369: 
1:eac0369:         /*
1:722a889:         dataValueFactory =  (DataValueFactory)
1:56c1dc2:             findServiceModule(
1:722a889:                 this,
1:722a889:                 org.apache.derby.iapi.reference.ClassName.DataValueFactory);
1:722a889:         */
1:722a889:             // if datafactory has not been booted yet, try now.  This can
1:722a889:             // happen in the unit tests.  Usually it is booted before store
1:722a889:             // booting is called.
1:722a889:             dataValueFactory = (DataValueFactory) 
1:56c1dc2:                 bootServiceModule(
1:722a889:                     create, 
1:722a889:                     this,
1:722a889:                     org.apache.derby.iapi.reference.ClassName.DataValueFactory, 
1:722a889:                     properties);
1:722a889: 		
1:eac0369: 
1:a0dbbd7: 		contextFactory = getContextService();
1:eac0369: 
1:eac0369: 		lockFactory = 
1:56c1dc2:             (LockFactory) bootServiceModule(false, this,
1:eac0369: 				org.apache.derby.iapi.reference.Module.LockFactory, properties);
1:eac0369: 
1:eac0369: 		
1:eac0369:         // adding entries to locking policy table which means we support that
1:eac0369:         // level of concurrency.
1:eac0369: 		lockingPolicies[LockingPolicy.MODE_NONE]
1:eac0369:                        [TransactionController.ISOLATION_NOLOCK] =
1:eac0369:                             new NoLocking();
1:eac0369: 
1:eac0369: 		lockingPolicies[LockingPolicy.MODE_RECORD]
1:eac0369:                        [TransactionController.ISOLATION_NOLOCK] =
1:eac0369:                             new NoLocking();
1:eac0369: 		lockingPolicies[LockingPolicy.MODE_RECORD]
1:eac0369:                        [TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:eac0369:                             new RowLocking1(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:eac0369:                        [TransactionController.ISOLATION_READ_COMMITTED] =
1:eac0369:                             new RowLocking2(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:eac0369:                        [TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:eac0369:                             new RowLocking2nohold(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:eac0369:                        [TransactionController.ISOLATION_REPEATABLE_READ] =
1:eac0369:                             new RowLockingRR(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:eac0369:                        [TransactionController.ISOLATION_SERIALIZABLE] =
1:eac0369:                             new RowLocking3(lockFactory);
1:eac0369: 
1:eac0369: 		lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:eac0369:                        [TransactionController.ISOLATION_NOLOCK] =
1:eac0369:                             new NoLocking();
1:eac0369: 
1:eac0369:         // note that current implementation of read uncommitted still gets
1:eac0369:         // container and container intent locks to prevent concurrent ddl.  Thus
1:eac0369:         // the read uncommitted containerlocking implementation is the same as
1:eac0369:         // the read committed implementation.  Future customer requests may 
1:eac0369:         // force us to change this - we will then have to figure out how to
1:eac0369:         // handle a table being dropped while a read uncommitted scanner is
1:eac0369:         // reading it - currently we just block that from happening.
1:eac0369: 		lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:eac0369:                        [TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:eac0369:                             new ContainerLocking2(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:eac0369:                        [TransactionController.ISOLATION_READ_COMMITTED] =
1:eac0369:                             new ContainerLocking2(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:eac0369:                        [TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:eac0369:                             new ContainerLocking2(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:eac0369:                        [TransactionController.ISOLATION_REPEATABLE_READ] =
1:eac0369:                             new ContainerLocking3(lockFactory);
1:eac0369: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:eac0369:                        [TransactionController.ISOLATION_SERIALIZABLE] =
1:eac0369:                             new ContainerLocking3(lockFactory);
1:eac0369: 
1:eac0369: 
1:eac0369: 		if (create)
1:eac0369: 		{
1:eac0369: 			ttab = new TransactionTable();
1:eac0369: 
1:eac0369: 			String noLog =
1:eac0369: 				properties.getProperty(Property.CREATE_WITH_NO_LOG);
1:eac0369: 
1:eac0369: 			inCreateNoLog = (noLog != null && Boolean.valueOf(noLog).booleanValue());
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	stop() {
1:eac0369: 
1:eac0369: 		if (rawStoreDaemon != null)
1:eac0369: 			rawStoreDaemon.stop();
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of TransactionFactory
1:eac0369: 	*/
1:eac0369: 
1:a0dbbd7: 	/**
1:eac0369: 		Get the LockFactory to use with this store.
1:eac0369: 	*/
1:eac0369: 	public LockFactory getLockFactory() {
1:eac0369: 		return lockFactory;
1:a0dbbd7: 	}
1:eac0369: 
1:eac0369: 
1:5b43e6f: 	/**
1:eac0369: 		Database creation finished
1:94f158a: 		@exception StandardException standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public void createFinished() throws StandardException
1:a0dbbd7: 	{
1:eac0369: 		if (!inCreateNoLog) 
1:a0dbbd7:         {
1:eac0369:             throw StandardException.newException(SQLState.XACT_CREATE_NO_LOG);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// make sure there is no active update transaction
1:eac0369: 		if (ttab.hasActiveUpdateTransaction())
1:eac0369:         {
1:eac0369:             throw StandardException.newException(SQLState.XACT_CREATE_NO_LOG);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		inCreateNoLog = false;
1:eac0369: 	}
1:eac0369: 
1:5b43e6f:     /**
1:eac0369:      * Common work done to create local or global transactions.
1:5b43e6f:      *
1:eac0369:      * @param rsf    the raw store factory creating this xact.
1:9819cf8:      * @param parentTransaction parent transaction (if this is a nested user transaction)
1:eac0369:      * @param cm     the current context manager to associate the xact with.
1:eac0369:      * @param compatibilitySpace 
1:eac0369:      *               if null, use the transaction being created, else if 
1:eac0369:      *               non-null use this compatibilitySpace.
1:5b43e6f:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:0fad4e6:     private Xact startCommonTransaction(
1:ceaf7df:     RawStoreFactory     rsf, 
1:9819cf8:     Xact                    parentTransaction, 
1:ceaf7df:     ContextManager      cm,
1:ceaf7df:     boolean             readOnly,
1:ceaf7df:     CompatibilitySpace  compatibilitySpace,
1:ceaf7df:     String              xact_context_id,
1:ceaf7df:     String              transName,
1:ceaf7df:     boolean             excludeMe,
1:ceaf7df:     boolean             flush_log_on_xact_end)
1:24bbe75:         throws StandardException
1:eac0369:     {
1:5b43e6f: 
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (rawStoreFactory != null)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     rawStoreFactory == rsf, "raw store factory different");
1:5b43e6f: 
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     cm == contextFactory.getCurrentContextManager());
1:5b43e6f: 		}
1:5b43e6f: 
1:722a889: 		Xact xact = 
1:722a889:             new Xact(
1:9819cf8:                 this, parentTransaction, logFactory, dataFactory, dataValueFactory, 
1:ceaf7df:                 readOnly, compatibilitySpace, flush_log_on_xact_end);
1:eac0369: 
1:eac0369:         xact.setTransName(transName);
1:eac0369: 		pushTransactionContext(cm, xact_context_id, xact,
1:eac0369: 							   false /* abortAll */,
1:eac0369: 							   rsf,
1:eac0369: 							   excludeMe /* excludeMe during quiesce state */);
1:eac0369: 		return xact;
1:5b43e6f: 	}
1:eac0369: 
1:eac0369: 	public RawTransaction startTransaction(
2:eac0369:     RawStoreFactory rsf,
1:eac0369:     ContextManager cm,
1:eac0369:     String transName)
1:eac0369:         throws StandardException
1:eac0369:     {
1:ceaf7df:         return(
1:ceaf7df:             startCommonTransaction(
1:ceaf7df:                 rsf, 
1:9819cf8:                 null, 
1:ceaf7df:                 cm, 
1:ceaf7df:                 false,              // user xact always read/write 
1:9819cf8:                 null, 
1:ceaf7df:                 USER_CONTEXT_ID, 
1:ceaf7df:                 transName, 
1:ceaf7df:                 true,               // user xact always excluded during quiesce
1:ceaf7df:                 true));             // user xact default flush on xact end
1:5b43e6f: 	}
1:eac0369: 
1:eac0369: 	public RawTransaction startNestedReadOnlyUserTransaction(
1:eac0369:     RawStoreFactory rsf,
1:9819cf8:     RawTransaction parentTransaction,
1:3c1f634:     CompatibilitySpace compatibilitySpace,
2:eac0369:     ContextManager  cm,
2:eac0369:     String          transName)
1:eac0369:         throws StandardException
1:eac0369:     {
1:ceaf7df:         return(
1:ceaf7df:             startCommonTransaction(
1:ceaf7df:                 rsf, 
1:9819cf8:                 (Xact) parentTransaction, 
1:ceaf7df:                 cm, 
1:ceaf7df:                 true, 
1:ceaf7df:                 compatibilitySpace, 
1:ceaf7df:                 NESTED_READONLY_USER_CONTEXT_ID, 
1:ceaf7df:                 transName, 
1:ceaf7df:                 false,
1:ceaf7df:                 true));             // user readonly xact default flush on xact
1:ceaf7df:                                     // end, should never have anything to flush.
1:5b43e6f: 	}
1:eac0369: 
1:eac0369: 	public RawTransaction startNestedUpdateUserTransaction(
1:eac0369:     RawStoreFactory rsf,
1:9819cf8:     RawTransaction parentTransaction,
1:eac0369:     ContextManager  cm,
1:ceaf7df:     String          transName,
1:ceaf7df:     boolean         flush_log_on_xact_end)
1:eac0369:         throws StandardException
1:eac0369:     {
1:ceaf7df:         return(
1:ceaf7df:             startCommonTransaction(
1:ceaf7df:                 rsf, 
1:9819cf8:                 (Xact) parentTransaction, 
1:ceaf7df:                 cm, 
1:ceaf7df:                 false, 
1:ceaf7df:                 null, 
1:ceaf7df:                 NESTED_UPDATE_USER_CONTEXT_ID, 
1:ceaf7df:                 transName, 
1:ceaf7df:                 true,
1:ceaf7df:                 flush_log_on_xact_end));    // allow caller to choose default 
1:ceaf7df:                                             // log log flushing on commit/abort
1:ceaf7df:                                             // for internal operations used 
1:ceaf7df:                                             // nested user update transaction.
1:5b43e6f: 	}
1:eac0369: 
1:eac0369: 	public RawTransaction startGlobalTransaction(
1:eac0369:     RawStoreFactory rsf,
1:eac0369:     ContextManager  cm,
1:eac0369:     int             format_id,
1:eac0369:     byte[]          global_id,
1:eac0369:     byte[]          branch_id)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         GlobalXactId gid = new GlobalXactId(format_id, global_id, branch_id);
1:eac0369: 
1:eac0369:         if (ttab.findTransactionContextByGlobalId(gid) != null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(SQLState.STORE_XA_XAER_DUPID);
1:eac0369:         }
1:eac0369: 
1:0fad4e6:         Xact xact =
1:eac0369:             startCommonTransaction(
1:ceaf7df:                 rsf, 
1:ceaf7df:                 null, 
1:ceaf7df:                 cm, 
1:ceaf7df:                 false, 
1:ceaf7df:                 null, 
1:ceaf7df:                 USER_CONTEXT_ID, 
1:ceaf7df:                 AccessFactoryGlobals.USER_TRANS_NAME, 
1:ceaf7df:                 true,
1:ceaf7df:                 true);             // user xact default flush on xact end
1:eac0369: 
1:eac0369:         xact.setTransactionId(gid, xact.getId());
1:eac0369: 
1:eac0369:         return(xact);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	public RawTransaction findUserTransaction(
1:eac0369:     RawStoreFactory rsf,
1:eac0369:     ContextManager  contextMgr,
1:eac0369:     String transName)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 contextMgr == contextFactory.getCurrentContextManager(),
1:eac0369:                 "passed in context mgr not the same as current context mgr");
1:eac0369: 
1:eac0369: 			if (rawStoreFactory != null)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     rawStoreFactory == rsf, "raw store factory different");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		XactContext xc = (XactContext)contextMgr.getContext(USER_CONTEXT_ID);
1:eac0369: 		if (xc == null)
1:eac0369: 			return startTransaction(rsf, contextMgr, transName);
1:a0dbbd7: 		else
1:eac0369: 			return xc.getTransaction();
1:eac0369:  	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public RawTransaction startNestedTopTransaction(RawStoreFactory rsf, ContextManager cm)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (rawStoreFactory != null)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     rawStoreFactory == rsf, "raw store factory different");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		Xact xact = 
1:722a889:             new Xact(
1:9819cf8:                 this, null, logFactory, dataFactory, dataValueFactory, 
1:ceaf7df:                 false, null, false);
1:eac0369: 
1:eac0369: 		// hold latches etc. past commit in NTT
1:eac0369: 		xact.setPostComplete();
1:eac0369: 		pushTransactionContext(cm, NTT_CONTEXT_ID, xact, 
1:eac0369: 							   true /* abortAll */,
1:eac0369: 							   rsf, 
1:eac0369: 							   true /* excludeMe during quiesce state*/);
1:eac0369: 		return xact;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public RawTransaction startInternalTransaction(RawStoreFactory rsf, ContextManager cm) 
1:eac0369:         throws StandardException 
1:eac0369:     {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (rawStoreFactory != null)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     rawStoreFactory == rsf, "raw store factory different");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		Xact xact = 
1:722a889:             new InternalXact(this, logFactory, dataFactory, dataValueFactory);
1:722a889: 
1:eac0369: 		pushTransactionContext(cm, INTERNAL_CONTEXT_ID, xact, 
1:eac0369: 							   true /* abortAll*/,
1:eac0369: 							   rsf,
1:eac0369: 							   true /* excludeMe during quiesce state */);
1:eac0369: 		return xact;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * the following TransactionFactory methods are to support recovery and
1:eac0369: 	 * should only be used by recovery!
1:5b43e6f: 	 */
1:eac0369: 
1:5b43e6f: 	/**
1:eac0369: 		Find the TransactionTableEntry with the given ID and make the passed in
1:eac0369: 		transaction assume the identity and properties of that
1:eac0369: 		TransactionTableEntry.
1:eac0369: 		Used in recovery only.
1:5b43e6f: 	*/
1:eac0369: 	public boolean findTransaction(TransactionId id,  RawTransaction tran)
1:eac0369: 	{
1:eac0369: 		return ttab.findAndAssumeTransaction(id, tran);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:5b43e6f: 	/**
1:eac0369: 		Rollback all active transactions that has updated the raw store.
1:eac0369: 		Use the recovery Transaction that is passed in to do all the work.
1:eac0369: 		Used in recovery only.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		Transactions are rolled back in the following order:
1:eac0369: 		<OL>
1:eac0369: 		<LI>internal transactions in reversed beginXact chronological order,
1:eac0369: 		<LI>all other transactions in reversed beginXact chronological order,
1:eac0369: 		</NL>
1:eac0369: 
1:eac0369: 		@param recoveryTransaction use this transaction to do all the user 
1:eac0369:                                    transaction work
1:eac0369: 
1:eac0369: 		@exception StandardException any exception thrown during rollback
1:5b43e6f: 	*/
1:eac0369: 	public void rollbackAllTransactions(
1:eac0369:     RawTransaction  recoveryTransaction,
1:eac0369:     RawStoreFactory rsf) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (rawStoreFactory != null)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     rawStoreFactory == rsf, "raw store factory different");
1:eac0369: 
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 recoveryTransaction != null, "recovery transaction null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int irbcount = 0;
1:eac0369: 
1:eac0369: 		// First undo internal transactions if there is any
1:eac0369: 		if (ttab.hasRollbackFirstTransaction())
1:eac0369: 		{
1:eac0369: 			RawTransaction internalTransaction = startInternalTransaction(rsf,
1:eac0369: 				recoveryTransaction.getContextManager());
1:eac0369: 
1:eac0369: 			// make this transaction be aware that it is being used by recovery
1:eac0369: 			internalTransaction.recoveryTransaction();
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     internalTransaction.handlesPostTerminationWork() == false,
1:eac0369:                     "internal recovery xact handles post termination work");
1:eac0369: 
1:eac0369: 			while(ttab.getMostRecentRollbackFirstTransaction(
1:eac0369:                                                 internalTransaction))
1:eac0369: 			{
1:eac0369: 				irbcount++;
1:eac0369: 				internalTransaction.abort();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			internalTransaction.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 ttab.hasRollbackFirstTransaction() == false,
1:eac0369:                 "cant rollback user xacts with existing active internal xacts");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int rbcount = 0;
1:eac0369: 
1:eac0369: 		// recoveryTransacion assumes the identity of the most recent xact
1:eac0369: 		while(ttab.getMostRecentTransactionForRollback(recoveryTransaction))
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     recoveryTransaction.handlesPostTerminationWork() == false,
1:eac0369:                     "recovery transaction handles post termination work");
1:eac0369:             }
1:eac0369: 
1:eac0369: 			rbcount++;
1:eac0369: 			recoveryTransaction.abort();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (rbcount > 0 || irbcount > 0)
1:eac0369: 			{
1:eac0369: 				// RESOLVE: put this in the log trace
1:eac0369: 				//	System.out.println(
1:eac0369:                 //	    "Recovery rolled back " + irbcount + 
1:eac0369:                 //	    " internal transactions,"
1:eac0369: 				//			+ rbcount + " user transactions");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:ee9c803: 	/**
1:eac0369:         Run through all prepared transactions known to this factory 
1:eac0369:         and restore their state such that they remain after recovery, and
1:eac0369:         can be found and handled by a XA transaction manager.  This includes
1:eac0369:         creating a context manager for each, pushing a xact context, and
1:eac0369:         reclaiming update locks on all data changed by the transaction.
1:eac0369: 
1:eac0369:         Expected to be called just after the redo and undo recovery loops, 
1:eac0369:         where the transaction table should be empty except for prepared
1:eac0369:         xacts.
1:eac0369: 
1:eac0369: 		Used only in recovery.
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard Error policy
1:b4b8d3b: 	*/
1:eac0369: 	public void handlePreparedXacts(
1:eac0369:     RawStoreFactory rsf)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			if (rawStoreFactory != null)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     rawStoreFactory == rsf, "raw store factory different");
1:eac0369: 		}
1:eac0369: 
1:eac0369:         int prepared_count = 0;
1:eac0369: 
1:eac0369: 		if (ttab.hasPreparedRecoveredXact())
1:eac0369: 		{
1:eac0369:             // if there any prepared xacts 
1:eac0369: 
1:eac0369:             // At this point recovery has used one context and one transaction
1:eac0369:             // to deal with all transactions.  Prepared transactions are to
1:eac0369:             // be left in the transaction table, but the must have real and
1:eac0369:             // separate CM's and transactions associated with them.
1:eac0369: 
1:eac0369:             // save old context.  Errors may go to funky contexts (the new
1:eac0369:             // context we created to bring the prepared transaction into the
1:eac0369:             // real world after recovery) after we switch contexts, but any 
1:eac0369:             // error we get at this point is going to shut down the db.
1:eac0369: 
1:eac0369:             while (true)
1:eac0369:             {
1:eac0369:                 // allocate new context and associate new xact with it.
1:eac0369:                 ContextManager cm      = contextFactory.newContextManager();
1:eac0369:                 contextFactory.setCurrentContextManager(cm);
1:eac0369: 
1:eac0369: 				try {
1:eac0369:                 RawTransaction rawtran = 
1:eac0369:                     startTransaction(
1:eac0369:                         rawStoreFactory, cm, 
1:eac0369:                         AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369: 
1:eac0369:                 if (ttab.getMostRecentPreparedRecoveredXact(rawtran))
1:eac0369:                 {
1:eac0369:                     // found a prepared xact.  The reprepare() call will 
1:eac0369:                     // accumulate locks, and change the transaction table entry
1:eac0369:                     // to not be "in-recovery" so that it won't show up again.
1:eac0369:                     rawtran.reprepare();
1:eac0369: 
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                         prepared_count++;
1:eac0369:                 }
3:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // get rid of last transaction allocated.
1:eac0369:                     rawtran.destroy();
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369: 				}
1:eac0369: 				finally
1:eac0369: 				{
1:eac0369: 					 contextFactory.resetCurrentContextManager(cm);
1:eac0369: 				}
1:eac0369:             }
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:             // RESOLVE - need to only do this under a debug flag.
1:eac0369:             // SanityManager.DEBUG_PRINT("",
1:eac0369:             // "Recovery re-prepared " + prepared_count + " xa transactions.");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:ee9c803: 	/**
1:eac0369: 		Get the earliest log instant that is still active, ie, the first log
1:eac0369: 		record logged by the earliest transaction that is still active.
1:eac0369: 		<BR>
1:eac0369: 		The logging system must guarentee that the transaction table is
1:eac0369: 		populated in the order transactions are started.
1:eac0369: 		Used in recovery only.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public LogInstant firstUpdateInstant()
1:eac0369: 	{
1:eac0369: 		return ttab.getFirstLogInstant();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Corruptable
1:eac0369: 	*/
1:eac0369: 
1:24bbe75: 	/**
1:eac0369: 		Really this is just a convience routine for callers that might not
1:eac0369: 		have access to a log factory.
1:eac0369: 	*/
1:eac0369: 	public StandardException markCorrupt(StandardException originalError) {
1:eac0369: 		logFactory.markCorrupt(originalError);
1:eac0369: 		return originalError;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	**		Implementation specific methods.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void setNewTransactionId(TransactionId oldxid, Xact t)
1:eac0369: 	{
1:eac0369: 		boolean excludeMe = true; // by default
1:eac0369: 
1:eac0369: 		if (oldxid != null)
1:eac0369: 			excludeMe = remove(oldxid);
1:eac0369: 
1:99c48bc:         XactId xid = new XactId(tranId.getAndIncrement());
1:eac0369: 
1:eac0369: 		t.setTransactionId(t.getGlobalId(), xid);
1:eac0369: 
1:eac0369: 		// RESOLVE: How does a real global xact id get set?
1:eac0369: 
1:eac0369: 		// If we got rid of the oldxid, that means this transaction object has
1:eac0369: 		// merely committed and starting the next transaction with the same
1:eac0369: 		// xact object.  In that case, the transaction context will remain the
1:eac0369: 		// same and won't be pushed.  We need to add this transaction with the
1:eac0369: 		// new id back into the transaction table.  If we did not get rid of
1:eac0369: 		// the old oldxid, that means this is a brand new transaction being
1:eac0369: 		// created.  The pushTransactionContext call will add it to the
1:eac0369: 		// transaction table with the appropriate flags
1:eac0369: 		if (oldxid != null)
1:eac0369: 			add(t, excludeMe);
1:eac0369: 	}
1:eac0369: 
1:ee9c803: 	/**
1:eac0369: 	**	Set the shortTranId, this is called by the log factory after recovery
1:eac0369: 	*/
1:eac0369: 	public void resetTranId()
1:eac0369: 	{
1:eac0369: 		XactId xid = (XactId)ttab.largestUpdateXactId();
1:99c48bc:         long highestId = (xid == null) ? 0L : xid.getId();
1:99c48bc:         tranId.set(highestId + 1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
8:eac0369: 	/**
1:eac0369: 		Create a new RawTransaction, a context for it and push the context
1:eac0369: 		onto the current context manager.  Then add the transacion to the
1:eac0369: 		transaction table.
1:eac0369: 
1:eac0369: 		@param contextName the name of the transaction context
1:eac0369: 		@param xact the Transaction object
1:eac0369: 		@param abortAll if true, then any error will abort the whole
1:eac0369: 		transaction.  Otherwise, let XactContext.cleanupOnError decide what to
1:eac0369: 		do
1:eac0369: 		@param rsf the raw store factory
1:eac0369: 		@param excludeMe during systeme quiesce, i.e., this transaction should
1:eac0369: 		not be allowed to be active during a quiesce state.
1:eac0369: 
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	protected void pushTransactionContext(ContextManager cm, String contextName, 
1:eac0369: 										  Xact xact,
1:eac0369: 										  boolean abortAll, 
1:eac0369: 										  RawStoreFactory rsf,
1:eac0369: 										  boolean excludeMe)
1:eac0369: 		 throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (cm.getContext(contextName) != null)	
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.XACT_TRANSACTION_ACTIVE);
1:eac0369:         }
1:eac0369: 		
1:eac0369: 		XactContext xc = new XactContext(cm, contextName, xact, abortAll, rsf);
1:eac0369: 
1:eac0369: 		// this transaction is now added to the transaction table.
1:eac0369: 		// This will cause an idle transaction to take on an identity, which is
1:eac0369: 		// unfortunate.  The reason why we have to add the transaction to the
1:eac0369: 		// table right now is because the transaction table is used to bring
1:eac0369: 		// system  to quisce state to  regulate who can go active during quiesce
1:eac0369: 		// state, and if we add the transaction
1:eac0369: 		// when it goes active, then there is a window where this transaction
1:eac0369: 		// can sneak in.  The transaction table itself does not keep track of
1:eac0369: 		// whether transactions can be started or not because quiesce related
1:eac0369: 		// transactions can start after all other user
1:eac0369: 		// transactions are excluded.  
1:eac0369: 		// RESOLVE: need to put more thought on the overall requirement and
1:eac0369: 		// design of the transaction table that satisfies the need of all the
1:eac0369: 		// clients, namely: checkpoint, recovery, quiesce mode, transaction table.
1:eac0369: 
1:eac0369: 		add(xact, excludeMe);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a transaction to the list of transactions that has updated
1:eac0369: 		the raw store.  
1:eac0369: 		<P>
1:eac0369: 		This is called underneath the BeginXact log operation's doMe method.
1:eac0369: 		The logging system must guarentee that transactions are added in the
1:eac0369: 		true order they are started, as defined by the order of beginXact log
1:eac0369: 		record in the log.
1:eac0369: 	*/
1:eac0369: 	protected void addUpdateTransaction(
1:eac0369:     TransactionId   id, 
1:eac0369:     RawTransaction  t, 
1:eac0369:     int             transactionStatus)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 id != null, "addding update transaction with null id");
1:eac0369: 
1:eac0369: 		ttab.addUpdateTransaction(id, t, transactionStatus);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove a transaction from the list of transactions that has updated the
1:eac0369: 		raw store.
1:eac0369: 	*/
1:eac0369: 	protected void removeUpdateTransaction(TransactionId id)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 id != null, "remove update transaction with null id");
1:eac0369: 
1:eac0369: 		ttab.removeUpdateTransaction(id);
1:eac0369: 	} 
1:eac0369: 
1:eac0369: 	/**
1:eac0369:         Change state of transaction to prepared.  Used by recovery to update
1:eac0369:         the transaction table entry to prepared state.
1:eac0369: 	*/
1:eac0369: 	protected void prepareTransaction(TransactionId id)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 id != null, "prepare transaction with null id");
1:eac0369: 
1:eac0369: 		ttab.prepareTransaction(id);
1:eac0369: 	} 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Submit this post commit work to the post commit daemon
1:eac0369: 	*/
1:eac0369: 	public boolean submitPostCommitWork(Serviceable work)
1:eac0369: 	{
1:eac0369: 		if (rawStoreDaemon != null)
1:eac0369: 			return rawStoreDaemon.enqueue(work, work.serviceASAP());
1:b4b8d3b: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setRawStoreFactory(RawStoreFactory rsf) throws StandardException 
1:eac0369: 	{
1:b4b8d3b: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(rsf != null, "rawStoreFactory == null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		rawStoreFactory = rsf;
1:eac0369: 
1:eac0369: 		// no need to remember raw store factory, 
1:eac0369: 		// just remember which daemon to use
1:eac0369: 		rawStoreDaemon = rsf.getDaemon();
1:eac0369: 
1:eac0369: 		// now its ok to look for the log and data factory
1:eac0369: 		// log factory is booted by the data factory
1:56c1dc2: 		logFactory = (LogFactory) findServiceModule(this, rsf.getLogFactoryModule());
1:eac0369: 
1:eac0369: 		// data factory is booted by the raw store implementation
1:56c1dc2: 		dataFactory = (DataFactory) findServiceModule(this, rsf.getDataFactoryModule());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Returns true if there is no in flight updating tranasaction.
1:eac0369: 		Caller must be aware that if there is no other mechanism to stop
1:eac0369: 		transactions from starting and ending, then this information is
1:eac0369: 		outdated as soon as it is reported.
1:eac0369: 
1:eac0369: 		Only call this function in special times - e.g, during recovery
1:eac0369: 	*/
1:eac0369: 	public boolean noActiveUpdateTransaction()
1:eac0369: 	{
1:eac0369: 		return (ttab.hasActiveUpdateTransaction() == false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:32635d2:     /**
1:32635d2:      * Check if there are any prepared transanctions in the 
1:32635d2:      * transaction table. 
1:24bbe75:      *
1:32635d2:      * Caller must be aware that if there is no other mechanism to stop
1:32635d2:      * transactions from starting and ending, then this information is
1:32635d2:      * outdated as soon as it is reported.
1:24bbe75:      *
1:32635d2:      * @return     <tt>true</tt> if there are prepared 
1:32635d2:      *              transactions in the transaction table,
1:32635d2:      *              <tt>false</tt> otherwise.
1:32635d2:      */
1:32635d2: 	public boolean hasPreparedXact()
1:32635d2: 	{
1:32635d2: 		return (ttab.hasPreparedXact());
1:32635d2: 	}
1:32635d2: 
1:32635d2: 
1:32635d2: 
1:eac0369: 	/**
1:eac0369: 		remove the transaction Id an return false iff the transaction is found
1:eac0369: 		in the table and it doesn't need exclusion from quiesce state
1:eac0369: 	 */
1:eac0369: 	protected boolean remove(TransactionId xactId)
1:eac0369: 	{
1:eac0369: 		return ttab.remove(xactId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void add(Xact xact, boolean excludeMe)
1:eac0369: 	{
1:eac0369: 		ttab.add(xact, excludeMe);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Make a new UUID for whomever that wants it
1:eac0369: 	*/
1:eac0369: 	public UUID makeNewUUID()
1:eac0369: 	{
1:eac0369: 		return uuidFactory.createUUID();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a locking policy for a transaction.
1:eac0369: 	*/
1:eac0369: 	final LockingPolicy getLockingPolicy(
1:eac0369:     int     mode, 
1:eac0369:     int     isolation, 
1:eac0369:     boolean stricterOk)
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (mode == LockingPolicy.MODE_NONE)
1:eac0369: 			isolation = TransactionController.ISOLATION_NOLOCK;
1:eac0369: 
1:eac0369: 		LockingPolicy policy = lockingPolicies[mode][isolation];
1:eac0369: 
1:eac0369: 		if ((policy != null) || (!stricterOk))
1:eac0369: 			return policy;
1:eac0369: 
1:eac0369: 		for (mode++; mode <= LockingPolicy.MODE_CONTAINER; mode++) 
1:eac0369:         {
1:eac0369: 			for (int i = isolation; 
1:eac0369:                  i <= TransactionController.ISOLATION_SERIALIZABLE; 
1:eac0369:                  i++) 
1:eac0369:             {
1:eac0369: 				policy = lockingPolicies[mode][i];
1:eac0369: 				if (policy != null)
1:eac0369: 					return policy;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:ee9c803: 	/**
1:eac0369: 		Return the transaction table to be logged with the checkpoint operation
1:eac0369: 	 */
1:eac0369: 	public Formatable getTransactionTable()
1:eac0369: 	{
1:eac0369: 		return ttab;
1:eac0369: 	}
1:eac0369: 
1:ee9c803: 	/**
1:eac0369: 		Use this transaction table, which is gotten from a checkpoint
1:eac0369: 		operation.  Use ONLY during recovery.
1:eac0369: 	 */
1:eac0369: 	public void useTransactionTable(Formatable transactionTable) 
1:b4b8d3b: 		 throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (ttab != null && transactionTable != null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.XACT_TRANSACTION_TABLE_IN_USE);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (ttab == null)
1:eac0369: 		{
1:eac0369: 			if (transactionTable == null)
1:eac0369: 				ttab = new TransactionTable();
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					if ((transactionTable instanceof TransactionTable) ==
1:eac0369: 						false)
1:eac0369: 					{
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 							"using transaction table which is of class " + 
1:eac0369: 							transactionTable.getClass().getName());
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				ttab = (TransactionTable)transactionTable;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		// else transactionTable must be null, if we already have a transaction
1:eac0369: 		// table, no need to do anything
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public TransactionInfo[] getTransactionInfo()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(ttab != null, "transaction table is null");
1:eac0369: 		return ttab.getTransactionInfo();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:ee9c803: 	 * @return false, if the Database creation finished
1:ee9c803: 	 */
1:eac0369: 	public boolean inDatabaseCreation()
1:eac0369: 	{
1:eac0369: 		return inCreateNoLog;
1:eac0369: 	}
1:eac0369: 	
1:ee9c803: 	/**
1:eac0369: 	 * Return the module providing XAresource interface to the transaction 
1:eac0369:      * table. 
1:b4b8d3b:      *
1:94f158a: 	 * @exception StandardException Standard Derby exception policy.
1:eac0369: 	 */
1:eac0369: 	public /* XAResourceManager */ Object getXAResourceManager()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (xa_resource == null)
1:eac0369:             xa_resource = new XactXAResourceManager(rawStoreFactory, ttab);
1:eac0369: 
1:eac0369:         return(xa_resource);
1:eac0369:     }
1:b4b8d3b: 
1:b4b8d3b: 
1:b4b8d3b:     /**
1:402725c:      * Block the online backup. Backup needs to be blocked while 
1:402725c:      * executing any unlogged operations or any opearation that 
1:402725c:      * prevents from  making a consistent backup.
1:402725c:      * 
1:402725c:      * @param wait if <tt>true</tt>, waits until the backup 
1:402725c:      *             is blocked. 
1:402725c:      * @return     <tt>true</tt> if backup is blocked.
1:24bbe75:      *			   <tt>false</tt> otherwise.
1:24bbe75:      */
1:402725c: 	protected boolean blockBackup(boolean wait)
1:b4b8d3b: 	{
1:b4b8d3b: 		synchronized(backupSemaphore) {
1:24bbe75:             // do not allow backup blocking operations, if online backup is
1:24bbe75:             // is in progress.
1:24bbe75: 			if (inBackup) 
1:24bbe75:             {
1:24bbe75:                 if(wait) {
1:24bbe75:                     while(inBackup) {
1:24bbe75:                         try {
1:24bbe75:                             backupSemaphore.wait();
1:24bbe75:                         } catch (InterruptedException ie) {
1:5d97422:                             InterruptStatus.setInterrupted();
1:24bbe75:                         }
1:24bbe75:                     }
1:24bbe75:                 }else {
1:24bbe75:                     return false;
1:24bbe75:                 }
1:b4b8d3b: 			}
1:24bbe75: 
1:24bbe75:             // not in online backup, allow backup blocking operations
1:24bbe75:             backupBlockingOperations++;
1:24bbe75:             return true;
1:b4b8d3b: 		}
1:b4b8d3b: 	}
1:b4b8d3b: 
1:b4b8d3b: 
1:b4b8d3b: 	/**
1:402725c:      * Unblock the backup, a backup blocking operation finished. 
1:b4b8d3b: 	 */
1:402725c: 	protected void unblockBackup()
1:b4b8d3b: 	{
1:b4b8d3b: 		synchronized(backupSemaphore) {
1:b4b8d3b: 			if (SanityManager.DEBUG)
1:b4b8d3b: 				SanityManager.ASSERT(backupBlockingOperations > 0, 
1:b4b8d3b:                     "no backup blocking opeations in progress"); 
1:b4b8d3b: 			
1:b4b8d3b: 			backupBlockingOperations--;
1:b4b8d3b: 
2:b4b8d3b: 			if (inBackup) {
1:b4b8d3b: 				// wake up the online backupthread
2:b4b8d3b: 				backupSemaphore.notifyAll(); 
1:b4b8d3b: 			}
1:b4b8d3b: 		}
1:b4b8d3b: 	}
1:b4b8d3b: 
1:b4b8d3b: 	/**
1:b4b8d3b: 	 * Checks if there are any backup blocking operations in progress and 
1:402725c: 	 * prevents new ones from starting until the backup is finished. 
1:b4b8d3b: 	 * If backup blocking operations are in progress and  <code> wait </code>
1:b4b8d3b: 	 * parameter value is <tt>true</tt>, then it will wait for the current 
1:b4b8d3b: 	 * backup blocking operations to finish. 
1:b4b8d3b: 	 * 
1:b4b8d3b: 	 * A Consistent backup can not be made if there are any backup 
1:b4b8d3b: 	 * blocking operations (like unlogged operations) are in progress
1:b4b8d3b: 	 *
1:b4b8d3b: 	 * @param wait if <tt>true</tt>, waits for the current backup blocking 
1:b4b8d3b: 	 *             operation in progress to finish.
1:b4b8d3b: 	 * @return     <tt>true</tt> if no backup blocking operations are in 
1:b4b8d3b:      *             progress
1:b4b8d3b: 	 *             <tt>false</tt> otherwise.
1:5d97422:      * @exception RuntimeException if runtime exception occurs, in which case
1:5d97422:      *             other threads blocked on backupSemaphore are notified
1:b4b8d3b: 	 */
1:402725c: 	public boolean blockBackupBlockingOperations(boolean wait) 
1:b4b8d3b: 	{
1:b4b8d3b: 		synchronized(backupSemaphore) {
1:b4b8d3b: 			if (wait) {
1:b4b8d3b: 				// set the inBackup state to true first to stop new backup
1:b4b8d3b: 				// blocking operation from starting.
1:b4b8d3b: 				inBackup= true;
1:b4b8d3b: 				try	{
1:b4b8d3b: 					// wait for backup blocking operation in progress to finish
1:b4b8d3b: 					while(backupBlockingOperations > 0)
1:b4b8d3b: 					{
1:b4b8d3b: 						try	{
1:b4b8d3b: 							backupSemaphore.wait();
1:b4b8d3b: 						}
1:b4b8d3b: 						catch (InterruptedException ie) {
1:5d97422:                             InterruptStatus.setInterrupted();
1:b4b8d3b: 						}
1:b4b8d3b: 					}
1:b4b8d3b: 				}
1:b4b8d3b: 				catch (RuntimeException rte) {
1:b4b8d3b: 					// make sure we are not stuck in backup state if we
1:b4b8d3b: 					// caught a run time exception and the calling thread may 
1:b4b8d3b:                     // not have a chance to clear the in backup state.
1:b4b8d3b: 					inBackup= false;
1:b4b8d3b: 					backupSemaphore.notifyAll();
1:b4b8d3b: 					throw rte;		// rethrow run time exception
1:b4b8d3b: 				}
2:b4b8d3b: 			} else {
1:b4b8d3b: 				// check if any backup blocking operations that are in  progress
1:b4b8d3b: 				if (backupBlockingOperations == 0)
1:b4b8d3b: 					inBackup = true;
1:b4b8d3b: 			}
1:fbb8866:             
1:b4b8d3b: 		}
1:b4b8d3b: 
1:fbb8866:         if (SanityManager.DEBUG) {
1:fbb8866:             if (inBackup) {
1:fbb8866:                 SanityManager.ASSERT(backupBlockingOperations == 0 ,
1:fbb8866:                                  "store is not in correct state for backup");
1:fbb8866:             }
1:fbb8866:         }
1:fbb8866: 
1:b4b8d3b: 		return inBackup;
1:b4b8d3b: 	}
1:b4b8d3b: 
1:b4b8d3b: 
1:b4b8d3b: 	/**
1:b4b8d3b: 	 * Backup completed. Allow backup blocking operations. 
1:b4b8d3b: 	 */
1:402725c: 	public void unblockBackupBlockingOperations()
1:b4b8d3b: 	{
1:b4b8d3b: 		synchronized(backupSemaphore) {
2:b4b8d3b: 			inBackup = false;
1:b4b8d3b: 			backupSemaphore.notifyAll();
1:b4b8d3b: 		}
1:b4b8d3b: 	}
1:b4b8d3b: 	
1:b4b8d3b:     
1:eac0369:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object bootServiceModule
1:56c1dc2:         (
1:56c1dc2:          final boolean create, final Object serviceModule,
1:56c1dc2:          final String factoryInterface, final Properties properties
1:56c1dc2:          )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:a0dbbd7:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:a0dbbd7:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedExceptionAction;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
1: 		uuidFactory = getMonitor().getUUIDFactory();
1:             findServiceModule(
/////////////////////////////////////////////////////////////////////////
1:                 bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1:             (LockFactory) bootServiceModule(false, this,
/////////////////////////////////////////////////////////////////////////
1: 		logFactory = (LogFactory) findServiceModule(this, rsf.getLogFactoryModule());
1: 		dataFactory = (DataFactory) findServiceModule(this, rsf.getDataFactoryModule());
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                  {
1:                      return ContextService.getFactory();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object bootServiceModule
1:         (
1:          final boolean create, final Object serviceModule,
1:          final String factoryInterface, final Properties properties
1:          )
1:         throws StandardException
1:     {
1:         try {
1:                  new PrivilegedExceptionAction<Object>()
1:                      public Object run()
1:                          throws StandardException
1:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: 		contextFactory = getContextService();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:      * @param parentTransaction parent transaction (if this is a nested user transaction)
/////////////////////////////////////////////////////////////////////////
1:     Xact                    parentTransaction, 
/////////////////////////////////////////////////////////////////////////
1:                 this, parentTransaction, logFactory, dataFactory, dataValueFactory, 
/////////////////////////////////////////////////////////////////////////
1:                 null, 
/////////////////////////////////////////////////////////////////////////
1:     RawTransaction parentTransaction,
/////////////////////////////////////////////////////////////////////////
1:                 (Xact) parentTransaction, 
/////////////////////////////////////////////////////////////////////////
1:     RawTransaction parentTransaction,
/////////////////////////////////////////////////////////////////////////
1:                 (Xact) parentTransaction, 
/////////////////////////////////////////////////////////////////////////
1:                 null, 
/////////////////////////////////////////////////////////////////////////
1:                 this, null, logFactory, dataFactory, dataValueFactory, 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:99c48bc
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1:     /** The id of the next transaction to be started. */
1:     private final AtomicLong tranId = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
1:         XactId xid = new XactId(tranId.getAndIncrement());
/////////////////////////////////////////////////////////////////////////
1:         long highestId = (xid == null) ? 0L : xid.getId();
1:         tranId.set(highestId + 1);
commit:a809756
/////////////////////////////////////////////////////////////////////////
commit:0fad4e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private Xact startCommonTransaction(
/////////////////////////////////////////////////////////////////////////
1:         Xact xact =
commit:850aba4
/////////////////////////////////////////////////////////////////////////
1:     private /* XAResourceManager */ Object xa_resource;
commit:5b43e6f
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * An instance of a helper class that provides maps with different
0:      * concurrency properties depending on the platform. Used by
0:      * {@code TransactionTable}.
1:      */
0:     private static TransactionMapFactory mapFactory;
1: 
0:         setMapFactory();
1:     /**
0:      * Create a {@code TransactionMapFactory} instance. This method can be
0:      * overridden by sub-classes in order to provide a factory that produces
0:      * maps that give higher concurrency, if supported by the platform.
1:      *
0:      * @return a {@code TransactionMapFactory} suitable for this platform
1:      */
0:     TransactionMapFactory createMapFactory() {
0:         return new TransactionMapFactory();
1:     }
1: 
1:     /**
0:      * Set the default map factory to use for this system, if it's not already
0:      * set. The value will be stored in a static variable so that it will only
0:      * be set by the first {@code XactFactory} that's booted.
1:      */
0:     private void setMapFactory() {
0:         synchronized (XactFactory.class) {
0:             if (mapFactory == null) {
0:                 mapFactory = createMapFactory();
1:             }
1:         }
1:     }
1: 
1:     /**
0:      * Get the map factory for this platform. This can be used by {@code
0:      * TransactionTable} in order to produce the sort of map that has the best
0:      * concurrency properties available on this platform.
1:      *
0:      * @return a map factory
1:      */
0:     static synchronized TransactionMapFactory getMapFactory() {
0:         return mapFactory;
1:     }
1: 
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1:     CompatibilitySpace compatibilitySpace,
/////////////////////////////////////////////////////////////////////////
0:     CompatibilitySpace compatibilitySpace,
commit:ee9c803
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @return false, if the Database creation finished
1: 	 */
1: 	/**
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ceaf7df
/////////////////////////////////////////////////////////////////////////
1:     RawStoreFactory     rsf, 
1:     ContextManager      cm,
1:     boolean             readOnly,
1:     CompatibilitySpace  compatibilitySpace,
1:     String              xact_context_id,
1:     String              transName,
1:     boolean             excludeMe,
1:     boolean             flush_log_on_xact_end)
/////////////////////////////////////////////////////////////////////////
1:                 readOnly, compatibilitySpace, flush_log_on_xact_end);
/////////////////////////////////////////////////////////////////////////
1:         return(
1:             startCommonTransaction(
1:                 rsf, 
1:                 cm, 
1:                 false,              // user xact always read/write 
1:                 null, 
1:                 USER_CONTEXT_ID, 
1:                 transName, 
1:                 true,               // user xact always excluded during quiesce
1:                 true));             // user xact default flush on xact end
/////////////////////////////////////////////////////////////////////////
1:         return(
1:             startCommonTransaction(
1:                 rsf, 
1:                 cm, 
1:                 true, 
1:                 compatibilitySpace, 
1:                 NESTED_READONLY_USER_CONTEXT_ID, 
1:                 transName, 
1:                 false,
1:                 true));             // user readonly xact default flush on xact
1:                                     // end, should never have anything to flush.
1:     String          transName,
1:     boolean         flush_log_on_xact_end)
1:         return(
1:             startCommonTransaction(
1:                 rsf, 
1:                 cm, 
1:                 false, 
1:                 null, 
1:                 NESTED_UPDATE_USER_CONTEXT_ID, 
1:                 transName, 
1:                 true,
1:                 flush_log_on_xact_end));    // allow caller to choose default 
1:                                             // log log flushing on commit/abort
1:                                             // for internal operations used 
1:                                             // nested user update transaction.
/////////////////////////////////////////////////////////////////////////
1:                 rsf, 
1:                 cm, 
1:                 false, 
1:                 null, 
1:                 USER_CONTEXT_ID, 
1:                 AccessFactoryGlobals.USER_TRANS_NAME, 
1:                 true,
1:                 true);             // user xact default flush on xact end
/////////////////////////////////////////////////////////////////////////
0:                 this, logFactory, dataFactory, dataValueFactory, 
1:                 false, null, false);
/////////////////////////////////////////////////////////////////////////
commit:5705f5b
/////////////////////////////////////////////////////////////////////////
0: 		// if this is a user transaction, flush the log by default.
0:         // if this is a nested user update transaction, flush log by default.
0:         //
0:         // In all cases log will not be flushsed by Xact.prepareCommit() 
0:         // if commitNoSync() has been called rather than commit.
0: 		return (contextName == USER_CONTEXT_ID               || 
0: 				contextName.equals(USER_CONTEXT_ID)          ||
0:                 contextName == NESTED_UPDATE_USER_CONTEXT_ID ||
0:                 contextName.equals(NESTED_UPDATE_USER_CONTEXT_ID));
commit:722a889
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
0: import org.apache.derby.impl.store.raw.xact.XactXAResourceManager;
1: 
1: import org.apache.derby.iapi.types.DataValueFactory;
/////////////////////////////////////////////////////////////////////////
1: 	protected DataValueFactory      dataValueFactory;
/////////////////////////////////////////////////////////////////////////
1: 
1:         /*
1:         dataValueFactory =  (DataValueFactory)
0:             Monitor.findServiceModule(
1:                 this,
1:                 org.apache.derby.iapi.reference.ClassName.DataValueFactory);
1:         */
1:             // if datafactory has not been booted yet, try now.  This can
1:             // happen in the unit tests.  Usually it is booted before store
1:             // booting is called.
1:             dataValueFactory = (DataValueFactory) 
0:                 Monitor.bootServiceModule(
1:                     create, 
1:                     this,
1:                     org.apache.derby.iapi.reference.ClassName.DataValueFactory, 
1:                     properties);
1: 
/////////////////////////////////////////////////////////////////////////
1:             new Xact(
0:                 this, logFactory, dataFactory, dataValueFactory, 
0:                 readOnly, compatibilitySpace);
/////////////////////////////////////////////////////////////////////////
1:             new Xact(
0:                 this, logFactory, dataFactory, dataValueFactory, false, null);
/////////////////////////////////////////////////////////////////////////
1: 		Xact xact = 
1:             new InternalXact(this, logFactory, dataFactory, dataValueFactory);
1: 
commit:402725c
/////////////////////////////////////////////////////////////////////////
1:      * Block the online backup. Backup needs to be blocked while 
1:      * executing any unlogged operations or any opearation that 
1:      * prevents from  making a consistent backup.
1:      * 
1:      * @param wait if <tt>true</tt>, waits until the backup 
1:      *             is blocked. 
1:      * @return     <tt>true</tt> if backup is blocked.
0:      * @exception StandardException if interrupted while waiting for a 
0:      *           backup  to complete.
1: 	protected boolean blockBackup(boolean wait)
/////////////////////////////////////////////////////////////////////////
1:      * Unblock the backup, a backup blocking operation finished. 
1: 	protected void unblockBackup()
/////////////////////////////////////////////////////////////////////////
1: 	 * prevents new ones from starting until the backup is finished. 
/////////////////////////////////////////////////////////////////////////
1: 	public boolean blockBackupBlockingOperations(boolean wait) 
/////////////////////////////////////////////////////////////////////////
1: 	public void unblockBackupBlockingOperations()
commit:24bbe75
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Checks if a backup blocking operation can be started.
1:      *
0:      * @param wait if <tt>true</tt>, waits until a backup blocking 
0:      *             operation can be started. 
1:      *
0:      * @return     <tt>true</tt> if backup blocking operations can be started.
1:      *			   <tt>false</tt> otherwise.
0:      * @exception StandardException if interrupted while waiting for backup 
0:      *             to complete.
1:      */
0: 	protected boolean canStartBackupBlockingOperation(boolean wait)
1:         throws StandardException 
1:             // do not allow backup blocking operations, if online backup is
1:             // is in progress.
1: 			if (inBackup) 
1:             {
1:                 if(wait) {
1:                     while(inBackup) {
1:                         try {
1:                             backupSemaphore.wait();
1:                         } catch (InterruptedException ie) {
0:                             throw StandardException.interrupt(ie);
1:                         }
1:                     }
1:                 }else {
1:                     return false;
1:                 }
1: 
1:             // not in online backup, allow backup blocking operations
1:             backupBlockingOperations++;
1:             return true;
commit:fbb8866
/////////////////////////////////////////////////////////////////////////
1:             
1:         if (SanityManager.DEBUG) {
1:             if (inBackup) {
1:                 SanityManager.ASSERT(backupBlockingOperations == 0 ,
1:                                  "store is not in correct state for backup");
1:             }
1:         }
1: 
commit:b4b8d3b
/////////////////////////////////////////////////////////////////////////
1: 
1: 	private Object   backupSemaphore = new Object();
1: 	private long     backupBlockingOperations = 0;
1: 	private boolean  inBackup = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
0: 	 * Checks if a backup blocking operation can be started.
1: 	 *
0: 	 * @return     <tt>true</tt> if backup blocking operations can be started.
0: 	 *			   <tt>false</tt> otherwise.
1: 	 */
0: 	protected boolean canStartBackupBlockingOperation()
1: 	{
1: 		synchronized(backupSemaphore) {
0: 			// do not allow backup blocking operations, if online backup is
0: 			// is in progress.
1: 			if (inBackup) {
1: 				return false;
1: 			} else {
0: 				// not in online backup, allow backup blocking operations
0: 				backupBlockingOperations++;
1: 				return true;
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/**
0: 	 * Mark that a backup blocking operation finished. 
1: 	 */
0: 	protected void backupBlockingOperationFinished()
1: 	{
1: 		synchronized(backupSemaphore) {
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(backupBlockingOperations > 0, 
1:                     "no backup blocking opeations in progress"); 
1: 			
1: 			backupBlockingOperations--;
1: 
1: 			if (inBackup) {
1: 				// wake up the online backupthread
1: 				backupSemaphore.notifyAll(); 
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Checks if there are any backup blocking operations in progress and 
0: 	 * stops new ones from starting until the backup is finished. 
1: 	 * If backup blocking operations are in progress and  <code> wait </code>
1: 	 * parameter value is <tt>true</tt>, then it will wait for the current 
1: 	 * backup blocking operations to finish. 
1: 	 * 
1: 	 * A Consistent backup can not be made if there are any backup 
1: 	 * blocking operations (like unlogged operations) are in progress
1: 	 *
1: 	 * @param wait if <tt>true</tt>, waits for the current backup blocking 
1: 	 *             operation in progress to finish.
1: 	 * @return     <tt>true</tt> if no backup blocking operations are in 
1:      *             progress
1: 	 *             <tt>false</tt> otherwise.
0: 	 * @exception StandardException if interrupted or a runtime exception occurs
1: 	 */
0: 	public boolean stopBackupBlockingOperations(boolean wait) 
1: 		throws StandardException 
1: 	{
1: 		synchronized(backupSemaphore) {
1: 			if (wait) {
1: 				// set the inBackup state to true first to stop new backup
1: 				// blocking operation from starting.
1: 				inBackup= true;
1: 				try	{
1: 					// wait for backup blocking operation in progress to finish
1: 					while(backupBlockingOperations > 0)
1: 					{
1: 						try	{
1: 							backupSemaphore.wait();
1: 						}
1: 						catch (InterruptedException ie) {
0: 							// make sure we are not stuck in the backup state 
0:                             // if we caught an interrupt exception and the 
0:                             // calling thread may not have a chance to clear 
0:                             // the in backup state.
1: 
1: 							inBackup = false;
1: 							backupSemaphore.notifyAll();
0: 							throw StandardException.interrupt(ie);
1: 						}
1: 					}
1: 				}
1: 				catch (RuntimeException rte) {
1: 					// make sure we are not stuck in backup state if we
1: 					// caught a run time exception and the calling thread may 
1:                     // not have a chance to clear the in backup state.
1: 					inBackup= false;
1: 					backupSemaphore.notifyAll();
1: 					throw rte;		// rethrow run time exception
1: 				}
1: 			} else {
1: 				// check if any backup blocking operations that are in  progress
1: 				if (backupBlockingOperations == 0)
1: 					inBackup = true;
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(backupBlockingOperations == 0 && 
0: 								 inBackup == true,
0: 								 "store is not in correct state for backup");
1: 		return inBackup;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Backup completed. Allow backup blocking operations. 
1: 	 */
0: 	public void backupFinished()
1: 	{
1: 		synchronized(backupSemaphore) {
1: 			inBackup = false;
1: 			backupSemaphore.notifyAll();
1: 		}
1: 	}
1: 	
commit:75b112d
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:5d97422
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             InterruptStatus.setInterrupted();
/////////////////////////////////////////////////////////////////////////
1:      * @exception RuntimeException if runtime exception occurs, in which case
1:      *             other threads blocked on backupSemaphore are notified
/////////////////////////////////////////////////////////////////////////
1:                             InterruptStatus.setInterrupted();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard Error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception StandardException Standard Derby exception policy.
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:32635d2
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Check if there are any prepared transanctions in the 
1:      * transaction table. 
0:      *
1:      * Caller must be aware that if there is no other mechanism to stop
1:      * transactions from starting and ending, then this information is
1:      * outdated as soon as it is reported.
0:      *
1:      * @return     <tt>true</tt> if there are prepared 
1:      *              transactions in the transaction table,
1:      *              <tt>false</tt> otherwise.
1:      */
1: 	public boolean hasPreparedXact()
1: 	{
1: 		return (ttab.hasPreparedXact());
1: 	}
1: 
1: 
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.xact.XactFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.xact;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.daemon.DaemonService;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.catalog.UUID;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.TransactionInfo;
1: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
1: 
0: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1: 
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: 
1: import org.apache.derby.iapi.store.raw.log.LogFactory;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: 
0: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.store.raw.xact.XactXAResourceManager;
1: 
0: import java.util.Enumeration;
1: import java.util.Properties;
0: import java.util.Hashtable;
1: 
1: public class XactFactory implements TransactionFactory, ModuleControl, ModuleSupportable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	protected static final String USER_CONTEXT_ID        = "UserTransaction";
1: 	protected static final String NESTED_READONLY_USER_CONTEXT_ID = 
1:         "NestedRawReadOnlyUserTransaction";
1: 	protected static final String NESTED_UPDATE_USER_CONTEXT_ID = 
1:         "NestedRawUpdateUserTransaction";
1: 	protected static final String INTERNAL_CONTEXT_ID    = "InternalTransaction";
1: 	protected static final String NTT_CONTEXT_ID         = "NestedTransaction";
1: 
1:  	/*
1: 	** Fields
1: 	*/
1: 
1: 	protected DaemonService rawStoreDaemon;
1: 
1: 	private   UUIDFactory           uuidFactory;
1: 	protected ContextService		contextFactory;
1: 	protected LockFactory           lockFactory;
1: 	protected LogFactory            logFactory;
1: 	protected DataFactory           dataFactory;
1: 	protected RawStoreFactory       rawStoreFactory;
1: 
1: 	public TransactionTable ttab;
0: 	private long	tranId;
1: 	private LockingPolicy[][] lockingPolicies = new LockingPolicy[3][6];
1: 
1: 	private boolean inCreateNoLog = false;	// creating database, no logging
1: 
0: 	private   XAResourceManager xa_resource;
1: 	
1: 	/*
1: 	** Constructor
1: 	*/
1: 
1: 	public XactFactory() {
1: 		super();
1: 	}
1: 
1: 	/*
1: 	** Methods of ModuleControl
1: 	*/
1: 	public boolean canSupport(Properties startParams) {
0: 		return true;
1: 	}
1: 
1: 	public void	boot(boolean create, Properties properties)
1: 		throws StandardException
1: 	{
1: 
0: 		uuidFactory = Monitor.getMonitor().getUUIDFactory();
1: 		
0: 		contextFactory = ContextService.getFactory();
1: 
1: 		lockFactory = 
0:             (LockFactory) Monitor.bootServiceModule(false, this,
1: 				org.apache.derby.iapi.reference.Module.LockFactory, properties);
1: 
1: 		
1:         // adding entries to locking policy table which means we support that
1:         // level of concurrency.
1: 		lockingPolicies[LockingPolicy.MODE_NONE]
1:                        [TransactionController.ISOLATION_NOLOCK] =
1:                             new NoLocking();
1: 
1: 		lockingPolicies[LockingPolicy.MODE_RECORD]
1:                        [TransactionController.ISOLATION_NOLOCK] =
1:                             new NoLocking();
1: 		lockingPolicies[LockingPolicy.MODE_RECORD]
1:                        [TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:                             new RowLocking1(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:                        [TransactionController.ISOLATION_READ_COMMITTED] =
1:                             new RowLocking2(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:                        [TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:                             new RowLocking2nohold(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:                        [TransactionController.ISOLATION_REPEATABLE_READ] =
1:                             new RowLockingRR(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
1:                        [TransactionController.ISOLATION_SERIALIZABLE] =
1:                             new RowLocking3(lockFactory);
1: 
1: 		lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:                        [TransactionController.ISOLATION_NOLOCK] =
1:                             new NoLocking();
1: 
1:         // note that current implementation of read uncommitted still gets
1:         // container and container intent locks to prevent concurrent ddl.  Thus
1:         // the read uncommitted containerlocking implementation is the same as
1:         // the read committed implementation.  Future customer requests may 
1:         // force us to change this - we will then have to figure out how to
1:         // handle a table being dropped while a read uncommitted scanner is
1:         // reading it - currently we just block that from happening.
1: 		lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:                        [TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:                             new ContainerLocking2(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:                        [TransactionController.ISOLATION_READ_COMMITTED] =
1:                             new ContainerLocking2(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:                        [TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:                             new ContainerLocking2(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:                        [TransactionController.ISOLATION_REPEATABLE_READ] =
1:                             new ContainerLocking3(lockFactory);
1: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
1:                        [TransactionController.ISOLATION_SERIALIZABLE] =
1:                             new ContainerLocking3(lockFactory);
1: 
1: 
1: 		if (create)
1: 		{
1: 			ttab = new TransactionTable();
1: 
1: 			String noLog =
1: 				properties.getProperty(Property.CREATE_WITH_NO_LOG);
1: 
1: 			inCreateNoLog = (noLog != null && Boolean.valueOf(noLog).booleanValue());
1: 
1: 		}
1: 	}
1: 
1: 	public void	stop() {
1: 
1: 		if (rawStoreDaemon != null)
1: 			rawStoreDaemon.stop();
1: 
1: 	}
1: 
1: 	/*
1: 	** Methods of TransactionFactory
1: 	*/
1: 
1: 	/**
1: 		Get the LockFactory to use with this store.
1: 	*/
1: 	public LockFactory getLockFactory() {
1: 		return lockFactory;
1: 	}
1: 
1: 
1: 	/**
1: 		Database creation finished
0: 		@exception StandardException standard cloudscape error policy
1: 	*/
1: 	public void createFinished() throws StandardException
1: 	{
1: 		if (!inCreateNoLog) 
1:         {
1:             throw StandardException.newException(SQLState.XACT_CREATE_NO_LOG);
1:         }
1: 
1: 		// make sure there is no active update transaction
1: 		if (ttab.hasActiveUpdateTransaction())
1:         {
1:             throw StandardException.newException(SQLState.XACT_CREATE_NO_LOG);
1:         }
1: 
1: 		inCreateNoLog = false;
1: 	}
1: 
1:     /**
1:      * Common work done to create local or global transactions.
0:      *
1:      * @param rsf    the raw store factory creating this xact.
1:      * @param cm     the current context manager to associate the xact with.
1:      * @param compatibilitySpace 
1:      *               if null, use the transaction being created, else if 
1:      *               non-null use this compatibilitySpace.
0:      * @param cm     true if transaction should be waited for and halted 
0:      *               during refresh.
0:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	private RawTransaction startCommonTransaction(
1:     RawStoreFactory rsf,
1:     ContextManager  cm,
0:     boolean         readOnly,
0:     Object          compatibilitySpace,
0:     String          xact_context_id,
0:     String          transName,
0:     boolean         excludeMe)
1:         throws StandardException
1:     {
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (rawStoreFactory != null)
1: 				SanityManager.ASSERT(
1:                     rawStoreFactory == rsf, "raw store factory different");
1: 
1: 				SanityManager.ASSERT(
1:                     cm == contextFactory.getCurrentContextManager());
1: 		}
1: 
1: 		Xact xact = 
0:             new Xact(this, logFactory, dataFactory, readOnly, compatibilitySpace);
1: 
1:         xact.setTransName(transName);
1: 		pushTransactionContext(cm, xact_context_id, xact,
1: 							   false /* abortAll */,
1: 							   rsf,
1: 							   excludeMe /* excludeMe during quiesce state */);
1: 		return xact;
1: 	}
1: 
1: 	public RawTransaction startTransaction(
1:     RawStoreFactory rsf,
1:     ContextManager cm,
1:     String transName)
1:         throws StandardException
1:     {
0:         return(startCommonTransaction(
0:                 rsf, cm, false, null, USER_CONTEXT_ID, transName, true));
1: 	}
1: 
1: 	public RawTransaction startNestedReadOnlyUserTransaction(
1:     RawStoreFactory rsf,
0:     Object          compatibilitySpace,
1:     ContextManager  cm,
1:     String          transName)
1:         throws StandardException
1:     {
0:         return(startCommonTransaction(
0:             rsf, cm, true, compatibilitySpace, 
0:             NESTED_READONLY_USER_CONTEXT_ID, transName, false));
1: 	}
1: 
1: 	public RawTransaction startNestedUpdateUserTransaction(
1:     RawStoreFactory rsf,
1:     ContextManager  cm,
1:     String          transName)
1:         throws StandardException
1:     {
0:         return(startCommonTransaction(
0:             rsf, cm, false, null, 
0:             NESTED_UPDATE_USER_CONTEXT_ID, transName, true));
1: 	}
1: 
1: 	public RawTransaction startGlobalTransaction(
1:     RawStoreFactory rsf,
1:     ContextManager  cm,
1:     int             format_id,
1:     byte[]          global_id,
1:     byte[]          branch_id)
1:         throws StandardException
1:     {
1:         GlobalXactId gid = new GlobalXactId(format_id, global_id, branch_id);
1: 
1:         if (ttab.findTransactionContextByGlobalId(gid) != null)
1:         {
1:             throw StandardException.newException(SQLState.STORE_XA_XAER_DUPID);
1:         }
1: 
0:         RawTransaction xact = 
1:             startCommonTransaction(
0:                 rsf, cm, false, null, 
0:                 USER_CONTEXT_ID, AccessFactoryGlobals.USER_TRANS_NAME, true);
1: 
1:         xact.setTransactionId(gid, xact.getId());
1: 
1:         return(xact);
1: 	}
1: 
1: 
1: 
1: 	public RawTransaction findUserTransaction(
1:     RawStoreFactory rsf,
1:     ContextManager  contextMgr,
1:     String transName)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(
1:                 contextMgr == contextFactory.getCurrentContextManager(),
1:                 "passed in context mgr not the same as current context mgr");
1: 
1: 			if (rawStoreFactory != null)
1: 				SanityManager.ASSERT(
1:                     rawStoreFactory == rsf, "raw store factory different");
1: 		}
1: 
1: 		XactContext xc = (XactContext)contextMgr.getContext(USER_CONTEXT_ID);
1: 		if (xc == null)
1: 			return startTransaction(rsf, contextMgr, transName);
1: 		else
1: 			return xc.getTransaction();
1:  	}
1: 
1: 
1: 	public RawTransaction startNestedTopTransaction(RawStoreFactory rsf, ContextManager cm)
1:         throws StandardException
1:     {
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (rawStoreFactory != null)
1: 				SanityManager.ASSERT(
1:                     rawStoreFactory == rsf, "raw store factory different");
1: 		}
1: 
1: 		Xact xact = 
0:             new Xact(this, logFactory, dataFactory, false, null);
1: 
1: 		// hold latches etc. past commit in NTT
1: 		xact.setPostComplete();
1: 		pushTransactionContext(cm, NTT_CONTEXT_ID, xact, 
1: 							   true /* abortAll */,
1: 							   rsf, 
1: 							   true /* excludeMe during quiesce state*/);
1: 		return xact;
1: 	}
1: 
1: 	public RawTransaction startInternalTransaction(RawStoreFactory rsf, ContextManager cm) 
1:         throws StandardException 
1:     {
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (rawStoreFactory != null)
1: 				SanityManager.ASSERT(
1:                     rawStoreFactory == rsf, "raw store factory different");
1: 		}
1: 
1: 
0: 		Xact xact = new InternalXact(this, logFactory, dataFactory);
1: 		pushTransactionContext(cm, INTERNAL_CONTEXT_ID, xact, 
1: 							   true /* abortAll*/,
1: 							   rsf,
1: 							   true /* excludeMe during quiesce state */);
1: 		return xact;
1: 	}
1: 
1: 	/*
1: 	 * the following TransactionFactory methods are to support recovery and
1: 	 * should only be used by recovery!
1: 	 */
1: 
1: 	/**
1: 		Find the TransactionTableEntry with the given ID and make the passed in
1: 		transaction assume the identity and properties of that
1: 		TransactionTableEntry.
1: 		Used in recovery only.
1: 	*/
1: 	public boolean findTransaction(TransactionId id,  RawTransaction tran)
1: 	{
1: 		return ttab.findAndAssumeTransaction(id, tran);
1: 	}
1: 
1: 
1: 	/**
1: 		Rollback all active transactions that has updated the raw store.
1: 		Use the recovery Transaction that is passed in to do all the work.
1: 		Used in recovery only.
1: 
1: 		<P>
1: 		Transactions are rolled back in the following order:
1: 		<OL>
1: 		<LI>internal transactions in reversed beginXact chronological order,
1: 		<LI>all other transactions in reversed beginXact chronological order,
1: 		</NL>
1: 
1: 		@param recoveryTransaction use this transaction to do all the user 
1:                                    transaction work
1: 
1: 		@exception StandardException any exception thrown during rollback
1: 	*/
1: 	public void rollbackAllTransactions(
1:     RawTransaction  recoveryTransaction,
1:     RawStoreFactory rsf) 
1:         throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (rawStoreFactory != null)
1: 				SanityManager.ASSERT(
1:                     rawStoreFactory == rsf, "raw store factory different");
1: 
1: 			SanityManager.ASSERT(
1:                 recoveryTransaction != null, "recovery transaction null");
1: 		}
1: 
1: 		int irbcount = 0;
1: 
1: 		// First undo internal transactions if there is any
1: 		if (ttab.hasRollbackFirstTransaction())
1: 		{
1: 			RawTransaction internalTransaction = startInternalTransaction(rsf,
1: 				recoveryTransaction.getContextManager());
1: 
1: 			// make this transaction be aware that it is being used by recovery
1: 			internalTransaction.recoveryTransaction();
1: 
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(
1:                     internalTransaction.handlesPostTerminationWork() == false,
1:                     "internal recovery xact handles post termination work");
1: 
1: 			while(ttab.getMostRecentRollbackFirstTransaction(
1:                                                 internalTransaction))
1: 			{
1: 				irbcount++;
1: 				internalTransaction.abort();
1: 			}
1: 
1: 			internalTransaction.close();
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(
1:                 ttab.hasRollbackFirstTransaction() == false,
1:                 "cant rollback user xacts with existing active internal xacts");
1: 		}
1: 
1: 		int rbcount = 0;
1: 
1: 		// recoveryTransacion assumes the identity of the most recent xact
1: 		while(ttab.getMostRecentTransactionForRollback(recoveryTransaction))
1: 		{
1: 			if (SanityManager.DEBUG)
1:             {
1: 				SanityManager.ASSERT(
1:                     recoveryTransaction.handlesPostTerminationWork() == false,
1:                     "recovery transaction handles post termination work");
1:             }
1: 
1: 			rbcount++;
1: 			recoveryTransaction.abort();
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (rbcount > 0 || irbcount > 0)
1: 			{
1: 				// RESOLVE: put this in the log trace
1: 				//	System.out.println(
1:                 //	    "Recovery rolled back " + irbcount + 
1:                 //	    " internal transactions,"
1: 				//			+ rbcount + " user transactions");
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 
1: 	/**
1:         Run through all prepared transactions known to this factory 
1:         and restore their state such that they remain after recovery, and
1:         can be found and handled by a XA transaction manager.  This includes
1:         creating a context manager for each, pushing a xact context, and
1:         reclaiming update locks on all data changed by the transaction.
1: 
1:         Expected to be called just after the redo and undo recovery loops, 
1:         where the transaction table should be empty except for prepared
1:         xacts.
1: 
1: 		Used only in recovery.
1: 
0: 		@exception StandardException Cloudscape Standard Error policy
1: 	*/
1: 	public void handlePreparedXacts(
1:     RawStoreFactory rsf)
1:         throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 
1: 			if (rawStoreFactory != null)
1: 				SanityManager.ASSERT(
1:                     rawStoreFactory == rsf, "raw store factory different");
1: 		}
1: 
1:         int prepared_count = 0;
1: 
1: 		if (ttab.hasPreparedRecoveredXact())
1: 		{
1:             // if there any prepared xacts 
1: 
1:             // At this point recovery has used one context and one transaction
1:             // to deal with all transactions.  Prepared transactions are to
1:             // be left in the transaction table, but the must have real and
1:             // separate CM's and transactions associated with them.
1: 
1:             // save old context.  Errors may go to funky contexts (the new
1:             // context we created to bring the prepared transaction into the
1:             // real world after recovery) after we switch contexts, but any 
1:             // error we get at this point is going to shut down the db.
1: 
1:             while (true)
1:             {
1:                 // allocate new context and associate new xact with it.
1:                 ContextManager cm      = contextFactory.newContextManager();
1:                 contextFactory.setCurrentContextManager(cm);
1: 
1: 				try {
1:                 RawTransaction rawtran = 
1:                     startTransaction(
1:                         rawStoreFactory, cm, 
1:                         AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1:                 if (ttab.getMostRecentPreparedRecoveredXact(rawtran))
1:                 {
1:                     // found a prepared xact.  The reprepare() call will 
1:                     // accumulate locks, and change the transaction table entry
1:                     // to not be "in-recovery" so that it won't show up again.
1:                     rawtran.reprepare();
1: 
1:                     if (SanityManager.DEBUG)
1:                         prepared_count++;
1:                 }
1:                 else
1:                 {
1:                     // get rid of last transaction allocated.
1:                     rawtran.destroy();
1:                     break;
1:                 }
1: 				}
1: 				finally
1: 				{
1: 					 contextFactory.resetCurrentContextManager(cm);
1: 				}
1:             }
1: 
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1:             // RESOLVE - need to only do this under a debug flag.
1:             // SanityManager.DEBUG_PRINT("",
1:             // "Recovery re-prepared " + prepared_count + " xa transactions.");
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 		Get the earliest log instant that is still active, ie, the first log
1: 		record logged by the earliest transaction that is still active.
1: 		<BR>
1: 		The logging system must guarentee that the transaction table is
1: 		populated in the order transactions are started.
1: 		Used in recovery only.
1: 	*/
1: 
1: 	public LogInstant firstUpdateInstant()
1: 	{
1: 		return ttab.getFirstLogInstant();
1: 	}
1: 
1: 	/*
1: 	** Methods of Corruptable
1: 	*/
1: 
1: 	/**
1: 		Really this is just a convience routine for callers that might not
1: 		have access to a log factory.
1: 	*/
1: 	public StandardException markCorrupt(StandardException originalError) {
1: 		logFactory.markCorrupt(originalError);
1: 		return originalError;
1: 	}
1: 
1: 	/*
1: 	**		Implementation specific methods.
1: 	*/
1: 
1: 	public void setNewTransactionId(TransactionId oldxid, Xact t)
1: 	{
0: 		XactId xid;
1: 		boolean excludeMe = true; // by default
1: 
1: 		if (oldxid != null)
1: 			excludeMe = remove(oldxid);
1: 
0: 		synchronized(this)
1: 		{
0: 			xid = new XactId(tranId++);
1: 		}
1: 
1: 		t.setTransactionId(t.getGlobalId(), xid);
1: 
1: 		// RESOLVE: How does a real global xact id get set?
1: 
1: 		// If we got rid of the oldxid, that means this transaction object has
1: 		// merely committed and starting the next transaction with the same
1: 		// xact object.  In that case, the transaction context will remain the
1: 		// same and won't be pushed.  We need to add this transaction with the
1: 		// new id back into the transaction table.  If we did not get rid of
1: 		// the old oldxid, that means this is a brand new transaction being
1: 		// created.  The pushTransactionContext call will add it to the
1: 		// transaction table with the appropriate flags
1: 		if (oldxid != null)
1: 			add(t, excludeMe);
1: 	}
1: 
1: 	/*
1: 	**	Set the shortTranId, this is called by the log factory after recovery
1: 	*/
1: 	public void resetTranId()
1: 	{
1: 		XactId xid = (XactId)ttab.largestUpdateXactId();
0: 		if (xid != null)
0: 			tranId = xid.getId() + 1;
1: 		else
0: 			tranId = 1;
1: 	}
1: 
1: 
1: 	/**
1: 		Create a new RawTransaction, a context for it and push the context
1: 		onto the current context manager.  Then add the transacion to the
1: 		transaction table.
1: 
1: 		@param contextName the name of the transaction context
1: 		@param xact the Transaction object
1: 		@param abortAll if true, then any error will abort the whole
1: 		transaction.  Otherwise, let XactContext.cleanupOnError decide what to
1: 		do
1: 		@param rsf the raw store factory
1: 		@param excludeMe during systeme quiesce, i.e., this transaction should
1: 		not be allowed to be active during a quiesce state.
1: 
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
1: 	*/
1: 	protected void pushTransactionContext(ContextManager cm, String contextName, 
1: 										  Xact xact,
1: 										  boolean abortAll, 
1: 										  RawStoreFactory rsf,
1: 										  boolean excludeMe)
1: 		 throws StandardException 
1: 	{
1: 		if (cm.getContext(contextName) != null)	
1:         {
1:             throw StandardException.newException(
1:                     SQLState.XACT_TRANSACTION_ACTIVE);
1:         }
1: 		
1: 		XactContext xc = new XactContext(cm, contextName, xact, abortAll, rsf);
1: 
1: 		// this transaction is now added to the transaction table.
1: 		// This will cause an idle transaction to take on an identity, which is
1: 		// unfortunate.  The reason why we have to add the transaction to the
1: 		// table right now is because the transaction table is used to bring
1: 		// system  to quisce state to  regulate who can go active during quiesce
1: 		// state, and if we add the transaction
1: 		// when it goes active, then there is a window where this transaction
1: 		// can sneak in.  The transaction table itself does not keep track of
1: 		// whether transactions can be started or not because quiesce related
1: 		// transactions can start after all other user
1: 		// transactions are excluded.  
1: 		// RESOLVE: need to put more thought on the overall requirement and
1: 		// design of the transaction table that satisfies the need of all the
1: 		// clients, namely: checkpoint, recovery, quiesce mode, transaction table.
1: 
1: 		add(xact, excludeMe);
1: 
1: 	}
1: 
1: 	/**
1: 		Add a transaction to the list of transactions that has updated
1: 		the raw store.  
1: 		<P>
1: 		This is called underneath the BeginXact log operation's doMe method.
1: 		The logging system must guarentee that transactions are added in the
1: 		true order they are started, as defined by the order of beginXact log
1: 		record in the log.
1: 	*/
1: 	protected void addUpdateTransaction(
1:     TransactionId   id, 
1:     RawTransaction  t, 
1:     int             transactionStatus)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(
1:                 id != null, "addding update transaction with null id");
1: 
1: 		ttab.addUpdateTransaction(id, t, transactionStatus);
1: 	}
1: 
1: 	/**
1: 		Remove a transaction from the list of transactions that has updated the
1: 		raw store.
1: 	*/
1: 	protected void removeUpdateTransaction(TransactionId id)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(
1:                 id != null, "remove update transaction with null id");
1: 
1: 		ttab.removeUpdateTransaction(id);
1: 	} 
1: 
1: 	/**
1:         Change state of transaction to prepared.  Used by recovery to update
1:         the transaction table entry to prepared state.
1: 	*/
1: 	protected void prepareTransaction(TransactionId id)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(
1:                 id != null, "prepare transaction with null id");
1: 
1: 		ttab.prepareTransaction(id);
1: 	} 
1: 
1: 	/**
1: 		Submit this post commit work to the post commit daemon
1: 	*/
1: 	public boolean submitPostCommitWork(Serviceable work)
1: 	{
1: 		if (rawStoreDaemon != null)
1: 			return rawStoreDaemon.enqueue(work, work.serviceASAP());
0: 		return false;
1: 	}
1: 
1: 	public void setRawStoreFactory(RawStoreFactory rsf) throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(rsf != null, "rawStoreFactory == null");
1: 		}
1: 
1: 		rawStoreFactory = rsf;
1: 
1: 		// no need to remember raw store factory, 
1: 		// just remember which daemon to use
1: 		rawStoreDaemon = rsf.getDaemon();
1: 
1: 		// now its ok to look for the log and data factory
1: 		// log factory is booted by the data factory
0: 		logFactory = (LogFactory) Monitor.findServiceModule(this, rsf.getLogFactoryModule());
1: 
1: 		// data factory is booted by the raw store implementation
0: 		dataFactory = (DataFactory) Monitor.findServiceModule(this, rsf.getDataFactoryModule());
1: 	}
1: 
1: 	/**
1: 		Returns true if there is no in flight updating tranasaction.
1: 		Caller must be aware that if there is no other mechanism to stop
1: 		transactions from starting and ending, then this information is
1: 		outdated as soon as it is reported.
1: 
1: 		Only call this function in special times - e.g, during recovery
1: 	*/
1: 	public boolean noActiveUpdateTransaction()
1: 	{
1: 		return (ttab.hasActiveUpdateTransaction() == false);
1: 	}
1: 
1: 	/*
1: 		remove the transaction Id an return false iff the transaction is found
1: 		in the table and it doesn't need exclusion from quiesce state
1: 	 */
1: 	protected boolean remove(TransactionId xactId)
1: 	{
1: 		return ttab.remove(xactId);
1: 	}
1: 
1: 	protected void add(Xact xact, boolean excludeMe)
1: 	{
1: 		ttab.add(xact, excludeMe);
1: 	}
1: 
1: 
1: 	/**
1: 		Make a new UUID for whomever that wants it
1: 	*/
1: 	public UUID makeNewUUID()
1: 	{
1: 		return uuidFactory.createUUID();
1: 	}
1: 
1: 	/**
0: 		Decide if a transaction of this contextId needs to flush the log when
0: 		it commits
1: 	*/
0: 	public boolean flushLogOnCommit(String contextName)
1: 	{
0: 		//
0: 		// if this is a user transaction, flush the log
0: 		// if this is an internal or nested top transaction, do not
0: 		// flush, let it age out.
0: 		//
0: 		return (contextName == USER_CONTEXT_ID || 
0: 				contextName.equals(USER_CONTEXT_ID));
1: 	}
1: 
1: 
1: 	/**
1: 		Get a locking policy for a transaction.
1: 	*/
1: 	final LockingPolicy getLockingPolicy(
1:     int     mode, 
1:     int     isolation, 
1:     boolean stricterOk)
1:     {
1: 
1: 		if (mode == LockingPolicy.MODE_NONE)
1: 			isolation = TransactionController.ISOLATION_NOLOCK;
1: 
1: 		LockingPolicy policy = lockingPolicies[mode][isolation];
1: 
1: 		if ((policy != null) || (!stricterOk))
1: 			return policy;
1: 
1: 		for (mode++; mode <= LockingPolicy.MODE_CONTAINER; mode++) 
1:         {
1: 			for (int i = isolation; 
1:                  i <= TransactionController.ISOLATION_SERIALIZABLE; 
1:                  i++) 
1:             {
1: 				policy = lockingPolicies[mode][i];
1: 				if (policy != null)
1: 					return policy;
1: 			}
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/*
1: 		Return the transaction table to be logged with the checkpoint operation
1: 	 */
1: 	public Formatable getTransactionTable()
1: 	{
1: 		return ttab;
1: 	}
1: 
1: 	/*
1: 		Use this transaction table, which is gotten from a checkpoint
1: 		operation.  Use ONLY during recovery.
1: 	 */
1: 	public void useTransactionTable(Formatable transactionTable) 
1: 		 throws StandardException 
1: 	{
1: 		if (ttab != null && transactionTable != null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.XACT_TRANSACTION_TABLE_IN_USE);
1:         }
1: 
1: 		if (ttab == null)
1: 		{
1: 			if (transactionTable == null)
1: 				ttab = new TransactionTable();
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					if ((transactionTable instanceof TransactionTable) ==
1: 						false)
1: 					{
1: 						SanityManager.THROWASSERT(
1: 							"using transaction table which is of class " + 
1: 							transactionTable.getClass().getName());
1: 					}
1: 				}
1: 				ttab = (TransactionTable)transactionTable;
1: 			}
1: 		}
1: 		// else transactionTable must be null, if we already have a transaction
1: 		// table, no need to do anything
1: 	}
1: 
1: 	public TransactionInfo[] getTransactionInfo()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(ttab != null, "transaction table is null");
1: 		return ttab.getTransactionInfo();
1: 	}
1: 
1: 
0: 	// @return false, if the Database creation finished
1: 	public boolean inDatabaseCreation()
1: 	{
1: 		return inCreateNoLog;
1: 	}
1: 	
1: 	/*
1: 	 * Return the module providing XAresource interface to the transaction 
1:      * table. 
0:      *
0: 	 * @exception StandardException Standard cloudscape exception policy.
1: 	 */
1: 	public /* XAResourceManager */ Object getXAResourceManager()
1:         throws StandardException
1:     {
1:         if (xa_resource == null)
1:             xa_resource = new XactXAResourceManager(rawStoreFactory, ttab);
1: 
1:         return(xa_resource);
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.xact;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.daemon.DaemonService;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.TransactionInfo;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: 
0: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
0: 
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.store.raw.data.DataFactory;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogFactory;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: 
0: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
0: import org.apache.derby.iapi.store.raw.xact.TransactionId;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.store.raw.xact.XactXAResourceManager;
0: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Hashtable;
0: 
0: public class XactFactory implements TransactionFactory, ModuleControl, ModuleSupportable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	protected static final String USER_CONTEXT_ID        = "UserTransaction";
0: 	protected static final String NESTED_READONLY_USER_CONTEXT_ID = 
0:         "NestedRawReadOnlyUserTransaction";
0: 	protected static final String NESTED_UPDATE_USER_CONTEXT_ID = 
0:         "NestedRawUpdateUserTransaction";
0: 	protected static final String INTERNAL_CONTEXT_ID    = "InternalTransaction";
0: 	protected static final String NTT_CONTEXT_ID         = "NestedTransaction";
0: 
0:  	/*
0: 	** Fields
0: 	*/
0: 
0: 	protected DaemonService rawStoreDaemon;
0: 
0: 	private   UUIDFactory           uuidFactory;
0: 	protected ContextService		contextFactory;
0: 	protected LockFactory           lockFactory;
0: 	protected LogFactory            logFactory;
0: 	protected DataFactory           dataFactory;
0: 	protected RawStoreFactory       rawStoreFactory;
0: 
0: 	public TransactionTable ttab;
0: 	private long	tranId;
0: 	private LockingPolicy[][] lockingPolicies = new LockingPolicy[3][6];
0: 
0: 	private boolean inCreateNoLog = false;	// creating database, no logging
0: 
0: 	private   XAResourceManager xa_resource;
0: 	
0: 	/*
0: 	** Constructor
0: 	*/
0: 
0: 	public XactFactory() {
0: 		super();
0: 	}
0: 
0: 	/*
0: 	** Methods of ModuleControl
0: 	*/
0: 	public boolean canSupport(Properties startParams) {
0: 		return true;
0: 	}
0: 
0: 	public void	boot(boolean create, Properties properties)
0: 		throws StandardException
0: 	{
0: 
0: 		uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 		
0: 		contextFactory = ContextService.getFactory();
0: 
0: 		lockFactory = 
0:             (LockFactory) Monitor.bootServiceModule(false, this,
0: 				org.apache.derby.iapi.reference.Module.LockFactory, properties);
0: 
0: 		
0:         // adding entries to locking policy table which means we support that
0:         // level of concurrency.
0: 		lockingPolicies[LockingPolicy.MODE_NONE]
0:                        [TransactionController.ISOLATION_NOLOCK] =
0:                             new NoLocking();
0: 
0: 		lockingPolicies[LockingPolicy.MODE_RECORD]
0:                        [TransactionController.ISOLATION_NOLOCK] =
0:                             new NoLocking();
0: 		lockingPolicies[LockingPolicy.MODE_RECORD]
0:                        [TransactionController.ISOLATION_READ_UNCOMMITTED] =
0:                             new RowLocking1(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
0:                        [TransactionController.ISOLATION_READ_COMMITTED] =
0:                             new RowLocking2(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
0:                        [TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
0:                             new RowLocking2nohold(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
0:                        [TransactionController.ISOLATION_REPEATABLE_READ] =
0:                             new RowLockingRR(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_RECORD]
0:                        [TransactionController.ISOLATION_SERIALIZABLE] =
0:                             new RowLocking3(lockFactory);
0: 
0: 		lockingPolicies[LockingPolicy.MODE_CONTAINER]
0:                        [TransactionController.ISOLATION_NOLOCK] =
0:                             new NoLocking();
0: 
0:         // note that current implementation of read uncommitted still gets
0:         // container and container intent locks to prevent concurrent ddl.  Thus
0:         // the read uncommitted containerlocking implementation is the same as
0:         // the read committed implementation.  Future customer requests may 
0:         // force us to change this - we will then have to figure out how to
0:         // handle a table being dropped while a read uncommitted scanner is
0:         // reading it - currently we just block that from happening.
0: 		lockingPolicies[LockingPolicy.MODE_CONTAINER]
0:                        [TransactionController.ISOLATION_READ_UNCOMMITTED] =
0:                             new ContainerLocking2(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
0:                        [TransactionController.ISOLATION_READ_COMMITTED] =
0:                             new ContainerLocking2(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
0:                        [TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
0:                             new ContainerLocking2(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
0:                        [TransactionController.ISOLATION_REPEATABLE_READ] =
0:                             new ContainerLocking3(lockFactory);
0: 	    lockingPolicies[LockingPolicy.MODE_CONTAINER]
0:                        [TransactionController.ISOLATION_SERIALIZABLE] =
0:                             new ContainerLocking3(lockFactory);
0: 
0: 
0: 		if (create)
0: 		{
0: 			ttab = new TransactionTable();
0: 
0: 			String noLog =
0: 				properties.getProperty(Property.CREATE_WITH_NO_LOG);
0: 
0: 			inCreateNoLog = (noLog != null && Boolean.valueOf(noLog).booleanValue());
0: 
0: 		}
0: 	}
0: 
0: 	public void	stop() {
0: 
0: 		if (rawStoreDaemon != null)
0: 			rawStoreDaemon.stop();
0: 
0: 	}
0: 
0: 	/*
0: 	** Methods of TransactionFactory
0: 	*/
0: 
0: 	/**
0: 		Get the LockFactory to use with this store.
0: 	*/
0: 	public LockFactory getLockFactory() {
0: 		return lockFactory;
0: 	}
0: 
0: 
0: 	/**
0: 		Database creation finished
0: 		@exception StandardException standard cloudscape error policy
0: 	*/
0: 	public void createFinished() throws StandardException
0: 	{
0: 		if (!inCreateNoLog) 
0:         {
0:             throw StandardException.newException(SQLState.XACT_CREATE_NO_LOG);
0:         }
0: 
0: 		// make sure there is no active update transaction
0: 		if (ttab.hasActiveUpdateTransaction())
0:         {
0:             throw StandardException.newException(SQLState.XACT_CREATE_NO_LOG);
0:         }
0: 
0: 		inCreateNoLog = false;
0: 	}
0: 
0:     /**
0:      * Common work done to create local or global transactions.
0:      *
0:      * @param rsf    the raw store factory creating this xact.
0:      * @param cm     the current context manager to associate the xact with.
0:      * @param compatibilitySpace 
0:      *               if null, use the transaction being created, else if 
0:      *               non-null use this compatibilitySpace.
0:      * @param cm     true if transaction should be waited for and halted 
0:      *               during refresh.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	private RawTransaction startCommonTransaction(
0:     RawStoreFactory rsf,
0:     ContextManager  cm,
0:     boolean         readOnly,
0:     Object          compatibilitySpace,
0:     String          xact_context_id,
0:     String          transName,
0:     boolean         excludeMe)
0:         throws StandardException
0:     {
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (rawStoreFactory != null)
0: 				SanityManager.ASSERT(
0:                     rawStoreFactory == rsf, "raw store factory different");
0: 
0: 				SanityManager.ASSERT(
0:                     cm == contextFactory.getCurrentContextManager());
0: 		}
0: 
0: 		Xact xact = 
0:             new Xact(this, logFactory, dataFactory, readOnly, compatibilitySpace);
0: 
0:         xact.setTransName(transName);
0: 		pushTransactionContext(cm, xact_context_id, xact,
0: 							   false /* abortAll */,
0: 							   rsf,
0: 							   excludeMe /* excludeMe during quiesce state */);
0: 		return xact;
0: 	}
0: 
0: 	public RawTransaction startTransaction(
0:     RawStoreFactory rsf,
0:     ContextManager cm,
0:     String transName)
0:         throws StandardException
0:     {
0:         return(startCommonTransaction(
0:                 rsf, cm, false, null, USER_CONTEXT_ID, transName, true));
0: 	}
0: 
0: 	public RawTransaction startNestedReadOnlyUserTransaction(
0:     RawStoreFactory rsf,
0:     Object          compatibilitySpace,
0:     ContextManager  cm,
0:     String          transName)
0:         throws StandardException
0:     {
0:         return(startCommonTransaction(
0:             rsf, cm, true, compatibilitySpace, 
0:             NESTED_READONLY_USER_CONTEXT_ID, transName, false));
0: 	}
0: 
0: 	public RawTransaction startNestedUpdateUserTransaction(
0:     RawStoreFactory rsf,
0:     ContextManager  cm,
0:     String          transName)
0:         throws StandardException
0:     {
0:         return(startCommonTransaction(
0:             rsf, cm, false, null, 
0:             NESTED_UPDATE_USER_CONTEXT_ID, transName, true));
0: 	}
0: 
0: 	public RawTransaction startGlobalTransaction(
0:     RawStoreFactory rsf,
0:     ContextManager  cm,
0:     int             format_id,
0:     byte[]          global_id,
0:     byte[]          branch_id)
0:         throws StandardException
0:     {
0:         GlobalXactId gid = new GlobalXactId(format_id, global_id, branch_id);
0: 
0:         if (ttab.findTransactionContextByGlobalId(gid) != null)
0:         {
0:             throw StandardException.newException(SQLState.STORE_XA_XAER_DUPID);
0:         }
0: 
0:         RawTransaction xact = 
0:             startCommonTransaction(
0:                 rsf, cm, false, null, 
0:                 USER_CONTEXT_ID, AccessFactoryGlobals.USER_TRANS_NAME, true);
0: 
0:         xact.setTransactionId(gid, xact.getId());
0: 
0:         return(xact);
0: 	}
0: 
0: 
0: 
0: 	public RawTransaction findUserTransaction(
0:     RawStoreFactory rsf,
0:     ContextManager  contextMgr,
0:     String transName)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(
0:                 contextMgr == contextFactory.getCurrentContextManager(),
0:                 "passed in context mgr not the same as current context mgr");
0: 
0: 			if (rawStoreFactory != null)
0: 				SanityManager.ASSERT(
0:                     rawStoreFactory == rsf, "raw store factory different");
0: 		}
0: 
0: 		XactContext xc = (XactContext)contextMgr.getContext(USER_CONTEXT_ID);
0: 		if (xc == null)
0: 			return startTransaction(rsf, contextMgr, transName);
0: 		else
0: 			return xc.getTransaction();
0:  	}
0: 
0: 
0: 	public RawTransaction startNestedTopTransaction(RawStoreFactory rsf, ContextManager cm)
0:         throws StandardException
0:     {
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (rawStoreFactory != null)
0: 				SanityManager.ASSERT(
0:                     rawStoreFactory == rsf, "raw store factory different");
0: 		}
0: 
0: 		Xact xact = 
0:             new Xact(this, logFactory, dataFactory, false, null);
0: 
0: 		// hold latches etc. past commit in NTT
0: 		xact.setPostComplete();
0: 		pushTransactionContext(cm, NTT_CONTEXT_ID, xact, 
0: 							   true /* abortAll */,
0: 							   rsf, 
0: 							   true /* excludeMe during quiesce state*/);
0: 		return xact;
0: 	}
0: 
0: 	public RawTransaction startInternalTransaction(RawStoreFactory rsf, ContextManager cm) 
0:         throws StandardException 
0:     {
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (rawStoreFactory != null)
0: 				SanityManager.ASSERT(
0:                     rawStoreFactory == rsf, "raw store factory different");
0: 		}
0: 
0: 
0: 		Xact xact = new InternalXact(this, logFactory, dataFactory);
0: 		pushTransactionContext(cm, INTERNAL_CONTEXT_ID, xact, 
0: 							   true /* abortAll*/,
0: 							   rsf,
0: 							   true /* excludeMe during quiesce state */);
0: 		return xact;
0: 	}
0: 
0: 	/*
0: 	 * the following TransactionFactory methods are to support recovery and
0: 	 * should only be used by recovery!
0: 	 */
0: 
0: 	/**
0: 		Find the TransactionTableEntry with the given ID and make the passed in
0: 		transaction assume the identity and properties of that
0: 		TransactionTableEntry.
0: 		Used in recovery only.
0: 	*/
0: 	public boolean findTransaction(TransactionId id,  RawTransaction tran)
0: 	{
0: 		return ttab.findAndAssumeTransaction(id, tran);
0: 	}
0: 
0: 
0: 	/**
0: 		Rollback all active transactions that has updated the raw store.
0: 		Use the recovery Transaction that is passed in to do all the work.
0: 		Used in recovery only.
0: 
0: 		<P>
0: 		Transactions are rolled back in the following order:
0: 		<OL>
0: 		<LI>internal transactions in reversed beginXact chronological order,
0: 		<LI>all other transactions in reversed beginXact chronological order,
0: 		</NL>
0: 
0: 		@param recoveryTransaction use this transaction to do all the user 
0:                                    transaction work
0: 
0: 		@exception StandardException any exception thrown during rollback
0: 	*/
0: 	public void rollbackAllTransactions(
0:     RawTransaction  recoveryTransaction,
0:     RawStoreFactory rsf) 
0:         throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (rawStoreFactory != null)
0: 				SanityManager.ASSERT(
0:                     rawStoreFactory == rsf, "raw store factory different");
0: 
0: 			SanityManager.ASSERT(
0:                 recoveryTransaction != null, "recovery transaction null");
0: 		}
0: 
0: 		int irbcount = 0;
0: 
0: 		// First undo internal transactions if there is any
0: 		if (ttab.hasRollbackFirstTransaction())
0: 		{
0: 			RawTransaction internalTransaction = startInternalTransaction(rsf,
0: 				recoveryTransaction.getContextManager());
0: 
0: 			// make this transaction be aware that it is being used by recovery
0: 			internalTransaction.recoveryTransaction();
0: 
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(
0:                     internalTransaction.handlesPostTerminationWork() == false,
0:                     "internal recovery xact handles post termination work");
0: 
0: 			while(ttab.getMostRecentRollbackFirstTransaction(
0:                                                 internalTransaction))
0: 			{
0: 				irbcount++;
0: 				internalTransaction.abort();
0: 			}
0: 
0: 			internalTransaction.close();
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(
0:                 ttab.hasRollbackFirstTransaction() == false,
0:                 "cant rollback user xacts with existing active internal xacts");
0: 		}
0: 
0: 		int rbcount = 0;
0: 
0: 		// recoveryTransacion assumes the identity of the most recent xact
0: 		while(ttab.getMostRecentTransactionForRollback(recoveryTransaction))
0: 		{
0: 			if (SanityManager.DEBUG)
0:             {
0: 				SanityManager.ASSERT(
0:                     recoveryTransaction.handlesPostTerminationWork() == false,
0:                     "recovery transaction handles post termination work");
0:             }
0: 
0: 			rbcount++;
0: 			recoveryTransaction.abort();
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (rbcount > 0 || irbcount > 0)
0: 			{
0: 				// RESOLVE: put this in the log trace
0: 				//	System.out.println(
0:                 //	    "Recovery rolled back " + irbcount + 
0:                 //	    " internal transactions,"
0: 				//			+ rbcount + " user transactions");
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 
0: 	/**
0:         Run through all prepared transactions known to this factory 
0:         and restore their state such that they remain after recovery, and
0:         can be found and handled by a XA transaction manager.  This includes
0:         creating a context manager for each, pushing a xact context, and
0:         reclaiming update locks on all data changed by the transaction.
0: 
0:         Expected to be called just after the redo and undo recovery loops, 
0:         where the transaction table should be empty except for prepared
0:         xacts.
0: 
0: 		Used only in recovery.
0: 
0: 		@exception StandardException Cloudscape Standard Error policy
0: 	*/
0: 	public void handlePreparedXacts(
0:     RawStoreFactory rsf)
0:         throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 
0: 			if (rawStoreFactory != null)
0: 				SanityManager.ASSERT(
0:                     rawStoreFactory == rsf, "raw store factory different");
0: 		}
0: 
0:         int prepared_count = 0;
0: 
0: 		if (ttab.hasPreparedRecoveredXact())
0: 		{
0:             // if there any prepared xacts 
0: 
0:             // At this point recovery has used one context and one transaction
0:             // to deal with all transactions.  Prepared transactions are to
0:             // be left in the transaction table, but the must have real and
0:             // separate CM's and transactions associated with them.
0: 
0:             // save old context.  Errors may go to funky contexts (the new
0:             // context we created to bring the prepared transaction into the
0:             // real world after recovery) after we switch contexts, but any 
0:             // error we get at this point is going to shut down the db.
0: 
0:             while (true)
0:             {
0:                 // allocate new context and associate new xact with it.
0:                 ContextManager cm      = contextFactory.newContextManager();
0:                 contextFactory.setCurrentContextManager(cm);
0: 
0: 				try {
0:                 RawTransaction rawtran = 
0:                     startTransaction(
0:                         rawStoreFactory, cm, 
0:                         AccessFactoryGlobals.USER_TRANS_NAME);
0: 
0:                 if (ttab.getMostRecentPreparedRecoveredXact(rawtran))
0:                 {
0:                     // found a prepared xact.  The reprepare() call will 
0:                     // accumulate locks, and change the transaction table entry
0:                     // to not be "in-recovery" so that it won't show up again.
0:                     rawtran.reprepare();
0: 
0:                     if (SanityManager.DEBUG)
0:                         prepared_count++;
0:                 }
0:                 else
0:                 {
0:                     // get rid of last transaction allocated.
0:                     rawtran.destroy();
0:                     break;
0:                 }
0: 				}
0: 				finally
0: 				{
0: 					 contextFactory.resetCurrentContextManager(cm);
0: 				}
0:             }
0: 
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0:             // RESOLVE - need to only do this under a debug flag.
0:             // SanityManager.DEBUG_PRINT("",
0:             // "Recovery re-prepared " + prepared_count + " xa transactions.");
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 		Get the earliest log instant that is still active, ie, the first log
0: 		record logged by the earliest transaction that is still active.
0: 		<BR>
0: 		The logging system must guarentee that the transaction table is
0: 		populated in the order transactions are started.
0: 		Used in recovery only.
0: 	*/
0: 
0: 	public LogInstant firstUpdateInstant()
0: 	{
0: 		return ttab.getFirstLogInstant();
0: 	}
0: 
0: 	/*
0: 	** Methods of Corruptable
0: 	*/
0: 
0: 	/**
0: 		Really this is just a convience routine for callers that might not
0: 		have access to a log factory.
0: 	*/
0: 	public StandardException markCorrupt(StandardException originalError) {
0: 		logFactory.markCorrupt(originalError);
0: 		return originalError;
0: 	}
0: 
0: 	/*
0: 	**		Implementation specific methods.
0: 	*/
0: 
0: 	public void setNewTransactionId(TransactionId oldxid, Xact t)
0: 	{
0: 		XactId xid;
0: 		boolean excludeMe = true; // by default
0: 
0: 		if (oldxid != null)
0: 			excludeMe = remove(oldxid);
0: 
0: 		synchronized(this)
0: 		{
0: 			xid = new XactId(tranId++);
0: 		}
0: 
0: 		t.setTransactionId(t.getGlobalId(), xid);
0: 
0: 		// RESOLVE: How does a real global xact id get set?
0: 
0: 		// If we got rid of the oldxid, that means this transaction object has
0: 		// merely committed and starting the next transaction with the same
0: 		// xact object.  In that case, the transaction context will remain the
0: 		// same and won't be pushed.  We need to add this transaction with the
0: 		// new id back into the transaction table.  If we did not get rid of
0: 		// the old oldxid, that means this is a brand new transaction being
0: 		// created.  The pushTransactionContext call will add it to the
0: 		// transaction table with the appropriate flags
0: 		if (oldxid != null)
0: 			add(t, excludeMe);
0: 	}
0: 
0: 	/*
0: 	**	Set the shortTranId, this is called by the log factory after recovery
0: 	*/
0: 	public void resetTranId()
0: 	{
0: 		XactId xid = (XactId)ttab.largestUpdateXactId();
0: 		if (xid != null)
0: 			tranId = xid.getId() + 1;
0: 		else
0: 			tranId = 1;
0: 	}
0: 
0: 
0: 	/**
0: 		Create a new RawTransaction, a context for it and push the context
0: 		onto the current context manager.  Then add the transacion to the
0: 		transaction table.
0: 
0: 		@param contextName the name of the transaction context
0: 		@param xact the Transaction object
0: 		@param abortAll if true, then any error will abort the whole
0: 		transaction.  Otherwise, let XactContext.cleanupOnError decide what to
0: 		do
0: 		@param rsf the raw store factory
0: 		@param excludeMe during systeme quiesce, i.e., this transaction should
0: 		not be allowed to be active during a quiesce state.
0: 
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 	*/
0: 	protected void pushTransactionContext(ContextManager cm, String contextName, 
0: 										  Xact xact,
0: 										  boolean abortAll, 
0: 										  RawStoreFactory rsf,
0: 										  boolean excludeMe)
0: 		 throws StandardException 
0: 	{
0: 		if (cm.getContext(contextName) != null)	
0:         {
0:             throw StandardException.newException(
0:                     SQLState.XACT_TRANSACTION_ACTIVE);
0:         }
0: 		
0: 		XactContext xc = new XactContext(cm, contextName, xact, abortAll, rsf);
0: 
0: 		// this transaction is now added to the transaction table.
0: 		// This will cause an idle transaction to take on an identity, which is
0: 		// unfortunate.  The reason why we have to add the transaction to the
0: 		// table right now is because the transaction table is used to bring
0: 		// system  to quisce state to  regulate who can go active during quiesce
0: 		// state, and if we add the transaction
0: 		// when it goes active, then there is a window where this transaction
0: 		// can sneak in.  The transaction table itself does not keep track of
0: 		// whether transactions can be started or not because quiesce related
0: 		// transactions can start after all other user
0: 		// transactions are excluded.  
0: 		// RESOLVE: need to put more thought on the overall requirement and
0: 		// design of the transaction table that satisfies the need of all the
0: 		// clients, namely: checkpoint, recovery, quiesce mode, transaction table.
0: 
0: 		add(xact, excludeMe);
0: 
0: 	}
0: 
0: 	/**
0: 		Add a transaction to the list of transactions that has updated
0: 		the raw store.  
0: 		<P>
0: 		This is called underneath the BeginXact log operation's doMe method.
0: 		The logging system must guarentee that transactions are added in the
0: 		true order they are started, as defined by the order of beginXact log
0: 		record in the log.
0: 	*/
0: 	protected void addUpdateTransaction(
0:     TransactionId   id, 
0:     RawTransaction  t, 
0:     int             transactionStatus)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(
0:                 id != null, "addding update transaction with null id");
0: 
0: 		ttab.addUpdateTransaction(id, t, transactionStatus);
0: 	}
0: 
0: 	/**
0: 		Remove a transaction from the list of transactions that has updated the
0: 		raw store.
0: 	*/
0: 	protected void removeUpdateTransaction(TransactionId id)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(
0:                 id != null, "remove update transaction with null id");
0: 
0: 		ttab.removeUpdateTransaction(id);
0: 	} 
0: 
0: 	/**
0:         Change state of transaction to prepared.  Used by recovery to update
0:         the transaction table entry to prepared state.
0: 	*/
0: 	protected void prepareTransaction(TransactionId id)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(
0:                 id != null, "prepare transaction with null id");
0: 
0: 		ttab.prepareTransaction(id);
0: 	} 
0: 
0: 	/**
0: 		Submit this post commit work to the post commit daemon
0: 	*/
0: 	public boolean submitPostCommitWork(Serviceable work)
0: 	{
0: 		if (rawStoreDaemon != null)
0: 			return rawStoreDaemon.enqueue(work, work.serviceASAP());
0: 		return false;
0: 	}
0: 
0: 	public void setRawStoreFactory(RawStoreFactory rsf) throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(rsf != null, "rawStoreFactory == null");
0: 		}
0: 
0: 		rawStoreFactory = rsf;
0: 
0: 		// no need to remember raw store factory, 
0: 		// just remember which daemon to use
0: 		rawStoreDaemon = rsf.getDaemon();
0: 
0: 		// now its ok to look for the log and data factory
0: 		// log factory is booted by the data factory
0: 		logFactory = (LogFactory) Monitor.findServiceModule(this, rsf.getLogFactoryModule());
0: 
0: 		// data factory is booted by the raw store implementation
0: 		dataFactory = (DataFactory) Monitor.findServiceModule(this, rsf.getDataFactoryModule());
0: 	}
0: 
0: 	/**
0: 		Returns true if there is no in flight updating tranasaction.
0: 		Caller must be aware that if there is no other mechanism to stop
0: 		transactions from starting and ending, then this information is
0: 		outdated as soon as it is reported.
0: 
0: 		Only call this function in special times - e.g, during recovery
0: 	*/
0: 	public boolean noActiveUpdateTransaction()
0: 	{
0: 		return (ttab.hasActiveUpdateTransaction() == false);
0: 	}
0: 
0: 	/*
0: 		remove the transaction Id an return false iff the transaction is found
0: 		in the table and it doesn't need exclusion from quiesce state
0: 	 */
0: 	protected boolean remove(TransactionId xactId)
0: 	{
0: 		return ttab.remove(xactId);
0: 	}
0: 
0: 	protected void add(Xact xact, boolean excludeMe)
0: 	{
0: 		ttab.add(xact, excludeMe);
0: 	}
0: 
0: 
0: 	/**
0: 		Make a new UUID for whomever that wants it
0: 	*/
0: 	public UUID makeNewUUID()
0: 	{
0: 		return uuidFactory.createUUID();
0: 	}
0: 
0: 	/**
0: 		Decide if a transaction of this contextId needs to flush the log when
0: 		it commits
0: 	*/
0: 	public boolean flushLogOnCommit(String contextName)
0: 	{
0: 		//
0: 		// if this is a user transaction, flush the log
0: 		// if this is an internal or nested top transaction, do not
0: 		// flush, let it age out.
0: 		//
0: 		return (contextName == USER_CONTEXT_ID || 
0: 				contextName.equals(USER_CONTEXT_ID));
0: 	}
0: 
0: 
0: 	/**
0: 		Get a locking policy for a transaction.
0: 	*/
0: 	final LockingPolicy getLockingPolicy(
0:     int     mode, 
0:     int     isolation, 
0:     boolean stricterOk)
0:     {
0: 
0: 		if (mode == LockingPolicy.MODE_NONE)
0: 			isolation = TransactionController.ISOLATION_NOLOCK;
0: 
0: 		LockingPolicy policy = lockingPolicies[mode][isolation];
0: 
0: 		if ((policy != null) || (!stricterOk))
0: 			return policy;
0: 
0: 		for (mode++; mode <= LockingPolicy.MODE_CONTAINER; mode++) 
0:         {
0: 			for (int i = isolation; 
0:                  i <= TransactionController.ISOLATION_SERIALIZABLE; 
0:                  i++) 
0:             {
0: 				policy = lockingPolicies[mode][i];
0: 				if (policy != null)
0: 					return policy;
0: 			}
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/*
0: 		Return the transaction table to be logged with the checkpoint operation
0: 	 */
0: 	public Formatable getTransactionTable()
0: 	{
0: 		return ttab;
0: 	}
0: 
0: 	/*
0: 		Use this transaction table, which is gotten from a checkpoint
0: 		operation.  Use ONLY during recovery.
0: 	 */
0: 	public void useTransactionTable(Formatable transactionTable) 
0: 		 throws StandardException 
0: 	{
0: 		if (ttab != null && transactionTable != null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.XACT_TRANSACTION_TABLE_IN_USE);
0:         }
0: 
0: 		if (ttab == null)
0: 		{
0: 			if (transactionTable == null)
0: 				ttab = new TransactionTable();
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if ((transactionTable instanceof TransactionTable) ==
0: 						false)
0: 					{
0: 						SanityManager.THROWASSERT(
0: 							"using transaction table which is of class " + 
0: 							transactionTable.getClass().getName());
0: 					}
0: 				}
0: 				ttab = (TransactionTable)transactionTable;
0: 			}
0: 		}
0: 		// else transactionTable must be null, if we already have a transaction
0: 		// table, no need to do anything
0: 	}
0: 
0: 	public TransactionInfo[] getTransactionInfo()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(ttab != null, "transaction table is null");
0: 		return ttab.getTransactionInfo();
0: 	}
0: 
0: 
0: 	// @return false, if the Database creation finished
0: 	public boolean inDatabaseCreation()
0: 	{
0: 		return inCreateNoLog;
0: 	}
0: 	
0: 	/*
0: 	 * Return the module providing XAresource interface to the transaction 
0:      * table. 
0:      *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public /* XAResourceManager */ Object getXAResourceManager()
0:         throws StandardException
0:     {
0:         if (xa_resource == null)
0:             xa_resource = new XactXAResourceManager(rawStoreFactory, ttab);
0: 
0:         return(xa_resource);
0:     }
0: }
============================================================================