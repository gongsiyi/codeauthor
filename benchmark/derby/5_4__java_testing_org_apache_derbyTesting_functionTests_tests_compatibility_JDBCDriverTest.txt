1:a69fa12: /*
6:a69fa12: 
1:a69fa12:    Derby - Class org.apache.derbyTesting.functionTests.tests.compatibility.JDBCDriverTest
1:a69fa12: 
1:a69fa12:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a69fa12:    contributor license agreements.  See the NOTICE file distributed with
1:a69fa12:    this work for additional information regarding copyright ownership.
1:a69fa12:    The ASF licenses this file to you under the Apache License, Version 2.0
1:a69fa12:    (the "License"); you may not use this file except in compliance with
1:a69fa12:    the License.  You may obtain a copy of the License at
1:a69fa12: 
1:a69fa12:       http://www.apache.org/licenses/LICENSE-2.0
1:a69fa12: 
1:a69fa12:    Unless required by applicable law or agreed to in writing, software
1:a69fa12:    distributed under the License is distributed on an "AS IS" BASIS,
1:a69fa12:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a69fa12:    See the License for the specific language governing permissions and
1:a69fa12:    limitations under the License.
1:a69fa12: 
1:a69fa12:  */
1:a69fa12: package org.apache.derbyTesting.functionTests.tests.compatibility;
1:a69fa12: 
1:a69fa12: import java.io.ByteArrayInputStream;
1:a69fa12: import java.math.BigDecimal;
1:a69fa12: import java.sql.Connection;
1:a69fa12: import java.sql.DatabaseMetaData;
1:a69fa12: import java.sql.ParameterMetaData;
1:a69fa12: import java.sql.PreparedStatement;
1:a69fa12: import java.sql.ResultSet;
1:a69fa12: import java.sql.ResultSetMetaData;
1:a69fa12: import java.sql.SQLException;
1:a69fa12: import java.sql.Statement;
1:a69fa12: import java.sql.Time;
1:a69fa12: import java.sql.Timestamp;
1:a69fa12: import java.sql.Types;
1:a69fa12: import java.util.HashMap;
1:a69fa12: import java.util.regex.Pattern;
1:a69fa12: import junit.framework.Test;
1:a69fa12: import org.apache.derbyTesting.functionTests.tests.compatibility.helpers.DummyBlob;
1:a69fa12: import org.apache.derbyTesting.functionTests.tests.compatibility.helpers.DummyClob;
1:a69fa12: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a69fa12: import org.apache.derbyTesting.junit.DerbyVersion;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:a69fa12: 
1:a69fa12: /**
1:a69fa12:  * A set of client driver compatibility tests.
1:a69fa12:  */
1:a69fa12: public class JDBCDriverTest
1:a69fa12:     extends AbstractCompatibilityTest {
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    CONSTANTS
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     private    static    final        String    ALL_TYPES_TABLE = "allTypesTable";
1:a69fa12:     private    static    final        String    KEY_COLUMN = "keyCol";
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Data values to be stuffed into columns of ALL_TYPES_TABLE.
1:a69fa12:     //
1:a69fa12:     private    static    final        byte[]    SAMPLE_BYTES =
1:a69fa12:         new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5 };
1:a69fa12:     private    static    final        String    SAMPLE_STRING = "hello";
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // These funny constants are defined this way to make the salient
1:a69fa12:     // facts of the COERCIONS table leap out at you.
1:a69fa12:     //
1:a69fa12:     private    static    final        boolean    Y = true;
1:ca48ab4:     private    static    final        boolean    n = false;
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // This table declares the datatypes supported by Derby and the earliest
1:a69fa12:     // versions of the Derby client which support these datatypes.
1:a69fa12:     //
1:a69fa12:     // If you add a type to this table, make sure you add a corresponding
1:a69fa12:     // column to the following row table. Also add a corresponding row to the
1:a69fa12:     // COERCIONS table.
1:a69fa12:     //
1:a69fa12:     private    static    final    TypeDescriptor[]    ALL_TYPES =
1:a69fa12:     {
1:a69fa12:         // 10.0 types
1:a69fa12: 
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.BIGINT,         "bigint",                   DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.BLOB,           "blob",                     DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.CHAR,           "char(5)",                  DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.BINARY,         "char(5) for bit data",     DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.CLOB,           "clob",                     DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.DATE,           "date",                     DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.DECIMAL,        "decimal",                  DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.DOUBLE,         "double",                   DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.DOUBLE,         "double precision",         DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.REAL,           "float(23)",                DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.DOUBLE,         "float",                    DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.INTEGER,        "integer",                  DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.LONGVARCHAR,    "long varchar",             DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.LONGVARBINARY,  "long varchar for bit data",DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.NUMERIC,        "numeric",                  DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.REAL,           "real",                     DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.SMALLINT,       "smallint",                 DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.TIME,           "time",                     DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.TIMESTAMP,      "timestamp",                DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.VARCHAR,        "varchar(5)",               DerbyVersion._10_0),
1:a69fa12:         new TypeDescriptor
1:a69fa12:         ( Types.VARBINARY,      "varchar(5) for bit data",  DerbyVersion._10_0),
1:a69fa12:     };
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // This table needs to have the same number of entries as ALL_TYPES.
1:a69fa12:     // The testSanity() test case enforces this at run time.
1:a69fa12:     //
1:a69fa12:     private    static    final    Object[]    ROW_1 =
1:a69fa12:     {
1:a69fa12:         // 10.0 columns
1:a69fa12: 
1:39b3237:         1L,
1:a69fa12:         new DummyBlob( SAMPLE_BYTES ),
1:a69fa12:         SAMPLE_STRING,
1:a69fa12:         SAMPLE_BYTES,
1:a69fa12:         new DummyClob( SAMPLE_STRING ),
1:a69fa12:         new java.sql.Date( 1L ),
1:a69fa12:         new BigDecimal( 1.0 ),
1:39b3237:         1.0,
1:39b3237:         1.0,
1:39b3237:         (float) 1.0,
1:39b3237:         1.0,
1:39b3237:         1,
1:a69fa12:         SAMPLE_STRING,
1:a69fa12:         SAMPLE_BYTES,
1:a69fa12:         new BigDecimal( 1.0 ),
1:39b3237:         (float) 1.0,
1:39b3237:         (short) 1,
1:a69fa12:         new Time( 1L ),
1:a69fa12:         new Timestamp( 1L ),
1:a69fa12:         SAMPLE_STRING,
1:a69fa12:         SAMPLE_BYTES,
1:a69fa12:     };
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // This table needs to have the same number of rows as ALL_TYPES.
1:a69fa12:     // Each row in this table needs to have the same number of columns as
1:a69fa12:     // rows in ALL_TYPES. The testSanity() test case enforces this at run time.
1:a69fa12:     // Note how the funny synonyms for true and false
1:a69fa12:     // make the salient facts of this table leap out at you.
1:a69fa12:     //
1:a69fa12:     // The ugly class name T_CN is an abbreviation which makes it possible to
1:a69fa12:     // squeeze this table onto a readable screen.
1:a69fa12:     //
1:a69fa12:     // Please read the introductory comment top-to-bottom. 'Y' means a coercion
1:a69fa12:     // is legal; '_' means it isn't.
1:a69fa12:     //
1:a69fa12:     private    static    final    T_CN[]    COERCIONS =
1:a69fa12:     {
1:a69fa12:         //                                                  B|B|C|B|C|D|D|D|R|I|L|L|N|R|S|T|T|V|V
1:a69fa12:         //                                                  I|L|H|I|L|A|E|O|E|N|O|O|U|E|M|I|I|A|A
1:a69fa12:         //                                                  G|O|A|N|O|T|C|U|A|T|N|N|M|A|A|M|M|R|R
1:a69fa12:         //                                                  I|B|R|A|B|E|I|B|L|E|G|G|E|L|L|E|E|C|B
1:a69fa12:         //                                                  N|-|-|R|-|-|M|L|-|G|V|V|R|-|L|-|S|H|I
1:a69fa12:         //                                                  T|-|-|Y|-|-|A|E|-|E|A|A|I|-|I|-|T|A|N
1:a69fa12:         //                                                  -|-|-|-|-|-|L|-|-|R|R|R|C|-|N|-|A|R|A
1:a69fa12:         //                                                  -|-|-|-|-|-|-|-|-|-|C|B|-|-|T|-|M|-|R
1:a69fa12:         //                                                  -|-|-|-|-|-|-|-|-|-|H|I|-|-|-|-|P|-|Y
1:a69fa12:         //                                                  -|-|-|-|-|-|-|-|-|-|A|N|-|-|-|-|-|-|-
1:a69fa12:         //                                                  -|-|-|-|-|-|-|-|-|-|R|A|-|-|-|-|-|-|-
1:a69fa12:         //                                                  -|-|-|-|-|-|-|-|-|-|-|R|-|-|-|-|-|-|-
1:a69fa12:         //                                                  -|-|-|-|-|-|-|-|-|-|-|Y|-|-|-|-|-|-|-
1:ca48ab4:         new T_CN( Types.BIGINT, new boolean[]             { Y,n,Y,n,n,n,n,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.BLOB, new boolean[]               { n,Y,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n } ),
1:ca48ab4:         new T_CN( Types.CHAR, new boolean[]               { n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.BINARY, new boolean[]             { n,n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y } ),
1:ca48ab4:         new T_CN( Types.CLOB, new boolean[]               { n,n,n,n,Y,n,n,n,n,n,n,n,n,n,n,n,n,n,n } ),
1:ca48ab4:         new T_CN( Types.DATE, new boolean[]               { n,n,n,n,n,Y,n,n,n,n,n,n,n,n,n,n,n,n,n } ),
1:ca48ab4:         new T_CN( Types.DECIMAL, new boolean[]            { Y,n,n,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.DOUBLE, new boolean[]             { Y,n,n,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.REAL, new boolean[]               { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.INTEGER, new boolean[]            { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.LONGVARCHAR, new boolean[]        { n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.LONGVARBINARY, new boolean[]      { n,n,n,n,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y } ),
1:ca48ab4:         new T_CN( Types.NUMERIC, new boolean[]            { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.REAL, new boolean[]               { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.SMALLINT, new boolean[]           { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.TIME, new boolean[]               { n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,Y,n,n,n } ),
1:ca48ab4:         new T_CN( Types.TIMESTAMP, new boolean[]          { n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,Y,n,n } ),
1:ca48ab4:         new T_CN( Types.VARCHAR, new boolean[]            { n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y,n } ),
1:ca48ab4:         new T_CN( Types.VARBINARY, new boolean[]          { n,n,n,n,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y } ),
1:a69fa12:     };
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    STATE
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     // map derby type name to type descriptor
1:ffa2d1b:     private    static    HashMap<String,TypeDescriptor>        _types = new HashMap<String,TypeDescriptor>();
1:a69fa12: 
1:a69fa12:     // map jdbc type to index into COERCIONS
1:ffa2d1b:     private    static    HashMap<Integer,Integer>        _coercionIndex = new HashMap<Integer,Integer>();
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    CONSTRUCTOR
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     public JDBCDriverTest(String name) {
1:a69fa12:         super(name);
2:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    TEST ENTRY POINTS
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Sanity check the integrity of this test suite.
1:a69fa12:      */
1:a69fa12:     public void testSanity()
1:a69fa12:     {
1:a69fa12:         assertEquals("ALL_TYPES.length == ROW_1.length",
1:a69fa12:                 ALL_TYPES.length, ROW_1.length );
1:a69fa12: 
1:a69fa12:         // make sure we completely describe the coercibility of every jdbc type
1:a69fa12:         int coercionCount = COERCIONS.length;
1:a69fa12:         for ( int i = 0; i < coercionCount; i++ ) {
1:a69fa12:             assertEquals("Coercion " + i,
1:a69fa12:                     coercionCount, COERCIONS[ i ].getCoercions().length );
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     public void testVerifyVersions()
1:a69fa12:             throws SQLException {
1:a69fa12:         DerbyVersion server = getServerVersion();
1:a69fa12:         DerbyVersion client = getDriverVersion();
1:a69fa12:         println("server=" + server.toString() + " <-> client=" +
1:a69fa12:                 client.toString());
1:a69fa12:         String expS = getSystemProperty("derby.tests.compat.expectedServer");
1:a69fa12:         String expC = getSystemProperty("derby.tests.compat.expectedClient");
1:a69fa12:         assertNotNull("expected server property missing", expS);
1:a69fa12:         assertNotNull("expected client property missing", expC);
1:a69fa12:         DerbyVersion expectedServer = DerbyVersion.parseVersionString(expS);
1:a69fa12:         DerbyVersion expectedClient = DerbyVersion.parseVersionString(expC);
1:a69fa12:         assertEquals("server version mismatch", expectedServer, server);
1:a69fa12:         assertEquals("client version mismatch", expectedClient, client);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Tests compatibility for the available data types.
1:a69fa12:      */
1:a69fa12:     public void testDataTypesCompatibility() throws SQLException {
1:a69fa12:         datatypesTest();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    DERBY-4613
1:a69fa12:     //
1:a69fa12:     // Make sure embedded and network clients treat BOOLEAN values identically.
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Verify that embedded and network clients handle BOOLEAN values the
1:a69fa12:      * same way from release 10.7 onward.
1:a69fa12:      */
1:a69fa12:     public void testDerby4613(Connection conn)
1:a69fa12:         throws Exception
1:a69fa12:     {
1:a69fa12:         boolean correctBehavior =
1:a69fa12:                 getServerVersion().atLeast( DerbyVersion._10_7 ) &&
1:a69fa12:                 getDriverVersion().atLeast( DerbyVersion._10_7 );
1:a69fa12:         println( "derby_4613_test correctBehavior = " + correctBehavior );
1:a69fa12: 
1:a69fa12:         vet_isindex_column(correctBehavior, "SYSTABLES_HEAP", false);
1:a69fa12:         vet_isindex_column(correctBehavior, "SYSTABLES_INDEX1", true);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Vet boolean results.
1:a69fa12:      */
1:a69fa12:     private void vet_isindex_column(boolean correctBehavior,
1:a69fa12:                                     String conglomerateName,
1:a69fa12:                                     boolean expectedValue)
1:a69fa12:             throws Exception
1:a69fa12:     {
1:a69fa12:         PreparedStatement ps = prepareStatement(
1:a69fa12:                 "select isindex from sys.sysconglomerates " +
1:a69fa12:                 "where conglomeratename = ?");
1:a69fa12:         ps.setString( 1, conglomerateName );
1:a69fa12:         ResultSet rs = ps.executeQuery();
1:a69fa12:         ResultSetMetaData rsmd = rs.getMetaData();
1:a69fa12: 
1:a69fa12:         int jdbcType = correctBehavior ? Types.BOOLEAN : Types.SMALLINT;
1:a69fa12:         String typeName = correctBehavior ? "BOOLEAN" : "SMALLINT";
1:a69fa12:         int precision = correctBehavior ? 1 : 5;
1:a69fa12:         int scale = 0;
1:a69fa12:         int columnDisplaySize = correctBehavior ? 5 : 6;
1:a69fa12:         String columnClassName = correctBehavior ? "java.lang.Boolean"
1:a69fa12:                                                  : "java.lang.Integer";
1:a69fa12: 
1:a69fa12:         Object objectValue;
1:a69fa12:         if ( correctBehavior )
1:a69fa12:         {
1:a69fa12:             objectValue = Boolean.valueOf(expectedValue);
1:a69fa12:         }
1:a69fa12:         else
1:a69fa12:         {
1:39b3237:             objectValue = expectedValue ? 1 : 0;
1:a69fa12:         }
1:a69fa12:         String stringValue = objectValue.toString();
1:a69fa12: 
1:a69fa12:         assertEquals( jdbcType, rsmd.getColumnType( 1 ) );
1:a69fa12:         assertEquals( typeName, rsmd.getColumnTypeName( 1 ) );
1:a69fa12:         assertEquals( precision, rsmd.getPrecision( 1 ) );
1:a69fa12:         assertEquals( scale, rsmd.getScale( 1 ) );
1:a69fa12:         assertEquals( columnDisplaySize, rsmd.getColumnDisplaySize( 1 ) );
1:a69fa12:         assertEquals( columnClassName, rsmd.getColumnClassName( 1 ) );
1:a69fa12: 
1:a69fa12:         assertEquals( true, rs.next() );
1:a69fa12: 
1:a69fa12:         assertEquals( expectedValue, rs.getBoolean( 1 ) );
1:a69fa12:         assertEquals( objectValue, rs.getObject( 1 ) );
1:a69fa12:         assertEquals( stringValue, rs.getString( 1 ) );
1:a69fa12: 
1:a69fa12:         rs.close();
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    DERBY-2602
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Verifies that timestamps retain their nanosecond-precision
1:a69fa12:      * across the network from release 10.6 onward.
1:a69fa12:      */
1:a69fa12:     public void testDerby2602() throws SQLException {
1:a69fa12:         //
1:a69fa12:         // We must expect truncation of timestamps in a network configuration
1:a69fa12:         // unless both the client and the server are at 10.6 or higher.
1:a69fa12:         // See DERBY-2602.
1:a69fa12:         //
1:a69fa12:         boolean correctBehavior =
1:a69fa12:                 getServerVersion().atLeast( DerbyVersion._10_6 ) &&
1:a69fa12:                 getDriverVersion().atLeast( DerbyVersion._10_6 );
1:a69fa12: 
1:a69fa12:         Timestamp ts = Timestamp.valueOf("2004-02-14 17:14:24.976255123");
1:a69fa12:         PreparedStatement    insert = prepareStatement(
1:a69fa12:                 "insert into t_2602( a ) values ( ? )");
1:a69fa12:         insert.setTimestamp(1,ts);
1:a69fa12:         insert.executeUpdate();
1:a69fa12:         insert.close();
1:a69fa12: 
1:a69fa12:         PreparedStatement    select = prepareStatement("select a from t_2602" );
1:a69fa12:         ResultSet selectRS = select.executeQuery();
1:a69fa12:         selectRS.next();
1:a69fa12:         Timestamp resultTS = selectRS.getTimestamp( 1 );
1:a69fa12:         int resultNanos = resultTS.getNanos();
1:a69fa12: 
1:a69fa12:         int expectedResult = correctBehavior ? 976255123  : 976255000;
1:a69fa12:         assertEquals( expectedResult, resultNanos );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Test case for DERBY-4888. Check that we can call DatabaseMetaData
1:a69fa12:      * methods returning a boolean without errors.
1:a69fa12:      */
1:a69fa12:     public void testDerby4888() throws SQLException {
1:a69fa12:         // Used to get a ClassCastException here in some combinations.
1:a69fa12:         assertFalse(getConnection().getMetaData().storesLowerCaseIdentifiers());
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * A pattern that matches the value returned by
1:a69fa12:      * DatabaseMetaData.getDriverVersion() for the versions that suffer
1:a69fa12:      * from DERBY-5449. That is, all version on the 10.8 branch up to 10.8.2.2.
1:a69fa12:      */
1:a69fa12:     private static Pattern DERBY_5449_PATTERN = Pattern.compile(
1:a69fa12:             "^10\\.8\\.([01]\\.|2\\.[012] ).*");
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Test case for DERBY-5449. Verify that PreparedStatement.setBoolean()
1:a69fa12:      * works across different versions. Used to fail with a ClassCastException
1:a69fa12:      * when talking to servers at version 10.7 and earlier.
1:a69fa12:      */
1:a69fa12:     public void testDerby5449() throws SQLException {
1:a69fa12:         if (getServerVersion().compareTo(DerbyVersion._10_7) <= 0) {
1:a69fa12:             // Derby's client drivers on the 10.8 branch up to 10.8.2.2
1:a69fa12:             // suffered from DERBY-5449 and the test case will fail when
1:a69fa12:             // talking to older servers. Skip the test case in such cases.
1:a69fa12:             String driverVersion =
1:a69fa12:                     getConnection().getMetaData().getDriverVersion();
1:a69fa12:             if (DERBY_5449_PATTERN.matcher(driverVersion).matches()) {
1:a69fa12:                 return;
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         PreparedStatement ps = prepareStatement("VALUES CAST(? AS INTEGER)");
1:a69fa12:         ps.setBoolean(1, true);
1:a69fa12:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:a69fa12:         ps.setBoolean(1, false);
1:a69fa12:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "0");
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    TEST UDTs
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Verify the metadata for user defined types.
1:a69fa12:      */
1:a69fa12:     public void testUDT() throws Exception
1:a69fa12:     {
1:a69fa12:         //
1:a69fa12:         // We must expect the wrong metadata in a network configuration
1:a69fa12:         // unless both the client and the server are at 10.6 or higher.
1:a69fa12:         // See DERBY-4491.
1:a69fa12:         //
1:a69fa12:         boolean correctBehavior =
1:a69fa12:              getServerVersion().atLeast( DerbyVersion._10_6 ) &&
1:a69fa12:              getDriverVersion().atLeast( DerbyVersion._10_6 );
1:a69fa12: 
1:a69fa12:         String query = "select aliasinfo from sys.sysaliases";
1:a69fa12: 
1:a69fa12:         if ( correctBehavior )
1:a69fa12:         {
1:a69fa12:             String aliasInfoClassName = "org.apache.derby.catalog.AliasInfo";
1:a69fa12: 
1:a69fa12:             checkRSMD
1:a69fa12:                 (
1:a69fa12:                  query,
1:a69fa12:                  aliasInfoClassName,
1:a69fa12:                  15,
1:a69fa12:                  java.sql.Types.JAVA_OBJECT,
1:a69fa12:                  aliasInfoClassName,
1:a69fa12:                  0,
1:a69fa12:                  0
1:a69fa12:                  );
1:a69fa12:         }
1:a69fa12:         else
1:a69fa12:         {
1:a69fa12:             checkRSMD
1:a69fa12:                 (
1:a69fa12:                  query,
1:a69fa12:                  "byte[]",
1:a69fa12:                  65400,
1:a69fa12:                  java.sql.Types.LONGVARBINARY,
1:a69fa12:                  "LONG VARCHAR FOR BIT DATA",
1:a69fa12:                  32700,
1:a69fa12:                  0
1:a69fa12:                  );
1:a69fa12:         }
1:a69fa12: 
1:a69fa12: 
1:a69fa12:         if ( serverSupportsUDTs() )
1:a69fa12:         {
1:a69fa12:             query = "select a from t_price";
1:a69fa12:             PreparedStatement ps = prepareStatement( query );
1:a69fa12:             ResultSet rs = ps.executeQuery();
1:a69fa12:             rs.next();
1:a69fa12:             Object price = rs.getObject( 1 );
1:a69fa12:             String actualClassName = price.getClass().getName();
1:a69fa12:             rs.close();
1:a69fa12:             ps.close();
1:a69fa12: 
1:a69fa12:             if ( correctBehavior )
1:a69fa12:             {
1:a69fa12:                 String priceClassName = "org.apache.derbyTesting.functionTests.tests.lang.Price";
1:a69fa12:                 checkRSMD
1:a69fa12:                     (
1:a69fa12:                      query,
1:a69fa12:                      priceClassName,
1:a69fa12:                      15,
1:a69fa12:                      java.sql.Types.JAVA_OBJECT,
1:a69fa12:                      "\"APP\".\"PRICE\"",
1:a69fa12:                      0,
1:a69fa12:                      0
1:a69fa12:                      );
1:a69fa12: 
1:a69fa12:                 assertEquals( priceClassName, actualClassName );
1:a69fa12:             }
1:a69fa12:             else
1:a69fa12:             {
1:a69fa12:                 checkRSMD
1:a69fa12:                     (
1:a69fa12:                      query,
1:a69fa12:                      "byte[]",
1:a69fa12:                      65400,
1:a69fa12:                      java.sql.Types.LONGVARBINARY,
1:a69fa12:                      "LONG VARCHAR FOR BIT DATA",
1:a69fa12:                      32700,
1:a69fa12:                      0
1:a69fa12:                      );
1:a69fa12: 
1:a69fa12:                 assertEquals( "java.lang.String", actualClassName );
1:a69fa12:             }
1:a69fa12: 
1:a69fa12:             query = "insert into t_price( a ) values ( ? )";
1:a69fa12: 
1:a69fa12:             if ( correctBehavior )
1:a69fa12:             {
1:a69fa12:                 checkPMD
1:a69fa12:                     (
1:a69fa12:                      query,
1:a69fa12:                      "org.apache.derbyTesting.functionTests.tests.lang.Price",
1:a69fa12:                      java.sql.Types.JAVA_OBJECT,
1:a69fa12:                      "\"APP\".\"PRICE\"",
1:a69fa12:                      0,
1:a69fa12:                      0
1:a69fa12:                      );
1:a69fa12:             }
1:a69fa12:             else
1:a69fa12:             {
1:a69fa12:                 checkPMD
1:a69fa12:                     (
1:a69fa12:                      query,
1:a69fa12:                      "byte[]",
1:a69fa12:                      java.sql.Types.LONGVARBINARY,
1:a69fa12:                      "LONG VARCHAR FOR BIT DATA",
1:a69fa12:                      32700,
1:a69fa12:                      0
1:a69fa12:                      );
1:a69fa12:             }
1:a69fa12: 
1:a69fa12:             //
1:a69fa12:             // Should only be able to stuff an object into the column if both
1:a69fa12:             // the client and server are at 10.6 or higher.
1:a69fa12:             //
1:a69fa12:             ps = prepareStatement( query );
1:a69fa12:             byte[] someBytes = new byte[] { (byte) 1, (byte) 2, (byte) 3 };
1:a69fa12:             ByteArrayInputStream bais = new ByteArrayInputStream( someBytes );
1:a69fa12: 
1:a69fa12:             try {
1:a69fa12:                 ps.setObject( 1, org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice() );
1:a69fa12:                 ps.executeUpdate();
1:a69fa12: 
1:a69fa12:                 if ( !correctBehavior ) {
1:a69fa12:                     fail( "setObject( Price ) unexpectedly worked." );
1:a69fa12:                 }
1:a69fa12:             }
1:a69fa12:             catch (SQLException se)
1:a69fa12:             {
1:a69fa12:                 if ( correctBehavior ) {
1:a69fa12:                     fail( "setObject( Price ) unexpectedly failed." );
1:a69fa12:                 }
1:a69fa12:             }
1:a69fa12:             try {
1:a69fa12:                 ps.setObject( 1, someBytes );
1:a69fa12:                 ps.executeUpdate();
1:a69fa12: 
1:a69fa12:                 fail( "setObject( byte[] ) unexpectedly worked." );
1:a69fa12:             }
1:a69fa12:             catch (SQLException se) {}
1:a69fa12:             try {
1:a69fa12:                 ps.setBytes( 1, someBytes );
1:a69fa12:                 ps.executeUpdate();
1:a69fa12: 
1:a69fa12:                 fail( "setBytes( byte[] ) unexpectedly worked." );
1:a69fa12:             }
1:a69fa12:             catch (SQLException se) {}
1:a69fa12:             try {
1:a69fa12:                 ps.setBinaryStream( 1, bais, 3 );
1:a69fa12:                 ps.executeUpdate();
1:a69fa12: 
1:a69fa12:                 fail( "setBinaryStream( InputStream ) unexpectedly worked." );
1:a69fa12:             }
1:a69fa12:             catch (SQLException se) {}
1:a69fa12: 
1:a69fa12:             ps.close();
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Check the ResultSetMetaData for a query whose first column is a UDT.
1:a69fa12:      */
1:a69fa12:     private void checkRSMD
1:a69fa12:         (
1:a69fa12:          String query,
1:a69fa12:          String expectedClassName,
1:a69fa12:          int expectedDisplaySize,
1:a69fa12:          int expectedJDBCType,
1:a69fa12:          String expectedSQLTypeName,
1:a69fa12:          int expectedPrecision,
1:a69fa12:          int expectedScale
1:a69fa12:          ) throws SQLException
1:a69fa12:     {
1:a69fa12:         PreparedStatement ps = prepareStatement( query );
1:a69fa12:         ResultSet rs = ps.executeQuery();
1:a69fa12:         ResultSetMetaData rsmd = rs.getMetaData();
1:a69fa12: 
1:a69fa12:         assertEquals( expectedClassName, rsmd.getColumnClassName( 1 ) );
1:a69fa12:         assertEquals( expectedDisplaySize , rsmd.getColumnDisplaySize( 1 ));
1:a69fa12:         assertEquals( expectedJDBCType, rsmd.getColumnType( 1 ) );
1:a69fa12:         assertEquals( expectedSQLTypeName, rsmd.getColumnTypeName( 1 ) );
1:a69fa12:         assertEquals( expectedPrecision, rsmd.getPrecision( 1 ) );
1:a69fa12:         assertEquals( expectedScale, rsmd.getScale( 1 ) );
1:a69fa12: 
1:a69fa12:         rs.close();
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Check the ParameterMetaData for a statement whose first parameter is a UDT.
1:a69fa12:      */
1:a69fa12:     private void checkPMD
1:a69fa12:         (
1:a69fa12:          String query,
1:a69fa12:          String expectedClassName,
1:a69fa12:          int expectedJDBCType,
1:a69fa12:          String expectedSQLTypeName,
1:a69fa12:          int expectedPrecision,
1:a69fa12:          int expectedScale
1:a69fa12:          ) throws SQLException
1:a69fa12:     {
1:a69fa12:         PreparedStatement ps = prepareStatement( query );
1:a69fa12:         ParameterMetaData pmd = ps.getParameterMetaData();
1:a69fa12: 
1:a69fa12:         assertEquals( pmd.getParameterClassName( 1 ), expectedClassName );
1:a69fa12:         assertEquals( pmd.getParameterType( 1 ), expectedJDBCType );
1:a69fa12:         assertEquals( pmd.getParameterTypeName( 1 ), expectedSQLTypeName );
1:a69fa12:         assertEquals( pmd.getPrecision( 1 ), expectedPrecision );
1:a69fa12:         assertEquals( pmd.getScale( 1 ), expectedScale );
1:a69fa12: 
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    TEST DATATYPES
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Test that we can declare, insert, and select all datatypes that
1:a69fa12:     // are legal on the server. Test the metadata for these datatypes.
1:a69fa12:     //
1:a69fa12:     private void datatypesTest()
1:a69fa12:             throws SQLException {
1:a69fa12:         TypeDescriptor[]    types = ALL_TYPES;
1:a69fa12:         String                tableName = ALL_TYPES_TABLE;
1:a69fa12:         Object[][]            rows = new Object[][] { makeNullRow( types.length ), ROW_1 };
1:a69fa12: 
1:a69fa12:         checkDBMetadata(tableName);
1:a69fa12:         stuffTable(tableName, types, rows);
1:654f47f:         readTable(tableName, types, rows);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Verify that we get the correct DatabaseMetaData for a table.
1:a69fa12:     //
1:a69fa12:     private void checkDBMetadata(String tableName)
1:a69fa12:         throws SQLException {
1:a69fa12:         String defaultUser = TestConfiguration.getCurrent().getUserName();
1:a69fa12:         String                normalizedSchema = defaultUser.toUpperCase();
1:a69fa12:         String                normalizedTable = tableName.toUpperCase();
1:a69fa12:         DatabaseMetaData    dbmd = getConnection().getMetaData();
1:a69fa12: 
1:a69fa12:         ResultSet            rs = dbmd.getColumns
1:a69fa12:             ( null, normalizedSchema, normalizedTable, "%" );
1:a69fa12: 
1:a69fa12:         println( "Pawing through database metadata for " + normalizedSchema + '.' + normalizedTable );
1:a69fa12: 
1:a69fa12:         while( rs.next() )
1:a69fa12:         {
1:a69fa12:             String            columnName = rs.getString( "COLUMN_NAME" );
1:a69fa12:             int                actualJdbcType = rs.getInt( "DATA_TYPE" );
1:a69fa12:             TypeDescriptor    typeDesc = getType( columnName );
1:a69fa12: 
1:a69fa12:             if ( columnName.equals( KEY_COLUMN ) ) { continue; }
1:a69fa12: 
1:a69fa12:             StringBuilder builder = new StringBuilder();
1:a69fa12: 
1:a69fa12:             builder.append( "[ " ).
1:a69fa12:                    append( rs.getString( "COLUMN_NAME" ) ).
1:a69fa12:                    append( ",\t" ).
1:a69fa12:                    append( "type( " ).
1:a69fa12:                    append(rs.getInt( "DATA_TYPE" )).
1:a69fa12:                    append( " ),\t" ).
1:a69fa12:                    append( rs.getString( "TYPE_NAME" ) ).
1:a69fa12:                    append( " ]" );
1:a69fa12: 
1:a69fa12:             println( builder.toString() );
1:a69fa12: 
1:a69fa12:             assertEquals( columnName, typeDesc.getJdbcType(), actualJdbcType );
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         rs.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Stuff a table with rows
1:a69fa12:     //
1:a69fa12:     private void stuffTable(String tableName, TypeDescriptor[] types,
1:a69fa12:                             Object[][] rows)
1:a69fa12:             throws SQLException {
1:a69fa12:         PreparedStatement    ps = makeInsert(tableName, types);
1:a69fa12:         int                    rowCount = rows.length;
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < rowCount; i++ )
1:a69fa12:         {
1:a69fa12:             setRow( ps, i + 1, types, rows[ i ] );
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     private    PreparedStatement    makeInsert(String tableName,
1:a69fa12:                                            TypeDescriptor[] types )
1:a69fa12:             throws SQLException {
1:a69fa12:         StringBuilder      masterBuilder = new StringBuilder();
1:a69fa12:         StringBuilder      columnBuilder = new StringBuilder();
1:a69fa12:         StringBuilder      valuesBuilder = new StringBuilder();
1:a69fa12:         int                columnNumber = 0;
1:a69fa12:         int                valuesNumber = 0;
1:a69fa12:         int                typeCount = types.length;
1:a69fa12: 
1:a69fa12:         beginColumnList( columnBuilder );
1:a69fa12:         beginColumnList( valuesBuilder );
1:a69fa12: 
1:a69fa12:         addColumn( columnBuilder, columnNumber++, doubleQuote( KEY_COLUMN ) );
1:a69fa12:         addColumn( valuesBuilder, valuesNumber++, "?" );
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < typeCount; i++ )
1:a69fa12:         {
1:a69fa12:             TypeDescriptor    type = types[ i ];
1:a69fa12: 
1:a69fa12:             if ( getServerVersion().atLeast( type.getDerbyVersion() ) )
1:a69fa12:             {
1:a69fa12:                 String    typeName = type.getDerbyTypeName();
1:a69fa12:                 String    columnDesc = doubleQuote( typeName );
1:a69fa12: 
1:a69fa12:                 addColumn( columnBuilder, columnNumber++, columnDesc );
1:a69fa12:                 addColumn( valuesBuilder, valuesNumber++, "?" );
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         endColumnList( columnBuilder );
1:a69fa12:         endColumnList( valuesBuilder );
1:a69fa12: 
1:a69fa12:         masterBuilder.append( "insert into " ).
1:a69fa12:                      append( tableName ).
1:a69fa12:                      append( "\n" ).
1:a69fa12:                      append( columnBuilder.toString() ).
1:a69fa12:                      append( "values\n" ).
1:a69fa12:                      append( valuesBuilder.toString() );
1:a69fa12: 
1:a69fa12:         return prepareStatement(masterBuilder.toString());
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Verify that we can select all legal datatypes in a table.
1:a69fa12:     //
1:a69fa12:     private void readTable(String tableName, TypeDescriptor[] types,
1:654f47f:                            Object[][] rows)
1:a69fa12:             throws SQLException {
1:a69fa12:         PreparedStatement    ps = readTableQuery(tableName, types);
1:a69fa12:         ResultSet            rs = ps.executeQuery();
1:a69fa12: 
1:a69fa12:         checkRSMD( rs );
1:a69fa12:         rs.close();
1:a69fa12:         // Execute the statement again for each cast / coercion we check.
1:654f47f:         checkRows( ps, types, rows );
1:a69fa12: 
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Make the select query
1:a69fa12:     //
1:a69fa12:     private PreparedStatement readTableQuery(String tableName,
1:a69fa12:                                              TypeDescriptor[] types)
1:a69fa12:             throws SQLException {
1:a69fa12:         StringBuilder    builder = new StringBuilder();
1:a69fa12:         int                columnNumber = 0;
1:a69fa12:         int                typeCount = types.length;
1:a69fa12: 
1:a69fa12:         builder.append( "select \n" );
1:a69fa12: 
1:a69fa12:         addColumn( builder, columnNumber++, doubleQuote( KEY_COLUMN ) );
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < typeCount; i++ )
1:a69fa12:         {
1:a69fa12:             TypeDescriptor    type = types[ i ];
1:a69fa12: 
1:a69fa12:             if ( getServerVersion().atLeast( type.getDerbyVersion() ) )
1:a69fa12:             {
1:a69fa12:                 String    typeName = type.getDerbyTypeName();
1:a69fa12:                 String    columnDesc = doubleQuote( typeName );
1:a69fa12: 
1:a69fa12:                 addColumn( builder, columnNumber++, columnDesc );
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         builder.append( "\nfrom " ).
1:a69fa12:                append( tableName ).
1:a69fa12:                append( "\n" ).
1:a69fa12:                append( "order by " ).
1:a69fa12:                append(doubleQuote( KEY_COLUMN ) );
1:a69fa12: 
1:a69fa12:         return prepareStatement(builder.toString());
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Verify that we get the correct ResultSetMetaData for all datatypes
1:a69fa12:     // which are legal on the server.
1:a69fa12:     //
1:a69fa12:     private    void    checkRSMD( ResultSet rs )
1:a69fa12:         throws SQLException
1:a69fa12:     {
1:a69fa12:         ResultSetMetaData    rsmd = rs.getMetaData();
1:a69fa12:         int                    columnCount = rsmd.getColumnCount();
1:a69fa12:         int                    firstTastyColumn = 0;
1:a69fa12: 
1:a69fa12:         println( "ResultSetMetaData:\n" );
1:a69fa12: 
1:a69fa12:         firstTastyColumn++;                // skip uninteresting key column
1:a69fa12: 
1:a69fa12:         for ( int i = firstTastyColumn; i < columnCount; i++ )
1:a69fa12:         {
1:a69fa12:             StringBuilder        builder = new StringBuilder();
1:a69fa12:             int                columnID = i + 1;
1:a69fa12:             String            columnName = rsmd.getColumnName( columnID );
1:a69fa12:             TypeDescriptor    typeDesc = getType( columnName );
1:a69fa12:             int                expectedType = rsmdTypeKludge( typeDesc.getJdbcType() );
1:a69fa12:             int                actualType = rsmd.getColumnType( columnID );
1:a69fa12: 
1:a69fa12:             builder.append( "[ " );
1:a69fa12:             builder.append( columnName );
1:a69fa12:             builder.append( ", type( " );
1:a69fa12:             builder.append( actualType );
1:a69fa12:             builder.append( " ), " );
1:a69fa12:             builder.append( rsmd.getColumnTypeName( columnID ) );
1:a69fa12:             builder.append( " ]\n" );
1:a69fa12: 
1:a69fa12:             println( builder.toString() );
1:a69fa12: 
1:a69fa12:             assertEquals( columnName, expectedType, actualType );
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Verify that we select the values we originally inserted into a table,
1:a69fa12:      * and that the valid coercions succeeds.
1:a69fa12:      *
1:a69fa12:      *
1:a69fa12:      * @param ps the query used to obtain the results
1:a69fa12:      * @param types the type descriptions of the columns
1:a69fa12:      * @param rows the values expected to be returned
1:a69fa12:      * @throws Exception
1:a69fa12:      */
1:a69fa12:     private void checkRows(PreparedStatement ps, TypeDescriptor[] types,
1:654f47f:                            Object[][] rows)
1:a69fa12:             throws SQLException {
1:a69fa12:         int typeCount = types.length;
1:a69fa12: 
1:a69fa12:         // Iterate over all the types we have defined.
1:a69fa12:         // Note that we don't iterate over the rows, as restrictions in
1:a69fa12:         // Derby stop us from getting the values of certain column types more
1:a69fa12:         // than once (see comments / patch for DERBY-3844).
1:a69fa12:         //We execute the query to obtain the rows many times.
1:a69fa12:         for (int colIndex=0; colIndex < typeCount; colIndex++ ) {
1:a69fa12:             TypeDescriptor type = types[colIndex];
1:a69fa12: 
1:a69fa12:             if (getServerVersion().atLeast(type.getDerbyVersion())) {
1:a69fa12:                 // Make sure we're using the correct type descriptor.
1:a69fa12:                 assertEquals(types[colIndex], type);
1:a69fa12:                 checkPlainGet(ps, colIndex, type, rows);
1:654f47f:                 checkCoercions(ps, type);
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Checks that fetching the specified column as the declared data type
1:a69fa12:      * works, i.e doing rs.getString() on a VARCHAR column or rs.getInt() on
1:a69fa12:      * a SMALLINT column.
1:a69fa12:      *
1:a69fa12:      * @param ps the query used to obtain the results
1:a69fa12:      * @param columnIndex the index of the column to check
1:a69fa12:      * @param type the type description of the column
1:a69fa12:      * @param rows the values expected to be returned
1:a69fa12:      * @throws Exception
1:a69fa12:      */
1:a69fa12:     private void checkPlainGet(PreparedStatement ps, int columnIndex,
1:a69fa12:                                TypeDescriptor type, Object[][] rows)
1:a69fa12:             throws SQLException {
1:a69fa12:         String columnName = type.getDerbyTypeName();
1:a69fa12:         ResultSet rs = ps.executeQuery();
1:a69fa12:         for (int rowId=0; rowId < rows.length; rowId++) {
1:a69fa12:             assertTrue("Not enough rows in the result", rs.next());
1:a69fa12:             Object expectedValue = rows[rowId][columnIndex];
1:a69fa12:             Object actualValue = getColumn(rs, columnName, type);
1:a69fa12: 
1:a69fa12:             println("Comparing column " + columnName + ": " + expectedValue +
1:a69fa12:                     " to " + actualValue );
1:a69fa12:             compareObjects(columnName, expectedValue, actualValue);
1:a69fa12:         }
1:a69fa12:         // Make sure we drained the result set.
1:a69fa12:         assertFalse("Remaining rows in result", rs.next());
1:a69fa12:         rs.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Verify all legal JDBC coercions of a data value.
1:a69fa12:      *
1:a69fa12:      * @param ps the query used to obtain the rows
1:a69fa12:      * @param type the type description of the column
1:a69fa12:      */
1:654f47f:     private void checkCoercions(PreparedStatement ps, TypeDescriptor type)
1:a69fa12:             throws SQLException {
1:a69fa12:         String columnName = type.getDerbyTypeName();
1:a69fa12:         T_CN coercionDesc = COERCIONS[ getCoercionIndex(type.getJdbcType()) ];
1:a69fa12:         boolean[] coercions = coercionDesc.getCoercions();
1:a69fa12:         int count = coercions.length;
1:a69fa12:         int legalCoercions = 0;
1:a69fa12: 
1:a69fa12:         println( "Checking coercions for " + columnName );
1:a69fa12: 
1:a69fa12:         for ( int i=0; i < count; i++ ) {
1:a69fa12:             if (coercions[i]) {
1:a69fa12:                 legalCoercions++;
1:a69fa12:                 ResultSet rs = ps.executeQuery();
1:a69fa12: 
1:a69fa12:                 while (rs.next()) {
1:a69fa12:                     int jdbcType = COERCIONS[i].getJdbcType();
1:a69fa12:                     Object retval = getColumn( rs, columnName, jdbcType );
1:a69fa12:                     println( "\t" + jdbcType + ":\t" + retval );
1:a69fa12:                 }
1:a69fa12:                 rs.close();
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12:         println(legalCoercions + " legal coercions for " + columnName + " (" +
1:a69fa12:                 "type=" + type.getDerbyTypeName() + ")");
1:a69fa12: 
1:a69fa12:         // finally, try getObject()
1:a69fa12:         ResultSet rs = ps.executeQuery();
1:a69fa12: 
1:a69fa12:         while (rs.next()) {
1:a69fa12:             Object objval = rs.getObject( columnName );
1:a69fa12:             if (objval == null) {
1:a69fa12:                 println("\tgetObject() = null");
1:a69fa12:             } else {
1:a69fa12:                 StringBuilder builder = new StringBuilder();
1:a69fa12:                 builder.append("\tgetObject() = ");
1:a69fa12:                 builder.append(objval.getClass().getName());
1:a69fa12:                 builder.append("( ");
1:a69fa12:                 builder.append(objval);
1:a69fa12:                 builder.append(" )");
1:a69fa12:                 println(builder.toString());
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12:         rs.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // This kludge compensates for the fact that the DRDA clients report
1:a69fa12:     // that NUMERIC columns are DECIMAL. See bug 584.
1:a69fa12:     //
1:a69fa12:     // In addition, booleans are handled oddly by down-rev clients.
1:a69fa12:     //
1:a69fa12:     private    int    rsmdTypeKludge( int originalJDbcType )
1:a69fa12:     {
1:a69fa12:         // The embedded client does the right thing.
1:a69fa12:         if ( usingEmbedded()) { return originalJDbcType; }
1:a69fa12: 
1:a69fa12:         switch( originalJDbcType )
1:a69fa12:         {
1:a69fa12:             //This kludge compensates for the fact that the DRDA clients report
1:a69fa12:             // that NUMERIC columns are DECIMAL. See bug 584.
1:a69fa12:             case Types.NUMERIC:
1:a69fa12:                 return Types.DECIMAL;
1:a69fa12: 
1:a69fa12:             default:            return originalJDbcType;
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Insert a row into the ALL_TYPES table. The row contains all datatypes
1:a69fa12:     // that are legal on the server.
1:a69fa12:     //
1:a69fa12:     private    void    setRow( PreparedStatement ps, int keyValue, TypeDescriptor[] types, Object[] row )
1:a69fa12:         throws SQLException
1:a69fa12:     {
1:a69fa12:         int                param = 1;
1:a69fa12:         int                typeCount = types.length;
1:a69fa12: 
1:a69fa12:         ps.setInt( param++, keyValue );
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < typeCount; i++ )
1:a69fa12:         {
1:a69fa12:             TypeDescriptor    type = types[ i ];
1:a69fa12:             Object            value = row[ i ];
1:a69fa12: 
1:a69fa12:             if ( getServerVersion().atLeast( type.getDerbyVersion() ) )
1:a69fa12:             {
1:a69fa12:                 setParameter( ps, param++, type, value );
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         ps.execute();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     private    Object[]    makeNullRow( int rowLength )
1:a69fa12:     {
1:a69fa12:         return new Object[ rowLength ];
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Index the TypeDescriptors by Derby type name.
1:a69fa12:     //
1:a69fa12:     private    void    buildTypeMap()
1:a69fa12:     {
1:a69fa12:         int                typeCount = ALL_TYPES.length;
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < typeCount; i++ ) { putType( ALL_TYPES[ i ] ); }
1:a69fa12:     }
1:a69fa12:     private    void    putType( TypeDescriptor type )
1:a69fa12:     {
1:a69fa12:         _types.put( type.getDerbyTypeName(), type );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Lookup TypeDescriptors by Derby type name.
1:a69fa12:     //
1:a69fa12:     private    TypeDescriptor    getType( String typeName )
1:a69fa12:     {
1:a69fa12:         if ( _types.isEmpty() ) { buildTypeMap(); }
1:a69fa12: 
1:a69fa12:         return (TypeDescriptor) _types.get( typeName );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Index legal coercions by jdbc type.
1:a69fa12:     //
1:a69fa12:     private    void    buildCoercionMap()
1:a69fa12:     {
1:a69fa12:         int                count = COERCIONS.length;
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < count; i++ ) { putCoercionIndex( i ); }
1:a69fa12:     }
1:a69fa12:     private    void    putCoercionIndex( int index )
1:a69fa12:     {
1:39b3237:         _coercionIndex.put( COERCIONS[ index ].getJdbcType(), index );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Lookup the legal coercions for a given jdbc type.
1:a69fa12:     //
1:a69fa12:     private    int    getCoercionIndex( int jdbcType )
1:a69fa12:     {
1:a69fa12:         if ( _coercionIndex.isEmpty() ) { buildCoercionMap(); }
1:a69fa12: 
1:39b3237:         return ((Integer) _coercionIndex.get( jdbcType )).intValue();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    MINIONS
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     ///////////////////
1:a69fa12:     //
1:a69fa12:     //    TYPE MANAGEMENT
1:a69fa12:     //
1:a69fa12:     ///////////////////
1:a69fa12: 
1:a69fa12:     //////////////////
1:a69fa12:     //
1:a69fa12:     //    SCHEMA MINIONS
1:a69fa12:     //
1:a69fa12:     //////////////////
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Create a table modelling an array of datatypes.
1:a69fa12:     //
1:a69fa12:     private static void createTable(Connection con, String tableName,
1:a69fa12:                                     TypeDescriptor[] types)
1:a69fa12:             throws SQLException {
1:a69fa12:         StringBuilder    builder = new StringBuilder();
1:a69fa12:         int                columnNumber = 0;
1:a69fa12:         int                typeCount = types.length;
1:a69fa12: 
1:a69fa12:         builder.append("create table ").append(tableName).append('\n');
1:a69fa12:         beginColumnList( builder );
1:a69fa12: 
1:a69fa12:         addColumn( builder, columnNumber++, doubleQuote( KEY_COLUMN ) + "\tint" );
1:a69fa12: 
1:a69fa12:         for ( int i = 0; i < typeCount; i++ )
1:a69fa12:         {
1:a69fa12:             TypeDescriptor    type = types[ i ];
1:a69fa12: 
1:a69fa12:             if ( getServerVersion(con).atLeast( type.getDerbyVersion() ) )
1:a69fa12:             {
1:a69fa12:                 String    typeName = type.getDerbyTypeName();
1:a69fa12:                 String    columnDesc = doubleQuote( typeName ) + '\t' + typeName;
1:a69fa12: 
1:a69fa12:                 addColumn( builder, columnNumber++, columnDesc );
1:a69fa12:             }
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         endColumnList( builder );
1:a69fa12: 
1:a69fa12:         PreparedStatement ps = con.prepareStatement(builder.toString());
1:a69fa12:         ps.execute();
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Create an ANSI UDT and a table with that type of column--
1:a69fa12:     // if the server is at 10.6 or higher.
1:a69fa12:     //
1:a69fa12:     private static void createUDTObjects(Connection con)
1:a69fa12:             throws SQLException {
1:a69fa12:         if ( !serverSupportsUDTs(con) ) { return; }
1:a69fa12: 
1:a69fa12:         PreparedStatement ps;
1:a69fa12: 
1:a69fa12:         ps = con.prepareStatement("create type price external name " +
1:a69fa12:                 "'org.apache.derbyTesting.functionTests.tests.lang.Price' " +
1:a69fa12:                 "language java\n");
1:a69fa12:         ps.execute();
1:a69fa12:         ps.close();
1:a69fa12: 
1:a69fa12:         ps = con.prepareStatement("create function makePrice( ) returns price " +
1:a69fa12:                 "language java parameter style java no sql external name " +
1:a69fa12:                 "'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n");
1:a69fa12:         ps.execute();
1:a69fa12:         ps.close();
1:a69fa12: 
1:a69fa12:         ps = con.prepareStatement("create table t_price( a price )\n");
1:a69fa12:         ps.execute();
1:a69fa12:         ps.close();
1:a69fa12: 
1:a69fa12:         ps = con.prepareStatement("insert into t_price( a ) " +
1:a69fa12:                 "values ( makePrice() )\n" );
1:a69fa12:         ps.execute();
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Create a table with a timestamp column.
1:a69fa12:     //
1:a69fa12:     private static void create_derby_2602_objects(Connection con)
1:a69fa12:             throws SQLException {
1:a69fa12:         PreparedStatement ps = con.prepareStatement(
1:a69fa12:                 "create table t_2602( a timestamp )\n");
1:a69fa12:         ps.execute();
1:a69fa12:         ps.close();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Helper methods for declaring a table.
1:a69fa12:     //
1:a69fa12:     private static void beginColumnList( StringBuilder builder )
1:a69fa12:     {
1:a69fa12:         builder.append( "(\n" );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     private static void endColumnList( StringBuilder builder )
1:a69fa12:     {
1:a69fa12:         builder.append( "\n)\n" );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     private static void addColumn( StringBuilder builder, int columnNumber, String text  )
1:a69fa12:     {
1:a69fa12:         if ( columnNumber > 0 ) { builder.append( "," ); }
1:a69fa12: 
1:a69fa12:         builder.append( "\n\t" );
1:a69fa12:         builder.append( text );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Drop the tables used by our test cases.
1:a69fa12:     //
1:a69fa12:     private void dropSchema()
1:a69fa12:             throws SQLException {
1:a69fa12:         dropTable(ALL_TYPES_TABLE);
1:a69fa12:         dropUDTObjects();
1:a69fa12:         drop_derby_2602_objects();
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Drop objects needed by UDT tests. We only do this if the server
1:a69fa12:     // is at 10.6 or higher.
1:a69fa12:     //
1:a69fa12:     private void dropUDTObjects()
1:a69fa12:             throws SQLException {
1:a69fa12:         if (serverSupportsUDTs()) {
1:a69fa12:             dropFunction("MAKEPRICE");
1:a69fa12:             dropTable("T_PRICE");
1:a69fa12:             dropUDT("PRICE");
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Drop objects needed by DERBY-2602 tests.
1:a69fa12:     //
1:a69fa12:     private void drop_derby_2602_objects()
1:a69fa12:             throws SQLException {
1:a69fa12:         dropTable("T_2602");
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Logic for stuffing a data value into a column, given its type.
1:a69fa12:     //
1:a69fa12:     private    void    setParameter( PreparedStatement ps, int param, TypeDescriptor type, Object value )
1:a69fa12:         throws SQLException
1:a69fa12:     {
1:a69fa12:         int        jdbcType = type.getJdbcType();
1:a69fa12: 
1:a69fa12:         if ( value != null )
1:a69fa12:         {
1:a69fa12:             setParameter( ps, param, jdbcType, value );
1:a69fa12:             return;
1:a69fa12:         }
1:a69fa12:         else if ( clientSupports( type ) )
1:a69fa12:         {
1:a69fa12:             ps.setNull( param, jdbcType );
1:a69fa12: 
1:a69fa12:             return;
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         // client does not support nulls of this type.
1:a69fa12: 
1:a69fa12:         fail( "Unsupported Derby type: " + type.getDerbyTypeName() );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     // return true if the client supports this datatype
1:a69fa12:     private    boolean    clientSupports( TypeDescriptor type )
1:a69fa12:             throws SQLException {
1:a69fa12:         DerbyVersion firstSupportedVersion = type.getDerbyVersion();
1:a69fa12: 
1:a69fa12:         if ( firstSupportedVersion == null ) { return false; }
1:a69fa12:         else { return getDriverVersion().atLeast( firstSupportedVersion ); }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // Get a data value from a column, given its type.
1:a69fa12:     //
1:a69fa12:     private    Object    getColumn( ResultSet rs, String columnName, TypeDescriptor type )
1:a69fa12:         throws SQLException
1:a69fa12:     {
1:a69fa12:         int            jdbcType = type.getJdbcType();
1:a69fa12: 
1:a69fa12:         return getColumn( rs, columnName, jdbcType );
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     //
1:a69fa12:     // SQL code generation minions
1:a69fa12:     //
1:a69fa12:     private static String doubleQuote( String text )
1:a69fa12:     {
1:a69fa12:         return '"' + text + '"';
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12:     //
1:a69fa12:     //    INNER CLASSES
1:a69fa12:     //
1:a69fa12:     /////////////////////////////////////////////////////////////
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Description of a legal datatype and the version of Derby
1:a69fa12:      * where the datatype first appears.
1:a69fa12:      */
1:a69fa12:     public    static    final    class    TypeDescriptor
1:a69fa12:     {
1:a69fa12:         private int          _jdbcType;
1:a69fa12:         private String       _derbyTypeName;
1:a69fa12:         /** The first Derby version which supports this type. */
1:a69fa12:         private DerbyVersion _derbyVersion;
1:a69fa12: 
1:a69fa12:         public    TypeDescriptor (
1:a69fa12:             int          jdbcType,
1:a69fa12:             String       derbyTypeName,
1:a69fa12:             DerbyVersion derbyVersion
1:a69fa12:         )
1:a69fa12:         {
1:a69fa12:             _jdbcType = jdbcType;
1:a69fa12:             _derbyTypeName = derbyTypeName;
1:a69fa12:             _derbyVersion = derbyVersion;
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         public int        getJdbcType()               { return _jdbcType; }
1:a69fa12:         public String    getDerbyTypeName()           { return _derbyTypeName; }
1:a69fa12:         public DerbyVersion    getDerbyVersion()      { return _derbyVersion; }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Helper class capturing TypeCoercion logic.
1:a69fa12:      * <p>
1:a69fa12:      * I have abbreviated it to this ugly class name so that the COERCIONS
1:a69fa12:      * table will fit on a readable screen.
1:a69fa12:      */
1:a69fa12:     public    static    final    class    T_CN
1:a69fa12:     {
1:a69fa12:         private    int            _jdbcType;
1:a69fa12:         private    boolean[]    _coercions;
1:a69fa12: 
1:a69fa12:         public    T_CN( int jdbcType, boolean[] coercions )
1:a69fa12:         {
1:a69fa12:             _jdbcType = jdbcType;
1:a69fa12:             _coercions = coercions;
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         public    int          getJdbcType()             { return _jdbcType; }
1:a69fa12:         public    boolean[]    getCoercions()            { return _coercions; }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Returns a suite with all the available JDBC client driver compatibility
1:a69fa12:      * tests.
1:a69fa12:      * <p>
1:a69fa12:      * JUnit boilerplate which adds as test cases all public methods
1:a69fa12:      * whose names start with the string "test" in the named classes.
1:a69fa12:      */
1:a69fa12:     public static Test suite() {
1:1ae02c9:         BaseTestSuite testSuite = new BaseTestSuite("JDBCDriverTest suite");
1:a69fa12:         testSuite.addTestSuite(JDBCDriverTest.class);
1:a69fa12:         return TestConfiguration.defaultExistingServerDecorator(
1:a69fa12:                 new BaseJDBCTestSetup(testSuite) {
1:a69fa12: 
1:a69fa12:                     protected void setUp() throws Exception {
1:a69fa12:                         super.setUp();
1:a69fa12:                         Connection con = getConnection();
1:a69fa12:                         Statement s = con.createStatement();
1:a69fa12:                         // We can't use Connection.getSchema yet.
1:a69fa12:                         ResultSet rs = s.executeQuery("values CURRENT SCHEMA");
1:a69fa12:                         rs.next();
1:a69fa12:                         String schema = rs.getString(1);
1:a69fa12:                         rs.close();
1:a69fa12:                         s.close();
1:a69fa12:                         con.setAutoCommit(false);
1:a69fa12:                         // Drop the current schema to clean up. Hopefully this
1:a69fa12:                         // is enough to start "reset" the database for each
1:a69fa12:                         // client run (running the newest CleanDatabaseTestSetup
1:a69fa12:                         // fails on older versions).
1:a69fa12:                         JDBC.dropSchema(con.getMetaData(), schema);
1:a69fa12:                         con.commit();
1:a69fa12: 
1:a69fa12:                         // Initialize the database for the tests.
1:a69fa12:                         con.setAutoCommit(true);
1:a69fa12:                         createTable(con, ALL_TYPES_TABLE, ALL_TYPES);
1:a69fa12:                         createUDTObjects(con);
1:a69fa12:                         create_derby_2602_objects(con);
1:a69fa12:                     }
1:a69fa12:                 });
1:a69fa12:     }
1:a69fa12: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         1L,
1:         1.0,
1:         1.0,
1:         (float) 1.0,
1:         1.0,
1:         1,
1:         (float) 1.0,
1:         (short) 1,
/////////////////////////////////////////////////////////////////////////
1:             objectValue = expectedValue ? 1 : 0;
/////////////////////////////////////////////////////////////////////////
1:         _coercionIndex.put( COERCIONS[ index ].getJdbcType(), index );
/////////////////////////////////////////////////////////////////////////
1:         return ((Integer) _coercionIndex.get( jdbcType )).intValue();
commit:ca48ab4
/////////////////////////////////////////////////////////////////////////
1:     private    static    final        boolean    n = false;
/////////////////////////////////////////////////////////////////////////
1:         new T_CN( Types.BIGINT, new boolean[]             { Y,n,Y,n,n,n,n,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.BLOB, new boolean[]               { n,Y,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n } ),
1:         new T_CN( Types.CHAR, new boolean[]               { n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y,n } ),
1:         new T_CN( Types.BINARY, new boolean[]             { n,n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y } ),
1:         new T_CN( Types.CLOB, new boolean[]               { n,n,n,n,Y,n,n,n,n,n,n,n,n,n,n,n,n,n,n } ),
1:         new T_CN( Types.DATE, new boolean[]               { n,n,n,n,n,Y,n,n,n,n,n,n,n,n,n,n,n,n,n } ),
1:         new T_CN( Types.DECIMAL, new boolean[]            { Y,n,n,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.DOUBLE, new boolean[]             { Y,n,n,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.REAL, new boolean[]               { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.INTEGER, new boolean[]            { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.LONGVARCHAR, new boolean[]        { n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y,n } ),
1:         new T_CN( Types.LONGVARBINARY, new boolean[]      { n,n,n,n,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y } ),
1:         new T_CN( Types.NUMERIC, new boolean[]            { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.REAL, new boolean[]               { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.SMALLINT, new boolean[]           { Y,n,Y,n,n,n,Y,Y,Y,Y,Y,n,Y,Y,Y,n,n,Y,n } ),
1:         new T_CN( Types.TIME, new boolean[]               { n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,Y,n,n,n } ),
1:         new T_CN( Types.TIMESTAMP, new boolean[]          { n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,Y,n,n } ),
1:         new T_CN( Types.VARCHAR, new boolean[]            { n,n,Y,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y,n } ),
1:         new T_CN( Types.VARBINARY, new boolean[]          { n,n,n,n,n,n,n,n,n,n,n,Y,n,n,n,n,n,n,Y } ),
commit:ffa2d1b
/////////////////////////////////////////////////////////////////////////
1:     private    static    HashMap<String,TypeDescriptor>        _types = new HashMap<String,TypeDescriptor>();
1:     private    static    HashMap<Integer,Integer>        _coercionIndex = new HashMap<Integer,Integer>();
/////////////////////////////////////////////////////////////////////////
0:                            Object[][] rows, List<Object> casts )
/////////////////////////////////////////////////////////////////////////
0:                            Object[][] rows, List<Object> casts)
/////////////////////////////////////////////////////////////////////////
0:                                 List<Object> casts)
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite testSuite = new BaseTestSuite("JDBCDriverTest suite");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:654f47f
/////////////////////////////////////////////////////////////////////////
1:         readTable(tableName, types, rows);
/////////////////////////////////////////////////////////////////////////
1:                            Object[][] rows)
/////////////////////////////////////////////////////////////////////////
1:         checkRows( ps, types, rows );
/////////////////////////////////////////////////////////////////////////
1:                            Object[][] rows)
/////////////////////////////////////////////////////////////////////////
1:                 checkCoercions(ps, type);
/////////////////////////////////////////////////////////////////////////
1:     private void checkCoercions(PreparedStatement ps, TypeDescriptor type)
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a69fa12
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.compatibility.JDBCDriverTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.compatibility;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.math.BigDecimal;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Types;
1: import java.util.HashMap;
0: import java.util.List;
1: import java.util.regex.Pattern;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: import org.apache.derbyTesting.functionTests.tests.compatibility.helpers.DummyBlob;
1: import org.apache.derbyTesting.functionTests.tests.compatibility.helpers.DummyClob;
1: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1: import org.apache.derbyTesting.junit.DerbyVersion;
1: 
1: /**
1:  * A set of client driver compatibility tests.
1:  */
1: public class JDBCDriverTest
1:     extends AbstractCompatibilityTest {
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    CONSTANTS
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     private    static    final        String    ALL_TYPES_TABLE = "allTypesTable";
1:     private    static    final        String    KEY_COLUMN = "keyCol";
1: 
1:     //
1:     // Data values to be stuffed into columns of ALL_TYPES_TABLE.
1:     //
1:     private    static    final        byte[]    SAMPLE_BYTES =
1:         new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5 };
1:     private    static    final        String    SAMPLE_STRING = "hello";
1: 
1:     //
1:     // These funny constants are defined this way to make the salient
1:     // facts of the COERCIONS table leap out at you.
1:     //
1:     private    static    final        boolean    Y = true;
0:     private    static    final        boolean    _ = false;
1: 
1:     //
1:     // This table declares the datatypes supported by Derby and the earliest
1:     // versions of the Derby client which support these datatypes.
1:     //
1:     // If you add a type to this table, make sure you add a corresponding
1:     // column to the following row table. Also add a corresponding row to the
1:     // COERCIONS table.
1:     //
1:     private    static    final    TypeDescriptor[]    ALL_TYPES =
1:     {
1:         // 10.0 types
1: 
1:         new TypeDescriptor
1:         ( Types.BIGINT,         "bigint",                   DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.BLOB,           "blob",                     DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.CHAR,           "char(5)",                  DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.BINARY,         "char(5) for bit data",     DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.CLOB,           "clob",                     DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.DATE,           "date",                     DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.DECIMAL,        "decimal",                  DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.DOUBLE,         "double",                   DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.DOUBLE,         "double precision",         DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.REAL,           "float(23)",                DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.DOUBLE,         "float",                    DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.INTEGER,        "integer",                  DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.LONGVARCHAR,    "long varchar",             DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.LONGVARBINARY,  "long varchar for bit data",DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.NUMERIC,        "numeric",                  DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.REAL,           "real",                     DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.SMALLINT,       "smallint",                 DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.TIME,           "time",                     DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.TIMESTAMP,      "timestamp",                DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.VARCHAR,        "varchar(5)",               DerbyVersion._10_0),
1:         new TypeDescriptor
1:         ( Types.VARBINARY,      "varchar(5) for bit data",  DerbyVersion._10_0),
1:     };
1: 
1:     //
1:     // This table needs to have the same number of entries as ALL_TYPES.
1:     // The testSanity() test case enforces this at run time.
1:     //
1:     private    static    final    Object[]    ROW_1 =
1:     {
1:         // 10.0 columns
1: 
0:         new Long( 1L ),
1:         new DummyBlob( SAMPLE_BYTES ),
1:         SAMPLE_STRING,
1:         SAMPLE_BYTES,
1:         new DummyClob( SAMPLE_STRING ),
1:         new java.sql.Date( 1L ),
1:         new BigDecimal( 1.0 ),
0:         new Double( 1.0 ),
0:         new Double( 1.0 ),
0:         new Float( (float) 1.0 ),
0:         new Double( 1.0 ),
0:         new Integer( 1 ),
1:         SAMPLE_STRING,
1:         SAMPLE_BYTES,
1:         new BigDecimal( 1.0 ),
0:         new Float( (float) 1.0 ),
0:         new Short( (short) 1 ),
1:         new Time( 1L ),
1:         new Timestamp( 1L ),
1:         SAMPLE_STRING,
1:         SAMPLE_BYTES,
1:     };
1: 
1:     //
1:     // This table needs to have the same number of rows as ALL_TYPES.
1:     // Each row in this table needs to have the same number of columns as
1:     // rows in ALL_TYPES. The testSanity() test case enforces this at run time.
1:     // Note how the funny synonyms for true and false
1:     // make the salient facts of this table leap out at you.
1:     //
1:     // The ugly class name T_CN is an abbreviation which makes it possible to
1:     // squeeze this table onto a readable screen.
1:     //
1:     // Please read the introductory comment top-to-bottom. 'Y' means a coercion
1:     // is legal; '_' means it isn't.
1:     //
1:     private    static    final    T_CN[]    COERCIONS =
1:     {
1:         //                                                  B|B|C|B|C|D|D|D|R|I|L|L|N|R|S|T|T|V|V
1:         //                                                  I|L|H|I|L|A|E|O|E|N|O|O|U|E|M|I|I|A|A
1:         //                                                  G|O|A|N|O|T|C|U|A|T|N|N|M|A|A|M|M|R|R
1:         //                                                  I|B|R|A|B|E|I|B|L|E|G|G|E|L|L|E|E|C|B
1:         //                                                  N|-|-|R|-|-|M|L|-|G|V|V|R|-|L|-|S|H|I
1:         //                                                  T|-|-|Y|-|-|A|E|-|E|A|A|I|-|I|-|T|A|N
1:         //                                                  -|-|-|-|-|-|L|-|-|R|R|R|C|-|N|-|A|R|A
1:         //                                                  -|-|-|-|-|-|-|-|-|-|C|B|-|-|T|-|M|-|R
1:         //                                                  -|-|-|-|-|-|-|-|-|-|H|I|-|-|-|-|P|-|Y
1:         //                                                  -|-|-|-|-|-|-|-|-|-|A|N|-|-|-|-|-|-|-
1:         //                                                  -|-|-|-|-|-|-|-|-|-|R|A|-|-|-|-|-|-|-
1:         //                                                  -|-|-|-|-|-|-|-|-|-|-|R|-|-|-|-|-|-|-
1:         //                                                  -|-|-|-|-|-|-|-|-|-|-|Y|-|-|-|-|-|-|-
0:         new T_CN( Types.BIGINT, new boolean[]             { Y,_,Y,_,_,_,_,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.BLOB, new boolean[]               { _,Y,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_ } ),
0:         new T_CN( Types.CHAR, new boolean[]               { _,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y,_ } ),
0:         new T_CN( Types.BINARY, new boolean[]             { _,_,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y } ),
0:         new T_CN( Types.CLOB, new boolean[]               { _,_,_,_,Y,_,_,_,_,_,_,_,_,_,_,_,_,_,_ } ),
0:         new T_CN( Types.DATE, new boolean[]               { _,_,_,_,_,Y,_,_,_,_,_,_,_,_,_,_,_,_,_ } ),
0:         new T_CN( Types.DECIMAL, new boolean[]            { Y,_,_,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.DOUBLE, new boolean[]             { Y,_,_,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.REAL, new boolean[]               { Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.INTEGER, new boolean[]            { Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.LONGVARCHAR, new boolean[]        { _,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y,_ } ),
0:         new T_CN( Types.LONGVARBINARY, new boolean[]      { _,_,_,_,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y } ),
0:         new T_CN( Types.NUMERIC, new boolean[]            { Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.REAL, new boolean[]               { Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.SMALLINT, new boolean[]           { Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_ } ),
0:         new T_CN( Types.TIME, new boolean[]               { _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,Y,_,_,_ } ),
0:         new T_CN( Types.TIMESTAMP, new boolean[]          { _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,Y,_,_ } ),
0:         new T_CN( Types.VARCHAR, new boolean[]            { _,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y,_ } ),
0:         new T_CN( Types.VARBINARY, new boolean[]          { _,_,_,_,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y } ),
1:     };
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    STATE
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     // map derby type name to type descriptor
0:     private    static    HashMap        _types = new HashMap();    // maps Derby type names to TypeDescriptors
1: 
1:     // map jdbc type to index into COERCIONS
0:     private    static    HashMap        _coercionIndex = new HashMap();    // maps jdbc types to legal coercions
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    CONSTRUCTOR
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     public JDBCDriverTest(String name) {
1:         super(name);
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    TEST ENTRY POINTS
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Sanity check the integrity of this test suite.
1:      */
1:     public void testSanity()
1:     {
1:         assertEquals("ALL_TYPES.length == ROW_1.length",
1:                 ALL_TYPES.length, ROW_1.length );
1: 
1:         // make sure we completely describe the coercibility of every jdbc type
1:         int coercionCount = COERCIONS.length;
1:         for ( int i = 0; i < coercionCount; i++ ) {
1:             assertEquals("Coercion " + i,
1:                     coercionCount, COERCIONS[ i ].getCoercions().length );
1:         }
1:     }
1: 
1:     public void testVerifyVersions()
1:             throws SQLException {
1:         DerbyVersion server = getServerVersion();
1:         DerbyVersion client = getDriverVersion();
1:         println("server=" + server.toString() + " <-> client=" +
1:                 client.toString());
1:         String expS = getSystemProperty("derby.tests.compat.expectedServer");
1:         String expC = getSystemProperty("derby.tests.compat.expectedClient");
1:         assertNotNull("expected server property missing", expS);
1:         assertNotNull("expected client property missing", expC);
1:         DerbyVersion expectedServer = DerbyVersion.parseVersionString(expS);
1:         DerbyVersion expectedClient = DerbyVersion.parseVersionString(expC);
1:         assertEquals("server version mismatch", expectedServer, server);
1:         assertEquals("client version mismatch", expectedClient, client);
1:     }
1: 
1:     /**
1:      * Tests compatibility for the available data types.
1:      */
1:     public void testDataTypesCompatibility() throws SQLException {
1:         datatypesTest();
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    DERBY-4613
1:     //
1:     // Make sure embedded and network clients treat BOOLEAN values identically.
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verify that embedded and network clients handle BOOLEAN values the
1:      * same way from release 10.7 onward.
1:      */
1:     public void testDerby4613(Connection conn)
1:         throws Exception
1:     {
1:         boolean correctBehavior =
1:                 getServerVersion().atLeast( DerbyVersion._10_7 ) &&
1:                 getDriverVersion().atLeast( DerbyVersion._10_7 );
1:         println( "derby_4613_test correctBehavior = " + correctBehavior );
1: 
1:         vet_isindex_column(correctBehavior, "SYSTABLES_HEAP", false);
1:         vet_isindex_column(correctBehavior, "SYSTABLES_INDEX1", true);
1:     }
1: 
1:     /**
1:      * Vet boolean results.
1:      */
1:     private void vet_isindex_column(boolean correctBehavior,
1:                                     String conglomerateName,
1:                                     boolean expectedValue)
1:             throws Exception
1:     {
1:         PreparedStatement ps = prepareStatement(
1:                 "select isindex from sys.sysconglomerates " +
1:                 "where conglomeratename = ?");
1:         ps.setString( 1, conglomerateName );
1:         ResultSet rs = ps.executeQuery();
1:         ResultSetMetaData rsmd = rs.getMetaData();
1: 
1:         int jdbcType = correctBehavior ? Types.BOOLEAN : Types.SMALLINT;
1:         String typeName = correctBehavior ? "BOOLEAN" : "SMALLINT";
1:         int precision = correctBehavior ? 1 : 5;
1:         int scale = 0;
1:         int columnDisplaySize = correctBehavior ? 5 : 6;
1:         String columnClassName = correctBehavior ? "java.lang.Boolean"
1:                                                  : "java.lang.Integer";
1: 
1:         Object objectValue;
1:         if ( correctBehavior )
1:         {
1:             objectValue = Boolean.valueOf(expectedValue);
1:         }
1:         else
1:         {
0:             objectValue = expectedValue ? new Integer( 1 ) : new Integer( 0 );
1:         }
1:         String stringValue = objectValue.toString();
1: 
1:         assertEquals( jdbcType, rsmd.getColumnType( 1 ) );
1:         assertEquals( typeName, rsmd.getColumnTypeName( 1 ) );
1:         assertEquals( precision, rsmd.getPrecision( 1 ) );
1:         assertEquals( scale, rsmd.getScale( 1 ) );
1:         assertEquals( columnDisplaySize, rsmd.getColumnDisplaySize( 1 ) );
1:         assertEquals( columnClassName, rsmd.getColumnClassName( 1 ) );
1: 
1:         assertEquals( true, rs.next() );
1: 
1:         assertEquals( expectedValue, rs.getBoolean( 1 ) );
1:         assertEquals( objectValue, rs.getObject( 1 ) );
1:         assertEquals( stringValue, rs.getString( 1 ) );
1: 
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    DERBY-2602
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verifies that timestamps retain their nanosecond-precision
1:      * across the network from release 10.6 onward.
1:      */
1:     public void testDerby2602() throws SQLException {
1:         //
1:         // We must expect truncation of timestamps in a network configuration
1:         // unless both the client and the server are at 10.6 or higher.
1:         // See DERBY-2602.
1:         //
1:         boolean correctBehavior =
1:                 getServerVersion().atLeast( DerbyVersion._10_6 ) &&
1:                 getDriverVersion().atLeast( DerbyVersion._10_6 );
1: 
1:         Timestamp ts = Timestamp.valueOf("2004-02-14 17:14:24.976255123");
1:         PreparedStatement    insert = prepareStatement(
1:                 "insert into t_2602( a ) values ( ? )");
1:         insert.setTimestamp(1,ts);
1:         insert.executeUpdate();
1:         insert.close();
1: 
1:         PreparedStatement    select = prepareStatement("select a from t_2602" );
1:         ResultSet selectRS = select.executeQuery();
1:         selectRS.next();
1:         Timestamp resultTS = selectRS.getTimestamp( 1 );
1:         int resultNanos = resultTS.getNanos();
1: 
1:         int expectedResult = correctBehavior ? 976255123  : 976255000;
1:         assertEquals( expectedResult, resultNanos );
1:     }
1: 
1:     /**
1:      * Test case for DERBY-4888. Check that we can call DatabaseMetaData
1:      * methods returning a boolean without errors.
1:      */
1:     public void testDerby4888() throws SQLException {
1:         // Used to get a ClassCastException here in some combinations.
1:         assertFalse(getConnection().getMetaData().storesLowerCaseIdentifiers());
1:     }
1: 
1:     /**
1:      * A pattern that matches the value returned by
1:      * DatabaseMetaData.getDriverVersion() for the versions that suffer
1:      * from DERBY-5449. That is, all version on the 10.8 branch up to 10.8.2.2.
1:      */
1:     private static Pattern DERBY_5449_PATTERN = Pattern.compile(
1:             "^10\\.8\\.([01]\\.|2\\.[012] ).*");
1: 
1:     /**
1:      * Test case for DERBY-5449. Verify that PreparedStatement.setBoolean()
1:      * works across different versions. Used to fail with a ClassCastException
1:      * when talking to servers at version 10.7 and earlier.
1:      */
1:     public void testDerby5449() throws SQLException {
1:         if (getServerVersion().compareTo(DerbyVersion._10_7) <= 0) {
1:             // Derby's client drivers on the 10.8 branch up to 10.8.2.2
1:             // suffered from DERBY-5449 and the test case will fail when
1:             // talking to older servers. Skip the test case in such cases.
1:             String driverVersion =
1:                     getConnection().getMetaData().getDriverVersion();
1:             if (DERBY_5449_PATTERN.matcher(driverVersion).matches()) {
1:                 return;
1:             }
1:         }
1: 
1:         PreparedStatement ps = prepareStatement("VALUES CAST(? AS INTEGER)");
1:         ps.setBoolean(1, true);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         ps.setBoolean(1, false);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "0");
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    TEST UDTs
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verify the metadata for user defined types.
1:      */
1:     public void testUDT() throws Exception
1:     {
1:         //
1:         // We must expect the wrong metadata in a network configuration
1:         // unless both the client and the server are at 10.6 or higher.
1:         // See DERBY-4491.
1:         //
1:         boolean correctBehavior =
1:              getServerVersion().atLeast( DerbyVersion._10_6 ) &&
1:              getDriverVersion().atLeast( DerbyVersion._10_6 );
1: 
1:         String query = "select aliasinfo from sys.sysaliases";
1: 
1:         if ( correctBehavior )
1:         {
1:             String aliasInfoClassName = "org.apache.derby.catalog.AliasInfo";
1: 
1:             checkRSMD
1:                 (
1:                  query,
1:                  aliasInfoClassName,
1:                  15,
1:                  java.sql.Types.JAVA_OBJECT,
1:                  aliasInfoClassName,
1:                  0,
1:                  0
1:                  );
1:         }
1:         else
1:         {
1:             checkRSMD
1:                 (
1:                  query,
1:                  "byte[]",
1:                  65400,
1:                  java.sql.Types.LONGVARBINARY,
1:                  "LONG VARCHAR FOR BIT DATA",
1:                  32700,
1:                  0
1:                  );
1:         }
1: 
1: 
1:         if ( serverSupportsUDTs() )
1:         {
1:             query = "select a from t_price";
1:             PreparedStatement ps = prepareStatement( query );
1:             ResultSet rs = ps.executeQuery();
1:             rs.next();
1:             Object price = rs.getObject( 1 );
1:             String actualClassName = price.getClass().getName();
1:             rs.close();
1:             ps.close();
1: 
1:             if ( correctBehavior )
1:             {
1:                 String priceClassName = "org.apache.derbyTesting.functionTests.tests.lang.Price";
1:                 checkRSMD
1:                     (
1:                      query,
1:                      priceClassName,
1:                      15,
1:                      java.sql.Types.JAVA_OBJECT,
1:                      "\"APP\".\"PRICE\"",
1:                      0,
1:                      0
1:                      );
1: 
1:                 assertEquals( priceClassName, actualClassName );
1:             }
1:             else
1:             {
1:                 checkRSMD
1:                     (
1:                      query,
1:                      "byte[]",
1:                      65400,
1:                      java.sql.Types.LONGVARBINARY,
1:                      "LONG VARCHAR FOR BIT DATA",
1:                      32700,
1:                      0
1:                      );
1: 
1:                 assertEquals( "java.lang.String", actualClassName );
1:             }
1: 
1:             query = "insert into t_price( a ) values ( ? )";
1: 
1:             if ( correctBehavior )
1:             {
1:                 checkPMD
1:                     (
1:                      query,
1:                      "org.apache.derbyTesting.functionTests.tests.lang.Price",
1:                      java.sql.Types.JAVA_OBJECT,
1:                      "\"APP\".\"PRICE\"",
1:                      0,
1:                      0
1:                      );
1:             }
1:             else
1:             {
1:                 checkPMD
1:                     (
1:                      query,
1:                      "byte[]",
1:                      java.sql.Types.LONGVARBINARY,
1:                      "LONG VARCHAR FOR BIT DATA",
1:                      32700,
1:                      0
1:                      );
1:             }
1: 
1:             //
1:             // Should only be able to stuff an object into the column if both
1:             // the client and server are at 10.6 or higher.
1:             //
1:             ps = prepareStatement( query );
1:             byte[] someBytes = new byte[] { (byte) 1, (byte) 2, (byte) 3 };
1:             ByteArrayInputStream bais = new ByteArrayInputStream( someBytes );
1: 
1:             try {
1:                 ps.setObject( 1, org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice() );
1:                 ps.executeUpdate();
1: 
1:                 if ( !correctBehavior ) {
1:                     fail( "setObject( Price ) unexpectedly worked." );
1:                 }
1:             }
1:             catch (SQLException se)
1:             {
1:                 if ( correctBehavior ) {
1:                     fail( "setObject( Price ) unexpectedly failed." );
1:                 }
1:             }
1:             try {
1:                 ps.setObject( 1, someBytes );
1:                 ps.executeUpdate();
1: 
1:                 fail( "setObject( byte[] ) unexpectedly worked." );
1:             }
1:             catch (SQLException se) {}
1:             try {
1:                 ps.setBytes( 1, someBytes );
1:                 ps.executeUpdate();
1: 
1:                 fail( "setBytes( byte[] ) unexpectedly worked." );
1:             }
1:             catch (SQLException se) {}
1:             try {
1:                 ps.setBinaryStream( 1, bais, 3 );
1:                 ps.executeUpdate();
1: 
1:                 fail( "setBinaryStream( InputStream ) unexpectedly worked." );
1:             }
1:             catch (SQLException se) {}
1: 
1:             ps.close();
1:         }
1:     }
1: 
1:     /**
1:      * Check the ResultSetMetaData for a query whose first column is a UDT.
1:      */
1:     private void checkRSMD
1:         (
1:          String query,
1:          String expectedClassName,
1:          int expectedDisplaySize,
1:          int expectedJDBCType,
1:          String expectedSQLTypeName,
1:          int expectedPrecision,
1:          int expectedScale
1:          ) throws SQLException
1:     {
1:         PreparedStatement ps = prepareStatement( query );
1:         ResultSet rs = ps.executeQuery();
1:         ResultSetMetaData rsmd = rs.getMetaData();
1: 
1:         assertEquals( expectedClassName, rsmd.getColumnClassName( 1 ) );
1:         assertEquals( expectedDisplaySize , rsmd.getColumnDisplaySize( 1 ));
1:         assertEquals( expectedJDBCType, rsmd.getColumnType( 1 ) );
1:         assertEquals( expectedSQLTypeName, rsmd.getColumnTypeName( 1 ) );
1:         assertEquals( expectedPrecision, rsmd.getPrecision( 1 ) );
1:         assertEquals( expectedScale, rsmd.getScale( 1 ) );
1: 
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Check the ParameterMetaData for a statement whose first parameter is a UDT.
1:      */
1:     private void checkPMD
1:         (
1:          String query,
1:          String expectedClassName,
1:          int expectedJDBCType,
1:          String expectedSQLTypeName,
1:          int expectedPrecision,
1:          int expectedScale
1:          ) throws SQLException
1:     {
1:         PreparedStatement ps = prepareStatement( query );
1:         ParameterMetaData pmd = ps.getParameterMetaData();
1: 
1:         assertEquals( pmd.getParameterClassName( 1 ), expectedClassName );
1:         assertEquals( pmd.getParameterType( 1 ), expectedJDBCType );
1:         assertEquals( pmd.getParameterTypeName( 1 ), expectedSQLTypeName );
1:         assertEquals( pmd.getPrecision( 1 ), expectedPrecision );
1:         assertEquals( pmd.getScale( 1 ), expectedScale );
1: 
1:         ps.close();
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    TEST DATATYPES
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     //
1:     // Test that we can declare, insert, and select all datatypes that
1:     // are legal on the server. Test the metadata for these datatypes.
1:     //
1:     private void datatypesTest()
1:             throws SQLException {
1:         TypeDescriptor[]    types = ALL_TYPES;
1:         String                tableName = ALL_TYPES_TABLE;
1:         Object[][]            rows = new Object[][] { makeNullRow( types.length ), ROW_1 };
1: 
1:         checkDBMetadata(tableName);
1:         stuffTable(tableName, types, rows);
0:         readTable(tableName, types, rows, null);
1:     }
1: 
1:     //
1:     // Verify that we get the correct DatabaseMetaData for a table.
1:     //
1:     private void checkDBMetadata(String tableName)
1:         throws SQLException {
1:         String defaultUser = TestConfiguration.getCurrent().getUserName();
1:         String                normalizedSchema = defaultUser.toUpperCase();
1:         String                normalizedTable = tableName.toUpperCase();
1:         DatabaseMetaData    dbmd = getConnection().getMetaData();
1: 
1:         ResultSet            rs = dbmd.getColumns
1:             ( null, normalizedSchema, normalizedTable, "%" );
1: 
1:         println( "Pawing through database metadata for " + normalizedSchema + '.' + normalizedTable );
1: 
1:         while( rs.next() )
1:         {
1:             String            columnName = rs.getString( "COLUMN_NAME" );
1:             int                actualJdbcType = rs.getInt( "DATA_TYPE" );
1:             TypeDescriptor    typeDesc = getType( columnName );
1: 
1:             if ( columnName.equals( KEY_COLUMN ) ) { continue; }
1: 
1:             StringBuilder builder = new StringBuilder();
1: 
1:             builder.append( "[ " ).
1:                    append( rs.getString( "COLUMN_NAME" ) ).
1:                    append( ",\t" ).
1:                    append( "type( " ).
1:                    append(rs.getInt( "DATA_TYPE" )).
1:                    append( " ),\t" ).
1:                    append( rs.getString( "TYPE_NAME" ) ).
1:                    append( " ]" );
1: 
1:             println( builder.toString() );
1: 
1:             assertEquals( columnName, typeDesc.getJdbcType(), actualJdbcType );
1:         }
1: 
1:         rs.close();
1:     }
1: 
1:     //
1:     // Stuff a table with rows
1:     //
1:     private void stuffTable(String tableName, TypeDescriptor[] types,
1:                             Object[][] rows)
1:             throws SQLException {
1:         PreparedStatement    ps = makeInsert(tableName, types);
1:         int                    rowCount = rows.length;
1: 
1:         for ( int i = 0; i < rowCount; i++ )
1:         {
1:             setRow( ps, i + 1, types, rows[ i ] );
1:         }
1: 
1:         ps.close();
1:     }
1: 
1:     private    PreparedStatement    makeInsert(String tableName,
1:                                            TypeDescriptor[] types )
1:             throws SQLException {
1:         StringBuilder      masterBuilder = new StringBuilder();
1:         StringBuilder      columnBuilder = new StringBuilder();
1:         StringBuilder      valuesBuilder = new StringBuilder();
1:         int                columnNumber = 0;
1:         int                valuesNumber = 0;
1:         int                typeCount = types.length;
1: 
1:         beginColumnList( columnBuilder );
1:         beginColumnList( valuesBuilder );
1: 
1:         addColumn( columnBuilder, columnNumber++, doubleQuote( KEY_COLUMN ) );
1:         addColumn( valuesBuilder, valuesNumber++, "?" );
1: 
1:         for ( int i = 0; i < typeCount; i++ )
1:         {
1:             TypeDescriptor    type = types[ i ];
1: 
1:             if ( getServerVersion().atLeast( type.getDerbyVersion() ) )
1:             {
1:                 String    typeName = type.getDerbyTypeName();
1:                 String    columnDesc = doubleQuote( typeName );
1: 
1:                 addColumn( columnBuilder, columnNumber++, columnDesc );
1:                 addColumn( valuesBuilder, valuesNumber++, "?" );
1:             }
1:         }
1: 
1:         endColumnList( columnBuilder );
1:         endColumnList( valuesBuilder );
1: 
1:         masterBuilder.append( "insert into " ).
1:                      append( tableName ).
1:                      append( "\n" ).
1:                      append( columnBuilder.toString() ).
1:                      append( "values\n" ).
1:                      append( valuesBuilder.toString() );
1: 
1:         return prepareStatement(masterBuilder.toString());
1:     }
1: 
1:     //
1:     // Verify that we can select all legal datatypes in a table.
1:     //
1:     private void readTable(String tableName, TypeDescriptor[] types,
0:                            Object[][] rows, List casts )
1:             throws SQLException {
1:         PreparedStatement    ps = readTableQuery(tableName, types);
1:         ResultSet            rs = ps.executeQuery();
1: 
1:         checkRSMD( rs );
1:         rs.close();
1:         // Execute the statement again for each cast / coercion we check.
0:         checkRows( ps, types, rows, casts );
1: 
1:         ps.close();
1:     }
1: 
1:     //
1:     // Make the select query
1:     //
1:     private PreparedStatement readTableQuery(String tableName,
1:                                              TypeDescriptor[] types)
1:             throws SQLException {
1:         StringBuilder    builder = new StringBuilder();
1:         int                columnNumber = 0;
1:         int                typeCount = types.length;
1: 
1:         builder.append( "select \n" );
1: 
1:         addColumn( builder, columnNumber++, doubleQuote( KEY_COLUMN ) );
1: 
1:         for ( int i = 0; i < typeCount; i++ )
1:         {
1:             TypeDescriptor    type = types[ i ];
1: 
1:             if ( getServerVersion().atLeast( type.getDerbyVersion() ) )
1:             {
1:                 String    typeName = type.getDerbyTypeName();
1:                 String    columnDesc = doubleQuote( typeName );
1: 
1:                 addColumn( builder, columnNumber++, columnDesc );
1:             }
1:         }
1: 
1:         builder.append( "\nfrom " ).
1:                append( tableName ).
1:                append( "\n" ).
1:                append( "order by " ).
1:                append(doubleQuote( KEY_COLUMN ) );
1: 
1:         return prepareStatement(builder.toString());
1:     }
1: 
1:     //
1:     // Verify that we get the correct ResultSetMetaData for all datatypes
1:     // which are legal on the server.
1:     //
1:     private    void    checkRSMD( ResultSet rs )
1:         throws SQLException
1:     {
1:         ResultSetMetaData    rsmd = rs.getMetaData();
1:         int                    columnCount = rsmd.getColumnCount();
1:         int                    firstTastyColumn = 0;
1: 
1:         println( "ResultSetMetaData:\n" );
1: 
1:         firstTastyColumn++;                // skip uninteresting key column
1: 
1:         for ( int i = firstTastyColumn; i < columnCount; i++ )
1:         {
1:             StringBuilder        builder = new StringBuilder();
1:             int                columnID = i + 1;
1:             String            columnName = rsmd.getColumnName( columnID );
1:             TypeDescriptor    typeDesc = getType( columnName );
1:             int                expectedType = rsmdTypeKludge( typeDesc.getJdbcType() );
1:             int                actualType = rsmd.getColumnType( columnID );
1: 
1:             builder.append( "[ " );
1:             builder.append( columnName );
1:             builder.append( ", type( " );
1:             builder.append( actualType );
1:             builder.append( " ), " );
1:             builder.append( rsmd.getColumnTypeName( columnID ) );
1:             builder.append( " ]\n" );
1: 
1:             println( builder.toString() );
1: 
1:             assertEquals( columnName, expectedType, actualType );
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Verify that we select the values we originally inserted into a table,
1:      * and that the valid coercions succeeds.
1:      *
1:      *
1:      * @param ps the query used to obtain the results
1:      * @param types the type descriptions of the columns
1:      * @param rows the values expected to be returned
0:      * @param casts a list to which objects retrieved from the result rows
0:      *      are added, specify {@code null} if you don't need this
1:      * @throws Exception
1:      */
1:     private void checkRows(PreparedStatement ps, TypeDescriptor[] types,
0:                            Object[][] rows, List casts)
1:             throws SQLException {
1:         int typeCount = types.length;
1: 
1:         // Iterate over all the types we have defined.
1:         // Note that we don't iterate over the rows, as restrictions in
1:         // Derby stop us from getting the values of certain column types more
1:         // than once (see comments / patch for DERBY-3844).
1:         //We execute the query to obtain the rows many times.
1:         for (int colIndex=0; colIndex < typeCount; colIndex++ ) {
1:             TypeDescriptor type = types[colIndex];
1: 
1:             if (getServerVersion().atLeast(type.getDerbyVersion())) {
1:                 // Make sure we're using the correct type descriptor.
1:                 assertEquals(types[colIndex], type);
1:                 checkPlainGet(ps, colIndex, type, rows);
0:                 checkCoercions(ps, type, casts);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Checks that fetching the specified column as the declared data type
1:      * works, i.e doing rs.getString() on a VARCHAR column or rs.getInt() on
1:      * a SMALLINT column.
1:      *
1:      * @param ps the query used to obtain the results
1:      * @param columnIndex the index of the column to check
1:      * @param type the type description of the column
1:      * @param rows the values expected to be returned
1:      * @throws Exception
1:      */
1:     private void checkPlainGet(PreparedStatement ps, int columnIndex,
1:                                TypeDescriptor type, Object[][] rows)
1:             throws SQLException {
1:         String columnName = type.getDerbyTypeName();
1:         ResultSet rs = ps.executeQuery();
1:         for (int rowId=0; rowId < rows.length; rowId++) {
1:             assertTrue("Not enough rows in the result", rs.next());
1:             Object expectedValue = rows[rowId][columnIndex];
1:             Object actualValue = getColumn(rs, columnName, type);
1: 
1:             println("Comparing column " + columnName + ": " + expectedValue +
1:                     " to " + actualValue );
1:             compareObjects(columnName, expectedValue, actualValue);
1:         }
1:         // Make sure we drained the result set.
1:         assertFalse("Remaining rows in result", rs.next());
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Verify all legal JDBC coercions of a data value.
1:      *
1:      * @param ps the query used to obtain the rows
1:      * @param type the type description of the column
0:      * @param casts
1:      */
0:     private void checkCoercions(PreparedStatement ps, TypeDescriptor type,
0:                                 List casts)
1:             throws SQLException {
1:         String columnName = type.getDerbyTypeName();
1:         T_CN coercionDesc = COERCIONS[ getCoercionIndex(type.getJdbcType()) ];
1:         boolean[] coercions = coercionDesc.getCoercions();
1:         int count = coercions.length;
1:         int legalCoercions = 0;
1: 
1:         println( "Checking coercions for " + columnName );
1: 
1:         for ( int i=0; i < count; i++ ) {
1:             if (coercions[i]) {
1:                 legalCoercions++;
1:                 ResultSet rs = ps.executeQuery();
1: 
1:                 while (rs.next()) {
1:                     int jdbcType = COERCIONS[i].getJdbcType();
1:                     Object retval = getColumn( rs, columnName, jdbcType );
1: 
0:                     if (casts != null) {
0:                         casts.add(retval);
1:                     }
1: 
1:                     println( "\t" + jdbcType + ":\t" + retval );
1:                 }
1:                 rs.close();
1:             }
1:         }
1:         println(legalCoercions + " legal coercions for " + columnName + " (" +
1:                 "type=" + type.getDerbyTypeName() + ")");
1: 
1:         // finally, try getObject()
1:         ResultSet rs = ps.executeQuery();
1: 
1:         while (rs.next()) {
1:             Object objval = rs.getObject( columnName );
1:             if (objval == null) {
1:                 println("\tgetObject() = null");
1:             } else {
1:                 StringBuilder builder = new StringBuilder();
1:                 builder.append("\tgetObject() = ");
1:                 builder.append(objval.getClass().getName());
1:                 builder.append("( ");
1:                 builder.append(objval);
1:                 builder.append(" )");
1:                 println(builder.toString());
1:             }
1:         }
1:         rs.close();
1:     }
1: 
1:     //
1:     // This kludge compensates for the fact that the DRDA clients report
1:     // that NUMERIC columns are DECIMAL. See bug 584.
1:     //
1:     // In addition, booleans are handled oddly by down-rev clients.
1:     //
1:     private    int    rsmdTypeKludge( int originalJDbcType )
1:     {
1:         // The embedded client does the right thing.
1:         if ( usingEmbedded()) { return originalJDbcType; }
1: 
1:         switch( originalJDbcType )
1:         {
1:             //This kludge compensates for the fact that the DRDA clients report
1:             // that NUMERIC columns are DECIMAL. See bug 584.
1:             case Types.NUMERIC:
1:                 return Types.DECIMAL;
1: 
1:             default:            return originalJDbcType;
1:         }
1:     }
1: 
1:     //
1:     // Insert a row into the ALL_TYPES table. The row contains all datatypes
1:     // that are legal on the server.
1:     //
1:     private    void    setRow( PreparedStatement ps, int keyValue, TypeDescriptor[] types, Object[] row )
1:         throws SQLException
1:     {
1:         int                param = 1;
1:         int                typeCount = types.length;
1: 
1:         ps.setInt( param++, keyValue );
1: 
1:         for ( int i = 0; i < typeCount; i++ )
1:         {
1:             TypeDescriptor    type = types[ i ];
1:             Object            value = row[ i ];
1: 
1:             if ( getServerVersion().atLeast( type.getDerbyVersion() ) )
1:             {
1:                 setParameter( ps, param++, type, value );
1:             }
1:         }
1: 
1:         ps.execute();
1:     }
1: 
1:     private    Object[]    makeNullRow( int rowLength )
1:     {
1:         return new Object[ rowLength ];
1:     }
1: 
1:     //
1:     // Index the TypeDescriptors by Derby type name.
1:     //
1:     private    void    buildTypeMap()
1:     {
1:         int                typeCount = ALL_TYPES.length;
1: 
1:         for ( int i = 0; i < typeCount; i++ ) { putType( ALL_TYPES[ i ] ); }
1:     }
1:     private    void    putType( TypeDescriptor type )
1:     {
1:         _types.put( type.getDerbyTypeName(), type );
1:     }
1: 
1:     //
1:     // Lookup TypeDescriptors by Derby type name.
1:     //
1:     private    TypeDescriptor    getType( String typeName )
1:     {
1:         if ( _types.isEmpty() ) { buildTypeMap(); }
1: 
1:         return (TypeDescriptor) _types.get( typeName );
1:     }
1: 
1:     //
1:     // Index legal coercions by jdbc type.
1:     //
1:     private    void    buildCoercionMap()
1:     {
1:         int                count = COERCIONS.length;
1: 
1:         for ( int i = 0; i < count; i++ ) { putCoercionIndex( i ); }
1:     }
1:     private    void    putCoercionIndex( int index )
1:     {
0:         _coercionIndex.put( new Integer( COERCIONS[ index ].getJdbcType() ), new Integer( index ) );
1:     }
1: 
1:     //
1:     // Lookup the legal coercions for a given jdbc type.
1:     //
1:     private    int    getCoercionIndex( int jdbcType )
1:     {
1:         if ( _coercionIndex.isEmpty() ) { buildCoercionMap(); }
1: 
0:         return ((Integer) _coercionIndex.get( new Integer( jdbcType ) )).intValue();
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    MINIONS
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     ///////////////////
1:     //
1:     //    TYPE MANAGEMENT
1:     //
1:     ///////////////////
1: 
1:     //////////////////
1:     //
1:     //    SCHEMA MINIONS
1:     //
1:     //////////////////
1: 
1:     //
1:     // Create a table modelling an array of datatypes.
1:     //
1:     private static void createTable(Connection con, String tableName,
1:                                     TypeDescriptor[] types)
1:             throws SQLException {
1:         StringBuilder    builder = new StringBuilder();
1:         int                columnNumber = 0;
1:         int                typeCount = types.length;
1: 
1:         builder.append("create table ").append(tableName).append('\n');
1:         beginColumnList( builder );
1: 
1:         addColumn( builder, columnNumber++, doubleQuote( KEY_COLUMN ) + "\tint" );
1: 
1:         for ( int i = 0; i < typeCount; i++ )
1:         {
1:             TypeDescriptor    type = types[ i ];
1: 
1:             if ( getServerVersion(con).atLeast( type.getDerbyVersion() ) )
1:             {
1:                 String    typeName = type.getDerbyTypeName();
1:                 String    columnDesc = doubleQuote( typeName ) + '\t' + typeName;
1: 
1:                 addColumn( builder, columnNumber++, columnDesc );
1:             }
1:         }
1: 
1:         endColumnList( builder );
1: 
1:         PreparedStatement ps = con.prepareStatement(builder.toString());
1:         ps.execute();
1:         ps.close();
1:     }
1: 
1:     //
1:     // Create an ANSI UDT and a table with that type of column--
1:     // if the server is at 10.6 or higher.
1:     //
1:     private static void createUDTObjects(Connection con)
1:             throws SQLException {
1:         if ( !serverSupportsUDTs(con) ) { return; }
1: 
1:         PreparedStatement ps;
1: 
1:         ps = con.prepareStatement("create type price external name " +
1:                 "'org.apache.derbyTesting.functionTests.tests.lang.Price' " +
1:                 "language java\n");
1:         ps.execute();
1:         ps.close();
1: 
1:         ps = con.prepareStatement("create function makePrice( ) returns price " +
1:                 "language java parameter style java no sql external name " +
1:                 "'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n");
1:         ps.execute();
1:         ps.close();
1: 
1:         ps = con.prepareStatement("create table t_price( a price )\n");
1:         ps.execute();
1:         ps.close();
1: 
1:         ps = con.prepareStatement("insert into t_price( a ) " +
1:                 "values ( makePrice() )\n" );
1:         ps.execute();
1:         ps.close();
1:     }
1: 
1:     //
1:     // Create a table with a timestamp column.
1:     //
1:     private static void create_derby_2602_objects(Connection con)
1:             throws SQLException {
1:         PreparedStatement ps = con.prepareStatement(
1:                 "create table t_2602( a timestamp )\n");
1:         ps.execute();
1:         ps.close();
1:     }
1: 
1: 
1:     //
1:     // Helper methods for declaring a table.
1:     //
1:     private static void beginColumnList( StringBuilder builder )
1:     {
1:         builder.append( "(\n" );
1:     }
1: 
1:     private static void endColumnList( StringBuilder builder )
1:     {
1:         builder.append( "\n)\n" );
1:     }
1: 
1:     private static void addColumn( StringBuilder builder, int columnNumber, String text  )
1:     {
1:         if ( columnNumber > 0 ) { builder.append( "," ); }
1: 
1:         builder.append( "\n\t" );
1:         builder.append( text );
1:     }
1: 
1:     //
1:     // Drop the tables used by our test cases.
1:     //
1:     private void dropSchema()
1:             throws SQLException {
1:         dropTable(ALL_TYPES_TABLE);
1:         dropUDTObjects();
1:         drop_derby_2602_objects();
1:     }
1: 
1:     //
1:     // Drop objects needed by UDT tests. We only do this if the server
1:     // is at 10.6 or higher.
1:     //
1:     private void dropUDTObjects()
1:             throws SQLException {
1:         if (serverSupportsUDTs()) {
1:             dropFunction("MAKEPRICE");
1:             dropTable("T_PRICE");
1:             dropUDT("PRICE");
1:         }
1:     }
1: 
1:     //
1:     // Drop objects needed by DERBY-2602 tests.
1:     //
1:     private void drop_derby_2602_objects()
1:             throws SQLException {
1:         dropTable("T_2602");
1:     }
1: 
1:     //
1:     // Logic for stuffing a data value into a column, given its type.
1:     //
1:     private    void    setParameter( PreparedStatement ps, int param, TypeDescriptor type, Object value )
1:         throws SQLException
1:     {
1:         int        jdbcType = type.getJdbcType();
1: 
1:         if ( value != null )
1:         {
1:             setParameter( ps, param, jdbcType, value );
1:             return;
1:         }
1:         else if ( clientSupports( type ) )
1:         {
1:             ps.setNull( param, jdbcType );
1: 
1:             return;
1:         }
1: 
1:         // client does not support nulls of this type.
1: 
1:         fail( "Unsupported Derby type: " + type.getDerbyTypeName() );
1:     }
1: 
1:     // return true if the client supports this datatype
1:     private    boolean    clientSupports( TypeDescriptor type )
1:             throws SQLException {
1:         DerbyVersion firstSupportedVersion = type.getDerbyVersion();
1: 
1:         if ( firstSupportedVersion == null ) { return false; }
1:         else { return getDriverVersion().atLeast( firstSupportedVersion ); }
1:     }
1: 
1:     //
1:     // Get a data value from a column, given its type.
1:     //
1:     private    Object    getColumn( ResultSet rs, String columnName, TypeDescriptor type )
1:         throws SQLException
1:     {
1:         int            jdbcType = type.getJdbcType();
1: 
1:         return getColumn( rs, columnName, jdbcType );
1:     }
1: 
1:     //
1:     // SQL code generation minions
1:     //
1:     private static String doubleQuote( String text )
1:     {
1:         return '"' + text + '"';
1:     }
1: 
1:     /////////////////////////////////////////////////////////////
1:     //
1:     //    INNER CLASSES
1:     //
1:     /////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Description of a legal datatype and the version of Derby
1:      * where the datatype first appears.
1:      */
1:     public    static    final    class    TypeDescriptor
1:     {
1:         private int          _jdbcType;
1:         private String       _derbyTypeName;
1:         /** The first Derby version which supports this type. */
1:         private DerbyVersion _derbyVersion;
1: 
1:         public    TypeDescriptor (
1:             int          jdbcType,
1:             String       derbyTypeName,
1:             DerbyVersion derbyVersion
1:         )
1:         {
1:             _jdbcType = jdbcType;
1:             _derbyTypeName = derbyTypeName;
1:             _derbyVersion = derbyVersion;
1:         }
1: 
1:         public int        getJdbcType()               { return _jdbcType; }
1:         public String    getDerbyTypeName()           { return _derbyTypeName; }
1:         public DerbyVersion    getDerbyVersion()      { return _derbyVersion; }
1:     }
1: 
1:     /**
1:      * Helper class capturing TypeCoercion logic.
1:      * <p>
1:      * I have abbreviated it to this ugly class name so that the COERCIONS
1:      * table will fit on a readable screen.
1:      */
1:     public    static    final    class    T_CN
1:     {
1:         private    int            _jdbcType;
1:         private    boolean[]    _coercions;
1: 
1:         public    T_CN( int jdbcType, boolean[] coercions )
1:         {
1:             _jdbcType = jdbcType;
1:             _coercions = coercions;
1:         }
1: 
1:         public    int          getJdbcType()             { return _jdbcType; }
1:         public    boolean[]    getCoercions()            { return _coercions; }
1:     }
1: 
1:     /**
1:      * Returns a suite with all the available JDBC client driver compatibility
1:      * tests.
1:      * <p>
1:      * JUnit boilerplate which adds as test cases all public methods
1:      * whose names start with the string "test" in the named classes.
1:      */
1:     public static Test suite() {
0:         TestSuite testSuite = new TestSuite("JDBCDriverTest suite");
1:         testSuite.addTestSuite(JDBCDriverTest.class);
1:         return TestConfiguration.defaultExistingServerDecorator(
1:                 new BaseJDBCTestSetup(testSuite) {
1: 
1:                     protected void setUp() throws Exception {
1:                         super.setUp();
1:                         Connection con = getConnection();
1:                         Statement s = con.createStatement();
1:                         // We can't use Connection.getSchema yet.
1:                         ResultSet rs = s.executeQuery("values CURRENT SCHEMA");
1:                         rs.next();
1:                         String schema = rs.getString(1);
1:                         rs.close();
1:                         s.close();
1:                         con.setAutoCommit(false);
1:                         // Drop the current schema to clean up. Hopefully this
1:                         // is enough to start "reset" the database for each
1:                         // client run (running the newest CleanDatabaseTestSetup
1:                         // fails on older versions).
1:                         JDBC.dropSchema(con.getMetaData(), schema);
1:                         con.commit();
1: 
1:                         // Initialize the database for the tests.
1:                         con.setAutoCommit(true);
1:                         createTable(con, ALL_TYPES_TABLE, ALL_TYPES);
1:                         createUDTObjects(con);
1:                         create_derby_2602_objects(con);
1:                     }
1:                 });
1:     }
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:4087714
commit:0438c35
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.compatibility.JDBCDriverTest
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: /**
0:  * <p>
0:  * This JUnit test verifies the compatibility of Derby clients and
0:  * servers across Derby version levels and supported VMs.
0:  * </p>
0:  *
0:  * @author Rick
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.compatibility;
0: 
0: import java.io.*;
0: import java.math.*;
0: import java.sql.*;
0: import java.util.*;
0: 
0: import junit.framework.*;
0: 
0: import org.apache.derbyTesting.functionTests.util.DerbyJUnitTest;
0: 
0: public	class	JDBCDriverTest	extends	DerbyJUnitTest
0: {
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTANTS
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	/** If you set this startup property to true, you will get chatty output. */
0: 	public	static	final			String	DEBUG_FLAG = "drb.tests.debug";
0: 	
0: 	public	static	final			int		SUCCESS_EXIT = 0;
0: 	public	static	final			int		FAILURE_EXIT = 1;
0: 
0: 	//
0: 	// These are properties for the Derby connection URL.
0: 	//
0: 	private	static	final			String	VERSION_PROPERTY = "java.version";
0: 	private	static	final			String	SERVER_URL = "jdbc:derby://localhost:1527/";
0: 	private	static	final			String	CREATE_PROPERTY = "create=true";
0: 
0: 	private	static	final			String	ALL_TYPES_TABLE = "allTypesTable";
0: 	private	static	final			String	KEY_COLUMN = "keyCol";
0: 	
0: 	private	static	final			int		EXPECTED_CLIENT_COUNT = 1;
0: 
0: 	//
0: 	// Indexes into the array of client-specific strings. E.g., DB2JCC_CLIENT,
0: 	// DERBY_CLIENT, and EMBEDDED_CLIENT.
0: 	//
0: 	private	static	final			int		DATABASE_URL = 0;
0: 	private	static	final			int		DRIVER_NAME = DATABASE_URL + 1;
0: 
0: 	//
0: 	// Data values to be stuffed into columns of ALL_TYPES_TABLE.
0: 	//
0: 	private	static	final			byte[]	SAMPLE_BYTES =
0: 		new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5 };
0: 	private	static	final			String	SAMPLE_STRING = "hello";
0: 
0: 	//
0: 	// These funny constants are defined this way to make the salient
0: 	// facts of the COERCIONS table leap out at you.
0: 	//
0: 	private	static	final			boolean	Y = true;
0: 	private	static	final			boolean	_ = false;
0: 
0: 	// indexed by DATABASE_URL and DRIVER_NAME
0: 	private	static	final	String[]	DB2JCC_CLIENT =
0: 	{
0: 		"jdbc:derby:net://localhost:1527/",
0: 		"com.ibm.db2.jcc.DB2Driver"
0: 	};
0: 	private	static	final	String[]	DERBY_CLIENT =
0: 	{
0: 		"jdbc:derby://localhost:1527/",
0: 		"org.apache.derby.jdbc.ClientDriver"
0: 	};
0: 	private	static	final	String[]	EMBEDDED_CLIENT =
0: 	{
0: 		"jdbc:derby:",
0: 		"org.apache.derby.jdbc.EmbeddedDriver"
0: 	};
0: 
0: 	private	static	final	String[][]	LEGAL_CLIENTS =
0: 	{
0: 		DB2JCC_CLIENT,
0: 		DERBY_CLIENT,
0: 		EMBEDDED_CLIENT
0: 	};
0: 	
0: 	private	static	final	String	DEFAULT_USER_NAME = "APP";
0: 	private	static	final	String	DEFAULT_PASSWORD = "APP";
0: 
0: 	// Supported versions of the db2jcc client.
0: 	private	static	final	Version	IBM_2_4 = new Version( 2, 4 );
0: 
0: 	// Supported versions of Derby.
0: 	private	static	final	Version	DRB_10_0 = new Version( 10, 0 );
0: 	private	static	final	Version	DRB_10_1 = new Version( 10, 1 );
0: 	private	static	final	Version	DRB_10_2 = new Version( 10, 2 );
0: 
0: 	// Supported VM versions.
0: 	private	static	final	Version	VM_1_3 = new Version( 1, 3 );
0: 	private	static	final	Version	VM_1_4 = new Version( 1, 4 );
0: 	private	static	final	Version	VM_1_5 = new Version( 1, 5 );
0: 
0: 	//
0: 	// This table declares the datatypes supported by Derby and the earliest
0: 	// versions of the Derby and the db2jcc client which support these
0: 	// datatypes.
0: 	//
0: 	// If you add a type to this table, make sure you add a corresponding
0: 	// column to the following row table. Also add a corresponding row to the
0: 	// COERCIONS table.
0: 	//
0: 	private	static	final	TypeDescriptor[]	ALL_TYPES =
0: 	{
0: 		// 10.0 types
0: 		
0: 		new TypeDescriptor
0: 		( Types.BIGINT,			"bigint",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.BLOB,			"blob",							IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.CHAR,			"char(5)",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.BINARY,			"char(5) for bit data",			IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.CLOB,			"clob",							IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.DATE,			"date",							IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.DECIMAL,		"decimal",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.DOUBLE,			"double",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.DOUBLE,			"double precision",				IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.REAL,			"float(23)",					IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.DOUBLE,			"float",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.INTEGER,		"integer",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.LONGVARCHAR,	"long varchar",					IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.LONGVARBINARY,	"long varchar for bit data",	IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.NUMERIC,		"numeric",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.REAL,			"real",							IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.SMALLINT,		"smallint",						IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.TIME,			"time",							IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.TIMESTAMP,		"timestamp",					IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.VARCHAR,		"varchar(5)",					IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 		new TypeDescriptor
0: 		( Types.VARBINARY,		"varchar(5) for bit data",		IBM_2_4,	DRB_10_0,	VM_1_3 ),
0: 	};
0: 
0: 	//
0: 	// This table needs to have the same number of entries as ALL_TYPES.
0: 	// The testSanity() test case enforces this at run time.
0: 	//
0: 	private	static	final	Object[]	ROW_1 =
0: 	{
0: 		new Long( 1L ),
0: 		new MyBlob( SAMPLE_BYTES ),
0: 		SAMPLE_STRING,
0: 		SAMPLE_BYTES,
0: 		new MyClob( SAMPLE_STRING ),
0: 		new java.sql.Date( 1L ),
0: 		new BigDecimal( 1.0 ),
0: 		new Double( 1.0 ),
0: 		new Double( 1.0 ),
0: 		new Float( (float) 1.0 ),
0: 		new Double( 1.0 ),
0: 		new Integer( 1 ),
0: 		SAMPLE_STRING,
0: 		SAMPLE_BYTES,
0: 		new BigDecimal( 1.0 ),
0: 		new Float( (float) 1.0 ),
0: 		new Short( (short) 1 ),
0: 		new Time( 1L ),
0: 		new Timestamp( 1L ),
0: 		SAMPLE_STRING,
0: 		SAMPLE_BYTES,
0: 	};
0: 
0: 	//
0: 	// This table needs to have the same number of rows as ALL_TYPES.
0: 	// Each row in this table needs to have the same number of columns as
0: 	// rows in ALL_TYPES. The testSanity() test case enforces this at run time.
0: 	// Note how the funny synonyms for true and false
0: 	// make the salient facts of this table leap out at you.
0: 	//
0: 	// The ugly class name T_CN is an abbreviation which makes it possible to
0: 	// squeeze this table onto a readable screen.
0: 	//
0: 	// Please read the introductory comment top-to-bottom. 'Y' means a coercion
0: 	// is legal; '_' means it isn't.
0: 	//
0: 	private	static	final	T_CN[]	COERCIONS =
0: 	{
0: 		//												  B|B|C|B|C|D|D|D|R|I|L|L|N|R|S|T|T|V|V
0: 		//												  I|L|H|I|L|A|E|O|E|N|O|O|U|E|M|I|I|A|A
0: 		//												  G|O|A|N|O|T|C|U|A|T|N|N|M|A|A|M|M|R|R
0: 		//												  I|B|R|A|B|E|I|B|L|E|G|G|E|L|L|E|E|C|B
0: 		//												  N|-|-|R|-|-|M|L|-|G|V|V|R|-|L|-|S|H|I
0: 		//												  T|-|-|Y|-|-|A|E|-|E|A|A|I|-|I|-|T|A|N
0: 		//												  -|-|-|-|-|-|L|-|-|R|R|R|C|-|N|-|A|R|A
0: 		//												  -|-|-|-|-|-|-|-|-|-|C|B|-|-|T|-|M|-|R
0: 		//												  -|-|-|-|-|-|-|-|-|-|H|I|-|-|-|-|P|-|Y
0: 		//												  -|-|-|-|-|-|-|-|-|-|A|N|-|-|-|-|-|-|-
0: 		//												  -|-|-|-|-|-|-|-|-|-|R|A|-|-|-|-|-|-|-
0: 		//												  -|-|-|-|-|-|-|-|-|-|-|R|-|-|-|-|-|-|-
0: 		//												  -|-|-|-|-|-|-|-|-|-|-|Y|-|-|-|-|-|-|-
0: 		new T_CN( Types.BIGINT, new boolean[]			{ Y,_,Y,_,_,_,_,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.BLOB, new boolean[] 			{ _,Y,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_, } ),
0: 		new T_CN( Types.CHAR, new boolean[]				{ _,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y,_, } ),
0: 		new T_CN( Types.BINARY, new boolean[]			{ _,_,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y, } ),
0: 		new T_CN( Types.CLOB, new boolean[]				{ _,_,_,_,Y,_,_,_,_,_,_,_,_,_,_,_,_,_,_, } ),
0: 		new T_CN( Types.DATE, new boolean[]				{ _,_,_,_,_,Y,_,_,_,_,_,_,_,_,_,_,_,_,_, } ),
0: 		new T_CN( Types.DECIMAL, new boolean[]			{ Y,_,_,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.DOUBLE, new boolean[]			{ Y,_,_,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.REAL, new boolean[]				{ Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.INTEGER, new boolean[]			{ Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.LONGVARCHAR, new boolean[]		{ _,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y,_, } ),
0: 		new T_CN( Types.LONGVARBINARY, new boolean[]	{ _,_,_,_,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y, } ),
0: 		new T_CN( Types.NUMERIC, new boolean[]			{ Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.REAL, new boolean[]				{ Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.SMALLINT, new boolean[]			{ Y,_,Y,_,_,_,Y,Y,Y,Y,Y,_,Y,Y,Y,_,_,Y,_, } ),
0: 		new T_CN( Types.TIME, new boolean[]				{ _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,Y,_,_,_, } ),
0: 		new T_CN( Types.TIMESTAMP, new boolean[]		{ _,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,Y,_,_, } ),
0: 		new T_CN( Types.VARCHAR, new boolean[]			{ _,_,Y,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y,_, } ),
0: 		new T_CN( Types.VARBINARY, new boolean[]		{ _,_,_,_,_,_,_,_,_,_,_,Y,_,_,_,_,_,_,Y, } ),
0: 	};
0: 
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATE
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	private	static	boolean		_debug;					// if true, we print chatty diagnostics
0: 	
0: 	private	static	PrintStream	_outputStream = System.out;	// where to print debug output
0: 
0: 	private	static	String[]	_defaultClientSettings;	// one of the clients in LEGAL_CLIENTS
0: 	private	static	Driver		_driver;				// the corresponding jdbc driver
0: 	private	static	String		_databaseName;			// sandbox for tests
0: 	private	static	Version		_clientVMLevel;			// level of client-side vm
0: 	private	static	Version		_driverLevel;			// client rev level
0: 	private	static	Version		_serverLevel;			// server rev level
0: 
0: 	// map derby type name to type descriptor
0: 	private	static	HashMap		_types = new HashMap();	// maps Derby type names to TypeDescriptors
0: 
0: 	// map jdbc type to index into COERCIONS
0: 	private	static	HashMap		_coercionIndex = new HashMap();	// maps jdbc types to legal coercions
0: 
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTOR
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 	
0: 	public	JDBCDriverTest() {}
0: 
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	JUnit BEHAVIOR
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * <p>
0: 	 * JUnit boilerplate which adds as test cases all public methods
0: 	 * whose names start with the string "test".
0: 	 * </p>
0: 	 */
0: 	public static Test suite()
0: 	{ 
0: 		return new TestSuite( JDBCDriverTest.class ); 
0: 	}
0: 
0: 
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	ENTRY POINT
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * <p>
0: 	 * Run JDBC compatibility tests using either the specified client or
0: 	 * the client that is visible
0: 	 * on the classpath. If there is more than one client on the classpath,
0: 	 * exits with an error.
0: 	 * </p>
0: 	 *
0: 	 * <ul>
0: 	 * <li>arg[ 0 ] = required name of database to connect to</li>
0: 	 * <li>arg[ 1 ] = optional driver to use. if not specified, we'll look for a
0: 	 *                client on the classpath</li>
0: 	 * </ul>
0: 	 */
0: 	public static void main( String args[] )
0: 		throws Exception
0: 	{
0: 		int			exitStatus = FAILURE_EXIT;
0: 		
0: 		if (
0: 			   parseDebug() &&
0: 			   parseArgs( args ) &&
0: 			   parseVMLevel() &&
0: 			   findClient() &&
0: 			   findServer()
0: 		   )
0: 		{		
0: 			TestResult	result = junit.textui.TestRunner.run( suite() );
0: 			
0: 			exitStatus = result.errorCount() + result.failureCount();
0: 		}
0: 
0: 		Runtime.getRuntime().exit( exitStatus );
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	TEST ENTRY POINTS
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * <p>
0: 	 * Sanity check the integrity of this test suite.
0: 	 * </p>
0: 	 */
0: 	public	void	testSanity()
0: 	{
0: 		assertEquals( "ALL_TYPES.length == ROW_1.length", ALL_TYPES.length, ROW_1.length );
0: 
0: 		// make sure there we completely describe the coercibility of every jdbc type
0: 		int		coercionCount = COERCIONS.length;
0: 		for ( int i = 0; i < coercionCount; i++ )
0: 		{ assertEquals( "Coercion " + i, coercionCount, COERCIONS[ i ].getCoercions().length ); }
0: 	}
0: 
0: 	/**
0: 	 * <p>
0: 	 * Main test of jdbc drivers.
0: 	 * </p>
0: 	 */
0: 	public	void	testJDBCDriver()
0: 		throws Exception
0: 	{
0: 		Connection		conn = getConnection();
0: 		
0: 		dropSchema( conn );
0: 		createSchema( conn );
0: 
0: 		datatypesTest( conn );
0: 
0: 		close( conn );
0: 	}
0: 	
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	TEST DATATYPES
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	//
0: 	// Test that we can declare, insert, and select all datatypes that
0: 	// are legal on the server. Test the metadata for these datatypes.
0: 	//
0: 	private	void	datatypesTest( Connection conn )
0: 		throws Exception
0: 	{
0: 		Object[][]	rows = new Object[][] { makeNullRow(), ROW_1 };
0: 		
0: 		checkTypeDBMetadata( conn );
0: 		stuffAllTypesTable( conn, rows );
0: 		readAllTypesTable( conn, rows );
0: 	}
0: 	
0: 	//
0: 	// Verify that we get the correct DatabaseMetaData for all datatypes
0: 	// that are legal on the server.
0: 	//
0: 	private	void	checkTypeDBMetadata( Connection conn )
0: 		throws Exception
0: 	{
0: 		String				normalizedSchema = DEFAULT_USER_NAME.toUpperCase();
0: 		String				normalizedTable = ALL_TYPES_TABLE.toUpperCase();
0: 		DatabaseMetaData	dbmd = conn.getMetaData();
0: 
0: 		ResultSet			rs = dbmd.getColumns
0: 			( null, normalizedSchema, normalizedTable, "%" );
0: 
0: 		println( "Pawing through metadata for " + normalizedSchema + '.' + normalizedTable );
0: 		
0: 		while( rs.next() )
0: 		{
0: 			String			columnName = rs.getString( "COLUMN_NAME" );
0: 			int				actualJdbcType = rs.getInt( "DATA_TYPE" );
0: 			TypeDescriptor	typeDesc = getType( columnName );
0: 
0: 			if ( columnName.equals( KEY_COLUMN ) ) { continue; }
0: 
0: 			StringBuffer	buffer = new StringBuffer();
0: 
0: 			buffer.append( "[ " );
0: 			buffer.append( rs.getString( "COLUMN_NAME" ) );
0: 			buffer.append( ",\t" );
0: 			buffer.append( "type( " + rs.getInt( "DATA_TYPE" ) + " ),\t" );
0: 			buffer.append( rs.getString( "TYPE_NAME" ) );
0: 			buffer.append( " ]" );
0: 
0: 			println( buffer.toString() );
0: 			
0: 			assertEquals( columnName, typeDesc.getJdbcType(), actualJdbcType );
0: 		}
0: 
0: 		close( rs );
0: 	}
0: 
0: 	//
0: 	// Verify that we can insert all datatypes that are legal on the
0: 	// server.
0: 	//
0: 	private	void	stuffAllTypesTable( Connection conn, Object[][] rows )
0: 		throws Exception
0: 	{
0: 		StringBuffer	masterBuffer = new StringBuffer();
0: 		StringBuffer	columnBuffer = new StringBuffer();
0: 		StringBuffer	valuesBuffer = new StringBuffer();
0: 		int				columnNumber = 0;
0: 		int				valuesNumber = 0;
0: 		int				typeCount = ALL_TYPES.length;
0: 
0: 		beginColumnList( columnBuffer );
0: 		beginColumnList( valuesBuffer );
0: 
0: 		addColumn( columnBuffer, columnNumber++, doubleQuote( KEY_COLUMN ) );
0: 		addColumn( valuesBuffer, valuesNumber++, "?" );
0: 		
0: 		for ( int i = 0; i < typeCount; i++ )
0: 		{
0: 			TypeDescriptor	type = ALL_TYPES[ i ];
0: 			
0: 			if ( _serverLevel.atLeast( type.getDerbyVersion() ) )
0: 			{
0: 				String	typeName = type.getDerbyTypeName();
0: 				String	columnDesc = doubleQuote( typeName );
0: 				
0: 				addColumn( columnBuffer, columnNumber++, columnDesc );
0: 				addColumn( valuesBuffer, valuesNumber++, "?" );
0: 			}
0: 		}
0: 
0: 		endColumnList( columnBuffer );
0: 		endColumnList( valuesBuffer );
0: 
0: 		masterBuffer.append( "insert into " + ALL_TYPES_TABLE + "\n" );
0: 		masterBuffer.append( columnBuffer.toString() );
0: 		masterBuffer.append( "values\n" );
0: 		masterBuffer.append( valuesBuffer.toString() );
0: 
0: 		PreparedStatement	ps = prepare( conn, masterBuffer.toString() );
0: 		int					rowCount = rows.length;
0: 
0: 		for ( int i = 0; i < rowCount; i++ )
0: 		{
0: 			setRow( ps, i + 1, rows[ i ] );
0: 		}
0: 		
0: 		close( ps );
0: 	}
0: 
0: 	//
0: 	// Verify that we can select all datatypes that are legal on the server.
0: 	//
0: 	private	void	readAllTypesTable( Connection conn, Object[][] rows )
0: 		throws Exception
0: 	{
0: 		StringBuffer	buffer = new StringBuffer();
0: 		int				columnNumber = 0;
0: 		int				typeCount = ALL_TYPES.length;
0: 
0: 		buffer.append( "select \n" );
0: 
0: 		addColumn( buffer, columnNumber++, doubleQuote( KEY_COLUMN ) );
0: 		
0: 		for ( int i = 0; i < typeCount; i++ )
0: 		{
0: 			TypeDescriptor	type = ALL_TYPES[ i ];
0: 			
0: 			if ( _serverLevel.atLeast( type.getDerbyVersion() ) )
0: 			{
0: 				String	typeName = type.getDerbyTypeName();
0: 				String	columnDesc = doubleQuote( typeName );
0: 				
0: 				addColumn( buffer, columnNumber++, columnDesc );
0: 			}
0: 		}
0: 
0: 		buffer.append( "\nfrom " + ALL_TYPES_TABLE + "\n" );
0: 		buffer.append( "order by " + doubleQuote( KEY_COLUMN ) );
0: 
0: 		PreparedStatement	ps = prepare( conn, buffer.toString() );
0: 		ResultSet			rs = ps.executeQuery();
0: 
0: 		checkRSMD( rs );
0: 		checkRows( rs, rows );
0: 		
0: 		close( rs );
0: 		close( ps );
0: 	}
0: 
0: 	//
0: 	// Verify that we get the correct ResultSetMetaData for all datatypes
0: 	// which are legal on the server.
0: 	//
0: 	private	void	checkRSMD( ResultSet rs )
0: 		throws Exception
0: 	{
0: 		ResultSetMetaData	rsmd = rs.getMetaData();
0: 		int					columnCount = rsmd.getColumnCount();
0: 		int					firstTastyColumn = 0;
0: 
0: 		println( "Column count = " + columnCount );
0: 		
0: 		firstTastyColumn++;				// skip uninteresting key column
0: 
0: 		for ( int i = firstTastyColumn; i < columnCount; i++ )
0: 		{
0: 			int				columnID = i + 1;
0: 			String			columnName = rsmd.getColumnName( columnID );
0: 			TypeDescriptor	typeDesc = getType( columnName );
0: 			int				expectedType = rsmdTypeKludge( typeDesc.getJdbcType() );
0: 			int				actualType = rsmd.getColumnType( columnID );
0: 			
0: 			println( "Checking type of " + columnName );
0: 
0: 			assertEquals( columnName, expectedType, actualType );
0: 		}
0: 	}
0: 
0: 	//
0: 	// Verify that we select the values we
0: 	// originally inserted into a table.
0: 	//
0: 	private	void	checkRows( ResultSet rs, Object[][] rows )
0: 		throws Exception
0: 	{
0: 		int					rowCount = rows.length;
0: 
0: 		for ( int i = 0; i < rowCount; i++ )
0: 		{
0: 			rs.next();
0: 			checkRow( rs, rows[ i ] );
0: 		}
0: 	}
0: 
0: 	//
0: 	// Verify that we select the values we
0: 	// originally inserted into a row.
0: 	//
0: 	private	void	checkRow( ResultSet rs, Object[] row )
0: 		throws Exception
0: 	{
0: 		int				typeCount = ALL_TYPES.length;
0: 
0: 		for ( int i = 0; i < typeCount; i++ )
0: 		{
0: 			TypeDescriptor	type = ALL_TYPES[ i ];
0: 			
0: 			if ( _serverLevel.atLeast( type.getDerbyVersion() ) )
0: 			{
0: 				String	columnName = type.getDerbyTypeName();
0: 				Object	expectedValue = row[ i ];
0: 				Object	actualValue = getColumn( rs, columnName, type );
0: 
0: 				println( "Comparing column " + columnName + ": " + expectedValue + " to " + actualValue );
0: 				compareObjects( columnName, expectedValue, actualValue );
0: 
0: 				checkCoercions( rs, columnName, type );
0: 			}
0: 		}
0: 	}
0: 
0: 	//
0: 	// Verify all legal jdbc coercions of a data value.
0: 	//
0: 	private	void	checkCoercions( ResultSet rs, String columnName, TypeDescriptor type )
0: 		throws Exception
0: 	{
0: 		T_CN		coercionDesc = COERCIONS[ getCoercionIndex( type.getJdbcType() ) ];
0: 		boolean[]	coercions = coercionDesc.getCoercions();
0: 		int			count = coercions.length;
0: 		int			legalCoercions = 0;
0: 
0: 		println( "Checking coercions for " + columnName );
0: 		
0: 		for ( int i = 0; i < count; i++ )
0: 		{
0: 			if ( coercions[ i ] )
0: 			{
0: 				legalCoercions++;
0: 				
0: 				Object	retval = getColumn( rs, columnName, COERCIONS[ i ].getJdbcType() );
0: 			}
0: 		}
0: 
0: 		println( "   Checked " + legalCoercions + " coercions for " + columnName );
0: 	}
0: 	
0: 	//
0: 	// This kludge compensates for the fact that the DRDA clients report
0: 	// that NUMERIC columns are DECIMAL. See bug 584.
0: 	//
0: 	private	int	rsmdTypeKludge( int originalJDbcType )
0: 	{
0: 		// The embedded client does the right thing.
0: 		if ( _defaultClientSettings == EMBEDDED_CLIENT ) { return originalJDbcType; }
0: 		
0: 		switch( originalJDbcType )
0: 		{
0: 			case Types.NUMERIC:	return Types.DECIMAL;
0: 
0: 		    default:			return originalJDbcType;
0: 		}
0: 	}
0: 
0: 	//
0: 	// Insert a row into the ALL_TYPES table. The row contains all datatypes
0: 	// that are legal on the server.
0: 	//
0: 	private	void	setRow( PreparedStatement ps, int keyValue, Object[] row )
0: 		throws Exception
0: 	{
0: 		int				param = 1;
0: 		int				typeCount = ALL_TYPES.length;
0: 
0: 		ps.setInt( param++, keyValue );
0: 
0: 		for ( int i = 0; i < typeCount; i++ )
0: 		{
0: 			TypeDescriptor	type = ALL_TYPES[ i ];
0: 			Object			value = row[ i ];
0: 			
0: 			if ( _serverLevel.atLeast( type.getDerbyVersion() ) )
0: 			{
0: 				setParameter( ps, param++, type, value );
0: 			}
0: 		}
0: 
0: 		ps.execute();
0: 	}
0: 
0: 	private	Object[]	makeNullRow()
0: 	{
0: 		return new Object[ ALL_TYPES.length ];
0: 	}
0: 
0: 	//
0: 	// Index the TypeDescriptors by Derby type name.
0: 	//
0: 	private	void	buildTypeMap()
0: 	{
0: 		int				typeCount = ALL_TYPES.length;
0: 
0: 		for ( int i = 0; i < typeCount; i++ ) { putType( ALL_TYPES[ i ] ); }
0: 	}
0: 	private	void	putType( TypeDescriptor type )
0: 	{
0: 		_types.put( type.getDerbyTypeName(), type );
0: 	}
0: 
0: 	//
0: 	// Lookup TypeDescriptors by Derby tgype name.
0: 	//
0: 	private	TypeDescriptor	getType( String typeName )
0: 	{
0: 		if ( _types.size() == 0 ) { buildTypeMap(); }
0: 		
0: 		return (TypeDescriptor) _types.get( typeName );
0: 	}
0: 
0: 	//
0: 	// Index legal coercions by jdbc type.
0: 	//
0: 	private	void	buildCoercionMap()
0: 	{
0: 		int				count = COERCIONS.length;
0: 
0: 		for ( int i = 0; i < count; i++ ) { putCoercionIndex( i ); }
0: 	}
0: 	private	void	putCoercionIndex( int index )
0: 	{
0: 		_coercionIndex.put( new Integer( COERCIONS[ index ].getJdbcType() ), new Integer( index ) );
0: 	}
0: 
0: 	//
0: 	// Lookup the legal coercions for a given jdbc type.
0: 	//
0: 	private	int	getCoercionIndex( int jdbcType )
0: 	{
0: 		if ( _coercionIndex.size() == 0 ) { buildCoercionMap(); }
0: 		
0: 		return ((Integer) _coercionIndex.get( new Integer( jdbcType ) )).intValue();
0: 	}
0: 	
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	MINIONS
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 	
0: 	///////////////////
0: 	//
0: 	//	TYPE MANAGEMENT
0: 	//
0: 	///////////////////
0: 	
0: 	//////////////////
0: 	//
0: 	//	SCHEMA MINIONS
0: 	//
0: 	//////////////////
0: 
0: 	//
0: 	// Create all the tables needed by our test cases.
0: 	//
0: 	private	void	createSchema( Connection conn )
0: 		throws Exception
0: 	{
0: 		createAllTypesTable( conn );
0: 	}
0: 
0: 	//
0: 	// Create the table for testing legal datatypes.
0: 	//
0: 	private	void	createAllTypesTable( Connection conn )
0: 		throws Exception
0: 	{
0: 		StringBuffer	buffer = new StringBuffer();
0: 		int				columnNumber = 0;
0: 		int				typeCount = ALL_TYPES.length;
0: 
0: 		buffer.append( "create table " + ALL_TYPES_TABLE + "\n" );
0: 		beginColumnList( buffer );
0: 
0: 		addColumn( buffer, columnNumber++, doubleQuote( KEY_COLUMN ) + "\tint" );
0: 		
0: 		for ( int i = 0; i < typeCount; i++ )
0: 		{
0: 			TypeDescriptor	type = ALL_TYPES[ i ];
0: 			
0: 			if ( _serverLevel.atLeast( type.getDerbyVersion() ) )
0: 			{
0: 				String	typeName = type.getDerbyTypeName();
0: 				String	columnDesc = doubleQuote( typeName ) + '\t' + typeName;
0: 				
0: 				addColumn( buffer, columnNumber++, columnDesc );
0: 			}
0: 		}
0: 
0: 		endColumnList( buffer );
0: 
0: 		PreparedStatement	ps = prepare( conn, buffer.toString() );
0: 
0: 		ps.execute();
0: 
0: 		close( ps );
0: 	}
0: 
0: 	//
0: 	// Helper methods for declaring a table.
0: 	//
0: 	private	void	beginColumnList( StringBuffer buffer )
0: 	{
0: 		buffer.append( "(\n" );
0: 	}
0: 	private	void	endColumnList( StringBuffer buffer )
0: 	{
0: 		buffer.append( "\n)\n" );
0: 	}
0: 	private	void	addColumn( StringBuffer buffer, int columnNumber, String text  )
0: 	{
0: 		if ( columnNumber > 0 ) { buffer.append( "," ); }
0: 
0: 		buffer.append( "\n\t" );
0: 		buffer.append( text );
0: 	}
0: 	
0: 	//
0: 	// Drop the tables used by our test cases.
0: 	//
0: 	private	void	dropSchema( Connection conn )
0: 	{
0: 		dropTable( conn, ALL_TYPES_TABLE );
0: 	}
0: 	private	void	dropTable( Connection conn, String tableName )
0: 	{
0: 		PreparedStatement	ps = null;
0: 		
0: 		try {
0: 			ps = prepare( conn, "drop table " + tableName );
0: 
0: 			ps.execute();
0: 		}
0: 		catch (SQLException e) {}
0: 
0: 		close( ps );
0: 	}
0: 
0: 	///////////////
0: 	//
0: 	//	SQL MINIONS
0: 	//
0: 	///////////////
0: 
0: 	/**
0: 	 * <p>
0: 	 * Create an empty database.
0: 	 * </p>
0: 	 */
0: 	public	void	createDB( String databaseName )
0: 		throws Exception
0: 	{
0: 		String[]	clientSettings = _defaultClientSettings;
0: 		String		dbURL = makeDatabaseURL( clientSettings, databaseName );
0: 
0: 		dbURL = dbURL + ';' + CREATE_PROPERTY;
0: 
0: 		Properties	properties = new Properties();
0: 
0: 		properties.put( "user", DEFAULT_USER_NAME );
0: 		properties.put( "password", DEFAULT_PASSWORD );
0: 
0: 		faultInDriver( clientSettings );
0: 
0: 		Connection		conn = DriverManager.getConnection( dbURL, properties );
0: 
0: 		conn.close();
0: 	}
0: 
0: 	// Get a connection to the server.
0: 	private	static	Connection	getConnection()
0: 		throws Exception
0: 	{
0: 		return getConnection( _defaultClientSettings, _databaseName, new Properties() );
0: 	}
0: 	private	static	Connection	getConnection
0: 	(
0: 	    String[]	clientSettings,
0: 		String		databaseName,
0: 		Properties	properties
0: 	)
0: 		throws Exception
0: 	{
0: 		faultInDriver( clientSettings );
0: 
0: 		properties.put( "user", DEFAULT_USER_NAME );
0: 		properties.put( "password", DEFAULT_PASSWORD );
0: 		properties.put( "retreiveMessagesFromServerOnGetMessage", "true" );
0: 
0: 		Connection		conn = DriverManager.getConnection
0: 			( makeDatabaseURL( clientSettings, databaseName ), properties );
0: 
0: 		println( "Connection is a " + conn.getClass().getName() );
0: 		
0: 		return conn;
0: 	}
0: 
0: 	// Build the connection URL.
0: 	private	static	String	makeDatabaseURL( String[] clientSettings, String databaseName )
0: 	{
0: 		return clientSettings[ DATABASE_URL ] + databaseName;
0: 	}
0: 
0: 	//
0: 	// Thin wrapper around jdbc layer to support debugging.
0: 	//
0: 	private	PreparedStatement	prepare( Connection conn, String text )
0: 		throws SQLException
0: 	{
0: 		println( "Preparing: " + text );
0: 
0: 		return conn.prepareStatement( text );
0: 	}
0: 
0: 	//
0: 	// Logic for stuffing a data value into a column, given its type.
0: 	//
0: 	private	void	setParameter( PreparedStatement ps, int param, TypeDescriptor type, Object value )
0: 		throws Exception
0: 	{
0: 		int		jdbcType = type.getJdbcType();
0: 
0: 		if ( value == null )
0: 		{
0: 			ps.setNull( param, jdbcType );
0: 
0: 			return;
0: 		}
0: 
0: 		switch( jdbcType )
0: 		{
0: 		    case Types.BIGINT:
0: 				ps.setLong( param, ((Long) value ).longValue() );
0: 				break;
0: 				
0: 		    case Types.BLOB:
0: 				ps.setBlob( param, ((Blob) value ) );
0: 				break;
0: 				
0: 		    case Types.CHAR:
0: 		    case Types.LONGVARCHAR:
0: 		    case Types.VARCHAR:
0: 				ps.setString( param, ((String) value ) );
0: 				break;
0: 				
0: 		    case Types.BINARY:
0: 		    case Types.LONGVARBINARY:
0: 		    case Types.VARBINARY:
0: 				ps.setBytes( param, (byte[]) value );
0: 				break;
0: 				
0: 		    case Types.CLOB:
0: 				ps.setClob( param, ((Clob) value ) );
0: 				break;
0: 				
0: 		    case Types.DATE:
0: 				ps.setDate( param, ((java.sql.Date) value ) );
0: 				break;
0: 				
0: 		    case Types.DECIMAL:
0: 		    case Types.NUMERIC:
0: 				ps.setBigDecimal( param, ((BigDecimal) value ) );
0: 				break;
0: 				
0: 		    case Types.DOUBLE:
0: 				ps.setDouble( param, ((Double) value ).doubleValue() );
0: 				break;
0: 				
0: 		    case Types.REAL:
0: 				ps.setFloat( param, ((Float) value ).floatValue() );
0: 				break;
0: 				
0: 		    case Types.INTEGER:
0: 				ps.setInt( param, ((Integer) value ).intValue() );
0: 				break;
0: 				
0: 		    case Types.SMALLINT:
0: 				ps.setShort( param, ((Short) value ).shortValue() );
0: 				break;
0: 				
0: 		    case Types.TIME:
0: 				ps.setTime( param, (Time) value );
0: 				break;
0: 				
0: 		    case Types.TIMESTAMP:
0: 				ps.setTimestamp( param, (Timestamp) value );
0: 				break;
0: 				
0: 		    default:
0: 				fail( "Unknown jdbc type for Derby type: " + type.getDerbyTypeName() );
0: 				break;
0: 		}
0: 	}
0: 	
0: 	//
0: 	// Get a data value from a column, given its type.
0: 	//
0: 	private	Object	getColumn( ResultSet rs, String columnName, TypeDescriptor type )
0: 		throws Exception
0: 	{
0: 		int			jdbcType = type.getJdbcType();
0: 
0: 		return getColumn( rs, columnName, jdbcType );
0: 	}
0: 	private	Object	getColumn( ResultSet rs, String columnName, int jdbcType )
0: 		throws Exception
0: 	{
0: 		Object		retval = null;
0: 
0: 		switch( jdbcType )
0: 		{
0: 		    case Types.BIGINT:
0: 				retval = new Long( rs.getLong( columnName ) );
0: 				break;
0: 				
0: 		    case Types.BLOB:
0: 				retval = rs.getBlob( columnName );
0: 				break;
0: 				
0: 		    case Types.CHAR:
0: 		    case Types.LONGVARCHAR:
0: 		    case Types.VARCHAR:
0: 				retval = rs.getString( columnName );
0: 				break;
0: 				
0: 		    case Types.BINARY:
0: 		    case Types.LONGVARBINARY:
0: 		    case Types.VARBINARY:
0: 				retval = rs.getBytes( columnName );
0: 				break;
0: 				
0: 		    case Types.CLOB:
0: 				retval = rs.getClob( columnName );
0: 				break;
0: 				
0: 		    case Types.DATE:
0: 				retval = rs.getDate( columnName );
0: 				break;
0: 				
0: 		    case Types.DECIMAL:
0: 		    case Types.NUMERIC:
0: 				retval = rs.getBigDecimal( columnName );
0: 				break;
0: 				
0: 		    case Types.DOUBLE:
0: 				retval = new Double( rs.getDouble( columnName ) );
0: 				break;
0: 				
0: 		    case Types.REAL:
0: 				retval = new Float( rs.getFloat( columnName ) );
0: 				break;
0: 				
0: 		    case Types.INTEGER:
0: 				retval = new Integer( rs.getInt( columnName ) );
0: 				break;
0: 				
0: 		    case Types.SMALLINT:
0: 				retval = new Short( rs.getShort( columnName ) );
0: 				break;
0: 				
0: 		    case Types.TIME:
0: 				retval = rs.getTime( columnName );
0: 				break;
0: 				
0: 		    case Types.TIMESTAMP:
0: 				retval = rs.getTimestamp( columnName );
0: 				break;
0: 				
0: 		    default:
0: 				fail( "Unknown jdbc type " + jdbcType + " used to retrieve column: " + columnName );
0: 				break;
0: 		}
0: 
0: 		if ( rs.wasNull() ) { retval = null; }
0: 
0: 		return retval;
0: 	}
0: 
0: 	//
0: 	// SQL code generation minions 
0: 	//
0: 	private	String	doubleQuote( String text )
0: 	{
0: 		return '"' + text + '"';
0: 	}
0: 
0: 	//
0: 	// Swallow uninteresting exceptions when disposing of jdbc objects.
0: 	//
0: 	private	void	close( ResultSet rs )
0: 	{
0: 		try {
0: 			if ( rs != null ) { rs.close(); }
0: 		}
0: 		catch (SQLException e) {}
0: 	}	
0: 	private	void	close( Statement statement )
0: 	{
0: 		try {
0: 			if ( statement != null ) { statement.close(); }
0: 		}
0: 		catch (SQLException e) {}
0: 	}
0: 	private	void	close( Connection conn )
0: 	{
0: 		try {
0: 			if ( conn != null ) { conn.close(); }
0: 		}
0: 		catch (SQLException e) {}
0: 	}
0: 
0: 	///////////////////
0: 	//
0: 	//	GENERAL MINIONS
0: 	//
0: 	///////////////////
0: 	
0: 	// Debug code to print chatty informational messages.
0: 	private	static	void	println( String text )
0: 	{
0: 		if ( _debug )
0: 		{
0: 			_outputStream.println( text );
0: 			_outputStream.flush();
0: 		}
0: 	}
0: 
0: 	// Print out a stack trace
0: 	private	static	void	printStackTrace( Throwable t )
0: 	{
0: 		while ( t != null )
0: 		{
0: 			t.printStackTrace( _outputStream );
0: 
0: 			if ( t instanceof SQLException )	{ t = ((SQLException) t).getNextException(); }
0: 			else { break; }
0: 		}
0: 	}
0: 
0: 	//
0: 	// Return a meaningful exit status so that calling scripts can take
0: 	// evasive action.
0: 	//
0: 	private	void	exit( int exitStatus )
0: 	{
0: 		Runtime.getRuntime().exit( exitStatus );
0: 	}
0: 
0: 	//////////////////////////
0: 	//
0: 	//	INITIALIZATION MINIONS
0: 	//
0: 	//////////////////////////
0: 	
0: 	//
0: 	// Initialize client settings based on the client found.
0: 	// Return true if one and only one client found, false otherwise.
0: 	// We allow for the special case when we're running the embedded client
0: 	// off the current compiled class tree rather than off product jars.
0: 	//
0: 	private	static	boolean	findClient()
0: 		throws Exception
0: 	{
0: 		//
0: 		// The client may have been specified on the command line.
0: 		// In that case, we don't bother looking for a client on
0: 		// the classpath.
0: 		//
0: 		if ( _defaultClientSettings != null ) { faultInDriver( _defaultClientSettings ); }
0: 		else
0: 		{
0: 			String	currentClientName = null;
0: 			int		legalCount = LEGAL_CLIENTS.length;
0: 			int		foundCount = 0;
0: 
0: 			for ( int i = 0; i < legalCount; i++ )
0: 			{
0: 				String[]	candidate = LEGAL_CLIENTS[ i ];
0: 
0: 				if ( faultInDriver( candidate ) )
0: 				{
0: 					_defaultClientSettings = candidate;
0: 					foundCount++;
0: 				}
0: 			}
0: 
0: 			if ( foundCount != EXPECTED_CLIENT_COUNT )
0: 			{
0: 				throw new Exception( "Wrong number of drivers: " + foundCount );
0: 			}
0: 		}
0: 
0: 		// Now make sure that the JDBC driver is what we expect
0: 
0: 		try {
0: 			_driver = DriverManager.getDriver( _defaultClientSettings[ DATABASE_URL ] );
0: 			_driverLevel = new Version( _driver.getMajorVersion(), _driver.getMinorVersion() );
0: 		}
0: 		catch (SQLException e)
0: 		{
0: 			printStackTrace( e );
0: 			
0: 			throw new Exception
0: 				( "Driver doesn't understand expected URL: " + _defaultClientSettings[ DATABASE_URL ] );
0: 		}
0: 
0: 		println
0: 			(
0: 			    "Driver " + _driver.getClass().getName() +
0: 				" Version = " + _driverLevel
0: 			);
0: 		
0: 		return true;
0: 	}
0: 
0: 	//
0: 	// Initialize server settings. Assumes that you have called
0: 	// findClient().
0: 	//
0: 	private	static	boolean	findServer()
0: 		throws Exception
0: 	{
0: 		try {
0: 			Connection			conn = getConnection();
0: 			DatabaseMetaData	dmd = conn.getMetaData();
0: 			String				dbProductVersion = dmd.getDatabaseProductVersion();
0: 
0: 			_serverLevel = new Version( dbProductVersion );
0: 		}
0: 		catch (Exception e)
0: 		{
0: 			printStackTrace( e );
0: 			
0: 			throw new Exception( "Error lookup up server info: " + e.getMessage() );
0: 		}
0: 		
0: 		println( "Server Version = " + _serverLevel );
0: 
0: 		return true;
0: 	}
0: 
0: 	private	static	boolean	faultInDriver( String[] clientSettings )
0: 	{
0: 		String	currentClientName = clientSettings[ DRIVER_NAME ];
0: 		
0: 		try {
0: 			Class.forName( currentClientName );
0: 
0: 			return true;
0: 		}
0: 		catch (Exception e)
0: 		{
0: 			println( "Could not find " + currentClientName );
0: 			return false;
0: 		}
0: 	}
0: 
0: 	private	static	boolean	parseDebug()
0: 	{
0: 		_debug = Boolean.getBoolean( DEBUG_FLAG );
0: 
0: 		return true;
0: 	}
0: 		
0: 	private	static	boolean	parseVMLevel()
0: 		throws Exception
0: 	{
0: 		String				vmVersion = System.getProperty( VERSION_PROPERTY );
0: 
0: 		try {
0: 			_clientVMLevel = new Version( vmVersion );
0: 		}
0: 		catch (NumberFormatException e)
0: 		{
0: 			throw new Exception( "Badly formatted vm version: " + vmVersion );
0: 		}
0: 
0: 		println( "VM Version = " + _clientVMLevel );
0: 
0: 		return true;
0: 	}
0: 
0: 	private	static	boolean	parseArgs( String args[] )
0: 		throws Exception
0: 	{
0: 		if ( ( args == null ) || (args.length == 0 ) )
0: 		{ throw new Exception( "Missing database name." ); }
0: 		
0: 		_databaseName = args[ 0 ];
0: 
0: 		if ( (args.length > 1) && !"".equals( args[ 1 ] ) )
0: 		{
0: 			String	desiredClientName = args[ 1 ];
0: 			int		count = LEGAL_CLIENTS.length;
0: 
0: 			for ( int i = 0; i < count; i++ )
0: 			{
0: 				String[]	candidate = LEGAL_CLIENTS[ i ];
0: 
0: 				if ( desiredClientName.equals( candidate[ DRIVER_NAME ] ) )
0: 				{
0: 					_defaultClientSettings = candidate;
0: 					break;
0: 				}
0: 			}
0: 
0: 			if ( _defaultClientSettings == null )
0: 			{
0: 				throw new Exception
0: 					( "Could not find client " + desiredClientName + " on the classpath." );
0: 			}
0: 		}
0: 			
0: 		return true;
0: 	}
0: 
0: 	
0: 	/////////////////////////////////////////////////////////////
0: 	//
0: 	//	INNER CLASSES
0: 	//
0: 	/////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * <p>
0: 	 * This helper class exposes an entry point for creating an empty database.
0: 	 * </p>
0: 	 */
0: 	public	static	final	class	Creator
0: 	{
0: 		private	static	JDBCDriverTest	_driver = new JDBCDriverTest();
0: 		
0: 		/**
0: 		 * <p>
0: 		 * Wait for server to come up, then create the database.
0: 		 * </p>
0: 		 *
0: 		 * <ul>
0: 		 * <li>args[ 0 ] = name of database to create.</li>
0: 		 * </ul>
0: 		 */
0: 		public	static	void	main( String[] args )
0: 			throws Exception
0: 		{
0: 			String		databaseName = args[ 0 ];
0: 
0: 			JDBCDriverTest.findClient();
0: 			
0: 			_driver.createDB( databaseName );
0: 		}
0: 		
0: 	}
0: 
0: 	/**
0: 	 * <p>
0: 	 * A class for storing a major and minor version number. This class
0: 	 * assumes that more capable versions compare greater than less capable versions.
0: 	 * </p>
0: 	 */
0: 	public	static	final	class	Version	implements	Comparable
0: 	{
0: 		private	int	_major;
0: 		private	int	_minor;
0: 
0: 		public	Version( int major, int minor )
0: 		{
0: 			constructorMinion( major, minor );
0: 		}
0: 
0: 		public	Version( String desc )
0: 			throws NumberFormatException
0: 		{
0: 			StringTokenizer		tokens = new StringTokenizer( desc, "." );
0: 
0: 			constructorMinion
0: 				(
0: 				    java.lang.Integer.parseInt( tokens.nextToken() ),
0: 					java.lang.Integer.parseInt( tokens.nextToken() )
0: 				);
0: 		}
0: 
0: 		private	void	constructorMinion( int major, int minor )
0: 		{
0: 			_major = major;
0: 			_minor = minor;
0: 		}
0: 
0: 		/**
0: 		 * <p>
0: 		 * Returns true if this Version is at least as advanced
0: 		 * as that Version.
0: 		 * </p>
0: 		 */
0: 		public	boolean	atLeast( Version that )
0: 		{
0: 			return this.compareTo( that ) > -1;
0: 		}
0: 
0: 
0: 		////////////////////////////////////////////////////////
0: 		//
0: 		//	Comparable BEHAVIOR
0: 		//
0: 		////////////////////////////////////////////////////////
0: 
0: 		public	int	compareTo( Object other )
0: 		{
0: 			if ( other == null ) { return -1; }
0: 			if ( !( other instanceof Version ) ) { return -1; }
0: 
0: 			Version	that = (Version) other;
0: 
0: 			if ( this._major < that._major ) { return -1; }
0: 			if ( this._major > that._major ) { return 1; }
0: 
0: 			return this._minor - that._minor;
0: 		}
0: 
0: 		////////////////////////////////////////////////////////
0: 		//
0: 		//	Object OVERLOADS
0: 		//
0: 		////////////////////////////////////////////////////////
0: 		
0: 		public	String	toString()
0: 		{
0: 			return Integer.toString( _major ) + '.' + Integer.toString( _minor );
0: 		}
0: 
0: 		public	boolean	equals( Object other )
0: 		{
0: 			return (compareTo( other ) == 0);
0: 		}
0: 
0: 		public	int	hashCode()
0: 		{
0: 			return _major ^ _minor;
0: 		}
0: 		
0: 	}
0: 
0: 	/**
0: 	 * <p>
0: 	 * This helper class describes a legal datatype and the version of Derby
0: 	 * and db2jcc where the datatype first appears.
0: 	 * </p>
0: 	 */
0: 	public	static	final	class	TypeDescriptor
0: 	{
0: 		private	int		_jdbcType;
0: 		private	String	_derbyTypeName;
0: 		private	Version	_db2jccVersion;		// first db2jcc version which supports this type
0: 		private	Version	_derbyVersion;		// first derby version which supports this type
0: 		private	Version	_vmVersion;			// first vm (jdbc) version which supports this type
0: 
0: 		public	TypeDescriptor
0: 		(
0: 		    int		jdbcType,
0: 			String	derbyTypeName,
0: 			Version	db2jccVersion,
0: 			Version	derbyVersion,
0: 			Version	vmVersion
0: 		)
0: 		{
0: 			_jdbcType = jdbcType;
0: 			_derbyTypeName = derbyTypeName;
0: 			_db2jccVersion = db2jccVersion;
0: 			_derbyVersion = derbyVersion;
0: 			_vmVersion = vmVersion;
0: 		}
0: 
0: 		public	int		getJdbcType() 					{ return _jdbcType; }
0: 		public	String	getDerbyTypeName()				{ return _derbyTypeName; }
0: 		public	Version	getDb2jccVersion()				{ return _db2jccVersion; }
0: 		public	Version	getDerbyVersion()				{ return _derbyVersion; }
0: 		public	Version	getVMVersion()					{ return _vmVersion; }
0: 	}
0: 
0: 	/**
0: 	 * <p>
0: 	 * This helper class captures TypeCoercion logic. I have abbreviated it to
0: 	 * this ugly class name so that the COERCIONS table will fit on a readable screen.
0: 	 * </p>
0: 	 */
0: 	public	static	final	class	T_CN
0: 	{
0: 		private	int			_jdbcType;
0: 		private	boolean[]	_coercions;
0: 
0: 		public	T_CN( int jdbcType, boolean[] coercions )
0: 		{
0: 			_jdbcType = jdbcType;
0: 			_coercions = coercions;
0: 		}
0: 
0: 		public	int			getJdbcType() 					{ return _jdbcType; }
0: 		public	boolean[]	getCoercions() 					{ return _coercions; }
0: 	}
0: 	
0: 	/**
0: 	 * <p>
0: 	 * A crude Blob implementation for datatype testing.
0: 	 * </p>
0: 	 */
0: 	public	static	final	class	MyBlob	implements	Blob
0: 	{
0: 		private	byte[]	_bytes;
0: 
0: 		public	MyBlob( byte[] bytes )
0: 		{
0: 			_bytes = bytes;
0: 		}
0: 
0: 		public	InputStream	getBinaryStream()
0: 		{
0: 			return new ByteArrayInputStream( _bytes );
0: 		}
0: 
0: 		public	byte[]	getBytes( long position, int length ) { return _bytes; }
0: 
0: 		public	long	length() { return (long) _bytes.length; }
0: 
0: 		public	long	position( Blob pattern, long start ) { return 0L; }
0: 		public	long	position( byte[] pattern, long start ) { return 0L; }
0: 
0: 		public	boolean	equals( Object other )
0: 		{
0: 			if ( other == null ) { return false; }
0: 			if ( !( other instanceof Blob ) ) { return false; }
0: 
0: 			Blob	that = (Blob) other;
0: 
0: 			try {
0: 				if ( this.length() != that.length() ) { return false; }
0: 
0: 				InputStream	thisStream = this.getBinaryStream();
0: 				InputStream	thatStream = that.getBinaryStream();
0: 
0: 				while( true )
0: 				{
0: 					int		nextByte = thisStream.read();
0: 
0: 					if ( nextByte < 0 ) { break; }
0: 					if ( nextByte != thatStream.read() ) { return false; }
0: 				}
0: 			}
0: 			catch (Exception e)
0: 			{
0: 				System.err.println( e.getMessage() );
0: 				e.printStackTrace();
0: 				return false;
0: 			}
0: 
0: 			return true;
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * <p>
0: 	 * A crude Clob implementation for datatype testing.
0: 	 * </p>
0: 	 */
0: 	public	static	final	class	MyClob	implements	Clob
0: 	{
0: 		private	String	_contents;
0: 
0: 		public	MyClob( String contents )
0: 		{
0: 			_contents = contents;
0: 		}
0: 
0: 		public	InputStream	getAsciiStream()
0: 		{
0: 			try {
0: 				return new ByteArrayInputStream( _contents.getBytes( "UTF-8" ) );
0: 			}
0: 			catch (Exception e) { return null; }
0: 		}
0: 
0: 		public	Reader	getCharacterStream()
0: 		{
0: 			return new CharArrayReader( _contents.toCharArray() );
0: 		}
0: 
0: 		public	String	getSubString( long position, int length )
0: 		{
0: 			return _contents.substring( (int) position, length );
0: 		}
0: 		
0: 		public	long	length() { return (long) _contents.length(); }
0: 
0: 		public	long	position( Clob searchstr, long start ) { return 0L; }
0: 		public	long	position( String searchstr, long start ) { return 0L; }
0: 
0: 		public	boolean	equals( Object other )
0: 		{
0: 			if ( other == null ) { return false; }
0: 			if ( !( other instanceof Clob ) ) { return false; }
0: 
0: 			Clob	that = (Clob) other;
0: 
0: 			try {
0: 				if ( this.length() != that.length() ) { return false; }
0: 			
0: 				InputStream	thisStream = this.getAsciiStream();
0: 				InputStream	thatStream = that.getAsciiStream();
0: 
0: 				while( true )
0: 				{
0: 					int		nextByte = thisStream.read();
0: 
0: 					if ( nextByte < 0 ) { break; }
0: 					if ( nextByte != thatStream.read() ) { return false; }
0: 				}
0: 			}
0: 			catch (Exception e)
0: 			{
0: 				System.err.println( e.getMessage() );
0: 				e.printStackTrace();
0: 				return false;
0: 			}
0: 
0: 			return true;
0: 		}
0: 
0: 	}
0: 
0: }
============================================================================