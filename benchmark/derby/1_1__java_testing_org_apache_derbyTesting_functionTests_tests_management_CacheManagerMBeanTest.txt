1:86ee0a0: /*
1:86ee0a0: 
1:86ee0a0:    Derby - Class org.apache.derbyTesting.functionTests.tests.management.CacheManagerMBeanTest
1:86ee0a0: 
1:86ee0a0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:86ee0a0:    contributor license agreements.  See the NOTICE file distributed with
1:86ee0a0:    this work for additional information regarding copyright ownership.
1:86ee0a0:    The ASF licenses this file to you under the Apache License, Version 2.0
1:86ee0a0:    (the "License"); you may not use this file except in compliance with
1:86ee0a0:    the License.  You may obtain a copy of the License at
1:86ee0a0: 
1:86ee0a0:       http://www.apache.org/licenses/LICENSE-2.0
1:86ee0a0: 
1:86ee0a0:    Unless required by applicable law or agreed to in writing, software
1:86ee0a0:    distributed under the License is distributed on an "AS IS" BASIS,
1:86ee0a0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:86ee0a0:    See the License for the specific language governing permissions and
1:86ee0a0:    limitations under the License.
1:86ee0a0: 
1:86ee0a0:  */
1:86ee0a0: 
1:86ee0a0: package org.apache.derbyTesting.functionTests.tests.management;
1:86ee0a0: 
1:0c12cde: import java.security.Permission;
1:86ee0a0: import java.sql.PreparedStatement;
1:6da88fc: import java.sql.Statement;
1:86ee0a0: import java.util.Hashtable;
1:86ee0a0: import java.util.Set;
1:86ee0a0: import javax.management.ObjectName;
1:0c12cde: import javax.management.RuntimeMBeanException;
1:86ee0a0: import junit.framework.Test;
1:0c12cde: import org.apache.derby.security.SystemPermission;
1:0c12cde: import org.apache.derbyTesting.junit.BaseTestSuite;
1:86ee0a0: import org.apache.derbyTesting.junit.JDBC;
1:0c12cde: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:86ee0a0: import org.apache.derbyTesting.junit.TestConfiguration;
1:86ee0a0: 
1:86ee0a0: /**
1:86ee0a0:  * Test cases for {@code CacheManagerMBean}.
1:86ee0a0:  */
1:86ee0a0: public class CacheManagerMBeanTest extends MBeanTest {
1:86ee0a0: 
1:6da88fc:     private final static int DEFAULT_PAGE_CACHE_SIZE = 1000;
1:6da88fc:     private final static int DEFAULT_CONTAINER_CACHE_SIZE = 100;
1:6da88fc:     private final static int DEFAULT_STATEMENT_CACHE_SIZE = 100;
1:6da88fc: 
1:0c12cde:     private static String[] ALL_ATTRIBUTES = {
1:0c12cde:         "CollectAccessCounts", "HitCount", "MissCount", "EvictionCount",
1:0c12cde:         "MaxEntries", "AllocatedEntries", "UsedEntries"
1:0c12cde:     };
1:0c12cde: 
1:86ee0a0:     public CacheManagerMBeanTest(String name) {
1:86ee0a0:         super(name);
1:86ee0a0:     }
1:86ee0a0: 
1:86ee0a0:     public static Test suite() {
1:0c12cde:         BaseTestSuite suite = new BaseTestSuite();
1:0c12cde:         suite.addTest(MBeanTest.suite(CacheManagerMBeanTest.class,
1:0c12cde:                                       "CacheManagerMBeanTest"));
1:0c12cde: 
1:0c12cde:         // Test that the management bean can only be accessed with proper
1:0c12cde:         // permissions. The custom policy files only have entries for jar
1:0c12cde:         // files, so skip these test cases when running from classes.
1:0c12cde:         if (TestConfiguration.loadingFromJars()) {
1:0c12cde:             Test negative = new CacheManagerMBeanTest("withoutPermsTest");
1:0c12cde:             negative = JMXConnectionDecorator.platformMBeanServer(negative);
1:0c12cde:             negative = new SecurityManagerSetup(negative,
1:0c12cde:                     "org/apache/derbyTesting/functionTests/tests/management/"
1:0c12cde:                         + "CacheManagerMBeanTest.withoutPerm.policy");
1:0c12cde:             suite.addTest(negative);
1:0c12cde: 
1:0c12cde:             Test positive = new CacheManagerMBeanTest("withPermsTest");
1:0c12cde:             positive = JMXConnectionDecorator.platformMBeanServer(positive);
1:0c12cde:             positive = new SecurityManagerSetup(positive,
1:0c12cde:                     "org/apache/derbyTesting/functionTests/tests/management/"
1:0c12cde:                             + "CacheManagerMBeanTest.withPerm.policy");
1:0c12cde:             suite.addTest(positive);
1:0c12cde:         }
1:0c12cde: 
1:0c12cde:         return suite;
1:86ee0a0:     }
1:86ee0a0: 
1:86ee0a0:     @Override
1:86ee0a0:     protected void setUp() throws Exception {
1:86ee0a0:         // Set up management.
1:86ee0a0:         super.setUp();
1:86ee0a0: 
1:86ee0a0:         // Shut down the database before running the test case, so that the
1:86ee0a0:         // test case can assume that it starts from a clean state where the
1:86ee0a0:         // cache beans have not started yet. shutdownDatabase() fails if
1:86ee0a0:         // the database is not already booted, so get a connection first to
1:86ee0a0:         // ensure that it is booted (otherwise, the test will fail if it
1:86ee0a0:         // runs standalone or first in a suite).
1:86ee0a0:         getConnection().close();
1:86ee0a0:         TestConfiguration.getCurrent().shutdownDatabase();
1:86ee0a0:     }
1:86ee0a0: 
1:86ee0a0:     /**
1:86ee0a0:      * Create an {@code ObjectName} that identifies a {@code CacheManager}
1:86ee0a0:      * management bean, or a pattern that potentially matches multiple
1:86ee0a0:      * beans.
1:86ee0a0:      *
1:86ee0a0:      * @param cacheName the name of the cache (such as PageCache), or
1:86ee0a0:      *   {@code null} to create a pattern that matches all cache names
1:86ee0a0:      * @param dbName the name of the database, or {@code null} to create
1:86ee0a0:      *   a pattern that matches all database names
1:86ee0a0:      * @return an {@code ObjectName} suitable for looking up beans
1:86ee0a0:      */
1:86ee0a0:     private ObjectName createObjectName(String cacheName, String dbName)
1:86ee0a0:             throws Exception {
1:86ee0a0:         Hashtable<String, String> props = new Hashtable<String, String>();
1:86ee0a0:         props.put("type", "CacheManager");
1:86ee0a0:         props.put("name", cacheName == null ? "*" : cacheName);
1:86ee0a0:         props.put("db", dbName == null ? "*" : ObjectName.quote(dbName));
1:86ee0a0:         return getDerbyMBeanName(props);
1:86ee0a0:     }
1:86ee0a0: 
1:86ee0a0:     /**
1:86ee0a0:      * Test case that verifies that {@code CacheManagerMBean}s start when
1:86ee0a0:      * a database is started, and stop when the database is shut down.
1:86ee0a0:      */
1:86ee0a0:     public void testAllMBeansStartedAndStopped() throws Exception {
1:86ee0a0:         // This pattern matches all CacheManager management beans when used
1:86ee0a0:         // in a query.
1:86ee0a0:         ObjectName pattern = createObjectName(null, null);
1:86ee0a0: 
1:86ee0a0:         // There should be no CacheManager MBeans before the database
1:86ee0a0:         // is booted.
1:86ee0a0:         Set<ObjectName> names = queryMBeans(pattern);
1:86ee0a0:         if (!names.isEmpty()) {
1:86ee0a0:             fail("Should not find MBeans before boot, found: " + names);
1:86ee0a0:         }
1:86ee0a0: 
1:86ee0a0:         // Boot the database, so that the MBeans are started.
1:86ee0a0:         getConnection();
1:86ee0a0: 
1:6da88fc:         // There should be three CacheManager beans. One for the page cache,
1:6da88fc:         // one for the container cache, and one for the statement cache.
1:86ee0a0:         names = queryMBeans(pattern);
1:86ee0a0:         assertEquals("Incorrect number of MBeans found in " + names,
1:6da88fc:                      3, names.size());
1:86ee0a0: 
1:86ee0a0:         // Shut down the database.
1:86ee0a0:         TestConfiguration.getCurrent().shutdownDatabase();
1:86ee0a0: 
1:86ee0a0:         // There should be no CacheManager MBeans after the database has
1:86ee0a0:         // been shut down.
1:86ee0a0:         names = queryMBeans(pattern);
1:86ee0a0:         if (!names.isEmpty()) {
1:86ee0a0:             fail("Should not find MBeans after shutdown, found: " + names);
1:86ee0a0:         }
1:86ee0a0:     }
1:86ee0a0: 
1:86ee0a0:     /**
1:86ee0a0:      * Test the {@code CacheManagerMBean} for the page cache.
1:86ee0a0:      */
1:86ee0a0:     public void testPageCache() throws Exception {
1:86ee0a0:         getConnection(); // boot the database
1:86ee0a0:         Set<ObjectName> names =
1:86ee0a0:                 queryMBeans(createObjectName("PageCache", null));
1:86ee0a0: 
1:86ee0a0:         assertEquals("Should have a single page cache", 1, names.size());
1:86ee0a0: 
1:86ee0a0:         ObjectName name = names.iterator().next();
1:86ee0a0: 
1:86ee0a0:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:86ee0a0:         assertLongAttribute(0, name, "HitCount");
1:86ee0a0:         assertLongAttribute(0, name, "MissCount");
1:86ee0a0:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc:         assertLongAttribute(DEFAULT_PAGE_CACHE_SIZE, name, "MaxEntries");
1:86ee0a0:         // Cannot reliably tell how many entries to expect.
1:86ee0a0:         // More than 0 for sure.
1:86ee0a0:         Long allocated = (Long) getAttribute(name, "AllocatedEntries");
1:86ee0a0:         assertTrue("Allocated entries: " + allocated, allocated > 0);
1:86ee0a0:         Long used = (Long) getAttribute(name, "UsedEntries");
1:86ee0a0:         assertTrue("Used entries: " + used, used > 0);
1:6da88fc: 
1:86ee0a0:         // Execute a statement against a table, so that the cache will be
1:86ee0a0:         // accessed.
1:86ee0a0:         PreparedStatement ps = prepareStatement(
1:86ee0a0:                                     "select * from sysibm.sysdummy1");
1:86ee0a0:         JDBC.assertDrainResults(ps.executeQuery());
1:86ee0a0: 
1:86ee0a0:         // Since collection of access counts is disabled by default, don't
1:86ee0a0:         // expect the counts to be updated.
1:86ee0a0:         assertLongAttribute(0, name, "HitCount");
1:86ee0a0:         assertLongAttribute(0, name, "MissCount");
1:86ee0a0:         assertLongAttribute(0, name, "EvictionCount");
1:86ee0a0: 
1:86ee0a0:         // Now enable the access counts and re-execute the query. It
1:86ee0a0:         // should result in a hit in the page cache.
1:86ee0a0:         setAttribute(name, "CollectAccessCounts", Boolean.TRUE);
1:86ee0a0:         assertBooleanAttribute(true, name, "CollectAccessCounts");
1:86ee0a0:         JDBC.assertDrainResults(ps.executeQuery());
1:86ee0a0:         assertLongAttribute(1, name, "HitCount");
1:86ee0a0:         assertLongAttribute(0, name, "MissCount");
1:86ee0a0: 
1:86ee0a0:         // Disable the access counts.
1:86ee0a0:         setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:86ee0a0:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:86ee0a0:     }
1:0c12cde: 
1:0c12cde:     /**
1:86ee0a0:      * Test the {@code CacheManagerMBean} for the page cache.
1:86ee0a0:      */
1:86ee0a0:     public void testContainerCache() throws Exception {
1:86ee0a0:         getConnection(); // boot the database
1:86ee0a0:         Set<ObjectName> names =
1:86ee0a0:                 queryMBeans(createObjectName("ContainerCache", null));
1:86ee0a0: 
1:86ee0a0:         assertEquals("Should have a single container cache", 1, names.size());
1:86ee0a0: 
1:86ee0a0:         ObjectName name = names.iterator().next();
1:86ee0a0: 
1:86ee0a0:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:86ee0a0:         assertLongAttribute(0, name, "HitCount");
1:86ee0a0:         assertLongAttribute(0, name, "MissCount");
1:86ee0a0:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc:         assertLongAttribute(DEFAULT_CONTAINER_CACHE_SIZE, name, "MaxEntries");
1:86ee0a0:         // Cannot reliably tell how many entries to expect.
1:86ee0a0:         // More than 0 for sure.
1:86ee0a0:         Long allocated = (Long) getAttribute(name, "AllocatedEntries");
1:86ee0a0:         assertTrue("Allocated entries: " + allocated, allocated > 0);
1:86ee0a0:         Long used = (Long) getAttribute(name, "UsedEntries");
1:86ee0a0:         assertTrue("Used entries: " + used, used > 0);
1:86ee0a0:     }
1:86ee0a0: 
1:6da88fc:     /**
1:6da88fc:      * Test the {@code CacheManagerMBean} for the statement cache.
1:6da88fc:      */
1:6da88fc:     public void testStatementCache() throws Exception {
1:6da88fc:         getConnection(); // boot the database
1:6da88fc:         Set<ObjectName> names =
1:6da88fc:                 queryMBeans(createObjectName("StatementCache", null));
1:6da88fc: 
1:6da88fc:         assertEquals("Should have a single statement cache", 1, names.size());
1:6da88fc: 
1:6da88fc:         ObjectName name = names.iterator().next();
1:6da88fc: 
1:6da88fc:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:6da88fc:         assertLongAttribute(0, name, "HitCount");
1:6da88fc:         assertLongAttribute(0, name, "MissCount");
1:6da88fc:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE, name, "MaxEntries");
1:6da88fc:         // The statement cache is initially empty
1:6da88fc:         assertLongAttribute(0, name, "AllocatedEntries");
1:6da88fc:         assertLongAttribute(0, name, "UsedEntries");
1:6da88fc: 
1:6da88fc:         // Prepare a statement. Now there should be one allocated entry, and
1:6da88fc:         // that entry is also a used entry.
1:6da88fc:         prepareStatement("values 1").close();
1:6da88fc:         assertLongAttribute(1, name, "AllocatedEntries");
1:6da88fc:         assertLongAttribute(1, name, "UsedEntries");
1:6da88fc: 
1:6da88fc:         // One more...
1:6da88fc:         prepareStatement("values 2").close();
1:6da88fc:         assertLongAttribute(2, name, "AllocatedEntries");
1:6da88fc:         assertLongAttribute(2, name, "UsedEntries");
1:6da88fc: 
1:6da88fc:         // Now clear the statement cache. One more entry is allocated (for
1:6da88fc:         // the statement that clears the cache), but no entries should be
1:6da88fc:         // used after the statement cache is cleared.
1:6da88fc:         Statement s = createStatement();
1:6da88fc:         s.execute("call syscs_util.syscs_empty_statement_cache()");
1:6da88fc:         assertLongAttribute(3, name, "AllocatedEntries");
1:6da88fc:         assertLongAttribute(0, name, "UsedEntries");
1:6da88fc: 
1:6da88fc:         // None of the accesses to the statement cache should have been
1:6da88fc:         // counted so far.
1:6da88fc:         assertLongAttribute(0, name, "HitCount");
1:6da88fc:         assertLongAttribute(0, name, "MissCount");
1:6da88fc:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc: 
1:6da88fc:         // Enable counting of cache accesses.
1:6da88fc:         setAttribute(name, "CollectAccessCounts", Boolean.TRUE);
1:6da88fc:         assertBooleanAttribute(true, name, "CollectAccessCounts");
1:6da88fc: 
1:6da88fc:         // Prepare a statement. Since the cache is empty, it must be a miss.
1:6da88fc:         prepareStatement("values 1").close();
1:6da88fc:         assertLongAttribute(0, name, "HitCount");
1:6da88fc:         assertLongAttribute(1, name, "MissCount");
1:6da88fc:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc: 
1:6da88fc:         // One more...
1:6da88fc:         prepareStatement("values 2").close();
1:6da88fc:         assertLongAttribute(0, name, "HitCount");
1:6da88fc:         assertLongAttribute(2, name, "MissCount");
1:6da88fc:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc: 
1:6da88fc:         // Now, this should cause a hit.
1:6da88fc:         prepareStatement("values 1").close();
1:6da88fc:         assertLongAttribute(1, name, "HitCount");
1:6da88fc:         assertLongAttribute(2, name, "MissCount");
1:6da88fc:         assertLongAttribute(0, name, "EvictionCount");
1:6da88fc: 
1:6da88fc:         // Prepare so many statements that the cache is filled twice.
1:6da88fc:         for (int i = 0; i < DEFAULT_STATEMENT_CACHE_SIZE * 2; i++) {
1:6da88fc:             prepareStatement("values 1, " + i).close();
1:6da88fc:         }
1:6da88fc: 
1:6da88fc:         // None of the above statements were already in the cache, so expect
1:6da88fc:         // all of them to cause misses.
1:6da88fc:         assertLongAttribute(1, name, "HitCount");
1:6da88fc:         assertLongAttribute(
1:6da88fc:                 2 + DEFAULT_STATEMENT_CACHE_SIZE * 2, name, "MissCount");
1:6da88fc: 
1:6da88fc:         // We have prepared 2 + (DEFAULT_STATEMENT_CACHE_SIZE * 2) statements,
1:6da88fc:         // and the cache can only hold DEFAULT_STATEMENT_CACHE_SIZE of them,
1:6da88fc:         // so expect DEFAULT_STATEMENT_CACHE_SIZE + 2 statements to have been
1:6da88fc:         // evicted from the cache.
1:6da88fc:         assertLongAttribute(2 + DEFAULT_STATEMENT_CACHE_SIZE,
1:6da88fc:                             name, "EvictionCount");
1:6da88fc: 
1:6da88fc:         // Expect the cache to be full.
1:6da88fc:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE, name, "MaxEntries");
1:6da88fc:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE,
1:6da88fc:                             name, "AllocatedEntries");
1:6da88fc:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE, name, "UsedEntries");
1:6da88fc: 
1:6da88fc:         // Disable the access counts.
1:6da88fc:         setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:6da88fc:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:6da88fc:     }
1:86ee0a0: 
1:86ee0a0:     /**
1:0c12cde:      * Test that the CacheManagerMBean cannot be accessed if the code
1:0c12cde:      * base lacks SystemPermission("engine", "monitor").
1:0c12cde:      */
1:0c12cde:     public void withoutPermsTest() throws Exception {
1:0c12cde:         getConnection(); // boot the database
1:0c12cde:         Set<ObjectName> names =
1:0c12cde:                 queryMBeans(createObjectName("StatementCache", null));
1:0c12cde: 
1:0c12cde:         assertEquals("Should have a single statement cache", 1, names.size());
1:0c12cde: 
1:0c12cde:         ObjectName name = names.iterator().next();
1:0c12cde: 
1:0c12cde:         // This is the permission required to access the MBean, but we don't
1:0c12cde:         // have it.
1:0c12cde:         SystemPermission monitorPerm =
1:0c12cde:                 new SystemPermission("engine", "monitor");
1:0c12cde: 
1:0c12cde:         // Reading attributes should cause security exception.
1:0c12cde:         for (String attrName : ALL_ATTRIBUTES) {
1:0c12cde:             try {
1:0c12cde:                 getAttribute(name, attrName);
1:0c12cde:                 fail();
1:0c12cde:             } catch (RuntimeMBeanException e) {
1:0c12cde:                 vetException(e, monitorPerm);
1:0c12cde:             }
1:0c12cde:         }
1:0c12cde: 
1:0c12cde:         // Modifying attributes should also cause security exception.
1:0c12cde:         try {
1:0c12cde:             setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:0c12cde:             fail();
1:0c12cde:         } catch (RuntimeMBeanException e) {
1:0c12cde:             vetException(e, monitorPerm);
1:0c12cde:         }
1:0c12cde:     }
1:0c12cde: 
1:0c12cde:     /**
1:0c12cde:      * Check that an exception raised when accessing an MBean, is caused
1:0c12cde:      * by missing a specific permission.
1:0c12cde:      *
1:0c12cde:      * @param e the exception to check
1:0c12cde:      * @param perm the missing permission to check for
1:0c12cde:      */
1:0c12cde:     private void vetException(RuntimeMBeanException e, Permission perm) {
1:0c12cde:         Throwable cause = e.getCause();
1:0c12cde:         if (cause instanceof SecurityException) {
1:0c12cde:             String msg = cause.getMessage();
1:0c12cde:             if (msg != null && msg.contains(perm.toString())) {
1:0c12cde:                 // This is the expected exception.
1:0c12cde:                 return;
1:0c12cde:             }
1:0c12cde:         }
1:0c12cde: 
1:0c12cde:         fail("Unexpected exception", e);
1:0c12cde:     }
1:0c12cde: 
1:0c12cde:     /**
1:0c12cde:      * Test that the CacheManagerMBean can be accessed if the code base
1:0c12cde:      * runs with the same permissions as the {@link #withoutPermsTest} test
1:0c12cde:      * case plus SystemPermission("engine", "monitor").
1:0c12cde:      */
1:0c12cde:     public void withPermsTest() throws Exception {
1:0c12cde:         getConnection(); // boot the database
1:0c12cde:         Set<ObjectName> names =
1:0c12cde:                 queryMBeans(createObjectName("StatementCache", null));
1:0c12cde: 
1:0c12cde:         assertEquals("Should have a single statement cache", 1, names.size());
1:0c12cde: 
1:0c12cde:         ObjectName name = names.iterator().next();
1:0c12cde: 
1:0c12cde:         // Expect no SecurityException when reading attributes ...
1:0c12cde:         for (String attrName : ALL_ATTRIBUTES) {
1:0c12cde:             getAttribute(name, attrName);
1:0c12cde:         }
1:0c12cde: 
1:0c12cde:         // ... or when modifying them.
1:0c12cde:         setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:0c12cde:     }
1:86ee0a0: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0c12cde
/////////////////////////////////////////////////////////////////////////
1: import java.security.Permission;
1: import javax.management.RuntimeMBeanException;
1: import org.apache.derby.security.SystemPermission;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
/////////////////////////////////////////////////////////////////////////
1:     private static String[] ALL_ATTRIBUTES = {
1:         "CollectAccessCounts", "HitCount", "MissCount", "EvictionCount",
1:         "MaxEntries", "AllocatedEntries", "UsedEntries"
1:     };
1: 
1:         BaseTestSuite suite = new BaseTestSuite();
1:         suite.addTest(MBeanTest.suite(CacheManagerMBeanTest.class,
1:                                       "CacheManagerMBeanTest"));
1: 
1:         // Test that the management bean can only be accessed with proper
1:         // permissions. The custom policy files only have entries for jar
1:         // files, so skip these test cases when running from classes.
1:         if (TestConfiguration.loadingFromJars()) {
1:             Test negative = new CacheManagerMBeanTest("withoutPermsTest");
1:             negative = JMXConnectionDecorator.platformMBeanServer(negative);
1:             negative = new SecurityManagerSetup(negative,
1:                     "org/apache/derbyTesting/functionTests/tests/management/"
1:                         + "CacheManagerMBeanTest.withoutPerm.policy");
1:             suite.addTest(negative);
1: 
1:             Test positive = new CacheManagerMBeanTest("withPermsTest");
1:             positive = JMXConnectionDecorator.platformMBeanServer(positive);
1:             positive = new SecurityManagerSetup(positive,
1:                     "org/apache/derbyTesting/functionTests/tests/management/"
1:                             + "CacheManagerMBeanTest.withPerm.policy");
1:             suite.addTest(positive);
1:         }
1: 
1:         return suite;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that the CacheManagerMBean cannot be accessed if the code
1:      * base lacks SystemPermission("engine", "monitor").
1:      */
1:     public void withoutPermsTest() throws Exception {
1:         getConnection(); // boot the database
1:         Set<ObjectName> names =
1:                 queryMBeans(createObjectName("StatementCache", null));
1: 
1:         assertEquals("Should have a single statement cache", 1, names.size());
1: 
1:         ObjectName name = names.iterator().next();
1: 
1:         // This is the permission required to access the MBean, but we don't
1:         // have it.
1:         SystemPermission monitorPerm =
1:                 new SystemPermission("engine", "monitor");
1: 
1:         // Reading attributes should cause security exception.
1:         for (String attrName : ALL_ATTRIBUTES) {
1:             try {
1:                 getAttribute(name, attrName);
1:                 fail();
1:             } catch (RuntimeMBeanException e) {
1:                 vetException(e, monitorPerm);
1:             }
1:         }
1: 
1:         // Modifying attributes should also cause security exception.
1:         try {
1:             setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:             fail();
1:         } catch (RuntimeMBeanException e) {
1:             vetException(e, monitorPerm);
1:         }
1:     }
1: 
1:     /**
1:      * Check that an exception raised when accessing an MBean, is caused
1:      * by missing a specific permission.
1:      *
1:      * @param e the exception to check
1:      * @param perm the missing permission to check for
1:      */
1:     private void vetException(RuntimeMBeanException e, Permission perm) {
1:         Throwable cause = e.getCause();
1:         if (cause instanceof SecurityException) {
1:             String msg = cause.getMessage();
1:             if (msg != null && msg.contains(perm.toString())) {
1:                 // This is the expected exception.
1:                 return;
1:             }
1:         }
1: 
1:         fail("Unexpected exception", e);
1:     }
1: 
1:     /**
1:      * Test that the CacheManagerMBean can be accessed if the code base
1:      * runs with the same permissions as the {@link #withoutPermsTest} test
1:      * case plus SystemPermission("engine", "monitor").
1:      */
1:     public void withPermsTest() throws Exception {
1:         getConnection(); // boot the database
1:         Set<ObjectName> names =
1:                 queryMBeans(createObjectName("StatementCache", null));
1: 
1:         assertEquals("Should have a single statement cache", 1, names.size());
1: 
1:         ObjectName name = names.iterator().next();
1: 
1:         // Expect no SecurityException when reading attributes ...
1:         for (String attrName : ALL_ATTRIBUTES) {
1:             getAttribute(name, attrName);
1:         }
1: 
1:         // ... or when modifying them.
1:         setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:     }
commit:6da88fc
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1:     private final static int DEFAULT_PAGE_CACHE_SIZE = 1000;
1:     private final static int DEFAULT_CONTAINER_CACHE_SIZE = 100;
1:     private final static int DEFAULT_STATEMENT_CACHE_SIZE = 100;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // There should be three CacheManager beans. One for the page cache,
1:         // one for the container cache, and one for the statement cache.
1:                      3, names.size());
/////////////////////////////////////////////////////////////////////////
1:         assertLongAttribute(DEFAULT_PAGE_CACHE_SIZE, name, "MaxEntries");
/////////////////////////////////////////////////////////////////////////
1:         assertLongAttribute(DEFAULT_CONTAINER_CACHE_SIZE, name, "MaxEntries");
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test the {@code CacheManagerMBean} for the statement cache.
1:      */
1:     public void testStatementCache() throws Exception {
1:         getConnection(); // boot the database
1:         Set<ObjectName> names =
1:                 queryMBeans(createObjectName("StatementCache", null));
1: 
1:         assertEquals("Should have a single statement cache", 1, names.size());
1: 
1:         ObjectName name = names.iterator().next();
1: 
1:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(0, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
1:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE, name, "MaxEntries");
1:         // The statement cache is initially empty
1:         assertLongAttribute(0, name, "AllocatedEntries");
1:         assertLongAttribute(0, name, "UsedEntries");
1: 
1:         // Prepare a statement. Now there should be one allocated entry, and
1:         // that entry is also a used entry.
1:         prepareStatement("values 1").close();
1:         assertLongAttribute(1, name, "AllocatedEntries");
1:         assertLongAttribute(1, name, "UsedEntries");
1: 
1:         // One more...
1:         prepareStatement("values 2").close();
1:         assertLongAttribute(2, name, "AllocatedEntries");
1:         assertLongAttribute(2, name, "UsedEntries");
1: 
1:         // Now clear the statement cache. One more entry is allocated (for
1:         // the statement that clears the cache), but no entries should be
1:         // used after the statement cache is cleared.
1:         Statement s = createStatement();
1:         s.execute("call syscs_util.syscs_empty_statement_cache()");
1:         assertLongAttribute(3, name, "AllocatedEntries");
1:         assertLongAttribute(0, name, "UsedEntries");
1: 
1:         // None of the accesses to the statement cache should have been
1:         // counted so far.
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(0, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
1: 
1:         // Enable counting of cache accesses.
1:         setAttribute(name, "CollectAccessCounts", Boolean.TRUE);
1:         assertBooleanAttribute(true, name, "CollectAccessCounts");
1: 
1:         // Prepare a statement. Since the cache is empty, it must be a miss.
1:         prepareStatement("values 1").close();
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(1, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
1: 
1:         // One more...
1:         prepareStatement("values 2").close();
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(2, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
1: 
1:         // Now, this should cause a hit.
1:         prepareStatement("values 1").close();
1:         assertLongAttribute(1, name, "HitCount");
1:         assertLongAttribute(2, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
1: 
1:         // Prepare so many statements that the cache is filled twice.
1:         for (int i = 0; i < DEFAULT_STATEMENT_CACHE_SIZE * 2; i++) {
1:             prepareStatement("values 1, " + i).close();
1:         }
1: 
1:         // None of the above statements were already in the cache, so expect
1:         // all of them to cause misses.
1:         assertLongAttribute(1, name, "HitCount");
1:         assertLongAttribute(
1:                 2 + DEFAULT_STATEMENT_CACHE_SIZE * 2, name, "MissCount");
1: 
1:         // We have prepared 2 + (DEFAULT_STATEMENT_CACHE_SIZE * 2) statements,
1:         // and the cache can only hold DEFAULT_STATEMENT_CACHE_SIZE of them,
1:         // so expect DEFAULT_STATEMENT_CACHE_SIZE + 2 statements to have been
1:         // evicted from the cache.
1:         assertLongAttribute(2 + DEFAULT_STATEMENT_CACHE_SIZE,
1:                             name, "EvictionCount");
1: 
1:         // Expect the cache to be full.
1:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE, name, "MaxEntries");
1:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE,
1:                             name, "AllocatedEntries");
1:         assertLongAttribute(DEFAULT_STATEMENT_CACHE_SIZE, name, "UsedEntries");
1: 
1:         // Disable the access counts.
1:         setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:     }
commit:86ee0a0
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.management.CacheManagerMBeanTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.management;
1: 
1: import java.sql.PreparedStatement;
1: import java.util.Hashtable;
1: import java.util.Set;
1: import javax.management.ObjectName;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test cases for {@code CacheManagerMBean}.
1:  */
1: public class CacheManagerMBeanTest extends MBeanTest {
1: 
1:     public CacheManagerMBeanTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         return MBeanTest.suite(CacheManagerMBeanTest.class,
0:                                "CacheManagerMBeanTest");
1:     }
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         // Set up management.
1:         super.setUp();
1: 
1:         // Shut down the database before running the test case, so that the
1:         // test case can assume that it starts from a clean state where the
1:         // cache beans have not started yet. shutdownDatabase() fails if
1:         // the database is not already booted, so get a connection first to
1:         // ensure that it is booted (otherwise, the test will fail if it
1:         // runs standalone or first in a suite).
1:         getConnection().close();
1:         TestConfiguration.getCurrent().shutdownDatabase();
1:     }
1: 
1:     /**
1:      * Create an {@code ObjectName} that identifies a {@code CacheManager}
1:      * management bean, or a pattern that potentially matches multiple
1:      * beans.
1:      *
1:      * @param cacheName the name of the cache (such as PageCache), or
1:      *   {@code null} to create a pattern that matches all cache names
1:      * @param dbName the name of the database, or {@code null} to create
1:      *   a pattern that matches all database names
1:      * @return an {@code ObjectName} suitable for looking up beans
1:      */
1:     private ObjectName createObjectName(String cacheName, String dbName)
1:             throws Exception {
1:         Hashtable<String, String> props = new Hashtable<String, String>();
1:         props.put("type", "CacheManager");
1:         props.put("name", cacheName == null ? "*" : cacheName);
1:         props.put("db", dbName == null ? "*" : ObjectName.quote(dbName));
1:         return getDerbyMBeanName(props);
1:     }
1: 
1:     /**
1:      * Test case that verifies that {@code CacheManagerMBean}s start when
1:      * a database is started, and stop when the database is shut down.
1:      */
1:     public void testAllMBeansStartedAndStopped() throws Exception {
1:         // This pattern matches all CacheManager management beans when used
1:         // in a query.
1:         ObjectName pattern = createObjectName(null, null);
1: 
1:         // There should be no CacheManager MBeans before the database
1:         // is booted.
1:         Set<ObjectName> names = queryMBeans(pattern);
1:         if (!names.isEmpty()) {
1:             fail("Should not find MBeans before boot, found: " + names);
1:         }
1: 
1:         // Boot the database, so that the MBeans are started.
1:         getConnection();
1: 
0:         // There should be two CacheManager beans. One for the page cache
0:         // and one for the container cache.
1:         names = queryMBeans(pattern);
1:         assertEquals("Incorrect number of MBeans found in " + names,
0:                      2, names.size());
1: 
1:         // Shut down the database.
1:         TestConfiguration.getCurrent().shutdownDatabase();
1: 
1:         // There should be no CacheManager MBeans after the database has
1:         // been shut down.
1:         names = queryMBeans(pattern);
1:         if (!names.isEmpty()) {
1:             fail("Should not find MBeans after shutdown, found: " + names);
1:         }
1:     }
1: 
1:     /**
1:      * Test the {@code CacheManagerMBean} for the page cache.
1:      */
1:     public void testPageCache() throws Exception {
1:         getConnection(); // boot the database
1:         Set<ObjectName> names =
1:                 queryMBeans(createObjectName("PageCache", null));
1: 
1:         assertEquals("Should have a single page cache", 1, names.size());
1: 
1:         ObjectName name = names.iterator().next();
1: 
1:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(0, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
0:         // Default page cache size is 1000
0:         assertLongAttribute(1000, name, "MaxEntries");
1:         // Cannot reliably tell how many entries to expect.
1:         // More than 0 for sure.
1:         Long allocated = (Long) getAttribute(name, "AllocatedEntries");
1:         assertTrue("Allocated entries: " + allocated, allocated > 0);
1:         Long used = (Long) getAttribute(name, "UsedEntries");
1:         assertTrue("Used entries: " + used, used > 0);
1: 
1:         // Execute a statement against a table, so that the cache will be
1:         // accessed.
1:         PreparedStatement ps = prepareStatement(
1:                                     "select * from sysibm.sysdummy1");
1:         JDBC.assertDrainResults(ps.executeQuery());
1: 
1:         // Since collection of access counts is disabled by default, don't
1:         // expect the counts to be updated.
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(0, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
1: 
1:         // Now enable the access counts and re-execute the query. It
1:         // should result in a hit in the page cache.
1:         setAttribute(name, "CollectAccessCounts", Boolean.TRUE);
1:         assertBooleanAttribute(true, name, "CollectAccessCounts");
1:         JDBC.assertDrainResults(ps.executeQuery());
1:         assertLongAttribute(1, name, "HitCount");
1:         assertLongAttribute(0, name, "MissCount");
1: 
1:         // Disable the access counts.
1:         setAttribute(name, "CollectAccessCounts", Boolean.FALSE);
1:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:     }
1: 
1:     /**
1:      * Test the {@code CacheManagerMBean} for the page cache.
1:      */
1:     public void testContainerCache() throws Exception {
1:         getConnection(); // boot the database
1:         Set<ObjectName> names =
1:                 queryMBeans(createObjectName("ContainerCache", null));
1: 
1:         assertEquals("Should have a single container cache", 1, names.size());
1: 
1:         ObjectName name = names.iterator().next();
1: 
1:         assertBooleanAttribute(false, name, "CollectAccessCounts");
1:         assertLongAttribute(0, name, "HitCount");
1:         assertLongAttribute(0, name, "MissCount");
1:         assertLongAttribute(0, name, "EvictionCount");
0:         // Default container cache size is 100
0:         assertLongAttribute(100, name, "MaxEntries");
1:         // Cannot reliably tell how many entries to expect.
1:         // More than 0 for sure.
1:         Long allocated = (Long) getAttribute(name, "AllocatedEntries");
1:         assertTrue("Allocated entries: " + allocated, allocated > 0);
1:         Long used = (Long) getAttribute(name, "UsedEntries");
1:         assertTrue("Used entries: " + used, used > 0);
1:     }
1: }
============================================================================