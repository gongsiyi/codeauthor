1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.RelationalOperator
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
8:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:05623b6: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * This interface is an abstraction of a relational operator.  It was created
1:eac0369:  * for optimization, to allow binary comparison operators and IS NULL to
1:eac0369:  * be treated the same.
1:eac0369:  */
1:05623b6: interface RelationalOperator
1:eac0369: {
1:3bb140c:     final int EQUALS_RELOP = 1;
1:3bb140c:     final int NOT_EQUALS_RELOP = 2;
1:3bb140c:     final int GREATER_THAN_RELOP = 3;
1:3bb140c:     final int GREATER_EQUALS_RELOP = 4;
1:3bb140c:     final int LESS_THAN_RELOP = 5;
1:3bb140c:     final int LESS_EQUALS_RELOP = 6;
1:3bb140c:     final int IS_NULL_RELOP = 7;
1:3bb140c:     final int IS_NOT_NULL_RELOP = 8;
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * Check whether this RelationalOperator is a comparison of the given
2:eac0369: 	 * column with an expression.  If so, return the ColumnReference that
2:eac0369: 	 * corresponds to the given column, and that is on one side of this
2:eac0369: 	 * RelationalOperator or the other (this method copes with the
2:eac0369: 	 * column being on either side of the operator).  If the given column
2:eac0369: 	 * does not appear by itself on one side of the comparison, the
2:eac0369: 	 * method returns null.
4:eac0369: 	 *
1:eac0369: 	 * @param optTable	An Optimizable for the base table the column is in
2:eac0369: 	 * @param columnPosition	The ordinal position of the column (one-based)
1:eac0369: 	 *
2:eac0369: 	 * @return	The ColumnReference on one side of this RelationalOperator
2:eac0369: 	 *			that represents the given columnPosition.  Returns null
2:eac0369: 	 *			if no such ColumnReference exists by itself on one side of
2:eac0369: 	 *			this RelationalOperator.
1:eac0369: 	 */
1:eac0369: 	ColumnReference	getColumnOperand(Optimizable optTable, int columnPosition);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the ColumnReference for the given table on one side of this
1:eac0369: 	 * RelationalOperator.  This presumes it will be found only on one
1:eac0369: 	 * side.  If not found, it will return null.
1:eac0369: 	 */
1:eac0369: 	ColumnReference getColumnOperand(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:0be2d6e: 	 * Find the operand (left or right) that points to the same table
1:0be2d6e: 	 * as the received ColumnReference, and then return either that
1:0be2d6e: 	 * operand or the "other" operand, depending on the value of
1:0be2d6e: 	 * otherSide. This presumes it will be found only on one
1:0be2d6e: 	 * side.  If not found, it will return null.
1:0be2d6e: 	 *
1:0be2d6e: 	 * @param cRef The ColumnReference for which we're searching.
1:0be2d6e: 	 * @param refSetSize Size of the referenced map for the predicate
1:0be2d6e: 	 *  represented by this RelationalOperator node.  This is used
1:0be2d6e: 	 *  for storing base table numbers when searching for cRef.
1:0be2d6e: 	 * @param otherSide Assuming we find an operand that points to
1:0be2d6e: 	 *  the same table as cRef, then we will return the *other*
1:0be2d6e: 	 *  operand if otherSide is true; else we'll return the operand
1:0be2d6e: 	 *  that matches cRef.
1:0be2d6e: 	 */
1:0be2d6e: 	ValueNode getOperand(ColumnReference cRef, int refSetSize,
1:0be2d6e: 		boolean otherSide);
1:0be2d6e: 
1:0be2d6e: 	/**
1:eac0369: 	 * Check whether this RelationalOperator is a comparison of the given
1:eac0369: 	 * column with an expression.  If so, return the expression
1:eac0369: 	 * the column is being compared to.
1:eac0369: 	 *
1:eac0369: 	 * @param tableNumber	The table number of the base table the column is in
1:eac0369: 	 * @param columnPosition	The ordinal position of the column (one-based)
1:0be2d6e: 	 * @param ft	We'll look for the column in all tables at and beneath ft.
1:0be2d6e: 	 *   This is useful if ft is, say, a ProjectRestrictNode over a subquery--
1:0be2d6e: 	 *   then we want to look at all of the FROM tables in the subquery to try
1:0be2d6e: 	 *   to find the right column.
1:eac0369: 	 *
1:eac0369: 	 * @return	The ValueNode for the expression the column is being compared
1:eac0369: 	 *			to - null if the column is not being compared to anything.
1:eac0369: 	 */
1:eac0369: 	ValueNode getExpressionOperand(int tableNumber,
1:0be2d6e: 									int columnPosition,
1:05623b6: 									Optimizable ft);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check whether this RelationalOperator is a comparison of the given
1:eac0369: 	 * column with an expression.  If so, generate the Expression for
1:eac0369: 	 * the ValueNode that the column is being compared to.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	An Optimizable for the base table the column is in
1:eac0369: 	 * @param columnPosition	The ordinal position of the column (one-based)
1:eac0369: 	 * @param acb		The ExpressionClassBuilder for the class we're building
1:eac0369: 	 * @param mb		The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void generateExpressionOperand(Optimizable optTable,
1:eac0369: 										int columnPosition,
1:05623b6: 										ExpressionClassBuilderInterface acb,
1:eac0369: 										MethodBuilder mb)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check whether this RelationalOperator compares the given ColumnReference
1:eac0369: 	 * to any columns in the same table as the ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @param cr	The ColumnReference that is being compared to some
1:eac0369: 	 *				expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if the given ColumnReference is being compared to any
1:eac0369: 	 *			columns from the same table
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean			selfComparison(ColumnReference cr)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tell whether this relop is a useful start key for the given table.
1:eac0369: 	 * It has already been determined that the relop has a column from
1:eac0369: 	 * the given table on one side or the other.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table for which we want to know
1:eac0369: 	 *					whether this is a useful start key.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this is a useful start key
1:eac0369: 	 */
1:eac0369: 	boolean	usefulStartKey(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tell whether this relop is a useful stop key for the given table.
1:eac0369: 	 * It has already been determined that the relop has a column from
1:eac0369: 	 * the given table on one side or the other.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table for which we want to know
1:eac0369: 	 *					whether this is a useful stop key.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this is a useful stop key
1:eac0369: 	 */
1:eac0369: 	boolean	usefulStopKey(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the start operator for a scan (at the store level) for this
1:eac0369: 	 * RelationalOperator.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The optimizable table we're doing the scan on.
1:eac0369: 	 *					This parameter is so we can tell which side of
1:eac0369: 	 *					the operator the table's column is on.
1:eac0369: 	 *
1:eac0369: 	 * @return	Either ScanController.GT or ScanController.GE
1:eac0369: 	 *
1:eac0369: 	 * @see TransactionController#openScan
1:eac0369: 	 */
1:eac0369: 	int getStartOperator(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the stop operator for a scan (at the store level) for this
1:eac0369: 	 * RelationalOperator.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The optimizable table we're doing the scan on.
1:eac0369: 	 *					This parameter is so we can tell which side of
1:eac0369: 	 *					the operator the table's column is on.
1:eac0369: 	 *
1:eac0369: 	 * @return	Either ScanController.GT or ScanController.GE
1:eac0369: 	 *
1:eac0369: 	 * @see TransactionController#openScan
1:eac0369: 	 */
1:eac0369: 	int getStopOperator(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the absolute column id for the ColumnReference that appears on one
1:eac0369: 	 * side of this RelationalOperator or the other, and that refers to
1:eac0369: 	 * the given table. (Absolute column id means column id within the 
1:eac0369: 	 * row stored on disk.)
1:eac0369: 	 *
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 * @param optTable	The optimizable table we're doing the scan on.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	void generateAbsoluteColumnId(MethodBuilder mb,
1:eac0369: 										Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the relative column id for the ColumnReference that appears on one
1:eac0369: 	 * side of this RelationalOperator or the other, and that refers to
1:eac0369: 	 * the given table. (Relative column id means column id within the 
1:eac0369: 	 * partial row returned by the store.)
1:eac0369: 	 *
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 * @param optTable	The optimizable table we're doing the scan on.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	void generateRelativeColumnId(MethodBuilder mb,
1:eac0369: 										Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the comparison operator for this RelationalOperator.
1:eac0369: 	 * The operator can depend on which side of this operator the
1:eac0369: 	 * optimizable column is.
1:eac0369: 	 * 
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 * @param optTable	The optimizable table we're doing the scan on.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	void generateOperator(MethodBuilder mb,
1:eac0369: 								Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the method to evaluate a Qualifier.  The factory method for
1:eac0369: 	 * a Qualifier takes a GeneratedMethod that returns the Orderable
1:eac0369: 	 * that Qualifier.getOrderable() returns.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're building
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 * @param optTable	The Optimizable table the Qualifier will qualify
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error.
1:eac0369: 	 */
1:05623b6:     void generateQualMethod(ExpressionClassBuilderInterface acb,
1:eac0369: 								MethodBuilder mb,
1:eac0369: 								Optimizable optTable)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate an expression that evaluates to true if this RelationalOperator
1:eac0369: 	 * uses ordered null semantics, false if it doesn't.
1:eac0369: 	 *
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	void generateOrderedNulls(MethodBuilder mb);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate an expression that evaluates to true if the result of the
1:dbed020: 	 * comparison should be negated.  For example, col &gt; 1 generates
1:dbed020: 	 * a comparison operator of &lt;= and a negation of true, while col &lt; 1
1:dbed020: 	 * generates a comparison operator of &lt; and a negation of false.
1:eac0369: 	 *
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 * @param optTable	The Optimizable table the Qualifier will qualify
1:eac0369: 	 */
1:eac0369: 	void generateNegate(MethodBuilder mb,
1:eac0369: 								Optimizable optTable);
1:eac0369: 
1:eac0369: 	/** Return true if this operator uses ordered null semantics */
1:eac0369: 	boolean orderedNulls();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if this operator can be compiled into a Qualifier for
1:eac0369: 	 * the given Optimizable table.  This means that there is a column
1:eac0369: 	 * from that table on one side of this relop, and an expression that
1:eac0369: 	 * does not refer to the table on the other side of the relop.
1:eac0369: 	 *
1:0be2d6e: 	 * Note that this method has two uses: 1) see if this operator (or
1:0be2d6e: 	 * more specifically, the predicate to which this operator belongs)
1:0be2d6e: 	 * can be used as a join predicate (esp. for a hash join), and 2)
1:0be2d6e: 	 * see if this operator can be pushed to the target optTable.  We
1:0be2d6e: 	 * use the parameter "forPush" to distinguish between the two uses
1:0be2d6e: 	 * because in some cases (esp. situations where we have subqueries)
1:0be2d6e: 	 * the answer to "is this a qualifier?" can differ depending on
1:0be2d6e: 	 * whether or not we're pushing.  In particular, for binary ops
1:0be2d6e: 	 * that are join predicates, if we're just trying to find an
1:0be2d6e: 	 * equijoin predicate then this op qualifies if it references either
1:0be2d6e: 	 * the target table OR any of the base tables in the table's subtree.
1:0be2d6e: 	 * But if we're planning to push the predicate down to the target
1:0be2d6e: 	 * table, this op only qualifies if it references the target table
1:0be2d6e: 	 * directly.  This difference in behavior is required because in
1:0be2d6e: 	 * case 1 (searching for join predicates), the operator remains at
1:0be2d6e: 	 * its current level in the tree even if its operands reference
1:0be2d6e: 	 * nodes further down; in case 2, though, we'll end up pushing
1:0be2d6e: 	 * the operator down the tree to child node(s) and that requires
1:0be2d6e: 	 * additional logic, such as "scoping" consideration.  Until
1:0be2d6e: 	 * that logic is in place, we don't search a subtree if the intent
1:0be2d6e: 	 * is to push the predicate to which this operator belongs further
1:0be2d6e: 	 * down that subtree.  See BinaryRelationalOperatorNode for an
1:0be2d6e: 	 * example of where this comes into play.
1:0be2d6e: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table in question.
1:0be2d6e: 	 * @param forPush	Are we asking because we're trying to push?
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this operator can be compiled into a Qualifier
1:eac0369: 	 *			for the given Optimizable table.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:0be2d6e: 	boolean isQualifier(Optimizable optTable, boolean forPush)
1:0be2d6e: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the operator (as an int) for this RelationalOperator.
1:eac0369: 	 *
1:eac0369: 	 * @return int		The operator for this RelationalOperator.
1:eac0369: 	 */
1:3bb140c:     int getOperator();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the Qualifier's Orderable.
1:eac0369: 	 * (Is the Orderable invariant within a scan or within a query?)
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table the Qualifier will qualify
1:eac0369: 	 *
1:eac0369: 	 * @return int		The variant type for the Qualifier's Orderable.
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:3bb140c:     int getOrderableVariantType(Optimizable optTable)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether this operator compares the given Optimizable with
1:eac0369: 	 * a constant whose value is known at compile time.
1:eac0369: 	 */
1:3bb140c:     boolean compareWithKnownConstant(
1:3bb140c:         Optimizable optTable, boolean considerParameters);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return an Object representing the known value that this relational
1:eac0369: 	 * operator is comparing to a column in the given Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     DataValueDescriptor getCompareValue(Optimizable optTable)
1:eac0369: 					throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether this operator is an equality comparison of the given
1:eac0369: 	 * optimizable with a constant expression.
1:eac0369: 	 */
1:3bb140c:     boolean equalsComparisonWithConstantExpression(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a relational operator which matches the current one
1:eac0369: 	 * but with the passed in ColumnReference as the (left) operand.
1:eac0369: 	 *
1:eac0369: 	 * @param otherCR	The ColumnReference for the new (left) operand.
1:eac0369: 	 *
1:eac0369: 	 * @return	A relational operator which matches the current one
1:eac0369: 	 *			but with the passed in ColumnReference as the (left) operand.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
1:eac0369: 		throws StandardException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * comparison should be negated.  For example, col &gt; 1 generates
1: 	 * a comparison operator of &lt;= and a negation of true, while col &lt; 1
1: 	 * generates a comparison operator of &lt; and a negation of false.
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
/////////////////////////////////////////////////////////////////////////
1:     final int EQUALS_RELOP = 1;
1:     final int NOT_EQUALS_RELOP = 2;
1:     final int GREATER_THAN_RELOP = 3;
1:     final int GREATER_EQUALS_RELOP = 4;
1:     final int LESS_THAN_RELOP = 5;
1:     final int LESS_EQUALS_RELOP = 6;
1:     final int IS_NULL_RELOP = 7;
1:     final int IS_NOT_NULL_RELOP = 8;
/////////////////////////////////////////////////////////////////////////
1:     int getOperator();
/////////////////////////////////////////////////////////////////////////
1:     int getOrderableVariantType(Optimizable optTable)
1:     boolean compareWithKnownConstant(
1:         Optimizable optTable, boolean considerParameters);
/////////////////////////////////////////////////////////////////////////
1:     DataValueDescriptor getCompareValue(Optimizable optTable)
1:     boolean equalsComparisonWithConstantExpression(Optimizable optTable);
/////////////////////////////////////////////////////////////////////////
1:     RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:05623b6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1: interface RelationalOperator
/////////////////////////////////////////////////////////////////////////
1: 									Optimizable ft);
/////////////////////////////////////////////////////////////////////////
1: 										ExpressionClassBuilderInterface acb,
/////////////////////////////////////////////////////////////////////////
1:     void generateQualMethod(ExpressionClassBuilderInterface acb,
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0be2d6e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Find the operand (left or right) that points to the same table
1: 	 * as the received ColumnReference, and then return either that
1: 	 * operand or the "other" operand, depending on the value of
1: 	 * otherSide. This presumes it will be found only on one
1: 	 * side.  If not found, it will return null.
1: 	 *
1: 	 * @param cRef The ColumnReference for which we're searching.
1: 	 * @param refSetSize Size of the referenced map for the predicate
1: 	 *  represented by this RelationalOperator node.  This is used
1: 	 *  for storing base table numbers when searching for cRef.
1: 	 * @param otherSide Assuming we find an operand that points to
1: 	 *  the same table as cRef, then we will return the *other*
1: 	 *  operand if otherSide is true; else we'll return the operand
1: 	 *  that matches cRef.
1: 	 */
1: 	ValueNode getOperand(ColumnReference cRef, int refSetSize,
1: 		boolean otherSide);
1: 
1: 	/**
1: 	 * @param ft	We'll look for the column in all tables at and beneath ft.
1: 	 *   This is useful if ft is, say, a ProjectRestrictNode over a subquery--
1: 	 *   then we want to look at all of the FROM tables in the subquery to try
1: 	 *   to find the right column.
1: 									int columnPosition,
0: 									FromTable ft);
/////////////////////////////////////////////////////////////////////////
1: 	 * Note that this method has two uses: 1) see if this operator (or
1: 	 * more specifically, the predicate to which this operator belongs)
1: 	 * can be used as a join predicate (esp. for a hash join), and 2)
1: 	 * see if this operator can be pushed to the target optTable.  We
1: 	 * use the parameter "forPush" to distinguish between the two uses
1: 	 * because in some cases (esp. situations where we have subqueries)
1: 	 * the answer to "is this a qualifier?" can differ depending on
1: 	 * whether or not we're pushing.  In particular, for binary ops
1: 	 * that are join predicates, if we're just trying to find an
1: 	 * equijoin predicate then this op qualifies if it references either
1: 	 * the target table OR any of the base tables in the table's subtree.
1: 	 * But if we're planning to push the predicate down to the target
1: 	 * table, this op only qualifies if it references the target table
1: 	 * directly.  This difference in behavior is required because in
1: 	 * case 1 (searching for join predicates), the operator remains at
1: 	 * its current level in the tree even if its operands reference
1: 	 * nodes further down; in case 2, though, we'll end up pushing
1: 	 * the operator down the tree to child node(s) and that requires
1: 	 * additional logic, such as "scoping" consideration.  Until
1: 	 * that logic is in place, we don't search a subtree if the intent
1: 	 * is to push the predicate to which this operator belongs further
1: 	 * down that subtree.  See BinaryRelationalOperatorNode for an
1: 	 * example of where this comes into play.
1: 	 *
1: 	 * @param forPush	Are we asking because we're trying to push?
1: 	boolean isQualifier(Optimizable optTable, boolean forPush)
1: 		throws StandardException;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.RelationalOperator
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
1: /**
1:  * This interface is an abstraction of a relational operator.  It was created
1:  * for optimization, to allow binary comparison operators and IS NULL to
1:  * be treated the same.
1:  */
0: public interface RelationalOperator
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public final int EQUALS_RELOP = 1;
0: 	public final int NOT_EQUALS_RELOP = 2;
0: 	public final int GREATER_THAN_RELOP = 3;
0: 	public final int GREATER_EQUALS_RELOP = 4;
0: 	public final int LESS_THAN_RELOP = 5;
0: 	public final int LESS_EQUALS_RELOP = 6;
0: 	public final int IS_NULL_RELOP = 7;
0: 	public final int IS_NOT_NULL_RELOP = 8;
1: 
1: 	/**
1: 	 * Check whether this RelationalOperator is a comparison of the given
1: 	 * column with an expression.  If so, return the ColumnReference that
1: 	 * corresponds to the given column, and that is on one side of this
1: 	 * RelationalOperator or the other (this method copes with the
1: 	 * column being on either side of the operator).  If the given column
1: 	 * does not appear by itself on one side of the comparison, the
1: 	 * method returns null.
1: 	 *
1: 	 * @param optTable	An Optimizable for the base table the column is in
1: 	 * @param columnPosition	The ordinal position of the column (one-based)
1: 	 *
1: 	 * @return	The ColumnReference on one side of this RelationalOperator
1: 	 *			that represents the given columnPosition.  Returns null
1: 	 *			if no such ColumnReference exists by itself on one side of
1: 	 *			this RelationalOperator.
1: 	 */
1: 	ColumnReference	getColumnOperand(Optimizable optTable, int columnPosition);
1: 
1: 	/**
1: 	 * Check whether this RelationalOperator is a comparison of the given
1: 	 * column with an expression.  If so, return the ColumnReference that
1: 	 * corresponds to the given column, and that is on one side of this
1: 	 * RelationalOperator or the other (this method copes with the
1: 	 * column being on either side of the operator).  If the given column
1: 	 * does not appear by itself on one side of the comparison, the
1: 	 * method returns null.
1: 	 *
0: 	 * @param tableNumber	The table number of the table in question
1: 	 * @param columnPosition	The ordinal position of the column (one-based)
1: 	 *
1: 	 * @return	The ColumnReference on one side of this RelationalOperator
1: 	 *			that represents the given columnPosition.  Returns null
1: 	 *			if no such ColumnReference exists by itself on one side of
1: 	 *			this RelationalOperator.
1: 	 */
0: 	ColumnReference getColumnOperand(int tableNumber, int columnPosition);
1: 
1: 	/**
1: 	 * Get the ColumnReference for the given table on one side of this
1: 	 * RelationalOperator.  This presumes it will be found only on one
1: 	 * side.  If not found, it will return null.
1: 	 */
1: 	ColumnReference getColumnOperand(Optimizable optTable);
1: 
1: 	/**
1: 	 * Check whether this RelationalOperator is a comparison of the given
1: 	 * column with an expression.  If so, return the expression
1: 	 * the column is being compared to.
1: 	 *
1: 	 * @param tableNumber	The table number of the base table the column is in
1: 	 * @param columnPosition	The ordinal position of the column (one-based)
1: 	 *
1: 	 * @return	The ValueNode for the expression the column is being compared
1: 	 *			to - null if the column is not being compared to anything.
1: 	 */
1: 	ValueNode getExpressionOperand(int tableNumber,
0: 									int columnPosition);
1: 
1: 	/**
1: 	 * Check whether this RelationalOperator is a comparison of the given
1: 	 * column with an expression.  If so, generate the Expression for
1: 	 * the ValueNode that the column is being compared to.
1: 	 *
1: 	 * @param optTable	An Optimizable for the base table the column is in
1: 	 * @param columnPosition	The ordinal position of the column (one-based)
1: 	 * @param acb		The ExpressionClassBuilder for the class we're building
1: 	 * @param mb		The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void generateExpressionOperand(Optimizable optTable,
1: 										int columnPosition,
0: 										ExpressionClassBuilder acb,
1: 										MethodBuilder mb)
1: 						throws StandardException;
1: 
1: 	/**
1: 	 * Check whether this RelationalOperator compares the given ColumnReference
1: 	 * to any columns in the same table as the ColumnReference.
1: 	 *
1: 	 * @param cr	The ColumnReference that is being compared to some
1: 	 *				expression.
1: 	 *
1: 	 * @return	true if the given ColumnReference is being compared to any
1: 	 *			columns from the same table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean			selfComparison(ColumnReference cr)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Tell whether this relop is a useful start key for the given table.
1: 	 * It has already been determined that the relop has a column from
1: 	 * the given table on one side or the other.
1: 	 *
1: 	 * @param optTable	The Optimizable table for which we want to know
1: 	 *					whether this is a useful start key.
1: 	 *
1: 	 * @return	true if this is a useful start key
1: 	 */
1: 	boolean	usefulStartKey(Optimizable optTable);
1: 
1: 	/**
1: 	 * Tell whether this relop is a useful stop key for the given table.
1: 	 * It has already been determined that the relop has a column from
1: 	 * the given table on one side or the other.
1: 	 *
1: 	 * @param optTable	The Optimizable table for which we want to know
1: 	 *					whether this is a useful stop key.
1: 	 *
1: 	 * @return	true if this is a useful stop key
1: 	 */
1: 	boolean	usefulStopKey(Optimizable optTable);
1: 
1: 	/**
1: 	 * Get the start operator for a scan (at the store level) for this
1: 	 * RelationalOperator.
1: 	 *
1: 	 * @param optTable	The optimizable table we're doing the scan on.
1: 	 *					This parameter is so we can tell which side of
1: 	 *					the operator the table's column is on.
1: 	 *
1: 	 * @return	Either ScanController.GT or ScanController.GE
1: 	 *
1: 	 * @see TransactionController#openScan
1: 	 */
1: 	int getStartOperator(Optimizable optTable);
1: 
1: 	/**
1: 	 * Get the stop operator for a scan (at the store level) for this
1: 	 * RelationalOperator.
1: 	 *
1: 	 * @param optTable	The optimizable table we're doing the scan on.
1: 	 *					This parameter is so we can tell which side of
1: 	 *					the operator the table's column is on.
1: 	 *
1: 	 * @return	Either ScanController.GT or ScanController.GE
1: 	 *
1: 	 * @see TransactionController#openScan
1: 	 */
1: 	int getStopOperator(Optimizable optTable);
1: 
1: 	/**
1: 	 * Generate the absolute column id for the ColumnReference that appears on one
1: 	 * side of this RelationalOperator or the other, and that refers to
1: 	 * the given table. (Absolute column id means column id within the 
1: 	 * row stored on disk.)
1: 	 *
1: 	 * @param mb	The method the generated code is to go into
1: 	 * @param optTable	The optimizable table we're doing the scan on.
1: 	 *
1: 	 */
1: 	void generateAbsoluteColumnId(MethodBuilder mb,
1: 										Optimizable optTable);
1: 
1: 	/**
1: 	 * Generate the relative column id for the ColumnReference that appears on one
1: 	 * side of this RelationalOperator or the other, and that refers to
1: 	 * the given table. (Relative column id means column id within the 
1: 	 * partial row returned by the store.)
1: 	 *
1: 	 * @param mb	The method the generated code is to go into
1: 	 * @param optTable	The optimizable table we're doing the scan on.
1: 	 *
1: 	 */
1: 	void generateRelativeColumnId(MethodBuilder mb,
1: 										Optimizable optTable);
1: 
1: 	/**
1: 	 * Generate the comparison operator for this RelationalOperator.
1: 	 * The operator can depend on which side of this operator the
1: 	 * optimizable column is.
1: 	 * 
1: 	 * @param mb	The method the generated code is to go into
1: 	 * @param optTable	The optimizable table we're doing the scan on.
1: 	 *
1: 	 */
1: 	void generateOperator(MethodBuilder mb,
1: 								Optimizable optTable);
1: 
1: 	/**
1: 	 * Generate the method to evaluate a Qualifier.  The factory method for
1: 	 * a Qualifier takes a GeneratedMethod that returns the Orderable
1: 	 * that Qualifier.getOrderable() returns.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're building
1: 	 * @param mb	The method the generated code is to go into
1: 	 * @param optTable	The Optimizable table the Qualifier will qualify
1: 	 *
0: 	 * @return	An expression that evaluates to the GeneratedMethod that
0: 	 *			returns the Orderable to be returned by Qualifier.getOrderable()
1: 	 *
1: 	 * @exception StandardException		Thrown on error.
1: 	 */
0: 	void generateQualMethod(ExpressionClassBuilder acb,
1: 								MethodBuilder mb,
1: 								Optimizable optTable)
1: 						throws StandardException;
1: 
1: 	/**
1: 	 * Generate an expression that evaluates to true if this RelationalOperator
1: 	 * uses ordered null semantics, false if it doesn't.
1: 	 *
1: 	 * @param mb	The method the generated code is to go into
1: 	 *
1: 	 */
1: 	void generateOrderedNulls(MethodBuilder mb);
1: 
1: 	/**
1: 	 * Generate an expression that evaluates to true if the result of the
0: 	 * comparison should be negated.  For example, col > 1 generates
0: 	 * a comparison operator of <= and a negation of true, while col < 1
0: 	 * generates a comparison operator of < and a negation of false.
1: 	 *
1: 	 * @param mb	The method the generated code is to go into
1: 	 * @param optTable	The Optimizable table the Qualifier will qualify
1: 	 */
1: 	void generateNegate(MethodBuilder mb,
1: 								Optimizable optTable);
1: 
1: 	/** Return true if this operator uses ordered null semantics */
1: 	boolean orderedNulls();
1: 
1: 	/**
1: 	 * Return true if this operator can be compiled into a Qualifier for
1: 	 * the given Optimizable table.  This means that there is a column
1: 	 * from that table on one side of this relop, and an expression that
1: 	 * does not refer to the table on the other side of the relop.
1: 	 *
1: 	 * @param optTable	The Optimizable table in question.
1: 	 *
1: 	 * @return	true if this operator can be compiled into a Qualifier
1: 	 *			for the given Optimizable table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	boolean isQualifier(Optimizable optTable) throws StandardException;
1: 
1: 	/**
1: 	 * Return the operator (as an int) for this RelationalOperator.
1: 	 *
1: 	 * @return int		The operator for this RelationalOperator.
1: 	 */
0: 	public int getOperator();
1: 
1: 	/**
1: 	 * Return the variant type for the Qualifier's Orderable.
1: 	 * (Is the Orderable invariant within a scan or within a query?)
1: 	 *
1: 	 * @param optTable	The Optimizable table the Qualifier will qualify
1: 	 *
1: 	 * @return int		The variant type for the Qualifier's Orderable.
1: 	 * @exception StandardException	thrown on error
1: 	 */
0: 	public int getOrderableVariantType(Optimizable optTable)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Return whether this operator compares the given Optimizable with
1: 	 * a constant whose value is known at compile time.
1: 	 */
0: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters);
1: 
1: 	/**
1: 	 * Return an Object representing the known value that this relational
1: 	 * operator is comparing to a column in the given Optimizable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public DataValueDescriptor getCompareValue(Optimizable optTable)
1: 					throws StandardException;
1: 
1: 	/**
1: 	 * Return whether this operator is an equality comparison of the given
1: 	 * optimizable with a constant expression.
1: 	 */
0: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable);
1: 
1: 	/**
1: 	 * Return a relational operator which matches the current one
1: 	 * but with the passed in ColumnReference as the (left) operand.
1: 	 *
1: 	 * @param otherCR	The ColumnReference for the new (left) operand.
1: 	 *
1: 	 * @return	A relational operator which matches the current one
1: 	 *			but with the passed in ColumnReference as the (left) operand.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
1: 		throws StandardException;
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: /**
0:  * This interface is an abstraction of a relational operator.  It was created
0:  * for optimization, to allow binary comparison operators and IS NULL to
0:  * be treated the same.
0:  */
0: public interface RelationalOperator
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public final int EQUALS_RELOP = 1;
0: 	public final int NOT_EQUALS_RELOP = 2;
0: 	public final int GREATER_THAN_RELOP = 3;
0: 	public final int GREATER_EQUALS_RELOP = 4;
0: 	public final int LESS_THAN_RELOP = 5;
0: 	public final int LESS_EQUALS_RELOP = 6;
0: 	public final int IS_NULL_RELOP = 7;
0: 	public final int IS_NOT_NULL_RELOP = 8;
0: 
0: 	/**
0: 	 * Check whether this RelationalOperator is a comparison of the given
0: 	 * column with an expression.  If so, return the ColumnReference that
0: 	 * corresponds to the given column, and that is on one side of this
0: 	 * RelationalOperator or the other (this method copes with the
0: 	 * column being on either side of the operator).  If the given column
0: 	 * does not appear by itself on one side of the comparison, the
0: 	 * method returns null.
0: 	 *
0: 	 * @param optTable	An Optimizable for the base table the column is in
0: 	 * @param columnPosition	The ordinal position of the column (one-based)
0: 	 *
0: 	 * @return	The ColumnReference on one side of this RelationalOperator
0: 	 *			that represents the given columnPosition.  Returns null
0: 	 *			if no such ColumnReference exists by itself on one side of
0: 	 *			this RelationalOperator.
0: 	 */
0: 	ColumnReference	getColumnOperand(Optimizable optTable, int columnPosition);
0: 
0: 	/**
0: 	 * Check whether this RelationalOperator is a comparison of the given
0: 	 * column with an expression.  If so, return the ColumnReference that
0: 	 * corresponds to the given column, and that is on one side of this
0: 	 * RelationalOperator or the other (this method copes with the
0: 	 * column being on either side of the operator).  If the given column
0: 	 * does not appear by itself on one side of the comparison, the
0: 	 * method returns null.
0: 	 *
0: 	 * @param tableNumber	The table number of the table in question
0: 	 * @param columnPosition	The ordinal position of the column (one-based)
0: 	 *
0: 	 * @return	The ColumnReference on one side of this RelationalOperator
0: 	 *			that represents the given columnPosition.  Returns null
0: 	 *			if no such ColumnReference exists by itself on one side of
0: 	 *			this RelationalOperator.
0: 	 */
0: 	ColumnReference getColumnOperand(int tableNumber, int columnPosition);
0: 
0: 	/**
0: 	 * Get the ColumnReference for the given table on one side of this
0: 	 * RelationalOperator.  This presumes it will be found only on one
0: 	 * side.  If not found, it will return null.
0: 	 */
0: 	ColumnReference getColumnOperand(Optimizable optTable);
0: 
0: 	/**
0: 	 * Check whether this RelationalOperator is a comparison of the given
0: 	 * column with an expression.  If so, return the expression
0: 	 * the column is being compared to.
0: 	 *
0: 	 * @param tableNumber	The table number of the base table the column is in
0: 	 * @param columnPosition	The ordinal position of the column (one-based)
0: 	 *
0: 	 * @return	The ValueNode for the expression the column is being compared
0: 	 *			to - null if the column is not being compared to anything.
0: 	 */
0: 	ValueNode getExpressionOperand(int tableNumber,
0: 									int columnPosition);
0: 
0: 	/**
0: 	 * Check whether this RelationalOperator is a comparison of the given
0: 	 * column with an expression.  If so, generate the Expression for
0: 	 * the ValueNode that the column is being compared to.
0: 	 *
0: 	 * @param optTable	An Optimizable for the base table the column is in
0: 	 * @param columnPosition	The ordinal position of the column (one-based)
0: 	 * @param acb		The ExpressionClassBuilder for the class we're building
0: 	 * @param mb		The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void generateExpressionOperand(Optimizable optTable,
0: 										int columnPosition,
0: 										ExpressionClassBuilder acb,
0: 										MethodBuilder mb)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * Check whether this RelationalOperator compares the given ColumnReference
0: 	 * to any columns in the same table as the ColumnReference.
0: 	 *
0: 	 * @param cr	The ColumnReference that is being compared to some
0: 	 *				expression.
0: 	 *
0: 	 * @return	true if the given ColumnReference is being compared to any
0: 	 *			columns from the same table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean			selfComparison(ColumnReference cr)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Tell whether this relop is a useful start key for the given table.
0: 	 * It has already been determined that the relop has a column from
0: 	 * the given table on one side or the other.
0: 	 *
0: 	 * @param optTable	The Optimizable table for which we want to know
0: 	 *					whether this is a useful start key.
0: 	 *
0: 	 * @return	true if this is a useful start key
0: 	 */
0: 	boolean	usefulStartKey(Optimizable optTable);
0: 
0: 	/**
0: 	 * Tell whether this relop is a useful stop key for the given table.
0: 	 * It has already been determined that the relop has a column from
0: 	 * the given table on one side or the other.
0: 	 *
0: 	 * @param optTable	The Optimizable table for which we want to know
0: 	 *					whether this is a useful stop key.
0: 	 *
0: 	 * @return	true if this is a useful stop key
0: 	 */
0: 	boolean	usefulStopKey(Optimizable optTable);
0: 
0: 	/**
0: 	 * Get the start operator for a scan (at the store level) for this
0: 	 * RelationalOperator.
0: 	 *
0: 	 * @param optTable	The optimizable table we're doing the scan on.
0: 	 *					This parameter is so we can tell which side of
0: 	 *					the operator the table's column is on.
0: 	 *
0: 	 * @return	Either ScanController.GT or ScanController.GE
0: 	 *
0: 	 * @see TransactionController#openScan
0: 	 */
0: 	int getStartOperator(Optimizable optTable);
0: 
0: 	/**
0: 	 * Get the stop operator for a scan (at the store level) for this
0: 	 * RelationalOperator.
0: 	 *
0: 	 * @param optTable	The optimizable table we're doing the scan on.
0: 	 *					This parameter is so we can tell which side of
0: 	 *					the operator the table's column is on.
0: 	 *
0: 	 * @return	Either ScanController.GT or ScanController.GE
0: 	 *
0: 	 * @see TransactionController#openScan
0: 	 */
0: 	int getStopOperator(Optimizable optTable);
0: 
0: 	/**
0: 	 * Generate the absolute column id for the ColumnReference that appears on one
0: 	 * side of this RelationalOperator or the other, and that refers to
0: 	 * the given table. (Absolute column id means column id within the 
0: 	 * row stored on disk.)
0: 	 *
0: 	 * @param mb	The method the generated code is to go into
0: 	 * @param optTable	The optimizable table we're doing the scan on.
0: 	 *
0: 	 */
0: 	void generateAbsoluteColumnId(MethodBuilder mb,
0: 										Optimizable optTable);
0: 
0: 	/**
0: 	 * Generate the relative column id for the ColumnReference that appears on one
0: 	 * side of this RelationalOperator or the other, and that refers to
0: 	 * the given table. (Relative column id means column id within the 
0: 	 * partial row returned by the store.)
0: 	 *
0: 	 * @param mb	The method the generated code is to go into
0: 	 * @param optTable	The optimizable table we're doing the scan on.
0: 	 *
0: 	 */
0: 	void generateRelativeColumnId(MethodBuilder mb,
0: 										Optimizable optTable);
0: 
0: 	/**
0: 	 * Generate the comparison operator for this RelationalOperator.
0: 	 * The operator can depend on which side of this operator the
0: 	 * optimizable column is.
0: 	 * 
0: 	 * @param mb	The method the generated code is to go into
0: 	 * @param optTable	The optimizable table we're doing the scan on.
0: 	 *
0: 	 */
0: 	void generateOperator(MethodBuilder mb,
0: 								Optimizable optTable);
0: 
0: 	/**
0: 	 * Generate the method to evaluate a Qualifier.  The factory method for
0: 	 * a Qualifier takes a GeneratedMethod that returns the Orderable
0: 	 * that Qualifier.getOrderable() returns.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're building
0: 	 * @param mb	The method the generated code is to go into
0: 	 * @param optTable	The Optimizable table the Qualifier will qualify
0: 	 *
0: 	 * @return	An expression that evaluates to the GeneratedMethod that
0: 	 *			returns the Orderable to be returned by Qualifier.getOrderable()
0: 	 *
0: 	 * @exception StandardException		Thrown on error.
0: 	 */
0: 	void generateQualMethod(ExpressionClassBuilder acb,
0: 								MethodBuilder mb,
0: 								Optimizable optTable)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * Generate an expression that evaluates to true if this RelationalOperator
0: 	 * uses ordered null semantics, false if it doesn't.
0: 	 *
0: 	 * @param mb	The method the generated code is to go into
0: 	 *
0: 	 */
0: 	void generateOrderedNulls(MethodBuilder mb);
0: 
0: 	/**
0: 	 * Generate an expression that evaluates to true if the result of the
0: 	 * comparison should be negated.  For example, col > 1 generates
0: 	 * a comparison operator of <= and a negation of true, while col < 1
0: 	 * generates a comparison operator of < and a negation of false.
0: 	 *
0: 	 * @param mb	The method the generated code is to go into
0: 	 * @param optTable	The Optimizable table the Qualifier will qualify
0: 	 */
0: 	void generateNegate(MethodBuilder mb,
0: 								Optimizable optTable);
0: 
0: 	/** Return true if this operator uses ordered null semantics */
0: 	boolean orderedNulls();
0: 
0: 	/**
0: 	 * Return true if this operator can be compiled into a Qualifier for
0: 	 * the given Optimizable table.  This means that there is a column
0: 	 * from that table on one side of this relop, and an expression that
0: 	 * does not refer to the table on the other side of the relop.
0: 	 *
0: 	 * @param optTable	The Optimizable table in question.
0: 	 *
0: 	 * @return	true if this operator can be compiled into a Qualifier
0: 	 *			for the given Optimizable table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean isQualifier(Optimizable optTable) throws StandardException;
0: 
0: 	/**
0: 	 * Return the operator (as an int) for this RelationalOperator.
0: 	 *
0: 	 * @return int		The operator for this RelationalOperator.
0: 	 */
0: 	public int getOperator();
0: 
0: 	/**
0: 	 * Return the variant type for the Qualifier's Orderable.
0: 	 * (Is the Orderable invariant within a scan or within a query?)
0: 	 *
0: 	 * @param optTable	The Optimizable table the Qualifier will qualify
0: 	 *
0: 	 * @return int		The variant type for the Qualifier's Orderable.
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	public int getOrderableVariantType(Optimizable optTable)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Return whether this operator compares the given Optimizable with
0: 	 * a constant whose value is known at compile time.
0: 	 */
0: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters);
0: 
0: 	/**
0: 	 * Return an Object representing the known value that this relational
0: 	 * operator is comparing to a column in the given Optimizable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataValueDescriptor getCompareValue(Optimizable optTable)
0: 					throws StandardException;
0: 
0: 	/**
0: 	 * Return whether this operator is an equality comparison of the given
0: 	 * optimizable with a constant expression.
0: 	 */
0: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable);
0: 
0: 	/**
0: 	 * Return a relational operator which matches the current one
0: 	 * but with the passed in ColumnReference as the (left) operand.
0: 	 *
0: 	 * @param otherCR	The ColumnReference for the new (left) operand.
0: 	 *
0: 	 * @return	A relational operator which matches the current one
0: 	 *			but with the passed in ColumnReference as the (left) operand.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
0: 		throws StandardException;
0: }
============================================================================