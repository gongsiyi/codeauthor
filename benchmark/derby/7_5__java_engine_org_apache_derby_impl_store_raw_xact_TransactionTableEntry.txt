1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.xact.TransactionTableEntry
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.xact;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionInfo;
1:eac0369: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
2:eac0369: /**
1:c6892a1: 	Transaction table entry is used to store all relevant information of a
1:eac0369: 	transaction into the transaction table for the use of checkpoint, recovery,
1:eac0369: 	Transaction management during Quiesce state, and for dumping transaction table.  Only works
1:eac0369: 	with the following classes: TransactionTable, XactFactory, Xact
1:eac0369: 	<BR>
1:eac0369: 	During run time, whenever any transaction is started, it is put into the
1:eac0369: 	transaction table.  Whenever any transaction is closed, it is removed from
1:eac0369: 	the transaction table.
1:eac0369: 
1:eac0369: 
1:eac0369: */
1:eac0369: 
1:eac0369: public class TransactionTableEntry implements Formatable, TransactionInfo, Cloneable
1:eac0369: {
1:eac0369: 	// These fields are only populated if this TTE has been read in from the
1:eac0369: 	// log.  Otherwise, they are gotten from the transaction object myxact.
1:eac0369: 	private TransactionId           xid;
1:eac0369: 	private GlobalTransactionId     gid;
1:eac0369: 	private LogInstant              firstLog;
1:eac0369: 	private LogInstant              lastLog;
1:eac0369: 
1:eac0369: 	// this field is always present - it is 0 for read only transaction, this
1:eac0369:     // is a copy of the status from the Xact (the copy is necessary as during
1:eac0369:     // recovery the Xact is shared by all transaction table entries during
1:eac0369:     // redo and undo).
1:eac0369: 	private int                     transactionStatus;
1:eac0369: 
1:eac0369: 	// fields useful for returning transaction information if read from 
1:eac0369:     // transaction log during recovery
1:eac0369: 	private transient Xact    myxact; 
1:eac0369: 	private transient boolean update;
1:eac0369: 	private transient boolean recovery;         // is this a transaction read 
1:eac0369:                                                 // from the log during recovery?
1:eac0369: 	private transient boolean needExclusion;    // in a quiesce state , this 
1:eac0369:                                                 // transaction needs to be 
1:eac0369:                                                 // barred from activation 
1:eac0369:                                                 // during quiesce state
1:eac0369: 
1:eac0369: 	private boolean isClone;		            // am I a clone made for the 
1:eac0369:                                                 // TransactionVTI?
1:eac0369: 
1:eac0369: 	private transient LanguageConnectionContext lcc;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/* package */
1:eac0369: 	// entry attribute
1:eac0369: 	static final int UPDATE		= 0x1;
1:eac0369: 	static final int RECOVERY	= 0x2;
1:eac0369: 	static final int EXCLUDE	= 0x4;
1:eac0369: 
1:eac0369: 	TransactionTableEntry(
1:eac0369:     Xact            xact, 
1:eac0369:     TransactionId   tid, 
1:eac0369:     int             status, 
1:eac0369:     int             attribute)
1:eac0369: 	{
1:eac0369: 		myxact              = xact;
1:eac0369: 		xid                 = tid;
1:eac0369: 		transactionStatus   = status;
1:eac0369: 
1:eac0369: 		update              = (attribute & UPDATE)   != 0;
1:eac0369: 		needExclusion       = (attribute & EXCLUDE)  != 0;
1:eac0369: 		recovery            = (attribute & RECOVERY) != 0;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(tid != null, "tid is null");
1:eac0369: 			if (update && xact.getFirstLogInstant() == null)
1:eac0369:             {
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369:                     "update transaction has firstLog = null");
1:eac0369:             }
1:eac0369: 
1:eac0369: 
1:eac0369:             /*
1:eac0369: 			if (!update && xact.getFirstLogInstant() != null)
1:eac0369:             {
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369:                     "read only transaction has firstLog = " + 
1:eac0369:                     xact.getFirstLogInstant());
1:eac0369:             }
1:eac0369:             */
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Normally, we don't need to remember the gid, firstLog and lastLog
1:eac0369: 		// because myxact will have the same information.  However, in
1:eac0369: 		// recovery, there is only one transaction taking on different identity
1:eac0369: 		// as the log is replayed.  Then each transaction table entry has keep
1:eac0369: 		// its own identity and not rely on myxact.  These recovery
1:eac0369: 		// transactions are materialized in the transaction table via a
1:eac0369: 		// readObject in the checkpoint log record, or are added by
1:eac0369: 		// addUpdateTransaction when the log is scanned.
1:eac0369: 		if (recovery)
1:eac0369: 		{
1:eac0369: 			// make a copy of everything
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(update, "recovery but not update");
1:eac0369: 
1:eac0369: 				if (tid != xact.getId())
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "adding a update transaction during recovery " + 
1:eac0369:                         " but the tids doesn't match" +
1:eac0369:                         tid + " " + xact.getId());
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			gid         = xact.getGlobalId();
1:eac0369: 			firstLog    = xact.getFirstLogInstant();
1:eac0369: 			lastLog     = xact.getLastLogInstant();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Formatable methods
1:eac0369: 	 */
1:eac0369: 	public TransactionTableEntry()
1:eac0369: 	{ }
1:eac0369: 
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(!recovery, "writing out a recovery transaction");
1:eac0369: 			SanityManager.ASSERT(update, "writing out read only transaction");
1:eac0369: 			SanityManager.ASSERT(myxact.getFirstLogInstant() != null, 
1:eac0369: 								 "myxact.getFirstLogInstant is null");
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot write out a clone");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Why is is safe to access first and last log instant in myxact while
1:eac0369: 		// this is happening?  Because we only writes out update transaction
1:eac0369: 		// during run time.  When a read only transactions becomes an update
1:eac0369: 		// transaction , or when an update transaction commits, the beginXact
1:eac0369: 		// and endXact log record's doMe method will try to change the
1:eac0369: 		// transaction table entry's state to updat and non-update
1:eac0369: 		// respectively.  That change needs to go thru the transaction table
1:eac0369: 		// which is mutually exclusive to writing out the transaction table.
1:eac0369: 		// Since we are only looking at update transactions and it is "stuck"
1:eac0369: 		// in update state in the middle of a TransactionTable.writeExternal
1:eac0369: 		// call, all the fields we access in myxact is stable (actually the xid
1:eac0369: 		// is also stable but we already have it).
1:eac0369: 		//
1:eac0369: 		out.writeObject(xid);
1:eac0369: 		out.writeObject(myxact.getGlobalId());
1:eac0369: 		out.writeObject(myxact.getFirstLogInstant());
1:eac0369: 		out.writeObject(myxact.getLastLogInstant());
1:eac0369: 		out.writeInt(transactionStatus);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void readExternal(ObjectInput in) 
1:eac0369: 		 throws ClassNotFoundException, IOException
1:eac0369: 	{
1:eac0369: 		// the only time a transaction table entry is written out is to the
1:eac0369: 		// log, so this must be read in during recovery.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot write out a clone");
1:eac0369: 
1:eac0369: 		xid = (TransactionId)in.readObject();
1:eac0369: 		gid = (GlobalTransactionId)in.readObject();
1:eac0369: 		firstLog = (LogInstant)in.readObject();
1:eac0369: 		lastLog = (LogInstant)in.readObject();
1:eac0369: 		transactionStatus = in.readInt();
1:eac0369: 		update = true;
1:eac0369: 		recovery = true;
1:eac0369: 		needExclusion = true;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(xid != null, "read in transaction table entry with null id");
1:eac0369: 			SanityManager.ASSERT(firstLog != null, "read in transaction table entry with firstLog");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// set my transaction instance variable for a recovery transaction
1:eac0369: 	void setXact(Xact xact)
1:eac0369: 	{
1:eac0369:         /*
1:eac0369:         RESOLVE (mikem) - prepared transactions now call setXact() when they are
1:eac0369:         not in recovery.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(recovery, 
1:eac0369: 								 "setting non-recovery transaction table entry xact");
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot setXact with a clone");
1:eac0369: 		}
1:eac0369:         */
1:eac0369: 		myxact = xact;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			StringBuffer str = new StringBuffer(500).
1:eac0369: 				append("Xid=").append(getXid()).
1:eac0369: 				append(" gid=").append(getGid()).
1:eac0369: 				append(" firstLog=").append(getFirstLog()).
1:eac0369: 				append(" lastLog=").append(getLastLog()).
1:eac0369: 				append(" transactionStatus=").append(transactionStatus).
1:eac0369: 				append(" myxact=").append(myxact).
1:eac0369: 				append(" update=").append(update).
1:eac0369: 				append(" recovery=").append(recovery).
1:eac0369: 				append(" prepare=").append(isPrepared()).
1:eac0369: 				append(" needExclusion=").append(needExclusion).
1:eac0369: 				append("\n");
1:eac0369: 			return str.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void updateTransactionStatus(Xact xact, int status, int attribute)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(myxact == xact,
1:eac0369: 				"update transaction status for wrong xact");
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.update = (attribute & UPDATE) != 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void removeUpdateTransaction()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1:eac0369: 
1:eac0369: 		this.update = false;
1:eac0369: 		transactionStatus = 0;
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void unsetRecoveryStatus()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - this is kind of ugly. move to a better place?
1:eac0369: 
1:eac0369:         firstLog = null;
1:eac0369: 
1:eac0369: 		this.recovery = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void prepareTransaction()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1:eac0369: 
1:eac0369: 		transactionStatus |= Xact.END_PREPARED;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * get instance variables
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	TransactionId getXid()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(xid != null, "TTE with null xid");
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return xid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final GlobalTransactionId getGid()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		if (gid != null)
1:eac0369: 			return gid;
1:eac0369: 
1:eac0369: 		if (myxact != null)
1:eac0369: 			return myxact.getGlobalId();
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	LogInstant getFirstLog()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 			if (recovery)
1:eac0369:             {
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     firstLog != null, 
1:eac0369:                     "a recovery transaction with a null firstLog");
1:eac0369:             }
1:eac0369: 			else
1:eac0369:             {
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     firstLog == null, 
1:eac0369:                     "a normal transaction with a non-null firstLog" +
1:eac0369:                     "myxact.getFirstLogInstant() = " + myxact.getFirstLogInstant());
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (firstLog != null)
1:eac0369: 			return firstLog;
1:eac0369: 
1:eac0369: 		if (myxact != null)
1:eac0369: 			return myxact.getFirstLogInstant();
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	LogInstant getLastLog()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		if (lastLog != null)
1:eac0369: 			return lastLog;
1:eac0369: 
1:eac0369: 		if (myxact != null)
1:eac0369: 			return myxact.getLastLogInstant();
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final Xact getXact()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		return myxact;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	int getTransactionStatus()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		return transactionStatus;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	boolean isUpdate()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		return update;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	boolean isRecovery()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		return recovery;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	boolean isPrepared()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		return((transactionStatus & Xact.END_PREPARED) != 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	public boolean needExclusion()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1:eac0369: 
1:eac0369: 		return needExclusion;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Methods of TransactionInfo
1:eac0369: 	 */
1:eac0369: 	public String getTransactionIdString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 !recovery, "trying to display recovery transaction");
1:eac0369: 			SanityManager.ASSERT(myxact != null, "my xact is null");
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		TransactionId t = myxact.getIdNoCheck();
1:eac0369: 		return (t == null) ? "CLOSED" : t.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getGlobalTransactionIdString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 !recovery, "trying to display recovery transaction");
1:eac0369: 			SanityManager.ASSERT(myxact != null, "my xact is null");
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		GlobalTransactionId gid = myxact.getGlobalId();
1:eac0369: 		return (gid == null) ? null : gid.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getUsernameString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 
1:eac0369: 		getlcc();
1:9f60172:         return (lcc == null) ? null : lcc.getSessionUserId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getTransactionTypeString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 
1:eac0369:         if (myxact == null)
1:eac0369:             return null;
1:eac0369:         else if (myxact.getTransName() != null)
1:eac0369:             return myxact.getTransName();
1:eac0369:         else
1:eac0369:             return myxact.getContextId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getTransactionStatusString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 
1:eac0369: 		return (myxact == null) ? null : myxact.getState();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getStatementTextString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 
1:eac0369: 		getlcc();
1:eac0369: 		if (lcc != null)
1:eac0369: 		{
1:eac0369: 			StatementContext sc = lcc.getStatementContext();
1:eac0369: 			if (sc != null)
1:eac0369: 				return sc.getStatementText() ;
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getFirstLogInstantString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 
1:eac0369: 		LogInstant logInstant = 
1:eac0369:             (myxact == null) ? null : myxact.getFirstLogInstant();
1:eac0369: 
1:eac0369: 		return (logInstant == null) ? null : logInstant.toString();
1:eac0369: 
1:eac0369: 	}		
1:eac0369: 
1:eac0369: 	private void getlcc()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1:eac0369: 
1:eac0369: 		if (lcc == null && myxact != null && myxact.xc != null)
1:eac0369: 		{
1:eac0369: 			XactContext xc = myxact.xc;
1:eac0369: 
1:eac0369: 			lcc = (LanguageConnectionContext)
1:eac0369: 				xc.getContextManager().getContext(
1:eac0369:                     LanguageConnectionContext.CONTEXT_ID);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Cloneable
1:eac0369: 	 */
1:eac0369: 	protected Object clone()
1:eac0369: 	{
1:eac0369: 		try 
1:eac0369: 		{
1:eac0369: 			Object c = super.clone();
1:eac0369: 			((TransactionTableEntry)c).isClone = true;
1:eac0369: 
1:eac0369: 			return c;
1:eac0369: 		}
1:eac0369: 		catch (CloneNotSupportedException e) 
1:eac0369: 		{
1:eac0369: 			// this should not happen, we are cloneable
1:eac0369: 			if (SanityManager.DEBUG) 
1:eac0369:             {
1:eac0369: 				SanityManager.THROWASSERT(
1:e7d2a42:                     "TransactionTableEntry cloneable but throws " +
1:e7d2a42: 					"CloneNotSupportedException", e);
1:eac0369: 			}
1:eac0369: 			return null;
1:eac0369: 		}				
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 	Transaction table entry is used to store all relevant information of a
commit:e7d2a42
/////////////////////////////////////////////////////////////////////////
1:                     "TransactionTableEntry cloneable but throws " +
1: 					"CloneNotSupportedException", e);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:         return (lcc == null) ? null : lcc.getSessionUserId();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.xact.TransactionTableEntry
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.xact;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: import org.apache.derby.iapi.store.access.TransactionInfo;
1: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: /**
0: 	Transaction table entry is used to store all relavent information of a
1: 	transaction into the transaction table for the use of checkpoint, recovery,
1: 	Transaction management during Quiesce state, and for dumping transaction table.  Only works
1: 	with the following classes: TransactionTable, XactFactory, Xact
1: 	<BR>
1: 	During run time, whenever any transaction is started, it is put into the
1: 	transaction table.  Whenever any transaction is closed, it is removed from
1: 	the transaction table.
1: 
1: 
1: */
1: 
1: public class TransactionTableEntry implements Formatable, TransactionInfo, Cloneable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	// These fields are only populated if this TTE has been read in from the
1: 	// log.  Otherwise, they are gotten from the transaction object myxact.
1: 	private TransactionId           xid;
1: 	private GlobalTransactionId     gid;
1: 	private LogInstant              firstLog;
1: 	private LogInstant              lastLog;
1: 
1: 	// this field is always present - it is 0 for read only transaction, this
1:     // is a copy of the status from the Xact (the copy is necessary as during
1:     // recovery the Xact is shared by all transaction table entries during
1:     // redo and undo).
1: 	private int                     transactionStatus;
1: 
1: 	// fields useful for returning transaction information if read from 
1:     // transaction log during recovery
1: 	private transient Xact    myxact; 
1: 	private transient boolean update;
1: 	private transient boolean recovery;         // is this a transaction read 
1:                                                 // from the log during recovery?
1: 	private transient boolean needExclusion;    // in a quiesce state , this 
1:                                                 // transaction needs to be 
1:                                                 // barred from activation 
1:                                                 // during quiesce state
1: 
1: 	private boolean isClone;		            // am I a clone made for the 
1:                                                 // TransactionVTI?
1: 
1: 	private transient LanguageConnectionContext lcc;
1: 
1: 
1: 	/* package */
1: 	// entry attribute
1: 	static final int UPDATE		= 0x1;
1: 	static final int RECOVERY	= 0x2;
1: 	static final int EXCLUDE	= 0x4;
1: 
1: 	TransactionTableEntry(
1:     Xact            xact, 
1:     TransactionId   tid, 
1:     int             status, 
1:     int             attribute)
1: 	{
1: 		myxact              = xact;
1: 		xid                 = tid;
1: 		transactionStatus   = status;
1: 
1: 		update              = (attribute & UPDATE)   != 0;
1: 		needExclusion       = (attribute & EXCLUDE)  != 0;
1: 		recovery            = (attribute & RECOVERY) != 0;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(tid != null, "tid is null");
1: 			if (update && xact.getFirstLogInstant() == null)
1:             {
1: 				SanityManager.THROWASSERT(
1:                     "update transaction has firstLog = null");
1:             }
1: 
1: 
1:             /*
1: 			if (!update && xact.getFirstLogInstant() != null)
1:             {
1: 				SanityManager.THROWASSERT(
1:                     "read only transaction has firstLog = " + 
1:                     xact.getFirstLogInstant());
1:             }
1:             */
1: 		}
1: 
1: 		// Normally, we don't need to remember the gid, firstLog and lastLog
1: 		// because myxact will have the same information.  However, in
1: 		// recovery, there is only one transaction taking on different identity
1: 		// as the log is replayed.  Then each transaction table entry has keep
1: 		// its own identity and not rely on myxact.  These recovery
1: 		// transactions are materialized in the transaction table via a
1: 		// readObject in the checkpoint log record, or are added by
1: 		// addUpdateTransaction when the log is scanned.
1: 		if (recovery)
1: 		{
1: 			// make a copy of everything
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(update, "recovery but not update");
1: 
1: 				if (tid != xact.getId())
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "adding a update transaction during recovery " + 
1:                         " but the tids doesn't match" +
1:                         tid + " " + xact.getId());
1:                 }
1: 			}
1: 
1: 			gid         = xact.getGlobalId();
1: 			firstLog    = xact.getFirstLogInstant();
1: 			lastLog     = xact.getLastLogInstant();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Formatable methods
1: 	 */
1: 	public TransactionTableEntry()
1: 	{ }
1: 
1: 	public void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(!recovery, "writing out a recovery transaction");
1: 			SanityManager.ASSERT(update, "writing out read only transaction");
1: 			SanityManager.ASSERT(myxact.getFirstLogInstant() != null, 
1: 								 "myxact.getFirstLogInstant is null");
1: 			SanityManager.ASSERT(!isClone, "cannot write out a clone");
1: 		}
1: 
1: 		// Why is is safe to access first and last log instant in myxact while
1: 		// this is happening?  Because we only writes out update transaction
1: 		// during run time.  When a read only transactions becomes an update
1: 		// transaction , or when an update transaction commits, the beginXact
1: 		// and endXact log record's doMe method will try to change the
1: 		// transaction table entry's state to updat and non-update
1: 		// respectively.  That change needs to go thru the transaction table
1: 		// which is mutually exclusive to writing out the transaction table.
1: 		// Since we are only looking at update transactions and it is "stuck"
1: 		// in update state in the middle of a TransactionTable.writeExternal
1: 		// call, all the fields we access in myxact is stable (actually the xid
1: 		// is also stable but we already have it).
1: 		//
1: 		out.writeObject(xid);
1: 		out.writeObject(myxact.getGlobalId());
1: 		out.writeObject(myxact.getFirstLogInstant());
1: 		out.writeObject(myxact.getLastLogInstant());
1: 		out.writeInt(transactionStatus);
1: 	}
1: 
1: 	public void readExternal(ObjectInput in) 
1: 		 throws ClassNotFoundException, IOException
1: 	{
1: 		// the only time a transaction table entry is written out is to the
1: 		// log, so this must be read in during recovery.
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot write out a clone");
1: 
1: 		xid = (TransactionId)in.readObject();
1: 		gid = (GlobalTransactionId)in.readObject();
1: 		firstLog = (LogInstant)in.readObject();
1: 		lastLog = (LogInstant)in.readObject();
1: 		transactionStatus = in.readInt();
1: 		update = true;
1: 		recovery = true;
1: 		needExclusion = true;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(xid != null, "read in transaction table entry with null id");
1: 			SanityManager.ASSERT(firstLog != null, "read in transaction table entry with firstLog");
1: 		}
1: 
1: 	}
1: 
1: 
1: 	// set my transaction instance variable for a recovery transaction
1: 	void setXact(Xact xact)
1: 	{
1:         /*
1:         RESOLVE (mikem) - prepared transactions now call setXact() when they are
1:         not in recovery.
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(recovery, 
1: 								 "setting non-recovery transaction table entry xact");
1: 			SanityManager.ASSERT(!isClone, "cannot setXact with a clone");
1: 		}
1:         */
1: 		myxact = xact;
1: 
1: 	}
1: 
1: 	/**
1: 		Return my format identifier.
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			StringBuffer str = new StringBuffer(500).
1: 				append("Xid=").append(getXid()).
1: 				append(" gid=").append(getGid()).
1: 				append(" firstLog=").append(getFirstLog()).
1: 				append(" lastLog=").append(getLastLog()).
1: 				append(" transactionStatus=").append(transactionStatus).
1: 				append(" myxact=").append(myxact).
1: 				append(" update=").append(update).
1: 				append(" recovery=").append(recovery).
1: 				append(" prepare=").append(isPrepared()).
1: 				append(" needExclusion=").append(needExclusion).
1: 				append("\n");
1: 			return str.toString();
1: 		}
1: 		else
1: 			return null;
1: 	}
1: 
1: 	void updateTransactionStatus(Xact xact, int status, int attribute)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(myxact == xact,
1: 				"update transaction status for wrong xact");
1: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1: 		}
1: 
1: 		this.update = (attribute & UPDATE) != 0;
1: 	}
1: 
1: 	void removeUpdateTransaction()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1: 
1: 		this.update = false;
1: 		transactionStatus = 0;
1: 		
1: 	}
1: 
1: 	void unsetRecoveryStatus()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1: 
1:         // RESOLVE (mikem) - this is kind of ugly. move to a better place?
1: 
1:         firstLog = null;
1: 
1: 		this.recovery = false;
1: 	}
1: 
1: 	void prepareTransaction()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
1: 
1: 		transactionStatus |= Xact.END_PREPARED;
1: 	}
1: 
1:     /**************************************************************************
1:      * get instance variables
1:      **************************************************************************
1:      */
1: 
1: 	TransactionId getXid()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(xid != null, "TTE with null xid");
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 		}
1: 
1: 		return xid;
1: 	}
1: 
1: 	public final GlobalTransactionId getGid()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		if (gid != null)
1: 			return gid;
1: 
1: 		if (myxact != null)
1: 			return myxact.getGlobalId();
1: 
1: 		return null;
1: 	}
1: 
1: 	LogInstant getFirstLog()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 			if (recovery)
1:             {
1: 				SanityManager.ASSERT(
1:                     firstLog != null, 
1:                     "a recovery transaction with a null firstLog");
1:             }
1: 			else
1:             {
1: 				SanityManager.ASSERT(
1:                     firstLog == null, 
1:                     "a normal transaction with a non-null firstLog" +
1:                     "myxact.getFirstLogInstant() = " + myxact.getFirstLogInstant());
1:             }
1: 		}
1: 
1: 		if (firstLog != null)
1: 			return firstLog;
1: 
1: 		if (myxact != null)
1: 			return myxact.getFirstLogInstant();
1: 
1: 		return null;
1: 	}
1: 
1: 	LogInstant getLastLog()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		if (lastLog != null)
1: 			return lastLog;
1: 
1: 		if (myxact != null)
1: 			return myxact.getLastLogInstant();
1: 
1: 		return null;
1: 	}
1: 
1: 	public final Xact getXact()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		return myxact;
1: 	}
1: 
1: 	int getTransactionStatus()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		return transactionStatus;
1: 	}
1: 
1: 	boolean isUpdate()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		return update;
1: 	}
1: 
1: 	boolean isRecovery()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		return recovery;
1: 	}
1: 
1: 	boolean isPrepared()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		return((transactionStatus & Xact.END_PREPARED) != 0);
1: 	}
1: 
1: 
1: 
1: 
1: 	public boolean needExclusion()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
1: 
1: 		return needExclusion;
1: 	}
1: 
1: 	/**
1: 		Methods of TransactionInfo
1: 	 */
1: 	public String getTransactionIdString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(
1:                 !recovery, "trying to display recovery transaction");
1: 			SanityManager.ASSERT(myxact != null, "my xact is null");
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 		}
1: 
1: 		TransactionId t = myxact.getIdNoCheck();
1: 		return (t == null) ? "CLOSED" : t.toString();
1: 	}
1: 
1: 	public String getGlobalTransactionIdString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(
1:                 !recovery, "trying to display recovery transaction");
1: 			SanityManager.ASSERT(myxact != null, "my xact is null");
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 		}
1: 
1: 		GlobalTransactionId gid = myxact.getGlobalId();
1: 		return (gid == null) ? null : gid.toString();
1: 	}
1: 
1: 	public String getUsernameString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 
1: 		getlcc();
0: 		return (lcc == null) ? null : lcc.getAuthorizationId();
1: 	}
1: 
1: 	public String getTransactionTypeString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 
1:         if (myxact == null)
1:             return null;
1:         else if (myxact.getTransName() != null)
1:             return myxact.getTransName();
1:         else
1:             return myxact.getContextId();
1: 	}
1: 
1: 	public String getTransactionStatusString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 
1: 		return (myxact == null) ? null : myxact.getState();
1: 	}
1: 
1: 	public String getStatementTextString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 
1: 		getlcc();
1: 		if (lcc != null)
1: 		{
1: 			StatementContext sc = lcc.getStatementContext();
1: 			if (sc != null)
1: 				return sc.getStatementText() ;
1: 		}
1: 		return null;
1: 
1: 	}
1: 
1: 	public String getFirstLogInstantString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 
1: 		LogInstant logInstant = 
1:             (myxact == null) ? null : myxact.getFirstLogInstant();
1: 
1: 		return (logInstant == null) ? null : logInstant.toString();
1: 
1: 	}		
1: 
1: 	private void getlcc()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
1: 
1: 		if (lcc == null && myxact != null && myxact.xc != null)
1: 		{
1: 			XactContext xc = myxact.xc;
1: 
1: 			lcc = (LanguageConnectionContext)
1: 				xc.getContextManager().getContext(
1:                     LanguageConnectionContext.CONTEXT_ID);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Cloneable
1: 	 */
1: 	protected Object clone()
1: 	{
1: 		try 
1: 		{
1: 			Object c = super.clone();
1: 			((TransactionTableEntry)c).isClone = true;
1: 
1: 			return c;
1: 		}
1: 		catch (CloneNotSupportedException e) 
1: 		{
1: 			// this should not happen, we are cloneable
1: 			if (SanityManager.DEBUG) 
1:             {
1: 				SanityManager.THROWASSERT(
0:                     "TransactionTableEntry cloneable but throws CloneNotSupportedException " + e);
1: 			}
1: 			return null;
1: 		}				
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.xact;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: import org.apache.derby.iapi.store.access.TransactionInfo;
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
0: import org.apache.derby.iapi.store.raw.xact.TransactionId;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: /**
0: 	Transaction table entry is used to store all relavent information of a
0: 	transaction into the transaction table for the use of checkpoint, recovery,
0: 	Transaction management during Quiesce state, and for dumping transaction table.  Only works
0: 	with the following classes: TransactionTable, XactFactory, Xact
0: 	<BR>
0: 	During run time, whenever any transaction is started, it is put into the
0: 	transaction table.  Whenever any transaction is closed, it is removed from
0: 	the transaction table.
0: 
0: 
0: */
0: 
0: public class TransactionTableEntry implements Formatable, TransactionInfo, Cloneable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	// These fields are only populated if this TTE has been read in from the
0: 	// log.  Otherwise, they are gotten from the transaction object myxact.
0: 	private TransactionId           xid;
0: 	private GlobalTransactionId     gid;
0: 	private LogInstant              firstLog;
0: 	private LogInstant              lastLog;
0: 
0: 	// this field is always present - it is 0 for read only transaction, this
0:     // is a copy of the status from the Xact (the copy is necessary as during
0:     // recovery the Xact is shared by all transaction table entries during
0:     // redo and undo).
0: 	private int                     transactionStatus;
0: 
0: 	// fields useful for returning transaction information if read from 
0:     // transaction log during recovery
0: 	private transient Xact    myxact; 
0: 	private transient boolean update;
0: 	private transient boolean recovery;         // is this a transaction read 
0:                                                 // from the log during recovery?
0: 	private transient boolean needExclusion;    // in a quiesce state , this 
0:                                                 // transaction needs to be 
0:                                                 // barred from activation 
0:                                                 // during quiesce state
0: 
0: 	private boolean isClone;		            // am I a clone made for the 
0:                                                 // TransactionVTI?
0: 
0: 	private transient LanguageConnectionContext lcc;
0: 
0: 
0: 	/* package */
0: 	// entry attribute
0: 	static final int UPDATE		= 0x1;
0: 	static final int RECOVERY	= 0x2;
0: 	static final int EXCLUDE	= 0x4;
0: 
0: 	TransactionTableEntry(
0:     Xact            xact, 
0:     TransactionId   tid, 
0:     int             status, 
0:     int             attribute)
0: 	{
0: 		myxact              = xact;
0: 		xid                 = tid;
0: 		transactionStatus   = status;
0: 
0: 		update              = (attribute & UPDATE)   != 0;
0: 		needExclusion       = (attribute & EXCLUDE)  != 0;
0: 		recovery            = (attribute & RECOVERY) != 0;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(tid != null, "tid is null");
0: 			if (update && xact.getFirstLogInstant() == null)
0:             {
0: 				SanityManager.THROWASSERT(
0:                     "update transaction has firstLog = null");
0:             }
0: 
0: 
0:             /*
0: 			if (!update && xact.getFirstLogInstant() != null)
0:             {
0: 				SanityManager.THROWASSERT(
0:                     "read only transaction has firstLog = " + 
0:                     xact.getFirstLogInstant());
0:             }
0:             */
0: 		}
0: 
0: 		// Normally, we don't need to remember the gid, firstLog and lastLog
0: 		// because myxact will have the same information.  However, in
0: 		// recovery, there is only one transaction taking on different identity
0: 		// as the log is replayed.  Then each transaction table entry has keep
0: 		// its own identity and not rely on myxact.  These recovery
0: 		// transactions are materialized in the transaction table via a
0: 		// readObject in the checkpoint log record, or are added by
0: 		// addUpdateTransaction when the log is scanned.
0: 		if (recovery)
0: 		{
0: 			// make a copy of everything
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(update, "recovery but not update");
0: 
0: 				if (tid != xact.getId())
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "adding a update transaction during recovery " + 
0:                         " but the tids doesn't match" +
0:                         tid + " " + xact.getId());
0:                 }
0: 			}
0: 
0: 			gid         = xact.getGlobalId();
0: 			firstLog    = xact.getFirstLogInstant();
0: 			lastLog     = xact.getLastLogInstant();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Formatable methods
0: 	 */
0: 	public TransactionTableEntry()
0: 	{ }
0: 
0: 	public void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!recovery, "writing out a recovery transaction");
0: 			SanityManager.ASSERT(update, "writing out read only transaction");
0: 			SanityManager.ASSERT(myxact.getFirstLogInstant() != null, 
0: 								 "myxact.getFirstLogInstant is null");
0: 			SanityManager.ASSERT(!isClone, "cannot write out a clone");
0: 		}
0: 
0: 		// Why is is safe to access first and last log instant in myxact while
0: 		// this is happening?  Because we only writes out update transaction
0: 		// during run time.  When a read only transactions becomes an update
0: 		// transaction , or when an update transaction commits, the beginXact
0: 		// and endXact log record's doMe method will try to change the
0: 		// transaction table entry's state to updat and non-update
0: 		// respectively.  That change needs to go thru the transaction table
0: 		// which is mutually exclusive to writing out the transaction table.
0: 		// Since we are only looking at update transactions and it is "stuck"
0: 		// in update state in the middle of a TransactionTable.writeExternal
0: 		// call, all the fields we access in myxact is stable (actually the xid
0: 		// is also stable but we already have it).
0: 		//
0: 		out.writeObject(xid);
0: 		out.writeObject(myxact.getGlobalId());
0: 		out.writeObject(myxact.getFirstLogInstant());
0: 		out.writeObject(myxact.getLastLogInstant());
0: 		out.writeInt(transactionStatus);
0: 	}
0: 
0: 	public void readExternal(ObjectInput in) 
0: 		 throws ClassNotFoundException, IOException
0: 	{
0: 		// the only time a transaction table entry is written out is to the
0: 		// log, so this must be read in during recovery.
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot write out a clone");
0: 
0: 		xid = (TransactionId)in.readObject();
0: 		gid = (GlobalTransactionId)in.readObject();
0: 		firstLog = (LogInstant)in.readObject();
0: 		lastLog = (LogInstant)in.readObject();
0: 		transactionStatus = in.readInt();
0: 		update = true;
0: 		recovery = true;
0: 		needExclusion = true;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(xid != null, "read in transaction table entry with null id");
0: 			SanityManager.ASSERT(firstLog != null, "read in transaction table entry with firstLog");
0: 		}
0: 
0: 	}
0: 
0: 
0: 	// set my transaction instance variable for a recovery transaction
0: 	void setXact(Xact xact)
0: 	{
0:         /*
0:         RESOLVE (mikem) - prepared transactions now call setXact() when they are
0:         not in recovery.
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(recovery, 
0: 								 "setting non-recovery transaction table entry xact");
0: 			SanityManager.ASSERT(!isClone, "cannot setXact with a clone");
0: 		}
0:         */
0: 		myxact = xact;
0: 
0: 	}
0: 
0: 	/**
0: 		Return my format identifier.
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer str = new StringBuffer(500).
0: 				append("Xid=").append(getXid()).
0: 				append(" gid=").append(getGid()).
0: 				append(" firstLog=").append(getFirstLog()).
0: 				append(" lastLog=").append(getLastLog()).
0: 				append(" transactionStatus=").append(transactionStatus).
0: 				append(" myxact=").append(myxact).
0: 				append(" update=").append(update).
0: 				append(" recovery=").append(recovery).
0: 				append(" prepare=").append(isPrepared()).
0: 				append(" needExclusion=").append(needExclusion).
0: 				append("\n");
0: 			return str.toString();
0: 		}
0: 		else
0: 			return null;
0: 	}
0: 
0: 	void updateTransactionStatus(Xact xact, int status, int attribute)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(myxact == xact,
0: 				"update transaction status for wrong xact");
0: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
0: 		}
0: 
0: 		this.update = (attribute & UPDATE) != 0;
0: 	}
0: 
0: 	void removeUpdateTransaction()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
0: 
0: 		this.update = false;
0: 		transactionStatus = 0;
0: 		
0: 	}
0: 
0: 	void unsetRecoveryStatus()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
0: 
0:         // RESOLVE (mikem) - this is kind of ugly. move to a better place?
0: 
0:         firstLog = null;
0: 
0: 		this.recovery = false;
0: 	}
0: 
0: 	void prepareTransaction()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot change a clone");
0: 
0: 		transactionStatus |= Xact.END_PREPARED;
0: 	}
0: 
0:     /**************************************************************************
0:      * get instance variables
0:      **************************************************************************
0:      */
0: 
0: 	TransactionId getXid()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(xid != null, "TTE with null xid");
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 		}
0: 
0: 		return xid;
0: 	}
0: 
0: 	public final GlobalTransactionId getGid()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		if (gid != null)
0: 			return gid;
0: 
0: 		if (myxact != null)
0: 			return myxact.getGlobalId();
0: 
0: 		return null;
0: 	}
0: 
0: 	LogInstant getFirstLog()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 			if (recovery)
0:             {
0: 				SanityManager.ASSERT(
0:                     firstLog != null, 
0:                     "a recovery transaction with a null firstLog");
0:             }
0: 			else
0:             {
0: 				SanityManager.ASSERT(
0:                     firstLog == null, 
0:                     "a normal transaction with a non-null firstLog" +
0:                     "myxact.getFirstLogInstant() = " + myxact.getFirstLogInstant());
0:             }
0: 		}
0: 
0: 		if (firstLog != null)
0: 			return firstLog;
0: 
0: 		if (myxact != null)
0: 			return myxact.getFirstLogInstant();
0: 
0: 		return null;
0: 	}
0: 
0: 	LogInstant getLastLog()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		if (lastLog != null)
0: 			return lastLog;
0: 
0: 		if (myxact != null)
0: 			return myxact.getLastLogInstant();
0: 
0: 		return null;
0: 	}
0: 
0: 	public final Xact getXact()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		return myxact;
0: 	}
0: 
0: 	int getTransactionStatus()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		return transactionStatus;
0: 	}
0: 
0: 	boolean isUpdate()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		return update;
0: 	}
0: 
0: 	boolean isRecovery()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		return recovery;
0: 	}
0: 
0: 	boolean isPrepared()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		return((transactionStatus & Xact.END_PREPARED) != 0);
0: 	}
0: 
0: 
0: 
0: 
0: 	public boolean needExclusion()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isClone, "cannot call method with a clone");
0: 
0: 		return needExclusion;
0: 	}
0: 
0: 	/**
0: 		Methods of TransactionInfo
0: 	 */
0: 	public String getTransactionIdString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(
0:                 !recovery, "trying to display recovery transaction");
0: 			SanityManager.ASSERT(myxact != null, "my xact is null");
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 		}
0: 
0: 		TransactionId t = myxact.getIdNoCheck();
0: 		return (t == null) ? "CLOSED" : t.toString();
0: 	}
0: 
0: 	public String getGlobalTransactionIdString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(
0:                 !recovery, "trying to display recovery transaction");
0: 			SanityManager.ASSERT(myxact != null, "my xact is null");
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 		}
0: 
0: 		GlobalTransactionId gid = myxact.getGlobalId();
0: 		return (gid == null) ? null : gid.toString();
0: 	}
0: 
0: 	public String getUsernameString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 
0: 		getlcc();
0: 		return (lcc == null) ? null : lcc.getAuthorizationId();
0: 	}
0: 
0: 	public String getTransactionTypeString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 
0:         if (myxact == null)
0:             return null;
0:         else if (myxact.getTransName() != null)
0:             return myxact.getTransName();
0:         else
0:             return myxact.getContextId();
0: 	}
0: 
0: 	public String getTransactionStatusString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 
0: 		return (myxact == null) ? null : myxact.getState();
0: 	}
0: 
0: 	public String getStatementTextString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 
0: 		getlcc();
0: 		if (lcc != null)
0: 		{
0: 			StatementContext sc = lcc.getStatementContext();
0: 			if (sc != null)
0: 				return sc.getStatementText() ;
0: 		}
0: 		return null;
0: 
0: 	}
0: 
0: 	public String getFirstLogInstantString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 
0: 		LogInstant logInstant = 
0:             (myxact == null) ? null : myxact.getFirstLogInstant();
0: 
0: 		return (logInstant == null) ? null : logInstant.toString();
0: 
0: 	}		
0: 
0: 	private void getlcc()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isClone, "Should only call method on a clone");
0: 
0: 		if (lcc == null && myxact != null && myxact.xc != null)
0: 		{
0: 			XactContext xc = myxact.xc;
0: 
0: 			lcc = (LanguageConnectionContext)
0: 				xc.getContextManager().getContext(
0:                     LanguageConnectionContext.CONTEXT_ID);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Cloneable
0: 	 */
0: 	protected Object clone()
0: 	{
0: 		try 
0: 		{
0: 			Object c = super.clone();
0: 			((TransactionTableEntry)c).isClone = true;
0: 
0: 			return c;
0: 		}
0: 		catch (CloneNotSupportedException e) 
0: 		{
0: 			// this should not happen, we are cloneable
0: 			if (SanityManager.DEBUG) 
0:             {
0: 				SanityManager.THROWASSERT(
0:                     "TransactionTableEntry cloneable but throws CloneNotSupportedException " + e);
0: 			}
0: 			return null;
0: 		}				
0: 	}
0: }
============================================================================